public function run ( ) { $ menu = Menu :: where ( 'name' , 'admin' ) -> firstOrFail ( ) ; $ menuItem = MenuItem :: firstOrNew ( [ 'menu_id' => $ menu -> id , 'title' => __ ( 'voyager::seeders.menu_items.dashboard' ) , 'url' => '' , 'route' => 'voyager.dashboard' , ] ) ; if ( ! $ menuItem -> exists ) { $ menuItem -> fill ( [ 'target' => '_self' , 'icon_class' => 'voyager-boat' , 'color' => null , 'parent_id' => null , 'order' => 1 , ] ) -> save ( ) ; } $ menuItem = MenuItem :: firstOrNew ( [ 'menu_id' => $ menu -> id , 'title' => __ ( 'voyager::seeders.menu_items.media' ) , 'url' => '' , 'route' => 'voyager.media.index' , ] ) ; if ( ! $ menuItem -> exists ) { $ menuItem -> fill ( [ 'target' => '_self' , 'icon_class' => 'voyager-images' , 'color' => null , 'parent_id' => null , 'order' => 5 , ] ) -> save ( ) ; } $ menuItem = MenuItem :: firstOrNew ( [ 'menu_id' => $ menu -> id , 'title' => __ ( 'voyager::seeders.menu_items.users' ) , 'url' => '' , 'route' => 'voyager.users.index' , ] ) ; if ( ! $ menuItem -> exists ) { $ menuItem -> fill ( [ 'target' => '_self' , 'icon_class' => 'voyager-person' , 'color' => null , 'parent_id' => null , 'order' => 3 , ] ) -> save ( ) ; } $ menuItem = MenuItem :: firstOrNew ( [ 'menu_id' => $ menu -> id , 'title' => __ ( 'voyager::seeders.menu_items.roles' ) , 'url' => '' , 'route' => 'voyager.roles.index' , ] ) ; if ( ! $ menuItem -> exists ) { $ menuItem -> fill ( [ 'target' => '_self' , 'icon_class' => 'voyager-lock' , 'color' => null , 'parent_id' => null , 'order' => 2 , ] ) -> save ( ) ; } $ toolsMenuItem = MenuItem :: firstOrNew ( [ 'menu_id' => $ menu -> id , 'title' => __ ( 'voyager::seeders.menu_items.tools' ) , 'url' => '' , ] ) ; if ( ! $ toolsMenuItem -> exists ) { $ toolsMenuItem -> fill ( [ 'target' => '_self' , 'icon_class' => 'voyager-tools' , 'color' => null , 'parent_id' => null , 'order' => 9 , ] ) -> save ( ) ; } $ menuItem = MenuItem :: firstOrNew ( [ 'menu_id' => $ menu -> id , 'title' => __ ( 'voyager::seeders.menu_items.menu_builder' ) , 'url' => '' , 'route' => 'voyager.menus.index' , ] ) ; if ( ! $ menuItem -> exists ) { $ menuItem -> fill ( [ 'target' => '_self' , 'icon_class' => 'voyager-list' , 'color' => null , 'parent_id' => $ toolsMenuItem -> id , 'order' => 10 , ] ) -> save ( ) ; } $ menuItem = MenuItem :: firstOrNew ( [ 'menu_id' => $ menu -> id , 'title' => __ ( 'voyager::seeders.menu_items.database' ) , 'url' => '' , 'route' => 'voyager.database.index' , ] ) ; if ( ! $ menuItem -> exists ) { $ menuItem -> fill ( [ 'target' => '_self' , 'icon_class' => 'voyager-data' , 'color' => null , 'parent_id' => $ toolsMenuItem -> id , 'order' => 11 , ] ) -> save ( ) ; } $ menuItem = MenuItem :: firstOrNew ( [ 'menu_id' => $ menu -> id , 'title' => __ ( 'voyager::seeders.menu_items.compass' ) , 'url' => '' , 'route' => 'voyager.compass.index' , ] ) ; if ( ! $ menuItem -> exists ) { $ menuItem -> fill ( [ 'target' => '_self' , 'icon_class' => 'voyager-compass' , 'color' => null , 'parent_id' => $ toolsMenuItem -> id , 'order' => 12 , ] ) -> save ( ) ; } $ menuItem = MenuItem :: firstOrNew ( [ 'menu_id' => $ menu -> id , 'title' => __ ( 'voyager::seeders.menu_items.bread' ) , 'url' => '' , 'route' => 'voyager.bread.index' , ] ) ; if ( ! $ menuItem -> exists ) { $ menuItem -> fill ( [ 'target' => '_self' , 'icon_class' => 'voyager-bread' , 'color' => null , 'parent_id' => $ toolsMenuItem -> id , 'order' => 13 , ] ) -> save ( ) ; } $ menuItem = MenuItem :: firstOrNew ( [ 'menu_id' => $ menu -> id , 'title' => __ ( 'voyager::seeders.menu_items.settings' ) , 'url' => '' , 'route' => 'voyager.settings.index' , ] ) ; if ( ! $ menuItem -> exists ) { $ menuItem -> fill ( [ 'target' => '_self' , 'icon_class' => 'voyager-settings' , 'color' => null , 'parent_id' => null , 'order' => 14 , ] ) -> save ( ) ; } } 
protected function getAdministratorRole ( ) { $ role = Voyager :: model ( 'Role' ) -> firstOrNew ( [ 'name' => 'admin' , ] ) ; if ( ! $ role -> exists ) { $ role -> fill ( [ 'display_name' => 'Administrator' , ] ) -> save ( ) ; } return $ role ; } 
protected function getUser ( $ create = false ) { $ email = $ this -> argument ( 'email' ) ; $ model = config ( 'voyager.user.namespace' ) ? : config ( 'auth.providers.users.model' ) ; 
public function handle ( BreadDeleted $ bread ) { if ( config ( 'voyager.bread.add_menu_item' ) ) { $ menuItem = Voyager :: model ( 'MenuItem' ) -> where ( 'route' , 'voyager.' . $ bread -> dataType -> slug . '.index' ) ; if ( $ menuItem -> exists ( ) ) { $ menuItem -> delete ( ) ; } } } 
private function categoriesTranslations ( ) { 
private function dataTypesTranslations ( ) { 
private function pagesTranslations ( ) { $ page = Page :: where ( 'slug' , 'hello-world' ) -> firstOrFail ( ) ; if ( $ page -> exists ) { $ _arr = $ this -> arr ( [ 'pages' , 'title' ] , $ page -> id ) ; $ this -> trans ( 'pt' , $ _arr , 'Olá Mundo') ; $ _arr = $ this -> arr ( [ 'pages' , 'slug' ] , $ page -> id ) ; $ this -> trans ( 'pt' , $ _arr , 'ola-mundo' ) ; $ _arr = $ this -> arr ( [ 'pages' , 'body' ] , $ page -> id ) ; $ this -> trans ( 'pt' , $ _arr , '<p>Olá Mundo. Scallywag grog swab Cat o\'nine tails scuttle rigging hardtack cable nipper Yellow Jack. Handsomely spirits knave lad killick landlubber or just lubber deadlights chantey pinnace crack Jennys tea cup. Provost long clothes black spot Yellow Jack bilged on her anchor league lateen sail case shot lee tackle.</p>' . "\r\n" . '<p>Ballast spirits fluke topmast me quarterdeck schooner landlubber or just lubber gabion belaying pin. Pinnace stern galleon starboard warp carouser to go on account dance the hempen jig jolly boat measured fer yer chains. Man-of-war fire in the hole nipperkin handsomely doubloon barkadeer Brethren of the Coast gibbet driver squiffy.</p>' ) ; } } 
private function menusTranslations ( ) { $ _tpl = [ 'menu_items' , 'title' ] ; $ _item = $ this -> findMenuItem ( 'Dashboard' ) ; if ( $ _item -> exists ) { $ this -> trans ( 'pt' , $ this -> arr ( $ _tpl , $ _item -> id ) , 'Painel de Controle' ) ; } $ _item = $ this -> findMenuItem ( 'Media' ) ; if ( $ _item -> exists ) { $ this -> trans ( 'pt' , $ this -> arr ( $ _tpl , $ _item -> id ) , 'Media' ) ; } $ _item = $ this -> findMenuItem ( 'Posts' ) ; if ( $ _item -> exists ) { $ this -> trans ( 'pt' , $ this -> arr ( $ _tpl , $ _item -> id ) , 'Publicações'); } $ _item = $ this -> findMenuItem ( 'Users' ) ; if ( $ _item -> exists ) { $ this -> trans ( 'pt' , $ this -> arr ( $ _tpl , $ _item -> id ) , 'Utilizadores' ) ; } $ _item = $ this -> findMenuItem ( 'Categories' ) ; if ( $ _item -> exists ) { $ this -> trans ( 'pt' , $ this -> arr ( $ _tpl , $ _item -> id ) , 'Categorias' ) ; } $ _item = $ this -> findMenuItem ( 'Pages' ) ; if ( $ _item -> exists ) { $ this -> trans ( 'pt' , $ this -> arr ( $ _tpl , $ _item -> id ) , 'Páginas') ; } $ _item = $ this -> findMenuItem ( 'Roles' ) ; if ( $ _item -> exists ) { $ this -> trans ( 'pt' , $ this -> arr ( $ _tpl , $ _item -> id ) , 'Funções'); } $ _item = $ this -> findMenuItem ( 'Tools' ) ; if ( $ _item -> exists ) { $ this -> trans ( 'pt' , $ this -> arr ( $ _tpl , $ _item -> id ) , 'Ferramentas' ) ; } $ _item = $ this -> findMenuItem ( 'Menu Builder' ) ; if ( $ _item -> exists ) { $ this -> trans ( 'pt' , $ this -> arr ( $ _tpl , $ _item -> id ) , 'Menus' ) ; } $ _item = $ this -> findMenuItem ( 'Database' ) ; if ( $ _item -> exists ) { $ this -> trans ( 'pt' , $ this -> arr ( $ _tpl , $ _item -> id ) , 'Base de dados' ) ; } $ _item = $ this -> findMenuItem ( 'Settings' ) ; if ( $ _item -> exists ) { $ this -> trans ( 'pt' , $ this -> arr ( $ _tpl , $ _item -> id ) , 'Configurações'); } } 
public function highestOrderMenuItem ( $ parent = null ) { $ order = 1 ; $ item = $ this -> where ( 'parent_id' , '=' , $ parent ) -> orderBy ( 'order' , 'DESC' ) -> first ( ) ; if ( ! is_null ( $ item ) ) { $ order = intval ( $ item -> order ) + 1 ; } return $ order ; } 
public function run ( ) { $ dataType = $ this -> dataType ( 'slug' , 'users' ) ; if ( ! $ dataType -> exists ) { $ dataType -> fill ( [ 'name' => 'users' , 'display_name_singular' => __ ( 'voyager::seeders.data_types.user.singular' ) , 'display_name_plural' => __ ( 'voyager::seeders.data_types.user.plural' ) , 'icon' => 'voyager-person' , 'model_name' => 'TCG\\Voyager\\Models\\User' , 'policy_name' => 'TCG\\Voyager\\Policies\\UserPolicy' , 'controller' => 'TCG\\Voyager\\Http\\Controllers\\VoyagerUserController' , 'generate_permissions' => 1 , 'description' => '' , ] ) -> save ( ) ; } $ dataType = $ this -> dataType ( 'slug' , 'menus' ) ; if ( ! $ dataType -> exists ) { $ dataType -> fill ( [ 'name' => 'menus' , 'display_name_singular' => __ ( 'voyager::seeders.data_types.menu.singular' ) , 'display_name_plural' => __ ( 'voyager::seeders.data_types.menu.plural' ) , 'icon' => 'voyager-list' , 'model_name' => 'TCG\\Voyager\\Models\\Menu' , 'controller' => '' , 'generate_permissions' => 1 , 'description' => '' , ] ) -> save ( ) ; } $ dataType = $ this -> dataType ( 'slug' , 'roles' ) ; if ( ! $ dataType -> exists ) { $ dataType -> fill ( [ 'name' => 'roles' , 'display_name_singular' => __ ( 'voyager::seeders.data_types.role.singular' ) , 'display_name_plural' => __ ( 'voyager::seeders.data_types.role.plural' ) , 'icon' => 'voyager-lock' , 'model_name' => 'TCG\\Voyager\\Models\\Role' , 'controller' => '' , 'generate_permissions' => 1 , 'description' => '' , ] ) -> save ( ) ; } } 
protected function checkPermission ( User $ user , $ model , $ action ) { if ( self :: $ permissions == null ) { self :: $ permissions = Voyager :: model ( 'Permission' ) -> all ( ) ; } if ( self :: $ datatypes == null ) { self :: $ datatypes = Voyager :: model ( 'DataType' ) :: all ( ) -> keyBy ( 'slug' ) ; } $ regex = str_replace ( '/' , '\/' , preg_quote ( route ( 'voyager.dashboard' ) ) ) ; $ slug = preg_replace ( '/' . $ regex . '/' , '' , $ model -> link ( true ) ) ; $ slug = str_replace ( '/' , '' , $ slug ) ; if ( $ str = self :: $ datatypes -> get ( $ slug ) ) { $ slug = $ str -> name ; } if ( $ slug == '' ) { $ slug = 'admin' ; } elseif ( $ slug == 'compass' && ! \ App :: environment ( 'local' ) && ! config ( 'voyager.compass_in_production' , false ) ) { return false ; } if ( empty ( $ action ) ) { $ action = 'browse' ; } 
public static function createName ( array $ columns , $ type , $ table = null ) { $ table = isset ( $ table ) ? trim ( $ table ) . '_' : '' ; $ type = trim ( $ type ) ; $ name = strtolower ( $ table . implode ( '_' , $ columns ) . '_' . $ type ) ; return str_replace ( [ '-' , '.' ] , '_' , $ name ) ; } 
public function up ( ) { $ platform = \ DB :: getDoctrineSchemaManager ( ) -> getDatabasePlatform ( ) ; $ platform -> registerDoctrineTypeMapping ( 'enum' , 'string' ) ; Schema :: table ( 'posts' , function ( Blueprint $ table ) { $ table -> text ( 'excerpt' ) -> nullable ( ) -> change ( ) ; $ table -> text ( 'meta_description' ) -> nullable ( ) -> change ( ) ; $ table -> text ( 'meta_keywords' ) -> nullable ( ) -> change ( ) ; } ) ; } 
public function down ( ) { Schema :: table ( 'posts' , function ( Blueprint $ table ) { $ table -> text ( 'excerpt' ) -> change ( ) ; $ table -> text ( 'meta_description' ) -> change ( ) ; $ table -> text ( 'meta_keywords' ) -> change ( ) ; } ) ; } 
public function handle ( SettingUpdated $ event ) { if ( config ( 'voyager.settings.cache' , false ) === true ) { Cache :: tags ( 'settings' ) -> forget ( $ event -> setting -> key ) ; } } 
public function handle ( Filesystem $ filesystem ) { $ this -> info ( 'Publishing the Voyager assets, database, and config files' ) ; 
public function run ( ) { $ keys = [ 'browse_admin' , 'browse_bread' , 'browse_database' , 'browse_media' , 'browse_compass' , ] ; foreach ( $ keys as $ key ) { Permission :: firstOrCreate ( [ 'key' => $ key , 'table_name' => null , ] ) ; } Permission :: generateFor ( 'menus' ) ; Permission :: generateFor ( 'roles' ) ; Permission :: generateFor ( 'users' ) ; Permission :: generateFor ( 'settings' ) ; } 
public function hasRole ( $ name ) { $ roles = $ this -> roles_all ( ) -> pluck ( 'name' ) -> toArray ( ) ; foreach ( ( is_array ( $ name ) ? $ name : [ $ name ] ) as $ role ) { if ( in_array ( $ role , $ roles ) ) { return true ; } } return false ; } 
public static function pathToLogFile ( $ file ) { $ logsPath = storage_path ( 'logs' ) ; if ( app ( 'files' ) -> exists ( $ file ) ) { 
public static function getFiles ( $ basename = false ) { $ files = glob ( storage_path ( ) . '/logs/*.log' ) ; $ files = array_reverse ( $ files ) ; $ files = array_filter ( $ files , 'is_file' ) ; if ( $ basename && is_array ( $ files ) ) { foreach ( $ files as $ k => $ file ) { $ files [ $ k ] = basename ( $ file ) ; } } return array_values ( $ files ) ; } 
public function run ( ) { $ this -> seedersPath = database_path ( 'seeds' ) . '/' ; $ this -> seed ( 'CategoriesTableSeeder' ) ; $ this -> seed ( 'UsersTableSeeder' ) ; $ this -> seed ( 'PostsTableSeeder' ) ; $ this -> seed ( 'PagesTableSeeder' ) ; $ this -> seed ( 'TranslationsTableSeeder' ) ; $ this -> seed ( 'PermissionRoleTableSeeder' ) ; } 
public function handle ( BreadAdded $ bread ) { if ( config ( 'voyager.bread.add_menu_item' ) && file_exists ( base_path ( 'routes/web.php' ) ) ) { require base_path ( 'routes/web.php' ) ; $ menu = Voyager :: model ( 'Menu' ) -> where ( 'name' , config ( 'voyager.bread.default_menu' ) ) -> firstOrFail ( ) ; $ menuItem = Voyager :: model ( 'MenuItem' ) -> firstOrNew ( [ 'menu_id' => $ menu -> id , 'title' => $ bread -> dataType -> display_name_plural , 'url' => '' , 'route' => 'voyager.' . $ bread -> dataType -> slug . '.index' , ] ) ; $ order = Voyager :: model ( 'MenuItem' ) -> highestOrderMenuItem ( ) ; if ( ! $ menuItem -> exists ) { $ menuItem -> fill ( [ 'target' => '_self' , 'icon_class' => $ bread -> dataType -> icon , 'color' => null , 'parent_id' => null , 'order' => $ order , ] ) -> save ( ) ; } } } 
public function up ( ) { Schema :: create ( 'menus' , function ( Blueprint $ table ) { $ table -> increments ( 'id' ) ; $ table -> string ( 'name' ) -> unique ( ) ; $ table -> timestamps ( ) ; } ) ; Schema :: create ( 'menu_items' , function ( Blueprint $ table ) { $ table -> increments ( 'id' ) ; $ table -> unsignedInteger ( 'menu_id' ) -> nullable ( ) ; $ table -> string ( 'title' ) ; $ table -> string ( 'url' ) ; $ table -> string ( 'target' ) -> default ( '_self' ) ; $ table -> string ( 'icon_class' ) -> nullable ( ) ; $ table -> string ( 'color' ) -> nullable ( ) ; $ table -> integer ( 'parent_id' ) -> nullable ( ) ; $ table -> integer ( 'order' ) ; $ table -> timestamps ( ) ; } ) ; Schema :: table ( 'menu_items' , function ( Blueprint $ table ) { $ table -> foreign ( 'menu_id' ) -> references ( 'id' ) -> on ( 'menus' ) -> onDelete ( 'cascade' ) ; } ) ; } 
public function up ( ) { Schema :: table ( 'users' , function ( Blueprint $ table ) { $ table -> text ( 'settings' ) -> nullable ( ) -> default ( null ) -> after ( 'remember_token' ) ; } ) ; } 
public function up ( ) { Schema :: table ( 'permissions' , function ( Blueprint $ table ) { $ table -> string ( 'table_name' ) -> nullable ( ) -> default ( null ) -> change ( ) ; } ) ; } 
public function up ( ) { Schema :: table ( 'menu_items' , function ( Blueprint $ table ) { $ table -> string ( 'route' ) -> nullable ( ) -> default ( null ) ; $ table -> text ( 'parameters' ) -> nullable ( ) -> default ( null ) ; } ) ; } 
public function update ( Request $ request , $ id ) { $ slug = $ this -> getSlug ( $ request ) ; $ dataType = Voyager :: model ( 'DataType' ) -> where ( 'slug' , '=' , $ slug ) -> first ( ) ; 
public static function update ( $ table ) { if ( ! is_array ( $ table ) ) { $ table = json_decode ( $ table , true ) ; } if ( ! SchemaManager :: tableExists ( $ table [ 'oldName' ] ) ) { throw SchemaException :: tableDoesNotExist ( $ table [ 'oldName' ] ) ; } $ updater = new self ( $ table ) ; $ updater -> updateTable ( ) ; } 
public function updateTable ( ) { 
protected function getRenamedColumnsDiff ( ) { $ renamedColumns = $ this -> getRenamedColumns ( ) ; if ( empty ( $ renamedColumns ) ) { return false ; } $ renamedColumnsDiff = new TableDiff ( $ this -> tableArr [ 'oldName' ] ) ; $ renamedColumnsDiff -> fromTable = $ this -> originalTable ; foreach ( $ renamedColumns as $ oldName => $ newName ) { $ renamedColumnsDiff -> renamedColumns [ $ oldName ] = $ this -> table -> getColumn ( $ newName ) ; } return $ renamedColumnsDiff ; } 
protected function getRenamedDiff ( ) { $ renamedColumns = $ this -> getRenamedColumns ( ) ; $ renamedIndexes = $ this -> getRenamedIndexes ( ) ; if ( empty ( $ renamedColumns ) && empty ( $ renamedIndexes ) ) { return false ; } $ renamedDiff = new TableDiff ( $ this -> tableArr [ 'oldName' ] ) ; $ renamedDiff -> fromTable = $ this -> originalTable ; foreach ( $ renamedColumns as $ oldName => $ newName ) { $ renamedDiff -> renamedColumns [ $ oldName ] = $ this -> table -> getColumn ( $ newName ) ; } foreach ( $ renamedIndexes as $ oldName => $ newName ) { $ renamedDiff -> renamedIndexes [ $ oldName ] = $ this -> table -> getIndex ( $ newName ) ; } return $ renamedDiff ; } 
protected function getRenamedColumns ( ) { $ renamedColumns = [ ] ; foreach ( $ this -> tableArr [ 'columns' ] as $ column ) { $ oldName = $ column [ 'oldName' ] ; 
protected function getRenamedIndexes ( ) { $ renamedIndexes = [ ] ; foreach ( $ this -> tableArr [ 'indexes' ] as $ index ) { $ oldName = $ index [ 'oldName' ] ; 
public function thumbnail ( $ type , $ attribute = 'image' ) { 
public function getThumbnail ( $ image , $ type ) { 
public function run ( ) { 
protected function checkPermission ( User $ user , $ model , $ action ) { if ( ! isset ( self :: $ datatypes [ get_class ( $ model ) ] ) ) { $ dataType = Voyager :: model ( 'DataType' ) ; self :: $ datatypes [ get_class ( $ model ) ] = $ dataType -> where ( 'model_name' , get_class ( $ model ) ) -> first ( ) ; } $ dataType = self :: $ datatypes [ get_class ( $ model ) ] ; return $ user -> hasPermission ( $ action . '_' . $ dataType -> name ) ; } 
public function update ( Request $ request , $ id ) { if ( app ( 'VoyagerAuth' ) -> user ( ) -> getKey ( ) == $ id ) { $ request -> merge ( [ 'role_id' => app ( 'VoyagerAuth' ) -> user ( ) -> role_id , 'user_belongsto_role_relationship' => app ( 'VoyagerAuth' ) -> user ( ) -> role_id , 'user_belongstomany_role_relationship' => app ( 'VoyagerAuth' ) -> user ( ) -> roles -> pluck ( 'id' ) -> toArray ( ) , ] ) ; } return parent :: update ( $ request , $ id ) ; } 
public function editRoles ( User $ user , $ model ) { 
public function dimmers ( ) { $ widgetClasses = config ( 'voyager.dashboard.widgets' ) ; $ dimmers = Widget :: group ( 'voyager::dimmers' ) ; foreach ( $ widgetClasses as $ widgetClass ) { $ widget = app ( $ widgetClass ) ; if ( $ widget -> shouldBeDisplayed ( ) ) { $ dimmers -> addWidget ( $ widgetClass ) ; } } return $ dimmers ; } 
public static function getPlatform ( $ platformName ) { $ platform = __NAMESPACE__ . '\\' . ucfirst ( $ platformName ) ; if ( ! class_exists ( $ platform ) ) { throw new \ Exception ( "Platform {$platformName} doesn't exist" ) ; } return $ platform ; } 
protected function prepareMenuTranslations ( & $ data ) { $ trans = json_decode ( $ data [ 'title_i18n' ] , true ) ; 
public function save ( ) { $ attributes = $ this -> getModifiedAttributes ( ) ; $ savings = [ ] ; foreach ( $ attributes as $ key => $ attribute ) { if ( $ attribute [ 'exists' ] ) { $ translation = $ this -> getTranslationModel ( $ key ) ; } else { $ translation = VoyagerFacade :: model ( 'Translation' ) -> where ( 'table_name' , $ this -> model -> getTable ( ) ) -> where ( 'column_name' , $ key ) -> where ( 'foreign_key' , $ this -> model -> getKey ( ) ) -> where ( 'locale' , $ this -> locale ) -> first ( ) ; } if ( is_null ( $ translation ) ) { $ translation = VoyagerFacade :: model ( 'Translation' ) ; } $ translation -> fill ( [ 'table_name' => $ this -> model -> getTable ( ) , 'column_name' => $ key , 'foreign_key' => $ this -> model -> getKey ( ) , 'value' => $ attribute [ 'value' ] , 'locale' => $ this -> locale , ] ) ; $ savings [ ] = $ translation -> save ( ) ; $ this -> attributes [ $ key ] [ 'locale' ] = $ this -> locale ; $ this -> attributes [ $ key ] [ 'exists' ] = true ; $ this -> attributes [ $ key ] [ 'modified' ] = false ; } return in_array ( false , $ savings ) ; } 
public function read ( User $ user , $ model ) { 
public function run ( ) { <p>Ballast spirits fluke topmast me quarterdeck schooner landlubber or just lubber gabion belaying pin. Pinnace stern galleon starboard warp carouser to go on account dance the hempen jig jolly boat measured fer yer chains. Man-of-war fire in the hole nipperkin handsomely doubloon barkadeer Brethren of the Coast gibbet driver squiffy.</p>' , 'image' => 'pages/page1.jpg' , 'meta_description' => 'Yar Meta Description' , 'meta_keywords' => 'Keyword1, Keyword2' , 'status' => 'ACTIVE' , ] ) -> save ( ) ; } } 
public function register ( ) { $ this -> app -> register ( WidgetServiceProvider :: class ) ; $ this -> registerConfigs ( ) ; if ( $ this -> app -> runningInConsole ( ) ) { $ this -> registerPublishableResources ( ) ; } } 
public function up ( ) { Schema :: create ( 'user_roles' , function ( Blueprint $ table ) { $ type = DB :: connection ( ) -> getDoctrineColumn ( 'users' , 'id' ) -> getType ( ) -> getName ( ) ; if ( $ type == 'bigint' ) { $ table -> bigInteger ( 'user_id' ) -> unsigned ( ) -> index ( ) ; } else { $ table -> integer ( 'user_id' ) -> unsigned ( ) -> index ( ) ; } $ table -> foreign ( 'user_id' ) -> references ( 'id' ) -> on ( 'users' ) -> onDelete ( 'cascade' ) ; $ table -> bigInteger ( 'role_id' ) -> unsigned ( ) -> index ( ) ; $ table -> foreign ( 'role_id' ) -> references ( 'id' ) -> on ( 'roles' ) -> onDelete ( 'cascade' ) ; $ table -> primary ( [ 'user_id' , 'role_id' ] ) ; } ) ; } 
public function create ( Request $ request , $ table ) { $ this -> authorize ( 'browse_bread' ) ; $ dataType = Voyager :: model ( 'DataType' ) -> whereName ( $ table ) -> first ( ) ; $ data = $ this -> prepopulateBreadInfo ( $ table ) ; $ data [ 'fieldOptions' ] = SchemaManager :: describeTable ( ( isset ( $ dataType ) && strlen ( $ dataType -> model_name ) != 0 ) ? app ( $ dataType -> model_name ) -> getTable ( ) : $ table ) ; return Voyager :: view ( 'voyager::tools.bread.edit-add' , $ data ) ; } 
public function store ( Request $ request ) { $ this -> authorize ( 'browse_bread' ) ; try { $ dataType = Voyager :: model ( 'DataType' ) ; $ res = $ dataType -> updateDataType ( $ request -> all ( ) , true ) ; $ data = $ res ? $ this -> alertSuccess ( __ ( 'voyager::bread.success_created_bread' ) ) : $ this -> alertError ( __ ( 'voyager::bread.error_creating_bread' ) ) ; if ( $ res ) { event ( new BreadAdded ( $ dataType , $ data ) ) ; } return redirect ( ) -> route ( 'voyager.bread.index' ) -> with ( $ data ) ; } catch ( Exception $ e ) { return redirect ( ) -> route ( 'voyager.bread.index' ) -> with ( $ this -> alertException ( $ e , 'Saving Failed' ) ) ; } } 
public function edit ( $ table ) { $ this -> authorize ( 'browse_bread' ) ; $ dataType = Voyager :: model ( 'DataType' ) -> whereName ( $ table ) -> first ( ) ; $ fieldOptions = SchemaManager :: describeTable ( ( strlen ( $ dataType -> model_name ) != 0 ) ? app ( $ dataType -> model_name ) -> getTable ( ) : $ dataType -> name ) ; $ isModelTranslatable = is_bread_translatable ( $ dataType ) ; $ tables = SchemaManager :: listTableNames ( ) ; $ dataTypeRelationships = Voyager :: model ( 'DataRow' ) -> where ( 'data_type_id' , '=' , $ dataType -> id ) -> where ( 'type' , '=' , 'relationship' ) -> get ( ) ; $ scopes = [ ] ; if ( $ dataType -> model_name != '' ) { $ scopes = $ this -> getModelScopes ( $ dataType -> model_name ) ; } return Voyager :: view ( 'voyager::tools.bread.edit-add' , compact ( 'dataType' , 'fieldOptions' , 'isModelTranslatable' , 'tables' , 'dataTypeRelationships' , 'scopes' ) ) ; } 
public function update ( Request $ request , $ id ) { $ this -> authorize ( 'browse_bread' ) ; try { $ dataType = Voyager :: model ( 'DataType' ) -> find ( $ id ) ; 
public function destroy ( $ id ) { $ this -> authorize ( 'browse_bread' ) ; $ dataType = Voyager :: model ( 'DataType' ) -> find ( $ id ) ; 
public function addRelationship ( Request $ request ) { $ relationshipField = $ this -> getRelationshipField ( $ request ) ; if ( ! class_exists ( $ request -> relationship_model ) ) { return back ( ) -> with ( [ 'message' => 'Model Class ' . $ request -> relationship_model . ' does not exist. Please create Model before creating relationship.' , 'alert-type' => 'error' , ] ) ; } try { DB :: beginTransaction ( ) ; $ relationship_column = $ request -> relationship_column_belongs_to ; if ( $ request -> relationship_type == 'hasOne' || $ request -> relationship_type == 'hasMany' ) { $ relationship_column = $ request -> relationship_column ; } 
private function getRelationshipField ( $ request ) { 
public function handle ( ) { return empty ( $ this -> request -> input ( $ this -> row -> field ) ) ? null : bcrypt ( $ this -> request -> input ( $ this -> row -> field ) ) ; } 
public function store ( Request $ request ) { $ this -> authorize ( 'browse_database' ) ; try { $ conn = 'database.connections.' . config ( 'database.default' ) ; Type :: registerCustomPlatformTypes ( ) ; $ table = $ request -> table ; if ( ! is_array ( $ request -> table ) ) { $ table = json_decode ( $ request -> table , true ) ; } $ table [ 'options' ] [ 'collate' ] = config ( $ conn . '.collation' , 'utf8mb4_unicode_ci' ) ; $ table [ 'options' ] [ 'charset' ] = config ( $ conn . '.charset' , 'utf8mb4' ) ; $ table = Table :: make ( $ table ) ; SchemaManager :: createTable ( $ table ) ; if ( isset ( $ request -> create_model ) && $ request -> create_model == 'on' ) { $ modelNamespace = config ( 'voyager.models.namespace' , app ( ) -> getNamespace ( ) ) ; $ params = [ 'name' => $ modelNamespace . Str :: studly ( Str :: singular ( $ table -> name ) ) , ] ; 
public function edit ( $ table ) { $ this -> authorize ( 'browse_database' ) ; if ( ! SchemaManager :: tableExists ( $ table ) ) { return redirect ( ) -> route ( 'voyager.database.index' ) -> with ( $ this -> alertError ( __ ( 'voyager::database.edit_table_not_exist' ) ) ) ; } $ db = $ this -> prepareDbManager ( 'update' , $ table ) ; return Voyager :: view ( 'voyager::tools.database.edit-add' , compact ( 'db' ) ) ; } 
public function update ( Request $ request ) { $ this -> authorize ( 'browse_database' ) ; $ table = json_decode ( $ request -> table , true ) ; try { DatabaseUpdater :: update ( $ table ) ; 
public function show ( $ table ) { $ this -> authorize ( 'browse_database' ) ; $ additional_attributes = [ ] ; $ model_name = Voyager :: model ( 'DataType' ) -> where ( 'name' , $ table ) -> pluck ( 'model_name' ) -> first ( ) ; if ( isset ( $ model_name ) ) { $ model = app ( $ model_name ) ; if ( isset ( $ model -> additional_attributes ) ) { foreach ( $ model -> additional_attributes as $ attribute ) { $ additional_attributes [ $ attribute ] = [ ] ; } } } return response ( ) -> json ( collect ( SchemaManager :: describeTable ( $ table ) ) -> merge ( $ additional_attributes ) ) ; } 
public function destroy ( $ table ) { $ this -> authorize ( 'browse_database' ) ; try { SchemaManager :: dropTable ( $ table ) ; event ( new TableDeleted ( $ table ) ) ; return redirect ( ) -> route ( 'voyager.database.index' ) -> with ( $ this -> alertSuccess ( __ ( 'voyager::database.success_delete_table' , [ 'table' => $ table ] ) ) ) ; } catch ( Exception $ e ) { return back ( ) -> with ( $ this -> alertException ( $ e ) ) ; } } 
public function run ( ) { $ count = Voyager :: model ( 'User' ) -> count ( ) ; $ string = trans_choice ( 'voyager::dimmer.user' , $ count ) ; return view ( 'voyager::dimmer' , array_merge ( $ this -> config , [ 'icon' => 'voyager-group' , 'title' => "{$count} {$string}" , 'text' => __ ( 'voyager::dimmer.user_text' , [ 'count' => $ count , 'string' => Str :: lower ( $ string ) ] ) , 'button' => [ 'text' => __ ( 'voyager::dimmer.user_link_text' ) , 'link' => route ( 'voyager.users.index' ) , ] , 'image' => voyager_asset ( 'images/widget-backgrounds/01.jpg' ) , ] ) ) ; } 
public function up ( ) { Schema :: table ( 'users' , function ( Blueprint $ table ) { $ table -> bigInteger ( 'role_id' ) -> unsigned ( ) -> change ( ) ; $ table -> foreign ( 'role_id' ) -> references ( 'id' ) -> on ( 'roles' ) ; } ) ; } 
public function down ( ) { Schema :: table ( 'users' , function ( Blueprint $ table ) { $ table -> dropForeign ( [ 'role_id' ] ) ; } ) ; Schema :: table ( 'users' , function ( Blueprint $ table ) { $ table -> bigInteger ( 'role_id' ) -> change ( ) ; } ) ; } 
public function sortByUrl ( $ orderBy , $ sortOrder ) { $ params = [ ] ; $ isDesc = $ sortOrder != 'asc' ; if ( $ this -> isCurrentSortField ( $ orderBy ) && $ isDesc ) { $ params [ 'sort_order' ] = 'asc' ; } else { $ params [ 'sort_order' ] = 'desc' ; } $ params [ 'order_by' ] = $ this -> field ; return url ( ) -> current ( ) . '?' . http_build_query ( array_merge ( \ Request :: all ( ) , $ params ) ) ; } 
protected function generateFileName ( $ file , $ path ) { if ( isset ( $ this -> options -> preserveFileUploadName ) && $ this -> options -> preserveFileUploadName ) { $ filename = basename ( $ file -> getClientOriginalName ( ) , '.' . $ file -> getClientOriginalExtension ( ) ) ; $ filename_counter = 1 ; 
public function run ( ) { $ userDataType = DataType :: where ( 'slug' , 'users' ) -> firstOrFail ( ) ; $ menuDataType = DataType :: where ( 'slug' , 'menus' ) -> firstOrFail ( ) ; $ roleDataType = DataType :: where ( 'slug' , 'roles' ) -> firstOrFail ( ) ; $ dataRow = $ this -> dataRow ( $ userDataType , 'id' ) ; if ( ! $ dataRow -> exists ) { $ dataRow -> fill ( [ 'type' => 'number' , 'display_name' => __ ( 'voyager::seeders.data_rows.id' ) , 'required' => 1 , 'browse' => 0 , 'read' => 0 , 'edit' => 0 , 'add' => 0 , 'delete' => 0 , 'order' => 1 , ] ) -> save ( ) ; } $ dataRow = $ this -> dataRow ( $ userDataType , 'name' ) ; if ( ! $ dataRow -> exists ) { $ dataRow -> fill ( [ 'type' => 'text' , 'display_name' => __ ( 'voyager::seeders.data_rows.name' ) , 'required' => 1 , 'browse' => 1 , 'read' => 1 , 'edit' => 1 , 'add' => 1 , 'delete' => 1 , 'order' => 2 , ] ) -> save ( ) ; } $ dataRow = $ this -> dataRow ( $ userDataType , 'email' ) ; if ( ! $ dataRow -> exists ) { $ dataRow -> fill ( [ 'type' => 'text' , 'display_name' => __ ( 'voyager::seeders.data_rows.email' ) , 'required' => 1 , 'browse' => 1 , 'read' => 1 , 'edit' => 1 , 'add' => 1 , 'delete' => 1 , 'order' => 3 , ] ) -> save ( ) ; } $ dataRow = $ this -> dataRow ( $ userDataType , 'password' ) ; if ( ! $ dataRow -> exists ) { $ dataRow -> fill ( [ 'type' => 'password' , 'display_name' => __ ( 'voyager::seeders.data_rows.password' ) , 'required' => 1 , 'browse' => 0 , 'read' => 0 , 'edit' => 1 , 'add' => 1 , 'delete' => 0 , 'order' => 4 , ] ) -> save ( ) ; } $ dataRow = $ this -> dataRow ( $ userDataType , 'remember_token' ) ; if ( ! $ dataRow -> exists ) { $ dataRow -> fill ( [ 'type' => 'text' , 'display_name' => __ ( 'voyager::seeders.data_rows.remember_token' ) , 'required' => 0 , 'browse' => 0 , 'read' => 0 , 'edit' => 0 , 'add' => 0 , 'delete' => 0 , 'order' => 5 , ] ) -> save ( ) ; } $ dataRow = $ this -> dataRow ( $ userDataType , 'created_at' ) ; if ( ! $ dataRow -> exists ) { $ dataRow -> fill ( [ 'type' => 'timestamp' , 'display_name' => __ ( 'voyager::seeders.data_rows.created_at' ) , 'required' => 0 , 'browse' => 1 , 'read' => 1 , 'edit' => 0 , 'add' => 0 , 'delete' => 0 , 'order' => 6 , ] ) -> save ( ) ; } $ dataRow = $ this -> dataRow ( $ userDataType , 'updated_at' ) ; if ( ! $ dataRow -> exists ) { $ dataRow -> fill ( [ 'type' => 'timestamp' , 'display_name' => __ ( 'voyager::seeders.data_rows.updated_at' ) , 'required' => 0 , 'browse' => 0 , 'read' => 0 , 'edit' => 0 , 'add' => 0 , 'delete' => 0 , 'order' => 7 , ] ) -> save ( ) ; } $ dataRow = $ this -> dataRow ( $ userDataType , 'avatar' ) ; if ( ! $ dataRow -> exists ) { $ dataRow -> fill ( [ 'type' => 'image' , 'display_name' => __ ( 'voyager::seeders.data_rows.avatar' ) , 'required' => 0 , 'browse' => 1 , 'read' => 1 , 'edit' => 1 , 'add' => 1 , 'delete' => 1 , 'order' => 8 , ] ) -> save ( ) ; } $ dataRow = $ this -> dataRow ( $ userDataType , 'user_belongsto_role_relationship' ) ; if ( ! $ dataRow -> exists ) { $ dataRow -> fill ( [ 'type' => 'relationship' , 'display_name' => __ ( 'voyager::seeders.data_rows.role' ) , 'required' => 0 , 'browse' => 1 , 'read' => 1 , 'edit' => 1 , 'add' => 1 , 'delete' => 0 , 'details' => [ 'model' => 'TCG\\Voyager\\Models\\Role' , 'table' => 'roles' , 'type' => 'belongsTo' , 'column' => 'role_id' , 'key' => 'id' , 'label' => 'display_name' , 'pivot_table' => 'roles' , 'pivot' => 0 , ] , 'order' => 10 , ] ) -> save ( ) ; } $ dataRow = $ this -> dataRow ( $ userDataType , 'user_belongstomany_role_relationship' ) ; if ( ! $ dataRow -> exists ) { $ dataRow -> fill ( [ 'type' => 'relationship' , 'display_name' => 'Roles' , 'required' => 0 , 'browse' => 1 , 'read' => 1 , 'edit' => 1 , 'add' => 1 , 'delete' => 0 , 'details' => [ 'model' => 'TCG\\Voyager\\Models\\Role' , 'table' => 'roles' , 'type' => 'belongsToMany' , 'column' => 'id' , 'key' => 'id' , 'label' => 'display_name' , 'pivot_table' => 'user_roles' , 'pivot' => '1' , 'taggable' => '0' , ] , 'order' => 11 , ] ) -> save ( ) ; } $ dataRow = $ this -> dataRow ( $ userDataType , 'settings' ) ; if ( ! $ dataRow -> exists ) { $ dataRow -> fill ( [ 'type' => 'hidden' , 'display_name' => 'Settings' , 'required' => 0 , 'browse' => 0 , 'read' => 0 , 'edit' => 0 , 'add' => 0 , 'delete' => 0 , 'order' => 12 , ] ) -> save ( ) ; } $ dataRow = $ this -> dataRow ( $ menuDataType , 'id' ) ; if ( ! $ dataRow -> exists ) { $ dataRow -> fill ( [ 'type' => 'number' , 'display_name' => __ ( 'voyager::seeders.data_rows.id' ) , 'required' => 1 , 'browse' => 0 , 'read' => 0 , 'edit' => 0 , 'add' => 0 , 'delete' => 0 , 'order' => 1 , ] ) -> save ( ) ; } $ dataRow = $ this -> dataRow ( $ menuDataType , 'name' ) ; if ( ! $ dataRow -> exists ) { $ dataRow -> fill ( [ 'type' => 'text' , 'display_name' => __ ( 'voyager::seeders.data_rows.name' ) , 'required' => 1 , 'browse' => 1 , 'read' => 1 , 'edit' => 1 , 'add' => 1 , 'delete' => 1 , 'order' => 2 , ] ) -> save ( ) ; } $ dataRow = $ this -> dataRow ( $ menuDataType , 'created_at' ) ; if ( ! $ dataRow -> exists ) { $ dataRow -> fill ( [ 'type' => 'timestamp' , 'display_name' => __ ( 'voyager::seeders.data_rows.created_at' ) , 'required' => 0 , 'browse' => 0 , 'read' => 0 , 'edit' => 0 , 'add' => 0 , 'delete' => 0 , 'order' => 3 , ] ) -> save ( ) ; } $ dataRow = $ this -> dataRow ( $ menuDataType , 'updated_at' ) ; if ( ! $ dataRow -> exists ) { $ dataRow -> fill ( [ 'type' => 'timestamp' , 'display_name' => __ ( 'voyager::seeders.data_rows.updated_at' ) , 'required' => 0 , 'browse' => 0 , 'read' => 0 , 'edit' => 0 , 'add' => 0 , 'delete' => 0 , 'order' => 4 , ] ) -> save ( ) ; } $ dataRow = $ this -> dataRow ( $ roleDataType , 'id' ) ; if ( ! $ dataRow -> exists ) { $ dataRow -> fill ( [ 'type' => 'number' , 'display_name' => __ ( 'voyager::seeders.data_rows.id' ) , 'required' => 1 , 'browse' => 0 , 'read' => 0 , 'edit' => 0 , 'add' => 0 , 'delete' => 0 , 'order' => 1 , ] ) -> save ( ) ; } $ dataRow = $ this -> dataRow ( $ roleDataType , 'name' ) ; if ( ! $ dataRow -> exists ) { $ dataRow -> fill ( [ 'type' => 'text' , 'display_name' => __ ( 'voyager::seeders.data_rows.name' ) , 'required' => 1 , 'browse' => 1 , 'read' => 1 , 'edit' => 1 , 'add' => 1 , 'delete' => 1 , 'order' => 2 , ] ) -> save ( ) ; } $ dataRow = $ this -> dataRow ( $ roleDataType , 'created_at' ) ; if ( ! $ dataRow -> exists ) { $ dataRow -> fill ( [ 'type' => 'timestamp' , 'display_name' => __ ( 'voyager::seeders.data_rows.created_at' ) , 'required' => 0 , 'browse' => 0 , 'read' => 0 , 'edit' => 0 , 'add' => 0 , 'delete' => 0 , 'order' => 3 , ] ) -> save ( ) ; } $ dataRow = $ this -> dataRow ( $ roleDataType , 'updated_at' ) ; if ( ! $ dataRow -> exists ) { $ dataRow -> fill ( [ 'type' => 'timestamp' , 'display_name' => __ ( 'voyager::seeders.data_rows.updated_at' ) , 'required' => 0 , 'browse' => 0 , 'read' => 0 , 'edit' => 0 , 'add' => 0 , 'delete' => 0 , 'order' => 4 , ] ) -> save ( ) ; } $ dataRow = $ this -> dataRow ( $ roleDataType , 'display_name' ) ; if ( ! $ dataRow -> exists ) { $ dataRow -> fill ( [ 'type' => 'text' , 'display_name' => __ ( 'voyager::seeders.data_rows.display_name' ) , 'required' => 1 , 'browse' => 1 , 'read' => 1 , 'edit' => 1 , 'add' => 1 , 'delete' => 1 , 'order' => 5 , ] ) -> save ( ) ; } $ dataRow = $ this -> dataRow ( $ userDataType , 'role_id' ) ; if ( ! $ dataRow -> exists ) { $ dataRow -> fill ( [ 'type' => 'text' , 'display_name' => __ ( 'voyager::seeders.data_rows.role' ) , 'required' => 1 , 'browse' => 1 , 'read' => 1 , 'edit' => 1 , 'add' => 1 , 'delete' => 1 , 'order' => 9 , ] ) -> save ( ) ; } } 
public static function display ( $ menuName , $ type = null , array $ options = [ ] ) { 
public function handle ( $ request , Closure $ next ) { if ( ! app ( 'VoyagerAuth' ) -> guest ( ) ) { $ user = app ( 'VoyagerAuth' ) -> user ( ) ; app ( ) -> setLocale ( $ user -> locale ?? app ( ) -> getLocale ( ) ) ; return $ user -> hasPermission ( 'browse_admin' ) ? $ next ( $ request ) : redirect ( '/' ) ; } $ urlLogin = route ( 'voyager.login' ) ; return redirect ( ) -> guest ( $ urlLogin ) ; } 
public function run ( ) { $ role = Role :: where ( 'name' , 'admin' ) -> firstOrFail ( ) ; $ permissions = Permission :: all ( ) ; $ role -> permissions ( ) -> sync ( $ permissions -> pluck ( 'id' ) -> all ( ) ) ; } 
public function translatable ( ) { if ( isset ( $ this -> translatable ) && $ this -> translatable == false ) { return false ; } return ! empty ( $ this -> getTranslatableAttributes ( ) ) ; } 
public function translations ( ) { return $ this -> hasMany ( Voyager :: model ( 'Translation' ) , 'foreign_key' , $ this -> getKeyName ( ) ) -> where ( 'table_name' , $ this -> getTable ( ) ) -> whereIn ( 'locale' , config ( 'voyager.multilingual.locales' , [ ] ) ) ; } 
public function scopeWithTranslation ( Builder $ query , $ locale = null , $ fallback = true ) { if ( is_null ( $ locale ) ) { $ locale = app ( ) -> getLocale ( ) ; } if ( $ fallback === true ) { $ fallback = config ( 'app.fallback_locale' , 'en' ) ; } $ query -> with ( [ 'translations' => function ( Relation $ query ) use ( $ locale , $ fallback ) { $ query -> where ( function ( $ q ) use ( $ locale , $ fallback ) { $ q -> where ( 'locale' , $ locale ) ; if ( $ fallback !== false ) { $ q -> orWhere ( 'locale' , $ fallback ) ; } } ) ; } ] ) ; } 
public function getTranslatedAttribute ( $ attribute , $ language = null , $ fallback = true ) { list ( $ value ) = $ this -> getTranslatedAttributeMeta ( $ attribute , $ language , $ fallback ) ; return $ value ; } 
public static function scopeWhereTranslation ( $ query , $ field , $ operator , $ value = null , $ locales = null , $ default = true ) { if ( $ locales && ! is_array ( $ locales ) ) { $ locales = [ $ locales ] ; } if ( ! isset ( $ value ) ) { $ value = $ operator ; $ operator = '=' ; } $ self = new static ( ) ; $ table = $ self -> getTable ( ) ; return $ query -> whereIn ( $ self -> getKeyName ( ) , Translation :: where ( 'table_name' , $ table ) -> where ( 'column_name' , $ field ) -> where ( 'value' , $ operator , $ value ) -> when ( ! is_null ( $ locales ) , function ( $ query ) use ( $ locales ) { return $ query -> whereIn ( 'locale' , $ locales ) ; } ) -> pluck ( 'foreign_key' ) ) -> when ( $ default , function ( $ query ) use ( $ field , $ operator , $ value ) { return $ query -> orWhere ( $ field , $ operator , $ value ) ; } ) ; } 
public function saveTranslations ( $ translations ) { foreach ( $ translations as $ field => $ locales ) { foreach ( $ locales as $ locale => $ translation ) { $ translation -> save ( ) ; } } } 
public static function listTableDetails ( $ tableName ) { $ columns = static :: manager ( ) -> listTableColumns ( $ tableName ) ; $ foreignKeys = [ ] ; if ( static :: manager ( ) -> getDatabasePlatform ( ) -> supportsForeignKeyConstraints ( ) ) { $ foreignKeys = static :: manager ( ) -> listTableForeignKeys ( $ tableName ) ; } $ indexes = static :: manager ( ) -> listTableIndexes ( $ tableName ) ; return new Table ( $ tableName , $ columns , $ indexes , $ foreignKeys , false , [ ] ) ; } 
public static function describeTable ( $ tableName ) { Type :: registerCustomPlatformTypes ( ) ; $ table = static :: listTableDetails ( $ tableName ) ; return collect ( $ table -> columns ) -> map ( function ( $ column ) use ( $ table ) { $ columnArr = Column :: toArray ( $ column ) ; $ columnArr [ 'field' ] = $ columnArr [ 'name' ] ; $ columnArr [ 'type' ] = $ columnArr [ 'type' ] [ 'name' ] ; 
public function down ( ) { Schema :: table ( 'settings' , function ( Blueprint $ table ) { $ table -> text ( 'value' ) -> nullable ( false ) -> change ( ) ; } ) ; } 
public function run ( ) { $ setting = $ this -> findSetting ( 'site.title' ) ; if ( ! $ setting -> exists ) { $ setting -> fill ( [ 'display_name' => __ ( 'voyager::seeders.settings.site.title' ) , 'value' => __ ( 'voyager::seeders.settings.site.title' ) , 'details' => '' , 'type' => 'text' , 'order' => 1 , 'group' => 'Site' , ] ) -> save ( ) ; } $ setting = $ this -> findSetting ( 'site.description' ) ; if ( ! $ setting -> exists ) { $ setting -> fill ( [ 'display_name' => __ ( 'voyager::seeders.settings.site.description' ) , 'value' => __ ( 'voyager::seeders.settings.site.description' ) , 'details' => '' , 'type' => 'text' , 'order' => 2 , 'group' => 'Site' , ] ) -> save ( ) ; } $ setting = $ this -> findSetting ( 'site.logo' ) ; if ( ! $ setting -> exists ) { $ setting -> fill ( [ 'display_name' => __ ( 'voyager::seeders.settings.site.logo' ) , 'value' => '' , 'details' => '' , 'type' => 'image' , 'order' => 3 , 'group' => 'Site' , ] ) -> save ( ) ; } $ setting = $ this -> findSetting ( 'site.google_analytics_tracking_id' ) ; if ( ! $ setting -> exists ) { $ setting -> fill ( [ 'display_name' => __ ( 'voyager::seeders.settings.site.google_analytics_tracking_id' ) , 'value' => '' , 'details' => '' , 'type' => 'text' , 'order' => 4 , 'group' => 'Site' , ] ) -> save ( ) ; } $ setting = $ this -> findSetting ( 'admin.bg_image' ) ; if ( ! $ setting -> exists ) { $ setting -> fill ( [ 'display_name' => __ ( 'voyager::seeders.settings.admin.background_image' ) , 'value' => '' , 'details' => '' , 'type' => 'image' , 'order' => 5 , 'group' => 'Admin' , ] ) -> save ( ) ; } $ setting = $ this -> findSetting ( 'admin.title' ) ; if ( ! $ setting -> exists ) { $ setting -> fill ( [ 'display_name' => __ ( 'voyager::seeders.settings.admin.title' ) , 'value' => 'Voyager' , 'details' => '' , 'type' => 'text' , 'order' => 1 , 'group' => 'Admin' , ] ) -> save ( ) ; } $ setting = $ this -> findSetting ( 'admin.description' ) ; if ( ! $ setting -> exists ) { $ setting -> fill ( [ 'display_name' => __ ( 'voyager::seeders.settings.admin.description' ) , 'value' => __ ( 'voyager::seeders.settings.admin.description_value' ) , 'details' => '' , 'type' => 'text' , 'order' => 2 , 'group' => 'Admin' , ] ) -> save ( ) ; } $ setting = $ this -> findSetting ( 'admin.loader' ) ; if ( ! $ setting -> exists ) { $ setting -> fill ( [ 'display_name' => __ ( 'voyager::seeders.settings.admin.loader' ) , 'value' => '' , 'details' => '' , 'type' => 'image' , 'order' => 3 , 'group' => 'Admin' , ] ) -> save ( ) ; } $ setting = $ this -> findSetting ( 'admin.icon_image' ) ; if ( ! $ setting -> exists ) { $ setting -> fill ( [ 'display_name' => __ ( 'voyager::seeders.settings.admin.icon_image' ) , 'value' => '' , 'details' => '' , 'type' => 'image' , 'order' => 4 , 'group' => 'Admin' , ] ) -> save ( ) ; } $ setting = $ this -> findSetting ( 'admin.google_analytics_client_id' ) ; if ( ! $ setting -> exists ) { $ setting -> fill ( [ 'display_name' => __ ( 'voyager::seeders.settings.admin.google_analytics_client_id' ) , 'value' => '' , 'details' => '' , 'type' => 'text' , 'order' => 1 , 'group' => 'Admin' , ] ) -> save ( ) ; } } 
public function up ( ) { Schema :: table ( 'users' , function ( $ table ) { if ( ! Schema :: hasColumn ( 'users' , 'avatar' ) ) { $ table -> string ( 'avatar' ) -> nullable ( ) -> after ( 'email' ) -> default ( 'users/default.png' ) ; } $ table -> bigInteger ( 'role_id' ) -> nullable ( ) -> after ( 'id' ) ; } ) ; } 
public function handle ( BreadAdded $ bread ) { if ( config ( 'voyager.bread.add_permission' ) && file_exists ( base_path ( 'routes/web.php' ) ) ) { 
public function register ( ) { $ this -> app -> register ( VoyagerEventServiceProvider :: class ) ; $ this -> app -> register ( ImageServiceProvider :: class ) ; $ this -> app -> register ( VoyagerDummyServiceProvider :: class ) ; $ this -> app -> register ( VoyagerHooksServiceProvider :: class ) ; $ this -> app -> register ( DoctrineSupportServiceProvider :: class ) ; $ loader = AliasLoader :: getInstance ( ) ; $ loader -> alias ( 'Voyager' , VoyagerFacade :: class ) ; $ this -> app -> singleton ( 'voyager' , function ( ) { return new Voyager ( ) ; } ) ; $ this -> app -> singleton ( 'VoyagerAuth' , function ( ) { return auth ( ) ; } ) ; $ this -> loadHelpers ( ) ; $ this -> registerAlertComponents ( ) ; $ this -> registerFormFields ( ) ; $ this -> registerConfigs ( ) ; if ( $ this -> app -> runningInConsole ( ) ) { $ this -> registerPublishableResources ( ) ; $ this -> registerConsoleCommands ( ) ; } if ( ! $ this -> app -> runningInConsole ( ) || config ( 'app.env' ) == 'testing' ) { $ this -> registerAppCommands ( ) ; } } 
public function boot ( Router $ router , Dispatcher $ event ) { if ( config ( 'voyager.user.add_default_role_on_register' ) ) { $ app_user = config ( 'voyager.user.namespace' ) ? : config ( 'auth.providers.users.model' ) ; $ app_user :: created ( function ( $ user ) { if ( is_null ( $ user -> role_id ) ) { VoyagerFacade :: model ( 'User' ) -> findOrFail ( $ user -> id ) -> setRole ( config ( 'voyager.user.default_role' ) ) -> save ( ) ; } } ) ; } $ this -> loadViewsFrom ( __DIR__ . '/../resources/views' , 'voyager' ) ; $ router -> aliasMiddleware ( 'admin.user' , VoyagerAdminMiddleware :: class ) ; $ this -> loadTranslationsFrom ( realpath ( __DIR__ . '/../publishable/lang' ) , 'voyager' ) ; if ( config ( 'voyager.database.autoload_migrations' , true ) ) { if ( config ( 'app.env' ) == 'testing' ) { $ this -> loadMigrationsFrom ( realpath ( __DIR__ . '/migrations' ) ) ; } $ this -> loadMigrationsFrom ( realpath ( __DIR__ . '/../migrations' ) ) ; } $ this -> loadAuth ( ) ; $ this -> registerViewComposers ( ) ; $ event -> listen ( 'voyager.alerts.collecting' , function ( ) { $ this -> addStorageSymlinkAlert ( ) ; } ) ; $ this -> bootTranslatorCollectionMacros ( ) ; } 
protected function addStorageSymlinkAlert ( ) { if ( app ( 'router' ) -> current ( ) !== null ) { $ currentRouteAction = app ( 'router' ) -> current ( ) -> getAction ( ) ; } else { $ currentRouteAction = null ; } $ routeName = is_array ( $ currentRouteAction ) ? Arr :: get ( $ currentRouteAction , 'as' ) : null ; if ( $ routeName != 'voyager.dashboard' ) { return ; } $ storage_disk = ( ! empty ( config ( 'voyager.storage.disk' ) ) ) ? config ( 'voyager.storage.disk' ) : 'public' ; if ( request ( ) -> has ( 'fix-missing-storage-symlink' ) ) { if ( file_exists ( public_path ( 'storage' ) ) ) { if ( @ readlink ( public_path ( 'storage' ) ) == public_path ( 'storage' ) ) { rename ( public_path ( 'storage' ) , 'storage_old' ) ; } } if ( ! file_exists ( public_path ( 'storage' ) ) ) { $ this -> fixMissingStorageSymlink ( ) ; } } elseif ( $ storage_disk == 'public' ) { if ( ! file_exists ( public_path ( 'storage' ) ) || @ readlink ( public_path ( 'storage' ) ) == public_path ( 'storage' ) ) { $ alert = ( new Alert ( 'missing-storage-symlink' , 'warning' ) ) -> title ( __ ( 'voyager::error.symlink_missing_title' ) ) -> text ( __ ( 'voyager::error.symlink_missing_text' ) ) -> button ( __ ( 'voyager::error.symlink_missing_button' ) , '?fix-missing-storage-symlink=1' ) ; VoyagerFacade :: addAlert ( $ alert ) ; } } } 
private function registerConsoleCommands ( ) { $ this -> commands ( Commands \ InstallCommand :: class ) ; $ this -> commands ( Commands \ ControllersCommand :: class ) ; $ this -> commands ( Commands \ AdminCommand :: class ) ; } 
public function index ( Request $ request ) { 
public function show ( Request $ request , $ id ) { $ slug = $ this -> getSlug ( $ request ) ; $ dataType = Voyager :: model ( 'DataType' ) -> where ( 'slug' , '=' , $ slug ) -> first ( ) ; $ isSoftDeleted = false ; if ( strlen ( $ dataType -> model_name ) != 0 ) { $ model = app ( $ dataType -> model_name ) ; 
public function edit ( Request $ request , $ id ) { $ slug = $ this -> getSlug ( $ request ) ; $ dataType = Voyager :: model ( 'DataType' ) -> where ( 'slug' , '=' , $ slug ) -> first ( ) ; if ( strlen ( $ dataType -> model_name ) != 0 ) { $ model = app ( $ dataType -> model_name ) ; 
public function update ( Request $ request , $ id ) { $ slug = $ this -> getSlug ( $ request ) ; $ dataType = Voyager :: model ( 'DataType' ) -> where ( 'slug' , '=' , $ slug ) -> first ( ) ; 
public function create ( Request $ request ) { $ slug = $ this -> getSlug ( $ request ) ; $ dataType = Voyager :: model ( 'DataType' ) -> where ( 'slug' , '=' , $ slug ) -> first ( ) ; 
public function store ( Request $ request ) { $ slug = $ this -> getSlug ( $ request ) ; $ dataType = Voyager :: model ( 'DataType' ) -> where ( 'slug' , '=' , $ slug ) -> first ( ) ; 
public function destroy ( Request $ request , $ id ) { $ slug = $ this -> getSlug ( $ request ) ; $ dataType = Voyager :: model ( 'DataType' ) -> where ( 'slug' , '=' , $ slug ) -> first ( ) ; 
protected function cleanup ( $ dataType , $ data ) { 
public function deleteBreadImages ( $ data , $ rows ) { foreach ( $ rows as $ row ) { if ( $ data -> { $ row -> field } != config ( 'voyager.user.default_avatar' ) ) { $ this -> deleteFileIfExists ( $ data -> { $ row -> field } ) ; } if ( isset ( $ row -> details -> thumbnails ) ) { foreach ( $ row -> details -> thumbnails as $ thumbnail ) { $ ext = explode ( '.' , $ data -> { $ row -> field } ) ; $ extension = '.' . $ ext [ count ( $ ext ) - 1 ] ; $ path = str_replace ( $ extension , '' , $ data -> { $ row -> field } ) ; $ thumb_name = $ thumbnail -> name ; $ this -> deleteFileIfExists ( $ path . '-' . $ thumb_name . $ extension ) ; } } } if ( $ rows -> count ( ) > 0 ) { event ( new BreadImagesDeleted ( $ data , $ rows ) ) ; } } 
public function order ( Request $ request ) { $ slug = $ this -> getSlug ( $ request ) ; $ dataType = Voyager :: model ( 'DataType' ) -> where ( 'slug' , '=' , $ slug ) -> first ( ) ; 
public function relation ( Request $ request ) { $ slug = $ this -> getSlug ( $ request ) ; $ page = $ request -> input ( 'page' ) ; $ on_page = 50 ; $ search = $ request -> input ( 'search' , false ) ; $ dataType = Voyager :: model ( 'DataType' ) -> where ( 'slug' , '=' , $ slug ) -> first ( ) ; foreach ( $ dataType -> editRows as $ key => $ row ) { if ( $ row -> field === $ request -> input ( 'type' ) ) { $ options = $ row -> details ; $ skip = $ on_page * ( $ page - 1 ) ; 
protected function resolveRelations ( $ dataTypeContent , DataType $ dataType ) { 
public function run ( ) { if ( User :: count ( ) == 0 ) { $ role = Role :: where ( 'name' , 'admin' ) -> firstOrFail ( ) ; User :: create ( [ 'name' => 'Admin' , 'email' => 'admin@admin.com' , 'password' => bcrypt ( 'password' ) , 'remember_token' => Str :: random ( 60 ) , 'role_id' => $ role -> id , ] ) ; } } 
public function up ( ) { 
protected function addSoftDelete ( & $ stub ) { $ traitIncl = $ trait = '' ; if ( $ this -> option ( 'softdelete' ) ) { $ traitIncl = 'use Illuminate\Database\Eloquent\SoftDeletes;' ; $ trait = 'use SoftDeletes;' ; } $ stub = str_replace ( '//DummySDTraitInclude' , $ traitIncl , $ stub ) ; $ stub = str_replace ( '//DummySDTrait' , $ trait , $ stub ) ; return $ this ; } 
public function validateBread ( $ request , $ data , $ name = null , $ id = null ) { $ rules = [ ] ; $ messages = [ ] ; $ customAttributes = [ ] ; $ is_update = $ name && $ id ; $ fieldsWithValidationRules = $ this -> getFieldsWithValidationRules ( $ data ) ; foreach ( $ fieldsWithValidationRules as $ field ) { $ fieldRules = $ field -> details -> validation -> rule ; $ fieldName = $ field -> field ; 
protected function getFieldsWithValidationRules ( $ fieldsConfig ) { return $ fieldsConfig -> filter ( function ( $ value ) { if ( empty ( $ value -> details ) ) { return false ; } return ! empty ( $ value -> details -> validation -> rule ) ; } ) ; } 
public function run ( ) { <h2>We can use all kinds of format!</h2> <p>And include a bunch of other stuff.</p>' , 'image' => 'posts/post2.jpg' , 'slug' => 'my-sample-post' , 'meta_description' => 'Meta Description for sample post' , 'meta_keywords' => 'keyword1, keyword2, keyword3' , 'status' => 'PUBLISHED' , 'featured' => 0 , ] ) -> save ( ) ; } $ post = $ this -> findPost ( 'latest-post' ) ; if ( ! $ post -> exists ) { $ post -> fill ( [ 'title' => 'Latest Post' , 'author_id' => 0 , 'seo_title' => null , 'excerpt' => 'This is the excerpt for the latest post' , 'body' => '<p>This is the body for the latest post</p>' , 'image' => 'posts/post3.jpg' , 'slug' => 'latest-post' , 'meta_description' => 'This is the meta description' , 'meta_keywords' => 'keyword1, keyword2, keyword3' , 'status' => 'PUBLISHED' , 'featured' => 0 , ] ) -> save ( ) ; } $ post = $ this -> findPost ( 'yarr-post' ) ; if ( ! $ post -> exists ) { $ post -> fill ( [ 'title' => 'Yarr Post' , 'author_id' => 0 , 'seo_title' => null , 'excerpt' => 'Reef sails nipperkin bring a spring upon her cable coffer jury mast spike marooned Pieces of Eight poop deck pillage. Clipper driver coxswain galleon hempen halter come about pressgang gangplank boatswain swing the lead. Nipperkin yard skysail swab lanyard Blimey bilge water ho quarter Buccaneer.' , 'body' => '<p>Swab deadlights Buccaneer fire ship square-rigged dance the hempen jig weigh anchor cackle fruit grog furl. Crack Jennys tea cup chase guns pressgang hearties spirits hogshead Gold Road six pounders fathom measured fer yer chains. Main sheet provost come about trysail barkadeer crimp scuttle mizzenmast brig plunder.</p> <p>Mizzen league keelhaul galleon tender cog chase Barbary Coast doubloon crack Jennys tea cup. Blow the man down lugsail fire ship pinnace cackle fruit line warp Admiral of the Black strike colors doubloon. Tackle Jack Ketch come about crimp rum draft scuppers run a shot across the bow haul wind maroon.</p> <p>Interloper heave down list driver pressgang holystone scuppers tackle scallywag bilged on her anchor. Jack Tar interloper draught grapple mizzenmast hulk knave cable transom hogshead. Gaff pillage to go on account grog aft chase guns piracy yardarm knave clap of thunder.</p>' , 'image' => 'posts/post4.jpg' , 'slug' => 'yarr-post' , 'meta_description' => 'this be a meta descript' , 'meta_keywords' => 'keyword1, keyword2, keyword3' , 'status' => 'PUBLISHED' , 'featured' => 0 , ] ) -> save ( ) ; } } 
public function revokeToken ( $ token ) { if ( is_array ( $ token ) ) { if ( isset ( $ token [ 'refresh_token' ] ) ) { $ token = $ token [ 'refresh_token' ] ; } else { $ token = $ token [ 'access_token' ] ; } } $ body = Psr7 \ stream_for ( http_build_query ( array ( 'token' => $ token ) ) ) ; $ request = new Request ( 'POST' , Google_Client :: OAUTH2_REVOKE_URI , [ 'Cache-Control' => 'no-store' , 'Content-Type' => 'application/x-www-form-urlencoded' , ] , $ body ) ; $ httpHandler = HttpHandlerFactory :: build ( $ this -> http ) ; $ response = $ httpHandler ( $ request ) ; return $ response -> getStatusCode ( ) == 200 ; } 
public function verifyIdToken ( $ idToken , $ audience = null ) { if ( empty ( $ idToken ) ) { throw new LogicException ( 'id_token cannot be null' ) ; } 
private function retrieveCertsFromLocation ( $ url ) { 
private function getFederatedSignOnCerts ( ) { $ certs = null ; if ( $ cache = $ this -> getCache ( ) ) { $ cacheItem = $ cache -> getItem ( 'federated_signon_certs_v3' ) ; $ certs = $ cacheItem -> get ( ) ; } if ( ! $ certs ) { $ certs = $ this -> retrieveCertsFromLocation ( self :: FEDERATED_SIGNON_CERT_URL ) ; if ( $ cache ) { $ cacheItem -> expiresAt ( new DateTime ( '+1 hour' ) ) ; $ cacheItem -> set ( $ certs ) ; $ cache -> save ( $ cacheItem ) ; } } if ( ! isset ( $ certs [ 'keys' ] ) ) { throw new InvalidArgumentException ( 'federated sign-on certs expects "keys" to be set' ) ; } return $ certs [ 'keys' ] ; } 
private function setPhpsecConstants ( ) { if ( filter_var ( getenv ( 'GAE_VM' ) , FILTER_VALIDATE_BOOLEAN ) ) { if ( ! defined ( 'MATH_BIGINTEGER_OPENSSL_ENABLED' ) ) { define ( 'MATH_BIGINTEGER_OPENSSL_ENABLED' , true ) ; } if ( ! defined ( 'CRYPT_RSA_MODE' ) ) { define ( 'CRYPT_RSA_MODE' , constant ( $ this -> getOpenSslConstant ( ) ) ) ; } } } 
public function call ( $ name , $ arguments , $ expectedClass = null ) { if ( ! isset ( $ this -> methods [ $ name ] ) ) { $ this -> client -> getLogger ( ) -> error ( 'Service method unknown' , array ( 'service' => $ this -> serviceName , 'resource' => $ this -> resourceName , 'method' => $ name ) ) ; throw new Google_Exception ( "Unknown function: " . "{$this->serviceName}->{$this->resourceName}->{$name}()" ) ; } $ method = $ this -> methods [ $ name ] ; $ parameters = $ arguments [ 0 ] ; 
public function createRequestUri ( $ restPath , $ params ) { 
public function fetchAccessTokenWithAuthCode ( $ code ) { if ( strlen ( $ code ) == 0 ) { throw new InvalidArgumentException ( "Invalid code" ) ; } $ auth = $ this -> getOAuth2Service ( ) ; $ auth -> setCode ( $ code ) ; $ auth -> setRedirectUri ( $ this -> getRedirectUri ( ) ) ; $ httpHandler = HttpHandlerFactory :: build ( $ this -> getHttpClient ( ) ) ; $ creds = $ auth -> fetchAuthToken ( $ httpHandler ) ; if ( $ creds && isset ( $ creds [ 'access_token' ] ) ) { $ creds [ 'created' ] = time ( ) ; $ this -> setAccessToken ( $ creds ) ; } return $ creds ; } 
public function fetchAccessTokenWithAssertion ( ClientInterface $ authHttp = null ) { if ( ! $ this -> isUsingApplicationDefaultCredentials ( ) ) { throw new DomainException ( 'set the JSON service account credentials using' . ' Google_Client::setAuthConfig or set the path to your JSON file' . ' with the "GOOGLE_APPLICATION_CREDENTIALS" environment variable' . ' and call Google_Client::useApplicationDefaultCredentials to' . ' refresh a token with assertion.' ) ; } $ this -> getLogger ( ) -> log ( 'info' , 'OAuth2 access token refresh with Signed JWT assertion grants.' ) ; $ credentials = $ this -> createApplicationDefaultCredentials ( ) ; $ httpHandler = HttpHandlerFactory :: build ( $ authHttp ) ; $ creds = $ credentials -> fetchAuthToken ( $ httpHandler ) ; if ( $ creds && isset ( $ creds [ 'access_token' ] ) ) { $ creds [ 'created' ] = time ( ) ; $ this -> setAccessToken ( $ creds ) ; } return $ creds ; } 
public function fetchAccessTokenWithRefreshToken ( $ refreshToken = null ) { if ( null === $ refreshToken ) { if ( ! isset ( $ this -> token [ 'refresh_token' ] ) ) { throw new LogicException ( 'refresh token must be passed in or set as part of setAccessToken' ) ; } $ refreshToken = $ this -> token [ 'refresh_token' ] ; } $ this -> getLogger ( ) -> info ( 'OAuth2 access token refresh' ) ; $ auth = $ this -> getOAuth2Service ( ) ; $ auth -> setRefreshToken ( $ refreshToken ) ; $ httpHandler = HttpHandlerFactory :: build ( $ this -> getHttpClient ( ) ) ; $ creds = $ auth -> fetchAuthToken ( $ httpHandler ) ; if ( $ creds && isset ( $ creds [ 'access_token' ] ) ) { $ creds [ 'created' ] = time ( ) ; if ( ! isset ( $ creds [ 'refresh_token' ] ) ) { $ creds [ 'refresh_token' ] = $ refreshToken ; } $ this -> setAccessToken ( $ creds ) ; } return $ creds ; } 
public function createAuthUrl ( $ scope = null ) { if ( empty ( $ scope ) ) { $ scope = $ this -> prepareScopes ( ) ; } if ( is_array ( $ scope ) ) { $ scope = implode ( ' ' , $ scope ) ; } 
public function authorize ( ClientInterface $ http = null ) { $ credentials = null ; $ token = null ; $ scopes = null ; if ( null === $ http ) { $ http = $ this -> getHttpClient ( ) ; } 
public function isAccessTokenExpired ( ) { if ( ! $ this -> token ) { return true ; } $ created = 0 ; if ( isset ( $ this -> token [ 'created' ] ) ) { $ created = $ this -> token [ 'created' ] ; } elseif ( isset ( $ this -> token [ 'id_token' ] ) ) { 
public function setRequestVisibleActions ( $ requestVisibleActions ) { if ( is_array ( $ requestVisibleActions ) ) { $ requestVisibleActions = implode ( " " , $ requestVisibleActions ) ; } $ this -> config [ 'request_visible_actions' ] = $ requestVisibleActions ; } 
public function revokeToken ( $ token = null ) { $ tokenRevoker = new Google_AccessToken_Revoke ( $ this -> getHttpClient ( ) ) ; return $ tokenRevoker -> revokeToken ( $ token ? : $ this -> getAccessToken ( ) ) ; } 
public function verifyIdToken ( $ idToken = null ) { $ tokenVerifier = new Google_AccessToken_Verify ( $ this -> getHttpClient ( ) , $ this -> getCache ( ) , $ this -> config [ 'jwt' ] ) ; if ( null === $ idToken ) { $ token = $ this -> getAccessToken ( ) ; if ( ! isset ( $ token [ 'id_token' ] ) ) { throw new LogicException ( 'id_token must be passed in or set as part of setAccessToken' ) ; } $ idToken = $ token [ 'id_token' ] ; } return $ tokenVerifier -> verifyIdToken ( $ idToken , $ this -> getClientId ( ) ) ; } 
public function addScope ( $ scope_or_scopes ) { if ( is_string ( $ scope_or_scopes ) && ! in_array ( $ scope_or_scopes , $ this -> requestedScopes ) ) { $ this -> requestedScopes [ ] = $ scope_or_scopes ; } else if ( is_array ( $ scope_or_scopes ) ) { foreach ( $ scope_or_scopes as $ scope ) { $ this -> addScope ( $ scope ) ; } } } 
public function execute ( RequestInterface $ request , $ expectedClass = null ) { $ request = $ request -> withHeader ( 'User-Agent' , $ this -> config [ 'application_name' ] . " " . self :: USER_AGENT_SUFFIX . $ this -> getLibraryVersion ( ) ) ; 
public function setAuthConfig ( $ config ) { if ( is_string ( $ config ) ) { if ( ! file_exists ( $ config ) ) { throw new InvalidArgumentException ( sprintf ( 'file "%s" does not exist' , $ config ) ) ; } $ json = file_get_contents ( $ config ) ; if ( ! $ config = json_decode ( $ json , true ) ) { throw new LogicException ( 'invalid json for auth config' ) ; } } $ key = isset ( $ config [ 'installed' ] ) ? 'installed' : 'web' ; if ( isset ( $ config [ 'type' ] ) && $ config [ 'type' ] == 'service_account' ) { 
protected function createOAuth2Service ( ) { $ auth = new OAuth2 ( [ 'clientId' => $ this -> getClientId ( ) , 'clientSecret' => $ this -> getClientSecret ( ) , 'authorizationUri' => self :: OAUTH2_AUTH_URL , 'tokenCredentialUri' => self :: OAUTH2_TOKEN_URI , 'redirectUri' => $ this -> getRedirectUri ( ) , 'issuer' => $ this -> config [ 'client_id' ] , 'signingKey' => $ this -> config [ 'signing_key' ] , 'signingAlgorithm' => $ this -> config [ 'signing_algorithm' ] , ] ) ; return $ auth ; } 
public function run ( ) { while ( $ this -> attempt ( ) ) { try { return call_user_func_array ( $ this -> action , $ this -> arguments ) ; } catch ( Google_Service_Exception $ exception ) { $ allowedRetries = $ this -> allowedRetries ( $ exception -> getCode ( ) , $ exception -> getErrors ( ) ) ; if ( ! $ this -> canAttempt ( ) || ! $ allowedRetries ) { throw $ exception ; } if ( $ allowedRetries > 0 ) { $ this -> maxAttempts = min ( $ this -> maxAttempts , $ this -> attempts + $ allowedRetries ) ; } } } } 
public function attempt ( ) { if ( ! $ this -> canAttempt ( ) ) { return false ; } if ( $ this -> attempts > 0 ) { $ this -> backOff ( ) ; } $ this -> attempts ++ ; return true ; } 
private function getDelay ( ) { $ jitter = $ this -> getJitter ( ) ; $ factor = $ this -> attempts > 1 ? $ this -> factor + $ jitter : 1 + abs ( $ jitter ) ; return $ this -> delay = min ( $ this -> maxDelay , $ this -> delay * $ factor ) ; } 
public function allowedRetries ( $ code , $ errors = array ( ) ) { if ( isset ( $ this -> retryMap [ $ code ] ) ) { return $ this -> retryMap [ $ code ] ; } if ( ! empty ( $ errors ) && isset ( $ errors [ 0 ] [ 'reason' ] , $ this -> retryMap [ $ errors [ 0 ] [ 'reason' ] ] ) ) { return $ this -> retryMap [ $ errors [ 0 ] [ 'reason' ] ] ; } return 0 ; } 
public function nextChunk ( $ chunk = false ) { $ resumeUri = $ this -> getResumeUri ( ) ; if ( false == $ chunk ) { $ chunk = substr ( $ this -> data , $ this -> progress , $ this -> chunkSize ) ; } $ lastBytePos = $ this -> progress + strlen ( $ chunk ) - 1 ; $ headers = array ( 'content-range' => "bytes $this->progress-$lastBytePos/$this->size" , 'content-length' => strlen ( $ chunk ) , 'expect' => '' , ) ; $ request = new Request ( 'PUT' , $ resumeUri , $ headers , Psr7 \ stream_for ( $ chunk ) ) ; return $ this -> makePutRequest ( $ request ) ; } 
private function makePutRequest ( RequestInterface $ request ) { $ response = $ this -> client -> execute ( $ request ) ; $ this -> httpResultCode = $ response -> getStatusCode ( ) ; if ( 308 == $ this -> httpResultCode ) { 
public function getUploadType ( $ meta ) { if ( $ this -> resumable ) { return self :: UPLOAD_RESUMABLE_TYPE ; } if ( false == $ meta && $ this -> data ) { return self :: UPLOAD_MEDIA_TYPE ; } return self :: UPLOAD_MULTIPART_TYPE ; } 
private function parseHttpResponse ( $ respData , $ headerSize ) { 
private function resolveNextSection ( $ string , $ parameters ) { $ start = strpos ( $ string , "{" ) ; if ( $ start === false ) { return $ string ; } $ end = strpos ( $ string , "}" ) ; if ( $ end === false ) { return $ string ; } $ string = $ this -> replace ( $ string , $ start , $ end , $ parameters ) ; return $ this -> resolveNextSection ( $ string , $ parameters ) ; } 
private function getDataType ( $ data ) { if ( is_array ( $ data ) ) { reset ( $ data ) ; if ( key ( $ data ) !== 0 ) { return self :: TYPE_MAP ; } return self :: TYPE_LIST ; } return self :: TYPE_SCALAR ; } 
private function combineList ( $ vars , $ sep , $ parameters , $ combine , $ reserved , $ tag_empty , $ combine_on_empty ) { $ ret = array ( ) ; foreach ( $ vars as $ var ) { $ response = $ this -> combine ( $ var , $ parameters , $ sep , $ combine , $ reserved , $ tag_empty , $ combine_on_empty ) ; if ( $ response === false ) { continue ; } $ ret [ ] = $ response ; } return implode ( $ sep , $ ret ) ; } 
private function getValue ( $ value , $ length ) { if ( $ length ) { $ value = substr ( $ value , 0 , $ length ) ; } $ value = rawurlencode ( $ value ) ; return $ value ; } 
public static function execute ( ClientInterface $ client , RequestInterface $ request , $ expectedClass = null , $ config = array ( ) , $ retryMap = null ) { $ runner = new Google_Task_Runner ( $ config , sprintf ( '%s %s' , $ request -> getMethod ( ) , ( string ) $ request -> getUri ( ) ) , array ( get_class ( ) , 'doExecute' ) , array ( $ client , $ request , $ expectedClass ) ) ; if ( null !== $ retryMap ) { $ runner -> setRetryMap ( $ retryMap ) ; } return $ runner -> run ( ) ; } 
public static function doExecute ( ClientInterface $ client , RequestInterface $ request , $ expectedClass = null ) { try { $ httpHandler = HttpHandlerFactory :: build ( $ client ) ; $ response = $ httpHandler ( $ request ) ; } catch ( RequestException $ e ) { 
public static function decodeHttpResponse ( ResponseInterface $ response , RequestInterface $ request = null , $ expectedClass = null ) { $ code = $ response -> getStatusCode ( ) ; 
protected function mapTypes ( $ array ) { 
public function toSimpleObject ( ) { $ object = new stdClass ( ) ; 
private function getSimpleValue ( $ value ) { if ( $ value instanceof Google_Model ) { return $ value -> toSimpleObject ( ) ; } else if ( is_array ( $ value ) ) { $ return = array ( ) ; foreach ( $ value as $ key => $ a_value ) { $ a_value = $ this -> getSimpleValue ( $ a_value ) ; if ( $ a_value !== null ) { $ key = $ this -> getMappedName ( $ key ) ; $ return [ $ key ] = $ this -> nullPlaceholderCheck ( $ a_value ) ; } } return $ return ; } return $ value ; } 
private function getMappedName ( $ key ) { if ( isset ( $ this -> internal_gapi_mappings , $ this -> internal_gapi_mappings [ $ key ] ) ) { $ key = $ this -> internal_gapi_mappings [ $ key ] ; } return $ key ; } 
protected function isAssociativeArray ( $ array ) { if ( ! is_array ( $ array ) ) { return false ; } $ keys = array_keys ( $ array ) ; foreach ( $ keys as $ key ) { if ( is_string ( $ key ) ) { return true ; } } return false ; } 
public static function build ( $ cache = null , array $ cacheConfig = [ ] ) { $ version = ClientInterface :: VERSION ; switch ( $ version [ 0 ] ) { case '5' : return new Google_AuthHandler_Guzzle5AuthHandler ( $ cache , $ cacheConfig ) ; case '6' : return new Google_AuthHandler_Guzzle6AuthHandler ( $ cache , $ cacheConfig ) ; default : throw new Exception ( 'Version not supported' ) ; } } 
public function find_config ( ) { $ config = $ this -> fix_win32_path ( $ this -> config ) ; if ( ! empty ( $ config ) && is_readable ( $ config ) ) { return $ config ; } if ( ! empty ( $ config ) && ! is_readable ( $ config ) ) { throw new ConfigException ( "User defined config not found at '$config'" ) ; } 
public function define_core_constants ( ) { * The following has an awful CRAP index and it would be much shorter reduced to something like * defining an array of ('YOURLS_SOMETHING' => 'default value') and then a simple loop over the * array, checking if $current is defined as a constant and otherwise define said constant with * its default value. I did not wrote it that way because that would make it difficult for code * parsers to identify which constants are defined and where. So, here it is, that long list of * if (!defined) define(). Ho and by the way, such beautiful comment, much right aligned, wow ! */ 
public function set_emulate_state ( ) { try { $ this -> is_emulate_prepare = $ this -> getAttribute ( PDO :: ATTR_EMULATE_PREPARES ) ; } catch ( \ PDOException $ e ) { $ this -> is_emulate_prepare = false ; } } 
public function dead_or_error ( \ Exception $ exception ) { 
public function get_queries ( ) { $ queries = $ this -> getProfiler ( ) -> getProfiles ( ) ; if ( $ this -> get_emulate_state ( ) ) { 
public function addProfile ( $ duration , $ function , $ statement , array $ bind_values = array ( ) ) { parent :: addProfile ( $ duration , $ function , $ statement , $ bind_values ) ; if ( $ function == 'connect' ) { $ this -> log ( sprintf ( 'SQL: CONNECT (%s s)' , number_format ( $ duration , 5 ) ) ) ; return ; } 
public function pretty_format ( $ statement , array $ values = array ( ) ) { if ( ! $ values ) { return $ statement ; } return preg_replace_callback ( '/:([^\s;)]*)/' , function ( $ matches ) use ( $ values ) { $ replacement = isset ( $ values [ $ matches [ 1 ] ] ) ? $ values [ $ matches [ 1 ] ] : '' ; if ( is_array ( $ replacement ) ) { $ replacement = implode ( "," , $ replacement ) ; } return "'$replacement'" ; } , $ statement ) ; } 
function array2xml ( $ array ) { 
function xml2array ( $ xml ) { $ this -> depth = - 1 ; $ this -> xml_parser = xml_parser_create ( ) ; xml_set_object ( $ this -> xml_parser , $ this ) ; xml_parser_set_option ( $ this -> xml_parser , XML_OPTION_CASE_FOLDING , 0 ) ; 
function init ( ) { 
function register_globals ( ) { $ GLOBALS [ 'weekday' ] = $ this -> weekday ; $ GLOBALS [ 'weekday_initial' ] = $ this -> weekday_initial ; $ GLOBALS [ 'weekday_abbrev' ] = $ this -> weekday_abbrev ; $ GLOBALS [ 'month' ] = $ this -> month ; $ GLOBALS [ 'month_abbrev' ] = $ this -> month_abbrev ; } 
public function get_all_options ( ) { 
public function get ( $ name , $ default ) { $ name = trim ( ( string ) $ name ) ; if ( empty ( $ name ) ) { return $ default ; } * We don't cache value if option is not set, to make a difference between "not found: returning false" * and "found, and value is false". * This way, we can: * $check = yourls_get_option('doesnt_exist'); // false * yourls_add_option('doesnt_exist', 'value'); */ return $ value ; } 
public function update ( $ name , $ newvalue ) { $ name = trim ( ( string ) $ name ) ; if ( empty ( $ name ) ) { return false ; } 
public function add ( $ name , $ value ) { $ name = trim ( ( string ) $ name ) ; if ( empty ( $ name ) ) { return false ; } 
public function delete ( $ name ) { $ name = trim ( ( string ) $ name ) ; if ( empty ( $ name ) ) { return false ; } $ table = YOURLS_DB_TABLE_OPTIONS ; $ sql = "DELETE FROM $table WHERE option_name = :name" ; $ bind = array ( 'name' => $ name ) ; $ do = $ this -> ydb -> fetchAffected ( $ sql , $ bind ) ; if ( $ do !== 1 ) { 
public function addPlaceholder ( $ placeholder , string $ pattern = null ) : RouteCollectionInterface { if ( ! is_array ( $ placeholder ) ) { $ placeholder = [ $ placeholder => $ pattern ] ; } $ this -> placeholders = array_merge ( $ this -> placeholders , $ placeholder ) ; return $ this ; } 
public function setDefaultNamespace ( string $ value ) : RouteCollectionInterface { $ this -> defaultNamespace = filter_var ( $ value , FILTER_SANITIZE_STRING ) ; $ this -> defaultNamespace = rtrim ( $ this -> defaultNamespace , '\\' ) . '\\' ; return $ this ; } 
public function setDefaultController ( string $ value ) : RouteCollectionInterface { $ this -> defaultController = filter_var ( $ value , FILTER_SANITIZE_STRING ) ; return $ this ; } 
public function setDefaultMethod ( string $ value ) : RouteCollectionInterface { $ this -> defaultMethod = filter_var ( $ value , FILTER_SANITIZE_STRING ) ; return $ this ; } 
protected function discoverRoutes ( ) { if ( $ this -> didDiscover ) { return ; } 
public function setDefaultConstraint ( string $ placeholder ) : RouteCollectionInterface { if ( array_key_exists ( $ placeholder , $ this -> placeholders ) ) { $ this -> defaultPlaceholder = $ placeholder ; } return $ this ; } 
public function getRoutes ( $ verb = null ) : array { if ( empty ( $ verb ) ) { $ verb = $ this -> getHTTPVerb ( ) ; } 
public function getRoutesOptions ( string $ from = null ) : array { return $ from ? $ this -> routesOptions [ $ from ] ?? [ ] : $ this -> routesOptions ; } 
public function map ( array $ routes = [ ] , array $ options = null ) : RouteCollectionInterface { foreach ( $ routes as $ from => $ to ) { $ this -> add ( $ from , $ to , $ options ) ; } return $ this ; } 
public function addRedirect ( string $ from , string $ to , int $ status = 302 ) { 
public function isRedirect ( string $ from ) : bool { foreach ( $ this -> routes [ '*' ] as $ name => $ route ) { 
public function getRedirectCode ( string $ from ) : int { foreach ( $ this -> routes [ '*' ] as $ name => $ route ) { 
public function group ( string $ name , ... $ params ) { $ oldGroup = $ this -> group ; $ oldOptions = $ this -> currentOptions ; 
public function resource ( string $ name , array $ options = null ) : RouteCollectionInterface { 
public function match ( array $ verbs = [ ] , string $ from , $ to , array $ options = null ) : RouteCollectionInterface { foreach ( $ verbs as $ verb ) { $ verb = strtolower ( $ verb ) ; $ this -> { $ verb } ( $ from , $ to , $ options ) ; } return $ this ; } 
public function options ( string $ from , $ to , array $ options = null ) : RouteCollectionInterface { $ this -> create ( 'options' , $ from , $ to , $ options ) ; return $ this ; } 
public function environment ( string $ env , \ Closure $ callback ) : RouteCollectionInterface { if ( ENVIRONMENT === $ env ) { $ callback ( $ this ) ; } return $ this ; } 
public function reverseRoute ( string $ search , ... $ params ) { 
public function getFilterForRoute ( string $ search ) : string { if ( ! $ this -> isFiltered ( $ search ) ) { return '' ; } return $ this -> routesOptions [ $ search ] [ 'filter' ] ; } 
protected function fillRouteParams ( string $ from , array $ params = null ) : string { 
protected function create ( string $ verb , string $ from , $ to , array $ options = null ) { $ overwrite = false ; $ prefix = is_null ( $ this -> group ) ? '' : $ this -> group . '/' ; $ from = filter_var ( $ prefix . $ from , FILTER_SANITIZE_STRING ) ; 
private function checkSubdomains ( $ subdomains ) : bool { 
private function determineCurrentSubdomain ( ) { 
public function resetRoutes ( ) { $ this -> routes = [ '*' => [ ] ] ; foreach ( $ this -> defaultHTTPMethods as $ verb ) { $ this -> routes [ $ verb ] = [ ] ; } } 
public function exceptionHandler ( Throwable $ exception ) { $ codes = $ this -> determineCodes ( $ exception ) ; $ statusCode = $ codes [ 0 ] ; $ exitCode = $ codes [ 1 ] ; 
public function errorHandler ( int $ severity , string $ message , string $ file = null , int $ line = null , $ context = null ) { if ( ! ( error_reporting ( ) & $ severity ) ) { return ; } 
public function shutdownHandler ( ) { $ error = error_get_last ( ) ; 
protected function determineView ( Throwable $ exception , string $ template_path ) : string { 
protected function render ( Throwable $ exception , int $ statusCode ) { 
protected function collectVars ( Throwable $ exception , int $ statusCode ) : array { return [ 'title' => get_class ( $ exception ) , 'type' => get_class ( $ exception ) , 'code' => $ statusCode , 'message' => $ exception -> getMessage ( ) ?? '(null)' , 'file' => $ exception -> getFile ( ) , 'line' => $ exception -> getLine ( ) , 'trace' => $ exception -> getTrace ( ) , ] ; } 
protected function determineCodes ( Throwable $ exception ) : array { $ statusCode = abs ( $ exception -> getCode ( ) ) ; if ( $ statusCode < 100 || $ statusCode > 599 ) { $ exitStatus = $ statusCode + EXIT__AUTO_MIN ; 
public static function describeMemory ( int $ bytes ) : string { if ( $ bytes < 1024 ) { return $ bytes . 'B' ; } else if ( $ bytes < 1048576 ) { return round ( $ bytes / 1024 , 2 ) . 'KB' ; } return round ( $ bytes / 1048576 , 2 ) . 'MB' ; } 
public static function highlightFile ( string $ file , int $ lineNumber , int $ lines = 15 ) { if ( empty ( $ file ) || ! is_readable ( $ file ) ) { return false ; } 
public function open ( $ save_path , $ name ) : bool { $ this -> memcached = new \ Memcached ( ) ; $ this -> memcached -> setOption ( \ Memcached :: OPT_BINARY_PROTOCOL , true ) ; 
public function read ( $ sessionID ) : string { if ( isset ( $ this -> memcached ) && $ this -> lockSession ( $ sessionID ) ) { 
public function write ( $ sessionID , $ sessionData ) : bool { if ( ! isset ( $ this -> memcached ) ) { return false ; } 
public function close ( ) : bool { if ( isset ( $ this -> memcached ) ) { isset ( $ this -> lockKey ) && $ this -> memcached -> delete ( $ this -> lockKey ) ; if ( ! $ this -> memcached -> quit ( ) ) { return false ; } $ this -> memcached = null ; return true ; } return false ; } 
public function destroy ( $ session_id ) : bool { if ( isset ( $ this -> memcached , $ this -> lockKey ) ) { $ this -> memcached -> delete ( $ this -> keyPrefix . $ session_id ) ; return $ this -> destroyCookie ( ) ; } return false ; } 
protected function lockSession ( string $ sessionID ) : bool { if ( isset ( $ this -> lockKey ) ) { return $ this -> memcached -> replace ( $ this -> lockKey , time ( ) , 300 ) ; } 
protected function releaseLock ( ) : bool { if ( isset ( $ this -> memcached , $ this -> lockKey ) && $ this -> lock ) { if ( ! $ this -> memcached -> delete ( $ this -> lockKey ) && $ this -> memcached -> getResultCode ( ) !== \ Memcached :: RES_NOTFOUND ) { $ this -> logger -> error ( 'Session: Error while trying to free lock for ' . $ this -> lockKey ) ; return false ; } $ this -> lockKey = null ; $ this -> lock = false ; } return true ; } 
public function alpha_space ( string $ value = null ) : bool { if ( $ value === null ) { return true ; } return ( bool ) preg_match ( '/^[A-Z ]+$/i' , $ value ) ; } 
public function regex_match ( string $ str = null , string $ pattern , array $ data ) : bool { if ( strpos ( $ pattern , '/' ) !== 0 ) { $ pattern = "/{$pattern}/" ; } return ( bool ) preg_match ( $ pattern , $ str ) ; } 
public function valid_email ( string $ str = null ) : bool { if ( function_exists ( 'idn_to_ascii' ) && defined ( 'INTL_IDNA_VARIANT_UTS46' ) && preg_match ( '#\A([^@]+)@(.+)\z#' , $ str , $ matches ) ) { $ str = $ matches [ 1 ] . '@' . idn_to_ascii ( $ matches [ 2 ] , 0 , INTL_IDNA_VARIANT_UTS46 ) ; } return ( bool ) filter_var ( $ str , FILTER_VALIDATE_EMAIL ) ; } 
public function valid_emails ( string $ str = null ) : bool { foreach ( explode ( ',' , $ str ) as $ email ) { $ email = trim ( $ email ) ; if ( $ email === '' ) { return false ; } if ( $ this -> valid_email ( $ email ) === false ) { return false ; } } return true ; } 
public function valid_ip ( string $ ip = null , string $ which = null , array $ data ) : bool { switch ( strtolower ( $ which ) ) { case 'ipv4' : $ which = FILTER_FLAG_IPV4 ; break ; case 'ipv6' : $ which = FILTER_FLAG_IPV6 ; break ; default : $ which = null ; break ; } return ( bool ) filter_var ( $ ip , FILTER_VALIDATE_IP , $ which ) ; } 
public function valid_url ( string $ str = null ) : bool { if ( empty ( $ str ) ) { return false ; } elseif ( preg_match ( '/^(?:([^:]*)\:)?\/\/(.+)$/' , $ str , $ matches ) ) { if ( ! in_array ( $ matches [ 1 ] , [ 'http' , 'https' ] , true ) ) { return false ; } $ str = $ matches [ 2 ] ; } $ str = 'http://' . $ str ; return ( filter_var ( $ str , FILTER_VALIDATE_URL ) !== false ) ; } 
public function valid_date ( string $ str = null , string $ format = null ) : bool { if ( empty ( $ format ) ) { return ( bool ) strtotime ( $ str ) ; } $ date = \ DateTime :: createFromFormat ( $ format , $ str ) ; return ( bool ) $ date && \ DateTime :: getLastErrors ( ) [ 'warning_count' ] === 0 && \ DateTime :: getLastErrors ( ) [ 'error_count' ] === 0 ; } 
public function dropDatabase ( string $ db_name ) : bool { 
protected function _alterTable ( string $ alter_type , string $ table , $ field ) { switch ( $ alter_type ) { case 'DROP' : $ sqlTable = new Table ( $ this -> db , $ this ) ; $ sqlTable -> fromTable ( $ table ) -> dropColumn ( $ field ) -> run ( ) ; return '' ; break ; case 'CHANGE' : $ sqlTable = new Table ( $ this -> db , $ this ) ; $ sqlTable -> fromTable ( $ table ) -> modifyColumn ( $ field ) -> run ( ) ; return null ; break ; default : return parent :: _alterTable ( $ alter_type , $ table , $ field ) ; } } 
protected function _processColumn ( array $ field ) : string { if ( $ field [ 'type' ] === 'TEXT' && strpos ( $ field [ 'length' ] , "('" ) === 0 ) { $ field [ 'type' ] .= ' CHECK(' . $ this -> db -> escapeIdentifiers ( $ field [ 'name' ] ) . ' IN ' . $ field [ 'length' ] . ')' ; } return $ this -> db -> escapeIdentifiers ( $ field [ 'name' ] ) . ' ' . $ field [ 'type' ] . $ field [ 'auto_increment' ] . $ field [ 'null' ] . $ field [ 'unique' ] . $ field [ 'default' ] ; } 
protected function _attributeAutoIncrement ( array & $ attributes , array & $ field ) { if ( ! empty ( $ attributes [ 'AUTO_INCREMENT' ] ) && $ attributes [ 'AUTO_INCREMENT' ] === true && stripos ( $ field [ 'type' ] , 'int' ) !== false ) { $ field [ 'type' ] = 'INTEGER PRIMARY KEY' ; $ field [ 'default' ] = '' ; $ field [ 'null' ] = '' ; $ field [ 'unique' ] = '' ; $ field [ 'auto_increment' ] = ' AUTOINCREMENT' ; $ this -> primaryKeys = [ ] ; } } 
public function _prepare ( string $ sql , array $ options = [ ] ) { 
public function _execute ( array $ data ) : bool { if ( is_null ( $ this -> statement ) ) { throw new \ BadMethodCallException ( 'You must call prepare before trying to execute a prepared statement.' ) ; } 
public static function forMoveFailed ( string $ source , string $ target , string $ error ) { return new static ( lang ( 'HTTP.moveFailed' , [ $ source , $ target , $ error ] ) ) ; } 
public function valid_cc_number ( string $ ccNumber = null , string $ type , array $ data ) : bool { $ type = strtolower ( $ type ) ; $ info = null ; 
protected function isValidLuhn ( string $ number = null ) : bool { settype ( $ number , 'string' ) ; $ sumTable = [ [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , ] , [ 0 , 2 , 4 , 6 , 8 , 1 , 3 , 5 , 7 , 9 , ] , ] ; $ sum = 0 ; $ flip = 0 ; for ( $ i = strlen ( $ number ) - 1 ; $ i >= 0 ; $ i -- ) { $ sum += $ sumTable [ $ flip ++ & 0x1 ] [ $ number [ $ i ] ] ; } return $ sum % 10 === 0 ; } 
protected static function moveFile ( string $ source , string $ destination ) : bool { $ source = realpath ( $ source ) ; if ( empty ( $ source ) ) { die ( 'Cannot move file. Source path invalid.' ) ; } if ( ! is_file ( $ source ) ) { return false ; } return copy ( $ source , $ destination ) ; } 
public static function moveEscaper ( ) { if ( class_exists ( '\\Zend\\Escaper\\Escaper' ) && is_file ( static :: getClassFilePath ( '\\Zend\\Escaper\\Escaper' ) ) ) { $ base = basename ( __DIR__ ) . '/' . static :: $ basePath . 'ZendEscaper' ; foreach ( [ $ base , $ base . '/Exception' ] as $ path ) { if ( ! is_dir ( $ path ) ) { mkdir ( $ path , 0755 ) ; } } $ files = [ static :: getClassFilePath ( '\\Zend\\Escaper\\Exception\\ExceptionInterface' ) => $ base . '/Exception/ExceptionInterface.php' , static :: getClassFilePath ( '\\Zend\\Escaper\\Exception\\InvalidArgumentException' ) => $ base . '/Exception/InvalidArgumentException.php' , static :: getClassFilePath ( '\\Zend\\Escaper\\Exception\\RuntimeException' ) => $ base . '/Exception/RuntimeException.php' , static :: getClassFilePath ( '\\Zend\\Escaper\\Escaper' ) => $ base . '/Escaper.php' , ] ; foreach ( $ files as $ source => $ dest ) { if ( ! static :: moveFile ( $ source , $ dest ) ) { die ( 'Error moving: ' . $ source ) ; } } } } 
public static function moveKint ( ) { $ filename = 'vendor/kint-php/kint/build/kint-aante-light.php' ; if ( is_file ( $ filename ) ) { $ base = basename ( __DIR__ ) . '/' . static :: $ basePath . 'Kint' ; 
public function start ( ) { if ( is_cli ( ) && ENVIRONMENT !== 'testing' ) { $ this -> logger -> debug ( 'Session: Initialization under CLI aborted.' ) ; return ; } elseif ( ( bool ) ini_get ( 'session.auto_start' ) ) { $ this -> logger -> error ( 'Session: session.auto_start is enabled in php.ini. Aborting.' ) ; return ; } elseif ( session_status ( ) === PHP_SESSION_ACTIVE ) { $ this -> logger -> warning ( 'Session: Sessions is enabled, and one exists.Please don\'t $session->start();' ) ; return ; } if ( ! $ this -> driver instanceof \ SessionHandlerInterface ) { $ this -> logger -> error ( "Session: Handler '" . $ this -> driver . "' doesn't implement SessionHandlerInterface. Aborting." ) ; } $ this -> configure ( ) ; $ this -> setSaveHandler ( ) ; // Sanitize the cookie, because apparently PHP doesn't do that for userspace handlers if ( isset ( $ _COOKIE [ $ this -> sessionCookieName ] ) && ( ! is_string ( $ _COOKIE [ $ this -> sessionCookieName ] ) || ! preg_match ( '#\A' . $ this -> sidRegexp . '\z#' , $ _COOKIE [ $ this -> sessionCookieName ] ) ) ) { unset ( $ _COOKIE [ $ this -> sessionCookieName ] ) ; } $ this -> startSession ( ) ; // Is session ID auto-regeneration configured? (ignoring ajax requests) if ( ( empty ( $ _SERVER [ 'HTTP_X_REQUESTED_WITH' ] ) || strtolower ( $ _SERVER [ 'HTTP_X_REQUESTED_WITH' ] ) !== 'xmlhttprequest' ) && ( $ regenerate_time = $ this -> sessionTimeToUpdate ) > 0 ) { if ( ! isset ( $ _SESSION [ '__ci_last_regenerate' ] ) ) { $ _SESSION [ '__ci_last_regenerate' ] = time ( ) ; } elseif ( $ _SESSION [ '__ci_last_regenerate' ] < ( time ( ) - $ regenerate_time ) ) { $ this -> regenerate ( ( bool ) $ this -> sessionRegenerateDestroy ) ; } } // Another work-around ... PHP doesn't seem to send the session cookie // unless it is being currently created or regenerated elseif ( isset ( $ _COOKIE [ $ this -> sessionCookieName ] ) && $ _COOKIE [ $ this -> sessionCookieName ] === session_id ( ) ) { $ this -> setCookie ( ) ; } $ this -> initVars ( ) ; $ this -> logger -> info ( "Session: Class initialized using '" . $ this -> sessionDriverName . "' driver." ) ; return $ this ; } 
public function stop ( ) { setcookie ( $ this -> sessionCookieName , session_id ( ) , 1 , $ this -> cookiePath , $ this -> cookieDomain , $ this -> cookieSecure , true ) ; session_regenerate_id ( true ) ; } 
protected function configure ( ) { if ( empty ( $ this -> sessionCookieName ) ) { $ this -> sessionCookieName = ini_get ( 'session.name' ) ; } else { ini_set ( 'session.name' , $ this -> sessionCookieName ) ; } session_set_cookie_params ( $ this -> sessionExpiration , $ this -> cookiePath , $ this -> cookieDomain , $ this -> cookieSecure , true 
protected function configureSidLength ( ) { $ bits_per_character = ( int ) ( ini_get ( 'session.sid_bits_per_character' ) !== false ? ini_get ( 'session.sid_bits_per_character' ) : 4 ) ; $ sid_length = ( int ) ( ini_get ( 'session.sid_length' ) !== false ? ini_get ( 'session.sid_length' ) : 40 ) ; if ( ( $ sid_length * $ bits_per_character ) < 160 ) { $ bits = ( $ sid_length * $ bits_per_character ) ; 
protected function initVars ( ) { if ( empty ( $ _SESSION [ '__ci_vars' ] ) ) { return ; } $ current_time = time ( ) ; foreach ( $ _SESSION [ '__ci_vars' ] as $ key => & $ value ) { if ( $ value === 'new' ) { $ _SESSION [ '__ci_vars' ] [ $ key ] = 'old' ; } 
public function set ( $ data , $ value = null ) { if ( is_array ( $ data ) ) { foreach ( $ data as $ key => & $ value ) { if ( is_int ( $ key ) ) { $ _SESSION [ $ value ] = null ; } else { $ _SESSION [ $ key ] = $ value ; } } return ; } $ _SESSION [ $ data ] = $ value ; } 
public function get ( string $ key = null ) { if ( ! empty ( $ key ) && $ value = dot_array_search ( $ key , $ _SESSION ) ) { return $ value ; } elseif ( empty ( $ _SESSION ) ) { return [ ] ; } if ( ! empty ( $ key ) ) { return null ; } $ userdata = [ ] ; $ _exclude = array_merge ( [ '__ci_vars' ] , $ this -> getFlashKeys ( ) , $ this -> getTempKeys ( ) ) ; $ keys = array_keys ( $ _SESSION ) ; foreach ( $ keys as $ key ) { if ( ! in_array ( $ key , $ _exclude , true ) ) { $ userdata [ $ key ] = $ _SESSION [ $ key ] ; } } return $ userdata ; } 
public function push ( string $ key , array $ data ) { if ( $ this -> has ( $ key ) && is_array ( $ value = $ this -> get ( $ key ) ) ) { $ this -> set ( $ key , array_merge ( $ value , $ data ) ) ; } } 
public function remove ( $ key ) { if ( is_array ( $ key ) ) { foreach ( $ key as $ k ) { unset ( $ _SESSION [ $ k ] ) ; } return ; } unset ( $ _SESSION [ $ key ] ) ; } 
public function setFlashdata ( $ data , $ value = null ) { $ this -> set ( $ data , $ value ) ; $ this -> markAsFlashdata ( is_array ( $ data ) ? array_keys ( $ data ) : $ data ) ; } 
public function getFlashdata ( string $ key = null ) { if ( isset ( $ key ) ) { return ( isset ( $ _SESSION [ '__ci_vars' ] , $ _SESSION [ '__ci_vars' ] [ $ key ] , $ _SESSION [ $ key ] ) && ! is_int ( $ _SESSION [ '__ci_vars' ] [ $ key ] ) ) ? $ _SESSION [ $ key ] : null ; } $ flashdata = [ ] ; if ( ! empty ( $ _SESSION [ '__ci_vars' ] ) ) { foreach ( $ _SESSION [ '__ci_vars' ] as $ key => & $ value ) { is_int ( $ value ) || $ flashdata [ $ key ] = $ _SESSION [ $ key ] ; } } return $ flashdata ; } 
public function markAsFlashdata ( $ key ) : bool { if ( is_array ( $ key ) ) { for ( $ i = 0 , $ c = count ( $ key ) ; $ i < $ c ; $ i ++ ) { if ( ! isset ( $ _SESSION [ $ key [ $ i ] ] ) ) { return false ; } } $ new = array_fill_keys ( $ key , 'new' ) ; $ _SESSION [ '__ci_vars' ] = isset ( $ _SESSION [ '__ci_vars' ] ) ? array_merge ( $ _SESSION [ '__ci_vars' ] , $ new ) : $ new ; return true ; } if ( ! isset ( $ _SESSION [ $ key ] ) ) { return false ; } $ _SESSION [ '__ci_vars' ] [ $ key ] = 'new' ; return true ; } 
public function getFlashKeys ( ) : array { if ( ! isset ( $ _SESSION [ '__ci_vars' ] ) ) { return [ ] ; } $ keys = [ ] ; foreach ( array_keys ( $ _SESSION [ '__ci_vars' ] ) as $ key ) { is_int ( $ _SESSION [ '__ci_vars' ] [ $ key ] ) || $ keys [ ] = $ key ; } return $ keys ; } 
public function setTempdata ( $ data , $ value = null , int $ ttl = 300 ) { $ this -> set ( $ data , $ value ) ; $ this -> markAsTempdata ( $ data , $ ttl ) ; } 
public function getTempdata ( string $ key = null ) { if ( isset ( $ key ) ) { return ( isset ( $ _SESSION [ '__ci_vars' ] , $ _SESSION [ '__ci_vars' ] [ $ key ] , $ _SESSION [ $ key ] ) && is_int ( $ _SESSION [ '__ci_vars' ] [ $ key ] ) ) ? $ _SESSION [ $ key ] : null ; } $ tempdata = [ ] ; if ( ! empty ( $ _SESSION [ '__ci_vars' ] ) ) { foreach ( $ _SESSION [ '__ci_vars' ] as $ key => & $ value ) { is_int ( $ value ) && $ tempdata [ $ key ] = $ _SESSION [ $ key ] ; } } return $ tempdata ; } 
public function markAsTempdata ( $ key , int $ ttl = 300 ) : bool { $ ttl += time ( ) ; if ( is_array ( $ key ) ) { $ temp = [ ] ; foreach ( $ key as $ k => $ v ) { 
public function unmarkTempdata ( $ key ) { if ( empty ( $ _SESSION [ '__ci_vars' ] ) ) { return ; } is_array ( $ key ) || $ key = [ $ key ] ; foreach ( $ key as $ k ) { if ( isset ( $ _SESSION [ '__ci_vars' ] [ $ k ] ) && is_int ( $ _SESSION [ '__ci_vars' ] [ $ k ] ) ) { unset ( $ _SESSION [ '__ci_vars' ] [ $ k ] ) ; } } if ( empty ( $ _SESSION [ '__ci_vars' ] ) ) { unset ( $ _SESSION [ '__ci_vars' ] ) ; } } 
public function getTempKeys ( ) : array { if ( ! isset ( $ _SESSION [ '__ci_vars' ] ) ) { return [ ] ; } $ keys = [ ] ; foreach ( array_keys ( $ _SESSION [ '__ci_vars' ] ) as $ key ) { is_int ( $ _SESSION [ '__ci_vars' ] [ $ key ] ) && $ keys [ ] = $ key ; } return $ keys ; } 
protected function setCookie ( ) { setcookie ( $ this -> sessionCookieName , session_id ( ) , ( empty ( $ this -> sessionExpiration ) ? 0 : time ( ) + $ this -> sessionExpiration ) , $ this -> cookiePath , $ this -> cookieDomain , $ this -> cookieSecure , true ) ; } 
public function check ( string $ key , int $ capacity , int $ seconds , int $ cost = 1 ) : bool { $ tokenName = $ this -> prefix . $ key ; 
public static function guessTypeFromExtension ( string $ extension ) { $ extension = trim ( strtolower ( $ extension ) , '. ' ) ; if ( ! array_key_exists ( $ extension , static :: $ mimes ) ) { return null ; } return is_array ( static :: $ mimes [ $ extension ] ) ? static :: $ mimes [ $ extension ] [ 0 ] : static :: $ mimes [ $ extension ] ; } 
public static function guessExtensionFromType ( string $ type , ? string $ proposed_extension = null ) { $ type = trim ( strtolower ( $ type ) , '. ' ) ; $ proposed_extension = trim ( strtolower ( $ proposed_extension ) ) ; if ( ! is_null ( $ proposed_extension ) && array_key_exists ( $ proposed_extension , static :: $ mimes ) && in_array ( $ type , is_string ( static :: $ mimes [ $ proposed_extension ] ) ? [ static :: $ mimes [ $ proposed_extension ] ] : static :: $ mimes [ $ proposed_extension ] ) ) { return $ proposed_extension ; } foreach ( static :: $ mimes as $ ext => $ types ) { if ( is_string ( $ types ) && $ types === $ type ) { return $ ext ; } else if ( is_array ( $ types ) && in_array ( $ type , $ types ) ) { return $ ext ; } } return null ; } 
public function to ( string $ uri , int $ code = null , string $ method = 'auto' ) { 
public function route ( string $ route , array $ params = [ ] , int $ code = 302 , string $ method = 'auto' ) { $ routes = Services :: routes ( true ) ; $ route = $ routes -> reverseRoute ( $ route , ... $ params ) ; if ( ! $ route ) { throw HTTPException :: forInvalidRedirectRoute ( $ route ) ; } return $ this -> redirect ( base_url ( $ route ) , $ method , $ code ) ; } 
public function back ( int $ code = null , string $ method = 'auto' ) { $ this -> ensureSession ( ) ; return $ this -> redirect ( previous_url ( ) , $ method , $ code ) ; } 
public function withInput ( ) { $ session = $ this -> ensureSession ( ) ; $ input = [ 'get' => $ _GET ?? [ ] , 'post' => $ _POST ?? [ ] , ] ; $ session -> setFlashdata ( '_ci_old_input' , $ input ) ; 
public function with ( string $ key , $ message ) { $ session = $ this -> ensureSession ( ) ; $ session -> setFlashdata ( $ key , $ message ) ; return $ this ; } 
public function run ( string $ uri , string $ position = 'before' ) { $ this -> initialize ( strtolower ( $ uri ) ) ; foreach ( $ this -> filters [ $ position ] as $ alias => $ rules ) { if ( is_numeric ( $ alias ) && is_string ( $ rules ) ) { $ alias = $ rules ; } if ( ! array_key_exists ( $ alias , $ this -> config -> aliases ) ) { throw FilterException :: forNoAlias ( $ alias ) ; } $ class = new $ this -> config -> aliases [ $ alias ] ( ) ; if ( ! $ class instanceof FilterInterface ) { throw FilterException :: forIncorrectInterface ( get_class ( $ class ) ) ; } if ( $ position === 'before' ) { $ result = $ class -> before ( $ this -> request , $ this -> arguments [ $ alias ] ?? null ) ; if ( $ result instanceof RequestInterface ) { $ this -> request = $ result ; continue ; } 
public function initialize ( string $ uri = null ) { if ( $ this -> initialized === true ) { return $ this ; } $ this -> processGlobals ( $ uri ) ; $ this -> processMethods ( ) ; $ this -> processFilters ( $ uri ) ; $ this -> initialized = true ; return $ this ; } 
public function addFilter ( string $ class , string $ alias = null , string $ when = 'before' , string $ section = 'globals' ) { $ alias = $ alias ?? md5 ( $ class ) ; if ( ! isset ( $ this -> config -> { $ section } ) ) { $ this -> config -> { $ section } = [ ] ; } if ( ! isset ( $ this -> config -> { $ section } [ $ when ] ) ) { $ this -> config -> { $ section } [ $ when ] = [ ] ; } $ this -> config -> aliases [ $ alias ] = $ class ; $ this -> config -> { $ section } [ $ when ] [ ] = $ alias ; return $ this ; } 
public function enableFilter ( string $ name , string $ when = 'before' ) { 
public function getArguments ( string $ key = null ) { return is_null ( $ key ) ? $ this -> arguments : $ this -> arguments [ $ key ] ; } 
protected function processGlobals ( string $ uri = null ) { if ( ! isset ( $ this -> config -> globals ) || ! is_array ( $ this -> config -> globals ) ) { return ; } 
protected function processMethods ( ) { if ( ! isset ( $ this -> config -> methods ) || ! is_array ( $ this -> config -> methods ) ) { return ; } 
protected function processFilters ( string $ uri = null ) { if ( ! isset ( $ this -> config -> filters ) || ! $ this -> config -> filters ) { return ; } $ uri = strtolower ( trim ( $ uri , '/ ' ) ) ; $ matches = [ ] ; foreach ( $ this -> config -> filters as $ alias => $ settings ) { 
public function handle ( $ level , $ message ) : bool { 
protected function format ( $ object ) { if ( ! is_object ( $ object ) ) { return $ object ; } 
public function sendLogs ( ResponseInterface & $ response = null ) { if ( is_null ( $ response ) ) { $ response = Services :: response ( null , true ) ; } $ data = base64_encode ( utf8_encode ( json_encode ( $ this -> json ) ) ) ; $ response -> setHeader ( $ this -> header , $ data ) ; } 
protected function _createTableAttributes ( array $ attributes ) : string { $ sql = '' ; foreach ( array_keys ( $ attributes ) as $ key ) { if ( is_string ( $ key ) ) { $ sql .= ' ' . strtoupper ( $ key ) . ' = ' ; if ( in_array ( strtoupper ( $ key ) , $ this -> _quoted_table_options ) ) { $ sql .= $ this -> db -> escape ( $ attributes [ $ key ] ) ; } else { $ sql .= $ this -> db -> escapeString ( $ attributes [ $ key ] ) ; } } } if ( ! empty ( $ this -> db -> charset ) && ! strpos ( $ sql , 'CHARACTER SET' ) && ! strpos ( $ sql , 'CHARSET' ) ) { $ sql .= ' DEFAULT CHARACTER SET = ' . $ this -> db -> escapeString ( $ this -> db -> charset ) ; } if ( ! empty ( $ this -> db -> DBCollat ) && ! strpos ( $ sql , 'COLLATE' ) ) { $ sql .= ' COLLATE = ' . $ this -> db -> escapeString ( $ this -> db -> DBCollat ) ; } return $ sql ; } 
protected function _alterTable ( string $ alter_type , string $ table , $ field ) { if ( $ alter_type === 'DROP' ) { return parent :: _alterTable ( $ alter_type , $ table , $ field ) ; } $ sql = 'ALTER TABLE ' . $ this -> db -> escapeIdentifiers ( $ table ) ; foreach ( $ field as $ i => $ data ) { if ( $ data [ '_literal' ] !== false ) { $ field [ $ i ] = ( $ alter_type === 'ADD' ) ? "\n\tADD " . $ data [ '_literal' ] : "\n\tMODIFY " . $ data [ '_literal' ] ; } else { if ( $ alter_type === 'ADD' ) { $ field [ $ i ] [ '_literal' ] = "\n\tADD " ; } else { $ field [ $ i ] [ '_literal' ] = empty ( $ data [ 'new_name' ] ) ? "\n\tMODIFY " : "\n\tCHANGE " ; } $ field [ $ i ] = $ field [ $ i ] [ '_literal' ] . $ this -> _processColumn ( $ field [ $ i ] ) ; } } return [ $ sql . implode ( ',' , $ field ) ] ; } 
protected function _processColumn ( array $ field ) : string { $ extra_clause = isset ( $ field [ 'after' ] ) ? ' AFTER ' . $ this -> db -> escapeIdentifiers ( $ field [ 'after' ] ) : '' ; if ( empty ( $ extra_clause ) && isset ( $ field [ 'first' ] ) && $ field [ 'first' ] === true ) { $ extra_clause = ' FIRST' ; } return $ this -> db -> escapeIdentifiers ( $ field [ 'name' ] ) . ( empty ( $ field [ 'new_name' ] ) ? '' : ' ' . $ this -> db -> escapeIdentifiers ( $ field [ 'new_name' ] ) ) . ' ' . $ field [ 'type' ] . $ field [ 'length' ] . $ field [ 'unsigned' ] . $ field [ 'null' ] . $ field [ 'default' ] . $ field [ 'auto_increment' ] . $ field [ 'unique' ] . ( empty ( $ field [ 'comment' ] ) ? '' : ' COMMENT ' . $ field [ 'comment' ] ) . $ extra_clause ; } 
protected function _processIndexes ( string $ table ) : string { $ sql = '' ; for ( $ i = 0 , $ c = count ( $ this -> keys ) ; $ i < $ c ; $ i ++ ) { if ( is_array ( $ this -> keys [ $ i ] ) ) { for ( $ i2 = 0 , $ c2 = count ( $ this -> keys [ $ i ] ) ; $ i2 < $ c2 ; $ i2 ++ ) { if ( ! isset ( $ this -> fields [ $ this -> keys [ $ i ] [ $ i2 ] ] ) ) { unset ( $ this -> keys [ $ i ] [ $ i2 ] ) ; continue ; } } } elseif ( ! isset ( $ this -> fields [ $ this -> keys [ $ i ] ] ) ) { unset ( $ this -> keys [ $ i ] ) ; continue ; } is_array ( $ this -> keys [ $ i ] ) || $ this -> keys [ $ i ] = [ $ this -> keys [ $ i ] ] ; $ unique = in_array ( $ i , $ this -> uniqueKeys ) ? 'UNIQUE ' : '' ; $ sql .= ",\n\t{$unique}KEY " . $ this -> db -> escapeIdentifiers ( implode ( '_' , $ this -> keys [ $ i ] ) ) . ' (' . implode ( ', ' , $ this -> db -> escapeIdentifiers ( $ this -> keys [ $ i ] ) ) . ')' ; } $ this -> keys = [ ] ; return $ sql ; } 
public function detectLocale ( $ config ) { $ this -> locale = $ this -> defaultLocale = $ config -> defaultLocale ; if ( ! $ config -> negotiateLocale ) { return ; } $ this -> setLocale ( $ this -> negotiate ( 'language' , $ config -> supportedLocales ) ) ; } 
public function setLocale ( string $ locale ) { 
public function isSecure ( ) : bool { if ( ! empty ( $ _SERVER [ 'HTTPS' ] ) && strtolower ( $ _SERVER [ 'HTTPS' ] ) !== 'off' ) { return true ; } elseif ( isset ( $ _SERVER [ 'HTTP_X_FORWARDED_PROTO' ] ) && $ _SERVER [ 'HTTP_X_FORWARDED_PROTO' ] === 'https' ) { return true ; } elseif ( ! empty ( $ _SERVER [ 'HTTP_FRONT_END_HTTPS' ] ) && strtolower ( $ _SERVER [ 'HTTP_FRONT_END_HTTPS' ] ) !== 'off' ) { return true ; } return false ; } 
public function getVar ( $ index = null , $ filter = null , $ flags = null ) { return $ this -> fetchGlobal ( 'request' , $ index , $ filter , $ flags ) ; } 
public function getJSON ( bool $ assoc = false , int $ depth = 512 , int $ options = 0 ) { return json_decode ( $ this -> body , $ assoc , $ depth , $ options ) ; } 
public function getGet ( $ index = null , $ filter = null , $ flags = null ) { return $ this -> fetchGlobal ( 'get' , $ index , $ filter , $ flags ) ; } 
public function getPost ( $ index = null , $ filter = null , $ flags = null ) { return $ this -> fetchGlobal ( 'post' , $ index , $ filter , $ flags ) ; } 
public function getPostGet ( $ index = null , $ filter = null , $ flags = null ) { 
public function getGetPost ( $ index = null , $ filter = null , $ flags = null ) { 
public function getCookie ( $ index = null , $ filter = null , $ flags = null ) { return $ this -> fetchGlobal ( 'cookie' , $ index , $ filter , $ flags ) ; } 
public function getOldInput ( string $ key ) { 
public function getFiles ( ) : array { if ( is_null ( $ this -> files ) ) { $ this -> files = new FileCollection ( ) ; } return $ this -> files -> all ( ) ; 
public function getFile ( string $ fileID ) { if ( is_null ( $ this -> files ) ) { $ this -> files = new FileCollection ( ) ; } return $ this -> files -> getFile ( $ fileID ) ; } 
protected function detectURI ( string $ protocol , string $ baseURL ) { $ this -> uri -> setPath ( $ this -> detectPath ( $ protocol ) ) ; 
public function detectPath ( string $ protocol = '' ) : string { if ( empty ( $ protocol ) ) { $ protocol = 'REQUEST_URI' ; } switch ( $ protocol ) { case 'REQUEST_URI' : $ path = $ this -> parseRequestURI ( ) ; break ; case 'QUERY_STRING' : $ path = $ this -> parseQueryString ( ) ; break ; case 'PATH_INFO' : default : $ path = $ this -> fetchGlobal ( 'server' , $ protocol ) ?? $ this -> parseRequestURI ( ) ; break ; } return $ path ; } 
public function negotiate ( string $ type , array $ supported , bool $ strictMatch = false ) : string { if ( is_null ( $ this -> negotiator ) ) { $ this -> negotiator = Services :: negotiator ( $ this , true ) ; } switch ( strtolower ( $ type ) ) { case 'media' : return $ this -> negotiator -> media ( $ supported , $ strictMatch ) ; case 'charset' : return $ this -> negotiator -> charset ( $ supported ) ; case 'encoding' : return $ this -> negotiator -> encoding ( $ supported ) ; case 'language' : return $ this -> negotiator -> language ( $ supported ) ; } throw HTTPException :: forInvalidNegotiationType ( $ type ) ; } 
protected function parseRequestURI ( ) : string { if ( ! isset ( $ _SERVER [ 'REQUEST_URI' ] , $ _SERVER [ 'SCRIPT_NAME' ] ) ) { return '' ; } 
protected function parseQueryString ( ) : string { $ uri = $ _SERVER [ 'QUERY_STRING' ] ?? @ getenv ( 'QUERY_STRING' ) ; if ( trim ( $ uri , '/' ) === '' ) { return '' ; } elseif ( strncmp ( $ uri , '/' , 1 ) === 0 ) { $ uri = explode ( '?' , $ uri , 2 ) ; $ _SERVER [ 'QUERY_STRING' ] = $ uri [ 1 ] ?? '' ; $ uri = $ uri [ 0 ] ; } parse_str ( $ _SERVER [ 'QUERY_STRING' ] , $ _GET ) ; return $ this -> removeRelativeDirectory ( $ uri ) ; } 
protected function removeRelativeDirectory ( string $ uri ) : string { $ uris = [ ] ; $ tok = strtok ( $ uri , '/' ) ; while ( $ tok !== false ) { if ( ( ! empty ( $ tok ) || $ tok === '0' ) && $ tok !== '..' ) { $ uris [ ] = $ tok ; } $ tok = strtok ( '/' ) ; } return implode ( '/' , $ uris ) ; } 
public function open ( $ save_path , $ name ) : bool { if ( empty ( $ this -> savePath ) ) { return false ; } $ redis = new \ Redis ( ) ; if ( ! $ redis -> connect ( $ this -> savePath [ 'host' ] , $ this -> savePath [ 'port' ] , $ this -> savePath [ 'timeout' ] ) ) { $ this -> logger -> error ( 'Session: Unable to connect to Redis with the configured settings.' ) ; } elseif ( isset ( $ this -> savePath [ 'password' ] ) && ! $ redis -> auth ( $ this -> savePath [ 'password' ] ) ) { $ this -> logger -> error ( 'Session: Unable to authenticate to Redis instance.' ) ; } elseif ( isset ( $ this -> savePath [ 'database' ] ) && ! $ redis -> select ( $ this -> savePath [ 'database' ] ) ) { $ this -> logger -> error ( 'Session: Unable to select Redis database with index ' . $ this -> savePath [ 'database' ] ) ; } else { $ this -> redis = $ redis ; return true ; } return false ; } 
public function read ( $ sessionID ) : string { if ( isset ( $ this -> redis ) && $ this -> lockSession ( $ sessionID ) ) { 
public function write ( $ sessionID , $ sessionData ) : bool { if ( ! isset ( $ this -> redis ) ) { return false ; } 
public function close ( ) : bool { if ( isset ( $ this -> redis ) ) { try { if ( $ this -> redis -> ping ( ) === '+PONG' ) { isset ( $ this -> lockKey ) && $ this -> redis -> delete ( $ this -> lockKey ) ; if ( ! $ this -> redis -> close ( ) ) { return false ; } } } catch ( \ RedisException $ e ) { $ this -> logger -> error ( 'Session: Got RedisException on close(): ' . $ e -> getMessage ( ) ) ; } $ this -> redis = null ; return true ; } return true ; } 
public function destroy ( $ sessionID ) : bool { if ( isset ( $ this -> redis , $ this -> lockKey ) ) { if ( ( $ result = $ this -> redis -> delete ( $ this -> keyPrefix . $ sessionID ) ) !== 1 ) { $ this -> logger -> debug ( 'Session: Redis::delete() expected to return 1, got ' . var_export ( $ result , true ) . ' instead.' ) ; } return $ this -> destroyCookie ( ) ; } return false ; } 
protected function lockSession ( string $ sessionID ) : bool { 
protected function releaseLock ( ) : bool { if ( isset ( $ this -> redis , $ this -> lockKey ) && $ this -> lock ) { if ( ! $ this -> redis -> delete ( $ this -> lockKey ) ) { $ this -> logger -> error ( 'Session: Error while trying to free lock for ' . $ this -> lockKey ) ; return false ; } $ this -> lockKey = null ; $ this -> lock = false ; } return true ; } 
public function _prepare ( string $ sql , array $ options = [ ] ) { if ( ! ( $ this -> statement = $ this -> db -> connID -> prepare ( $ sql ) ) ) { $ this -> errorCode = $ this -> db -> connID -> lastErrorCode ( ) ; $ this -> errorString = $ this -> db -> connID -> lastErrorMsg ( ) ; } return $ this ; } 
public function _execute ( array $ data ) : bool { if ( is_null ( $ this -> statement ) ) { throw new \ BadMethodCallException ( 'You must call prepare before trying to execute a prepared statement.' ) ; } foreach ( $ data as $ key => $ item ) { 
protected function formatTimelineData ( ) : array { $ data = [ ] ; $ benchmark = Services :: timer ( true ) ; $ rows = $ benchmark -> getTimers ( 6 ) ; foreach ( $ rows as $ name => $ info ) { if ( $ name === 'total_execution' ) { continue ; } $ data [ ] = [ 'name' => ucwords ( str_replace ( '_' , ' ' , $ name ) ) , 'component' => 'Timer' , 'start' => $ info [ 'start' ] , 'duration' => $ info [ 'end' ] - $ info [ 'start' ] , ] ; } return $ data ; } 
public function connect ( bool $ persistent = false ) { if ( empty ( $ this -> DSN ) ) { $ this -> buildDSN ( ) ; } 
public function getVersion ( ) : string { if ( isset ( $ this -> dataCache [ 'version' ] ) ) { return $ this -> dataCache [ 'version' ] ; } if ( ! $ this -> connID || ( $ pgVersion = pg_version ( $ this -> connID ) ) === false ) { $ this -> initialize ( ) ; } return isset ( $ pgVersion [ 'server' ] ) ? $ this -> dataCache [ 'version' ] = $ pgVersion [ 'server' ] : false ; } 
public function escape ( $ str ) { if ( ! $ this -> connID ) { $ this -> initialize ( ) ; } if ( is_string ( $ str ) || ( is_object ( $ str ) && method_exists ( $ str , '__toString' ) ) ) { return pg_escape_literal ( $ this -> connID , $ str ) ; } elseif ( is_bool ( $ str ) ) { return $ str ? 'TRUE' : 'FALSE' ; } return parent :: escape ( $ str ) ; } 
protected function _escapeString ( string $ str ) : string { if ( ! $ this -> connID ) { $ this -> initialize ( ) ; } return pg_escape_string ( $ this -> connID , $ str ) ; } 
protected function _listColumns ( string $ table = '' ) : string { return 'SELECT "column_name" FROM "information_schema"."columns" WHERE LOWER("table_name") = ' . $ this -> escape ( $ this -> DBPrefix . strtolower ( $ table ) ) ; } 
public function _fieldData ( string $ table ) : array { $ sql = 'SELECT "column_name", "data_type", "character_maximum_length", "numeric_precision", "column_default" FROM "information_schema"."columns" WHERE LOWER("table_name") = ' . $ this -> escape ( strtolower ( $ table ) ) ; if ( ( $ query = $ this -> query ( $ sql ) ) === false ) { throw new DatabaseException ( lang ( 'Database.failGetFieldData' ) ) ; } $ query = $ query -> getResultObject ( ) ; $ retVal = [ ] ; for ( $ i = 0 , $ c = count ( $ query ) ; $ i < $ c ; $ i ++ ) { $ retVal [ $ i ] = new \ stdClass ( ) ; $ retVal [ $ i ] -> name = $ query [ $ i ] -> column_name ; $ retVal [ $ i ] -> type = $ query [ $ i ] -> data_type ; $ retVal [ $ i ] -> default = $ query [ $ i ] -> column_default ; $ retVal [ $ i ] -> max_length = $ query [ $ i ] -> character_maximum_length > 0 ? $ query [ $ i ] -> character_maximum_length : $ query [ $ i ] -> numeric_precision ; } return $ retVal ; } 
public function _indexData ( string $ table ) : array { $ sql = 'SELECT "indexname", "indexdef" FROM "pg_indexes" WHERE LOWER("tablename") = ' . $ this -> escape ( strtolower ( $ table ) ) . ' AND "schemaname" = ' . $ this -> escape ( 'public' ) ; if ( ( $ query = $ this -> query ( $ sql ) ) === false ) { throw new DatabaseException ( lang ( 'Database.failGetIndexData' ) ) ; } $ query = $ query -> getResultObject ( ) ; $ retVal = [ ] ; foreach ( $ query as $ row ) { $ obj = new \ stdClass ( ) ; $ obj -> name = $ row -> indexname ; $ _fields = explode ( ',' , preg_replace ( '/^.*\((.+?)\)$/' , '$1' , trim ( $ row -> indexdef ) ) ) ; $ obj -> fields = array_map ( function ( $ v ) { return trim ( $ v ) ; } , $ _fields ) ; if ( strpos ( $ row -> indexdef , 'CREATE UNIQUE INDEX pk' ) === 0 ) { $ obj -> type = 'PRIMARY' ; } else { $ obj -> type = ( strpos ( $ row -> indexdef , 'CREATE UNIQUE' ) === 0 ) ? 'UNIQUE' : 'INDEX' ; } $ retVal [ $ obj -> name ] = $ obj ; } return $ retVal ; } 
public function _foreignKeyData ( string $ table ) : array { $ sql = 'SELECT tc.constraint_name, tc.table_name, kcu.column_name, ccu.table_name AS foreign_table_name, ccu.column_name AS foreign_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = ' . $ this -> escape ( 'FOREIGN KEY' ) . ' AND tc.table_name = ' . $ this -> escape ( $ table ) ; if ( ( $ query = $ this -> query ( $ sql ) ) === false ) { throw new DatabaseException ( lang ( 'Database.failGetForeignKeyData' ) ) ; } $ query = $ query -> getResultObject ( ) ; $ retVal = [ ] ; foreach ( $ query as $ row ) { $ obj = new \ stdClass ( ) ; $ obj -> constraint_name = $ row -> constraint_name ; $ obj -> table_name = $ row -> table_name ; $ obj -> foreign_table_name = $ row -> foreign_table_name ; $ retVal [ ] = $ obj ; } return $ retVal ; } 
public function insertID ( ) : int { $ v = pg_version ( $ this -> connID ) ; 
protected function buildDSN ( ) { $ this -> DSN === '' || $ this -> DSN = '' ; 
public function getFormatter ( string $ mime ) { if ( ! array_key_exists ( $ mime , $ this -> formatters ) ) { throw new \ InvalidArgumentException ( 'No Formatter defined for mime type: ' . $ mime ) ; } $ class = $ this -> formatters [ $ mime ] ; if ( ! class_exists ( $ class ) ) { throw new \ BadMethodCallException ( $ class . ' is not a valid Formatter.' ) ; } return new $ class ( ) ; } 
public function before ( RequestInterface $ request ) { $ honeypot = Services :: honeypot ( new \ Config \ Honeypot ( ) ) ; if ( $ honeypot -> hasContent ( $ request ) ) { throw HoneypotException :: isBot ( ) ; } } 
public function after ( RequestInterface $ request , ResponseInterface $ response ) { $ honeypot = Services :: honeypot ( new \ Config \ Honeypot ( ) ) ; $ honeypot -> attachHoneypot ( $ response ) ; } 
public function _resize ( bool $ maintainRatio = false ) { $ source = ! empty ( $ this -> resource ) ? $ this -> resource : $ this -> image -> getPathname ( ) ; $ destination = $ this -> getResourcePath ( ) ; $ escape = '\\' ; if ( stripos ( PHP_OS , 'WIN' ) === 0 ) { $ escape = '' ; } $ action = $ maintainRatio === true ? ' -resize ' . $ this -> width . 'x' . $ this -> height . ' "' . $ source . '" "' . $ destination . '"' : ' -resize ' . $ this -> width . 'x' . $ this -> height . "{$escape}! \"" . $ source . '" "' . $ destination . '"' ; $ this -> process ( $ action ) ; return $ this ; } 
public function _crop ( ) { $ source = ! empty ( $ this -> resource ) ? $ this -> resource : $ this -> image -> getPathname ( ) ; $ destination = $ this -> getResourcePath ( ) ; $ action = ' -crop ' . $ this -> width . 'x' . $ this -> height . '+' . $ this -> xAxis . '+' . $ this -> yAxis . ' "' . $ source . '" "' . $ destination . '"' ; $ this -> process ( $ action ) ; return $ this ; } 
protected function _rotate ( int $ angle ) { $ angle = '-rotate ' . $ angle ; $ source = ! empty ( $ this -> resource ) ? $ this -> resource : $ this -> image -> getPathname ( ) ; $ destination = $ this -> getResourcePath ( ) ; $ action = ' ' . $ angle . ' "' . $ source . '" "' . $ destination . '"' ; $ this -> process ( $ action ) ; return $ this ; } 
public function _flatten ( int $ red = 255 , int $ green = 255 , int $ blue = 255 ) { $ flatten = "-background RGB({$red},{$green},{$blue}) -flatten" ; $ source = ! empty ( $ this -> resource ) ? $ this -> resource : $ this -> image -> getPathname ( ) ; $ destination = $ this -> getResourcePath ( ) ; $ action = ' ' . $ flatten . ' "' . $ source . '" "' . $ destination . '"' ; $ this -> process ( $ action ) ; return $ this ; } 
public function _flip ( string $ direction ) { $ angle = $ direction === 'horizontal' ? '-flop' : '-flip' ; $ source = ! empty ( $ this -> resource ) ? $ this -> resource : $ this -> image -> getPathname ( ) ; $ destination = $ this -> getResourcePath ( ) ; $ action = ' ' . $ angle . ' "' . $ source . '" "' . $ destination . '"' ; $ this -> process ( $ action ) ; return $ this ; } 
public function getVersion ( ) : string { $ result = $ this -> process ( '-version' ) ; 
protected function process ( string $ action , int $ quality = 100 ) { 
public function save ( string $ target = null , int $ quality = 90 ) : bool { $ target = empty ( $ target ) ? $ this -> image : $ target ; 
protected function getResourcePath ( ) { if ( ! is_null ( $ this -> resource ) ) { return $ this -> resource ; } $ this -> resource = WRITEPATH . 'cache/' . time ( ) . '_' . bin2hex ( random_bytes ( 10 ) ) . '.png' ; return $ this -> resource ; } 
protected function _text ( string $ text , array $ options = [ ] ) { $ cmd = '' ; 
public function run ( array $ params = [ ] ) { $ seeder = new Seeder ( new \ Config \ Database ( ) ) ; $ seedName = array_shift ( $ params ) ; if ( empty ( $ seedName ) ) { $ seedName = CLI :: prompt ( lang ( 'Migrations.migSeeder' ) , 'DatabaseSeeder' ) ; } if ( empty ( $ seedName ) ) { CLI :: error ( lang ( 'Migrations.migMissingSeeder' ) ) ; return ; } try { $ seeder -> call ( $ seedName ) ; } catch ( \ Exception $ e ) { $ this -> showError ( $ e ) ; } } 
public function createDatabase ( string $ db_name ) : bool { if ( $ this -> createDatabaseStr === false ) { if ( $ this -> db -> DBDebug ) { throw new DatabaseException ( 'This feature is not available for the database you are using.' ) ; } return false ; } elseif ( ! $ this -> db -> query ( sprintf ( $ this -> createDatabaseStr , $ db_name , $ this -> db -> charset , $ this -> db -> DBCollat ) ) ) { if ( $ this -> db -> DBDebug ) { throw new DatabaseException ( 'Unable to create the specified database.' ) ; } return false ; } if ( ! empty ( $ this -> db -> dataCache [ 'db_names' ] ) ) { $ this -> db -> dataCache [ 'db_names' ] [ ] = $ db_name ; } return true ; } 
public function dropDatabase ( string $ db_name ) : bool { if ( $ this -> dropDatabaseStr === false ) { if ( $ this -> db -> DBDebug ) { throw new DatabaseException ( 'This feature is not available for the database you are using.' ) ; } return false ; } elseif ( ! $ this -> db -> query ( sprintf ( $ this -> dropDatabaseStr , $ db_name ) ) ) { if ( $ this -> db -> DBDebug ) { throw new DatabaseException ( 'Unable to drop the specified database.' ) ; } return false ; } if ( ! empty ( $ this -> db -> dataCache [ 'db_names' ] ) ) { $ key = array_search ( strtolower ( $ db_name ) , array_map ( 'strtolower' , $ this -> db -> dataCache [ 'db_names' ] ) , true ) ; if ( $ key !== false ) { unset ( $ this -> db -> dataCache [ 'db_names' ] [ $ key ] ) ; } } return true ; } 
public function addKey ( $ key , bool $ primary = false , bool $ unique = false ) { if ( $ primary === true ) { foreach ( ( array ) $ key as $ one ) { $ this -> primaryKeys [ ] = $ one ; } } else { $ this -> keys [ ] = $ key ; if ( $ unique === true ) { $ this -> uniqueKeys [ ] = ( $ c = count ( $ this -> keys ) ) ? $ c - 1 : 0 ; } } return $ this ; } 
public function addField ( $ field ) { if ( is_string ( $ field ) ) { if ( $ field === 'id' ) { $ this -> addField ( [ 'id' => [ 'type' => 'INT' , 'constraint' => 9 , 'auto_increment' => true , ] , ] ) ; $ this -> addKey ( 'id' , true ) ; } else { if ( strpos ( $ field , ' ' ) === false ) { throw new \ InvalidArgumentException ( 'Field information is required for that operation.' ) ; } $ this -> fields [ ] = $ field ; } } if ( is_array ( $ field ) ) { $ this -> fields = array_merge ( $ this -> fields , $ field ) ; } return $ this ; } 
public function addForeignKey ( string $ fieldName = '' , string $ tableName = '' , string $ tableField = '' , string $ onUpdate = '' , string $ onDelete = '' ) { if ( ! isset ( $ this -> fields [ $ fieldName ] ) ) { throw new DatabaseException ( lang ( 'Database.fieldNotExists' , [ $ fieldName ] ) ) ; } $ this -> foreignKeys [ $ fieldName ] = [ 'table' => $ tableName , 'field' => $ tableField , 'onDelete' => strtoupper ( $ onDelete ) , 'onUpdate' => strtoupper ( $ onUpdate ) , ] ; return $ this ; } 
public function dropForeignKey ( string $ table , string $ foreign_name ) { $ sql = sprintf ( $ this -> dropConstraintStr , $ this -> db -> escapeIdentifiers ( $ this -> db -> DBPrefix . $ table ) , $ this -> db -> escapeIdentifiers ( $ this -> db -> DBPrefix . $ foreign_name ) ) ; if ( $ sql === false ) { if ( $ this -> db -> DBDebug ) { throw new DatabaseException ( 'This feature is not available for the database you are using.' ) ; } return false ; } return $ this -> db -> query ( $ sql ) ; } 
public function createTable ( string $ table , bool $ if_not_exists = false , array $ attributes = [ ] ) { if ( $ table === '' ) { throw new \ InvalidArgumentException ( 'A table name is required for that operation.' ) ; } $ table = $ this -> db -> DBPrefix . $ table ; if ( count ( $ this -> fields ) === 0 ) { throw new \ RuntimeException ( 'Field information is required.' ) ; } $ sql = $ this -> _createTable ( $ table , $ if_not_exists , $ attributes ) ; if ( is_bool ( $ sql ) ) { $ this -> reset ( ) ; if ( $ sql === false ) { if ( $ this -> db -> DBDebug ) { throw new DatabaseException ( 'This feature is not available for the database you are using.' ) ; } return false ; } } if ( ( $ result = $ this -> db -> query ( $ sql ) ) !== false ) { empty ( $ this -> db -> dataCache [ 'table_names' ] ) || ( $ this -> db -> dataCache [ 'table_names' ] [ ] = $ table ) ; 
protected function _createTable ( string $ table , bool $ if_not_exists , array $ attributes ) { 
protected function _createTableAttributes ( array $ attributes ) : string { $ sql = '' ; foreach ( array_keys ( $ attributes ) as $ key ) { if ( is_string ( $ key ) ) { $ sql .= ' ' . strtoupper ( $ key ) . ' ' . $ this -> db -> escape ( $ attributes [ $ key ] ) ; } } return $ sql ; } 
public function dropTable ( string $ table_name , bool $ if_exists = false , bool $ cascade = false ) { if ( $ table_name === '' ) { if ( $ this -> db -> DBDebug ) { throw new DatabaseException ( 'A table name is required for that operation.' ) ; } return false ; } 
protected function _dropTable ( string $ table , bool $ if_exists , bool $ cascade ) : string { $ sql = 'DROP TABLE' ; if ( $ if_exists ) { if ( $ this -> dropTableIfStr === false ) { if ( ! $ this -> db -> tableExists ( $ table ) ) { return true ; } } else { $ sql = sprintf ( $ this -> dropTableIfStr , $ this -> db -> escapeIdentifiers ( $ table ) ) ; } } $ sql = $ sql . ' ' . $ this -> db -> escapeIdentifiers ( $ table ) ; return $ sql ; } 
public function renameTable ( string $ table_name , string $ new_table_name ) { if ( $ table_name === '' || $ new_table_name === '' ) { throw new \ InvalidArgumentException ( 'A table name is required for that operation.' ) ; } elseif ( $ this -> renameTableStr === false ) { if ( $ this -> db -> DBDebug ) { throw new DatabaseException ( 'This feature is not available for the database you are using.' ) ; } return false ; } $ result = $ this -> db -> query ( sprintf ( $ this -> renameTableStr , $ this -> db -> escapeIdentifiers ( $ this -> db -> DBPrefix . $ table_name ) , $ this -> db -> escapeIdentifiers ( $ this -> db -> DBPrefix . $ new_table_name ) ) ) ; if ( $ result && ! empty ( $ this -> db -> dataCache [ 'table_names' ] ) ) { $ key = array_search ( strtolower ( $ this -> db -> DBPrefix . $ table_name ) , array_map ( 'strtolower' , $ this -> db -> dataCache [ 'table_names' ] ) , true ) ; if ( $ key !== false ) { $ this -> db -> dataCache [ 'table_names' ] [ $ key ] = $ this -> db -> DBPrefix . $ new_table_name ; } } return $ result ; } 
public function addColumn ( string $ table , $ field ) : bool { 
public function dropColumn ( string $ table , string $ column_name ) { $ sql = $ this -> _alterTable ( 'DROP' , $ this -> db -> DBPrefix . $ table , $ column_name ) ; if ( $ sql === false ) { if ( $ this -> db -> DBDebug ) { throw new DatabaseException ( 'This feature is not available for the database you are using.' ) ; } return false ; } return $ this -> db -> query ( $ sql ) ; } 
protected function _alterTable ( string $ alter_type , string $ table , $ field ) { $ sql = 'ALTER TABLE ' . $ this -> db -> escapeIdentifiers ( $ table ) . ' ' ; 
protected function _processFields ( bool $ create_table = false ) : array { $ fields = [ ] ; foreach ( $ this -> fields as $ key => $ attributes ) { if ( is_int ( $ key ) && ! is_array ( $ attributes ) ) { $ fields [ ] = [ '_literal' => $ attributes ] ; continue ; } $ attributes = array_change_key_case ( $ attributes , CASE_UPPER ) ; if ( $ create_table === true && empty ( $ attributes [ 'TYPE' ] ) ) { continue ; } isset ( $ attributes [ 'TYPE' ] ) && $ this -> _attributeType ( $ attributes ) ; $ field = [ 'name' => $ key , 'new_name' => isset ( $ attributes [ 'NAME' ] ) ? $ attributes [ 'NAME' ] : null , 'type' => isset ( $ attributes [ 'TYPE' ] ) ? $ attributes [ 'TYPE' ] : null , 'length' => '' , 'unsigned' => '' , 'null' => '' , 'unique' => '' , 'default' => '' , 'auto_increment' => '' , '_literal' => false , ] ; isset ( $ attributes [ 'TYPE' ] ) && $ this -> _attributeUnsigned ( $ attributes , $ field ) ; if ( $ create_table === false ) { if ( isset ( $ attributes [ 'AFTER' ] ) ) { $ field [ 'after' ] = $ attributes [ 'AFTER' ] ; } elseif ( isset ( $ attributes [ 'FIRST' ] ) ) { $ field [ 'first' ] = ( bool ) $ attributes [ 'FIRST' ] ; } } $ this -> _attributeDefault ( $ attributes , $ field ) ; if ( isset ( $ attributes [ 'NULL' ] ) ) { if ( $ attributes [ 'NULL' ] === true ) { $ field [ 'null' ] = empty ( $ this -> null ) ? '' : ' ' . $ this -> null ; } else { $ field [ 'null' ] = ' NOT NULL' ; } } elseif ( $ create_table === true ) { $ field [ 'null' ] = ' NOT NULL' ; } $ this -> _attributeAutoIncrement ( $ attributes , $ field ) ; $ this -> _attributeUnique ( $ attributes , $ field ) ; if ( isset ( $ attributes [ 'COMMENT' ] ) ) { $ field [ 'comment' ] = $ this -> db -> escape ( $ attributes [ 'COMMENT' ] ) ; } if ( isset ( $ attributes [ 'TYPE' ] ) && ! empty ( $ attributes [ 'CONSTRAINT' ] ) ) { if ( is_array ( $ attributes [ 'CONSTRAINT' ] ) ) { $ attributes [ 'CONSTRAINT' ] = $ this -> db -> escape ( $ attributes [ 'CONSTRAINT' ] ) ; $ attributes [ 'CONSTRAINT' ] = implode ( ',' , $ attributes [ 'CONSTRAINT' ] ) ; } $ field [ 'length' ] = '(' . $ attributes [ 'CONSTRAINT' ] . ')' ; } $ fields [ ] = $ field ; } return $ fields ; } 
protected function _attributeUnsigned ( array & $ attributes , array & $ field ) { if ( empty ( $ attributes [ 'UNSIGNED' ] ) || $ attributes [ 'UNSIGNED' ] !== true ) { return ; } 
protected function _attributeDefault ( array & $ attributes , array & $ field ) { if ( $ this -> default === false ) { return ; } if ( array_key_exists ( 'DEFAULT' , $ attributes ) ) { if ( $ attributes [ 'DEFAULT' ] === null ) { $ field [ 'default' ] = empty ( $ this -> null ) ? '' : $ this -> default . $ this -> null ; 
protected function _attributeAutoIncrement ( array & $ attributes , array & $ field ) { if ( ! empty ( $ attributes [ 'AUTO_INCREMENT' ] ) && $ attributes [ 'AUTO_INCREMENT' ] === true && stripos ( $ field [ 'type' ] , 'int' ) !== false ) { $ field [ 'auto_increment' ] = ' AUTO_INCREMENT' ; } } 
protected function _processPrimaryKeys ( string $ table ) : string { $ sql = '' ; for ( $ i = 0 , $ c = count ( $ this -> primaryKeys ) ; $ i < $ c ; $ i ++ ) { if ( ! isset ( $ this -> fields [ $ this -> primaryKeys [ $ i ] ] ) ) { unset ( $ this -> primaryKeys [ $ i ] ) ; } } if ( count ( $ this -> primaryKeys ) > 0 ) { $ sql .= ",\n\tCONSTRAINT " . $ this -> db -> escapeIdentifiers ( 'pk_' . $ table ) . ' PRIMARY KEY(' . implode ( ', ' , $ this -> db -> escapeIdentifiers ( $ this -> primaryKeys ) ) . ')' ; } return $ sql ; } 
protected function _processIndexes ( string $ table ) { $ sqls = [ ] ; for ( $ i = 0 , $ c = count ( $ this -> keys ) ; $ i < $ c ; $ i ++ ) { $ this -> keys [ $ i ] = ( array ) $ this -> keys [ $ i ] ; for ( $ i2 = 0 , $ c2 = count ( $ this -> keys [ $ i ] ) ; $ i2 < $ c2 ; $ i2 ++ ) { if ( ! isset ( $ this -> fields [ $ this -> keys [ $ i ] [ $ i2 ] ] ) ) { unset ( $ this -> keys [ $ i ] [ $ i2 ] ) ; } } if ( count ( $ this -> keys [ $ i ] ) <= 0 ) { continue ; } if ( in_array ( $ i , $ this -> uniqueKeys ) ) { $ sqls [ ] = 'ALTER TABLE ' . $ this -> db -> escapeIdentifiers ( $ table ) . ' ADD CONSTRAINT ' . $ this -> db -> escapeIdentifiers ( $ table . '_' . implode ( '_' , $ this -> keys [ $ i ] ) ) . ' UNIQUE (' . implode ( ', ' , $ this -> db -> escapeIdentifiers ( $ this -> keys [ $ i ] ) ) . ');' ; continue ; } $ sqls [ ] = 'CREATE INDEX ' . $ this -> db -> escapeIdentifiers ( $ table . '_' . implode ( '_' , $ this -> keys [ $ i ] ) ) . ' ON ' . $ this -> db -> escapeIdentifiers ( $ table ) . ' (' . implode ( ', ' , $ this -> db -> escapeIdentifiers ( $ this -> keys [ $ i ] ) ) . ');' ; } return $ sqls ; } 
protected function _processForeignKeys ( string $ table ) : string { $ sql = '' ; $ allowActions = [ 'CASCADE' , 'SET NULL' , 'NO ACTION' , 'RESTRICT' , 'SET DEFAULT' , ] ; if ( count ( $ this -> foreignKeys ) > 0 ) { foreach ( $ this -> foreignKeys as $ field => $ fkey ) { $ name_index = $ table . '_' . $ field . '_foreign' ; $ sql .= ",\n\tCONSTRAINT " . $ this -> db -> escapeIdentifiers ( $ name_index ) . ' FOREIGN KEY(' . $ this -> db -> escapeIdentifiers ( $ field ) . ') REFERENCES ' . $ this -> db -> escapeIdentifiers ( $ this -> db -> DBPrefix . $ fkey [ 'table' ] ) . ' (' . $ this -> db -> escapeIdentifiers ( $ fkey [ 'field' ] ) . ')' ; if ( $ fkey [ 'onDelete' ] !== false && in_array ( $ fkey [ 'onDelete' ] , $ allowActions ) ) { $ sql .= ' ON DELETE ' . $ fkey [ 'onDelete' ] ; } if ( $ fkey [ 'onUpdate' ] !== false && in_array ( $ fkey [ 'onUpdate' ] , $ allowActions ) ) { $ sql .= ' ON UPDATE ' . $ fkey [ 'onUpdate' ] ; } } } return $ sql ; } 
public function reset ( ) { $ this -> fields = $ this -> keys = $ this -> uniqueKeys = $ this -> primaryKeys = $ this -> foreignKeys = [ ] ; } 
public function setLocale ( string $ locale = null ) { if ( ! is_null ( $ locale ) ) { $ this -> locale = $ locale ; } return $ this ; } 
public function getLine ( string $ line , array $ args = [ ] ) { 
protected function parseLine ( string $ line , string $ locale ) : array { $ file = substr ( $ line , 0 , strpos ( $ line , '.' ) ) ; $ line = substr ( $ line , strlen ( $ file ) + 1 ) ; if ( ! isset ( $ this -> language [ $ locale ] [ $ file ] ) || ! array_key_exists ( $ line , $ this -> language [ $ locale ] [ $ file ] ) ) { $ this -> load ( $ file , $ locale ) ; } return [ $ file , $ line , ] ; } 
protected function formatMessage ( $ message , array $ args = [ ] ) { if ( ! $ this -> intlSupport || ! $ args ) { return $ message ; } if ( is_array ( $ message ) ) { foreach ( $ message as $ index => $ value ) { $ message [ $ index ] = $ this -> formatMessage ( $ value , $ args ) ; } return $ message ; } return \ MessageFormatter :: formatMessage ( $ this -> locale , $ message , $ args ) ; } 
protected function load ( string $ file , string $ locale , bool $ return = false ) { if ( ! array_key_exists ( $ locale , $ this -> loadedFiles ) ) { $ this -> loadedFiles [ $ locale ] = [ ] ; } if ( in_array ( $ file , $ this -> loadedFiles [ $ locale ] ) ) { 
protected function requireFile ( string $ path ) : array { $ files = Services :: locator ( ) -> search ( $ path ) ; $ strings = [ ] ; foreach ( $ files as $ file ) { 
public function addBaseURI ( $ uri , ? bool $ explicitReporting = null ) { $ this -> addOption ( $ uri , 'baseURI' , $ explicitReporting ?? $ this -> reportOnly ) ; return $ this ; } 
public function addChildSrc ( $ uri , ? bool $ explicitReporting = null ) { $ this -> addOption ( $ uri , 'childSrc' , $ explicitReporting ?? $ this -> reportOnly ) ; return $ this ; } 
public function addConnectSrc ( $ uri , ? bool $ explicitReporting = null ) { $ this -> addOption ( $ uri , 'connectSrc' , $ explicitReporting ?? $ this -> reportOnly ) ; return $ this ; } 
public function setDefaultSrc ( $ uri , ? bool $ explicitReporting = null ) { $ this -> defaultSrc = [ ( string ) $ uri => $ explicitReporting ?? $ this -> reportOnly ] ; return $ this ; } 
public function addFontSrc ( $ uri , ? bool $ explicitReporting = null ) { $ this -> addOption ( $ uri , 'fontSrc' , $ explicitReporting ?? $ this -> reportOnly ) ; return $ this ; } 
public function addFormAction ( $ uri , ? bool $ explicitReporting = null ) { $ this -> addOption ( $ uri , 'formAction' , $ explicitReporting ?? $ this -> reportOnly ) ; return $ this ; } 
public function addFrameAncestor ( $ uri , ? bool $ explicitReporting = null ) { $ this -> addOption ( $ uri , 'frameAncestors' , $ explicitReporting ?? $ this -> reportOnly ) ; return $ this ; } 
public function addImageSrc ( $ uri , ? bool $ explicitReporting = null ) { $ this -> addOption ( $ uri , 'imageSrc' , $ explicitReporting ?? $ this -> reportOnly ) ; return $ this ; } 
public function addMediaSrc ( $ uri , ? bool $ explicitReporting = null ) { $ this -> addOption ( $ uri , 'mediaSrc' , $ explicitReporting ?? $ this -> reportOnly ) ; return $ this ; } 
public function addManifestSrc ( $ uri , ? bool $ explicitReporting = null ) { $ this -> addOption ( $ uri , 'manifestSrc' , $ explicitReporting ?? $ this -> reportOnly ) ; return $ this ; } 
public function addObjectSrc ( $ uri , ? bool $ explicitReporting = null ) { $ this -> addOption ( $ uri , 'objectSrc' , $ explicitReporting ?? $ this -> reportOnly ) ; return $ this ; } 
public function addPluginType ( $ mime , ? bool $ explicitReporting = null ) { $ this -> addOption ( $ mime , 'pluginTypes' , $ explicitReporting ?? $ this -> reportOnly ) ; return $ this ; } 
public function addSandbox ( $ flags , ? bool $ explicitReporting = null ) { $ this -> addOption ( $ flags , 'sandbox' , $ explicitReporting ?? $ this -> reportOnly ) ; return $ this ; } 
public function addScriptSrc ( $ uri , ? bool $ explicitReporting = null ) { $ this -> addOption ( $ uri , 'scriptSrc' , $ explicitReporting ?? $ this -> reportOnly ) ; return $ this ; } 
public function addStyleSrc ( $ uri , ? bool $ explicitReporting = null ) { $ this -> addOption ( $ uri , 'styleSrc' , $ explicitReporting ?? $ this -> reportOnly ) ; return $ this ; } 
protected function addOption ( $ options , string $ target , ? bool $ explicitReporting = null ) { 
protected function generateNonces ( ResponseInterface & $ response ) { $ body = $ response -> getBody ( ) ; if ( empty ( $ body ) ) { return ; } if ( ! is_array ( $ this -> styleSrc ) ) { $ this -> styleSrc = [ $ this -> styleSrc ] ; } if ( ! is_array ( $ this -> scriptSrc ) ) { $ this -> scriptSrc = [ $ this -> scriptSrc ] ; } 
protected function buildHeaders ( ResponseInterface & $ response ) { 
protected function addToHeader ( string $ name , $ values = null ) { if ( is_string ( $ values ) ) { $ values = [ $ values => 0 ] ; } $ sources = [ ] ; $ reportSources = [ ] ; foreach ( $ values as $ value => $ reportOnly ) { if ( is_numeric ( $ value ) && is_string ( $ reportOnly ) && ! empty ( $ reportOnly ) ) { $ value = $ reportOnly ; $ reportOnly = 0 ; } if ( $ reportOnly === true ) { $ reportSources [ ] = in_array ( $ value , $ this -> validSources ) ? "'{$value}'" : $ value ; } else { if ( strpos ( $ value , 'nonce-' ) === 0 ) { $ sources [ ] = "'{$value}'" ; } else { $ sources [ ] = in_array ( $ value , $ this -> validSources ) ? "'{$value}'" : $ value ; } } } if ( ! empty ( $ sources ) ) { $ this -> tempHeaders [ $ name ] = implode ( ' ' , $ sources ) ; } if ( ! empty ( $ reportSources ) ) { $ this -> reportOnlyHeaders [ $ name ] = implode ( ' ' , $ reportSources ) ; } } 
public function _prepare ( string $ sql , array $ options = [ ] ) { $ this -> name = random_int ( 1 , 10000000000000000 ) ; $ sql = $ this -> parameterize ( $ sql ) ; 
public function _execute ( array $ data ) : bool { if ( is_null ( $ this -> statement ) ) { throw new \ BadMethodCallException ( 'You must call prepare before trying to execute a prepared statement.' ) ; } $ this -> result = pg_execute ( $ this -> db -> connID , $ this -> name , $ data ) ; return ( bool ) $ this -> result ; } 
public function parameterize ( string $ sql ) : string { 
public function getTitle ( bool $ safe = false ) : string { if ( $ safe ) { return str_replace ( ' ' , '-' , strtolower ( $ this -> title ) ) ; } return $ this -> title ; } 
public function cleanPath ( string $ file ) : string { if ( strpos ( $ file , APPPATH ) === 0 ) { $ file = 'APPPATH/' . substr ( $ file , strlen ( APPPATH ) ) ; } elseif ( strpos ( $ file , SYSTEMPATH ) === 0 ) { $ file = 'SYSTEMPATH/' . substr ( $ file , strlen ( SYSTEMPATH ) ) ; } elseif ( strpos ( $ file , FCPATH ) === 0 ) { $ file = 'FCPATH/' . substr ( $ file , strlen ( FCPATH ) ) ; } return $ file ; } 
protected function collectLogs ( ) { if ( ! is_null ( $ this -> data ) ) { return $ this -> data ; } return $ this -> data = Services :: logger ( true ) -> logCache ?? [ ] ; } 
public function render ( string $ library , $ params = null , int $ ttl = 0 , string $ cacheName = null ) : string { list ( $ class , $ method ) = $ this -> determineClass ( $ library ) ; 
public function prepareParams ( $ params ) { if ( empty ( $ params ) || ( ! is_string ( $ params ) && ! is_array ( $ params ) ) ) { return [ ] ; } if ( is_string ( $ params ) ) { $ new_params = [ ] ; $ separator = ' ' ; if ( strpos ( $ params , ',' ) !== false ) { $ separator = ',' ; } $ params = explode ( $ separator , $ params ) ; unset ( $ separator ) ; foreach ( $ params as $ p ) { if ( ! empty ( $ p ) ) { list ( $ key , $ val ) = explode ( '=' , $ p ) ; $ new_params [ trim ( $ key ) ] = trim ( $ val , ', ' ) ; } } $ params = $ new_params ; unset ( $ new_params ) ; } if ( is_array ( $ params ) && empty ( $ params ) ) { return [ ] ; } return $ params ; } 
protected function determineClass ( string $ library ) : array { 
public function getResult ( string $ type = 'object' ) : array { if ( $ type === 'array' ) { return $ this -> getResultArray ( ) ; } elseif ( $ type === 'object' ) { return $ this -> getResultObject ( ) ; } return $ this -> getCustomResultObject ( $ type ) ; } 
public function getCustomResultObject ( string $ className ) { if ( isset ( $ this -> customResultObject [ $ className ] ) ) { return $ this -> customResultObject [ $ className ] ; } if ( is_bool ( $ this -> resultID ) || ! $ this -> resultID || $ this -> numRows === 0 ) { return [ ] ; } 
public function getResultArray ( ) : array { if ( ! empty ( $ this -> resultArray ) ) { return $ this -> resultArray ; } 
public function getResultObject ( ) : array { if ( ! empty ( $ this -> resultObject ) ) { return $ this -> resultObject ; } 
public function getRow ( $ n = 0 , string $ type = 'object' ) { if ( ! is_numeric ( $ n ) ) { 
public function getCustomRowObject ( int $ n , string $ className ) { isset ( $ this -> customResultObject [ $ className ] ) || $ this -> getCustomResultObject ( $ className ) ; if ( empty ( $ this -> customResultObject [ $ className ] ) ) { return null ; } if ( $ n !== $ this -> currentRow && isset ( $ this -> customResultObject [ $ className ] [ $ n ] ) ) { $ this -> currentRow = $ n ; } return $ this -> customResultObject [ $ className ] [ $ this -> currentRow ] ; } 
public function getRowArray ( int $ n = 0 ) { $ result = $ this -> getResultArray ( ) ; if ( empty ( $ result ) ) { return null ; } if ( $ n !== $ this -> currentRow && isset ( $ result [ $ n ] ) ) { $ this -> currentRow = $ n ; } return $ result [ $ this -> currentRow ] ; } 
public function getRowObject ( int $ n = 0 ) { $ result = $ this -> getResultObject ( ) ; if ( empty ( $ result ) ) { return null ; } if ( $ n !== $ this -> customResultObject && isset ( $ result [ $ n ] ) ) { $ this -> currentRow = $ n ; } return $ result [ $ this -> currentRow ] ; } 
public function setRow ( $ key , $ value = null ) { 
public function getFirstRow ( string $ type = 'object' ) { $ result = $ this -> getResult ( $ type ) ; return ( empty ( $ result ) ) ? null : $ result [ 0 ] ; } 
public function getLastRow ( string $ type = 'object' ) { $ result = $ this -> getResult ( $ type ) ; return ( empty ( $ result ) ) ? null : $ result [ count ( $ result ) - 1 ] ; } 
public function getNextRow ( string $ type = 'object' ) { $ result = $ this -> getResult ( $ type ) ; if ( empty ( $ result ) ) { return null ; } return isset ( $ result [ $ this -> currentRow + 1 ] ) ? $ result [ ++ $ this -> currentRow ] : null ; } 
public function getUnbufferedRow ( string $ type = 'object' ) { if ( $ type === 'array' ) { return $ this -> fetchAssoc ( ) ; } elseif ( $ type === 'object' ) { return $ this -> fetchObject ( ) ; } return $ this -> fetchObject ( $ type ) ; } 
public function media ( array $ supported , bool $ strictMatch = false ) : string { return $ this -> getBestMatch ( $ supported , $ this -> request -> getHeaderLine ( 'accept' ) , true , $ strictMatch ) ; } 
public function charset ( array $ supported ) : string { $ match = $ this -> getBestMatch ( $ supported , $ this -> request -> getHeaderLine ( 'accept-charset' ) , false , true ) ; 
public function encoding ( array $ supported = [ ] ) : string { array_push ( $ supported , 'identity' ) ; return $ this -> getBestMatch ( $ supported , $ this -> request -> getHeaderLine ( 'accept-encoding' ) ) ; } 
protected function getBestMatch ( array $ supported , string $ header = null , bool $ enforceTypes = false , bool $ strictMatch = false ) : string { if ( empty ( $ supported ) ) { throw HTTPException :: forEmptySupportedNegotiations ( ) ; } if ( empty ( $ header ) ) { return $ strictMatch ? '' : $ supported [ 0 ] ; } $ acceptable = $ this -> parseHeader ( $ header ) ; foreach ( $ acceptable as $ accept ) { 
public function parseHeader ( string $ header ) : array { $ results = [ ] ; $ acceptable = explode ( ',' , $ header ) ; foreach ( $ acceptable as $ value ) { $ pairs = explode ( ';' , $ value ) ; $ value = $ pairs [ 0 ] ; unset ( $ pairs [ 0 ] ) ; $ parameters = [ ] ; foreach ( $ pairs as $ pair ) { $ param = [ ] ; preg_match ( '/^(?P<name>.+?)=(?P<quoted>"|\')?(?P<value>.*?)(?:\k<quoted>)?$/' , $ pair , $ param ) ; $ parameters [ trim ( $ param [ 'name' ] ) ] = trim ( $ param [ 'value' ] ) ; } $ quality = 1.0 ; if ( array_key_exists ( 'q' , $ parameters ) ) { $ quality = $ parameters [ 'q' ] ; unset ( $ parameters [ 'q' ] ) ; } $ results [ ] = [ 'value' => trim ( $ value ) , 'q' => ( float ) $ quality , 'params' => $ parameters , ] ; } // Sort to get the highest results first usort ( $ results , function ( $ a , $ b ) { if ( $ a [ 'q' ] === $ b [ 'q' ] ) { $ a_ast = substr_count ( $ a [ 'value' ] , '*' ) ; $ b_ast = substr_count ( $ b [ 'value' ] , '*' ) ; // '*/*' has lower precedence than 'text/*', // and 'text/*' has lower priority than 'text/plain' // // This seems backwards, but needs to be that way // due to the way PHP7 handles ordering or array // elements created by reference. if ( $ a_ast > $ b_ast ) { return 1 ; } // If the counts are the same, but one element // has more params than another, it has higher precedence. // // This seems backwards, but needs to be that way // due to the way PHP7 handles ordering or array // elements created by reference. if ( $ a_ast === $ b_ast ) { return count ( $ b [ 'params' ] ) - count ( $ a [ 'params' ] ) ; } return 0 ; } // Still here? Higher q values have precedence. return ( $ a [ 'q' ] > $ b [ 'q' ] ) ? - 1 : 1 ; } ) ; return $ results ; } 
protected function match ( array $ acceptable , string $ supported , bool $ enforceTypes = false ) : bool { $ supported = $ this -> parseHeader ( $ supported ) ; if ( is_array ( $ supported ) && count ( $ supported ) === 1 ) { $ supported = $ supported [ 0 ] ; } 
protected function matchParameters ( array $ acceptable , array $ supported ) : bool { if ( count ( $ acceptable [ 'params' ] ) !== count ( $ supported [ 'params' ] ) ) { return false ; } foreach ( $ supported [ 'params' ] as $ label => $ value ) { if ( ! isset ( $ acceptable [ 'params' ] [ $ label ] ) || $ acceptable [ 'params' ] [ $ label ] !== $ value ) { return false ; } } return true ; } 
public function matchTypes ( array $ acceptable , array $ supported ) : bool { list ( $ aType , $ aSubType ) = explode ( '/' , $ acceptable [ 'value' ] ) ; list ( $ sType , $ sSubType ) = explode ( '/' , $ supported [ 'value' ] ) ; 
public function getFieldNames ( ) : array { $ fieldNames = [ ] ; $ this -> resultID -> field_seek ( 0 ) ; while ( $ field = $ this -> resultID -> fetch_field ( ) ) { $ fieldNames [ ] = $ field -> name ; } return $ fieldNames ; } 
public function getFieldData ( ) : array { $ retVal = [ ] ; $ fieldData = $ this -> resultID -> fetch_fields ( ) ; foreach ( $ fieldData as $ i => $ data ) { $ retVal [ $ i ] = new \ stdClass ( ) ; $ retVal [ $ i ] -> name = $ data -> name ; $ retVal [ $ i ] -> type = $ data -> type ; $ retVal [ $ i ] -> max_length = $ data -> max_length ; $ retVal [ $ i ] -> primary_key = ( int ) ( $ data -> flags & 2 ) ; $ retVal [ $ i ] -> default = $ data -> def ; } return $ retVal ; } 
public function freeResult ( ) { if ( is_object ( $ this -> resultID ) ) { $ this -> resultID -> free ( ) ; $ this -> resultID = false ; } } 
public function run ( bool $ useSafeOutput = false ) { $ path = CLI :: getURI ( ) ? : 'list' ; 
public function showHeader ( ) { CLI :: newLine ( 1 ) ; CLI :: write ( CLI :: color ( 'CodeIgniter CLI Tool' , 'green' ) . ' - Version ' . CodeIgniter :: CI_VERSION . ' - Server-Time: ' . date ( 'Y-m-d H:i:sa' ) ) ; CLI :: newLine ( 1 ) ; } 
public function links ( string $ group = 'default' , string $ template = 'default_full' ) : string { $ this -> ensureGroup ( $ group ) ; return $ this -> displayLinks ( $ group , $ template ) ; } 
public function simpleLinks ( string $ group = 'default' , string $ template = 'default_simple' ) : string { $ this -> ensureGroup ( $ group ) ; return $ this -> displayLinks ( $ group , $ template ) ; } 
public function makeLinks ( int $ page , int $ perPage , int $ total , string $ template = 'default_full' , int $ segment = 0 ) : string { $ name = time ( ) ; $ this -> store ( $ name , $ page , $ perPage , $ total , $ segment ) ; return $ this -> displayLinks ( $ name , $ template ) ; } 
protected function displayLinks ( string $ group , string $ template ) : string { $ pager = new PagerRenderer ( $ this -> getDetails ( $ group ) ) ; if ( ! array_key_exists ( $ template , $ this -> config -> templates ) ) { throw PagerException :: forInvalidTemplate ( $ template ) ; } return $ this -> view -> setVar ( 'pager' , $ pager ) -> render ( $ this -> config -> templates [ $ template ] ) ; } 
public function store ( string $ group , int $ page , int $ perPage , int $ total , int $ segment = 0 ) { $ this -> segment [ $ group ] = $ segment ; $ this -> ensureGroup ( $ group ) ; $ this -> groups [ $ group ] [ 'currentPage' ] = $ page ; $ this -> groups [ $ group ] [ 'perPage' ] = $ perPage ; $ this -> groups [ $ group ] [ 'total' ] = $ total ; $ this -> groups [ $ group ] [ 'pageCount' ] = ( int ) ceil ( $ total / $ perPage ) ; return $ this ; } 
public function setPath ( string $ path , string $ group = 'default' ) { $ this -> ensureGroup ( $ group ) ; $ this -> groups [ $ group ] [ 'uri' ] -> setPath ( $ path ) ; return $ this ; } 
public function getPageCount ( string $ group = 'default' ) : int { $ this -> ensureGroup ( $ group ) ; return $ this -> groups [ $ group ] [ 'pageCount' ] ; } 
public function getCurrentPage ( string $ group = 'default' ) : int { $ this -> ensureGroup ( $ group ) ; return $ this -> groups [ $ group ] [ 'currentPage' ] ; } 
public function hasMore ( string $ group = 'default' ) : bool { $ this -> ensureGroup ( $ group ) ; return ( $ this -> groups [ $ group ] [ 'currentPage' ] * $ this -> groups [ $ group ] [ 'perPage' ] ) < $ this -> groups [ $ group ] [ 'total' ] ; } 
public function getLastPage ( string $ group = 'default' ) { $ this -> ensureGroup ( $ group ) ; if ( ! is_numeric ( $ this -> groups [ $ group ] [ 'total' ] ) || ! is_numeric ( $ this -> groups [ $ group ] [ 'perPage' ] ) ) { return null ; } return ( int ) ceil ( $ this -> groups [ $ group ] [ 'total' ] / $ this -> groups [ $ group ] [ 'perPage' ] ) ; } 
public function getPageURI ( int $ page = null , string $ group = 'default' , bool $ returnObject = false ) { $ this -> ensureGroup ( $ group ) ; $ uri = $ this -> groups [ $ group ] [ 'uri' ] ; $ segment = $ this -> segment [ $ group ] ?? 0 ; if ( $ segment ) { $ uri -> setSegment ( $ segment , $ page ) ; } else { $ uri -> addQuery ( 'page' , $ page ) ; } if ( $ this -> only ) { $ query = array_intersect_key ( $ _GET , array_flip ( $ this -> only ) ) ; if ( ! $ segment ) { $ query [ 'page' ] = $ page ; } $ uri -> setQueryArray ( $ query ) ; } return $ returnObject === true ? $ uri : ( string ) $ uri ; } 
public function getNextPageURI ( string $ group = 'default' , bool $ returnObject = false ) { $ this -> ensureGroup ( $ group ) ; $ last = $ this -> getLastPage ( $ group ) ; $ curr = $ this -> getCurrentPage ( $ group ) ; $ page = null ; if ( ! empty ( $ last ) && ! empty ( $ curr ) && $ last === $ curr ) { return null ; } if ( $ last > $ curr ) { $ page = $ curr + 1 ; } return $ this -> getPageURI ( $ page , $ group , $ returnObject ) ; } 
public function getPreviousPageURI ( string $ group = 'default' , bool $ returnObject = false ) { $ this -> ensureGroup ( $ group ) ; $ first = $ this -> getFirstPage ( $ group ) ; $ curr = $ this -> getCurrentPage ( $ group ) ; $ page = null ; if ( ! empty ( $ first ) && ! empty ( $ curr ) && $ first === $ curr ) { return null ; } if ( $ first < $ curr ) { $ page = $ curr - 1 ; } return $ this -> getPageURI ( $ page , $ group , $ returnObject ) ; } 
public function getPerPage ( string $ group = 'default' ) : int { $ this -> ensureGroup ( $ group ) ; return ( int ) $ this -> groups [ $ group ] [ 'perPage' ] ; } 
public function getDetails ( string $ group = 'default' ) : array { if ( ! array_key_exists ( $ group , $ this -> groups ) ) { throw PagerException :: forInvalidPaginationGroup ( $ group ) ; } $ newGroup = $ this -> groups [ $ group ] ; $ newGroup [ 'next' ] = $ this -> getNextPageURI ( $ group ) ; $ newGroup [ 'previous' ] = $ this -> getPreviousPageURI ( $ group ) ; $ newGroup [ 'segment' ] = $ this -> segment [ $ group ] ?? 0 ; return $ newGroup ; } 
protected function ensureGroup ( string $ group ) { if ( array_key_exists ( $ group , $ this -> groups ) ) { return ; } $ this -> groups [ $ group ] = [ 'uri' => clone Services :: request ( ) -> uri , 'hasMore' => false , 'total' => null , 'perPage' => $ this -> config -> perPage , 'pageCount' => 1 , ] ; if ( array_key_exists ( $ group , $ this -> segment ) ) { try { $ this -> groups [ $ group ] [ 'currentPage' ] = $ this -> groups [ $ group ] [ 'uri' ] -> getSegment ( $ this -> segment [ $ group ] ) ; } catch ( \ CodeIgniter \ HTTP \ Exceptions \ HTTPException $ e ) { $ this -> groups [ $ group ] [ 'currentPage' ] = 1 ; } } else { $ this -> groups [ $ group ] [ 'currentPage' ] = $ _GET [ 'page_' . $ group ] ?? $ _GET [ 'page' ] ?? 1 ; } if ( $ _GET ) { $ this -> groups [ $ group ] [ 'uri' ] = $ this -> groups [ $ group ] [ 'uri' ] -> setQueryArray ( $ _GET ) ; } } 
public function getYears ( bool $ raw = false ) { if ( $ raw ) { return $ this -> difference / YEAR ; } $ time = clone ( $ this -> currentTime ) ; return $ time -> fieldDifference ( $ this -> testTime , IntlCalendar :: FIELD_YEAR ) ; } 
public function getMonths ( bool $ raw = false ) { if ( $ raw ) { return $ this -> difference / MONTH ; } $ time = clone ( $ this -> currentTime ) ; return $ time -> fieldDifference ( $ this -> testTime , IntlCalendar :: FIELD_MONTH ) ; } 
public function getWeeks ( bool $ raw = false ) { if ( $ raw ) { return $ this -> difference / WEEK ; } $ time = clone ( $ this -> currentTime ) ; return ( int ) ( $ time -> fieldDifference ( $ this -> testTime , IntlCalendar :: FIELD_DAY_OF_YEAR ) / 7 ) ; } 
public function getDays ( bool $ raw = false ) { if ( $ raw ) { return $ this -> difference / DAY ; } $ time = clone ( $ this -> currentTime ) ; return $ time -> fieldDifference ( $ this -> testTime , IntlCalendar :: FIELD_DAY_OF_YEAR ) ; } 
public function getHours ( bool $ raw = false ) { if ( $ raw ) { return $ this -> difference / HOUR ; } $ time = clone ( $ this -> currentTime ) ; return $ time -> fieldDifference ( $ this -> testTime , IntlCalendar :: FIELD_HOUR_OF_DAY ) ; } 
public function getMinutes ( bool $ raw = false ) { if ( $ raw ) { return $ this -> difference / MINUTE ; } $ time = clone ( $ this -> currentTime ) ; return $ time -> fieldDifference ( $ this -> testTime , IntlCalendar :: FIELD_MINUTE ) ; } 
public function getSeconds ( bool $ raw = false ) { if ( $ raw ) { return $ this -> difference ; } $ time = clone ( $ this -> currentTime ) ; return $ time -> fieldDifference ( $ this -> testTime , IntlCalendar :: FIELD_SECOND ) ; } 
public function humanize ( string $ locale = null ) : string { $ current = clone ( $ this -> currentTime ) ; $ years = $ current -> fieldDifference ( $ this -> testTime , IntlCalendar :: FIELD_YEAR ) ; $ months = $ current -> fieldDifference ( $ this -> testTime , IntlCalendar :: FIELD_MONTH ) ; $ days = $ current -> fieldDifference ( $ this -> testTime , IntlCalendar :: FIELD_DAY_OF_YEAR ) ; $ hours = $ current -> fieldDifference ( $ this -> testTime , IntlCalendar :: FIELD_HOUR_OF_DAY ) ; $ minutes = $ current -> fieldDifference ( $ this -> testTime , IntlCalendar :: FIELD_MINUTE ) ; $ phrase = null ; if ( $ years !== 0 ) { $ phrase = lang ( 'Time.years' , [ abs ( $ years ) ] , $ locale ) ; $ before = $ years < 0 ; } else if ( $ months !== 0 ) { $ phrase = lang ( 'Time.months' , [ abs ( $ months ) ] , $ locale ) ; $ before = $ months < 0 ; } else if ( $ days !== 0 && ( abs ( $ days ) >= 7 ) ) { $ weeks = ceil ( $ days / 7 ) ; $ phrase = lang ( 'Time.weeks' , [ abs ( $ weeks ) ] , $ locale ) ; $ before = $ days < 0 ; } else if ( $ days !== 0 ) { $ phrase = lang ( 'Time.days' , [ abs ( $ days ) ] , $ locale ) ; $ before = $ days < 0 ; } else if ( $ hours !== 0 ) { $ phrase = lang ( 'Time.hours' , [ abs ( $ hours ) ] , $ locale ) ; $ before = $ hours < 0 ; } else if ( $ minutes !== 0 ) { $ phrase = lang ( 'Time.minutes' , [ abs ( $ minutes ) ] , $ locale ) ; $ before = $ minutes < 0 ; } else { return lang ( 'Time.now' , [ ] , $ locale ) ; } return $ before ? lang ( 'Time.ago' , [ $ phrase ] , $ locale ) : lang ( 'Time.inFuture' , [ $ phrase ] , $ locale ) ; } 
public function load ( array $ params = [ ] , string $ alias ) { 
public function loadForge ( ConnectionInterface $ db ) { $ className = strpos ( $ db -> DBDriver , '\\' ) === false ? '\CodeIgniter\Database\\' . $ db -> DBDriver . '\\Forge' : $ db -> DBDriver . '\\Forge' ; 
public function fill ( array $ data ) { foreach ( $ data as $ key => $ value ) { $ key = $ this -> mapProperty ( $ key ) ; $ method = 'set' . str_replace ( ' ' , '' , ucwords ( str_replace ( [ '-' , '_' ] , ' ' , $ key ) ) ) ; if ( method_exists ( $ this , $ method ) ) { $ this -> $ method ( $ value ) ; } elseif ( property_exists ( $ this , $ key ) ) { $ this -> $ key = $ value ; } } return $ this ; } 
public function toArray ( bool $ onlyChanged = false , bool $ cast = true ) : array { $ this -> _cast = $ cast ; $ return = [ ] ; 
public function toRawArray ( bool $ onlyChanged = false ) : array { $ return = [ ] ; $ properties = get_object_vars ( $ this ) ; foreach ( $ properties as $ key => $ value ) { if ( substr ( $ key , 0 , 1 ) === '_' ) { continue ; } if ( $ onlyChanged && ! $ this -> hasPropertyChanged ( $ key , $ value ) ) { continue ; } $ return [ $ key ] = $ this -> $ key ; } return $ return ; } 
protected function hasPropertyChanged ( string $ key , $ value = null ) : bool { return ! ( ( $ this -> _original [ $ key ] === null && $ value === null ) || $ this -> _original [ $ key ] === $ value ) ; } 
public function __isset ( string $ key ) : bool { 
protected function mapProperty ( string $ key ) { if ( empty ( $ this -> _options [ 'datamap' ] ) ) { return $ key ; } if ( isset ( $ this -> _options [ 'datamap' ] [ $ key ] ) && ! empty ( $ this -> _options [ 'datamap' ] [ $ key ] ) ) { return $ this -> _options [ 'datamap' ] [ $ key ] ; } return $ key ; } 
protected function mutateDate ( $ value ) { if ( $ value instanceof Time ) { return $ value ; } if ( $ value instanceof \ DateTime ) { return Time :: instance ( $ value ) ; } if ( is_numeric ( $ value ) ) { return Time :: createFromTimestamp ( $ value ) ; } if ( is_string ( $ value ) ) { return Time :: parse ( $ value ) ; } return $ value ; } 
protected function castAs ( $ value , string $ type ) { if ( substr ( $ type , 0 , 1 ) === '?' ) { if ( $ value === null ) { return null ; } $ type = substr ( $ type , 1 ) ; } switch ( $ type ) { case 'int' : case 'integer' : 
private function castAsJson ( $ value , bool $ asArray = false ) { $ tmp = ! is_null ( $ value ) ? ( $ asArray ? [ ] : new \ stdClass ) : null ; if ( function_exists ( 'json_decode' ) ) { if ( ( is_string ( $ value ) && ( strpos ( $ value , '[' ) === 0 || strpos ( $ value , '{' ) === 0 || ( strpos ( $ value , '"' ) === 0 && strrpos ( $ value , '"' ) === 0 ) ) ) || is_numeric ( $ value ) ) { $ tmp = json_decode ( $ value , $ asArray ) ; if ( json_last_error ( ) !== JSON_ERROR_NONE ) { throw CastException :: forInvalidJsonFormatException ( json_last_error ( ) ) ; } } } return $ tmp ; } 
public function shouldDiscover ( string $ alias ) { if ( ! $ this -> enabled ) { return false ; } $ alias = strtolower ( $ alias ) ; return in_array ( $ alias , $ this -> activeExplorers ) ; } 
public function find ( $ id = null ) { $ builder = $ this -> builder ( ) ; if ( $ this -> tempUseSoftDeletes === true ) { $ builder -> where ( $ this -> table . '.' . $ this -> deletedField , 0 ) ; } if ( is_array ( $ id ) ) { $ row = $ builder -> whereIn ( $ this -> table . '.' . $ this -> primaryKey , $ id ) -> get ( ) ; $ row = $ row -> getResult ( $ this -> tempReturnType ) ; } elseif ( is_numeric ( $ id ) || is_string ( $ id ) ) { $ row = $ builder -> where ( $ this -> table . '.' . $ this -> primaryKey , $ id ) -> get ( ) ; $ row = $ row -> getFirstRow ( $ this -> tempReturnType ) ; } else { $ row = $ builder -> get ( ) ; $ row = $ row -> getResult ( $ this -> tempReturnType ) ; } $ row = $ this -> trigger ( 'afterFind' , [ 'id' => $ id , 'data' => $ row ] ) ; $ this -> tempReturnType = $ this -> returnType ; $ this -> tempUseSoftDeletes = $ this -> useSoftDeletes ; return $ row [ 'data' ] ; } 
public function findColumn ( string $ columnName ) { if ( strpos ( $ columnName , ',' ) !== false ) { throw DataException :: forFindColumnHaveMultipleColumns ( ) ; } $ resultSet = $ this -> select ( $ columnName ) -> asArray ( ) -> find ( ) ; return ( ! empty ( $ resultSet ) ) ? array_column ( $ resultSet , $ columnName ) : null ; } 
public function findAll ( int $ limit = 0 , int $ offset = 0 ) { $ builder = $ this -> builder ( ) ; if ( $ this -> tempUseSoftDeletes === true ) { $ builder -> where ( $ this -> table . '.' . $ this -> deletedField , 0 ) ; } $ row = $ builder -> limit ( $ limit , $ offset ) -> get ( ) ; $ row = $ row -> getResult ( $ this -> tempReturnType ) ; $ row = $ this -> trigger ( 'afterFind' , [ 'data' => $ row , 'limit' => $ limit , 'offset' => $ offset ] ) ; $ this -> tempReturnType = $ this -> returnType ; $ this -> tempUseSoftDeletes = $ this -> useSoftDeletes ; return $ row [ 'data' ] ; } 
public function first ( ) { $ builder = $ this -> builder ( ) ; if ( $ this -> tempUseSoftDeletes === true ) { $ builder -> where ( $ this -> table . '.' . $ this -> deletedField , 0 ) ; } 
public function set ( $ key , string $ value = '' , bool $ escape = null ) { $ data = is_array ( $ key ) ? $ key : [ $ key => $ value ] ; $ this -> tempData [ 'escape' ] = $ escape ; $ this -> tempData [ 'data' ] = array_merge ( $ this -> tempData [ 'data' ] ?? [ ] , $ data ) ; return $ this ; } 
public function save ( $ data ) : bool { if ( empty ( $ data ) ) { return true ; } if ( is_object ( $ data ) && isset ( $ data -> { $ this -> primaryKey } ) ) { $ response = $ this -> update ( $ data -> { $ this -> primaryKey } , $ data ) ; } elseif ( is_array ( $ data ) && ! empty ( $ data [ $ this -> primaryKey ] ) ) { $ response = $ this -> update ( $ data [ $ this -> primaryKey ] , $ data ) ; } else { $ response = $ this -> insert ( $ data , false ) ; 
public static function classToArray ( $ data , $ primaryKey = null , string $ dateFormat = 'datetime' , bool $ onlyChanged = true ) : array { if ( method_exists ( $ data , 'toRawArray' ) ) { $ properties = $ data -> toRawArray ( $ onlyChanged ) ; 
public function insert ( $ data = null , bool $ returnID = true ) { $ escape = null ; $ this -> insertID = 0 ; if ( empty ( $ data ) ) { $ data = $ this -> tempData [ 'data' ] ?? null ; $ escape = $ this -> tempData [ 'escape' ] ?? null ; $ this -> tempData = [ ] ; } if ( empty ( $ data ) ) { throw DataException :: forEmptyDataset ( 'insert' ) ; } 
public function insertBatch ( array $ set = null , bool $ escape = null , int $ batchSize = 100 , bool $ testing = false ) { if ( is_array ( $ set ) && $ this -> skipValidation === false ) { foreach ( $ set as $ row ) { if ( $ this -> validate ( $ row ) === false ) { return false ; } } } return $ this -> builder ( ) -> insertBatch ( $ set , $ escape , $ batchSize , $ testing ) ; } 
public function update ( $ id = null , $ data = null ) : bool { $ escape = null ; if ( is_numeric ( $ id ) || is_string ( $ id ) ) { $ id = [ $ id ] ; } if ( empty ( $ data ) ) { $ data = $ this -> tempData [ 'data' ] ?? null ; $ escape = $ this -> tempData [ 'escape' ] ?? null ; $ this -> tempData = [ ] ; } if ( empty ( $ data ) ) { throw DataException :: forEmptyDataset ( 'update' ) ; } 
public function updateBatch ( array $ set = null , string $ index = null , int $ batchSize = 100 , bool $ returnSQL = false ) { if ( is_array ( $ set ) && $ this -> skipValidation === false ) { foreach ( $ set as $ row ) { if ( $ this -> validate ( $ row ) === false ) { return false ; } } } return $ this -> builder ( ) -> updateBatch ( $ set , $ index , $ batchSize , $ returnSQL ) ; } 
public function delete ( $ id = null , bool $ purge = false ) { if ( ! empty ( $ id ) && is_numeric ( $ id ) ) { $ id = [ $ id ] ; } $ builder = $ this -> builder ( ) ; if ( ! empty ( $ id ) ) { $ builder = $ builder -> whereIn ( $ this -> primaryKey , $ id ) ; } $ this -> trigger ( 'beforeDelete' , [ 'id' => $ id , 'purge' => $ purge ] ) ; if ( $ this -> useSoftDeletes && ! $ purge ) { $ set [ $ this -> deletedField ] = 1 ; if ( $ this -> useTimestamps && ! empty ( $ this -> updatedField ) ) { $ set [ $ this -> updatedField ] = $ this -> setDate ( ) ; } $ result = $ builder -> update ( $ set ) ; } else { $ result = $ builder -> delete ( ) ; } $ this -> trigger ( 'afterDelete' , [ 'id' => $ id , 'purge' => $ purge , 'result' => $ result , 'data' => null ] ) ; return $ result ; } 
public function purgeDeleted ( ) { if ( ! $ this -> useSoftDeletes ) { return true ; } return $ this -> builder ( ) -> where ( $ this -> deletedField , 1 ) -> delete ( ) ; } 
public function onlyDeleted ( ) { $ this -> tempUseSoftDeletes = false ; $ this -> builder ( ) -> where ( $ this -> deletedField , 1 ) ; return $ this ; } 
public function replace ( $ data = null , bool $ returnSQL = false ) { 
public function chunk ( int $ size , Closure $ userFunc ) { $ total = $ this -> builder ( ) -> countAllResults ( false ) ; $ offset = 0 ; while ( $ offset <= $ total ) { $ builder = clone ( $ this -> builder ( ) ) ; $ rows = $ builder -> get ( $ size , $ offset ) ; if ( $ rows === false ) { throw DataException :: forEmptyDataset ( 'chunk' ) ; } $ rows = $ rows -> getResult ( $ this -> tempReturnType ) ; $ offset += $ size ; if ( empty ( $ rows ) ) { continue ; } foreach ( $ rows as $ row ) { if ( $ userFunc ( $ row ) === false ) { return ; } } } } 
public function paginate ( int $ perPage = 20 , string $ group = 'default' , int $ page = 0 ) { 
protected function builder ( string $ table = null ) { if ( $ this -> builder instanceof BaseBuilder ) { return $ this -> builder ; } 
protected function doProtectFields ( array $ data ) : array { if ( $ this -> protectFields === false ) { return $ data ; } if ( empty ( $ this -> allowedFields ) ) { throw DataException :: forInvalidAllowedFields ( get_class ( $ this ) ) ; } if ( is_array ( $ data ) && count ( $ data ) ) { foreach ( $ data as $ key => $ val ) { if ( ! in_array ( $ key , $ this -> allowedFields ) ) { unset ( $ data [ $ key ] ) ; } } } return $ data ; } 
protected function setDate ( int $ userData = null ) { $ currentDate = is_numeric ( $ userData ) ? ( int ) $ userData : time ( ) ; switch ( $ this -> dateFormat ) { case 'int' : return $ currentDate ; break ; case 'datetime' : return date ( 'Y-m-d H:i:s' , $ currentDate ) ; break ; case 'date' : return date ( 'Y-m-d' , $ currentDate ) ; break ; } } 
public function errors ( bool $ forceDB = false ) { 
public function validate ( $ data ) : bool { if ( $ this -> skipValidation === true || empty ( $ this -> validationRules ) || empty ( $ data ) ) { return true ; } 
protected function cleanValidationRules ( array $ rules , array $ data = null ) : array { if ( empty ( $ data ) ) { return [ ] ; } foreach ( $ rules as $ field => $ rule ) { if ( ! array_key_exists ( $ field , $ data ) ) { unset ( $ rules [ $ field ] ) ; } } return $ rules ; } 
protected function fillPlaceholders ( array $ rules , array $ data ) : array { $ replacements = [ ] ; foreach ( $ data as $ key => $ value ) { $ replacements [ "{{$key}}" ] = $ value ; } if ( ! empty ( $ replacements ) ) { foreach ( $ rules as & $ rule ) { if ( is_array ( $ rule ) ) { foreach ( $ rule as & $ row ) { 
public function getValidationRules ( array $ options = [ ] ) : array { $ rules = $ this -> validationRules ; if ( isset ( $ options [ 'except' ] ) ) { $ rules = array_diff_key ( $ rules , array_flip ( $ options [ 'except' ] ) ) ; } elseif ( isset ( $ options [ 'only' ] ) ) { $ rules = array_intersect_key ( $ rules , array_flip ( $ options [ 'only' ] ) ) ; } return $ rules ; } 
public function countAllResults ( bool $ reset = true , bool $ test = false ) { if ( $ this -> tempUseSoftDeletes === true ) { $ this -> builder ( ) -> where ( $ this -> deletedField , 0 ) ; } return $ this -> builder ( ) -> countAllResults ( $ reset , $ test ) ; } 
protected function trigger ( string $ event , array $ data ) { 
public function request ( $ method , string $ url , array $ options = [ ] ) : ResponseInterface { $ this -> parseOptions ( $ options ) ; $ url = $ this -> prepareURL ( $ url ) ; $ method = filter_var ( $ method , FILTER_SANITIZE_STRING ) ; $ this -> send ( $ method , $ url ) ; return $ this -> response ; } 
public function setAuth ( string $ username , string $ password , string $ type = 'basic' ) { $ this -> config [ 'auth' ] = [ $ username , $ password , $ type , ] ; return $ this ; } 
public function setForm ( array $ params , bool $ multipart = false ) { if ( $ multipart ) { $ this -> config [ 'multipart' ] = $ params ; } else { $ this -> config [ 'form_params' ] = $ params ; } return $ this ; } 
protected function parseOptions ( array $ options ) { if ( array_key_exists ( 'baseURI' , $ options ) ) { $ this -> baseURI = $ this -> baseURI -> setURI ( $ options [ 'baseURI' ] ) ; unset ( $ options [ 'baseURI' ] ) ; } if ( array_key_exists ( 'headers' , $ options ) && is_array ( $ options [ 'headers' ] ) ) { foreach ( $ options [ 'headers' ] as $ name => $ value ) { $ this -> setHeader ( $ name , $ value ) ; } unset ( $ options [ 'headers' ] ) ; } if ( array_key_exists ( 'delay' , $ options ) ) { 
protected function prepareURL ( string $ url ) : string { 
public function getMethod ( bool $ upper = false ) : string { return ( $ upper ) ? strtoupper ( $ this -> method ) : strtolower ( $ this -> method ) ; } 
public function send ( string $ method , string $ url ) { 
protected function applyRequestHeaders ( array $ curl_options = [ ] ) : array { $ headers = $ this -> getHeaders ( ) ; if ( empty ( $ headers ) ) { return $ curl_options ; } $ set = [ ] ; foreach ( $ headers as $ name => $ value ) { $ set [ ] = $ name . ': ' . $ this -> getHeaderLine ( $ name ) ; } $ curl_options [ CURLOPT_HTTPHEADER ] = $ set ; return $ curl_options ; } 
protected function applyMethod ( string $ method , array $ curl_options ) : array { $ method = strtoupper ( $ method ) ; $ this -> method = $ method ; $ curl_options [ CURLOPT_CUSTOMREQUEST ] = $ method ; $ size = strlen ( $ this -> body ) ; 
protected function applyBody ( array $ curl_options = [ ] ) : array { if ( ! empty ( $ this -> body ) ) { $ curl_options [ CURLOPT_POSTFIELDS ] = ( string ) $ this -> getBody ( ) ; } return $ curl_options ; } 
protected function setResponseHeaders ( array $ headers = [ ] ) { foreach ( $ headers as $ header ) { if ( ( $ pos = strpos ( $ header , ':' ) ) !== false ) { $ title = substr ( $ header , 0 , $ pos ) ; $ value = substr ( $ header , $ pos + 1 ) ; $ this -> response -> setHeader ( $ title , $ value ) ; } else if ( strpos ( $ header , 'HTTP' ) === 0 ) { preg_match ( '#^HTTP\/([12]\.[01]) ([0-9]+) (.+)#' , $ header , $ matches ) ; if ( isset ( $ matches [ 1 ] ) ) { $ this -> response -> setProtocolVersion ( $ matches [ 1 ] ) ; } if ( isset ( $ matches [ 2 ] ) ) { $ this -> response -> setStatusCode ( $ matches [ 2 ] , $ matches [ 3 ] ?? null ) ; } } } } 
protected function setCURLOptions ( array $ curl_options = [ ] , array $ config = [ ] ) { 
protected function sendRequest ( array $ curl_options = [ ] ) : string { $ ch = curl_init ( ) ; curl_setopt_array ( $ ch , $ curl_options ) ; 
public function run ( array $ params = [ ] ) { $ config = new App ( ) ; $ tableName = CLI :: getOption ( 't' ) ?? 'ci_sessions' ; $ path = APPPATH . 'Database/Migrations/' . date ( 'YmdHis_' ) . 'create_' . $ tableName . '_table' . '.php' ; $ data = [ 'namespace' => CLI :: getOption ( 'n' ) ?? APP_NAMESPACE ?? 'App' , 'DBGroup' => CLI :: getOption ( 'g' ) , 'tableName' => $ tableName , 'matchIP' => $ config -> sessionMatchIP ?? false , ] ; $ template = view ( '\CodeIgniter\Commands\Sessions\Views\migration.tpl.php' , $ data , [ 'debug' => false ] ) ; $ template = str_replace ( '@php' , '<?php' , $ template ) ; 
public function handle ( $ level , $ message ) : bool { $ filepath = $ this -> path . 'log-' . date ( 'Y-m-d' ) . '.' . $ this -> fileExtension ; $ msg = '' ; if ( ! is_file ( $ filepath ) ) { $ newfile = true ; 
public function version ( string $ targetVersion , string $ namespace = null , string $ group = null ) { if ( ! $ this -> enabled ) { throw ConfigException :: forDisabledMigrations ( ) ; } $ this -> ensureTable ( ) ; 
public function current ( string $ group = null ) { $ this -> ensureTable ( ) ; 
public function findMigrations ( ) : array { $ migrations = [ ] ; 
protected function checkMigrations ( array $ migrations , string $ method , string $ targetVersion ) : bool { 
public function getHistory ( string $ group = 'default' ) : array { $ this -> ensureTable ( ) ; $ query = $ this -> db -> table ( $ this -> table ) -> where ( 'group' , $ group ) -> where ( 'namespace' , $ this -> namespace ) -> orderBy ( 'version' , 'ASC' ) -> get ( ) ; if ( ! $ query ) { return [ ] ; } return $ query -> getResultArray ( ) ; } 
protected function getMigrationName ( string $ migration ) : string { $ parts = explode ( '_' , $ migration ) ; array_shift ( $ parts ) ; return implode ( '_' , $ parts ) ; } 
protected function getVersion ( ) : string { $ this -> ensureTable ( ) ; $ row = $ this -> db -> table ( $ this -> table ) -> select ( 'version' ) -> where ( 'group' , $ this -> group ) -> where ( 'namespace' , $ this -> namespace ) -> orderBy ( 'version' , 'DESC' ) -> get ( ) ; return $ row && ! is_null ( $ row -> getRow ( ) ) ? $ row -> getRow ( ) -> version : '0' ; } 
protected function addHistory ( string $ version ) { $ this -> db -> table ( $ this -> table ) -> insert ( [ 'version' => $ version , 'name' => $ this -> name , 'group' => $ this -> group , 'namespace' => $ this -> namespace , 'time' => time ( ) , ] ) ; if ( is_cli ( ) ) { $ this -> cliMessages [ ] = "\t" . CLI :: color ( lang ( 'Migrations.added' ) , 'yellow' ) . "($this->namespace) " . $ version . '_' . $ this -> name ; } } 
protected function removeHistory ( string $ version ) { $ this -> db -> table ( $ this -> table ) -> where ( 'version' , $ version ) -> where ( 'group' , $ this -> group ) -> where ( 'namespace' , $ this -> namespace ) -> delete ( ) ; if ( is_cli ( ) ) { $ this -> cliMessages [ ] = "\t" . CLI :: color ( lang ( 'Migrations.removed' ) , 'yellow' ) . "($this->namespace) " . $ version . '_' . $ this -> name ; } } 
public function ensureTable ( ) { if ( $ this -> tableChecked || $ this -> db -> tableExists ( $ this -> table ) ) { return ; } $ forge = \ Config \ Database :: forge ( $ this -> db ) ; $ forge -> addField ( [ 'version' => [ 'type' => 'VARCHAR' , 'constraint' => 255 , 'null' => false , ] , 'name' => [ 'type' => 'VARCHAR' , 'constraint' => 255 , 'null' => false , ] , 'group' => [ 'type' => 'VARCHAR' , 'constraint' => 255 , 'null' => false , ] , 'namespace' => [ 'type' => 'VARCHAR' , 'constraint' => 255 , 'null' => false , ] , 'time' => [ 'type' => 'INT' , 'constraint' => 11 , 'null' => false , ] , ] ) ; $ forge -> createTable ( $ this -> table , true ) ; $ this -> tableChecked = true ; } 
public function run ( array $ data = null , string $ group = null , string $ db_group = null ) : bool { $ data = $ data ?? $ this -> data ; 
public function check ( $ value , string $ rule , array $ errors = [ ] ) : bool { $ this -> reset ( ) ; $ this -> setRule ( 'check' , null , $ rule , $ errors ) ; return $ this -> run ( [ 'check' => $ value , ] ) ; } 
protected function processRules ( string $ field , string $ label = null , $ value , $ rules = null , array $ data ) : bool { 
public function withRequest ( RequestInterface $ request ) : ValidationInterface { if ( in_array ( $ request -> getMethod ( ) , [ 'put' , 'patch' , 'delete' ] ) ) { $ this -> data = $ request -> getRawInput ( ) ; } else { $ this -> data = $ request -> getVar ( ) ?? [ ] ; } return $ this ; } 
public function setRule ( string $ field , string $ label = null , string $ rules , array $ errors = [ ] ) { $ this -> rules [ $ field ] = [ 'label' => $ label , 'rules' => $ rules , ] ; $ this -> customErrors = array_merge ( $ this -> customErrors , [ $ field => $ errors , ] ) ; return $ this ; } 
public function setRules ( array $ rules , array $ errors = [ ] ) : ValidationInterface { $ this -> customErrors = $ errors ; foreach ( $ rules as $ field => & $ rule ) { if ( is_array ( $ rule ) ) { if ( array_key_exists ( 'errors' , $ rule ) ) { $ this -> customErrors [ $ field ] = $ rule [ 'errors' ] ; unset ( $ rule [ 'errors' ] ) ; } } } $ this -> rules = $ rules ; return $ this ; } 
public function getRuleGroup ( string $ group ) : array { if ( ! isset ( $ this -> config -> $ group ) ) { throw ValidationException :: forGroupNotFound ( $ group ) ; } if ( ! is_array ( $ this -> config -> $ group ) ) { throw ValidationException :: forGroupNotArray ( $ group ) ; } return $ this -> config -> $ group ; } 
public function setRuleGroup ( string $ group ) { $ rules = $ this -> getRuleGroup ( $ group ) ; $ this -> rules = $ rules ; $ errorName = $ group . '_errors' ; if ( isset ( $ this -> config -> $ errorName ) ) { $ this -> customErrors = $ this -> config -> $ errorName ; } } 
public function listErrors ( string $ template = 'list' ) : string { if ( ! array_key_exists ( $ template , $ this -> config -> templates ) ) { throw ValidationException :: forInvalidTemplate ( $ template ) ; } return $ this -> view -> setVar ( 'errors' , $ this -> getErrors ( ) ) -> render ( $ this -> config -> templates [ $ template ] ) ; } 
public function showError ( string $ field , string $ template = 'single' ) : string { if ( ! array_key_exists ( $ field , $ this -> getErrors ( ) ) ) { return '' ; } if ( ! array_key_exists ( $ template , $ this -> config -> templates ) ) { throw ValidationException :: forInvalidTemplate ( $ template ) ; } return $ this -> view -> setVar ( 'error' , $ this -> getError ( $ field ) ) -> render ( $ this -> config -> templates [ $ template ] ) ; } 
protected function loadRuleSets ( ) { if ( empty ( $ this -> ruleSetFiles ) ) { throw ValidationException :: forNoRuleSets ( ) ; } foreach ( $ this -> ruleSetFiles as $ file ) { $ this -> ruleSetInstances [ ] = new $ file ( ) ; } } 
public function loadRuleGroup ( string $ group = null ) { if ( empty ( $ group ) ) { return null ; } if ( ! isset ( $ this -> config -> $ group ) ) { throw ValidationException :: forGroupNotFound ( $ group ) ; } if ( ! is_array ( $ this -> config -> $ group ) ) { throw ValidationException :: forGroupNotArray ( $ group ) ; } $ this -> rules = $ this -> config -> $ group ; 
public function getError ( string $ field = null ) : string { if ( $ field === null && count ( $ this -> rules ) === 1 ) { reset ( $ this -> rules ) ; $ field = key ( $ this -> rules ) ; } return array_key_exists ( $ field , $ this -> getErrors ( ) ) ? $ this -> errors [ $ field ] : '' ; } 
public function getErrors ( ) : array { 
public function setError ( string $ field , string $ error ) : ValidationInterface { $ this -> errors [ $ field ] = $ error ; return $ this ; } 
protected function getErrorMessage ( string $ rule , string $ field , string $ label = null , string $ param = null ) : string { 
protected function splitRules ( string $ rules ) : array { $ non_escape_bracket = '((?<!\\\\)(?:\\\\\\\\)*[\[\]])' ; $ pipe_not_in_bracket = sprintf ( '/\|(?=(?:[^\[\]]*%s[^\[\]]*%s)*(?![^\[\]]*%s))/' , $ non_escape_bracket , $ non_escape_bracket , $ non_escape_bracket ) ; $ _rules = preg_split ( $ pipe_not_in_bracket , $ rules ) ; return array_unique ( $ _rules ) ; } 
public function reset ( ) : ValidationInterface { $ this -> data = [ ] ; $ this -> rules = [ ] ; $ this -> errors = [ ] ; $ this -> customErrors = [ ] ; return $ this ; } 
public function format ( $ data ) { 
protected function arrayToXML ( array $ data , & $ output ) { foreach ( $ data as $ key => $ value ) { if ( is_array ( $ value ) ) { if ( ! is_numeric ( $ key ) ) { $ subnode = $ output -> addChild ( "$key" ) ; $ this -> arrayToXML ( $ value , $ subnode ) ; } else { $ subnode = $ output -> addChild ( "item{$key}" ) ; $ this -> arrayToXML ( $ value , $ subnode ) ; } } else { $ output -> addChild ( "$key" , htmlspecialchars ( "$value" ) ) ; } } } 
public function log ( $ level , $ message , array $ context = [ ] ) : bool { if ( is_numeric ( $ level ) ) { $ level = array_search ( ( int ) $ level , $ this -> logLevels ) ; } * @var \CodeIgniter\Log\Handlers\HandlerInterface */ $ handler = $ this -> handlers [ $ className ] ; if ( ! $ handler -> canHandle ( $ level ) ) { continue ; } 
protected function interpolate ( $ message , array $ context = [ ] ) { if ( ! is_string ( $ message ) ) { return $ message ; } 
public function determineFile ( ) : array { 
protected function cleanFileNames ( string $ file ) : string { $ file = str_replace ( APPPATH , 'APPPATH/' , $ file ) ; $ file = str_replace ( SYSTEMPATH , 'SYSTEMPATH/' , $ file ) ; $ file = str_replace ( FCPATH , 'FCPATH/' , $ file ) ; return $ file ; } 
public function setURI ( string $ uri = null ) { if ( ! is_null ( $ uri ) ) { $ parts = parse_url ( $ uri ) ; if ( $ parts === false ) { throw HTTPException :: forUnableToParseURI ( $ uri ) ; } $ this -> applyParts ( $ parts ) ; } return $ this ; } 
public function getAuthority ( bool $ ignorePort = false ) : string { if ( empty ( $ this -> host ) ) { return '' ; } $ authority = $ this -> host ; if ( ! empty ( $ this -> getUserInfo ( ) ) ) { $ authority = $ this -> getUserInfo ( ) . '@' . $ authority ; } if ( ! empty ( $ this -> port ) && ! $ ignorePort ) { 
public function getUserInfo ( ) { $ userInfo = $ this -> user ; if ( $ this -> showPassword === true && ! empty ( $ this -> password ) ) { $ userInfo .= ':' . $ this -> password ; } return $ userInfo ; } 
public function getQuery ( array $ options = [ ] ) : string { $ vars = $ this -> query ; if ( array_key_exists ( 'except' , $ options ) ) { if ( ! is_array ( $ options [ 'except' ] ) ) { $ options [ 'except' ] = [ $ options [ 'except' ] ] ; } foreach ( $ options [ 'except' ] as $ var ) { unset ( $ vars [ $ var ] ) ; } } elseif ( array_key_exists ( 'only' , $ options ) ) { $ temp = [ ] ; if ( ! is_array ( $ options [ 'only' ] ) ) { $ options [ 'only' ] = [ $ options [ 'only' ] ] ; } foreach ( $ options [ 'only' ] as $ var ) { if ( array_key_exists ( $ var , $ vars ) ) { $ temp [ $ var ] = $ vars [ $ var ] ; } } $ vars = $ temp ; } return empty ( $ vars ) ? '' : http_build_query ( $ vars ) ; } 
public function getSegment ( int $ number ) : string { 
public function setSegment ( int $ number , $ value ) { 
public static function createURIString ( string $ scheme = null , string $ authority = null , string $ path = null , string $ query = null , string $ fragment = null ) : string { $ uri = '' ; if ( ! empty ( $ scheme ) ) { $ uri .= $ scheme . '://' ; } if ( ! empty ( $ authority ) ) { $ uri .= $ authority ; } if ( $ path ) { $ uri .= substr ( $ uri , - 1 , 1 ) !== '/' ? '/' . ltrim ( $ path , '/' ) : $ path ; } if ( $ query ) { $ uri .= '?' . $ query ; } if ( $ fragment ) { $ uri .= '#' . $ fragment ; } return $ uri ; } 
public function setAuthority ( string $ str ) { $ parts = parse_url ( $ str ) ; if ( empty ( $ parts [ 'host' ] ) && ! empty ( $ parts [ 'path' ] ) ) { $ parts [ 'host' ] = $ parts [ 'path' ] ; unset ( $ parts [ 'path' ] ) ; } $ this -> applyParts ( $ parts ) ; return $ this ; } 
public function setScheme ( string $ str ) { $ str = strtolower ( $ str ) ; $ str = preg_replace ( '#:(//)?$#' , '' , $ str ) ; $ this -> scheme = $ str ; return $ this ; } 
public function setUserInfo ( string $ user , string $ pass ) { $ this -> user = trim ( $ user ) ; $ this -> password = trim ( $ pass ) ; return $ this ; } 
public function setPort ( int $ port = null ) { if ( is_null ( $ port ) ) { return $ this ; } if ( $ port <= 0 || $ port > 65535 ) { throw HTTPException :: forInvalidPort ( $ port ) ; } $ this -> port = $ port ; return $ this ; } 
public function setPath ( string $ path ) { $ this -> path = $ this -> filterPath ( $ path ) ; $ this -> segments = explode ( '/' , $ this -> path ) ; return $ this ; } 
public function refreshPath ( ) { $ this -> path = $ this -> filterPath ( implode ( '/' , $ this -> segments ) ) ; $ this -> segments = explode ( '/' , $ this -> path ) ; return $ this ; } 
public function setQuery ( string $ query ) { if ( strpos ( $ query , '#' ) !== false ) { throw HTTPException :: forMalformedQueryString ( ) ; } 
protected function decode ( string $ value ) : string { if ( empty ( $ value ) ) { return $ value ; } $ decoded = urldecode ( $ value ) ; 
protected function splitQueryPart ( string $ part ) { $ parts = explode ( '=' , $ part , 2 ) ; 
public function addQuery ( string $ key , $ value = null ) { $ this -> query [ $ key ] = $ value ; return $ this ; } 
public function keepQuery ( ... $ params ) { $ temp = [ ] ; foreach ( $ this -> query as $ key => $ value ) { if ( ! in_array ( $ key , $ params ) ) { continue ; } $ temp [ $ key ] = $ value ; } $ this -> query = $ temp ; return $ this ; } 
protected function filterPath ( string $ path = null ) : string { $ orig = $ path ; 
protected function applyParts ( array $ parts ) { if ( ! empty ( $ parts [ 'host' ] ) ) { $ this -> host = $ parts [ 'host' ] ; } if ( ! empty ( $ parts [ 'user' ] ) ) { $ this -> user = $ parts [ 'user' ] ; } if ( ! empty ( $ parts [ 'path' ] ) ) { $ this -> path = $ this -> filterPath ( $ parts [ 'path' ] ) ; } if ( ! empty ( $ parts [ 'query' ] ) ) { $ this -> setQuery ( $ parts [ 'query' ] ) ; } if ( ! empty ( $ parts [ 'fragment' ] ) ) { $ this -> fragment = $ parts [ 'fragment' ] ; } 
public function resolveRelativeURI ( string $ uri ) { $ relative = new URI ( ) ; $ relative -> setURI ( $ uri ) ; if ( $ relative -> getScheme ( ) === $ this -> getScheme ( ) ) { $ relative -> setScheme ( '' ) ; } $ transformed = clone $ relative ; 
protected function mergePaths ( URI $ base , URI $ reference ) : string { if ( ! empty ( $ base -> getAuthority ( ) ) && empty ( $ base -> getPath ( ) ) ) { return '/' . ltrim ( $ reference -> getPath ( ) , '/ ' ) ; } $ path = explode ( '/' , $ base -> getPath ( ) ) ; if ( empty ( $ path [ 0 ] ) ) { unset ( $ path [ 0 ] ) ; } array_pop ( $ path ) ; array_push ( $ path , $ reference -> getPath ( ) ) ; return implode ( '/' , $ path ) ; } 
public function removeDotSegments ( string $ path ) : string { if ( empty ( $ path ) || $ path === '/' ) { return $ path ; } $ output = [ ] ; $ input = explode ( '/' , $ path ) ; if ( empty ( $ input [ 0 ] ) ) { unset ( $ input [ 0 ] ) ; $ input = array_values ( $ input ) ; } 
public function run ( array $ params ) { $ config = new Autoload ( ) ; $ tbody = [ ] ; foreach ( $ config -> psr4 as $ ns => $ path ) { $ path = realpath ( $ path ) ?? $ path ; $ tbody [ ] = [ $ ns , realpath ( $ path ) ?? $ path , is_dir ( $ path ) ? 'Yes' : 'MISSING' , ] ; } $ thead = [ 'Namespace' , 'Path' , 'Found?' , ] ; CLI :: table ( $ tbody , $ thead ) ; } 
public function appendValue ( $ value = null ) { if ( ! is_array ( $ this -> value ) ) { $ this -> value = [ $ this -> value ] ; } $ this -> value [ ] = $ value ; return $ this ; } 
public function prependValue ( $ value = null ) { if ( ! is_array ( $ this -> value ) ) { $ this -> value = [ $ this -> value ] ; } array_unshift ( $ this -> value , $ value ) ; return $ this ; } 
public function getValueLine ( ) : string { if ( is_string ( $ this -> value ) ) { return $ this -> value ; } else if ( ! is_array ( $ this -> value ) ) { return '' ; } $ options = [ ] ; foreach ( $ this -> value as $ key => $ value ) { if ( is_string ( $ key ) && ! is_array ( $ value ) ) { $ options [ ] = $ key . '=' . $ value ; } else if ( is_array ( $ value ) ) { $ key = key ( $ value ) ; $ options [ ] = $ key . '=' . $ value [ $ key ] ; } else if ( is_numeric ( $ key ) ) { $ options [ ] = $ value ; } } return implode ( ', ' , $ options ) ; } 
public function getPrevious ( ) { if ( ! $ this -> hasPrevious ( ) ) { return null ; } $ uri = clone $ this -> uri ; if ( $ this -> segment === 0 ) { $ uri -> addQuery ( 'page' , $ this -> first - 1 ) ; } else { $ uri -> setSegment ( $ this -> segment , $ this -> first - 1 ) ; } return ( string ) $ uri ; } 
public function getNext ( ) { if ( ! $ this -> hasNext ( ) ) { return null ; } $ uri = clone $ this -> uri ; if ( $ this -> segment === 0 ) { $ uri -> addQuery ( 'page' , $ this -> last + 1 ) ; } else { $ uri -> setSegment ( $ this -> segment , $ this -> last + 1 ) ; } return ( string ) $ uri ; } 
public function getFirst ( ) : string { $ uri = clone $ this -> uri ; if ( $ this -> segment === 0 ) { $ uri -> addQuery ( 'page' , 1 ) ; } else { $ uri -> setSegment ( $ this -> segment , 1 ) ; } return ( string ) $ uri ; } 
public function getLast ( ) : string { $ uri = clone $ this -> uri ; if ( $ this -> segment === 0 ) { $ uri -> addQuery ( 'page' , $ this -> pageCount ) ; } else { $ uri -> setSegment ( $ this -> segment , $ this -> pageCount ) ; } return ( string ) $ uri ; } 
public function getCurrent ( ) : string { $ uri = clone $ this -> uri ; if ( $ this -> segment === 0 ) { $ uri -> addQuery ( 'page' , $ this -> current ) ; } else { $ uri -> setSegment ( $ this -> segment , $ this -> current ) ; } return ( string ) $ uri ; } 
public function links ( ) : array { $ links = [ ] ; $ uri = clone $ this -> uri ; for ( $ i = $ this -> first ; $ i <= $ this -> last ; $ i ++ ) { $ links [ ] = [ 'uri' => ( string ) ( $ this -> segment === 0 ? $ uri -> addQuery ( 'page' , $ i ) : $ uri -> setSegment ( $ this -> segment , $ i ) ) , 'title' => ( int ) $ i , 'active' => ( $ i === $ this -> current ) , ] ; } return $ links ; } 
protected function updatePages ( int $ count = null ) { if ( is_null ( $ count ) ) { return ; } $ this -> first = $ this -> current - $ count > 0 ? ( int ) ( $ this -> current - $ count ) : 1 ; $ this -> last = $ this -> current + $ count <= $ this -> pageCount ? ( int ) ( $ this -> current + $ count ) : ( int ) $ this -> pageCount ; } 
public function start ( string $ name , float $ time = null ) { $ this -> timers [ strtolower ( $ name ) ] = [ 'start' => ! empty ( $ time ) ? $ time : microtime ( true ) , 'end' => null , ] ; return $ this ; } 
public function stop ( string $ name ) { $ name = strtolower ( $ name ) ; if ( empty ( $ this -> timers [ $ name ] ) ) { throw new \ RuntimeException ( 'Cannot stop timer: invalid name given.' ) ; } $ this -> timers [ $ name ] [ 'end' ] = microtime ( true ) ; return $ this ; } 
public function getElapsedTime ( string $ name , int $ decimals = 4 ) { $ name = strtolower ( $ name ) ; if ( empty ( $ this -> timers [ $ name ] ) ) { return null ; } $ timer = $ this -> timers [ $ name ] ; if ( empty ( $ timer [ 'end' ] ) ) { $ timer [ 'end' ] = microtime ( true ) ; } return ( float ) number_format ( $ timer [ 'end' ] - $ timer [ 'start' ] , $ decimals ) ; } 
public function getTimers ( int $ decimals = 4 ) : array { $ timers = $ this -> timers ; foreach ( $ timers as & $ timer ) { if ( empty ( $ timer [ 'end' ] ) ) { $ timer [ 'end' ] = microtime ( true ) ; } $ timer [ 'duration' ] = ( float ) number_format ( $ timer [ 'end' ] - $ timer [ 'start' ] , $ decimals ) ; } return $ timers ; } 
public function initialize ( ) { if ( $ this -> connID ) { return ; } 
public function addTableAlias ( string $ table ) { if ( ! in_array ( $ table , $ this -> aliasedTables ) ) { $ this -> aliasedTables [ ] = $ table ; } return $ this ; } 
public function query ( string $ sql , $ binds = null , bool $ setEscapeFlags = true , string $ queryClass = 'CodeIgniter\\Database\\Query' ) { if ( empty ( $ this -> connID ) ) { $ this -> initialize ( ) ; } $ resultClass = str_replace ( 'Connection' , 'Result' , get_class ( $ this ) ) ; $ query = new $ queryClass ( $ this ) ; $ query -> setQuery ( $ sql , $ binds , $ setEscapeFlags ) ; if ( ! empty ( $ this -> swapPre ) && ! empty ( $ this -> DBPrefix ) ) { $ query -> swapPrefix ( $ this -> DBPrefix , $ this -> swapPre ) ; } $ startTime = microtime ( true ) ; 
public function simpleQuery ( string $ sql ) { if ( empty ( $ this -> connID ) ) { $ this -> initialize ( ) ; } return $ this -> execute ( $ sql ) ; } 
public function transStart ( bool $ test_mode = false ) : bool { if ( ! $ this -> transEnabled ) { return false ; } return $ this -> transBegin ( $ test_mode ) ; } 
public function transComplete ( ) : bool { if ( ! $ this -> transEnabled ) { return false ; } 
public function transBegin ( bool $ test_mode = false ) : bool { if ( ! $ this -> transEnabled ) { return false ; } 
public function transCommit ( ) : bool { if ( ! $ this -> transEnabled || $ this -> transDepth === 0 ) { return false ; } 
public function transRollback ( ) : bool { if ( ! $ this -> transEnabled || $ this -> transDepth === 0 ) { return false ; } 
public function table ( $ tableName ) { if ( empty ( $ tableName ) ) { throw new DatabaseException ( 'You must set the database table to be used with your query.' ) ; } $ className = str_replace ( 'Connection' , 'Builder' , get_class ( $ this ) ) ; return new $ className ( $ tableName , $ this ) ; } 
public function prepare ( \ Closure $ func , array $ options = [ ] ) { if ( empty ( $ this -> connID ) ) { $ this -> initialize ( ) ; } $ this -> pretend ( true ) ; $ sql = $ func ( $ this ) ; $ this -> pretend ( false ) ; if ( $ sql instanceof QueryInterface ) { $ sql = $ sql -> getOriginalQuery ( ) ; } $ class = str_ireplace ( 'Connection' , 'PreparedQuery' , get_class ( $ this ) ) ; $ class = new $ class ( $ this ) ; return $ class -> prepare ( $ sql , $ options ) ; } 
public function protectIdentifiers ( $ item , bool $ prefixSingle = false , bool $ protectIdentifiers = null , bool $ fieldExists = true ) { if ( ! is_bool ( $ protectIdentifiers ) ) { $ protectIdentifiers = $ this -> protectIdentifiers ; } if ( is_array ( $ item ) ) { $ escaped_array = [ ] ; foreach ( $ item as $ k => $ v ) { $ escaped_array [ $ this -> protectIdentifiers ( $ k ) ] = $ this -> protectIdentifiers ( $ v , $ prefixSingle , $ protectIdentifiers , $ fieldExists ) ; } return $ escaped_array ; } 
public function escapeIdentifiers ( $ item ) { if ( $ this -> escapeChar === '' || empty ( $ item ) || in_array ( $ item , $ this -> reservedIdentifiers ) ) { return $ item ; } elseif ( is_array ( $ item ) ) { foreach ( $ item as $ key => $ value ) { $ item [ $ key ] = $ this -> escapeIdentifiers ( $ value ) ; } return $ item ; } 
public function escape ( $ str ) { if ( is_array ( $ str ) ) { $ str = array_map ( [ & $ this , 'escape' ] , $ str ) ; return $ str ; } else if ( is_string ( $ str ) || ( is_object ( $ str ) && method_exists ( $ str , '__toString' ) ) ) { return "'" . $ this -> escapeString ( $ str ) . "'" ; } else if ( is_bool ( $ str ) ) { return ( $ str === false ) ? 0 : 1 ; } else if ( is_numeric ( $ str ) && $ str < 0 ) { return "'{$str}'" ; } else if ( $ str === null ) { return 'NULL' ; } return $ str ; } 
public function escapeString ( $ str , bool $ like = false ) { if ( is_array ( $ str ) ) { foreach ( $ str as $ key => $ val ) { $ str [ $ key ] = $ this -> escapeString ( $ val , $ like ) ; } return $ str ; } $ str = $ this -> _escapeString ( $ str ) ; 
public function callFunction ( string $ functionName , ... $ params ) : bool { $ driver = ( $ this -> DBDriver === 'postgre' ? 'pg' : strtolower ( $ this -> DBDriver ) ) . '_' ; if ( false === strpos ( $ driver , $ functionName ) ) { $ functionName = $ driver . $ functionName ; } if ( ! function_exists ( $ functionName ) ) { if ( $ this -> DBDebug ) { throw new DatabaseException ( 'This feature is not available for the database you are using.' ) ; } return false ; } return $ functionName ( ... $ params ) ; } 
public function listTables ( bool $ constrainByPrefix = false ) { * Due to array_shift() accepting its argument by reference, if * E_STRICT is on, this would trigger a warning. So we'll have to * assign it first. */ $ key = array_keys ( $ row ) ; $ key = array_shift ( $ key ) ; } } $ this -> dataCache [ 'table_names' ] [ ] = $ row [ $ key ] ; } return $ this -> dataCache [ 'table_names' ] ; } 
public function tableExists ( string $ tableName ) : bool { return in_array ( $ this -> protectIdentifiers ( $ tableName , true , false , false ) , $ this -> listTables ( ) ) ; } 
public function fieldExists ( string $ fieldName , string $ tableName ) : bool { return in_array ( $ fieldName , $ this -> getFieldNames ( $ tableName ) ) ; } 
public function getFieldData ( string $ table ) { $ fields = $ this -> _fieldData ( $ this -> protectIdentifiers ( $ table , true , false , false ) ) ; return $ fields ?? false ; } 
public function getIndexData ( string $ table ) { $ fields = $ this -> _indexData ( $ this -> protectIdentifiers ( $ table , true , false , false ) ) ; return $ fields ?? false ; } 
public function getForeignKeyData ( string $ table ) { $ fields = $ this -> _foreignKeyData ( $ this -> protectIdentifiers ( $ table , true , false , false ) ) ; return $ fields ?? false ; } 
protected function getEnvValue ( string $ property , string $ prefix , string $ shortPrefix ) { $ shortPrefix = ltrim ( $ shortPrefix , '\\' ) ; switch ( true ) { case array_key_exists ( "{$shortPrefix}.{$property}" , $ _ENV ) : return $ _ENV [ "{$shortPrefix}.{$property}" ] ; break ; case array_key_exists ( "{$shortPrefix}.{$property}" , $ _SERVER ) : return $ _SERVER [ "{$shortPrefix}.{$property}" ] ; break ; case array_key_exists ( "{$prefix}.{$property}" , $ _ENV ) : return $ _ENV [ "{$prefix}.{$property}" ] ; break ; case array_key_exists ( "{$prefix}.{$property}" , $ _SERVER ) : return $ _SERVER [ "{$prefix}.{$property}" ] ; break ; default : $ value = getenv ( $ property ) ; return $ value === false ? null : $ value ; } } 
protected function registerProperties ( ) { if ( ! static :: $ moduleConfig -> shouldDiscover ( 'registrars' ) ) { return ; } if ( ! static :: $ didDiscovery ) { $ locator = \ Config \ Services :: locator ( ) ; $ registrarsFiles = $ locator -> search ( 'Config/Registrar.php' ) ; foreach ( $ registrarsFiles as $ file ) { $ className = $ locator -> getClassname ( $ file ) ; static :: $ registrars [ ] = new $ className ( ) ; } static :: $ didDiscovery = true ; } $ shortName = ( new \ ReflectionClass ( $ this ) ) -> getShortName ( ) ; 
public function get ( string $ key ) { $ key = $ this -> prefix . $ key ; $ data = $ this -> getItem ( $ key ) ; return is_array ( $ data ) ? $ data [ 'data' ] : null ; } 
public function save ( string $ key , $ value , int $ ttl = 60 ) { $ key = $ this -> prefix . $ key ; $ contents = [ 'time' => time ( ) , 'ttl' => $ ttl , 'data' => $ value , ] ; if ( $ this -> writeFile ( $ this -> path . $ key , serialize ( $ contents ) ) ) { chmod ( $ this -> path . $ key , 0640 ) ; return true ; } return false ; } 
public function delete ( string $ key ) { $ key = $ this -> prefix . $ key ; return is_file ( $ this -> path . $ key ) ? unlink ( $ this -> path . $ key ) : false ; } 
public function decrement ( string $ key , int $ offset = 1 ) { $ key = $ this -> prefix . $ key ; $ data = $ this -> getItem ( $ key ) ; if ( $ data === false ) { $ data = [ 'data' => 0 , 'ttl' => 60 , ] ; } elseif ( ! is_int ( $ data [ 'data' ] ) ) { return false ; } $ new_value = $ data [ 'data' ] - $ offset ; return $ this -> save ( $ key , $ new_value , $ data [ 'ttl' ] ) ? $ new_value : false ; } 
public function getMetaData ( string $ key ) { $ key = $ this -> prefix . $ key ; if ( ! is_file ( $ this -> path . $ key ) ) { return false ; } $ data = @ unserialize ( file_get_contents ( $ this -> path . $ key ) ) ; if ( is_array ( $ data ) ) { $ mtime = filemtime ( $ this -> path . $ key ) ; if ( ! isset ( $ data [ 'ttl' ] ) ) { return false ; } return [ 'expire' => $ mtime + $ data [ 'ttl' ] , 'mtime' => $ mtime , 'data' => $ data [ 'data' ] , ] ; } return false ; } 
protected function getItem ( string $ key ) { if ( ! is_file ( $ this -> path . $ key ) ) { return false ; } $ data = unserialize ( file_get_contents ( $ this -> path . $ key ) ) ; if ( $ data [ 'ttl' ] > 0 && time ( ) > $ data [ 'time' ] + $ data [ 'ttl' ] ) { unlink ( $ this -> path . $ key ) ; return false ; } return $ data ; } 
protected function writeFile ( $ path , $ data , $ mode = 'wb' ) { if ( ( $ fp = @ fopen ( $ path , $ mode ) ) === false ) { return false ; } flock ( $ fp , LOCK_EX ) ; for ( $ result = $ written = 0 , $ length = strlen ( $ data ) ; $ written < $ length ; $ written += $ result ) { if ( ( $ result = fwrite ( $ fp , substr ( $ data , $ written ) ) ) === false ) { break ; } } flock ( $ fp , LOCK_UN ) ; fclose ( $ fp ) ; return is_int ( $ result ) ; } 
protected function deleteFiles ( string $ path , bool $ del_dir = false , bool $ htdocs = false , int $ _level = 0 ) : bool { 
protected function getDirFileInfo ( string $ source_dir , bool $ top_level_only = true , bool $ _recursion = false ) { static $ _filedata = [ ] ; $ relative_path = $ source_dir ; if ( $ fp = @ opendir ( $ source_dir ) ) { 
protected function getFileInfo ( string $ file , $ returned_values = [ 'name' , 'server_path' , 'size' , 'date' ] ) { if ( ! is_file ( $ file ) ) { return false ; } if ( is_string ( $ returned_values ) ) { $ returned_values = explode ( ',' , $ returned_values ) ; } foreach ( $ returned_values as $ key ) { switch ( $ key ) { case 'name' : $ fileInfo [ 'name' ] = basename ( $ file ) ; break ; case 'server_path' : $ fileInfo [ 'server_path' ] = $ file ; break ; case 'size' : $ fileInfo [ 'size' ] = filesize ( $ file ) ; break ; case 'date' : $ fileInfo [ 'date' ] = filemtime ( $ file ) ; break ; case 'readable' : $ fileInfo [ 'readable' ] = is_readable ( $ file ) ; break ; case 'writable' : $ fileInfo [ 'writable' ] = is_writable ( $ file ) ; break ; case 'executable' : $ fileInfo [ 'executable' ] = is_executable ( $ file ) ; break ; case 'fileperms' : $ fileInfo [ 'fileperms' ] = fileperms ( $ file ) ; break ; } } return $ fileInfo ; } 
public function display ( ) : array { $ rawFiles = get_included_files ( ) ; $ coreFiles = [ ] ; $ userFiles = [ ] ; foreach ( $ rawFiles as $ file ) { $ path = $ this -> cleanPath ( $ file ) ; if ( strpos ( $ path , 'SYSTEMPATH' ) !== false ) { $ coreFiles [ ] = [ 'name' => basename ( $ file ) , 'path' => $ path , ] ; } else { $ userFiles [ ] = [ 'name' => basename ( $ file ) , 'path' => $ path , ] ; } } sort ( $ userFiles ) ; sort ( $ coreFiles ) ; return [ 'coreFiles' => $ coreFiles , 'userFiles' => $ userFiles , ] ; } 
public function initialize ( ) { 
public function run ( RouteCollectionInterface $ routes = null , bool $ returnResponse = false ) { $ this -> startBenchmark ( ) ; $ this -> getRequestObject ( ) ; $ this -> getResponseObject ( ) ; $ this -> forceSecureAccess ( ) ; $ this -> spoofRequestMethod ( ) ; Events :: trigger ( 'pre_system' ) ; 
protected function handleRequest ( RouteCollectionInterface $ routes = null , $ cacheConfig , bool $ returnResponse = false ) { $ routeFilter = $ this -> tryToRouteIt ( $ routes ) ; 
protected function startBenchmark ( ) { $ this -> startTime = microtime ( true ) ; $ this -> benchmark = Services :: timer ( ) ; $ this -> benchmark -> start ( 'total_execution' , $ this -> startTime ) ; $ this -> benchmark -> start ( 'bootstrap' ) ; } 
protected function getRequestObject ( ) { if ( $ this -> request instanceof Request ) { return ; } if ( is_cli ( ) && ! ( ENVIRONMENT === 'testing' ) ) { $ this -> request = Services :: clirequest ( $ this -> config ) ; } else { $ this -> request = Services :: request ( $ this -> config ) ; 
protected function getResponseObject ( ) { $ this -> response = Services :: response ( $ this -> config ) ; if ( ! is_cli ( ) || ENVIRONMENT === 'testing' ) { $ this -> response -> setProtocolVersion ( $ this -> request -> getProtocolVersion ( ) ) ; } 
protected function forceSecureAccess ( $ duration = 31536000 ) { if ( $ this -> config -> forceGlobalSecureRequests !== true ) { return ; } force_https ( $ duration , $ this -> request , $ this -> response ) ; } 
public function displayCache ( $ config ) { if ( $ cachedResponse = cache ( ) -> get ( $ this -> generateCacheName ( $ config ) ) ) { $ cachedResponse = unserialize ( $ cachedResponse ) ; if ( ! is_array ( $ cachedResponse ) || ! isset ( $ cachedResponse [ 'output' ] ) || ! isset ( $ cachedResponse [ 'headers' ] ) ) { throw new Exception ( 'Error unserializing page cache' ) ; } $ headers = $ cachedResponse [ 'headers' ] ; $ output = $ cachedResponse [ 'output' ] ; 
public function cachePage ( Cache $ config ) { $ headers = [ ] ; foreach ( $ this -> response -> getHeaders ( ) as $ header ) { $ headers [ $ header -> getName ( ) ] = $ header -> getValueLine ( ) ; } return cache ( ) -> save ( $ this -> generateCacheName ( $ config ) , serialize ( [ 'headers' => $ headers , 'output' => $ this -> output ] ) , static :: $ cacheTTL ) ; } 
protected function generateCacheName ( $ config ) : string { if ( is_cli ( ) && ! ( ENVIRONMENT === 'testing' ) ) { return md5 ( $ this -> request -> getPath ( ) ) ; } $ uri = $ this -> request -> uri ; if ( $ config -> cacheQueryString ) { $ name = URI :: createURIString ( $ uri -> getScheme ( ) , $ uri -> getAuthority ( ) , $ uri -> getPath ( ) , $ uri -> getQuery ( ) ) ; } else { $ name = URI :: createURIString ( $ uri -> getScheme ( ) , $ uri -> getAuthority ( ) , $ uri -> getPath ( ) ) ; } return md5 ( $ name ) ; } 
public function displayPerformanceMetrics ( string $ output ) : string { $ this -> totalTime = $ this -> benchmark -> getElapsedTime ( 'total_execution' ) ; $ output = str_replace ( '{elapsed_time}' , $ this -> totalTime , $ output ) ; return $ output ; } 
protected function tryToRouteIt ( RouteCollectionInterface $ routes = null ) { if ( empty ( $ routes ) || ! $ routes instanceof RouteCollectionInterface ) { require APPPATH . 'Config/Routes.php' ; } 
protected function determinePath ( ) { if ( ! empty ( $ this -> path ) ) { return $ this -> path ; } return ( is_cli ( ) && ! ( ENVIRONMENT === 'testing' ) ) ? $ this -> request -> getPath ( ) : $ this -> request -> uri -> getPath ( ) ; } 
protected function startController ( ) { $ this -> benchmark -> start ( 'controller' ) ; $ this -> benchmark -> start ( 'controller_constructor' ) ; 
protected function createController ( ) { $ class = new $ this -> controller ( ) ; $ class -> initController ( $ this -> request , $ this -> response , Services :: logger ( ) ) ; $ this -> benchmark -> stop ( 'controller_constructor' ) ; return $ class ; } 
protected function runController ( $ class ) { if ( method_exists ( $ class , '_remap' ) ) { $ output = $ class -> _remap ( $ this -> method , ... $ this -> router -> params ( ) ) ; } else { $ output = $ class -> { $ this -> method } ( ... $ this -> router -> params ( ) ) ; } $ this -> benchmark -> stop ( 'controller' ) ; return $ output ; } 
protected function display404errors ( PageNotFoundException $ e ) { 
protected function gatherOutput ( $ cacheConfig = null , $ returned = null ) { $ this -> output = ob_get_contents ( ) ; 
public function storePreviousURL ( $ uri ) { 
public function spoofRequestMethod ( ) { if ( is_cli ( ) ) { return ; } 
public static function getHandler ( $ config , string $ handler = null , string $ backup = null ) { if ( ! isset ( $ config -> validHandlers ) || ! is_array ( $ config -> validHandlers ) ) { throw CacheException :: forInvalidHandlers ( ) ; } if ( ! isset ( $ config -> handler ) || ! isset ( $ config -> backupHandler ) ) { throw CacheException :: forNoBackup ( ) ; } $ handler = ! empty ( $ handler ) ? $ handler : $ config -> handler ; $ backup = ! empty ( $ backup ) ? $ backup : $ config -> backupHandler ; if ( ! array_key_exists ( $ handler , $ config -> validHandlers ) || ! array_key_exists ( $ backup , $ config -> validHandlers ) ) { throw CacheException :: forHandlerNotFound ( ) ; } 
public function select ( $ select = '*' , bool $ escape = null ) { if ( is_string ( $ select ) ) { $ select = explode ( ',' , $ select ) ; } * When doing 'SELECT NULL as field_alias FROM table' * null gets taken as a field, and therefore escaped * with backticks. * This prevents NULL being escaped * @see https: */ if ( strtoupper ( mb_substr ( trim ( $ val ) , 0 , 4 ) ) === 'NULL' ) { $ escape = false ; } $ this -> QBNoEscape [ ] = $ escape ; } } return $ this ; } 
protected function maxMinAvgSum ( string $ select = '' , string $ alias = '' , string $ type = 'MAX' ) { if ( $ select === '' ) { throw DataException :: forEmptyInputGiven ( 'Select' ) ; } if ( strpos ( $ select , ',' ) !== false ) { throw DataException :: forInvalidArgument ( 'column name not separated by comma' ) ; } $ type = strtoupper ( $ type ) ; if ( ! in_array ( $ type , [ 'MAX' , 'MIN' , 'AVG' , 'SUM' ] ) ) { throw new DatabaseException ( 'Invalid function type: ' . $ type ) ; } if ( $ alias === '' ) { $ alias = $ this -> createAliasFromTable ( trim ( $ select ) ) ; } $ sql = $ type . '(' . $ this -> db -> protectIdentifiers ( trim ( $ select ) ) . ') AS ' . $ this -> db -> escapeIdentifiers ( trim ( $ alias ) ) ; $ this -> QBSelect [ ] = $ sql ; $ this -> QBNoEscape [ ] = null ; return $ this ; } 
protected function createAliasFromTable ( string $ item ) : string { if ( strpos ( $ item , '.' ) !== false ) { $ item = explode ( '.' , $ item ) ; return end ( $ item ) ; } return $ item ; } 
public function from ( $ from , bool $ overwrite = false ) { if ( $ overwrite === true ) { $ this -> QBFrom = [ ] ; $ this -> db -> setAliasedTables ( [ ] ) ; } foreach ( ( array ) $ from as $ val ) { if ( strpos ( $ val , ',' ) !== false ) { foreach ( explode ( ',' , $ val ) as $ v ) { $ v = trim ( $ v ) ; $ this -> trackAliases ( $ v ) ; $ this -> QBFrom [ ] = $ v = $ this -> db -> protectIdentifiers ( $ v , true , null , false ) ; } } else { $ val = trim ( $ val ) ; 
public function join ( string $ table , string $ cond , string $ type = '' , bool $ escape = null ) { if ( $ type !== '' ) { $ type = strtoupper ( trim ( $ type ) ) ; if ( ! in_array ( $ type , [ 'LEFT' , 'RIGHT' , 'OUTER' , 'INNER' , 'LEFT OUTER' , 'RIGHT OUTER' ] , true ) ) { $ type = '' ; } else { $ type .= ' ' ; } } 
public function where ( $ key , $ value = null , bool $ escape = null ) { return $ this -> whereHaving ( 'QBWhere' , $ key , $ value , 'AND ' , $ escape ) ; } 
public function orWhere ( $ key , $ value = null , bool $ escape = null ) { return $ this -> whereHaving ( 'QBWhere' , $ key , $ value , 'OR ' , $ escape ) ; } 
protected function whereHaving ( string $ qb_key , $ key , $ value = null , string $ type = 'AND ' , bool $ escape = null ) { if ( ! is_array ( $ key ) ) { $ key = [ $ key => $ value ] ; } 
public function whereIn ( string $ key = null , array $ values = null , bool $ escape = null ) { return $ this -> _whereIn ( $ key , $ values , false , 'AND ' , $ escape ) ; } 
public function whereNotIn ( string $ key = null , array $ values = null , bool $ escape = null ) { return $ this -> _whereIn ( $ key , $ values , true , 'AND ' , $ escape ) ; } 
protected function _whereIn ( string $ key = null , array $ values = null , bool $ not = false , string $ type = 'AND ' , bool $ escape = null ) { if ( $ key === null || $ values === null ) { return $ this ; } is_bool ( $ escape ) || $ escape = $ this -> db -> protectIdentifiers ; $ ok = $ key ; if ( $ escape === true ) { $ key = $ this -> db -> protectIdentifiers ( $ key ) ; } $ not = ( $ not ) ? ' NOT' : '' ; $ where_in = array_values ( $ values ) ; $ ok = $ this -> setBind ( $ ok , $ where_in , $ escape ) ; $ prefix = empty ( $ this -> QBWhere ) ? $ this -> groupGetType ( '' ) : $ this -> groupGetType ( $ type ) ; $ where_in = [ 'condition' => $ prefix . $ key . $ not . " IN :{$ok}:" , 'escape' => false , ] ; $ this -> QBWhere [ ] = $ where_in ; return $ this ; } 
public function orLike ( $ field , string $ match = '' , string $ side = 'both' , bool $ escape = null , bool $ insensitiveSearch = false ) { return $ this -> _like ( $ field , $ match , 'OR ' , $ side , '' , $ escape , $ insensitiveSearch ) ; } 
protected function _like ( $ field , string $ match = '' , string $ type = 'AND ' , string $ side = 'both' , string $ not = '' , bool $ escape = null , bool $ insensitiveSearch = false ) { if ( ! is_array ( $ field ) ) { $ field = [ $ field => $ match ] ; } $ escape = is_bool ( $ escape ) ? $ escape : $ this -> db -> protectIdentifiers ; 
protected function _like_statement ( string $ prefix = null , string $ column , string $ not = null , string $ bind , bool $ insensitiveSearch = false ) : string { $ like_statement = "{$prefix} {$column} {$not} LIKE :{$bind}:" ; if ( $ insensitiveSearch === true ) { $ like_statement = "{$prefix} LOWER({$column}) {$not} LIKE :{$bind}:" ; } return $ like_statement ; } 
public function groupStart ( string $ not = '' , string $ type = 'AND ' ) { $ type = $ this -> groupGetType ( $ type ) ; $ this -> QBWhereGroupStarted = true ; $ prefix = empty ( $ this -> QBWhere ) ? '' : $ type ; $ where = [ 'condition' => $ prefix . $ not . str_repeat ( ' ' , ++ $ this -> QBWhereGroupCount ) . ' (' , 'escape' => false , ] ; $ this -> QBWhere [ ] = $ where ; return $ this ; } 
public function groupEnd ( ) { $ this -> QBWhereGroupStarted = false ; $ where = [ 'condition' => str_repeat ( ' ' , $ this -> QBWhereGroupCount -- ) . ')' , 'escape' => false , ] ; $ this -> QBWhere [ ] = $ where ; return $ this ; } 
protected function groupGetType ( string $ type ) : string { if ( $ this -> QBWhereGroupStarted ) { $ type = '' ; $ this -> QBWhereGroupStarted = false ; } return $ type ; } 
public function groupBy ( $ by , bool $ escape = null ) { is_bool ( $ escape ) || $ escape = $ this -> db -> protectIdentifiers ; if ( is_string ( $ by ) ) { $ by = ( $ escape === true ) ? explode ( ',' , $ by ) : [ $ by ] ; } foreach ( $ by as $ val ) { $ val = trim ( $ val ) ; if ( $ val !== '' ) { $ val = [ 'field' => $ val , 'escape' => $ escape , ] ; $ this -> QBGroupBy [ ] = $ val ; } } return $ this ; } 
public function having ( $ key , $ value = null , bool $ escape = null ) { return $ this -> whereHaving ( 'QBHaving' , $ key , $ value , 'AND ' , $ escape ) ; } 
public function orHaving ( $ key , $ value = null , bool $ escape = null ) { return $ this -> whereHaving ( 'QBHaving' , $ key , $ value , 'OR ' , $ escape ) ; } 
public function orderBy ( string $ orderBy , string $ direction = '' , bool $ escape = null ) { $ direction = strtoupper ( trim ( $ direction ) ) ; if ( $ direction === 'RANDOM' ) { $ direction = '' ; 
public function limit ( int $ value = null , int $ offset = 0 ) { if ( ! is_null ( $ value ) ) { $ this -> QBLimit = $ value ; } if ( ! empty ( $ offset ) ) { $ this -> QBOffset = $ offset ; } return $ this ; } 
public function offset ( int $ offset ) { if ( ! empty ( $ offset ) ) { $ this -> QBOffset = ( int ) $ offset ; } return $ this ; } 
protected function _limit ( string $ sql ) : string { return $ sql . ' LIMIT ' . ( $ this -> QBOffset ? $ this -> QBOffset . ', ' : '' ) . $ this -> QBLimit ; } 
public function set ( $ key , string $ value = '' , bool $ escape = null ) { $ key = $ this -> objectToArray ( $ key ) ; if ( ! is_array ( $ key ) ) { $ key = [ $ key => $ value ] ; } $ escape = is_bool ( $ escape ) ? $ escape : $ this -> db -> protectIdentifiers ; foreach ( $ key as $ k => $ v ) { if ( $ escape ) { $ bind = $ this -> setBind ( $ k , $ v , $ escape ) ; $ this -> QBSet [ $ this -> db -> protectIdentifiers ( $ k , false , $ escape ) ] = ":$bind:" ; } else { $ this -> QBSet [ $ this -> db -> protectIdentifiers ( $ k , false , $ escape ) ] = $ v ; } } return $ this ; } 
public function getSetData ( bool $ clean = false ) : array { $ data = $ this -> QBSet ; if ( $ clean ) { $ this -> QBSet = [ ] ; } return $ data ; } 
public function getCompiledSelect ( bool $ reset = true ) : string { $ select = $ this -> compileSelect ( ) ; if ( $ reset === true ) { $ this -> resetSelect ( ) ; } return $ this -> compileFinalQuery ( $ select ) ; } 
protected function compileFinalQuery ( string $ sql ) : string { $ query = new Query ( $ this -> db ) ; $ query -> setQuery ( $ sql , $ this -> binds , false ) ; if ( ! empty ( $ this -> db -> swapPre ) && ! empty ( $ this -> db -> DBPrefix ) ) { $ query -> swapPrefix ( $ this -> db -> DBPrefix , $ this -> db -> swapPre ) ; } return $ query -> getQuery ( ) ; } 
public function get ( int $ limit = null , int $ offset = 0 , bool $ returnSQL = false , bool $ reset = true ) { if ( ! is_null ( $ limit ) ) { $ this -> limit ( $ limit , $ offset ) ; } $ result = $ returnSQL ? $ this -> getCompiledSelect ( ) : $ this -> db -> query ( $ this -> compileSelect ( ) , $ this -> binds , false ) ; if ( $ reset === true ) { $ this -> resetSelect ( ) ; 
public function countAll ( bool $ reset = true , bool $ test = false ) { $ table = $ this -> QBFrom [ 0 ] ; $ sql = $ this -> countString . $ this -> db -> escapeIdentifiers ( 'numrows' ) . ' FROM ' . $ this -> db -> protectIdentifiers ( $ table , true , null , false ) ; if ( $ test ) { return $ sql ; } $ query = $ this -> db -> query ( $ sql , null , false ) ; if ( empty ( $ query -> getResult ( ) ) ) { return 0 ; } $ query = $ query -> getRow ( ) ; if ( $ reset === true ) { $ this -> resetSelect ( ) ; } return ( int ) $ query -> numrows ; } 
public function countAllResults ( bool $ reset = true , bool $ test = false ) { 
public function getWhere ( $ where = null , int $ limit = null , int $ offset = null ) { if ( $ where !== null ) { $ this -> where ( $ where ) ; } if ( ! empty ( $ limit ) ) { $ this -> limit ( $ limit , $ offset ) ; } $ result = $ this -> db -> query ( $ this -> compileSelect ( ) , $ this -> binds , false ) ; $ this -> resetSelect ( ) ; return $ result ; } 
public function insertBatch ( array $ set = null , bool $ escape = null , int $ batchSize = 100 , bool $ testing = false ) { if ( $ set === null ) { if ( empty ( $ this -> QBSet ) ) { if ( CI_DEBUG ) { throw new DatabaseException ( 'You must use the "set" method to update an entry.' ) ; } return false ; } } else { if ( empty ( $ set ) ) { if ( CI_DEBUG ) { throw new DatabaseException ( 'insertBatch() called with no data' ) ; } return false ; } $ this -> setInsertBatch ( $ set , '' , $ escape ) ; } $ table = $ this -> QBFrom [ 0 ] ; 
protected function _insertBatch ( string $ table , array $ keys , array $ values ) : string { return 'INSERT INTO ' . $ table . ' (' . implode ( ', ' , $ keys ) . ') VALUES ' . implode ( ', ' , $ values ) ; } 
public function setInsertBatch ( $ key , string $ value = '' , bool $ escape = null ) { $ key = $ this -> batchObjectToArray ( $ key ) ; if ( ! is_array ( $ key ) ) { $ key = [ $ key => $ value ] ; } $ escape = is_bool ( $ escape ) ? $ escape : $ this -> db -> protectIdentifiers ; $ keys = array_keys ( $ this -> objectToArray ( current ( $ key ) ) ) ; sort ( $ keys ) ; foreach ( $ key as $ row ) { $ row = $ this -> objectToArray ( $ row ) ; if ( count ( array_diff ( $ keys , array_keys ( $ row ) ) ) > 0 || count ( array_diff ( array_keys ( $ row ) , $ keys ) ) > 0 ) { 
public function getCompiledInsert ( bool $ reset = true ) : string { if ( $ this -> validateInsert ( ) === false ) { return false ; } $ sql = $ this -> _insert ( $ this -> db -> protectIdentifiers ( $ this -> QBFrom [ 0 ] , true , null , false ) , array_keys ( $ this -> QBSet ) , array_values ( $ this -> QBSet ) ) ; if ( $ reset === true ) { $ this -> resetWrite ( ) ; } return $ this -> compileFinalQuery ( $ sql ) ; } 
public function insert ( array $ set = null , bool $ escape = null , bool $ test = false ) { if ( $ set !== null ) { $ this -> set ( $ set , '' , $ escape ) ; } if ( $ this -> validateInsert ( ) === false ) { return false ; } $ sql = $ this -> _insert ( $ this -> db -> protectIdentifiers ( $ this -> QBFrom [ 0 ] , true , $ escape , false ) , array_keys ( $ this -> QBSet ) , array_values ( $ this -> QBSet ) ) ; if ( $ test === false ) { $ this -> resetWrite ( ) ; $ result = $ this -> db -> query ( $ sql , $ this -> binds , false ) ; 
protected function _insert ( string $ table , array $ keys , array $ unescapedKeys ) : string { return 'INSERT INTO ' . $ table . ' (' . implode ( ', ' , $ keys ) . ') VALUES (' . implode ( ', ' , $ unescapedKeys ) . ')' ; } 
public function replace ( array $ set = null , bool $ returnSQL = false ) { if ( $ set !== null ) { $ this -> set ( $ set ) ; } if ( empty ( $ this -> QBSet ) ) { if ( CI_DEBUG ) { throw new DatabaseException ( 'You must use the "set" method to update an entry.' ) ; } return false ; } $ table = $ this -> QBFrom [ 0 ] ; $ sql = $ this -> _replace ( $ table , array_keys ( $ this -> QBSet ) , array_values ( $ this -> QBSet ) ) ; $ this -> resetWrite ( ) ; return $ returnSQL ? $ sql : $ this -> db -> query ( $ sql , $ this -> binds , false ) ; } 
protected function _replace ( string $ table , array $ keys , array $ values ) : string { return 'REPLACE INTO ' . $ table . ' (' . implode ( ', ' , $ keys ) . ') VALUES (' . implode ( ', ' , $ values ) . ')' ; } 
public function getCompiledUpdate ( bool $ reset = true ) : string { if ( $ this -> validateUpdate ( ) === false ) { return false ; } $ sql = $ this -> _update ( $ this -> QBFrom [ 0 ] , $ this -> QBSet ) ; if ( $ reset === true ) { $ this -> resetWrite ( ) ; } return $ this -> compileFinalQuery ( $ sql ) ; } 
public function update ( array $ set = null , $ where = null , int $ limit = null , bool $ test = false ) : bool { if ( $ set !== null ) { $ this -> set ( $ set ) ; } if ( $ this -> validateUpdate ( ) === false ) { return false ; } if ( $ where !== null ) { $ this -> where ( $ where ) ; } if ( ! empty ( $ limit ) ) { if ( ! $ this -> canLimitWhereUpdates ) { throw new DatabaseException ( 'This driver does not allow LIMITs on UPDATE queries using WHERE.' ) ; } $ this -> limit ( $ limit ) ; } $ sql = $ this -> _update ( $ this -> QBFrom [ 0 ] , $ this -> QBSet ) ; if ( ! $ test ) { $ this -> resetWrite ( ) ; if ( $ this -> db -> query ( $ sql , $ this -> binds , false ) ) { 
protected function _update ( string $ table , array $ values ) : string { $ valstr = [ ] ; foreach ( $ values as $ key => $ val ) { $ valstr [ ] = $ key . ' = ' . $ val ; } return 'UPDATE ' . $ table . ' SET ' . implode ( ', ' , $ valstr ) . $ this -> compileWhereHaving ( 'QBWhere' ) . $ this -> compileOrderBy ( ) . ( $ this -> QBLimit ? $ this -> _limit ( ' ' ) : '' ) ; } 
public function updateBatch ( array $ set = null , string $ index = null , int $ batchSize = 100 , bool $ returnSQL = false ) { if ( $ index === null ) { if ( CI_DEBUG ) { throw new DatabaseException ( 'You must specify an index to match on for batch updates.' ) ; } return false ; } if ( $ set === null ) { if ( empty ( $ this -> QBSet ) ) { if ( CI_DEBUG ) { throw new DatabaseException ( 'You must use the "set" method to update an entry.' ) ; } return false ; } } else { if ( empty ( $ set ) ) { if ( CI_DEBUG ) { throw new DatabaseException ( 'updateBatch() called with no data' ) ; } return false ; } $ this -> setUpdateBatch ( $ set , $ index ) ; } $ table = $ this -> QBFrom [ 0 ] ; 
protected function _updateBatch ( string $ table , array $ values , string $ index ) : string { $ ids = [ ] ; $ final = [ ] ; foreach ( $ values as $ key => $ val ) { $ ids [ ] = $ val [ $ index ] ; foreach ( array_keys ( $ val ) as $ field ) { if ( $ field !== $ index ) { $ final [ $ field ] [ ] = 'WHEN ' . $ index . ' = ' . $ val [ $ index ] . ' THEN ' . $ val [ $ field ] ; } } } $ cases = '' ; foreach ( $ final as $ k => $ v ) { $ cases .= $ k . " = CASE \n" . implode ( "\n" , $ v ) . "\n" . 'ELSE ' . $ k . ' END, ' ; } $ this -> where ( $ index . ' IN(' . implode ( ',' , $ ids ) . ')' , null , false ) ; return 'UPDATE ' . $ table . ' SET ' . substr ( $ cases , 0 , - 2 ) . $ this -> compileWhereHaving ( 'QBWhere' ) ; } 
public function setUpdateBatch ( $ key , string $ index = '' , bool $ escape = null ) { $ key = $ this -> batchObjectToArray ( $ key ) ; if ( ! is_array ( $ key ) ) { return null ; } is_bool ( $ escape ) || $ escape = $ this -> db -> protectIdentifiers ; foreach ( $ key as $ k => $ v ) { $ index_set = false ; $ clean = [ ] ; foreach ( $ v as $ k2 => $ v2 ) { if ( $ k2 === $ index ) { $ index_set = true ; } $ bind = $ this -> setBind ( $ k2 , $ v2 , $ escape ) ; $ clean [ $ this -> db -> protectIdentifiers ( $ k2 , false , $ escape ) ] = ":$bind:" ; } if ( $ index_set === false ) { throw new DatabaseException ( 'One or more rows submitted for batch updating is missing the specified index.' ) ; } $ this -> QBSet [ ] = $ clean ; } return $ this ; } 
public function emptyTable ( bool $ test = false ) { $ table = $ this -> QBFrom [ 0 ] ; $ sql = $ this -> _delete ( $ table ) ; if ( $ test ) { return $ sql ; } $ this -> resetWrite ( ) ; return $ this -> db -> query ( $ sql , null , false ) ; } 
public function truncate ( bool $ test = false ) { $ table = $ this -> QBFrom [ 0 ] ; $ sql = $ this -> _truncate ( $ table ) ; if ( $ test === true ) { return $ sql ; } $ this -> resetWrite ( ) ; return $ this -> db -> query ( $ sql , null , false ) ; } 
public function getCompiledDelete ( bool $ reset = true ) : string { $ table = $ this -> QBFrom [ 0 ] ; $ sql = $ this -> delete ( $ table , '' , $ reset , true ) ; return $ this -> compileFinalQuery ( $ sql ) ; } 
public function delete ( $ where = '' , int $ limit = null , bool $ reset_data = true , bool $ returnSQL = false ) { $ table = $ this -> db -> protectIdentifiers ( $ this -> QBFrom [ 0 ] , true , null , false ) ; if ( $ where !== '' ) { $ this -> where ( $ where ) ; } if ( empty ( $ this -> QBWhere ) ) { if ( CI_DEBUG ) { throw new DatabaseException ( 'Deletes are not allowed unless they contain a "where" or "like" clause.' ) ; } return false ; } $ sql = $ this -> _delete ( $ table ) ; if ( ! empty ( $ limit ) ) { $ this -> QBLimit = $ limit ; } if ( ! empty ( $ this -> QBLimit ) ) { if ( ! $ this -> canLimitDeletes ) { throw new DatabaseException ( 'SQLite3 does not allow LIMITs on DELETE queries.' ) ; } $ sql = $ this -> _limit ( $ sql ) ; } if ( $ reset_data ) { $ this -> resetWrite ( ) ; } return ( $ returnSQL === true ) ? $ sql : $ this -> db -> query ( $ sql , $ this -> binds , false ) ; } 
public function decrement ( string $ column , int $ value = 1 ) { $ column = $ this -> db -> protectIdentifiers ( $ column ) ; $ sql = $ this -> _update ( $ this -> QBFrom [ 0 ] , [ $ column => "{$column}-{$value}" ] ) ; return $ this -> db -> query ( $ sql , $ this -> binds , false ) ; } 
protected function _delete ( string $ table ) : string { return 'DELETE FROM ' . $ table . $ this -> compileWhereHaving ( 'QBWhere' ) . ( $ this -> QBLimit ? ' LIMIT ' . $ this -> QBLimit : '' ) ; } 
protected function trackAliases ( $ table ) { if ( is_array ( $ table ) ) { foreach ( $ table as $ t ) { $ this -> trackAliases ( $ t ) ; } return ; } 
protected function compileSelect ( $ select_override = false ) : string { 
protected function compileWhereHaving ( string $ qb_key ) : string { if ( ! empty ( $ this -> $ qb_key ) ) { for ( $ i = 0 , $ c = count ( $ this -> $ qb_key ) ; $ i < $ c ; $ i ++ ) { 
protected function compileGroupBy ( ) : string { if ( ! empty ( $ this -> QBGroupBy ) ) { for ( $ i = 0 , $ c = count ( $ this -> QBGroupBy ) ; $ i < $ c ; $ i ++ ) { 
protected function compileOrderBy ( ) : string { if ( is_array ( $ this -> QBOrderBy ) && ! empty ( $ this -> QBOrderBy ) ) { for ( $ i = 0 , $ c = count ( $ this -> QBOrderBy ) ; $ i < $ c ; $ i ++ ) { if ( $ this -> QBOrderBy [ $ i ] [ 'escape' ] !== false && ! $ this -> isLiteral ( $ this -> QBOrderBy [ $ i ] [ 'field' ] ) ) { $ this -> QBOrderBy [ $ i ] [ 'field' ] = $ this -> db -> protectIdentifiers ( $ this -> QBOrderBy [ $ i ] [ 'field' ] ) ; } $ this -> QBOrderBy [ $ i ] = $ this -> QBOrderBy [ $ i ] [ 'field' ] . $ this -> QBOrderBy [ $ i ] [ 'direction' ] ; } return $ this -> QBOrderBy = "\nORDER BY " . implode ( ', ' , $ this -> QBOrderBy ) ; } elseif ( is_string ( $ this -> QBOrderBy ) ) { return $ this -> QBOrderBy ; } return '' ; } 
protected function objectToArray ( $ object ) { if ( ! is_object ( $ object ) ) { return $ object ; } $ array = [ ] ; foreach ( get_object_vars ( $ object ) as $ key => $ val ) { 
protected function batchObjectToArray ( $ object ) { if ( ! is_object ( $ object ) ) { return $ object ; } $ array = [ ] ; $ out = get_object_vars ( $ object ) ; $ fields = array_keys ( $ out ) ; foreach ( $ fields as $ val ) { 
protected function isLiteral ( string $ str ) : bool { $ str = trim ( $ str ) ; if ( empty ( $ str ) || ctype_digit ( $ str ) || ( string ) ( float ) $ str === $ str || in_array ( strtoupper ( $ str ) , [ 'TRUE' , 'FALSE' ] , true ) ) { return true ; } static $ _str ; if ( empty ( $ _str ) ) { $ _str = ( $ this -> db -> escapeChar !== '"' ) ? [ '"' , "'" ] : [ "'" ] ; } return in_array ( $ str [ 0 ] , $ _str , true ) ; } 
protected function resetSelect ( ) { $ this -> resetRun ( [ 'QBSelect' => [ ] , 'QBJoin' => [ ] , 'QBWhere' => [ ] , 'QBGroupBy' => [ ] , 'QBHaving' => [ ] , 'QBOrderBy' => [ ] , 'QBNoEscape' => [ ] , 'QBDistinct' => false , 'QBLimit' => false , 'QBOffset' => false , ] ) ; if ( ! empty ( $ this -> db ) ) { $ this -> db -> setAliasedTables ( [ ] ) ; } } 
protected function getOperator ( string $ str , bool $ list = false ) { static $ _operators ; if ( empty ( $ _operators ) ) { $ _les = ( $ this -> db -> likeEscapeStr !== '' ) ? '\s+' . preg_quote ( trim ( sprintf ( $ this -> db -> likeEscapeStr , $ this -> db -> likeEscapeChar ) ) , '/' ) : '' ; $ _operators = [ '\s*(?:<|>|!)?=\s*' , 
protected function setBind ( string $ key , $ value = null , bool $ escape = true ) : string { if ( ! array_key_exists ( $ key , $ this -> binds ) ) { $ this -> binds [ $ key ] = [ $ value , $ escape , ] ; return $ key ; } $ count = 0 ; while ( array_key_exists ( $ key . $ count , $ this -> binds ) ) { ++ $ count ; } $ this -> binds [ $ key . $ count ] = [ $ value , $ escape , ] ; return $ key . $ count ; } 
public function run ( float $ startTime , float $ totalTime , RequestInterface $ request , ResponseInterface $ response ) : string { 
protected function renderTimeline ( array $ collectors , $ startTime , int $ segmentCount , int $ segmentDuration , array & $ styles ) : string { $ displayTime = $ segmentCount * $ segmentDuration ; $ rows = $ this -> collectTimelineData ( $ collectors ) ; $ output = '' ; $ styleCount = 0 ; foreach ( $ rows as $ row ) { $ output .= '<tr>' ; $ output .= "<td>{$row['name']}</td>" ; $ output .= "<td>{$row['component']}</td>" ; $ output .= "<td class='debug-bar-alignRight'>" . number_format ( $ row [ 'duration' ] * 1000 , 2 ) . ' ms</td>' ; $ output .= "<td class='debug-bar-noverflow' colspan='{$segmentCount}'>" ; $ offset = ( ( ( $ row [ 'start' ] - $ startTime ) * 1000 ) / $ displayTime ) * 100 ; $ length = ( ( $ row [ 'duration' ] * 1000 ) / $ displayTime ) * 100 ; $ styles [ 'debug-bar-timeline-' . $ styleCount ] = "left: {$offset}%; width: {$length}%;" ; $ output .= "<span class='timer debug-bar-timeline-{$styleCount}' title='" . number_format ( $ length , 2 ) . "%'></span>" ; $ output .= '</td>' ; $ output .= '</tr>' ; $ styleCount ++ ; } return $ output ; } 
protected function collectTimelineData ( $ collectors ) : array { $ data = [ ] ; 
protected function collectVarData ( ) : array { $ data = [ ] ; foreach ( $ this -> collectors as $ collector ) { if ( ! $ collector -> hasVarData ( ) ) { continue ; } $ data = array_merge ( $ data , $ collector -> getVarData ( ) ) ; } return $ data ; } 
protected function roundTo ( float $ number , int $ increments = 5 ) : float { $ increments = 1 / $ increments ; return ( ceil ( $ number * $ increments ) / $ increments ) ; } 
public function prepare ( ) { if ( CI_DEBUG && ! is_cli ( ) ) { global $ app ; $ request = Services :: request ( ) ; $ response = Services :: response ( ) ; $ toolbar = Services :: toolbar ( config ( Toolbar :: class ) ) ; $ stats = $ app -> getPerformanceStats ( ) ; $ data = $ toolbar -> run ( $ stats [ 'startTime' ] , $ stats [ 'totalTime' ] , $ request , $ response ) ; helper ( 'filesystem' ) ; 
protected function format ( string $ data , string $ format = 'html' ) : string { $ data = json_decode ( $ data , true ) ; if ( $ this -> config -> maxHistory !== 0 ) { $ history = new History ( ) ; $ history -> setFiles ( Services :: request ( ) -> getGet ( 'debugbar_time' ) , $ this -> config -> maxHistory ) ; $ data [ 'collectors' ] [ ] = $ history -> getAsArray ( ) ; } $ output = '' ; switch ( $ format ) { case 'html' : $ data [ 'styles' ] = [ ] ; extract ( $ data ) ; $ parser = Services :: parser ( $ this -> config -> viewsPath , null , false ) ; ob_start ( ) ; include ( $ this -> config -> viewsPath . 'toolbar.tpl.php' ) ; $ output = ob_get_clean ( ) ; break ; case 'json' : $ formatter = new JSONFormatter ( ) ; $ output = $ formatter -> format ( $ data ) ; break ; case 'xml' : $ formatter = new XMLFormatter ; $ output = $ formatter -> format ( $ data ) ; break ; } return $ output ; } 
public function copy ( string $ targetPath , string $ targetName = null , int $ perms = 0644 ) : bool { $ targetPath = rtrim ( $ targetPath , '/ ' ) . '/' ; $ targetName = is_null ( $ targetName ) ? $ this -> getFilename ( ) : $ targetName ; if ( empty ( $ targetName ) ) { throw ImageException :: forInvalidFile ( $ targetName ) ; } if ( ! is_dir ( $ targetPath ) ) { mkdir ( $ targetName , 0755 , true ) ; } if ( ! copy ( $ this -> getPathname ( ) , "{$targetPath}{$targetName}" ) ) { throw ImageException :: forCopyError ( $ targetPath ) ; } chmod ( "{$targetPath}/{$targetName}" , $ perms ) ; return true ; } 
public function getProperties ( bool $ return = false ) { $ path = $ this -> getPathname ( ) ; $ vals = getimagesize ( $ path ) ; $ types = [ 1 => 'gif' , 2 => 'jpeg' , 3 => 'png' , ] ; $ mime = 'image/' . ( $ types [ $ vals [ 2 ] ] ?? 'jpg' ) ; if ( $ return === true ) { return [ 'width' => $ vals [ 0 ] , 'height' => $ vals [ 1 ] , 'image_type' => $ vals [ 2 ] , 'size_str' => $ vals [ 3 ] , 'mime_type' => $ mime , ] ; } $ this -> origWidth = $ vals [ 0 ] ; $ this -> origHeight = $ vals [ 1 ] ; $ this -> imageType = $ vals [ 2 ] ; $ this -> sizeStr = $ vals [ 3 ] ; $ this -> mime = $ mime ; return true ; } 
public function open ( $ savePath , $ name ) : bool { if ( empty ( $ this -> db -> connID ) ) { $ this -> db -> initialize ( ) ; } return true ; } 
public function read ( $ sessionID ) : string { if ( $ this -> lockSession ( $ sessionID ) === false ) { $ this -> fingerprint = md5 ( '' ) ; return '' ; } 
public function write ( $ sessionID , $ sessionData ) : bool { if ( $ this -> lock === false ) { return $ this -> fail ( ) ; } 
public function destroy ( $ sessionID ) : bool { if ( $ this -> lock ) { $ builder = $ this -> db -> table ( $ this -> table ) -> where ( 'id' , $ sessionID ) ; if ( $ this -> matchIP ) { $ builder = $ builder -> where ( 'ip_address' , $ this -> ipAddress ) ; } if ( ! $ builder -> delete ( ) ) { return $ this -> fail ( ) ; } } if ( $ this -> close ( ) ) { $ this -> destroyCookie ( ) ; return true ; } return $ this -> fail ( ) ; } 
public function gc ( $ maxlifetime ) : bool { return ( $ this -> db -> table ( $ this -> table ) -> delete ( 'timestamp < ' . ( time ( ) - $ maxlifetime ) ) ) ? true : $ this -> fail ( ) ; } 
protected function lockSession ( string $ sessionID ) : bool { if ( $ this -> platform === 'mysql' ) { $ arg = md5 ( $ sessionID . ( $ this -> matchIP ? '_' . $ this -> ipAddress : '' ) ) ; if ( $ this -> db -> query ( "SELECT GET_LOCK('{$arg}', 300) AS ci_session_lock" ) -> getRow ( ) -> ci_session_lock ) { $ this -> lock = $ arg ; return true ; } return $ this -> fail ( ) ; } elseif ( $ this -> platform === 'postgre' ) { $ arg = "hashtext('{$sessionID}')" . ( $ this -> matchIP ? ", hashtext('{$this->ipAddress}')" : '' ) ; if ( $ this -> db -> simpleQuery ( "SELECT pg_advisory_lock({$arg})" ) ) { $ this -> lock = $ arg ; return true ; } return $ this -> fail ( ) ; } 
protected function releaseLock ( ) : bool { if ( ! $ this -> lock ) { return true ; } if ( $ this -> platform === 'mysql' ) { if ( $ this -> db -> query ( "SELECT RELEASE_LOCK('{$this->lock}') AS ci_session_lock" ) -> getRow ( ) -> ci_session_lock ) { $ this -> lock = false ; return true ; } return $ this -> fail ( ) ; } elseif ( $ this -> platform === 'postgre' ) { if ( $ this -> db -> simpleQuery ( "SELECT pg_advisory_unlock({$this->lock})" ) ) { $ this -> lock = false ; return true ; } return $ this -> fail ( ) ; } 
public function display ( ) : array { $ rawRoutes = Services :: routes ( true ) ; $ router = Services :: router ( null , true ) ; $ route = $ router -> getMatchedRoute ( ) ; * Defined Routes */ $ rawRoutes = $ rawRoutes -> getRoutes ( ) ; $ routes = [ ] ; foreach ( $ rawRoutes as $ from => $ to ) { $ routes [ ] = [ 'from' => $ from , 'to' => $ to , ] ; } return [ 'matchedRoute' => $ matchedRoute , 'routes' => $ routes , ] ; } 
public function attachHoneypot ( ResponseInterface $ response ) { $ prep_field = $ this -> prepareTemplate ( $ this -> config -> template ) ; $ body = $ response -> getBody ( ) ; $ body = str_ireplace ( '</form>' , $ prep_field , $ body ) ; $ response -> setBody ( $ body ) ; } 
protected function prepareTemplate ( string $ template ) : string { $ template = str_ireplace ( '{label}' , $ this -> config -> label , $ template ) ; $ template = str_ireplace ( '{name}' , $ this -> config -> name , $ template ) ; if ( $ this -> config -> hidden ) { $ template = '<div style="display:none">' . $ template . '</div>' ; } return $ template ; } 
protected function _replace ( string $ table , array $ keys , array $ values ) : string { return 'INSERT OR ' . parent :: _replace ( $ table , $ keys , $ values ) ; } 
public function getFieldNames ( ) : array { $ fieldNames = [ ] ; for ( $ i = 0 , $ c = $ this -> getFieldCount ( ) ; $ i < $ c ; $ i ++ ) { $ fieldNames [ ] = $ this -> resultID -> columnName ( $ i ) ; } return $ fieldNames ; } 
public function getFieldData ( ) : array { static $ data_types = [ SQLITE3_INTEGER => 'integer' , SQLITE3_FLOAT => 'float' , SQLITE3_TEXT => 'text' , SQLITE3_BLOB => 'blob' , SQLITE3_NULL => 'null' , ] ; $ retVal = [ ] ; for ( $ i = 0 , $ c = $ this -> getFieldCount ( ) ; $ i < $ c ; $ i ++ ) { $ retVal [ $ i ] = new \ stdClass ( ) ; $ retVal [ $ i ] -> name = $ this -> resultID -> columnName ( $ i ) ; $ type = $ this -> resultID -> columnType ( $ i ) ; $ retVal [ $ i ] -> type = isset ( $ data_types [ $ type ] ) ? $ data_types [ $ type ] : $ type ; $ retVal [ $ i ] -> max_length = null ; } return $ retVal ; } 
public function freeResult ( ) { if ( is_object ( $ this -> resultID ) ) { $ this -> resultID -> finalize ( ) ; $ this -> resultID = false ; } } 
protected function fetchObject ( string $ className = 'stdClass' ) { 
public function makeColumns ( $ array = [ ] , $ columnLimit = 0 ) { if ( ! is_array ( $ array ) || count ( $ array ) === 0 || ! is_int ( $ columnLimit ) ) { return false ; } 
protected function _prepArgs ( $ args ) { 
public function generate ( $ tableData = null ) { 
public function clear ( ) { $ this -> rows = [ ] ; $ this -> heading = [ ] ; $ this -> footing = [ ] ; $ this -> autoHeading = true ; $ this -> caption = null ; return $ this ; } 
protected function _setFromDBResult ( $ object ) { 
protected function _setFromArray ( $ data ) { if ( $ this -> autoHeading === true && empty ( $ this -> heading ) ) { $ this -> heading = $ this -> _prepArgs ( array_shift ( $ data ) ) ; } foreach ( $ data as & $ row ) { $ this -> rows [ ] = $ this -> _prepArgs ( $ row ) ; } } 
protected function _compileTemplate ( ) { if ( $ this -> template === null ) { $ this -> template = $ this -> _defaultTemplate ( ) ; return ; } $ this -> temp = $ this -> _defaultTemplate ( ) ; foreach ( [ 'table_open' , 'thead_open' , 'thead_close' , 'heading_row_start' , 'heading_row_end' , 'heading_cell_start' , 'heading_cell_end' , 'tbody_open' , 'tbody_close' , 'row_start' , 'row_end' , 'cell_start' , 'cell_end' , 'row_alt_start' , 'row_alt_end' , 'cell_alt_start' , 'cell_alt_end' , 'table_close' ] as $ val ) { if ( ! isset ( $ this -> template [ $ val ] ) ) { $ this -> template [ $ val ] = $ this -> temp [ $ val ] ; } } } 
public function initialize ( ) { if ( class_exists ( '\Memcached' ) ) { $ this -> memcached = new \ Memcached ( ) ; if ( $ this -> config [ 'raw' ] ) { $ this -> memcached -> setOption ( \ Memcached :: OPT_BINARY_PROTOCOL , true ) ; } } elseif ( class_exists ( '\Memcache' ) ) { $ this -> memcached = new \ Memcache ( ) ; } else { throw new CriticalError ( 'Cache: Not support Memcache(d) extension.' ) ; } if ( $ this -> memcached instanceof \ Memcached ) { $ this -> memcached -> addServer ( $ this -> config [ 'host' ] , $ this -> config [ 'port' ] , $ this -> config [ 'weight' ] ) ; } elseif ( $ this -> memcached instanceof \ Memcache ) { 
public function get ( string $ key ) { $ key = $ this -> prefix . $ key ; if ( $ this -> memcached instanceof \ Memcached ) { $ data = $ this -> memcached -> get ( $ key ) ; 
public function save ( string $ key , $ value , int $ ttl = 60 ) { $ key = $ this -> prefix . $ key ; if ( ! $ this -> config [ 'raw' ] ) { $ value = [ $ value , time ( ) , $ ttl , ] ; } if ( $ this -> memcached instanceof \ Memcached ) { return $ this -> memcached -> set ( $ key , $ value , $ ttl ) ; } elseif ( $ this -> memcached instanceof \ Memcache ) { return $ this -> memcached -> set ( $ key , $ value , 0 , $ ttl ) ; } return false ; } 
public function delete ( string $ key ) { $ key = $ this -> prefix . $ key ; return $ this -> memcached -> delete ( $ key ) ; } 
public function increment ( string $ key , int $ offset = 1 ) { if ( ! $ this -> config [ 'raw' ] ) { return false ; } $ key = $ this -> prefix . $ key ; return $ this -> memcached -> increment ( $ key , $ offset , $ offset , 60 ) ; } 
public function getMetaData ( string $ key ) { $ key = $ this -> prefix . $ key ; $ stored = $ this -> memcached -> get ( $ key ) ; 
public function move ( string $ targetPath , string $ name = null , bool $ overwrite = false ) { $ targetPath = $ this -> setPath ( $ targetPath ) ; 
protected function setPath ( string $ path ) : string { if ( ! is_dir ( $ path ) ) { mkdir ( $ path , 0777 , true ) ; 
public function getErrorString ( ) : string { $ errors = [ UPLOAD_ERR_OK => lang ( 'HTTP.uploadErrOk' ) , UPLOAD_ERR_INI_SIZE => lang ( 'HTTP.uploadErrIniSize' ) , UPLOAD_ERR_FORM_SIZE => lang ( 'HTTP.uploadErrFormSize' ) , UPLOAD_ERR_PARTIAL => lang ( 'HTTP.uploadErrPartial' ) , UPLOAD_ERR_NO_FILE => lang ( 'HTTP.uploadErrNoFile' ) , UPLOAD_ERR_CANT_WRITE => lang ( 'HTTP.uploadErrCantWrite' ) , UPLOAD_ERR_NO_TMP_DIR => lang ( 'HTTP.uploadErrNoTmpDir' ) , UPLOAD_ERR_EXTENSION => lang ( 'HTTP.uploadErrExtension' ) , ] ; $ error = is_null ( $ this -> error ) ? UPLOAD_ERR_OK : $ this -> error ; return sprintf ( $ errors [ $ error ] ?? lang ( 'HTTP.uploadErrUnknown' ) , $ this -> getName ( ) ) ; } 
public function store ( string $ folderName = null , string $ fileName = null ) : string { $ folderName = $ folderName ?? date ( 'Ymd' ) ; $ fileName = $ fileName ?? $ this -> getRandomName ( ) ; 
public function run ( array $ params = [ ] ) { $ name = array_shift ( $ params ) ; if ( empty ( $ name ) ) { $ name = CLI :: prompt ( lang ( 'Migrations.nameMigration' ) ) ; } if ( empty ( $ name ) ) { CLI :: error ( lang ( 'Migrations.badCreateName' ) ) ; return ; } $ ns = $ params [ '-n' ] ?? CLI :: getOption ( 'n' ) ; $ homepath = APPPATH ; if ( ! empty ( $ ns ) ) { <?php namespace $ns\Database\Migrations; use CodeIgniter\Database\Migration; class Migration_{name} extends Migration { public function up() { } public function down() { } } EOD ; $ template = str_replace ( '{name}' , $ name , $ template ) ; helper ( 'filesystem' ) ; if ( ! write_file ( $ path , $ template ) ) { CLI :: error ( lang ( 'Migrations.writeError' ) ) ; return ; } CLI :: write ( 'Created file: ' . CLI :: color ( str_replace ( $ homepath , $ ns , $ path ) , 'green' ) ) ; } 
public function uploaded ( string $ blank = null , string $ name , array $ data ) : bool { $ file = $ this -> request -> getFile ( $ name ) ; if ( is_null ( $ file ) ) { return false ; } if ( ENVIRONMENT === 'testing' ) { return $ file -> getError ( ) === 0 ; } 
public function max_size ( string $ blank = null , string $ params , array $ data ) : bool { 
public function is_image ( string $ blank = null , string $ params , array $ data ) : bool { 
public function mime_in ( string $ blank = null , string $ params , array $ data ) : bool { 
public function max_dims ( string $ blank = null , string $ params , array $ data ) : bool { 
protected function formatTimelineData ( ) : array { $ data = [ ] ; $ rows = $ this -> viewer -> getPerformanceData ( ) ; foreach ( $ rows as $ name => $ info ) { $ data [ ] = [ 'name' => 'View: ' . $ info [ 'view' ] , 'component' => 'Views' , 'start' => $ info [ 'start' ] , 'duration' => $ info [ 'end' ] - $ info [ 'start' ] , ] ; } return $ data ; } 
public function display ( ) : array { $ data = [ 'events' => [ ] , ] ; foreach ( \ CodeIgniter \ Events \ Events :: getPerformanceLogs ( ) as $ row ) { $ key = $ row [ 'event' ] ; if ( ! array_key_exists ( $ key , $ data [ 'events' ] ) ) { $ data [ 'events' ] [ $ key ] = [ 'event' => $ key , 'duration' => number_format ( ( $ row [ 'end' ] - $ row [ 'start' ] ) * 1000 , 2 ) , 'count' => 1 , ] ; continue ; } $ data [ 'events' ] [ $ key ] [ 'duration' ] += number_format ( ( $ row [ 'end' ] - $ row [ 'start' ] ) * 1000 , 2 ) ; $ data [ 'events' ] [ $ key ] [ 'count' ] ++ ; } return $ data ; } 
public function getIPAddress ( ) : string { if ( ! empty ( $ this -> ipAddress ) ) { return $ this -> ipAddress ; } $ proxy_ips = $ this -> proxyIPs ; if ( ! empty ( $ this -> proxyIPs ) && ! is_array ( $ this -> proxyIPs ) ) { $ proxy_ips = explode ( ',' , str_replace ( ' ' , '' , $ this -> proxyIPs ) ) ; } $ this -> ipAddress = $ this -> getServer ( 'REMOTE_ADDR' ) ; if ( $ proxy_ips ) { foreach ( [ 'HTTP_X_FORWARDED_FOR' , 'HTTP_CLIENT_IP' , 'HTTP_X_CLIENT_IP' , 'HTTP_X_CLUSTER_CLIENT_IP' ] as $ header ) { if ( ( $ spoof = $ this -> getServer ( $ header ) ) !== null ) { 
public function isValidIP ( string $ ip = null , string $ which = null ) : bool { switch ( strtolower ( $ which ) ) { case 'ipv4' : $ which = FILTER_FLAG_IPV4 ; break ; case 'ipv6' : $ which = FILTER_FLAG_IPV6 ; break ; default : $ which = null ; break ; } return ( bool ) filter_var ( $ ip , FILTER_VALIDATE_IP , $ which ) ; } 
public function getServer ( $ index = null , $ filter = null , $ flags = null ) { return $ this -> fetchGlobal ( 'server' , $ index , $ filter , $ flags ) ; } 
public function getEnv ( $ index = null , $ filter = null , $ flags = null ) { return $ this -> fetchGlobal ( 'env' , $ index , $ filter , $ flags ) ; } 
public function fetchGlobal ( $ method , $ index = null , $ filter = null , $ flags = null ) { $ method = strtolower ( $ method ) ; if ( ! isset ( $ this -> globals [ $ method ] ) ) { $ this -> populateGlobals ( $ method ) ; } 
protected function populateGlobals ( string $ method ) { if ( ! isset ( $ this -> globals [ $ method ] ) ) { $ this -> globals [ $ method ] = [ ] ; } 
public function run ( array $ params = [ ] ) { $ runner = Services :: migrations ( ) ; 
public function getOptionString ( ) : string { if ( empty ( $ this -> options ) ) { return '' ; } $ out = '' ; foreach ( $ this -> options as $ name => $ value ) { 
protected function parseCommand ( ) { 
public function fromTable ( string $ table ) { $ this -> prefixedTableName = $ table ; 
public function run ( ) : bool { $ this -> db -> query ( 'PRAGMA foreign_keys = OFF' ) ; $ this -> db -> transStart ( ) ; $ this -> forge -> renameTable ( $ this -> tableName , "temp_{$this->tableName}" ) ; $ this -> forge -> reset ( ) ; $ this -> createTable ( ) ; $ this -> copyData ( ) ; $ this -> forge -> dropTable ( "temp_{$this->tableName}" ) ; $ success = $ this -> db -> transComplete ( ) ; $ this -> db -> query ( 'PRAGMA foreign_keys = ON' ) ; return $ success ; } 
public function modifyColumn ( array $ field ) { $ field = $ field [ 0 ] ; $ oldName = $ field [ 'name' ] ; unset ( $ field [ 'name' ] ) ; $ this -> fields [ $ oldName ] = $ field ; return $ this ; } 
protected function createTable ( ) { $ this -> dropIndexes ( ) ; $ this -> db -> resetDataCache ( ) ; 
protected function copyData ( ) { $ exFields = [ ] ; $ newFields = [ ] ; foreach ( $ this -> fields as $ name => $ details ) { 
protected function formatFields ( $ fields ) { if ( ! is_array ( $ fields ) ) { return $ fields ; } $ return = [ ] ; foreach ( $ fields as $ field ) { $ return [ $ field -> name ] = [ 'type' => $ field -> type , 'default' => $ field -> default , 'nullable' => $ field -> nullable , ] ; if ( $ field -> primary_key ) { $ this -> keys [ $ field -> name ] = [ 'fields' => [ $ field -> name ] , 'type' => 'primary' , ] ; } } return $ return ; } 
protected function formatKeys ( $ keys ) { if ( ! is_array ( $ keys ) ) { return $ keys ; } $ return = [ ] ; foreach ( $ keys as $ name => $ key ) { $ return [ $ name ] = [ 'fields' => $ key -> fields , 'type' => 'index' , ] ; } return $ return ; } 
protected function dropIndexes ( ) { if ( ! is_array ( $ this -> keys ) || ! count ( $ this -> keys ) ) { return ; } foreach ( $ this -> keys as $ name => $ key ) { if ( $ key [ 'type' ] === 'primary' || $ key [ 'type' ] === 'unique' ) { continue ; } $ this -> db -> query ( "DROP INDEX IF EXISTS '{$name}'" ) ; } } 
public function CSRFVerify ( RequestInterface $ request ) { 
public function CSRFSetCookie ( RequestInterface $ request ) { $ expire = time ( ) + $ this -> CSRFExpire ; $ secure_cookie = ( bool ) $ this -> cookieSecure ; if ( $ secure_cookie && ! $ request -> isSecure ( ) ) { return false ; } setcookie ( $ this -> CSRFCookieName , $ this -> CSRFHash , $ expire , $ this -> cookiePath , $ this -> cookieDomain , $ secure_cookie , true 
protected function CSRFSetHash ( ) : string { if ( $ this -> CSRFHash === null ) { 
public function sanitizeFilename ( string $ str , bool $ relative_path = false ) : string { $ bad = $ this -> filenameBadChars ; if ( ! $ relative_path ) { $ bad [ ] = './' ; $ bad [ ] = '/' ; } $ str = remove_invisible_characters ( $ str , false ) ; do { $ old = $ str ; $ str = str_replace ( $ bad , '' , $ str ) ; } while ( $ old !== $ str ) ; return stripslashes ( $ str ) ; } 
public static function now ( $ timezone = null , string $ locale = null ) { return new Time ( null , $ timezone , $ locale ) ; } 
public static function parse ( string $ datetime , $ timezone = null , string $ locale = null ) { return new Time ( $ datetime , $ timezone , $ locale ) ; } 
public static function today ( $ timezone = null , string $ locale = null ) { return new Time ( date ( 'Y-m-d 00:00:00' ) , $ timezone , $ locale ) ; } 
public static function yesterday ( $ timezone = null , string $ locale = null ) { return new Time ( date ( 'Y-m-d 00:00:00' , strtotime ( '-1 day' ) ) , $ timezone , $ locale ) ; } 
public static function tomorrow ( $ timezone = null , string $ locale = null ) { return new Time ( date ( 'Y-m-d 00:00:00' , strtotime ( '+1 day' ) ) , $ timezone , $ locale ) ; } 
public static function createFromDate ( int $ year = null , int $ month = null , int $ day = null , $ timezone = null , string $ locale = null ) { return static :: create ( $ year , $ month , $ day , null , null , null , $ timezone , $ locale ) ; } 
public static function createFromTime ( int $ hour = null , int $ minutes = null , int $ seconds = null , $ timezone = null , string $ locale = null ) { return static :: create ( null , null , null , $ hour , $ minutes , $ seconds , $ timezone , $ locale ) ; } 
public static function create ( int $ year = null , int $ month = null , int $ day = null , int $ hour = null , int $ minutes = null , int $ seconds = null , $ timezone = null , string $ locale = null ) { $ year = is_null ( $ year ) ? date ( 'Y' ) : $ year ; $ month = is_null ( $ month ) ? date ( 'm' ) : $ month ; $ day = is_null ( $ day ) ? date ( 'd' ) : $ day ; $ hour = empty ( $ hour ) ? 0 : $ hour ; $ minutes = empty ( $ minutes ) ? 0 : $ minutes ; $ seconds = empty ( $ seconds ) ? 0 : $ seconds ; return new Time ( date ( 'Y-m-d H:i:s' , strtotime ( "{$year}-{$month}-{$day} {$hour}:{$minutes}:{$seconds}" ) ) , $ timezone , $ locale ) ; } 
public static function createFromFormat ( $ format , $ datetime , $ timeZone = null ) { $ date = parent :: createFromFormat ( $ format , $ datetime ) ; return new Time ( $ date -> format ( 'Y-m-d H:i:s' ) , $ timeZone ) ; } 
public static function createFromTimestamp ( int $ timestamp , $ timeZone = null , string $ locale = null ) { return new Time ( date ( 'Y-m-d H:i:s' , $ timestamp ) , $ timeZone , $ locale ) ; } 
public static function instance ( DateTime $ dateTime , string $ locale = null ) { $ date = $ dateTime -> format ( 'Y-m-d H:i:s' ) ; $ timezone = $ dateTime -> getTimezone ( ) ; return new Time ( $ date , $ timezone , $ locale ) ; } 
public function toDateTime ( ) { $ dateTime = new DateTime ( null , $ this -> getTimezone ( ) ) ; $ dateTime -> setTimestamp ( parent :: getTimestamp ( ) ) ; return $ dateTime ; } 
public function getAge ( ) { $ now = Time :: now ( ) -> getTimestamp ( ) ; $ time = $ this -> getTimestamp ( ) ; 
public function getDst ( ) : bool { 
public function setMonth ( $ value ) { if ( is_numeric ( $ value ) && $ value < 1 || $ value > 12 ) { throw I18nException :: forInvalidMonth ( $ value ) ; } if ( is_string ( $ value ) && ! is_numeric ( $ value ) ) { $ value = date ( 'm' , strtotime ( "{$value} 1 2017" ) ) ; } return $ this -> setValue ( 'month' , $ value ) ; } 
public function setDay ( $ value ) { if ( $ value < 1 || $ value > 31 ) { throw I18nException :: forInvalidDay ( $ value ) ; } $ date = $ this -> getYear ( ) . '-' . $ this -> getMonth ( ) ; $ lastDay = date ( 't' , strtotime ( $ date ) ) ; if ( $ value > $ lastDay ) { throw I18nException :: forInvalidOverDay ( $ lastDay , $ value ) ; } return $ this -> setValue ( 'day' , $ value ) ; } 
public function setHour ( $ value ) { if ( $ value < 0 || $ value > 23 ) { throw I18nException :: forInvalidHour ( $ value ) ; } return $ this -> setValue ( 'hour' , $ value ) ; } 
public function setMinute ( $ value ) { if ( $ value < 0 || $ value > 59 ) { throw I18nException :: forInvalidMinutes ( $ value ) ; } return $ this -> setValue ( 'minute' , $ value ) ; } 
public function setSecond ( $ value ) { if ( $ value < 0 || $ value > 59 ) { throw I18nException :: forInvalidSeconds ( $ value ) ; } return $ this -> setValue ( 'second' , $ value ) ; } 
protected function setValue ( string $ name , $ value ) { list ( $ year , $ month , $ day , $ hour , $ minute , $ second ) = explode ( '-' , $ this -> format ( 'Y-n-j-G-i-s' ) ) ; $ $ name = $ value ; return Time :: create ( $ year , $ month , $ day , $ hour , $ minute , $ second , $ this -> getTimezoneName ( ) , $ this -> locale ) ; } 
public function setTimestamp ( $ timestamp ) { $ time = date ( 'Y-m-d H:i:s' , $ timestamp ) ; return Time :: parse ( $ time , $ this -> timezone , $ this -> locale ) ; } 
public function toLocalizedString ( ? string $ format = null ) { $ format = $ format ?? $ this -> toStringFormat ; return IntlDateFormatter :: formatObject ( $ this -> toDateTime ( ) , $ format , $ this -> locale ) ; } 
public function equals ( $ testTime , string $ timezone = null ) : bool { $ testTime = $ this -> getUTCObject ( $ testTime , $ timezone ) ; $ ourTime = $ this -> toDateTime ( ) -> setTimezone ( new DateTimeZone ( 'UTC' ) ) -> format ( 'Y-m-d H:i:s' ) ; return $ testTime -> format ( 'Y-m-d H:i:s' ) === $ ourTime ; } 
public function sameAs ( $ testTime , string $ timezone = null ) : bool { if ( $ testTime instanceof DateTime ) { $ testTime = $ testTime -> format ( 'Y-m-d H:i:s' ) ; } else if ( is_string ( $ testTime ) ) { $ timezone = $ timezone ? : $ this -> timezone ; $ timezone = $ timezone instanceof DateTimeZone ? $ timezone : new DateTimeZone ( $ timezone ) ; $ testTime = new DateTime ( $ testTime , $ timezone ) ; $ testTime = $ testTime -> format ( 'Y-m-d H:i:s' ) ; } $ ourTime = $ this -> toDateTimeString ( ) ; return $ testTime === $ ourTime ; } 
public function isBefore ( $ testTime , string $ timezone = null ) : bool { $ testTime = $ this -> getUTCObject ( $ testTime , $ timezone ) -> getTimestamp ( ) ; $ ourTime = $ this -> getTimestamp ( ) ; return $ ourTime < $ testTime ; } 
public function humanize ( ) { $ now = IntlCalendar :: fromDateTime ( Time :: now ( $ this -> timezone ) -> toDateTimeString ( ) ) ; $ time = $ this -> getCalendar ( ) -> getTime ( ) ; $ years = $ now -> fieldDifference ( $ time , IntlCalendar :: FIELD_YEAR ) ; $ months = $ now -> fieldDifference ( $ time , IntlCalendar :: FIELD_MONTH ) ; $ days = $ now -> fieldDifference ( $ time , IntlCalendar :: FIELD_DAY_OF_YEAR ) ; $ hours = $ now -> fieldDifference ( $ time , IntlCalendar :: FIELD_HOUR_OF_DAY ) ; $ minutes = $ now -> fieldDifference ( $ time , IntlCalendar :: FIELD_MINUTE ) ; $ phrase = null ; if ( $ years !== 0 ) { $ phrase = lang ( 'Time.years' , [ abs ( $ years ) ] ) ; $ before = $ years < 0 ; } else if ( $ months !== 0 ) { $ phrase = lang ( 'Time.months' , [ abs ( $ months ) ] ) ; $ before = $ months < 0 ; } else if ( $ days !== 0 && ( abs ( $ days ) >= 7 ) ) { $ weeks = ceil ( $ days / 7 ) ; $ phrase = lang ( 'Time.weeks' , [ abs ( $ weeks ) ] ) ; $ before = $ days < 0 ; } else if ( $ days !== 0 ) { $ before = $ days < 0 ; 
public function difference ( $ testTime , string $ timezone = null ) { $ testTime = $ this -> getUTCObject ( $ testTime , $ timezone ) ; $ ourTime = $ this -> getUTCObject ( $ this ) ; return new TimeDifference ( $ ourTime , $ testTime ) ; } 
public function getUTCObject ( $ time , string $ timezone = null ) { if ( $ time instanceof Time ) { $ time = $ time -> toDateTime ( ) -> setTimezone ( new DateTimeZone ( 'UTC' ) ) ; } else if ( $ time instanceof DateTime ) { $ time = $ time -> setTimezone ( new DateTimeZone ( 'UTC' ) ) ; } else if ( is_string ( $ time ) ) { $ timezone = $ timezone ? : $ this -> timezone ; $ timezone = $ timezone instanceof DateTimeZone ? $ timezone : new DateTimeZone ( $ timezone ) ; $ time = new DateTime ( $ time , $ timezone ) ; $ time = $ time -> setTimezone ( new DateTimeZone ( 'UTC' ) ) ; } return $ time ; } 
protected static function hasRelativeKeywords ( string $ time ) : bool { 
protected function jsMatcher ( $ matches ) { $ chr = $ matches [ 0 ] ; if ( strlen ( $ chr ) == 1 ) { return sprintf ( '\\x%02X' , ord ( $ chr ) ) ; } $ chr = $ this -> convertEncoding ( $ chr , 'UTF-16BE' , 'UTF-8' ) ; $ hex = strtoupper ( bin2hex ( $ chr ) ) ; if ( strlen ( $ hex ) <= 4 ) { return sprintf ( '\\u%04s' , $ hex ) ; } $ highSurrogate = substr ( $ hex , 0 , 4 ) ; $ lowSurrogate = substr ( $ hex , 4 , 4 ) ; return sprintf ( '\\u%04s\\u%04s' , $ highSurrogate , $ lowSurrogate ) ; } 
protected function cssMatcher ( $ matches ) { $ chr = $ matches [ 0 ] ; if ( strlen ( $ chr ) == 1 ) { $ ord = ord ( $ chr ) ; } else { $ chr = $ this -> convertEncoding ( $ chr , 'UTF-32BE' , 'UTF-8' ) ; $ ord = hexdec ( bin2hex ( $ chr ) ) ; } return sprintf ( '\\%X ' , $ ord ) ; } 
protected function toUtf8 ( $ string ) { if ( $ this -> getEncoding ( ) === 'utf-8' ) { $ result = $ string ; } else { $ result = $ this -> convertEncoding ( $ string , 'UTF-8' , $ this -> getEncoding ( ) ) ; } if ( ! $ this -> isUtf8 ( $ result ) ) { throw new Exception \ RuntimeException ( sprintf ( 'String to be escaped was not valid UTF-8 or could not be converted: %s' , $ result ) ) ; } return $ result ; } 
protected function fromUtf8 ( $ string ) { if ( $ this -> getEncoding ( ) === 'utf-8' ) { return $ string ; } return $ this -> convertEncoding ( $ string , $ this -> getEncoding ( ) , 'UTF-8' ) ; } 
public function initialize ( ) { try { 
public function get ( string $ key ) { $ data = array_combine ( [ '__ci_type' , '__ci_value' , ] , $ this -> redis -> hmget ( $ key , [ '__ci_type' , '__ci_value' ] ) ) ; if ( ! isset ( $ data [ '__ci_type' ] , $ data [ '__ci_value' ] ) || $ data [ '__ci_value' ] === false ) { return null ; } switch ( $ data [ '__ci_type' ] ) { case 'array' : case 'object' : return unserialize ( $ data [ '__ci_value' ] ) ; case 'boolean' : case 'integer' : case 'double' : 
public function save ( string $ key , $ value , int $ ttl = 60 ) { switch ( $ data_type = gettype ( $ value ) ) { case 'array' : case 'object' : $ value = serialize ( $ value ) ; break ; case 'boolean' : case 'integer' : case 'double' : 
public function increment ( string $ key , int $ offset = 1 ) { return $ this -> redis -> hincrby ( $ key , 'data' , $ offset ) ; } 
public function decrement ( string $ key , int $ offset = 1 ) { return $ this -> redis -> hincrby ( $ key , 'data' , - $ offset ) ; } 
public function getMetaData ( string $ key ) { $ data = array_combine ( [ '__ci_value' ] , $ this -> redis -> hmget ( $ key , [ '__ci_value' ] ) ) ; if ( isset ( $ data [ '__ci_value' ] ) && $ data [ '__ci_value' ] !== false ) { return [ 'expire' => time ( ) + $ this -> redis -> ttl ( $ key ) , 'data' => $ data [ '__ci_value' ] , ] ; } return false ; } 
public function getFile ( string $ name ) { $ this -> populateFiles ( ) ; if ( $ this -> hasFile ( $ name ) ) { if ( strpos ( $ name , '.' ) !== false ) { $ name = explode ( '.' , $ name ) ; $ uploadedFile = $ this -> getValueDotNotationSyntax ( $ name , $ this -> files ) ; return ( $ uploadedFile instanceof UploadedFile ) ? $ uploadedFile : null ; } if ( array_key_exists ( $ name , $ this -> files ) ) { $ uploadedFile = $ this -> files [ $ name ] ; return ( $ uploadedFile instanceof UploadedFile ) ? $ uploadedFile : null ; } } return null ; } 
public function hasFile ( string $ fileID ) : bool { $ this -> populateFiles ( ) ; if ( strpos ( $ fileID , '.' ) !== false ) { $ segments = explode ( '.' , $ fileID ) ; $ el = $ this -> files ; foreach ( $ segments as $ segment ) { if ( ! array_key_exists ( $ segment , $ el ) ) { return false ; } $ el = $ el [ $ segment ] ; } return true ; } return isset ( $ this -> files [ $ fileID ] ) ; } 
protected function populateFiles ( ) { if ( is_array ( $ this -> files ) ) { return ; } $ this -> files = [ ] ; if ( empty ( $ _FILES ) ) { return ; } $ files = $ this -> fixFilesArray ( $ _FILES ) ; foreach ( $ files as $ name => $ file ) { $ this -> files [ $ name ] = $ this -> createFileObject ( $ file ) ; } } 
protected function createFileObject ( array $ array ) { if ( ! isset ( $ array [ 'name' ] ) ) { $ output = [ ] ; foreach ( $ array as $ key => $ values ) { if ( ! is_array ( $ values ) ) { continue ; } $ output [ $ key ] = $ this -> createFileObject ( $ values ) ; } return $ output ; } return new UploadedFile ( $ array [ 'tmp_name' ] ?? null , $ array [ 'name' ] ?? null , $ array [ 'type' ] ?? null , $ array [ 'size' ] ?? null , $ array [ 'error' ] ?? null ) ; } 
protected function fixFilesArray ( array $ data ) : array { $ output = [ ] ; foreach ( $ data as $ name => $ array ) { foreach ( $ array as $ field => $ value ) { $ pointer = & $ output [ $ name ] ; if ( ! is_array ( $ value ) ) { $ pointer [ $ field ] = $ value ; continue ; } $ stack = [ & $ pointer ] ; $ iterator = new \ RecursiveIteratorIterator ( new \ RecursiveArrayIterator ( $ value ) , \ RecursiveIteratorIterator :: SELF_FIRST ) ; foreach ( $ iterator as $ key => $ val ) { array_splice ( $ stack , $ iterator -> getDepth ( ) + 1 ) ; $ pointer = & $ stack [ count ( $ stack ) - 1 ] ; $ pointer = & $ pointer [ $ key ] ; $ stack [ ] = & $ pointer ; if ( ! $ iterator -> hasChildren ( ) ) { $ pointer [ $ field ] = $ val ; } } } } return $ output ; } 
protected function getValueDotNotationSyntax ( array $ index , array $ value ) { if ( is_array ( $ index ) && ! empty ( $ index ) ) { $ current_index = array_shift ( $ index ) ; } if ( is_array ( $ index ) && $ index && is_array ( $ value [ $ current_index ] ) && $ value [ $ current_index ] ) { return $ this -> getValueDotNotationSyntax ( $ index , $ value [ $ current_index ] ) ; } return ( isset ( $ value [ $ current_index ] ) ) ? $ value [ $ current_index ] : null ; } 
public function run ( array $ params ) { $ collection = Services :: routes ( true ) ; $ methods = [ 'get' , 'head' , 'post' , 'put' , 'delete' , 'options' , 'trace' , 'connect' , 'cli' , ] ; $ tbody = [ ] ; foreach ( $ methods as $ method ) { $ routes = $ collection -> getRoutes ( $ method ) ; foreach ( $ routes as $ from => $ to ) { 
public function initialize ( ) { $ config = $ this -> config ; $ this -> redis = new \ Redis ( ) ; if ( ! $ this -> redis -> connect ( $ config [ 'host' ] , ( $ config [ 'host' ] [ 0 ] === '/' ? 0 : $ config [ 'port' ] ) , $ config [ 'timeout' ] ) ) { log_message ( 'error' , 'Cache: Redis connection failed. Check your configuration.' ) ; } if ( isset ( $ config [ 'password' ] ) && ! $ this -> redis -> auth ( $ config [ 'password' ] ) ) { log_message ( 'error' , 'Cache: Redis authentication failed.' ) ; } if ( isset ( $ config [ 'database' ] ) && ! $ this -> redis -> select ( $ config [ 'database' ] ) ) { log_message ( 'error' , 'Cache: Redis select database failed.' ) ; } } 
public function get ( string $ key ) { $ key = $ this -> prefix . $ key ; $ data = $ this -> redis -> hMGet ( $ key , [ '__ci_type' , '__ci_value' ] ) ; if ( ! isset ( $ data [ '__ci_type' ] , $ data [ '__ci_value' ] ) || $ data [ '__ci_value' ] === false ) { return null ; } switch ( $ data [ '__ci_type' ] ) { case 'array' : case 'object' : return unserialize ( $ data [ '__ci_value' ] ) ; case 'boolean' : case 'integer' : case 'double' : 
public function save ( string $ key , $ value , int $ ttl = 60 ) { $ key = $ this -> prefix . $ key ; switch ( $ data_type = gettype ( $ value ) ) { case 'array' : case 'object' : $ value = serialize ( $ value ) ; break ; case 'boolean' : case 'integer' : case 'double' : 
public function delete ( string $ key ) { $ key = $ this -> prefix . $ key ; return ( $ this -> redis -> delete ( $ key ) === 1 ) ; } 
public function increment ( string $ key , int $ offset = 1 ) { $ key = $ this -> prefix . $ key ; return $ this -> redis -> hIncrBy ( $ key , 'data' , $ offset ) ; } 
public function getMetaData ( string $ key ) { $ key = $ this -> prefix . $ key ; $ value = $ this -> get ( $ key ) ; if ( $ value !== null ) { $ time = time ( ) ; return [ 'expire' => $ time + $ this -> redis -> ttl ( $ key ) , 'mtime' => $ time , 'data' => $ value , ] ; } return null ; } 
public function setBinary ( string $ binary ) { if ( $ this -> file !== null ) { throw DownloadException :: forCannotSetBinary ( ) ; } $ this -> binary = $ binary ; } 
public function setFilePath ( string $ filepath ) { if ( $ this -> binary !== null ) { throw DownloadException :: forCannotSetFilePath ( $ filepath ) ; } $ this -> file = new File ( $ filepath , true ) ; } 
public function getContentLength ( ) : int { if ( is_string ( $ this -> binary ) ) { return strlen ( $ this -> binary ) ; } elseif ( $ this -> file instanceof File ) { return $ this -> file -> getSize ( ) ; } return 0 ; } 
private function setContentTypeByMimeType ( ) { $ mime = null ; $ charset = '' ; if ( $ this -> setMime === true ) { if ( ( $ last_dot_position = strrpos ( $ this -> filename , '.' ) ) !== false ) { $ mime = Mimes :: guessTypeFromExtension ( substr ( $ this -> filename , $ last_dot_position + 1 ) ) ; $ charset = $ this -> charset ; } } if ( ! is_string ( $ mime ) ) { 
private function getDownloadFileName ( ) : string { $ filename = $ this -> filename ; $ x = explode ( '.' , $ this -> filename ) ; $ extension = end ( $ x ) ; 
private function getContentDisposition ( ) : string { $ download_filename = $ this -> getDownloadFileName ( ) ; $ utf8_filename = $ download_filename ; if ( strtoupper ( $ this -> charset ) !== 'UTF-8' ) { $ utf8_filename = mb_convert_encoding ( $ download_filename , 'UTF-8' , $ this -> charset ) ; } $ result = sprintf ( 'attachment; filename="%s"' , $ download_filename ) ; if ( isset ( $ utf8_filename ) ) { $ result .= '; filename*=UTF-8\'\'' . rawurlencode ( $ utf8_filename ) ; } return $ result ; } 
public function setDate ( \ DateTime $ date ) { $ date -> setTimezone ( new \ DateTimeZone ( 'UTC' ) ) ; $ this -> setHeader ( 'Date' , $ date -> format ( 'D, d M Y H:i:s' ) . ' GMT' ) ; return $ this ; } 
public function setLastModified ( $ date ) { if ( $ date instanceof \ DateTime ) { $ date -> setTimezone ( new \ DateTimeZone ( 'UTC' ) ) ; $ this -> setHeader ( 'Last-Modified' , $ date -> format ( 'D, d M Y H:i:s' ) . ' GMT' ) ; } elseif ( is_string ( $ date ) ) { $ this -> setHeader ( 'Last-Modified' , $ date ) ; } return $ this ; } 
public function buildHeaders ( ) { if ( ! $ this -> hasHeader ( 'Content-Type' ) ) { $ this -> setContentTypeByMimeType ( ) ; } $ this -> setHeader ( 'Content-Disposition' , $ this -> getContentDisposition ( ) ) ; $ this -> setHeader ( 'Expires-Disposition' , '0' ) ; $ this -> setHeader ( 'Content-Transfer-Encoding' , 'binary' ) ; $ this -> setHeader ( 'Content-Length' , ( string ) $ this -> getContentLength ( ) ) ; $ this -> noCache ( ) ; } 
public function sendBody ( ) { if ( $ this -> binary !== null ) { return $ this -> sendBodyByBinary ( ) ; } elseif ( $ this -> file !== null ) { return $ this -> sendBodyByFilePath ( ) ; } throw DownloadException :: forNotFoundDownloadSource ( ) ; } 
private function sendBodyByFilePath ( ) { $ spl_file_object = $ this -> file -> openFile ( 'rb' ) ; 
public function _remap ( $ method , ... $ params ) { 
public function index ( array $ params ) { $ command = array_shift ( $ params ) ; $ this -> createCommandList ( ) ; if ( is_null ( $ command ) ) { $ command = 'help' ; } return $ this -> runCommand ( $ command , $ params ) ; } 
protected function runCommand ( string $ command , array $ params ) { if ( ! isset ( $ this -> commands [ $ command ] ) ) { CLI :: error ( lang ( 'CLI.commandNotFound' , [ $ command ] ) ) ; CLI :: newLine ( ) ; return ; } 
protected function createCommandList ( ) { $ files = Services :: locator ( ) -> listFiles ( 'Commands/' ) ; 
public static function connect ( $ group = null , bool $ getShared = true ) { 
public static function seeder ( string $ group = null ) { $ config = config ( 'Database' ) ; return new Seeder ( $ config , static :: connect ( $ group ) ) ; } 
public function run ( array $ params = [ ] ) { $ runner = Services :: migrations ( ) ; CLI :: write ( lang ( 'Migrations.rollingBack' ) , 'yellow' ) ; $ group = $ params [ '-g' ] ?? CLI :: getOption ( 'g' ) ; if ( ! is_null ( $ group ) ) { $ runner -> setGroup ( $ group ) ; } try { if ( ! $ this -> isAllNamespace ( $ params ) ) { $ namespace = $ params [ '-n' ] ?? CLI :: getOption ( 'n' ) ; $ runner -> version ( 0 , $ namespace ) ; } else { 
private function isAllNamespace ( array $ params ) : bool { if ( array_search ( '-all' , $ params ) !== false ) { return true ; } return ! is_null ( CLI :: getOption ( 'all' ) ) ; } 
public function add ( string $ name , \ Closure $ closure ) { $ name = strtolower ( $ name ) ; $ this -> tests [ $ name ] = $ closure ; return $ this ; } 
public function run ( int $ iterations = 1000 , bool $ output = true ) { foreach ( $ this -> tests as $ name => $ test ) { 
public function getReport ( ) : string { if ( empty ( $ this -> results ) ) { return 'No results to display.' ; } helper ( 'number' ) ; <thead> <tr> <td>Test</td> <td>Time</td> <td>Memory</td> </tr> </thead> <tbody> {rows} </tbody> </table>' ; $ rows = '' ; foreach ( $ this -> results as $ name => $ result ) { $ memory = number_to_size ( $ result [ 'memory' ] , 4 ) ; $ rows .= "<tr> <td>{$name}</td> <td>" . number_format ( $ result [ 'time' ] , 4 ) . "</td> <td>{$memory}</td> </tr>" ; } $ tpl = str_replace ( '{rows}' , $ rows , $ tpl ) ; return $ tpl . '<br/>' ; } 
public function setQuery ( string $ sql , $ binds = null , bool $ setEscape = true ) { $ this -> originalQueryString = $ sql ; if ( ! is_null ( $ binds ) ) { if ( ! is_array ( $ binds ) ) { $ binds = [ $ binds ] ; } if ( $ setEscape ) { array_walk ( $ binds , function ( & $ item ) { $ item = [ $ item , true , ] ; } ) ; } $ this -> binds = $ binds ; } return $ this ; } 
public function getQuery ( ) : string { if ( empty ( $ this -> finalQueryString ) ) { $ this -> finalQueryString = $ this -> originalQueryString ; } $ this -> compileBinds ( ) ; return $ this -> finalQueryString ; } 
public function setDuration ( float $ start , float $ end = null ) { $ this -> startTime = $ start ; if ( is_null ( $ end ) ) { $ end = microtime ( true ) ; } $ this -> endTime = $ end ; return $ this ; } 
public function getStartTime ( bool $ returnRaw = false , int $ decimals = 6 ) : string { if ( $ returnRaw ) { return $ this -> startTime ; } return number_format ( $ this -> startTime , $ decimals ) ; } 
public function getDuration ( int $ decimals = 6 ) : string { return number_format ( ( $ this -> endTime - $ this -> startTime ) , $ decimals ) ; } 
public function setError ( int $ code , string $ error ) { $ this -> errorCode = $ code ; $ this -> errorString = $ error ; return $ this ; } 
public function swapPrefix ( string $ orig , string $ swap ) { $ sql = empty ( $ this -> finalQueryString ) ? $ this -> originalQueryString : $ this -> finalQueryString ; $ this -> finalQueryString = preg_replace ( '/(\W)' . $ orig . '(\S+?)/' , '\\1' . $ swap . '\\2' , $ sql ) ; return $ this ; } 
protected function compileBinds ( ) { $ sql = $ this -> finalQueryString ; $ hasNamedBinds = strpos ( $ sql , ':' ) !== false ; if ( empty ( $ this -> binds ) || empty ( $ this -> bindMarker ) || ( strpos ( $ sql , $ this -> bindMarker ) === false && $ hasNamedBinds === false ) ) { return ; } if ( ! is_array ( $ this -> binds ) ) { $ binds = [ $ this -> binds ] ; $ bindCount = 1 ; } else { $ binds = $ this -> binds ; $ bindCount = count ( $ binds ) ; } 
protected function matchNamedBinds ( string $ sql , array $ binds ) : string { $ replacers = [ ] ; foreach ( $ binds as $ placeholder => $ value ) { 
protected function matchSimpleBinds ( string $ sql , array $ binds , int $ bindCount , int $ ml ) : string { 
public function initController ( RequestInterface $ request , ResponseInterface $ response , LoggerInterface $ logger ) { $ this -> request = $ request ; $ this -> response = $ response ; $ this -> logger = $ logger ; $ this -> logger -> info ( 'Controller "' . get_class ( $ this ) . '" loaded.' ) ; if ( $ this -> forceHTTPS > 0 ) { $ this -> forceHTTPS ( $ this -> forceHTTPS ) ; } $ this -> loadHelpers ( ) ; } 
protected function loadHelpers ( ) { if ( empty ( $ this -> helpers ) ) { return ; } foreach ( $ this -> helpers as $ helper ) { helper ( $ helper ) ; } } 
protected function validate ( $ rules , array $ messages = [ ] ) : bool { $ this -> validator = Services :: validation ( ) ; 
public function initialize ( \ Config \ Autoload $ config , \ Config \ Modules $ moduleConfig ) { 
public function register ( ) { 
public function addNamespace ( $ namespace , string $ path = null ) { if ( is_array ( $ namespace ) ) { foreach ( $ namespace as $ prefix => $ path ) { $ prefix = trim ( $ prefix , '\\' ) ; if ( is_array ( $ path ) ) { foreach ( $ path as $ dir ) { $ this -> prefixes [ $ prefix ] [ ] = rtrim ( $ dir , '/' ) . '/' ; } continue ; } $ this -> prefixes [ $ prefix ] [ ] = rtrim ( $ path , '/' ) . '/' ; } } else { $ this -> prefixes [ trim ( $ namespace , '\\' ) ] [ ] = rtrim ( $ path , '/' ) . '/' ; } return $ this ; } 
public function getNamespace ( string $ prefix = null ) { if ( $ prefix === null ) { return $ this -> prefixes ; } return $ this -> prefixes [ trim ( $ prefix , '\\' ) ] ?? [ ] ; } 
public function loadClass ( string $ class ) { $ class = trim ( $ class , '\\' ) ; $ class = str_ireplace ( '.php' , '' , $ class ) ; $ mapped_file = $ this -> loadInNamespace ( $ class ) ; 
protected function loadInNamespace ( string $ class ) { if ( strpos ( $ class , '\\' ) === false ) { return false ; } foreach ( $ this -> prefixes as $ namespace => $ directories ) { foreach ( $ directories as $ directory ) { $ directory = rtrim ( $ directory , '/' ) ; if ( strpos ( $ class , $ namespace ) === 0 ) { $ filePath = $ directory . str_replace ( '\\' , '/' , substr ( $ class , strlen ( $ namespace ) ) ) . '.php' ; $ filename = $ this -> requireFile ( $ filePath ) ; if ( $ filename ) { return $ filename ; } } } } 
protected function loadLegacy ( string $ class ) { 
protected function requireFile ( string $ file ) { $ file = $ this -> sanitizeFilename ( $ file ) ; if ( is_file ( $ file ) ) { require_once $ file ; return $ file ; } return false ; } 
public function sanitizeFilename ( string $ filename ) : string { 
protected function discoverComposerNamespaces ( ) { if ( ! is_file ( COMPOSER_PATH ) ) { return false ; } $ composer = include COMPOSER_PATH ; $ paths = $ composer -> getPrefixesPsr4 ( ) ; unset ( $ composer ) ; 
public static function date ( $ value , string $ format ) : string { if ( is_string ( $ value ) && ! is_numeric ( $ value ) ) { $ value = strtotime ( $ value ) ; } return date ( $ format , $ value ) ; } 
public static function date_modify ( $ value , string $ adjustment ) : string { $ value = static :: date ( $ value , 'Y-m-d H:i:s' ) ; return strtotime ( $ adjustment , strtotime ( $ value ) ) ; } 
public static function excerpt ( string $ value , string $ phrase , int $ radius = 100 ) : string { helper ( 'text' ) ; return excerpt ( $ value , $ phrase , $ radius ) ; } 
public static function highlight ( string $ value , string $ phrase ) : string { helper ( 'text' ) ; return highlight_phrase ( $ value , $ phrase ) ; } 
public static function local_number ( $ value , string $ type = 'decimal' , int $ precision = 4 , string $ locale = null ) : string { helper ( 'number' ) ; $ types = [ 'decimal' => NumberFormatter :: DECIMAL , 'currency' => NumberFormatter :: CURRENCY , 'percent' => NumberFormatter :: PERCENT , 'scientific' => NumberFormatter :: SCIENTIFIC , 'spellout' => NumberFormatter :: SPELLOUT , 'ordinal' => NumberFormatter :: ORDINAL , 'duration' => NumberFormatter :: DURATION , ] ; return format_number ( $ value , $ precision , $ locale , [ 'type' => $ types [ $ type ] ] ) ; } 
public static function local_currency ( $ value , string $ currency , string $ locale = null ) : string { helper ( 'number' ) ; $ options = [ 'type' => NumberFormatter :: CURRENCY , 'currency' => $ currency , ] ; return format_number ( $ value , 2 , $ locale , $ options ) ; } 
public static function nl2br ( string $ value ) : string { $ typography = Services :: typography ( ) ; return $ typography -> nl2brExceptPre ( $ value ) ; } 
public static function prose ( string $ value ) : string { $ typography = Services :: typography ( ) ; return $ typography -> autoTypography ( $ value ) ; } 
public static function round ( string $ value , $ precision = 2 , string $ type = 'common' ) : string { if ( ! is_numeric ( $ precision ) ) { $ type = $ precision ; $ precision = 2 ; } switch ( $ type ) { case 'common' : return round ( $ value , $ precision ) ; break ; case 'ceil' : return ceil ( $ value ) ; break ; case 'floor' : return floor ( $ value ) ; break ; } 
public function load ( ) : bool { 
protected function setVariable ( string $ name , string $ value = '' ) { list ( $ name , $ value ) = $ this -> normaliseVariable ( $ name , $ value ) ; if ( ! getenv ( $ name , true ) ) { putenv ( "$name=$value" ) ; } if ( empty ( $ _ENV [ $ name ] ) ) { $ _ENV [ $ name ] = $ value ; } if ( empty ( $ _SERVER [ $ name ] ) ) { $ _SERVER [ $ name ] = $ value ; } } 
public function normaliseVariable ( string $ name , string $ value = '' ) : array { 
protected function sanitizeValue ( string $ value ) : string { if ( ! $ value ) { return $ value ; } %1$s # match a quote at the start of the value ( # capturing sub-pattern used (?: # we do not need to capture this [^%1$s\\\\] # any character other than a quote or backslash |\\\\\\\\ # or two backslashes together |\\\\%1$s # or an escaped quote e.g \" )* # as many characters that match the previous rules ) # end of the capturing sub-pattern %1$s # and the closing quote .*$ # and discard any string after the closing quote /mx' , $ quote ) ; $ value = preg_replace ( $ regexPattern , '$1' , $ value ) ; $ value = str_replace ( "\\$quote" , $ quote , $ value ) ; $ value = str_replace ( '\\\\' , '\\' , $ value ) ; } else { $ parts = explode ( ' #' , $ value , 2 ) ; $ value = trim ( $ parts [ 0 ] ) ; 
protected function resolveNestedVariables ( string $ value ) : string { if ( strpos ( $ value , '$' ) !== false ) { $ loader = $ this ; $ value = preg_replace_callback ( '/\${([a-zA-Z0-9_]+)}/' , function ( $ matchedPatterns ) use ( $ loader ) { $ nestedVariable = $ loader -> getVariable ( $ matchedPatterns [ 1 ] ) ; if ( is_null ( $ nestedVariable ) ) { return $ matchedPatterns [ 0 ] ; } return $ nestedVariable ; } , $ value ) ; } return $ value ; } 
public function connect ( bool $ persistent = false ) { REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE( @@sql_mode, "STRICT_ALL_TABLES,", ""), ",STRICT_ALL_TABLES", ""), "STRICT_ALL_TABLES", ""), "STRICT_TRANS_TABLES,", ""), ",STRICT_TRANS_TABLES", ""), "STRICT_TRANS_TABLES", "")' ) ; } } if ( is_array ( $ this -> encrypt ) ) { $ ssl = [ ] ; empty ( $ this -> encrypt [ 'ssl_key' ] ) || $ ssl [ 'key' ] = $ this -> encrypt [ 'ssl_key' ] ; empty ( $ this -> encrypt [ 'ssl_cert' ] ) || $ ssl [ 'cert' ] = $ this -> encrypt [ 'ssl_cert' ] ; empty ( $ this -> encrypt [ 'ssl_ca' ] ) || $ ssl [ 'ca' ] = $ this -> encrypt [ 'ssl_ca' ] ; empty ( $ this -> encrypt [ 'ssl_capath' ] ) || $ ssl [ 'capath' ] = $ this -> encrypt [ 'ssl_capath' ] ; empty ( $ this -> encrypt [ 'ssl_cipher' ] ) || $ ssl [ 'cipher' ] = $ this -> encrypt [ 'ssl_cipher' ] ; if ( ! empty ( $ ssl ) ) { if ( isset ( $ this -> encrypt [ 'ssl_verify' ] ) ) { if ( $ this -> encrypt [ 'ssl_verify' ] ) { defined ( 'MYSQLI_OPT_SSL_VERIFY_SERVER_CERT' ) && $ this -> mysqli -> options ( MYSQLI_OPT_SSL_VERIFY_SERVER_CERT , true ) ; } // Apparently (when it exists), setting MYSQLI_OPT_SSL_VERIFY_SERVER_CERT // to FALSE didn't do anything, so PHP 5.6.16 introduced yet another 
public function setDatabase ( string $ databaseName ) : bool { if ( $ databaseName === '' ) { $ databaseName = $ this -> database ; } if ( empty ( $ this -> connID ) ) { $ this -> initialize ( ) ; } if ( $ this -> connID -> select_db ( $ databaseName ) ) { $ this -> database = $ databaseName ; return true ; } return false ; } 
public function getVersion ( ) : string { if ( isset ( $ this -> dataCache [ 'version' ] ) ) { return $ this -> dataCache [ 'version' ] ; } if ( empty ( $ this -> mysqli ) ) { $ this -> initialize ( ) ; } return $ this -> dataCache [ 'version' ] = $ this -> mysqli -> server_info ; } 
public function execute ( string $ sql ) { while ( $ this -> connID -> more_results ( ) ) { $ this -> connID -> next_result ( ) ; if ( $ res = $ this -> connID -> store_result ( ) ) { $ res -> free ( ) ; } } return $ this -> connID -> query ( $ this -> prepQuery ( $ sql ) ) ; } 
protected function prepQuery ( string $ sql ) : string { 
protected function _escapeString ( string $ str ) : string { if ( is_bool ( $ str ) ) { return $ str ; } if ( ! $ this -> connID ) { $ this -> initialize ( ) ; } return $ this -> connID -> real_escape_string ( $ str ) ; } 
protected function _listTables ( bool $ prefixLimit = false ) : string { $ sql = 'SHOW TABLES FROM ' . $ this -> escapeIdentifiers ( $ this -> database ) ; if ( $ prefixLimit !== false && $ this -> DBPrefix !== '' ) { return $ sql . " LIKE '" . $ this -> escapeLikeString ( $ this -> DBPrefix ) . "%'" ; } return $ sql ; } 
public function _fieldData ( string $ table ) : array { $ table = $ this -> protectIdentifiers ( $ table , true , null , false ) ; if ( ( $ query = $ this -> query ( 'SHOW COLUMNS FROM ' . $ table ) ) === false ) { throw new DatabaseException ( lang ( 'Database.failGetFieldData' ) ) ; } $ query = $ query -> getResultObject ( ) ; $ retVal = [ ] ; for ( $ i = 0 , $ c = count ( $ query ) ; $ i < $ c ; $ i ++ ) { $ retVal [ $ i ] = new \ stdClass ( ) ; $ retVal [ $ i ] -> name = $ query [ $ i ] -> Field ; sscanf ( $ query [ $ i ] -> Type , '%[a-z](%d)' , $ retVal [ $ i ] -> type , $ retVal [ $ i ] -> max_length ) ; $ retVal [ $ i ] -> default = $ query [ $ i ] -> Default ; $ retVal [ $ i ] -> primary_key = ( int ) ( $ query [ $ i ] -> Key === 'PRI' ) ; } return $ retVal ; } 
public function _indexData ( string $ table ) : array { $ table = $ this -> protectIdentifiers ( $ table , true , null , false ) ; if ( ( $ query = $ this -> query ( 'SHOW INDEX FROM ' . $ table ) ) === false ) { throw new DatabaseException ( lang ( 'Database.failGetIndexData' ) ) ; } if ( ! $ indexes = $ query -> getResultArray ( ) ) { return [ ] ; } $ keys = [ ] ; foreach ( $ indexes as $ index ) { if ( empty ( $ keys [ $ index [ 'Key_name' ] ] ) ) { $ keys [ $ index [ 'Key_name' ] ] = new \ stdClass ( ) ; $ keys [ $ index [ 'Key_name' ] ] -> name = $ index [ 'Key_name' ] ; if ( $ index [ 'Key_name' ] === 'PRIMARY' ) { $ type = 'PRIMARY' ; } elseif ( $ index [ 'Index_type' ] === 'FULLTEXT' ) { $ type = 'FULLTEXT' ; } elseif ( $ index [ 'Non_unique' ] ) { if ( $ index [ 'Index_type' ] === 'SPATIAL' ) { $ type = 'SPATIAL' ; } else { $ type = 'INDEX' ; } } else { $ type = 'UNIQUE' ; } $ keys [ $ index [ 'Key_name' ] ] -> type = $ type ; } $ keys [ $ index [ 'Key_name' ] ] -> fields [ ] = $ index [ 'Column_name' ] ; } return $ keys ; } 
public function error ( ) : array { if ( ! empty ( $ this -> mysqli -> connect_errno ) ) { return [ 'code' => $ this -> mysqli -> connect_errno , 'message' => $ this -> mysqli -> connect_error , ] ; } return [ 'code' => $ this -> connID -> errno , 'message' => $ this -> connID -> error , ] ; } 
protected function _transCommit ( ) : bool { if ( $ this -> connID -> commit ( ) ) { $ this -> connID -> autocommit ( true ) ; return true ; } return false ; } 
protected function _transRollback ( ) : bool { if ( $ this -> connID -> rollback ( ) ) { $ this -> connID -> autocommit ( true ) ; return true ; } return false ; } 
public function connect ( bool $ persistent = false ) { if ( $ persistent && $ this -> db -> DBDebug ) { throw new DatabaseException ( 'SQLite3 doesn\'t support persistent connections.' ) ; } try { return ( ! $ this -> password ) ? new \ SQLite3 ( $ this -> database ) : new \ SQLite3 ( $ this -> database , SQLITE3_OPEN_READWRITE | SQLITE3_OPEN_CREATE , $ this -> password ) ; } catch ( \ Exception $ e ) { throw new DatabaseException ( 'SQLite3 error: ' . $ e -> getMessage ( ) ) ; } } 
public function getVersion ( ) : string { if ( isset ( $ this -> dataCache [ 'version' ] ) ) { return $ this -> dataCache [ 'version' ] ; } $ version = \ SQLite3 :: version ( ) ; return $ this -> dataCache [ 'version' ] = $ version [ 'versionString' ] ; } 
public function execute ( string $ sql ) { return $ this -> isWriteType ( $ sql ) ? $ this -> connID -> exec ( $ sql ) : $ this -> connID -> query ( $ sql ) ; } 
protected function _listTables ( bool $ prefixLimit = false ) : string { return 'SELECT "NAME" FROM "SQLITE_MASTER" WHERE "TYPE" = \'table\'' . ( ( $ prefixLimit !== false && $ this -> DBPrefix !== '' ) ? ' AND "NAME" LIKE \'' . $ this -> escapeLikeString ( $ this -> DBPrefix ) . '%\' ' . sprintf ( $ this -> likeEscapeStr , $ this -> likeEscapeChar ) : '' ) ; } 
protected function _listColumns ( string $ table = '' ) : string { return 'PRAGMA TABLE_INFO(' . $ this -> protectIdentifiers ( $ table , true , null , false ) . ')' ; } 
public function getFieldNames ( string $ table ) { 
public function _fieldData ( string $ table ) : array { if ( ( $ query = $ this -> query ( 'PRAGMA TABLE_INFO(' . $ this -> protectIdentifiers ( $ table , true , null , false ) . ')' ) ) === false ) { throw new DatabaseException ( lang ( 'Database.failGetFieldData' ) ) ; } $ query = $ query -> getResultObject ( ) ; if ( empty ( $ query ) ) { return [ ] ; } $ retVal = [ ] ; for ( $ i = 0 , $ c = count ( $ query ) ; $ i < $ c ; $ i ++ ) { $ retVal [ $ i ] = new \ stdClass ( ) ; $ retVal [ $ i ] -> name = $ query [ $ i ] -> name ; $ retVal [ $ i ] -> type = $ query [ $ i ] -> type ; $ retVal [ $ i ] -> max_length = null ; $ retVal [ $ i ] -> default = $ query [ $ i ] -> dflt_value ; $ retVal [ $ i ] -> primary_key = isset ( $ query [ $ i ] -> pk ) ? ( bool ) $ query [ $ i ] -> pk : false ; $ retVal [ $ i ] -> nullable = isset ( $ query [ $ i ] -> notnull ) ? ! ( bool ) $ query [ $ i ] -> notnull : false ; } return $ retVal ; } 
public function _indexData ( string $ table ) : array { 
public function _foreignKeyData ( string $ table ) : array { if ( $ this -> supportsForeignKeys ( ) !== true ) { return [ ] ; } $ tables = $ this -> listTables ( ) ; if ( empty ( $ tables ) ) { return [ ] ; } $ retVal = [ ] ; foreach ( $ tables as $ table ) { $ query = $ this -> query ( "PRAGMA foreign_key_list({$table})" ) -> getResult ( ) ; foreach ( $ query as $ row ) { $ obj = new \ stdClass ( ) ; $ obj -> constraint_name = $ row -> from . ' to ' . $ row -> table . '.' . $ row -> to ; $ obj -> table_name = $ table ; $ obj -> foreign_table_name = $ row -> table ; $ retVal [ ] = $ obj ; } } return $ retVal ; } 
public static function cache ( Cache $ config = null , bool $ getShared = true ) { if ( $ getShared ) { return static :: getSharedInstance ( 'cache' , $ config ) ; } if ( ! is_object ( $ config ) ) { $ config = new Cache ( ) ; } return CacheFactory :: getHandler ( $ config ) ; } 
public static function clirequest ( App $ config = null , bool $ getShared = true ) { if ( $ getShared ) { return static :: getSharedInstance ( 'clirequest' , $ config ) ; } if ( ! is_object ( $ config ) ) { $ config = config ( App :: class ) ; } return new CLIRequest ( $ config ) ; } 
public static function curlrequest ( array $ options = [ ] , ResponseInterface $ response = null , App $ config = null , bool $ getShared = true ) { if ( $ getShared === true ) { return static :: getSharedInstance ( 'curlrequest' , $ options , $ response , $ config ) ; } if ( ! is_object ( $ config ) ) { $ config = config ( App :: class ) ; } if ( ! is_object ( $ response ) ) { $ response = new Response ( $ config ) ; } return new CURLRequest ( $ config , new URI ( $ options [ 'base_uri' ] ?? null ) , $ response , $ options ) ; } 
public static function exceptions ( \ Config \ Exceptions $ config = null , IncomingRequest $ request = null , Response $ response = null , bool $ getShared = true ) { if ( $ getShared ) { return static :: getSharedInstance ( 'exceptions' , $ config , $ request , $ response ) ; } if ( empty ( $ config ) ) { $ config = new \ Config \ Exceptions ( ) ; } if ( empty ( $ request ) ) { $ request = static :: request ( ) ; } if ( empty ( $ response ) ) { $ response = static :: response ( ) ; } return ( new Exceptions ( $ config , $ request , $ response ) ) ; } 
public static function filters ( $ config = null , bool $ getShared = true ) { if ( $ getShared ) { return static :: getSharedInstance ( 'filters' , $ config ) ; } if ( empty ( $ config ) ) { $ config = new \ Config \ Filters ( ) ; } return new Filters ( $ config , static :: request ( ) , static :: response ( ) ) ; } 
public static function honeypot ( BaseConfig $ config = null , bool $ getShared = true ) { if ( $ getShared ) { return static :: getSharedInstance ( 'honeypot' , $ config ) ; } if ( is_null ( $ config ) ) { $ config = new \ Config \ Honeypot ( ) ; } return new Honeypot ( $ config ) ; } 
public static function image ( string $ handler = null , $ config = null , bool $ getShared = true ) { if ( $ getShared ) { return static :: getSharedInstance ( 'image' , $ handler , $ config ) ; } if ( empty ( $ config ) ) { $ config = new Images ( ) ; } $ handler = is_null ( $ handler ) ? $ config -> defaultHandler : $ handler ; $ class = $ config -> handlers [ $ handler ] ; return new $ class ( $ config ) ; } 
public static function language ( string $ locale = null , bool $ getShared = true ) { if ( $ getShared ) { return static :: getSharedInstance ( 'language' , $ locale ) -> setLocale ( $ locale ) ; } $ locale = ! empty ( $ locale ) ? $ locale : static :: request ( ) -> getLocale ( ) ; return new Language ( $ locale ) ; } 
public static function logger ( bool $ getShared = true ) { if ( $ getShared ) { return static :: getSharedInstance ( 'logger' ) ; } return new \ CodeIgniter \ Log \ Logger ( new Logger ( ) ) ; } 
public static function migrations ( BaseConfig $ config = null , ConnectionInterface $ db = null , bool $ getShared = true ) { if ( $ getShared ) { return static :: getSharedInstance ( 'migrations' , $ config , $ db ) ; } $ config = empty ( $ config ) ? new Migrations ( ) : $ config ; return new MigrationRunner ( $ config , $ db ) ; } 
public static function negotiator ( RequestInterface $ request = null , bool $ getShared = true ) { if ( $ getShared ) { return static :: getSharedInstance ( 'negotiator' , $ request ) ; } if ( is_null ( $ request ) ) { $ request = static :: request ( ) ; } return new Negotiate ( $ request ) ; } 
public static function pager ( $ config = null , RendererInterface $ view = null , bool $ getShared = true ) { if ( $ getShared ) { return static :: getSharedInstance ( 'pager' , $ config , $ view ) ; } if ( empty ( $ config ) ) { $ config = new \ Config \ Pager ( ) ; } if ( ! $ view instanceof RendererInterface ) { $ view = static :: renderer ( ) ; } return new Pager ( $ config , $ view ) ; } 
public static function parser ( string $ viewPath = null , $ config = null , bool $ getShared = true ) { if ( $ getShared ) { return static :: getSharedInstance ( 'parser' , $ viewPath , $ config ) ; } if ( is_null ( $ config ) ) { $ config = new \ Config \ View ( ) ; } if ( is_null ( $ viewPath ) ) { $ paths = config ( 'Paths' ) ; $ viewPath = $ paths -> viewDirectory ; } return new Parser ( $ config , $ viewPath , static :: locator ( true ) , CI_DEBUG , static :: logger ( true ) ) ; } 
public static function request ( App $ config = null , bool $ getShared = true ) { if ( $ getShared ) { return static :: getSharedInstance ( 'request' , $ config ) ; } if ( ! is_object ( $ config ) ) { $ config = config ( App :: class ) ; } return new IncomingRequest ( $ config , new URI ( ) , 'php://input' , new UserAgent ( ) ) ; } 
public static function response ( App $ config = null , bool $ getShared = true ) { if ( $ getShared ) { return static :: getSharedInstance ( 'response' , $ config ) ; } if ( ! is_object ( $ config ) ) { $ config = config ( App :: class ) ; } return new Response ( $ config ) ; } 
public static function redirectResponse ( App $ config = null , bool $ getShared = true ) { if ( $ getShared ) { return static :: getSharedInstance ( 'redirectResponse' , $ config ) ; } if ( ! is_object ( $ config ) ) { $ config = config ( App :: class ) ; } $ response = new RedirectResponse ( $ config ) ; $ response -> setProtocolVersion ( static :: request ( ) -> getProtocolVersion ( ) ) ; return $ response ; } 
public static function router ( RouteCollectionInterface $ routes = null , bool $ getShared = true ) { if ( $ getShared ) { return static :: getSharedInstance ( 'router' , $ routes ) ; } if ( empty ( $ routes ) ) { $ routes = static :: routes ( true ) ; } return new Router ( $ routes ) ; } 
public static function security ( App $ config = null , bool $ getShared = true ) { if ( $ getShared ) { return static :: getSharedInstance ( 'security' , $ config ) ; } if ( ! is_object ( $ config ) ) { $ config = config ( App :: class ) ; } return new Security ( $ config ) ; } 
public static function session ( App $ config = null , bool $ getShared = true ) { if ( $ getShared ) { return static :: getSharedInstance ( 'session' , $ config ) ; } if ( ! is_object ( $ config ) ) { $ config = config ( App :: class ) ; } $ logger = static :: logger ( true ) ; $ driverName = $ config -> sessionDriver ; $ driver = new $ driverName ( $ config , static :: request ( ) -> getIpAddress ( ) ) ; $ driver -> setLogger ( $ logger ) ; $ session = new Session ( $ driver , $ config ) ; $ session -> setLogger ( $ logger ) ; if ( session_status ( ) === PHP_SESSION_NONE ) { $ session -> start ( ) ; } return $ session ; } 
public static function toolbar ( \ Config \ Toolbar $ config = null , bool $ getShared = true ) { if ( $ getShared ) { return static :: getSharedInstance ( 'toolbar' , $ config ) ; } if ( ! is_object ( $ config ) ) { $ config = config ( 'Toolbar' ) ; } return new Toolbar ( $ config ) ; } 
public static function uri ( string $ uri = null , bool $ getShared = true ) { if ( $ getShared ) { return static :: getSharedInstance ( 'uri' , $ uri ) ; } return new URI ( $ uri ) ; } 
public static function validation ( \ Config \ Validation $ config = null , bool $ getShared = true ) { if ( $ getShared ) { return static :: getSharedInstance ( 'validation' , $ config ) ; } if ( is_null ( $ config ) ) { $ config = config ( 'Validation' ) ; } return new Validation ( $ config , static :: renderer ( ) ) ; } 
public function run ( array $ params = [ ] ) { $ runner = Services :: migrations ( ) ; CLI :: write ( lang ( 'Migrations.toVersion' ) , 'yellow' ) ; $ group = $ params [ '-g' ] ?? CLI :: getOption ( 'g' ) ; try { $ runner -> current ( $ group ) ; $ messages = $ runner -> getCliMessages ( ) ; foreach ( $ messages as $ message ) { CLI :: write ( $ message ) ; } CLI :: write ( 'Done' ) ; } catch ( \ Exception $ e ) { $ this -> showError ( $ e ) ; } } 
protected function destroyCookie ( ) : bool { return setcookie ( $ this -> cookieName , null , 1 , $ this -> cookiePath , $ this -> cookieDomain , $ this -> cookieSecure , true ) ; } 
public function run ( array $ params ) { $ commands = $ this -> commands -> getCommands ( ) ; $ this -> describeCommands ( $ commands ) ; CLI :: newLine ( ) ; } 
protected function describeCommands ( array $ commands = [ ] ) { ksort ( $ commands ) ; 
protected function padTitle ( string $ item , int $ max , int $ extra = 2 , int $ indent = 0 ) : string { $ max += $ extra + $ indent ; $ item = str_repeat ( ' ' , $ indent ) . $ item ; $ item = str_pad ( $ item , $ max ) ; return $ item ; } 
public function listDatabases ( ) { 
public function optimizeTable ( string $ table_name ) { if ( $ this -> optimizeTable === false ) { if ( $ this -> db -> DBDebug ) { throw new DatabaseException ( 'Unsupported feature of the database platform you are using.' ) ; } return false ; } $ query = $ this -> db -> query ( sprintf ( $ this -> optimizeTable , $ this -> db -> escapeIdentifiers ( $ table_name ) ) ) ; if ( $ query !== false ) { $ query = $ query -> getResultArray ( ) ; return current ( $ query ) ; } return false ; } 
public function optimizeDatabase ( ) { if ( $ this -> optimizeTable === false ) { if ( $ this -> db -> DBDebug ) { throw new DatabaseException ( 'Unsupported feature of the database platform you are using.' ) ; } return false ; } $ result = [ ] ; foreach ( $ this -> db -> listTables ( ) as $ table_name ) { $ res = $ this -> db -> query ( sprintf ( $ this -> optimizeTable , $ this -> db -> escapeIdentifiers ( $ table_name ) ) ) ; if ( is_bool ( $ res ) ) { return $ res ; } 
public function getCSVFromResult ( ResultInterface $ query , string $ delim = ',' , string $ newline = "\n" , string $ enclosure = '"' ) { $ out = '' ; 
public function getXMLFromResult ( ResultInterface $ query , array $ params = [ ] ) : string { 
public function backup ( $ params = [ ] ) { 
protected function call ( string $ command , array $ params = [ ] ) { 
protected function showError ( \ Exception $ e ) { CLI :: newLine ( ) ; CLI :: error ( $ e -> getMessage ( ) ) ; CLI :: write ( $ e -> getFile ( ) . ' - ' . $ e -> getLine ( ) ) ; CLI :: newLine ( ) ; } 
public function showHelp ( ) { 
public function getPad ( array $ array , int $ pad ) : int { $ max = 0 ; foreach ( $ array as $ key => $ value ) { $ max = max ( $ max , strlen ( $ key ) ) ; } return $ max + $ pad ; } 
public function call ( string $ class ) { if ( empty ( $ class ) ) { throw new \ InvalidArgumentException ( 'No Seeder was specified.' ) ; } $ path = str_replace ( '.php' , '' , $ class ) . '.php' ; 
public function differs ( string $ str = null , string $ field , array $ data ) : bool { return array_key_exists ( $ field , $ data ) ? ( $ str !== $ data [ $ field ] ) : false ; } 
public function exact_length ( string $ str = null , string $ val , array $ data ) : bool { $ val = explode ( ',' , $ val ) ; foreach ( $ val as $ tmp ) { if ( is_numeric ( $ tmp ) && ( int ) $ tmp === mb_strlen ( $ str ) ) { return true ; } } return false ; } 
public function greater_than ( string $ str = null , string $ min , array $ data ) : bool { return is_numeric ( $ str ) ? ( $ str > $ min ) : false ; } 
public function in_list ( string $ value = null , string $ list , array $ data ) : bool { $ list = explode ( ',' , $ list ) ; $ list = array_map ( function ( $ value ) { return trim ( $ value ) ; } , $ list ) ; return in_array ( $ value , $ list , true ) ; } 
public function is_unique ( string $ str = null , string $ field , array $ data ) : bool { 
public function less_than ( string $ str = null , string $ max ) : bool { return is_numeric ( $ str ) ? ( $ str < $ max ) : false ; } 
public function less_than_equal_to ( string $ str = null , string $ max ) : bool { return is_numeric ( $ str ) ? ( $ str <= $ max ) : false ; } 
public function max_length ( string $ str = null , string $ val , array $ data ) : bool { return ( $ val >= mb_strlen ( $ str ) ) ; } 
public function min_length ( string $ str = null , string $ val , array $ data ) : bool { return ( $ val <= mb_strlen ( $ str ) ) ; } 
public function required ( $ str = null ) : bool { if ( is_object ( $ str ) ) { return true ; } return is_array ( $ str ) ? ! empty ( $ str ) : ( trim ( $ str ) !== '' ) ; } 
public function required_with ( $ str = null , string $ fields , array $ data ) : bool { $ fields = explode ( ',' , $ fields ) ; 
public function required_without ( $ str = null , string $ fields , array $ data ) : bool { $ fields = explode ( ',' , $ fields ) ; 
public function getFieldNames ( ) : array { $ fieldNames = [ ] ; for ( $ i = 0 , $ c = $ this -> getFieldCount ( ) ; $ i < $ c ; $ i ++ ) { $ fieldNames [ ] = pg_field_name ( $ this -> resultID , $ i ) ; } return $ fieldNames ; } 
public function getFieldData ( ) : array { $ retVal = [ ] ; for ( $ i = 0 , $ c = $ this -> getFieldCount ( ) ; $ i < $ c ; $ i ++ ) { $ retVal [ $ i ] = new \ stdClass ( ) ; $ retVal [ $ i ] -> name = pg_field_name ( $ this -> resultID , $ i ) ; $ retVal [ $ i ] -> type = pg_field_type ( $ this -> resultID , $ i ) ; $ retVal [ $ i ] -> max_length = pg_field_size ( $ this -> resultID , $ i ) ; 
public function freeResult ( ) { if ( is_resource ( $ this -> resultID ) ) { pg_free_result ( $ this -> resultID ) ; $ this -> resultID = false ; } } 
public function handle ( string $ uri = null ) { $ this -> translateURIDashes = $ this -> collection -> shouldTranslateURIDashes ( ) ; 
public function get404Override ( ) { $ route = $ this -> collection -> get404Override ( ) ; if ( is_string ( $ route ) ) { $ routeArray = explode ( '::' , $ route ) ; return [ $ routeArray [ 0 ] , 
protected function checkRoutes ( string $ uri ) : bool { $ routes = $ this -> collection -> getRoutes ( $ this -> collection -> getHTTPVerb ( ) ) ; $ uri = $ uri === '/' ? $ uri : ltrim ( $ uri , '/ ' ) ; 
public function autoRoute ( string $ uri ) { $ segments = explode ( '/' , $ uri ) ; $ segments = $ this -> validateRequest ( $ segments ) ; 
protected function validateRequest ( array $ segments ) : array { $ segments = array_filter ( $ segments ) ; $ segments = array_values ( $ segments ) ; $ c = count ( $ segments ) ; $ directory_override = isset ( $ this -> directory ) ; 
protected function setDirectory ( string $ dir = null , bool $ append = false ) { $ dir = ucfirst ( $ dir ) ; if ( $ append !== true || empty ( $ this -> directory ) ) { $ this -> directory = str_replace ( '.' , '' , trim ( $ dir , '/' ) ) . '/' ; } else { $ this -> directory .= str_replace ( '.' , '' , trim ( $ dir , '/' ) ) . '/' ; } } 
protected function setRequest ( array $ segments = [ ] ) { 
protected function setDefaultController ( ) { if ( empty ( $ this -> controller ) ) { throw RouterException :: forMissingDefaultRoute ( ) ; } 
public function orderBy ( string $ orderBy , string $ direction = '' , bool $ escape = null ) { $ direction = strtoupper ( trim ( $ direction ) ) ; if ( $ direction === 'RANDOM' ) { if ( ! is_float ( $ orderBy ) && ctype_digit ( ( string ) $ orderBy ) ) { $ orderBy = ( float ) ( $ orderBy > 1 ? "0.{$orderBy}" : $ orderBy ) ; } if ( is_float ( $ orderBy ) ) { $ this -> db -> simpleQuery ( "SET SEED {$orderBy}" ) ; } $ orderBy = $ this -> randomKeyword [ 0 ] ; $ direction = '' ; $ escape = false ; } return parent :: orderBy ( $ orderBy , $ direction , $ escape ) ; } 
public function replace ( array $ set = null , bool $ returnSQL = false ) { if ( $ set !== null ) { $ this -> set ( $ set ) ; } if ( ! $ this -> QBSet ) { if ( CI_DEBUG ) { throw new DatabaseException ( 'You must use the "set" method to update an entry.' ) ; } return false ; } $ table = $ this -> QBFrom [ 0 ] ; $ set = $ this -> binds ; 
public function delete ( $ where = '' , int $ limit = null , bool $ reset_data = true , bool $ returnSQL = false ) { if ( ! empty ( $ limit ) || ! empty ( $ this -> QBLimit ) ) { throw new DatabaseException ( 'PostgreSQL does not allow LIMITs on DELETE queries.' ) ; } return parent :: delete ( $ where , $ limit , $ reset_data , $ returnSQL ) ; } 
protected function _update ( string $ table , array $ values ) : string { if ( ! empty ( $ this -> QBLimit ) ) { throw new DatabaseException ( 'Postgres does not support LIMITs with UPDATE queries.' ) ; } $ this -> QBOrderBy = [ ] ; return parent :: _update ( $ table , $ values ) ; } 
protected function _delete ( string $ table ) : string { $ this -> QBLimit = false ; return parent :: _delete ( $ table ) ; } 
public function getSize ( string $ unit = 'b' ) { if ( is_null ( $ this -> size ) ) { $ this -> size = filesize ( $ this -> getPathname ( ) ) ; } switch ( strtolower ( $ unit ) ) { case 'kb' : return number_format ( $ this -> size / 1024 , 3 ) ; case 'mb' : return number_format ( ( $ this -> size / 1024 ) / 1024 , 3 ) ; } return ( int ) $ this -> size ; } 
public function getMimeType ( ) : string { $ finfo = finfo_open ( FILEINFO_MIME_TYPE ) ; $ mimeType = finfo_file ( $ finfo , $ this -> getRealPath ( ) ) ; finfo_close ( $ finfo ) ; return $ mimeType ; } 
public function move ( string $ targetPath , string $ name = null , bool $ overwrite = false ) { $ targetPath = rtrim ( $ targetPath , '/' ) . '/' ; $ name = $ name ?? $ this -> getBaseName ( ) ; $ destination = $ overwrite ? $ targetPath . $ name : $ this -> getDestination ( $ targetPath . $ name ) ; $ oldName = empty ( $ this -> getRealPath ( ) ) ? $ this -> getPath ( ) : $ this -> getRealPath ( ) ; if ( ! @ rename ( $ oldName , $ destination ) ) { $ error = error_get_last ( ) ; throw FileException :: forUnableToMove ( $ this -> getBasename ( ) , $ targetPath , strip_tags ( $ error [ 'message' ] ) ) ; } @ chmod ( $ targetPath , 0777 & ~ umask ( ) ) ; return new File ( $ destination ) ; } 
public function getDestination ( string $ destination , string $ delimiter = '_' , int $ i = 0 ) : string { while ( is_file ( $ destination ) ) { $ info = pathinfo ( $ destination ) ; if ( strpos ( $ info [ 'filename' ] , $ delimiter ) !== false ) { $ parts = explode ( $ delimiter , $ info [ 'filename' ] ) ; if ( is_numeric ( end ( $ parts ) ) ) { $ i = end ( $ parts ) ; array_pop ( $ parts ) ; array_push ( $ parts , ++ $ i ) ; $ destination = $ info [ 'dirname' ] . '/' . implode ( $ delimiter , $ parts ) . '.' . $ info [ 'extension' ] ; } else { $ destination = $ info [ 'dirname' ] . '/' . $ info [ 'filename' ] . $ delimiter . ++ $ i . '.' . $ info [ 'extension' ] ; } } else { $ destination = $ info [ 'dirname' ] . '/' . $ info [ 'filename' ] . $ delimiter . ++ $ i . '.' . $ info [ 'extension' ] ; } } return $ destination ; } 
public static function collect ( Query $ query ) { $ config = config ( 'Toolbar' ) ; 
protected function formatTimelineData ( ) : array { $ data = [ ] ; foreach ( $ this -> connections as $ alias => $ connection ) { 
public function display ( ) : array { 
public function locateFile ( string $ file , string $ folder = null , string $ ext = 'php' ) { $ file = $ this -> ensureExt ( $ file , $ ext ) ; 
public function getClassname ( string $ file ) : string { $ php = file_get_contents ( $ file ) ; $ tokens = token_get_all ( $ php ) ; $ count = count ( $ tokens ) ; $ dlm = false ; $ namespace = '' ; $ class_name = '' ; for ( $ i = 2 ; $ i < $ count ; $ i ++ ) { if ( ( isset ( $ tokens [ $ i - 2 ] [ 1 ] ) && ( $ tokens [ $ i - 2 ] [ 1 ] === 'phpnamespace' || $ tokens [ $ i - 2 ] [ 1 ] === 'namespace' ) ) || ( $ dlm && $ tokens [ $ i - 1 ] [ 0 ] === T_NS_SEPARATOR && $ tokens [ $ i ] [ 0 ] === T_STRING ) ) { if ( ! $ dlm ) { $ namespace = 0 ; } if ( isset ( $ tokens [ $ i ] [ 1 ] ) ) { $ namespace = $ namespace ? $ namespace . '\\' . $ tokens [ $ i ] [ 1 ] : $ tokens [ $ i ] [ 1 ] ; $ dlm = true ; } } elseif ( $ dlm && ( $ tokens [ $ i ] [ 0 ] !== T_NS_SEPARATOR ) && ( $ tokens [ $ i ] [ 0 ] !== T_STRING ) ) { $ dlm = false ; } if ( ( $ tokens [ $ i - 2 ] [ 0 ] === T_CLASS || ( isset ( $ tokens [ $ i - 2 ] [ 1 ] ) && $ tokens [ $ i - 2 ] [ 1 ] === 'phpclass' ) ) && $ tokens [ $ i - 1 ] [ 0 ] === T_WHITESPACE && $ tokens [ $ i ] [ 0 ] === T_STRING ) { $ class_name = $ tokens [ $ i ] [ 1 ] ; break ; } } if ( empty ( $ class_name ) ) { return '' ; } return $ namespace . '\\' . $ class_name ; } 
public function search ( string $ path , string $ ext = 'php' ) : array { $ path = $ this -> ensureExt ( $ path , $ ext ) ; $ foundPaths = [ ] ; foreach ( $ this -> getNamespaces ( ) as $ namespace ) { if ( is_file ( $ namespace [ 'path' ] . $ path ) ) { $ foundPaths [ ] = $ namespace [ 'path' ] . $ path ; } } 
protected function ensureExt ( string $ path , string $ ext ) : string { if ( $ ext ) { $ ext = '.' . $ ext ; if ( substr ( $ path , - strlen ( $ ext ) ) !== $ ext ) { $ path .= $ ext ; } } return $ path ; } 
protected function getNamespaces ( string $ prefix = null ) { if ( $ prefix ) { $ path = $ this -> autoloader -> getNamespace ( $ prefix ) ; return isset ( $ path [ 0 ] ) ? rtrim ( $ path [ 0 ] , DIRECTORY_SEPARATOR ) . DIRECTORY_SEPARATOR : '' ; } $ namespaces = [ ] ; foreach ( $ this -> autoloader -> getNamespace ( ) as $ prefix => $ paths ) { foreach ( $ paths as $ path ) { $ namespaces [ ] = [ 'prefix' => $ prefix , 'path' => rtrim ( $ path , DIRECTORY_SEPARATOR ) . DIRECTORY_SEPARATOR , ] ; } } return $ namespaces ; } 
public function findQualifiedNameFromPath ( string $ path ) { $ path = realpath ( $ path ) ; if ( ! $ path ) { return false ; } foreach ( $ this -> getNamespaces ( ) as $ namespace ) { $ namespace [ 'path' ] = realpath ( $ namespace [ 'path' ] ) ; if ( empty ( $ namespace [ 'path' ] ) ) { continue ; } if ( mb_strpos ( $ path , $ namespace [ 'path' ] ) === 0 ) { $ className = '\\' . $ namespace [ 'prefix' ] . '\\' . ltrim ( str_replace ( '/' , '\\' , mb_substr ( $ path , mb_strlen ( $ namespace [ 'path' ] ) ) ) , '\\' ) ; 
public function listFiles ( string $ path ) : array { if ( empty ( $ path ) ) { return [ ] ; } $ files = [ ] ; helper ( 'filesystem' ) ; foreach ( $ this -> getNamespaces ( ) as $ namespace ) { $ fullPath = realpath ( $ namespace [ 'path' ] . $ path ) ; if ( ! is_dir ( $ fullPath ) ) { continue ; } $ tempFiles = get_filenames ( $ fullPath , true ) ; if ( ! empty ( $ tempFiles ) ) { $ files = array_merge ( $ files , $ tempFiles ) ; } } return $ files ; } 
public function listNamespaceFiles ( string $ prefix , string $ path ) : array { if ( empty ( $ path ) || empty ( $ prefix ) ) { return [ ] ; } $ files = [ ] ; helper ( 'filesystem' ) ; 
protected function legacyLocate ( string $ file , string $ folder = null ) { $ paths = [ APPPATH , SYSTEMPATH , ] ; foreach ( $ paths as $ path ) { $ path .= empty ( $ folder ) ? $ file : $ folder . '/' . $ file ; if ( is_file ( $ path ) ) { return $ path ; } } return false ; } 
public function render ( string $ view , array $ options = null , bool $ saveData = null ) : string { $ this -> renderVars [ 'start' ] = microtime ( true ) ; 
public function renderString ( string $ view , array $ options = null , bool $ saveData = null ) : string { $ start = microtime ( true ) ; if ( is_null ( $ saveData ) ) { $ saveData = $ this -> config -> saveData ; } extract ( $ this -> data ) ; if ( ! $ saveData ) { $ this -> data = [ ] ; } ob_start ( ) ; $ incoming = '?>' . $ view ; eval ( $ incoming ) ; $ output = ob_get_contents ( ) ; @ ob_end_clean ( ) ; $ this -> logPerformance ( $ start , microtime ( true ) , $ this -> excerpt ( $ view ) ) ; return $ output ; } 
public function excerpt ( string $ string , int $ length = 20 ) : string { return ( strlen ( $ string ) > $ length ) ? substr ( $ string , 0 , $ length - 3 ) . '...' : $ string ; } 
public function setData ( array $ data = [ ] , string $ context = null ) : RendererInterface { if ( ! empty ( $ context ) ) { $ data = \ esc ( $ data , $ context ) ; } $ this -> data = array_merge ( $ this -> data , $ data ) ; return $ this ; } 
public function setVar ( string $ name , $ value = null , string $ context = null ) : RendererInterface { if ( ! empty ( $ context ) ) { $ value = \ esc ( $ value , $ context ) ; } $ this -> data [ $ name ] = $ value ; return $ this ; } 
public function renderSection ( string $ sectionName ) { if ( ! isset ( $ this -> sections [ $ sectionName ] ) ) { echo '' ; return ; } foreach ( $ this -> sections [ $ sectionName ] as $ contents ) { echo $ contents ; } } 
public function include ( string $ view , array $ options = null , $ saveData = null ) : string { return $ this -> render ( $ view , $ options , $ saveData ) ; } 
protected function logPerformance ( float $ start , float $ end , string $ view ) { if ( ! $ this -> debug ) { return ; } $ this -> performanceData [ ] = [ 'start' => $ start , 'end' => $ end , 'view' => $ view , ] ; } 
public function withFile ( string $ path ) { 
protected function ensureResource ( ) { if ( $ this -> resource === null ) { $ path = $ this -> image -> getPathname ( ) ; 
public function resize ( int $ width , int $ height , bool $ maintainRatio = false , string $ masterDim = 'auto' ) { 
public function crop ( int $ width = null , int $ height = null , int $ x = null , int $ y = null , bool $ maintainRatio = false , string $ masterDim = 'auto' ) { $ this -> width = $ width ; $ this -> height = $ height ; $ this -> xAxis = $ x ; $ this -> yAxis = $ y ; if ( $ maintainRatio ) { $ this -> masterDim = $ masterDim ; $ this -> reproportion ( ) ; } $ result = $ this -> _crop ( ) ; $ this -> xAxis = null ; $ this -> yAxis = null ; return $ result ; } 
public function rotate ( float $ angle ) { 
public function flatten ( int $ red = 255 , int $ green = 255 , int $ blue = 255 ) { $ this -> width = $ this -> image -> origWidth ; $ this -> height = $ this -> image -> origHeight ; return $ this -> _flatten ( ) ; } 
public function flip ( string $ dir = 'vertical' ) { $ dir = strtolower ( $ dir ) ; if ( $ dir !== 'vertical' && $ dir !== 'horizontal' ) { throw ImageException :: forInvalidDirection ( $ dir ) ; } return $ this -> _flip ( $ dir ) ; } 
public function text ( string $ text , array $ options = [ ] ) { $ options = array_merge ( $ this -> textDefaults , $ options ) ; $ options [ 'color' ] = trim ( $ options [ 'color' ] , '# ' ) ; $ options [ 'shadowColor' ] = trim ( $ options [ 'shadowColor' ] , '# ' ) ; $ this -> _text ( $ text , $ options ) ; return $ this ; } 
public function reorient ( bool $ silent = false ) { $ orientation = $ this -> getEXIF ( 'Orientation' , $ silent ) ; switch ( $ orientation ) { case 2 : return $ this -> flip ( 'horizontal' ) ; break ; case 3 : return $ this -> rotate ( 180 ) ; break ; case 4 : return $ this -> rotate ( 180 ) -> flip ( 'horizontal' ) ; break ; case 5 : return $ this -> rotate ( 270 ) -> flip ( 'horizontal' ) ; break ; case 6 : return $ this -> rotate ( 270 ) ; break ; case 7 : return $ this -> rotate ( 90 ) -> flip ( 'horizontal' ) ; break ; case 8 : return $ this -> rotate ( 90 ) ; break ; default : return $ this ; } } 
public function getEXIF ( string $ key = null , bool $ silent = false ) { if ( ! function_exists ( 'exif_read_data' ) ) { if ( $ silent ) { return null ; } } $ exif = exif_read_data ( $ this -> image -> getPathname ( ) ) ; if ( ! is_null ( $ key ) && is_array ( $ exif ) ) { $ exif = $ exif [ $ key ] ?? false ; } return $ exif ; } 
public function fit ( int $ width , int $ height = null , string $ position = 'center' ) { $ origWidth = $ this -> image -> origWidth ; $ origHeight = $ this -> image -> origHeight ; list ( $ cropWidth , $ cropHeight ) = $ this -> calcAspectRatio ( $ width , $ height , $ origWidth , $ origHeight ) ; if ( is_null ( $ height ) ) { $ height = ceil ( ( $ width / $ cropWidth ) * $ cropHeight ) ; } list ( $ x , $ y ) = $ this -> calcCropCoords ( $ width , $ height , $ origWidth , $ origHeight , $ position ) ; return $ this -> crop ( $ cropWidth , $ cropHeight , $ x , $ y ) -> resize ( $ width , $ height ) ; } 
protected function calcCropCoords ( $ width , $ height , $ origWidth , $ origHeight , $ position ) : array { $ position = strtolower ( $ position ) ; $ x = $ y = 0 ; switch ( $ position ) { case 'top-left' : $ x = 0 ; $ y = 0 ; break ; case 'top' : $ x = floor ( ( $ origWidth - $ width ) / 2 ) ; $ y = 0 ; break ; case 'top-right' : $ x = $ origWidth - $ width ; $ y = 0 ; break ; case 'left' : $ x = 0 ; $ y = floor ( ( $ origHeight - $ height ) / 2 ) ; break ; case 'center' : $ x = floor ( ( $ origWidth - $ width ) / 2 ) ; $ y = floor ( ( $ origHeight - $ height ) / 2 ) ; break ; case 'right' : $ x = ( $ origWidth - $ width ) ; $ y = floor ( ( $ origHeight - $ height ) / 2 ) ; break ; case 'bottom-left' : $ x = 0 ; $ y = $ origHeight - $ height ; break ; case 'bottom' : $ x = floor ( ( $ origWidth - $ width ) / 2 ) ; $ y = $ origHeight - $ height ; break ; case 'bottom-right' : $ x = ( $ origWidth - $ width ) ; $ y = $ origHeight - $ height ; break ; } return [ $ x , $ y , ] ; } 
protected function reproportion ( ) { if ( ( $ this -> width === 0 && $ this -> height === 0 ) || $ this -> image -> origWidth === 0 || $ this -> image -> origHeight === 0 || ( ! ctype_digit ( ( string ) $ this -> width ) && ! ctype_digit ( ( string ) $ this -> height ) ) || ! ctype_digit ( ( string ) $ this -> image -> origWidth ) || ! ctype_digit ( ( string ) $ this -> image -> origHeight ) ) { return ; } 
public function get ( string $ key ) { $ key = $ this -> prefix . $ key ; $ success = false ; $ data = wincache_ucache_get ( $ key , $ success ) ; 
public function save ( string $ key , $ value , int $ ttl = 60 ) { $ key = $ this -> prefix . $ key ; return wincache_ucache_set ( $ key , $ value , $ ttl ) ; } 
public function increment ( string $ key , int $ offset = 1 ) { $ key = $ this -> prefix . $ key ; $ success = false ; $ value = wincache_ucache_inc ( $ key , $ offset , $ success ) ; return ( $ success === true ) ? $ value : false ; } 
public function decrement ( string $ key , int $ offset = 1 ) { $ key = $ this -> prefix . $ key ; $ success = false ; $ value = wincache_ucache_dec ( $ key , $ offset , $ success ) ; return ( $ success === true ) ? $ value : false ; } 
public function getMetaData ( string $ key ) { $ key = $ this -> prefix . $ key ; if ( $ stored = wincache_ucache_info ( false , $ key ) ) { $ age = $ stored [ 'ucache_entries' ] [ 1 ] [ 'age_seconds' ] ; $ ttl = $ stored [ 'ucache_entries' ] [ 1 ] [ 'ttl_seconds' ] ; $ hitcount = $ stored [ 'ucache_entries' ] [ 1 ] [ 'hitcount' ] ; return [ 'expire' => $ ttl - $ age , 'hitcount' => $ hitcount , 'age' => $ age , 'ttl' => $ ttl , ] ; } return false ; } 
public function run ( array $ params ) { 
public function render ( string $ view , array $ options = null , bool $ saveData = null ) : string { $ start = microtime ( true ) ; if ( is_null ( $ saveData ) ) { $ saveData = $ this -> config -> saveData ; } $ view = str_replace ( '.php' , '' , $ view ) ; 
public function renderString ( string $ template , array $ options = null , bool $ saveData = null ) : string { $ start = microtime ( true ) ; if ( is_null ( $ saveData ) ) { $ saveData = $ this -> config -> saveData ; } $ output = $ this -> parse ( $ template , $ this -> data , $ options ) ; $ this -> logPerformance ( $ start , microtime ( true ) , $ this -> excerpt ( $ template ) ) ; if ( ! $ saveData ) { $ this -> data = [ ] ; } return $ output ; } 
public function setData ( array $ data = [ ] , string $ context = null ) : RendererInterface { if ( ! empty ( $ context ) ) { foreach ( $ data as $ key => & $ value ) { if ( is_array ( $ value ) ) { foreach ( $ value as & $ obj ) { $ obj = $ this -> objectToArray ( $ obj ) ; } } else { $ value = $ this -> objectToArray ( $ value ) ; } $ this -> dataContexts [ $ key ] = $ context ; } } $ this -> data = array_merge ( $ this -> data , $ data ) ; return $ this ; } 
protected function parse ( string $ template , array $ data = [ ] , array $ options = null ) : string { if ( $ template === '' ) { return '' ; } 
protected function parseSingle ( string $ key , string $ val ) : array { $ pattern = '#' . $ this -> leftDelimiter . '!?\s*' . preg_quote ( $ key ) . '\s*\|*\s*([|a-zA-Z0-9<>=\(\),:_\-\s\+]+)*\s*!?' . $ this -> rightDelimiter . '#ms' ; return [ $ pattern => $ val ] ; } 
protected function parsePair ( string $ variable , array $ data , string $ template ) : array { * Each match looks like: * * $match[0] {tag}...{/tag} * $match[1] Contents inside the tag */ foreach ( $ matches as $ match ) { 
protected function extractNoparse ( string $ template ) : string { $ pattern = '/\{\s*noparse\s*\}(.*?)\{\s*\/noparse\s*\}/ms' ; if ( preg_match_all ( $ pattern , $ template , $ matches , PREG_SET_ORDER ) ) { foreach ( $ matches as $ match ) { 
public function insertNoparse ( string $ template ) : string { foreach ( $ this -> noparseBlocks as $ hash => $ replace ) { $ template = str_replace ( "noparse_{$hash}" , $ replace , $ template ) ; unset ( $ this -> noparseBlocks [ $ hash ] ) ; } return $ template ; } 
protected function parseConditionals ( string $ template ) : string { $ pattern = '/\{\s*(if|elseif)\s*((?:\()?(.*?)(?:\))?)\s*\}/ms' ; preg_match_all ( $ pattern , $ template , $ matches , PREG_SET_ORDER ) ; foreach ( $ matches as $ match ) { 
public function setDelimiters ( $ leftDelimiter = '{' , $ rightDelimiter = '}' ) : RendererInterface { $ this -> leftDelimiter = $ leftDelimiter ; $ this -> rightDelimiter = $ rightDelimiter ; return $ this ; } 
protected function replaceSingle ( $ pattern , $ content , $ template , bool $ escape = false ) : string { 
protected function prepareReplacement ( array $ matches , string $ replace , bool $ escape = true ) : string { $ orig = array_shift ( $ matches ) ; 
public function shouldAddEscaping ( string $ key ) { $ escape = false ; $ key = trim ( str_replace ( [ '{' , '}' ] , '' , $ key ) ) ; 
protected function applyFilters ( string $ replace , array $ filters ) : string { 
protected function parsePlugins ( string $ template ) { foreach ( $ this -> plugins as $ plugin => $ callable ) { * Match tag pairs * * Each match is an array: * $matches[0] = entire matched string * $matches[1] = all parameters string in opening tag * $matches[2] = content between the tags to send to the plugin. */ preg_match_all ( $ pattern , $ template , $ matches , PREG_SET_ORDER ) ; if ( empty ( $ matches ) ) { continue ; } foreach ( $ matches as $ match ) { $ params = [ ] ; 
public function addPlugin ( string $ alias , callable $ callback , bool $ isPair = false ) { $ this -> plugins [ $ alias ] = $ isPair ? [ $ callback ] : $ callback ; return $ this ; } 
protected function objectToArray ( $ value ) { 
protected function _rotate ( int $ angle ) : bool { 
public function _flatten ( int $ red = 255 , int $ green = 255 , int $ blue = 255 ) { $ srcImg = $ this -> createImage ( ) ; if ( function_exists ( 'imagecreatetruecolor' ) ) { $ create = 'imagecreatetruecolor' ; $ copy = 'imagecopyresampled' ; } else { $ create = 'imagecreate' ; $ copy = 'imagecopyresized' ; } $ dest = $ create ( $ this -> width , $ this -> height ) ; $ matte = imagecolorallocate ( $ dest , $ red , $ green , $ blue ) ; imagefilledrectangle ( $ dest , 0 , 0 , $ this -> width , $ this -> height , $ matte ) ; imagecopy ( $ dest , $ srcImg , 0 , 0 , 0 , 0 , $ this -> width , $ this -> height ) ; 
public function _flip ( string $ direction ) { $ srcImg = $ this -> createImage ( ) ; $ width = $ this -> image -> origWidth ; $ height = $ this -> image -> origHeight ; if ( $ direction === 'horizontal' ) { for ( $ i = 0 ; $ i < $ height ; $ i ++ ) { $ left = 0 ; $ right = $ width - 1 ; while ( $ left < $ right ) { $ cl = imagecolorat ( $ srcImg , $ left , $ i ) ; $ cr = imagecolorat ( $ srcImg , $ right , $ i ) ; imagesetpixel ( $ srcImg , $ left , $ i , $ cr ) ; imagesetpixel ( $ srcImg , $ right , $ i , $ cl ) ; $ left ++ ; $ right -- ; } } } else { for ( $ i = 0 ; $ i < $ width ; $ i ++ ) { $ top = 0 ; $ bottom = $ height - 1 ; while ( $ top < $ bottom ) { $ ct = imagecolorat ( $ srcImg , $ i , $ top ) ; $ cb = imagecolorat ( $ srcImg , $ i , $ bottom ) ; imagesetpixel ( $ srcImg , $ i , $ top , $ cb ) ; imagesetpixel ( $ srcImg , $ i , $ bottom , $ ct ) ; $ top ++ ; $ bottom -- ; } } } $ this -> resource = $ srcImg ; return $ this ; } 
protected function process ( string $ action ) { $ origWidth = $ this -> image -> origWidth ; $ origHeight = $ this -> image -> origHeight ; if ( $ action === 'crop' ) { 
public function save ( string $ target = null , int $ quality = 90 ) : bool { $ target = empty ( $ target ) ? $ this -> image -> getPathname ( ) : $ target ; switch ( $ this -> image -> imageType ) { case IMAGETYPE_GIF : if ( ! function_exists ( 'imagegif' ) ) { throw ImageException :: forInvalidImageCreate ( lang ( 'images.gifNotSupported' ) ) ; } if ( ! @ imagegif ( $ this -> resource , $ target ) ) { throw ImageException :: forSaveFailed ( ) ; } break ; case IMAGETYPE_JPEG : if ( ! function_exists ( 'imagejpeg' ) ) { throw ImageException :: forInvalidImageCreate ( lang ( 'images.jpgNotSupported' ) ) ; } if ( ! @ imagejpeg ( $ this -> resource , $ target , $ quality ) ) { throw ImageException :: forSaveFailed ( ) ; } break ; case IMAGETYPE_PNG : if ( ! function_exists ( 'imagepng' ) ) { throw ImageException :: forInvalidImageCreate ( lang ( 'images.pngNotSupported' ) ) ; } if ( ! @ imagepng ( $ this -> resource , $ target ) ) { throw ImageException :: forSaveFailed ( ) ; } break ; default : throw ImageException :: forInvalidImageCreate ( ) ; break ; } imagedestroy ( $ this -> resource ) ; chmod ( $ target , $ this -> filePermissions ) ; return true ; } 
protected function createImage ( string $ path = '' , string $ imageType = '' ) { if ( $ this -> resource !== null ) { return $ this -> resource ; } if ( $ path === '' ) { $ path = $ this -> image -> getPathname ( ) ; } if ( $ imageType === '' ) { $ imageType = $ this -> image -> imageType ; } switch ( $ imageType ) { case IMAGETYPE_GIF : if ( ! function_exists ( 'imagecreatefromgif' ) ) { throw ImageException :: forInvalidImageCreate ( lang ( 'images.gifNotSupported' ) ) ; } return imagecreatefromgif ( $ path ) ; case IMAGETYPE_JPEG : if ( ! function_exists ( 'imagecreatefromjpeg' ) ) { throw ImageException :: forInvalidImageCreate ( lang ( 'images.jpgNotSupported' ) ) ; } return imagecreatefromjpeg ( $ path ) ; case IMAGETYPE_PNG : if ( ! function_exists ( 'imagecreatefrompng' ) ) { throw ImageException :: forInvalidImageCreate ( lang ( 'images.pngNotSupported' ) ) ; } return imagecreatefrompng ( $ path ) ; default : throw ImageException :: forInvalidImageCreate ( 'Ima' ) ; } } 
protected function _text ( string $ text , array $ options = [ ] ) { 
protected function textOverlay ( string $ text , array $ options = [ ] , bool $ isShadow = false ) { $ src = $ this -> createImage ( ) ; $ opacity = ( $ options [ 'opacity' ] * 127 ) ; 
public function initController ( \ CodeIgniter \ HTTP \ RequestInterface $ request , \ CodeIgniter \ HTTP \ ResponseInterface $ response , \ Psr \ Log \ LoggerInterface $ logger ) { 
public function populateHeaders ( ) { $ contentType = $ _SERVER [ 'CONTENT_TYPE' ] ?? getenv ( 'CONTENT_TYPE' ) ; if ( ! empty ( $ contentType ) ) { $ this -> setHeader ( 'Content-Type' , $ contentType ) ; } unset ( $ contentType ) ; foreach ( $ _SERVER as $ key => $ val ) { if ( sscanf ( $ key , 'HTTP_%s' , $ header ) === 1 ) { 
public function getHeader ( string $ name ) { $ orig_name = $ this -> getHeaderName ( $ name ) ; if ( ! isset ( $ this -> headers [ $ orig_name ] ) ) { return null ; } return $ this -> headers [ $ orig_name ] ; } 
public function hasHeader ( string $ name ) : bool { $ orig_name = $ this -> getHeaderName ( $ name ) ; return isset ( $ this -> headers [ $ orig_name ] ) ; } 
public function getHeaderLine ( string $ name ) : string { $ orig_name = $ this -> getHeaderName ( $ name ) ; if ( ! array_key_exists ( $ orig_name , $ this -> headers ) ) { return '' ; } return $ this -> headers [ $ orig_name ] -> getValueLine ( ) ; } 
public function setHeader ( string $ name , $ value ) { if ( ! isset ( $ this -> headers [ $ name ] ) ) { $ this -> headers [ $ name ] = new Header ( $ name , $ value ) ; $ this -> headerMap [ strtolower ( $ name ) ] = $ name ; return $ this ; } if ( ! is_array ( $ this -> headers [ $ name ] ) ) { $ this -> headers [ $ name ] = [ $ this -> headers [ $ name ] ] ; } if ( isset ( $ this -> headers [ $ name ] ) ) { $ this -> headers [ $ name ] = new Header ( $ name , $ value ) ; } return $ this ; } 
public function removeHeader ( string $ name ) { $ orig_name = $ this -> getHeaderName ( $ name ) ; unset ( $ this -> headers [ $ orig_name ] ) ; unset ( $ this -> headerMap [ strtolower ( $ name ) ] ) ; return $ this ; } 
public function appendHeader ( string $ name , string $ value ) { $ orig_name = $ this -> getHeaderName ( $ name ) ; $ this -> headers [ $ orig_name ] -> appendValue ( $ value ) ; return $ this ; } 
public function prependHeader ( string $ name , string $ value ) { $ orig_name = $ this -> getHeaderName ( $ name ) ; $ this -> headers [ $ orig_name ] -> prependValue ( $ value ) ; return $ this ; } 
public function setProtocolVersion ( string $ version ) { if ( ! is_numeric ( $ version ) ) { $ version = substr ( $ version , strpos ( $ version , '/' ) + 1 ) ; } if ( ! in_array ( $ version , $ this -> validProtocolVersions ) ) { throw HTTPException :: forInvalidHTTPProtocol ( implode ( ', ' , $ this -> validProtocolVersions ) ) ; } $ this -> protocolVersion = $ version ; return $ this ; } 
protected function getHeaderName ( string $ name ) : string { $ lower_name = strtolower ( $ name ) ; return $ this -> headerMap [ $ lower_name ] ?? $ name ; } 
public function prepare ( string $ sql , array $ options = [ ] , string $ queryClass = 'CodeIgniter\\Database\\Query' ) { * @var \CodeIgniter\Database\Query $query */ $ query = new $ queryClass ( $ this -> db ) ; $ query -> setQuery ( $ sql ) ; if ( ! empty ( $ this -> db -> swapPre ) && ! empty ( $ this -> db -> DBPrefix ) ) { $ query -> swapPrefix ( $ this -> db -> DBPrefix , $ this -> db -> swapPre ) ; } $ this -> query = $ query ; return $ this -> _prepare ( $ query -> getOriginalQuery ( ) , $ options ) ; } 
public function execute ( ... $ data ) { 
public static function mailto ( array $ params = [ ] ) : string { $ email = $ params [ 'email' ] ?? '' ; $ title = $ params [ 'title' ] ?? '' ; $ attrs = $ params [ 'attributes' ] ?? '' ; return mailto ( $ email , $ title , $ attrs ) ; } 
public static function safeMailto ( array $ params = [ ] ) : string { $ email = $ params [ 'email' ] ?? '' ; $ title = $ params [ 'title' ] ?? '' ; $ attrs = $ params [ 'attributes' ] ?? '' ; return safe_mailto ( $ email , $ title , $ attrs ) ; } 
public static function ValidationErrors ( array $ params = [ ] ) : string { $ validator = \ Config \ Services :: validation ( ) ; if ( empty ( $ params ) ) { return $ validator -> listErrors ( ) ; } return $ validator -> showError ( $ params [ 'field' ] ) ; } 
public function run ( array $ params ) { $ command = array_shift ( $ params ) ; if ( is_null ( $ command ) ) { $ command = 'help' ; } $ commands = $ this -> commands -> getCommands ( ) ; $ class = new $ commands [ $ command ] [ 'class' ] ( $ this -> logger , $ this -> commands ) ; $ class -> showHelp ( ) ; } 
public function open ( $ savePath , $ name ) : bool { if ( ! is_dir ( $ savePath ) ) { if ( ! mkdir ( $ savePath , 0700 , true ) ) { throw SessionException :: forInvalidSavePath ( $ this -> savePath ) ; } } elseif ( ! is_writable ( $ savePath ) ) { throw SessionException :: forWriteProtectedSavePath ( $ this -> savePath ) ; } $ this -> savePath = $ savePath ; $ this -> filePath = $ this -> savePath . '/' . $ name 
public function read ( $ sessionID ) : string { 
public function write ( $ sessionID , $ sessionData ) : bool { 
public function close ( ) : bool { if ( is_resource ( $ this -> fileHandle ) ) { flock ( $ this -> fileHandle , LOCK_UN ) ; fclose ( $ this -> fileHandle ) ; $ this -> fileHandle = $ this -> fileNew = $ this -> sessionID = null ; return true ; } return true ; } 
public function destroy ( $ session_id ) : bool { if ( $ this -> close ( ) ) { return is_file ( $ this -> filePath . $ session_id ) ? ( unlink ( $ this -> filePath . $ session_id ) && $ this -> destroyCookie ( ) ) : true ; } elseif ( $ this -> filePath !== null ) { clearstatcache ( ) ; return is_file ( $ this -> filePath . $ session_id ) ? ( unlink ( $ this -> filePath . $ session_id ) && $ this -> destroyCookie ( ) ) : true ; } return false ; } 
public function gc ( $ maxlifetime ) : bool { if ( ! is_dir ( $ this -> savePath ) || ( $ directory = opendir ( $ this -> savePath ) ) === false ) { $ this -> logger -> debug ( "Session: Garbage collector couldn't list files under directory '" . $ this -> savePath . "'." ) ; return false ; } $ ts = time ( ) - $ maxlifetime ; $ pattern = $ this -> matchIP === true ? '[0-9a-f]{32}' : '' ; $ pattern = sprintf ( '#\A%s' . $ pattern . $ this -> sessionIDRegex . '\z#' , preg_quote ( $ this -> cookieName ) ) ; while ( ( $ file = readdir ( $ directory ) ) !== false ) { 
protected function configureSessionIDRegex ( ) { $ bitsPerCharacter = ( int ) ini_get ( 'session.sid_bits_per_character' ) ; $ SIDLength = ( int ) ini_get ( 'session.sid_length' ) ; if ( ( $ bits = $ SIDLength * $ bitsPerCharacter ) < 160 ) { 
public function setStatusCode ( int $ code , string $ reason = '' ) { 
public function getReason ( ) : string { if ( empty ( $ this -> reason ) ) { return ! empty ( $ this -> statusCode ) ? static :: $ statusCodes [ $ this -> statusCode ] : '' ; } return $ this -> reason ; } 
public function setLink ( PagerInterface $ pager ) { $ links = '' ; if ( $ previous = $ pager -> getPreviousPageURI ( ) ) { $ links .= '<' . $ pager -> getPageURI ( $ pager -> getFirstPage ( ) ) . '>; rel="first",' ; $ links .= '<' . $ previous . '>; rel="prev"' ; } if ( ( $ next = $ pager -> getNextPageURI ( ) ) && $ previous ) { $ links .= ',' ; } if ( $ next ) { $ links .= '<' . $ next . '>; rel="next",' ; $ links .= '<' . $ pager -> getPageURI ( $ pager -> getLastPage ( ) ) . '>; rel="last"' ; } $ this -> setHeader ( 'Link' , $ links ) ; return $ this ; } 
public function setContentType ( string $ mime , string $ charset = 'UTF-8' ) { 
public function getJSON ( ) { $ body = $ this -> body ; if ( $ this -> bodyFormat !== 'json' ) { $ config = config ( Format :: class ) ; $ formatter = $ config -> getFormatter ( 'application/json' ) ; $ body = $ formatter -> format ( $ body ) ; } return $ body ? : null ; } 
public function getXML ( ) { $ body = $ this -> body ; if ( $ this -> bodyFormat !== 'xml' ) { $ config = config ( Format :: class ) ; $ formatter = $ config -> getFormatter ( 'application/xml' ) ; $ body = $ formatter -> format ( $ body ) ; } return $ body ; } 
protected function formatBody ( $ body , string $ format ) { $ mime = "application/{$format}" ; $ this -> setContentType ( $ mime ) ; $ this -> bodyFormat = $ format ; * @var Format $config */ $ config = config ( Format :: class ) ; $ formatter = $ config -> getFormatter ( $ mime ) ; $ body = $ formatter -> format ( $ body ) ; } return $ body ; } 
public function setCache ( array $ options = [ ] ) { if ( empty ( $ options ) ) { return $ this ; } $ this -> removeHeader ( 'Cache-Control' ) ; $ this -> removeHeader ( 'ETag' ) ; 
public function send ( ) { 
public function sendHeaders ( ) { 
public function redirect ( string $ uri , string $ method = 'auto' , int $ code = null ) { 
public function setCookie ( $ name , $ value = '' , $ expire = '' , $ domain = '' , $ path = '/' , $ prefix = '' , $ secure = false , $ httponly = false ) { if ( is_array ( $ name ) ) { 
public function hasCookie ( string $ name , string $ value = null , string $ prefix = '' ) : bool { if ( $ prefix === '' && $ this -> cookiePrefix !== '' ) { $ prefix = $ this -> cookiePrefix ; } $ name = $ prefix . $ name ; foreach ( $ this -> cookies as $ cookie ) { if ( $ cookie [ 'name' ] !== $ name ) { continue ; } if ( $ value === null ) { return true ; } return $ cookie [ 'value' ] === $ value ; } return false ; } 
public function getCookie ( string $ name = null , string $ prefix = '' ) { 
public function deleteCookie ( string $ name = '' , string $ domain = '' , string $ path = '/' , string $ prefix = '' ) { if ( empty ( $ name ) ) { return $ this ; } if ( $ prefix === '' && $ this -> cookiePrefix !== '' ) { $ prefix = $ this -> cookiePrefix ; } $ name = $ prefix . $ name ; foreach ( $ this -> cookies as & $ cookie ) { if ( $ cookie [ 'name' ] === $ name ) { if ( ! empty ( $ domain ) && $ cookie [ 'domain' ] !== $ domain ) { continue ; } if ( ! empty ( $ path ) && $ cookie [ 'path' ] !== $ path ) { continue ; } $ cookie [ 'value' ] = '' ; $ cookie [ 'expires' ] = '' ; break ; } } return $ this ; } 
protected function sendCookies ( ) { if ( $ this -> pretend ) { return ; } foreach ( $ this -> cookies as $ params ) { 
public function download ( string $ filename = '' , $ data = '' , bool $ setMime = false ) { if ( $ filename === '' || $ data === '' ) { return null ; } $ filepath = '' ; if ( $ data === null ) { $ filepath = $ filename ; $ filename = explode ( '/' , str_replace ( DIRECTORY_SEPARATOR , '/' , $ filename ) ) ; $ filename = end ( $ filename ) ; } $ response = new DownloadResponse ( $ filename , $ setMime ) ; if ( $ filepath !== '' ) { $ response -> setFilePath ( $ filepath ) ; } elseif ( $ data !== null ) { $ response -> setBinary ( $ data ) ; } return $ response ; } 
public static function get ( string $ name , bool $ getShared = true ) { $ class = $ name ; if ( ( $ pos = strrpos ( $ name , '\\' ) ) !== false ) { $ class = substr ( $ name , $ pos + 1 ) ; } if ( ! $ getShared ) { return self :: createClass ( $ name ) ; } if ( ! isset ( self :: $ instances [ $ class ] ) ) { self :: $ instances [ $ class ] = self :: createClass ( $ name ) ; } return self :: $ instances [ $ class ] ; } 
private static function createClass ( string $ name ) { if ( class_exists ( $ name ) ) { return new $ name ( ) ; } $ locator = Services :: locator ( ) ; $ file = $ locator -> locateFile ( $ name , 'Config' ) ; if ( empty ( $ file ) ) { return null ; } $ name = $ locator -> getClassname ( $ file ) ; if ( empty ( $ name ) ) { return null ; } return new $ name ( ) ; } 
protected static function getSharedInstance ( string $ key , ... $ params ) { 
public static function autoloader ( bool $ getShared = true ) { if ( $ getShared ) { if ( empty ( static :: $ instances [ 'autoloader' ] ) ) { static :: $ instances [ 'autoloader' ] = new Autoloader ( ) ; } return static :: $ instances [ 'autoloader' ] ; } return new Autoloader ( ) ; } 
public static function locator ( bool $ getShared = true ) { if ( $ getShared ) { if ( empty ( static :: $ instances [ 'locator' ] ) ) { static :: $ instances [ 'locator' ] = new FileLocator ( static :: autoloader ( ) ) ; } return static :: $ instances [ 'locator' ] ; } return new FileLocator ( static :: autoloader ( ) ) ; } 
public static function reset ( bool $ init_autoloader = false ) { static :: $ mocks = [ ] ; static :: $ instances = [ ] ; if ( $ init_autoloader ) { static :: autoloader ( ) -> initialize ( new Autoload ( ) , new Modules ( ) ) ; } } 
public static function injectMock ( string $ name , $ mock ) { $ name = strtolower ( $ name ) ; static :: $ mocks [ $ name ] = $ mock ; } 
protected static function discoverServices ( string $ name , array $ arguments ) { if ( ! static :: $ discovered ) { $ config = config ( 'Modules' ) ; if ( $ config -> shouldDiscover ( 'services' ) ) { $ locator = static :: locator ( ) ; $ files = $ locator -> search ( 'Config/Services' ) ; if ( empty ( $ files ) ) { 
public static function input ( string $ prefix = null ) : string { if ( static :: $ readline_support ) { return readline ( $ prefix ) ; } echo $ prefix ; return fgets ( STDIN ) ; } 
public static function prompt ( string $ field , $ options = null , string $ validation = null ) : string { $ extra_output = '' ; $ default = '' ; if ( is_string ( $ options ) ) { $ extra_output = ' [' . static :: color ( $ options , 'white' ) . ']' ; $ default = $ options ; } if ( is_array ( $ options ) && $ options ) { $ opts = $ options ; $ extra_output_default = static :: color ( $ opts [ 0 ] , 'white' ) ; unset ( $ opts [ 0 ] ) ; if ( empty ( $ opts ) ) { $ extra_output = $ extra_output_default ; } else { $ extra_output = ' [' . $ extra_output_default . ', ' . implode ( ', ' , $ opts ) . ']' ; $ validation .= '|in_list[' . implode ( ',' , $ options ) . ']' ; $ validation = trim ( $ validation , '|' ) ; } $ default = $ options [ 0 ] ; } fwrite ( STDOUT , $ field . $ extra_output . ': ' ) ; 
protected static function validate ( string $ field , string $ value , string $ rules ) : bool { $ validation = \ Config \ Services :: validation ( null , false ) ; $ validation -> setRule ( $ field , null , $ rules ) ; $ validation -> run ( [ $ field => $ value ] ) ; if ( $ validation -> hasError ( $ field ) ) { static :: error ( $ validation -> getError ( $ field ) ) ; return false ; } return true ; } 
public static function print ( string $ text = '' , string $ foreground = null , string $ background = null ) { if ( $ foreground || $ background ) { $ text = static :: color ( $ text , $ foreground , $ background ) ; } static :: $ lastWrite = null ; fwrite ( STDOUT , $ text ) ; } 
public static function error ( string $ text , string $ foreground = 'light_red' , string $ background = null ) { if ( $ foreground || $ background ) { $ text = static :: color ( $ text , $ foreground , $ background ) ; } fwrite ( STDERR , $ text . PHP_EOL ) ; } 
public static function wait ( int $ seconds , bool $ countdown = false ) { if ( $ countdown === true ) { $ time = $ seconds ; while ( $ time > 0 ) { fwrite ( STDOUT , $ time . '... ' ) ; sleep ( 1 ) ; $ time -- ; } static :: write ( ) ; } else { if ( $ seconds > 0 ) { sleep ( $ seconds ) ; } else { 
public static function color ( string $ text , string $ foreground , string $ background = null , string $ format = null ) : string { if ( static :: isWindows ( ) && ! isset ( $ _SERVER [ 'ANSICON' ] ) ) { 
public static function strlen ( ? string $ string ) : int { if ( is_null ( $ string ) ) { return 0 ; } foreach ( static :: $ foreground_colors as $ color ) { $ string = strtr ( $ string , [ "\033[" . $ color . 'm' => '' ] ) ; } foreach ( static :: $ background_colors as $ color ) { $ string = strtr ( $ string , [ "\033[" . $ color . 'm' => '' ] ) ; } $ string = strtr ( $ string , [ "\033[4m" => '' , "\033[0m" => '' ] ) ; return mb_strlen ( $ string ) ; } 
public static function showProgress ( $ thisStep = 1 , int $ totalSteps = 10 ) { static $ inProgress = false ; 
public static function wrap ( string $ string = null , int $ max = 0 , int $ pad_left = 0 ) : string { if ( empty ( $ string ) ) { return '' ; } if ( $ max === 0 ) { $ max = CLI :: getWidth ( ) ; } if ( CLI :: getWidth ( ) < $ max ) { $ max = CLI :: getWidth ( ) ; } $ max = $ max - $ pad_left ; $ lines = wordwrap ( $ string , $ max ) ; if ( $ pad_left > 0 ) { $ lines = explode ( PHP_EOL , $ lines ) ; $ first = true ; array_walk ( $ lines , function ( & $ line , $ index ) use ( $ pad_left , & $ first ) { if ( ! $ first ) { $ line = str_repeat ( ' ' , $ pad_left ) . $ line ; } else { $ first = false ; } } ) ; $ lines = implode ( PHP_EOL , $ lines ) ; } return $ lines ; } 
protected static function parseCommandLine ( ) { $ optionsFound = false ; 
public static function getOption ( string $ name ) { if ( ! array_key_exists ( $ name , static :: $ options ) ) { return null ; } 
public static function getOptionString ( ) : string { if ( empty ( static :: $ options ) ) { return '' ; } $ out = '' ; foreach ( static :: $ options as $ name => $ value ) { 
public static function table ( array $ tbody , array $ thead = [ ] ) { 
public function respond ( $ data = null , int $ status = null , string $ message = '' ) { 
public function fail ( $ messages , int $ status = 400 , string $ code = null , string $ customMessage = '' ) { if ( ! is_array ( $ messages ) ) { $ messages = [ 'error' => $ messages ] ; } $ response = [ 'status' => $ status , 'error' => $ code === null ? $ status : $ code , 'messages' => $ messages , ] ; return $ this -> respond ( $ response , $ status , $ customMessage ) ; } 
public function respondCreated ( $ data = null , string $ message = '' ) { return $ this -> respond ( $ data , $ this -> codes [ 'created' ] , $ message ) ; } 
public function respondDeleted ( $ data = null , string $ message = '' ) { return $ this -> respond ( $ data , $ this -> codes [ 'deleted' ] , $ message ) ; } 
public function failUnauthorized ( string $ description = 'Unauthorized' , string $ code = null , string $ message = '' ) { return $ this -> fail ( $ description , $ this -> codes [ 'unauthorized' ] , $ code , $ message ) ; } 
public function failServerError ( string $ description = 'Internal Server Error' , string $ code = null , string $ message = '' ) : Response { return $ this -> fail ( $ description , $ this -> codes [ 'server_error' ] , $ code , $ message ) ; } 
protected function format ( $ data = null ) { 
public function before ( RequestInterface $ request ) { if ( $ request -> isCLI ( ) ) { return ; } $ security = Services :: security ( ) ; try { $ security -> CSRFVerify ( $ request ) ; } catch ( SecurityException $ e ) { if ( config ( 'App' ) -> CSRFRedirect && ! $ request -> isAJAX ( ) ) { return redirect ( ) -> back ( ) -> with ( 'error' , $ e -> getMessage ( ) ) ; } throw $ e ; } } 
public static function initialize ( ) { 
public static function on ( $ event_name , $ callback , $ priority = EVENT_PRIORITY_NORMAL ) { if ( ! isset ( static :: $ listeners [ $ event_name ] ) ) { static :: $ listeners [ $ event_name ] = [ true , 
public static function trigger ( $ eventName , ... $ arguments ) : bool { 
public static function listeners ( $ event_name ) : array { if ( ! isset ( static :: $ listeners [ $ event_name ] ) ) { return [ ] ; } 
public static function removeListener ( $ event_name , callable $ listener ) : bool { if ( ! isset ( static :: $ listeners [ $ event_name ] ) ) { return false ; } foreach ( static :: $ listeners [ $ event_name ] [ 2 ] as $ index => $ check ) { if ( $ check === $ listener ) { unset ( static :: $ listeners [ $ event_name ] [ 1 ] [ $ index ] ) ; unset ( static :: $ listeners [ $ event_name ] [ 2 ] [ $ index ] ) ; return true ; } } return false ; } 
public function isBrowser ( string $ key = null ) : bool { if ( ! $ this -> isBrowser ) { return false ; } 
public function isRobot ( string $ key = null ) : bool { if ( ! $ this -> isRobot ) { return false ; } 
public function isMobile ( string $ key = null ) : bool { if ( ! $ this -> isMobile ) { return false ; } 
public function isReferral ( ) : bool { if ( ! isset ( $ this -> referrer ) ) { if ( empty ( $ _SERVER [ 'HTTP_REFERER' ] ) ) { $ this -> referrer = false ; } else { $ referer_host = @ parse_url ( $ _SERVER [ 'HTTP_REFERER' ] , PHP_URL_HOST ) ; $ own_host = parse_url ( \ base_url ( ) , PHP_URL_HOST ) ; $ this -> referrer = ( $ referer_host && $ referer_host !== $ own_host ) ; } } return $ this -> referrer ; } 
protected function setPlatform ( ) : bool { if ( is_array ( $ this -> config -> platforms ) && $ this -> config -> platforms ) { foreach ( $ this -> config -> platforms as $ key => $ val ) { if ( preg_match ( '|' . preg_quote ( $ key ) . '|i' , $ this -> agent ) ) { $ this -> platform = $ val ; return true ; } } } $ this -> platform = 'Unknown Platform' ; return false ; } 
protected function setBrowser ( ) : bool { if ( is_array ( $ this -> config -> browsers ) && $ this -> config -> browsers ) { foreach ( $ this -> config -> browsers as $ key => $ val ) { if ( preg_match ( '|' . $ key . '.*?([0-9\.]+)|i' , $ this -> agent , $ match ) ) { $ this -> isBrowser = true ; $ this -> version = $ match [ 1 ] ; $ this -> browser = $ val ; $ this -> setMobile ( ) ; return true ; } } } return false ; } 
protected function setRobot ( ) : bool { if ( is_array ( $ this -> config -> robots ) && $ this -> config -> robots ) { foreach ( $ this -> config -> robots as $ key => $ val ) { if ( preg_match ( '|' . preg_quote ( $ key ) . '|i' , $ this -> agent ) ) { $ this -> isRobot = true ; $ this -> robot = $ val ; $ this -> setMobile ( ) ; return true ; } } } return false ; } 
protected function setMobile ( ) : bool { if ( is_array ( $ this -> config -> mobiles ) && $ this -> config -> mobiles ) { foreach ( $ this -> config -> mobiles as $ key => $ val ) { if ( false !== ( stripos ( $ this -> agent , $ key ) ) ) { $ this -> isMobile = true ; $ this -> mobile = $ val ; return true ; } } } return false ; } 
protected function _alterTable ( string $ alter_type , string $ table , $ field ) { if ( in_array ( $ alter_type , [ 'DROP' , 'ADD' ] , true ) ) { return parent :: _alterTable ( $ alter_type , $ table , $ field ) ; } $ sql = 'ALTER TABLE ' . $ this -> db -> escapeIdentifiers ( $ table ) ; $ sqls = [ ] ; foreach ( $ field as $ data ) { if ( $ data [ '_literal' ] !== false ) { return false ; } if ( version_compare ( $ this -> db -> getVersion ( ) , '8' , '>=' ) && isset ( $ data [ 'type' ] ) ) { $ sqls [ ] = $ sql . ' ALTER COLUMN ' . $ this -> db -> escapeIdentifiers ( $ data [ 'name' ] ) . " TYPE {$data['type']}{$data['length']}" ; } if ( ! empty ( $ data [ 'default' ] ) ) { $ sqls [ ] = $ sql . ' ALTER COLUMN ' . $ this -> db -> escapeIdentifiers ( $ data [ 'name' ] ) . " SET DEFAULT {$data['default']}" ; } if ( isset ( $ data [ 'null' ] ) ) { $ sqls [ ] = $ sql . ' ALTER COLUMN ' . $ this -> db -> escapeIdentifiers ( $ data [ 'name' ] ) . ( $ data [ 'null' ] === true ? ' DROP' : ' SET' ) . ' NOT NULL' ; } if ( ! empty ( $ data [ 'new_name' ] ) ) { $ sqls [ ] = $ sql . ' RENAME COLUMN ' . $ this -> db -> escapeIdentifiers ( $ data [ 'name' ] ) . ' TO ' . $ this -> db -> escapeIdentifiers ( $ data [ 'new_name' ] ) ; } if ( ! empty ( $ data [ 'comment' ] ) ) { $ sqls [ ] = 'COMMENT ON COLUMN' . $ this -> db -> escapeIdentifiers ( $ table ) . '.' . $ this -> db -> escapeIdentifiers ( $ data [ 'name' ] ) . " IS {$data['comment']}" ; } } return $ sqls ; } 
protected function _processColumn ( array $ field ) : string { return $ this -> db -> escapeIdentifiers ( $ field [ 'name' ] ) . ' ' . $ field [ 'type' ] . $ field [ 'length' ] . $ field [ 'default' ] . $ field [ 'null' ] . $ field [ 'auto_increment' ] . $ field [ 'unique' ] ; } 
protected function _attributeType ( array & $ attributes ) { 
protected function _dropTable ( string $ table , bool $ if_exists , bool $ cascade ) : string { $ sql = parent :: _dropTable ( $ table , $ if_exists , $ cascade ) ; if ( $ cascade === true ) { $ sql .= ' CASCADE' ; } return $ sql ; } 
public function format ( $ data ) { $ options = JSON_UNESCAPED_UNICODE | JSON_UNESCAPED_SLASHES ; $ options = ENVIRONMENT === 'production' ? $ options : $ options | JSON_PRETTY_PRINT ; $ result = json_encode ( $ data , $ options , 512 ) ; if ( json_last_error ( ) !== JSON_ERROR_NONE ) { throw FormatException :: forInvalidJSON ( json_last_error_msg ( ) ) ; } return $ result ; } 
public function autoTypography ( string $ str , bool $ reduce_linebreaks = false ) : string { if ( $ str === '' ) { return '' ; } * * [array] * { * [0] = <opening tag> * [1] = Content... * [2] = <closing tag> * Etc... * } */ $ chunks = preg_split ( '/(<(?:[^<>]+(?:"[^"]*"|\'[^\']*\')?)+>)/' , $ str , - 1 , PREG_SPLIT_DELIM_CAPTURE | PREG_SPLIT_NO_EMPTY ) ; // Build our finalized string. We cycle through the array, skipping tags, and processing the contained text $ str = '' ; $ process = true ; for ( $ i = 0 , $ c = count ( $ chunks ) - 1 ; $ i <= $ c ; $ i ++ ) { // Are we dealing with a tag? If so, we'll skip the processing for this cycle. 
public function formatCharacters ( string $ str ) : string { static $ table ; if ( ! isset ( $ table ) ) { $ table = [ 
protected function formatNewLines ( string $ str ) : string { if ( $ str === '' || ( strpos ( $ str , "\n" ) === false && ! in_array ( $ this -> lastBlockElement , $ this -> innerBlockRequired ) ) ) { return $ str ; } 
public function make ( $ msg ) { switch ( $ msg [ 'MsgType' ] ) { case 1 : 
public function init ( ) { $ this -> config = vbot ( 'config' ) -> get ( 'extension.' . $ this -> name ) ; $ this -> admin ( ) ; $ this -> register ( ) ; return $ this ; } 
final public function messageHandler ( Collection $ collection ) { if ( $ collection [ 'type' ] === 'text' && $ this -> isAdmin ( $ collection [ 'username' ] ) ) { if ( starts_with ( $ collection [ 'content' ] , $ this -> name . ' ' ) ) { $ content = str_replace ( $ this -> name . ' ' , '' , $ collection [ 'content' ] ) ; switch ( $ content ) { case 'info' : $ this -> applicationInfo ( $ collection ) ; break ; case 'on' : $ this -> setStatus ( true , $ collection ) ; break ; case 'off' : $ this -> setStatus ( false , $ collection ) ; break ; default : break ; } } } if ( ! $ this -> status ) { return false ; } return $ this -> handler ( $ collection ) ; } 
final public function setStatus ( bool $ boolean , $ collection ) { $ this -> status = $ boolean ; $ status = $ this -> status ? '开' : ' '; Text :: send ( $ collection [ 'from' ] [ 'UserName' ] , "应用：{$this->zhName} 状态已更改为：{$status}"); } 
final public function admin ( ) { $ remark = vbot ( 'config' ) -> get ( 'extension.admin.remark' ) ; if ( $ remark ) { static :: $ admin = vbot ( 'friends' ) -> getUsernameByRemarkName ( $ remark ) ; } if ( ! $ remark && ( $ nickname = vbot ( 'config' ) -> get ( 'extension.admin.nickname' ) ) ) { static :: $ admin = vbot ( 'friends' ) -> getUsernameByNickname ( $ nickname ) ; } } 
public function request ( $ url , $ method = 'GET' , $ options = [ ] , $ retry = false ) { try { $ options = array_merge ( [ 'timeout' => 10 , 'verify' => false ] , $ options ) ; $ response = $ this -> getClient ( ) -> request ( $ method , $ url , $ options ) ; $ this -> cookieJar -> save ( $ this -> vbot -> config [ 'cookie_file' ] ) ; return $ response -> getBody ( ) -> getContents ( ) ; } catch ( \ Exception $ e ) { $ this -> vbot -> console -> log ( $ url . $ e -> getMessage ( ) , Console :: ERROR , true ) ; if ( ! $ retry ) { return $ this -> request ( $ url , $ method , $ options , true ) ; } return false ; } } 
private function initializeConfig ( ) { if ( ! is_dir ( $ this -> vbot -> config [ 'path' ] ) ) { mkdir ( $ this -> vbot -> config [ 'path' ] , 0755 , true ) ; } $ this -> vbot -> config [ 'storage' ] = $ this -> vbot -> config [ 'storage' ] ? : 'collection' ; $ this -> vbot -> config [ 'path' ] = realpath ( $ this -> vbot -> config [ 'path' ] ) ; } 
public function show ( $ text ) { if ( ! array_get ( $ this -> config , 'qrcode' , true ) ) { return false ; } $ output = new ConsoleOutput ( ) ; static :: initQrcodeStyle ( $ output ) ; $ pxMap [ 0 ] = Console :: isWin ( ) ? '<whitec>mm</whitec>' : '<whitec> </whitec>' ; $ pxMap [ 1 ] = '<blackc> </blackc>' ; $ text = QrCodeConsole :: text ( $ text ) ; $ length = strlen ( $ text [ 0 ] ) ; $ output -> write ( "\n" ) ; foreach ( $ text as $ line ) { $ output -> write ( $ pxMap [ 0 ] ) ; for ( $ i = 0 ; $ i < $ length ; $ i ++ ) { $ type = substr ( $ line , $ i , 1 ) ; $ output -> write ( $ pxMap [ $ type ] ) ; } $ output -> writeln ( $ pxMap [ 0 ] ) ; } } 
private static function initQrcodeStyle ( OutputInterface $ output ) { $ style = new OutputFormatterStyle ( 'black' , 'black' , [ 'bold' ] ) ; $ output -> getFormatter ( ) -> setStyle ( 'blackc' , $ style ) ; $ style = new OutputFormatterStyle ( 'white' , 'white' , [ 'bold' ] ) ; $ output -> getFormatter ( ) -> setStyle ( 'whitec' , $ style ) ; } 
public function getUsername ( $ search , $ key , $ blur = false ) { return $ this -> search ( function ( $ item ) use ( $ search , $ key , $ blur ) { if ( ! isset ( $ item [ $ key ] ) ) { return false ; } if ( $ blur && str_contains ( $ item [ $ key ] , $ search ) ) { return true ; } elseif ( ! $ blur && $ item [ $ key ] === $ search ) { return true ; } return false ; } ) ; } 
public function getObject ( $ search , $ key , $ blur = false ) { $ username = $ this -> getUsername ( $ search , $ key , $ blur ) ; return $ username ? $ this -> get ( $ username ) : null ; } 
public function getAccount ( $ username ) { if ( starts_with ( $ username , '@@' ) ) { return $ this -> vbot -> groups -> get ( $ username ) ; } else { $ account = $ this -> vbot -> friends -> get ( $ username , null ) ; $ account = $ account ? : $ this -> vbot -> members -> get ( $ username , null ) ; $ account = $ account ? : $ this -> vbot -> officials -> get ( $ username , null ) ; return $ account ? : $ this -> vbot -> specials -> get ( $ username , null ) ; } } 
public function put ( $ key , $ value ) { $ value = $ this -> format ( $ value ) ; return parent :: put ( $ key , $ value ) ; } 
public function format ( $ contact ) { if ( isset ( $ contact [ 'DisplayName' ] ) ) { $ contact [ 'DisplayName' ] = Content :: emojiHandle ( $ contact [ 'DisplayName' ] ) ; } if ( isset ( $ contact [ 'RemarkName' ] ) ) { $ contact [ 'RemarkName' ] = Content :: emojiHandle ( $ contact [ 'RemarkName' ] ) ; } if ( isset ( $ contact [ 'Signature' ] ) ) { $ contact [ 'Signature' ] = Content :: emojiHandle ( $ contact [ 'Signature' ] ) ; } $ contact [ 'NickName' ] = Content :: emojiHandle ( $ contact [ 'NickName' ] ) ; return $ contact ; } 
public function update ( $ username , $ list ) : array { $ usernames = is_string ( $ username ) ? [ $ username ] : $ username ; $ url = $ this -> vbot -> config [ 'server.uri.base' ] . '/webwxbatchgetcontact?type=ex&r=' . time ( ) ; $ data = [ 'BaseRequest' => $ this -> vbot -> config [ 'server.baseRequest' ] , 'Count' => count ( $ usernames ) , 'List' => $ list , ] ; $ response = $ this -> vbot -> http -> json ( $ url , $ data , true ) ; if ( ! $ response ) { return [ ] ; } foreach ( $ response [ 'ContactList' ] as $ item ) { $ this -> put ( $ item [ 'UserName' ] , $ item ) ; } return is_string ( $ username ) ? head ( $ response [ 'ContactList' ] ) : $ response [ 'ContactList' ] ; } 
public static function formatContent ( $ content ) { $ content = self :: emojiHandle ( $ content ) ; $ content = self :: replaceBr ( $ content ) ; return self :: htmlDecode ( $ content ) ; } 
public static function emojiHandle ( string $ content ) { 
private function heartbeat ( $ time ) { if ( time ( ) - $ time > 1800 ) { Text :: send ( 'filehelper' , 'heart beat ' . Carbon :: now ( ) -> toDateTimeString ( ) ) ; return time ( ) ; } return $ time ; } 
public function handleCheckSync ( $ retCode , $ selector , $ test = false ) { if ( in_array ( $ retCode , [ 1100 , 1101 , 1102 , 1205 ] ) ) { 
private function handleMessage ( $ selector ) { if ( $ selector == 0 ) { return ; } $ message = $ this -> vbot -> sync -> sync ( ) ; $ this -> log ( $ message ) ; $ this -> storeContactsFromMessage ( $ message ) ; if ( $ message [ 'AddMsgList' ] ) { foreach ( $ message [ 'AddMsgList' ] as $ msg ) { $ collection = $ this -> vbot -> messageFactory -> make ( $ msg ) ; if ( $ collection ) { $ this -> cache ( $ msg , $ collection ) ; $ this -> console ( $ collection ) ; if ( ! $ this -> vbot -> messageExtension -> exec ( $ collection ) && $ this -> handler ) { call_user_func_array ( $ this -> handler , [ $ collection ] ) ; } } } } } 
private function log ( $ message ) { if ( $ this -> vbot -> messageLog && ( $ message [ 'ModContactList' ] || $ message [ 'AddMsgList' ] ) ) { $ this -> vbot -> messageLog -> info ( json_encode ( $ message ) ) ; } } 
private function tryLogin ( ) : bool { if ( is_file ( $ this -> vbot -> config [ 'cookie_file' ] ) && $ this -> vbot -> cache -> has ( $ this -> vbot -> config [ 'session_key' ] ) ) { $ configs = json_decode ( $ this -> vbot -> cache -> get ( $ this -> vbot -> config [ 'session_key' ] ) , true ) ; $ this -> vbot -> config [ 'server' ] = $ configs ; $ this -> vbot -> config [ 'server.time' ] = $ this -> vbot -> config [ 'server.time' ] ? : Carbon :: now ( ) -> toDateTimeString ( ) ; if ( ! ( $ checkSync = $ this -> vbot -> sync -> checkSync ( ) ) ) { return false ; } $ result = $ this -> vbot -> messageHandler -> handleCheckSync ( $ checkSync [ 0 ] , $ checkSync [ 1 ] , true ) ; if ( $ result ) { $ this -> vbot -> reLoginSuccessObserver -> trigger ( ) ; return true ; } } $ this -> vbot -> config [ 'server.time' ] = Carbon :: now ( ) -> toDateTimeString ( ) ; return false ; } 
protected function getUuid ( ) { $ content = $ this -> vbot -> http -> get ( 'https://login.weixin.qq.com/jslogin' , [ 'query' => [ 'appid' => 'wx782c26e4c19acffb' , 'fun' => 'new' , 'lang' => 'zh_CN' , '_' => time ( ) , ] ] ) ; preg_match ( '/window.QRLogin.code = (\d+); window.QRLogin.uuid = \"(\S+?)\"/' , $ content , $ matches ) ; if ( ! $ matches ) { throw new FetchUuidException ( 'fetch uuid failed.' ) ; } $ this -> vbot -> config [ 'server.uuid' ] = $ matches [ 2 ] ; } 
public function showQrCode ( ) { $ url = 'https://login.weixin.qq.com/l/' . $ this -> vbot -> config [ 'server.uuid' ] ; $ this -> vbot -> qrCodeObserver -> trigger ( $ url ) ; $ this -> vbot -> qrCode -> show ( $ url ) ; } 
protected function waitForLogin ( ) { $ retryTime = 10 ; $ tip = 1 ; $ this -> vbot -> console -> log ( 'please scan the qrCode with wechat.' ) ; while ( $ retryTime > 0 ) { $ url = sprintf ( 'https://login.weixin.qq.com/cgi-bin/mmwebwx-bin/login?tip=%s&uuid=%s&_=%s' , $ tip , $ this -> vbot -> config [ 'server.uuid' ] , time ( ) ) ; $ content = $ this -> vbot -> http -> get ( $ url , [ 'timeout' => 35 ] ) ; preg_match ( '/window.code=(\d+);/' , $ content , $ matches ) ; $ code = $ matches [ 1 ] ; switch ( $ code ) { case '201' : $ this -> vbot -> console -> log ( 'please confirm login in wechat.' ) ; $ tip = 0 ; break ; case '200' : preg_match ( '/window.redirect_uri="(https:\/\/(\S+?)\/\S+?)";/' , $ content , $ matches ) ; $ this -> vbot -> config [ 'server.uri.redirect' ] = $ matches [ 1 ] . '&fun=new' ; $ url = 'https://%s/cgi-bin/mmwebwx-bin' ; $ this -> vbot -> config [ 'server.uri.file' ] = sprintf ( $ url , 'file.' . $ matches [ 2 ] ) ; $ this -> vbot -> config [ 'server.uri.push' ] = sprintf ( $ url , 'webpush.' . $ matches [ 2 ] ) ; $ this -> vbot -> config [ 'server.uri.base' ] = sprintf ( $ url , $ matches [ 2 ] ) ; return ; case '408' : $ tip = 1 ; $ retryTime -= 1 ; sleep ( 1 ) ; break ; default : $ tip = 1 ; $ retryTime -= 1 ; sleep ( 1 ) ; break ; } } $ this -> vbot -> console -> log ( 'login time out!' , Console :: ERROR ) ; throw new LoginTimeoutException ( 'Login time out.' ) ; } 
private function getLogin ( ) { $ content = $ this -> vbot -> http -> get ( $ this -> vbot -> config [ 'server.uri.redirect' ] ) ; $ data = ( array ) simplexml_load_string ( $ content , 'SimpleXMLElement' , LIBXML_NOCDATA ) ; $ this -> vbot -> config [ 'server.skey' ] = $ data [ 'skey' ] ; $ this -> vbot -> config [ 'server.sid' ] = $ data [ 'wxsid' ] ; $ this -> vbot -> config [ 'server.uin' ] = $ data [ 'wxuin' ] ; $ this -> vbot -> config [ 'server.passTicket' ] = $ data [ 'pass_ticket' ] ; if ( in_array ( '' , [ $ data [ 'wxsid' ] , $ data [ 'wxuin' ] , $ data [ 'pass_ticket' ] ] ) ) { throw new LoginFailedException ( 'Login failed.' ) ; } $ this -> vbot -> config [ 'server.deviceId' ] = 'e' . substr ( mt_rand ( ) . mt_rand ( ) , 1 , 15 ) ; $ this -> vbot -> config [ 'server.baseRequest' ] = [ 'Uin' => $ data [ 'wxuin' ] , 'Sid' => $ data [ 'wxsid' ] , 'Skey' => $ data [ 'skey' ] , 'DeviceID' => $ this -> vbot -> config [ 'server.deviceId' ] , ] ; $ this -> saveServer ( ) ; } 
private function saveServer ( ) { $ this -> vbot -> cache -> forever ( 'session.' . $ this -> vbot -> config [ 'session' ] , json_encode ( $ this -> vbot -> config [ 'server' ] ) ) ; } 
protected function init ( $ first = true ) { $ this -> beforeInitSuccess ( ) ; $ url = $ this -> vbot -> config [ 'server.uri.base' ] . '/webwxinit?r=' . time ( ) ; $ result = $ this -> vbot -> http -> json ( $ url , [ 'BaseRequest' => $ this -> vbot -> config [ 'server.baseRequest' ] , ] , true ) ; $ this -> generateSyncKey ( $ result , $ first ) ; $ this -> vbot -> myself -> init ( $ result [ 'User' ] ) ; ApiExceptionHandler :: handle ( $ result , function ( $ result ) { $ this -> vbot -> cache -> forget ( 'session.' . $ this -> vbot -> config [ 'session' ] ) ; $ this -> vbot -> log -> error ( 'Init failed.' . json_encode ( $ result ) ) ; throw new InitFailException ( 'Init failed.' ) ; } ) ; $ this -> afterInitSuccess ( $ result ) ; $ this -> initContactList ( $ result [ 'ContactList' ] ) ; $ this -> initContact ( ) ; } 
private function beforeInitSuccess ( ) { $ this -> vbot -> console -> log ( 'current session: ' . $ this -> vbot -> config [ 'session' ] ) ; $ this -> vbot -> console -> log ( 'init begin.' ) ; } 
private function afterInitSuccess ( $ content ) { $ this -> vbot -> log -> info ( 'response:' . json_encode ( $ content ) ) ; $ this -> vbot -> console -> log ( 'init success.' ) ; $ this -> vbot -> loginSuccessObserver -> trigger ( ) ; $ this -> vbot -> console -> log ( 'init contacts begin.' ) ; } 
protected function statusNotify ( ) { $ url = sprintf ( $ this -> vbot -> config [ 'server.uri.base' ] . '/webwxstatusnotify?lang=zh_CN&pass_ticket=%s' , $ this -> vbot -> config [ 'server.passTicket' ] ) ; $ this -> vbot -> http -> json ( $ url , [ 'BaseRequest' => $ this -> vbot -> config [ 'server.baseRequest' ] , 'Code' => 3 , 'FromUserName' => $ this -> vbot -> myself -> username , 'ToUserName' => $ this -> vbot -> myself -> username , 'ClientMsgId' => time ( ) , ] ) ; } 
public static function download ( $ message , $ callback = null ) { if ( ! $ callback ) { static :: autoDownload ( $ message [ 'raw' ] , true ) ; return true ; } if ( $ callback && ! is_callable ( $ callback ) ) { throw new ArgumentException ( ) ; } call_user_func_array ( $ callback , [ static :: getResource ( $ message [ 'raw' ] ) ] ) ; return true ; } 
private static function getResource ( $ message ) { $ url = static :: getDownloadUrl ( $ message ) ; $ content = vbot ( 'http' ) -> get ( $ url , static :: getDownloadOption ( $ message ) ) ; if ( ! $ content ) { vbot ( 'console' ) -> log ( 'download file failed.' , Console :: WARNING ) ; } else { return $ content ; } } 
protected static function autoDownload ( $ message , $ force = false ) { $ isDownload = vbot ( 'config' ) [ 'download.' . static :: TYPE ] ; if ( $ isDownload || $ force ) { $ resource = static :: getResource ( $ message ) ; if ( $ resource ) { File :: saveTo ( vbot ( 'config' ) [ 'user_path' ] . static :: TYPE . DIRECTORY_SEPARATOR . static :: fileName ( $ message ) , $ resource ) ; } } } 
public static function uploadMedia ( $ username , $ file ) { if ( ! is_file ( $ file ) ) { return false ; } $ url = vbot ( 'config' ) [ 'server.uri.file' ] . '/webwxuploadmedia?f=json' ; static :: $ file = $ file ; list ( $ mime , $ mediaType ) = static :: getMediaType ( $ file ) ; $ data = [ 'id' => 'WU_FILE_0' , 'name' => basename ( $ file ) , 'type' => $ mime , 'lastModifieDate' => gmdate ( 'D M d Y H:i:s TO' , filemtime ( $ file ) ) . ' (CST)' , 'size' => filesize ( $ file ) , 'mediatype' => $ mediaType , 'uploadmediarequest' => json_encode ( [ 'BaseRequest' => vbot ( 'config' ) [ 'server.baseRequest' ] , 'ClientMediaId' => time ( ) , 'TotalLen' => filesize ( $ file ) , 'StartPos' => 0 , 'DataLen' => filesize ( $ file ) , 'MediaType' => 4 , 'UploadType' => 2 , 'FromUserName' => vbot ( 'myself' ) -> username , 'ToUserName' => $ username , 'FileMd5' => md5_file ( $ file ) , ] , JSON_UNESCAPED_UNICODE | JSON_UNESCAPED_SLASHES ) , 'webwx_data_ticket' => static :: getTicket ( ) , 'pass_ticket' => vbot ( 'config' ) [ 'server.passTicket' ] , 'filename' => fopen ( $ file , 'r' ) , ] ; $ data = static :: dataToMultipart ( $ data ) ; $ result = vbot ( 'http' ) -> request ( $ url , 'post' , [ 'multipart' => $ data , ] ) ; $ result = json_decode ( $ result , true ) ; return ApiExceptionHandler :: handle ( $ result ) ; } 
private static function getMediaType ( $ file ) { $ info = finfo_open ( FILEINFO_MIME_TYPE ) ; $ mime = finfo_file ( $ info , $ file ) ; finfo_close ( $ info ) ; $ fileExplode = explode ( '.' , $ file ) ; $ fileExtension = end ( $ fileExplode ) ; return [ $ mime , $ fileExtension === 'jpg' ? 'pic' : ( $ fileExtension === 'mp4' ? 'video' : 'doc' ) ] ; } 
private static function getTicket ( ) { $ cookies = vbot ( 'http' ) -> getClient ( ) -> getConfig ( 'cookies' ) -> toArray ( ) ; $ key = array_search ( 'webwx_data_ticket' , array_column ( $ cookies , 'Name' ) ) ; return $ cookies [ $ key ] [ 'Value' ] ; } 
private static function dataToMultipart ( $ data ) { $ result = [ ] ; foreach ( $ data as $ key => $ item ) { $ field = [ 'name' => $ key , 'contents' => $ item , ] ; if ( $ key === 'filename' ) { $ field [ 'filename' ] = basename ( static :: $ file ) ; } $ result [ ] = $ field ; } return $ result ; } 
public function bootstrap ( Vbot $ app ) { $ this -> app = $ app ; error_reporting ( - 1 ) ; set_error_handler ( [ $ this , 'handleError' ] ) ; set_exception_handler ( [ $ this , 'handleException' ] ) ; register_shutdown_function ( [ $ this , 'handleShutdown' ] ) ; } 
public function checkSync ( ) { $ content = $ this -> vbot -> http -> get ( $ this -> vbot -> config [ 'server.uri.push' ] . '/synccheck' , [ 'timeout' => 35 , 'query' => [ 'r' => time ( ) , 'sid' => $ this -> vbot -> config [ 'server.sid' ] , 'uin' => $ this -> vbot -> config [ 'server.uin' ] , 'skey' => $ this -> vbot -> config [ 'server.skey' ] , 'deviceid' => $ this -> vbot -> config [ 'server.deviceId' ] , 'synckey' => $ this -> vbot -> config [ 'server.syncKeyStr' ] , '_' => time ( ) , ] ] ) ; if ( ! $ content ) { $ this -> vbot -> console -> log ( 'checkSync no response' ) ; return false ; } return preg_match ( '/window.synccheck=\{retcode:"(\d+)",selector:"(\d+)"\}/' , $ content , $ matches ) ? [ $ matches [ 1 ] , $ matches [ 2 ] ] : false ; } 
public function sync ( ) { $ url = sprintf ( $ this -> vbot -> config [ 'server.uri.base' ] . '/webwxsync?sid=%s&skey=%s&lang=zh_CN&pass_ticket=%s' , $ this -> vbot -> config [ 'server.sid' ] , $ this -> vbot -> config [ 'server.skey' ] , $ this -> vbot -> config [ 'server.passTicket' ] ) ; $ result = $ this -> vbot -> http -> json ( $ url , [ 'BaseRequest' => $ this -> vbot -> config [ 'server.baseRequest' ] , 'SyncKey' => $ this -> vbot -> config [ 'server.syncKey' ] , 'rr' => ~ time ( ) , ] , true ) ; if ( $ result && $ result [ 'BaseResponse' ] [ 'Ret' ] == 0 ) { $ this -> generateSyncKey ( $ result ) ; } return $ result ; } 
public function generateSyncKey ( $ result ) { $ this -> vbot -> config [ 'server.syncKey' ] = $ result [ 'SyncKey' ] ; $ syncKey = [ ] ; if ( is_array ( $ this -> vbot -> config [ 'server.syncKey.List' ] ) ) { foreach ( $ this -> vbot -> config [ 'server.syncKey.List' ] as $ item ) { $ syncKey [ ] = $ item [ 'Key' ] . '_' . $ item [ 'Val' ] ; } } $ this -> vbot -> config [ 'server.syncKeyStr' ] = implode ( '|' , $ syncKey ) ; } 
public function log ( $ str , $ level = 'INFO' , $ log = false ) { if ( $ this -> isOutput ( ) ) { if ( $ log && in_array ( $ level , array_keys ( Logger :: getLevels ( ) ) ) ) { $ this -> vbot -> log -> log ( $ level , $ str ) ; } echo '[' . Carbon :: now ( ) -> toDateTimeString ( ) . ']' . "[{$level}] " . $ str . PHP_EOL ; } } 
public function message ( $ str ) { if ( array_get ( $ this -> config , 'message' , true ) ) { $ this -> log ( $ str , self :: MESSAGE ) ; } } 
public function setRemarkName ( $ username , $ remarkName ) { $ url = sprintf ( '%s/webwxoplog?lang=zh_CN&pass_ticket=%s' , $ this -> vbot -> config [ 'server.uri.base' ] , $ this -> vbot -> config [ 'server.passTicket' ] ) ; $ result = $ this -> vbot -> http -> post ( $ url , json_encode ( [ 'UserName' => $ username , 'CmdId' => 2 , 'RemarkName' => $ remarkName , 'BaseRequest' => $ this -> vbot -> config [ 'server.baseRequest' ] , ] , JSON_UNESCAPED_UNICODE | JSON_UNESCAPED_SLASHES ) , true ) ; return $ result [ 'BaseResponse' ] [ 'Ret' ] == 0 ; } 
public function setStick ( $ username , $ isStick = true ) { $ url = sprintf ( '%s/webwxoplog?lang=zh_CN&pass_ticket=%s' , $ this -> vbot -> config [ 'server.uri.base' ] , $ this -> vbot -> config [ 'server.passTicket' ] ) ; $ result = $ this -> vbot -> http -> json ( $ url , [ 'UserName' => $ username , 'CmdId' => 3 , 'OP' => ( int ) $ isStick , 'BaseRequest' => $ this -> vbot -> config [ 'server.baseRequest' ] , ] , true ) ; return $ result [ 'BaseResponse' ] [ 'Ret' ] == 0 ; } 
public function verifyUser ( $ code , $ userList , $ content = null ) { $ url = sprintf ( $ this -> vbot -> config [ 'server.uri.base' ] . '/webwxverifyuser?lang=zh_CN&r=%s&pass_ticket=%s' , time ( ) * 1000 , $ this -> vbot -> config [ 'server.passTicket' ] ) ; $ data = [ 'BaseRequest' => $ this -> vbot -> config [ 'server.baseRequest' ] , 'Opcode' => $ code , 'VerifyUserListSize' => 1 , 'VerifyUserList' => [ $ userList ] , 'VerifyContent' => $ content , 'SceneListCount' => 1 , 'SceneList' => [ 33 ] , 'skey' => $ this -> vbot -> config [ 'server.skey' ] , ] ; $ result = $ this -> vbot -> http -> post ( $ url , json_encode ( $ data , JSON_UNESCAPED_UNICODE | JSON_UNESCAPED_SLASHES ) , true ) ; return ApiExceptionHandler :: handle ( $ result ) ; } 
public function update ( $ username , $ list = null ) : array { $ username = is_array ( $ username ) ? : [ $ username ] ; return parent :: update ( $ username , $ this -> makeUsernameList ( $ username ) ) ; } 
public static function send ( $ username , $ word ) { if ( ! $ word || ! $ username ) { return false ; } return static :: sendMsg ( [ 'Type' => 1 , 'Content' => $ word , 'FromUserName' => vbot ( 'myself' ) -> username , 'ToUserName' => $ username , 'LocalID' => time ( ) * 1e4 , 'ClientMsgId' => time ( ) * 1e4 , ] ) ; } 
public function getMemberByUsername ( $ username , $ memberUsername ) { $ members = $ this -> get ( $ username ) [ 'MemberList' ] ; if ( count ( $ members ) === 0 ) { return ; } foreach ( $ members as $ member ) { if ( $ memberUsername === $ member [ 'UserName' ] ) { return $ member ; } } } 
public function getMembersByNickname ( $ groupUsername , $ memberNickname , $ blur = false ) { $ group = $ this -> get ( $ groupUsername ) ; if ( ! $ group ) { return false ; } $ result = [ ] ; foreach ( $ group [ 'MemberList' ] as $ member ) { if ( $ blur && str_contains ( $ member [ 'NickName' ] , $ memberNickname ) ) { $ result [ ] = $ member ; } elseif ( ! $ blur && $ member [ 'NickName' ] === $ memberNickname ) { $ result [ ] = $ member ; } } return $ result ; } 
public function create ( array $ contacts ) { $ url = sprintf ( '%s/webwxcreatechatroom?lang=zh_CN&r=%s' , $ this -> vbot -> config [ 'server.uri.base' ] , time ( ) ) ; $ result = $ this -> vbot -> http -> json ( $ url , [ 'MemberCount' => count ( $ contacts ) , 'MemberList' => $ this -> makeMemberList ( $ contacts ) , 'Topic' => '' , 'BaseRequest' => $ this -> vbot -> config [ 'server.baseRequest' ] , ] , true ) ; if ( $ result [ 'BaseResponse' ] [ 'Ret' ] != 0 ) { return false ; } return $ this -> add ( $ result [ 'ChatRoomName' ] ) ; } 
public function deleteMember ( $ group , $ members ) { $ members = is_string ( $ members ) ? [ $ members ] : $ members ; $ result = $ this -> vbot -> http -> json ( sprintf ( '%s/webwxupdatechatroom?fun=delmember&pass_ticket=%s' , $ this -> vbot -> config [ 'server.uri.base' ] , $ this -> vbot -> config [ 'server.passTicket' ] ) , [ 'BaseRequest' => $ this -> vbot -> config [ 'server.baseRequest' ] , 'ChatRoomName' => $ group , 'DelMemberList' => implode ( ',' , $ members ) , ] , true ) ; return $ result [ 'BaseResponse' ] [ 'Ret' ] == 0 ; } 
public function addMember ( $ groupUsername , $ members ) { if ( ! $ groupUsername ) { return false ; } $ group = $ this -> get ( $ groupUsername ) ; if ( ! $ group ) { return false ; } $ groupCount = count ( $ group [ 'MemberList' ] ) ; list ( $ fun , $ key ) = $ groupCount > 40 ? [ 'invitemember' , 'InviteMemberList' ] : [ 'addmember' , 'AddMemberList' ] ; $ members = is_string ( $ members ) ? [ $ members ] : $ members ; $ result = $ this -> vbot -> http -> json ( sprintf ( '%s/webwxupdatechatroom?fun=%s&pass_ticket=%s' , $ this -> vbot -> config [ 'server.uri.base' ] , $ fun , $ this -> vbot -> config [ 'server.passTicket' ] ) , [ 'BaseRequest' => $ this -> vbot -> config [ 'server.baseRequest' ] , 'ChatRoomName' => $ groupUsername , $ key => implode ( ',' , $ members ) , ] , true ) ; return $ result [ 'BaseResponse' ] [ 'Ret' ] == 0 ; } 
public function setGroupName ( $ group , $ name ) { $ result = $ this -> vbot -> http -> post ( sprintf ( '%s/webwxupdatechatroom?fun=modtopic&pass_ticket=%s' , $ this -> vbot -> config [ 'server.uri.base' ] , $ this -> vbot -> config [ 'server.passTicket' ] ) , json_encode ( [ 'BaseRequest' => $ this -> vbot -> config [ 'server.baseRequest' ] , 'ChatRoomName' => $ group , 'NewTopic' => $ name , ] , JSON_UNESCAPED_UNICODE | JSON_UNESCAPED_SLASHES ) , true ) ; return $ result [ 'BaseResponse' ] [ 'Ret' ] == 0 ; } 
public function add ( $ username ) { $ result = $ this -> vbot -> http -> json ( sprintf ( '%s/webwxbatchgetcontact?type=ex&r=%s&pass_ticket=%s' , $ this -> vbot -> config [ 'server.uri.base' ] , time ( ) , $ this -> vbot -> config [ 'server.passTicket' ] ) , [ 'Count' => 1 , 'BaseRequest' => $ this -> vbot -> config [ 'server.baseRequest' ] , 'List' => [ [ 'ChatRoomId' => '' , 'UserName' => $ username , ] , ] , ] , true ) ; if ( $ result [ 'BaseResponse' ] [ 'Ret' ] != 0 ) { throw new CreateGroupException ( 'create group chat fail.' ) ; } $ this -> put ( $ username , $ result [ 'ContactList' ] [ 0 ] ) ; return $ result [ 'ContactList' ] [ 0 ] ; } 
public function put ( $ key , $ value ) { foreach ( $ value [ 'MemberList' ] as & $ member ) { $ member = $ this -> format ( $ member ) ; } return parent :: put ( $ key , $ value ) ; } 
public function get ( $ key , $ default = null ) { $ group = parent :: get ( $ key ) ; return $ group ? : current ( $ this -> update ( $ key ) ) ; } 
public function fetchAllContacts ( $ seq = 0 ) { $ url = sprintf ( $ this -> vbot -> config [ 'server.uri.base' ] . '/webwxgetcontact?pass_ticket=%s&skey=%s&r=%s&seq=%s' , $ this -> vbot -> config [ 'server.passTicket' ] , $ this -> vbot -> config [ 'server.skey' ] , time ( ) , $ seq ) ; $ result = $ this -> vbot -> http -> json ( $ url , [ ] , true , [ 'timeout' => 60 ] ) ; if ( isset ( $ result [ 'MemberList' ] ) && $ result [ 'MemberList' ] ) { $ this -> store ( $ result [ 'MemberList' ] ) ; } if ( isset ( $ result [ 'Seq' ] ) && $ result [ 'Seq' ] != 0 ) { $ this -> fetchAllContacts ( $ result [ 'Seq' ] ) ; } } 
public function store ( $ memberList ) { foreach ( $ memberList as $ contact ) { if ( in_array ( $ contact [ 'UserName' ] , static :: SPECIAL_USERS ) ) { $ this -> vbot -> specials -> put ( $ contact [ 'UserName' ] , $ contact ) ; } elseif ( $ this -> vbot -> officials -> isOfficial ( $ contact [ 'VerifyFlag' ] ) ) { $ this -> vbot -> officials -> put ( $ contact [ 'UserName' ] , $ contact ) ; } elseif ( strstr ( $ contact [ 'UserName' ] , '@@' ) !== false ) { $ this -> vbot -> groups -> put ( $ contact [ 'UserName' ] , $ contact ) ; } else { $ this -> vbot -> friends -> put ( $ contact [ 'UserName' ] , $ contact ) ; } } } 
public function fetchGroupMembers ( ) { $ url = sprintf ( $ this -> vbot -> config [ 'server.uri.base' ] . '/webwxbatchgetcontact?type=ex&r=%s&pass_ticket=%s' , time ( ) , $ this -> vbot -> config [ 'server.passTicket' ] ) ; $ list = [ ] ; $ this -> vbot -> groups -> each ( function ( $ item , $ key ) use ( & $ list ) { $ list [ ] = [ 'UserName' => $ key , 'EncryChatRoomId' => '' ] ; } ) ; $ content = $ this -> vbot -> http -> json ( $ url , [ 'BaseRequest' => $ this -> vbot -> config [ 'server.baseRequest' ] , 'Count' => $ this -> vbot -> groups -> count ( ) , 'List' => $ list , ] , true , [ 'timeout' => 60 ] ) ; $ this -> storeMembers ( $ content ) ; } 
private function storeMembers ( $ array ) { if ( isset ( $ array [ 'ContactList' ] ) && $ array [ 'ContactList' ] ) { foreach ( $ array [ 'ContactList' ] as $ group ) { $ groupAccount = $ this -> vbot -> groups -> get ( $ group [ 'UserName' ] ) ; $ groupAccount [ 'MemberList' ] = $ group [ 'MemberList' ] ; $ groupAccount [ 'ChatRoomId' ] = $ group [ 'EncryChatRoomId' ] ; $ this -> vbot -> groups -> put ( $ group [ 'UserName' ] , $ groupAccount ) ; foreach ( $ group [ 'MemberList' ] as $ member ) { $ this -> vbot -> members -> put ( $ member [ 'UserName' ] , $ member ) ; } } } } 
public function report ( Exception $ e ) { if ( $ this -> shouldntReport ( $ e ) ) { return true ; } if ( $ this -> handler ) { call_user_func_array ( $ this -> handler , [ $ e ] ) ; } } 
public function handleException ( Throwable $ e ) { $ this -> vbot -> log -> error ( $ e -> getMessage ( ) ) ; $ this -> report ( $ e ) ; $ this -> throwFatalException ( $ e ) ; throw $ e ; } 
private function throwFatalException ( Throwable $ e ) { foreach ( $ this -> fatalException as $ exception ) { if ( $ e instanceof $ exception ) { throw $ e ; } } } 
public function handleShutdown ( ) { if ( ! is_null ( $ error = error_get_last ( ) ) && $ this -> isFatal ( $ error [ 'type' ] ) ) { $ this -> handleException ( $ this -> fatalExceptionFromError ( $ error , 0 ) ) ; } $ this -> vbot -> exitObserver -> trigger ( ) ; } 
public function load ( $ extensions ) { if ( ! is_array ( $ extensions ) ) { throw new ExtensionException ( 'extensions must pass an array.' ) ; } foreach ( $ extensions as $ extension ) { $ this -> addServiceExtension ( $ extension ) ; } $ this -> serviceExtensions = array_unique ( $ this -> serviceExtensions ) ; } 
public function initServiceExtensions ( ) { $ tmpExtensions = [ ] ; foreach ( $ this -> serviceExtensions as $ serviceExtensions ) { $ extension = new $ serviceExtensions ( ) ; $ tmpExtensions [ ] = $ extension -> init ( ) ; $ this -> baseExtensions = array_merge ( $ this -> baseExtensions , $ extension -> baseExtensions ) ; } $ this -> serviceExtensions = $ tmpExtensions ; $ this -> baseExtensions = array_unique ( $ this -> baseExtensions ) ; $ this -> initBaseExtensions ( ) ; } 
private function initBaseExtensions ( ) { $ tmpExtensions = [ ] ; foreach ( $ this -> baseExtensions as $ baseExtension ) { $ tmpExtensions [ ] = ( new $ baseExtension ( ) ) -> init ( ) ; } $ this -> baseExtensions = $ tmpExtensions ; } 
public function exec ( $ collection ) { foreach ( $ this -> serviceExtensions as $ extension ) { if ( $ extension -> messageHandler ( $ collection ) ) { return true ; } } } 
public static function xlsCell ( $ row_number , $ column_number , $ absolute = false ) { $ n = $ column_number ; for ( $ r = "" ; $ n >= 0 ; $ n = intval ( $ n / 26 ) - 1 ) { $ r = chr ( $ n % 26 + 0x41 ) . $ r ; } if ( $ absolute ) { return '$' . $ r . '$' . ( $ row_number + 1 ) ; } return $ r . ( $ row_number + 1 ) ; } 
public static function log ( $ string ) { file_put_contents ( "php://stderr" , date ( "Y-m-d H:i:s:" ) . rtrim ( is_array ( $ string ) ? json_encode ( $ string ) : $ string ) . "\n" ) ; } 
public static function sanitize_filename ( $ filename ) 
public static function xmlspecialchars ( $ val ) { 
public static function add_to_list_get_index ( & $ haystack , $ needle ) { $ existing_idx = array_search ( $ needle , $ haystack , $ strict = true ) ; if ( $ existing_idx === false ) { $ existing_idx = count ( $ haystack ) ; $ haystack [ ] = $ needle ; } return $ existing_idx ; } 
public static function convert_date_time ( $ date_input ) 
public function permittedFor ( string ... $ audiences ) : BuilderInterface { $ configured = $ this -> claims [ RegisteredClaims :: AUDIENCE ] ?? [ ] ; $ toAppend = array_diff ( $ audiences , $ configured ) ; return $ this -> setClaim ( RegisteredClaims :: AUDIENCE , array_merge ( $ configured , $ toAppend ) ) ; } 
public function withHeader ( string $ name , $ value ) : BuilderInterface { $ this -> headers [ $ name ] = $ value ; return $ this ; } 
public function withClaim ( string $ name , $ value ) : BuilderInterface { if ( in_array ( $ name , RegisteredClaims :: ALL , true ) ) { throw new InvalidArgumentException ( 'You should use the correct methods to set registered claims' ) ; } return $ this -> setClaim ( $ name , $ value ) ; } 
public function getToken ( Signer $ signer , Key $ key ) : Plain { $ headers = $ this -> headers ; $ headers [ 'alg' ] = $ signer -> getAlgorithmId ( ) ; $ encodedHeaders = $ this -> encode ( $ headers ) ; $ encodedClaims = $ this -> encode ( $ this -> formatClaims ( $ this -> claims ) ) ; $ signature = $ signer -> sign ( $ encodedHeaders . '.' . $ encodedClaims , $ key ) ; $ encodedSignature = $ this -> encoder -> base64UrlEncode ( $ signature ) ; return new Plain ( new DataSet ( $ headers , $ encodedHeaders ) , new DataSet ( $ this -> claims , $ encodedClaims ) , new Signature ( $ signature , $ encodedSignature ) ) ; } 
private function formatClaims ( array $ claims ) : array { if ( isset ( $ claims [ RegisteredClaims :: AUDIENCE ] [ 0 ] ) && ! isset ( $ claims [ RegisteredClaims :: AUDIENCE ] [ 1 ] ) ) { $ claims [ RegisteredClaims :: AUDIENCE ] = $ claims [ RegisteredClaims :: AUDIENCE ] [ 0 ] ; } foreach ( array_intersect ( RegisteredClaims :: DATE_CLAIMS , array_keys ( $ claims ) ) as $ claim ) { $ claims [ $ claim ] = $ this -> convertDate ( $ claims [ $ claim ] ) ; } return $ claims ; } 
public function assert ( Token $ token , Constraint ... $ constraints ) : void { $ violations = [ ] ; foreach ( $ constraints as $ constraint ) { $ this -> checkConstraint ( $ constraint , $ token , $ violations ) ; } if ( $ violations ) { throw InvalidToken :: fromViolations ( ... $ violations ) ; } } 
private function validateKey ( $ key ) : void { if ( ! is_resource ( $ key ) ) { throw new InvalidArgumentException ( 'It was not possible to parse your key, reason: ' . openssl_error_string ( ) ) ; } $ details = openssl_pkey_get_details ( $ key ) ; assert ( is_array ( $ details ) ) ; if ( ! isset ( $ details [ 'key' ] ) || $ details [ 'type' ] !== $ this -> getKeyType ( ) ) { throw new InvalidArgumentException ( 'This key is not compatible with this signer' ) ; } } 
final public function sign ( string $ payload , Key $ key ) : string { return $ this -> createSignature ( $ key -> getContent ( ) , $ key -> getPassphrase ( ) , $ payload ) ; } 
final public function verify ( string $ expected , string $ payload , Key $ key ) : bool { return $ this -> verifySignature ( $ expected , $ payload , $ key -> getContent ( ) ) ; } 
final public function sign ( string $ payload , Key $ key ) : string { return $ this -> converter -> fromAsn1 ( $ this -> createSignature ( $ key -> getContent ( ) , $ key -> getPassphrase ( ) , $ payload ) , $ this -> getKeyLength ( ) ) ; } 
final public function verify ( string $ expected , string $ payload , Key $ key ) : bool { return $ this -> verifySignature ( $ this -> converter -> toAsn1 ( $ expected , $ this -> getKeyLength ( ) ) , $ payload , $ key -> getContent ( ) ) ; } 
final public function sign ( string $ payload , Key $ key ) : string { return hash_hmac ( $ this -> getAlgorithm ( ) , $ payload , $ key -> getContent ( ) , true ) ; } 
final public function verify ( string $ expected , string $ payload , Key $ key ) : bool { return hash_equals ( $ expected , $ this -> sign ( $ payload , $ key ) ) ; } 
public function assert ( Token $ token ) : void { $ now = $ this -> clock -> now ( ) ; $ this -> assertIssueTime ( $ token , $ now -> add ( $ this -> leeway ) ) ; $ this -> assertMinimumTime ( $ token , $ now -> add ( $ this -> leeway ) ) ; $ this -> assertExpiration ( $ token , $ now -> sub ( $ this -> leeway ) ) ; } 
public function assert ( Token $ token ) : void { if ( ! $ token instanceof Token \ Plain ) { throw new ConstraintViolation ( 'You should pass a plain token' ) ; } if ( $ token -> headers ( ) -> get ( 'alg' ) !== $ this -> signer -> getAlgorithmId ( ) ) { throw new ConstraintViolation ( 'Token signer mismatch' ) ; } if ( ! $ this -> signer -> verify ( $ token -> signature ( ) -> hash ( ) , $ token -> payload ( ) , $ this -> key ) ) { throw new ConstraintViolation ( 'Token signature mismatch' ) ; } } 
public function parse ( string $ jwt ) : TokenInterface { [ $ encodedHeaders , $ encodedClaims , $ encodedSignature ] = $ this -> splitJwt ( $ jwt ) ; $ header = $ this -> parseHeader ( $ encodedHeaders ) ; return new Plain ( new DataSet ( $ header , $ encodedHeaders ) , new DataSet ( $ this -> parseClaims ( $ encodedClaims ) , $ encodedClaims ) , $ this -> parseSignature ( $ header , $ encodedSignature ) ) ; } 
private function splitJwt ( string $ jwt ) : array { $ data = explode ( '.' , $ jwt ) ; if ( count ( $ data ) !== 3 ) { throw new InvalidArgumentException ( 'The JWT string must have two dots' ) ; } return $ data ; } 
private function parseHeader ( string $ data ) : array { $ header = $ this -> decoder -> jsonDecode ( $ this -> decoder -> base64UrlDecode ( $ data ) ) ; if ( ! is_array ( $ header ) ) { throw new InvalidArgumentException ( 'Headers must be an array' ) ; } if ( isset ( $ header [ 'enc' ] ) ) { throw new InvalidArgumentException ( 'Encryption is not supported yet' ) ; } if ( ! isset ( $ header [ 'typ' ] ) ) { throw new InvalidArgumentException ( 'The header "typ" must be present' ) ; } return $ header ; } 
private function parseClaims ( string $ data ) : array { $ claims = $ this -> decoder -> jsonDecode ( $ this -> decoder -> base64UrlDecode ( $ data ) ) ; if ( ! is_array ( $ claims ) ) { throw new InvalidArgumentException ( 'Claims must be an array' ) ; } if ( isset ( $ claims [ RegisteredClaims :: AUDIENCE ] ) ) { $ claims [ RegisteredClaims :: AUDIENCE ] = ( array ) $ claims [ RegisteredClaims :: AUDIENCE ] ; } foreach ( array_intersect ( RegisteredClaims :: DATE_CLAIMS , array_keys ( $ claims ) ) as $ claim ) { $ claims [ $ claim ] = $ this -> convertDate ( ( string ) $ claims [ $ claim ] ) ; } return $ claims ; } 
private function parseSignature ( array $ header , string $ data ) : Signature { if ( $ data === '' || ! isset ( $ header [ 'alg' ] ) || $ header [ 'alg' ] === 'none' ) { return Signature :: fromEmptyData ( ) ; } $ hash = $ this -> decoder -> base64UrlDecode ( $ data ) ; return new Signature ( $ hash , $ data ) ; } 
public function isPermittedFor ( string $ audience ) : bool { return in_array ( $ audience , $ this -> claims -> get ( RegisteredClaims :: AUDIENCE , [ ] ) , true ) ; } 
public function isIdentifiedBy ( string $ id ) : bool { return $ this -> claims -> get ( RegisteredClaims :: ID ) === $ id ; } 
public function isRelatedTo ( string $ subject ) : bool { return $ this -> claims -> get ( RegisteredClaims :: SUBJECT ) === $ subject ; } 
public function hasBeenIssuedBy ( string ... $ issuers ) : bool { return in_array ( $ this -> claims -> get ( RegisteredClaims :: ISSUER ) , $ issuers , true ) ; } 
public function hasBeenIssuedBefore ( DateTimeInterface $ now ) : bool { return $ now >= $ this -> claims -> get ( RegisteredClaims :: ISSUED_AT ) ; } 
public function isMinimumTimeBefore ( DateTimeInterface $ now ) : bool { return $ now >= $ this -> claims -> get ( RegisteredClaims :: NOT_BEFORE ) ; } 
public function isExpired ( DateTimeInterface $ now ) : bool { if ( ! $ this -> claims -> has ( RegisteredClaims :: EXPIRATION_TIME ) ) { return false ; } return $ now > $ this -> claims -> get ( RegisteredClaims :: EXPIRATION_TIME ) ; } 
public function handle ( $ request , Closure $ next ) { 
public function handle ( $ request , Closure $ next ) { 
public function handle ( ) { foreach ( $ this -> getSupportedLocales ( ) as $ locale ) { $ path = $ this -> makeLocaleRoutesPath ( $ locale ) ; if ( $ this -> files -> exists ( $ path ) ) { $ this -> files -> delete ( $ path ) ; } } $ path = $ this -> laravel -> getCachedRoutesPath ( ) ; if ( $ this -> files -> exists ( $ path ) ) { $ this -> files -> delete ( $ path ) ; } $ this -> info ( 'Route caches for locales cleared!' ) ; } 
public function negotiateLanguage ( ) { $ matches = $ this -> getMatchesFromAcceptedLanguages ( ) ; foreach ( $ matches as $ key => $ q ) { $ key = ( $ this -> configRepository -> get ( 'laravellocalization.localesMapping' ) [ $ key ] ) ?? $ key ; if ( ! empty ( $ this -> supportedLanguages [ $ key ] ) ) { return $ key ; } if ( $ this -> use_intl ) { $ key = Locale :: canonicalize ( $ key ) ; } 
private function getMatchesFromAcceptedLanguages ( ) { $ matches = [ ] ; if ( $ acceptLanguages = $ this -> request -> header ( 'Accept-Language' ) ) { $ acceptLanguages = explode ( ',' , $ acceptLanguages ) ; $ generic_matches = [ ] ; foreach ( $ acceptLanguages as $ option ) { $ option = array_map ( 'trim' , explode ( ';' , $ option ) ) ; $ l = $ option [ 0 ] ; if ( isset ( $ option [ 1 ] ) ) { $ q = ( float ) str_replace ( 'q=' , '' , $ option [ 1 ] ) ; } else { $ q = null ; 
protected function cacheRoutesPerLocale ( ) { 
protected function getFreshApplicationRoutes ( $ locale = null ) { $ app = require $ this -> getBootstrapPath ( ) . '/app.php' ; if ( null !== $ locale ) { $ key = LaravelLocalization :: ENV_ROUTE_KEY ; putenv ( "{$key}={$locale}" ) ; $ app -> make ( Kernel :: class ) -> bootstrap ( ) ; putenv ( "{$key}=" ) ; } else { $ app -> make ( Kernel :: class ) -> bootstrap ( ) ; } return $ app [ 'router' ] -> getRoutes ( ) ; } 
protected function buildRouteCacheFile ( RouteCollection $ routes ) { $ stub = $ this -> files -> get ( realpath ( __DIR__ . DIRECTORY_SEPARATOR . '..' . DIRECTORY_SEPARATOR . '..' . DIRECTORY_SEPARATOR . '..' . DIRECTORY_SEPARATOR . 'stubs' . DIRECTORY_SEPARATOR . 'routes.stub' ) ) ; return str_replace ( [ '{{routes}}' , '{{translatedRoutes}}' , ] , [ base64_encode ( serialize ( $ routes ) ) , $ this -> getLaravelLocalization ( ) -> getSerializedTranslatedRoutes ( ) , ] , $ stub ) ; } 
public function register ( ) { $ packageConfigFile = __DIR__ . '/../../config/config.php' ; $ this -> mergeConfigFrom ( $ packageConfigFile , 'laravellocalization' ) ; $ this -> registerBindings ( ) ; $ this -> registerCommands ( ) ; } 
protected function registerBindings ( ) { $ this -> app -> singleton ( LaravelLocalization :: class , function ( ) { return new LaravelLocalization ( ) ; } ) ; $ this -> app -> alias ( LaravelLocalization :: class , 'laravellocalization' ) ; } 
protected function registerCommands ( ) { $ this -> app -> singleton ( 'laravellocalizationroutecache.cache' , Commands \ RouteTranslationsCacheCommand :: class ) ; $ this -> app -> singleton ( 'laravellocalizationroutecache.clear' , Commands \ RouteTranslationsClearCommand :: class ) ; $ this -> app -> singleton ( 'laravellocalizationroutecache.list' , Commands \ RouteTranslationsListCommand :: class ) ; $ this -> commands ( [ 'laravellocalizationroutecache.cache' , 'laravellocalizationroutecache.clear' , 'laravellocalizationroutecache.list' , ] ) ; } 
public function handle ( $ request , Closure $ next ) { 
public function setLocale ( $ locale = null ) { if ( empty ( $ locale ) || ! \ is_string ( $ locale ) ) { 
public function getLocalizedURL ( $ locale = null , $ url = null , $ attributes = [ ] , $ forceDefaultLocation = false ) { if ( $ locale === null ) { $ locale = $ this -> getCurrentLocale ( ) ; } if ( ! $ this -> checkLocaleInSupportedLocales ( $ locale ) ) { throw new UnsupportedLocaleException ( 'Locale \'' . $ locale . '\' is not in the list of supported locales.' ) ; } if ( empty ( $ attributes ) ) { $ attributes = $ this -> extractAttributes ( $ url , $ locale ) ; } $ urlQuery = parse_url ( $ url , PHP_URL_QUERY ) ; $ urlQuery = $ urlQuery ? '?' . $ urlQuery : '' ; if ( empty ( $ url ) ) { if ( ! empty ( $ this -> routeName ) ) { return $ this -> getURLFromRouteNameTranslated ( $ locale , $ this -> routeName , $ attributes , $ forceDefaultLocation ) ; } $ url = $ this -> request -> fullUrl ( ) ; } else { $ url = $ this -> url -> to ( $ url ) ; $ url = preg_replace ( '/' . preg_quote ( $ urlQuery , '/' ) . '$/' , '' , $ url ) ; } if ( $ locale && $ translatedRoute = $ this -> findTranslatedRouteByUrl ( $ url , $ attributes , $ this -> currentLocale ) ) { return $ this -> getURLFromRouteNameTranslated ( $ locale , $ translatedRoute , $ attributes , $ forceDefaultLocation ) . $ urlQuery ; } $ base_path = $ this -> request -> getBaseUrl ( ) ; $ parsed_url = parse_url ( $ url ) ; $ url_locale = $ this -> getDefaultLocale ( ) ; if ( ! $ parsed_url || empty ( $ parsed_url [ 'path' ] ) ) { $ path = $ parsed_url [ 'path' ] = '' ; } else { $ parsed_url [ 'path' ] = str_replace ( $ base_path , '' , '/' . ltrim ( $ parsed_url [ 'path' ] , '/' ) ) ; $ path = $ parsed_url [ 'path' ] ; foreach ( $ this -> getSupportedLocales ( ) as $ localeCode => $ lang ) { $ parsed_url [ 'path' ] = preg_replace ( '%^/?' . $ localeCode . '/%' , '$1' , $ parsed_url [ 'path' ] ) ; if ( $ parsed_url [ 'path' ] !== $ path ) { $ url_locale = $ localeCode ; break ; } $ parsed_url [ 'path' ] = preg_replace ( '%^/?' . $ localeCode . '$%' , '$1' , $ parsed_url [ 'path' ] ) ; if ( $ parsed_url [ 'path' ] !== $ path ) { $ url_locale = $ localeCode ; break ; } } } $ parsed_url [ 'path' ] = ltrim ( $ parsed_url [ 'path' ] , '/' ) ; if ( $ translatedRoute = $ this -> findTranslatedRouteByPath ( $ parsed_url [ 'path' ] , $ url_locale ) ) { return $ this -> getURLFromRouteNameTranslated ( $ locale , $ translatedRoute , $ attributes , $ forceDefaultLocation ) . $ urlQuery ; } if ( ! empty ( $ locale ) ) { if ( $ forceDefaultLocation || $ locale != $ this -> getDefaultLocale ( ) || ! $ this -> hideDefaultLocaleInURL ( ) ) { $ parsed_url [ 'path' ] = $ locale . '/' . ltrim ( $ parsed_url [ 'path' ] , '/' ) ; } } $ parsed_url [ 'path' ] = ltrim ( ltrim ( $ base_path , '/' ) . '/' . $ parsed_url [ 'path' ] , '/' ) ; 
public function getURLFromRouteNameTranslated ( $ locale , $ transKeyName , $ attributes = [ ] , $ forceDefaultLocation = false ) { if ( ! $ this -> checkLocaleInSupportedLocales ( $ locale ) ) { throw new UnsupportedLocaleException ( 'Locale \'' . $ locale . '\' is not in the list of supported locales.' ) ; } if ( ! \ is_string ( $ locale ) ) { $ locale = $ this -> getDefaultLocale ( ) ; } $ route = '' ; if ( $ forceDefaultLocation || ! ( $ locale === $ this -> defaultLocale && $ this -> hideDefaultLocaleInURL ( ) ) ) { $ route = '/' . $ locale ; } if ( \ is_string ( $ locale ) && $ this -> translator -> has ( $ transKeyName , $ locale ) ) { $ translation = $ this -> translator -> trans ( $ transKeyName , [ ] , $ locale ) ; $ route .= '/' . $ translation ; $ route = $ this -> substituteAttributesInRoute ( $ attributes , $ route ) ; } if ( empty ( $ route ) ) { 
public function getSupportedLocales ( ) { if ( ! empty ( $ this -> supportedLocales ) ) { return $ this -> supportedLocales ; } $ locales = $ this -> configRepository -> get ( 'laravellocalization.supportedLocales' ) ; if ( empty ( $ locales ) || ! \ is_array ( $ locales ) ) { throw new SupportedLocalesNotDefined ( ) ; } $ this -> supportedLocales = $ locales ; return $ locales ; } 
public function getLocalesOrder ( ) { $ locales = $ this -> getSupportedLocales ( ) ; $ order = $ this -> configRepository -> get ( 'laravellocalization.localesOrder' ) ; uksort ( $ locales , function ( $ a , $ b ) use ( $ order ) { $ pos_a = array_search ( $ a , $ order ) ; $ pos_b = array_search ( $ b , $ order ) ; return $ pos_a - $ pos_b ; } ) ; return $ locales ; } 
public function getCurrentLocaleDirection ( ) { if ( ! empty ( $ this -> supportedLocales [ $ this -> getCurrentLocale ( ) ] [ 'dir' ] ) ) { return $ this -> supportedLocales [ $ this -> getCurrentLocale ( ) ] [ 'dir' ] ; } switch ( $ this -> getCurrentLocaleScript ( ) ) { 
public function getCurrentLocale ( ) { if ( $ this -> currentLocale ) { return $ this -> currentLocale ; } if ( $ this -> useAcceptLanguageHeader ( ) && ! $ this -> app -> runningInConsole ( ) ) { $ negotiator = new LanguageNegotiator ( $ this -> defaultLocale , $ this -> getSupportedLocales ( ) , $ this -> request ) ; return $ negotiator -> negotiateLanguage ( ) ; } 
public function getCurrentLocaleRegional ( ) { 
public function checkLocaleInSupportedLocales ( $ locale ) { $ locales = $ this -> getSupportedLocales ( ) ; if ( $ locale !== false && empty ( $ locales [ $ locale ] ) ) { return false ; } return true ; } 
protected function substituteAttributesInRoute ( $ attributes , $ route ) { foreach ( $ attributes as $ key => $ value ) { if ( $ value instanceOf UrlRoutable ) { $ value = $ value -> getRouteKey ( ) ; } $ route = str_replace ( array ( '{' . $ key . '}' , '{' . $ key . '?}' ) , $ value , $ route ) ; } 
public function transRoute ( $ routeName ) { if ( ! \ in_array ( $ routeName , $ this -> translatedRoutes ) ) { $ this -> translatedRoutes [ ] = $ routeName ; } return $ this -> translator -> trans ( $ routeName ) ; } 
public function getRouteNameFromAPath ( $ path ) { $ attributes = $ this -> extractAttributes ( $ path ) ; $ path = parse_url ( $ path ) [ 'path' ] ; $ path = trim ( str_replace ( '/' . $ this -> currentLocale . '/' , '' , $ path ) , "/" ) ; foreach ( $ this -> translatedRoutes as $ route ) { if ( trim ( $ this -> substituteAttributesInRoute ( $ attributes , $ this -> translator -> trans ( $ route ) ) , '/' ) === $ path ) { return $ route ; } } return false ; } 
protected function findTranslatedRouteByPath ( $ path , $ url_locale ) { 
protected function findTranslatedRouteByUrl ( $ url , $ attributes , $ locale ) { if ( empty ( $ url ) ) { return false ; } if ( isset ( $ this -> cachedTranslatedRoutesByUrl [ $ locale ] [ $ url ] ) ) { return $ this -> cachedTranslatedRoutesByUrl [ $ locale ] [ $ url ] ; } 
public function createUrlFromUri ( $ uri ) { $ uri = ltrim ( $ uri , '/' ) ; if ( empty ( $ this -> baseUrl ) ) { return app ( 'url' ) -> to ( $ uri ) ; } return $ this -> baseUrl . $ uri ; } 
protected function extractAttributes ( $ url = false , $ locale = '' ) { if ( ! empty ( $ url ) ) { $ attributes = [ ] ; $ parse = parse_url ( $ url ) ; if ( isset ( $ parse [ 'path' ] ) ) { $ parse [ 'path' ] = trim ( str_replace ( '/' . $ this -> currentLocale . '/' , '' , $ parse [ 'path' ] ) , "/" ) ; $ url = explode ( '/' , trim ( $ parse [ 'path' ] , '/' ) ) ; } else { $ url = [ ] ; } foreach ( $ this -> router -> getRoutes ( ) as $ route ) { $ attributes = [ ] ; $ path = method_exists ( $ route , 'uri' ) ? $ route -> uri ( ) : $ route -> getUri ( ) ; if ( ! preg_match ( "/{[\w]+\??}/" , $ path ) ) { continue ; } $ path = explode ( '/' , $ path ) ; $ i = 0 ; 
protected function normalizeAttributes ( $ attributes ) { if ( array_key_exists ( 'data' , $ attributes ) && \ is_array ( $ attributes [ 'data' ] ) && ! \ count ( $ attributes [ 'data' ] ) ) { $ attributes [ 'data' ] = null ; return $ attributes ; } return $ attributes ; } 
protected function loadCachedRoutes ( ) { $ localization = $ this -> getLaravelLocalization ( ) ; $ localization -> setLocale ( ) ; $ locale = $ localization -> getCurrentLocale ( ) ; $ localeKeys = $ localization -> getSupportedLanguagesKeys ( ) ; 
protected function makeLocaleRoutesPath ( $ locale , $ localeKeys ) { $ path = $ this -> getDefaultCachedRoutePath ( ) ; $ localeSegment = request ( ) -> segment ( 1 ) ; if ( ! $ localeSegment || ! in_array ( $ localeSegment , $ localeKeys ) ) { return $ path ; } return substr ( $ path , 0 , - 4 ) . '_' . $ locale . '.php' ; } 
public function handle ( $ request , Closure $ next ) { 
public function handle ( ) { if ( count ( $ this -> routes ) == 0 ) { $ this -> error ( "Your application doesn't have any routes." ) ; return ; } $ locale = $ this -> argument ( 'locale' ) ; if ( ! $ this -> isSupportedLocale ( $ locale ) ) { $ this -> error ( "Unsupported locale: '{$locale}'." ) ; return ; } $ this -> routes = $ this -> getFreshApplicationRoutes ( $ locale ) ; $ this -> displayRoutes ( $ this -> getRoutes ( ) ) ; } 
protected function getFreshApplicationRoutes ( $ locale ) { $ app = require $ this -> getBootstrapPath ( ) . '/app.php' ; $ key = LaravelLocalization :: ENV_ROUTE_KEY ; putenv ( "{$key}={$locale}" ) ; $ app -> make ( Kernel :: class ) -> bootstrap ( ) ; putenv ( "{$key}=" ) ; return $ app [ 'router' ] -> getRoutes ( ) ; } 
public function handle ( $ request , Closure $ next ) { 
public function encode ( array $ payloads = [ ] ) : string { if ( ! isset ( $ payloads [ 'group_id' ] ) ) { throw new ProtocolException ( 'given heartbeat data invalid. `group_id` is undefined.' ) ; } if ( ! isset ( $ payloads [ 'generation_id' ] ) ) { throw new ProtocolException ( 'given heartbeat data invalid. `generation_id` is undefined.' ) ; } if ( ! isset ( $ payloads [ 'member_id' ] ) ) { throw new ProtocolException ( 'given heartbeat data invalid. `member_id` is undefined.' ) ; } $ header = $ this -> requestHeader ( 'kafka-php' , self :: HEART_BEAT_REQUEST , self :: HEART_BEAT_REQUEST ) ; $ data = self :: encodeString ( $ payloads [ 'group_id' ] , self :: PACK_INT16 ) ; $ data .= self :: pack ( self :: BIT_B32 , ( string ) $ payloads [ 'generation_id' ] ) ; $ data .= self :: encodeString ( $ payloads [ 'member_id' ] , self :: PACK_INT16 ) ; $ data = self :: encodeString ( $ header . $ data , self :: PACK_INT32 ) ; return $ data ; } 
public function emergency ( string $ message , array $ context = [ ] ) : void { $ this -> log ( LogLevel :: EMERGENCY , $ message , $ context ) ; } 
public function alert ( string $ message , array $ context = [ ] ) : void { $ this -> log ( LogLevel :: ALERT , $ message , $ context ) ; } 
public function critical ( string $ message , array $ context = [ ] ) : void { $ this -> log ( LogLevel :: CRITICAL , $ message , $ context ) ; } 
public function error ( string $ message , array $ context = [ ] ) : void { $ this -> log ( LogLevel :: ERROR , $ message , $ context ) ; } 
public function warning ( string $ message , array $ context = [ ] ) : void { $ this -> log ( LogLevel :: WARNING , $ message , $ context ) ; } 
public function log ( $ level , $ message , array $ context = [ ] ) : void { if ( $ this -> logger === null ) { $ this -> logger = new NullLogger ( ) ; } $ this -> logger -> log ( $ level , $ message , $ context ) ; } 
protected function processRequest ( string $ data , int $ fd ) : void { $ correlationId = Protocol \ Protocol :: unpack ( Protocol \ Protocol :: BIT_B32 , substr ( $ data , 0 , 4 ) ) ; switch ( $ correlationId ) { case Protocol :: METADATA_REQUEST : $ result = Protocol :: decode ( Protocol :: METADATA_REQUEST , substr ( $ data , 4 ) ) ; if ( ! isset ( $ result [ 'brokers' ] , $ result [ 'topics' ] ) ) { $ this -> error ( 'Get metadata is fail, brokers or topics is null.' ) ; $ this -> state -> failRun ( State :: REQUEST_METADATA ) ; break ; } $ broker = $ this -> getBroker ( ) ; $ isChange = $ broker -> setData ( $ result [ 'topics' ] , $ result [ 'brokers' ] ) ; $ this -> state -> succRun ( State :: REQUEST_METADATA , $ isChange ) ; break ; case Protocol :: PRODUCE_REQUEST : $ result = Protocol :: decode ( Protocol :: PRODUCE_REQUEST , substr ( $ data , 4 ) ) ; $ this -> succProduce ( $ result , $ fd ) ; break ; default : $ this -> error ( 'Error request, correlationId:' . $ correlationId ) ; } } 
protected function convertRecordSet ( array $ recordSet ) : array { $ sendData = [ ] ; $ broker = $ this -> getBroker ( ) ; $ topics = $ broker -> getTopics ( ) ; foreach ( $ recordSet as $ record ) { $ this -> recordValidator -> validate ( $ record , $ topics ) ; $ topicMeta = $ topics [ $ record [ 'topic' ] ] ; $ partNums = array_keys ( $ topicMeta ) ; shuffle ( $ partNums ) ; $ partId = ! isset ( $ record [ 'partId' ] , $ topicMeta [ $ record [ 'partId' ] ] ) ? $ partNums [ 0 ] : $ record [ 'partId' ] ; $ brokerId = $ topicMeta [ $ partId ] ; $ topicData = [ ] ; if ( isset ( $ sendData [ $ brokerId ] [ $ record [ 'topic' ] ] ) ) { $ topicData = $ sendData [ $ brokerId ] [ $ record [ 'topic' ] ] ; } $ partition = [ ] ; if ( isset ( $ topicData [ 'partitions' ] [ $ partId ] ) ) { $ partition = $ topicData [ 'partitions' ] [ $ partId ] ; } $ partition [ 'partition_id' ] = $ partId ; if ( trim ( $ record [ 'key' ] ?? '' ) !== '' ) { $ partition [ 'messages' ] [ ] = [ 'value' => $ record [ 'value' ] , 'key' => $ record [ 'key' ] ] ; } else { $ partition [ 'messages' ] [ ] = $ record [ 'value' ] ; } $ topicData [ 'partitions' ] [ $ partId ] = $ partition ; $ topicData [ 'topic_name' ] = $ record [ 'topic' ] ; $ sendData [ $ brokerId ] [ $ record [ 'topic' ] ] = $ topicData ; } return $ sendData ; } 
public function read ( $ data ) : void { $ this -> readBuffer .= ( string ) $ data ; do { if ( $ this -> readNeedLength === 0 ) { 
public function write ( ? string $ data = null ) : void { if ( $ data !== null ) { $ this -> writeBuffer .= $ data ; } $ bytesToWrite = strlen ( $ this -> writeBuffer ) ; $ bytesWritten = @ fwrite ( $ this -> stream , $ this -> writeBuffer ) ; if ( $ bytesToWrite === $ bytesWritten ) { Loop :: disable ( $ this -> writeWatcherId ) ; } elseif ( $ bytesWritten >= 0 ) { Loop :: enable ( $ this -> writeWatcherId ) ; } elseif ( $ this -> isSocketDead ( ) ) { $ this -> reconnect ( ) ; } $ this -> writeBuffer = substr ( $ this -> writeBuffer , $ bytesWritten ) ; } 
public function encode ( array $ payloads = [ ] ) : string { if ( ! isset ( $ payloads [ 'data' ] ) ) { throw new ProtocolException ( 'given procude data invalid. `data` is undefined.' ) ; } $ header = $ this -> requestHeader ( 'kafka-php' , 0 , self :: PRODUCE_REQUEST ) ; $ data = self :: pack ( self :: BIT_B16 , ( string ) ( $ payloads [ 'required_ack' ] ?? 0 ) ) ; $ data .= self :: pack ( self :: BIT_B32 , ( string ) ( $ payloads [ 'timeout' ] ?? 100 ) ) ; $ data .= self :: encodeArray ( $ payloads [ 'data' ] , [ $ this , 'encodeProduceTopic' ] , $ payloads [ 'compression' ] ?? self :: COMPRESSION_NONE ) ; return self :: encodeString ( $ header . $ data , self :: PACK_INT32 ) ; } 
public function decode ( string $ data ) : array { $ offset = 0 ; $ version = $ this -> getApiVersion ( self :: PRODUCE_REQUEST ) ; $ ret = $ this -> decodeArray ( substr ( $ data , $ offset ) , [ $ this , 'produceTopicPair' ] , $ version ) ; $ offset += $ ret [ 'length' ] ; $ throttleTime = 0 ; if ( $ version === self :: API_VERSION2 ) { $ throttleTime = self :: unpack ( self :: BIT_B32 , substr ( $ data , $ offset , 4 ) ) ; } return [ 'throttleTime' => $ throttleTime , 'data' => $ ret [ 'data' ] ] ; } 
protected function encodeMessageSet ( array $ messages , int $ compression = self :: COMPRESSION_NONE ) : string { $ data = '' ; $ next = 0 ; foreach ( $ messages as $ message ) { $ encodedMessage = $ this -> encodeMessage ( $ message ) ; $ data .= self :: pack ( self :: BIT_B64 , ( string ) $ next ) . self :: encodeString ( $ encodedMessage , self :: PACK_INT32 ) ; ++ $ next ; } if ( $ compression === self :: COMPRESSION_NONE ) { return $ data ; } return self :: pack ( self :: BIT_B64 , '0' ) . self :: encodeString ( $ this -> encodeMessage ( $ data , $ compression ) , self :: PACK_INT32 ) ; } 
protected function encodeMessage ( $ message , int $ compression = self :: COMPRESSION_NONE ) : string { $ magic = $ this -> computeMagicByte ( ) ; $ attributes = $ this -> computeAttributes ( $ magic , $ compression , $ this -> computeTimestampType ( $ magic ) ) ; $ data = self :: pack ( self :: BIT_B8 , ( string ) $ magic ) ; $ data .= self :: pack ( self :: BIT_B8 , ( string ) $ attributes ) ; if ( $ magic >= self :: MESSAGE_MAGIC_VERSION1 ) { $ data .= self :: pack ( self :: BIT_B64 , $ this -> clock -> now ( ) -> format ( 'Uv' ) ) ; } $ key = '' ; if ( is_array ( $ message ) ) { $ key = $ message [ 'key' ] ; $ message = $ message [ 'value' ] ; } 
protected function encodeProducePartition ( array $ values , int $ compression ) : string { if ( ! isset ( $ values [ 'partition_id' ] ) ) { throw new ProtocolException ( 'given produce data invalid. `partition_id` is undefined.' ) ; } if ( ! isset ( $ values [ 'messages' ] ) || empty ( $ values [ 'messages' ] ) ) { throw new ProtocolException ( 'given produce data invalid. `messages` is undefined.' ) ; } $ data = self :: pack ( self :: BIT_B32 , ( string ) $ values [ 'partition_id' ] ) ; $ data .= self :: encodeString ( $ this -> encodeMessageSet ( ( array ) $ values [ 'messages' ] , $ compression ) , self :: PACK_INT32 ) ; return $ data ; } 
protected function encodeProduceTopic ( array $ values , int $ compression ) : string { if ( ! isset ( $ values [ 'topic_name' ] ) ) { throw new ProtocolException ( 'given produce data invalid. `topic_name` is undefined.' ) ; } if ( ! isset ( $ values [ 'partitions' ] ) || empty ( $ values [ 'partitions' ] ) ) { throw new ProtocolException ( 'given produce data invalid. `partitions` is undefined.' ) ; } $ topic = self :: encodeString ( $ values [ 'topic_name' ] , self :: PACK_INT16 ) ; $ partitions = self :: encodeArray ( $ values [ 'partitions' ] , [ $ this , 'encodeProducePartition' ] , $ compression ) ; return $ topic . $ partitions ; } 
protected function produceTopicPair ( string $ data , int $ version ) : array { $ offset = 0 ; $ topicInfo = $ this -> decodeString ( $ data , self :: BIT_B16 ) ; $ offset += $ topicInfo [ 'length' ] ; $ ret = $ this -> decodeArray ( substr ( $ data , $ offset ) , [ $ this , 'producePartitionPair' ] , $ version ) ; $ offset += $ ret [ 'length' ] ; return [ 'length' => $ offset , 'data' => [ 'topicName' => $ topicInfo [ 'data' ] , 'partitions' => $ ret [ 'data' ] , ] , ] ; } 
protected function producePartitionPair ( string $ data , int $ version ) : array { $ offset = 0 ; $ partitionId = self :: unpack ( self :: BIT_B32 , substr ( $ data , $ offset , 4 ) ) ; $ offset += 4 ; $ errorCode = self :: unpack ( self :: BIT_B16_SIGNED , substr ( $ data , $ offset , 2 ) ) ; $ offset += 2 ; $ partitionOffset = self :: unpack ( self :: BIT_B64 , substr ( $ data , $ offset , 8 ) ) ; $ offset += 8 ; $ timestamp = 0 ; if ( $ version === self :: API_VERSION2 ) { $ timestamp = self :: unpack ( self :: BIT_B64 , substr ( $ data , $ offset , 8 ) ) ; $ offset += 8 ; } return [ 'length' => $ offset , 'data' => [ 'partition' => $ partitionId , 'errorCode' => $ errorCode , 'offset' => $ offset , 'timestamp' => $ timestamp , ] , ] ; } 
public function send ( $ data = true ) : ? array { if ( $ this -> logger ) { $ this -> process -> setLogger ( $ this -> logger ) ; } if ( is_array ( $ data ) ) { return $ this -> sendSynchronously ( $ data ) ; } $ this -> sendAsynchronously ( $ data ) ; return null ; } 
private function sendSynchronously ( array $ data ) : array { if ( ! $ this -> process instanceof SyncProcess ) { throw new Exception ( 'An asynchronous process is not able to send messages synchronously' ) ; } return $ this -> process -> send ( $ data ) ; } 
public function encode ( array $ payloads = [ ] ) : string { if ( ! isset ( $ payloads [ 'data' ] ) ) { throw new ProtocolException ( 'given fetch offset data invalid. `data` is undefined.' ) ; } if ( ! isset ( $ payloads [ 'group_id' ] ) ) { throw new ProtocolException ( 'given fetch offset data invalid. `group_id` is undefined.' ) ; } $ header = $ this -> requestHeader ( 'kafka-php' , self :: OFFSET_FETCH_REQUEST , self :: OFFSET_FETCH_REQUEST ) ; $ data = self :: encodeString ( $ payloads [ 'group_id' ] , self :: PACK_INT16 ) ; $ data .= self :: encodeArray ( $ payloads [ 'data' ] , [ $ this , 'encodeOffsetTopic' ] ) ; $ data = self :: encodeString ( $ header . $ data , self :: PACK_INT32 ) ; return $ data ; } 
public function encode ( array $ payloads = [ ] ) : string { $ header = $ this -> requestHeader ( 'kafka-php' , self :: DESCRIBE_GROUPS_REQUEST , self :: DESCRIBE_GROUPS_REQUEST ) ; $ data = self :: encodeArray ( $ payloads , [ $ this , 'encodeString' ] , self :: PACK_INT16 ) ; return self :: encodeString ( $ header . $ data , self :: PACK_INT32 ) ; } 
public function send ( array $ recordSet ) : array { $ broker = $ this -> getBroker ( ) ; $ config = $ this -> getConfig ( ) ; $ requiredAck = $ config -> getRequiredAck ( ) ; $ timeout = $ config -> getTimeout ( ) ; $ compression = $ config -> getCompression ( ) ; 
public function encode ( array $ payloads = [ ] ) : string { if ( ! isset ( $ payloads [ 'data' ] ) ) { throw new ProtocolException ( 'given fetch kafka data invalid. `data` is undefined.' ) ; } if ( ! isset ( $ payloads [ 'replica_id' ] ) ) { $ payloads [ 'replica_id' ] = - 1 ; } if ( ! isset ( $ payloads [ 'max_wait_time' ] ) ) { $ payloads [ 'max_wait_time' ] = 100 ; 
protected function fetchPartition ( string $ data ) : array { $ offset = 0 ; $ partitionId = self :: unpack ( self :: BIT_B32 , substr ( $ data , $ offset , 4 ) ) ; $ offset += 4 ; $ errorCode = self :: unpack ( self :: BIT_B16_SIGNED , substr ( $ data , $ offset , 2 ) ) ; $ offset += 2 ; $ highwaterMarkOffset = self :: unpack ( self :: BIT_B64 , substr ( $ data , $ offset , 8 ) ) ; $ offset += 8 ; $ messageSetSize = self :: unpack ( self :: BIT_B32 , substr ( $ data , $ offset , 4 ) ) ; $ offset += 4 ; $ messages = [ ] ; if ( $ messageSetSize > 0 && $ offset < strlen ( $ data ) ) { $ messages = $ this -> decodeMessageSetArray ( substr ( $ data , $ offset , $ messageSetSize ) , $ messageSetSize ) ; $ offset += $ messages [ 'length' ] ; } return [ 'length' => $ offset , 'data' => [ 'partition' => $ partitionId , 'errorCode' => $ errorCode , 'highwaterMarkOffset' => $ highwaterMarkOffset , 'messageSetSize' => $ messageSetSize , 'messages' => $ messages [ 'data' ] ?? [ ] , ] , ] ; } 
protected function decodeMessageSetArray ( string $ data , int $ messageSetSize ) : array { $ offset = 0 ; $ result = [ ] ; while ( $ offset < strlen ( $ data ) ) { $ value = substr ( $ data , $ offset ) ; $ ret = $ this -> decodeMessageSet ( $ value ) ; if ( $ ret === null ) { break ; } if ( ! isset ( $ ret [ 'length' ] , $ ret [ 'data' ] ) ) { throw new ProtocolException ( 'Decode array failed, given function return format is invalid' ) ; } if ( ( int ) $ ret [ 'length' ] === 0 ) { continue ; } $ offset += $ ret [ 'length' ] ; if ( ( $ ret [ 'data' ] [ 'message' ] [ 'attr' ] & Produce :: COMPRESSION_CODEC_MASK ) === Produce :: COMPRESSION_NONE ) { $ result [ ] = $ ret [ 'data' ] ; continue ; } $ innerMessages = $ this -> decodeMessageSetArray ( $ ret [ 'data' ] [ 'message' ] [ 'value' ] , $ ret [ 'length' ] ) ; $ result = array_merge ( $ result , $ innerMessages [ 'data' ] ) ; } if ( $ offset < $ messageSetSize ) { $ offset = $ messageSetSize ; } return [ 'length' => $ offset , 'data' => $ result ] ; } 
protected function decodeMessageSet ( string $ data ) : ? array { if ( strlen ( $ data ) <= 12 ) { return null ; } $ offset = 0 ; $ roffset = self :: unpack ( self :: BIT_B64 , substr ( $ data , $ offset , 8 ) ) ; $ offset += 8 ; $ messageSize = self :: unpack ( self :: BIT_B32 , substr ( $ data , $ offset , 4 ) ) ; $ offset += 4 ; $ ret = $ this -> decodeMessage ( substr ( $ data , $ offset ) , $ messageSize ) ; if ( $ ret === null ) { return null ; } $ offset += $ ret [ 'length' ] ; return [ 'length' => $ offset , 'data' => [ 'offset' => $ roffset , 'size' => $ messageSize , 'message' => $ ret [ 'data' ] , ] , ] ; } 
protected function decodeMessage ( string $ data , int $ messageSize ) : ? array { if ( $ messageSize === 0 || strlen ( $ data ) < $ messageSize ) { return null ; } $ offset = 0 ; $ crc = self :: unpack ( self :: BIT_B32 , substr ( $ data , $ offset , 4 ) ) ; $ offset += 4 ; $ magic = self :: unpack ( self :: BIT_B8 , substr ( $ data , $ offset , 1 ) ) ; ++ $ offset ; $ attr = self :: unpack ( self :: BIT_B8 , substr ( $ data , $ offset , 1 ) ) ; ++ $ offset ; $ timestamp = 0 ; $ backOffset = $ offset ; try { 
protected function encodeFetchPartition ( array $ values ) : string { if ( ! isset ( $ values [ 'partition_id' ] ) ) { throw new ProtocolException ( 'given fetch data invalid. `partition_id` is undefined.' ) ; } if ( ! isset ( $ values [ 'offset' ] ) ) { $ values [ 'offset' ] = 0 ; } if ( ! isset ( $ values [ 'max_bytes' ] ) ) { $ values [ 'max_bytes' ] = 2 * 1024 * 1024 ; } $ data = self :: pack ( self :: BIT_B32 , ( string ) $ values [ 'partition_id' ] ) ; $ data .= self :: pack ( self :: BIT_B64 , ( string ) $ values [ 'offset' ] ) ; $ data .= self :: pack ( self :: BIT_B32 , ( string ) $ values [ 'max_bytes' ] ) ; return $ data ; } 
public function encode ( array $ payloads = [ ] ) : string { if ( ! isset ( $ payloads [ 'group_id' ] ) ) { throw new ProtocolException ( 'given join group data invalid. `group_id` is undefined.' ) ; } if ( ! isset ( $ payloads [ 'session_timeout' ] ) ) { throw new ProtocolException ( 'given join group data invalid. `session_timeout` is undefined.' ) ; } if ( ! isset ( $ payloads [ 'member_id' ] ) ) { throw new ProtocolException ( 'given join group data invalid. `member_id` is undefined.' ) ; } if ( ! isset ( $ payloads [ 'data' ] ) ) { throw new ProtocolException ( 'given join group data invalid. `data` is undefined.' ) ; } if ( ! isset ( $ payloads [ 'protocol_type' ] ) ) { $ payloads [ 'protocol_type' ] = 'consumer' ; } if ( ! isset ( $ payloads [ 'rebalance_timeout' ] ) ) { $ payloads [ 'rebalance_timeout' ] = $ payloads [ 'session_timeout' ] ; } $ header = $ this -> requestHeader ( 'kafka-php' , self :: JOIN_GROUP_REQUEST , self :: JOIN_GROUP_REQUEST ) ; $ data = self :: encodeString ( $ payloads [ 'group_id' ] , self :: PACK_INT16 ) ; $ data .= self :: pack ( self :: BIT_B32 , ( string ) $ payloads [ 'session_timeout' ] ) ; if ( $ this -> getApiVersion ( self :: JOIN_GROUP_REQUEST ) === self :: API_VERSION1 ) { $ data .= self :: pack ( self :: BIT_B32 , ( string ) $ payloads [ 'rebalance_timeout' ] ) ; } $ data .= self :: encodeString ( $ payloads [ 'member_id' ] , self :: PACK_INT16 ) ; $ data .= self :: encodeString ( $ payloads [ 'protocol_type' ] , self :: PACK_INT16 ) ; $ data .= self :: encodeArray ( $ payloads [ 'data' ] , [ $ this , 'encodeGroupProtocol' ] ) ; $ data = self :: encodeString ( $ header . $ data , self :: PACK_INT32 ) ; return $ data ; } 
protected function encodeGroupProtocol ( array $ values ) : string { if ( ! isset ( $ values [ 'protocol_name' ] ) ) { throw new ProtocolException ( 'given join group data invalid. `protocol_name` is undefined.' ) ; } $ protocolName = self :: encodeString ( $ values [ 'protocol_name' ] , self :: PACK_INT16 ) ; if ( ! isset ( $ values [ 'version' ] ) ) { throw new ProtocolException ( 'given data invalid. `version` is undefined.' ) ; } if ( ! isset ( $ values [ 'subscription' ] ) || empty ( $ values [ 'subscription' ] ) ) { throw new ProtocolException ( 'given data invalid. `subscription` is undefined.' ) ; } if ( ! isset ( $ values [ 'user_data' ] ) ) { $ values [ 'user_data' ] = '' ; } $ data = self :: pack ( self :: BIT_B16 , '0' ) ; $ data .= self :: encodeArray ( $ values [ 'subscription' ] , [ $ this , 'encodeGroupProtocolMetaTopic' ] ) ; $ data .= self :: encodeString ( $ values [ 'user_data' ] , self :: PACK_INT32 ) ; return $ protocolName . self :: encodeString ( $ data , self :: PACK_INT32 ) ; } 
public function start ( ? callable $ consumer = null ) : void { if ( $ this -> process !== null ) { $ this -> error ( 'Consumer is already being executed' ) ; return ; } $ this -> setupStopStrategy ( ) ; $ this -> process = $ this -> createProcess ( $ consumer ) ; $ this -> process -> start ( ) ; Loop :: run ( ) ; } 
protected function createProcess ( ? callable $ consumer ) : Process { $ process = new Process ( $ consumer ) ; if ( $ this -> logger ) { $ process -> setLogger ( $ this -> logger ) ; } return $ process ; } 
protected function createSocket ( string $ remoteSocket , $ context , ? int & $ errno , ? string & $ errstr ) { return stream_socket_client ( $ remoteSocket , $ errno , $ errstr , $ this -> sendTimeoutSec + ( $ this -> sendTimeoutUsec / 1000000 ) , STREAM_CLIENT_CONNECT , $ context ) ; } 
protected function select ( array $ sockets , int $ timeoutSec , int $ timeoutUsec , bool $ isRead = true ) { $ null = null ; if ( $ isRead ) { return @ stream_select ( $ sockets , $ null , $ null , $ timeoutSec , $ timeoutUsec ) ; } return @ stream_select ( $ null , $ sockets , $ null , $ timeoutSec , $ timeoutUsec ) ; } 
public function readBlocking ( int $ length ) : string { if ( $ length > self :: READ_MAX_LENGTH ) { throw Exception \ Socket :: invalidLength ( $ length , self :: READ_MAX_LENGTH ) ; } $ readable = $ this -> select ( [ $ this -> stream ] , $ this -> recvTimeoutSec , $ this -> recvTimeoutUsec ) ; if ( $ readable === false ) { $ this -> close ( ) ; throw Exception \ Socket :: notReadable ( $ length ) ; } if ( $ readable === 0 ) { 
public function writeBlocking ( string $ buffer ) : int { 
public function encode ( array $ payloads = [ ] ) : string { foreach ( $ payloads as $ topic ) { if ( ! is_string ( $ topic ) ) { throw new ProtocolException ( 'request metadata topic array have invalid value. ' ) ; } } $ header = $ this -> requestHeader ( 'kafka-php' , self :: METADATA_REQUEST , self :: METADATA_REQUEST ) ; $ data = self :: encodeArray ( $ payloads , [ $ this , 'encodeString' ] , self :: PACK_INT16 ) ; $ data = self :: encodeString ( $ header . $ data , self :: PACK_INT32 ) ; return $ data ; } 
public function encode ( array $ payloads = [ ] ) : string { if ( ! isset ( $ payloads [ 'group_id' ] ) ) { throw new ProtocolException ( 'given group coordinator invalid. `group_id` is undefined.' ) ; } $ header = $ this -> requestHeader ( 'kafka-php' , self :: GROUP_COORDINATOR_REQUEST , self :: GROUP_COORDINATOR_REQUEST ) ; $ data = self :: encodeString ( $ payloads [ 'group_id' ] , self :: PACK_INT16 ) ; $ data = self :: encodeString ( $ header . $ data , self :: PACK_INT32 ) ; return $ data ; } 
protected function encodeGroupAssignment ( array $ values ) : string { if ( ! isset ( $ values [ 'version' ] ) ) { throw new ProtocolException ( 'given data invalid. `version` is undefined.' ) ; } if ( ! isset ( $ values [ 'member_id' ] ) ) { throw new ProtocolException ( 'given data invalid. `member_id` is undefined.' ) ; } if ( ! isset ( $ values [ 'assignments' ] ) ) { throw new ProtocolException ( 'given data invalid. `assignments` is undefined.' ) ; } if ( ! isset ( $ values [ 'user_data' ] ) ) { $ values [ 'user_data' ] = '' ; } $ memberId = self :: encodeString ( $ values [ 'member_id' ] , self :: PACK_INT16 ) ; $ data = self :: pack ( self :: BIT_B16 , '0' ) ; $ data .= self :: encodeArray ( $ values [ 'assignments' ] , [ $ this , 'encodeGroupAssignmentTopic' ] ) ; $ data .= self :: encodeString ( $ values [ 'user_data' ] , self :: PACK_INT32 ) ; return $ memberId . self :: encodeString ( $ data , self :: PACK_INT32 ) ; } 
protected function encodeGroupAssignmentTopic ( array $ values ) : string { if ( ! isset ( $ values [ 'topic_name' ] ) ) { throw new ProtocolException ( 'given data invalid. `topic_name` is undefined.' ) ; } if ( ! isset ( $ values [ 'partitions' ] ) ) { throw new ProtocolException ( 'given data invalid. `partitions` is undefined.' ) ; } $ topicName = self :: encodeString ( $ values [ 'topic_name' ] , self :: PACK_INT16 ) ; $ partitions = self :: encodeArray ( $ values [ 'partitions' ] , [ $ this , 'encodeGroupAssignmentTopicPartition' ] ) ; return $ topicName . $ partitions ; } 
public static function unpack ( string $ type , string $ bytes ) { self :: checkLen ( $ type , $ bytes ) ; if ( $ type === self :: BIT_B64 ) { $ set = unpack ( $ type , $ bytes ) ; $ result = ( $ set [ 1 ] & 0xFFFFFFFF ) << 32 | ( $ set [ 2 ] & 0xFFFFFFFF ) ; } elseif ( $ type === self :: BIT_B16_SIGNED ) { 
protected static function checkLen ( string $ type , string $ bytes ) : void { $ expectedLength = 0 ; switch ( $ type ) { case self :: BIT_B64 : $ expectedLength = 8 ; break ; case self :: BIT_B32 : $ expectedLength = 4 ; break ; case self :: BIT_B16 : $ expectedLength = 2 ; break ; case self :: BIT_B16_SIGNED : $ expectedLength = 2 ; break ; case self :: BIT_B8 : $ expectedLength = 1 ; break ; } $ length = strlen ( $ bytes ) ; if ( $ length !== $ expectedLength ) { throw new ProtocolException ( 'unpack failed. string(raw) length is ' . $ length . ' , TO ' . $ type ) ; } } 
public static function isSystemLittleEndian ( ) : bool { 
public static function convertSignedShortFromLittleEndianToBigEndian ( array $ bits ) : array { $ convert = function ( int $ bit ) : int { $ lsb = $ bit & 0xff ; $ msb = $ bit >> 8 & 0xff ; $ bit = $ lsb << 8 | $ msb ; if ( $ bit >= 32768 ) { $ bit -= 65536 ; } return $ bit ; } ; return array_map ( $ convert , $ bits ) ; } 
public function getApiVersion ( int $ apikey ) : int { switch ( $ apikey ) { case self :: METADATA_REQUEST : return self :: API_VERSION0 ; case self :: PRODUCE_REQUEST : if ( version_compare ( $ this -> version , '0.10.0' ) >= 0 ) { return self :: API_VERSION2 ; } if ( version_compare ( $ this -> version , '0.9.0' ) >= 0 ) { return self :: API_VERSION1 ; } return self :: API_VERSION0 ; case self :: FETCH_REQUEST : if ( version_compare ( $ this -> version , '0.10.0' ) >= 0 ) { return self :: API_VERSION2 ; } if ( version_compare ( $ this -> version , '0.9.0' ) >= 0 ) { return self :: API_VERSION1 ; } return self :: API_VERSION0 ; case self :: OFFSET_REQUEST : 
public static function getApiText ( int $ apikey ) : string { $ apis = [ self :: PRODUCE_REQUEST => 'ProduceRequest' , self :: FETCH_REQUEST => 'FetchRequest' , self :: OFFSET_REQUEST => 'OffsetRequest' , self :: METADATA_REQUEST => 'MetadataRequest' , self :: OFFSET_COMMIT_REQUEST => 'OffsetCommitRequest' , self :: OFFSET_FETCH_REQUEST => 'OffsetFetchRequest' , self :: GROUP_COORDINATOR_REQUEST => 'GroupCoordinatorRequest' , self :: JOIN_GROUP_REQUEST => 'JoinGroupRequest' , self :: HEART_BEAT_REQUEST => 'HeartbeatRequest' , self :: LEAVE_GROUP_REQUEST => 'LeaveGroupRequest' , self :: SYNC_GROUP_REQUEST => 'SyncGroupRequest' , self :: DESCRIBE_GROUPS_REQUEST => 'DescribeGroupsRequest' , self :: LIST_GROUPS_REQUEST => 'ListGroupsRequest' , self :: SASL_HAND_SHAKE_REQUEST => 'SaslHandShakeRequest' , self :: API_VERSIONS_REQUEST => 'ApiVersionsRequest' , ] ; return $ apis [ $ apikey ] ?? 'Unknown message' ; } 
public function decodeString ( string $ data , string $ bytes , int $ compression = self :: COMPRESSION_NONE ) : array { $ offset = $ bytes === self :: BIT_B32 ? 4 : 2 ; $ packLen = self :: unpack ( $ bytes , substr ( $ data , 0 , $ offset ) ) ; 
public function decodeArray ( string $ data , callable $ func , $ options = null ) : array { $ offset = 0 ; $ arrayCount = self :: unpack ( self :: BIT_B32 , substr ( $ data , $ offset , 4 ) ) ; $ offset += 4 ; $ result = [ ] ; for ( $ i = 0 ; $ i < $ arrayCount ; $ i ++ ) { $ value = substr ( $ data , $ offset ) ; $ ret = $ options !== null ? $ func ( $ value , $ options ) : $ func ( $ value ) ; if ( ! is_array ( $ ret ) && $ ret === false ) { break ; } if ( ! isset ( $ ret [ 'length' ] , $ ret [ 'data' ] ) ) { throw new ProtocolException ( 'Decode array failed, given function return format is invalid' ) ; } if ( ( int ) $ ret [ 'length' ] === 0 ) { continue ; } $ offset += $ ret [ 'length' ] ; $ result [ ] = $ ret [ 'data' ] ; } return [ 'length' => $ offset , 'data' => $ result ] ; } 
public function decodePrimitiveArray ( string $ data , string $ bit ) : array { $ offset = 0 ; $ arrayCount = self :: unpack ( self :: BIT_B32 , substr ( $ data , $ offset , 4 ) ) ; $ offset += 4 ; if ( $ arrayCount === 4294967295 ) { $ arrayCount = 0 ; } $ result = [ ] ; for ( $ i = 0 ; $ i < $ arrayCount ; $ i ++ ) { if ( $ bit === self :: BIT_B64 ) { $ result [ ] = self :: unpack ( self :: BIT_B64 , substr ( $ data , $ offset , 8 ) ) ; $ offset += 8 ; } elseif ( $ bit === self :: BIT_B32 ) { $ result [ ] = self :: unpack ( self :: BIT_B32 , substr ( $ data , $ offset , 4 ) ) ; $ offset += 4 ; } elseif ( in_array ( $ bit , [ self :: BIT_B16 , self :: BIT_B16_SIGNED ] , true ) ) { $ result [ ] = self :: unpack ( $ bit , substr ( $ data , $ offset , 2 ) ) ; $ offset += 2 ; } elseif ( $ bit === self :: BIT_B8 ) { $ result [ ] = self :: unpack ( $ bit , substr ( $ data , $ offset , 1 ) ) ; ++ $ offset ; } } return [ 'length' => $ offset , 'data' => $ result ] ; } 
public function encode ( array $ payloads = [ ] ) : string { if ( ! isset ( $ payloads [ 'group_id' ] ) ) { throw new ProtocolException ( 'given commit offset data invalid. `group_id` is undefined.' ) ; } if ( ! isset ( $ payloads [ 'data' ] ) ) { throw new ProtocolException ( 'given commit data invalid. `data` is undefined.' ) ; } if ( ! isset ( $ payloads [ 'generation_id' ] ) ) { $ payloads [ 'generation_id' ] = - 1 ; } if ( ! isset ( $ payloads [ 'member_id' ] ) ) { $ payloads [ 'member_id' ] = '' ; } if ( ! isset ( $ payloads [ 'retention_time' ] ) ) { $ payloads [ 'retention_time' ] = - 1 ; } $ version = $ this -> getApiVersion ( self :: OFFSET_COMMIT_REQUEST ) ; $ header = $ this -> requestHeader ( 'kafka-php' , self :: OFFSET_COMMIT_REQUEST , self :: OFFSET_COMMIT_REQUEST ) ; $ data = self :: encodeString ( $ payloads [ 'group_id' ] , self :: PACK_INT16 ) ; if ( $ version === self :: API_VERSION1 ) { $ data .= self :: pack ( self :: BIT_B32 , ( string ) $ payloads [ 'generation_id' ] ) ; $ data .= self :: encodeString ( $ payloads [ 'member_id' ] , self :: PACK_INT16 ) ; } if ( $ version === self :: API_VERSION2 ) { $ data .= self :: pack ( self :: BIT_B32 , ( string ) $ payloads [ 'generation_id' ] ) ; $ data .= self :: encodeString ( $ payloads [ 'member_id' ] , self :: PACK_INT16 ) ; $ data .= self :: pack ( self :: BIT_B64 , ( string ) $ payloads [ 'retention_time' ] ) ; } $ data .= self :: encodeArray ( $ payloads [ 'data' ] , [ $ this , 'encodeTopic' ] ) ; $ data = self :: encodeString ( $ header . $ data , self :: PACK_INT32 ) ; return $ data ; } 
protected function encodeTopic ( array $ values ) : string { if ( ! isset ( $ values [ 'topic_name' ] ) ) { throw new ProtocolException ( 'given commit offset data invalid. `topic_name` is undefined.' ) ; } if ( ! isset ( $ values [ 'partitions' ] ) ) { throw new ProtocolException ( 'given commit offset data invalid. `partitions` is undefined.' ) ; } $ data = self :: encodeString ( $ values [ 'topic_name' ] , self :: PACK_INT16 ) ; $ data .= self :: encodeArray ( $ values [ 'partitions' ] , [ $ this , 'encodePartition' ] ) ; return $ data ; } 
protected function encodePartition ( array $ values ) : string { if ( ! isset ( $ values [ 'partition' ] ) ) { throw new ProtocolException ( 'given commit offset data invalid. `partition` is undefined.' ) ; } if ( ! isset ( $ values [ 'offset' ] ) ) { throw new ProtocolException ( 'given commit offset data invalid. `offset` is undefined.' ) ; } if ( ! isset ( $ values [ 'metadata' ] ) ) { $ values [ 'metadata' ] = '' ; } if ( ! isset ( $ values [ 'timestamp' ] ) ) { $ values [ 'timestamp' ] = time ( ) * 1000 ; } $ version = $ this -> getApiVersion ( self :: OFFSET_COMMIT_REQUEST ) ; $ data = self :: pack ( self :: BIT_B32 , ( string ) $ values [ 'partition' ] ) ; $ data .= self :: pack ( self :: BIT_B64 , ( string ) $ values [ 'offset' ] ) ; if ( $ version === self :: API_VERSION1 ) { $ data .= self :: pack ( self :: BIT_B64 , ( string ) $ values [ 'timestamp' ] ) ; } $ data .= self :: encodeString ( $ values [ 'metadata' ] , self :: PACK_INT16 ) ; return $ data ; } 
public function encode ( array $ payloads = [ ] ) : string { $ mechanism = array_shift ( $ payloads ) ; if ( ! is_string ( $ mechanism ) ) { throw new ProtocolException ( 'Invalid request SASL hand shake mechanism given. ' ) ; } if ( ! in_array ( $ mechanism , self :: ALLOW_SASL_MECHANISMS , true ) ) { throw new ProtocolException ( 'Invalid request SASL hand shake mechanism given, it must be one of: ' . implode ( '|' , self :: ALLOW_SASL_MECHANISMS ) ) ; } $ header = $ this -> requestHeader ( 'kafka-php' , self :: SASL_HAND_SHAKE_REQUEST , self :: SASL_HAND_SHAKE_REQUEST ) ; $ data = self :: encodeString ( $ mechanism , self :: PACK_INT16 ) ; $ data = self :: encodeString ( $ header . $ data , self :: PACK_INT32 ) ; return $ data ; } 
public function before ( $ methods , $ pattern , $ fn ) { $ pattern = $ this -> baseRoute . '/' . trim ( $ pattern , '/' ) ; $ pattern = $ this -> baseRoute ? rtrim ( $ pattern , '/' ) : $ pattern ; foreach ( explode ( '|' , $ methods ) as $ method ) { $ this -> beforeRoutes [ $ method ] [ ] = [ 'pattern' => $ pattern , 'fn' => $ fn , ] ; } } 
public function match ( $ methods , $ pattern , $ fn ) { $ pattern = $ this -> baseRoute . '/' . trim ( $ pattern , '/' ) ; $ pattern = $ this -> baseRoute ? rtrim ( $ pattern , '/' ) : $ pattern ; foreach ( explode ( '|' , $ methods ) as $ method ) { $ this -> afterRoutes [ $ method ] [ ] = [ 'pattern' => $ pattern , 'fn' => $ fn , ] ; } } 
public function mount ( $ baseRoute , $ fn ) { 
public function getRequestMethod ( ) { 
public function run ( $ callback = null ) { 
public function getBasePath ( ) { 
public function map ( $ pattern , $ callback , $ pass_route = false ) { $ url = $ pattern ; $ methods = array ( '*' ) ; if ( strpos ( $ pattern , ' ' ) !== false ) { list ( $ method , $ url ) = explode ( ' ' , trim ( $ pattern ) , 2 ) ; $ methods = explode ( '|' , $ method ) ; } $ this -> routes [ ] = new Route ( $ url , $ callback , $ methods , $ pass_route ) ; } 
public function route ( Request $ request ) { $ url_decoded = urldecode ( $ request -> url ) ; while ( $ route = $ this -> current ( ) ) { if ( $ route !== false && $ route -> matchMethod ( $ request -> method ) && $ route -> matchUrl ( $ url_decoded , $ this -> case_sensitive ) ) { return $ route ; } $ this -> next ( ) ; } return false ; } 
public function current ( ) { return isset ( $ this -> routes [ $ this -> index ] ) ? $ this -> routes [ $ this -> index ] : false ; } 
public function matchUrl ( $ url , $ case_sensitive = false ) { 
public function run ( $ name , array $ params = array ( ) ) { $ output = '' ; 
public function get ( $ name ) { return isset ( $ this -> events [ $ name ] ) ? $ this -> events [ $ name ] : null ; } 
public function clear ( $ name = null ) { if ( $ name !== null ) { unset ( $ this -> events [ $ name ] ) ; unset ( $ this -> filters [ $ name ] ) ; } else { $ this -> events = array ( ) ; $ this -> filters = array ( ) ; } } 
public function filter ( $ filters , & $ params , & $ output ) { $ args = array ( & $ params , & $ output ) ; foreach ( $ filters as $ callback ) { $ continue = $ this -> execute ( $ callback , $ args ) ; if ( $ continue === false ) break ; } } 
public static function execute ( $ callback , array & $ params = array ( ) ) { if ( is_callable ( $ callback ) ) { return is_array ( $ callback ) ? self :: invokeMethod ( $ callback , $ params ) : self :: callFunction ( $ callback , $ params ) ; } else { throw new \ Exception ( 'Invalid callback specified.' ) ; } } 
public static function callFunction ( $ func , array & $ params = array ( ) ) { 
public static function invokeMethod ( $ func , array & $ params = array ( ) ) { list ( $ class , $ method ) = $ func ; $ instance = is_object ( $ class ) ; switch ( count ( $ params ) ) { case 0 : return ( $ instance ) ? $ class -> $ method ( ) : $ class :: $ method ( ) ; case 1 : return ( $ instance ) ? $ class -> $ method ( $ params [ 0 ] ) : $ class :: $ method ( $ params [ 0 ] ) ; case 2 : return ( $ instance ) ? $ class -> $ method ( $ params [ 0 ] , $ params [ 1 ] ) : $ class :: $ method ( $ params [ 0 ] , $ params [ 1 ] ) ; case 3 : return ( $ instance ) ? $ class -> $ method ( $ params [ 0 ] , $ params [ 1 ] , $ params [ 2 ] ) : $ class :: $ method ( $ params [ 0 ] , $ params [ 1 ] , $ params [ 2 ] ) ; case 4 : return ( $ instance ) ? $ class -> $ method ( $ params [ 0 ] , $ params [ 1 ] , $ params [ 2 ] , $ params [ 3 ] ) : $ class :: $ method ( $ params [ 0 ] , $ params [ 1 ] , $ params [ 2 ] , $ params [ 3 ] ) ; case 5 : return ( $ instance ) ? $ class -> $ method ( $ params [ 0 ] , $ params [ 1 ] , $ params [ 2 ] , $ params [ 3 ] , $ params [ 4 ] ) : $ class :: $ method ( $ params [ 0 ] , $ params [ 1 ] , $ params [ 2 ] , $ params [ 3 ] , $ params [ 4 ] ) ; default : return call_user_func_array ( $ func , $ params ) ; } } 
public function init ( $ properties = array ( ) ) { 
public static function getBody ( ) { static $ body ; if ( ! is_null ( $ body ) ) { return $ body ; } $ method = self :: getMethod ( ) ; if ( $ method == 'POST' || $ method == 'PUT' || $ method == 'PATCH' ) { $ body = file_get_contents ( 'php://input' ) ; } return $ body ; } 
public static function getMethod ( ) { $ method = self :: getVar ( 'REQUEST_METHOD' , 'GET' ) ; if ( isset ( $ _SERVER [ 'HTTP_X_HTTP_METHOD_OVERRIDE' ] ) ) { $ method = $ _SERVER [ 'HTTP_X_HTTP_METHOD_OVERRIDE' ] ; } elseif ( isset ( $ _REQUEST [ '_method' ] ) ) { $ method = $ _REQUEST [ '_method' ] ; } return strtoupper ( $ method ) ; } 
public static function getProxyIpAddress ( ) { static $ forwarded = array ( 'HTTP_CLIENT_IP' , 'HTTP_X_FORWARDED_FOR' , 'HTTP_X_FORWARDED' , 'HTTP_X_CLUSTER_CLIENT_IP' , 'HTTP_FORWARDED_FOR' , 'HTTP_FORWARDED' ) ; $ flags = \ FILTER_FLAG_NO_PRIV_RANGE | \ FILTER_FLAG_NO_RES_RANGE ; foreach ( $ forwarded as $ key ) { if ( array_key_exists ( $ key , $ _SERVER ) ) { sscanf ( $ _SERVER [ $ key ] , '%[^,]' , $ ip ) ; if ( filter_var ( $ ip , \ FILTER_VALIDATE_IP , $ flags ) !== false ) { return $ ip ; } } } return '' ; } 
public static function parseQuery ( $ url ) { $ params = array ( ) ; $ args = parse_url ( $ url ) ; if ( isset ( $ args [ 'query' ] ) ) { parse_str ( $ args [ 'query' ] , $ params ) ; } return $ params ; } 
public function status ( $ code = null ) { if ( $ code === null ) { return $ this -> status ; } if ( array_key_exists ( $ code , self :: $ codes ) ) { $ this -> status = $ code ; } else { throw new \ Exception ( 'Invalid status code.' ) ; } return $ this ; } 
public function header ( $ name , $ value = null ) { if ( is_array ( $ name ) ) { foreach ( $ name as $ k => $ v ) { $ this -> headers [ $ k ] = $ v ; } } else { $ this -> headers [ $ name ] = $ value ; } return $ this ; } 
public function cache ( $ expires ) { if ( $ expires === false ) { $ this -> headers [ 'Expires' ] = 'Mon, 26 Jul 1997 05:00:00 GMT' ; $ this -> headers [ 'Cache-Control' ] = array ( 'no-store, no-cache, must-revalidate' , 'post-check=0, pre-check=0' , 'max-age=0' ) ; $ this -> headers [ 'Pragma' ] = 'no-cache' ; } else { $ expires = is_int ( $ expires ) ? $ expires : strtotime ( $ expires ) ; $ this -> headers [ 'Expires' ] = gmdate ( 'D, d M Y H:i:s' , $ expires ) . ' GMT' ; $ this -> headers [ 'Cache-Control' ] = 'max-age=' . ( $ expires - time ( ) ) ; if ( isset ( $ this -> headers [ 'Pragma' ] ) && $ this -> headers [ 'Pragma' ] == 'no-cache' ) { unset ( $ this -> headers [ 'Pragma' ] ) ; } } return $ this ; } 
public function sendHeaders ( ) { 
public function send ( ) { if ( ob_get_length ( ) > 0 ) { ob_end_clean ( ) ; } if ( ! headers_sent ( ) ) { $ this -> sendHeaders ( ) ; } echo $ this -> body ; $ this -> sent = true ; } 
public function init ( ) { static $ initialized = false ; $ self = $ this ; if ( $ initialized ) { $ this -> vars = array ( ) ; $ this -> loader -> reset ( ) ; $ this -> dispatcher -> reset ( ) ; } 
public function handleError ( $ errno , $ errstr , $ errfile , $ errline ) { if ( $ errno & error_reporting ( ) ) { throw new \ ErrorException ( $ errstr , $ errno , 0 , $ errfile , $ errline ) ; } } 
public function handleException ( $ e ) { if ( $ this -> get ( 'flight.log_errors' ) ) { error_log ( $ e -> getMessage ( ) ) ; } $ this -> error ( $ e ) ; } 
public function map ( $ name , $ callback ) { if ( method_exists ( $ this , $ name ) ) { throw new \ Exception ( 'Cannot override an existing framework method.' ) ; } $ this -> dispatcher -> set ( $ name , $ callback ) ; } 
public function register ( $ name , $ class , array $ params = array ( ) , $ callback = null ) { if ( method_exists ( $ this , $ name ) ) { throw new \ Exception ( 'Cannot override an existing framework method.' ) ; } $ this -> loader -> register ( $ name , $ class , $ params , $ callback ) ; } 
public function get ( $ key = null ) { if ( $ key === null ) return $ this -> vars ; return isset ( $ this -> vars [ $ key ] ) ? $ this -> vars [ $ key ] : null ; } 
public function clear ( $ key = null ) { if ( is_null ( $ key ) ) { $ this -> vars = array ( ) ; } else { unset ( $ this -> vars [ $ key ] ) ; } } 
public function _start ( ) { $ dispatched = false ; $ self = $ this ; $ request = $ this -> request ( ) ; $ response = $ this -> response ( ) ; $ router = $ this -> router ( ) ; 
public function _stop ( $ code = null ) { $ response = $ this -> response ( ) ; if ( ! $ response -> sent ( ) ) { if ( $ code !== null ) { $ response -> status ( $ code ) ; } $ response -> write ( ob_get_clean ( ) ) ; $ response -> send ( ) ; } } 
public function _route ( $ pattern , $ callback , $ pass_route = false ) { $ this -> router ( ) -> map ( $ pattern , $ callback , $ pass_route ) ; } 
public function _halt ( $ code = 200 , $ message = '' ) { $ this -> response ( ) -> clear ( ) -> status ( $ code ) -> write ( $ message ) -> send ( ) ; exit ( ) ; } 
public function _error ( $ e ) { $ msg = sprintf ( '<h1>500 Internal Server Error</h1>' . '<h3>%s (%s)</h3>' . '<pre>%s</pre>' , $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e -> getTraceAsString ( ) ) ; try { $ this -> response ( ) -> clear ( ) -> status ( 500 ) -> write ( $ msg ) -> send ( ) ; } catch ( \ Throwable $ t ) { 
public function _redirect ( $ url , $ code = 303 ) { $ base = $ this -> get ( 'flight.base_url' ) ; if ( $ base === null ) { $ base = $ this -> request ( ) -> base ; } 
public function _render ( $ file , $ data = null , $ key = null ) { if ( $ key !== null ) { $ this -> view ( ) -> set ( $ key , $ this -> view ( ) -> fetch ( $ file , $ data ) ) ; } else { $ this -> view ( ) -> render ( $ file , $ data ) ; } } 
public function _json ( $ data , $ code = 200 , $ encode = true , $ charset = 'utf-8' , $ option = 0 ) { $ json = ( $ encode ) ? json_encode ( $ data , $ option ) : $ data ; $ this -> response ( ) -> status ( $ code ) -> header ( 'Content-Type' , 'application/json; charset=' . $ charset ) -> write ( $ json ) -> send ( ) ; } 
public function _jsonp ( $ data , $ param = 'jsonp' , $ code = 200 , $ encode = true , $ charset = 'utf-8' , $ option = 0 ) { $ json = ( $ encode ) ? json_encode ( $ data , $ option ) : $ data ; $ callback = $ this -> request ( ) -> query [ $ param ] ; $ this -> response ( ) -> status ( $ code ) -> header ( 'Content-Type' , 'application/javascript; charset=' . $ charset ) -> write ( $ callback . '(' . $ json . ');' ) -> send ( ) ; } 
public function _etag ( $ id , $ type = 'strong' ) { $ id = ( ( $ type === 'weak' ) ? 'W/' : '' ) . $ id ; $ this -> response ( ) -> header ( 'ETag' , $ id ) ; if ( isset ( $ _SERVER [ 'HTTP_IF_NONE_MATCH' ] ) && $ _SERVER [ 'HTTP_IF_NONE_MATCH' ] === $ id ) { $ this -> halt ( 304 ) ; } } 
public function _lastModified ( $ time ) { $ this -> response ( ) -> header ( 'Last-Modified' , gmdate ( 'D, d M Y H:i:s \G\M\T' , $ time ) ) ; if ( isset ( $ _SERVER [ 'HTTP_IF_MODIFIED_SINCE' ] ) && strtotime ( $ _SERVER [ 'HTTP_IF_MODIFIED_SINCE' ] ) === $ time ) { $ this -> halt ( 304 ) ; } } 
public function register ( $ name , $ class , array $ params = array ( ) , $ callback = null ) { unset ( $ this -> instances [ $ name ] ) ; $ this -> classes [ $ name ] = array ( $ class , $ params , $ callback ) ; } 
public function load ( $ name , $ shared = true ) { $ obj = null ; if ( isset ( $ this -> classes [ $ name ] ) ) { list ( $ class , $ params , $ callback ) = $ this -> classes [ $ name ] ; $ exists = isset ( $ this -> instances [ $ name ] ) ; if ( $ shared ) { $ obj = ( $ exists ) ? $ this -> getInstance ( $ name ) : $ this -> newInstance ( $ class , $ params ) ; if ( ! $ exists ) { $ this -> instances [ $ name ] = $ obj ; } } else { $ obj = $ this -> newInstance ( $ class , $ params ) ; } if ( $ callback && ( ! $ shared || ! $ exists ) ) { $ ref = array ( & $ obj ) ; call_user_func_array ( $ callback , $ ref ) ; } } return $ obj ; } 
public function getInstance ( $ name ) { return isset ( $ this -> instances [ $ name ] ) ? $ this -> instances [ $ name ] : null ; } 
public function newInstance ( $ class , array $ params = array ( ) ) { if ( is_callable ( $ class ) ) { return call_user_func_array ( $ class , $ params ) ; } switch ( count ( $ params ) ) { case 0 : return new $ class ( ) ; case 1 : return new $ class ( $ params [ 0 ] ) ; case 2 : return new $ class ( $ params [ 0 ] , $ params [ 1 ] ) ; case 3 : return new $ class ( $ params [ 0 ] , $ params [ 1 ] , $ params [ 2 ] ) ; case 4 : return new $ class ( $ params [ 0 ] , $ params [ 1 ] , $ params [ 2 ] , $ params [ 3 ] ) ; case 5 : return new $ class ( $ params [ 0 ] , $ params [ 1 ] , $ params [ 2 ] , $ params [ 3 ] , $ params [ 4 ] ) ; default : try { $ refClass = new \ ReflectionClass ( $ class ) ; return $ refClass -> newInstanceArgs ( $ params ) ; } catch ( \ ReflectionException $ e ) { throw new \ Exception ( "Cannot instantiate {$class}" , 0 , $ e ) ; } } } 
public static function autoload ( $ enabled = true , $ dirs = array ( ) ) { if ( $ enabled ) { spl_autoload_register ( array ( __CLASS__ , 'loadClass' ) ) ; } else { spl_autoload_unregister ( array ( __CLASS__ , 'loadClass' ) ) ; } if ( ! empty ( $ dirs ) ) { self :: addDirectory ( $ dirs ) ; } } 
public static function loadClass ( $ class ) { $ class_file = str_replace ( array ( '\\' , '_' ) , '/' , $ class ) . '.php' ; foreach ( self :: $ dirs as $ dir ) { $ file = $ dir . '/' . $ class_file ; if ( file_exists ( $ file ) ) { require $ file ; return ; } } } 
public static function addDirectory ( $ dir ) { if ( is_array ( $ dir ) || is_object ( $ dir ) ) { foreach ( $ dir as $ value ) { self :: addDirectory ( $ value ) ; } } else if ( is_string ( $ dir ) ) { if ( ! in_array ( $ dir , self :: $ dirs ) ) self :: $ dirs [ ] = $ dir ; } } 
public function render ( $ file , $ data = null ) { $ this -> template = $ this -> getTemplate ( $ file ) ; if ( ! file_exists ( $ this -> template ) ) { throw new \ Exception ( "Template file not found: {$this->template}." ) ; } if ( is_array ( $ data ) ) { $ this -> vars = array_merge ( $ this -> vars , $ data ) ; } extract ( $ this -> vars ) ; include $ this -> template ; } 
public function fetch ( $ file , $ data = null ) { ob_start ( ) ; $ this -> render ( $ file , $ data ) ; $ output = ob_get_clean ( ) ; return $ output ; } 
public function getTemplate ( $ file ) { $ ext = $ this -> extension ; if ( ! empty ( $ ext ) && ( substr ( $ file , - 1 * strlen ( $ ext ) ) != $ ext ) ) { $ file .= $ ext ; } if ( ( substr ( $ file , 0 , 1 ) == '/' ) ) { return $ file ; } return $ this -> path . '/' . $ file ; } 
public function run ( $ files ) { 
public function isCyclic ( Graph $ graph ) { 
public function getDepthOfNode ( Node $ node ) { $ edges = $ node -> getEdges ( ) ; if ( 0 === sizeof ( $ edges ) ) { return 0 ; } 
public function getNumberOfChilds ( Node $ node , $ uniqs = false ) { $ edges = $ node -> getEdges ( ) ; if ( 0 === sizeof ( $ edges ) ) { return 0 ; } 
public function getAverageHeightOfGraph ( ) { $ ns = [ ] ; foreach ( $ this -> graph -> getRootNodes ( ) as $ node ) { array_push ( $ ns , $ this -> getLongestBranch ( $ node ) ) ; } return round ( array_sum ( $ ns ) / max ( 1 , sizeof ( $ ns ) ) , 2 ) ; } 
public function addEdge ( Node $ from , Node $ to ) { $ key = $ from -> getUniqueId ( ) . '->' . $ to -> getUniqueId ( ) ; if ( isset ( $ this -> edgesMap [ $ key ] ) ) { return $ this ; } $ this -> edgesMap [ $ key ] = true ; return parent :: addEdge ( $ from , $ to ) ; } 
public function read ( Config $ config ) { $ jsonText = file_get_contents ( $ this -> filename ) ; if ( false === $ jsonText ) { throw new \ InvalidArgumentException ( "Cannot read configuration file '{$this->filename}'" ) ; } $ jsonData = json_decode ( $ jsonText , true ) ; if ( false === $ jsonData ) { throw new \ InvalidArgumentException ( "Bad json file '{$this->filename}'" ) ; } $ jsonDataImploded = $ this -> collapseArray ( $ jsonData ) ; foreach ( $ jsonDataImploded as $ key => $ value ) { $ config -> set ( $ key , $ value ) ; } } 
private function collapseArray ( array $ arr ) { $ iterator = new RecursiveIteratorIterator ( new RecursiveArrayIterator ( $ arr ) ) ; $ result = [ ] ; foreach ( $ iterator as $ leafValue ) { $ keys = [ ] ; foreach ( range ( 0 , $ iterator -> getDepth ( ) ) as $ depth ) { $ keys [ ] = $ iterator -> getSubIterator ( $ depth ) -> key ( ) ; } $ result [ join ( '-' , $ keys ) ] = $ leafValue ; } return $ result ; } 
public function fetch ( array $ paths ) { $ files = array ( ) ; foreach ( $ paths as $ path ) { if ( is_dir ( $ path ) ) { $ path = rtrim ( $ path , DIRECTORY_SEPARATOR ) . DIRECTORY_SEPARATOR ; $ directory = new RecursiveDirectoryIterator ( $ path , $ this -> flags ) ; $ iterator = new RecursiveIteratorIterator ( $ directory ) ; $ filterRegex = sprintf ( '`^%s%s%s$`' , preg_quote ( $ path , '`' ) , ! empty ( $ this -> excludedDirs ) ? '((?!' . implode ( '|' , array_map ( 'preg_quote' , $ this -> excludedDirs ) ) . ').)+' : '.+' , '\.(' . implode ( '|' , $ this -> extensions ) . ')' ) ; $ filteredIterator = new RegexIterator ( $ iterator , $ filterRegex , \ RecursiveRegexIterator :: GET_MATCH ) ; foreach ( $ filteredIterator as $ file ) { $ files [ ] = $ file [ 0 ] ; } } elseif ( is_file ( $ path ) ) { $ files [ ] = $ path ; } } return $ files ; } 
private function traverse ( TreeNode $ node ) { if ( $ node -> visited ) { return 0 ; } $ node -> visited = true ; foreach ( $ node -> getAdjacents ( ) as $ adjacent ) { $ this -> traverse ( $ adjacent ) ; } return 1 ; } 
public function read ( Config $ config ) { $ options = parse_ini_file ( $ this -> filename ) ; if ( false === $ options ) { throw new \ InvalidArgumentException ( "Cannot parse configuration file '{$this->filename}'" ) ; } foreach ( $ options as $ name => $ value ) { $ config -> set ( $ name , $ value ) ; } } 
public static function createFromFileName ( $ filename ) { if ( ! is_file ( $ filename ) || ! is_readable ( $ filename ) ) { throw new \ InvalidArgumentException ( "Cannot read configuration file '{$filename}'" ) ; } switch ( pathinfo ( $ filename , PATHINFO_EXTENSION ) ) { case 'json' : return new ConfigFileReaderJson ( $ filename ) ; case 'ini' : return new ConfigFileReaderIni ( $ filename ) ; break ; default : throw new \ InvalidArgumentException ( "Unsupported config file format: '$filename'" ) ; } } 
public static function getName ( Node $ node ) { return ( $ node instanceof Node \ Stmt \ Class_ && $ node -> isAnonymous ( ) ) ? 'anonymous@' . spl_object_hash ( $ node ) : $ node -> namespacedName -> toString ( ) ; } 
public function getRootNodes ( ) { $ roots = [ ] ; foreach ( $ this -> all ( ) as $ node ) { $ isRoot = true ; foreach ( $ node -> getEdges ( ) as $ edge ) { if ( $ edge -> getTo ( ) == $ node ) { $ isRoot = false ; } } if ( $ isRoot ) { array_push ( $ roots , $ node ) ; } } return $ roots ; } 
protected function getComposerJsonRequirements ( ) { $ rawRequirements = [ [ ] ] ; 
protected function getComposerLockInstalled ( $ rootPackageRequirements ) { $ rawInstalled = [ [ ] ] ; 
public function advance ( ) { $ this -> current ++ ; if ( $ this -> hasAnsi ( ) ) { $ percent = round ( $ this -> current / $ this -> max * 100 ) ; $ this -> output -> write ( "\x0D" ) ; $ this -> output -> write ( "\x1B[2K" ) ; $ this -> output -> write ( sprintf ( '... %s%% ...' , $ percent ) ) ; } else { $ this -> output -> write ( '.' ) ; } } 
public function clear ( ) { if ( $ this -> hasAnsi ( ) ) { $ this -> output -> write ( "\x0D" ) ; $ this -> output -> write ( "\x1B[2K" ) ; $ this -> output -> clearln ( ) ; } } 
protected function hasAnsi ( ) { if ( DIRECTORY_SEPARATOR === '\\' ) { return 0 >= version_compare ( '10.0.10586' , PHP_WINDOWS_VERSION_MAJOR . '.' . PHP_WINDOWS_VERSION_MINOR . '.' . PHP_WINDOWS_VERSION_BUILD ) || false !== getenv ( 'ANSICON' ) || 'ON' === getenv ( 'ConEmuANSI' ) || 'xterm' === getenv ( 'TERM' ) ; } return function_exists ( 'posix_isatty' ) && @ posix_isatty ( $ this -> stream ) ; } 
public function process_token ( $ stackPtr ) { $ superglobals = $ this -> input_superglobals ; * Check for validation first. */ $ validated = false ; for ( $ i = ( $ stackPtr + 1 ) ; $ i < $ this -> phpcsFile -> numTokens ; $ i ++ ) { if ( isset ( Tokens :: $ emptyTokens [ $ this -> tokens [ $ i ] [ 'code' ] ] ) ) { continue ; } if ( \ T_OPEN_SQUARE_BRACKET === $ this -> tokens [ $ i ] [ 'code' ] && isset ( $ this -> tokens [ $ i ] [ 'bracket_closer' ] ) ) { 
protected function mergeFunctionLists ( ) { if ( $ this -> customSanitizingFunctions !== $ this -> addedCustomFunctions [ 'sanitize' ] ) { $ this -> sanitizingFunctions = $ this -> merge_custom_array ( $ this -> customSanitizingFunctions , $ this -> sanitizingFunctions ) ; $ this -> addedCustomFunctions [ 'sanitize' ] = $ this -> customSanitizingFunctions ; } if ( $ this -> customUnslashingSanitizingFunctions !== $ this -> addedCustomFunctions [ 'unslashsanitize' ] ) { $ this -> unslashingSanitizingFunctions = $ this -> merge_custom_array ( $ this -> customUnslashingSanitizingFunctions , $ this -> unslashingSanitizingFunctions ) ; $ this -> addedCustomFunctions [ 'unslashsanitize' ] = $ this -> customUnslashingSanitizingFunctions ; } } 
public function register ( ) { $ headers = array_map ( 'preg_quote' , array_keys ( $ this -> theme_headers ) , array_fill ( 0 , \ count ( $ this -> theme_headers ) , '`' ) ) ; $ this -> theme_header_regex = sprintf ( $ this -> header_regex_template , implode ( '|' , $ headers ) ) ; $ headers = array_map ( 'preg_quote' , array_keys ( $ this -> plugin_headers ) , array_fill ( 0 , \ count ( $ this -> plugin_headers ) , '`' ) ) ; $ this -> plugin_header_regex = sprintf ( $ this -> header_regex_template , implode ( '|' , $ headers ) ) ; $ targets = parent :: register ( ) ; $ targets [ ] = \ T_DOC_COMMENT_OPEN_TAG ; $ targets [ ] = \ T_COMMENT ; return $ targets ; } 
public function process_token ( $ stackPtr ) { 
public function process_parameters ( $ stackPtr , $ group_name , $ matched_content , $ parameters ) { $ target_param = $ this -> target_functions [ $ matched_content ] ; if ( isset ( $ parameters [ $ target_param ] ) === false && 1 !== $ target_param ) { $ error_msg = 'Missing $domain arg' ; $ error_code = 'MissingArgDomain' ; if ( isset ( $ parameters [ ( $ target_param - 1 ) ] ) ) { $ fix = $ this -> phpcsFile -> addFixableError ( $ error_msg , $ stackPtr , $ error_code ) ; if ( true === $ fix ) { $ start_previous = $ parameters [ ( $ target_param - 1 ) ] [ 'start' ] ; $ end_previous = $ parameters [ ( $ target_param - 1 ) ] [ 'end' ] ; if ( \ T_WHITESPACE === $ this -> tokens [ $ start_previous ] [ 'code' ] && $ this -> tokens [ $ start_previous ] [ 'content' ] === $ this -> phpcsFile -> eolChar ) { 
public function process_no_parameters ( $ stackPtr , $ group_name , $ matched_content ) { $ target_param = $ this -> target_functions [ $ matched_content ] ; if ( 1 !== $ target_param ) { 
public function process_comments ( $ stackPtr ) { if ( true === $ this -> header_found && ! defined ( 'PHP_CODESNIFFER_IN_TESTS' ) ) { return ; } $ regex = $ this -> plugin_header_regex ; $ headers = $ this -> plugin_headers ; $ type = 'plugin' ; $ skip_to = $ stackPtr ; $ file = $ this -> strip_quotes ( $ this -> phpcsFile -> getFileName ( ) ) ; if ( 'STDIN' === $ file ) { return ; } $ file_name = basename ( $ file ) ; if ( 'CSS' === $ this -> phpcsFile -> tokenizerType ) { if ( 'style.css' !== $ file_name && ! defined ( 'PHP_CODESNIFFER_IN_TESTS' ) ) { 
protected function examine_comment_line ( $ stackPtr , $ regex , $ headers , $ comment_details ) { if ( preg_match ( $ regex , $ this -> tokens [ $ stackPtr ] [ 'content' ] , $ matches ) === 1 ) { ++ $ comment_details [ 'headers_found' ] ; if ( true === $ headers [ $ matches [ 1 ] ] ) { $ comment_details [ 'required_header_found' ] = true ; } if ( 'Text Domain' === $ matches [ 1 ] ) { $ comment_details [ 'text_domain_ptr' ] = $ stackPtr ; $ comment_details [ 'text_domain_found' ] = trim ( $ matches [ 2 ] ) ; } $ comment_details [ 'last_header_ptr' ] = $ stackPtr ; $ comment_details [ 'last_header_matches' ] = $ matches ; } return $ comment_details ; } 
public function process_token ( $ stackPtr ) { $ token = $ this -> tokens [ $ stackPtr ] ; if ( 'cron_schedules' !== $ this -> strip_quotes ( $ token [ 'content' ] ) ) { return ; } 
public function process ( File $ phpcsFile , $ stackPtr ) { $ this -> init ( $ phpcsFile ) ; return $ this -> process_token ( $ stackPtr ) ; } 
protected function init ( File $ phpcsFile ) { $ this -> phpcsFile = $ phpcsFile ; $ this -> tokens = $ phpcsFile -> getTokens ( ) ; } 
protected function addMessage ( $ message , $ stackPtr , $ is_error = true , $ code = 'Found' , $ data = array ( ) , $ severity = 0 ) { return $ this -> throwMessage ( $ message , $ stackPtr , $ is_error , $ code , $ data , $ severity , false ) ; } 
protected function addFixableMessage ( $ message , $ stackPtr , $ is_error = true , $ code = 'Found' , $ data = array ( ) , $ severity = 0 ) { return $ this -> throwMessage ( $ message , $ stackPtr , $ is_error , $ code , $ data , $ severity , true ) ; } 
private function throwMessage ( $ message , $ stackPtr , $ is_error = true , $ code = 'Found' , $ data = array ( ) , $ severity = 0 , $ fixable = false ) { $ method = 'add' ; if ( true === $ fixable ) { $ method .= 'Fixable' ; } if ( true === $ is_error ) { $ method .= 'Error' ; } else { $ method .= 'Warning' ; } return \ call_user_func ( array ( $ this -> phpcsFile , $ method ) , $ message , $ stackPtr , $ code , $ data , $ severity ) ; } 
public static function get_snake_case_name_suggestion ( $ name ) { $ suggested = preg_replace ( '`([A-Z])`' , '_$1' , $ name ) ; $ suggested = strtolower ( $ suggested ) ; $ suggested = str_replace ( '__' , '_' , $ suggested ) ; $ suggested = trim ( $ suggested , '_' ) ; return $ suggested ; } 
public static function merge_custom_array ( $ custom , $ base = array ( ) , $ flip = true ) { if ( true === $ flip ) { $ base = array_filter ( $ base ) ; } if ( empty ( $ custom ) || ! \ is_array ( $ custom ) ) { return $ base ; } if ( true === $ flip ) { $ custom = array_fill_keys ( $ custom , false ) ; } if ( empty ( $ base ) ) { return $ custom ; } return array_merge ( $ base , $ custom ) ; } 
protected function get_last_ptr_on_line ( $ stackPtr ) { $ tokens = $ this -> tokens ; $ currentLine = $ tokens [ $ stackPtr ] [ 'line' ] ; $ nextPtr = ( $ stackPtr + 1 ) ; while ( isset ( $ tokens [ $ nextPtr ] ) && $ tokens [ $ nextPtr ] [ 'line' ] === $ currentLine ) { $ nextPtr ++ ; 
protected function get_wp_version_from_cl ( ) { $ cl_supported_version = trim ( PHPCSHelper :: get_config_data ( 'minimum_supported_wp_version' ) ) ; if ( ! empty ( $ cl_supported_version ) && filter_var ( $ cl_supported_version , \ FILTER_VALIDATE_FLOAT ) !== false ) { $ this -> minimum_supported_version = $ cl_supported_version ; } } 
protected function has_whitelist_comment ( $ comment , $ stackPtr ) { 
protected function is_assignment ( $ stackPtr ) { static $ valid = array ( \ T_VARIABLE => true , \ T_CLOSE_SQUARE_BRACKET => true , ) ; 
protected function has_nonce_check ( $ stackPtr ) { static $ last ; $ start = 0 ; $ end = $ stackPtr ; $ tokens = $ this -> phpcsFile -> getTokens ( ) ; * Now, make sure it is a call to a global function. */ if ( $ this -> is_class_object_call ( $ i ) === true ) { continue ; } if ( $ this -> is_token_namespaced ( $ i ) === true ) { continue ; } $ last [ 'nonce_check' ] = $ i ; return true ; } } 
protected function is_in_isset_or_empty ( $ stackPtr ) { if ( ! isset ( $ this -> tokens [ $ stackPtr ] [ 'nested_parenthesis' ] ) ) { return false ; } $ nested_parenthesis = $ this -> tokens [ $ stackPtr ] [ 'nested_parenthesis' ] ; end ( $ nested_parenthesis ) ; $ open_parenthesis = key ( $ nested_parenthesis ) ; $ previous_non_empty = $ this -> phpcsFile -> findPrevious ( Tokens :: $ emptyTokens , ( $ open_parenthesis - 1 ) , null , true , null , true ) ; if ( false === $ previous_non_empty ) { return false ; } $ previous_code = $ this -> tokens [ $ previous_non_empty ] [ 'code' ] ; if ( \ T_ISSET === $ previous_code || \ T_EMPTY === $ previous_code ) { return true ; } $ valid_functions = array ( 'array_key_exists' => true , 'key_exists' => true , 
protected function is_class_object_call ( $ stackPtr ) { $ before = $ this -> phpcsFile -> findPrevious ( Tokens :: $ emptyTokens , ( $ stackPtr - 1 ) , null , true , null , true ) ; if ( false === $ before ) { return false ; } if ( \ T_OBJECT_OPERATOR !== $ this -> tokens [ $ before ] [ 'code' ] && \ T_DOUBLE_COLON !== $ this -> tokens [ $ before ] [ 'code' ] ) { return false ; } return true ; } 
protected function is_token_namespaced ( $ stackPtr ) { $ prev = $ this -> phpcsFile -> findPrevious ( Tokens :: $ emptyTokens , ( $ stackPtr - 1 ) , null , true , null , true ) ; if ( false === $ prev ) { return false ; } if ( \ T_NS_SEPARATOR !== $ this -> tokens [ $ prev ] [ 'code' ] ) { return false ; } $ before_prev = $ this -> phpcsFile -> findPrevious ( Tokens :: $ emptyTokens , ( $ prev - 1 ) , null , true , null , true ) ; if ( false === $ before_prev ) { return false ; } if ( \ T_STRING !== $ this -> tokens [ $ before_prev ] [ 'code' ] && \ T_NAMESPACE !== $ this -> tokens [ $ before_prev ] [ 'code' ] ) { return false ; } return true ; } 
protected function is_in_function_call ( $ stackPtr , $ valid_functions , $ global = true , $ allow_nested = false ) { if ( ! isset ( $ this -> tokens [ $ stackPtr ] [ 'nested_parenthesis' ] ) ) { return false ; } $ nested_parenthesis = $ this -> tokens [ $ stackPtr ] [ 'nested_parenthesis' ] ; if ( false === $ allow_nested ) { $ nested_parenthesis = array_reverse ( $ nested_parenthesis , true ) ; } foreach ( $ nested_parenthesis as $ open => $ close ) { $ prev_non_empty = $ this -> phpcsFile -> findPrevious ( Tokens :: $ emptyTokens , ( $ open - 1 ) , null , true , null , true ) ; if ( false === $ prev_non_empty || \ T_STRING !== $ this -> tokens [ $ prev_non_empty ] [ 'code' ] ) { continue ; } if ( isset ( $ valid_functions [ strtolower ( $ this -> tokens [ $ prev_non_empty ] [ 'content' ] ) ] ) === false ) { if ( false === $ allow_nested ) { * Now, make sure it is a global function. */ if ( $ this -> is_class_object_call ( $ prev_non_empty ) === true ) { continue ; } if ( $ this -> is_token_namespaced ( $ prev_non_empty ) === true ) { continue ; } return $ prev_non_empty ; } return false ; } 
protected function is_only_sanitized ( $ stackPtr ) { 
protected function is_safe_casted ( $ stackPtr ) { 
protected function is_sanitized ( $ stackPtr , $ require_unslash = false ) { * If this is a function callback (not a method callback array) and we're able * to resolve the function name, do so. */ $ first_non_empty = $ this -> phpcsFile -> findNext ( Tokens :: $ emptyTokens , $ callback [ 'start' ] , ( $ callback [ 'end' ] + 1 ) , true ) ; if ( false !== $ first_non_empty && \ T_CONSTANT_ENCAPSED_STRING === $ this -> tokens [ $ first_non_empty ] [ 'code' ] ) { $ functionName = $ this -> strip_quotes ( $ this -> tokens [ $ first_non_empty ] [ 'content' ] ) ; } } } 
protected function get_array_access_keys ( $ stackPtr , $ all = true ) { $ keys = array ( ) ; if ( \ T_VARIABLE !== $ this -> tokens [ $ stackPtr ] [ 'code' ] ) { return $ keys ; } $ current = $ stackPtr ; do { 
protected function get_array_access_key ( $ stackPtr ) { $ keys = $ this -> get_array_access_keys ( $ stackPtr , false ) ; if ( isset ( $ keys [ 0 ] ) ) { return $ keys [ 0 ] ; } return false ; } 
protected function is_validated ( $ stackPtr , $ array_keys = array ( ) , $ in_condition_only = false ) { if ( $ in_condition_only ) { * We are are more loose, requiring only that the variable be validated * in the same function/file scope as it is used. */ $ scope_start = 0 ; * For multi-level array access, the complete set of keys could be split between * the first and the second parameter, but could also be completely in the second * parameter, so we need to check both options. */ $ found_keys = $ this -> get_array_access_keys ( $ param2_first_token ) ; $ found_keys = array_map ( array ( $ this , 'strip_quotes' ) , $ found_keys ) ; 
protected function is_comparison ( $ stackPtr , $ include_coalesce = true ) { $ comparisonTokens = Tokens :: $ comparisonTokens ; if ( false === $ include_coalesce ) { unset ( $ comparisonTokens [ \ T_COALESCE ] ) ; } 
protected function is_in_array_comparison ( $ stackPtr ) { $ function_ptr = $ this -> is_in_function_call ( $ stackPtr , $ this -> arrayCompareFunctions , true , true ) ; if ( false === $ function_ptr ) { return false ; } $ function_name = $ this -> tokens [ $ function_ptr ] [ 'content' ] ; if ( true === $ this -> arrayCompareFunctions [ $ function_name ] ) { return true ; } if ( $ this -> get_function_call_parameter_count ( $ function_ptr ) >= $ this -> arrayCompareFunctions [ $ function_name ] ) { return true ; } return false ; } 
protected function get_use_type ( $ stackPtr ) { 
protected function get_interpolated_variables ( $ string ) { $ variables = array ( ) ; if ( preg_match_all ( '/(?P<backslashes>\\\\*)\$(?P<symbol>\w+)/' , $ string , $ match_sets , \ PREG_SET_ORDER ) ) { foreach ( $ match_sets as $ matches ) { if ( ! isset ( $ matches [ 'backslashes' ] ) || ( \ strlen ( $ matches [ 'backslashes' ] ) % 2 ) === 0 ) { $ variables [ ] = $ matches [ 'symbol' ] ; } } } return $ variables ; } 
public function strip_interpolated_variables ( $ string ) { if ( strpos ( $ string , '$' ) === false ) { return $ string ; } return preg_replace ( self :: REGEX_COMPLEX_VARS , '' , $ string ) ; } 
public function does_function_call_have_parameters ( $ stackPtr ) { 
public function get_function_call_parameter_count ( $ stackPtr ) { if ( false === $ this -> does_function_call_have_parameters ( $ stackPtr ) ) { return 0 ; } return \ count ( $ this -> get_function_call_parameters ( $ stackPtr ) ) ; } 
public function get_function_call_parameters ( $ stackPtr ) { if ( false === $ this -> does_function_call_have_parameters ( $ stackPtr ) ) { return array ( ) ; } * Check if there are more tokens before the closing parenthesis. * Prevents code like the following from setting a third parameter: * functionCall( $param1, $param2, ); */ $ has_next_param = $ this -> phpcsFile -> findNext ( Tokens :: $ emptyTokens , ( $ next_comma + 1 ) , $ closer , true , null , true ) ; if ( false === $ has_next_param ) { break ; } 
public function get_function_call_parameter ( $ stackPtr , $ param_offset ) { $ parameters = $ this -> get_function_call_parameters ( $ stackPtr ) ; if ( false === isset ( $ parameters [ $ param_offset ] ) ) { return false ; } return $ parameters [ $ param_offset ] ; } 
protected function find_array_open_close ( $ stackPtr ) { if ( \ T_ARRAY === $ this -> tokens [ $ stackPtr ] [ 'code' ] ) { if ( isset ( $ this -> tokens [ $ stackPtr ] [ 'parenthesis_opener' ] ) ) { $ opener = $ this -> tokens [ $ stackPtr ] [ 'parenthesis_opener' ] ; if ( isset ( $ this -> tokens [ $ opener ] [ 'parenthesis_closer' ] ) ) { $ closer = $ this -> tokens [ $ opener ] [ 'parenthesis_closer' ] ; } } } else { 
public function determine_namespace ( $ stackPtr ) { * Not in a scoped namespace, so let's see if we can find a non-scoped namespace instead. * Keeping in mind that: * - there can be multiple non-scoped namespaces in a file (bad practice, but it happens). * - the namespace keyword can also be used as part of a function/method call and such. * - that a non-named namespace resolves to the global namespace. */ $ previousNSToken = $ stackPtr ; $ namespace = false ; do { $ previousNSToken = $ this -> phpcsFile -> findPrevious ( \ T_NAMESPACE , ( $ previousNSToken - 1 ) ) ; // Stop if we encounter a scoped namespace declaration as we already know we're not in one. if ( ! empty ( $ this -> tokens [ $ previousNSToken ] [ 'scope_condition' ] ) && $ this -> tokens [ $ previousNSToken ] [ 'scope_condition' ] === $ previousNSToken ) { break ; } $ namespace = $ this -> get_declared_namespace_name ( $ previousNSToken ) ; } while ( false === $ namespace && false !== $ previousNSToken ) ; 
public function get_declared_namespace_name ( $ stackPtr ) { 
public function is_class_constant ( $ stackPtr ) { if ( ! isset ( $ this -> tokens [ $ stackPtr ] ) || \ T_CONST !== $ this -> tokens [ $ stackPtr ] [ 'code' ] ) { return false ; } 
public function is_class_property ( $ stackPtr ) { if ( ! isset ( $ this -> tokens [ $ stackPtr ] ) || \ T_VARIABLE !== $ this -> tokens [ $ stackPtr ] [ 'code' ] ) { return false ; } 
protected function valid_direct_scope ( $ stackPtr , array $ valid_scopes ) { if ( empty ( $ this -> tokens [ $ stackPtr ] [ 'conditions' ] ) ) { return false ; } $ conditions = array_keys ( $ this -> tokens [ $ stackPtr ] [ 'conditions' ] ) ; $ ptr = array_pop ( $ conditions ) ; if ( ! isset ( $ this -> tokens [ $ ptr ] ) ) { return false ; } if ( isset ( $ valid_scopes [ $ this -> tokens [ $ ptr ] [ 'type' ] ] ) ) { return $ ptr ; } return false ; } 
protected function is_wpdb_method_call ( $ stackPtr , $ target_methods ) { 
public function is_use_of_global_constant ( $ stackPtr ) { * Deal with a number of variations of use statements. */ for ( $ i = $ stackPtr ; $ i > 0 ; $ i -- ) { if ( $ this -> tokens [ $ i ] [ 'line' ] !== $ this -> tokens [ $ stackPtr ] [ 'line' ] ) { break ; } } $ firstOnLine = $ this -> phpcsFile -> findNext ( Tokens :: $ emptyTokens , ( $ i + 1 ) , null , true ) ; if ( false !== $ firstOnLine && \ T_USE === $ this -> tokens [ $ firstOnLine ] [ 'code' ] ) { $ nextOnLine = $ this -> phpcsFile -> findNext ( Tokens :: $ emptyTokens , ( $ firstOnLine + 1 ) , null , true ) ; if ( false !== $ nextOnLine ) { if ( \ T_STRING === $ this -> tokens [ $ nextOnLine ] [ 'code' ] && 'const' === $ this -> tokens [ $ nextOnLine ] [ 'content' ] ) { $ hasNsSep = $ this -> phpcsFile -> findNext ( \ T_NS_SEPARATOR , ( $ nextOnLine + 1 ) , $ stackPtr ) ; if ( false !== $ hasNsSep ) { 
protected function is_foreach_as ( $ stackPtr ) { if ( ! isset ( $ this -> tokens [ $ stackPtr ] [ 'nested_parenthesis' ] ) ) { return false ; } $ nested_parenthesis = $ this -> tokens [ $ stackPtr ] [ 'nested_parenthesis' ] ; $ close_parenthesis = end ( $ nested_parenthesis ) ; $ open_parenthesis = key ( $ nested_parenthesis ) ; if ( ! isset ( $ this -> tokens [ $ close_parenthesis ] [ 'parenthesis_owner' ] ) ) { return false ; } if ( \ T_FOREACH !== $ this -> tokens [ $ this -> tokens [ $ close_parenthesis ] [ 'parenthesis_owner' ] ] [ 'code' ] ) { return false ; } $ as_ptr = $ this -> phpcsFile -> findNext ( \ T_AS , ( $ open_parenthesis + 1 ) , $ close_parenthesis ) ; if ( false === $ as_ptr ) { 
public function process_token ( $ stackPtr ) { $ token = $ this -> tokens [ $ stackPtr ] ; if ( ! isset ( $ token [ 'bracket_closer' ] ) ) { $ this -> phpcsFile -> addWarning ( 'Missing bracket closer.' , $ stackPtr , 'MissingBracketCloser' ) ; return ; } $ need_spaces = $ this -> phpcsFile -> findNext ( array ( \ T_CONSTANT_ENCAPSED_STRING , \ T_LNUMBER , \ T_WHITESPACE , \ T_MINUS ) , ( $ stackPtr + 1 ) , $ token [ 'bracket_closer' ] , true ) ; $ spaced1 = ( \ T_WHITESPACE === $ this -> tokens [ ( $ stackPtr + 1 ) ] [ 'code' ] ) ; $ spaced2 = ( \ T_WHITESPACE === $ this -> tokens [ ( $ token [ 'bracket_closer' ] - 1 ) ] [ 'code' ] ) ; 
public function process_parameters ( $ stackPtr , $ group_name , $ matched_content , $ parameters ) { * Here be dragons - a double quoted string can contain extrapolated variables * which don't have to comply with these rules. */ if ( \ T_DOUBLE_QUOTED_STRING === $ this -> tokens [ $ i ] [ 'code' ] ) { $ transform = $ this -> transform_complex_string ( $ string , $ regex ) ; $ case_transform = $ this -> transform_complex_string ( $ string , $ regex , 'case' ) ; $ punct_transform = $ this -> transform_complex_string ( $ string , $ regex , 'punctuation' ) ; } else { $ transform = $ this -> transform ( $ string , $ regex ) ; $ case_transform = $ this -> transform ( $ string , $ regex , 'case' ) ; $ punct_transform = $ this -> transform ( $ string , $ regex , 'punctuation' ) ; } if ( $ string === $ transform ) { continue ; } if ( \ T_DOUBLE_QUOTED_STRING === $ this -> tokens [ $ i ] [ 'code' ] ) { $ expected [ $ i ] = '"' . $ transform . '"' ; } else { $ expected [ $ i ] = '\'' . $ transform . '\'' ; } if ( $ string !== $ case_transform ) { $ case_errors ++ ; } if ( $ string !== $ punct_transform ) { $ underscores ++ ; } } } $ data = array ( implode ( '' , $ expected ) , implode ( '' , $ content ) , ) ; if ( $ case_errors > 0 ) { $ error = 'Hook names should be lowercase. Expected: %s, but found: %s.' ; $ this -> phpcsFile -> addError ( $ error , $ stackPtr , 'NotLowercase' , $ data ) ; } if ( $ underscores > 0 ) { $ error = 'Words in hook names should be separated using underscores. Expected: %s, but found: %s.' ; $ this -> phpcsFile -> addWarning ( $ error , $ stackPtr , 'UseUnderscores' , $ data ) ; } } 
protected function prepare_regex ( ) { $ extra = '' ; if ( '' !== $ this -> additionalWordDelimiters && \ is_string ( $ this -> additionalWordDelimiters ) ) { $ extra = preg_quote ( $ this -> additionalWordDelimiters , '`' ) ; } return sprintf ( $ this -> punctuation_regex , $ extra ) ; } 
protected function transform ( $ string , $ regex , $ transform_type = 'full' ) { switch ( $ transform_type ) { case 'case' : return strtolower ( $ string ) ; case 'punctuation' : return preg_replace ( $ regex , '_' , $ string ) ; case 'full' : default : return preg_replace ( $ regex , '_' , strtolower ( $ string ) ) ; } } 
protected function transform_complex_string ( $ string , $ regex , $ transform_type = 'full' ) { $ output = preg_split ( '`([\{\}\$\[\] ])`' , $ string , - 1 , \ PREG_SPLIT_DELIM_CAPTURE ) ; $ is_variable = false ; $ has_braces = false ; $ braces = 0 ; foreach ( $ output as $ i => $ part ) { if ( \ in_array ( $ part , array ( '$' , '{' ) , true ) ) { $ is_variable = true ; if ( '{' === $ part ) { $ has_braces = true ; $ braces ++ ; } continue ; } if ( true === $ is_variable ) { if ( '[' === $ part ) { $ has_braces = true ; $ braces ++ ; } if ( \ in_array ( $ part , array ( '}' , ']' ) , true ) ) { $ braces -- ; } if ( false === $ has_braces && ' ' === $ part ) { $ is_variable = false ; $ output [ $ i ] = $ this -> transform ( $ part , $ regex , $ transform_type ) ; } if ( ( true === $ has_braces && 0 === $ braces ) && false === \ in_array ( $ output [ ( $ i + 1 ) ] , array ( '{' , '[' ) , true ) ) { $ has_braces = false ; $ is_variable = false ; } continue ; } $ output [ $ i ] = $ this -> transform ( $ part , $ regex , $ transform_type ) ; } return implode ( '' , $ output ) ; } 
public function getGroups ( ) { 
public function process_matched_token ( $ stackPtr , $ group_name , $ matched_content ) { $ this -> get_wp_version_from_cl ( ) ; $ class_name = ltrim ( strtolower ( $ matched_content ) , '\\' ) ; $ message = 'The %s class has been deprecated since WordPress version %s.' ; $ data = array ( ltrim ( $ matched_content , '\\' ) , $ this -> deprecated_classes [ $ class_name ] [ 'version' ] , ) ; if ( ! empty ( $ this -> deprecated_classes [ $ class_name ] [ 'alt' ] ) ) { $ message .= ' Use %s instead.' ; $ data [ ] = $ this -> deprecated_classes [ $ class_name ] [ 'alt' ] ; } $ this -> addMessage ( $ message , $ stackPtr , ( version_compare ( $ this -> deprecated_classes [ $ class_name ] [ 'version' ] , $ this -> minimum_supported_version , '<' ) ) , $ this -> string_to_errorcode ( $ class_name . 'Found' ) , $ data ) ; } 
public function process_parameters ( $ stackPtr , $ group_name , $ matched_content , $ parameters ) { $ this -> get_wp_version_from_cl ( ) ; $ param_count = \ count ( $ parameters ) ; foreach ( $ this -> target_functions [ $ matched_content ] as $ position => $ parameter_args ) { 
protected function process_parameter ( $ matched_content , $ parameter , $ parameter_args ) { $ parameter_position = $ this -> phpcsFile -> findNext ( Tokens :: $ emptyTokens , $ parameter [ 'start' ] , $ parameter [ 'end' ] + 1 , true ) ; if ( false === $ parameter_position ) { return ; } $ matched_parameter = $ this -> strip_quotes ( $ this -> tokens [ $ parameter_position ] [ 'content' ] ) ; if ( ! isset ( $ parameter_args [ $ matched_parameter ] ) ) { return ; } $ message = 'The parameter value "%s" has been deprecated since WordPress version %s.' ; $ data = array ( $ matched_parameter , $ parameter_args [ $ matched_parameter ] [ 'version' ] , ) ; if ( ! empty ( $ parameter_args [ $ matched_parameter ] [ 'alt' ] ) ) { $ message .= ' Use %s instead.' ; $ data [ ] = $ parameter_args [ $ matched_parameter ] [ 'alt' ] ; } $ is_error = version_compare ( $ parameter_args [ $ matched_parameter ] [ 'version' ] , $ this -> minimum_supported_version , '<' ) ; $ this -> addMessage ( $ message , $ parameter_position , $ is_error , $ this -> string_to_errorcode ( 'Found' ) , $ data ) ; } 
public function process_parameters ( $ stackPtr , $ group_name , $ matched_content , $ parameters ) { if ( \ count ( $ parameters ) > 1 ) { return ; } $ this -> phpcsFile -> addWarning ( 'Passing the $delimiter as the second parameter to preg_quote() is strongly recommended.' , $ stackPtr , 'Missing' ) ; } 
public function process_token ( $ stackPtr ) { if ( isset ( $ this -> target_functions [ strtolower ( $ this -> tokens [ $ stackPtr ] [ 'content' ] ) ] ) ) { 
public function process_arbitrary_tstring ( $ stackPtr ) { $ content = $ this -> tokens [ $ stackPtr ] [ 'content' ] ; if ( ! isset ( $ this -> discouraged_constants [ $ content ] ) ) { return ; } $ next = $ this -> phpcsFile -> findNext ( Tokens :: $ emptyTokens , ( $ stackPtr + 1 ) , null , true ) ; if ( false !== $ next && \ T_OPEN_PARENTHESIS === $ this -> tokens [ $ next ] [ 'code' ] ) { * Deal with a number of variations of use statements. */ for ( $ i = $ stackPtr ; $ i > 0 ; $ i -- ) { if ( $ this -> tokens [ $ i ] [ 'line' ] !== $ this -> tokens [ $ stackPtr ] [ 'line' ] ) { break ; } } $ first_on_line = $ this -> phpcsFile -> findNext ( Tokens :: $ emptyTokens , ( $ i + 1 ) , null , true ) ; if ( false !== $ first_on_line && \ T_USE === $ this -> tokens [ $ first_on_line ] [ 'code' ] ) { $ next_on_line = $ this -> phpcsFile -> findNext ( Tokens :: $ emptyTokens , ( $ first_on_line + 1 ) , null , true ) ; if ( false !== $ next_on_line ) { if ( ( \ T_STRING === $ this -> tokens [ $ next_on_line ] [ 'code' ] && 'const' === $ this -> tokens [ $ next_on_line ] [ 'content' ] ) || \ T_CONST === $ this -> tokens [ $ next_on_line ] [ 'code' ] 
public function process_parameters ( $ stackPtr , $ group_name , $ matched_content , $ parameters ) { $ function_name = strtolower ( $ matched_content ) ; $ target_param = $ this -> target_functions [ $ function_name ] ; 
public function process_token ( $ stackPtr ) { if ( ! $ this -> is_wpdb_method_call ( $ stackPtr , $ this -> target_methods ) ) { return ; } $ parameters = $ this -> get_function_call_parameters ( $ this -> methodPtr ) ; if ( empty ( $ parameters ) ) { return ; } $ query = $ parameters [ 1 ] ; $ text_string_tokens_found = false ; $ variable_found = false ; $ sql_wildcard_found = false ; $ total_placeholders = 0 ; $ total_parameters = \ count ( $ parameters ) ; $ valid_in_clauses = array ( 'uses_in' => 0 , 'implode_fill' => 0 , 'adjustment_count' => 0 , ) ; for ( $ i = $ query [ 'start' ] ; $ i <= $ query [ 'end' ] ; $ i ++ ) { * Analyse the query for incorrect LIKE queries. * * - `LIKE %s` is the only correct one. * - `LIKE '%s'` or `LIKE "%s"` will not be reported here, but in the quote check. * - Any other `LIKE` statement should be reported, either for using `LIKE` without * SQL wildcards or for not passing the SQL wildcards via the replacement. */ $ regex = '`\s+LIKE\s*(?:(' . $ regex_quote . ')(?!%s(?:\1|$))(?P<content>.*?)(?:\1|$)|(?:concat\((?![^\)]*%s[^\)]*\))(?P<concat>[^\)]*))\))`i' ; if ( preg_match_all ( $ regex , $ content , $ matches ) > 0 ) { $ walk = array ( ) ; if ( ! empty ( $ matches [ 'content' ] ) ) { $ matches [ 'content' ] = array_filter ( $ matches [ 'content' ] ) ; if ( ! empty ( $ matches [ 'content' ] ) ) { $ walk [ ] = 'content' ; } } if ( ! empty ( $ matches [ 'concat' ] ) ) { $ matches [ 'concat' ] = array_filter ( $ matches [ 'concat' ] ) ; if ( ! empty ( $ matches [ 'concat' ] ) ) { $ walk [ ] = 'concat' ; } } if ( ! empty ( $ walk ) ) { foreach ( $ walk as $ match_key ) { foreach ( $ matches [ $ match_key ] as $ index => $ match ) { $ data = array ( $ matches [ 0 ] [ $ index ] ) ; * Don't throw `UnescapedLiteral`, `UnsupportedPlaceholder` or `QuotedPlaceholder` * for this part of the SQL query. */ $ content = preg_replace ( '`' . preg_quote ( $ match , '`' ) . '`' , '' , $ content , 1 ) ; } } } unset ( $ matches , $ index , $ match , $ data ) ; } if ( strpos ( $ content , '%' ) === false ) { continue ; } /* * Analyse the query for unsupported placeholders. */ if ( preg_match_all ( self :: UNSUPPORTED_PLACEHOLDER_REGEX , $ content , $ matches ) > 0 ) { if ( ! empty ( $ matches [ 0 ] ) ) { foreach ( $ matches [ 0 ] as $ match ) { if ( '%' === $ match ) { $ this -> phpcsFile -> addError ( 'Found unescaped literal "%%" character.' , $ i , 'UnescapedLiteral' , array ( $ match ) ) ; } else { $ this -> phpcsFile -> addError ( 'Unsupported placeholder used in $wpdb->prepare(). Found: "%s".' , $ i , 'UnsupportedPlaceholder' , array ( $ match ) ) ; } } } unset ( $ match , $ matches ) ; } /* * Analyse the query for quoted placeholders. */ $ regex = '`(' . $ regex_quote . ')%[dfFs]\1`' ; if ( preg_match_all ( $ regex , $ content , $ matches ) > 0 ) { if ( ! empty ( $ matches [ 0 ] ) ) { foreach ( $ matches [ 0 ] as $ match ) { $ this -> phpcsFile -> addError ( 'Simple placeholders should not be quoted in the query string in $wpdb->prepare(). Found: %s.' , $ i , 'QuotedSimplePlaceholder' , array ( $ match ) ) ; } } unset ( $ match , $ matches ) ; } /* * Analyse the query for unquoted complex placeholders. */ $ regex = '`(?<!' . $ regex_quote . ')' . self :: PREPARE_PLACEHOLDER_REGEX . '(?!' . $ regex_quote . ')`x' ; if ( preg_match_all ( $ regex , $ content , $ matches ) > 0 ) { if ( ! empty ( $ matches [ 0 ] ) ) { foreach ( $ matches [ 0 ] as $ match ) { if ( preg_match ( '`%[dfFs]`' , $ match ) !== 1 ) { $ this -> phpcsFile -> addWarning ( 'Complex placeholders used for values in the query string in $wpdb->prepare() will NOT be quoted automagically. Found: %s.' , $ i , 'UnquotedComplexPlaceholder' , array ( $ match ) ) ; } } } unset ( $ match , $ matches ) ; } /* * Check for an ` IN (%s)` clause. */ $ found_in = preg_match_all ( '`\s+IN\s*\(\s*%s\s*\)`i' , $ content , $ matches ) ; if ( $ found_in > 0 ) { $ valid_in_clauses [ 'uses_in' ] += $ found_in ; } unset ( $ found_in ) ; } if ( false === $ text_string_tokens_found ) { // Query string passed in as a variable or function call, nothing to examine. return ; } $ count_diff_whitelisted = $ this -> has_whitelist_comment ( 'PreparedSQLPlaceholders replacement count' , $ stackPtr ) ; if ( 0 === $ total_placeholders ) { if ( 1 === $ total_parameters ) { if ( false === $ variable_found && false === $ sql_wildcard_found ) { /* * Only throw this warning if the PreparedSQL sniff won't throw one about * variables being found. * Also don't throw it if we just advised to use a replacement variable to pass a * string containing an SQL wildcard. */ $ this -> phpcsFile -> addWarning ( 'It is not necessary to prepare a query which doesn\'t use variable replacement.' , $ i , 'UnnecessaryPrepare' ) ; } } elseif ( false === $ count_diff_whitelisted && 0 === $ valid_in_clauses [ 'uses_in' ] ) { $ this -> phpcsFile -> addWarning ( 'Replacement variables found, but no valid placeholders found in the query.' , $ i , 'UnfinishedPrepare' ) ; } return ; } if ( 1 === $ total_parameters ) { $ this -> phpcsFile -> addError ( 'Placeholders found in the query passed to $wpdb->prepare(), but no replacements found. Expected %d replacement(s) parameters.' , $ stackPtr , 'MissingReplacements' , array ( $ total_placeholders ) ) ; return ; } if ( true === $ count_diff_whitelisted ) { return ; } $ replacements = $ parameters ; array_shift ( $ replacements ) ; * Verify that the correct amount of replacements have been passed. */ if ( $ total_replacements !== $ total_placeholders ) { $ this -> phpcsFile -> addWarning ( 'Incorrect number of replacements passed to $wpdb->prepare(). Found %d replacement parameters, expected %d.' , $ stackPtr , 'ReplacementsWrongNumber' , array ( $ total_replacements , $ total_placeholders ) ) ; } } 
protected function get_regex_quote_snippet ( $ stripped_content , $ original_content ) { $ regex_quote = $ this -> regex_quote ; if ( $ original_content !== $ stripped_content ) { $ quote_style = $ original_content [ 0 ] ; if ( '"' === $ quote_style ) { $ regex_quote = '\\\\"|\'' ; } elseif ( "'" === $ quote_style ) { $ regex_quote = '"|\\\\\'' ; } } return $ regex_quote ; } 
protected function analyse_sprintf ( $ sprintf_params ) { $ found = 0 ; unset ( $ sprintf_params [ 1 ] ) ; foreach ( $ sprintf_params as $ sprintf_param ) { if ( strpos ( strtolower ( $ sprintf_param [ 'raw' ] ) , 'implode' ) === false ) { continue ; } $ implode = $ this -> phpcsFile -> findNext ( Tokens :: $ emptyTokens , $ sprintf_param [ 'start' ] , $ sprintf_param [ 'end' ] , true ) ; if ( \ T_STRING === $ this -> tokens [ $ implode ] [ 'code' ] && 'implode' === strtolower ( $ this -> tokens [ $ implode ] [ 'content' ] ) ) { if ( $ this -> analyse_implode ( $ implode ) === true ) { ++ $ found ; } } } return $ found ; } 
protected function analyse_implode ( $ implode_token ) { $ implode_params = $ this -> get_function_call_parameters ( $ implode_token ) ; if ( empty ( $ implode_params ) || \ count ( $ implode_params ) !== 2 ) { return false ; } if ( preg_match ( '`^(["\']), ?\1$`' , $ implode_params [ 1 ] [ 'raw' ] ) !== 1 ) { return false ; } if ( strpos ( strtolower ( $ implode_params [ 2 ] [ 'raw' ] ) , 'array_fill' ) === false ) { return false ; } $ array_fill = $ this -> phpcsFile -> findNext ( Tokens :: $ emptyTokens , $ implode_params [ 2 ] [ 'start' ] , $ implode_params [ 2 ] [ 'end' ] , true ) ; if ( \ T_STRING !== $ this -> tokens [ $ array_fill ] [ 'code' ] || 'array_fill' !== strtolower ( $ this -> tokens [ $ array_fill ] [ 'content' ] ) ) { return false ; } $ array_fill_params = $ this -> get_function_call_parameters ( $ array_fill ) ; if ( empty ( $ array_fill_params ) || \ count ( $ array_fill_params ) !== 3 ) { return false ; } return ( bool ) preg_match ( '`^(["\'])%[dfFs]\1$`' , $ array_fill_params [ 3 ] [ 'raw' ] ) ; } 
public function process_token ( $ stackPtr ) { $ token = $ this -> tokens [ $ stackPtr ] ; if ( preg_match ( '# rel=\\\\?[\'"]?stylesheet\\\\?[\'"]?#' , $ token [ 'content' ] ) > 0 ) { $ this -> phpcsFile -> addError ( 'Stylesheets must be registered/enqueued via wp_enqueue_style' , $ stackPtr , 'NonEnqueuedStylesheet' ) ; } if ( preg_match ( '#<script[^>]*(?<=src=)#' , $ token [ 'content' ] ) > 0 ) { $ this -> phpcsFile -> addError ( 'Scripts must be registered/enqueued via wp_enqueue_script' , $ stackPtr , 'NonEnqueuedScript' ) ; } } 
public function process_parameters ( $ stackPtr , $ group_name , $ matched_content , $ parameters ) { $ option_name = $ this -> strip_quotes ( $ parameters [ 1 ] [ 'raw' ] ) ; $ option_value = $ this -> strip_quotes ( $ parameters [ 2 ] [ 'raw' ] ) ; if ( isset ( $ this -> whitelisted_options [ $ option_name ] ) ) { $ whitelisted_option = $ this -> whitelisted_options [ $ option_name ] ; if ( ! isset ( $ whitelisted_option [ 'valid_values' ] ) || in_array ( strtolower ( $ option_value ) , $ whitelisted_option [ 'valid_values' ] , true ) ) { return ; } } if ( isset ( $ this -> blacklisted_options [ $ option_name ] ) ) { $ blacklisted_option = $ this -> blacklisted_options [ $ option_name ] ; if ( ! isset ( $ blacklisted_option [ 'invalid_values' ] ) || in_array ( strtolower ( $ option_value ) , $ blacklisted_option [ 'invalid_values' ] , true ) ) { $ this -> phpcsFile -> addError ( '%s(%s, %s) found. %s' , $ stackPtr , $ this -> string_to_errorcode ( $ option_name . '_Blacklisted' ) , array ( $ matched_content , $ parameters [ 1 ] [ 'raw' ] , $ parameters [ 2 ] [ 'raw' ] , $ blacklisted_option [ 'message' ] , ) ) ; return ; } } $ this -> phpcsFile -> addWarning ( '%s(%s, %s) found. Changing configuration values at runtime is strongly discouraged.' , $ stackPtr , 'Risky' , array ( $ matched_content , $ parameters [ 1 ] [ 'raw' ] , $ parameters [ 2 ] [ 'raw' ] , ) ) ; } 
public function process_parameters ( $ stackPtr , $ group_name , $ matched_content , $ parameters ) { * Use a different error code when `false` is found to allow for excluding * the warning as this will be a conscious choice made by the dev. */ if ( isset ( $ parameters [ 3 ] ) && 'false' === strtolower ( $ parameters [ 3 ] [ 'raw' ] ) ) { $ errorcode = 'FoundNonStrictFalse' ; } $ this -> phpcsFile -> addWarning ( 'Not using strict comparison for %s; supply true for third argument.' , ( isset ( $ parameters [ 3 ] [ 'start' ] ) ? $ parameters [ 3 ] [ 'start' ] : $ parameters [ 1 ] [ 'start' ] ) , $ errorcode , array ( $ matched_content ) ) ; return ; } } 
public function register ( ) { 
public function process_token ( $ stackPtr ) { if ( $ this -> has_whitelist_comment ( 'spelling' , $ stackPtr ) ) { return ; } if ( \ T_OPEN_SHORT_ARRAY === $ this -> tokens [ $ stackPtr ] [ 'code' ] && isset ( $ this -> tokens [ $ stackPtr ] [ 'bracket_closer' ] ) ) { return $ this -> tokens [ $ stackPtr ] [ 'bracket_closer' ] ; } elseif ( \ T_ARRAY === $ this -> tokens [ $ stackPtr ] [ 'code' ] && isset ( $ this -> tokens [ $ stackPtr ] [ 'parenthesis_closer' ] ) ) { return $ this -> tokens [ $ stackPtr ] [ 'parenthesis_closer' ] ; } if ( isset ( Tokens :: $ ooScopeTokens [ $ this -> tokens [ $ stackPtr ] [ 'code' ] ] ) ) { $ classname = $ this -> phpcsFile -> getDeclarationName ( $ stackPtr ) ; if ( empty ( $ classname ) ) { return ; } if ( preg_match_all ( self :: WP_CLASSNAME_REGEX , $ classname , $ matches , \ PREG_PATTERN_ORDER ) > 0 ) { $ mispelled = $ this -> retrieve_misspellings ( $ matches [ 1 ] ) ; if ( ! empty ( $ mispelled ) ) { $ this -> phpcsFile -> addWarning ( 'Please spell "WordPress" correctly. Found: "%s" as part of the class/interface/trait name.' , $ stackPtr , 'MisspelledClassName' , array ( implode ( ', ' , $ mispelled ) ) ) ; } } return ; } * Prevent some typical false positives. */ if ( isset ( $ this -> text_and_comment_tokens [ $ this -> tokens [ $ stackPtr ] [ 'code' ] ] ) ) { $ offset = 0 ; foreach ( $ matches [ 1 ] as $ key => $ match_data ) { $ next_offset = ( $ match_data [ 1 ] + \ strlen ( $ match_data [ 0 ] ) ) ; 
protected function retrieve_misspellings ( $ match_stack ) { $ mispelled = array ( ) ; foreach ( $ match_stack as $ match ) { 
public function process_token ( $ stackPtr ) { if ( $ this -> has_whitelist_comment ( 'slow query' , $ stackPtr ) ) { return ; } elseif ( $ this -> has_whitelist_comment ( 'tax_query' , $ stackPtr ) ) { return ; } return parent :: process_token ( $ stackPtr ) ; } 
public function callback ( $ key , $ val , $ line , $ group ) { $ this -> posts_per_page = ( int ) $ this -> posts_per_page ; if ( $ val > $ this -> posts_per_page ) { return 'Detected high pagination limit, `%s` is set to `%s`' ; } return false ; } 
public function register ( ) { $ this -> classname_tokens = Tokens :: $ emptyTokens ; $ this -> classname_tokens [ \ T_NS_SEPARATOR ] = \ T_NS_SEPARATOR ; $ this -> classname_tokens [ \ T_STRING ] = \ T_STRING ; $ this -> classname_tokens [ \ T_SELF ] = \ T_SELF ; $ this -> classname_tokens [ \ T_STATIC ] = \ T_STATIC ; $ this -> classname_tokens [ \ T_PARENT ] = \ T_PARENT ; $ this -> classname_tokens [ \ T_ANON_CLASS ] = \ T_ANON_CLASS ; 
public function process_token ( $ stackPtr ) { * Check for new by reference used in PHP files. */ if ( 'PHP' === $ this -> phpcsFile -> tokenizerType ) { $ prev_non_empty = $ this -> phpcsFile -> findPrevious ( Tokens :: $ emptyTokens , ( $ stackPtr - 1 ) , null , true ) ; if ( false !== $ prev_non_empty && 'T_BITWISE_AND' === $ this -> tokens [ $ prev_non_empty ] [ 'type' ] ) { $ this -> phpcsFile -> recordMetric ( $ stackPtr , 'Assigning new by reference' , 'yes' ) ; $ this -> phpcsFile -> addError ( 'Assigning the return value of new by reference is no longer supported by PHP.' , $ stackPtr , 'NewByReferenceFound' ) ; } else { $ this -> phpcsFile -> recordMetric ( $ stackPtr , 'Assigning new by reference' , 'no' ) ; } } $ next_non_empty_after_class_name = $ this -> phpcsFile -> findNext ( $ this -> classname_tokens , ( $ stackPtr + 1 ) , null , true , null , true ) ; if ( false === $ next_non_empty_after_class_name ) { 
public function process_token ( $ stackPtr ) { $ array_open_close = $ this -> find_array_open_close ( $ stackPtr ) ; if ( false === $ array_open_close ) { * Check if this is a comma at the end of the last item in a single line array. */ if ( true === $ single_line && $ item_index === $ array_item_count ) { if ( true === $ is_comma ) { $ fix = $ this -> phpcsFile -> addFixableError ( 'Comma not allowed after last value in single-line array declaration' , $ maybe_comma , 'CommaAfterLast' ) ; if ( true === $ fix ) { $ this -> phpcsFile -> fixer -> replaceToken ( $ maybe_comma , '' ) ; } } continue ; } $ last_content = $ this -> phpcsFile -> findPrevious ( Tokens :: $ emptyTokens , $ item [ 'end' ] , $ item [ 'start' ] , true ) ; if ( false === $ last_content ) { * Make sure every item in a multi-line array has a comma at the end. * * Should in reality only be triggered by the last item in a multi-line array * as otherwise we'd have a parse error already. */ if ( false === $ is_comma && false === $ single_line ) { $ fix = $ this -> phpcsFile -> addFixableError ( 'Each array item in a multi-line array declaration must end in a comma' , $ last_content , 'NoComma' ) ; if ( true === $ fix ) { $ this -> phpcsFile -> fixer -> addContent ( $ last_content , ',' ) ; } } if ( false === $ is_comma ) { // Can't check spacing around the comma if there is no comma. continue ; } if ( $ last_content !== $ item [ 'end' ] * No need to worry about removing too much whitespace in * combination with a ` * is part of the comment, so we're good. */ break ; } } $ this -> phpcsFile -> fixer -> endChangeset ( ) ; } } if ( ! isset ( $ this -> tokens [ ( $ maybe_comma + 1 ) ] ) ) { // Shouldn't be able to happen, but just in case. continue ; } $ next_token = $ this -> tokens [ ( $ maybe_comma + 1 ) ] ; if ( \ T_WHITESPACE === $ next_token [ 'code' ] ) { if ( false === $ single_line && $ this -> phpcsFile -> eolChar === $ next_token [ 'content' ] ) { continue ; } $ next_non_whitespace = $ this -> phpcsFile -> findNext ( \ T_WHITESPACE , ( $ maybe_comma + 1 ) , $ closer , true ) ; if ( false === $ next_non_whitespace || ( false === $ single_line && $ this -> tokens [ $ next_non_whitespace ] [ 'line' ] === $ this -> tokens [ $ maybe_comma ] [ 'line' ] && ( \ T_COMMENT === $ this -> tokens [ $ next_non_whitespace ] [ 'code' ] || isset ( Tokens :: $ phpcsCommentTokens [ $ this -> tokens [ $ next_non_whitespace ] [ 'code' ] ] ) ) ) ) { continue ; } $ space_length = $ next_token [ 'length' ] ; if ( 1 === $ space_length ) { continue ; } $ fix = $ this -> phpcsFile -> addFixableError ( 'Expected 1 space between comma and "%s"; %s found' , $ maybe_comma , 'SpaceAfterComma' , array ( $ this -> tokens [ $ next_non_whitespace ] [ 'content' ] , $ space_length , ) ) ; if ( true === $ fix ) { $ this -> phpcsFile -> fixer -> replaceToken ( ( $ maybe_comma + 1 ) , ' ' ) ; } } else { 
protected function processTokenOutsideScope ( File $ phpcsFile , $ stackPtr ) { $ functionName = $ phpcsFile -> getDeclarationName ( $ stackPtr ) ; if ( ! isset ( $ functionName ) ) { 
protected function processTokenWithinScope ( File $ phpcsFile , $ stackPtr , $ currScope ) { $ tokens = $ phpcsFile -> getTokens ( ) ; 
public function process_token ( $ stackPtr ) { if ( ! isset ( $ this -> tab_width ) ) { $ this -> tab_width = PHPCSHelper :: get_tab_width ( $ this -> phpcsFile ) ; } * Indentation whitespace for subsequent lines of multi-line comments * are tokenized as part of the comment. */ $ comment = ltrim ( $ this -> tokens [ $ i ] [ 'content' ] ) ; $ whitespace = str_replace ( $ comment , '' , $ this -> tokens [ $ i ] [ 'content' ] ) ; $ length = \ strlen ( $ whitespace ) ; $ spaces = ( $ length % $ this -> tab_width ) ; if ( isset ( $ comment [ 0 ] ) && '*' === $ comment [ 0 ] && 0 !== $ spaces ) { -- $ spaces ; } break ; case 'T_INLINE_HTML' : if ( $ this -> tokens [ $ i ] [ 'content' ] === $ this -> phpcsFile -> eolChar ) { $ spaces = 0 ; } else { $ content = ltrim ( $ this -> tokens [ $ i ] [ 'content' ] ) ; $ whitespace = str_replace ( $ content , '' , $ this -> tokens [ $ i ] [ 'content' ] ) ; $ spaces = ( \ strlen ( $ whitespace ) % $ this -> tab_width ) ; } if ( isset ( $ content [ 0 ] ) && '*' === $ content [ 0 ] && 0 !== $ spaces ) { -- $ spaces ; } break ; } if ( $ spaces > 0 && ! $ this -> has_whitelist_comment ( 'precision alignment' , $ i ) ) { $ this -> phpcsFile -> addWarning ( 'Found precision alignment of %s spaces.' , $ i , 'Found' , array ( $ spaces ) ) ; } } 
public static function set_config_data ( $ key , $ value , $ temp = false ) { Config :: setConfigData ( $ key , $ value , $ temp ) ; } 
public static function get_tab_width ( File $ phpcsFile ) { $ tab_width = 4 ; if ( isset ( $ phpcsFile -> config -> tabWidth ) && $ phpcsFile -> config -> tabWidth > 0 ) { $ tab_width = $ phpcsFile -> config -> tabWidth ; } return $ tab_width ; } 
public static function ignore_annotations ( File $ phpcsFile = null ) { if ( isset ( $ phpcsFile , $ phpcsFile -> config -> annotations ) ) { return ! $ phpcsFile -> config -> annotations ; } else { $ annotations = Config :: getConfigData ( 'annotations' ) ; if ( isset ( $ annotations ) ) { return ! $ annotations ; } } } 
public function process_token ( $ stackPtr ) { $ token_code = $ this -> tokens [ $ stackPtr ] [ 'code' ] ; $ typecast = str_replace ( ' ' , '' , $ this -> tokens [ $ stackPtr ] [ 'content' ] ) ; $ typecast_lc = strtolower ( $ typecast ) ; switch ( $ token_code ) { case \ T_DOUBLE_CAST : if ( '(float)' !== $ typecast_lc ) { $ fix = $ this -> phpcsFile -> addFixableError ( 'Normalized type keywords must be used; expected "(float)" but found "%s"' , $ stackPtr , 'DoubleRealFound' , array ( $ typecast ) ) ; if ( true === $ fix ) { $ this -> phpcsFile -> fixer -> replaceToken ( $ stackPtr , '(float)' ) ; } } break ; case \ T_UNSET_CAST : $ this -> phpcsFile -> addWarning ( 'Using the "(unset)" cast is strongly discouraged. Use the "unset()" language construct or assign "null" as the value to the variable instead.' , $ stackPtr , 'UnsetFound' ) ; break ; case \ T_STRING_CAST : case \ T_BINARY_CAST : if ( \ T_STRING_CAST === $ token_code && '(binary)' !== $ typecast_lc ) { break ; } $ this -> phpcsFile -> addWarning ( 'Using binary casting is strongly discouraged. Found: "%s"' , $ stackPtr , 'BinaryFound' , array ( $ typecast ) ) ; break ; } } 
public function register ( ) { $ this -> empty_tokens = Tokens :: $ emptyTokens ; $ this -> empty_tokens [ \ T_NS_SEPARATOR ] = \ T_NS_SEPARATOR ; $ this -> empty_tokens [ \ T_BITWISE_AND ] = \ T_BITWISE_AND ; return array ( \ T_ASPERAND , ) ; } 
public function process_token ( $ stackPtr ) { * Check if the error silencing is done for one of the whitelisted functions. */ $ next_non_empty = $ this -> phpcsFile -> findNext ( $ this -> empty_tokens , ( $ stackPtr + 1 ) , null , true , null , true ) ; if ( false !== $ next_non_empty && \ T_STRING === $ this -> tokens [ $ next_non_empty ] [ 'code' ] ) { $ has_parenthesis = $ this -> phpcsFile -> findNext ( Tokens :: $ emptyTokens , ( $ next_non_empty + 1 ) , null , true , null , true ) ; if ( false !== $ has_parenthesis && \ T_OPEN_PARENTHESIS === $ this -> tokens [ $ has_parenthesis ] [ 'code' ] ) { $ function_name = strtolower ( $ this -> tokens [ $ next_non_empty ] [ 'content' ] ) ; if ( ( true === $ this -> use_default_whitelist && isset ( $ this -> function_whitelist [ $ function_name ] ) === true ) || in_array ( $ function_name , $ this -> custom_whitelist , true ) === true ) { $ this -> phpcsFile -> recordMetric ( $ stackPtr , 'Error silencing' , 'whitelisted function call: ' . $ function_name ) ; return ; } } } } $ this -> context_length = ( int ) $ this -> context_length ; $ context_length = $ this -> context_length ; if ( $ this -> context_length <= 0 ) { $ context_length = 2 ; } 
public function register ( ) { $ tokens = parent :: register ( ) ; $ tokens [ \ T_BOOLEAN_NOT ] = \ T_BOOLEAN_NOT ; $ tokens [ \ T_INSTANCEOF ] = \ T_INSTANCEOF ; $ logical_operators = Tokens :: $ booleanOperators ; 
public function register ( ) { 
public function process_token ( $ stackPtr ) { $ token = $ this -> tokens [ $ stackPtr ] ; * Examine variables within a function scope based on a `global` statement in the * function. * Examine variable not within a function scope and access to the `$GLOBALS` * variable based on the variable token. */ $ in_function_scope = $ this -> phpcsFile -> hasCondition ( $ stackPtr , array ( \ T_FUNCTION , \ T_CLOSURE ) ) ; if ( \ T_VARIABLE === $ token [ 'code' ] && ( '$GLOBALS' === $ token [ 'content' ] || ( false === $ in_function_scope && false === $ this -> treat_files_as_scoped ) ) ) { return $ this -> process_variable_assignment ( $ stackPtr ) ; } elseif ( \ T_GLOBAL === $ token [ 'code' ] && ( true === $ in_function_scope || true === $ this -> treat_files_as_scoped ) ) { return $ this -> process_global_statement ( $ stackPtr , $ in_function_scope ) ; } } 
protected function process_variable_assignment ( $ stackPtr ) { if ( $ this -> has_whitelist_comment ( 'override' , $ stackPtr ) === true ) { return ; } $ token = $ this -> tokens [ $ stackPtr ] ; $ var_name = substr ( $ token [ 'content' ] , 1 ) ; * If the globals array key contains a variable, constant, function call * or interpolated variable, bow out. */ if ( \ T_VARIABLE === $ this -> tokens [ $ ptr ] [ 'code' ] || \ T_STRING === $ this -> tokens [ $ ptr ] [ 'code' ] || \ T_DOUBLE_QUOTED_STRING === $ this -> tokens [ $ ptr ] [ 'code' ] ) { return ; } if ( \ T_CONSTANT_ENCAPSED_STRING === $ this -> tokens [ $ ptr ] [ 'code' ] ) { $ var_name .= $ this -> strip_quotes ( $ this -> tokens [ $ ptr ] [ 'content' ] ) ; } } if ( '' === $ var_name ) { * Is this one of the WP global variables ? */ if ( isset ( $ this -> wp_globals [ $ var_name ] ) === false ) { return ; } if ( false === $ this -> is_assignment ( $ stackPtr ) && false === $ this -> is_foreach_as ( $ stackPtr ) ) { return ; } if ( isset ( $ this -> tokens [ $ stackPtr ] [ 'nested_parenthesis' ] ) ) { foreach ( $ this -> tokens [ $ stackPtr ] [ 'nested_parenthesis' ] as $ opener => $ closer ) { if ( isset ( $ this -> tokens [ $ opener ] [ 'parenthesis_owner' ] ) && ( \ T_FUNCTION === $ this -> tokens [ $ this -> tokens [ $ opener ] [ 'parenthesis_owner' ] ] [ 'code' ] || \ T_CLOSURE === $ this -> tokens [ $ this -> tokens [ $ opener ] [ 'parenthesis_owner' ] ] [ 'code' ] ) ) { return ; } } unset ( $ opener , $ closer ) ; } if ( true === $ this -> is_class_property ( $ stackPtr ) ) { return ; } 
protected function process_global_statement ( $ stackPtr , $ in_function_scope ) { $ search = array ( ) ; $ ptr = ( $ stackPtr + 1 ) ; while ( isset ( $ this -> tokens [ $ ptr ] ) ) { $ var = $ this -> tokens [ $ ptr ] ; * Search for assignments to the imported global variables within the relevant scope. */ $ start = $ ptr ; if ( true === $ in_function_scope ) { $ function_cond = $ this -> phpcsFile -> getCondition ( $ stackPtr , \ T_FUNCTION ) ; $ closure_cond = $ this -> phpcsFile -> getCondition ( $ stackPtr , \ T_CLOSURE ) ; $ scope_cond = max ( $ function_cond , $ closure_cond ) ; 
protected function add_error ( $ stackPtr , $ data = array ( ) ) { if ( empty ( $ data ) ) { $ data [ ] = $ this -> tokens [ $ stackPtr ] [ 'content' ] ; } $ this -> phpcsFile -> addError ( 'Overriding WordPress globals is prohibited. Found assignment to %s' , $ stackPtr , 'Prohibited' , $ data ) ; } 
public function process_token ( $ stackPtr ) { $ this -> spaces_before_closure_open_paren = ( int ) $ this -> spaces_before_closure_open_paren ; if ( isset ( $ this -> tokens [ ( $ stackPtr + 1 ) ] ) && \ T_WHITESPACE !== $ this -> tokens [ ( $ stackPtr + 1 ) ] [ 'code' ] && ! ( \ T_ELSE === $ this -> tokens [ $ stackPtr ] [ 'code' ] && \ T_COLON === $ this -> tokens [ ( $ stackPtr + 1 ) ] [ 'code' ] ) && ! ( \ T_CLOSURE === $ this -> tokens [ $ stackPtr ] [ 'code' ] && 0 >= $ this -> spaces_before_closure_open_paren ) ) { $ error = 'Space after opening control structure is required' ; $ fix = $ this -> phpcsFile -> addFixableError ( $ error , $ stackPtr , 'NoSpaceAfterStructureOpen' ) ; if ( true === $ fix ) { $ this -> phpcsFile -> fixer -> addContent ( $ stackPtr , ' ' ) ; } } if ( ! isset ( $ this -> tokens [ $ stackPtr ] [ 'scope_closer' ] ) ) { if ( \ T_USE === $ this -> tokens [ $ stackPtr ] [ 'code' ] && 'closure' === $ this -> get_use_type ( $ stackPtr ) ) { $ scopeOpener = $ this -> phpcsFile -> findNext ( \ T_OPEN_CURLY_BRACKET , ( $ stackPtr + 1 ) ) ; $ scopeCloser = $ this -> tokens [ $ scopeOpener ] [ 'scope_closer' ] ; } elseif ( \ T_WHILE !== $ this -> tokens [ $ stackPtr ] [ 'code' ] ) { return ; } } else { $ scopeOpener = $ this -> tokens [ $ stackPtr ] [ 'scope_opener' ] ; $ scopeCloser = $ this -> tokens [ $ stackPtr ] [ 'scope_closer' ] ; } * PHPCS annotations, like normal inline comments, are tokenized including * the new line at the end, so don't add any extra as it would cause a fixer * conflict. */ if ( \ T_COMMENT !== $ this -> tokens [ $ lastContent ] [ 'code' ] && ! isset ( Tokens :: $ phpcsCommentTokens [ $ this -> tokens [ $ lastContent ] [ 'code' ] ] ) ) { $ this -> phpcsFile -> fixer -> addNewlineBefore ( $ j ) ; } $ this -> phpcsFile -> fixer -> endChangeset ( ) ; } break ; } } } } unset ( $ ignore ) ; } if ( ! isset ( $ scopeCloser ) || true !== $ this -> blank_line_after_check ) { return ; } // {@internal This is just for the blank line check. Only whitespace should be considered, // not "other" empty tokens.}} $ trailingContent = $ this -> phpcsFile -> findNext ( \ T_WHITESPACE , ( $ scopeCloser + 1 ) , null , true ) ; if ( false === $ trailingContent ) { return ; } if ( \ T_COMMENT === $ this -> tokens [ $ trailingContent ] [ 'code' ] || isset ( Tokens :: $ phpcsCommentTokens [ $ this -> tokens [ $ trailingContent ] [ 'code' ] ] ) ) { // Special exception for code where the comment about // an ELSE or ELSEIF is written between the control structures. $ nextCode = $ this -> phpcsFile -> findNext ( Tokens :: $ emptyTokens , ( $ scopeCloser + 1 ) , null , true ) ; if ( \ T_ELSE === $ this -> tokens [ $ nextCode ] [ 'code' ] || \ T_ELSEIF === $ this -> tokens [ $ nextCode ] [ 'code' ] ) { $ trailingContent = $ nextCode ; } // Move past end comments. if ( $ this -> tokens [ $ trailingContent ] [ 'line' ] === $ this -> tokens [ $ scopeCloser ] [ 'line' ] ) { if ( preg_match ( '`^ 
public function getGroups ( ) { 
public function process_matched_token ( $ stackPtr , $ group_name , $ matched_content ) { $ this -> get_wp_version_from_cl ( ) ; $ function_name = strtolower ( $ matched_content ) ; $ message = '%s() has been deprecated since WordPress version %s.' ; $ data = array ( $ matched_content , $ this -> deprecated_functions [ $ function_name ] [ 'version' ] , ) ; if ( ! empty ( $ this -> deprecated_functions [ $ function_name ] [ 'alt' ] ) ) { $ message .= ' Use %s instead.' ; $ data [ ] = $ this -> deprecated_functions [ $ function_name ] [ 'alt' ] ; } $ this -> addMessage ( $ message , $ stackPtr , ( version_compare ( $ this -> deprecated_functions [ $ function_name ] [ 'version' ] , $ this -> minimum_supported_version , '<' ) ) , $ this -> string_to_errorcode ( $ matched_content . 'Found' ) , $ data ) ; } 
public function process_token ( $ stackPtr ) { if ( \ T_WHITESPACE !== $ this -> tokens [ ( $ stackPtr - 1 ) ] [ 'code' ] ) { $ error = 'No space before opening casting parenthesis is prohibited' ; $ fix = $ this -> phpcsFile -> addFixableError ( $ error , $ stackPtr , 'NoSpaceBeforeOpenParenthesis' ) ; if ( true === $ fix ) { $ this -> phpcsFile -> fixer -> addContentBefore ( $ stackPtr , ' ' ) ; } } } 
protected function setup_groups ( $ key ) { 
public function process_token ( $ stackPtr ) { $ this -> excluded_groups = $ this -> merge_custom_array ( $ this -> exclude ) ; if ( array_diff_key ( $ this -> groups , $ this -> excluded_groups ) === array ( ) ) { 
public function is_targetted_token ( $ stackPtr ) { 
public function check_for_matches ( $ stackPtr ) { $ token_content = strtolower ( $ this -> tokens [ $ stackPtr ] [ 'content' ] ) ; $ skip_to = array ( ) ; foreach ( $ this -> groups as $ groupName => $ group ) { if ( isset ( $ this -> excluded_groups [ $ groupName ] ) ) { continue ; } if ( isset ( $ group [ 'whitelist' ] [ $ token_content ] ) ) { continue ; } if ( preg_match ( $ group [ 'regex' ] , $ token_content ) === 1 ) { $ skip_to [ ] = $ this -> process_matched_token ( $ stackPtr , $ groupName , $ token_content ) ; } } if ( empty ( $ skip_to ) || min ( $ skip_to ) === 0 ) { return ; } return min ( $ skip_to ) ; } 
public function process_matched_token ( $ stackPtr , $ group_name , $ matched_content ) { $ this -> addMessage ( $ this -> groups [ $ group_name ] [ 'message' ] , $ stackPtr , ( 'error' === $ this -> groups [ $ group_name ] [ 'type' ] ) , $ this -> string_to_errorcode ( $ group_name . '_' . $ matched_content ) , array ( $ matched_content ) ) ; } 
public function register ( ) { 
public function getGroups ( ) { $ this -> target_functions = $ this -> hookInvokeFunctions ; $ this -> target_functions [ 'define' ] = true ; return parent :: getGroups ( ) ; } 
public function process_token ( $ stackPtr ) { if ( $ this -> has_whitelist_comment ( 'prefix' , $ stackPtr ) ) { return ; } 
protected function process_variable_variable ( $ stackPtr ) { static $ indicators = array ( \ T_OPEN_CURLY_BRACKET => true , \ T_VARIABLE => true , ) ; * Local variable variables in a function do not need to be prefixed. * But a variable variable could evaluate to the name of an imported global * variable. * Not concerned with imported variable variables (global.. ) as that has been * forbidden since PHP 7.0. Presuming cross-version code and if not, that * is for the PHPCompatibility standard to detect. */ if ( $ this -> phpcsFile -> hasCondition ( $ stackPtr , array ( \ T_FUNCTION , \ T_CLOSURE ) ) === true ) { $ condition = $ this -> phpcsFile -> getCondition ( $ stackPtr , \ T_FUNCTION ) ; if ( false === $ condition ) { $ condition = $ this -> phpcsFile -> getCondition ( $ stackPtr , \ T_CLOSURE ) ; } $ has_global = $ this -> phpcsFile -> findPrevious ( \ T_GLOBAL , ( $ stackPtr - 1 ) , $ this -> tokens [ $ condition ] [ 'scope_opener' ] ) ; if ( false === $ has_global ) { 
protected function process_variable_assignment ( $ stackPtr ) { if ( false === $ this -> is_assignment ( $ stackPtr ) && false === $ this -> is_foreach_as ( $ stackPtr ) ) { return ; } $ is_error = true ; $ variable_name = substr ( $ this -> tokens [ $ stackPtr ] [ 'content' ] , 1 ) ; 
public function process_parameters ( $ stackPtr , $ group_name , $ matched_content , $ parameters ) { 
private function is_prefixed ( $ stackPtr , $ name ) { foreach ( $ this -> validated_prefixes as $ prefix ) { if ( stripos ( $ name , $ prefix ) === 0 ) { $ this -> phpcsFile -> recordMetric ( $ stackPtr , 'Prefix all globals: allowed prefixes' , $ prefix ) ; return true ; } } return false ; } 
private function variable_prefixed_or_whitelisted ( $ stackPtr , $ name ) { 
private function validate_prefixes ( ) { if ( $ this -> previous_prefixes === $ this -> prefixes ) { return ; } * Replace non-word characters in the prefix with a regex snippet, but only if the * string doesn't already contain namespace separators. */ $ is_regex = false ; if ( strpos ( $ prefix , '\\' ) === false && preg_match ( '`[_\W]`' , $ prefix ) > 0 ) { $ prefix = preg_replace ( '`([_\W])`' , '[\\\\\\\\$1]' , $ prefixLC ) ; $ is_regex = true ; } $ ns_prefixes [ $ prefixLC ] = array ( 'prefix' => $ prefix , 'is_regex' => $ is_regex , ) ; } 
private function record_potential_prefix_metric ( $ stackPtr , $ construct_name ) { if ( preg_match ( '`^([A-Z]*[a-z0-9]*+)`' , ltrim ( $ construct_name , '\$_' ) , $ matches ) > 0 && isset ( $ matches [ 1 ] ) && '' !== $ matches [ 1 ] ) { $ this -> phpcsFile -> recordMetric ( $ stackPtr , 'Prefix all globals: potential prefixes - start of non-prefixed construct' , strtolower ( $ matches [ 1 ] ) ) ; } } 
protected function setup_groups ( ) { $ this -> groups_cache = $ this -> getGroups ( ) ; if ( empty ( $ this -> groups_cache ) && empty ( self :: $ groups ) ) { return false ; } 
public function process_token ( $ stackPtr ) { $ this -> excluded_groups = $ this -> merge_custom_array ( $ this -> exclude ) ; if ( array_diff_key ( $ this -> groups_cache , $ this -> excluded_groups ) === array ( ) ) { * Covers: * $foo = array( 'bar' => 'taz' ); * $foo['bar'] = $taz; */ if ( \ in_array ( $ token [ 'code' ] , array ( \ T_CLOSE_SQUARE_BRACKET , \ T_DOUBLE_ARROW ) , true ) ) { $ operator = $ stackPtr ; 
public function process_token ( $ stackPtr ) { $ array_open_close = $ this -> find_array_open_close ( $ stackPtr ) ; if ( false === $ array_open_close ) { 
protected function process_single_line_array ( $ stackPtr , $ items , $ opener , $ closer ) { $ next_arrow = $ this -> phpcsFile -> findNext ( \ T_DOUBLE_ARROW , ( $ opener + 1 ) , $ closer ) ; while ( false !== $ next_arrow ) { if ( \ T_WHITESPACE === $ this -> tokens [ ( $ next_arrow - 1 ) ] [ 'code' ] ) { $ space_length = $ this -> tokens [ ( $ next_arrow - 1 ) ] [ 'length' ] ; if ( 1 !== $ space_length ) { $ error = 'Expected 1 space between "%s" and double arrow; %s found' ; $ data = array ( $ this -> tokens [ ( $ next_arrow - 2 ) ] [ 'content' ] , $ space_length , ) ; $ fix = $ this -> phpcsFile -> addFixableWarning ( $ error , $ next_arrow , 'SpaceBeforeDoubleArrow' , $ data ) ; if ( true === $ fix ) { $ this -> phpcsFile -> fixer -> replaceToken ( ( $ next_arrow - 1 ) , ' ' ) ; } } } 
protected function process_multi_line_array ( $ stackPtr , $ items , $ opener , $ closer ) { $ this -> maxColumn = ( int ) $ this -> maxColumn ; $ this -> validate_align_multiline_items ( ) ; $ index_end_cols = array ( ) ; * Determine whether the operators for multi-line items should be aligned. */ if ( 'always' === $ this -> alignMultilineItems ) { $ alignMultilineItems = true ; } elseif ( 'never' === $ this -> alignMultilineItems ) { $ alignMultilineItems = false ; } else { $ percentage = ( string ) round ( ( $ multi_line_count / $ total_items ) * 100 , 0 ) ; * If necessary, rebuild the $index_end_cols and $double_arrow_cols arrays * excluding multi-line items. */ if ( false === $ alignMultilineItems ) { $ select_index_end_cols = array ( ) ; $ double_arrow_cols = array ( ) ; foreach ( $ items as $ item ) { if ( false === $ item [ 'single_line' ] ) { continue ; } if ( ( $ item [ 'last_index_col' ] + 2 ) <= $ this -> maxColumn ) { $ select_index_end_cols [ ] = $ item [ 'last_index_col' ] ; } if ( ! isset ( $ double_arrow_cols [ $ this -> tokens [ $ item [ 'operatorPtr' ] ] [ 'column' ] ] ) ) { $ double_arrow_cols [ $ this -> tokens [ $ item [ 'operatorPtr' ] ] [ 'column' ] ] = 1 ; } else { $ double_arrow_cols [ $ this -> tokens [ $ item [ 'operatorPtr' ] ] [ 'column' ] ] ++ ; } } } if ( ! empty ( $ select_index_end_cols ) ) { $ max_index_width = max ( $ select_index_end_cols ) ; } else { $ max_index_width = max ( $ index_end_cols ) ; } $ expected_col = ( $ max_index_width + 2 ) ; if ( false === $ this -> exact && ! empty ( $ double_arrow_cols ) ) { arsort ( $ double_arrow_cols , \ SORT_NUMERIC ) ; reset ( $ double_arrow_cols ) ; $ count = current ( $ double_arrow_cols ) ; if ( $ count > 1 || ( 1 === $ count && \ count ( $ items ) === 1 ) ) { * Verify and correct the spacing around the double arrows. */ foreach ( $ items as $ item ) { if ( $ this -> tokens [ $ item [ 'operatorPtr' ] ] [ 'column' ] === $ expected_col && $ this -> tokens [ $ item [ 'operatorPtr' ] ] [ 'line' ] === $ this -> tokens [ $ item [ 'last_index_token' ] ] [ 'line' ] ) { * Deal with index sizes larger than maxColumn and with multi-line * array items which should not be aligned. */ if ( ( $ item [ 'last_index_col' ] + 2 ) > $ this -> maxColumn || ( false === $ alignMultilineItems && false === $ item [ 'single_line' ] ) ) { if ( ( $ item [ 'last_index_col' ] + 2 ) === $ this -> tokens [ $ item [ 'operatorPtr' ] ] [ 'column' ] && $ this -> tokens [ $ item [ 'operatorPtr' ] ] [ 'line' ] === $ this -> tokens [ $ item [ 'last_index_token' ] ] [ 'line' ] ) { * Deal with the space before double arrows in all other cases. */ $ expected_whitespace = $ expected_col - ( $ this -> tokens [ $ item [ 'last_index_token' ] ] [ 'column' ] + $ this -> tokens [ $ item [ 'last_index_token' ] ] [ 'length' ] ) ; $ fix = $ this -> phpcsFile -> addFixableWarning ( 'Array double arrow not aligned correctly; expected %s space(s) between "%s" and double arrow, but found %s.' , $ item [ 'operatorPtr' ] , 'DoubleArrowNotAligned' , array ( $ expected_whitespace , $ this -> tokens [ $ item [ 'last_index_token' ] ] [ 'content' ] , $ before , ) ) ; if ( true === $ fix ) { if ( 0 === $ before || 'newline' === $ before ) { $ this -> phpcsFile -> fixer -> beginChangeset ( ) ; 
protected function validate_align_multiline_items ( ) { $ alignMultilineItems = $ this -> alignMultilineItems ; if ( 'always' === $ alignMultilineItems || 'never' === $ alignMultilineItems ) { return ; } else { 
public function process_token ( $ stackPtr ) { if ( ! $ this -> is_wpdb_method_call ( $ stackPtr , $ this -> methods ) ) { return ; } if ( $ this -> has_whitelist_comment ( 'unprepared SQL' , $ stackPtr ) ) { return ; } for ( $ this -> i ; $ this -> i < $ this -> end ; $ this -> i ++ ) { if ( isset ( $ this -> ignored_tokens [ $ this -> tokens [ $ this -> i ] [ 'code' ] ] ) ) { continue ; } if ( \ T_DOUBLE_QUOTED_STRING === $ this -> tokens [ $ this -> i ] [ 'code' ] || \ T_HEREDOC === $ this -> tokens [ $ this -> i ] [ 'code' ] ) { $ bad_variables = array_filter ( $ this -> get_interpolated_variables ( $ this -> tokens [ $ this -> i ] [ 'content' ] ) , function ( $ symbol ) { return ( 'wpdb' !== $ symbol ) ; } ) ; foreach ( $ bad_variables as $ bad_variable ) { $ this -> phpcsFile -> addError ( 'Use placeholders and $wpdb->prepare(); found interpolated variable $%s at %s' , $ this -> i , 'InterpolatedNotPrepared' , array ( $ bad_variable , $ this -> tokens [ $ this -> i ] [ 'content' ] , ) ) ; } continue ; } if ( \ T_VARIABLE === $ this -> tokens [ $ this -> i ] [ 'code' ] ) { if ( '$wpdb' === $ this -> tokens [ $ this -> i ] [ 'content' ] ) { $ this -> is_wpdb_method_call ( $ this -> i , $ this -> methods ) ; continue ; } if ( $ this -> is_safe_casted ( $ this -> i ) ) { continue ; } } if ( \ T_STRING === $ this -> tokens [ $ this -> i ] [ 'code' ] ) { if ( isset ( $ this -> SQLEscapingFunctions [ $ this -> tokens [ $ this -> i ] [ 'content' ] ] ) || isset ( $ this -> SQLAutoEscapedFunctions [ $ this -> tokens [ $ this -> i ] [ 'content' ] ] ) ) { 
public function process_token ( $ stackPtr ) { switch ( $ this -> tokens [ $ stackPtr ] [ 'type' ] ) { case 'T_SEMICOLON' : $ prevNonEmpty = $ this -> phpcsFile -> findPrevious ( Tokens :: $ emptyTokens , ( $ stackPtr - 1 ) , null , true ) ; if ( false === $ prevNonEmpty || ( \ T_SEMICOLON !== $ this -> tokens [ $ prevNonEmpty ] [ 'code' ] && \ T_OPEN_TAG !== $ this -> tokens [ $ prevNonEmpty ] [ 'code' ] && \ T_OPEN_TAG_WITH_ECHO !== $ this -> tokens [ $ prevNonEmpty ] [ 'code' ] ) ) { return ; } if ( isset ( $ this -> tokens [ $ stackPtr ] [ 'nested_parenthesis' ] ) ) { $ nested = $ this -> tokens [ $ stackPtr ] [ 'nested_parenthesis' ] ; $ last_closer = array_pop ( $ nested ) ; if ( isset ( $ this -> tokens [ $ last_closer ] [ 'parenthesis_owner' ] ) && \ T_FOR === $ this -> tokens [ $ this -> tokens [ $ last_closer ] [ 'parenthesis_owner' ] ] [ 'code' ] ) { * Check for superfluous whitespace after the semi-colon which will be * removed as the `<?php ` open tag token already contains whitespace, * either a space or a new line and in case of a new line, the indentation * should be done via tabs, so spaces can be safely removed. */ if ( \ T_WHITESPACE === $ this -> tokens [ ( $ stackPtr + 1 ) ] [ 'code' ] ) { $ replacement = str_replace ( ' ' , '' , $ this -> tokens [ ( $ stackPtr + 1 ) ] [ 'content' ] ) ; $ this -> phpcsFile -> fixer -> replaceToken ( ( $ stackPtr + 1 ) , $ replacement ) ; } } for ( $ i = $ stackPtr ; $ i > $ prevNonEmpty ; $ i -- ) { if ( \ T_SEMICOLON !== $ this -> tokens [ $ i ] [ 'code' ] && \ T_WHITESPACE !== $ this -> tokens [ $ i ] [ 'code' ] ) { break ; } $ this -> phpcsFile -> fixer -> replaceToken ( $ i , '' ) ; } $ this -> phpcsFile -> fixer -> endChangeset ( ) ; } break ; case 'T_CLOSE_TAG' : $ prevNonEmpty = $ this -> phpcsFile -> findPrevious ( \ T_WHITESPACE , ( $ stackPtr - 1 ) , null , true ) ; if ( false === $ prevNonEmpty || ( \ T_OPEN_TAG !== $ this -> tokens [ $ prevNonEmpty ] [ 'code' ] && \ T_OPEN_TAG_WITH_ECHO !== $ this -> tokens [ $ prevNonEmpty ] [ 'code' ] ) ) { return ; } $ fix = $ this -> phpcsFile -> addFixableWarning ( 'Empty PHP open/close tag combination detected.' , $ prevNonEmpty , 'EmptyPHPOpenCloseTagsDetected' ) ; if ( true === $ fix ) { $ this -> phpcsFile -> fixer -> beginChangeset ( ) ; for ( $ i = $ prevNonEmpty ; $ i <= $ stackPtr ; $ i ++ ) { $ this -> phpcsFile -> fixer -> replaceToken ( $ i , '' ) ; } $ this -> phpcsFile -> fixer -> endChangeset ( ) ; } break ; default : break ; } } 
public function process_token ( $ stackPtr ) { $ this -> mergeFunctionLists ( ) ; $ function = $ this -> tokens [ $ stackPtr ] [ 'content' ] ; * If this is a function callback (not a method callback array) and we're able * to resolve the function name, do so. */ $ mapped_function = $ this -> phpcsFile -> findNext ( Tokens :: $ emptyTokens , $ callback [ 'start' ] , ( $ callback [ 'end' ] + 1 ) , true ) ; if ( false !== $ mapped_function && \ T_CONSTANT_ENCAPSED_STRING === $ this -> tokens [ $ mapped_function ] [ 'code' ] ) { $ functionName = $ this -> strip_quotes ( $ this -> tokens [ $ mapped_function ] [ 'content' ] ) ; $ ptr = $ mapped_function ; } } } // Skip pointer to after the function. // If this is a formatting function we just skip over the opening // parenthesis. Otherwise we skip all the way to the closing. if ( $ is_formatting_function ) { $ i = ( $ function_opener + 1 ) ; $ watch = true ; } else { if ( isset ( $ this -> tokens [ $ function_opener ] [ 'parenthesis_closer' ] ) ) { $ i = $ this -> tokens [ $ function_opener ] [ 'parenthesis_closer' ] ; } else { // Live coding or parse error. break ; } } } // If this is a safe function, we don't flag it. if ( $ is_formatting_function || isset ( $ this -> autoEscapedFunctions [ $ functionName ] ) || isset ( $ this -> escapingFunctions [ $ functionName ] ) ) { continue ; } $ content = $ functionName ; } else { $ content = $ this -> tokens [ $ i ] [ 'content' ] ; $ ptr = $ i ; } $ this -> phpcsFile -> addError ( "All output should be run through an escaping function (see the Security sections in the WordPress Developer Handbooks), found '%s'." , $ ptr , 'OutputNotEscaped' , $ content ) ; } return $ end_of_statement ; } 
protected function mergeFunctionLists ( ) { if ( $ this -> customEscapingFunctions !== $ this -> addedCustomFunctions [ 'escape' ] ) { $ customEscapeFunctions = $ this -> merge_custom_array ( $ this -> customEscapingFunctions , array ( ) , false ) ; $ this -> escapingFunctions = $ this -> merge_custom_array ( $ customEscapeFunctions , $ this -> escapingFunctions ) ; $ this -> addedCustomFunctions [ 'escape' ] = $ this -> customEscapingFunctions ; } if ( $ this -> customAutoEscapedFunctions !== $ this -> addedCustomFunctions [ 'autoescape' ] ) { $ this -> autoEscapedFunctions = $ this -> merge_custom_array ( $ this -> customAutoEscapedFunctions , $ this -> autoEscapedFunctions ) ; $ this -> addedCustomFunctions [ 'autoescape' ] = $ this -> customAutoEscapedFunctions ; } if ( $ this -> customPrintingFunctions !== $ this -> addedCustomFunctions [ 'print' ] ) { $ this -> printingFunctions = $ this -> merge_custom_array ( $ this -> customPrintingFunctions , $ this -> printingFunctions ) ; $ this -> addedCustomFunctions [ 'print' ] = $ this -> customPrintingFunctions ; } } 
public function process_token ( $ stackPtr ) { $ array_open_close = $ this -> find_array_open_close ( $ stackPtr ) ; if ( false === $ array_open_close ) { * Long arrays only: Check for space between the array keyword and the open parenthesis. */ if ( \ T_ARRAY === $ this -> tokens [ $ stackPtr ] [ 'code' ] ) { if ( ( $ stackPtr + 1 ) !== $ opener ) { $ error = 'There must be no space between the "array" keyword and the opening parenthesis' ; $ error_code = 'SpaceAfterKeyword' ; $ nextNonWhitespace = $ this -> phpcsFile -> findNext ( \ T_WHITESPACE , ( $ stackPtr + 1 ) , ( $ opener + 1 ) , true ) ; if ( $ nextNonWhitespace !== $ opener ) { * Check for empty arrays. */ $ nextNonWhitespace = $ this -> phpcsFile -> findNext ( \ T_WHITESPACE , ( $ opener + 1 ) , ( $ closer + 1 ) , true ) ; if ( $ nextNonWhitespace === $ closer ) { if ( ( $ opener + 1 ) !== $ closer ) { $ fix = $ this -> phpcsFile -> addFixableError ( 'Empty array declaration must have no space between the parentheses' , $ stackPtr , 'SpaceInEmptyArray' ) ; if ( true === $ fix ) { $ this -> phpcsFile -> fixer -> beginChangeset ( ) ; for ( $ i = ( $ opener + 1 ) ; $ i < $ closer ; $ i ++ ) { $ this -> phpcsFile -> fixer -> replaceToken ( $ i , '' ) ; } $ this -> phpcsFile -> fixer -> endChangeset ( ) ; unset ( $ i ) ; } } 
protected function process_single_line_array ( $ stackPtr , $ opener , $ closer ) { $ array_has_keys = $ this -> phpcsFile -> findNext ( \ T_DOUBLE_ARROW , $ opener , $ closer ) ; if ( false !== $ array_has_keys ) { $ array_items = $ this -> get_function_call_parameters ( $ stackPtr ) ; if ( ( false === $ this -> allow_single_item_single_line_associative_arrays && ! empty ( $ array_items ) ) || ( true === $ this -> allow_single_item_single_line_associative_arrays && \ count ( $ array_items ) > 1 ) ) { $ array_has_keys = false ; * Add a line break before the first non-empty token in the array item. * Prevents extraneous whitespace at the start of the line which could be * interpreted as alignment whitespace. */ $ first_non_empty = $ this -> phpcsFile -> findNext ( Tokens :: $ emptyTokens , $ item [ 'start' ] , ( $ item [ 'end' ] + 1 ) , true ) ; if ( false === $ first_non_empty ) { continue ; } if ( $ item [ 'start' ] <= ( $ first_non_empty - 1 ) && \ T_WHITESPACE === $ this -> tokens [ ( $ first_non_empty - 1 ) ] [ 'code' ] ) { * Check that there is a single space after the array opener and before the array closer. */ if ( \ T_WHITESPACE !== $ this -> tokens [ ( $ opener + 1 ) ] [ 'code' ] ) { $ fix = $ this -> phpcsFile -> addFixableError ( 'Missing space after array opener.' , $ opener , 'NoSpaceAfterArrayOpener' ) ; if ( true === $ fix ) { $ this -> phpcsFile -> fixer -> addContent ( $ opener , ' ' ) ; } } elseif ( ' ' !== $ this -> tokens [ ( $ opener + 1 ) ] [ 'content' ] ) { $ fix = $ this -> phpcsFile -> addFixableError ( 'Expected 1 space after array opener, found %s.' , $ opener , 'SpaceAfterArrayOpener' , array ( \ strlen ( $ this -> tokens [ ( $ opener + 1 ) ] [ 'content' ] ) ) ) ; if ( true === $ fix ) { $ this -> phpcsFile -> fixer -> replaceToken ( ( $ opener + 1 ) , ' ' ) ; } } if ( \ T_WHITESPACE !== $ this -> tokens [ ( $ closer - 1 ) ] [ 'code' ] ) { $ fix = $ this -> phpcsFile -> addFixableError ( 'Missing space before array closer.' , $ closer , 'NoSpaceBeforeArrayCloser' ) ; if ( true === $ fix ) { $ this -> phpcsFile -> fixer -> addContentBefore ( $ closer , ' ' ) ; } } elseif ( ' ' !== $ this -> tokens [ ( $ closer - 1 ) ] [ 'content' ] ) { $ fix = $ this -> phpcsFile -> addFixableError ( 'Expected 1 space before array closer, found %s.' , $ closer , 'SpaceBeforeArrayCloser' , array ( \ strlen ( $ this -> tokens [ ( $ closer - 1 ) ] [ 'content' ] ) ) ) ; if ( true === $ fix ) { $ this -> phpcsFile -> fixer -> replaceToken ( ( $ closer - 1 ) , ' ' ) ; } } } 
protected function process_multi_line_array ( $ stackPtr , $ opener , $ closer ) { $ last_content = $ this -> phpcsFile -> findPrevious ( \ T_WHITESPACE , ( $ closer - 1 ) , $ opener , true ) ; if ( false !== $ last_content && $ this -> tokens [ $ last_content ] [ 'line' ] === $ this -> tokens [ $ closer ] [ 'line' ] ) { $ fix = $ this -> phpcsFile -> addFixableError ( 'Closing parenthesis of array declaration must be on a new line' , $ closer , 'CloseBraceNewLine' ) ; if ( true === $ fix ) { $ this -> phpcsFile -> fixer -> beginChangeset ( ) ; if ( $ last_content < ( $ closer - 1 ) && \ T_WHITESPACE === $ this -> tokens [ ( $ closer - 1 ) ] [ 'code' ] ) { * Check that each array item starts on a new line. */ $ array_items = $ this -> get_function_call_parameters ( $ stackPtr ) ; $ end_of_last_item = $ opener ; foreach ( $ array_items as $ item ) { $ end_of_this_item = ( $ item [ 'end' ] + 1 ) ; 
public function process_matched_token ( $ stackPtr , $ group_name , $ matched_content ) { $ this -> get_wp_version_from_cl ( ) ; switch ( $ matched_content ) { case 'strip_tags' : if ( $ this -> get_function_call_parameter_count ( $ stackPtr ) !== 1 ) { return ; } break ; case 'wp_parse_url' : if ( $ this -> get_function_call_parameter_count ( $ stackPtr ) !== 1 && version_compare ( $ this -> minimum_supported_version , '4.7.0' , '<' ) ) { return ; } break ; case 'file_get_contents' : $ params = $ this -> get_function_call_parameters ( $ stackPtr ) ; if ( isset ( $ params [ 2 ] ) && 'true' === $ params [ 2 ] [ 'raw' ] ) { * Allow for handling raw data streams from the request body. */ $ first_param = $ this -> get_function_call_parameter ( $ stackPtr , 1 ) ; if ( false === $ first_param ) { 
protected function is_local_data_stream ( $ raw_param_value ) { $ raw_stripped = $ this -> strip_quotes ( $ raw_param_value ) ; if ( isset ( $ this -> allowed_local_streams [ $ raw_stripped ] ) || isset ( $ this -> allowed_local_stream_constants [ $ raw_param_value ] ) ) { return true ; } foreach ( $ this -> allowed_local_stream_partials as $ partial ) { if ( strpos ( $ raw_stripped , $ partial ) === 0 ) { return true ; } } return false ; } 
public function process_token ( $ stackPtr ) { if ( ! isset ( $ this -> tab_width ) ) { $ this -> tab_width = PHPCSHelper :: get_tab_width ( $ this -> phpcsFile ) ; } $ check_tokens = array ( \ T_WHITESPACE => true , \ T_DOC_COMMENT_WHITESPACE => true , \ T_DOC_COMMENT_STRING => true , ) ; for ( $ i = ( $ stackPtr + 1 ) ; $ i < $ this -> phpcsFile -> numTokens ; $ i ++ ) { 
public function process_token ( $ stackPtr ) { 
protected function mergeFunctionLists ( ) { if ( ! isset ( $ this -> methods [ 'all' ] ) ) { $ this -> methods [ 'all' ] = array_merge ( $ this -> methods [ 'cachable' ] , $ this -> methods [ 'noncachable' ] ) ; } if ( $ this -> customCacheGetFunctions !== $ this -> addedCustomFunctions [ 'cacheget' ] ) { $ this -> cacheGetFunctions = $ this -> merge_custom_array ( $ this -> customCacheGetFunctions , $ this -> cacheGetFunctions ) ; $ this -> addedCustomFunctions [ 'cacheget' ] = $ this -> customCacheGetFunctions ; } if ( $ this -> customCacheSetFunctions !== $ this -> addedCustomFunctions [ 'cacheset' ] ) { $ this -> cacheSetFunctions = $ this -> merge_custom_array ( $ this -> customCacheSetFunctions , $ this -> cacheSetFunctions ) ; $ this -> addedCustomFunctions [ 'cacheset' ] = $ this -> customCacheSetFunctions ; } if ( $ this -> customCacheDeleteFunctions !== $ this -> addedCustomFunctions [ 'cachedelete' ] ) { $ this -> cacheDeleteFunctions = $ this -> merge_custom_array ( $ this -> customCacheDeleteFunctions , $ this -> cacheDeleteFunctions ) ; $ this -> addedCustomFunctions [ 'cachedelete' ] = $ this -> customCacheDeleteFunctions ; } } 
public function register ( ) { $ starters = Tokens :: $ booleanOperators ; $ starters += Tokens :: $ assignmentTokens ; $ starters [ \ T_CASE ] = \ T_CASE ; $ starters [ \ T_RETURN ] = \ T_RETURN ; $ starters [ \ T_INLINE_THEN ] = \ T_INLINE_THEN ; $ starters [ \ T_INLINE_ELSE ] = \ T_INLINE_ELSE ; $ starters [ \ T_SEMICOLON ] = \ T_SEMICOLON ; $ starters [ \ T_OPEN_PARENTHESIS ] = \ T_OPEN_PARENTHESIS ; $ this -> condition_start_tokens = $ starters ; return array ( \ T_IS_EQUAL , \ T_IS_NOT_EQUAL , \ T_IS_IDENTICAL , \ T_IS_NOT_IDENTICAL , ) ; } 
public function process_token ( $ stackPtr ) { $ start = $ this -> phpcsFile -> findPrevious ( $ this -> condition_start_tokens , $ stackPtr , null , false , null , true ) ; $ needs_yoda = false ; 
public function process_parameters ( $ stackPtr , $ group_name , $ matched_content , $ parameters ) { $ this -> get_wp_version_from_cl ( ) ; $ paramCount = \ count ( $ parameters ) ; foreach ( $ this -> target_functions [ $ matched_content ] as $ position => $ parameter_args ) { 
public function process_token ( $ stackPtr ) { $ instance = $ this -> tokens [ $ stackPtr ] ; if ( ! isset ( $ this -> superglobals [ $ instance [ 'content' ] ] ) ) { return ; } if ( $ this -> has_whitelist_comment ( 'CSRF' , $ stackPtr ) ) { return ; } if ( $ this -> is_assignment ( $ stackPtr ) ) { return ; } $ this -> mergeFunctionLists ( ) ; if ( $ this -> has_nonce_check ( $ stackPtr ) ) { return ; } $ error_code = 'Missing' ; if ( false === $ this -> superglobals [ $ instance [ 'content' ] ] ) { $ error_code = 'Recommended' ; } 
protected function mergeFunctionLists ( ) { if ( $ this -> customNonceVerificationFunctions !== $ this -> addedCustomFunctions [ 'nonce' ] ) { $ this -> nonceVerificationFunctions = $ this -> merge_custom_array ( $ this -> customNonceVerificationFunctions , $ this -> nonceVerificationFunctions ) ; $ this -> addedCustomFunctions [ 'nonce' ] = $ this -> customNonceVerificationFunctions ; } if ( $ this -> customSanitizingFunctions !== $ this -> addedCustomFunctions [ 'sanitize' ] ) { $ this -> sanitizingFunctions = $ this -> merge_custom_array ( $ this -> customSanitizingFunctions , $ this -> sanitizingFunctions ) ; $ this -> addedCustomFunctions [ 'sanitize' ] = $ this -> customSanitizingFunctions ; } if ( $ this -> customUnslashingSanitizingFunctions !== $ this -> addedCustomFunctions [ 'unslashsanitize' ] ) { $ this -> unslashingSanitizingFunctions = $ this -> merge_custom_array ( $ this -> customUnslashingSanitizingFunctions , $ this -> unslashingSanitizingFunctions ) ; $ this -> addedCustomFunctions [ 'unslashsanitize' ] = $ this -> customUnslashingSanitizingFunctions ; } } 
public function process_matched_token ( $ stackPtr , $ group_name , $ matched_content ) { $ parameters = $ this -> get_function_call_parameters ( $ stackPtr ) ; if ( empty ( $ parameters ) ) { return $ this -> process_no_parameters ( $ stackPtr , $ group_name , $ matched_content ) ; } else { return $ this -> process_parameters ( $ stackPtr , $ group_name , $ matched_content , $ parameters ) ; } } 
protected function processVariable ( File $ phpcs_file , $ stack_ptr ) { $ tokens = $ phpcs_file -> getTokens ( ) ; $ var_name = ltrim ( $ tokens [ $ stack_ptr ] [ 'content' ] , '$' ) ; 
protected function processMemberVar ( File $ phpcs_file , $ stack_ptr ) { $ tokens = $ phpcs_file -> getTokens ( ) ; $ var_name = ltrim ( $ tokens [ $ stack_ptr ] [ 'content' ] , '$' ) ; $ member_props = $ phpcs_file -> getMemberProperties ( $ stack_ptr ) ; if ( empty ( $ member_props ) ) { 
protected function processVariableInString ( File $ phpcs_file , $ stack_ptr ) { $ tokens = $ phpcs_file -> getTokens ( ) ; if ( preg_match_all ( '|[^\\\]\${?([a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*)|' , $ tokens [ $ stack_ptr ] [ 'content' ] , $ matches ) > 0 ) { 
protected function mergeWhiteList ( ) { if ( $ this -> customPropertiesWhitelist !== $ this -> addedCustomProperties [ 'properties' ] ) { 
public function process_parameters ( $ stackPtr , $ group_name , $ matched_content , $ parameters ) { foreach ( $ this -> target_functions [ $ matched_content ] as $ position ) { if ( isset ( $ parameters [ $ position ] ) ) { $ file_constant = $ this -> phpcsFile -> findNext ( \ T_FILE , $ parameters [ $ position ] [ 'start' ] , ( $ parameters [ $ position ] [ 'end' ] + 1 ) ) ; if ( false !== $ file_constant ) { $ this -> phpcsFile -> addWarning ( 'Using __FILE__ for menu slugs risks exposing filesystem structure.' , $ stackPtr , 'Using__FILE__' ) ; } } } } 
public function register ( ) { $ this -> ignore_tokens = Tokens :: $ heredocTokens ; unset ( $ this -> ignore_tokens [ \ T_START_HEREDOC ] , $ this -> ignore_tokens [ \ T_START_NOWDOC ] ) ; $ this -> ignore_tokens [ \ T_INLINE_HTML ] = \ T_INLINE_HTML ; return array ( \ T_ARRAY , \ T_OPEN_SHORT_ARRAY , ) ; } 
public function process_token ( $ stackPtr ) { if ( ! isset ( $ this -> tab_width ) ) { $ this -> tab_width = PHPCSHelper :: get_tab_width ( $ this -> phpcsFile ) ; } $ array_open_close = $ this -> find_array_open_close ( $ stackPtr ) ; if ( false === $ array_open_close ) { * Check the closing bracket is lined up with the start of the content on the line * containing the array opener. */ $ opener_line_spaces = $ this -> get_indentation_size ( $ opener ) ; $ closer_line_spaces = ( $ this -> tokens [ $ closer ] [ 'column' ] - 1 ) ; if ( $ closer_line_spaces !== $ opener_line_spaces ) { $ error = 'Array closer not aligned correctly; expected %s space(s) but found %s' ; $ error_code = 'CloseBraceNotAligned' ; if ( 0 === $ closer_line_spaces || ( \ T_WHITESPACE === $ this -> tokens [ ( $ closer - 1 ) ] [ 'code' ] && 1 === $ this -> tokens [ ( $ closer - 1 ) ] [ 'column' ] ) ) { $ this -> add_array_alignment_error ( $ closer , $ error , $ error_code , $ opener_line_spaces , $ closer_line_spaces , $ this -> get_indentation_string ( $ opener_line_spaces ) ) ; } else { $ this -> phpcsFile -> addError ( $ error , $ closer , $ error_code , array ( $ opener_line_spaces , $ closer_line_spaces ) ) ; } unset ( $ error , $ error_code ) ; } $ array_items = $ this -> get_function_call_parameters ( $ stackPtr ) ; if ( empty ( $ array_items ) ) { * Multi-line array items. * * Verify & if needed, correct the indentation of subsequent lines. * Subsequent lines may be indented more or less than the mimimum expected indent, * but the "first line after" should be indented - at least - as much as the very first line * of the array item. * Indentation correction for subsequent lines will be based on that diff. */ * Apparently there were only tokens in the ignore list on subsequent lines. * * In that case, the comma after the array item might be on a line by itself, * so check its placement. */ if ( $ this -> tokens [ $ item [ 'end' ] ] [ 'line' ] !== $ this -> tokens [ $ end_of_this_item ] [ 'line' ] && \ T_COMMA === $ this -> tokens [ $ end_of_this_item ] [ 'code' ] && ( $ this -> tokens [ $ end_of_this_item ] [ 'column' ] - 1 ) !== $ expected_spaces ) { $ this -> add_array_alignment_error ( $ end_of_this_item , 'Comma after multi-line array item not aligned correctly; expected %s spaces, but found %s' , 'MultiLineArrayItemCommaNotAligned' , $ expected_spaces , ( $ this -> tokens [ $ end_of_this_item ] [ 'column' ] - 1 ) , $ expected_indent ) ; } $ end_of_previous_item = $ end_of_this_item ; continue ; } $ found_spaces_on_line2 = $ this -> get_indentation_size ( $ first_content_on_line2 ) ; $ expected_spaces_on_line2 = $ expected_spaces ; if ( $ found_spaces < $ found_spaces_on_line2 ) { $ expected_spaces_on_line2 += ( $ found_spaces_on_line2 - $ found_spaces ) ; } if ( $ found_spaces_on_line2 !== $ expected_spaces_on_line2 ) { $ fix = $ this -> phpcsFile -> addFixableError ( 'Multi-line array item not aligned correctly; expected %s spaces, but found %s' , $ first_content_on_line2 , 'MultiLineArrayItemNotAligned' , array ( $ expected_spaces_on_line2 , $ found_spaces_on_line2 , ) ) ; if ( true === $ fix ) { $ expected_indent_on_line2 = $ this -> get_indentation_string ( $ expected_spaces_on_line2 ) ; $ this -> phpcsFile -> fixer -> beginChangeset ( ) ; * Check the placement of the comma after the array item as it might be on a line by itself. */ if ( $ this -> tokens [ $ item [ 'end' ] ] [ 'line' ] !== $ this -> tokens [ $ end_of_this_item ] [ 'line' ] && \ T_COMMA === $ this -> tokens [ $ end_of_this_item ] [ 'code' ] && ( $ this -> tokens [ $ end_of_this_item ] [ 'column' ] - 1 ) !== $ expected_spaces ) { $ this -> add_array_alignment_error ( $ end_of_this_item , 'Comma after array item not aligned correctly; expected %s spaces, but found %s' , 'MultiLineArrayItemCommaNotAligned' , $ expected_spaces , ( $ this -> tokens [ $ end_of_this_item ] [ 'column' ] - 1 ) , $ expected_indent ) ; } $ this -> phpcsFile -> fixer -> endChangeset ( ) ; } } $ end_of_previous_item = $ end_of_this_item ; } } 
protected function ignore_token ( $ ptr ) { $ token_code = $ this -> tokens [ $ ptr ] [ 'code' ] ; if ( isset ( $ this -> ignore_tokens [ $ token_code ] ) ) { return true ; } if ( \ T_CONSTANT_ENCAPSED_STRING === $ token_code || \ T_DOUBLE_QUOTED_STRING === $ token_code ) { 
protected function get_indentation_size ( $ ptr ) { * Special case for multi-line, non-docblock comments. * Only applicable for subsequent lines in an array item. * * First/Single line is tokenized as T_WHITESPACE + T_COMMENT * Subsequent lines are tokenized as T_COMMENT including the indentation whitespace. */ if ( \ T_COMMENT === $ this -> tokens [ $ ptr ] [ 'code' ] ) { $ content = $ this -> tokens [ $ ptr ] [ 'content' ] ; $ actual_comment = ltrim ( $ content ) ; $ whitespace = str_replace ( $ actual_comment , '' , $ content ) ; } return \ strlen ( $ whitespace ) ; } 
protected function get_indentation_string ( $ nr ) { if ( 0 >= $ nr ) { return '' ; } 
protected function add_array_alignment_error ( $ ptr , $ error , $ error_code , $ expected , $ found , $ new_indent ) { $ fix = $ this -> phpcsFile -> addFixableError ( $ error , $ ptr , $ error_code , array ( $ expected , $ found ) ) ; if ( true === $ fix ) { $ this -> fix_alignment_error ( $ ptr , $ new_indent ) ; } } 
protected function fix_alignment_error ( $ ptr , $ new_indent ) { if ( 1 === $ this -> tokens [ $ ptr ] [ 'column' ] ) { $ this -> phpcsFile -> fixer -> addContentBefore ( $ ptr , $ new_indent ) ; } else { $ this -> phpcsFile -> fixer -> replaceToken ( ( $ ptr - 1 ) , $ new_indent ) ; } } 
public function process_token ( $ stackPtr ) { if ( ! $ this -> has_whitelist_comment ( 'loose comparison' , $ stackPtr ) ) { $ error = 'Found: ' . $ this -> tokens [ $ stackPtr ] [ 'content' ] . '. Use strict comparisons (=== or !==).' ; $ this -> phpcsFile -> addWarning ( $ error , $ stackPtr , 'LooseComparison' ) ; } } 
public function register ( ) { $ this -> false_tokens += Tokens :: $ emptyTokens ; $ this -> safe_tokens += Tokens :: $ emptyTokens ; $ this -> safe_tokens += Tokens :: $ assignmentTokens ; $ this -> safe_tokens += Tokens :: $ comparisonTokens ; $ this -> safe_tokens += Tokens :: $ operators ; $ this -> safe_tokens += Tokens :: $ booleanOperators ; $ this -> safe_tokens += Tokens :: $ castTokens ; return parent :: register ( ) ; } 
public function process_parameters ( $ stackPtr , $ group_name , $ matched_content , $ parameters ) { * Version Check: Check to make sure the version is set explicitly. */ if ( ! isset ( $ parameters [ 4 ] ) || 'null' === $ parameters [ 4 ] [ 'raw' ] ) { $ type = 'script' ; if ( strpos ( $ matched_content , '_style' ) !== false ) { $ type = 'style' ; } $ this -> phpcsFile -> addError ( 'Resource version not set in call to %s(). This means new versions of the %s will not always be loaded due to browser caching.' , $ stackPtr , 'MissingVersion' , array ( $ matched_content , $ type ) ) ; } else { * In footer Check * * Check to make sure that $in_footer is set to true. * It will warn the user to make sure it is intended. * * Only wp_register_script and wp_enqueue_script need this check, * as this parameter is not available to wp_register_style and wp_enqueue_style. */ if ( 'wp_register_script' !== $ matched_content && 'wp_enqueue_script' !== $ matched_content ) { return ; } if ( ! isset ( $ parameters [ 5 ] ) ) { 
protected function is_falsy ( $ start , $ end ) { 
public function process_token ( $ stack_ptr ) { 
public function process_matched_token ( $ stack_ptr , $ group_name , $ matched_content ) { $ func_open_paren_token = $ this -> phpcsFile -> findNext ( Tokens :: $ emptyTokens , ( $ stack_ptr + 1 ) , null , true ) ; if ( false === $ func_open_paren_token || \ T_OPEN_PARENTHESIS !== $ this -> tokens [ $ func_open_paren_token ] [ 'code' ] || ! isset ( $ this -> tokens [ $ func_open_paren_token ] [ 'parenthesis_closer' ] ) ) { 
protected function check_argument_tokens ( $ context ) { $ stack_ptr = $ context [ 'stack_ptr' ] ; $ tokens = $ context [ 'tokens' ] ; $ arg_name = $ context [ 'arg_name' ] ; $ is_error = empty ( $ context [ 'warning' ] ) ; $ content = isset ( $ tokens [ 0 ] ) ? $ tokens [ 0 ] [ 'content' ] : '' ; if ( empty ( $ tokens ) || 0 === \ count ( $ tokens ) ) { $ code = $ this -> string_to_errorcode ( 'MissingArg' . ucfirst ( $ arg_name ) ) ; if ( 'domain' !== $ arg_name ) { $ this -> addMessage ( 'Missing $%s arg.' , $ stack_ptr , $ is_error , $ code , array ( $ arg_name ) ) ; return false ; } 
protected function compare_single_and_plural_arguments ( $ stack_ptr , $ single_context , $ plural_context ) { $ single_content = $ single_context [ 'tokens' ] [ 0 ] [ 'content' ] ; $ plural_content = $ plural_context [ 'tokens' ] [ 0 ] [ 'content' ] ; preg_match_all ( self :: SPRINTF_PLACEHOLDER_REGEX , $ single_content , $ single_placeholders ) ; $ single_placeholders = $ single_placeholders [ 0 ] ; preg_match_all ( self :: SPRINTF_PLACEHOLDER_REGEX , $ plural_content , $ plural_placeholders ) ; $ plural_placeholders = $ plural_placeholders [ 0 ] ; 
protected function check_text ( $ context ) { $ stack_ptr = $ context [ 'stack_ptr' ] ; $ arg_name = $ context [ 'arg_name' ] ; $ content = $ context [ 'tokens' ] [ 0 ] [ 'content' ] ; $ is_error = empty ( $ context [ 'warning' ] ) ; * NoEmptyStrings. * * Strip placeholders and surrounding quotes. */ $ non_placeholder_content = trim ( $ this -> strip_quotes ( $ content ) ) ; $ non_placeholder_content = preg_replace ( self :: SPRINTF_PLACEHOLDER_REGEX , '' , $ non_placeholder_content ) ; if ( '' === $ non_placeholder_content ) { $ this -> phpcsFile -> addError ( 'Strings should have translatable content' , $ stack_ptr , 'NoEmptyStrings' ) ; } } 
protected function check_for_translator_comment ( $ stack_ptr , $ args ) { foreach ( $ args as $ arg ) { if ( false === \ in_array ( $ arg [ 'arg_name' ] , array ( 'text' , 'single' , 'plural' ) , true ) ) { continue ; } if ( empty ( $ arg [ 'tokens' ] ) ) { continue ; } foreach ( $ arg [ 'tokens' ] as $ token ) { if ( empty ( $ token [ 'content' ] ) ) { continue ; } if ( preg_match ( self :: SPRINTF_PLACEHOLDER_REGEX , $ token [ 'content' ] , $ placeholders ) < 1 ) { * Check that the comment is either on the line before the gettext call or * if it's not, that there is only whitespace between. */ $ correctly_placed = false ; if ( ( $ this -> tokens [ $ previous_comment ] [ 'line' ] + 1 ) === $ this -> tokens [ $ stack_ptr ] [ 'line' ] ) { $ correctly_placed = true ; } else { $ next_non_whitespace = $ this -> phpcsFile -> findNext ( \ T_WHITESPACE , ( $ previous_comment + 1 ) , $ stack_ptr , true ) ; if ( false === $ next_non_whitespace || $ this -> tokens [ $ next_non_whitespace ] [ 'line' ] === $ this -> tokens [ $ stack_ptr ] [ 'line' ] ) { // No non-whitespace found or next non-whitespace is on same line as gettext call. $ correctly_placed = true ; } unset ( $ next_non_whitespace ) ; } /* * Check that the comment starts with 'translators:'. */ if ( true === $ correctly_placed ) { if ( \ T_COMMENT === $ this -> tokens [ $ previous_comment ] [ 'code' ] ) { $ comment_text = trim ( $ this -> tokens [ $ previous_comment ] [ 'content' ] ) ; // If it's multi-line comment, collect all the parts. if ( '*/' === substr ( $ comment_text , - 2 ) && '/*' !== substr ( $ comment_text , 0 , 2 ) ) { for ( $ i = ( $ previous_comment - 1 ) ; 0 <= $ i ; $ i -- ) { if ( \ T_COMMENT !== $ this -> tokens [ $ i ] [ 'code' ] ) { break ; } $ comment_text = trim ( $ this -> tokens [ $ i ] [ 'content' ] ) . $ comment_text ; } } if ( true === $ this -> is_translators_comment ( $ comment_text ) ) { 
public function register ( ) { if ( \ defined ( '\PHP_CODESNIFFER_IN_TESTS' ) ) { $ this -> class_exceptions = array_merge ( $ this -> class_exceptions , $ this -> unittest_class_exceptions ) ; } return array ( \ T_OPEN_TAG , \ T_OPEN_TAG_WITH_ECHO , ) ; } 
public function process_token ( $ stackPtr ) { * Generic check for lowercase hyphenated file names. */ if ( $ fileName !== $ expected && ( false === $ this -> is_theme || 1 !== preg_match ( self :: THEME_EXCEPTIONS_REGEX , $ fileName ) ) ) { $ this -> phpcsFile -> addError ( 'Filenames should be all lowercase with hyphens as word separators. Expected %s, but found %s.' , 0 , 'NotHyphenatedLowercase' , array ( $ expected , $ fileName ) ) ; } unset ( $ expected ) ; if ( true === $ this -> strict_class_file_names ) { $ has_class = $ this -> phpcsFile -> findNext ( \ T_CLASS , $ stackPtr ) ; if ( false !== $ has_class && false === $ this -> is_test_class ( $ has_class ) ) { $ class_name = $ this -> phpcsFile -> getDeclarationName ( $ has_class ) ; $ expected = 'class-' . strtolower ( str_replace ( '_' , '-' , $ class_name ) ) ; if ( substr ( $ fileName , 0 , - 4 ) !== $ expected && ! isset ( $ this -> class_exceptions [ $ fileName ] ) ) { $ this -> phpcsFile -> addError ( 'Class file names should be based on the class name with "class-" prepended. Expected %s, but found %s.' , 0 , 'InvalidClassFileName' , array ( $ expected . '.php' , $ fileName , ) ) ; } unset ( $ expected ) ; } } if ( false !== strpos ( $ file , \ DIRECTORY_SEPARATOR . 'wp-includes' . \ DIRECTORY_SEPARATOR ) ) { $ subpackage_tag = $ this -> phpcsFile -> findNext ( \ T_DOC_COMMENT_TAG , $ stackPtr , null , false , '@subpackage' ) ; if ( false !== $ subpackage_tag ) { $ subpackage = $ this -> phpcsFile -> findNext ( \ T_DOC_COMMENT_STRING , $ subpackage_tag ) ; if ( false !== $ subpackage ) { $ fileName_end = substr ( $ fileName , - 13 ) ; $ has_class = $ this -> phpcsFile -> findNext ( \ T_CLASS , $ stackPtr ) ; if ( ( 'Template' === trim ( $ this -> tokens [ $ subpackage ] [ 'content' ] ) && $ this -> tokens [ $ subpackage_tag ] [ 'line' ] === $ this -> tokens [ $ subpackage ] [ 'line' ] ) && ( ( ! \ defined ( '\PHP_CODESNIFFER_IN_TESTS' ) && '-template.php' !== $ fileName_end ) || ( \ defined ( '\PHP_CODESNIFFER_IN_TESTS' ) && '-template.inc' !== $ fileName_end ) ) && false === $ has_class ) { $ this -> phpcsFile -> addError ( 'Files containing template tags should have "-template" appended to the end of the file name. Expected %s, but found %s.' , 0 , 'InvalidTemplateTagFileName' , array ( substr ( $ fileName , 0 , - 4 ) . '-template.php' , $ fileName , ) ) ; } } } } 
public function process_token ( $ stackPtr ) { 
public function is_targetted_token ( $ stackPtr ) { $ token = $ this -> tokens [ $ stackPtr ] ; $ classname = '' ; if ( \ in_array ( $ token [ 'code' ] , array ( \ T_NEW , \ T_EXTENDS , \ T_IMPLEMENTS ) , true ) ) { if ( \ T_NEW === $ token [ 'code' ] ) { $ nameEnd = ( $ this -> phpcsFile -> findNext ( array ( \ T_OPEN_PARENTHESIS , \ T_WHITESPACE , \ T_SEMICOLON , \ T_OBJECT_OPERATOR ) , ( $ stackPtr + 2 ) ) - 1 ) ; } else { $ nameEnd = ( $ this -> phpcsFile -> findNext ( array ( \ T_CLOSE_CURLY_BRACKET , \ T_WHITESPACE ) , ( $ stackPtr + 2 ) ) - 1 ) ; } $ length = ( $ nameEnd - ( $ stackPtr + 1 ) ) ; $ classname = $ this -> phpcsFile -> getTokensAsString ( ( $ stackPtr + 2 ) , $ length ) ; if ( \ T_NS_SEPARATOR !== $ this -> tokens [ ( $ stackPtr + 2 ) ] [ 'code' ] ) { $ classname = $ this -> get_namespaced_classname ( $ classname , ( $ stackPtr - 1 ) ) ; } } if ( \ T_DOUBLE_COLON === $ token [ 'code' ] ) { $ nameEnd = $ this -> phpcsFile -> findPrevious ( \ T_STRING , ( $ stackPtr - 1 ) ) ; $ nameStart = ( $ this -> phpcsFile -> findPrevious ( array ( \ T_STRING , \ T_NS_SEPARATOR , \ T_NAMESPACE ) , ( $ nameEnd - 1 ) , null , true , null , true ) + 1 ) ; $ length = ( $ nameEnd - ( $ nameStart - 1 ) ) ; $ classname = $ this -> phpcsFile -> getTokensAsString ( $ nameStart , $ length ) ; if ( \ T_NS_SEPARATOR !== $ this -> tokens [ $ nameStart ] [ 'code' ] ) { $ classname = $ this -> get_namespaced_classname ( $ classname , ( $ nameStart - 1 ) ) ; } } 
public function check_for_matches ( $ stackPtr ) { $ skip_to = array ( ) ; foreach ( $ this -> groups as $ groupName => $ group ) { if ( isset ( $ this -> excluded_groups [ $ groupName ] ) ) { continue ; } if ( preg_match ( $ group [ 'regex' ] , $ this -> classname ) === 1 ) { $ skip_to [ ] = $ this -> process_matched_token ( $ stackPtr , $ groupName , $ this -> classname ) ; } } if ( empty ( $ skip_to ) || min ( $ skip_to ) === 0 ) { return ; } return min ( $ skip_to ) ; } 
protected function get_namespaced_classname ( $ classname , $ search_from ) { 
public function register ( ) { $ this -> assignment_tokens = Tokens :: $ assignmentTokens ; unset ( $ this -> assignment_tokens [ \ T_DOUBLE_ARROW ] ) ; $ starters = Tokens :: $ booleanOperators ; $ starters [ \ T_SEMICOLON ] = \ T_SEMICOLON ; $ starters [ \ T_OPEN_PARENTHESIS ] = \ T_OPEN_PARENTHESIS ; $ starters [ \ T_INLINE_ELSE ] = \ T_INLINE_ELSE ; $ this -> condition_start_tokens = $ starters ; return array ( \ T_IF , \ T_ELSEIF , \ T_FOR , \ T_SWITCH , \ T_CASE , \ T_WHILE , \ T_INLINE_THEN , ) ; } 
public function process_token ( $ stackPtr ) { $ token = $ this -> tokens [ $ stackPtr ] ; 
public function execute ( $ queue ) { $ serializer = new Serializer ( ) ; $ closure = $ serializer -> unserialize ( $ this -> serialized ) ; return $ closure ( ) ; } 
public function listen ( ) { $ this -> open ( ) ; $ callback = function ( AMQPMessage $ payload ) { $ id = $ payload -> get ( 'message_id' ) ; list ( $ ttr , $ message ) = explode ( ';' , $ payload -> body , 2 ) ; if ( $ this -> handleMessage ( $ id , $ message , $ ttr , 1 ) ) { $ payload -> delivery_info [ 'channel' ] -> basic_ack ( $ payload -> delivery_info [ 'delivery_tag' ] ) ; } } ; $ this -> channel -> basic_qos ( null , 1 , null ) ; $ this -> channel -> basic_consume ( $ this -> queueName , '' , false , false , false , false , $ callback ) ; while ( count ( $ this -> channel -> callbacks ) ) { $ this -> channel -> wait ( ) ; } } 
protected function open ( ) { if ( $ this -> channel ) { return ; } $ this -> connection = new AMQPStreamConnection ( $ this -> host , $ this -> port , $ this -> user , $ this -> password , $ this -> vhost ) ; $ this -> channel = $ this -> connection -> channel ( ) ; $ this -> channel -> queue_declare ( $ this -> queueName , false , true , false , false ) ; $ this -> channel -> exchange_declare ( $ this -> exchangeName , 'direct' , false , true , false ) ; $ this -> channel -> queue_bind ( $ this -> queueName , $ this -> exchangeName ) ; } 
protected function reserve ( $ timeout ) { $ response = $ this -> getClient ( ) -> receiveMessage ( [ 'QueueUrl' => $ this -> url , 'AttributeNames' => [ 'ApproximateReceiveCount' ] , 'MessageAttributeNames' => [ 'TTR' ] , 'MaxNumberOfMessages' => 1 , 'VisibilityTimeout' => $ this -> ttr , 'WaitTimeSeconds' => $ timeout , ] ) ; if ( ! $ response [ 'Messages' ] ) { return null ; } $ payload = reset ( $ response [ 'Messages' ] ) ; $ ttr = ( int ) $ payload [ 'MessageAttributes' ] [ 'TTR' ] [ 'StringValue' ] ; if ( $ ttr != $ this -> ttr ) { $ this -> getClient ( ) -> changeMessageVisibility ( [ 'QueueUrl' => $ this -> url , 'ReceiptHandle' => $ payload [ 'ReceiptHandle' ] , 'VisibilityTimeout' => $ ttr , ] ) ; } return $ payload ; } 
public function listen ( ) { $ this -> open ( ) ; $ this -> setupBroker ( ) ; $ queue = $ this -> context -> createQueue ( $ this -> queueName ) ; $ consumer = $ this -> context -> createConsumer ( $ queue ) ; $ this -> context -> subscribe ( $ consumer , function ( AmqpMessage $ message , AmqpConsumer $ consumer ) { if ( $ message -> isRedelivered ( ) ) { $ consumer -> acknowledge ( $ message ) ; $ this -> redeliver ( $ message ) ; return true ; } $ ttr = $ message -> getProperty ( self :: TTR ) ; $ attempt = $ message -> getProperty ( self :: ATTEMPT , 1 ) ; if ( $ this -> handleMessage ( $ message -> getMessageId ( ) , $ message -> getBody ( ) , $ ttr , $ attempt ) ) { $ consumer -> acknowledge ( $ message ) ; } else { $ consumer -> acknowledge ( $ message ) ; $ this -> redeliver ( $ message ) ; } return true ; } ) ; $ this -> context -> consume ( ) ; } 
protected function open ( ) { if ( $ this -> context ) { return ; } switch ( $ this -> driver ) { case self :: ENQUEUE_AMQP_LIB : $ connectionClass = AmqpLibConnectionFactory :: class ; break ; case self :: ENQUEUE_AMQP_EXT : $ connectionClass = AmqpExtConnectionFactory :: class ; break ; case self :: ENQUEUE_AMQP_BUNNY : $ connectionClass = AmqpBunnyConnectionFactory :: class ; break ; default : throw new \ LogicException ( sprintf ( 'The given driver "%s" is not supported. Drivers supported are "%s"' , $ this -> driver , implode ( '", "' , $ this -> supportedDrivers ) ) ) ; } $ config = [ 'dsn' => $ this -> dsn , 'host' => $ this -> host , 'port' => $ this -> port , 'user' => $ this -> user , 'pass' => $ this -> password , 'vhost' => $ this -> vhost , 'read_timeout' => $ this -> readTimeout , 'write_timeout' => $ this -> writeTimeout , 'connection_timeout' => $ this -> connectionTimeout , 'heartbeat' => $ this -> heartbeat , 'persisted' => $ this -> persisted , 'lazy' => $ this -> lazy , 'qos_global' => $ this -> qosGlobal , 'qos_prefetch_size' => $ this -> qosPrefetchSize , 'qos_prefetch_count' => $ this -> qosPrefetchCount , 'ssl_on' => $ this -> sslOn , 'ssl_verify' => $ this -> sslVerify , 'ssl_cacert' => $ this -> sslCacert , 'ssl_cert' => $ this -> sslCert , 'ssl_key' => $ this -> sslKey , ] ; $ config = array_filter ( $ config , function ( $ value ) { return null !== $ value ; } ) ; $ factory = new $ connectionClass ( $ config ) ; $ this -> context = $ factory -> createContext ( ) ; if ( $ this -> context instanceof DelayStrategyAware ) { $ this -> context -> setDelayStrategy ( new RabbitMqDlxDelayStrategy ( ) ) ; } } 
protected function close ( ) { if ( ! $ this -> context ) { return ; } $ this -> context -> close ( ) ; $ this -> context = null ; $ this -> setupBrokerDone = false ; } 
protected function redeliver ( AmqpMessage $ message ) { $ attempt = $ message -> getProperty ( self :: ATTEMPT , 1 ) ; $ newMessage = $ this -> context -> createMessage ( $ message -> getBody ( ) , $ message -> getProperties ( ) , $ message -> getHeaders ( ) ) ; $ newMessage -> setDeliveryMode ( $ message -> getDeliveryMode ( ) ) ; $ newMessage -> setProperty ( self :: ATTEMPT , ++ $ attempt ) ; $ this -> context -> createProducer ( ) -> send ( $ this -> context -> createQueue ( $ this -> queueName ) , $ newMessage ) ; } 
public function run ( $ repeat ) { return $ this -> runWorker ( function ( callable $ canContinue ) use ( $ repeat ) { $ worker = new \ GearmanWorker ( ) ; $ worker -> addServer ( $ this -> host , $ this -> port ) ; $ worker -> addFunction ( $ this -> channel , function ( \ GearmanJob $ payload ) { list ( $ ttr , $ message ) = explode ( ';' , $ payload -> workload ( ) , 2 ) ; $ this -> handleMessage ( $ payload -> handle ( ) , $ message , $ ttr , 1 ) ; } ) ; $ worker -> setTimeout ( $ repeat ? 1000 : 1 ) ; while ( $ canContinue ( ) ) { $ result = $ worker -> work ( ) ; if ( ! $ result && ! $ repeat ) { break ; } } } ) ; } 
public function validateNamespace ( $ attribute ) { $ value = $ this -> $ attribute ; $ value = ltrim ( $ value , '\\' ) ; $ path = Yii :: getAlias ( '@' . str_replace ( '\\' , '/' , $ value ) , false ) ; if ( $ path === false ) { $ this -> addError ( $ attribute , 'Namespace must be associated with an existing directory.' ) ; } } 
public function push ( $ job ) { $ event = new PushEvent ( [ 'job' => $ job , 'ttr' => $ this -> pushTtr ? : ( $ job instanceof RetryableJobInterface ? $ job -> getTtr ( ) : $ this -> ttr ) , 'delay' => $ this -> pushDelay ? : 0 , 'priority' => $ this -> pushPriority , ] ) ; $ this -> pushTtr = null ; $ this -> pushDelay = null ; $ this -> pushPriority = null ; $ this -> trigger ( self :: EVENT_BEFORE_PUSH , $ event ) ; if ( $ event -> handled ) { return null ; } if ( $ this -> strictJobType && ! ( $ event -> job instanceof JobInterface ) ) { throw new InvalidArgumentException ( 'Job must be instance of JobInterface.' ) ; } if ( ! is_numeric ( $ event -> ttr ) ) { throw new InvalidArgumentException ( 'Job TTR must be integer.' ) ; } $ event -> ttr = ( int ) $ event -> ttr ; if ( $ event -> ttr <= 0 ) { throw new InvalidArgumentException ( 'Job TTR must be greater that zero.' ) ; } if ( ! is_numeric ( $ event -> delay ) ) { throw new InvalidArgumentException ( 'Job delay must be integer.' ) ; } $ event -> delay = ( int ) $ event -> delay ; if ( $ event -> delay < 0 ) { throw new InvalidArgumentException ( 'Job delay must be positive.' ) ; } $ message = $ this -> serializer -> serialize ( $ event -> job ) ; $ event -> id = $ this -> pushMessage ( $ message , $ event -> ttr , $ event -> delay , $ event -> priority ) ; $ this -> trigger ( self :: EVENT_AFTER_PUSH , $ event ) ; return $ event -> id ; } 
public function unserializeMessage ( $ serialized ) { try { $ job = $ this -> serializer -> unserialize ( $ serialized ) ; } catch ( \ Exception $ e ) { return [ null , new InvalidJobException ( $ serialized , $ e -> getMessage ( ) , 0 , $ e ) ] ; } if ( $ job instanceof JobInterface ) { return [ $ job , null ] ; } return [ null , new InvalidJobException ( $ serialized , sprintf ( 'Job must be a JobInterface instance instead of %s.' , VarDumper :: dumpAsString ( $ job ) ) ) ] ; } 
public function actionListen ( $ timeout = 3 ) { if ( ! is_numeric ( $ timeout ) ) { throw new Exception ( 'Timeout must be numeric.' ) ; } if ( $ timeout < 1 ) { throw new Exception ( 'Timeout must be greater than zero.' ) ; } return $ this -> queue -> run ( true , $ timeout ) ; } 
public function actionExec ( $ id , $ ttr , $ attempt , $ pid ) { if ( $ this -> queue -> execute ( $ id , file_get_contents ( 'php://stdin' ) , $ ttr , $ attempt , $ pid ? : null ) ) { return self :: EXEC_DONE ; } return self :: EXEC_RETRY ; } 
protected function handleMessage ( $ id , $ message , $ ttr , $ attempt ) { 
public function run ( ) { while ( ( $ payload = array_shift ( $ this -> payloads ) ) !== null ) { list ( $ ttr , $ message ) = $ payload ; $ this -> startedId = $ this -> finishedId + 1 ; $ this -> handleMessage ( $ this -> startedId , $ message , $ ttr , 1 ) ; $ this -> finishedId = $ this -> startedId ; $ this -> startedId = 0 ; } } 
public function run ( ) { Console :: output ( $ this -> format ( 'Statistical information about the tube:' , Console :: FG_GREEN ) ) ; foreach ( $ this -> queue -> getStatsTube ( ) as $ key => $ value ) { Console :: stdout ( $ this -> format ( "- $key: " , Console :: FG_YELLOW ) ) ; Console :: output ( $ value ) ; } } 
public function run ( ) { $ prefix = $ this -> queue -> channel ; $ waiting = $ this -> queue -> redis -> llen ( "$prefix.waiting" ) ; $ delayed = $ this -> queue -> redis -> zcount ( "$prefix.delayed" , '-inf' , '+inf' ) ; $ reserved = $ this -> queue -> redis -> zcount ( "$prefix.reserved" , '-inf' , '+inf' ) ; $ total = $ this -> queue -> redis -> get ( "$prefix.message_id" ) ; $ done = $ total - $ waiting - $ delayed - $ reserved ; Console :: output ( $ this -> format ( 'Jobs' , Console :: FG_GREEN ) ) ; Console :: stdout ( $ this -> format ( '- waiting: ' , Console :: FG_YELLOW ) ) ; Console :: output ( $ waiting ) ; Console :: stdout ( $ this -> format ( '- delayed: ' , Console :: FG_YELLOW ) ) ; Console :: output ( $ delayed ) ; Console :: stdout ( $ this -> format ( '- reserved: ' , Console :: FG_YELLOW ) ) ; Console :: output ( $ reserved ) ; Console :: stdout ( $ this -> format ( '- done: ' , Console :: FG_YELLOW ) ) ; Console :: output ( $ done ) ; } 
public function run ( ) { Console :: output ( $ this -> format ( 'Jobs' , Console :: FG_GREEN ) ) ; Console :: stdout ( $ this -> format ( '- waiting: ' , Console :: FG_YELLOW ) ) ; Console :: output ( $ this -> getWaitingCount ( ) ) ; Console :: stdout ( $ this -> format ( '- delayed: ' , Console :: FG_YELLOW ) ) ; Console :: output ( $ this -> getDelayedCount ( ) ) ; Console :: stdout ( $ this -> format ( '- reserved: ' , Console :: FG_YELLOW ) ) ; Console :: output ( $ this -> getReservedCount ( ) ) ; Console :: stdout ( $ this -> format ( '- done: ' , Console :: FG_YELLOW ) ) ; Console :: output ( $ this -> getDoneCount ( ) ) ; } 
public function run ( $ repeat , $ timeout = 0 ) { return $ this -> runWorker ( function ( callable $ canContinue ) use ( $ repeat , $ timeout ) { while ( $ canContinue ( ) ) { if ( $ payload = $ this -> reserve ( ) ) { if ( $ this -> handleMessage ( $ payload [ 'id' ] , $ payload [ 'job' ] , $ payload [ 'ttr' ] , $ payload [ 'attempt' ] ) ) { $ this -> release ( $ payload ) ; } } elseif ( ! $ repeat ) { break ; } elseif ( $ timeout ) { sleep ( $ timeout ) ; } } } ) ; } 
public function clear ( ) { $ this -> db -> createCommand ( ) -> delete ( $ this -> tableName , [ 'channel' => $ this -> channel ] ) -> execute ( ) ; } 
public function remove ( $ id ) { return ( bool ) $ this -> db -> createCommand ( ) -> delete ( $ this -> tableName , [ 'channel' => $ this -> channel , 'id' => $ id ] ) -> execute ( ) ; } 
protected function reserve ( ) { return $ this -> db -> useMaster ( function ( ) { if ( ! $ this -> mutex -> acquire ( __CLASS__ . $ this -> channel , $ this -> mutexTimeout ) ) { throw new Exception ( 'Has not waited the lock.' ) ; } try { $ this -> moveExpired ( ) ; 
private function moveExpired ( ) { if ( $ this -> reserveTime !== time ( ) ) { $ this -> reserveTime = time ( ) ; $ this -> db -> createCommand ( ) -> update ( $ this -> tableName , [ 'reserved_at' => null ] , '[[reserved_at]] < :time - [[ttr]] and [[done_at]] is null' , [ ':time' => $ this -> reserveTime ] ) -> execute ( ) ; } } 
public function beforePush ( PushEvent $ event ) { if ( $ event -> job instanceof \ Closure ) { $ serializer = new Serializer ( ) ; $ serialized = $ serializer -> serialize ( $ event -> job ) ; $ event -> job = new Job ( ) ; $ event -> job -> serialized = $ serialized ; } } 
public function run ( $ repeat , $ timeout = 0 ) { return $ this -> runWorker ( function ( callable $ canContinue ) use ( $ repeat , $ timeout ) { while ( $ canContinue ( ) ) { if ( ( $ payload = $ this -> reserve ( $ timeout ) ) !== null ) { list ( $ id , $ message , $ ttr , $ attempt ) = $ payload ; if ( $ this -> handleMessage ( $ id , $ message , $ ttr , $ attempt ) ) { $ this -> delete ( $ id ) ; } } elseif ( ! $ repeat ) { break ; } } } ) ; } 
public function clear ( ) { while ( ! $ this -> redis -> set ( "$this->channel.moving_lock" , true , 'NX' ) ) { usleep ( 10000 ) ; } $ this -> redis -> executeCommand ( 'DEL' , $ this -> redis -> keys ( "$this->channel.*" ) ) ; } 
public function remove ( $ id ) { while ( ! $ this -> redis -> set ( "$this->channel.moving_lock" , true , 'NX' , 'EX' , 1 ) ) { usleep ( 10000 ) ; } if ( $ this -> redis -> hdel ( "$this->channel.messages" , $ id ) ) { $ this -> redis -> zrem ( "$this->channel.delayed" , $ id ) ; $ this -> redis -> zrem ( "$this->channel.reserved" , $ id ) ; $ this -> redis -> lrem ( "$this->channel.waiting" , 0 , $ id ) ; $ this -> redis -> hdel ( "$this->channel.attempts" , $ id ) ; return true ; } return false ; } 
protected function delete ( $ id ) { $ this -> redis -> zrem ( "$this->channel.reserved" , $ id ) ; $ this -> redis -> hdel ( "$this->channel.attempts" , $ id ) ; $ this -> redis -> hdel ( "$this->channel.messages" , $ id ) ; } 
protected function runWorker ( callable $ handler ) { $ this -> _workerPid = getmypid ( ) ; $ loop = Yii :: createObject ( $ this -> loopConfig , [ $ this ] ) ; $ event = new WorkerEvent ( [ 'loop' => $ loop ] ) ; $ this -> trigger ( self :: EVENT_WORKER_START , $ event ) ; if ( $ event -> exitCode !== null ) { return $ event -> exitCode ; } $ exitCode = null ; try { call_user_func ( $ handler , function ( ) use ( $ loop , $ event ) { $ this -> trigger ( self :: EVENT_WORKER_LOOP , $ event ) ; return $ event -> exitCode === null && $ loop -> canContinue ( ) ; } ) ; } finally { $ this -> trigger ( self :: EVENT_WORKER_STOP , $ event ) ; $ this -> _workerPid = null ; } return $ event -> exitCode ; } 
public function handle ( $ id , $ message , $ ttr , $ attempt ) { return $ this -> handleMessage ( $ id , $ message , $ ttr , $ attempt ) ; } 
public function init ( ) { parent :: init ( ) ; if ( extension_loaded ( 'pcntl' ) ) { foreach ( $ this -> exitSignals as $ signal ) { pcntl_signal ( $ signal , function ( ) { self :: $ exit = true ; } ) ; } foreach ( $ this -> suspendSignals as $ signal ) { pcntl_signal ( $ signal , function ( ) { self :: $ pause = true ; } ) ; } foreach ( $ this -> resumeSignals as $ signal ) { pcntl_signal ( $ signal , function ( ) { self :: $ pause = false ; } ) ; } } } 
public function canContinue ( ) { if ( extension_loaded ( 'pcntl' ) ) { pcntl_signal_dispatch ( ) ; 
public function run ( ) { Console :: output ( $ this -> format ( 'Jobs' , Console :: FG_GREEN ) ) ; Console :: stdout ( $ this -> format ( '- waiting: ' , Console :: FG_YELLOW ) ) ; Console :: output ( $ this -> getWaiting ( ) -> count ( '*' , $ this -> queue -> db ) ) ; Console :: stdout ( $ this -> format ( '- delayed: ' , Console :: FG_YELLOW ) ) ; Console :: output ( $ this -> getDelayed ( ) -> count ( '*' , $ this -> queue -> db ) ) ; Console :: stdout ( $ this -> format ( '- reserved: ' , Console :: FG_YELLOW ) ) ; Console :: output ( $ this -> getReserved ( ) -> count ( '*' , $ this -> queue -> db ) ) ; Console :: stdout ( $ this -> format ( '- done: ' , Console :: FG_YELLOW ) ) ; Console :: output ( $ this -> getDone ( ) -> count ( '*' , $ this -> queue -> db ) ) ; } 
public function run ( $ repeat , $ timeout = 0 ) { return $ this -> runWorker ( function ( callable $ canContinue ) use ( $ repeat , $ timeout ) { while ( $ canContinue ( ) ) { if ( $ payload = $ this -> getPheanstalk ( ) -> reserveFromTube ( $ this -> tube , $ timeout ) ) { $ info = $ this -> getPheanstalk ( ) -> statsJob ( $ payload ) ; if ( $ this -> handleMessage ( $ payload -> getId ( ) , $ payload -> getData ( ) , $ info -> ttr , $ info -> reserves ) ) { $ this -> getPheanstalk ( ) -> delete ( $ payload ) ; } } elseif ( ! $ repeat ) { break ; } } } ) ; } 
public function remove ( $ id ) { try { $ this -> getPheanstalk ( ) -> delete ( new Job ( $ id , null ) ) ; return true ; } catch ( ServerException $ e ) { if ( strpos ( $ e -> getMessage ( ) , 'NOT_FOUND' ) === 0 ) { return false ; } throw $ e ; } } 
public static function isExit ( ) { if ( function_exists ( 'pcntl_signal' ) ) { 
public function clear ( ) { $ this -> touchIndex ( function ( & $ data ) { $ data = [ ] ; foreach ( glob ( "$this->path/job*.data" ) as $ fileName ) { unlink ( $ fileName ) ; } } ) ; } 
public function remove ( $ id ) { $ removed = false ; $ this -> touchIndex ( function ( & $ data ) use ( $ id , & $ removed ) { if ( ! empty ( $ data [ 'waiting' ] ) ) { foreach ( $ data [ 'waiting' ] as $ key => $ payload ) { if ( $ payload [ 0 ] === $ id ) { unset ( $ data [ 'waiting' ] [ $ key ] ) ; $ removed = true ; break ; } } } if ( ! $ removed && ! empty ( $ data [ 'delayed' ] ) ) { foreach ( $ data [ 'delayed' ] as $ key => $ payload ) { if ( $ payload [ 0 ] === $ id ) { unset ( $ data [ 'delayed' ] [ $ key ] ) ; $ removed = true ; break ; } } } if ( ! $ removed && ! empty ( $ data [ 'reserved' ] ) ) { foreach ( $ data [ 'reserved' ] as $ key => $ payload ) { if ( $ payload [ 0 ] === $ id ) { unset ( $ data [ 'reserved' ] [ $ key ] ) ; $ removed = true ; break ; } } } if ( $ removed ) { unlink ( "$this->path/job$id.data" ) ; } } ) ; return $ removed ; } 
protected function reserve ( ) { $ id = null ; $ ttr = null ; $ attempt = null ; $ this -> touchIndex ( function ( & $ data ) use ( & $ id , & $ ttr , & $ attempt ) { if ( ! empty ( $ data [ 'reserved' ] ) ) { foreach ( $ data [ 'reserved' ] as $ key => $ payload ) { if ( $ payload [ 1 ] + $ payload [ 3 ] < time ( ) ) { list ( $ id , $ ttr , $ attempt , $ time ) = $ payload ; $ data [ 'reserved' ] [ $ key ] [ 2 ] = ++ $ attempt ; $ data [ 'reserved' ] [ $ key ] [ 3 ] = time ( ) ; return ; } } } if ( ! empty ( $ data [ 'delayed' ] ) && $ data [ 'delayed' ] [ 0 ] [ 2 ] <= time ( ) ) { list ( $ id , $ ttr , $ time ) = array_shift ( $ data [ 'delayed' ] ) ; } elseif ( ! empty ( $ data [ 'waiting' ] ) ) { list ( $ id , $ ttr ) = array_shift ( $ data [ 'waiting' ] ) ; } if ( $ id ) { $ attempt = 1 ; $ data [ 'reserved' ] [ "job$id" ] = [ $ id , $ ttr , $ attempt , time ( ) ] ; } } ) ; if ( $ id ) { return [ $ id , file_get_contents ( "$this->path/job$id.data" ) , $ ttr , $ attempt ] ; } return null ; } 
protected function delete ( $ payload ) { $ id = $ payload [ 0 ] ; $ this -> touchIndex ( function ( & $ data ) use ( $ id ) { foreach ( $ data [ 'reserved' ] as $ key => $ payload ) { if ( $ payload [ 0 ] === $ id ) { unset ( $ data [ 'reserved' ] [ $ key ] ) ; break ; } } } ) ; unlink ( "$this->path/job$id.data" ) ; } 
public function parse ( ) : array { $ previousEntityState = libxml_disable_entity_loader ( true ) ; $ previousSetting = libxml_use_internal_errors ( true ) ; try { while ( self :: ELEMENT !== $ this -> nodeType ) { if ( ! $ this -> read ( ) ) { $ errors = libxml_get_errors ( ) ; libxml_clear_errors ( ) ; if ( $ errors ) { throw new LibXMLException ( $ errors ) ; } } } $ result = $ this -> parseCurrentElement ( ) ; 
public function parseGetElements ( array $ elementMap = null ) : array { $ result = $ this -> parseInnerTree ( $ elementMap ) ; if ( ! is_array ( $ result ) ) { return [ ] ; } return $ result ; } 
public function parseInnerTree ( array $ elementMap = null ) { $ text = null ; $ elements = [ ] ; if ( self :: ELEMENT === $ this -> nodeType && $ this -> isEmptyElement ) { 
public function readText ( ) : string { $ result = '' ; $ previousDepth = $ this -> depth ; while ( $ this -> read ( ) && $ this -> depth != $ previousDepth ) { if ( in_array ( $ this -> nodeType , [ XMLReader :: TEXT , XMLReader :: CDATA , XMLReader :: WHITESPACE ] ) ) { $ result .= $ this -> value ; } } return $ result ; } 
public function parseCurrentElement ( ) : array { $ name = $ this -> getClark ( ) ; $ attributes = [ ] ; if ( $ this -> hasAttributes ) { $ attributes = $ this -> parseAttributes ( ) ; } $ value = call_user_func ( $ this -> getDeserializerForElementName ( ( string ) $ name ) , $ this ) ; return [ 'name' => $ name , 'value' => $ value , 'attributes' => $ attributes , ] ; } 
public function parseAttributes ( ) : array { $ attributes = [ ] ; while ( $ this -> moveToNextAttribute ( ) ) { if ( $ this -> namespaceURI ) { 
public function getDeserializerForElementName ( string $ name ) : callable { if ( ! array_key_exists ( $ name , $ this -> elementMap ) ) { if ( '{}' == substr ( $ name , 0 , 2 ) && array_key_exists ( substr ( $ name , 2 ) , $ this -> elementMap ) ) { $ name = substr ( $ name , 2 ) ; } else { return [ 'Sabre\\Xml\\Element\\Base' , 'xmlDeserialize' ] ; } } $ deserializer = $ this -> elementMap [ $ name ] ; if ( is_subclass_of ( $ deserializer , 'Sabre\\Xml\\XmlDeserializable' ) ) { return [ $ deserializer , 'xmlDeserialize' ] ; } if ( is_callable ( $ deserializer ) ) { return $ deserializer ; } $ type = gettype ( $ deserializer ) ; if ( 'string' === $ type ) { $ type .= ' (' . $ deserializer . ')' ; } elseif ( 'object' === $ type ) { $ type .= ' (' . get_class ( $ deserializer ) . ')' ; } throw new \ LogicException ( 'Could not use this type as a deserializer: ' . $ type . ' for element: ' . $ name ) ; } 
public function pushContext ( ) { $ this -> contextStack [ ] = [ $ this -> elementMap , $ this -> contextUri , $ this -> namespaceMap , $ this -> classMap , ] ; } 
public function popContext ( ) { list ( $ this -> elementMap , $ this -> contextUri , $ this -> namespaceMap , $ this -> classMap ) = array_pop ( $ this -> contextStack ) ; } 
public function getWriter ( ) : Writer { $ w = new Writer ( ) ; $ w -> namespaceMap = $ this -> namespaceMap ; $ w -> classMap = $ this -> classMap ; return $ w ; } 
public function parse ( $ input , string $ contextUri = null , string & $ rootElementName = null ) { if ( is_resource ( $ input ) ) { 
public function expect ( $ rootElementName , $ input , string $ contextUri = null ) { if ( is_resource ( $ input ) ) { 
public function write ( string $ rootElementName , $ value , string $ contextUri = null ) { $ w = $ this -> getWriter ( ) ; $ w -> openMemory ( ) ; $ w -> contextUri = $ contextUri ; $ w -> setIndent ( true ) ; $ w -> startDocument ( ) ; $ w -> writeElement ( $ rootElementName , $ value ) ; return $ w -> outputMemory ( ) ; } 
public function mapValueObject ( string $ elementName , string $ className ) { list ( $ namespace ) = self :: parseClarkNotation ( $ elementName ) ; $ this -> elementMap [ $ elementName ] = function ( Reader $ reader ) use ( $ className , $ namespace ) { return \ Sabre \ Xml \ Deserializer \ valueObject ( $ reader , $ className , $ namespace ) ; } ; $ this -> classMap [ $ className ] = function ( Writer $ writer , $ valueObject ) use ( $ namespace ) { return \ Sabre \ Xml \ Serializer \ valueObject ( $ writer , $ valueObject , $ namespace ) ; } ; $ this -> valueObjectMap [ $ className ] = $ elementName ; } 
public function writeValueObject ( $ object , string $ contextUri = null ) { if ( ! isset ( $ this -> valueObjectMap [ get_class ( $ object ) ] ) ) { throw new \ InvalidArgumentException ( '"' . get_class ( $ object ) . '" is not a registered value object class. Register your class with mapValueObject.' ) ; } return $ this -> write ( $ this -> valueObjectMap [ get_class ( $ object ) ] , $ object , $ contextUri ) ; } 
public static function parseClarkNotation ( string $ str ) : array { static $ cache = [ ] ; if ( ! isset ( $ cache [ $ str ] ) ) { if ( ! preg_match ( '/^{([^}]*)}(.*)$/' , $ str , $ matches ) ) { throw new \ InvalidArgumentException ( '\'' . $ str . '\' is not a valid clark-notation formatted string' ) ; } $ cache [ $ str ] = [ $ matches [ 1 ] , $ matches [ 2 ] , ] ; } return $ cache [ $ str ] ; } 
public function xmlSerialize ( Writer $ writer ) { $ reader = new Reader ( ) ; <?xml version="1.0"?> <xml-fragment xmlns="http://sabre.io/ns">{$this->getXml()}</xml-fragment> XML ; $ reader -> xml ( $ xml ) ; while ( $ reader -> read ( ) ) { if ( $ reader -> depth < 1 ) { 
public static function xmlDeserialize ( Reader $ reader ) { $ result = new self ( $ reader -> readInnerXml ( ) ) ; $ reader -> next ( ) ; return $ result ; } 
public function xmlSerialize ( Xml \ Writer $ writer ) { $ writer -> text ( \ Sabre \ Uri \ resolve ( $ writer -> contextUri , $ this -> value ) ) ; } 
public static function xmlDeserialize ( Xml \ Reader $ reader ) { return new self ( \ Sabre \ Uri \ resolve ( ( string ) $ reader -> contextUri , $ reader -> readText ( ) ) ) ; } 
public function startElement ( $ name ) : bool { if ( '{' === $ name [ 0 ] ) { list ( $ namespace , $ localName ) = Service :: parseClarkNotation ( $ name ) ; if ( array_key_exists ( $ namespace , $ this -> namespaceMap ) ) { $ result = $ this -> startElementNS ( '' === $ this -> namespaceMap [ $ namespace ] ? null : $ this -> namespaceMap [ $ namespace ] , $ localName , null ) ; } else { 
public function writeElement ( $ name , $ content = null ) : bool { $ this -> startElement ( $ name ) ; if ( ! is_null ( $ content ) ) { $ this -> write ( $ content ) ; } $ this -> endElement ( ) ; return true ; } 
public function writeAttributes ( array $ attributes ) { foreach ( $ attributes as $ name => $ value ) { $ this -> writeAttribute ( $ name , $ value ) ; } } 
public function writeAttribute ( $ name , $ value ) : bool { if ( '{' !== $ name [ 0 ] ) { return parent :: writeAttribute ( $ name , $ value ) ; } list ( $ namespace , $ localName ) = Service :: parseClarkNotation ( $ name ) ; if ( array_key_exists ( $ namespace , $ this -> namespaceMap ) ) { 
public function register ( ) { $ this -> mergeConfigFrom ( __DIR__ . '/../config/config.php' , 'erd-generator' ) ; $ this -> app -> bind ( 'command.generate:diagram' , GenerateDiagramCommand :: class ) ; $ this -> commands ( [ 'command.generate:diagram' , ] ) ; } 
public function getModelRelations ( string $ model ) { $ class = new ReflectionClass ( $ model ) ; $ traitMethods = Collection :: make ( $ class -> getTraits ( ) ) -> map ( function ( ReflectionClass $ trait ) { return Collection :: make ( $ trait -> getMethods ( ReflectionMethod :: IS_PUBLIC ) ) ; } ) -> flatten ( ) ; $ methods = Collection :: make ( $ class -> getMethods ( ReflectionMethod :: IS_PUBLIC ) ) -> merge ( $ traitMethods ) -> reject ( function ( ReflectionMethod $ method ) use ( $ model ) { return $ method -> class !== $ model || $ method -> getNumberOfParameters ( ) > 0 ; } ) ; $ relations = Collection :: make ( ) ; $ methods -> map ( function ( ReflectionMethod $ method ) use ( $ model , & $ relations ) { $ relations = $ relations -> merge ( $ this -> getRelationshipFromMethodAndModel ( $ method , $ model ) ) ; } ) ; $ relations = $ relations -> filter ( ) ; if ( $ ignoreRelations = array_get ( config ( 'erd-generator.ignore' , [ ] ) , $ model ) ) { $ relations = $ relations -> diffKeys ( array_flip ( $ ignoreRelations ) ) ; } return $ relations ; } 
protected function execute ( InputInterface $ input , OutputInterface $ output ) { $ job = new CronJob ( ) ; $ output -> writeln ( '' ) ; $ output -> writeln ( '<info>The unique name how the job will be referenced.</info>' ) ; $ question = new Question ( '<question>Name:</question> ' , false ) ; $ name = $ this -> getQuestionHelper ( ) -> ask ( $ input , $ output , $ question ) ; $ this -> validateJobName ( $ name ) ; $ job -> setName ( $ name ) ; $ output -> writeln ( '' ) ; $ output -> writeln ( '<info>The command to execute. You may add extra arguments.</info>' ) ; $ question = new Question ( '<question>Command:</question> ' , false ) ; $ command = $ this -> getQuestionHelper ( ) -> ask ( $ input , $ output , $ question ) ; $ this -> validateCommand ( $ command ) ; $ job -> setCommand ( $ command ) ; $ output -> writeln ( '' ) ; $ output -> writeln ( '<info>The schedule in the crontab syntax.</info>' ) ; $ question = new Question ( '<question>Schedule:</question> ' , false ) ; $ schedule = $ this -> getQuestionHelper ( ) -> ask ( $ input , $ output , $ question ) ; $ this -> validateSchedule ( $ schedule ) ; $ job -> setSchedule ( $ schedule ) ; $ output -> writeln ( '' ) ; $ output -> writeln ( '<info>Some more information about the job.</info>' ) ; $ question = new Question ( '<question>Description:</question> ' , false ) ; $ description = $ this -> getQuestionHelper ( ) -> ask ( $ input , $ output , $ question ) ; $ job -> setDescription ( $ description ) ; $ output -> writeln ( '' ) ; $ output -> writeln ( '<info>Should the cron be enabled.</info>' ) ; $ question = new ConfirmationQuestion ( '<question>Enable?</question> [y/n]: ' , false , '/^(y)/i' ) ; $ enabled = $ this -> getQuestionHelper ( ) -> ask ( $ input , $ output , $ question ) ; $ job -> setEnabled ( $ enabled ) ; $ this -> getContainer ( ) -> get ( 'cron.manager' ) -> saveJob ( $ job ) ; $ output -> writeln ( '' ) ; $ output -> writeln ( sprintf ( '<info>Cron "%s" was created..</info>' , $ job -> getName ( ) ) ) ; } 
protected function validateJobName ( $ name ) { if ( ! $ name || strlen ( $ name ) == 0 ) { throw new \ InvalidArgumentException ( 'Please set a name.' ) ; } if ( $ this -> queryJob ( $ name ) ) { throw new \ InvalidArgumentException ( 'Name already in use.' ) ; } return $ name ; } 
protected function validateCommand ( $ command ) { $ parts = explode ( ' ' , $ command ) ; $ this -> getApplication ( ) -> get ( ( string ) $ parts [ 0 ] ) ; return $ command ; } 
protected function execute ( InputInterface $ input , OutputInterface $ output ) { $ cron = new Cron ( ) ; $ cron -> setExecutor ( $ this -> getContainer ( ) -> get ( 'cron.executor' ) ) ; if ( $ input -> getArgument ( 'job' ) ) { $ resolver = $ this -> getJobResolver ( $ input -> getArgument ( 'job' ) , $ input -> hasOption ( 'force' ) ) ; } else { $ resolver = $ this -> getContainer ( ) -> get ( 'cron.resolver' ) ; } $ cron -> setResolver ( $ resolver ) ; $ time = microtime ( true ) ; $ dbReport = $ cron -> run ( ) ; while ( $ cron -> isRunning ( ) ) { } $ output -> writeln ( 'time: ' . ( microtime ( true ) - $ time ) ) ; $ manager = $ this -> getContainer ( ) -> get ( 'cron.manager' ) ; $ manager -> saveReports ( $ dbReport -> getReports ( ) ) ; } 
protected function createJob ( CronJob $ dbJob ) { $ job = new ShellJob ( ) ; $ job -> setCommand ( $ this -> commandBuilder -> build ( $ dbJob -> getCommand ( ) ) , $ this -> rootDir ) ; $ job -> setSchedule ( new CrontabSchedule ( $ dbJob -> getSchedule ( ) ) ) ; $ job -> raw = $ dbJob ; return $ job ; } 
protected function execute ( InputInterface $ input , OutputInterface $ output ) { $ pidFile = sys_get_temp_dir ( ) . DIRECTORY_SEPARATOR . CronStartCommand :: PID_FILE ; if ( ! file_exists ( $ pidFile ) ) { return 0 ; } if ( ! extension_loaded ( 'pcntl' ) ) { throw new \ RuntimeException ( 'This command needs the pcntl extension to run.' ) ; } if ( ! posix_kill ( file_get_contents ( $ pidFile ) , SIGINT ) ) { if ( ! unlink ( $ pidFile ) ) { throw new \ RuntimeException ( 'Unable to stop scheduler.' ) ; } $ output -> writeln ( sprintf ( '<comment>%s</comment>' , 'Unable to kill cron scheduler process. Scheduler will be stopped before the next run.' ) ) ; return 0 ; } unlink ( $ pidFile ) ; $ output -> writeln ( sprintf ( '<info>%s</info>' , 'Cron scheduler is stopped.' ) ) ; } 
protected function execute ( InputInterface $ input , OutputInterface $ output ) { $ jobs = $ this -> queryJobs ( ) ; foreach ( $ jobs as $ job ) { $ state = $ job -> getEnabled ( ) ? 'x' : ' ' ; $ output -> writeln ( sprintf ( ' [%s] %s' , $ state , $ job -> getName ( ) ) ) ; } } 
protected function execute ( InputInterface $ input , OutputInterface $ output ) { if ( $ input -> getOption ( 'blocking' ) ) { $ output -> writeln ( sprintf ( '<info>%s</info>' , 'Starting cron scheduler in blocking mode.' ) ) ; $ this -> scheduler ( $ output -> isVerbose ( ) ? $ output : new NullOutput ( ) , null ) ; return 0 ; } if ( ! extension_loaded ( 'pcntl' ) ) { throw new \ RuntimeException ( 'This command needs the pcntl extension to run.' ) ; } $ pidFile = sys_get_temp_dir ( ) . DIRECTORY_SEPARATOR . self :: PID_FILE ; if ( - 1 === $ pid = pcntl_fork ( ) ) { throw new \ RuntimeException ( 'Unable to start the cron process.' ) ; } elseif ( 0 !== $ pid ) { if ( false === file_put_contents ( $ pidFile , $ pid ) ) { throw new \ RuntimeException ( 'Unable to create process file.' ) ; } $ output -> writeln ( sprintf ( '<info>%s</info>' , 'Cron scheduler started in non-blocking mode...' ) ) ; return 0 ; } if ( - 1 === posix_setsid ( ) ) { throw new \ RuntimeException ( 'Unable to set the child process as session leader.' ) ; } $ this -> scheduler ( new NullOutput ( ) , $ pidFile ) ; } 
protected function execute ( InputInterface $ input , OutputInterface $ output ) { $ job = $ this -> queryJob ( $ input -> getArgument ( 'job' ) ) ; if ( ! $ job ) { throw new \ InvalidArgumentException ( 'Unknown job.' ) ; } $ job -> setEnabled ( false ) ; $ this -> getContainer ( ) -> get ( 'cron.manager' ) -> saveJob ( $ job ) ; $ output -> writeln ( sprintf ( 'Cron "%s" disabled' , $ job -> getName ( ) ) ) ; } 
protected function execute ( InputInterface $ input , OutputInterface $ output ) { $ job = $ this -> queryJob ( $ input -> getArgument ( 'job' ) ) ; if ( ! $ job ) { throw new \ InvalidArgumentException ( 'Unknown job.' ) ; } if ( $ job -> getEnabled ( ) ) { throw new \ InvalidArgumentException ( 'The job should be disabled first.' ) ; } $ output -> writeln ( sprintf ( '<info>You are about to delete "%s".</info>' , $ job -> getName ( ) ) ) ; $ question = new ConfirmationQuestion ( '<question>Delete this job</question> [N/y]: ' , false , '/^(y)/i' ) ; if ( ! $ this -> getQuestionHelper ( ) -> ask ( $ input , $ output , $ question ) ) { return ; } $ this -> getContainer ( ) -> get ( 'cron.manager' ) -> deleteJob ( $ job ) ; $ output -> writeln ( sprintf ( '<info>Cron "%s" was deleted.</info>' , $ job -> getName ( ) ) ) ; } 
public function createScopeAndRetrieveItsCloser ( ? TraceContext $ currentContext = null ) : callable { $ previous = $ this -> context ; $ self = $ this ; $ this -> context = $ currentContext ; return function ( ) use ( $ previous , $ self ) { $ self -> context = $ previous ; } ; } 
public function build ( ? array $ options = [ ] ) : callable { return static function ( $ payload ) use ( $ options ) { $ handle = curl_init ( $ options [ 'endpoint_url' ] ) ; if ( $ handle === false ) { throw new RuntimeException ( sprintf ( 'failed to create the handle for url "%s"' , $ options [ 'endpoint_url' ] ) ) ; } curl_setopt ( $ handle , CURLOPT_POST , 1 ) ; curl_setopt ( $ handle , CURLOPT_POSTFIELDS , $ payload ) ; curl_setopt ( $ handle , CURLOPT_RETURNTRANSFER , true ) ; $ requiredHeaders = [ 'Content-Type' => 'application/json' , 'Content-Length' => strlen ( $ payload ) , ] ; $ additionalHeaders = ( isset ( $ options [ 'headers' ] ) ? $ options [ 'headers' ] : [ ] ) ; $ headers = array_merge ( $ additionalHeaders , $ requiredHeaders ) ; $ formattedHeaders = array_map ( function ( $ key , $ value ) { return $ key . ': ' . $ value ; } , array_keys ( $ headers ) , $ headers ) ; curl_setopt ( $ handle , CURLOPT_HTTPHEADER , $ formattedHeaders ) ; if ( isset ( $ options [ 'timeout' ] ) ) { curl_setopt ( $ handle , CURLOPT_TIMEOUT , $ options [ 'timeout' ] ) ; } if ( curl_exec ( $ handle ) !== false ) { $ statusCode = curl_getinfo ( $ handle , CURLINFO_HTTP_CODE ) ; curl_close ( $ handle ) ; if ( $ statusCode !== 202 ) { throw new RuntimeException ( sprintf ( 'Reporting of spans failed, status code %d' , $ statusCode ) ) ; } } else { throw new RuntimeException ( sprintf ( 'Reporting of spans failed: %s, error code %s' , curl_error ( $ handle ) , curl_errno ( $ handle ) ) ) ; } } ; } 
public function getInjector ( Setter $ setter ) : callable { return function ( TraceContext $ traceContext , & $ carrier ) use ( $ setter ) { $ setter -> put ( $ carrier , self :: TRACE_ID_NAME , $ traceContext -> getTraceId ( ) ) ; $ setter -> put ( $ carrier , self :: SPAN_ID_NAME , $ traceContext -> getSpanId ( ) ) ; if ( $ traceContext -> getParentId ( ) !== null ) { $ setter -> put ( $ carrier , self :: PARENT_SPAN_ID_NAME , $ traceContext -> getParentId ( ) ) ; } if ( $ traceContext -> isSampled ( ) !== null ) { $ setter -> put ( $ carrier , self :: SAMPLED_NAME , $ traceContext -> isSampled ( ) ? '1' : '0' ) ; } $ setter -> put ( $ carrier , self :: FLAGS_NAME , $ traceContext -> isDebug ( ) ? '1' : '0' ) ; } ; } 
public function getExtractor ( Getter $ getter ) : callable { return function ( $ carrier ) use ( $ getter ) { $ isSampledRaw = $ getter -> get ( $ carrier , self :: SAMPLED_NAME ) ; $ isSampled = SamplingFlags :: EMPTY_SAMPLED ; if ( $ isSampledRaw !== null ) { if ( $ isSampledRaw === '1' || strtolower ( $ isSampledRaw ) === 'true' ) { $ isSampled = true ; } elseif ( $ isSampledRaw === '0' || strtolower ( $ isSampledRaw ) === 'false' ) { $ isSampled = false ; } } $ isDebugRaw = $ getter -> get ( $ carrier , self :: FLAGS_NAME ) ; $ isDebug = SamplingFlags :: EMPTY_DEBUG ; if ( $ isDebugRaw !== null ) { $ isDebug = ( $ isDebugRaw === '1' ) ; } $ traceId = $ getter -> get ( $ carrier , self :: TRACE_ID_NAME ) ; if ( $ isSampled === null && $ isDebug === null && $ traceId === null ) { return DefaultSamplingFlags :: createAsEmpty ( ) ; } $ spanId = $ getter -> get ( $ carrier , self :: SPAN_ID_NAME ) ; if ( $ spanId === null ) { return DefaultSamplingFlags :: create ( $ isSampled , $ isDebug ) ; } $ parentSpanId = $ getter -> get ( $ carrier , self :: PARENT_SPAN_ID_NAME ) ; try { return TraceContext :: create ( $ traceId , $ spanId , $ parentSpanId , $ isSampled , $ isDebug ) ; } catch ( InvalidTraceContextArgument $ e ) { $ this -> logger -> debug ( sprintf ( 'Failed to extract propagated context: %s' , $ e -> getMessage ( ) ) ) ; return DefaultSamplingFlags :: createAsEmpty ( ) ; } } ; } 
public function finish ( ? int $ finishTimestamp = null ) : void { if ( $ this -> finished ) { return ; } if ( $ this -> timestamp !== null && $ finishTimestamp !== null ) { $ this -> duration = $ finishTimestamp - $ this -> timestamp ; } $ this -> finished = true ; } 
public function newTrace ( SamplingFlags $ samplingFlags = null ) : Span { if ( $ samplingFlags === null ) { $ samplingFlags = DefaultSamplingFlags :: createAsEmpty ( ) ; } return $ this -> ensureSampled ( $ this -> newRootContext ( $ samplingFlags ) ) ; } 
public function openScope ( ? Span $ span = null ) : callable { return $ this -> currentTraceContext -> createScopeAndRetrieveItsCloser ( $ span === null ? null : $ span -> getContext ( ) ) ; } 
public function getCurrentSpan ( ) : ? Span { $ currentContext = $ this -> currentTraceContext -> getContext ( ) ; return $ currentContext === null ? null : $ this -> toSpan ( $ currentContext ) ; } 
public function nextSpan ( ? SamplingFlags $ contextOrFlags = null ) : Span { if ( $ contextOrFlags === null ) { $ parent = $ this -> currentTraceContext -> getContext ( ) ; return $ parent === null ? $ this -> newTrace ( ) : $ this -> newChild ( $ parent ) ; } if ( $ contextOrFlags instanceof TraceContext ) { return $ this -> toSpan ( TraceContext :: createFromParent ( $ contextOrFlags ) ) ; } if ( $ contextOrFlags instanceof SamplingFlags ) { $ implicitParent = $ this -> currentTraceContext -> getContext ( ) ; if ( $ implicitParent === null ) { return $ this -> toSpan ( $ this -> newRootContext ( $ contextOrFlags ) ) ; } } throw new RuntimeException ( 'Context or flags for next span is invalid.' ) ; } 
private function toSpan ( TraceContext $ context ) : Span { if ( ! $ this -> isNoop && $ context -> isSampled ( ) ) { return RealSpan :: create ( $ context , $ this -> recorder ) ; } return NoopSpan :: create ( $ context ) ; } 
public function get ( $ carrier , string $ key ) : ? string { $ lKey = strtolower ( $ key ) ; if ( $ carrier instanceof ArrayAccess ) { return $ carrier -> offsetExists ( $ lKey ) ? $ carrier -> offsetGet ( $ lKey ) : null ; } if ( is_array ( $ carrier ) ) { return array_key_exists ( $ lKey , $ carrier ) ? $ carrier [ $ lKey ] : null ; } throw InvalidPropagationCarrier :: forCarrier ( $ carrier ) ; } 
public function put ( & $ carrier , string $ key , string $ value ) : void { if ( $ key === '' ) { throw InvalidPropagationKey :: forEmptyKey ( ) ; } $ lKey = strtolower ( $ key ) ; if ( $ carrier instanceof ArrayAccess || is_array ( $ carrier ) ) { $ carrier [ $ lKey ] = $ value ; return ; } throw InvalidPropagationCarrier :: forCarrier ( $ carrier ) ; } 
public function start ( ? int $ timestamp = null ) : void { if ( $ timestamp === null ) { $ timestamp = now ( ) ; } else { if ( ! isValid ( $ timestamp ) ) { throw new InvalidArgumentException ( sprintf ( 'Invalid timestamp. Expected int, got %s' , $ timestamp ) ) ; } } $ this -> recorder -> start ( $ this -> traceContext , $ timestamp ) ; } 
public function setName ( string $ name ) : void { $ this -> recorder -> setName ( $ this -> traceContext , $ name ) ; } 
public function setKind ( string $ kind ) : void { $ this -> recorder -> setKind ( $ this -> traceContext , $ kind ) ; } 
public function tag ( string $ key , string $ value ) : void { $ this -> recorder -> tag ( $ this -> traceContext , $ key , $ value ) ; } 
public function annotate ( string $ value , ? int $ timestamp = null ) : void { if ( ! isValid ( $ timestamp ) ) { throw new InvalidArgumentException ( sprintf ( 'Valid timestamp represented microtime expected, got \'%s\'' , $ timestamp ) ) ; } $ this -> recorder -> annotate ( $ this -> traceContext , $ timestamp , $ value ) ; } 
public function setRemoteEndpoint ( Endpoint $ remoteEndpoint ) : void { $ this -> recorder -> setRemoteEndpoint ( $ this -> traceContext , $ remoteEndpoint ) ; } 
public function finish ( ? int $ timestamp = null ) : void { if ( $ timestamp !== null && ! Timestamp \ isValid ( $ timestamp ) ) { throw new InvalidArgumentException ( 'Invalid timestamp' ) ; } if ( $ timestamp === null ) { $ timestamp = now ( ) ; } $ this -> recorder -> finish ( $ this -> traceContext , $ timestamp ) ; } 
public function get ( $ carrier , string $ key ) : ? string { $ lKey = strtolower ( $ key ) ; return $ carrier -> hasHeader ( $ lKey ) ? $ carrier -> getHeader ( $ lKey ) [ 0 ] : null ; } 
public function put ( & $ carrier , string $ key , string $ value ) : void { $ lKey = strtolower ( $ key ) ; $ carrier = $ carrier -> withAddedHeader ( $ lKey , $ value ) ; } 
public function generateToken ( ) { 
public function generateNewToken ( ServerRequestInterface $ request ) { $ pair = $ this -> generateToken ( ) ; $ request = $ this -> attachRequestAttributes ( $ request , $ pair ) ; return $ request ; } 
protected function getFromStorage ( $ name ) { return isset ( $ this -> storage [ $ name ] ) ? $ this -> storage [ $ name ] : false ; } 
protected function getLastKeyPair ( ) { 
protected function enforceStorageLimit ( ) { if ( $ this -> storageLimit < 1 ) { return ; } 
public static function create ( array $ config ) : SanitizerInterface { $ builder = new SanitizerBuilder ( ) ; $ builder -> registerExtension ( new BasicExtension ( ) ) ; $ builder -> registerExtension ( new ListExtension ( ) ) ; $ builder -> registerExtension ( new ImageExtension ( ) ) ; $ builder -> registerExtension ( new CodeExtension ( ) ) ; $ builder -> registerExtension ( new TableExtension ( ) ) ; $ builder -> registerExtension ( new IframeExtension ( ) ) ; $ builder -> registerExtension ( new DetailsExtension ( ) ) ; $ builder -> registerExtension ( new ExtraExtension ( ) ) ; return $ builder -> build ( $ config ) ; } 
private function setAttributes ( \ DOMNode $ domNode , TagNodeInterface $ node , array $ allowedAttributes = [ ] ) { if ( ! \ count ( $ domNode -> attributes ) ) { return ; } foreach ( $ domNode -> attributes as $ attribute ) { $ name = strtolower ( $ attribute -> name ) ; if ( \ in_array ( $ name , $ allowedAttributes , true ) ) { $ node -> setAttribute ( $ name , $ attribute -> value ) ; } } } 
private function getAttribute ( \ DOMNode $ domNode , string $ name ) : ? string { if ( ! \ count ( $ domNode -> attributes ) ) { return null ; } foreach ( $ domNode -> attributes as $ attribute ) { if ( $ attribute -> name === $ name ) { return $ attribute -> value ; } } return null ; } 
public function boot ( ) { if ( $ this -> app -> runningInConsole ( ) ) { $ this -> publishes ( [ __DIR__ . '/../config/config.php' => config_path ( 'querydetector.php' ) , ] , 'config' ) ; } $ this -> registerMiddleware ( QueryDetectorMiddleware :: class ) ; } 
public function register ( ) { $ this -> app -> singleton ( QueryDetector :: class ) ; $ this -> app -> alias ( QueryDetector :: class , 'querydetector' ) ; $ this -> mergeConfigFrom ( __DIR__ . '/../config/config.php' , 'querydetector' ) ; } 
public function handle ( $ request , Closure $ next ) { if ( ! $ this -> detector -> isEnabled ( ) ) { return $ next ( $ request ) ; } $ this -> detector -> boot ( ) ; $ response = $ next ( $ request ) ; 
private function processDefaultEntity ( array $ backendConfig ) { $ entityNames = \ array_keys ( $ backendConfig [ 'entities' ] ) ; $ firstEntityName = $ entityNames [ 0 ] ?? null ; $ backendConfig [ 'default_entity_name' ] = $ firstEntityName ; return $ backendConfig ; } 
private function processDefaultMenuItem ( array $ backendConfig ) { $ defaultMenuItem = $ this -> findDefaultMenuItem ( $ backendConfig [ 'design' ] [ 'menu' ] ) ; if ( 'empty' === $ defaultMenuItem [ 'type' ] ) { throw new \ RuntimeException ( \ sprintf ( 'The "menu" configuration sets "%s" as the default item, which is not possible because its type is "empty" and it cannot redirect to a valid URL.' , $ defaultMenuItem [ 'label' ] ) ) ; } $ backendConfig [ 'default_menu_item' ] = $ defaultMenuItem ; return $ backendConfig ; } 
private function findDefaultMenuItem ( array $ menuConfig ) { foreach ( $ menuConfig as $ itemConfig ) { if ( true === $ itemConfig [ 'default' ] ) { return $ itemConfig ; } foreach ( $ itemConfig [ 'children' ] as $ subitemConfig ) { if ( true === $ subitemConfig [ 'default' ] ) { return $ subitemConfig ; } } } } 
private function processDefaultHomepage ( array $ backendConfig ) { $ backendHomepage = [ ] ; 
public function supports ( $ type , array $ options , array $ metadata ) { $ isFosCkeditorField = \ in_array ( $ type , [ 'fos_ckeditor' , 'FOS\\CKEditorBundle\\Form\\Type\\CKEditorType' ] , true ) ; return $ isFosCkeditorField && ! isset ( $ options [ 'config' ] [ 'toolbar' ] ) && ! isset ( $ options [ 'config_name' ] ) ; } 
public function supports ( $ type , array $ options , array $ metadata ) { $ isTextareaField = \ in_array ( $ type , [ 'textarea' , TextareaType :: class ] , true ) ; return $ isTextareaField && ! isset ( $ options [ 'attr' ] [ 'rows' ] ) ; } 
public static function getTypeName ( $ typeFqcn ) { 
public function configure ( $ name , array $ options , array $ metadata , FormConfigInterface $ parentConfig ) { if ( ! isset ( $ options [ 'multiple' ] ) && $ metadata [ 'associationType' ] & ClassMetadata :: TO_MANY ) { $ options [ 'multiple' ] = true ; } 
public function supports ( $ type , array $ options , array $ metadata ) { $ isEntityType = \ in_array ( $ type , [ 'entity' , EntityType :: class ] , true ) ; return $ isEntityType && 'association' === $ metadata [ 'dataType' ] ; } 
public function finishView ( FormView $ view , FormInterface $ form , array $ options ) { $ request = null ; if ( null !== $ this -> requestStack ) { $ request = $ this -> requestStack -> getCurrentRequest ( ) ; } if ( null === $ request ) { return ; } if ( $ request -> attributes -> has ( 'easyadmin' ) ) { $ easyadmin = $ request -> attributes -> get ( 'easyadmin' ) ; $ entity = $ easyadmin [ 'entity' ] ; $ action = $ easyadmin [ 'view' ] ; $ fields = $ entity [ $ action ] [ 'fields' ] ?? [ ] ; $ view -> vars [ 'easyadmin' ] = [ 'entity' => $ entity , 'view' => $ action , 'item' => $ easyadmin [ 'item' ] , 'field' => null , 'form_group' => $ form -> getConfig ( ) -> getAttribute ( 'easyadmin_form_group' ) , 'form_tab' => $ form -> getConfig ( ) -> getAttribute ( 'easyadmin_form_tab' ) , ] ; if ( null !== $ view -> parent && null === $ view -> parent -> parent ) { $ view -> vars [ 'easyadmin' ] [ 'field' ] = $ fields [ $ view -> vars [ 'name' ] ] ?? null ; } } } 
public function findByAllProperties ( array $ entityConfig , $ searchQuery , $ page = 1 , $ maxResults = self :: MAX_RESULTS , $ sortField = null , $ sortDirection = null ) { $ queryBuilder = $ this -> queryBuilder -> createSearchQueryBuilder ( $ entityConfig , $ searchQuery , $ sortField , $ sortDirection ) ; return $ this -> paginator -> createOrmPaginator ( $ queryBuilder , $ page , $ maxResults ) ; } 
private function processMetadataConfig ( array $ backendConfig ) { foreach ( $ backendConfig [ 'entities' ] as $ entityName => $ entityConfig ) { $ properties = [ ] ; foreach ( $ entityConfig [ 'properties' ] as $ propertyName => $ propertyMetadata ) { $ typeGuess = $ this -> getFormTypeGuessOfProperty ( $ entityConfig [ 'class' ] , $ propertyName ) ; $ requiredGuess = $ this -> getFormRequiredGuessOfProperty ( $ entityConfig [ 'class' ] , $ propertyName ) ; $ guessedType = null !== $ typeGuess ? FormTypeHelper :: getTypeName ( $ typeGuess -> getType ( ) ) : $ propertyMetadata [ 'type' ] ; $ guessedTypeOptions = null !== $ typeGuess ? $ typeGuess -> getOptions ( ) : [ ] ; if ( null !== $ requiredGuess ) { $ guessedTypeOptions [ 'required' ] = $ requiredGuess -> getValue ( ) ; } $ properties [ $ propertyName ] = \ array_replace ( $ this -> defaultEntityFieldConfig , $ propertyMetadata , [ 'property' => $ propertyName , 'dataType' => $ propertyMetadata [ 'type' ] , 'fieldType' => $ guessedType , 'type_options' => $ guessedTypeOptions , ] ) ; 
private function processFieldConfig ( array $ backendConfig ) { foreach ( $ backendConfig [ 'entities' ] as $ entityName => $ entityConfig ) { foreach ( [ 'edit' , 'list' , 'new' , 'search' , 'show' ] as $ view ) { $ originalViewConfig = $ backendConfig [ 'entities' ] [ $ entityName ] [ $ view ] ; foreach ( $ entityConfig [ $ view ] [ 'fields' ] as $ fieldName => $ fieldConfig ) { $ originalFieldConfig = $ originalViewConfig [ 'fields' ] [ $ fieldName ] ?? null ; if ( \ array_key_exists ( $ fieldName , $ entityConfig [ 'properties' ] ) ) { $ fieldMetadata = \ array_merge ( $ entityConfig [ 'properties' ] [ $ fieldName ] , [ 'virtual' => false ] ) ; } else { 
private function getFormTypeOptionsOfProperty ( array $ mergedConfig , array $ guessedConfig , array $ userDefinedConfig ) { $ resolvedFormOptions = $ mergedConfig [ 'type_options' ] ; 
private function getFieldFormat ( $ fieldType , array $ backendConfig ) { if ( \ in_array ( $ fieldType , [ 'date' , 'date_immutable' , 'dateinterval' , 'time' , 'time_immutable' , 'datetime' , 'datetime_immutable' , 'datetimetz' ] ) ) { 
public function configure ( $ name , array $ options , array $ metadata , FormConfigInterface $ parentConfig ) { if ( ! \ array_key_exists ( 'label' , $ options ) && \ array_key_exists ( 'label' , $ metadata ) ) { $ options [ 'label' ] = $ metadata [ 'label' ] ; } if ( empty ( $ options [ 'translation_domain' ] ) ) { $ entityConfig = $ this -> configManager -> getEntityConfig ( $ parentConfig -> getOption ( 'entity' ) ) ; if ( ! empty ( $ entityConfig [ 'translation_domain' ] ) ) { $ options [ 'translation_domain' ] = $ entityConfig [ 'translation_domain' ] ; } } return $ options ; } 
public function indexAction ( Request $ request ) { $ this -> initialize ( $ request ) ; if ( null === $ request -> query -> get ( 'entity' ) ) { return $ this -> redirectToBackendHomepage ( ) ; } $ action = $ request -> query -> get ( 'action' , 'list' ) ; if ( ! $ this -> isActionAllowed ( $ action ) ) { throw new ForbiddenActionException ( [ 'action' => $ action , 'entity_name' => $ this -> entity [ 'name' ] ] ) ; } return $ this -> executeDynamicMethod ( $ action . '<EntityName>Action' ) ; } 
protected function initialize ( Request $ request ) { $ this -> dispatch ( EasyAdminEvents :: PRE_INITIALIZE ) ; $ this -> config = $ this -> get ( 'easyadmin.config.manager' ) -> getBackendConfig ( ) ; if ( 0 === \ count ( $ this -> config [ 'entities' ] ) ) { throw new NoEntitiesConfiguredException ( ) ; } 
protected function autocompleteAction ( ) { $ results = $ this -> get ( 'easyadmin.autocomplete' ) -> find ( $ this -> request -> query -> get ( 'entity' ) , $ this -> request -> query -> get ( 'query' ) , $ this -> request -> query -> get ( 'page' , 1 ) ) ; return new JsonResponse ( $ results ) ; } 
protected function listAction ( ) { $ this -> dispatch ( EasyAdminEvents :: PRE_LIST ) ; $ fields = $ this -> entity [ 'list' ] [ 'fields' ] ; $ paginator = $ this -> findAll ( $ this -> entity [ 'class' ] , $ this -> request -> query -> get ( 'page' , 1 ) , $ this -> entity [ 'list' ] [ 'max_results' ] , $ this -> request -> query -> get ( 'sortField' ) , $ this -> request -> query -> get ( 'sortDirection' ) , $ this -> entity [ 'list' ] [ 'dql_filter' ] ) ; $ this -> dispatch ( EasyAdminEvents :: POST_LIST , [ 'paginator' => $ paginator ] ) ; $ parameters = [ 'paginator' => $ paginator , 'fields' => $ fields , 'batch_form' => $ this -> createBatchForm ( $ this -> entity [ 'name' ] ) -> createView ( ) , 'delete_form_template' => $ this -> createDeleteForm ( $ this -> entity [ 'name' ] , '__id__' ) -> createView ( ) , ] ; return $ this -> executeDynamicMethod ( 'render<EntityName>Template' , [ 'list' , $ this -> entity [ 'templates' ] [ 'list' ] , $ parameters ] ) ; } 
protected function editAction ( ) { $ this -> dispatch ( EasyAdminEvents :: PRE_EDIT ) ; $ id = $ this -> request -> query -> get ( 'id' ) ; $ easyadmin = $ this -> request -> attributes -> get ( 'easyadmin' ) ; $ entity = $ easyadmin [ 'item' ] ; if ( $ this -> request -> isXmlHttpRequest ( ) && $ property = $ this -> request -> query -> get ( 'property' ) ) { $ newValue = 'true' === \ mb_strtolower ( $ this -> request -> query -> get ( 'newValue' ) ) ; $ fieldsMetadata = $ this -> entity [ 'list' ] [ 'fields' ] ; if ( ! isset ( $ fieldsMetadata [ $ property ] ) || 'toggle' !== $ fieldsMetadata [ $ property ] [ 'dataType' ] ) { throw new \ RuntimeException ( \ sprintf ( 'The type of the "%s" property is not "toggle".' , $ property ) ) ; } $ this -> updateEntityProperty ( $ entity , $ property , $ newValue ) ; 
protected function showAction ( ) { $ this -> dispatch ( EasyAdminEvents :: PRE_SHOW ) ; $ id = $ this -> request -> query -> get ( 'id' ) ; $ easyadmin = $ this -> request -> attributes -> get ( 'easyadmin' ) ; $ entity = $ easyadmin [ 'item' ] ; $ fields = $ this -> entity [ 'show' ] [ 'fields' ] ; $ deleteForm = $ this -> createDeleteForm ( $ this -> entity [ 'name' ] , $ id ) ; $ this -> dispatch ( EasyAdminEvents :: POST_SHOW , [ 'deleteForm' => $ deleteForm , 'fields' => $ fields , 'entity' => $ entity , ] ) ; $ parameters = [ 'entity' => $ entity , 'fields' => $ fields , 'delete_form' => $ deleteForm -> createView ( ) , ] ; return $ this -> executeDynamicMethod ( 'render<EntityName>Template' , [ 'show' , $ this -> entity [ 'templates' ] [ 'show' ] , $ parameters ] ) ; } 
protected function newAction ( ) { $ this -> dispatch ( EasyAdminEvents :: PRE_NEW ) ; $ entity = $ this -> executeDynamicMethod ( 'createNew<EntityName>Entity' ) ; $ easyadmin = $ this -> request -> attributes -> get ( 'easyadmin' ) ; $ easyadmin [ 'item' ] = $ entity ; $ this -> request -> attributes -> set ( 'easyadmin' , $ easyadmin ) ; $ fields = $ this -> entity [ 'new' ] [ 'fields' ] ; $ newForm = $ this -> executeDynamicMethod ( 'create<EntityName>NewForm' , [ $ entity , $ fields ] ) ; $ newForm -> handleRequest ( $ this -> request ) ; if ( $ newForm -> isSubmitted ( ) && $ newForm -> isValid ( ) ) { $ this -> dispatch ( EasyAdminEvents :: PRE_PERSIST , [ 'entity' => $ entity ] ) ; $ this -> executeDynamicMethod ( 'persist<EntityName>Entity' , [ $ entity , $ newForm ] ) ; $ this -> dispatch ( EasyAdminEvents :: POST_PERSIST , [ 'entity' => $ entity ] ) ; return $ this -> redirectToReferrer ( ) ; } $ this -> dispatch ( EasyAdminEvents :: POST_NEW , [ 'entity_fields' => $ fields , 'form' => $ newForm , 'entity' => $ entity , ] ) ; $ parameters = [ 'form' => $ newForm -> createView ( ) , 'entity_fields' => $ fields , 'entity' => $ entity , ] ; return $ this -> executeDynamicMethod ( 'render<EntityName>Template' , [ 'new' , $ this -> entity [ 'templates' ] [ 'new' ] , $ parameters ] ) ; } 
protected function deleteAction ( ) { $ this -> dispatch ( EasyAdminEvents :: PRE_DELETE ) ; if ( 'DELETE' !== $ this -> request -> getMethod ( ) ) { return $ this -> redirect ( $ this -> generateUrl ( 'easyadmin' , [ 'action' => 'list' , 'entity' => $ this -> entity [ 'name' ] ] ) ) ; } $ id = $ this -> request -> query -> get ( 'id' ) ; $ form = $ this -> createDeleteForm ( $ this -> entity [ 'name' ] , $ id ) ; $ form -> handleRequest ( $ this -> request ) ; if ( $ form -> isSubmitted ( ) && $ form -> isValid ( ) ) { $ easyadmin = $ this -> request -> attributes -> get ( 'easyadmin' ) ; $ entity = $ easyadmin [ 'item' ] ; $ this -> dispatch ( EasyAdminEvents :: PRE_REMOVE , [ 'entity' => $ entity ] ) ; try { $ this -> executeDynamicMethod ( 'remove<EntityName>Entity' , [ $ entity , $ form ] ) ; } catch ( ForeignKeyConstraintViolationException $ e ) { throw new EntityRemoveException ( [ 'entity_name' => $ this -> entity [ 'name' ] , 'message' => $ e -> getMessage ( ) ] ) ; } $ this -> dispatch ( EasyAdminEvents :: POST_REMOVE , [ 'entity' => $ entity ] ) ; } $ this -> dispatch ( EasyAdminEvents :: POST_DELETE ) ; return $ this -> redirectToReferrer ( ) ; } 
protected function searchAction ( ) { $ this -> dispatch ( EasyAdminEvents :: PRE_SEARCH ) ; $ query = \ trim ( $ this -> request -> query -> get ( 'query' ) ) ; 
protected function batchAction ( ) : RedirectResponse { $ batchForm = $ this -> createBatchForm ( $ this -> entity [ 'name' ] ) ; $ batchForm -> handleRequest ( $ this -> request ) ; if ( $ batchForm -> isSubmitted ( ) && $ batchForm -> isValid ( ) ) { $ actionName = $ batchForm -> get ( 'name' ) -> getData ( ) ; $ actionIds = $ batchForm -> get ( 'ids' ) -> getData ( ) ; $ this -> executeDynamicMethod ( $ actionName . '<EntityName>BatchAction' , [ $ actionIds , $ batchForm ] ) ; } return $ this -> redirectToReferrer ( ) ; } 
protected function updateEntityProperty ( $ entity , $ property , $ value ) { $ entityConfig = $ this -> entity ; if ( ! $ this -> get ( 'easyadmin.property_accessor' ) -> isWritable ( $ entity , $ property ) ) { throw new \ RuntimeException ( \ sprintf ( 'The "%s" property of the "%s" entity is not writable.' , $ property , $ entityConfig [ 'name' ] ) ) ; } $ this -> get ( 'easyadmin.property_accessor' ) -> setValue ( $ entity , $ property , $ value ) ; $ this -> dispatch ( EasyAdminEvents :: PRE_UPDATE , [ 'entity' => $ entity , 'newValue' => $ value ] ) ; $ this -> executeDynamicMethod ( 'update<EntityName>Entity' , [ $ entity ] ) ; $ this -> dispatch ( EasyAdminEvents :: POST_UPDATE , [ 'entity' => $ entity , 'newValue' => $ value ] ) ; $ this -> dispatch ( EasyAdminEvents :: POST_EDIT ) ; } 
protected function findAll ( $ entityClass , $ page = 1 , $ maxPerPage = 15 , $ sortField = null , $ sortDirection = null , $ dqlFilter = null ) { if ( null === $ sortDirection || ! \ in_array ( \ strtoupper ( $ sortDirection ) , [ 'ASC' , 'DESC' ] ) ) { $ sortDirection = 'DESC' ; } $ queryBuilder = $ this -> executeDynamicMethod ( 'create<EntityName>ListQueryBuilder' , [ $ entityClass , $ sortDirection , $ sortField , $ dqlFilter ] ) ; $ this -> dispatch ( EasyAdminEvents :: POST_LIST_QUERY_BUILDER , [ 'query_builder' => $ queryBuilder , 'sort_field' => $ sortField , 'sort_direction' => $ sortDirection , ] ) ; return $ this -> get ( 'easyadmin.paginator' ) -> createOrmPaginator ( $ queryBuilder , $ page , $ maxPerPage ) ; } 
protected function createListQueryBuilder ( $ entityClass , $ sortDirection , $ sortField = null , $ dqlFilter = null ) { return $ this -> get ( 'easyadmin.query_builder' ) -> createListQueryBuilder ( $ this -> entity , $ sortField , $ sortDirection , $ dqlFilter ) ; } 
protected function findBy ( $ entityClass , $ searchQuery , array $ searchableFields , $ page = 1 , $ maxPerPage = 15 , $ sortField = null , $ sortDirection = null , $ dqlFilter = null ) { if ( empty ( $ sortDirection ) || ! \ in_array ( \ strtoupper ( $ sortDirection ) , [ 'ASC' , 'DESC' ] ) ) { $ sortDirection = 'DESC' ; } $ queryBuilder = $ this -> executeDynamicMethod ( 'create<EntityName>SearchQueryBuilder' , [ $ entityClass , $ searchQuery , $ searchableFields , $ sortField , $ sortDirection , $ dqlFilter ] ) ; $ this -> dispatch ( EasyAdminEvents :: POST_SEARCH_QUERY_BUILDER , [ 'query_builder' => $ queryBuilder , 'search_query' => $ searchQuery , 'searchable_fields' => $ searchableFields , ] ) ; return $ this -> get ( 'easyadmin.paginator' ) -> createOrmPaginator ( $ queryBuilder , $ page , $ maxPerPage ) ; } 
protected function createSearchQueryBuilder ( $ entityClass , $ searchQuery , array $ searchableFields , $ sortField = null , $ sortDirection = null , $ dqlFilter = null ) { return $ this -> get ( 'easyadmin.query_builder' ) -> createSearchQueryBuilder ( $ this -> entity , $ searchQuery , $ sortField , $ sortDirection , $ dqlFilter ) ; } 
protected function createEntityFormBuilder ( $ entity , $ view ) { $ formOptions = $ this -> executeDynamicMethod ( 'get<EntityName>EntityFormOptions' , [ $ entity , $ view ] ) ; return $ this -> get ( 'form.factory' ) -> createNamedBuilder ( \ mb_strtolower ( $ this -> entity [ 'name' ] ) , EasyAdminFormType :: class , $ entity , $ formOptions ) ; } 
protected function getEntityFormOptions ( $ entity , $ view ) { $ formOptions = $ this -> entity [ $ view ] [ 'form_options' ] ; $ formOptions [ 'entity' ] = $ this -> entity [ 'name' ] ; $ formOptions [ 'view' ] = $ view ; return $ formOptions ; } 
protected function createEntityForm ( $ entity , array $ entityProperties , $ view ) { if ( \ method_exists ( $ this , $ customMethodName = 'create' . $ this -> entity [ 'name' ] . 'EntityForm' ) ) { $ form = $ this -> { $ customMethodName } ( $ entity , $ entityProperties , $ view ) ; if ( ! $ form instanceof FormInterface ) { throw new \ UnexpectedValueException ( \ sprintf ( 'The "%s" method must return a FormInterface, "%s" given.' , $ customMethodName , \ is_object ( $ form ) ? \ get_class ( $ form ) : \ gettype ( $ form ) ) ) ; } return $ form ; } $ formBuilder = $ this -> executeDynamicMethod ( 'create<EntityName>EntityFormBuilder' , [ $ entity , $ view ] ) ; if ( ! $ formBuilder instanceof FormBuilderInterface ) { throw new \ UnexpectedValueException ( \ sprintf ( 'The "%s" method must return a FormBuilderInterface, "%s" given.' , 'createEntityForm' , \ is_object ( $ formBuilder ) ? \ get_class ( $ formBuilder ) : \ gettype ( $ formBuilder ) ) ) ; } return $ formBuilder -> getForm ( ) ; } 
protected function createDeleteForm ( $ entityName , $ entityId ) { $ formBuilder = $ this -> get ( 'form.factory' ) -> createNamedBuilder ( 'delete_form' ) -> setAction ( $ this -> generateUrl ( 'easyadmin' , [ 'action' => 'delete' , 'entity' => $ entityName , 'id' => $ entityId ] ) ) -> setMethod ( 'DELETE' ) ; $ formBuilder -> add ( 'submit' , SubmitType :: class , [ 'label' => 'delete_modal.action' , 'translation_domain' => 'EasyAdminBundle' ] ) ; 
protected function executeDynamicMethod ( $ methodNamePattern , array $ arguments = [ ] ) { $ methodName = \ str_replace ( '<EntityName>' , $ this -> entity [ 'name' ] , $ methodNamePattern ) ; if ( ! \ is_callable ( [ $ this , $ methodName ] ) ) { $ methodName = \ str_replace ( '<EntityName>' , '' , $ methodNamePattern ) ; } return \ call_user_func_array ( [ $ this , $ methodName ] , $ arguments ) ; } 
protected function redirectToBackendHomepage ( ) { $ homepageConfig = $ this -> config [ 'homepage' ] ; $ url = $ homepageConfig [ 'url' ] ?? $ this -> get ( 'router' ) -> generate ( $ homepageConfig [ 'route' ] , $ homepageConfig [ 'params' ] ) ; return $ this -> redirect ( $ url ) ; } 
public function process ( ContainerBuilder $ container ) { $ configPasses = $ this -> findAndSortTaggedServices ( 'easyadmin.config_pass' , $ container ) ; $ definition = $ container -> getDefinition ( 'easyadmin.config.manager' ) ; foreach ( $ configPasses as $ service ) { $ definition -> addMethodCall ( 'addConfigPass' , [ $ service ] ) ; } } 
public function onKernelController ( FilterControllerEvent $ event ) { $ request = $ event -> getRequest ( ) ; if ( 'easyadmin' !== $ request -> attributes -> get ( '_route' ) ) { return ; } $ currentController = $ event -> getController ( ) ; 
public function buildView ( FormView $ view , FormInterface $ form , array $ options ) { if ( null === $ config = $ this -> configManager -> getEntityConfigByClass ( $ options [ 'class' ] ) ) { throw new \ InvalidArgumentException ( \ sprintf ( 'The configuration of the "%s" entity is not available (this entity is used as the target of the "%s" autocomplete field).' , $ options [ 'class' ] , $ form -> getName ( ) ) ) ; } $ view -> vars [ 'autocomplete_entity_name' ] = $ config [ 'name' ] ; } 
public function mapDataToForms ( $ data , $ forms ) { $ form = \ current ( \ iterator_to_array ( $ forms ) ) ; $ form -> setData ( $ data ) ; } 
public function mapFormsToData ( $ forms , & $ data ) { $ form = \ current ( \ iterator_to_array ( $ forms ) ) ; $ data = $ form -> getData ( ) ; } 
public function generate ( $ entity , $ action , array $ parameters = [ ] ) { if ( \ is_object ( $ entity ) ) { $ config = $ this -> getEntityConfigByClass ( \ get_class ( $ entity ) ) ; 
private function getRealClass ( $ class ) { if ( false === $ pos = \ strrpos ( $ class , '\\' . Proxy :: MARKER . '\\' ) ) { return $ class ; } return \ substr ( $ class , $ pos + Proxy :: MARKER_LENGTH + 2 ) ; } 
public function configure ( $ name , array $ options , array $ metadata , FormConfigInterface $ parentConfig ) { 
public function supports ( $ type , array $ options , array $ metadata ) { $ supportedTypes = [ 'easyadmin_autocomplete' , EasyAdminAutocompleteType :: class , ] ; return \ in_array ( $ type , $ supportedTypes , true ) ; } 
private function processEntityTemplates ( array $ backendConfig ) { 
private function processDefaultTemplates ( array $ backendConfig ) { 
private function processFieldTemplates ( array $ backendConfig ) { foreach ( $ backendConfig [ 'entities' ] as $ entityName => $ entityConfig ) { foreach ( [ 'list' , 'show' ] as $ view ) { foreach ( $ entityConfig [ $ view ] [ 'fields' ] as $ fieldName => $ fieldMetadata ) { if ( null !== $ fieldMetadata [ 'template' ] ) { continue ; } 
private function normalizeMenuConfig ( array $ menuConfig , array $ backendConfig , $ parentItemIndex = - 1 ) { 
public function configure ( $ name , array $ options , array $ metadata , FormConfigInterface $ parentConfig ) { 
public function guessType ( $ class , $ property ) { if ( null !== $ metadataAndName = $ this -> getMetadata ( $ class ) ) { $ metadata = $ metadataAndName [ 0 ] ; switch ( $ metadata -> getTypeOfField ( $ property ) ) { case 'datetime_immutable' : 
public function supports ( $ type , array $ options , array $ metadata ) { $ isCkeditorField = \ in_array ( $ type , [ 'ckeditor' , 'Ivory\\CKEditorBundle\\Form\\Type\\CKEditorType' ] , true ) ; return $ isCkeditorField && ! isset ( $ options [ 'config' ] [ 'toolbar' ] ) && ! isset ( $ options [ 'config_name' ] ) ; } 
public function getFunctions ( ) { return [ new TwigFunction ( 'easyadmin_render_field_for_*_view' , [ $ this , 'renderEntityField' ] , [ 'is_safe' => [ 'html' ] , 'needs_environment' => true ] ) , new TwigFunction ( 'easyadmin_config' , [ $ this , 'getBackendConfiguration' ] ) , new TwigFunction ( 'easyadmin_entity' , [ $ this , 'getEntityConfiguration' ] ) , new TwigFunction ( 'easyadmin_path' , [ $ this , 'getEntityPath' ] ) , new TwigFunction ( 'easyadmin_action_is_enabled' , [ $ this , 'isActionEnabled' ] ) , new TwigFunction ( 'easyadmin_action_is_enabled_for_*_view' , [ $ this , 'isActionEnabled' ] ) , new TwigFunction ( 'easyadmin_get_action' , [ $ this , 'getActionConfiguration' ] ) , new TwigFunction ( 'easyadmin_get_action_for_*_view' , [ $ this , 'getActionConfiguration' ] ) , new TwigFunction ( 'easyadmin_get_actions_for_*_item' , [ $ this , 'getActionsForItem' ] ) , new TwigFunction ( 'easyadmin_logout_path' , [ $ this , 'getLogoutPath' ] ) , new TwigFunction ( 'easyadmin_read_property' , [ $ this , 'readProperty' ] ) , ] ; } 
public function getFilters ( ) { $ filters = [ new TwigFilter ( 'easyadmin_truncate' , [ $ this , 'truncateText' ] , [ 'needs_environment' => true ] ) , new TwigFilter ( 'easyadmin_urldecode' , 'urldecode' ) , ] ; if ( Kernel :: VERSION_ID >= 40200 ) { $ filters [ ] = new TwigFilter ( 'transchoice' , [ $ this , 'transchoice' ] ) ; } return $ filters ; } 
public function getEntityConfiguration ( $ entityName ) { return null !== $ this -> getBackendConfiguration ( 'entities.' . $ entityName ) ? $ this -> configManager -> getEntityConfig ( $ entityName ) : null ; } 
public function getEntityPath ( $ entity , $ action , array $ parameters = [ ] ) { return $ this -> easyAdminRouter -> generate ( $ entity , $ action , $ parameters ) ; } 
public function renderEntityField ( \ Twig_Environment $ twig , $ view , $ entityName , $ item , array $ fieldMetadata ) { $ entityConfiguration = $ this -> configManager -> getEntityConfig ( $ entityName ) ; $ hasCustomTemplate = 0 !== \ strpos ( $ fieldMetadata [ 'template' ] , '@EasyAdmin/' ) ; $ templateParameters = [ ] ; try { $ templateParameters = $ this -> getTemplateParameters ( $ entityName , $ view , $ fieldMetadata , $ item ) ; 
public function isActionEnabled ( $ view , $ action , $ entityName ) { return $ this -> configManager -> isActionEnabled ( $ entityName , $ view , $ action ) ; } 
public function getActionConfiguration ( $ view , $ action , $ entityName ) { return $ this -> configManager -> getActionConfig ( $ entityName , $ view , $ action ) ; } 
public function getActionsForItem ( $ view , $ entityName ) { try { $ entityConfig = $ this -> configManager -> getEntityConfig ( $ entityName ) ; } catch ( \ Exception $ e ) { return [ ] ; } $ disabledActions = $ entityConfig [ 'disabled_actions' ] ; $ viewActions = $ entityConfig [ $ view ] [ 'actions' ] ; $ actionsExcludedForItems = [ 'list' => [ 'new' , 'search' ] , 'edit' => [ ] , 'new' => [ ] , 'show' => [ ] , ] ; $ excludedActions = $ actionsExcludedForItems [ $ view ] ; return \ array_filter ( $ viewActions , function ( $ action ) use ( $ excludedActions , $ disabledActions ) { return ! \ in_array ( $ action [ 'name' ] , $ excludedActions ) && ! \ in_array ( $ action [ 'name' ] , $ disabledActions ) ; } ) ; } 
public function truncateText ( \ Twig_Environment $ env , $ value , $ length = 64 , $ preserve = false , $ separator = '...' ) { try { $ value = ( string ) $ value ; } catch ( \ Exception $ e ) { $ value = '' ; } if ( \ mb_strlen ( $ value , $ env -> getCharset ( ) ) > $ length ) { if ( $ preserve ) { 
public function transchoice ( $ message , $ count , array $ arguments = [ ] , $ domain = null , $ locale = null ) { if ( null === $ this -> translator ) { return strtr ( $ message , $ arguments ) ; } return $ this -> translator -> trans ( $ message , array_merge ( [ '%count%' => $ count ] , $ arguments ) , $ domain , $ locale ) ; } 
public function configure ( $ name , array $ options , array $ metadata , FormConfigInterface $ parentConfig ) { if ( ! isset ( $ options [ 'allow_add' ] ) ) { $ options [ 'allow_add' ] = true ; } if ( ! isset ( $ options [ 'allow_delete' ] ) ) { $ options [ 'allow_delete' ] = true ; } if ( ! isset ( $ options [ 'delete_empty' ] ) ) { $ options [ 'delete_empty' ] = true ; } 
public function createOrmPaginator ( $ queryBuilder , $ page = 1 , $ maxPerPage = self :: MAX_ITEMS ) { $ query = $ queryBuilder -> getQuery ( ) ; if ( 0 === \ count ( $ queryBuilder -> getDQLPart ( 'join' ) ) ) { $ query -> setHint ( CountWalker :: HINT_DISTINCT , false ) ; } 
public function buildForm ( FormBuilderInterface $ builder , array $ options ) : void { $ builder -> add ( 'name' , HiddenType :: class ) ; $ builder -> add ( 'ids' , HiddenType :: class ) ; $ builder -> get ( 'ids' ) -> addModelTransformer ( new CallbackTransformer ( function ( $ value ) { return $ value ; } , function ( $ value ) { return explode ( ',' , $ value ) ; } ) ) ; } 
public function buildView ( FormView $ view , FormInterface $ form , array $ options ) : void { $ entityConfig = $ this -> configManager -> getEntityConfig ( $ options [ 'entity' ] ) ; $ disabledActions = $ entityConfig [ 'disabled_actions' ] ; $ batchActions = $ entityConfig [ 'list' ] [ 'batch_actions' ] ; $ view -> vars [ 'batch_actions' ] = \ array_filter ( $ batchActions , function ( $ batchAction ) use ( $ disabledActions ) { return ! \ in_array ( $ batchAction [ 'name' ] , $ disabledActions , true ) ; } ) ; } 
public function finishView ( FormView $ view , FormInterface $ form , array $ options ) : void { 
private function doProcessConfig ( $ backendConfig ) : array { foreach ( $ this -> configPasses as $ configPass ) { $ backendConfig = $ configPass -> process ( $ backendConfig ) ; } return $ backendConfig ; } 
public function initializeRequest ( GenericEvent $ event ) { $ request = null ; if ( null !== $ this -> requestStack ) { $ request = $ this -> requestStack -> getCurrentRequest ( ) ; } if ( null === $ request ) { return ; } $ request -> attributes -> set ( 'easyadmin' , [ 'entity' => $ entity = $ event -> getArgument ( 'entity' ) , 'view' => $ request -> query -> get ( 'action' , 'list' ) , 'item' => ( $ id = $ request -> query -> get ( 'id' ) ) ? $ this -> findCurrentItem ( $ entity , $ id ) : null , ] ) ; } 
private function findCurrentItem ( array $ entityConfig , $ itemId ) { if ( null === $ manager = $ this -> doctrine -> getManagerForClass ( $ entityConfig [ 'class' ] ) ) { throw new \ RuntimeException ( \ sprintf ( 'There is no Doctrine Entity Manager defined for the "%s" class' , $ entityConfig [ 'class' ] ) ) ; } if ( null === $ entity = $ manager -> getRepository ( $ entityConfig [ 'class' ] ) -> find ( $ itemId ) ) { throw new EntityNotFoundException ( [ 'entity_name' => $ entityConfig [ 'name' ] , 'entity_id_name' => $ entityConfig [ 'primary_key_field_name' ] , 'entity_id_value' => $ itemId ] ) ; } return $ entity ; } 
public static function create ( \ Exception $ exception , $ statusCode = null , array $ headers = [ ] ) { if ( ! $ exception instanceof BaseException ) { throw new \ RuntimeException ( \ sprintf ( 'You should only try to create an instance of "%s" with a "EasyCorp\Bundle\EasyAdminBundle\Exception\BaseException" instance, or subclass. "%s" given.' , __CLASS__ , \ get_class ( $ exception ) ) ) ; } $ e = parent :: create ( $ exception , $ statusCode , $ headers ) ; $ e -> context = $ exception -> getContext ( ) ; return $ e ; } 
public function buildForm ( FormBuilderInterface $ builder , array $ options ) { $ entity = $ options [ 'entity' ] ; $ view = $ options [ 'view' ] ; $ entityConfig = $ this -> configManager -> getEntityConfig ( $ entity ) ; $ entityProperties = $ entityConfig [ $ view ] [ 'fields' ] ?? [ ] ; $ formTabs = [ ] ; $ currentFormTab = null ; $ formGroups = [ ] ; $ currentFormGroup = null ; foreach ( $ entityProperties as $ name => $ metadata ) { $ formFieldOptions = $ metadata [ 'type_options' ] ; 
public function finishView ( FormView $ view , FormInterface $ form , array $ options ) { $ view -> vars [ 'easyadmin_form_tabs' ] = $ form -> getConfig ( ) -> getAttribute ( 'easyadmin_form_tabs' ) ; $ view -> vars [ 'easyadmin_form_groups' ] = $ form -> getConfig ( ) -> getAttribute ( 'easyadmin_form_groups' ) ; } 
public function configureOptions ( OptionsResolver $ resolver ) { $ resolver -> setDefaults ( [ 'allow_extra_fields' => true , 'data_class' => function ( Options $ options , $ dataClass ) { if ( null !== $ dataClass ) { return $ dataClass ; } $ entityConfig = $ this -> configManager -> getEntityConfig ( $ options [ 'entity' ] ) ; return $ entityConfig [ 'class' ] ; } , ] ) -> setRequired ( [ 'entity' , 'view' ] ) -> setNormalizer ( 'attr' , $ this -> getAttributesNormalizer ( ) ) ; } 
private function getAttributesNormalizer ( ) { return function ( Options $ options , $ value ) { return \ array_replace ( [ 'id' => \ sprintf ( '%s-%s-form' , $ options [ 'view' ] , \ mb_strtolower ( $ options [ 'entity' ] ) ) , ] , $ value ) ; } ; } 
protected function duplicateRequest ( \ Exception $ exception , Request $ request ) { $ request = parent :: duplicateRequest ( $ exception , $ request ) ; $ request -> attributes -> set ( 'exception' , FlattenException :: create ( $ exception ) ) ; return $ request ; } 
private function processEntityPropertiesMetadata ( ClassMetadata $ entityMetadata ) { $ entityPropertiesMetadata = [ ] ; if ( $ entityMetadata -> isIdentifierComposite ) { throw new \ RuntimeException ( \ sprintf ( "The '%s' entity isn't valid because it contains a composite primary key." , $ entityMetadata -> name ) ) ; } 
private function normalizeActionsConfig ( array $ backendConfig ) { 
private function normalizeBatchActionsConfig ( array $ backendConfig ) { 
private function doNormalizeDefaultActionsConfig ( array $ actionsConfig , $ view ) { $ defaultActionsConfig = $ this -> getDefaultActionsConfig ( $ view ) ; foreach ( $ actionsConfig as $ actionName => $ actionConfig ) { if ( \ array_key_exists ( $ actionName , $ defaultActionsConfig ) ) { 
private function resolveActionInheritance ( array $ backendConfig ) { foreach ( $ backendConfig [ 'entities' ] as $ entityName => $ entityConfig ) { foreach ( $ this -> views as $ view ) { $ defaultActions = $ this -> getDefaultActions ( $ view ) ; $ backendActions = $ backendConfig [ $ view ] [ 'actions' ] ; $ entityActions = $ entityConfig [ $ view ] [ 'actions' ] ; 
private function resolveBatchActionInheritance ( array $ backendConfig ) { foreach ( $ backendConfig [ 'entities' ] as $ entityName => $ entityConfig ) { $ backendBatchActions = $ backendConfig [ 'list' ] [ 'batch_actions' ] ; $ entityBatchActions = $ entityConfig [ 'list' ] [ 'batch_actions' ] ; 
private function getDefaultActionsConfig ( $ view ) { $ actions = $ this -> doNormalizeActionsConfig ( [ 'delete' => [ 'name' => 'delete' , 'label' => 'action.delete' , 'icon' => 'trash-o' , 'css_class' => 'btn text-danger' ] , 'edit' => [ 'name' => 'edit' , 'label' => 'action.edit' , 'icon' => 'edit' , 'css_class' => 'btn btn-primary' ] , 'new' => [ 'name' => 'new' , 'label' => 'action.new' , 'css_class' => 'btn btn-primary' ] , 'search' => [ 'name' => 'search' , 'label' => 'action.search' ] , 'show' => [ 'name' => 'show' , 'label' => 'action.show' ] , 'list' => [ 'name' => 'list' , 'label' => 'action.list' , 'css_class' => 'btn btn-link pr-0' ] , ] ) ; 
private function getDefaultActions ( $ view ) { $ defaultActions = [ ] ; $ defaultActionsConfig = $ this -> getDefaultActionsConfig ( $ view ) ; 
public function handleViolations ( FormEvent $ event ) { $ formTabs = $ event -> getForm ( ) -> getConfig ( ) -> getAttribute ( 'easyadmin_form_tabs' ) ; $ firstTabWithErrors = null ; foreach ( $ event -> getForm ( ) as $ child ) { $ errors = $ child -> getErrors ( true ) ; if ( \ count ( $ errors ) > 0 ) { $ formTab = $ child -> getConfig ( ) -> getAttribute ( 'easyadmin_form_tab' ) ; $ formTabs [ $ formTab ] [ 'errors' ] += \ count ( $ errors ) ; if ( null === $ firstTabWithErrors ) { $ firstTabWithErrors = $ formTab ; } } } 
public function collect ( Request $ request , Response $ response , \ Exception $ exception = null ) { if ( 'easyadmin' !== $ request -> attributes -> get ( '_route' ) ) { return ; } $ backendConfig = $ this -> configManager -> getBackendConfig ( ) ; $ entityName = $ request -> query -> get ( 'entity' ) ; $ currentEntityConfig = \ array_key_exists ( $ entityName , $ backendConfig [ 'entities' ] ) ? $ backendConfig [ 'entities' ] [ $ entityName ] : [ ] ; $ this -> data = [ 'num_entities' => \ count ( $ backendConfig [ 'entities' ] ) , 'request_parameters' => $ this -> getEasyAdminParameters ( $ request ) , 'current_entity_configuration' => $ currentEntityConfig , 'backend_configuration' => $ backendConfig , ] ; } 
private function getEasyAdminParameters ( Request $ request ) { return [ 'action' => $ request -> query -> get ( 'action' ) , 'entity' => $ request -> query -> get ( 'entity' ) , 'id' => $ request -> query -> get ( 'id' ) , 'sort_field' => $ request -> query -> get ( 'sortField' ) , 'sort_direction' => $ request -> query -> get ( 'sortDirection' ) , ] ; } 
public function dump ( $ variable ) { if ( \ class_exists ( HtmlDumper :: class ) ) { $ cloner = new VarCloner ( ) ; $ dumper = new HtmlDumper ( ) ; $ dumper -> dump ( $ cloner -> cloneVar ( $ variable ) , $ output = \ fopen ( 'php://memory' , 'r+b' ) ) ; if ( false !== $ dumpedData = \ stream_get_contents ( $ output , - 1 , 0 ) ) { return $ dumpedData ; } } if ( \ class_exists ( Yaml :: class ) ) { return \ sprintf ( '<pre class="sf-dump">%s</pre>' , Yaml :: dump ( ( array ) $ variable , 1024 ) ) ; } return \ sprintf ( '<pre class="sf-dump">%s</pre>' , \ var_export ( $ variable , true ) ) ; } 
public function find ( $ entity , $ query , $ page = 1 ) { if ( empty ( $ entity ) || empty ( $ query ) ) { return [ 'results' => [ ] ] ; } $ backendConfig = $ this -> configManager -> getBackendConfig ( ) ; if ( ! isset ( $ backendConfig [ 'entities' ] [ $ entity ] ) ) { throw new \ InvalidArgumentException ( \ sprintf ( 'The "entity" argument must contain the name of an entity managed by EasyAdmin ("%s" given).' , $ entity ) ) ; } $ paginator = $ this -> finder -> findByAllProperties ( $ backendConfig [ 'entities' ] [ $ entity ] , $ query , $ page , $ backendConfig [ 'show' ] [ 'max_results' ] ) ; return [ 'results' => $ this -> processResults ( $ paginator -> getCurrentPageResults ( ) , $ backendConfig [ 'entities' ] [ $ entity ] ) , 'has_next_page' => $ paginator -> hasNextPage ( ) , ] ; } 
public function load ( array $ configs , ContainerBuilder $ container ) { 
private function processConfigFiles ( array $ configs ) { $ existingEntityNames = [ ] ; foreach ( $ configs as $ i => $ config ) { if ( \ array_key_exists ( 'entities' , $ config ) ) { $ processedConfig = [ ] ; foreach ( $ config [ 'entities' ] as $ key => $ value ) { $ entityConfig = $ this -> normalizeEntityConfig ( $ key , $ value ) ; $ entityName = $ this -> getUniqueEntityName ( $ key , $ entityConfig , $ existingEntityNames ) ; $ entityConfig [ 'name' ] = $ entityName ; $ processedConfig [ $ entityName ] = $ entityConfig ; $ existingEntityNames [ ] = $ entityName ; } $ config [ 'entities' ] = $ processedConfig ; } $ configs [ $ i ] = $ config ; } return $ configs ; } 
private function normalizeEntityConfig ( $ entityName , $ entityConfig ) { 
private function getUniqueEntityName ( $ entityName , array $ entityConfig , array $ existingEntityNames ) { 
private function normalizeEntityConfig ( array $ backendConfig ) { foreach ( $ backendConfig [ 'entities' ] as $ entityName => $ entityConfig ) { if ( ! isset ( $ entityConfig [ 'label' ] ) ) { $ backendConfig [ 'entities' ] [ $ entityName ] [ 'label' ] = $ entityName ; } } return $ backendConfig ; } 
private function normalizeFormConfig ( array $ backendConfig ) { foreach ( $ backendConfig [ 'entities' ] as $ entityName => $ entityConfig ) { if ( isset ( $ entityConfig [ 'form' ] ) ) { $ entityConfig [ 'new' ] = isset ( $ entityConfig [ 'new' ] ) ? $ this -> mergeFormConfig ( $ entityConfig [ 'form' ] , $ entityConfig [ 'new' ] ) : $ entityConfig [ 'form' ] ; $ entityConfig [ 'edit' ] = isset ( $ entityConfig [ 'edit' ] ) ? $ this -> mergeFormConfig ( $ entityConfig [ 'form' ] , $ entityConfig [ 'edit' ] ) : $ entityConfig [ 'form' ] ; } $ backendConfig [ 'entities' ] [ $ entityName ] = $ entityConfig ; } return $ backendConfig ; } 
private function normalizeViewConfig ( array $ backendConfig ) { foreach ( $ backendConfig [ 'entities' ] as $ entityName => $ entityConfig ) { 
private function normalizePropertyConfig ( array $ backendConfig ) { foreach ( $ backendConfig [ 'entities' ] as $ entityName => $ entityConfig ) { $ designElementIndex = 0 ; foreach ( [ 'form' , 'edit' , 'list' , 'new' , 'search' , 'show' ] as $ view ) { $ fields = [ ] ; foreach ( $ entityConfig [ $ view ] [ 'fields' ] as $ i => $ field ) { if ( ! \ is_string ( $ field ) && ! \ is_array ( $ field ) ) { throw new \ RuntimeException ( \ sprintf ( 'The values of the "fields" option for the "%s" view of the "%s" entity can only be strings or arrays.' , $ view , $ entityConfig [ 'class' ] ) ) ; } if ( \ is_string ( $ field ) ) { 
private function normalizeFormDesignConfig ( array $ backendConfig ) { 
private function normalizeControllerConfig ( array $ backendConfig ) { foreach ( $ backendConfig [ 'entities' ] as $ entityName => $ entityConfig ) { if ( isset ( $ entityConfig [ 'controller' ] ) ) { $ controller = \ trim ( $ entityConfig [ 'controller' ] ) ; if ( ! $ this -> container -> has ( $ controller ) && ! \ class_exists ( $ controller ) ) { throw new \ InvalidArgumentException ( \ sprintf ( 'The "%s" value defined in the "controller" option of the "%s" entity is not a valid controller. For a regular controller, set its FQCN as the value; for a controller defined as service, set its service name as the value.' , $ controller , $ entityName ) ) ; } $ backendConfig [ 'entities' ] [ $ entityName ] [ 'controller' ] = $ controller ; } } return $ backendConfig ; } 
private function mergeFormConfig ( array $ parentConfig , array $ childConfig ) { 
private function getRemovedFieldNames ( array $ fieldsConfig ) { $ removedFieldNames = [ ] ; foreach ( $ fieldsConfig as $ fieldConfig ) { if ( isset ( $ fieldConfig [ 'property' ] ) && 0 === \ strpos ( $ fieldConfig [ 'property' ] , '-' ) ) { $ removedFieldNames [ ] = \ mb_substr ( $ fieldConfig [ 'property' ] , 1 ) ; } } return $ removedFieldNames ; } 
public function createListQueryBuilder ( array $ entityConfig , $ sortField = null , $ sortDirection = null , $ dqlFilter = null ) { $ em = $ this -> doctrine -> getManagerForClass ( $ entityConfig [ 'class' ] ) ; $ classMetadata = $ em -> getClassMetadata ( $ entityConfig [ 'class' ] ) ; $ queryBuilder = $ em -> createQueryBuilder ( ) -> select ( 'entity' ) -> from ( $ entityConfig [ 'class' ] , 'entity' ) ; $ isSortedByDoctrineAssociation = $ this -> isDoctrineAssociation ( $ classMetadata , $ sortField ) ; if ( $ isSortedByDoctrineAssociation ) { $ sortFieldParts = \ explode ( '.' , $ sortField ) ; $ queryBuilder -> leftJoin ( 'entity.' . $ sortFieldParts [ 0 ] , $ sortFieldParts [ 0 ] ) ; } if ( ! empty ( $ dqlFilter ) ) { $ queryBuilder -> andWhere ( $ dqlFilter ) ; } if ( null !== $ sortField ) { $ queryBuilder -> orderBy ( \ sprintf ( '%s%s' , $ isSortedByDoctrineAssociation ? '' : 'entity.' , $ sortField ) , $ sortDirection ) ; } return $ queryBuilder ; } 
public function createSearchQueryBuilder ( array $ entityConfig , $ searchQuery , $ sortField = null , $ sortDirection = null , $ dqlFilter = null ) { $ em = $ this -> doctrine -> getManagerForClass ( $ entityConfig [ 'class' ] ) ; $ classMetadata = $ em -> getClassMetadata ( $ entityConfig [ 'class' ] ) ; $ queryBuilder = $ em -> createQueryBuilder ( ) -> select ( 'entity' ) -> from ( $ entityConfig [ 'class' ] , 'entity' ) ; $ isSearchQueryNumeric = \ is_numeric ( $ searchQuery ) ; $ isSearchQuerySmallInteger = \ ctype_digit ( $ searchQuery ) && $ searchQuery >= - 32768 && $ searchQuery <= 32767 ; $ isSearchQueryInteger = \ ctype_digit ( $ searchQuery ) && $ searchQuery >= - 2147483648 && $ searchQuery <= 2147483647 ; $ isSearchQueryUuid = 1 === \ preg_match ( '/^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i' , $ searchQuery ) ; $ lowerSearchQuery = \ mb_strtolower ( $ searchQuery ) ; $ queryParameters = [ ] ; $ entitiesAlreadyJoined = [ ] ; foreach ( $ entityConfig [ 'search' ] [ 'fields' ] as $ fieldName => $ metadata ) { $ entityName = 'entity' ; if ( $ this -> isDoctrineAssociation ( $ classMetadata , $ fieldName ) ) { 
protected function isDoctrineAssociation ( ClassMetadata $ classMetadata , $ fieldName ) { if ( null === $ fieldName ) { return false ; } $ fieldNameParts = \ explode ( '.' , $ fieldName ) ; return false !== \ strpos ( $ fieldName , '.' ) && ! \ array_key_exists ( $ fieldNameParts [ 0 ] , $ classMetadata -> embeddedClasses ) ; } 
private function processDefaultFieldsConfig ( array $ backendConfig ) { foreach ( $ backendConfig [ 'entities' ] as $ entityName => $ entityConfig ) { foreach ( [ 'edit' , 'list' , 'new' , 'search' , 'show' ] as $ view ) { if ( 0 === \ count ( $ entityConfig [ $ view ] [ 'fields' ] ) ) { $ fieldsConfig = $ this -> filterFieldList ( $ entityConfig [ 'properties' ] , $ this -> getExcludedFieldNames ( $ view , $ entityConfig ) , $ this -> getExcludedFieldTypes ( $ view ) , $ this -> getMaxNumberFields ( $ view ) ) ; foreach ( $ fieldsConfig as $ fieldName => $ fieldConfig ) { if ( null === $ fieldsConfig [ $ fieldName ] [ 'format' ] ) { $ fieldsConfig [ $ fieldName ] [ 'format' ] = $ this -> getFieldFormat ( $ fieldConfig [ 'type' ] , $ backendConfig ) ; } } $ backendConfig [ 'entities' ] [ $ entityName ] [ $ view ] [ 'fields' ] = $ fieldsConfig ; } } } return $ backendConfig ; } 
private function processFieldConfig ( array $ backendConfig ) { foreach ( $ backendConfig [ 'entities' ] as $ entityName => $ entityConfig ) { foreach ( [ 'edit' , 'list' , 'new' , 'search' , 'show' ] as $ view ) { foreach ( $ entityConfig [ $ view ] [ 'fields' ] as $ fieldName => $ fieldConfig ) { if ( ! isset ( $ fieldConfig [ 'label' ] ) && 'id' === $ fieldConfig [ 'property' ] ) { 
private function processPageTitleConfig ( array $ backendConfig ) { foreach ( $ backendConfig [ 'entities' ] as $ entityName => $ entityConfig ) { foreach ( [ 'edit' , 'list' , 'new' , 'search' , 'show' ] as $ view ) { if ( ! isset ( $ entityConfig [ $ view ] [ 'title' ] ) && isset ( $ backendConfig [ $ view ] [ 'title' ] ) ) { $ backendConfig [ 'entities' ] [ $ entityName ] [ $ view ] [ 'title' ] = $ backendConfig [ $ view ] [ 'title' ] ; } } } return $ backendConfig ; } 
private function processMaxResultsConfig ( array $ backendConfig ) { foreach ( $ backendConfig [ 'entities' ] as $ entityName => $ entityConfig ) { foreach ( [ 'list' , 'search' , 'show' ] as $ view ) { if ( ! isset ( $ entityConfig [ $ view ] [ 'max_results' ] ) && isset ( $ backendConfig [ $ view ] [ 'max_results' ] ) ) { $ backendConfig [ 'entities' ] [ $ entityName ] [ $ view ] [ 'max_results' ] = $ backendConfig [ $ view ] [ 'max_results' ] ; } } } return $ backendConfig ; } 
private function processSortingConfig ( array $ backendConfig ) { foreach ( $ backendConfig [ 'entities' ] as $ entityName => $ entityConfig ) { foreach ( [ 'list' , 'search' ] as $ view ) { if ( ! isset ( $ entityConfig [ $ view ] [ 'sort' ] ) ) { continue ; } $ sortConfig = $ entityConfig [ $ view ] [ 'sort' ] ; if ( ! \ is_string ( $ sortConfig ) && ! \ is_array ( $ sortConfig ) ) { throw new \ InvalidArgumentException ( \ sprintf ( 'The "sort" option of the "%s" view of the "%s" entity contains an invalid value (it can only be a string or an array).' , $ view , $ entityName ) ) ; } if ( \ is_string ( $ sortConfig ) ) { $ sortConfig = [ 'field' => $ sortConfig , 'direction' => 'DESC' ] ; } else { $ sortConfig = [ 'field' => $ sortConfig [ 0 ] , 'direction' => \ strtoupper ( $ sortConfig [ 1 ] ) ] ; } if ( ! \ in_array ( $ sortConfig [ 'direction' ] , [ 'ASC' , 'DESC' ] ) ) { throw new \ InvalidArgumentException ( \ sprintf ( 'If defined, the second value of the "sort" option of the "%s" view of the "%s" entity can only be "ASC" or "DESC".' , $ view , $ entityName ) ) ; } $ isSortedByDoctrineAssociation = false !== \ strpos ( $ sortConfig [ 'field' ] , '.' ) ; if ( ! $ isSortedByDoctrineAssociation && ( isset ( $ entityConfig [ $ view ] [ 'fields' ] [ $ sortConfig [ 'field' ] ] ) && true === $ entityConfig [ $ view ] [ 'fields' ] [ $ sortConfig [ 'field' ] ] [ 'virtual' ] ) ) { throw new \ InvalidArgumentException ( \ sprintf ( 'The "%s" field cannot be used in the "sort" option of the "%s" view of the "%s" entity because it\'s a virtual property that is not persisted in the database.' , $ sortConfig [ 'field' ] , $ view , $ entityName ) ) ; } // sort can be defined using simple properties (sort: author) or association properties (sort: author.name) if ( \ substr_count ( $ sortConfig [ 'field' ] , '.' ) > 1 ) { throw new \ InvalidArgumentException ( \ sprintf ( 'The "%s" value cannot be used as the "sort" option in the "%s" view of the "%s" entity because it defines multiple sorting levels (e.g. "aaa.bbb.ccc") but only up to one level is supported (e.g. "aaa.bbb").' , $ sortConfig [ 'field' ] , $ view , $ entityName ) ) ; } // sort field can be a Doctrine association (sort: author.name) instead of a simple property $ sortFieldParts = \ explode ( '.' , $ sortConfig [ 'field' ] ) ; $ sortFieldProperty = $ sortFieldParts [ 0 ] ; if ( ! \ array_key_exists ( $ sortFieldProperty , $ entityConfig [ 'properties' ] ) && ! isset ( $ entityConfig [ $ view ] [ 'fields' ] [ $ sortFieldProperty ] ) ) { throw new \ InvalidArgumentException ( \ sprintf ( 'The "%s" field used in the "sort" option of the "%s" view of the "%s" entity does not exist neither as a property of that entity nor as a virtual field of that view.' , $ sortFieldProperty , $ view , $ entityName ) ) ; } $ backendConfig [ 'entities' ] [ $ entityName ] [ $ view ] [ 'sort' ] = $ sortConfig ; } } return $ backendConfig ; } 
private function getExcludedFieldNames ( $ view , array $ entityConfig ) { $ excludedFieldNames = [ 'edit' => [ $ entityConfig [ 'primary_key_field_name' ] ] , 'list' => [ 'password' , 'salt' , 'slug' , 'updatedAt' , 'uuid' ] , 'new' => [ $ entityConfig [ 'primary_key_field_name' ] ] , 'search' => [ 'password' , 'salt' ] , 'show' => [ ] , ] ; return isset ( $ excludedFieldNames [ $ view ] ) ? $ excludedFieldNames [ $ view ] : [ ] ; } 
private function filterFieldList ( array $ fields , array $ excludedFieldNames , array $ excludedFieldTypes , $ maxNumFields ) { $ filteredFields = [ ] ; foreach ( $ fields as $ name => $ metadata ) { if ( ! \ in_array ( $ name , $ excludedFieldNames ) && ! \ in_array ( $ metadata [ 'type' ] , $ excludedFieldTypes ) ) { $ filteredFields [ $ name ] = $ fields [ $ name ] ; } } if ( \ count ( $ filteredFields ) > $ maxNumFields ) { $ filteredFields = \ array_slice ( $ filteredFields , 0 , $ maxNumFields , true ) ; } return $ filteredFields ; } 
public function run ( array $ argv ) { $ command = count ( $ argv ) >= 2 ? $ argv [ 1 ] : false ; $ this -> settingConfig ( $ argv ) ; $ this -> commandHandler ( $ command ) ; } 
protected function settingConfig ( array $ argv ) { 
protected function commandHandler ( string $ command ) { $ serverCommand = new ServerCommand ( ) ; if ( '-h' == $ command || '--help' == $ command ) { echo $ serverCommand -> desc , PHP_EOL ; return ; } if ( '-v' == $ command || '--version' == $ command ) { echo $ serverCommand -> logo , PHP_EOL ; return ; } if ( ! $ command || ! method_exists ( $ serverCommand , $ command ) ) { echo $ serverCommand -> usage , PHP_EOL ; return ; } PhpHelper :: call ( [ $ serverCommand , $ command ] ) ; } 
public static function setProcessTitle ( string $ title ) : bool { if ( PhpHelper :: isMac ( ) ) { return false ; } if ( \ function_exists ( 'cli_set_process_title' ) ) { return @ cli_set_process_title ( $ title ) ; } return true ; } 
public static function run ( string $ command , string $ cwd = null ) : array { $ descriptors = [ 0 => [ 'pipe' , 'r' ] , 
private static function tCheck ( string $ stmt , int $ offset ) { if ( strlen ( $ stmt ) > $ offset + 7 ) { $ c1 = $ stmt [ ++ $ offset ] ; $ c2 = $ stmt [ ++ $ offset ] ; $ c3 = $ stmt [ ++ $ offset ] ; $ c4 = $ stmt [ ++ $ offset ] ; $ c5 = $ stmt [ ++ $ offset ] ; $ c6 = $ stmt [ ++ $ offset ] ; $ c7 = $ stmt [ ++ $ offset ] ; $ c8 = $ stmt [ ++ $ offset ] ; if ( ( $ c1 == 'R' || $ c1 == 'r' ) && ( $ c2 == 'U' || $ c2 == 'u' ) && ( $ c3 == 'N' || $ c3 == 'n' ) && ( $ c4 == 'C' || $ c4 == 'c' ) && ( $ c5 == 'A' || $ c5 == 'a' ) && ( $ c6 == 'T' || $ c6 == 't' ) && ( $ c7 == 'E' || $ c7 == 'e' ) && ( $ c8 == ' ' || $ c8 == '\t' || $ c8 == '\r' || $ c8 == '\n' ) ) { return self :: DDL ; } } return self :: OTHER ; } 
private static function aCheck ( string $ stmt , int $ offset ) { if ( strlen ( $ stmt ) > $ offset + 4 ) { $ c1 = $ stmt [ ++ $ offset ] ; $ c2 = $ stmt [ ++ $ offset ] ; $ c3 = $ stmt [ ++ $ offset ] ; $ c4 = $ stmt [ ++ $ offset ] ; $ c5 = $ stmt [ ++ $ offset ] ; if ( ( $ c1 == 'L' || $ c1 == 'l' ) && ( $ c2 == 'T' || $ c2 == 't' ) && ( $ c3 == 'E' || $ c3 == 'e' ) && ( $ c4 == 'R' || $ c4 == 'r' ) && ( $ c5 == ' ' || $ c5 == '\t' || $ c5 == '\r' || $ c5 == '\n' ) ) { return self :: DDL ; } } return self :: OTHER ; } 
public static function deleteOrdCheck ( string $ stmt , int $ offset ) { $ sqlType = self :: OTHER ; switch ( $ stmt [ $ offset + 1 ] ) { case 'E' : case 'e' : $ sqlType = self :: dCheck ( $ stmt , $ offset ) ; break ; case 'R' : case 'r' : $ sqlType = self :: dropCheck ( $ stmt , $ offset ) ; break ; default : $ sqlType = self :: OTHER ; } return $ sqlType ; } 
public static function helpCheck ( string $ stmt , int $ offset ) { if ( strlen ( $ stmt ) > $ offset + 3 ) { $ c1 = $ stmt [ ++ $ offset ] ; $ c2 = $ stmt [ ++ $ offset ] ; $ c3 = $ stmt [ ++ $ offset ] ; if ( ( $ c1 == 'E' || $ c1 == 'e' ) && ( $ c2 == 'L' || $ c2 == 'l' ) && ( $ c3 == 'P' || $ c3 == 'p' ) ) { return ( $ offset << 8 ) | self :: HELP ; } } return self :: OTHER ; } 
public static function explainCheck ( string $ stmt , int $ offset ) { if ( strlen ( $ stmt ) > $ offset + 6 ) { $ c1 = $ stmt [ ++ $ offset ] ; $ c2 = $ stmt [ ++ $ offset ] ; $ c3 = $ stmt [ ++ $ offset ] ; $ c4 = $ stmt [ ++ $ offset ] ; $ c5 = $ stmt [ ++ $ offset ] ; $ c6 = $ stmt [ ++ $ offset ] ; $ c7 = $ stmt [ ++ $ offset ] ; if ( ( $ c1 == 'X' || $ c1 == 'x' ) && ( $ c2 == 'P' || $ c2 == 'p' ) && ( $ c3 == 'L' || $ c3 == 'l' ) && ( $ c4 == 'A' || $ c4 == 'a' ) && ( $ c5 == 'I' || $ c5 == 'i' ) && ( $ c6 == 'N' || $ c6 == 'n' ) && ( $ c7 == ' ' || $ c7 == '\t' || $ c7 == '\r' || $ c7 == '\n' ) ) { return ( $ offset << 8 ) | self :: EXPLAIN ; } } if ( $ stmt != null && startsWith ( strtolower ( $ stmt ) , "explain2" ) ) { return ( $ offset << 8 ) | self :: EXPLAIN2 ; } return self :: OTHER ; } 
public static function killCheck ( string $ stmt , int $ offset ) { if ( strlen ( $ stmt ) > $ offset + 3 ) { $ c1 = $ stmt [ ++ $ offset ] ; $ c2 = $ stmt [ ++ $ offset ] ; $ c3 = $ stmt [ ++ $ offset ] ; $ c4 = $ stmt [ ++ $ offset ] ; if ( ( $ c1 == 'I' || $ c1 == 'i' ) && ( $ c2 == 'L' || $ c2 == 'l' ) && ( $ c3 == 'L' || $ c3 == 'l' ) && ( $ c4 == ' ' || $ c4 == '\t' || $ c4 == '\r' || $ c4 == '\n' ) ) { while ( strlen ( $ stmt ) > ++ $ offset ) { switch ( $ stmt [ $ offset ] ) { case ' ' : case '\t' : case '\r' : case '\n' : continue 2 ; case 'Q' : case 'q' : return self :: killQueryCheck ( $ stmt , $ offset ) ; default : return ( $ offset << 8 ) | self :: KILL ; } } return self :: OTHER ; } } return self :: OTHER ; } 
public static function killQueryCheck ( string $ stmt , int $ offset ) { if ( strlen ( $ stmt ) > $ offset + 4 ) { $ c1 = $ stmt [ ++ $ offset ] ; $ c2 = $ stmt [ ++ $ offset ] ; $ c3 = $ stmt [ ++ $ offset ] ; $ c4 = $ stmt [ ++ $ offset ] ; $ c5 = $ stmt [ ++ $ offset ] ; if ( ( $ c1 == 'U' || $ c1 == 'u' ) && ( $ c2 == 'E' || $ c2 == 'e' ) && ( $ c3 == 'R' || $ c3 == 'r' ) && ( $ c4 == 'Y' || $ c4 == 'y' ) && ( $ c5 == ' ' || $ c5 == '\t' || $ c5 == '\r' || $ c5 == '\n' ) ) { while ( strlen ( $ stmt ) > ++ $ offset ) { switch ( $ stmt [ $ offset ] ) { case ' ' : case '\t' : case '\r' : case '\n' : continue 2 ; default : return ( $ offset << 8 ) | self :: KILL_QUERY ; } } return self :: OTHER ; } } return self :: OTHER ; } 
public static function beginCheck ( string $ stmt , int $ offset ) { if ( strlen ( $ stmt ) > $ offset + 4 ) { $ c1 = $ stmt [ ++ $ offset ] ; $ c2 = $ stmt [ ++ $ offset ] ; $ c3 = $ stmt [ ++ $ offset ] ; $ c4 = $ stmt [ ++ $ offset ] ; if ( ( $ c1 == 'E' || $ c1 == 'e' ) && ( $ c2 == 'G' || $ c2 == 'g' ) && ( $ c3 == 'I' || $ c3 == 'i' ) && ( $ c4 == 'N' || $ c4 == 'n' ) && ( strlen ( $ stmt ) == ++ $ offset || ParseUtil :: isEOF ( $ stmt [ $ offset ] ) ) ) { return self :: BEGIN ; } } return self :: OTHER ; } 
public static function commitCheck ( string $ stmt , int $ offset ) { if ( strlen ( $ stmt ) > $ offset + 5 ) { $ c1 = $ stmt [ ++ $ offset ] ; $ c2 = $ stmt [ ++ $ offset ] ; $ c3 = $ stmt [ ++ $ offset ] ; $ c4 = $ stmt [ ++ $ offset ] ; $ c5 = $ stmt [ ++ $ offset ] ; if ( ( $ c1 == 'O' || $ c1 == 'o' ) && ( $ c2 == 'M' || $ c2 == 'm' ) && ( $ c3 == 'M' || $ c3 == 'm' ) && ( $ c4 == 'I' || $ c4 == 'i' ) && ( $ c5 == 'T' || $ c5 == 't' ) && ( strlen ( $ stmt ) == ++ $ offset || ParseUtil :: isEOF ( $ stmt [ $ offset ] ) ) ) { return self :: COMMIT ; } } return self :: OTHER ; } 
public static function callCheck ( string $ stmt , int $ offset ) { if ( strlen ( $ stmt ) > $ offset + 3 ) { $ c1 = $ stmt [ ++ $ offset ] ; $ c2 = $ stmt [ ++ $ offset ] ; $ c3 = $ stmt [ ++ $ offset ] ; if ( ( $ c1 == 'A' || $ c1 == 'a' ) && ( $ c2 == 'L' || $ c2 == 'l' ) && ( $ c3 == 'L' || $ c3 == 'l' ) ) { return self :: CALL ; } } return self :: OTHER ; } 
public static function dCheck ( string $ stmt , int $ offset ) { if ( strlen ( $ stmt ) > $ offset + 4 ) { $ res = self :: describeCheck ( $ stmt , $ offset ) ; if ( $ res == self :: DESCRIBE ) { return $ res ; } } 
public static function describeCheck ( string $ stmt , int $ offset ) { 
public static function insertCheck ( string $ stmt , int $ offset ) { if ( strlen ( $ stmt ) > $ offset + 6 ) { $ c1 = $ stmt [ ++ $ offset ] ; $ c2 = $ stmt [ ++ $ offset ] ; $ c3 = $ stmt [ ++ $ offset ] ; $ c4 = $ stmt [ ++ $ offset ] ; $ c5 = $ stmt [ ++ $ offset ] ; $ c6 = $ stmt [ ++ $ offset ] ; if ( ( $ c1 == 'N' || $ c1 == 'n' ) && ( $ c2 == 'S' || $ c2 == 's' ) && ( $ c3 == 'E' || $ c3 == 'e' ) && ( $ c4 == 'R' || $ c4 == 'r' ) && ( $ c5 == 'T' || $ c5 == 't' ) && ( $ c6 == ' ' || $ c6 == '\t' || $ c6 == '\r' || $ c6 == '\n' ) ) { return self :: INSERT ; } } return self :: OTHER ; } 
public static function replaceCheck ( string $ stmt , int $ offset ) { if ( strlen ( $ stmt ) > $ offset + 6 ) { $ c1 = $ stmt [ ++ $ offset ] ; $ c2 = $ stmt [ ++ $ offset ] ; $ c3 = $ stmt [ ++ $ offset ] ; $ c4 = $ stmt [ ++ $ offset ] ; $ c5 = $ stmt [ ++ $ offset ] ; $ c6 = $ stmt [ ++ $ offset ] ; if ( ( $ c1 == 'P' || $ c1 == 'p' ) && ( $ c2 == 'L' || $ c2 == 'l' ) && ( $ c3 == 'A' || $ c3 == 'a' ) && ( $ c4 == 'C' || $ c4 == 'c' ) && ( $ c5 == 'E' || $ c5 == 'e' ) && ( $ c6 == ' ' || $ c6 == '\t' || $ c6 == '\r' || $ c6 == '\n' ) ) { return self :: REPLACE ; } } return self :: OTHER ; } 
public static function rollabckCheck ( string $ stmt , int $ offset ) { if ( strlen ( $ stmt ) > $ offset + 6 ) { $ c1 = $ stmt [ ++ $ offset ] ; $ c2 = $ stmt [ ++ $ offset ] ; $ c3 = $ stmt [ ++ $ offset ] ; $ c4 = $ stmt [ ++ $ offset ] ; $ c5 = $ stmt [ ++ $ offset ] ; $ c6 = $ stmt [ ++ $ offset ] ; if ( ( $ c1 == 'L' || $ c1 == 'l' ) && ( $ c2 == 'L' || $ c2 == 'l' ) && ( $ c3 == 'B' || $ c3 == 'b' ) && ( $ c4 == 'A' || $ c4 == 'a' ) && ( $ c5 == 'C' || $ c5 == 'c' ) && ( $ c6 == 'K' || $ c6 == 'k' ) && ( strlen ( $ stmt ) == ++ $ offset || ParseUtil :: isEOF ( $ stmt [ $ offset ] ) ) ) { return self :: ROLLBACK ; } } return self :: OTHER ; } 
public static function savepointCheck ( string $ stmt , int $ offset ) { if ( strlen ( $ stmt ) > $ offset + 8 ) { $ c1 = $ stmt [ ++ $ offset ] ; $ c2 = $ stmt [ ++ $ offset ] ; $ c3 = $ stmt [ ++ $ offset ] ; $ c4 = $ stmt [ ++ $ offset ] ; $ c5 = $ stmt [ ++ $ offset ] ; $ c6 = $ stmt [ ++ $ offset ] ; $ c7 = $ stmt [ ++ $ offset ] ; $ c8 = $ stmt [ ++ $ offset ] ; if ( ( $ c1 == 'V' || $ c1 == 'v' ) && ( $ c2 == 'E' || $ c2 == 'e' ) && ( $ c3 == 'P' || $ c3 == 'p' ) && ( $ c4 == 'O' || $ c4 == 'o' ) && ( $ c5 == 'I' || $ c5 == 'i' ) && ( $ c6 == 'N' || $ c6 == 'n' ) && ( $ c7 == 'T' || $ c7 == 't' ) && ( $ c8 == ' ' || $ c8 == '\t' || $ c8 == '\r' || $ c8 == '\n' ) ) { return self :: SAVEPOINT ; } } return self :: OTHER ; } 
public static function selectCheck ( string $ stmt , int $ offset ) { if ( strlen ( $ stmt ) > $ offset + 4 ) { $ c1 = $ stmt [ ++ $ offset ] ; $ c2 = $ stmt [ ++ $ offset ] ; $ c3 = $ stmt [ ++ $ offset ] ; $ c4 = $ stmt [ ++ $ offset ] ; if ( ( $ c1 == 'E' || $ c1 == 'e' ) && ( $ c2 == 'C' || $ c2 == 'c' ) && ( $ c3 == 'T' || $ c3 == 't' ) && ( $ c4 == ' ' || $ c4 == '\t' || $ c4 == '\r' || $ c4 == '\n' || $ c4 == '/' || $ c4 == '#' ) ) { return ( $ offset << 8 ) | self :: SELECT ; } } return self :: OTHER ; } 
public static function showCheck ( string $ stmt , int $ offset ) { if ( strlen ( $ stmt ) > $ offset + 3 ) { $ c1 = $ stmt [ ++ $ offset ] ; $ c2 = $ stmt [ ++ $ offset ] ; $ c3 = $ stmt [ ++ $ offset ] ; if ( ( $ c1 == 'O' || $ c1 == 'o' ) && ( $ c2 == 'W' || $ c2 == 'w' ) && ( $ c3 == ' ' || $ c3 == '\t' || $ c3 == '\r' || $ c3 == '\n' ) ) { return ( $ offset << 8 ) | self :: SHOW ; } } return self :: OTHER ; } 
public static function startCheck ( string $ stmt , int $ offset ) { if ( strlen ( $ stmt ) > $ offset + 4 ) { $ c1 = $ stmt [ ++ $ offset ] ; $ c2 = $ stmt [ ++ $ offset ] ; $ c3 = $ stmt [ ++ $ offset ] ; $ c4 = $ stmt [ ++ $ offset ] ; if ( ( $ c1 == 'A' || $ c1 == 'a' ) && ( $ c2 == 'R' || $ c2 == 'r' ) && ( $ c3 == 'T' || $ c3 == 't' ) && ( $ c4 == ' ' || $ c4 == '\t' || $ c4 == '\r' || $ c4 == '\n' ) ) { return ( $ offset << 8 ) | self :: START ; } } return self :: OTHER ; } 
public static function uCheck ( string $ stmt , int $ offset , bool $ has_Space = true ) { if ( strlen ( $ stmt ) > ++ $ offset ) { switch ( $ stmt [ $ offset ] ) { case 'P' : case 'p' : if ( strlen ( $ stmt ) > $ offset + 5 ) { $ c1 = $ stmt [ ++ $ offset ] ; $ c2 = $ stmt [ ++ $ offset ] ; $ c3 = $ stmt [ ++ $ offset ] ; $ c4 = $ stmt [ ++ $ offset ] ; $ c5 = $ stmt [ ++ $ offset ] ; if ( ( $ c1 == 'D' || $ c1 == 'd' ) && ( $ c2 == 'A' || $ c2 == 'a' ) && ( $ c3 == 'T' || $ c3 == 't' ) && ( $ c4 == 'E' || $ c4 == 'e' ) && ( $ has_Space ? ( ' ' == $ c5 || '\t' == $ c5 || '\r' == $ c5 || '\n' == $ c5 ) : true ) ) { return self :: UPDATE ; } } break ; case 'S' : case 's' : if ( strlen ( $ stmt ) > $ offset + 2 ) { $ c1 = $ stmt [ ++ $ offset ] ; $ c2 = $ stmt [ ++ $ offset ] ; if ( ( $ c1 == 'E' || $ c1 == 'e' ) && ( $ c2 == ' ' || $ c2 == '\t' || $ c2 == '\r' || $ c2 == '\n' ) ) { return ( $ offset << 8 ) | self :: USE ; } } break ; case 'N' : case 'n' : if ( strlen ( $ stmt ) > $ offset + 5 ) { $ c1 = $ stmt [ ++ $ offset ] ; $ c2 = $ stmt [ ++ $ offset ] ; $ c3 = $ stmt [ ++ $ offset ] ; $ c4 = $ stmt [ ++ $ offset ] ; $ c5 = $ stmt [ ++ $ offset ] ; if ( ( $ c1 == 'L' || $ c1 == 'l' ) && ( $ c2 == 'O' || $ c2 == 'o' ) && ( $ c3 == 'C' || $ c3 == 'c' ) && ( $ c4 == 'K' || $ c4 == 'k' ) && ( $ c5 == ' ' || $ c5 == '\t' || $ c5 == '\r' || $ c5 == '\n' ) ) { return self :: UNLOCK ; } } break ; default : return self :: OTHER ; } } return self :: OTHER ; } 
public static function readLength ( array $ data ) { $ length = $ data [ 0 ] ; switch ( $ length ) { case 251 : return MySQLMessage :: $ NULL_LENGTH ; case 252 : return self :: readUB2 ( $ data ) ; case 253 : return self :: readUB3 ( $ data ) ; case 254 : return self :: readLong ( $ data ) ; default : return $ length ; } } 
public function decode ( string $ data ) { $ data = getBytes ( $ data ) ; 
public function start ( ) { 
public function stop ( ) { if ( ! $ this -> isRunning ( ) ) { smproxy_error ( 'ERROR: The server is not running! cannot stop!' ) ; } echo 'SMProxy is stopping ...' , PHP_EOL ; $ result = function ( ) { 
public function reload ( ) { 
public function isRunning ( ) { $ masterIsLive = false ; $ pFile = CONFIG [ 'server' ] [ 'swoole' ] [ 'pid_file' ] ; 
public static function call ( $ cb , array $ args = [ ] ) { if ( version_compare ( SWOOLE_VERSION , '4.0' , '>=' ) ) { $ ret = call_user_func_array ( $ cb , $ args ) ; } else { $ ret = \ Swoole \ Coroutine :: call_user_func_array ( $ cb , $ args ) ; } return $ ret ; } 
public function query ( BinaryPacket $ bin ) { 
public function connect ( string $ host , int $ port , float $ timeout = 0.1 , int $ tryStep = 0 ) { $ this -> timeout = $ timeout ; if ( ! $ this -> client -> connect ( $ host , $ port , $ timeout ) ) { if ( $ tryStep < 3 ) { $ this -> client -> close ( ) ; return $ this -> connect ( $ host , $ port , $ timeout , ++ $ tryStep ) ; } else { $ this -> onClientError ( $ this -> client ) ; return false ; } } else { if ( ! $ this -> isDuplex ) { $ this -> mysqlClient -> push ( $ this -> client ) ; } self :: go ( function ( ) { while ( true ) { $ data = $ this -> recv ( ) ; if ( $ data === '' ) { break ; } } } ) ; return $ this -> client ; } } 
public function onClientReceive ( \ Swoole \ Coroutine \ Client $ cli , string $ data ) { if ( $ this -> connected ) { $ packages = [ $ data ] ; } else { $ packages = packageSplit ( $ data , true , 3 , true ) ; } foreach ( $ packages as $ package ) { $ data = $ package ; self :: go ( function ( ) use ( $ cli , $ data ) { $ fd = $ this -> serverFd ; $ binaryPacket = new BinaryPacket ( ) ; $ binaryPacket -> data = getBytes ( $ data ) ; $ binaryPacket -> packetLength = $ binaryPacket -> calcPacketSize ( ) ; if ( isset ( $ binaryPacket -> data [ 4 ] ) ) { $ send = true ; if ( $ binaryPacket -> data [ 4 ] == ErrorPacket :: $ FIELD_COUNT ) { $ errorPacket = new ErrorPacket ( ) ; $ errorPacket -> read ( $ binaryPacket ) ; $ errorPacket -> errno = ErrorCode :: ER_SYNTAX_ERROR ; $ data = getString ( $ errorPacket -> write ( ) ) ; } elseif ( ! $ this -> connected ) { if ( $ binaryPacket -> data [ 4 ] == OkPacket :: $ FIELD_COUNT ) { if ( ! array_diff_assoc ( $ binaryPacket -> data , OkPacket :: $ AUTH_OK ) || ! array_diff_assoc ( $ binaryPacket -> data , OkPacket :: $ FAST_AUTH_OK ) || ! array_diff_assoc ( $ binaryPacket -> data , OkPacket :: $ SWITCH_AUTH_OK ) || ! array_diff_assoc ( $ binaryPacket -> data , OkPacket :: $ FULL_AUTH_OK ) ) { $ send = false ; $ this -> connected = true ; $ this -> chan -> push ( $ this ) ; } # 快速认证 } elseif ( $ binaryPacket -> data [ 4 ] == 0x01 ) { # 请求公钥 if ( $ binaryPacket -> packetLength == 6 ) { if ( $ binaryPacket -> data [ $ binaryPacket -> packetLength - 1 ] == 4 ) { $ data = getString ( array_merge ( getMysqlPackSize ( 1 ) , [ 3 , 2 ] ) ) ; $ this -> send ( $ data ) ; } } else { $ this -> serverPublicKey = substr ( $ data , 5 , strlen ( $ data ) - 2 ) ; $ encryptData = SecurityUtil :: sha2RsaEncrypt ( $ this -> account [ 'password' ] , $ this -> salt , $ this -> serverPublicKey ) ; $ data = getString ( array_merge ( getMysqlPackSize ( strlen ( $ encryptData ) ) , [ 5 ] ) ) . $ encryptData ; $ this -> send ( $ data ) ; } $ send = false ; } elseif ( $ binaryPacket -> data [ 4 ] == 0xfe ) { $ mm = new MySQLMessage ( $ binaryPacket -> data ) ; $ mm -> move ( 5 ) ; $ pluginName = $ mm -> readStringWithNull ( ) ; $ this -> salt = $ mm -> readBytesWithNull ( ) ; $ password = $ this -> processAuth ( $ pluginName ? : 'mysql_native_password' ) ; $ this -> send ( getString ( array_merge ( getMysqlPackSize ( count ( $ password ) ) , [ 3 ] , $ password ) ) ) ; $ send = false ; } elseif ( ! $ this -> auth ) { $ handshakePacket = ( new HandshakePacket ( ) ) -> read ( $ binaryPacket ) ; $ this -> salt = array_merge ( $ handshakePacket -> seed , $ handshakePacket -> restOfScrambleBuff ) ; $ password = $ this -> processAuth ( $ handshakePacket -> pluginName ) ; $ clientFlag = Capabilities :: CLIENT_CAPABILITIES ; $ authPacket = new AuthPacket ( ) ; $ authPacket -> pluginName = $ handshakePacket -> pluginName ; $ authPacket -> packetId = 1 ; if ( isset ( $ this -> database ) && $ this -> database ) { $ authPacket -> database = $ this -> database ; } else { $ authPacket -> database = 0 ; } if ( $ authPacket -> database ) { $ clientFlag |= Capabilities :: CLIENT_CONNECT_WITH_DB ; } if ( version_compare ( $ handshakePacket -> serverVersion , '5.0' , '>=' ) ) { $ clientFlag |= Capabilities :: CLIENT_MULTI_RESULTS ; } $ authPacket -> clientFlags = $ clientFlag ; $ authPacket -> serverCapabilities = $ handshakePacket -> serverCapabilities ; $ authPacket -> maxPacketSize = CONFIG [ 'server' ] [ 'swoole_client_setting' ] [ 'package_max_length' ] ?? 16777215 ; $ authPacket -> charsetIndex = CharsetUtil :: getIndex ( $ this -> charset ?? 'utf8mb4' ) ; $ authPacket -> user = $ this -> account [ 'user' ] ; $ authPacket -> password = $ password ; $ this -> auth = true ; $ this -> send ( getString ( $ authPacket -> write ( ) ) ) ; $ send = false ; } } if ( $ send && $ this -> server -> exist ( $ fd ) ) { $ this -> server -> send ( $ fd , $ data ) ; } } } ) ; } } 
public function processAuth ( string $ pluginName ) { switch ( $ pluginName ) { case 'mysql_native_password' : $ password = SecurityUtil :: scramble411 ( $ this -> account [ 'password' ] , $ this -> salt ) ; break ; case 'caching_sha2_password' : $ password = SecurityUtil :: scrambleSha256 ( $ this -> account [ 'password' ] , $ this -> salt ) ; break ; case 'sha256_password' : throw new MySQLException ( 'Sha256_password plugin is not supported yet' ) ; break ; case 'mysql_old_password' : throw new MySQLException ( 'mysql_old_password plugin is not supported yet' ) ; break ; case 'mysql_clear_password' : $ password = array_merge ( getBytes ( $ this -> account [ 'password' ] ) , [ 0 ] ) ; break ; default : $ password = SecurityUtil :: scramble411 ( $ this -> account [ 'password' ] , $ this -> salt ) ; break ; } return $ password ; } 
public function send ( ... $ data ) { if ( $ this -> isDuplex ) { if ( $ this -> client -> isConnected ( ) ) { return $ this -> client -> send ( ... $ data ) ; } else { return false ; } } else { $ client = self :: coPop ( $ this -> mysqlClient ) ; if ( $ client === false ) { 
public function recv ( ) { if ( $ this -> isDuplex ) { $ data = $ this -> client -> recv ( - 1 ) ; if ( $ data === '' ) { $ this -> onClientClose ( $ this -> client ) ; } elseif ( is_string ( $ data ) ) { $ this -> onClientReceive ( $ this -> client , $ data ) ; } return $ data ; } else { $ client = self :: coPop ( $ this -> mysqlClient , $ this -> timeout ) ; if ( $ client === false ) { 
public function onClientClose ( \ Swoole \ Coroutine \ Client $ cli ) { MySQLPool :: destruct ( $ cli , $ this -> database ? ( $ this -> model . DB_DELIMITER . $ this -> database ) : $ this -> model ) ; } 
private static function parsestring2 ( string $ stmt , int $ offset ) { $ sb = '' ; $ stmtLen = strlen ( $ stmt ) ; for ( ++ $ offset ; $ offset < $ stmtLen ; ++ $ offset ) { $ c = $ stmt = [ $ offset ] ; if ( '\\' == $ c ) { switch ( $ c = $ stmt [ ++ $ offset ] ) { case '0' : $ sb .= "\0" ; break ; case 'b' : $ sb .= "\b" ; break ; case 'n' : $ sb .= "\n" ; break ; case 'r' : $ sb .= "\r" ; break ; case 't' : $ sb .= "\t" ; break ; case 'Z' : $ sb .= chr ( 26 ) ; break ; default : $ sb .= $ c ; } } elseif ( '"' == $ c ) { if ( $ offset + 1 < strlen ( $ stmt ) && '"' == $ stmt [ $ offset + 1 ] ) { ++ $ offset ; $ sb .= '"' ; } else { break ; } } else { $ sb .= $ c ; } } return $ sb ; } 
private static function parseIdentifierEscape ( string $ stmt , int $ offset ) { $ sb = '' ; for ( ++ $ offset , $ stemLen = strlen ( $ stmt ) ; $ offset < $ stemLen ; ++ $ offset ) { $ c = $ stmt [ $ offset ] ; if ( '`' == $ c ) { if ( $ offset + 1 < strlen ( $ stmt ) && '`' == $ stmt [ $ offset + 1 ] ) { ++ $ offset ; $ sb .= '`' ; } else { break ; } } else { $ sb .= $ c ; } } return $ sb ; } 
public static function nextstringIsExpectedWithIgnoreSepChar ( string $ stmt , int $ offset , string $ nextExpectedstring , bool $ checkSepChar ) { if ( null == $ nextExpectedstring || strlen ( $ nextExpectedstring ) < 1 ) { return $ offset ; } $ i = $ offset ; $ index = 0 ; for ( $ stmtLen = strlen ( $ stmt ) ; $ i < $ stmtLen && $ index < strlen ( $ nextExpectedstring ) ; ++ $ i ) { if ( 0 == $ index ) { $ isSep = self :: currentCharIsSep ( $ stmt , $ i ) ; if ( $ isSep ) { continue ; } } $ actualChar = $ stmt [ $ i ] ; $ expectedChar = $ nextExpectedstring [ $ index ++ ] ; if ( $ actualChar != $ expectedChar ) { return $ offset ; } } if ( $ index == strlen ( $ nextExpectedstring ) ) { $ ok = true ; if ( $ checkSepChar ) { $ ok = self :: nextCharIsSep ( $ stmt , $ i ) ; } if ( $ ok ) { return $ i ; } } return $ offset ; } 
public static function nextstringIsJsonEq ( string $ stmt , int $ offset ) { $ i = $ offset ; 
public function log ( $ level , $ message , array $ context = [ ] ) { if ( self :: $ open ) { if ( ! isset ( self :: $ levels [ $ level ] ) ) { throw new InvalidArgumentException ( sprintf ( 'The log level "%s" does not exist.' , $ level ) ) ; } if ( self :: $ levels [ $ level ] < $ this -> minLevelIndex ) { return ; } $ log_data = $ this -> format ( $ level , $ message , $ context ) ; 
public static function getLogger ( string $ tag = 'system' ) { if ( ! is_array ( self :: $ CONFIG ) || empty ( self :: $ CONFIG ) ) { self :: $ CONFIG = CONFIG [ 'server' ] [ 'logs' ] [ 'config' ] ; self :: $ open = CONFIG [ 'server' ] [ 'logs' ] [ 'open' ] ; } 
private function createLogPath ( string $ log_path ) { if ( ! file_exists ( $ log_path ) || ! is_dir ( $ log_path ) ) { return mkdir ( $ log_path , 0755 , true ) ; } return true ; } 
private function getLogFile ( ) { 
private function coWrite ( string $ logFile , string $ messageText ) { go ( function ( ) use ( $ logFile , $ messageText ) { $ res = Coroutine :: writeFile ( $ logFile , $ messageText , FILE_APPEND ) ; if ( $ res === false ) { throw new \ InvalidArgumentException ( "Unable to append to log file: {$this->logFile}" ) ; } } ) ; } 
private function syncWrite ( string $ logFile , string $ messageText ) { $ fp = fopen ( $ logFile , 'a' ) ; if ( $ fp === false ) { throw new \ InvalidArgumentException ( "Unable to append to log file: {$this->logFile}" ) ; } flock ( $ fp , LOCK_EX ) ; fwrite ( $ fp , $ messageText ) ; flock ( $ fp , LOCK_UN ) ; fclose ( $ fp ) ; } 
public function onConnect ( \ swoole_server $ server , int $ fd ) { 
public function onReceive ( \ swoole_server $ server , int $ fd , int $ reactor_id , string $ data ) { self :: go ( function ( ) use ( $ server , $ fd , $ reactor_id , $ data ) { if ( ! isset ( $ this -> source [ $ fd ] -> auth ) ) { throw new SMProxyException ( 'Must be connected before sending data!' ) ; } if ( ! isset ( $ this -> halfPack [ $ fd ] ) ) { $ this -> halfPack [ $ fd ] = '' ; } if ( $ this -> source [ $ fd ] -> auth ) { $ headerLength = 4 ; } else { $ headerLength = 3 ; } $ packages = packageSplit ( $ data , $ this -> source [ $ fd ] -> auth ? : false , $ headerLength , false , $ this -> halfPack [ $ fd ] ) ; foreach ( $ packages as $ package ) { $ data = $ package ; self :: go ( function ( ) use ( $ server , $ fd , $ reactor_id , $ data ) { $ bin = ( new MySqlPacketDecoder ( ) ) -> decode ( $ data ) ; if ( ! $ this -> source [ $ fd ] -> auth ) { $ this -> auth ( $ bin , $ server , $ fd ) ; } else { $ this -> query ( $ bin , $ data , $ fd ) ; if ( isset ( $ this -> connectReadState [ $ fd ] ) && true === $ this -> connectReadState [ $ fd ] ) { $ model = 'read' ; } else { $ model = 'write' ; } $ key = $ this -> compareModel ( $ model , $ server , $ fd ) ; if ( $ data ) { if ( isset ( $ this -> mysqlClient [ $ fd ] [ $ key ] ) ) { $ this -> mysqlClient [ $ fd ] [ $ key ] -> send ( $ data ) ; } else { $ client = MySQLPool :: fetch ( $ key , $ server , $ fd ) ; $ result = $ client -> send ( $ data ) ; if ( $ result ) { $ this -> mysqlClient [ $ fd ] [ $ key ] = $ client ; } } } 
public function onClose ( \ swoole_server $ server , int $ fd ) { if ( isset ( $ this -> source [ $ fd ] ) ) { unset ( $ this -> source [ $ fd ] ) ; } if ( isset ( $ this -> halfPack [ $ fd ] ) ) { unset ( $ this -> halfPack [ $ fd ] ) ; } $ connectHasTransaction = false ; $ connectHasAutoCommit = false ; if ( isset ( $ this -> connectHasTransaction [ $ fd ] ) && true === $ this -> connectHasTransaction [ $ fd ] ) { 
public function onWorkerStart ( \ swoole_server $ server , int $ worker_id ) { self :: go ( function ( ) use ( $ server , $ worker_id ) { if ( $ worker_id >= CONFIG [ 'server' ] [ 'swoole' ] [ 'worker_num' ] ) { ProcessHelper :: setProcessTitle ( 'SMProxy task process' ) ; } else { ProcessHelper :: setProcessTitle ( 'SMProxy worker process' ) ; } try { $ this -> dbConfig = $ this -> parseDbConfig ( initConfig ( CONFIG_PATH ) ) ; 
private function setStartConns ( ) { $ clients = [ ] ; foreach ( $ this -> dbConfig as $ key => $ value ) { if ( count ( explode ( DB_DELIMITER , $ key ) ) < 2 ) { continue ; } 
private function checkAccount ( \ swoole_server $ server , int $ fd , string $ user , array $ password ) { $ checkPassword = $ this -> source [ $ fd ] -> checkPassword ( $ password , CONFIG [ 'server' ] [ 'password' ] ) ; return CONFIG [ 'server' ] [ 'user' ] == $ user && $ checkPassword ; } 
private function accessDenied ( \ swoole_server $ server , int $ fd , int $ serverId ) { $ message = 'SMProxy@access denied for user \'' . $ this -> source [ $ fd ] -> user . '\'@\'' . $ server -> getClientInfo ( $ fd ) [ 'remote_ip' ] . '\' (using password: YES)' ; $ errMessage = self :: writeErrMessage ( $ serverId , $ message , ErrorCode :: ER_ACCESS_DENIED_ERROR , 28000 ) ; if ( $ server -> exist ( $ fd ) ) { $ server -> send ( $ fd , getString ( $ errMessage ) ) ; } throw new MySQLException ( $ message ) ; } 
private function compareModel ( string $ model , \ swoole_server $ server , int $ fd ) { $ spliceKey = function ( int $ fd , string $ model ) { return $ this -> source [ $ fd ] -> database ? $ model . DB_DELIMITER . $ this -> source [ $ fd ] -> database : $ model ; } ; switch ( $ model ) { case 'read' : $ key = $ spliceKey ( $ fd , $ model ) ; 
private function existsDBKey ( \ swoole_server $ server , int $ fd , string $ model , string $ key ) { 
private function auth ( BinaryPacket $ bin , \ swoole_server $ server , int $ fd ) { if ( $ bin -> data [ 0 ] == 20 ) { $ checkAccount = $ this -> checkAccount ( $ server , $ fd , $ this -> source [ $ fd ] -> user , array_copy ( $ bin -> data , 4 , 20 ) ) ; if ( ! $ checkAccount ) { $ this -> accessDenied ( $ server , $ fd , 4 ) ; } else { if ( $ server -> exist ( $ fd ) ) { $ server -> send ( $ fd , getString ( OkPacket :: $ SWITCH_AUTH_OK ) ) ; } $ this -> source [ $ fd ] -> auth = true ; } } elseif ( $ bin -> data [ 4 ] == 14 ) { if ( $ server -> exist ( $ fd ) ) { $ server -> send ( $ fd , getString ( OkPacket :: $ OK ) ) ; } } else { $ authPacket = new AuthPacket ( ) ; $ authPacket -> read ( $ bin ) ; $ checkAccount = $ this -> checkAccount ( $ server , $ fd , $ authPacket -> user ?? '' , $ authPacket -> password ?? [ ] ) ; if ( ! $ checkAccount ) { if ( $ authPacket -> pluginName == 'mysql_native_password' ) { $ this -> accessDenied ( $ server , $ fd , 2 ) ; } else { $ this -> source [ $ fd ] -> user = $ authPacket -> user ; $ this -> source [ $ fd ] -> database = $ authPacket -> database ; $ this -> source [ $ fd ] -> seed = RandomUtil :: randomBytes ( 20 ) ; $ authSwitchRequest = array_merge ( [ 254 ] , getBytes ( 'mysql_native_password' ) , [ 0 ] , $ this -> source [ $ fd ] -> seed , [ 0 ] ) ; if ( $ server -> exist ( $ fd ) ) { $ server -> send ( $ fd , getString ( array_merge ( getMysqlPackSize ( count ( $ authSwitchRequest ) ) , [ 2 ] , $ authSwitchRequest ) ) ) ; } } } else { if ( $ server -> exist ( $ fd ) ) { $ server -> send ( $ fd , getString ( OkPacket :: $ AUTH_OK ) ) ; } $ this -> source [ $ fd ] -> auth = true ; $ this -> source [ $ fd ] -> database = $ authPacket -> database ; } } } 
private function query ( BinaryPacket $ bin , string & $ data , int $ fd ) { $ trim_data = rtrim ( $ data ) ; switch ( $ bin -> data [ 4 ] ) { case MySQLPacket :: $ COM_INIT_DB : 
public static function init ( array $ connsConfig ) { if ( self :: $ init ) { return ; } self :: $ connsConfig = $ connsConfig ; foreach ( $ connsConfig as $ name => $ config ) { self :: $ spareConns [ $ name ] = [ ] ; self :: $ busyConns [ $ name ] = [ ] ; self :: $ pendingFetchCount [ $ name ] = 0 ; self :: $ resumeFetchCount [ $ name ] = 0 ; self :: $ initConnCount [ $ name ] = 0 ; if ( $ config [ 'maxSpareConns' ] <= 0 || $ config [ 'maxConns' ] <= 0 ) { throw new MySQLException ( "Invalid maxSpareConns or maxConns in {$name}" ) ; } } self :: $ init = true ; } 
public static function recycle ( MysqlProxy $ conn , bool $ busy = true ) { self :: go ( function ( ) use ( $ conn , $ busy ) { if ( ! self :: $ init ) { throw new MySQLException ( 'Should call MySQLPool::init.' ) ; } $ id = spl_object_hash ( $ conn ) ; $ connName = self :: $ connsNameMap [ $ id ] ; if ( $ busy ) { if ( isset ( self :: $ busyConns [ $ connName ] [ $ id ] ) ) { unset ( self :: $ busyConns [ $ connName ] [ $ id ] ) ; } else { throw new MySQLException ( 'Unknow MySQL connection.' ) ; } } $ connsPool = & self :: $ spareConns [ $ connName ] ; if ( ( ( count ( $ connsPool ) + self :: $ initConnCount [ $ connName ] ) >= self :: $ connsConfig [ $ connName ] [ 'maxSpareConns' ] ) && ( ( microtime ( true ) - self :: $ lastConnsTime [ $ id ] ) >= ( ( self :: $ connsConfig [ $ connName ] [ 'maxSpareExp' ] ) ?? 0 ) ) ) { if ( $ conn -> client -> isConnected ( ) ) { $ conn -> client -> close ( ) ; } unset ( self :: $ connsNameMap [ $ id ] ) ; } else { if ( ! $ conn -> client -> isConnected ( ) ) { unset ( self :: $ connsNameMap [ $ id ] ) ; $ conn = self :: initConn ( $ conn -> server , $ conn -> serverFd , $ connName ) ; $ id = spl_object_hash ( $ conn ) ; } $ connsPool [ ] = $ conn ; if ( self :: $ pendingFetchCount [ $ connName ] > 0 ) { ++ self :: $ resumeFetchCount [ $ connName ] ; self :: $ yieldChannel [ $ connName ] -> push ( $ id ) ; } } } ) ; } 
public static function fetch ( string $ connName , \ swoole_server $ server , int $ fd ) { if ( ! self :: $ init ) { throw new MySQLException ( 'Should call MySQLPool::init!' ) ; } if ( ! isset ( self :: $ connsConfig [ $ connName ] ) ) { throw new MySQLException ( "Unvalid connName: {$connName}." ) ; } $ connsPool = & self :: $ spareConns [ $ connName ] ; if ( ! empty ( $ connsPool ) && count ( $ connsPool ) > self :: $ resumeFetchCount [ $ connName ] ) { $ conn = array_pop ( $ connsPool ) ; if ( ! $ conn -> client -> isConnected ( ) ) { return self :: reconnect ( $ server , $ fd , $ conn , $ connName ) ; } else { $ conn -> serverFd = $ fd ; $ id = spl_object_hash ( $ conn ) ; self :: $ busyConns [ $ connName ] [ $ id ] = $ conn ; self :: $ lastConnsTime [ $ id ] = microtime ( true ) ; return $ conn ; } } if ( ( count ( self :: $ busyConns [ $ connName ] ) + count ( $ connsPool ) + self :: $ pendingFetchCount [ $ connName ] + self :: $ initConnCount [ $ connName ] ) >= self :: $ connsConfig [ $ connName ] [ 'maxConns' ] ) { if ( ! isset ( self :: $ yieldChannel [ $ connName ] ) ) { self :: $ yieldChannel [ $ connName ] = new \ Swoole \ Coroutine \ Channel ( 1 ) ; } ++ self :: $ pendingFetchCount [ $ connName ] ; $ client = self :: coPop ( self :: $ yieldChannel [ $ connName ] , self :: $ connsConfig [ $ connName ] [ 'serverInfo' ] [ 'timeout' ] ) ; if ( false === $ client ) { -- self :: $ pendingFetchCount [ $ connName ] ; $ message = 'SMProxy@Reach max connections! Cann\'t pending fetch!' ; $ errMessage = self :: writeErrMessage ( 1 , $ message , ErrorCode :: ER_HAS_GONE_AWAY ) ; if ( $ server -> exist ( $ fd ) ) { $ server -> send ( $ fd , getString ( $ errMessage ) ) ; } throw new MySQLException ( $ message ) ; } -- self :: $ resumeFetchCount [ $ connName ] ; if ( ! empty ( $ connsPool ) ) { $ conn = array_pop ( $ connsPool ) ; if ( ! $ conn -> client -> isConnected ( ) ) { $ conn = self :: reconnect ( $ server , $ fd , $ conn , $ connName ) ; -- self :: $ pendingFetchCount [ $ connName ] ; return $ conn ; } else { $ conn -> serverFd = $ fd ; $ id = spl_object_hash ( $ conn ) ; self :: $ busyConns [ $ connName ] [ $ id ] = $ conn ; self :: $ lastConnsTime [ $ id ] = microtime ( true ) ; -- self :: $ pendingFetchCount [ $ connName ] ; return $ conn ; } } else { return false ; 
public static function initConn ( \ swoole_server $ server , int $ fd , string $ connName , $ tryStep = 0 ) { ++ self :: $ initConnCount [ $ connName ] ; $ chan = new \ Swoole \ Coroutine \ Channel ( 1 ) ; $ conn = new MysqlProxy ( $ server , $ fd , $ chan ) ; $ serverInfo = self :: $ connsConfig [ $ connName ] [ 'serverInfo' ] ; if ( false == strpos ( $ connName , DB_DELIMITER ) ) { $ conn -> database = 0 ; $ conn -> model = $ connName ; } else { $ conn -> database = substr ( $ connName , strpos ( $ connName , DB_DELIMITER ) + strlen ( DB_DELIMITER ) ) ; $ conn -> model = substr ( $ connName , 0 , strpos ( $ connName , DB_DELIMITER ) ) ; } $ conn -> account = $ serverInfo [ 'account' ] ; $ conn -> charset = self :: $ connsConfig [ $ connName ] [ 'charset' ] ; if ( false == $ conn -> connect ( $ serverInfo [ 'host' ] , $ serverInfo [ 'port' ] , $ serverInfo [ 'timeout' ] ?? 0.1 ) ) { -- self :: $ initConnCount [ $ connName ] ; $ message = 'SMProxy@MySQL server has gone away' ; $ errMessage = self :: writeErrMessage ( 1 , $ message , ErrorCode :: ER_HAS_GONE_AWAY ) ; if ( $ server -> exist ( $ fd ) ) { $ server -> send ( $ fd , getString ( $ errMessage ) ) ; } throw new MySQLException ( $ message ) ; } $ client = self :: coPop ( $ chan , $ serverInfo [ 'timeout' ] * 3 ) ; if ( $ client === false ) { -- self :: $ initConnCount [ $ connName ] ; if ( $ tryStep < 3 ) { return self :: initConn ( $ server , $ fd , $ connName , ++ $ tryStep ) ; } else { $ message = 'SMProxy@Connection ' . $ serverInfo [ 'host' ] . ':' . $ serverInfo [ 'port' ] . ' waiting timeout, timeout=' . $ serverInfo [ 'timeout' ] ; $ errMessage = self :: writeErrMessage ( 1 , $ message , ErrorCode :: ER_HAS_GONE_AWAY ) ; if ( $ server -> exist ( $ fd ) ) { $ server -> send ( $ fd , getString ( $ errMessage ) ) ; } throw new MySQLException ( $ message ) ; } } $ id = spl_object_hash ( $ client ) ; self :: $ connsNameMap [ $ id ] = $ connName ; self :: $ busyConns [ $ connName ] [ $ id ] = $ client ; self :: $ lastConnsTime [ $ id ] = microtime ( true ) ; -- self :: $ initConnCount [ $ connName ] ; return $ client ; } 
public static function destruct ( Client $ cli , string $ connName ) { self :: go ( function ( ) use ( $ cli , $ connName ) { if ( $ cli -> isConnected ( ) ) { $ cli -> close ( ) ; } $ proxyConn = false ; foreach ( self :: $ spareConns [ $ connName ] as $ key => $ conn ) { if ( spl_object_hash ( $ conn -> client ) == spl_object_hash ( $ cli ) ) { $ proxyConn = $ conn ; unset ( self :: $ spareConns [ $ connName ] [ $ key ] ) ; break ; } } if ( $ proxyConn ) { self :: recycle ( $ proxyConn , false ) ; } } ) ; } 
public static function reconnect ( \ swoole_server $ server , int $ fd , MysqlProxy $ conn , string $ connName ) { if ( $ conn -> client -> isConnected ( ) ) { $ conn -> client -> close ( ) ; } $ old_id = spl_object_hash ( $ conn ) ; unset ( self :: $ busyConns [ $ connName ] [ $ old_id ] ) ; unset ( self :: $ connsNameMap [ $ old_id ] ) ; self :: $ lastConnsTime [ $ old_id ] = 0 ; return self :: initConn ( $ server , $ fd , $ connName ) ; } 
protected static function go ( \ Closure $ function ) { if ( - 1 !== \ Swoole \ Coroutine :: getuid ( ) ) { $ pool = self :: $ pool [ \ Swoole \ Coroutine :: getuid ( ) ] ?? false ; } else { $ pool = false ; } go ( function ( ) use ( $ function , $ pool ) { try { if ( $ pool ) { self :: $ pool [ \ Swoole \ Coroutine :: getuid ( ) ] = $ pool ; } $ function ( ) ; if ( $ pool ) { unset ( self :: $ pool [ \ Swoole \ Coroutine :: getuid ( ) ] ) ; } } catch ( SMProxyException $ SMProxyException ) { self :: writeErrorMessage ( $ SMProxyException , 'system' ) ; } catch ( MySQLException $ MySQLException ) { self :: writeErrorMessage ( $ MySQLException , 'mysql' ) ; } } ) ; } 
protected static function writeErrorMessage ( $ exception , string $ tag = 'mysql' ) { $ log = Log :: getLogger ( $ tag ) ; $ errLevel = $ exception -> getCode ( ) ? array_search ( $ exception -> getCode ( ) , Log :: $ levels ) : 'warning' ; $ log -> $ errLevel ( $ exception -> errorMessage ( ) ) ; if ( CONFIG [ 'server' ] [ 'swoole' ] [ 'daemonize' ] != true ) { echo '[' . ucfirst ( $ errLevel ) . '] ' , $ exception -> errorMessage ( ) , PHP_EOL ; } } 
public function parseDbConfig ( array $ _config ) { $ config = $ _config [ 'database' ] ?? [ ] ; foreach ( $ config [ 'databases' ] as $ key => $ database ) { if ( isset ( $ config [ 'serverInfo' ] [ $ database [ 'serverInfo' ] ] ) ) { $ config [ 'databases' ] [ $ key ] [ 'maxConns' ] = floor ( eval ( 'return ' . $ config [ 'databases' ] [ $ key ] [ 'maxConns' ] . ';' ) / CONFIG [ 'server' ] [ 'swoole' ] [ 'worker_num' ] ) ; $ config [ 'databases' ] [ $ key ] [ 'maxSpareConns' ] = floor ( eval ( 'return ' . $ config [ 'databases' ] [ $ key ] [ 'maxSpareConns' ] . ';' ) / CONFIG [ 'server' ] [ 'swoole' ] [ 'worker_num' ] ) ; $ config [ 'databases' ] [ $ key ] [ 'startConns' ] = eval ( 'return ' . $ config [ 'databases' ] [ $ key ] [ 'startConns' ] . ';' ) ; $ config [ 'databases' ] [ $ key ] [ 'maxSpareExp' ] = eval ( 'return ' . $ config [ 'databases' ] [ $ key ] [ 'maxSpareExp' ] . ';' ) ; foreach ( $ config [ 'serverInfo' ] [ $ database [ 'serverInfo' ] ] as $ s_key => $ value ) { if ( isset ( $ config [ 'account' ] [ $ value [ 'account' ] ] ) ) { $ host = & $ config [ 'serverInfo' ] [ $ database [ 'serverInfo' ] ] [ $ s_key ] [ 'host' ] ; if ( is_array ( $ host ) ) { $ host = $ host [ array_rand ( $ host ) ] ; } if ( ! isset ( $ config [ 'databases' ] [ $ s_key ] ) ) { $ config [ 'databases' ] [ $ s_key ] = $ config [ 'databases' ] [ $ key ] ; $ config [ 'databases' ] [ $ s_key ] [ 'serverInfo' ] = $ config [ 'serverInfo' ] [ $ database [ 'serverInfo' ] ] [ $ s_key ] ; $ config [ 'databases' ] [ $ s_key ] [ 'serverInfo' ] [ 'account' ] = $ config [ 'account' ] [ $ value [ 'account' ] ] ; } $ config [ 'databases' ] [ $ s_key . DB_DELIMITER . $ key ] = $ config [ 'databases' ] [ $ key ] ; $ config [ 'databases' ] [ $ s_key . DB_DELIMITER . $ key ] [ 'serverInfo' ] = $ config [ 'serverInfo' ] [ $ database [ 'serverInfo' ] ] [ $ s_key ] ; $ config [ 'databases' ] [ $ s_key . DB_DELIMITER . $ key ] [ 'serverInfo' ] [ 'account' ] = $ config [ 'account' ] [ $ value [ 'account' ] ] ; } else { throw new SMProxyException ( 'Config serverInfo->' . $ s_key . '->account is not exists!' ) ; } } } else { throw new SMProxyException ( 'Config serverInfo key ' . $ database [ 'serverInfo' ] . 'is not exists!' ) ; } unset ( $ config [ 'databases' ] [ $ key ] ) ; } return $ config [ 'databases' ] ; } 
protected static function coPop ( Channel $ chan , int $ timeout = 0 ) { if ( version_compare ( swoole_version ( ) , '4.0.3' , '>=' ) ) { return $ chan -> pop ( $ timeout ) ; } else { if ( 0 == $ timeout ) { return $ chan -> pop ( ) ; } else { $ writes = [ ] ; $ reads = [ $ chan ] ; $ result = $ chan -> select ( $ reads , $ writes , $ timeout ) ; if ( false === $ result || empty ( $ reads ) ) { return false ; } $ readChannel = $ reads [ 0 ] ; return $ readChannel -> pop ( ) ; } } } 
public function provide ( array $ options = array ( ) ) { $ options = array_replace ( $ this -> baseOptions , $ options ) ; $ manager = $ this -> doctrine -> getManagerForClass ( $ this -> objectClass ) ; $ repository = $ manager -> getRepository ( $ this -> objectClass ) ; $ qb = \ call_user_func ( [ $ repository , $ options [ 'query_builder_method' ] ] , self :: ENTITY_ALIAS ) ; 
public function serialize ( $ object ) { $ context = $ this -> serializer instanceof JMSSerializer ? SerializationContext :: create ( ) -> enableMaxDepthChecks ( ) : [ ] ; if ( ! empty ( $ this -> groups ) ) { if ( $ context instanceof SerializationContext ) { $ context -> setGroups ( $ this -> groups ) ; } else { $ context [ 'groups' ] = $ this -> groups ; } } if ( $ this -> version ) { $ context -> setVersion ( $ this -> version ) ; } if ( ! is_array ( $ context ) ) { $ context -> setSerializeNull ( $ this -> serializeNull ) ; } return $ this -> serializer -> serialize ( $ object , 'json' , $ context ) ; } 
public static function build ( OutputInterface $ output , $ action , $ index , $ type , $ offset ) { $ progress = null ; return function ( $ increment , $ totalObjects , $ message = null ) use ( & $ progress , $ output , $ action , $ index , $ type , $ offset ) { if ( null === $ progress ) { $ progress = new ProgressBar ( $ output , $ totalObjects ) ; $ progress -> start ( ) ; $ progress -> setProgress ( $ offset ) ; } if ( null !== $ message ) { $ progress -> clear ( ) ; $ output -> writeln ( sprintf ( '<info>%s</info> <error>%s</error>' , $ action , $ message ) ) ; $ progress -> display ( ) ; } $ progress -> setMessage ( sprintf ( '<info>%s</info> <comment>%s/%s</comment>' , $ action , $ index , $ type ) ) ; $ progress -> advance ( $ increment ) ; } ; } 
public function insertMany ( array $ objects ) { $ documents = [ ] ; foreach ( $ objects as $ object ) { $ documents [ ] = $ this -> transformToElasticaDocument ( $ object ) ; } try { $ this -> type -> addDocuments ( $ documents , $ this -> options ) ; } catch ( BulkException $ e ) { $ this -> log ( $ e ) ; } } 
public function replaceMany ( array $ objects ) { $ documents = [ ] ; foreach ( $ objects as $ object ) { $ document = $ this -> transformToElasticaDocument ( $ object ) ; $ document -> setDocAsUpsert ( true ) ; $ documents [ ] = $ document ; } try { $ this -> type -> updateDocuments ( $ documents , $ this -> options ) ; } catch ( BulkException $ e ) { $ this -> log ( $ e ) ; } } 
public function deleteMany ( array $ objects ) { $ documents = [ ] ; foreach ( $ objects as $ object ) { $ documents [ ] = $ this -> transformToElasticaDocument ( $ object ) ; } try { $ this -> type -> deleteDocuments ( $ documents ) ; } catch ( BulkException $ e ) { $ this -> log ( $ e ) ; } } 
public function deleteManyByIdentifiers ( array $ identifiers , $ routing = false ) { try { $ this -> type -> deleteIds ( $ identifiers , $ routing ) ; } catch ( BulkException $ e ) { $ this -> log ( $ e ) ; } } 
private function log ( BulkException $ e ) { if ( ! $ this -> logger ) { throw $ e ; } $ this -> logger -> error ( $ e ) ; } 
protected function execute ( InputInterface $ input , OutputInterface $ output ) { $ indexTemplate = $ input -> getOption ( 'index' ) ; $ deleteByPattern = $ input -> getOption ( 'force-delete' ) ; if ( $ deleteByPattern ) { $ helper = $ this -> getHelper ( 'question' ) ; $ question = new ConfirmationQuestion ( 'You are going to remove all template indexes. Are you sure?' , false ) ; if ( ! $ helper -> ask ( $ input , $ output , $ question ) ) { return 1 ; } } if ( null !== $ indexTemplate ) { $ output -> writeln ( sprintf ( '<info>Resetting template</info> <comment>%s</comment>' , $ indexTemplate ) ) ; $ this -> resetter -> resetIndex ( $ indexTemplate , $ deleteByPattern ) ; } else { $ output -> writeln ( '<info>Resetting all templates</info>' ) ; $ this -> resetter -> resetAllIndexes ( $ deleteByPattern ) ; } return 0 ; } 
public function process ( ContainerBuilder $ container ) { if ( ! $ container -> hasDefinition ( 'fos_elastica.config_manager' ) ) { return ; } $ indexSources = [ ] ; $ indexTemplateSources = [ ] ; foreach ( array_keys ( $ container -> findTaggedServiceIds ( 'fos_elastica.config_source' ) ) as $ id ) { $ tag = $ container -> findDefinition ( $ id ) -> getTag ( 'fos_elastica.config_source' ) ; if ( isset ( $ tag [ 0 ] [ 'source' ] ) && $ tag [ 0 ] [ 'source' ] === self :: SOURCE_TYPE_INDEX_TEMPLATE ) { $ indexTemplateSources [ ] = new Reference ( $ id ) ; } else { $ indexSources [ ] = new Reference ( $ id ) ; } } $ container -> getDefinition ( 'fos_elastica.config_manager' ) -> replaceArgument ( 0 , $ indexSources ) ; $ container -> getDefinition ( 'fos_elastica.config_manager.index_templates' ) -> replaceArgument ( 0 , $ indexTemplateSources ) ; } 
protected function getTypes ( $ config ) { $ types = array ( ) ; if ( isset ( $ config [ 'types' ] ) ) { foreach ( $ config [ 'types' ] as $ typeConfig ) { $ types [ $ typeConfig [ 'name' ] ] = new TypeConfig ( $ typeConfig [ 'name' ] , $ typeConfig [ 'mapping' ] , $ typeConfig [ 'config' ] ) ; } } return $ types ; } 
public function provide ( array $ options = array ( ) ) { $ options = array_replace ( $ this -> baseOptions , $ options ) ; $ manager = $ this -> doctrine -> getManagerForClass ( $ this -> objectClass ) ; $ repository = $ manager -> getRepository ( $ this -> objectClass ) ; $ pager = new PagerfantaPager ( new Pagerfanta ( new DoctrineODMMongoDBAdapter ( call_user_func ( [ $ repository , $ options [ 'query_builder_method' ] ] ) ) ) ) ; $ this -> registerListenersService -> register ( $ manager , $ pager , $ options ) ; return $ pager ; } 
public function getConfiguration ( ) { $ indexes = [ ] ; foreach ( $ this -> configArray as $ config ) { $ types = $ this -> getTypes ( $ config ) ; $ index = new IndexConfig ( $ config [ 'name' ] , $ types , [ 'elasticSearchName' => $ config [ 'elasticsearch_name' ] , 'settings' => $ config [ 'settings' ] , 'useAlias' => $ config [ 'use_alias' ] , ] ) ; $ indexes [ $ config [ 'name' ] ] = $ index ; } return $ indexes ; } 
public function getType ( $ typeName ) { if ( ! array_key_exists ( $ typeName , $ this -> types ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Type "%s" does not exist on index "%s"' , $ typeName , $ this -> name ) ) ; } return $ this -> types [ $ typeName ] ; } 
public function getAllProviders ( ) { $ providers = [ ] ; foreach ( $ this -> providers as $ index => $ indexProviders ) { foreach ( $ indexProviders as $ type => $ providerId ) { $ providers [ sprintf ( '%s/%s' , $ index , $ type ) ] = $ this -> container -> get ( $ providerId ) ; } } return $ providers ; } 
public function getIndexProviders ( $ index ) { if ( ! isset ( $ this -> providers [ $ index ] ) ) { throw new \ InvalidArgumentException ( sprintf ( 'No providers were registered for index "%s".' , $ index ) ) ; } $ providers = [ ] ; foreach ( $ this -> providers [ $ index ] as $ type => $ providerId ) { $ providers [ $ type ] = $ this -> getProvider ( $ index , $ type ) ; } return $ providers ; } 
public function getProvider ( $ index , $ type ) { if ( ! isset ( $ this -> providers [ $ index ] [ $ type ] ) ) { throw new \ InvalidArgumentException ( sprintf ( 'No provider was registered for index "%s" and type "%s".' , $ index , $ type ) ) ; } return $ this -> container -> get ( $ this -> providers [ $ index ] [ $ type ] ) ; } 
protected function setSorting ( ItemsEvent $ event ) { $ options = $ event -> options ; $ sortField = $ this -> getRequest ( ) -> get ( $ options [ 'sortFieldParameterName' ] ) ; if ( ! $ sortField && isset ( $ options [ 'defaultSortFieldName' ] ) ) { $ sortField = $ options [ 'defaultSortFieldName' ] ; } if ( ! empty ( $ sortField ) ) { $ event -> target -> getQuery ( ) -> setSort ( [ $ sortField => $ this -> getSort ( $ sortField , $ options ) , ] ) ; } } 
public function getResults ( $ offset , $ length ) { return new TransformedPartialResults ( $ this -> getElasticaResults ( $ offset , $ length ) , $ this -> transformer ) ; } 
protected function formatResult ( Result $ result , $ showField , $ showSource , $ showId , $ explain ) { $ source = $ result -> getSource ( ) ; if ( $ showField ) { $ toString = isset ( $ source [ $ showField ] ) ? $ source [ $ showField ] : '-' ; } else { $ toString = reset ( $ source ) ; } $ string = sprintf ( '[%0.2f] %s' , $ result -> getScore ( ) , var_export ( $ toString , true ) ) ; if ( $ showSource ) { $ string = sprintf ( '%s %s' , $ string , json_encode ( $ source ) ) ; } if ( $ showId ) { $ string = sprintf ( '{%s} %s' , $ result -> getId ( ) , $ string ) ; } if ( $ explain ) { $ string = sprintf ( '%s %s' , $ string , json_encode ( $ result -> getExplanation ( ) ) ) ; } return $ string ; } 
public function buildIndexMapping ( IndexConfigInterface $ indexConfig ) { $ typeMappings = [ ] ; foreach ( $ indexConfig -> getTypes ( ) as $ typeConfig ) { $ typeMappings [ $ typeConfig -> getName ( ) ] = $ this -> buildTypeMapping ( $ typeConfig ) ; } $ mapping = [ ] ; if ( ! empty ( $ typeMappings ) ) { $ mapping [ 'mappings' ] = $ typeMappings ; } 
public function buildIndexTemplateMapping ( IndexTemplateConfig $ indexTemplateConfig ) { $ mapping = $ this -> buildIndexMapping ( $ indexTemplateConfig ) ; $ mapping [ 'template' ] = $ indexTemplateConfig -> getTemplate ( ) ; return $ mapping ; } 
public function buildTypeMapping ( TypeConfig $ typeConfig ) { $ mapping = $ typeConfig -> getMapping ( ) ; if ( null !== $ typeConfig -> getDynamicDateFormats ( ) ) { $ mapping [ 'dynamic_date_formats' ] = $ typeConfig -> getDynamicDateFormats ( ) ; } if ( null !== $ typeConfig -> getDateDetection ( ) ) { $ mapping [ 'date_detection' ] = $ typeConfig -> getDateDetection ( ) ; } if ( null !== $ typeConfig -> getNumericDetection ( ) ) { $ mapping [ 'numeric_detection' ] = $ typeConfig -> getNumericDetection ( ) ; } if ( $ typeConfig -> getAnalyzer ( ) ) { $ mapping [ 'analyzer' ] = $ typeConfig -> getAnalyzer ( ) ; } if ( null !== $ typeConfig -> getDynamic ( ) ) { $ mapping [ 'dynamic' ] = $ typeConfig -> getDynamic ( ) ; } if ( isset ( $ mapping [ 'dynamic_templates' ] ) and empty ( $ mapping [ 'dynamic_templates' ] ) ) { unset ( $ mapping [ 'dynamic_templates' ] ) ; } $ this -> fixProperties ( $ mapping [ 'properties' ] ) ; if ( ! $ mapping [ 'properties' ] ) { unset ( $ mapping [ 'properties' ] ) ; } if ( $ typeConfig -> getModel ( ) ) { $ mapping [ '_meta' ] [ 'model' ] = $ typeConfig -> getModel ( ) ; } unset ( $ mapping [ '_parent' ] [ 'identifier' ] , $ mapping [ '_parent' ] [ 'property' ] ) ; if ( empty ( $ mapping ) ) { 
private function fixProperties ( & $ properties ) { foreach ( $ properties as $ name => & $ property ) { unset ( $ property [ 'property_path' ] ) ; if ( ! isset ( $ property [ 'type' ] ) ) { $ property [ 'type' ] = 'text' ; } if ( isset ( $ property [ 'fields' ] ) ) { $ this -> fixProperties ( $ property [ 'fields' ] ) ; } if ( isset ( $ property [ 'properties' ] ) ) { $ this -> fixProperties ( $ property [ 'properties' ] ) ; } } } 
public function process ( ContainerBuilder $ container ) { if ( ! $ container -> hasDefinition ( 'fos_elastica.pager_persister_registry' ) ) { return ; } $ registry = $ container -> getDefinition ( 'fos_elastica.pager_persister_registry' ) ; $ nameToServiceIdMap = [ ] ; foreach ( $ container -> findTaggedServiceIds ( 'fos_elastica.pager_persister' , true ) as $ id => $ attributes ) { foreach ( $ attributes as $ attribute ) { if ( ! isset ( $ attribute [ 'persisterName' ] ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Elastica pager persister "%s" must specify the "persisterName" attribute.' , $ id ) ) ; } $ persisterName = $ attribute [ 'persisterName' ] ; if ( isset ( $ nameToServiceIdMap [ $ persisterName ] ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Cannot register pager persister "%s". The pager persister "%s" has been registered for same name "%s"' , $ id , $ nameToServiceIdMap [ $ persisterName ] , $ persisterName ) ) ; } $ persisterDef = $ container -> getDefinition ( $ id ) ; if ( ! $ persisterDef -> getFactory ( ) && $ persisterDef -> getClass ( ) ) { 
private function assertClassImplementsPagerPersisterInterface ( $ persisterId , $ persisterClass ) { $ rc = new \ ReflectionClass ( $ persisterClass ) ; if ( ! $ rc -> implementsInterface ( PagerPersisterInterface :: class ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Elastica pager persister "%s" with class "%s" must implement "%s".' , $ persisterId , $ persisterClass , PagerPersisterInterface :: class ) ) ; } } 
public function logQuery ( $ path , $ method , $ data , $ queryTime , $ connection = [ ] , $ query = [ ] , $ engineTime = 0 , $ itemCount = 0 ) { $ executionMS = $ queryTime * 1000 ; if ( $ this -> debug ) { $ e = new \ Exception ( ) ; if ( is_string ( $ data ) ) { $ jsonStrings = explode ( "\n" , $ data ) ; $ data = [ ] ; foreach ( $ jsonStrings as $ json ) { if ( $ json != '' ) { $ data [ ] = json_decode ( $ json , true ) ; } } } else { $ data = [ $ data ] ; } $ this -> queries [ ] = [ 'path' => $ path , 'method' => $ method , 'data' => $ data , 'executionMS' => $ executionMS , 'engineMS' => $ engineTime , 'connection' => $ connection , 'queryString' => $ query , 'itemCount' => $ itemCount , 'backtrace' => $ e -> getTraceAsString ( ) , ] ; } if ( null !== $ this -> logger ) { $ message = sprintf ( '%s (%s) %0.2f ms' , $ path , $ method , $ executionMS ) ; $ this -> logger -> info ( $ message , ( array ) $ data ) ; } } 
public function insert ( PagerInterface $ pager , array $ options = array ( ) ) { $ pager -> setMaxPerPage ( empty ( $ options [ 'max_per_page' ] ) ? 100 : $ options [ 'max_per_page' ] ) ; $ options = array_replace ( [ 'max_per_page' => $ pager -> getMaxPerPage ( ) , 'first_page' => $ pager -> getCurrentPage ( ) , 'last_page' => $ pager -> getNbPages ( ) , ] , $ options ) ; $ pager -> setCurrentPage ( $ options [ 'first_page' ] ) ; $ objectPersister = $ this -> registry -> getPersister ( $ options [ 'indexName' ] , $ options [ 'typeName' ] ) ; try { $ event = new PrePersistEvent ( $ pager , $ objectPersister , $ options ) ; $ this -> dispatcher -> dispatch ( Events :: PRE_PERSIST , $ event ) ; $ pager = $ event -> getPager ( ) ; $ options = $ event -> getOptions ( ) ; $ lastPage = min ( $ options [ 'last_page' ] , $ pager -> getNbPages ( ) ) ; $ page = $ pager -> getCurrentPage ( ) ; do { $ pager -> setCurrentPage ( $ page ) ; $ this -> insertPage ( $ page , $ pager , $ objectPersister , $ options ) ; $ page ++ ; } while ( $ page <= $ lastPage ) ; } finally { $ event = new PostPersistEvent ( $ pager , $ objectPersister , $ options ) ; $ this -> dispatcher -> dispatch ( Events :: POST_PERSIST , $ event ) ; } } 
private function insertPage ( $ page , PagerInterface $ pager , ObjectPersisterInterface $ objectPersister , array $ options = array ( ) ) { $ pager -> setCurrentPage ( $ page ) ; $ event = new PreFetchObjectsEvent ( $ pager , $ objectPersister , $ options ) ; $ this -> dispatcher -> dispatch ( Events :: PRE_FETCH_OBJECTS , $ event ) ; $ pager = $ event -> getPager ( ) ; $ options = $ event -> getOptions ( ) ; $ objects = $ pager -> getCurrentPageResults ( ) ; if ( $ objects instanceof \ Traversable ) { $ objects = iterator_to_array ( $ objects ) ; } $ event = new PreInsertObjectsEvent ( $ pager , $ objectPersister , $ objects , $ options ) ; $ this -> dispatcher -> dispatch ( Events :: PRE_INSERT_OBJECTS , $ event ) ; $ pager = $ event -> getPager ( ) ; $ options = $ event -> getOptions ( ) ; $ objects = $ event -> getObjects ( ) ; try { if ( ! empty ( $ objects ) ) { $ objectPersister -> insertMany ( $ objects ) ; } $ event = new PostInsertObjectsEvent ( $ pager , $ objectPersister , $ objects , $ options ) ; $ this -> dispatcher -> dispatch ( Events :: POST_INSERT_OBJECTS , $ event ) ; } catch ( \ Exception $ e ) { $ event = new OnExceptionEvent ( $ pager , $ objectPersister , $ e , $ objects , $ options ) ; $ this -> dispatcher -> dispatch ( Events :: ON_EXCEPTION , $ event ) ; if ( $ event -> isIgnored ( ) ) { $ event = new PostInsertObjectsEvent ( $ pager , $ objectPersister , $ objects , $ options ) ; $ this -> dispatcher -> dispatch ( Events :: POST_INSERT_OBJECTS , $ event ) ; } else { $ e = $ event -> getException ( ) ; throw $ e ; } } } 
private function assertClassImplementsPagerProviderInterface ( $ providerId , $ providerClass ) { $ rc = new \ ReflectionClass ( $ providerClass ) ; if ( ! $ rc -> implementsInterface ( PagerProviderInterface :: class ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Elastica provider "%s" with class "%s" must implement "%s".' , $ providerId , $ providerClass , PagerProviderInterface :: class ) ) ; } } 
public function transformToElasticaDocument ( $ object ) { $ document = $ this -> transformer -> transform ( $ object , [ ] ) ; $ data = call_user_func ( $ this -> serializer , $ object ) ; $ document -> setData ( $ data ) ; return $ document ; } 
public function getTotalHits ( $ genuineTotal = false ) { if ( ! isset ( $ this -> totalHits ) ) { $ this -> totalHits = $ this -> searchable -> count ( $ this -> query ) ; } return $ this -> query -> hasParam ( 'size' ) && ! $ genuineTotal ? min ( $ this -> totalHits , ( int ) $ this -> query -> getParam ( 'size' ) ) : $ this -> totalHits ; } 
public function getAggregations ( ) { if ( ! isset ( $ this -> aggregations ) ) { $ this -> aggregations = $ this -> searchable -> search ( $ this -> query ) -> getAggregations ( ) ; } return $ this -> aggregations ; } 
public function getSuggests ( ) { if ( ! isset ( $ this -> suggests ) ) { $ this -> suggests = $ this -> searchable -> search ( $ this -> query ) -> getSuggests ( ) ; } return $ this -> suggests ; } 
protected function getElasticaResults ( $ offset , $ itemCountPerPage ) { $ offset = ( int ) $ offset ; $ itemCountPerPage = ( int ) $ itemCountPerPage ; $ size = $ this -> query -> hasParam ( 'size' ) ? ( int ) $ this -> query -> getParam ( 'size' ) : null ; if ( null !== $ size && $ size < $ offset + $ itemCountPerPage ) { $ itemCountPerPage = $ size - $ offset ; } if ( $ itemCountPerPage < 1 ) { throw new InvalidArgumentException ( '$itemCountPerPage must be greater than zero' ) ; } $ query = clone $ this -> query ; $ query -> setFrom ( $ offset ) ; $ query -> setSize ( $ itemCountPerPage ) ; $ resultSet = $ this -> searchable -> search ( $ query , $ this -> options ) ; $ this -> totalHits = $ resultSet -> getTotalHits ( ) ; $ this -> aggregations = $ resultSet -> getAggregations ( ) ; $ this -> suggests = $ resultSet -> getSuggests ( ) ; $ this -> maxScore = $ resultSet -> getMaxScore ( ) ; return $ resultSet ; } 
public function deleteTemplateIndexes ( IndexTemplateConfig $ template ) { $ this -> client -> request ( $ template -> getTemplate ( ) . '/' , Request :: DELETE ) ; } 
public function getIndex ( $ name = null ) { if ( null === $ name ) { return $ this -> defaultIndex ; } if ( ! isset ( $ this -> indexes [ $ name ] ) ) { throw new \ InvalidArgumentException ( sprintf ( 'The index "%s" does not exist' , $ name ) ) ; } return $ this -> indexes [ $ name ] ; } 
public function getPersister ( $ index , $ type ) { if ( ! isset ( $ this -> persisters [ $ index ] [ $ type ] ) ) { throw new \ InvalidArgumentException ( sprintf ( 'No persister was registered for index "%s" and type "%s".' , $ index , $ type ) ) ; } return $ this -> container -> get ( $ this -> persisters [ $ index ] [ $ type ] ) ; } 
private function populateIndex ( OutputInterface $ output , $ index , $ reset , $ options ) { $ event = new IndexPopulateEvent ( $ index , $ reset , $ options ) ; $ this -> dispatcher -> dispatch ( IndexPopulateEvent :: PRE_INDEX_POPULATE , $ event ) ; if ( $ event -> isReset ( ) ) { $ output -> writeln ( sprintf ( '<info>Resetting</info> <comment>%s</comment>' , $ index ) ) ; $ this -> resetter -> resetIndex ( $ index , true ) ; } $ types = array_keys ( $ this -> pagerProviderRegistry -> getIndexProviders ( $ index ) ) ; foreach ( $ types as $ type ) { $ this -> populateIndexType ( $ output , $ index , $ type , false , $ event -> getOptions ( ) ) ; } $ this -> dispatcher -> dispatch ( IndexPopulateEvent :: POST_INDEX_POPULATE , $ event ) ; $ this -> refreshIndex ( $ output , $ index ) ; } 
private function populateIndexType ( OutputInterface $ output , $ index , $ type , $ reset , $ options ) { $ event = new TypePopulateEvent ( $ index , $ type , $ reset , $ options ) ; $ this -> dispatcher -> dispatch ( TypePopulateEvent :: PRE_TYPE_POPULATE , $ event ) ; if ( $ event -> isReset ( ) ) { $ output -> writeln ( sprintf ( '<info>Resetting</info> <comment>%s/%s</comment>' , $ index , $ type ) ) ; $ this -> resetter -> resetIndexType ( $ index , $ type ) ; } $ offset = 1 < $ options [ 'first_page' ] ? ( $ options [ 'first_page' ] - 1 ) * $ options [ 'max_per_page' ] : 0 ; $ loggerClosure = ProgressClosureBuilder :: build ( $ output , 'Populating' , $ index , $ type , $ offset ) ; $ this -> dispatcher -> addListener ( Events :: ON_EXCEPTION , function ( OnExceptionEvent $ event ) use ( $ loggerClosure ) { $ loggerClosure ( count ( $ event -> getObjects ( ) ) , $ event -> getPager ( ) -> getNbResults ( ) , sprintf ( '<error>%s</error>' , $ event -> getException ( ) -> getMessage ( ) ) ) ; } ) ; $ this -> dispatcher -> addListener ( Events :: POST_INSERT_OBJECTS , function ( PostInsertObjectsEvent $ event ) use ( $ loggerClosure ) { $ loggerClosure ( count ( $ event -> getObjects ( ) ) , $ event -> getPager ( ) -> getNbResults ( ) ) ; } ) ; $ this -> dispatcher -> addListener ( Events :: POST_ASYNC_INSERT_OBJECTS , function ( PostAsyncInsertObjectsEvent $ event ) use ( $ loggerClosure ) { $ loggerClosure ( $ event -> getObjectsCount ( ) , $ event -> getPager ( ) -> getNbResults ( ) , $ event -> getErrorMessage ( ) ) ; } ) ; if ( $ options [ 'ignore_errors' ] ) { $ this -> dispatcher -> addListener ( Events :: ON_EXCEPTION , function ( OnExceptionEvent $ event ) { if ( $ event -> getException ( ) instanceof BulkResponseException ) { $ event -> setIgnore ( true ) ; } } ) ; } $ provider = $ this -> pagerProviderRegistry -> getProvider ( $ index , $ type ) ; $ pager = $ provider -> provide ( $ options ) ; $ options [ 'indexName' ] = $ index ; $ options [ 'typeName' ] = $ type ; $ this -> pagerPersister -> insert ( $ pager , $ options ) ; $ this -> dispatcher -> dispatch ( TypePopulateEvent :: POST_TYPE_POPULATE , $ event ) ; $ this -> refreshIndex ( $ output , $ index ) ; } 
private function refreshIndex ( OutputInterface $ output , $ index ) { $ output -> writeln ( sprintf ( '<info>Refreshing</info> <comment>%s</comment>' , $ index ) ) ; $ this -> indexManager -> getIndex ( $ index ) -> refresh ( ) ; } 
public function transform ( $ object , array $ fields ) { $ identifier = $ this -> propertyAccessor -> getValue ( $ object , $ this -> options [ 'identifier' ] ) ; if ( $ identifier && ! is_scalar ( $ identifier ) ) { $ identifier = ( string ) $ identifier ; } return $ this -> transformObjectToDocument ( $ object , $ fields , $ identifier ) ; } 
protected function transformNested ( $ objects , array $ fields ) { if ( is_array ( $ objects ) || $ objects instanceof \ Traversable || $ objects instanceof \ ArrayAccess ) { $ documents = [ ] ; foreach ( $ objects as $ object ) { $ document = $ this -> transformObjectToDocument ( $ object , $ fields ) ; $ documents [ ] = $ document -> getData ( ) ; } return $ documents ; } elseif ( null !== $ objects ) { $ document = $ this -> transformObjectToDocument ( $ objects , $ fields ) ; return $ document -> getData ( ) ; } return [ ] ; } 
protected function normalizeValue ( $ value ) { $ normalizeValue = function ( & $ v ) { if ( $ v instanceof \ DateTimeInterface ) { $ v = $ v -> format ( 'c' ) ; } elseif ( ! is_scalar ( $ v ) && ! is_null ( $ v ) ) { $ v = ( string ) $ v ; } } ; if ( is_array ( $ value ) || $ value instanceof \ Traversable || $ value instanceof \ ArrayAccess ) { $ value = is_array ( $ value ) ? $ value : iterator_to_array ( $ value , false ) ; array_walk_recursive ( $ value , $ normalizeValue ) ; } else { $ normalizeValue ( $ value ) ; } return $ value ; } 
protected function transformObjectToDocument ( $ object , array $ fields , $ identifier = '' ) { $ document = new Document ( $ identifier , [ ] , '' , $ this -> options [ 'index' ] ) ; if ( $ this -> dispatcher ) { $ event = new TransformEvent ( $ document , $ fields , $ object ) ; $ this -> dispatcher -> dispatch ( TransformEvent :: PRE_TRANSFORM , $ event ) ; $ document = $ event -> getDocument ( ) ; } foreach ( $ fields as $ key => $ mapping ) { if ( '_parent' == $ key ) { $ property = ( null !== $ mapping [ 'property' ] ) ? $ mapping [ 'property' ] : $ mapping [ 'type' ] ; $ value = $ this -> propertyAccessor -> getValue ( $ object , $ property ) ; $ document -> setParent ( $ this -> propertyAccessor -> getValue ( $ value , $ mapping [ 'identifier' ] ) ) ; continue ; } $ path = isset ( $ mapping [ 'property_path' ] ) ? $ mapping [ 'property_path' ] : $ key ; if ( false === $ path ) { continue ; } $ value = $ this -> propertyAccessor -> getValue ( $ object , $ path ) ; if ( isset ( $ mapping [ 'type' ] ) && in_array ( $ mapping [ 'type' ] , [ 'nested' , 'object' ] ) && isset ( $ mapping [ 'properties' ] ) && ! empty ( $ mapping [ 'properties' ] ) ) { $ document -> set ( $ key , $ this -> transformNested ( $ value , $ mapping [ 'properties' ] ) ) ; continue ; } if ( isset ( $ mapping [ 'type' ] ) && 'attachment' == $ mapping [ 'type' ] ) { 
protected function findByIdentifiers ( array $ identifierValues , $ hydrate ) { if ( empty ( $ identifierValues ) ) { return [ ] ; } $ hydrationMode = $ hydrate ? Query :: HYDRATE_OBJECT : Query :: HYDRATE_ARRAY ; $ qb = $ this -> getEntityQueryBuilder ( ) ; $ qb -> andWhere ( $ qb -> expr ( ) -> in ( static :: ENTITY_ALIAS . '.' . $ this -> options [ 'identifier' ] , ':values' ) ) -> setParameter ( 'values' , $ identifierValues ) ; $ query = $ qb -> getQuery ( ) ; foreach ( $ this -> options [ 'hints' ] as $ hint ) { $ query -> setHint ( $ hint [ 'name' ] , $ hint [ 'value' ] ) ; } return $ query -> setHydrationMode ( $ hydrationMode ) -> execute ( ) ; } 
protected function getEntityQueryBuilder ( ) { $ repository = $ this -> registry -> getManagerForClass ( $ this -> objectClass ) -> getRepository ( $ this -> objectClass ) ; return $ repository -> { $ this -> options [ 'query_builder_method' ] } ( static :: ENTITY_ALIAS ) ; } 
public function process ( ContainerBuilder $ container ) { if ( ! $ container -> hasDefinition ( 'fos_elastica.persister_registry' ) ) { return ; } $ defaultIndex = $ container -> getParameter ( 'fos_elastica.default_index' ) ; $ registry = $ container -> getDefinition ( 'fos_elastica.persister_registry' ) ; $ registeredPersisters = [ ] ; foreach ( $ container -> findTaggedServiceIds ( 'fos_elastica.persister' , true ) as $ id => $ attributes ) { foreach ( $ attributes as $ attribute ) { if ( ! isset ( $ attribute [ 'type' ] ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Elastica persister "%s" must specify the "type" attribute.' , $ id ) ) ; } $ index = isset ( $ attribute [ 'index' ] ) ? $ attribute [ 'index' ] : $ defaultIndex ; $ type = $ attribute [ 'type' ] ; if ( isset ( $ registeredPersisters [ $ index ] [ $ type ] ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Cannot register persister "%s". The persister "%s" has been registered for same index "%s" and type "%s"' , $ id , $ registeredPersisters [ $ index ] [ $ type ] , $ index , $ type ) ) ; } $ persisterDef = $ container -> getDefinition ( $ id ) ; if ( ! $ persisterDef -> getFactory ( ) && $ persisterDef -> getClass ( ) ) { 
private function assertClassImplementsPersisterInterface ( $ persisterId , $ persisterClass ) { $ rc = new \ ReflectionClass ( $ persisterClass ) ; if ( ! $ rc -> implementsInterface ( ObjectPersisterInterface :: class ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Elastica persister "%s" with class "%s" must implement "%s".' , $ persisterId , $ persisterClass , ObjectPersisterInterface :: class ) ) ; } } 
public function transform ( array $ elasticaObjects ) { $ sorted = [ ] ; foreach ( $ elasticaObjects as $ object ) { $ sorted [ $ object -> getType ( ) ] [ ] = $ object ; } $ transformed = [ ] ; foreach ( $ sorted as $ type => $ objects ) { $ transformedObjects = $ this -> transformers [ $ type ] -> transform ( $ objects ) ; $ identifierGetter = 'get' . ucfirst ( $ this -> transformers [ $ type ] -> getIdentifierField ( ) ) ; $ transformed [ $ type ] = array_combine ( array_map ( function ( $ o ) use ( $ identifierGetter ) { return $ o -> $ identifierGetter ( ) ; } , $ transformedObjects ) , $ transformedObjects ) ; } $ result = [ ] ; foreach ( $ elasticaObjects as $ object ) { if ( array_key_exists ( ( string ) $ object -> getId ( ) , $ transformed [ $ object -> getType ( ) ] ) ) { $ result [ ] = $ transformed [ $ object -> getType ( ) ] [ ( string ) $ object -> getId ( ) ] ; } } return $ result ; } 
public function process ( ContainerBuilder $ container ) { if ( ! $ container -> hasDefinition ( 'fos_elastica.index_manager' ) ) { return ; } $ indexes = [ ] ; foreach ( $ container -> findTaggedServiceIds ( 'fos_elastica.index' ) as $ id => $ tags ) { foreach ( $ tags as $ tag ) { $ indexes [ $ tag [ 'name' ] ] = new Reference ( $ id ) ; } } $ container -> getDefinition ( 'fos_elastica.index_manager' ) -> replaceArgument ( 0 , $ indexes ) ; } 
public function find ( $ query , $ limit = null , $ options = [ ] ) { $ results = $ this -> search ( $ query , $ limit , $ options ) ; return $ this -> transformer -> transform ( $ results ) ; } 
public function findHybrid ( $ query , $ limit = null , $ options = [ ] ) { $ results = $ this -> search ( $ query , $ limit , $ options ) ; return $ this -> transformer -> hybridTransform ( $ results ) ; } 
public function findPaginated ( $ query , $ options = [ ] ) { $ queryObject = Query :: create ( $ query ) ; $ paginatorAdapter = $ this -> createPaginatorAdapter ( $ queryObject , $ options ) ; return new Pagerfanta ( new FantaPaginatorAdapter ( $ paginatorAdapter ) ) ; } 
public function createPaginatorAdapter ( $ query , $ options = [ ] ) { $ query = Query :: create ( $ query ) ; return new TransformedPaginatorAdapter ( $ this -> searchable , $ query , $ options , $ this -> transformer ) ; } 
public function createHybridPaginatorAdapter ( $ query ) { $ query = Query :: create ( $ query ) ; return new HybridPaginatorAdapter ( $ this -> searchable , $ query , $ this -> transformer ) ; } 
public function createRawPaginatorAdapter ( $ query , $ options = [ ] ) { $ query = Query :: create ( $ query ) ; return new RawPaginatorAdapter ( $ this -> searchable , $ query , $ options ) ; } 
protected function search ( $ query , $ limit = null , $ options = [ ] ) { $ queryObject = Query :: create ( $ query ) ; if ( null !== $ limit ) { $ queryObject -> setSize ( $ limit ) ; } $ results = $ this -> searchable -> search ( $ queryObject , $ options ) -> getResults ( ) ; return $ results ; } 
public function getIndexTemplate ( $ name ) { if ( ! isset ( $ this -> templates [ $ name ] ) ) { throw new \ InvalidArgumentException ( sprintf ( 'The index template "%s" does not exist' , $ name ) ) ; } return $ this -> templates [ $ name ] ; } 
public function build ( ContainerBuilder $ container ) { parent :: build ( $ container ) ; $ container -> addCompilerPass ( new ConfigSourcePass ( ) ) ; $ container -> addCompilerPass ( new IndexPass ( ) ) ; $ container -> addCompilerPass ( new RegisterPagerProvidersPass ( ) ) ; $ container -> addCompilerPass ( new RegisterPersistersPass ( ) ) ; $ container -> addCompilerPass ( new RegisterPagerPersistersPass ( ) ) ; $ container -> addCompilerPass ( new TransformerPass ( ) ) ; } 
public function getResults ( $ offset , $ length ) { return new HybridPartialResults ( $ this -> getElasticaResults ( $ offset , $ length ) , $ this -> transformer ) ; } 
public function resetAllIndexes ( $ populating = false , $ force = false ) { foreach ( $ this -> configManager -> getIndexNames ( ) as $ name ) { $ this -> resetIndex ( $ name , $ populating , $ force ) ; } } 
public function resetIndex ( $ indexName , $ populating = false , $ force = false ) { $ indexConfig = $ this -> configManager -> getIndexConfiguration ( $ indexName ) ; $ index = $ this -> indexManager -> getIndex ( $ indexName ) ; if ( $ indexConfig -> isUseAlias ( ) ) { $ this -> aliasProcessor -> setRootName ( $ indexConfig , $ index ) ; } $ event = new IndexResetEvent ( $ indexName , $ populating , $ force ) ; $ this -> dispatcher -> dispatch ( IndexResetEvent :: PRE_INDEX_RESET , $ event ) ; $ mapping = $ this -> mappingBuilder -> buildIndexMapping ( $ indexConfig ) ; $ index -> create ( $ mapping , true ) ; if ( ! $ populating and $ indexConfig -> isUseAlias ( ) ) { $ this -> aliasProcessor -> switchIndexAlias ( $ indexConfig , $ index , $ force ) ; } $ this -> dispatcher -> dispatch ( IndexResetEvent :: POST_INDEX_RESET , $ event ) ; } 
public function resetIndexType ( $ indexName , $ typeName ) { $ typeConfig = $ this -> configManager -> getTypeConfiguration ( $ indexName , $ typeName ) ; $ this -> resetIndex ( $ indexName , true ) ; $ index = $ this -> indexManager -> getIndex ( $ indexName ) ; $ type = $ index -> getType ( $ typeName ) ; $ event = new TypeResetEvent ( $ indexName , $ typeName ) ; $ this -> dispatcher -> dispatch ( TypeResetEvent :: PRE_TYPE_RESET , $ event ) ; $ mapping = new Mapping ( ) ; foreach ( $ this -> mappingBuilder -> buildTypeMapping ( $ typeConfig ) as $ name => $ field ) { $ mapping -> setParam ( $ name , $ field ) ; } $ type -> setMapping ( $ mapping ) ; $ this -> dispatcher -> dispatch ( TypeResetEvent :: POST_TYPE_RESET , $ event ) ; } 
public function switchIndexAlias ( $ indexName , $ delete = true ) { $ indexConfig = $ this -> configManager -> getIndexConfiguration ( $ indexName ) ; if ( $ indexConfig -> isUseAlias ( ) ) { $ index = $ this -> indexManager -> getIndex ( $ indexName ) ; $ this -> aliasProcessor -> switchIndexAlias ( $ indexConfig , $ index , false , $ delete ) ; } } 
public function getPagerPersister ( $ name ) { if ( ! isset ( $ this -> nameToServiceIdMap [ $ name ] ) ) { throw new \ InvalidArgumentException ( sprintf ( 'No pager persister was registered for the give name "%s".' , $ name ) ) ; } $ serviceId = $ this -> nameToServiceIdMap [ $ name ] ; $ pagerPersister = $ this -> container -> get ( $ serviceId ) ; if ( ! $ pagerPersister instanceof PagerPersisterInterface ) { throw new \ LogicException ( sprintf ( 'The pager provider service "%s" must implement "%s" interface but it is an instance of "%s" class.' , $ serviceId , PagerPersisterInterface :: class , get_class ( $ pagerPersister ) ) ) ; } return $ pagerPersister ; } 
private function loadIndexes ( array $ indexes , ContainerBuilder $ container ) { $ indexableCallbacks = [ ] ; foreach ( $ indexes as $ name => $ index ) { $ indexId = sprintf ( 'fos_elastica.index.%s' , $ name ) ; $ indexName = isset ( $ index [ 'index_name' ] ) ? $ index [ 'index_name' ] : $ name ; $ indexDef = new ChildDefinition ( 'fos_elastica.index_prototype' ) ; $ indexDef -> setFactory ( [ new Reference ( 'fos_elastica.client' ) , 'getIndex' ] ) ; $ indexDef -> replaceArgument ( 0 , $ indexName ) ; $ indexDef -> addTag ( 'fos_elastica.index' , [ 'name' => $ name , ] ) ; if ( isset ( $ index [ 'client' ] ) ) { $ client = $ this -> getClient ( $ index [ 'client' ] ) ; $ indexDef -> setFactory ( [ $ client , 'getIndex' ] ) ; } $ container -> setDefinition ( $ indexId , $ indexDef ) ; $ reference = new Reference ( $ indexId ) ; $ this -> indexConfigs [ $ name ] = [ 'elasticsearch_name' => $ indexName , 'reference' => $ reference , 'name' => $ name , 'settings' => $ index [ 'settings' ] , 'type_prototype' => isset ( $ index [ 'type_prototype' ] ) ? $ index [ 'type_prototype' ] : [ ] , 'use_alias' => $ index [ 'use_alias' ] , ] ; if ( $ index [ 'finder' ] ) { $ this -> loadIndexFinder ( $ container , $ name , $ reference ) ; } $ this -> loadTypes ( ( array ) $ index [ 'types' ] , $ container , $ this -> indexConfigs [ $ name ] , $ indexableCallbacks ) ; } $ indexable = $ container -> getDefinition ( 'fos_elastica.indexable' ) ; $ indexable -> replaceArgument ( 0 , $ indexableCallbacks ) ; } 
private function loadIndexTemplates ( array $ indexTemplates , ContainerBuilder $ container ) { $ indexableCallbacks = array ( ) ; foreach ( $ indexTemplates as $ name => $ indexTemplate ) { $ indexId = sprintf ( 'fos_elastica.index_template.%s' , $ name ) ; $ indexTemplateName = isset ( $ indexTemplate [ 'template_name' ] ) ? $ indexTemplate [ 'template_name' ] : $ name ; $ indexDef = new ChildDefinition ( 'fos_elastica.index_template_prototype' ) ; $ indexDef -> setFactory ( [ new Reference ( 'fos_elastica.client' ) , 'getIndexTemplate' ] ) ; $ indexDef -> replaceArgument ( 0 , $ indexTemplateName ) ; $ indexDef -> addTag ( 'fos_elastica.index_template' , array ( 'name' => $ name , ) ) ; if ( isset ( $ indexTemplate [ 'client' ] ) ) { $ client = $ this -> getClient ( $ indexTemplate [ 'client' ] ) ; $ indexDef -> setFactory ( [ $ client , 'getIndexTemplate' ] ) ; } $ container -> setDefinition ( $ indexId , $ indexDef ) ; $ reference = new Reference ( $ indexId ) ; $ this -> indexTemplateConfigs [ $ name ] = array ( 'elasticsearch_name' => $ indexTemplateName , 'reference' => $ reference , 'name' => $ name , 'settings' => $ indexTemplate [ 'settings' ] , 'template' => $ indexTemplate [ 'template' ] , ) ; $ this -> loadTypes ( ( array ) $ indexTemplate [ 'types' ] , $ container , $ this -> indexTemplateConfigs [ $ name ] , $ indexableCallbacks ) ; } if ( $ indexableCallbacks ) { throw new \ RuntimeException ( '`indexable_callback` option is not supported by index templates' ) ; } } 
private function loadIndexFinder ( ContainerBuilder $ container , $ name , Reference $ index ) { $ transformerId = sprintf ( 'fos_elastica.elastica_to_model_transformer.collection.%s' , $ name ) ; $ transformerDef = new ChildDefinition ( 'fos_elastica.elastica_to_model_transformer.collection' ) ; $ container -> setDefinition ( $ transformerId , $ transformerDef ) ; $ finderId = sprintf ( 'fos_elastica.finder.%s' , $ name ) ; $ finderDef = new ChildDefinition ( 'fos_elastica.finder' ) ; $ finderDef -> replaceArgument ( 0 , $ index ) ; $ finderDef -> replaceArgument ( 1 , new Reference ( $ transformerId ) ) ; $ container -> setDefinition ( $ finderId , $ finderDef ) ; } 
private function loadTypes ( array $ types , ContainerBuilder $ container , array & $ indexConfig , array & $ indexableCallbacks ) { foreach ( $ types as $ name => $ type ) { $ indexName = $ indexConfig [ 'name' ] ; $ typeId = sprintf ( '%s.%s' , $ indexConfig [ 'reference' ] , $ name ) ; $ typeDef = new ChildDefinition ( 'fos_elastica.type_prototype' ) ; $ typeDef -> setFactory ( [ $ indexConfig [ 'reference' ] , 'getType' ] ) ; $ typeDef -> replaceArgument ( 0 , $ name ) ; $ container -> setDefinition ( $ typeId , $ typeDef ) ; $ typeConfig = [ 'name' => $ name , 'mapping' => [ ] , 
private function loadTypePersistenceIntegration ( array $ typeConfig , ContainerBuilder $ container , Reference $ typeRef , $ indexName , $ typeName ) { if ( isset ( $ typeConfig [ 'driver' ] ) ) { $ this -> loadDriver ( $ container , $ typeConfig [ 'driver' ] ) ; } $ elasticaToModelTransformerId = $ this -> loadElasticaToModelTransformer ( $ typeConfig , $ container , $ indexName , $ typeName ) ; $ modelToElasticaTransformerId = $ this -> loadModelToElasticaTransformer ( $ typeConfig , $ container , $ indexName , $ typeName ) ; $ objectPersisterId = $ this -> loadObjectPersister ( $ typeConfig , $ typeRef , $ container , $ indexName , $ typeName , $ modelToElasticaTransformerId ) ; if ( isset ( $ typeConfig [ 'provider' ] ) ) { $ this -> loadTypePagerProvider ( $ typeConfig , $ container , $ indexName , $ typeName ) ; } if ( isset ( $ typeConfig [ 'finder' ] ) ) { $ this -> loadTypeFinder ( $ typeConfig , $ container , $ elasticaToModelTransformerId , $ typeRef , $ indexName , $ typeName ) ; } if ( isset ( $ typeConfig [ 'listener' ] ) && $ typeConfig [ 'listener' ] [ 'enabled' ] ) { $ this -> loadTypeListener ( $ typeConfig , $ container , $ objectPersisterId , $ indexName , $ typeName ) ; } } 
private function loadElasticaToModelTransformer ( array $ typeConfig , ContainerBuilder $ container , $ indexName , $ typeName ) { if ( isset ( $ typeConfig [ 'elastica_to_model_transformer' ] [ 'service' ] ) ) { return $ typeConfig [ 'elastica_to_model_transformer' ] [ 'service' ] ; } $ abstractId = sprintf ( 'fos_elastica.elastica_to_model_transformer.prototype.%s' , $ typeConfig [ 'driver' ] ) ; $ serviceId = sprintf ( 'fos_elastica.elastica_to_model_transformer.%s.%s' , $ indexName , $ typeName ) ; $ serviceDef = new ChildDefinition ( $ abstractId ) ; $ serviceDef -> addTag ( 'fos_elastica.elastica_to_model_transformer' , [ 'type' => $ typeName , 'index' => $ indexName ] ) ; $ serviceDef -> replaceArgument ( 1 , $ typeConfig [ 'model' ] ) ; $ serviceDef -> replaceArgument ( 2 , array_merge ( $ typeConfig [ 'elastica_to_model_transformer' ] , [ 'identifier' => $ typeConfig [ 'identifier' ] , ] ) ) ; $ container -> setDefinition ( $ serviceId , $ serviceDef ) ; return $ serviceId ; } 
private function loadModelToElasticaTransformer ( array $ typeConfig , ContainerBuilder $ container , $ indexName , $ typeName ) { if ( isset ( $ typeConfig [ 'model_to_elastica_transformer' ] [ 'service' ] ) ) { return $ typeConfig [ 'model_to_elastica_transformer' ] [ 'service' ] ; } $ abstractId = $ container -> hasDefinition ( 'fos_elastica.serializer_callback_prototype' ) ? 'fos_elastica.model_to_elastica_identifier_transformer' : 'fos_elastica.model_to_elastica_transformer' ; $ serviceId = sprintf ( 'fos_elastica.model_to_elastica_transformer.%s.%s' , $ indexName , $ typeName ) ; $ serviceDef = new ChildDefinition ( $ abstractId ) ; $ serviceDef -> replaceArgument ( 0 , [ 'identifier' => $ typeConfig [ 'identifier' ] , 'index' => $ indexName , ] ) ; $ container -> setDefinition ( $ serviceId , $ serviceDef ) ; return $ serviceId ; } 
private function loadObjectPersister ( array $ typeConfig , Reference $ typeRef , ContainerBuilder $ container , $ indexName , $ typeName , $ transformerId ) { if ( isset ( $ typeConfig [ 'persister' ] [ 'service' ] ) ) { return $ typeConfig [ 'persister' ] [ 'service' ] ; } $ arguments = [ $ typeRef , new Reference ( $ transformerId ) , $ typeConfig [ 'model' ] , ] ; if ( $ container -> hasDefinition ( 'fos_elastica.serializer_callback_prototype' ) ) { $ abstractId = 'fos_elastica.object_serializer_persister' ; $ callbackId = sprintf ( '%s.%s.serializer.callback' , $ this -> indexConfigs [ $ indexName ] [ 'reference' ] , $ typeName ) ; $ arguments [ ] = [ new Reference ( $ callbackId ) , 'serialize' ] ; } else { $ abstractId = 'fos_elastica.object_persister' ; $ mapping = $ this -> indexConfigs [ $ indexName ] [ 'types' ] [ $ typeName ] [ 'mapping' ] ; $ argument = $ mapping [ 'properties' ] ; if ( isset ( $ mapping [ '_parent' ] ) ) { $ argument [ '_parent' ] = $ mapping [ '_parent' ] ; } $ arguments [ ] = $ argument ; } $ arguments [ ] = array_intersect_key ( $ typeConfig [ 'persister' ] , array_flip ( [ 'refresh' ] ) ) ; $ serviceId = sprintf ( 'fos_elastica.object_persister.%s.%s' , $ indexName , $ typeName ) ; $ serviceDef = new ChildDefinition ( $ abstractId ) ; foreach ( $ arguments as $ i => $ argument ) { $ serviceDef -> replaceArgument ( $ i , $ argument ) ; } $ serviceDef -> addTag ( 'fos_elastica.persister' , [ 'index' => $ indexName , 'type' => $ typeName ] ) ; $ container -> setDefinition ( $ serviceId , $ serviceDef ) ; return $ serviceId ; } 
private function loadTypePagerProvider ( array $ typeConfig , ContainerBuilder $ container , $ indexName , $ typeName ) { if ( isset ( $ typeConfig [ 'provider' ] [ 'service' ] ) ) { return $ typeConfig [ 'provider' ] [ 'service' ] ; } $ baseConfig = $ typeConfig [ 'provider' ] ; unset ( $ baseConfig [ 'service' ] ) ; $ driver = $ typeConfig [ 'driver' ] ; switch ( $ driver ) { case 'orm' : $ providerDef = new ChildDefinition ( 'fos_elastica.pager_provider.prototype.' . $ driver ) ; $ providerDef -> replaceArgument ( 2 , $ typeConfig [ 'model' ] ) ; $ providerDef -> replaceArgument ( 3 , $ baseConfig ) ; break ; case 'mongodb' : $ providerDef = new ChildDefinition ( 'fos_elastica.pager_provider.prototype.' . $ driver ) ; $ providerDef -> replaceArgument ( 2 , $ typeConfig [ 'model' ] ) ; $ providerDef -> replaceArgument ( 3 , $ baseConfig ) ; break ; case 'phpcr' : $ providerDef = new ChildDefinition ( 'fos_elastica.pager_provider.prototype.' . $ driver ) ; $ providerDef -> replaceArgument ( 2 , $ typeConfig [ 'model' ] ) ; $ providerDef -> replaceArgument ( 3 , $ baseConfig ) ; break ; default : throw new \ LogicException ( sprintf ( 'The pager provider for driver "%s" does not exist.' , $ driver ) ) ; } $ providerId = sprintf ( 'fos_elastica.pager_provider.%s.%s' , $ indexName , $ typeName ) ; $ providerDef -> addTag ( 'fos_elastica.pager_provider' , [ 'index' => $ indexName , 'type' => $ typeName ] ) ; $ container -> setDefinition ( $ providerId , $ providerDef ) ; return $ providerId ; } 
private function loadTypeListener ( array $ typeConfig , ContainerBuilder $ container , $ objectPersisterId , $ indexName , $ typeName ) { if ( isset ( $ typeConfig [ 'listener' ] [ 'service' ] ) ) { return $ typeConfig [ 'listener' ] [ 'service' ] ; } $ abstractListenerId = sprintf ( 'fos_elastica.listener.prototype.%s' , $ typeConfig [ 'driver' ] ) ; $ listenerId = sprintf ( 'fos_elastica.listener.%s.%s' , $ indexName , $ typeName ) ; $ listenerDef = new ChildDefinition ( $ abstractListenerId ) ; $ listenerDef -> replaceArgument ( 0 , new Reference ( $ objectPersisterId ) ) ; $ listenerDef -> replaceArgument ( 3 , $ typeConfig [ 'listener' ] [ 'logger' ] ? new Reference ( $ typeConfig [ 'listener' ] [ 'logger' ] ) : null ) ; $ listenerConfig = [ 'identifier' => $ typeConfig [ 'identifier' ] , 'indexName' => $ indexName , 'typeName' => $ typeName , ] ; $ tagName = null ; switch ( $ typeConfig [ 'driver' ] ) { case 'orm' : $ tagName = 'doctrine.event_listener' ; break ; case 'phpcr' : $ tagName = 'doctrine_phpcr.event_listener' ; break ; case 'mongodb' : $ tagName = 'doctrine_mongodb.odm.event_listener' ; break ; } if ( $ typeConfig [ 'listener' ] [ 'defer' ] ) { $ listenerDef -> setPublic ( true ) ; $ listenerDef -> addTag ( 'kernel.event_listener' , [ 'event' => 'kernel.terminate' , 'method' => 'onTerminate' ] ) ; $ listenerDef -> addTag ( 'kernel.event_listener' , [ 'event' => 'console.terminate' , 'method' => 'onTerminate' ] ) ; $ listenerConfig [ 'defer' ] = true ; } $ listenerDef -> replaceArgument ( 2 , $ listenerConfig ) ; if ( null !== $ tagName ) { foreach ( $ this -> getDoctrineEvents ( $ typeConfig ) as $ event ) { $ listenerDef -> addTag ( $ tagName , [ 'event' => $ event ] ) ; } } $ container -> setDefinition ( $ listenerId , $ listenerDef ) ; return $ listenerId ; } 
private function getDoctrineEvents ( array $ typeConfig ) { switch ( $ typeConfig [ 'driver' ] ) { case 'orm' : $ eventsClass = '\Doctrine\ORM\Events' ; break ; case 'phpcr' : $ eventsClass = '\Doctrine\ODM\PHPCR\Event' ; break ; case 'mongodb' : $ eventsClass = '\Doctrine\ODM\MongoDB\Events' ; break ; default : throw new \ InvalidArgumentException ( sprintf ( 'Cannot determine events for driver "%s"' , $ typeConfig [ 'driver' ] ) ) ; } $ events = [ ] ; $ eventMapping = [ 'insert' => [ constant ( $ eventsClass . '::postPersist' ) ] , 'update' => [ constant ( $ eventsClass . '::postUpdate' ) ] , 'delete' => [ constant ( $ eventsClass . '::preRemove' ) ] , 'flush' => [ constant ( $ eventsClass . '::postFlush' ) ] , ] ; foreach ( $ eventMapping as $ event => $ doctrineEvents ) { if ( isset ( $ typeConfig [ 'listener' ] [ $ event ] ) && $ typeConfig [ 'listener' ] [ $ event ] ) { $ events = array_merge ( $ events , $ doctrineEvents ) ; } } return $ events ; } 
private function loadTypeFinder ( array $ typeConfig , ContainerBuilder $ container , $ elasticaToModelId , Reference $ typeRef , $ indexName , $ typeName ) { if ( isset ( $ typeConfig [ 'finder' ] [ 'service' ] ) ) { $ finderId = $ typeConfig [ 'finder' ] [ 'service' ] ; } else { $ finderId = sprintf ( 'fos_elastica.finder.%s.%s' , $ indexName , $ typeName ) ; $ finderDef = new ChildDefinition ( 'fos_elastica.finder' ) ; $ finderDef -> replaceArgument ( 0 , $ typeRef ) ; $ finderDef -> replaceArgument ( 1 , new Reference ( $ elasticaToModelId ) ) ; $ container -> setDefinition ( $ finderId , $ finderDef ) ; } $ indexTypeName = "$indexName/$typeName" ; $ arguments = [ $ indexTypeName , new Reference ( $ finderId ) ] ; if ( isset ( $ typeConfig [ 'repository' ] ) ) { $ arguments [ ] = $ typeConfig [ 'repository' ] ; } $ container -> getDefinition ( 'fos_elastica.repository_manager' ) -> addMethodCall ( 'addType' , $ arguments ) ; $ managerId = sprintf ( 'fos_elastica.manager.%s' , $ typeConfig [ 'driver' ] ) ; $ container -> getDefinition ( $ managerId ) -> addMethodCall ( 'addEntity' , [ $ typeConfig [ 'model' ] , $ indexTypeName ] ) ; return $ finderId ; } 
private function loadIndexManager ( ContainerBuilder $ container ) { $ indexRefs = array_map ( function ( $ index ) { return $ index [ 'reference' ] ; } , $ this -> indexConfigs ) ; $ managerDef = $ container -> getDefinition ( 'fos_elastica.index_manager' ) ; $ managerDef -> replaceArgument ( 0 , $ indexRefs ) ; } 
private function loadIndexTemplateManager ( ContainerBuilder $ container ) { $ indexTemplateRefs = array_map ( function ( $ index ) { return $ index [ 'reference' ] ; } , $ this -> indexTemplateConfigs ) ; $ managerDef = $ container -> getDefinition ( 'fos_elastica.index_template_manager' ) ; $ managerDef -> replaceArgument ( 0 , $ indexTemplateRefs ) ; } 
private function loadDriver ( ContainerBuilder $ container , $ driver ) { if ( in_array ( $ driver , $ this -> loadedDrivers ) ) { return ; } $ loader = new XmlFileLoader ( $ container , new FileLocator ( __DIR__ . '/../Resources/config' ) ) ; $ loader -> load ( $ driver . '.xml' ) ; $ this -> loadedDrivers [ ] = $ driver ; } 
private function loadSerializer ( $ config , ContainerBuilder $ container ) { $ container -> setAlias ( 'fos_elastica.serializer' , $ config [ 'serializer' ] ) ; $ serializer = $ container -> getDefinition ( 'fos_elastica.serializer_callback_prototype' ) ; $ serializer -> setClass ( $ config [ 'callback_class' ] ) ; if ( is_subclass_of ( $ config [ 'callback_class' ] , ContainerAwareInterface :: class ) ) { $ serializer -> addMethodCall ( 'setContainer' , [ new Reference ( 'service_container' ) ] ) ; } } 
private function createDefaultManagerAlias ( $ defaultManager , ContainerBuilder $ container ) { if ( 0 == count ( $ this -> loadedDrivers ) ) { return ; } if ( count ( $ this -> loadedDrivers ) > 1 && in_array ( $ defaultManager , $ this -> loadedDrivers ) ) { $ defaultManagerService = $ defaultManager ; } else { $ defaultManagerService = $ this -> loadedDrivers [ 0 ] ; } $ container -> setAlias ( 'fos_elastica.manager' , sprintf ( 'fos_elastica.manager.%s' , $ defaultManagerService ) ) ; $ container -> getAlias ( 'fos_elastica.manager' ) -> setPublic ( true ) ; $ container -> setAlias ( RepositoryManagerInterface :: class , 'fos_elastica.manager' ) ; $ container -> getAlias ( RepositoryManagerInterface :: class ) -> setPublic ( false ) ; } 
public function getConfigTreeBuilder ( ) { $ treeBuilder = new TreeBuilder ( 'fos_elastica' ) ; if ( method_exists ( $ treeBuilder , 'getRootNode' ) ) { $ rootNode = $ treeBuilder -> getRootNode ( ) ; } else { 
private function getDynamicTemplateNode ( ) { $ node = $ this -> createTreeBuilderNode ( 'dynamic_templates' ) ; $ node -> prototype ( 'array' ) -> prototype ( 'array' ) -> children ( ) -> scalarNode ( 'match' ) -> end ( ) -> scalarNode ( 'unmatch' ) -> end ( ) -> scalarNode ( 'match_mapping_type' ) -> end ( ) -> scalarNode ( 'path_match' ) -> end ( ) -> scalarNode ( 'path_unmatch' ) -> end ( ) -> scalarNode ( 'match_pattern' ) -> end ( ) -> arrayNode ( 'mapping' ) -> prototype ( 'variable' ) -> treatNullLike ( [ ] ) -> end ( ) -> end ( ) -> end ( ) -> end ( ) -> end ( ) ; return $ node ; } 
private function getTypesNode ( ) { $ node = $ this -> createTreeBuilderNode ( 'types' ) ; $ node -> useAttributeAsKey ( 'name' ) -> prototype ( 'array' ) -> treatNullLike ( [ ] ) -> beforeNormalization ( ) -> ifNull ( ) -> thenEmptyArray ( ) -> end ( ) 
private function getIdNode ( ) { $ node = $ this -> createTreeBuilderNode ( '_id' ) ; $ node -> children ( ) -> scalarNode ( 'path' ) -> end ( ) -> end ( ) ; return $ node ; } 
private function getSourceNode ( ) { $ node = $ this -> createTreeBuilderNode ( '_source' ) ; $ node -> children ( ) -> arrayNode ( 'excludes' ) -> useAttributeAsKey ( 'name' ) -> prototype ( 'scalar' ) -> end ( ) -> end ( ) -> arrayNode ( 'includes' ) -> useAttributeAsKey ( 'name' ) -> prototype ( 'scalar' ) -> end ( ) -> end ( ) -> scalarNode ( 'compress' ) -> end ( ) -> scalarNode ( 'compress_threshold' ) -> end ( ) -> scalarNode ( 'enabled' ) -> defaultTrue ( ) -> end ( ) -> end ( ) ; return $ node ; } 
private function getRoutingNode ( ) { $ node = $ this -> createTreeBuilderNode ( '_routing' ) ; $ node -> children ( ) -> scalarNode ( 'required' ) -> end ( ) -> scalarNode ( 'path' ) -> end ( ) -> end ( ) ; return $ node ; } 
private function getParentNode ( ) { $ node = $ this -> createTreeBuilderNode ( '_parent' ) ; $ node -> children ( ) -> scalarNode ( 'type' ) -> end ( ) -> scalarNode ( 'property' ) -> defaultValue ( null ) -> end ( ) -> scalarNode ( 'identifier' ) -> defaultValue ( 'id' ) -> end ( ) -> end ( ) ; return $ node ; } 
private function getAllNode ( ) { $ node = $ this -> createTreeBuilderNode ( '_all' ) ; $ node -> children ( ) -> scalarNode ( 'enabled' ) -> defaultValue ( true ) -> end ( ) -> scalarNode ( 'analyzer' ) -> end ( ) -> end ( ) ; return $ node ; } 
private function addClientsSection ( ArrayNodeDefinition $ rootNode ) { $ rootNode -> fixXmlConfig ( 'client' ) -> children ( ) -> arrayNode ( 'clients' ) -> useAttributeAsKey ( 'id' ) -> prototype ( 'array' ) -> performNoDeepMerging ( ) 
private function addIndexesSection ( ArrayNodeDefinition $ rootNode ) { $ rootNode -> fixXmlConfig ( 'index' ) -> children ( ) -> arrayNode ( 'indexes' ) -> useAttributeAsKey ( 'name' ) -> prototype ( 'array' ) -> children ( ) -> scalarNode ( 'index_name' ) -> info ( 'Defaults to the name of the index, but can be modified if the index name is different in ElasticSearch' ) -> end ( ) -> booleanNode ( 'use_alias' ) -> defaultValue ( false ) -> end ( ) -> scalarNode ( 'client' ) -> end ( ) -> scalarNode ( 'finder' ) -> treatNullLike ( true ) -> defaultFalse ( ) -> end ( ) -> arrayNode ( 'type_prototype' ) -> children ( ) -> scalarNode ( 'analyzer' ) -> end ( ) -> append ( $ this -> getPersistenceNode ( ) ) -> append ( $ this -> getSerializerNode ( ) ) -> end ( ) -> end ( ) -> variableNode ( 'settings' ) -> defaultValue ( [ ] ) -> end ( ) -> end ( ) -> append ( $ this -> getTypesNode ( ) ) -> end ( ) -> end ( ) -> end ( ) ; } 
private function addIndexTemplatesSection ( ArrayNodeDefinition $ rootNode ) { $ rootNode -> fixXmlConfig ( 'index_template' ) -> children ( ) -> arrayNode ( 'index_templates' ) -> useAttributeAsKey ( 'name' ) -> prototype ( 'array' ) -> children ( ) -> scalarNode ( 'template_name' ) -> info ( 'Defaults to the name of the index template, but can be modified if the index name is different in ElasticSearch' ) -> end ( ) -> scalarNode ( 'template' ) -> isRequired ( ) -> end ( ) -> scalarNode ( 'client' ) -> end ( ) -> variableNode ( 'settings' ) -> defaultValue ( [ ] ) -> end ( ) -> end ( ) -> append ( $ this -> getTypesNode ( ) ) -> end ( ) -> end ( ) -> end ( ) ; } 
public function transform ( array $ elasticaObjects ) { $ ids = $ highlights = [ ] ; foreach ( $ elasticaObjects as $ elasticaObject ) { $ ids [ ] = $ elasticaObject -> getId ( ) ; $ highlights [ $ elasticaObject -> getId ( ) ] = $ elasticaObject -> getHighlights ( ) ; } $ objects = $ this -> findByIdentifiers ( $ ids , $ this -> options [ 'hydrate' ] ) ; $ objectsCnt = count ( $ objects ) ; $ elasticaObjectsCnt = count ( $ elasticaObjects ) ; if ( ! $ this -> options [ 'ignore_missing' ] && $ objectsCnt < $ elasticaObjectsCnt ) { throw new \ RuntimeException ( sprintf ( 'Cannot find corresponding Doctrine objects (%d) for all Elastica results (%d). IDs: %s' , $ objectsCnt , $ elasticaObjectsCnt , implode ( ', ' , $ ids ) ) ) ; } $ propertyAccessor = $ this -> propertyAccessor ; $ identifier = $ this -> options [ 'identifier' ] ; foreach ( $ objects as $ object ) { if ( $ object instanceof HighlightableModelInterface ) { $ id = $ propertyAccessor -> getValue ( $ object , $ identifier ) ; $ object -> setElasticHighlights ( $ highlights [ ( string ) $ id ] ) ; } } 
public function process ( ContainerBuilder $ container ) { if ( ! $ container -> hasDefinition ( 'fos_elastica.elastica_to_model_transformer.collection' ) ) { return ; } $ transformers = [ ] ; foreach ( $ container -> findTaggedServiceIds ( 'fos_elastica.elastica_to_model_transformer' ) as $ id => $ tags ) { foreach ( $ tags as $ tag ) { if ( empty ( $ tag [ 'index' ] ) || empty ( $ tag [ 'type' ] ) ) { throw new InvalidArgumentException ( 'The Transformer must have both a type and an index defined.' ) ; } $ transformers [ $ tag [ 'index' ] ] [ $ tag [ 'type' ] ] = new Reference ( $ id ) ; } } foreach ( $ transformers as $ index => $ indexTransformers ) { if ( ! $ container -> hasDefinition ( sprintf ( 'fos_elastica.elastica_to_model_transformer.collection.%s' , $ index ) ) ) { continue ; } $ index = $ container -> getDefinition ( sprintf ( 'fos_elastica.elastica_to_model_transformer.collection.%s' , $ index ) ) ; $ index -> replaceArgument ( 0 , $ indexTransformers ) ; } } 
protected function findByIdentifiers ( array $ identifierValues , $ hydrate ) { return $ this -> registry -> getManagerForClass ( $ this -> objectClass ) -> getRepository ( $ this -> objectClass ) -> { $ this -> options [ 'query_builder_method' ] } ( $ this -> objectClass ) -> field ( $ this -> options [ 'identifier' ] ) -> in ( $ identifierValues ) -> hydrate ( $ hydrate ) -> getQuery ( ) -> execute ( ) -> toArray ( ) ; } 
public function isObjectIndexable ( $ indexName , $ typeName , $ object ) { $ type = sprintf ( '%s/%s' , $ indexName , $ typeName ) ; $ callback = $ this -> getCallback ( $ type , $ object ) ; if ( ! $ callback ) { return true ; } if ( $ callback instanceof Expression ) { return ( bool ) $ this -> getExpressionLanguage ( ) -> evaluate ( $ callback , [ 'object' => $ object , $ this -> getExpressionVar ( $ object ) => $ object , ] ) ; } return is_string ( $ callback ) ? call_user_func ( [ $ object , $ callback ] ) : call_user_func ( $ callback , $ object ) ; } 
private function buildCallback ( $ type , $ object ) { if ( ! array_key_exists ( $ type , $ this -> callbacks ) ) { return null ; } $ callback = $ this -> callbacks [ $ type ] ; if ( is_callable ( $ callback ) or is_callable ( [ $ object , $ callback ] ) ) { return $ callback ; } if ( is_string ( $ callback ) ) { return $ this -> buildExpressionCallback ( $ type , $ object , $ callback ) ; } throw new \ InvalidArgumentException ( sprintf ( 'Callback for type "%s" is not a valid callback.' , $ type ) ) ; } 
private function buildExpressionCallback ( $ type , $ object , $ callback ) { $ expression = $ this -> getExpressionLanguage ( ) ; if ( ! $ expression ) { throw new \ RuntimeException ( 'Unable to process an expression without the ExpressionLanguage component.' ) ; } try { $ callback = new Expression ( $ callback ) ; $ expression -> compile ( $ callback , [ 'object' , $ this -> getExpressionVar ( $ object ) , ] ) ; return $ callback ; } catch ( SyntaxError $ e ) { throw new \ InvalidArgumentException ( sprintf ( 'Callback for type "%s" is an invalid expression' , $ type ) , $ e -> getCode ( ) , $ e ) ; } } 
private function getCallback ( $ type , $ object ) { if ( ! array_key_exists ( $ type , $ this -> initialisedCallbacks ) ) { $ this -> initialisedCallbacks [ $ type ] = $ this -> buildCallback ( $ type , $ object ) ; } return $ this -> initialisedCallbacks [ $ type ] ; } 
private function getExpressionVar ( $ object = null ) { if ( ! is_object ( $ object ) ) { return 'object' ; } $ ref = new \ ReflectionClass ( $ object ) ; return strtolower ( $ ref -> getShortName ( ) ) ; } 
public function getIndexConfiguration ( $ indexName ) { if ( ! $ this -> hasIndexConfiguration ( $ indexName ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Index with name "%s" is not configured.' , $ indexName ) ) ; } return $ this -> indexes [ $ indexName ] ; } 
public function getTypeConfiguration ( $ indexName , $ typeName ) { $ index = $ this -> getIndexConfiguration ( $ indexName ) ; $ type = $ index -> getType ( $ typeName ) ; if ( ! $ type ) { throw new \ InvalidArgumentException ( sprintf ( 'Type with name "%s" on index "%s" is not configured' , $ typeName , $ indexName ) ) ; } return $ type ; } 
public function setRootName ( IndexConfig $ indexConfig , Index $ index ) { $ index -> overrideName ( sprintf ( '%s_%s' , $ indexConfig -> getElasticSearchName ( ) , date ( 'Y-m-d-His' ) ) ) ; } 
public function switchIndexAlias ( IndexConfig $ indexConfig , Index $ index , $ force = false , $ delete = true ) { $ client = $ index -> getClient ( ) ; $ aliasName = $ indexConfig -> getElasticSearchName ( ) ; $ oldIndexName = null ; $ newIndexName = $ index -> getName ( ) ; try { $ oldIndexName = $ this -> getAliasedIndex ( $ client , $ aliasName ) ; } catch ( AliasIsIndexException $ e ) { if ( ! $ force ) { throw $ e ; } if ( $ delete ) { $ this -> deleteIndex ( $ client , $ aliasName ) ; } else { $ this -> closeIndex ( $ client , $ aliasName ) ; } } try { $ aliasUpdateRequest = $ this -> buildAliasUpdateRequest ( $ oldIndexName , $ aliasName , $ newIndexName ) ; $ client -> request ( '_aliases' , 'POST' , $ aliasUpdateRequest ) ; } catch ( ExceptionInterface $ e ) { $ this -> cleanupRenameFailure ( $ client , $ newIndexName , $ e ) ; } 
private function buildAliasUpdateRequest ( $ aliasedIndex , $ aliasName , $ newIndexName ) { $ aliasUpdateRequest = [ 'actions' => [ ] ] ; if ( null !== $ aliasedIndex ) { 
private function cleanupRenameFailure ( Client $ client , $ indexName , \ Exception $ renameAliasException ) { $ additionalError = '' ; try { $ this -> deleteIndex ( $ client , $ indexName ) ; } catch ( ExceptionInterface $ deleteNewIndexException ) { $ additionalError = sprintf ( 'Tried to delete newly built index %s, but also failed: %s' , $ indexName , $ deleteNewIndexException -> getMessage ( ) ) ; } throw new \ RuntimeException ( sprintf ( 'Failed to updated index alias: %s. %s' , $ renameAliasException -> getMessage ( ) , $ additionalError ? : sprintf ( 'Newly built index %s was deleted' , $ indexName ) ) , 0 , $ renameAliasException ) ; } 
private function deleteIndex ( Client $ client , $ indexName ) { try { $ path = sprintf ( '%s' , $ indexName ) ; $ client -> request ( $ path , Request :: DELETE ) ; } catch ( ExceptionInterface $ deleteOldIndexException ) { throw new \ RuntimeException ( sprintf ( 'Failed to delete index %s with message: %s' , $ indexName , $ deleteOldIndexException -> getMessage ( ) ) , 0 , $ deleteOldIndexException ) ; } } 
private function closeIndex ( Client $ client , $ indexName ) { try { $ path = sprintf ( '%s/_close' , $ indexName ) ; $ client -> request ( $ path , Request :: POST ) ; } catch ( ExceptionInterface $ e ) { throw new \ RuntimeException ( sprintf ( 'Failed to close index %s with message: %s' , $ indexName , $ e -> getMessage ( ) ) , 0 , $ e ) ; } } 
private function getAliasedIndex ( Client $ client , $ aliasName ) { $ aliasesInfo = $ client -> request ( '_aliases' , 'GET' ) -> getData ( ) ; $ aliasedIndexes = [ ] ; foreach ( $ aliasesInfo as $ indexName => $ indexInfo ) { if ( $ indexName === $ aliasName ) { throw new AliasIsIndexException ( $ indexName ) ; } if ( ! isset ( $ indexInfo [ 'aliases' ] ) ) { continue ; } $ aliases = array_keys ( $ indexInfo [ 'aliases' ] ) ; if ( in_array ( $ aliasName , $ aliases ) ) { $ aliasedIndexes [ ] = $ indexName ; } } if ( count ( $ aliasedIndexes ) > 1 ) { throw new \ RuntimeException ( sprintf ( 'Alias %s is used for multiple indexes: [%s]. Make sure it\'s' . 'either not used or is assigned to one index only' , $ aliasName , implode ( ', ' , $ aliasedIndexes ) ) ) ; } return array_shift ( $ aliasedIndexes ) ; } 
public function request ( $ path , $ method = Request :: GET , $ data = [ ] , array $ query = [ ] , $ contentType = Request :: DEFAULT_CONTENT_TYPE ) { if ( $ this -> stopwatch ) { $ this -> stopwatch -> start ( 'es_request' , 'fos_elastica' ) ; } $ response = parent :: request ( $ path , $ method , $ data , $ query , $ contentType ) ; $ responseData = $ response -> getData ( ) ; $ transportInfo = $ response -> getTransferInfo ( ) ; $ connection = $ this -> getLastRequest ( ) -> getConnection ( ) ; $ forbiddenHttpCodes = $ connection -> hasConfig ( 'http_error_codes' ) ? $ connection -> getConfig ( 'http_error_codes' ) : [ ] ; if ( isset ( $ transportInfo [ 'http_code' ] ) && in_array ( $ transportInfo [ 'http_code' ] , $ forbiddenHttpCodes , true ) ) { $ body = is_array ( $ responseData ) ? json_encode ( $ responseData ) : $ responseData ; $ message = sprintf ( 'Error in transportInfo: response code is %s, response body is %s' , $ transportInfo [ 'http_code' ] , $ body ) ; throw new ClientException ( $ message ) ; } if ( isset ( $ responseData [ 'took' ] ) && isset ( $ responseData [ 'hits' ] ) ) { $ this -> logQuery ( $ path , $ method , $ data , $ query , $ response -> getQueryTime ( ) , $ response -> getEngineTime ( ) , $ responseData [ 'hits' ] [ 'total' ] ) ; } else { $ this -> logQuery ( $ path , $ method , $ data , $ query , $ response -> getQueryTime ( ) , 0 , 0 ) ; } if ( $ this -> stopwatch ) { $ this -> stopwatch -> stop ( 'es_request' ) ; } return $ response ; } 
public function getIndex ( $ name ) { if ( isset ( $ this -> indexCache [ $ name ] ) ) { return $ this -> indexCache [ $ name ] ; } return $ this -> indexCache [ $ name ] = new Index ( $ this , $ name ) ; } 
private function logQuery ( $ path , $ method , $ data , array $ query , $ queryTime , $ engineMS = 0 , $ itemCount = 0 ) { if ( ! $ this -> _logger or ! $ this -> _logger instanceof ElasticaLogger ) { return ; } $ connection = $ this -> getLastRequest ( ) -> getConnection ( ) ; $ connectionArray = [ 'host' => $ connection -> getHost ( ) , 'port' => $ connection -> getPort ( ) , 'transport' => $ connection -> getTransport ( ) , 'headers' => $ connection -> hasConfig ( 'headers' ) ? $ connection -> getConfig ( 'headers' ) : [ ] , ] ; $ logger = $ this -> _logger ; $ logger -> logQuery ( $ path , $ method , $ data , $ queryTime , $ connectionArray , $ query , $ engineMS , $ itemCount ) ; } 
public function find ( $ query , $ limit = null , $ options = [ ] ) { return $ this -> finder -> find ( $ query , $ limit , $ options ) ; } 
public function findHybrid ( $ query , $ limit = null , $ options = [ ] ) { return $ this -> finder -> findHybrid ( $ query , $ limit , $ options ) ; } 
public function postPersist ( LifecycleEventArgs $ eventArgs ) { $ entity = $ eventArgs -> getObject ( ) ; if ( $ this -> objectPersister -> handlesObject ( $ entity ) && $ this -> isObjectIndexable ( $ entity ) ) { $ this -> scheduledForInsertion [ ] = $ entity ; } } 
public function postUpdate ( LifecycleEventArgs $ eventArgs ) { $ entity = $ eventArgs -> getObject ( ) ; if ( $ this -> objectPersister -> handlesObject ( $ entity ) ) { if ( $ this -> isObjectIndexable ( $ entity ) ) { $ this -> scheduledForUpdate [ ] = $ entity ; } else { 
public function preRemove ( LifecycleEventArgs $ eventArgs ) { $ entity = $ eventArgs -> getObject ( ) ; if ( $ this -> objectPersister -> handlesObject ( $ entity ) ) { $ this -> scheduleForDeletion ( $ entity ) ; } } 
private function persistScheduled ( ) { if ( $ this -> shouldPersist ( ) ) { if ( count ( $ this -> scheduledForInsertion ) ) { $ this -> objectPersister -> insertMany ( $ this -> scheduledForInsertion ) ; $ this -> scheduledForInsertion = [ ] ; } if ( count ( $ this -> scheduledForUpdate ) ) { $ this -> objectPersister -> replaceMany ( $ this -> scheduledForUpdate ) ; $ this -> scheduledForUpdate = [ ] ; } if ( count ( $ this -> scheduledForDeletion ) ) { $ this -> objectPersister -> deleteManyByIdentifiers ( $ this -> scheduledForDeletion ) ; $ this -> scheduledForDeletion = [ ] ; } } } 
private function scheduleForDeletion ( $ object ) { if ( $ identifierValue = $ this -> propertyAccessor -> getValue ( $ object , $ this -> config [ 'identifier' ] ) ) { $ this -> scheduledForDeletion [ ] = ! is_scalar ( $ identifierValue ) ? ( string ) $ identifierValue : $ identifierValue ; } } 
private function isObjectIndexable ( $ object ) { return $ this -> indexable -> isObjectIndexable ( $ this -> config [ 'indexName' ] , $ this -> config [ 'typeName' ] , $ object ) ; } 
public function getRepository ( $ entityName ) { $ realEntityName = $ entityName ; if ( false !== strpos ( $ entityName , ':' ) ) { list ( $ namespaceAlias , $ simpleClassName ) = explode ( ':' , $ entityName ) ; $ realEntityName = $ this -> managerRegistry -> getAliasNamespace ( $ namespaceAlias ) . '\\' . $ simpleClassName ; } if ( isset ( $ this -> entities [ $ realEntityName ] ) ) { $ realEntityName = $ this -> entities [ $ realEntityName ] ; } return $ this -> repositoryManager -> getRepository ( $ realEntityName ) ; } 
protected function findByIdentifiers ( array $ identifierValues , $ hydrate ) { return $ this -> registry -> getManager ( ) -> getRepository ( $ this -> objectClass ) -> findMany ( $ identifierValues ) -> toArray ( ) ; } 
public function transform ( $ object , array $ fields ) { $ identifier = $ this -> propertyAccessor -> getValue ( $ object , $ this -> options [ 'identifier' ] ) ; return new Document ( $ identifier ) ; } 
public function getRepository ( $ typeName ) { if ( isset ( $ this -> repositories [ $ typeName ] ) ) { return $ this -> repositories [ $ typeName ] ; } if ( ! isset ( $ this -> types [ $ typeName ] ) ) { throw new RuntimeException ( sprintf ( 'No search finder configured for %s' , $ typeName ) ) ; } $ repository = $ this -> createRepository ( $ typeName ) ; $ this -> repositories [ $ typeName ] = $ repository ; return $ repository ; } 
private function createRepository ( $ typeName ) { if ( ! class_exists ( $ repositoryName = $ this -> getRepositoryName ( $ typeName ) ) ) { throw new RuntimeException ( sprintf ( '%s repository for %s does not exist' , $ repositoryName , $ typeName ) ) ; } return new $ repositoryName ( $ this -> types [ $ typeName ] [ 'finder' ] ) ; } 
public function make ( array $ config ) : Hashids { $ config = $ this -> getConfig ( $ config ) ; return $ this -> getClient ( $ config ) ; } 
protected function registerFactory ( ) : void { $ this -> app -> singleton ( 'hashids.factory' , function ( ) { return new HashidsFactory ( ) ; } ) ; $ this -> app -> alias ( 'hashids.factory' , HashidsFactory :: class ) ; } 
public function execute ( $ request ) { RequestNotSupportedException :: assertSupports ( $ this , $ request ) ; $ this -> gateway -> execute ( $ httpRequest = new GetHttpRequest ( ) ) ; if ( 'POST' == $ httpRequest -> method && false == empty ( $ httpRequest -> request [ 'confirm' ] ) ) { return ; } $ renderTemplate = new RenderTemplate ( $ this -> templateName , array ( 'model' => ArrayObject :: ensureArrayObject ( $ request -> getModel ( ) ) , 'firstModel' => $ request -> getFirstModel ( ) , ) ) ; $ this -> gateway -> execute ( $ renderTemplate ) ; throw new HttpResponse ( $ renderTemplate -> getResult ( ) ) ; } 
public function execute ( $ request ) { RequestNotSupportedException :: assertSupports ( $ this , $ request ) ; $ model = ArrayObject :: ensureArrayObject ( $ request -> getModel ( ) ) ; if ( $ model [ 'status' ] ) { return ; } if ( $ model [ 'customer' ] ) { } else { if ( false == $ model [ 'card' ] ) { $ obtainToken = new ObtainToken ( $ request -> getToken ( ) ) ; $ obtainToken -> setModel ( $ model ) ; $ this -> gateway -> execute ( $ obtainToken ) ; } } $ this -> gateway -> execute ( new CreateCharge ( $ model ) ) ; } 
public function execute ( $ request ) { RequestNotSupportedException :: assertSupports ( $ this , $ request ) ; $ this -> gateway -> execute ( new RefundTransaction ( $ request -> getModel ( ) ) ) ; $ this -> gateway -> execute ( new Sync ( $ request -> getModel ( ) ) ) ; } 
public function createConfig ( array $ config = array ( ) ) { $ config = ArrayObject :: ensureArrayObject ( $ config ) ; $ config -> defaults ( $ this -> defaultConfig ) ; $ config -> defaults ( $ this -> coreGatewayFactory -> createConfig ( ( array ) $ config ) ) ; $ this -> populateConfig ( $ config ) ; return ( array ) $ config ; } 
protected function populateConfig ( ArrayObject $ config ) { if ( false == class_exists ( Sofortueberweisung :: class ) ) { throw new LogicException ( 'You must install "sofort/sofortlib-php:^3.0" library.' ) ; } $ config -> defaults ( array ( 'payum.factory_name' => 'sofort' , 'payum.factory_title' => 'Sofort' , 'payum.action.capture' => new CaptureAction ( ) , 'payum.action.status' => new StatusAction ( ) , 'payum.action.notify' => new NotifyAction ( ) , 'payum.action.sync' => new SyncAction ( ) , 'payum.action.refund' => new RefundAction ( ) , 'payum.action.convert_payment' => new ConvertPaymentAction ( ) , 'payum.action.api.create_transaction' => new CreateTransactionAction ( ) , 'payum.action.api.get_transaction_data' => new GetTransactionDataAction ( ) , 'payum.action.api.refund_transaction' => new RefundTransactionAction ( ) , ) ) ; if ( false == $ config [ 'payum.api' ] ) { $ config [ 'payum.default_options' ] = [ 'config_key' => '' , 'abort_url' => '' , 'disable_notification' => false , ] ; $ config -> defaults ( $ config [ 'payum.default_options' ] ) ; $ config [ 'payum.required_options' ] = [ 'config_key' ] ; $ config [ 'payum.api' ] = function ( ArrayObject $ config ) { $ config -> validateNotEmpty ( $ config [ 'payum.required_options' ] ) ; if ( false == preg_match ( '/.*\:.*\:.*/' , $ config [ 'config_key' ] ) ) { throw new \ LogicException ( 'The config_key is invalid. It must match the regexp "/.*\:.*\:.*/".' ) ; } return new Api ( [ 'config_key' => $ config [ 'config_key' ] , 'abort_url' => $ config [ 'abort_url' ] , 'disable_notification' => $ config [ 'disable_notification' ] , ] ) ; } ; } } 
public function execute ( $ request ) { RequestNotSupportedException :: assertSupports ( $ this , $ request ) ; $ model = ArrayObject :: ensureArrayObject ( $ request -> getModel ( ) ) ; if ( $ model [ 'location' ] ) { $ this -> gateway -> execute ( $ fetchOrder = new FetchOrder ( $ model ) ) ; $ model -> replace ( $ fetchOrder -> getOrder ( ) -> marshal ( ) ) ; } } 
public function execute ( $ request ) { RequestNotSupportedException :: assertSupports ( $ this , $ request ) ; $ model = ArrayObject :: ensureArrayObject ( $ request -> getModel ( ) ) ; if ( $ model [ 'error' ] ) { $ request -> markFailed ( ) ; return ; } if ( false == $ model [ 'status' ] && false == $ model [ 'card' ] ) { $ request -> markNew ( ) ; return ; } if ( false == $ model [ 'status' ] && $ model [ 'card' ] ) { $ request -> markPending ( ) ; return ; } if ( Constants :: STATUS_FAILED == $ model [ 'status' ] ) { $ request -> markFailed ( ) ; return ; } if ( $ model [ 'refunded' ] ) { $ request -> markRefunded ( ) ; return ; } if ( Constants :: STATUS_SUCCEEDED == $ model [ 'status' ] && $ model [ 'captured' ] && $ model [ 'paid' ] ) { $ request -> markCaptured ( ) ; return ; } if ( Constants :: STATUS_PAID == $ model [ 'status' ] && $ model [ 'captured' ] && $ model [ 'paid' ] ) { $ request -> markCaptured ( ) ; return ; } if ( Constants :: STATUS_SUCCEEDED == $ model [ 'status' ] && false == $ model [ 'captured' ] ) { $ request -> markAuthorized ( ) ; return ; } if ( Constants :: STATUS_PAID == $ model [ 'status' ] && false == $ model [ 'captured' ] ) { $ request -> markAuthorized ( ) ; return ; } $ request -> markUnknown ( ) ; } 
public function onExecute ( Context $ context ) { $ action = $ context -> getAction ( ) ; if ( $ action instanceof GenericTokenFactoryAwareInterface ) { $ action -> setGenericTokenFactory ( $ this -> genericTokenFactory ) ; } } 
public function onPostExecute ( Context $ context ) { $ action = $ context -> getAction ( ) ; if ( $ action instanceof GenericTokenFactoryAwareInterface ) { $ action -> setGenericTokenFactory ( null ) ; } } 
protected function populateConfig ( ArrayObject $ config ) { $ config -> defaults ( [ 'payum.factory_name' => 'be2bill_offsite' , 'payum.factory_title' => 'Be2Bill Offsite' , 'payum.action.capture' => new CaptureOffsiteAction ( ) , 'payum.action.capture_null' => new CaptureOffsiteNullAction ( ) , 'payum.action.notify_null' => new NotifyNullAction ( ) , 'payum.action.notify' => new NotifyAction ( ) , ] ) ; parent :: populateConfig ( $ config ) ; } 
public function execute ( $ request ) { RequestNotSupportedException :: assertSupports ( $ this , $ request ) ; $ model = ArrayObject :: ensureArrayObject ( $ request -> getModel ( ) ) ; if ( $ model [ 'card' ] ) { throw new LogicException ( 'The token has already been set.' ) ; } $ getHttpRequest = new GetHttpRequest ( ) ; $ this -> gateway -> execute ( $ getHttpRequest ) ; if ( $ getHttpRequest -> method == 'POST' && isset ( $ getHttpRequest -> request [ 'stripeToken' ] ) ) { $ model [ 'card' ] = $ getHttpRequest -> request [ 'stripeToken' ] ; return ; } $ this -> gateway -> execute ( $ renderTemplate = new RenderTemplate ( $ this -> templateName , array ( 'model' => $ model , 'publishable_key' => $ this -> keys -> getPublishableKey ( ) , 'actionUrl' => $ request -> getToken ( ) ? $ request -> getToken ( ) -> getTargetUrl ( ) : null , ) ) ) ; throw new HttpResponse ( $ renderTemplate -> getResult ( ) ) ; } 
public function setHolder ( $ holder ) { $ this -> securedHolder = SensitiveValue :: ensureSensitive ( $ holder ) ; $ this -> maskedHolder = Mask :: mask ( $ this -> securedHolder -> peek ( ) ) ; 
public function setNumber ( $ number ) { $ this -> securedNumber = SensitiveValue :: ensureSensitive ( $ number ) ; $ this -> maskedNumber = Mask :: mask ( $ this -> securedNumber -> peek ( ) ) ; 
public function setSecurityCode ( $ securityCode ) { $ this -> securedSecurityCode = SensitiveValue :: ensureSensitive ( $ securityCode ) ; 
public function setExpireAt ( $ date = null ) { $ date = SensitiveValue :: ensureSensitive ( $ date ) ; if ( false == ( null === $ date -> peek ( ) || $ date -> peek ( ) instanceof \ DateTime ) ) { throw new InvalidArgumentException ( 'The date argument must be either instance of DateTime or null' ) ; } $ this -> securedExpireAt = $ date ; 
public function secure ( ) { $ this -> holder = $ this -> number = $ this -> expireAt = $ this -> securityCode = null ; } 
public function setDetails ( $ details ) { if ( $ details instanceof \ Traversable ) { $ details = iterator_to_array ( $ details ) ; } $ this -> details = $ details ; } 
public function execute ( $ request ) { RequestNotSupportedException :: assertSupports ( $ this , $ request ) ; $ model = ArrayObject :: ensureArrayObject ( $ request -> getModel ( ) ) ; if ( $ model [ Constants :: FIELD_PAYOUT ] ) { $ model [ Constants :: FIELD_STATUS ] = Constants :: STATUS_PAYEDOUT ; } else { $ model [ Constants :: FIELD_STATUS ] = Constants :: STATUS_PENDING ; } } 
public function execute ( $ request ) { RequestNotSupportedException :: assertSupports ( $ this , $ request ) ; $ model = ArrayObject :: ensureArrayObject ( $ request -> getModel ( ) ) ; $ model -> validateNotEmpty ( [ 'subtotal' , 'currency_code' , ] ) ; $ result = $ this -> api -> doCreateButton ( ( array ) $ model ) ; $ model -> replace ( ( array ) $ result ) ; if ( $ model [ 'EMAILLINK' ] != null ) { throw new HttpRedirect ( $ model [ 'EMAILLINK' ] ) ; } } 
public function execute ( $ request ) { RequestNotSupportedException :: assertSupports ( $ this , $ request ) ; $ this -> gateway -> execute ( new Sync ( $ request -> getModel ( ) ) ) ; } 
public function payment ( array $ params ) { $ params [ 'OPERATIONTYPE' ] = static :: OPERATION_PAYMENT ; $ this -> addGlobalParams ( $ params ) ; return $ this -> doRequest ( [ 'method' => 'payment' , 'params' => $ params ] ) ; } 
public function verifyHash ( array $ params ) { if ( empty ( $ params [ 'HASH' ] ) ) { return false ; } $ hash = $ params [ 'HASH' ] ; unset ( $ params [ 'HASH' ] ) ; return $ hash === $ this -> calculateHash ( $ params ) ; } 
protected function doRequest ( array $ fields ) { $ headers = array ( 'Content-Type' => 'application/x-www-form-urlencoded' , ) ; $ request = $ this -> messageFactory -> createRequest ( 'POST' , $ this -> getApiEndpoint ( ) , $ headers , http_build_query ( $ fields ) ) ; $ response = $ this -> client -> send ( $ request ) ; if ( false == ( $ response -> getStatusCode ( ) >= 200 && $ response -> getStatusCode ( ) < 300 ) ) { throw HttpException :: factory ( $ request , $ response ) ; } $ result = json_decode ( $ response -> getBody ( ) -> getContents ( ) ) ; if ( null === $ result ) { throw new LogicException ( "Response content is not valid json: \n\n{$response->getBody()->getContents()}" ) ; } return $ result ; } 
public function prepareOffsitePayment ( array $ params ) { $ supportedParams = array ( 'CLIENTIDENT' => null , 'DESCRIPTION' => null , 'ORDERID' => null , 'AMOUNT' => null , 'CARDTYPE' => null , 'CLIENTEMAIL' => null , 'CARDFULLNAME' => null , 'LANGUAGE' => null , 'EXTRADATA' => null , 'CLIENTDOB' => null , 'CLIENTADDRESS' => null , 'CREATEALIAS' => null , '3DSECURE' => null , '3DSECUREDISPLAYMODE' => null , 'USETEMPLATE' => null , 'HIDECLIENTEMAIL' => null , 'HIDEFULLNAME' => null , ) ; $ params = array_filter ( array_replace ( $ supportedParams , array_intersect_key ( $ params , $ supportedParams ) ) ) ; $ params [ 'OPERATIONTYPE' ] = static :: OPERATION_PAYMENT ; $ this -> addGlobalParams ( $ params ) ; return $ params ; } 
public function calculateHash ( array $ params ) { #Alpha sort ksort ( $ params ) ; $ clearString = $ this -> options [ 'password' ] ; foreach ( $ params as $ key => $ value ) { $ clearString .= $ key . '=' . $ value . $ this -> options [ 'password' ] ; } return hash ( 'sha256' , $ clearString ) ; } 
public function execute ( $ request ) { RequestNotSupportedException :: assertSupports ( $ this , $ request ) ; $ details = ArrayObject :: ensureArrayObject ( $ request -> getModel ( ) ) ; if ( false == $ details [ 'rno' ] ) { $ this -> gateway -> execute ( new Authorize ( $ details ) ) ; } if ( $ details [ 'rno' ] && false == $ details [ 'invoice_number' ] ) { $ this -> gateway -> execute ( new Activate ( $ details ) ) ; } } 
public function execute ( $ request ) { RequestNotSupportedException :: assertSupports ( $ this , $ request ) ; $ payout = $ request -> getSource ( ) ; $ this -> gateway -> execute ( $ currency = new GetCurrency ( $ payout -> getCurrencyCode ( ) ) ) ; $ divisor = pow ( 10 , $ currency -> exp ) ; $ details = ArrayObject :: ensureArrayObject ( $ payout -> getDetails ( ) ) ; $ details [ 'CURRENCYCODE' ] = $ payout -> getCurrencyCode ( ) ; $ details [ 'L_AMT0' ] = $ payout -> getTotalAmount ( ) / $ divisor ; $ details [ 'L_NOTE0' ] = $ payout -> getDescription ( ) ; if ( $ payout -> getRecipientEmail ( ) ) { $ details [ 'RECEIVERTYPE' ] = 'EmailAddress' ; $ details [ 'L_EMAIL0' ] = $ payout -> getRecipientEmail ( ) ; } elseif ( $ payout -> getRecipientId ( ) ) { $ details [ 'RECEIVERTYPE' ] = 'UserID' ; $ details [ 'L_RECEIVERID0' ] = $ payout -> getRecipientId ( ) ; } else { throw new LogicException ( 'Either recipient id or email must be set.' ) ; } $ request -> setResult ( ( array ) $ details ) ; } 
public function execute ( $ request ) { RequestNotSupportedException :: assertSupports ( $ this , $ request ) ; $ model = ArrayObject :: ensureArrayObject ( $ request -> getModel ( ) ) ; $ this -> gateway -> execute ( $ httpRequest = new GetHttpRequest ( ) ) ; $ response = ArrayObject :: ensureArrayObject ( $ httpRequest -> request ) ; if ( isset ( $ httpRequest -> query [ 'cancelled' ] ) ) { $ newResponse [ 'CANCELLED' ] = true ; $ model -> replace ( $ newResponse ) ; return ; } if ( $ response [ 'txn_id' ] != null ) { $ response -> validateNotEmpty ( [ 'payment_status' , 'business' , 'invoice' , 'txn_id' , 'mc_gross' , ] ) ; $ this -> gateway -> execute ( new Sync ( $ response ) ) ; $ model -> replace ( $ response ) ; } else { if ( $ model [ 'cancel_return' ] ) { $ cancelUri = HttpUri :: createFromString ( $ model [ 'cancel_return' ] ) ; $ modifier = new MergeQuery ( 'cancelled=1' ) ; $ cancelUri = $ modifier -> process ( $ cancelUri ) ; $ model [ 'cancel_return' ] = ( string ) $ cancelUri ; } $ this -> gateway -> execute ( new CreateButtonPayment ( $ model ) ) ; } } 
public function execute ( $ request ) { RequestNotSupportedException :: assertSupports ( $ this , $ request ) ; $ httpRequest = null ; if ( $ this -> httpRequest instanceof Request ) { $ httpRequest = $ this -> httpRequest ; } elseif ( $ this -> httpRequestStack instanceof RequestStack ) { $ httpRequest = $ this -> httpRequestStack -> getMasterRequest ( ) ; } if ( false == $ httpRequest ) { throw new LogicException ( 'The action can be run only when http request is set.' ) ; } $ form = $ this -> createCreditCardForm ( ) ; $ form -> handleRequest ( $ httpRequest ) ; if ( $ form -> isSubmitted ( ) ) { $ card = $ form -> getData ( ) ; $ card -> secure ( ) ; if ( $ form -> isValid ( ) ) { $ request -> set ( $ card ) ; return ; } } $ renderTemplate = new RenderTemplate ( $ this -> templateName , array ( 'model' => $ request -> getModel ( ) , 'firstModel' => $ request -> getFirstModel ( ) , 'form' => $ form -> createView ( ) , 'actionUrl' => $ request -> getToken ( ) ? $ request -> getToken ( ) -> getTargetUrl ( ) : null , ) ) ; $ this -> gateway -> execute ( $ renderTemplate ) ; throw new HttpResponse ( new Response ( $ renderTemplate -> getResult ( ) , 200 , array ( 'Cache-Control' => 'no-store, no-cache, max-age=0, post-check=0, pre-check=0' , 'X-Status-Code' => 200 , 'Pragma' => 'no-cache' , ) ) ) ; } 
public function getGatewayFactory ( $ name ) { try { return $ this -> registry -> getGatewayFactory ( $ name ) ; } catch ( InvalidArgumentException $ e ) { return $ this -> fallbackRegistry -> getGatewayFactory ( $ name ) ; } } 
public function getGateway ( $ name ) { try { return $ this -> registry -> getGateway ( $ name ) ; } catch ( InvalidArgumentException $ e ) { return $ this -> fallbackRegistry -> getGateway ( $ name ) ; } } 
public function execute ( $ request ) { RequestNotSupportedException :: assertSupports ( $ this , $ request ) ; $ model = ArrayObject :: ensureArrayObject ( $ request -> getModel ( ) ) ; $ httpRequest = new GetHttpRequest ( ) ; $ this -> gateway -> execute ( $ httpRequest ) ; 
protected function populateConfig ( ArrayObject $ config ) { $ config -> defaults ( [ 'payum.factory_name' => 'offline' , 'payum.factory_title' => 'Offline' , 'payum.action.capture' => new CaptureAction ( ) , 'payum.action.authorize' => new AuthorizeAction ( ) , 'payum.action.payout' => new PayoutAction ( ) , 'payum.action.refund' => new RefundAction ( ) , 'payum.action.status' => new StatusAction ( ) , 'payum.action.convert_payment' => new ConvertPaymentAction ( ) , 'payum.action.convert_payout' => new ConvertPayoutAction ( ) , ] ) ; } 
public function verify ( $ httpRequest ) { if ( false == $ httpRequest instanceof Request ) { throw new InvalidArgumentException ( sprintf ( 'Invalid request given. Expected %s but it is %s' , 'Symfony\Component\HttpFoundation\Request' , is_object ( $ httpRequest ) ? get_class ( $ httpRequest ) : gettype ( $ httpRequest ) ) ) ; } if ( false === $ hash = $ httpRequest -> attributes -> get ( 'payum_token' , $ httpRequest -> get ( 'payum_token' , false ) ) ) { throw new NotFoundHttpException ( 'Token parameter not set in request' ) ; } if ( $ hash instanceof TokenInterface ) { $ token = $ hash ; } else { if ( false == $ token = $ this -> tokenStorage -> find ( $ hash ) ) { throw new NotFoundHttpException ( sprintf ( 'A token with hash `%s` could not be found.' , $ hash ) ) ; } if ( ! RequestTokenVerifier :: isValid ( $ httpRequest -> getUri ( ) , $ token -> getTargetUrl ( ) ) ) { throw new HttpException ( 400 , sprintf ( 'The current url %s not match target url %s set in the token.' , $ httpRequest -> getUri ( ) , $ token -> getTargetUrl ( ) ) ) ; } } return $ token ; } 
public function execute ( $ request ) { RequestNotSupportedException :: assertSupports ( $ this , $ request ) ; $ payment = $ request -> getSource ( ) ; $ details = ArrayObject :: ensureArrayObject ( $ payment -> getDetails ( ) ) ; $ details [ 'amount' ] = $ payment -> getTotalAmount ( ) ; $ details [ 'currency' ] = $ payment -> getCurrencyCode ( ) ; $ details [ 'number' ] = $ payment -> getNumber ( ) ; $ details [ 'description' ] = $ payment -> getDescription ( ) ; $ details [ 'client_email' ] = $ payment -> getClientEmail ( ) ; $ details [ 'client_id' ] = $ payment -> getClientId ( ) ; $ details -> defaults ( array ( Constants :: FIELD_PAID => true , ) ) ; $ request -> setResult ( ( array ) $ details ) ; } 
public function execute ( $ request ) { RequestNotSupportedException :: assertSupports ( $ this , $ request ) ; $ details = ArrayObject :: ensureArrayObject ( $ request -> getModel ( ) ) ; $ klarna = $ this -> getKlarna ( ) ; try { $ klarna -> emailInvoice ( $ details [ 'invoice_number' ] ) ; } catch ( \ KlarnaException $ e ) { $ this -> populateDetailsWithError ( $ details , $ e , $ request ) ; } } 
protected function doRequest ( $ method , array $ fields ) { $ headers = [ ] ; $ request = $ this -> messageFactory -> createRequest ( $ method , $ this -> getApiEndpoint ( ) , $ headers , http_build_query ( $ fields ) ) ; $ response = $ this -> client -> send ( $ request ) ; if ( false == ( $ response -> getStatusCode ( ) >= 200 && $ response -> getStatusCode ( ) < 300 ) ) { throw HttpException :: factory ( $ request , $ response ) ; } return $ response ; } 
public function execute ( $ request ) { RequestNotSupportedException :: assertSupports ( $ this , $ request ) ; $ model = new ArrayObject ( $ request -> getModel ( ) ) ; if ( Api :: EXECCODE_3DSECURE_IDENTIFICATION_REQUIRED === $ model [ 'EXECCODE' ] ) { throw new HttpResponse ( base64_decode ( $ model [ '3DSECUREHTML' ] ) , 302 ) ; } if ( null !== $ model [ 'EXECCODE' ] ) { return ; } if ( false == $ model [ 'CLIENTUSERAGENT' ] ) { $ this -> gateway -> execute ( $ httpRequest = new GetHttpRequest ( ) ) ; $ model [ 'CLIENTUSERAGENT' ] = $ httpRequest -> userAgent ; } if ( false == $ model [ 'CLIENTIP' ] ) { $ this -> gateway -> execute ( $ httpRequest = new GetHttpRequest ( ) ) ; $ model [ 'CLIENTIP' ] = $ httpRequest -> clientIp ; } $ cardFields = array ( 'CARDCODE' , 'CARDCVV' , 'CARDVALIDITYDATE' , 'CARDFULLNAME' ) ; if ( false == $ model -> validateNotEmpty ( $ cardFields , false ) && false == $ model [ 'ALIAS' ] ) { try { $ obtainCreditCard = new ObtainCreditCard ( $ request -> getToken ( ) ) ; $ obtainCreditCard -> setModel ( $ request -> getFirstModel ( ) ) ; $ obtainCreditCard -> setModel ( $ request -> getModel ( ) ) ; $ this -> gateway -> execute ( $ obtainCreditCard ) ; $ card = $ obtainCreditCard -> obtain ( ) ; if ( $ card -> getToken ( ) ) { $ model [ 'ALIAS' ] = $ card -> getToken ( ) ; } else { $ model [ 'CARDVALIDITYDATE' ] = SensitiveValue :: ensureSensitive ( $ card -> getExpireAt ( ) -> format ( 'm-y' ) ) ; $ model [ 'CARDCODE' ] = SensitiveValue :: ensureSensitive ( $ card -> getNumber ( ) ) ; $ model [ 'CARDFULLNAME' ] = SensitiveValue :: ensureSensitive ( $ card -> getHolder ( ) ) ; $ model [ 'CARDCVV' ] = SensitiveValue :: ensureSensitive ( $ card -> getSecurityCode ( ) ) ; } } catch ( RequestNotSupportedException $ e ) { throw new LogicException ( 'Credit card details has to be set explicitly or there has to be an action that supports ObtainCreditCard request.' ) ; } } 
public function setField ( $ name , $ value ) { 
public function execute ( $ request ) { RequestNotSupportedException :: assertSupports ( $ this , $ request ) ; $ model = $ request -> getModel ( ) ; if ( false == isset ( $ model -> state ) && isset ( $ model -> payer -> payment_method ) && 'paypal' == $ model -> payer -> payment_method ) { $ model -> create ( $ this -> api ) ; foreach ( $ model -> links as $ link ) { if ( $ link -> rel == 'approval_url' ) { throw new HttpRedirect ( $ link -> href ) ; } } } if ( false == isset ( $ model -> state ) && isset ( $ model -> payer -> payment_method ) && 'credit_card' == $ model -> payer -> payment_method ) { $ model -> create ( $ this -> api ) ; } if ( true == isset ( $ model -> state ) && isset ( $ model -> payer -> payment_method ) && 'paypal' == $ model -> payer -> payment_method ) { $ execution = new PaymentExecution ( ) ; $ execution -> payer_id = $ _GET [ 'PayerID' ] ; 
public function execute ( $ request ) { RequestNotSupportedException :: assertSupports ( $ this , $ request ) ; $ model = ArrayObject :: ensureArrayObject ( $ request -> getModel ( ) ) ; foreach ( range ( 0 , 9 ) as $ index ) { if ( Api :: L_ERRORCODE_PAYMENT_NOT_AUTHORIZED == $ model [ 'L_ERRORCODE' . $ index ] ) { $ request -> markCanceled ( ) ; return ; } } foreach ( range ( 0 , 9 ) as $ index ) { if ( $ model [ 'L_ERRORCODE' . $ index ] ) { $ request -> markFailed ( ) ; return ; } } if ( isset ( $ model [ 'CANCELLED' ] ) ) { $ request -> markCanceled ( ) ; return ; } if ( false == $ model [ 'PAYERID' ] && Api :: CHECKOUTSTATUS_PAYMENT_ACTION_NOT_INITIATED == $ model [ 'CHECKOUTSTATUS' ] ) { $ request -> markPending ( ) ; return ; } 
public function decrypt ( CypherInterface $ cypher ) { if ( empty ( $ this -> config [ 'encrypted' ] ) ) { return ; } foreach ( $ this -> config as $ name => $ value ) { if ( 'encrypted' == $ name || is_bool ( $ value ) ) { $ this -> decryptedConfig [ $ name ] = $ value ; continue ; } $ this -> decryptedConfig [ $ name ] = $ cypher -> decrypt ( $ value ) ; } } 
public function encrypt ( CypherInterface $ cypher ) { $ this -> decryptedConfig [ 'encrypted' ] = true ; foreach ( $ this -> decryptedConfig as $ name => $ value ) { if ( 'encrypted' == $ name || is_bool ( $ value ) ) { $ this -> config [ $ name ] = $ value ; continue ; } $ this -> config [ $ name ] = $ cypher -> encrypt ( $ value ) ; } } 
protected function prepareContent ( $ url , array $ fields ) { $ formInputs = '' ; foreach ( $ fields as $ name => $ value ) { $ formInputs .= sprintf ( '<input type="hidden" name="%1$s" value="%2$s" />' , htmlspecialchars ( $ name , ENT_QUOTES , 'UTF-8' ) , htmlspecialchars ( $ value , ENT_QUOTES , 'UTF-8' ) ) . "\n" ; } $ content = <<<'HTML' <!DOCTYPE html> <html> <head> <title>Redirecting...</title> </head> <body onload="document.forms[0].submit();"> <form action="%1$s" method="post"> <p>Redirecting to payment page...</p> <p>%2$s</p> </form> </body> </html> HTML ; return sprintf ( $ content , htmlspecialchars ( $ url , ENT_QUOTES , 'UTF-8' ) , $ formInputs ) ; } 
public function execute ( $ request ) { RequestNotSupportedException :: assertSupports ( $ this , $ request ) ; $ model = new ArrayObject ( $ request -> getModel ( ) ) ; if ( null === $ model [ 'EXECCODE' ] ) { $ request -> markNew ( ) ; return ; } if ( Api :: EXECCODE_SUCCESSFUL === $ model [ 'EXECCODE' ] ) { $ request -> markCaptured ( ) ; return ; } if ( Api :: EXECCODE_TIME_OUT === $ model [ 'EXECCODE' ] ) { $ request -> markUnknown ( ) ; return ; } $ request -> markFailed ( ) ; } 
public function execute ( $ request ) { RequestNotSupportedException :: assertSupports ( $ this , $ request ) ; $ details = ArrayObject :: ensureArrayObject ( $ request -> getModel ( ) ) ; $ details [ 'PAYMENTREQUEST_0_PAYMENTACTION' ] = Api :: PAYMENTACTION_SALE ; foreach ( range ( 0 , 9 ) as $ index ) { if ( Api :: PENDINGREASON_AUTHORIZATION == $ details [ 'PAYMENTINFO_' . $ index . '_PENDINGREASON' ] ) { $ details -> defaults ( [ 'PAYMENTREQUEST_' . $ index . '_COMPLETETYPE' => 'Complete' ] ) ; $ this -> gateway -> execute ( new DoCapture ( $ details , $ index ) ) ; } } parent :: execute ( $ request ) ; } 
public function execute ( $ request ) { RequestNotSupportedException :: assertSupports ( $ this , $ request ) ; $ details = ArrayObject :: ensureArrayObject ( $ request -> getModel ( ) ) ; if ( ! $ details [ 'TRANSACTIONID' ] ) { return ; } $ voidDetails = new ArrayObject ( [ 'AUTHORIZATIONID' => $ details [ 'TRANSACTIONID' ] , ] ) ; $ this -> gateway -> execute ( new DoVoid ( $ voidDetails ) ) ; $ this -> gateway -> execute ( new Sync ( $ request -> getModel ( ) ) ) ; } 
public function supports ( $ request ) { if ( false == ( $ request instanceof Cancel && $ request -> getModel ( ) instanceof \ ArrayAccess ) ) { return false ; } 
public function addGateway ( $ name , $ gateway ) { 
public function addGatewayFactory ( $ name , $ gatewayFactory ) { if ( $ gatewayFactory instanceof GatewayFactoryInterface || is_callable ( $ gatewayFactory ) ) { $ this -> gatewayFactories [ $ name ] = $ gatewayFactory ; return $ this ; } throw new InvalidArgumentException ( 'Invalid argument' ) ; } 
public function addGatewayFactoryConfig ( $ name , array $ config ) { $ currentConfig = isset ( $ this -> gatewayFactoryConfigs [ $ name ] ) ? $ this -> gatewayFactoryConfigs [ $ name ] : [ ] ; $ this -> gatewayFactoryConfigs [ $ name ] = array_replace_recursive ( $ currentConfig , $ config ) ; return $ this ; } 
public function setHttpRequestVerifier ( $ httpRequestVerifier = null ) { if ( null === $ httpRequestVerifier || $ httpRequestVerifier instanceof HttpRequestVerifierInterface || is_callable ( $ httpRequestVerifier ) ) { $ this -> httpRequestVerifier = $ httpRequestVerifier ; return $ this ; } throw new InvalidArgumentException ( 'Invalid argument' ) ; } 
public function setTokenFactory ( $ tokenFactory = null ) { if ( null === $ tokenFactory || $ tokenFactory instanceof TokenFactoryInterface || is_callable ( $ tokenFactory ) ) { $ this -> tokenFactory = $ tokenFactory ; return $ this ; } throw new InvalidArgumentException ( 'Invalid argument' ) ; } 
public function setGenericTokenFactory ( $ tokenFactory = null ) { if ( null === $ tokenFactory || $ tokenFactory instanceof GenericTokenFactoryInterface || is_callable ( $ tokenFactory ) ) { $ this -> genericTokenFactory = $ tokenFactory ; return $ this ; } throw new InvalidArgumentException ( 'Invalid argument' ) ; } 
public function setCoreGatewayFactory ( $ coreGatewayFactory = null ) { if ( null === $ coreGatewayFactory || $ coreGatewayFactory instanceof GatewayFactoryInterface || is_callable ( $ coreGatewayFactory ) ) { $ this -> coreGatewayFactory = $ coreGatewayFactory ; return $ this ; } throw new InvalidArgumentException ( 'Invalid argument' ) ; } 
public function addCoreGatewayFactoryConfig ( array $ config ) { $ currentConfig = $ this -> coreGatewayFactoryConfig ? : [ ] ; $ this -> coreGatewayFactoryConfig = array_replace_recursive ( $ currentConfig , $ config ) ; return $ this ; } 
protected function buildTokenFactory ( StorageInterface $ tokenStorage , StorageRegistryInterface $ storageRegistry ) { $ tokenFactory = $ this -> tokenFactory ; if ( is_callable ( $ tokenFactory ) ) { $ tokenFactory = call_user_func ( $ tokenFactory , $ tokenStorage , $ storageRegistry ) ; if ( false == $ tokenFactory instanceof TokenFactoryInterface ) { throw new \ LogicException ( 'Builder returned invalid instance' ) ; } } return $ tokenFactory ? : new TokenFactory ( $ tokenStorage , $ storageRegistry ) ; } 
protected function buildGenericTokenFactory ( TokenFactoryInterface $ tokenFactory , array $ paths ) { $ genericTokenFactory = $ this -> genericTokenFactory ; if ( is_callable ( $ genericTokenFactory ) ) { $ genericTokenFactory = call_user_func ( $ genericTokenFactory , $ tokenFactory , $ paths ) ; if ( false == $ genericTokenFactory instanceof GenericTokenFactoryInterface ) { throw new \ LogicException ( 'Builder returned invalid instance' ) ; } } return $ genericTokenFactory ? : new GenericTokenFactory ( $ tokenFactory , $ paths ) ; } 
private function buildHttpRequestVerifier ( StorageInterface $ tokenStorage ) { $ httpRequestVerifier = $ this -> httpRequestVerifier ; if ( is_callable ( $ httpRequestVerifier ) ) { $ httpRequestVerifier = call_user_func ( $ httpRequestVerifier , $ tokenStorage ) ; if ( false == $ httpRequestVerifier instanceof HttpRequestVerifierInterface ) { throw new \ LogicException ( 'Builder returned invalid instance' ) ; } } return $ httpRequestVerifier ? : new HttpRequestVerifier ( $ tokenStorage ) ; } 
protected function buildRegistry ( array $ gateways = [ ] , array $ storages = [ ] , array $ gatewayFactories = [ ] ) { $ registry = new SimpleRegistry ( $ gateways , $ storages , $ gatewayFactories ) ; $ registry -> setAddStorageExtensions ( false ) ; if ( $ this -> gatewayConfigStorage ) { $ dynamicRegistry = new DynamicRegistry ( $ this -> gatewayConfigStorage , $ registry ) ; $ dynamicRegistry -> setBackwardCompatibility ( false ) ; $ registry = new FallbackRegistry ( $ dynamicRegistry , $ registry ) ; } if ( $ this -> mainRegistry ) { $ registry = new FallbackRegistry ( $ this -> mainRegistry , $ registry ) ; } return $ registry ; } 
protected function buildGatewayFactories ( GatewayFactoryInterface $ coreGatewayFactory ) { $ map = [ 'paypal_express_checkout' => PaypalExpressCheckoutGatewayFactory :: class , 'paypal_pro_checkout' => PaypalProCheckoutGatewayFactory :: class , 'paypal_pro_hosted' => PaypalProHostedGatewayFactory :: class , 'paypal_masspay' => PaypalMasspayGatewayFactory :: class , 'paypal_rest' => PaypalRestGatewayFactory :: class , 'authorize_net_aim' => AuthorizeNetAimGatewayFactory :: class , 'be2bill_direct' => Be2BillDirectGatewayFactory :: class , 'be2bill_offsite' => Be2BillOffsiteGatewayFactory :: class , 'klarna_checkout' => KlarnaCheckoutGatewayFactory :: class , 'klarna_invoice' => KlarnaInvoiceGatewayFactory :: class , 'offline' => OfflineGatewayFactory :: class , 'payex' => PayexGatewayFactory :: class , 'stripe_checkout' => StripeCheckoutGatewayFactory :: class , 'stripe_js' => StripeJsGatewayFactory :: class , 'sofort' => SofortGatewayFactory :: class , ] ; $ gatewayFactories = [ ] ; foreach ( $ map as $ name => $ factoryClass ) { if ( class_exists ( $ factoryClass ) ) { $ gatewayFactories [ $ name ] = new $ factoryClass ( isset ( $ this -> gatewayFactoryConfigs [ $ name ] ) ? $ this -> gatewayFactoryConfigs [ $ name ] : [ ] , $ coreGatewayFactory ) ; } } return $ gatewayFactories ; } 
protected function buildAddedGatewayFactories ( GatewayFactoryInterface $ coreGatewayFactory ) { $ gatewayFactories = [ ] ; foreach ( $ this -> gatewayFactories as $ name => $ factory ) { if ( is_callable ( $ factory ) ) { $ config = isset ( $ this -> gatewayFactoryConfigs [ $ name ] ) ? $ this -> gatewayFactoryConfigs [ $ name ] : [ ] ; $ factory = call_user_func ( $ factory , $ config , $ coreGatewayFactory ) ; } $ gatewayFactories [ $ name ] = $ factory ; } return $ gatewayFactories ; } 
protected function buildOmnipayGatewayFactories ( GatewayFactoryInterface $ coreGatewayFactory ) { $ gatewayFactories = [ ] ; if ( false == class_exists ( \ Omnipay \ Omnipay :: class ) || false == class_exists ( OmnipayGatewayFactory :: class ) ) { return $ gatewayFactories ; } $ factory = \ Omnipay \ Omnipay :: getFactory ( ) ; $ gatewayFactories [ 'omnipay' ] = new OmnipayGatewayFactory ( '' , $ factory , [ ] , $ coreGatewayFactory ) ; $ gatewayFactories [ 'omnipay_direct' ] = new OmnipayGatewayFactory ( '' , $ factory , [ ] , $ coreGatewayFactory ) ; $ gatewayFactories [ 'omnipay_offsite' ] = new OmnipayGatewayFactory ( '' , $ factory , [ ] , $ coreGatewayFactory ) ; foreach ( $ factory -> getSupportedGateways ( ) as $ type ) { 
protected function buildOmnipayV3GatewayFactories ( GatewayFactoryInterface $ coreGatewayFactory ) { $ gatewayFactories = [ ] ; if ( false == class_exists ( \ Omnipay \ Omnipay :: class ) || false == class_exists ( OmnipayV3GatewayFactory :: class ) ) { return $ gatewayFactories ; } $ factory = \ Omnipay \ Omnipay :: getFactory ( ) ; $ gatewayFactories [ 'omnipay' ] = new OmnipayV3GatewayFactory ( $ factory , [ ] , $ coreGatewayFactory ) ; return $ gatewayFactories ; } 
public function build ( array $ defaultConfig ) { $ coreGatewayFactory = new ContainerAwareCoreGatewayFactory ( $ defaultConfig ) ; $ coreGatewayFactory -> setContainer ( $ this -> container ) ; return $ coreGatewayFactory ; } 
public function findBy ( array $ criteria ) { $ crit = new Criteria ( ) ; foreach ( $ criteria as $ column => $ value ) { $ crit -> add ( $ column , $ value ) ; } $ modelPeer = $ this -> modelPeer ; return $ modelPeer :: doSelect ( $ crit ) ; } 
protected function doGetIdentity ( $ model ) { $ id = $ this -> getModelId ( $ model ) ; if ( count ( $ id ) > 1 ) { throw new LogicException ( 'Storage not support composite primary ids' ) ; } return new Identity ( array_shift ( $ id ) , $ model ) ; } 
protected function getModelId ( $ model ) { $ id = array ( ) ; $ modelPeer = get_class ( $ model ) . 'Peer' ; $ modelColumns = $ modelPeer :: getTableMap ( ) -> getColumns ( ) ; foreach ( $ modelColumns as $ column ) { if ( $ column -> isPrimaryKey ( ) ) { $ name = $ column -> getPhpName ( ) ; $ id [ $ name ] = $ model -> getByName ( $ name ) ; 
public function execute ( $ request ) { RequestNotSupportedException :: assertSupports ( $ this , $ request ) ; $ model = ArrayObject :: ensureArrayObject ( $ request -> getModel ( ) ) ; throw new \ LogicException ( 'Not implemented' ) ; } 
public function execute ( $ request ) { RequestNotSupportedException :: assertSupports ( $ this , $ request ) ; $ model = ArrayObject :: ensureArrayObject ( $ request -> getModel ( ) ) ; if ( false == $ model [ Constants :: FIELD_STATUS ] ) { $ request -> markNew ( ) ; return ; } if ( Constants :: STATUS_PENDING == $ model [ Constants :: FIELD_STATUS ] ) { $ request -> markPending ( ) ; return ; } if ( Constants :: STATUS_AUTHORIZED == $ model [ Constants :: FIELD_STATUS ] ) { $ request -> markAuthorized ( ) ; return ; } if ( Constants :: STATUS_CAPTURED == $ model [ Constants :: FIELD_STATUS ] ) { $ request -> markCaptured ( ) ; return ; } if ( Constants :: STATUS_PAYEDOUT == $ model [ Constants :: FIELD_STATUS ] ) { $ request -> markPayedout ( ) ; return ; } if ( Constants :: STATUS_REFUNDED == $ model [ Constants :: FIELD_STATUS ] ) { $ request -> markRefunded ( ) ; return ; } if ( Constants :: STATUS_CANCELED == $ model [ Constants :: FIELD_STATUS ] ) { $ request -> markCanceled ( ) ; return ; } $ request -> markUnknown ( ) ; } 
public static function guessViewsPath ( $ gatewayFactoryOrRootClass ) { if ( false == class_exists ( $ gatewayFactoryOrRootClass ) ) { return ; } $ rc = new \ ReflectionClass ( $ gatewayFactoryOrRootClass ) ; return dirname ( $ rc -> getFileName ( ) ) . '/Resources/views' ; } 
protected function populateConfig ( ArrayObject $ config ) { if ( ! class_exists ( 'SoapClient' ) ) { throw new \ LogicException ( 'You must install "ext-soap" extension.' ) ; } $ config [ 'payum.default_options' ] = array ( 'account_number' => '' , 'encryption_key' => '' , 'sandbox' => true , ) ; $ config -> defaults ( $ config [ 'payum.default_options' ] ) ; $ config [ 'payum.required_options' ] = array ( 'account_number' , 'encryption_key' ) ; $ config -> defaults ( array ( 'payum.factory_name' => 'payex' , 'payum.factory_title' => 'Payex' , 'soap.client_factory' => new SoapClientFactory ( ) , 'payum.api.order' => function ( ArrayObject $ config ) { $ config -> validateNotEmpty ( $ config [ 'payum.required_options' ] ) ; $ payexConfig = array ( 'account_number' => $ config [ 'account_number' ] , 'encryption_key' => $ config [ 'encryption_key' ] , 'sandbox' => $ config [ 'sandbox' ] , ) ; return new OrderApi ( $ config [ 'soap.client_factory' ] , $ payexConfig ) ; } , 'payum.api.agreement' => function ( ArrayObject $ config ) { $ config -> validateNotEmpty ( $ config [ 'payum.required_options' ] ) ; $ payexConfig = array ( 'account_number' => $ config [ 'account_number' ] , 'encryption_key' => $ config [ 'encryption_key' ] , 'sandbox' => $ config [ 'sandbox' ] , ) ; return new AgreementApi ( $ config [ 'soap.client_factory' ] , $ payexConfig ) ; } , 'payum.api.recurring' => function ( ArrayObject $ config ) { $ config -> validateNotEmpty ( $ config [ 'payum.required_options' ] ) ; $ payexConfig = array ( 'account_number' => $ config [ 'account_number' ] , 'encryption_key' => $ config [ 'encryption_key' ] , 'sandbox' => $ config [ 'sandbox' ] , ) ; return new RecurringApi ( $ config [ 'soap.client_factory' ] , $ payexConfig ) ; } , 'payum.action.capture' => new PaymentDetailsCaptureAction ( ) , 'payum.action.status' => new PaymentDetailsStatusAction ( ) , 'payum.action.sync' => new PaymentDetailsSyncAction ( ) , 'payum.action.auto_pay_capture' => new AutoPayPaymentDetailsCaptureAction ( ) , 'payum.action.auto_pay_status' => new AutoPayPaymentDetailsStatusAction ( ) , 'payum.action.convert_payment' => new ConvertPaymentAction ( ) , 
public function execute ( $ request ) { RequestNotSupportedException :: assertSupports ( $ this , $ request ) ; $ model = ArrayObject :: ensureArrayObject ( $ request -> getModel ( ) ) ; 
public function supports ( $ request ) { return $ request instanceof GetStatusInterface && $ request -> getModel ( ) instanceof \ ArrayAccess && 
public function onPreExecute ( Context $ context ) { if ( count ( $ context -> getPrevious ( ) ) >= $ this -> limit ) { throw new LogicException ( sprintf ( 'Possible endless cycle detected. ::onPreExecute was called %d times before reach the limit.' , $ this -> limit ) ) ; } } 
public function onPreExecute ( Context $ context ) { $ request = $ context -> getRequest ( ) ; if ( false == $ request instanceof ModelAggregateInterface ) { return ; } if ( $ request -> getModel ( ) instanceof IdentityInterface ) { $ identity = $ request -> getModel ( ) ; if ( false == $ model = $ this -> storage -> find ( $ identity ) ) { return ; } $ request -> setModel ( $ model ) ; } $ this -> scheduleForUpdateIfSupported ( $ request -> getModel ( ) ) ; } 
public function onPostExecute ( Context $ context ) { $ request = $ context -> getRequest ( ) ; if ( $ request instanceof ModelAggregateInterface ) { $ this -> scheduleForUpdateIfSupported ( $ request -> getModel ( ) ) ; } if ( false == $ context -> getPrevious ( ) ) { foreach ( $ this -> scheduledForUpdateModels as $ modelHash => $ model ) { $ this -> storage -> update ( $ model ) ; unset ( $ this -> scheduledForUpdateModels [ $ modelHash ] ) ; } } } 
public function create ( array $ parameters ) { $ parameters [ 'accountNumber' ] = $ this -> options [ 'account_number' ] ; 
public function check ( array $ parameters ) { $ parameters [ 'accountNumber' ] = $ this -> options [ 'account_number' ] ; $ parameters [ 'hash' ] = $ this -> calculateHash ( $ parameters , array ( 'accountNumber' , 'agreementRef' , ) ) ; return $ this -> call ( 'Check' , $ parameters , $ this -> getPxAgreementWsdl ( ) ) ; } 
public function delete ( array $ parameters ) { $ parameters [ 'accountNumber' ] = $ this -> options [ 'account_number' ] ; $ parameters [ 'hash' ] = $ this -> calculateHash ( $ parameters , array ( 'accountNumber' , 'agreementRef' , ) ) ; return $ this -> call ( 'DeleteAgreement' , $ parameters , $ this -> getPxAgreementWsdl ( ) ) ; } 
public function autoPay ( array $ parameters ) { $ parameters [ 'accountNumber' ] = $ this -> options [ 'account_number' ] ; $ parameters [ 'hash' ] = $ this -> calculateHash ( $ parameters , array ( 'accountNumber' , 'agreementRef' , 'price' , 'productNumber' , 'description' , 'orderId' , 'purchaseOperation' , 'currency' , ) ) ; return $ this -> call ( 'AutoPay3' , $ parameters , $ this -> getPxAgreementWsdl ( ) ) ; } 
public function execute ( $ request ) { RequestNotSupportedException :: assertSupports ( $ this , $ request ) ; $ details = ArrayObject :: ensureArrayObject ( $ request -> getModel ( ) ) ; if ( $ details [ 'transaction_id' ] ) { throw new LogicException ( sprintf ( 'The transaction has already been created for this payment. transaction_id: %s' , $ details [ 'transaction_id' ] ) ) ; } $ details -> validateNotEmpty ( [ 'amount' , 'currency_code' , 'reason' , 'success_url' , 'notification_url' ] ) ; $ details -> replace ( $ this -> api -> createTransaction ( ( array ) $ details ) ) ; if ( $ details [ 'payment_url' ] ) { throw new HttpRedirect ( $ details [ 'payment_url' ] ) ; } } 
protected function generateUrl ( $ path , array $ parameters = array ( ) ) { return $ this -> urlGenerator -> generate ( $ path , $ parameters , UrlGeneratorInterface :: ABSOLUTE_URL ) ; } 
public function getGatewayFactory ( $ name ) { 
public function getGateway ( $ name ) { if ( array_key_exists ( $ name , $ this -> gateways ) ) { return $ this -> gateways [ $ name ] ; } if ( $ gatewayConfigs = $ this -> gatewayConfigStore -> findBy ( array ( 'gatewayName' => $ name ) ) ) { $ gateway = $ this -> createGateway ( array_shift ( $ gatewayConfigs ) ) ; $ this -> gateways [ $ name ] = $ gateway ; return $ gateway ; } 
public function getGateways ( ) { 
public function getStorage ( $ class ) { 
protected function createGateway ( GatewayConfigInterface $ gatewayConfig ) { $ config = $ gatewayConfig -> getConfig ( ) ; if ( isset ( $ config [ 'factory' ] ) ) { $ factory = $ this -> gatewayFactoryRegistry -> getGatewayFactory ( $ config [ 'factory' ] ) ; unset ( $ config [ 'factory' ] ) ; } else { 
public function execute ( $ request ) { RequestNotSupportedException :: assertSupports ( $ this , $ request ) ; $ payment = $ request -> getSource ( ) ; $ details = ArrayObject :: ensureArrayObject ( $ payment -> getDetails ( ) ) ; $ details [ "amount" ] = $ payment -> getTotalAmount ( ) ; $ details [ "currency" ] = $ payment -> getCurrencyCode ( ) ; $ details [ "description" ] = $ payment -> getDescription ( ) ; if ( $ card = $ payment -> getCreditCard ( ) ) { if ( $ card -> getToken ( ) ) { $ details [ "customer" ] = $ card -> getToken ( ) ; } else { $ details [ "card" ] = SensitiveValue :: ensureSensitive ( [ 'number' => $ card -> getNumber ( ) , 'exp_month' => $ card -> getExpireAt ( ) -> format ( 'm' ) , 'exp_year' => $ card -> getExpireAt ( ) -> format ( 'Y' ) , 'cvc' => $ card -> getSecurityCode ( ) , ] ) ; } } $ request -> setResult ( ( array ) $ details ) ; } 
public function execute ( $ request ) { RequestNotSupportedException :: assertSupports ( $ this , $ request ) ; $ model = ArrayObject :: ensureArrayObject ( $ request -> getModel ( ) ) ; if ( false == $ model [ 'TOKEN' ] ) { throw new LogicException ( 'The TOKEN must be set by SetExpressCheckout request but it was not executed or failed. Review payment details model for more information' ) ; } if ( false == $ model [ 'PAYERID' ] || $ request -> isForced ( ) ) { throw new HttpRedirect ( $ this -> api -> getAuthorizeTokenUrl ( $ model [ 'TOKEN' ] , array ( 'useraction' => $ model [ 'AUTHORIZE_TOKEN_USERACTION' ] , 'cmd' => $ model [ 'AUTHORIZE_TOKEN_CMD' ] , ) ) ) ; } } 
public function execute ( $ request ) { RequestNotSupportedException :: assertSupports ( $ this , $ request ) ; $ payment = $ request -> getSource ( ) ; throw new \ LogicException ( 'Not implemented' ) ; } 
public function build ( StorageInterface $ tokenStorage , StorageRegistryInterface $ storageRegistry ) { return new TokenFactory ( $ tokenStorage , $ storageRegistry , $ this -> urlGenerator ) ; } 
public function doCreateButton ( array $ fields ) { if ( false == isset ( $ fields [ 'return' ] ) ) { if ( false == $ this -> options [ 'return' ] ) { throw new RuntimeException ( 'The return must be set either to FormRequest or to options.' ) ; } $ fields [ 'return' ] = $ this -> options [ 'return' ] ; } $ fields [ 'paymentaction' ] = self :: PAYMENTACTION_SALE ; $ fields [ 'cmd' ] = self :: FORM_CMD ; $ newFields = [ ] ; $ i = 0 ; foreach ( $ fields as $ key => $ val ) { $ newFields [ 'L_BUTTONVAR' . $ i ] = $ key . '=' . $ val ; $ i ++ ; } $ newFields [ 'METHOD' ] = 'BMCreateButton' ; $ newFields [ 'BUTTONTYPE' ] = 'PAYMENT' ; $ newFields [ 'BUTTONCODE' ] = 'TOKEN' ; $ this -> addVersionField ( $ newFields ) ; $ this -> addAuthorizeFields ( $ newFields ) ; $ response = $ this -> doRequest ( $ newFields ) ; return $ response ; } 
public function getTransactionDetails ( $ fields ) { $ fields [ 'METHOD' ] = 'GetTransactionDetails' ; $ this -> addAuthorizeFields ( $ fields ) ; $ this -> addVersionField ( $ fields ) ; return $ this -> doRequest ( $ fields ) ; } 
protected function doRequest ( array $ fields ) { $ headers = array ( 'Content-Type' => 'application/x-www-form-urlencoded' , ) ; $ request = $ this -> messageFactory -> createRequest ( 'POST' , $ this -> getApiEndpoint ( ) , $ headers , http_build_query ( $ fields ) ) ; $ response = $ this -> client -> send ( $ request ) ; if ( false == ( $ response -> getStatusCode ( ) >= 200 && $ response -> getStatusCode ( ) < 300 ) ) { throw HttpException :: factory ( $ request , $ response ) ; } parse_str ( $ response -> getBody ( ) -> getContents ( ) , $ result ) ; foreach ( $ result as & $ value ) { $ value = urldecode ( $ value ) ; } return $ result ; } 
protected function doFind ( $ id ) { $ query = new $ this -> modelQuery ( ) ; $ model = $ query -> findPk ( $ id ) ; return $ model ? : new $ this -> modelClass ( ) ; } 
public function findBy ( array $ criteria ) { $ query = new $ this -> modelQuery ( ) ; foreach ( $ criteria as $ column => $ value ) { $ query -> filterBy ( $ column , $ value ) ; } return $ query -> find ( ) ; } 
public static function mask ( $ value , $ maskSymbol = null , $ showLast = 3 ) { $ maskSymbol = $ maskSymbol ? : 'X' ; $ showLast = max ( 0 , $ showLast ) ; if ( mb_strlen ( $ value ) <= ( $ showLast + 1 ) * 2 || false == $ showLast ) { $ showRegExpPart = "" ; } else { $ showRegExpPart = "(?!(.){0,$showLast}$)" ; } return preg_replace ( "/(?!^.?)[^-_\s]$showRegExpPart/u" , $ maskSymbol , $ value ) ; } 
protected function callWithRetry ( \ Closure $ function , $ maxRetry = 3 ) { $ attempts = 1 ; while ( true ) { try { return call_user_func ( $ function ) ; } catch ( \ Klarna_Checkout_ConnectionErrorException $ e ) { if ( $ attempts >= $ maxRetry ) { throw $ e ; } $ attempts ++ ; } } } 
public function execute ( $ request ) { RequestNotSupportedException :: assertSupports ( $ this , $ request ) ; $ model = ArrayObject :: ensureArrayObject ( $ request -> getModel ( ) ) ; if ( null === $ model [ 'TOKEN' ] ) { throw new LogicException ( 'TOKEN must be set. Have you run SetExpressCheckoutAction?' ) ; } if ( null === $ model [ 'PAYERID' ] ) { throw new LogicException ( 'PAYERID must be set. Has user authorized this transaction?' ) ; } if ( null === $ model [ 'PAYMENTREQUEST_0_PAYMENTACTION' ] ) { throw new LogicException ( 'PAYMENTREQUEST_0_PAYMENTACTION must be set.' ) ; } if ( null === $ model [ 'PAYMENTREQUEST_0_AMT' ] ) { throw new LogicException ( 'PAYMENTREQUEST_0_AMT must be set.' ) ; } $ model -> replace ( $ this -> api -> doExpressCheckoutPayment ( ( array ) $ model ) ) ; } 
protected function doUpdateModel ( $ model ) { if ( $ id = $ this -> getModelId ( $ model ) ) { $ this -> tableGateway -> update ( $ this -> tableGateway -> getResultSetPrototype ( ) -> getHydrator ( ) -> extract ( $ model ) , array ( "{$this->idField} = ?" => $ id ) ) ; } else { $ this -> tableGateway -> insert ( $ this -> tableGateway -> getResultSetPrototype ( ) -> getHydrator ( ) -> extract ( $ model ) ) ; } } 
protected function doGetIdentity ( $ model ) { $ id = $ this -> getModelId ( $ model ) ; if ( ! $ id ) { throw new LogicException ( 'The model must be persisted before usage of this method' ) ; } return new Identity ( $ id , $ model ) ; } 
protected function getModelId ( $ model ) { $ rp = new \ ReflectionProperty ( $ model , $ this -> idField ) ; $ rp -> setAccessible ( true ) ; $ id = $ rp -> getValue ( $ model ) ; $ rp -> setAccessible ( false ) ; return $ id ; } 
public function execute ( $ request ) { RequestNotSupportedException :: assertSupports ( $ this , $ request ) ; if ( false == $ token = $ this -> tokenStorage -> find ( $ request -> getHash ( ) ) ) { throw new LogicException ( sprintf ( 'The token %s could not be found' , $ request -> getHash ( ) ) ) ; } $ request -> setToken ( $ token ) ; } 
public function execute ( $ request ) { RequestNotSupportedException :: assertSupports ( $ this , $ request ) ; $ model = $ request -> getModel ( ) ; if ( isset ( $ model -> state ) && 'approved' == $ model -> state ) { $ request -> markCaptured ( ) ; return ; } if ( isset ( $ model -> state ) && 'created' == $ model -> state ) { $ request -> markNew ( ) ; return ; } if ( false == isset ( $ model -> state ) ) { $ request -> markNew ( ) ; return ; } $ request -> markUnknown ( ) ; } 
public function supports ( $ request ) { if ( false == $ request instanceof GetStatusInterface ) { return false ; } $ model = $ request -> getModel ( ) ; if ( false == $ model instanceof Payment ) { return false ; } return true ; } 
public function onExecute ( Context $ context ) { $ this -> logger -> debug ( sprintf ( '[Payum] %d# %s::execute(%s)' , count ( $ context -> getPrevious ( ) ) + 1 , Humanify :: value ( $ context -> getAction ( ) , false ) , Humanify :: request ( $ context -> getRequest ( ) ) ) ) ; } 
public function onPostExecute ( Context $ context ) { if ( $ context -> getReply ( ) ) { $ this -> logger -> debug ( sprintf ( '[Payum] %d# %s::execute(%s) throws reply %s' , count ( $ context -> getPrevious ( ) ) + 1 , Humanify :: value ( $ context -> getAction ( ) ) , Humanify :: request ( $ context -> getRequest ( ) ) , Humanify :: request ( $ context -> getReply ( ) ) ) ) ; } elseif ( $ context -> getException ( ) ) { $ this -> logger -> debug ( sprintf ( '[Payum] %d# %s::execute(%s) throws exception %s' , count ( $ context -> getPrevious ( ) ) + 1 , $ context -> getAction ( ) ? Humanify :: value ( $ context -> getAction ( ) ) : 'Gateway' , Humanify :: request ( $ context -> getRequest ( ) ) , Humanify :: value ( $ context -> getException ( ) ) ) ) ; } } 
public function buildForm ( FormBuilderInterface $ builder , array $ options ) { $ builder -> add ( 'gatewayName' ) -> add ( 'factoryName' , GatewayFactoriesChoiceType :: class ) ; $ builder -> addEventListener ( FormEvents :: PRE_SUBMIT , array ( $ this , 'buildCredentials' ) ) ; $ builder -> addEventListener ( FormEvents :: PRE_SET_DATA , array ( $ this , 'buildCredentials' ) ) ; } 
public function execute ( $ request ) { RequestNotSupportedException :: assertSupports ( $ this , $ request ) ; $ this -> gateway -> execute ( $ httpRequest = new GetHttpRequest ( ) ) ; 
public function execute ( $ request ) { RequestNotSupportedException :: assertSupports ( $ this , $ request ) ; $ model = ArrayObject :: ensureArrayObject ( $ request -> getModel ( ) ) ; if ( $ model [ 'agreementRef' ] ) { throw new LogicException ( 'The agreement has already been created.' ) ; } $ model -> validatedKeysSet ( array ( 'merchantRef' , 'description' , 'purchaseOperation' , 'maxAmount' , 'startDate' , 'stopDate' , ) ) ; $ model -> validateNotEmpty ( array ( 'maxAmount' , 'merchantRef' , 'description' , ) ) ; $ result = $ this -> api -> create ( ( array ) $ model ) ; $ model -> replace ( $ result ) ; } 
protected function populateConfig ( ArrayObject $ config ) { $ config -> defaults ( array ( 'payum.factory_name' => 'paypal_express_checkout_nvp' , 'payum.factory_title' => 'PayPal ExpressCheckout' , 'payum.template.confirm_order' => '@PayumPaypalExpressCheckout/confirmOrder.html.twig' , 'payum.action.capture' => new CaptureAction ( ) , 'payum.action.cancel' => new CancelAction ( ) , 'payum.action.authorize' => new AuthorizeAction ( ) , 'payum.action.convert_payment' => new ConvertPaymentAction ( ) , 'payum.action.notify' => new NotifyAction ( ) , 'payum.action.status' => new PaymentDetailsStatusAction ( ) , 'payum.action.sync' => new PaymentDetailsSyncAction ( ) , 'payum.action.recurring_status' => new RecurringPaymentDetailsStatusAction ( ) , 'payum.action.recurring_sync' => new RecurringPaymentDetailsSyncAction ( ) , 'payum.action.api.set_express_checkout' => new SetExpressCheckoutAction ( ) , 'payum.action.api.get_express_checkout_details' => new GetExpressCheckoutDetailsAction ( ) , 'payum.action.api.get_transaction_details' => new GetTransactionDetailsAction ( ) , 'payum.action.api.do_express_checkout_payment' => new DoExpressCheckoutPaymentAction ( ) , 'payum.action.api.create_recurring_payment_profile' => new CreateRecurringPaymentProfileAction ( ) , 'payum.action.api.update_recurring_payment_profile' => new UpdateRecurringPaymentProfileAction ( ) , 'payum.action.api.get_recurring_payments_profile_details' => new GetRecurringPaymentsProfileDetailsAction ( ) , 'payum.action.api.cancel_recurring_payments_profile' => new CancelRecurringPaymentsProfileAction ( ) , 'payum.action.api.manage_recurring_payments_profile_status' => new ManageRecurringPaymentsProfileStatusAction ( ) , 'payum.action.api.create_billing_agreement' => new CreateBillingAgreementAction ( ) , 'payum.action.api.do_reference_transaction' => new DoReferenceTransactionAction ( ) , 'payum.action.api.do_capture' => new DoCaptureAction ( ) , 'payum.action.api.authorize_token' => new AuthorizeTokenAction ( ) , 'payum.action.api.do_void' => new DoVoidAction ( ) , 'payum.action.api.confirm_order' => function ( ArrayObject $ config ) { return new ConfirmOrderAction ( $ config [ 'payum.template.confirm_order' ] ) ; } , 'payum.action.api.transaction_search' => new TransactionSearchAction ( ) , ) ) ; if ( false == $ config [ 'payum.api' ] ) { $ config [ 'payum.default_options' ] = array ( 'username' => '' , 'password' => '' , 'signature' => '' , 'sandbox' => true , ) ; $ config -> defaults ( $ config [ 'payum.default_options' ] ) ; $ config [ 'payum.required_options' ] = array ( 'username' , 'password' , 'signature' ) ; $ config [ 'payum.api' ] = function ( ArrayObject $ config ) { $ config -> validateNotEmpty ( $ config [ 'payum.required_options' ] ) ; $ paypalConfig = array ( 'username' => $ config [ 'username' ] , 'password' => $ config [ 'password' ] , 'signature' => $ config [ 'signature' ] , 'sandbox' => $ config [ 'sandbox' ] , ) ; return new Api ( $ paypalConfig , $ config [ 'payum.http_client' ] , $ config [ 'httplug.message_factory' ] ) ; } ; } $ config [ 'payum.paths' ] = array_replace ( [ 'PayumPaypalExpressCheckout' => __DIR__ . '/Resources/views' , ] , $ config [ 'payum.paths' ] ? : [ ] ) ; } 
public function execute ( $ request ) { RequestNotSupportedException :: assertSupports ( $ this , $ request ) ; $ model = ArrayObject :: ensureArrayObject ( $ request -> getModel ( ) ) ; $ transactionIndex = 'PAYMENTREQUEST_' . $ request -> getPaymentRequestN ( ) . '_TRANSACTIONID' ; if ( false == $ model [ $ transactionIndex ] ) { throw new LogicException ( $ transactionIndex . ' must be set.' ) ; } $ result = $ this -> api -> getTransactionDetails ( array ( 'TRANSACTIONID' => $ model [ $ transactionIndex ] ) ) ; foreach ( $ result as $ name => $ value ) { if ( in_array ( $ name , $ this -> getPaymentRequestNFields ( ) ) ) { $ model [ 'PAYMENTREQUEST_' . $ request -> getPaymentRequestN ( ) . '_' . $ name ] = $ value ; } } } 
public function execute ( $ request ) { RequestNotSupportedException :: assertSupports ( $ this , $ request ) ; $ details = ArrayObject :: ensureArrayObject ( $ request -> getModel ( ) ) ; $ details -> validateNotEmpty ( 'PAYMENTREQUEST_0_PAYMENTACTION' ) ; $ details -> defaults ( array ( 'AUTHORIZE_TOKEN_USERACTION' => Api :: USERACTION_COMMIT , ) ) ; $ this -> gateway -> execute ( $ httpRequest = new GetHttpRequest ( ) ) ; if ( isset ( $ httpRequest -> query [ 'cancelled' ] ) ) { $ details [ 'CANCELLED' ] = true ; return ; } if ( false == $ details [ 'TOKEN' ] ) { if ( false == $ details [ 'RETURNURL' ] && $ request -> getToken ( ) ) { $ details [ 'RETURNURL' ] = $ request -> getToken ( ) -> getTargetUrl ( ) ; } if ( false == $ details [ 'CANCELURL' ] && $ request -> getToken ( ) ) { $ details [ 'CANCELURL' ] = $ request -> getToken ( ) -> getTargetUrl ( ) ; } if ( empty ( $ details [ 'PAYMENTREQUEST_0_NOTIFYURL' ] ) && $ request -> getToken ( ) && $ this -> tokenFactory ) { $ notifyToken = $ this -> tokenFactory -> createNotifyToken ( $ request -> getToken ( ) -> getGatewayName ( ) , $ request -> getToken ( ) -> getDetails ( ) ) ; $ details [ 'PAYMENTREQUEST_0_NOTIFYURL' ] = $ notifyToken -> getTargetUrl ( ) ; } if ( $ details [ 'CANCELURL' ] ) { $ cancelUri = HttpUri :: createFromString ( $ details [ 'CANCELURL' ] ) ; $ modifier = new MergeQuery ( 'cancelled=1' ) ; $ cancelUri = $ modifier -> process ( $ cancelUri ) ; $ details [ 'CANCELURL' ] = ( string ) $ cancelUri ; } $ this -> gateway -> execute ( new SetExpressCheckout ( $ details ) ) ; if ( $ details [ 'L_ERRORCODE0' ] ) { return ; } } $ this -> gateway -> execute ( new Sync ( $ details ) ) ; if ( $ details [ 'PAYERID' ] && Api :: CHECKOUTSTATUS_PAYMENT_ACTION_NOT_INITIATED == $ details [ 'CHECKOUTSTATUS' ] && $ details [ 'PAYMENTREQUEST_0_AMT' ] > 0 ) { if ( Api :: USERACTION_COMMIT !== $ details [ 'AUTHORIZE_TOKEN_USERACTION' ] ) { $ confirmOrder = new ConfirmOrder ( $ request -> getFirstModel ( ) ) ; $ confirmOrder -> setModel ( $ request -> getModel ( ) ) ; $ this -> gateway -> execute ( $ confirmOrder ) ; } $ this -> gateway -> execute ( new DoExpressCheckoutPayment ( $ details ) ) ; } if ( false == $ details [ 'PAYERID' ] ) { $ this -> gateway -> execute ( new AuthorizeToken ( $ details ) ) ; } $ this -> gateway -> execute ( new Sync ( $ details ) ) ; } 
public function finishView ( FormView $ view , FormInterface $ form , array $ options ) { if ( 'choice' == $ options [ 'widget' ] ) { if ( empty ( $ view [ 'day' ] -> vars [ 'value' ] ) ) { $ view [ 'day' ] -> vars [ 'value' ] = $ view [ 'day' ] -> vars [ 'choices' ] [ 0 ] -> value ; } $ style = 'display:none' ; if ( false == empty ( $ view [ 'day' ] -> vars [ 'attr' ] [ 'style' ] ) ) { $ style = $ view [ 'day' ] -> vars [ 'attr' ] [ 'style' ] . '; ' . $ style ; } $ view [ 'day' ] -> vars [ 'attr' ] [ 'style' ] = $ style ; } } 
public function configureOptions ( OptionsResolver $ resolver ) { $ resolver -> setDefaults ( array ( 'max_expiration_year' => date ( 'Y' ) + 10 , 'min_expiration_year' => date ( 'Y' ) , 'years' => function ( Options $ options ) { return range ( $ options [ 'min_expiration_year' ] , $ options [ 'max_expiration_year' ] ) ; } , ) ) ; } 
public function execute ( $ request ) { RequestNotSupportedException :: assertSupports ( $ this , $ request ) ; $ model = ArrayObject :: ensureArrayObject ( $ request -> getModel ( ) ) ; $ paymentRequestN = $ request -> getPaymentRequestN ( ) ; $ fields = new ArrayObject ( [ ] ) ; foreach ( $ this -> getPaymentRequestNFields ( ) as $ field ) { $ fields [ $ field ] = $ model [ 'PAYMENTREQUEST_' . $ paymentRequestN . '_' . $ field ] ; } $ fields [ 'AUTHORIZATIONID' ] = $ fields [ 'TRANSACTIONID' ] ; $ fields -> validateNotEmpty ( [ 'AMT' , 'COMPLETETYPE' , 'AUTHORIZATIONID' ] ) ; $ this -> api -> doCapture ( ( array ) $ fields ) ; $ this -> gateway -> execute ( new GetTransactionDetails ( $ model , $ paymentRequestN ) ) ; } 
public function execute ( $ request ) { RequestNotSupportedException :: assertSupports ( $ this , $ request ) ; $ model = ArrayObject :: ensureArrayObject ( $ request -> getModel ( ) ) ; try { Stripe :: setApiKey ( $ this -> keys -> getSecretKey ( ) ) ; $ plan = Plan :: create ( $ model -> toUnsafeArrayWithoutLocal ( ) ) ; $ model -> replace ( $ plan -> __toArray ( true ) ) ; } catch ( Error \ Base $ e ) { $ model -> replace ( $ e -> getJsonBody ( ) ) ; } } 
public function update ( $ model ) { $ this -> assertCrypted ( $ model ) ; $ model -> encrypt ( $ this -> crypto ) ; $ this -> decoratedStorage -> update ( $ model ) ; } 
public function find ( $ id ) { $ model = $ this -> decoratedStorage -> find ( $ id ) ; $ this -> assertCrypted ( $ model ) ; $ model -> decrypt ( $ this -> crypto ) ; return $ model ; } 
public function findBy ( array $ criteria ) { $ models = $ this -> decoratedStorage -> findBy ( $ criteria ) ; foreach ( $ models as $ model ) { $ this -> assertCrypted ( $ model ) ; $ model -> decrypt ( $ this -> crypto ) ; } return $ models ; } 
public function execute ( $ request ) { RequestNotSupportedException :: assertSupports ( $ this , $ request ) ; $ model = ArrayObject :: ensureArrayObject ( $ request -> getModel ( ) ) ; if ( null != $ model [ 'response_code' ] ) { return ; } if ( false == $ model -> validateNotEmpty ( array ( 'card_num' , 'exp_date' ) , false ) ) { try { $ obtainCreditCard = new ObtainCreditCard ( $ request -> getToken ( ) ) ; $ obtainCreditCard -> setModel ( $ request -> getFirstModel ( ) ) ; $ obtainCreditCard -> setModel ( $ request -> getModel ( ) ) ; $ this -> gateway -> execute ( $ obtainCreditCard ) ; $ card = $ obtainCreditCard -> obtain ( ) ; $ model [ 'exp_date' ] = SensitiveValue :: ensureSensitive ( $ card -> getExpireAt ( ) -> format ( 'm/y' ) ) ; $ model [ 'card_num' ] = SensitiveValue :: ensureSensitive ( $ card -> getNumber ( ) ) ; $ model [ 'card_code' ] = SensitiveValue :: ensureSensitive ( $ card -> getSecurityCode ( ) ) ; } catch ( RequestNotSupportedException $ e ) { throw new LogicException ( 'Credit card details has to be set explicitly or there has to be an action that supports ObtainCreditCard request.' ) ; } } $ api = clone $ this -> api ; $ api -> ignore_not_x_fields = true ; $ api -> setFields ( array_filter ( $ model -> toUnsafeArray ( ) ) ) ; $ response = $ api -> authorizeAndCapture ( ) ; $ model -> replace ( get_object_vars ( $ response ) ) ; } 
public function execute ( $ request ) { RequestNotSupportedException :: assertSupports ( $ this , $ request ) ; $ model = new ArrayObject ( $ request -> getModel ( ) ) ; if ( null === $ model [ 'RESULT' ] ) { $ request -> markNew ( ) ; return ; } if ( false == is_numeric ( $ model [ 'RESULT' ] ) ) { $ request -> markUnknown ( ) ; return ; } if ( $ model [ 'RESULT' ] > 0 ) { $ request -> markFailed ( ) ; return ; } if ( $ model [ 'ORIGID' ] && Api :: TRXTYPE_CREDIT == $ model [ 'TRXTYPE' ] && Api :: RESULT_SUCCESS == $ model [ 'RESULT' ] ) { $ request -> markRefunded ( ) ; return ; } if ( Api :: TRXTYPE_SALE == $ model [ 'TRXTYPE' ] && Api :: RESULT_SUCCESS == $ model [ 'RESULT' ] ) { $ request -> markCaptured ( ) ; return ; } $ request -> markUnknown ( ) ; } 
public function find ( $ id ) { if ( $ id instanceof IdentityInterface ) { if ( ltrim ( $ id -> getClass ( ) , '\\' ) === ltrim ( $ this -> modelClass , '\\' ) ) { return $ this -> doFind ( $ id -> getId ( ) ) ; } return ; } return $ this -> doFind ( $ id ) ; } 
protected function assertModelSupported ( $ model ) { if ( false == $ this -> support ( $ model ) ) { throw new InvalidArgumentException ( sprintf ( 'Invalid model given. Should be instance of %s but it is %s' , $ this -> modelClass , is_object ( $ model ) ? get_class ( $ model ) : gettype ( $ model ) ) ) ; } } 
public function getGateway ( $ name ) { $ gateway = parent :: getGateway ( $ name ) ; if ( $ this -> addStorageExtensions ) { $ this -> addStorageToGateway ( $ name , $ gateway ) ; } return $ gateway ; } 
protected function addStorageToGateway ( $ name , GatewayInterface $ gateway ) { if ( false == $ gateway instanceof Gateway ) { return ; } if ( isset ( $ this -> initializedStorageExtensions [ $ name ] ) ) { return ; } foreach ( $ this -> getStorages ( ) as $ storage ) { $ gateway -> addExtension ( new StorageExtension ( $ storage ) ) ; } $ this -> initializedStorageExtensions [ $ name ] = true ; } 
protected function populateConfig ( ArrayObject $ config ) { $ config -> defaults ( [ 'payum.factory_name' => 'paypal_pro_hosted' , 'payum.factory_title' => 'Paypal Pro Hosted' , 'payum.action.capture' => new CaptureAction ( ) , 'payum.action.notify' => new NotifyAction ( ) , 'payum.action.status' => new StatusAction ( ) , 'payum.action.sync' => new SyncAction ( ) , 'payum.action.convert_payment' => new ConvertPaymentAction ( ) , 'payum.action.api.get_transaction_details' => new GetTransactionDetailsAction ( ) , 'payum.action.api.create_button_payment' => new CreateButtonPaymentAction ( ) , ] ) ; if ( false == $ config [ 'payum.api' ] ) { $ config [ 'payum.default_options' ] = [ 'username' => '' , 'password' => '' , 'signature' => '' , 'business' => '' , 'sandbox' => true , ] ; $ config -> defaults ( $ config [ 'payum.default_options' ] ) ; $ config [ 'payum.required_options' ] = [ 'username' , 'password' , 'signature' , ] ; $ config [ 'payum.api' ] = function ( ArrayObject $ config ) { $ config -> validateNotEmpty ( $ config [ 'payum.required_options' ] ) ; $ paypalConfig = array ( 'username' => $ config [ 'username' ] , 'password' => $ config [ 'password' ] , 'signature' => $ config [ 'signature' ] , 'business' => $ config [ 'business' ] , 'sandbox' => $ config [ 'sandbox' ] , ) ; return new Api ( $ paypalConfig , $ config [ 'payum.http_client' ] , $ config [ 'httplug.message_factory' ] ) ; } ; } } 
public function execute ( $ request ) { RequestNotSupportedException :: assertSupports ( $ this , $ request ) ; $ details = ArrayObject :: ensureArrayObject ( $ request -> getModel ( ) ) ; $ klarna = $ this -> getKlarna ( ) ; try { $ this -> gateway -> execute ( new PopulateKlarnaFromDetails ( $ details , $ klarna ) ) ; $ details [ 'updated' ] = $ klarna -> update ( $ details [ 'rno' ] ) ; } catch ( \ KlarnaException $ e ) { $ this -> populateDetailsWithError ( $ details , $ e , $ request ) ; } } 
public static function value ( $ value , $ shortClass = true ) { if ( is_object ( $ value ) ) { if ( $ shortClass ) { $ ro = new \ ReflectionObject ( $ value ) ; return $ ro -> getShortName ( ) ; } return get_class ( $ value ) ; } return gettype ( $ value ) ; } 
public function execute ( $ request ) { RequestNotSupportedException :: assertSupports ( $ this , $ request ) ; $ details = ArrayObject :: ensureArrayObject ( $ request -> getModel ( ) ) ; if ( ! isset ( $ details [ 'status' ] ) && isset ( $ details [ 'transaction_id' ] ) && isset ( $ details [ 'expires' ] ) && $ details [ 'expires' ] < time ( ) ) { $ request -> markExpired ( ) ; return ; } if ( ! isset ( $ details [ 'transaction_id' ] ) || ! strlen ( $ details [ 'transaction_id' ] ) ) { $ request -> markNew ( ) ; return ; } if ( ! isset ( $ details [ 'status' ] ) ) { $ request -> markNew ( ) ; return ; } $ subcode = isset ( $ details [ 'statusReason' ] ) ? $ details [ 'statusReason' ] : null ; switch ( $ details [ 'status' ] ) { case Api :: STATUS_LOSS : $ request -> markFailed ( ) ; break ; case Api :: STATUS_PENDING : $ request -> markPending ( ) ; break ; case Api :: STATUS_RECEIVED : switch ( $ subcode ) { case Api :: SUB_PARTIALLY : $ request -> markUnknown ( ) ; break ; case Api :: SUB_CREDITED : case Api :: SUB_OVERPAYMENT : $ request -> markCaptured ( ) ; break ; } break ; case Api :: STATUS_REFUNDED : switch ( $ subcode ) { default : case Api :: SUB_COMPENSATION : $ request -> markUnknown ( ) ; break ; case Api :: SUB_REFUNDED : $ request -> markRefunded ( ) ; break ; } break ; case Api :: STATUS_UNTRACEABLE : $ request -> markCaptured ( ) ; break ; default : $ request -> markUnknown ( ) ; break ; } } 
protected function populateConfig ( ArrayObject $ config ) { if ( false == class_exists ( Stripe :: class ) ) { throw new LogicException ( 'You must install "stripe/stripe-php:~2.0|~3.0" library.' ) ; } $ config -> defaults ( [ 'payum.factory_name' => 'stripe_checkout' , 'payum.factory_title' => 'Stripe Checkout' , 'payum.template.obtain_token' => '@PayumStripe/Action/obtain_checkout_token.html.twig' , 'payum.action.capture' => new CaptureAction ( ) , 'payum.action.convert_payment' => new ConvertPaymentAction ( ) , 'payum.action.status' => new StatusAction ( ) , 'payum.action.get_credit_card_token' => new GetCreditCardTokenAction ( ) , 'payum.action.obtain_token' => function ( ArrayObject $ config ) { return new ObtainTokenAction ( $ config [ 'payum.template.obtain_token' ] ) ; } , 'payum.action.create_charge' => new CreateChargeAction ( ) , 'payum.action.create_customer' => new CreateCustomerAction ( ) , 'payum.action.create_plan' => new CreatePlanAction ( ) , 'payum.action.create_token' => new CreateTokenAction ( ) , 'payum.action.create_subscription' => new CreateSubscriptionAction ( ) , 'payum.extension.create_customer' => new CreateCustomerExtension ( ) , ] ) ; if ( false == $ config [ 'payum.api' ] ) { $ config [ 'payum.default_options' ] = [ 'publishable_key' => '' , 'secret_key' => '' ] ; $ config -> defaults ( $ config [ 'payum.default_options' ] ) ; $ config [ 'payum.required_options' ] = [ 'publishable_key' , 'secret_key' ] ; $ config [ 'payum.api' ] = function ( ArrayObject $ config ) { $ config -> validateNotEmpty ( $ config [ 'payum.required_options' ] ) ; return new Keys ( $ config [ 'publishable_key' ] , $ config [ 'secret_key' ] ) ; } ; } $ config [ 'payum.paths' ] = array_replace ( [ 'PayumStripe' => __DIR__ . '/Resources/views' , ] , $ config [ 'payum.paths' ] ? : [ ] ) ; } 
public function execute ( $ request ) { RequestNotSupportedException :: assertSupports ( $ this , $ request ) ; $ request -> method = isset ( $ _SERVER [ 'REQUEST_METHOD' ] ) ? $ _SERVER [ 'REQUEST_METHOD' ] : 'GET' ; $ request -> query = $ _GET ; $ request -> request = $ _REQUEST ; $ request -> clientIp = isset ( $ _SERVER [ 'REMOTE_ADDR' ] ) ? $ _SERVER [ 'REMOTE_ADDR' ] : '' ; $ request -> uri = isset ( $ _SERVER [ 'REQUEST_URI' ] ) ? $ _SERVER [ 'REQUEST_URI' ] : '' ; $ request -> userAgent = isset ( $ _SERVER [ 'HTTP_USER_AGENT' ] ) ? $ _SERVER [ 'HTTP_USER_AGENT' ] : '' ; $ request -> content = file_get_contents ( 'php://input' ) ; } 
public static function createGuzzle ( ) { $ client = null ; if ( ! class_exists ( Client :: class ) ) { @ trigger_error ( 'The function "HttpClientFactory::createGuzzle" is depcrecated and will be removed in 2.0.' , E_USER_DEPRECATED ) ; throw new \ LogicException ( 'Can not use "HttpClientFactory::createGuzzle" since Guzzle is not installed. This function is deprecated and will be removed in 2.0.' ) ; } $ version = \ GuzzleHttp \ ClientInterface :: VERSION ; if ( substr ( $ version , 0 , 1 ) !== '6' ) { throw new \ LogicException ( 'This version of Guzzle is not supported.' ) ; } $ curl = curl_version ( ) ; $ curlOptions = [ CURLOPT_USERAGENT => sprintf ( 'Payum/1.x curl/%s PHP/%s' , $ curl [ 'version' ] , phpversion ( ) ) , ] ; return new \ GuzzleHttp \ Client ( [ 'curl' => $ curlOptions , ] ) ; } 
public function execute ( $ request ) { RequestNotSupportedException :: assertSupports ( $ this , $ request ) ; $ currency = is_numeric ( $ request -> code ) ? $ this -> iso4217 -> findByNumeric ( $ request -> code ) : $ this -> iso4217 -> findByAlpha3 ( $ request -> code ) ; $ request -> alpha3 = $ currency -> getAlpha3 ( ) ; $ request -> country = $ currency -> getCountry ( ) ; $ request -> exp = $ currency -> getExp ( ) ; $ request -> name = $ currency -> getName ( ) ; $ request -> numeric = $ currency -> getNumeric ( ) ; } 
public function build ( ArrayObject $ config ) { $ action = new ObtainCreditCardAction ( $ this -> formFactory , $ config [ 'payum.template.obtain_credit_card' ] ) ; $ action -> setRequestStack ( $ this -> requestStack ) ; return $ action ; } 
protected function populateConfig ( ArrayObject $ config ) { if ( ! class_exists ( 'KlarnaCurrency' ) ) { throw new \ LogicException ( 'You must install "fp/klarna-invoice" library.' ) ; } $ config -> defaults ( array ( 'payum.factory_name' => 'klarna_invoice' , 'payum.factory_title' => 'Klarna Invoice' , 'sandbox' => true , 'pClassStorage' => 'json' , 'pClassStoragePath' => './pclasses.json' , 'xmlRpcVerifyHost' => 2 , 'xmlRpcVerifyPeer' => true , 'payum.action.capture' => new CaptureAction ( ) , 'payum.action.authorize' => new AuthorizeAction ( ) , 'payum.action.status' => new StatusAction ( ) , 'payum.action.sync' => new SyncAction ( ) , 'payum.action.refund' => new RefundAction ( ) , 'payum.action.api.activate' => new ActivateAction ( ) , 'payum.action.api.activate_reservation' => new ActivateReservationAction ( ) , 'payum.action.api.cancel_reservation' => new CancelReservationAction ( ) , 'payum.action.api.check_order_status' => new CheckOrderStatusAction ( ) , 'payum.action.api.get_addresses' => new GetAddressesAction ( ) , 'payum.action.api.populate_klarna_from_details' => new PopulateKlarnaFromDetailsAction ( ) , 'payum.action.api.credit_invoice' => new CreditInvoiceAction ( ) , 'payum.action.api.credit_part' => new CreditPartAction ( ) , 'payum.action.api.reserve_amount' => new ReserveAmountAction ( ) , 'payum.action.api.return_amount' => new ReturnAmountAction ( ) , 'payum.action.api.email_invoice' => new EmailInvoiceAction ( ) , 'payum.action.api.send_invoice' => new SendInvoiceAction ( ) , 'payum.action.api.update' => new UpdateAction ( ) , ) ) ; if ( false == $ config [ 'payum.api' ] ) { $ config [ 'payum.default_options' ] = array ( 'eid' => '' , 'secret' => '' , 'country' => '' , 'language' => '' , 'currency' => '' , 'sandbox' => true , ) ; $ config -> defaults ( $ config [ 'payum.default_options' ] ) ; $ config [ 'payum.required_options' ] = array ( 'eid' , 'secret' , 'country' , 'language' , 'currency' ) ; $ config -> defaults ( array ( 'sandbox' => true , ) ) ; $ config [ 'payum.api' ] = function ( ArrayObject $ config ) { $ config -> validateNotEmpty ( $ config [ 'payum.required_options' ] ) ; $ config [ 'mode' ] = $ config [ 'sandbox' ] ? \ Klarna :: BETA : \ Klarna :: LIVE ; if ( null === $ country = \ KlarnaCountry :: fromCode ( $ config [ 'country' ] ) ) { throw new LogicException ( sprintf ( 'Given %s country code is not valid. Klarna cannot recognize it.' , $ config [ 'country' ] ) ) ; } if ( null === $ language = \ KlarnaLanguage :: fromCode ( $ config [ 'language' ] ) ) { throw new LogicException ( sprintf ( 'Given %s language code is not valid. Klarna cannot recognize it.' , $ config [ 'language' ] ) ) ; } if ( null === $ currency = \ KlarnaCurrency :: fromCode ( $ config [ 'currency' ] ) ) { throw new LogicException ( sprintf ( 'Given %s currency code is not valid. Klarna cannot recognize it.' , $ config [ 'currency' ] ) ) ; } $ klarnaConfig = new Config ( ) ; $ klarnaConfig -> eid = $ config [ 'eid' ] ; $ klarnaConfig -> secret = $ config [ 'secret' ] ; $ klarnaConfig -> mode = $ config [ 'mode' ] ; $ klarnaConfig -> country = $ country ; $ klarnaConfig -> language = $ language ; $ klarnaConfig -> currency = $ currency ; $ klarnaConfig -> pClassStorage = $ config [ 'pClassStorage' ] ; $ klarnaConfig -> pClassStoragePath = $ config [ 'pClassStoragePath' ] ; $ klarnaConfig -> xmlRpcVerifyHost = $ config [ 'xmlRpcVerifyHost' ] ; $ klarnaConfig -> xmlRpcVerifyHost = $ config [ 'xmlRpcVerifyHost' ] ; return $ klarnaConfig ; } ; } } 
public function execute ( $ request ) { RequestNotSupportedException :: assertSupports ( $ this , $ request ) ; $ this -> gateway -> execute ( new AutoPayAgreement ( $ request -> getModel ( ) ) ) ; } 
public function execute ( $ request ) { RequestNotSupportedException :: assertSupports ( $ this , $ request ) ; $ model = ArrayObject :: ensureArrayObject ( $ request -> getModel ( ) ) ; if ( $ model [ 'reservation' ] ) { return ; } $ model [ 'activate' ] = false ; $ backupConfig = clone $ this -> api ; $ token = $ model [ 'recurring_token' ] ; try { unset ( $ model [ 'recurring_token' ] ) ; $ baseUri = Constants :: BASE_URI_LIVE == $ backupConfig -> baseUri ? Constants :: BASE_URI_RECURRING_LIVE : Constants :: BASE_URI_RECURRING_SANDBOX ; $ this -> api -> contentType = Constants :: CONTENT_TYPE_RECURRING_ORDER_V1 ; $ this -> api -> acceptHeader = Constants :: ACCEPT_HEADER_RECURRING_ORDER_ACCEPTED_V1 ; $ this -> api -> baseUri = str_replace ( '{recurring_token}' , $ token , $ baseUri ) ; $ this -> gateway -> execute ( $ createOrderRequest = new CreateOrder ( $ model ) ) ; $ model -> replace ( $ createOrderRequest -> getOrder ( ) -> marshal ( ) ) ; } catch ( \ Exception $ e ) { $ this -> api -> contentType = $ backupConfig -> contentType ; $ this -> api -> acceptHeader = $ backupConfig -> acceptHeader ; $ this -> api -> baseUri = $ backupConfig -> baseUri ; $ model [ 'recurring_token' ] = $ token ; throw $ e ; } $ model [ 'recurring_token' ] = $ token ; $ this -> api -> contentType = $ backupConfig -> contentType ; $ this -> api -> acceptHeader = $ backupConfig -> acceptHeader ; $ this -> api -> baseUri = $ backupConfig -> baseUri ; } 
public function supports ( $ request ) { if ( false == ( $ request instanceof Authorize && $ request -> getModel ( ) instanceof \ ArrayAccess ) ) { return false ; } $ model = ArrayObject :: ensureArrayObject ( $ request -> getModel ( ) ) ; return false == $ model [ 'recurring' ] && $ model [ 'recurring_token' ] ; } 
public function execute ( $ request ) { RequestNotSupportedException :: assertSupports ( $ this , $ request ) ; $ payout = $ request -> getSource ( ) ; $ details = ArrayObject :: ensureArrayObject ( $ payout -> getDetails ( ) ) ; $ details [ 'amount' ] = $ payout -> getTotalAmount ( ) ; $ details [ 'currency' ] = $ payout -> getCurrencyCode ( ) ; $ details [ 'description' ] = $ payout -> getDescription ( ) ; $ details [ 'recipient_email' ] = $ payout -> getRecipientEmail ( ) ; $ details [ 'recipient_id' ] = $ payout -> getRecipientId ( ) ; $ details -> defaults ( array ( Constants :: FIELD_PAYOUT => true , ) ) ; $ request -> setResult ( ( array ) $ details ) ; } 
public function execute ( $ request ) { RequestNotSupportedException :: assertSupports ( $ this , $ request ) ; $ model = $ request -> getModel ( ) ; $ details = $ model -> getDetails ( ) ; if ( is_array ( $ details ) ) { $ details = ArrayObject :: ensureArrayObject ( $ details ) ; } $ request -> setModel ( $ details ) ; try { $ this -> gateway -> execute ( $ request ) ; } finally { if ( $ model instanceof DetailsAwareInterface ) { $ model -> setDetails ( $ details ) ; } } } 
protected function populateConfig ( ArrayObject $ config ) { if ( ! class_exists ( \ AuthorizeNetAIM :: class ) ) { throw new \ LogicException ( 'You must install "authorizenet/authorizenet" library.' ) ; } $ config -> defaults ( array ( 'payum.factory_name' => 'authorize_net_aim' , 'payum.factory_title' => 'Authorize.NET AIM' , 'payum.action.capture' => new CaptureAction ( ) , 'payum.action.status' => new StatusAction ( ) , 'payum.action.convert_payment' => new ConvertPaymentAction ( ) , ) ) ; if ( false == $ config [ 'payum.api' ] ) { $ config [ 'payum.default_options' ] = array ( 'login_id' => '' , 'transaction_key' => '' , 'sandbox' => true , ) ; $ config -> defaults ( $ config [ 'payum.default_options' ] ) ; $ config [ 'payum.required_options' ] = array ( 'login_id' , 'transaction_key' ) ; $ config [ 'payum.api' ] = function ( ArrayObject $ config ) { $ config -> validateNotEmpty ( $ config [ 'payum.required_options' ] ) ; $ api = new AuthorizeNetAIM ( $ config [ 'login_id' ] , $ config [ 'transaction_key' ] ) ; $ api -> setSandbox ( $ config [ 'sandbox' ] ) ; return $ api ; } ; } } 
public function execute ( $ request ) { RequestNotSupportedException :: assertSupports ( $ this , $ request ) ; $ model = ArrayObject :: ensureArrayObject ( $ request -> getModel ( ) ) ; if ( false == ( $ model [ 'card' ] || $ model [ 'customer' ] ) ) { throw new LogicException ( 'The either card token or customer id has to be set.' ) ; } if ( is_array ( $ model [ 'card' ] ) ) { throw new LogicException ( 'The token has already been used.' ) ; } try { Stripe :: setApiKey ( $ this -> keys -> getSecretKey ( ) ) ; $ charge = Charge :: create ( $ model -> toUnsafeArrayWithoutLocal ( ) ) ; $ model -> replace ( $ charge -> __toArray ( true ) ) ; } catch ( Error \ Base $ e ) { $ model -> replace ( $ e -> getJsonBody ( ) ) ; } } 
public function execute ( $ request ) { RequestNotSupportedException :: assertSupports ( $ this , $ request ) ; $ model = ArrayObject :: ensureArrayObject ( $ request -> getModel ( ) ) ; if ( $ model [ 'error_code' ] ) { $ request -> markFailed ( ) ; return ; } if ( $ model [ 'invoice_number' ] ) { $ request -> markCaptured ( ) ; return ; } if ( $ model [ 'reservation' ] ) { $ request -> markAuthorized ( ) ; return ; } if ( false == $ model [ 'status' ] || Constants :: STATUS_CHECKOUT_INCOMPLETE == $ model [ 'status' ] ) { $ request -> markNew ( ) ; return ; } if ( Constants :: STATUS_CHECKOUT_COMPLETE == $ model [ 'status' ] ) { $ request -> markPending ( ) ; return ; } $ request -> markUnknown ( ) ; } 
public function execute ( $ request ) { RequestNotSupportedException :: assertSupports ( $ this , $ request ) ; $ this -> gateway -> execute ( new CheckAgreement ( $ request -> getModel ( ) ) ) ; } 
public function supports ( $ request ) { return $ request instanceof Sync && $ request -> getModel ( ) instanceof \ ArrayAccess && 
public function initialize ( array $ parameters ) { $ parameters [ 'accountNumber' ] = $ this -> options [ 'account_number' ] ; 
public function complete ( array $ parameters ) { $ parameters [ 'accountNumber' ] = $ this -> options [ 'account_number' ] ; $ parameters [ 'hash' ] = $ this -> calculateHash ( $ parameters , array ( 'accountNumber' , 'orderRef' , ) ) ; return $ this -> call ( 'Complete' , $ parameters , $ this -> getPxOrderWsdl ( ) ) ; } 
public function check ( array $ parameters ) { $ parameters [ 'accountNumber' ] = $ this -> options [ 'account_number' ] ; $ parameters [ 'hash' ] = $ this -> calculateHash ( $ parameters , array ( 'accountNumber' , 'transactionNumber' , ) ) ; return $ this -> call ( 'Check2' , $ parameters , $ this -> getPxOrderWsdl ( ) ) ; } 
public function execute ( $ request ) { RequestNotSupportedException :: assertSupports ( $ this , $ request ) ; $ model = ArrayObject :: ensureArrayObject ( $ request -> getModel ( ) ) ; if ( $ model [ 'orderRef' ] ) { throw new LogicException ( 'The order has already been initialized.' ) ; } $ model -> validatedKeysSet ( array ( 'price' , 'priceArgList' , 'vat' , 'currency' , 'orderId' , 'productNumber' , 'purchaseOperation' , 'view' , 'description' , 'additionalValues' , 'returnUrl' , 'cancelUrl' , 'clientIPAddress' , 'clientIdentifier' , 'agreementRef' , 'clientLanguage' , ) ) ; $ result = $ this -> api -> initialize ( ( array ) $ model ) ; $ model -> replace ( $ result ) ; if ( $ model [ 'redirectUrl' ] ) { throw new HttpRedirect ( $ model [ 'redirectUrl' ] ) ; } } 
public function onPreExecute ( Context $ context ) { $ event = new ExecuteEvent ( $ context ) ; $ this -> dispatcher -> dispatch ( PayumEvents :: GATEWAY_PRE_EXECUTE , $ event ) ; } 
public function onExecute ( Context $ context ) { $ event = new ExecuteEvent ( $ context ) ; $ this -> dispatcher -> dispatch ( PayumEvents :: GATEWAY_EXECUTE , $ event ) ; } 
public function onPostExecute ( Context $ context ) { $ event = new ExecuteEvent ( $ context ) ; $ this -> dispatcher -> dispatch ( PayumEvents :: GATEWAY_POST_EXECUTE , $ event ) ; } 
public function execute ( $ request ) { RequestNotSupportedException :: assertSupports ( $ this , $ request ) ; $ model = ArrayObject :: ensureArrayObject ( $ request -> getModel ( ) ) ; if ( false == $ model [ 'PROFILEID' ] ) { return ; } $ this -> gateway -> execute ( new GetRecurringPaymentsProfileDetails ( $ model ) ) ; } 
public function supports ( $ request ) { if ( false == $ request instanceof Sync ) { return false ; } $ model = $ request -> getModel ( ) ; if ( false == $ model instanceof \ ArrayAccess ) { return false ; } return isset ( $ model [ 'BILLINGPERIOD' ] ) && null !== $ model [ 'BILLINGPERIOD' ] ; } 
public function execute ( $ request ) { RequestNotSupportedException :: assertSupports ( $ this , $ request ) ; $ details = ArrayObject :: ensureArrayObject ( $ request -> getModel ( ) ) ; if ( false == $ details [ 'transaction_id' ] ) { if ( false == $ details [ 'success_url' ] && $ request -> getToken ( ) ) { $ details [ 'success_url' ] = $ request -> getToken ( ) -> getTargetUrl ( ) ; } if ( false == $ details [ 'abort_url' ] && $ request -> getToken ( ) ) { $ details [ 'abort_url' ] = $ request -> getToken ( ) -> getTargetUrl ( ) ; } if ( false == $ details [ 'notification_url' ] && $ request -> getToken ( ) && $ this -> tokenFactory ) { $ notifyToken = $ this -> tokenFactory -> createNotifyToken ( $ request -> getToken ( ) -> getGatewayName ( ) , $ request -> getToken ( ) -> getDetails ( ) ) ; $ details [ 'notification_url' ] = $ notifyToken -> getTargetUrl ( ) ; } $ this -> gateway -> execute ( new CreateTransaction ( $ details ) ) ; } $ this -> gateway -> execute ( new Sync ( $ details ) ) ; } 
public function doSale ( array $ fields ) { $ fields [ 'TRXTYPE' ] = self :: TRXTYPE_SALE ; $ this -> addAuthorizeFields ( $ fields ) ; $ result = $ this -> doRequest ( $ fields ) ; $ result [ 'TRXTYPE' ] = self :: TRXTYPE_SALE ; return $ result ; } 
public function doCredit ( array $ fields ) { $ fields [ 'TRXTYPE' ] = self :: TRXTYPE_CREDIT ; $ this -> addAuthorizeFields ( $ fields ) ; $ result = $ this -> doRequest ( $ fields ) ; $ result [ 'TRXTYPE' ] = self :: TRXTYPE_CREDIT ; return $ result ; } 
protected function doGetIdentity ( $ model ) { $ modelMetadata = $ this -> objectManager -> getClassMetadata ( get_class ( $ model ) ) ; $ id = $ modelMetadata -> getIdentifierValues ( $ model ) ; if ( count ( $ id ) > 1 ) { throw new \ LogicException ( 'Storage not support composite primary ids' ) ; } return new Identity ( array_shift ( $ id ) , $ model ) ; } 
public function execute ( $ request ) { RequestNotSupportedException :: assertSupports ( $ this , $ request ) ; $ details = ArrayObject :: ensureArrayObject ( $ request -> getModel ( ) ) ; if ( ! isset ( $ details [ 'transaction_id' ] ) ) { throw new LogicException ( 'The parameter "transaction_id" must be set. Have you run CreateTransactionAction?' ) ; } if ( ! isset ( $ details [ 'refund_amount' ] ) ) { if ( ! isset ( $ details [ 'amount' ] ) ) { throw new LogicException ( 'One of the parameters "refund_amount" or "amount" must be set.' ) ; } $ details [ 'refund_amount' ] = $ details [ 'amount' ] ; } $ details -> replace ( $ this -> api -> refundTransaction ( ( array ) $ details ) ) ; } 
public function execute ( $ request ) { RequestNotSupportedException :: assertSupports ( $ this , $ request ) ; $ model = ArrayObject :: ensureArrayObject ( $ request -> getModel ( ) ) ; $ merchant = ArrayObject :: ensureArrayObject ( $ model [ 'merchant' ] ? : [ ] ) ; if ( false == $ merchant [ 'checkout_uri' ] && $ this -> api -> checkoutUri ) { $ merchant [ 'checkout_uri' ] = $ this -> api -> checkoutUri ; } if ( false == $ merchant [ 'terms_uri' ] && $ this -> api -> termsUri ) { $ merchant [ 'terms_uri' ] = $ this -> api -> termsUri ; } if ( false == $ merchant [ 'confirmation_uri' ] && $ request -> getToken ( ) ) { $ merchant [ 'confirmation_uri' ] = $ request -> getToken ( ) -> getTargetUrl ( ) ; } if ( empty ( $ merchant [ 'push_uri' ] ) && $ request -> getToken ( ) && $ this -> tokenFactory ) { $ notifyToken = $ this -> tokenFactory -> createNotifyToken ( $ request -> getToken ( ) -> getGatewayName ( ) , $ request -> getToken ( ) -> getDetails ( ) ) ; $ merchant [ 'push_uri' ] = $ notifyToken -> getTargetUrl ( ) ; } $ merchant -> validateNotEmpty ( [ 'checkout_uri' , 'terms_uri' , 'confirmation_uri' , 'push_uri' ] ) ; $ model [ 'merchant' ] = ( array ) $ merchant ; if ( false == $ model [ 'location' ] ) { $ createOrderRequest = new CreateOrder ( $ model ) ; $ this -> gateway -> execute ( $ createOrderRequest ) ; $ model -> replace ( $ createOrderRequest -> getOrder ( ) -> marshal ( ) ) ; $ model [ 'location' ] = $ createOrderRequest -> getOrder ( ) -> getLocation ( ) ; } $ this -> gateway -> execute ( new Sync ( $ model ) ) ; if ( Constants :: STATUS_CHECKOUT_INCOMPLETE == $ model [ 'status' ] ) { $ renderTemplate = new RenderTemplate ( $ this -> templateName , array ( 'snippet' => $ model [ 'gui' ] [ 'snippet' ] , ) ) ; $ this -> gateway -> execute ( $ renderTemplate ) ; throw new HttpResponse ( $ renderTemplate -> getResult ( ) ) ; } } 
public function convert ( ReplyInterface $ reply ) { if ( $ reply instanceof SymfonyHttpResponse ) { return $ reply -> getResponse ( ) ; } elseif ( $ reply instanceof HttpResponse ) { $ headers = $ reply -> getHeaders ( ) ; $ headers [ 'X-Status-Code' ] = $ reply -> getStatusCode ( ) ; return new Response ( $ reply -> getContent ( ) , $ reply -> getStatusCode ( ) , $ headers ) ; } $ ro = new \ ReflectionObject ( $ reply ) ; throw new LogicException ( sprintf ( 'Cannot convert reply %s to http response.' , $ ro -> getShortName ( ) ) , null , $ reply ) ; } 
public function execute ( $ request ) { RequestNotSupportedException :: assertSupports ( $ this , $ request ) ; $ model = ArrayObject :: ensureArrayObject ( $ request -> getModel ( ) ) ; if ( false == $ model [ 'location' ] ) { throw new LogicException ( 'Location has to be provided to fetch an order' ) ; } $ this -> callWithRetry ( function ( ) use ( $ model , $ request ) { $ order = new \ Klarna_Checkout_Order ( $ this -> getConnector ( ) , $ model [ 'location' ] ) ; $ order -> fetch ( ) ; $ request -> setOrder ( $ order ) ; } ) ; } 
public function execute ( $ request ) { RequestNotSupportedException :: assertSupports ( $ this , $ request ) ; $ payout = $ request -> getModel ( ) ; $ this -> gateway -> execute ( $ status = new GetHumanStatus ( $ payout ) ) ; if ( $ status -> isNew ( ) ) { $ this -> gateway -> execute ( $ convert = new Convert ( $ payout , 'array' , $ request -> getToken ( ) ) ) ; $ payout -> setDetails ( $ convert -> getResult ( ) ) ; } $ details = ArrayObject :: ensureArrayObject ( $ payout -> getDetails ( ) ) ; $ request -> setModel ( $ details ) ; try { $ this -> gateway -> execute ( $ request ) ; } finally { $ payout -> setDetails ( $ details ) ; } } 
public function execute ( $ request ) { RequestNotSupportedException :: assertSupports ( $ this , $ request ) ; $ model = new ArrayObject ( $ request -> getModel ( ) ) ; if ( is_numeric ( $ model [ 'RESULT' ] ) ) { return ; } $ cardFields = array ( 'ACCT' , 'CVV2' , 'EXPDATE' ) ; if ( false == $ model -> validateNotEmpty ( $ cardFields , false ) ) { try { $ obtainCreditCard = new ObtainCreditCard ( $ request -> getToken ( ) ) ; $ obtainCreditCard -> setModel ( $ request -> getFirstModel ( ) ) ; $ obtainCreditCard -> setModel ( $ request -> getModel ( ) ) ; $ this -> gateway -> execute ( $ obtainCreditCard ) ; $ card = $ obtainCreditCard -> obtain ( ) ; $ model [ 'EXPDATE' ] = SensitiveValue :: ensureSensitive ( $ card -> getExpireAt ( ) -> format ( 'my' ) ) ; $ model [ 'ACCT' ] = SensitiveValue :: ensureSensitive ( $ card -> getNumber ( ) ) ; $ model [ 'CVV2' ] = SensitiveValue :: ensureSensitive ( $ card -> getSecurityCode ( ) ) ; } catch ( RequestNotSupportedException $ e ) { throw new LogicException ( 'Credit card details has to be set explicitly or there has to be an action that supports ObtainCreditCard request.' ) ; } } $ model -> replace ( $ this -> api -> doSale ( $ model -> toUnsafeArray ( ) ) ) ; } 
public function execute ( $ request ) { RequestNotSupportedException :: assertSupports ( $ this , $ request ) ; $ model = ArrayObject :: ensureArrayObject ( $ request -> getModel ( ) ) ; if ( false == $ model [ 'TOKEN' ] ) { return ; } $ copiedModel = new ArrayObject ( array ( 'TOKEN' => $ model [ 'TOKEN' ] , ) ) ; $ this -> gateway -> execute ( new GetExpressCheckoutDetails ( $ copiedModel ) ) ; if ( Api :: L_ERRORCODE_SESSION_HAS_EXPIRED != $ copiedModel [ 'L_ERRORCODE0' ] ) { $ model -> replace ( $ copiedModel ) ; } foreach ( range ( 0 , 9 ) as $ index ) { if ( $ model [ 'PAYMENTREQUEST_' . $ index . '_TRANSACTIONID' ] ) { $ this -> gateway -> execute ( new GetTransactionDetails ( $ model , $ index ) ) ; } } } 
public function execute ( $ request ) { RequestNotSupportedException :: assertSupports ( $ this , $ request ) ; $ details = ArrayObject :: ensureArrayObject ( $ request -> getModel ( ) ) ; if ( false == $ details [ 'returnUrl' ] && $ request -> getToken ( ) ) { $ details [ 'returnUrl' ] = $ request -> getToken ( ) -> getTargetUrl ( ) ; } if ( false == $ details [ 'cancelUrl' ] && $ request -> getToken ( ) ) { $ details [ 'cancelUrl' ] = $ request -> getToken ( ) -> getTargetUrl ( ) ; } if ( false == $ details [ 'clientIPAddress' ] ) { $ this -> gateway -> execute ( $ httpRequest = new GetHttpRequest ( ) ) ; $ details [ 'clientIPAddress' ] = $ httpRequest -> clientIp ; } if ( false == $ details [ 'orderRef' ] ) { $ this -> gateway -> execute ( new InitializeOrder ( $ details ) ) ; } if ( $ details [ 'orderRef' ] ) { $ this -> gateway -> execute ( new CompleteOrder ( $ details ) ) ; if ( $ details [ 'recurring' ] ) { $ this -> gateway -> execute ( new StartRecurringPayment ( $ details ) ) ; } } } 
public function supports ( $ request ) { if ( false == ( $ request instanceof Capture && $ request -> getModel ( ) instanceof \ ArrayAccess ) ) { return false ; } $ model = ArrayObject :: ensureArrayObject ( $ request -> getModel ( ) ) ; if ( $ model [ 'recurring' ] ) { return true ; } 
public function execute ( $ request ) { RequestNotSupportedException :: assertSupports ( $ this , $ request ) ; $ model = ArrayObject :: ensureArrayObject ( $ request -> getModel ( ) ) ; if ( null == $ model [ 'txn_id' ] ) { throw new LogicException ( 'TRANSACTIONID must be set.' ) ; } $ fields = new ArrayObject ( [ ] ) ; $ fields [ 'TRANSACTIONID' ] = $ model [ 'txn_id' ] ; $ result = $ this -> api -> getTransactionDetails ( ( array ) $ fields ) ; $ model -> replace ( $ result ) ; } 
public function execute ( $ request ) { RequestNotSupportedException :: assertSupports ( $ this , $ request ) ; $ details = ArrayObject :: ensureArrayObject ( $ request -> getModel ( ) ) ; $ klarna = $ this -> getKlarna ( ) ; try { $ klarna -> returnAmount ( $ details [ 'invoice_number' ] , $ details [ 'amount' ] , $ details [ 'vat' ] , $ details [ 'flags' ] ? : \ KlarnaFlags :: NO_FLAG , $ details [ 'description' ] ) ; } catch ( \ KlarnaException $ e ) { $ this -> populateDetailsWithError ( $ details , $ e , $ request ) ; } } 
public function execute ( $ request ) { RequestNotSupportedException :: assertSupports ( $ this , $ request ) ; $ details = ArrayObject :: ensureArrayObject ( $ request -> getModel ( ) ) ; $ klarna = $ this -> getKlarna ( ) ; try { $ this -> gateway -> execute ( new PopulateKlarnaFromDetails ( $ details , $ klarna ) ) ; $ result = $ klarna -> reserveAmount ( $ details [ 'pno' ] , $ details [ 'gender' ] , $ details [ 'amount' ] ? : - 1 , $ details [ 'reservation_flags' ] ? : \ KlarnaFlags :: NO_FLAG ) ; $ details [ 'rno' ] = $ result [ 0 ] ; $ details [ 'status' ] = $ result [ 1 ] ; } catch ( \ KlarnaException $ e ) { $ this -> populateDetailsWithError ( $ details , $ e , $ request ) ; } } 
public function getStorage ( $ class ) { $ class = is_object ( $ class ) ? get_class ( $ class ) : $ class ; 
public function getStorages ( ) { $ storages = array ( ) ; foreach ( $ this -> storages as $ modelClass => $ storageId ) { $ storages [ $ modelClass ] = $ this -> getService ( $ storageId ) ; } return $ storages ; } 
public function getGateway ( $ name ) { if ( ! isset ( $ this -> gateways [ $ name ] ) ) { throw new InvalidArgumentException ( sprintf ( 'Gateway "%s" does not exist.' , $ name ) ) ; } return $ this -> getService ( $ this -> gateways [ $ name ] ) ; } 
public function getGateways ( ) { $ gateways = array ( ) ; foreach ( $ this -> gateways as $ name => $ id ) { $ gateways [ $ name ] = $ this -> getGateway ( $ name ) ; } return $ gateways ; } 
public function getGatewayFactory ( $ name ) { if ( ! isset ( $ this -> gatewayFactories [ $ name ] ) ) { throw new InvalidArgumentException ( sprintf ( 'Gateway factory "%s" does not exist.' , $ name ) ) ; } return $ this -> getService ( $ this -> gatewayFactories [ $ name ] ) ; } 
public function getGatewayFactories ( ) { $ gatewayFactories = array ( ) ; foreach ( $ this -> gatewayFactories as $ name => $ id ) { $ gatewayFactories [ $ name ] = $ this -> getGatewayFactory ( $ name ) ; } return $ gatewayFactories ; } 
public function execute ( $ request ) { RequestNotSupportedException :: assertSupports ( $ this , $ request ) ; $ model = ArrayObject :: ensureArrayObject ( $ request -> getModel ( ) ) ; try { Stripe :: setApiKey ( $ this -> api -> getSecretKey ( ) ) ; $ subscription = Subscription :: create ( $ model -> toUnsafeArrayWithoutLocal ( ) ) ; $ model -> replace ( $ subscription -> __toArray ( true ) ) ; } catch ( Error \ Base $ e ) { $ model -> replace ( $ e -> getJsonBody ( ) ) ; } } 
public function execute ( $ request ) { RequestNotSupportedException :: assertSupports ( $ this , $ request ) ; $ details = ArrayObject :: ensureArrayObject ( $ request -> getModel ( ) ) ; $ klarna = $ request -> getKlarna ( ) ; if ( $ details [ 'articles' ] ) { foreach ( $ details [ 'articles' ] as $ article ) { $ article = ArrayObject :: ensureArrayObject ( $ article ) ; $ klarna -> addArticle ( utf8_decode ( $ article [ 'qty' ] ) , utf8_decode ( $ article [ 'artNo' ] ) , utf8_decode ( $ article [ 'title' ] ) , utf8_decode ( $ article [ 'price' ] ) , utf8_decode ( $ article [ 'vat' ] ) , utf8_decode ( $ article [ 'discount' ] ) , $ article [ 'flags' ] ? : \ KlarnaFlags :: NO_FLAG ) ; } } if ( $ details [ 'partial_articles' ] ) { foreach ( $ details [ 'partial_articles' ] as $ article ) { $ klarna -> addArtNo ( utf8_decode ( $ article [ 'qty' ] ) , utf8_decode ( $ article [ 'artNo' ] ) ) ; } } if ( $ details [ 'shipping_address' ] ) { $ address = ArrayObject :: ensureArrayObject ( $ details [ 'shipping_address' ] ) ; $ klarna -> setAddress ( \ KlarnaFlags :: IS_SHIPPING , new \ KlarnaAddr ( utf8_decode ( $ address [ 'email' ] ) , utf8_decode ( $ address [ 'telno' ] ) , utf8_decode ( $ address [ 'cellno' ] ) , utf8_decode ( $ address [ 'fname' ] ) , utf8_decode ( $ address [ 'lname' ] ) , utf8_decode ( $ address [ 'careof' ] ) , utf8_decode ( $ address [ 'street' ] ) , utf8_decode ( $ address [ 'zip' ] ) , utf8_decode ( $ address [ 'city' ] ) , utf8_decode ( $ address [ 'country' ] ) , utf8_decode ( $ address [ 'house_number' ] ) , utf8_decode ( $ address [ 'house_extension' ] ) ) ) ; } if ( $ details [ 'billing_address' ] ) { $ address = ArrayObject :: ensureArrayObject ( $ details [ 'billing_address' ] ) ; $ klarna -> setAddress ( \ KlarnaFlags :: IS_BILLING , new \ KlarnaAddr ( utf8_decode ( $ address [ 'email' ] ) , utf8_decode ( $ address [ 'telno' ] ) , utf8_decode ( $ address [ 'cellno' ] ) , utf8_decode ( $ address [ 'fname' ] ) , utf8_decode ( $ address [ 'lname' ] ) , utf8_decode ( $ address [ 'careof' ] ) , utf8_decode ( $ address [ 'street' ] ) , utf8_decode ( $ address [ 'zip' ] ) , utf8_decode ( $ address [ 'city' ] ) , utf8_decode ( $ address [ 'country' ] ) , utf8_decode ( $ address [ 'house_number' ] ) , utf8_decode ( $ address [ 'house_extension' ] ) ) ) ; } if ( $ details [ 'estore_info' ] ) { $ estoreInfo = ArrayObject :: ensureArrayObject ( $ details [ 'estore_info' ] ) ; $ klarna -> setEstoreInfo ( utf8_decode ( $ estoreInfo [ 'order_id1' ] ) , utf8_decode ( $ estoreInfo [ 'order_id2' ] ) , utf8_decode ( $ estoreInfo [ 'username' ] ) ) ; } $ klarna -> setComment ( utf8_decode ( $ details [ 'comment' ] ) ) ; } 
public function execute ( $ request ) { RequestNotSupportedException :: assertSupports ( $ this , $ request ) ; $ this -> gateway -> execute ( $ httpRequest = new GetHttpRequest ( ) ) ; 
public function execute ( $ request ) { RequestNotSupportedException :: assertSupports ( $ this , $ request ) ; $ details = ArrayObject :: ensureArrayObject ( $ request -> getModel ( ) ) ; $ details [ 'PAYMENTREQUEST_0_PAYMENTACTION' ] = Api :: PAYMENTACTION_AUTHORIZATION ; parent :: execute ( $ request ) ; } 
public function verify ( $ httpRequest ) { if ( false == is_array ( $ httpRequest ) ) { throw new InvalidArgumentException ( 'Invalid request given. In most cases you have to pass $_REQUEST array.' ) ; } if ( false == isset ( $ httpRequest [ $ this -> tokenParameter ] ) ) { throw new InvalidArgumentException ( sprintf ( 'Token parameter `%s` was not found in in the http request.' , $ this -> tokenParameter ) ) ; } if ( $ httpRequest [ $ this -> tokenParameter ] instanceof TokenInterface ) { return $ httpRequest [ $ this -> tokenParameter ] ; } if ( false == $ token = $ this -> tokenStorage -> find ( $ httpRequest [ $ this -> tokenParameter ] ) ) { throw new InvalidArgumentException ( sprintf ( 'A token with hash `%s` could not be found.' , $ httpRequest [ $ this -> tokenParameter ] ) ) ; } if ( ! RequestTokenVerifier :: isValid ( $ _SERVER [ 'REQUEST_URI' ] , $ token -> getTargetUrl ( ) ) ) { throw new InvalidArgumentException ( sprintf ( 'The current url %s not match target url %s set in the token.' , $ _SERVER [ 'REQUEST_URI' ] , $ token -> getTargetUrl ( ) ) ) ; } return $ token ; } 
public function execute ( $ request ) { RequestNotSupportedException :: assertSupports ( $ this , $ request ) ; $ payment = $ request -> getSource ( ) ; $ details = ArrayObject :: ensureArrayObject ( $ payment -> getDetails ( ) ) ; $ details [ 'price' ] = $ payment -> getTotalAmount ( ) ; $ details [ 'priceArgList' ] = '' ; $ details [ 'vat' ] = 0 ; $ details [ 'currency' ] = $ payment -> getCurrencyCode ( ) ; $ details [ 'orderId' ] = $ payment -> getNumber ( ) ; $ details [ 'productNumber' ] = 'n\a' ; $ details [ 'purchaseOperation' ] = OrderApi :: PURCHASEOPERATION_SALE ; $ details [ 'view' ] = OrderApi :: VIEW_CREDITCARD ; $ details [ 'description' ] = $ payment -> getDescription ( ) ; $ details [ 'clientIdentifier' ] = '' ; $ details [ 'additionalValues' ] = '' ; $ details [ 'agreementRef' ] = '' ; $ details [ 'clientLanguage' ] = isset ( $ details [ 'clientLanguage' ] ) ? $ details [ 'clientLanguage' ] : 'en-US' ; $ details [ 'autoPay' ] = false ; $ request -> setResult ( ( array ) $ details ) ; } 
public function execute ( $ request ) { RequestNotSupportedException :: assertSupports ( $ this , $ request ) ; $ model = ArrayObject :: ensureArrayObject ( $ request -> getModel ( ) ) ; foreach ( range ( 0 , 9 ) as $ index ) { if ( $ model [ 'L_ERRORCODE' . $ index ] ) { $ request -> markFailed ( ) ; return ; } } if ( isset ( $ model [ 'CANCELLED' ] ) ) { $ request -> markCanceled ( ) ; return ; } if ( null === $ paymentStatus = $ model [ 'PAYMENTSTATUS' ] ) { $ request -> markUnknown ( ) ; return ; } $ refundStatuses = [ Api :: PAYMENTSTATUS_REFUNDED , Api :: PAYMENTSTATUS_PARTIALLY_REFUNDED , ] ; if ( in_array ( $ paymentStatus , $ refundStatuses ) ) { $ request -> markRefunded ( ) ; return ; } if ( $ paymentStatus == Api :: PAYMENTSTATUS_COMPLETED ) { $ request -> markCaptured ( ) ; return ; } $ pendingStatuses = [ Api :: PAYMENTSTATUS_IN_PROGRESS , Api :: PAYMENTSTATUS_PENDING , ] ; if ( in_array ( $ paymentStatus , $ pendingStatuses ) ) { if ( Api :: PENDINGREASON_AUTHORIZATION == $ model [ 'PENDINGREASON' ] ) { $ request -> markAuthorized ( ) ; return ; } } if ( $ paymentStatus == Api :: PAYMENTSTATUS_PENDING ) { $ request -> markPending ( ) ; return ; } $ failedStatuses = array ( Api :: PAYMENTSTATUS_FAILED , Api :: PAYMENTSTATUS_EXPIRED , Api :: PAYMENTSTATUS_DENIED , Api :: PAYMENTSTATUS_CANCELED_REVERSAL , ) ; if ( in_array ( $ paymentStatus , $ failedStatuses ) ) { $ request -> markFailed ( ) ; return ; } } 
public function execute ( $ request ) { RequestNotSupportedException :: assertSupports ( $ this , $ request ) ; $ model = ArrayObject :: ensureArrayObject ( $ request -> getModel ( ) ) ; $ model -> validateNotEmpty ( array ( 'PROFILEID' , 'BILLINGPERIOD' ) ) ; $ cancelDetails = new ArrayObject ( [ 'PROFILEID' => $ model [ 'PROFILEID' ] , 'ACTION' => Api :: RECURRINGPAYMENTACTION_CANCEL , ] ) ; $ this -> gateway -> execute ( new ManageRecurringPaymentsProfileStatus ( $ cancelDetails ) ) ; $ this -> gateway -> execute ( new Sync ( $ request -> getModel ( ) ) ) ; } 
public function supports ( $ request ) { if ( false == ( $ request instanceof Cancel && $ request -> getModel ( ) instanceof \ ArrayAccess ) ) { return false ; } 
public function execute ( $ request ) { RequestNotSupportedException :: assertSupports ( $ this , $ request ) ; $ details = ArrayObject :: ensureArrayObject ( $ request -> getModel ( ) ) ; if ( false == $ details [ 'rno' ] ) { $ this -> gateway -> execute ( new ReserveAmount ( $ details ) ) ; } } 
public function execute ( $ request ) { RequestNotSupportedException :: assertSupports ( $ this , $ request ) ; $ model = $ request -> getModel ( ) ; $ payment = PaypalPayment :: get ( $ model -> id ) ; $ model -> fromArray ( $ payment -> toArray ( ) ) ; } 
public function start ( array $ parameters ) { $ parameters [ 'accountNumber' ] = $ this -> options [ 'account_number' ] ; if ( isset ( $ parameters [ 'orderId' ] ) ) { $ parameters [ 'orderID' ] = $ parameters [ 'orderId' ] ; unset ( $ parameters [ 'orderId' ] ) ; } 
public function stop ( array $ parameters ) { $ parameters [ 'accountNumber' ] = $ this -> options [ 'account_number' ] ; $ parameters [ 'hash' ] = $ this -> calculateHash ( $ parameters , array ( 'accountNumber' , 'agreementRef' , ) ) ; return $ this -> call ( 'Stop' , $ parameters , $ this -> getPxRecurringWsdl ( ) ) ; } 
public function check ( array $ parameters ) { $ parameters [ 'accountNumber' ] = $ this -> options [ 'account_number' ] ; $ parameters [ 'hash' ] = $ this -> calculateHash ( $ parameters , array ( 'accountNumber' , 'agreementRef' , ) ) ; return $ this -> call ( 'Check' , $ parameters , $ this -> getPxRecurringWsdl ( ) ) ; } 
public function notifyValidate ( array $ fields ) { $ fields [ 'cmd' ] = self :: CMD_NOTIFY_VALIDATE ; $ headers = array ( 'Content-Type' => 'application/x-www-form-urlencoded' , ) ; $ request = $ this -> messageFactory -> createRequest ( 'POST' , $ this -> getIpnEndpoint ( ) , $ headers , http_build_query ( $ fields ) ) ; $ response = $ this -> client -> send ( $ request ) ; if ( false == ( $ response -> getStatusCode ( ) >= 200 && $ response -> getStatusCode ( ) < 300 ) ) { throw HttpException :: factory ( $ request , $ response ) ; } $ result = $ response -> getBody ( ) -> getContents ( ) ; return self :: NOTIFY_VERIFIED === $ result ? self :: NOTIFY_VERIFIED : self :: NOTIFY_INVALID ; } 
public function execute ( $ request ) { RequestNotSupportedException :: assertSupports ( $ this , $ request ) ; $ model = ArrayObject :: ensureArrayObject ( $ request -> getModel ( ) ) ; foreach ( range ( 0 , 9 ) as $ index ) { if ( $ model [ 'L_ERRORCODE' . $ index ] ) { $ request -> markFailed ( ) ; return ; } } if ( false == $ model [ 'PROFILESTATUS' ] && false == $ model [ 'STATUS' ] ) { $ request -> markNew ( ) ; return ; } if ( Api :: RECURRINGPAYMENTSTATUS_ACTIVE == $ model [ 'STATUS' ] ) { $ request -> markCaptured ( ) ; return ; } if ( Api :: RECURRINGPAYMENTSTATUS_CANCELLED == $ model [ 'STATUS' ] ) { $ request -> markCanceled ( ) ; return ; } if ( Api :: RECURRINGPAYMENTSTATUS_PENDING == $ model [ 'STATUS' ] ) { $ request -> markPending ( ) ; return ; } if ( Api :: RECURRINGPAYMENTSTATUS_EXPIRED == $ model [ 'STATUS' ] ) { $ request -> markExpired ( ) ; return ; } if ( Api :: RECURRINGPAYMENTSTATUS_SUSPENDED == $ model [ 'STATUS' ] ) { $ request -> markSuspended ( ) ; return ; } if ( Api :: PROFILESTATUS_PENDINGPROFILE == $ model [ 'PROFILESTATUS' ] ) { $ request -> markPending ( ) ; return ; } if ( Api :: PROFILESTATUS_ACTIVEPROFILE == $ model [ 'PROFILESTATUS' ] ) { $ request -> markCaptured ( ) ; return ; } $ request -> markUnknown ( ) ; } 
public function addExtension ( ExtensionInterface $ extension , $ forcePrepend = false ) { $ forcePrepend ? array_unshift ( $ this -> extensions , $ extension ) : array_push ( $ this -> extensions , $ extension ) ; } 
public function onPreExecute ( Context $ context ) { foreach ( $ this -> extensions as $ extension ) { $ extension -> onPreExecute ( $ context ) ; } } 
public function onExecute ( Context $ context ) { foreach ( $ this -> extensions as $ extension ) { $ extension -> onExecute ( $ context ) ; } } 
public function onPostExecute ( Context $ context ) { foreach ( $ this -> extensions as $ extension ) { $ extension -> onPostExecute ( $ context ) ; } } 
public function execute ( $ request ) { RequestNotSupportedException :: assertSupports ( $ this , $ request ) ; $ model = ArrayObject :: ensureArrayObject ( $ request -> getModel ( ) ) ; if ( false == $ model [ 'ACK' ] ) { $ request -> markNew ( ) ; return ; } if ( in_array ( $ model [ 'ACK' ] , [ Api :: ACK_SUCCESS , Api :: ACK_SUCCESS_WITH_WARNING ] ) ) { $ request -> markPayedout ( ) ; return ; } if ( in_array ( $ model [ 'ACK' ] , [ Api :: ACK_FAILURE , Api :: ACK_FAILURE_WITH_WARNING ] ) ) { $ request -> markFailed ( ) ; return ; } $ request -> markUnknown ( ) ; } 
public function execute ( $ request ) { RequestNotSupportedException :: assertSupports ( $ this , $ request ) ; $ details = ArrayObject :: ensureArrayObject ( $ request -> getModel ( ) ) ; if ( $ details [ 'error_code' ] ) { $ request -> markFailed ( ) ; return ; } if ( $ details [ 'canceled' ] ) { $ request -> markCanceled ( ) ; return ; } if ( $ details [ 'refund_invoice_number' ] ) { $ request -> markRefunded ( ) ; return ; } if ( $ details [ 'invoice_number' ] ) { $ request -> markCaptured ( ) ; return ; } if ( false == $ details [ 'status' ] ) { $ request -> markNew ( ) ; return ; } if ( \ KlarnaFlags :: ACCEPTED == $ details [ 'status' ] ) { $ request -> markAuthorized ( ) ; return ; } if ( \ KlarnaFlags :: PENDING == $ details [ 'status' ] ) { $ request -> markPending ( ) ; return ; } if ( \ KlarnaFlags :: DENIED == $ details [ 'status' ] ) { $ request -> markFailed ( ) ; return ; } $ request -> markUnknown ( ) ; } 
public function execute ( $ request ) { RequestNotSupportedException :: assertSupports ( $ this , $ request ) ; $ model = ArrayObject :: ensureArrayObject ( $ request -> getModel ( ) ) ; 
public function supports ( $ request ) { if ( false == ( $ request instanceof GetStatusInterface && $ request -> getModel ( ) instanceof \ ArrayAccess ) ) { return false ; } $ model = ArrayObject :: ensureArrayObject ( $ request -> getModel ( ) ) ; if ( count ( iterator_to_array ( $ model ) ) == 0 ) { return true ; } if ( $ model [ 'recurring' ] ) { return true ; } 
public function createToken ( $ gatewayName , $ model , $ targetPath , array $ targetParameters = [ ] , $ afterPath = null , array $ afterParameters = [ ] ) { $ token = $ this -> tokenStorage -> create ( ) ; $ token -> setHash ( $ token -> getHash ( ) ? : Random :: generateToken ( ) ) ; $ targetParameters = array_replace ( [ 'payum_token' => $ token -> getHash ( ) ] , $ targetParameters ) ; $ token -> setGatewayName ( $ gatewayName ) ; if ( $ model instanceof IdentityInterface ) { $ token -> setDetails ( $ model ) ; } elseif ( null !== $ model ) { $ token -> setDetails ( $ this -> storageRegistry -> getStorage ( $ model ) -> identify ( $ model ) ) ; } if ( 0 === strpos ( $ targetPath , 'http' ) ) { $ targetUri = HttpUri :: createFromString ( $ targetPath ) ; $ targetUri = $ this -> addQueryToUri ( $ targetUri , $ targetParameters ) ; $ token -> setTargetUrl ( ( string ) $ targetUri ) ; } else { $ token -> setTargetUrl ( $ this -> generateUrl ( $ targetPath , $ targetParameters ) ) ; } if ( $ afterPath && 0 === strpos ( $ afterPath , 'http' ) ) { $ afterUri = HttpUri :: createFromString ( $ afterPath ) ; $ afterUri = $ this -> addQueryToUri ( $ afterUri , $ afterParameters ) ; $ token -> setAfterUrl ( ( string ) $ afterUri ) ; } elseif ( $ afterPath ) { $ token -> setAfterUrl ( $ this -> generateUrl ( $ afterPath , $ afterParameters ) ) ; } $ this -> tokenStorage -> update ( $ token ) ; return $ token ; } 
protected function addQueryToUri ( HttpUri $ uri , array $ query ) { $ query = array_replace ( ( new QueryParser ( ) ) -> parse ( $ uri -> getQuery ( ) ) , $ query ) ; $ query = array_filter ( $ query , function ( $ value ) { return null !== $ value ; } ) ; return $ uri -> withQuery ( ( string ) Query :: createFromPairs ( $ query ) ) ; } 
public static function factory ( RequestInterface $ request , ResponseInterface $ response ) { if ( $ response -> getStatusCode ( ) >= 400 && $ response -> getStatusCode ( ) < 500 ) { $ label = 'Client error response' ; } elseif ( $ response -> getStatusCode ( ) >= 500 && $ response -> getStatusCode ( ) < 600 ) { $ label = 'Server error response' ; } else { $ label = 'Unsuccessful response' ; } $ message = implode ( PHP_EOL , array ( $ label , '[status code] ' . $ response -> getStatusCode ( ) , '[reason phrase] ' . $ response -> getReasonPhrase ( ) , '[url] ' . $ request -> getUri ( ) , ) ) ; $ e = new static ( $ message , $ response -> getStatusCode ( ) ) ; $ e -> setResponse ( $ response ) ; $ e -> setRequest ( $ request ) ; return $ e ; } 
public function massPay ( array $ fields ) { $ fields [ 'METHOD' ] = 'MassPay' ; $ this -> addVersionField ( $ fields ) ; $ this -> addAuthorizeFields ( $ fields ) ; return $ this -> doRequest ( $ fields ) ; } 
protected function doFind ( $ id ) { if ( isset ( $ this -> identityMap [ $ id ] ) ) { return $ this -> identityMap [ $ id ] ; } if ( file_exists ( $ this -> storageDir . '/payum-model-' . $ id ) ) { return $ this -> identityMap [ $ id ] = unserialize ( file_get_contents ( $ this -> storageDir . '/payum-model-' . $ id ) ) ; } } 
protected function doUpdateModel ( $ model ) { $ ro = new \ ReflectionObject ( $ model ) ; if ( false == $ ro -> hasProperty ( $ this -> idProperty ) ) { $ model -> { $ this -> idProperty } = null ; } $ rp = new \ ReflectionProperty ( $ model , $ this -> idProperty ) ; $ rp -> setAccessible ( true ) ; $ id = $ rp -> getValue ( $ model ) ; if ( false == $ id ) { $ rp -> setValue ( $ model , $ id = uniqid ( ) ) ; } $ rp -> setAccessible ( false ) ; $ this -> identityMap [ $ id ] = $ model ; file_put_contents ( $ this -> storageDir . '/payum-model-' . $ id , serialize ( $ model ) ) ; } 
protected function doDeleteModel ( $ model ) { $ rp = new \ ReflectionProperty ( $ model , $ this -> idProperty ) ; $ rp -> setAccessible ( true ) ; if ( $ id = $ rp -> getValue ( $ model ) ) { unlink ( $ this -> storageDir . '/payum-model-' . $ id ) ; unset ( $ this -> identityMap [ $ id ] ) ; } } 
protected function doGetIdentity ( $ model ) { $ rp = new \ ReflectionProperty ( $ model , $ this -> idProperty ) ; $ rp -> setAccessible ( true ) ; if ( false == $ id = $ rp -> getValue ( $ model ) ) { throw new LogicException ( 'The model must be persisted before usage of this method' ) ; } return new Identity ( $ id , $ model ) ; } 
public static function assertSupports ( ActionInterface $ action , $ request ) { if ( false == $ action -> supports ( $ request ) ) { throw static :: createActionNotSupported ( $ action , $ request ) ; } } 
public static function create ( $ request ) { $ exception = new self ( sprintf ( 'Request %s is not supported. %s' , Humanify :: request ( $ request ) , implode ( " " , static :: suggestions ( $ request ) ) ) ) ; $ exception -> request = $ request ; return $ exception ; } 
public static function createActionNotSupported ( ActionInterface $ action , $ request ) { $ exception = new self ( sprintf ( "Action %s is not supported the request %s. %s" , Humanify :: value ( $ action ) , Humanify :: request ( $ request ) , implode ( " " , static :: suggestions ( $ request ) ) ) ) ; $ exception -> request = $ request ; $ exception -> action = $ action ; return $ exception ; } 
protected static function suggestions ( $ request ) { $ suggestions = [ ] ; if ( $ request instanceof Generic && $ request -> getModel ( ) instanceof IdentityInterface ) { $ suggestions [ ] = sprintf ( 'Make sure the storage extension for "%s" is registered to the gateway.' , $ request -> getModel ( ) -> getClass ( ) ) ; $ suggestions [ ] = sprintf ( 'Make sure the storage find method returns an instance by id "%s".' , $ request -> getModel ( ) -> getId ( ) ) ; } $ suggestions [ ] = 'Make sure the gateway supports the requests and there is an action which supports this request (The method returns true).' ; $ suggestions [ ] = 'There may be a bug, so look for a related issue on the issue tracker.' ; return $ suggestions ; } 
protected function populateConfig ( ArrayObject $ config ) { if ( false == class_exists ( ApiContext :: class ) ) { throw new \ LogicException ( 'You must install "paypal/rest-api-sdk-php" library.' ) ; } $ config -> defaults ( [ 'payum.factory_name' => 'paypal_rest' , 'payum.factory_title' => 'PayPal Rest' , 'payum.action.capture' => new CaptureAction ( ) , 'payum.action.sync' => new SyncAction ( ) , 'payum.action.status' => new StatusAction ( ) , ] ) ; if ( false == $ config [ 'payum.api' ] ) { $ config [ 'payum.default_options' ] = [ 'client_id' => '' , 'client_secret' => '' , 'config_path' => '' , ] ; $ config -> defaults ( $ config [ 'payum.default_options' ] ) ; $ config [ 'payum.required_options' ] = [ 'client_id' , 'client_secret' , 'config_path' ] ; $ config [ 'payum.api' ] = function ( ArrayObject $ config ) { $ config -> validateNotEmpty ( $ config [ 'payum.required_options' ] ) ; if ( false == defined ( 'PP_CONFIG_PATH' ) ) { define ( 'PP_CONFIG_PATH' , $ config [ 'config_path' ] ) ; } elseif ( PP_CONFIG_PATH !== $ config [ 'config_path' ] ) { throw new InvalidArgumentException ( sprintf ( 'Given "config_path" is invalid. Should be equal to the defined "PP_CONFIG_PATH": %s.' , PP_CONFIG_PATH ) ) ; } $ credential = new OAuthTokenCredential ( $ config [ 'client_id' ] , $ config [ 'client_secret' ] ) ; return new ApiContext ( $ credential ) ; } ; } } 
public function execute ( $ request ) { RequestNotSupportedException :: assertSupports ( $ this , $ request ) ; $ details = ArrayObject :: ensureArrayObject ( $ request -> getModel ( ) ) ; if ( $ details [ 'refund_invoice_number' ] ) { return ; } $ details -> validateNotEmpty ( array ( 'invoice_number' ) ) ; $ this -> gateway -> execute ( new CreditPart ( $ details ) ) ; } 
public function execute ( $ request ) { RequestNotSupportedException :: assertSupports ( $ this , $ request ) ; $ model = ArrayObject :: ensureArrayObject ( $ request -> getModel ( ) ) ; 
public function execute ( $ request ) { RequestNotSupportedException :: assertSupports ( $ this , $ request ) ; $ details = ArrayObject :: ensureArrayObject ( $ request -> getModel ( ) ) ; $ this -> gateway -> execute ( new Sync ( $ details ) ) ; if ( Constants :: STATUS_CHECKOUT_COMPLETE == $ details [ 'status' ] ) { $ this -> gateway -> execute ( new UpdateOrder ( array ( 'location' => $ details [ 'location' ] , 'status' => Constants :: STATUS_CREATED , 'merchant_reference' => array ( 'orderid1' => $ details [ 'merchant_reference' ] [ 'orderid1' ] , ) , ) ) ) ; $ this -> gateway -> execute ( new Sync ( $ details ) ) ; } } 
public function execute ( $ request ) { RequestNotSupportedException :: assertSupports ( $ this , $ request ) ; $ card = $ request -> getModel ( ) ; $ token = ArrayObject :: ensureArrayObject ( $ request -> getToken ( ) ) ; $ token [ 'object' ] = 'card' ; $ token [ 'number' ] = SensitiveValue :: ensureSensitive ( $ card -> getNumber ( ) ) ; $ token [ 'exp_month' ] = SensitiveValue :: ensureSensitive ( $ card -> getExpireAt ( ) -> format ( 'm' ) ) ; $ token [ 'exp_year' ] = SensitiveValue :: ensureSensitive ( $ card -> getExpireAt ( ) -> format ( 'Y' ) ) ; if ( $ card -> getSecurityCode ( ) ) { $ token [ 'cvc' ] = SensitiveValue :: ensureSensitive ( $ card -> getSecurityCode ( ) ) ; } $ this -> gateway -> execute ( new CreateToken ( $ token ) ) ; $ request -> setToken ( $ token -> toUnsafeArray ( ) ) ; } 
public function execute ( $ request ) { RequestNotSupportedException :: assertSupports ( $ this , $ request ) ; $ model = ArrayObject :: ensureArrayObject ( $ request -> getModel ( ) ) ; if ( $ model [ 'card' ] ) { throw new LogicException ( 'Payment already has token set' ) ; } $ obtainCreditCard = new ObtainCreditCard ( $ request -> getToken ( ) ) ; $ obtainCreditCard -> setModel ( $ request -> getFirstModel ( ) ) ; $ obtainCreditCard -> setModel ( $ request -> getModel ( ) ) ; $ this -> gateway -> execute ( $ obtainCreditCard ) ; $ card = $ obtainCreditCard -> obtain ( ) ; $ local = $ model -> getArray ( 'local' ) ; $ createTokenForCreditCard = new CreateTokenForCreditCard ( $ card ) ; $ createTokenForCreditCard -> setToken ( ( array ) $ local -> getArray ( 'token' ) ) ; $ this -> gateway -> execute ( $ createTokenForCreditCard ) ; $ token = ArrayObject :: ensureArrayObject ( $ createTokenForCreditCard -> getToken ( ) ) ; $ local [ 'token' ] = $ token -> toUnsafeArray ( ) ; $ model [ 'local' ] = ( array ) $ local ; if ( $ token [ 'id' ] ) { $ model [ 'card' ] = $ token [ 'id' ] ; } else { $ model [ 'status' ] = Constants :: STATUS_FAILED ; } } 
public function replace ( $ input ) { if ( false == ( is_array ( $ input ) || $ input instanceof \ Traversable ) ) { throw new InvalidArgumentException ( 'Invalid input given. Should be an array or instance of \Traversable' ) ; } foreach ( $ input as $ index => $ value ) { $ this [ $ index ] = $ value ; } } 
public function defaults ( $ input ) { if ( false == ( is_array ( $ input ) || $ input instanceof \ Traversable ) ) { throw new InvalidArgumentException ( 'Invalid input given. Should be an array or instance of \Traversable' ) ; } foreach ( $ input as $ index => $ value ) { if ( null === $ this [ $ index ] ) { $ this [ $ index ] = $ value ; } } } 
public function validateNotEmpty ( $ required , $ throwOnInvalid = true ) { $ required = is_array ( $ required ) ? $ required : array ( $ required ) ; $ empty = array ( ) ; foreach ( $ required as $ r ) { $ value = $ this [ $ r ] ; if ( empty ( $ value ) ) { $ empty [ ] = $ r ; } } if ( $ empty && $ throwOnInvalid ) { throw new LogicException ( sprintf ( 'The %s fields are required.' , implode ( ', ' , $ empty ) ) ) ; } if ( $ empty ) { return false ; } return true ; } 
public function validatedKeysSet ( $ required , $ throwOnInvalid = true ) { $ required = is_array ( $ required ) ? $ required : array ( $ required ) ; foreach ( $ required as $ required ) { if ( false == $ this -> offsetExists ( $ required ) ) { if ( $ throwOnInvalid ) { throw new LogicException ( sprintf ( 'The %s fields is not set.' , $ required ) ) ; } return false ; } } return true ; } 
public function offsetSet ( $ index , $ value ) { if ( $ this -> input ) { $ this -> input [ $ index ] = $ value ; } return parent :: offsetSet ( $ index , $ value ) ; } 
public function offsetUnset ( $ index ) { if ( $ this -> input ) { unset ( $ this -> input [ $ index ] ) ; } return parent :: offsetUnset ( $ index ) ; } 
public function toUnsafeArray ( ) { $ array = [ ] ; foreach ( $ this as $ name => $ value ) { if ( $ value instanceof SensitiveValue ) { $ array [ $ name ] = $ value -> get ( ) ; continue ; } $ array [ $ name ] = $ value ; } return $ array ; } 
public function setApi ( $ api ) { if ( empty ( $ this -> apiClass ) ) { throw new LogicException ( sprintf ( 'You must configure apiClass in __constructor method of the class the trait is applied to.' ) ) ; } if ( false == ( class_exists ( $ this -> apiClass ) || interface_exists ( $ this -> apiClass ) ) ) { throw new LogicException ( sprintf ( 'Api class not found or invalid class. "%s", $this->apiClass' , $ this -> apiClass ) ) ; } if ( false == $ api instanceof $ this -> apiClass ) { throw new UnsupportedApiException ( sprintf ( 'Not supported api given. It must be an instance of %s' , $ this -> apiClass ) ) ; } $ this -> api = $ api ; } 
public function createToken ( $ gatewayName , $ model , $ targetPath , array $ targetParameters = [ ] , $ afterPath = null , array $ afterParameters = [ ] ) { return $ this -> tokenFactory -> createToken ( $ gatewayName , $ model , $ targetPath , $ targetParameters , $ afterPath , $ afterParameters ) ; } 
public function createAuthorizeToken ( $ gatewayName , $ model , $ afterPath , array $ afterParameters = [ ] ) { $ authorizePath = $ this -> getPath ( 'authorize' ) ; $ afterToken = $ this -> createToken ( $ gatewayName , $ model , $ afterPath , $ afterParameters ) ; return $ this -> createToken ( $ gatewayName , $ model , $ authorizePath , [ ] , $ afterToken -> getTargetUrl ( ) ) ; } 
public function createRefundToken ( $ gatewayName , $ model , $ afterPath = null , array $ afterParameters = [ ] ) { $ refundPath = $ this -> getPath ( 'refund' ) ; $ afterUrl = null ; if ( $ afterPath ) { $ afterUrl = $ this -> createToken ( $ gatewayName , $ model , $ afterPath , $ afterParameters ) -> getTargetUrl ( ) ; } return $ this -> createToken ( $ gatewayName , $ model , $ refundPath , [ ] , $ afterUrl ) ; } 
public function createCancelToken ( $ gatewayName , $ model , $ afterPath = null , array $ afterParameters = [ ] ) { $ cancelPath = $ this -> getPath ( 'cancel' ) ; $ afterUrl = null ; if ( $ afterPath ) { $ afterUrl = $ this -> createToken ( $ gatewayName , $ model , $ afterPath , $ afterParameters ) -> getTargetUrl ( ) ; } return $ this -> createToken ( $ gatewayName , $ model , $ cancelPath , [ ] , $ afterUrl ) ; } 
public function createPayoutToken ( $ gatewayName , $ model , $ afterPath , array $ afterParameters = [ ] ) { $ capturePath = $ this -> getPath ( 'payout' ) ; $ afterToken = $ this -> createToken ( $ gatewayName , $ model , $ afterPath , $ afterParameters ) ; return $ this -> createToken ( $ gatewayName , $ model , $ capturePath , [ ] , $ afterToken -> getTargetUrl ( ) ) ; } 
public function createNotifyToken ( $ gatewayName , $ model = null ) { return $ this -> createToken ( $ gatewayName , $ model , $ this -> getPath ( 'notify' ) ) ; } 
protected function getPath ( $ name ) { if ( empty ( $ this -> paths [ $ name ] ) ) { throw new LogicException ( sprintf ( 'The path "%s" is not found. Possible paths are %s' , $ name , implode ( ', ' , array_keys ( $ this -> paths ) ) ) ) ; } return $ this -> paths [ $ name ] ; } 
public function build ( array $ defaultConfig , GatewayFactoryInterface $ coreGatewayFactory ) { $ gatewayFactoryClass = $ this -> gatewayFactoryClass ; return new $ gatewayFactoryClass ( $ defaultConfig , $ coreGatewayFactory ) ; } 
public function execute ( $ request ) { RequestNotSupportedException :: assertSupports ( $ this , $ request ) ; $ model = ArrayObject :: ensureArrayObject ( $ request -> getModel ( ) ) ; $ this -> addMerchantId ( $ model ) ; $ this -> callWithRetry ( function ( ) use ( $ model , $ request ) { $ order = new \ Klarna_Checkout_Order ( $ this -> getConnector ( ) ) ; $ order -> create ( $ model -> toUnsafeArray ( ) ) ; $ request -> setOrder ( $ order ) ; } ) ; } 
public function execute ( $ request ) { RequestNotSupportedException :: assertSupports ( $ this , $ request ) ; $ request -> setResult ( $ this -> twig -> render ( $ request -> getTemplateName ( ) , array_replace ( array ( 'layout' => $ this -> layout ) , $ request -> getParameters ( ) ) ) ) ; } 
public function execute ( $ request ) { RequestNotSupportedException :: assertSupports ( $ this , $ request ) ; $ details = ArrayObject :: ensureArrayObject ( $ request -> getModel ( ) ) ; if ( null === $ details [ 'RESULT' ] ) { return ; } $ refundableTrxTypes = array ( Api :: TRXTYPE_SALE , Api :: TRXTYPE_DELAYED_CAPUTER , Api :: TRXTYPE_VOICE_AUTHORIZATION ) ; if ( false == in_array ( $ details [ 'TRXTYPE' ] , $ refundableTrxTypes ) ) { throw new LogicException ( sprintf ( 'You cannot refund transaction with type %s. Only these types could be refunded: %s' , $ details [ 'TRXTYPE' ] , implode ( ', ' , $ refundableTrxTypes ) ) ) ; } $ details -> validateNotEmpty ( array ( 'PNREF' ) , true ) ; $ details [ 'PURCHASE_TRXTYPE' ] = $ details [ 'TRXTYPE' ] ; $ details [ 'TRXTYPE' ] = null ; $ details [ 'PURCHASE_RESULT' ] = $ details [ 'RESULT' ] ; $ details [ 'RESULT' ] = null ; $ details [ 'ORIGID' ] = $ details [ 'PNREF' ] ; $ details -> replace ( $ this -> api -> doCredit ( $ details -> toUnsafeArray ( ) ) ) ; } 
public function execute ( $ request ) { RequestNotSupportedException :: assertSupports ( $ this , $ request ) ; $ model = ArrayObject :: ensureArrayObject ( $ request -> getModel ( ) ) ; if ( null === $ model [ 'response_code' ] ) { $ request -> markNew ( ) ; return ; } if ( \ AuthorizeNetAIM_Response :: APPROVED == $ model [ 'response_code' ] ) { $ request -> markCaptured ( ) ; return ; } if ( \ AuthorizeNetAIM_Response :: DECLINED == $ model [ 'response_code' ] ) { $ request -> markCanceled ( ) ; return ; } if ( \ AuthorizeNetAIM_Response :: ERROR == $ model [ 'response_code' ] ) { $ request -> markFailed ( ) ; return ; } if ( \ AuthorizeNetAIM_Response :: HELD == $ model [ 'response_code' ] ) { $ request -> markPending ( ) ; return ; } $ request -> markUnknown ( ) ; } 
public function onExecute ( Context $ context ) { $ action = $ context -> getAction ( ) ; if ( $ action instanceof LoggerAwareInterface ) { $ action -> setLogger ( $ this -> logger ) ; } } 
public function onPostExecute ( Context $ context ) { $ action = $ context -> getAction ( ) ; if ( $ action instanceof LoggerAwareInterface ) { $ action -> setLogger ( $ this -> nullLogger ) ; } } 
protected function populateConfig ( ArrayObject $ config ) { $ config -> defaults ( array ( 'payum.factory_name' => 'paypal_pro_checkout_nvp' , 'payum.factory_title' => 'PayPal ProCheckout' , 'payum.action.capture' => new CaptureAction ( ) , 'payum.action.refund' => new RefundAction ( ) , 'payum.action.convert_payment' => new ConvertPaymentAction ( ) , 'payum.action.status' => new StatusAction ( ) , ) ) ; if ( false == $ config [ 'payum.api' ] ) { $ config [ 'payum.default_options' ] = array ( 'username' => '' , 'password' => '' , 'partner' => '' , 'vendor' => '' , 'tender' => '' , 'sandbox' => true , ) ; $ config -> defaults ( $ config [ 'payum.default_options' ] ) ; $ config [ 'payum.required_options' ] = array ( 'username' , 'password' , 'partner' , 'vendor' , 'tender' ) ; $ config [ 'payum.api' ] = function ( ArrayObject $ config ) { $ config -> validateNotEmpty ( $ config [ 'payum.required_options' ] ) ; $ paypalConfig = array ( 'username' => $ config [ 'username' ] , 'password' => $ config [ 'password' ] , 'partner' => $ config [ 'partner' ] , 'vendor' => $ config [ 'vendor' ] , 'tender' => $ config [ 'tender' ] , 'sandbox' => $ config [ 'sandbox' ] , ) ; return new Api ( $ paypalConfig , $ config [ 'payum.http_client' ] , $ config [ 'httplug.message_factory' ] ) ; } ; } } 
protected function generateUrl ( $ path , array $ parameters = [ ] ) { $ newPath = ( new Path ( $ this -> baseUrl -> getPath ( ) ) ) -> withTrailingSlash ( ) . $ path ; $ uri = $ this -> baseUrl -> withPath ( $ newPath ) ; $ uri = $ this -> addQueryToUri ( $ uri , $ parameters ) ; return ( string ) $ uri ; } 
public function execute ( $ request ) { RequestNotSupportedException :: assertSupports ( $ this , $ request ) ; $ model = ArrayObject :: ensureArrayObject ( $ request -> getModel ( ) ) ; $ this -> callWithRetry ( function ( ) use ( $ model , $ request ) { $ order = new \ Klarna_Checkout_Order ( $ this -> getConnector ( ) , $ model [ 'location' ] ) ; $ data = $ model -> toUnsafeArray ( ) ; unset ( $ data [ 'location' ] ) ; $ order -> update ( $ data ) ; $ request -> setOrder ( $ order ) ; } ) ; } 
protected function populateConfig ( ArrayObject $ config ) { if ( ! class_exists ( 'Klarna_Checkout_Order' ) ) { throw new \ LogicException ( 'You must install "klarna/checkout" library.' ) ; } $ config -> defaults ( array ( 'payum.factory_name' => 'klarna_checkout' , 'payum.factory_title' => 'Klarna Checkout' , 'payum.template.authorize' => '@PayumKlarnaCheckout/Action/capture.html.twig' , 'contentType' => Constants :: CONTENT_TYPE_AGGREGATED_ORDER_V2 , 'sandbox' => true , ) ) ; $ config -> defaults ( array ( 'payum.action.authorize_recurring' => new AuthorizeRecurringAction ( ) , 
protected function populateConfig ( ArrayObject $ config ) { $ config -> defaults ( array ( 'payum.factory_name' => 'paypal_masspay_nvp' , 'payum.factory_title' => 'PayPal Masspay' , 'payum.action.payout' => new PayoutAction ( ) , 'payum.action.api.masspay' => new MasspayAction ( ) , 'payum.action.convert_payout' => new ConvertPayoutAction ( ) , 'payum.action.get_payout_status' => new GetPayoutStatusAction ( ) , ) ) ; if ( false == $ config [ 'payum.api' ] ) { $ config [ 'payum.default_options' ] = array ( 'username' => '' , 'password' => '' , 'signature' => '' , 'sandbox' => true , ) ; $ config -> defaults ( $ config [ 'payum.default_options' ] ) ; $ config [ 'payum.required_options' ] = array ( 'username' , 'password' , 'signature' ) ; $ config [ 'payum.api' ] = function ( ArrayObject $ config ) { $ config -> validateNotEmpty ( $ config [ 'payum.required_options' ] ) ; $ paypalConfig = [ 'username' => $ config [ 'username' ] , 'password' => $ config [ 'password' ] , 'signature' => $ config [ 'signature' ] , 'sandbox' => $ config [ 'sandbox' ] , ] ; return new Api ( $ paypalConfig , $ config [ 'payum.http_client' ] , $ config [ 'httplug.message_factory' ] ) ; } ; } } 
protected function call ( $ operation , array $ parameters , $ serviceWsdl ) { $ client = $ this -> clientFactory -> createWsdlClient ( $ serviceWsdl ) ; $ response = @ $ client -> $ operation ( $ parameters ) ; $ result = $ this -> convertSimpleXmlToArray ( new \ SimpleXMLElement ( $ response -> { $ operation . 'Result' } ) ) ; $ result = $ this -> normalizeStatusFields ( $ result ) ; $ result = $ this -> removeHeader ( $ result ) ; $ result = $ this -> removeObsolete ( $ result ) ; return $ result ; } 
protected function calculateHash ( array $ parameters , array $ parametersKeys ) { $ orderedParameters = array ( ) ; foreach ( $ parametersKeys as $ parametersKey ) { if ( false == isset ( $ parameters [ $ parametersKey ] ) ) { 
protected function normalizeStatusFields ( array $ inputResult ) { $ result = $ inputResult ; unset ( $ result [ 'status' ] ) ; if ( array_key_exists ( 'status' , $ inputResult ) && is_array ( $ inputResult [ 'status' ] ) ) { $ statuses = $ inputResult [ 'status' ] ; 
public function execute ( $ request ) { RequestNotSupportedException :: assertSupports ( $ this , $ request ) ; $ klarna = $ this -> getKlarna ( ) ; foreach ( $ klarna -> getAddresses ( $ request -> getPno ( ) ) as $ address ) { $ address -> setEmail ( utf8_encode ( $ address -> getEmail ( ) ) ) ; $ address -> setTelno ( utf8_encode ( $ address -> getTelno ( ) ) ) ; $ address -> setCellno ( utf8_encode ( $ address -> getCellno ( ) ) ) ; $ address -> setFirstName ( utf8_encode ( $ address -> getFirstName ( ) ) ) ; $ address -> setLastName ( utf8_encode ( $ address -> getLastName ( ) ) ) ; $ address -> setCompanyName ( utf8_encode ( $ address -> getCompanyName ( ) ) ) ; $ address -> setCareof ( utf8_encode ( $ address -> getCareof ( ) ) ) ; $ address -> setStreet ( utf8_encode ( $ address -> getStreet ( ) ) ) ; $ address -> setHouseNumber ( utf8_encode ( $ address -> getHouseNumber ( ) ) ) ; $ address -> setHouseExt ( utf8_encode ( $ address -> getHouseExt ( ) ) ) ; $ address -> setZipCode ( utf8_encode ( $ address -> getZipCode ( ) ) ) ; $ address -> setCity ( utf8_encode ( $ address -> getCity ( ) ) ) ; $ address -> setCountry ( utf8_encode ( $ address -> getCountry ( ) ) ) ; $ request -> addAddress ( $ address ) ; } } 
public function setExpressCheckout ( array $ fields ) { if ( false == isset ( $ fields [ 'RETURNURL' ] ) ) { if ( false == $ this -> options [ 'return_url' ] ) { throw new RuntimeException ( 'The return_url must be set either to FormRequest or to options.' ) ; } $ fields [ 'RETURNURL' ] = $ this -> options [ 'return_url' ] ; } if ( false == isset ( $ fields [ 'CANCELURL' ] ) ) { if ( false == $ this -> options [ 'cancel_url' ] ) { throw new RuntimeException ( 'The cancel_url must be set either to FormRequest or to options.' ) ; } $ fields [ 'CANCELURL' ] = $ this -> options [ 'cancel_url' ] ; } $ fields [ 'METHOD' ] = 'SetExpressCheckout' ; $ this -> addVersionField ( $ fields ) ; $ this -> addAuthorizeFields ( $ fields ) ; return $ this -> doRequest ( $ fields ) ; } 
public function getExpressCheckoutDetails ( array $ fields ) { $ fields [ 'METHOD' ] = 'GetExpressCheckoutDetails' ; $ this -> addVersionField ( $ fields ) ; $ this -> addAuthorizeFields ( $ fields ) ; return $ this -> doRequest ( $ fields ) ; } 
public function transactionSearch ( array $ fields ) { $ fields [ 'METHOD' ] = 'TransactionSearch' ; $ this -> addVersionField ( $ fields ) ; $ this -> addAuthorizeFields ( $ fields ) ; return $ this -> doRequest ( $ fields ) ; } 
public function doExpressCheckoutPayment ( array $ fields ) { $ fields [ 'METHOD' ] = 'DoExpressCheckoutPayment' ; $ this -> addVersionField ( $ fields ) ; $ this -> addAuthorizeFields ( $ fields ) ; return $ this -> doRequest ( $ fields ) ; } 
public function createRecurringPaymentsProfile ( array $ fields ) { $ fields [ 'METHOD' ] = 'CreateRecurringPaymentsProfile' ; $ this -> addVersionField ( $ fields ) ; $ this -> addAuthorizeFields ( $ fields ) ; return $ this -> doRequest ( $ fields ) ; } 
public function updateRecurringPaymentsProfile ( array $ fields ) { $ fields [ 'METHOD' ] = 'UpdateRecurringPaymentsProfile' ; $ this -> addVersionField ( $ fields ) ; $ this -> addAuthorizeFields ( $ fields ) ; return $ this -> doRequest ( $ fields ) ; } 
public function getRecurringPaymentsProfileDetails ( array $ fields ) { $ fields [ 'METHOD' ] = 'GetRecurringPaymentsProfileDetails' ; $ this -> addVersionField ( $ fields ) ; $ this -> addAuthorizeFields ( $ fields ) ; return $ this -> doRequest ( $ fields ) ; } 
public function manageRecurringPaymentsProfileStatus ( array $ fields ) { $ fields [ 'METHOD' ] = 'ManageRecurringPaymentsProfileStatus' ; $ this -> addVersionField ( $ fields ) ; $ this -> addAuthorizeFields ( $ fields ) ; return $ this -> doRequest ( $ fields ) ; } 
public function createBillingAgreement ( array $ fields ) { $ fields [ 'METHOD' ] = 'CreateBillingAgreement' ; $ this -> addVersionField ( $ fields ) ; $ this -> addAuthorizeFields ( $ fields ) ; return $ this -> doRequest ( $ fields ) ; } 
public function doReferenceTransaction ( array $ fields ) { $ fields [ 'METHOD' ] = 'DoReferenceTransaction' ; $ this -> addVersionField ( $ fields ) ; $ this -> addAuthorizeFields ( $ fields ) ; return $ this -> doRequest ( $ fields ) ; } 
public function doCapture ( array $ fields ) { $ fields [ 'METHOD' ] = 'DoCapture' ; $ this -> addVersionField ( $ fields ) ; $ this -> addAuthorizeFields ( $ fields ) ; return $ this -> doRequest ( $ fields ) ; } 
public function doVoid ( array $ fields ) { $ fields [ 'METHOD' ] = 'DoVoid' ; $ this -> addVersionField ( $ fields ) ; $ this -> addAuthorizeFields ( $ fields ) ; return $ this -> doRequest ( $ fields ) ; } 
public function getAuthorizeTokenUrl ( $ token , array $ query = array ( ) ) { $ defaultQuery = array_filter ( array ( 'useraction' => $ this -> options [ 'useraction' ] , 'cmd' => $ this -> options [ 'cmd' ] , 'token' => $ token , ) ) ; $ query = array_filter ( $ query ) ; return sprintf ( 'https://%s/cgi-bin/webscr?%s' , $ this -> options [ 'sandbox' ] ? 'www.sandbox.paypal.com' : 'www.paypal.com' , http_build_query ( array_replace ( $ defaultQuery , $ query ) ) ) ; } 
public function execute ( $ request ) { RequestNotSupportedException :: assertSupports ( $ this , $ request ) ; if ( $ this -> httpRequest instanceof Request ) { $ this -> updateRequest ( $ request , $ this -> httpRequest ) ; } elseif ( $ this -> httpRequestStack instanceof RequestStack && null !== $ this -> httpRequestStack -> getMasterRequest ( ) ) { $ this -> updateRequest ( $ request , $ this -> httpRequestStack -> getMasterRequest ( ) ) ; } } 
public function create ( array $ config = [ ] ) { $ config = ArrayObject :: ensureArrayObject ( $ config ) ; $ config -> defaults ( $ this -> createConfig ( ) ) ; $ gateway = new Gateway ( ) ; $ this -> buildClosures ( $ config ) ; $ this -> buildActions ( $ gateway , $ config ) ; $ this -> buildApis ( $ gateway , $ config ) ; $ this -> buildExtensions ( $ gateway , $ config ) ; return $ gateway ; } 
public function createConfig ( array $ config = [ ] ) { $ config = ArrayObject :: ensureArrayObject ( $ config ) ; $ config -> defaults ( $ this -> defaultConfig ) ; $ config -> defaults ( [ 'httplug.message_factory' => function ( ArrayObject $ config ) { if ( class_exists ( MessageFactoryDiscovery :: class ) ) { return MessageFactoryDiscovery :: find ( ) ; } if ( class_exists ( \ GuzzleHttp \ Psr7 \ Request :: class ) ) { return new GuzzleMessageFactory ( ) ; } if ( class_exists ( \ Zend \ Diactoros \ Request :: class ) ) { return new DiactorosMessageFactory ( ) ; } throw new \ LogicException ( 'The httplug.message_factory could not be guessed. Install one of the following packages: php-http/guzzle6-adapter, zendframework/zend-diactoros. You can also overwrite the config option with your implementation.' ) ; } , 'httplug.stream_factory' => function ( ArrayObject $ config ) { if ( class_exists ( StreamFactoryDiscovery :: class ) ) { return StreamFactoryDiscovery :: find ( ) ; } if ( class_exists ( \ GuzzleHttp \ Psr7 \ Request :: class ) ) { return new GuzzleStreamFactory ( ) ; } if ( class_exists ( \ Zend \ Diactoros \ Request :: class ) ) { return new DiactorosStreamFactory ( ) ; } throw new \ LogicException ( 'The httplug.stream_factory could not be guessed. Install one of the following packages: php-http/guzzle6-adapter, zendframework/zend-diactoros. You can also overwrite the config option with your implementation.' ) ; } , 'httplug.client' => function ( ArrayObject $ config ) { if ( class_exists ( HttpClientDiscovery :: class ) ) { return HttpClientDiscovery :: find ( ) ; } if ( class_exists ( HttpGuzzle6Client :: class ) ) { return new HttpGuzzle6Client ( ) ; } if ( class_exists ( HttpGuzzle5Client :: class ) ) { return new HttpGuzzle5Client ( ) ; } if ( class_exists ( HttpSocketClient :: class ) ) { return new HttpSocketClient ( ) ; } if ( class_exists ( HttpCurlClient :: class ) ) { return new HttpCurlClient ( $ config [ 'httplug.message_factory' ] , $ config [ 'httplug.stream_factory' ] ) ; } if ( class_exists ( HttpBuzzClient :: class ) ) { return new HttpBuzzClient ( ) ; } throw new \ LogicException ( 'The httplug.client could not be guessed. Install one of the following packages: php-http/guzzle6-adapter. You can also overwrite the config option with your implementation.' ) ; } , 'payum.http_client' => function ( ArrayObject $ config ) { return new HttplugClient ( $ config [ 'httplug.client' ] ) ; } , 'payum.template.layout' => '@PayumCore/layout.html.twig' , 'twig.env' => function ( ) { return new \ Twig_Environment ( new \ Twig_Loader_Chain ( ) ) ; } , 'twig.register_paths' => function ( ArrayObject $ config ) { $ twig = $ config [ 'twig.env' ] ; if ( false == $ twig instanceof \ Twig_Environment ) { throw new \ LogicException ( sprintf ( 'The `twig.env config option must contains instance of Twig_Environment but got %s`' , is_object ( $ twig ) ? get_class ( $ twig ) : gettype ( $ twig ) ) ) ; } TwigUtil :: registerPaths ( $ twig , $ config [ 'payum.paths' ] ) ; return null ; } , 'payum.action.get_http_request' => new GetHttpRequestAction ( ) , 'payum.action.capture_payment' => new CapturePaymentAction ( ) , 'payum.action.authorize_payment' => new AuthorizePaymentAction ( ) , 'payum.action.payout_payout' => new PayoutPayoutAction ( ) , 'payum.action.execute_same_request_with_model_details' => new ExecuteSameRequestWithModelDetailsAction ( ) , 'payum.action.render_template' => function ( ArrayObject $ config ) { return new RenderTemplateAction ( $ config [ 'twig.env' ] , $ config [ 'payum.template.layout' ] ) ; } , 'payum.extension.endless_cycle_detector' => new EndlessCycleDetectorExtension ( ) , 'payum.action.get_currency' => function ( ArrayObject $ config ) { return new GetCurrencyAction ( $ config [ 'payum.iso4217' ] ) ; } , 'payum.prepend_actions' => [ ] , 'payum.prepend_extensions' => [ ] , 'payum.prepend_apis' => [ ] , 'payum.default_options' => [ ] , 'payum.required_options' => [ ] , 'payum.api.http_client' => function ( ArrayObject $ config ) { return $ config [ 'payum.http_client' ] ; } , 'payum.security.token_storage' => null , ] ) ; if ( $ config [ 'payum.security.token_storage' ] ) { $ config [ 'payum.action.get_token' ] = function ( ArrayObject $ config ) { return new GetTokenAction ( $ config [ 'payum.security.token_storage' ] ) ; } ; } $ config [ 'payum.paths' ] = array_replace ( [ 'PayumCore' => __DIR__ . '/Resources/views' , ] , $ config [ 'payum.paths' ] ? : [ ] ) ; return ( array ) $ config ; } 
public function addApi ( $ api , $ forcePrepend = false ) { $ forcePrepend ? array_unshift ( $ this -> apis , $ api ) : array_push ( $ this -> apis , $ api ) ; } 
public function addAction ( ActionInterface $ action , $ forcePrepend = false ) { $ forcePrepend ? array_unshift ( $ this -> actions , $ action ) : array_push ( $ this -> actions , $ action ) ; } 
public function addExtension ( ExtensionInterface $ extension , $ forcePrepend = false ) { $ this -> extensions -> addExtension ( $ extension , $ forcePrepend ) ; } 
public function execute ( $ request , $ catchReply = false ) { $ context = new Context ( $ this , $ request , $ this -> stack ) ; array_push ( $ this -> stack , $ context ) ; try { $ this -> extensions -> onPreExecute ( $ context ) ; if ( false == $ context -> getAction ( ) ) { if ( false == $ action = $ this -> findActionSupported ( $ context -> getRequest ( ) ) ) { throw RequestNotSupportedException :: create ( $ context -> getRequest ( ) ) ; } $ context -> setAction ( $ action ) ; } $ this -> extensions -> onExecute ( $ context ) ; $ context -> getAction ( ) -> execute ( $ request ) ; $ this -> extensions -> onPostExecute ( $ context ) ; array_pop ( $ this -> stack ) ; } catch ( ReplyInterface $ reply ) { $ context -> setReply ( $ reply ) ; $ this -> extensions -> onPostExecute ( $ context ) ; array_pop ( $ this -> stack ) ; if ( $ catchReply && $ context -> getReply ( ) ) { return $ context -> getReply ( ) ; } if ( $ context -> getReply ( ) ) { throw $ context -> getReply ( ) ; } } catch ( \ Exception $ e ) { $ context -> setException ( $ e ) ; $ this -> onPostExecuteWithException ( $ context ) ; } return ; } 
protected function findActionSupported ( $ request ) { foreach ( $ this -> actions as $ action ) { if ( $ action instanceof GatewayAwareInterface ) { $ action -> setGateway ( $ this ) ; } if ( $ action instanceof ApiAwareInterface ) { $ apiSet = false ; $ unsupportedException = null ; foreach ( $ this -> apis as $ api ) { try { $ action -> setApi ( $ api ) ; $ apiSet = true ; break ; } catch ( UnsupportedApiException $ e ) { $ unsupportedException = $ e ; } } if ( false == $ apiSet ) { throw new LogicException ( sprintf ( 'Cannot find right api for the action %s' , get_class ( $ action ) ) , null , $ unsupportedException ) ; } } if ( $ action -> supports ( $ request ) ) { return $ action ; } } return false ; } 
public function validate ( $ value , Constraint $ constraint ) { if ( null === $ value ) { return ; } if ( ! ( $ value instanceof \ DateTime ) ) { if ( method_exists ( $ this -> context , 'buildViolation' ) ) { $ this -> context -> buildViolation ( $ constraint -> invalidMessage , array ( '{{ value }}' => $ value , ) ) -> addViolation ( ) ; return ; } $ this -> context -> addViolationAt ( 'expireAt' , $ constraint -> invalidMessage , array ( '{{ value }}' => $ value , ) ) ; } $ value -> modify ( 'last day of this month' ) ; if ( null !== $ constraint -> min && $ value < $ constraint -> min ) { if ( method_exists ( $ this -> context , 'buildViolation' ) ) { $ this -> context -> buildViolation ( $ constraint -> minMessage ) -> atPath ( 'expireAt' ) -> addViolation ( ) ; return ; } $ this -> context -> addViolationAt ( 'expireAt' , $ constraint -> minMessage ) ; } } 
public function createTransaction ( array $ fields ) { $ fields = ( array_replace ( [ 'success_url' => null , 'success_link_redirect' => true , 'abort_url' => null , 'notification_url' => null , 'notify_on' => implode ( ',' , [ self :: STATUS_PENDING , self :: STATUS_LOSS , self :: STATUS_RECEIVED , self :: STATUS_REFUNDED , self :: STATUS_UNTRACEABLE ] ) , 'reason' => '' , 'reason_2' => '' , 'product_code' => null , ] , $ fields ) ) ; $ sofort = new Sofortueberweisung ( $ this -> options [ 'config_key' ] ) ; $ sofort -> setAmount ( $ fields [ 'amount' ] ) ; $ sofort -> setCurrencyCode ( $ fields [ 'currency_code' ] ) ; $ sofort -> setReason ( $ fields [ 'reason' ] , $ fields [ 'reason_2' ] , $ fields [ 'product_code' ] ) ; $ sofort -> setSuccessUrl ( $ fields [ 'success_url' ] , $ fields [ 'success_link_redirect' ] ) ; $ sofort -> setAbortUrl ( $ fields [ 'abort_url' ] ) ; if ( false == $ this -> options [ 'disable_notification' ] ) { $ sofort -> setNotificationUrl ( $ fields [ 'notification_url' ] , $ fields [ 'notify_on' ] ) ; } $ sofort -> sendRequest ( ) ; return array_filter ( [ 'error' => $ sofort -> getError ( ) , 'transaction_id' => $ sofort -> getTransactionId ( ) , 'payment_url' => $ sofort -> getPaymentUrl ( ) , ] ) ; } 
public function getTransactionData ( $ transactionId ) { $ transactionData = new TransactionData ( $ this -> options [ 'config_key' ] ) ; $ transactionData -> addTransaction ( $ transactionId ) ; $ transactionData -> setApiVersion ( '2.0' ) ; $ transactionData -> sendRequest ( ) ; $ fields = array ( ) ; $ methods = array ( 'getAmount' => '' , 'getAmountRefunded' => '' , 'getCount' => '' , 'getPaymentMethod' => '' , 'getConsumerProtection' => '' , 'getStatus' => '' , 'getStatusReason' => '' , 'getStatusModifiedTime' => '' , 'getLanguageCode' => '' , 'getCurrency' => '' , 'getTransaction' => '' , 'getReason' => array ( 0 , 0 ) , 'getUserVariable' => 0 , 'getTime' => '' , 'getProjectId' => '' , 'getRecipientHolder' => '' , 'getRecipientAccountNumber' => '' , 'getRecipientBankCode' => '' , 'getRecipientCountryCode' => '' , 'getRecipientBankName' => '' , 'getRecipientBic' => '' , 'getRecipientIban' => '' , 'getSenderHolder' => '' , 'getSenderAccountNumber' => '' , 'getSenderBankCode' => '' , 'getSenderCountryCode' => '' , 'getSenderBankName' => '' , 'getSenderBic' => '' , 'getSenderIban' => '' , ) ; foreach ( $ methods as $ method => $ params ) { $ varName = $ method ; $ varName = strtolower ( preg_replace ( '/([^A-Z])([A-Z])/' , '$1_$2' , substr ( $ varName , 3 ) ) ) ; if ( count ( $ params ) == 2 ) { $ fields [ $ varName ] = $ transactionData -> $ method ( $ params [ 0 ] , $ params [ 1 ] ) ; } elseif ( $ params !== '' ) { $ fields [ $ varName ] = $ transactionData -> $ method ( $ params ) ; } else { $ fields [ $ varName ] = $ transactionData -> $ method ( ) ; } } if ( $ transactionData -> isError ( ) ) { $ fields [ 'error' ] = $ transactionData -> getError ( ) ; } return $ fields ; } 
public function refundTransaction ( array $ fields ) { $ refund = new Refund ( $ this -> options [ 'config_key' ] ) ; $ refund -> setSenderSepaAccount ( $ fields [ 'recipient_bic' ] , $ fields [ 'recipient_iban' ] , $ fields [ 'recipient_holder' ] ) ; $ refund -> addRefund ( $ fields [ 'transaction_id' ] , $ fields [ 'refund_amount' ] ) ; $ refund -> setPartialRefundId ( md5 ( uniqid ( ) ) ) ; $ refund -> setReason ( $ fields [ 'reason' ] ) ; $ refund -> sendRequest ( ) ; if ( $ refund -> isError ( ) ) { $ fields [ 'refund_error' ] = $ refund -> getError ( ) ; } else { $ fields [ 'refund_url' ] = $ refund -> getPaymentUrl ( ) ; } return $ fields ; } 
public function convertToPHPValue ( $ value ) { if ( $ value === null ) { return ; } $ value = ( is_resource ( $ value ) ) ? stream_get_contents ( $ value ) : $ value ; $ val = unserialize ( $ value ) ; if ( $ val === false && $ value !== 'b:0;' ) { throw new \ LogicException ( 'Conversion exception: ' . $ value . '. ' . $ this -> getName ( ) ) ; } return $ val ; } 
protected function validateOptions ( array $ options = [ ] ) : ParameterBag { if ( empty ( $ options ) ) { return $ this -> options ; } return $ this -> doValidateOptions ( $ options ) ; } 
private function doValidateOptions ( array $ options = [ ] ) : ParameterBag { $ parameterBag = $ this -> options -> add ( $ options ) ; try { $ parameters = $ this -> getOptionsResolver ( ) -> resolve ( $ parameterBag -> all ( ) ) ; } catch ( \ Throwable $ e ) { 
public function addCookie ( Cookie $ cookie ) : void { $ this -> cookies [ $ this -> getHash ( $ cookie ) ] = $ cookie ; } 
public function addCookieHeaders ( RequestInterface $ request ) : RequestInterface { $ cookies = [ ] ; foreach ( $ this -> getCookies ( ) as $ cookie ) { if ( $ cookie -> matchesRequest ( $ request ) ) { $ cookies [ ] = $ cookie -> toCookieHeader ( ) ; } } if ( $ cookies ) { $ request = $ request -> withAddedHeader ( 'Cookie' , implode ( '; ' , $ cookies ) ) ; } return $ request ; } 
public function processSetCookieHeaders ( RequestInterface $ request , ResponseInterface $ response ) : void { $ host = $ request -> getUri ( ) -> getHost ( ) ; foreach ( $ response -> getHeader ( 'Set-Cookie' ) as $ header ) { $ cookie = new Cookie ( ) ; $ cookie -> fromSetCookieHeader ( $ header , $ host ) ; $ this -> addCookie ( $ cookie ) ; } } 
public function clearExpiredCookies ( ) : void { $ cookies = $ this -> getCookies ( ) ; foreach ( $ cookies as $ i => $ cookie ) { if ( $ cookie -> isExpired ( ) ) { unset ( $ cookies [ $ i ] ) ; } } $ this -> clear ( ) ; $ this -> setCookies ( array_values ( $ cookies ) ) ; } 
private function getHash ( Cookie $ cookie ) : string { return sha1 ( sprintf ( '%s|%s|%s' , $ cookie -> getName ( ) , $ cookie -> getAttribute ( Cookie :: ATTR_DOMAIN ) , $ cookie -> getAttribute ( Cookie :: ATTR_PATH ) ) ) ; } 
public function addHeader ( string $ input ) : void { list ( $ key , $ value ) = explode ( ':' , $ input , 2 ) ; $ this -> response = $ this -> response -> withAddedHeader ( trim ( $ key ) , trim ( $ value ) ) ; } 
public function parseHttpHeaders ( array $ headers ) : void { $ headers = $ this -> filterHeaders ( $ headers ) ; $ statusLine = array_shift ( $ headers ) ; try { $ this -> setStatus ( $ statusLine ) ; } catch ( InvalidArgumentException $ e ) { array_unshift ( $ headers , $ statusLine ) ; } foreach ( $ headers as $ header ) { $ this -> addHeader ( $ header ) ; } } 
public function handleRequest ( RequestInterface $ request , callable $ next ) { $ this -> setUri ( $ request -> getUri ( ) -> getPath ( ) ) ; $ this -> setMethod ( strtoupper ( $ request -> getMethod ( ) ) ) ; $ this -> setEntityBody ( $ request -> getBody ( ) -> __toString ( ) ) ; $ header = $ this -> getHeader ( ) ; if ( null !== $ header ) { $ request = $ request -> withHeader ( 'Authorization' , $ header ) ; } return $ next ( $ request ) ; } 
public function handleResponse ( RequestInterface $ request , ResponseInterface $ response , callable $ next ) { $ this -> parseServerHeaders ( $ response ) ; return $ next ( $ request , $ response ) ; } 
public function setOptions ( $ options ) : void { if ( $ options & self :: OPTION_QOP_AUTH_INT ) { if ( $ options & self :: OPTION_QOP_AUTH ) { throw new \ InvalidArgumentException ( 'DigestAuthMiddleware: Only one value of OPTION_QOP_AUTH_INT or OPTION_QOP_AUTH may be set.' ) ; } $ this -> options = $ this -> options | self :: OPTION_QOP_AUTH_INT ; } elseif ( $ options & self :: OPTION_QOP_AUTH ) { $ this -> options = $ this -> options | self :: OPTION_QOP_AUTH ; } if ( $ options & self :: OPTION_IGNORE_DOWNGRADE_REQUEST ) { $ this -> options = $ this -> options | self :: OPTION_IGNORE_DOWNGRADE_REQUEST ; } if ( $ options & self :: OPTION_DISCARD_CLIENT_NONCE ) { $ this -> options = $ this -> options | self :: OPTION_DISCARD_CLIENT_NONCE ; } } 
private function getClientNonce ( ) : ? string { if ( null == $ this -> clientNonce ) { $ this -> clientNonce = uniqid ( ) ; if ( null == $ this -> nonceCount ) { 
private function getHA1 ( ) : ? string { $ username = $ this -> getUsername ( ) ; $ password = $ this -> getPassword ( ) ; $ realm = $ this -> getRealm ( ) ; if ( ( $ username ) && ( $ password ) && ( $ realm ) ) { $ algorithm = $ this -> getAlgorithm ( ) ; if ( 'MD5' === $ algorithm ) { $ A1 = "{$username}:{$realm}:{$password}" ; return $ this -> hash ( $ A1 ) ; } elseif ( 'MD5-sess' === $ algorithm ) { $ nonce = $ this -> getNonce ( ) ; $ cnonce = $ this -> getClientNonce ( ) ; if ( ( $ nonce ) && ( $ cnonce ) ) { $ A1 = $ this -> hash ( "{$username}:{$realm}:{$password}" ) . ":{$nonce}:{$cnonce}" ; return $ this -> hash ( $ A1 ) ; } } } return null ; } 
private function getHA2 ( ) : ? string { $ method = $ this -> getMethod ( ) ; $ uri = $ this -> getUri ( ) ; if ( ( $ method ) && ( $ uri ) ) { $ qop = $ this -> getQOP ( ) ; if ( null === $ qop || 'auth' === $ qop ) { $ A2 = "{$method}:{$uri}" ; } elseif ( 'auth-int' === $ qop ) { $ entityBody = ( string ) $ this -> getEntityBody ( ) ; $ A2 = "{$method}:{$uri}:" . ( string ) $ this -> hash ( $ entityBody ) ; } else { return null ; } $ HA2 = $ this -> hash ( $ A2 ) ; return $ HA2 ; } return null ; } 
private function getHeader ( ) : ? string { if ( 'Digest' == $ this -> getAuthenticationMethod ( ) ) { $ username = $ this -> getUsername ( ) ; $ realm = $ this -> getRealm ( ) ; $ nonce = $ this -> getNonce ( ) ; $ response = $ this -> getResponse ( ) ; if ( ( $ username ) && ( $ realm ) && ( $ nonce ) && ( $ response ) ) { $ uri = $ this -> getUri ( ) ; $ opaque = $ this -> getOpaque ( ) ; $ qop = $ this -> getQOP ( ) ; $ header = 'Digest' ; $ header .= ' username="' . $ username . '",' ; $ header .= ' realm="' . $ realm . '",' ; $ header .= ' nonce="' . $ nonce . '",' ; $ header .= ' response="' . $ response . '",' ; if ( $ uri ) { $ header .= ' uri="' . $ uri . '",' ; } if ( $ opaque ) { $ header .= ' opaque="' . $ opaque . '",' ; } if ( $ qop ) { $ header .= ' qop=' . $ qop . ',' ; $ cnonce = $ this -> getClientNonce ( ) ; $ nc = $ this -> getNonceCount ( ) ; if ( $ cnonce ) { $ header .= ' nc=' . $ nc . ',' ; } if ( $ cnonce ) { $ header .= ' cnonce="' . $ cnonce . '",' ; } } 
private function getResponse ( ) : ? string { $ HA1 = $ this -> getHA1 ( ) ; $ nonce = $ this -> getNonce ( ) ; $ HA2 = $ this -> getHA2 ( ) ; if ( null !== $ HA1 && ( $ nonce ) && null !== $ HA2 ) { $ qop = $ this -> getQOP ( ) ; if ( empty ( $ qop ) ) { $ response = $ this -> hash ( "{$HA1}:{$nonce}:{$HA2}" ) ; return $ response ; } $ cnonce = $ this -> getClientNonce ( ) ; $ nc = $ this -> getNonceCount ( ) ; if ( ( $ cnonce ) && ( $ nc ) ) { $ response = $ this -> hash ( "{$HA1}:{$nonce}:{$nc}:{$cnonce}:{$qop}:{$HA2}" ) ; return $ response ; } } return null ; } 
private function getQOP ( ) : ? string { 
private function hash ( $ value ) : ? string { $ algorithm = $ this -> getAlgorithm ( ) ; if ( ( 'MD5' == $ algorithm ) || ( 'MD5-sess' == $ algorithm ) ) { return hash ( 'md5' , $ value ) ; } return null ; } 
private function parseAuthenticationInfoHeader ( string $ authenticationInfo ) : void { $ nameValuePairs = $ this -> parseNameValuePairs ( $ authenticationInfo ) ; foreach ( $ nameValuePairs as $ name => $ value ) { switch ( $ name ) { case 'message-qop' : break ; case 'nextnonce' : 
private function parseNameValuePairs ( string $ nameValuePairs ) : array { $ parsedNameValuePairs = [ ] ; $ nameValuePairs = explode ( ',' , $ nameValuePairs ) ; foreach ( $ nameValuePairs as $ nameValuePair ) { 
private function parseServerHeaders ( ResponseInterface $ response ) : void { 
private function parseWwwAuthenticateHeader ( string $ wwwAuthenticate ) : void { if ( 'Digest ' == substr ( $ wwwAuthenticate , 0 , 7 ) ) { $ this -> setAuthenticationMethod ( 'Digest' ) ; 
private function setAlgorithm ( string $ algorithm ) : void { if ( ( 'MD5' == $ algorithm ) || ( 'MD5-sess' == $ algorithm ) ) { $ this -> algorithm = $ algorithm ; } else { throw new \ InvalidArgumentException ( 'DigestAuthMiddleware: Only MD5 and MD5-sess algorithms are currently supported.' ) ; } } 
private function setAuthenticationMethod ( string $ authenticationMethod ) : void { if ( 'Digest' === $ authenticationMethod || 'Basic' === $ authenticationMethod ) { $ this -> authenticationMethod = $ authenticationMethod ; } else { throw new \ InvalidArgumentException ( 'DigestAuthMiddleware: Only Digest and Basic authentication methods are currently supported.' ) ; } } 
private function setMethod ( string $ method = null ) : void { if ( 'GET' == $ method ) { $ this -> method = 'GET' ; return ; } if ( 'POST' == $ method ) { $ this -> method = 'POST' ; return ; } if ( 'PUT' == $ method ) { $ this -> method = 'PUT' ; return ; } if ( 'DELETE' == $ method ) { $ this -> method = 'DELETE' ; return ; } if ( 'HEAD' == $ method ) { $ this -> method = 'HEAD' ; return ; } throw new \ InvalidArgumentException ( 'DigestAuthMiddleware: Only GET,POST,PUT,DELETE,HEAD HTTP methods are currently supported.' ) ; } 
private function setQOP ( array $ qop = [ ] ) : void { $ this -> qop = [ ] ; foreach ( $ qop as $ protection ) { $ protection = trim ( $ protection ) ; if ( 'auth-int' == $ protection ) { $ this -> qop [ ] = 'auth-int' ; } elseif ( 'auth' == $ protection ) { $ this -> qop [ ] = 'auth' ; } else { throw new \ InvalidArgumentException ( 'DigestAuthMiddleware: Only auth-int and auth are supported Quality of Protection mechanisms.' ) ; } } } 
private function unquoteString ( string $ str = null ) : ? string { if ( $ str ) { if ( '"' == substr ( $ str , 0 , 1 ) ) { $ str = substr ( $ str , 1 , \ strlen ( $ str ) - 1 ) ; } if ( '"' == substr ( $ str , \ strlen ( $ str ) - 1 , 1 ) ) { $ str = substr ( $ str , 0 , \ strlen ( $ str ) - 1 ) ; } } return $ str ; } 
public function add ( array $ parameters = [ ] ) : self { 
public static function toBuzzHeaders ( array $ headers ) : array { $ buzz = [ ] ; foreach ( $ headers as $ key => $ values ) { if ( ! \ is_array ( $ values ) ) { $ buzz [ ] = sprintf ( '%s: %s' , $ key , $ values ) ; } else { foreach ( $ values as $ value ) { $ buzz [ ] = sprintf ( '%s: %s' , $ key , $ value ) ; } } } return $ buzz ; } 
public static function toPsrHeaders ( array $ headers ) : array { $ psr = [ ] ; foreach ( $ headers as $ header ) { list ( $ key , $ value ) = explode ( ':' , $ header , 2 ) ; $ psr [ trim ( $ key ) ] [ ] = trim ( $ value ) ; } return $ psr ; } 
protected function getStreamContextArray ( RequestInterface $ request , ParameterBag $ options ) : array { $ headers = $ request -> getHeaders ( ) ; unset ( $ headers [ 'Host' ] ) ; $ context = [ 'http' => [ 
public function sendAsyncRequest ( RequestInterface $ request , array $ options = [ ] ) : void { $ options = $ this -> validateOptions ( $ options ) ; $ this -> addToQueue ( $ request , $ options ) ; } 
public function sendRequest ( RequestInterface $ request , array $ options = [ ] ) : ResponseInterface { $ options = $ this -> validateOptions ( $ options ) ; $ originalCallback = $ options -> get ( 'callback' ) ; $ responseToReturn = null ; $ options = $ options -> add ( [ 'callback' => function ( RequestInterface $ request , ResponseInterface $ response = null , ClientException $ e = null ) use ( & $ responseToReturn , $ originalCallback ) { $ responseToReturn = $ response ; $ originalCallback ( $ request , $ response , $ e ) ; if ( null !== $ e ) { throw $ e ; } } ] ) ; $ this -> addToQueue ( $ request , $ options ) ; $ this -> flush ( ) ; return $ responseToReturn ; } 
public function proceed ( ) : void { if ( empty ( $ this -> queue ) ) { return ; } if ( ! $ this -> curlm ) { $ this -> initMultiCurlHandle ( ) ; } $ this -> initQueue ( ) ; $ exception = null ; do { 
private function initMultiCurlHandle ( ) : void { $ this -> curlm = curl_multi_init ( ) ; if ( false === $ this -> curlm ) { throw new ClientException ( 'Unable to create a new cURL multi handle' ) ; } if ( $ this -> serverPushSupported ) { $ userCallbacks = $ this -> pushFunctions ; curl_multi_setopt ( $ this -> curlm , CURLMOPT_PIPELINING , CURLPIPE_MULTIPLEX ) ; 
private function initQueue ( ) : void { foreach ( $ this -> queue as $ i => $ queueItem ) { if ( 2 !== \ count ( $ queueItem ) ) { 
private function cleanup ( ) : void { if ( empty ( $ this -> queue ) ) { curl_multi_close ( $ this -> curlm ) ; $ this -> curlm = null ; $ this -> pushFunctions = [ ] ; $ this -> pushCb = [ ] ; } } 
public function matchesRequest ( RequestInterface $ request ) : bool { $ uri = $ request -> getUri ( ) ; 
public function isExpired ( ) : bool { $ maxAge = $ this -> getAttribute ( static :: ATTR_MAX_AGE ) ; if ( $ maxAge && time ( ) - $ this -> getCreatedAt ( ) > $ maxAge ) { return true ; } $ expires = $ this -> getAttribute ( static :: ATTR_EXPIRES ) ; if ( $ expires && strtotime ( $ expires ) < time ( ) ) { return true ; } return false ; } 
public function matchesDomain ( string $ domain ) : bool { $ cookieDomain = $ this -> getAttribute ( static :: ATTR_DOMAIN ) ?? '' ; if ( 0 === strpos ( $ cookieDomain , '.' ) ) { $ pattern = '/\b' . preg_quote ( substr ( $ cookieDomain , 1 ) , '/' ) . '$/i' ; return ( bool ) preg_match ( $ pattern , $ domain ) ; } else { return 0 == strcasecmp ( $ cookieDomain , $ domain ) ; } } 
public function matchesPath ( string $ path ) : bool { $ needle = $ this -> getAttribute ( static :: ATTR_PATH ) ; return null === $ needle || 0 === strpos ( $ path , $ needle ) ; } 
public function fromSetCookieHeader ( string $ header , string $ issuingDomain ) : void { list ( $ this -> name , $ header ) = explode ( '=' , $ header , 2 ) ; if ( false === strpos ( $ header , ';' ) ) { $ this -> value = $ header ; $ header = null ; } else { list ( $ this -> value , $ header ) = explode ( ';' , $ header , 2 ) ; } $ this -> clearAttributes ( ) ; if ( null !== $ header ) { foreach ( array_map ( 'trim' , explode ( ';' , trim ( $ header ) ) ) as $ pair ) { if ( false === strpos ( $ pair , '=' ) ) { $ name = $ pair ; $ value = null ; } else { list ( $ name , $ value ) = explode ( '=' , $ pair ) ; } $ this -> setAttribute ( $ name , $ value ) ; } } if ( ! $ this -> getAttribute ( static :: ATTR_DOMAIN ) ) { $ this -> setAttribute ( static :: ATTR_DOMAIN , $ issuingDomain ) ; } } 
protected function releaseHandle ( $ curl ) : void { if ( \ count ( $ this -> handles ) >= $ this -> maxHandles ) { curl_close ( $ curl ) ; } else { 
protected function prepare ( $ curl , RequestInterface $ request , ParameterBag $ options ) : ResponseBuilder { if ( \ defined ( 'CURLOPT_PROTOCOLS' ) ) { curl_setopt ( $ curl , CURLOPT_PROTOCOLS , CURLPROTO_HTTP | CURLPROTO_HTTPS ) ; curl_setopt ( $ curl , CURLOPT_REDIR_PROTOCOLS , CURLPROTO_HTTP | CURLPROTO_HTTPS ) ; } curl_setopt ( $ curl , CURLOPT_HEADER , false ) ; curl_setopt ( $ curl , CURLOPT_RETURNTRANSFER , false ) ; curl_setopt ( $ curl , CURLOPT_FAILONERROR , false ) ; $ this -> setOptionsFromParameterBag ( $ curl , $ options ) ; $ this -> setOptionsFromRequest ( $ curl , $ request ) ; $ responseBuilder = new ResponseBuilder ( $ this -> responseFactory ) ; curl_setopt ( $ curl , CURLOPT_HEADERFUNCTION , function ( $ ch , $ data ) use ( $ responseBuilder ) { $ str = trim ( $ data ) ; if ( '' !== $ str ) { if ( 0 === strpos ( strtolower ( $ str ) , 'http/' ) ) { $ responseBuilder -> setStatus ( $ str ) ; } else { $ responseBuilder -> addHeader ( $ str ) ; } } return \ strlen ( $ data ) ; } ) ; curl_setopt ( $ curl , CURLOPT_WRITEFUNCTION , function ( $ ch , $ data ) use ( $ responseBuilder ) { return $ responseBuilder -> writeBody ( $ data ) ; } ) ; 
private function setOptionsFromRequest ( $ curl , RequestInterface $ request ) : void { $ options = [ CURLOPT_CUSTOMREQUEST => $ request -> getMethod ( ) , CURLOPT_URL => $ request -> getUri ( ) -> __toString ( ) , CURLOPT_HTTPHEADER => HeaderConverter :: toBuzzHeaders ( $ request -> getHeaders ( ) ) , ] ; if ( 0 !== $ version = $ this -> getProtocolVersion ( $ request ) ) { $ options [ CURLOPT_HTTP_VERSION ] = $ version ; } if ( $ request -> getUri ( ) -> getUserInfo ( ) ) { $ options [ CURLOPT_USERPWD ] = $ request -> getUri ( ) -> getUserInfo ( ) ; } switch ( strtoupper ( $ request -> getMethod ( ) ) ) { case 'HEAD' : $ options [ CURLOPT_NOBODY ] = true ; break ; case 'GET' : $ options [ CURLOPT_HTTPGET ] = true ; break ; case 'POST' : case 'PUT' : case 'DELETE' : case 'PATCH' : case 'OPTIONS' : $ body = $ request -> getBody ( ) ; $ bodySize = $ body -> getSize ( ) ; if ( 0 !== $ bodySize ) { if ( $ body -> isSeekable ( ) ) { $ body -> rewind ( ) ; } 
protected function parseError ( RequestInterface $ request , int $ errno , $ curl ) : void { switch ( $ errno ) { case CURLE_OK : 
public function sendRequest ( RequestInterface $ request , array $ options = [ ] ) : ResponseInterface { $ chain = $ this -> createMiddlewareChain ( $ this -> middleware , function ( RequestInterface $ request , callable $ responseChain ) use ( $ options ) { $ response = $ this -> client -> sendRequest ( $ request , $ options ) ; $ responseChain ( $ request , $ response ) ; } , function ( RequestInterface $ request , ResponseInterface $ response ) { $ this -> lastRequest = $ request ; $ this -> lastResponse = $ response ; } ) ; 
public function record ( RequestInterface $ request , ResponseInterface $ response , float $ duration = null ) : void { $ this -> addEntry ( new Entry ( $ request , $ response , $ duration ) ) ; } 
public function setPage ( $ page ) { $ this -> _page = preg_match ( self :: REGEX_HTML , $ page ) ? new File ( $ page , '.html' ) : $ page ; return $ this ; } 
public function saveAs ( $ filename ) { if ( ! $ this -> _isCreated && ! $ this -> createImage ( ) ) { return false ; } if ( ! $ this -> _tmpImageFile -> saveAs ( $ filename ) ) { $ tmpFile = $ this -> _tmpImageFile -> getFileName ( ) ; $ this -> _error = "Could not copy image from tmp location '$tmpFile' to '$filename'" ; return false ; } return true ; } 
public function send ( $ filename = null , $ inline = false ) { if ( ! $ this -> _isCreated && ! $ this -> createImage ( ) ) { return false ; } $ this -> _tmpImageFile -> send ( $ filename , $ this -> getMimeType ( ) , $ inline ) ; return true ; } 
public function toString ( ) { if ( ! $ this -> _isCreated && ! $ this -> createImage ( ) ) { return false ; } return file_get_contents ( $ this -> _tmpImageFile -> getFileName ( ) ) ; } 
public function setOptions ( $ options = array ( ) ) { foreach ( $ options as $ key => $ val ) { if ( is_int ( $ key ) ) { $ this -> _options [ ] = $ val ; } elseif ( $ key [ 0 ] !== '_' && property_exists ( $ this , $ key ) ) { $ this -> $ key = $ val ; } else { $ this -> _options [ $ key ] = $ val ; } } return $ this ; } 
protected function createImage ( ) { if ( $ this -> _isCreated ) { return false ; } $ command = $ this -> getCommand ( ) ; $ fileName = $ this -> getImageFilename ( ) ; $ command -> addArgs ( $ this -> _options ) ; 
public function addPage ( $ input , $ options = array ( ) , $ type = null ) { $ options [ 'inputArg' ] = $ this -> ensureUrlOrFile ( $ input , $ type ) ; $ this -> _objects [ ] = $ this -> ensureUrlOrFileOptions ( $ options ) ; return $ this ; } 
public function addCover ( $ input , $ options = array ( ) , $ type = null ) { $ options [ 'input' ] = ( $ this -> version9 ? '--' : '' ) . 'cover' ; $ options [ 'inputArg' ] = $ this -> ensureUrlOrFile ( $ input , $ type ) ; $ this -> _objects [ ] = $ this -> ensureUrlOrFileOptions ( $ options ) ; return $ this ; } 
public function addToc ( $ options = array ( ) ) { $ options [ 'input' ] = ( $ this -> version9 ? '--' : '' ) . 'toc' ; $ this -> _objects [ ] = $ this -> ensureUrlOrFileOptions ( $ options ) ; return $ this ; } 
public function saveAs ( $ filename ) { if ( ! $ this -> _isCreated && ! $ this -> createPdf ( ) ) { return false ; } if ( ! $ this -> _tmpPdfFile -> saveAs ( $ filename ) ) { $ this -> _error = "Could not save PDF as '$filename'" ; return false ; } return true ; } 
public function send ( $ filename = null , $ inline = false ) { if ( ! $ this -> _isCreated && ! $ this -> createPdf ( ) ) { return false ; } $ this -> _tmpPdfFile -> send ( $ filename , 'application/pdf' , $ inline ) ; return true ; } 
public function toString ( ) { if ( ! $ this -> _isCreated && ! $ this -> createPdf ( ) ) { return false ; } return file_get_contents ( $ this -> _tmpPdfFile -> getFileName ( ) ) ; } 
public function setOptions ( $ options = array ( ) ) { 
protected function createPdf ( ) { if ( $ this -> _isCreated ) { return false ; } $ command = $ this -> getCommand ( ) ; $ fileName = $ this -> getPdfFilename ( ) ; $ command -> addArgs ( $ this -> _options ) ; foreach ( $ this -> _objects as $ object ) { $ command -> addArgs ( $ object ) ; } $ command -> addArg ( $ fileName , null , true ) ; 
protected function ensureUrlOrFile ( $ input , $ type = null ) { if ( $ input instanceof File ) { $ this -> _tmpFiles [ ] = $ input ; return $ input ; } elseif ( preg_match ( self :: REGEX_URL , $ input ) ) { return $ input ; } elseif ( $ type === self :: TYPE_XML || $ type === null && preg_match ( self :: REGEX_XML , $ input ) ) { $ ext = '.xml' ; } else { 
public function addArgs ( $ args ) { if ( isset ( $ args [ 'input' ] ) ) { 
public static function create ( array $ parsedResponse ) { $ result = new Logging ( ) ; $ result -> setVersion ( $ parsedResponse [ 'Version' ] ) ; $ result -> setDelete ( Utilities :: toBoolean ( $ parsedResponse [ 'Delete' ] ) ) ; $ result -> setRead ( Utilities :: toBoolean ( $ parsedResponse [ 'Read' ] ) ) ; $ result -> setWrite ( Utilities :: toBoolean ( $ parsedResponse [ 'Write' ] ) ) ; $ result -> setRetentionPolicy ( RetentionPolicy :: create ( $ parsedResponse [ 'RetentionPolicy' ] ) ) ; return $ result ; } 
public function toArray ( ) { return array ( 'Version' => $ this -> _version , 'Delete' => Utilities :: booleanToString ( $ this -> _delete ) , 'Read' => Utilities :: booleanToString ( $ this -> _read ) , 'Write' => Utilities :: booleanToString ( $ this -> _write ) , 'RetentionPolicy' => ! empty ( $ this -> _retentionPolicy ) ? $ this -> _retentionPolicy -> toArray ( ) : null ) ; } 
private static function createClient ( array $ options ) { $ verify = true ; 
protected function createMiddlewareStack ( ServiceOptions $ serviceOptions ) { 
protected function sendConcurrentAsync ( callable $ generator , $ statusCode , ServiceOptions $ options ) { $ client = $ this -> client ; $ middlewareStack = $ this -> createMiddlewareStack ( $ options ) ; $ sendAsync = function ( $ request , $ options ) use ( $ client ) { if ( $ request -> getMethod ( ) == 'HEAD' ) { $ options [ 'decode_content' ] = false ; } return $ client -> sendAsync ( $ request , $ options ) ; } ; $ handler = $ middlewareStack -> apply ( $ sendAsync ) ; $ requestOptions = $ this -> generateRequestOptions ( $ options , $ handler ) ; $ promises = \ call_user_func ( function ( ) use ( $ generator , $ handler , $ requestOptions ) { while ( is_callable ( $ generator ) && ( $ request = $ generator ( ) ) ) { yield \ call_user_func ( $ handler , $ request , $ requestOptions ) ; } } ) ; $ eachPromise = new EachPromise ( $ promises , [ 'concurrency' => $ options -> getNumberOfConcurrency ( ) , 'fulfilled' => function ( $ response , $ index ) use ( $ statusCode ) { 
protected function createRequest ( $ method , array $ headers , array $ queryParams , array $ postParameters , $ path , $ locationMode , $ body = Resources :: EMPTY_STRING ) { if ( $ locationMode == LocationMode :: SECONDARY_ONLY || $ locationMode == LocationMode :: SECONDARY_THEN_PRIMARY ) { $ uri = $ this -> psrSecondaryUri ; } else { $ uri = $ this -> psrPrimaryUri ; } 
protected function sendAsync ( $ method , array $ headers , array $ queryParams , array $ postParameters , $ path , $ expected = Resources :: STATUS_OK , $ body = Resources :: EMPTY_STRING , ServiceOptions $ serviceOptions = null ) { if ( $ serviceOptions == null ) { $ serviceOptions = new ServiceOptions ( ) ; } $ this -> addOptionalQueryParam ( $ queryParams , Resources :: QP_TIMEOUT , $ serviceOptions -> getTimeout ( ) ) ; $ request = $ this -> createRequest ( $ method , $ headers , $ queryParams , $ postParameters , $ path , $ serviceOptions -> getLocationMode ( ) , $ body ) ; $ client = $ this -> client ; $ middlewareStack = $ this -> createMiddlewareStack ( $ serviceOptions ) ; $ sendAsync = function ( $ request , $ options ) use ( $ client ) { return $ client -> sendAsync ( $ request , $ options ) ; } ; $ handler = $ middlewareStack -> apply ( $ sendAsync ) ; $ requestOptions = $ this -> generateRequestOptions ( $ serviceOptions , $ handler ) ; if ( $ request -> getMethod ( ) == 'HEAD' ) { $ requestOptions [ Resources :: ROS_DECODE_CONTENT ] = false ; } $ promise = \ call_user_func ( $ handler , $ request , $ requestOptions ) ; return $ promise -> then ( function ( $ response ) use ( $ expected , $ requestOptions ) { self :: throwIfError ( $ response , $ expected ) ; return self :: addLocationHeaderToResponse ( $ response , $ requestOptions [ Resources :: ROS_LOCATION_MODE ] ) ; } , function ( $ reason ) use ( $ expected ) { if ( ! ( $ reason instanceof RequestException ) ) { throw $ reason ; } $ response = $ reason -> getResponse ( ) ; if ( $ response != null ) { self :: throwIfError ( $ response , $ expected ) ; } else { 
protected function generateRequestOptions ( ServiceOptions $ serviceOptions , callable $ handler ) { $ result = array ( ) ; $ result [ Resources :: ROS_LOCATION_MODE ] = $ serviceOptions -> getLocationMode ( ) ; $ result [ Resources :: ROS_STREAM ] = $ serviceOptions -> getIsStreaming ( ) ; $ result [ Resources :: ROS_DECODE_CONTENT ] = $ serviceOptions -> getDecodeContent ( ) ; $ result [ Resources :: ROS_HANDLER ] = $ handler ; $ result [ Resources :: ROS_SECONDARY_URI ] = $ this -> getPsrSecondaryUri ( ) ; $ result [ Resources :: ROS_PRIMARY_URI ] = $ this -> getPsrPrimaryUri ( ) ; return $ result ; } 
protected function sendContextAsync ( HttpCallContext $ context ) { return $ this -> sendAsync ( $ context -> getMethod ( ) , $ context -> getHeaders ( ) , $ context -> getQueryParameters ( ) , $ context -> getPostParameters ( ) , $ context -> getPath ( ) , $ context -> getStatusCodes ( ) , $ context -> getBody ( ) , $ context -> getServiceOptions ( ) ) ; } 
public static function throwIfError ( ResponseInterface $ response , $ expected ) { $ expectedStatusCodes = is_array ( $ expected ) ? $ expected : array ( $ expected ) ; if ( ! in_array ( $ response -> getStatusCode ( ) , $ expectedStatusCodes ) ) { throw new ServiceException ( $ response ) ; } } 
public function addPostParameter ( array $ postParameters , $ key , $ value ) { Validate :: isArray ( $ postParameters , 'postParameters' ) ; $ postParameters [ $ key ] = $ value ; return $ postParameters ; } 
public static function groupQueryValues ( array $ values ) { Validate :: isArray ( $ values , 'values' ) ; $ joined = Resources :: EMPTY_STRING ; sort ( $ values ) ; foreach ( $ values as $ value ) { if ( ! is_null ( $ value ) && ! empty ( $ value ) ) { $ joined .= $ value . Resources :: SEPARATOR ; } } return trim ( $ joined , Resources :: SEPARATOR ) ; } 
protected function addMetadataHeaders ( array $ headers , array $ metadata = null ) { Utilities :: validateMetadata ( $ metadata ) ; $ metadata = $ this -> generateMetadataHeaders ( $ metadata ) ; $ headers = array_merge ( $ headers , $ metadata ) ; return $ headers ; } 
private static function addLocationHeaderToResponse ( ResponseInterface $ response , $ locationMode ) { 
private function _validateProperties ( $ properties ) { Validate :: isArray ( $ properties , 'entity properties' ) ; foreach ( $ properties as $ key => $ value ) { Validate :: canCastAsString ( $ key , 'key' ) ; Validate :: isTrue ( $ value instanceof Property , Resources :: INVALID_PROP_MSG ) ; Validate :: isTrue ( EdmType :: validateEdmValue ( $ value -> getEdmType ( ) , $ value -> getValue ( ) , $ condition ) , sprintf ( Resources :: INVALID_PROP_VAL_MSG , $ key , $ condition ) ) ; } } 
public function getPropertyValue ( $ name ) { $ p = Utilities :: tryGetValue ( $ this -> _properties , $ name ) ; return is_null ( $ p ) ? null : $ p -> getValue ( ) ; } 
public function setPropertyValue ( $ name , $ value ) { $ p = Utilities :: tryGetValue ( $ this -> _properties , $ name ) ; if ( ! is_null ( $ p ) ) { $ p -> setValue ( $ value ) ; } } 
public function setProperty ( $ name , $ property ) { Validate :: isTrue ( $ property instanceof Property , Resources :: INVALID_PROP_MSG ) ; $ this -> _properties [ $ name ] = $ property ; } 
public function addProperty ( $ name , $ edmType , $ value , $ rawValue = '' ) { $ p = new Property ( ) ; $ p -> setEdmType ( $ edmType ) ; $ p -> setValue ( $ value ) ; $ p -> setRawValue ( $ rawValue ) ; $ this -> setProperty ( $ name , $ p ) ; } 
public function isValid ( & $ msg = null ) { try { $ this -> _validateProperties ( $ this -> _properties ) ; } catch ( \ Exception $ exc ) { $ msg = $ exc -> getMessage ( ) ; return false ; } if ( is_null ( $ this -> getPartitionKey ( ) ) || is_null ( $ this -> getRowKey ( ) ) ) { $ msg = Resources :: NULL_TABLE_KEY_MSG ; return false ; } else { return true ; } } 
public static function create ( $ body , $ odataSerializer ) { $ result = new GetTableResult ( ) ; $ name = $ odataSerializer -> parseTable ( $ body ) ; $ result -> setName ( $ name ) ; return $ result ; } 
protected function computeSignature ( array $ headers , $ url , array $ queryParams , $ httpMethod ) { $ canonicalizedHeaders = $ this -> computeCanonicalizedHeaders ( $ headers ) ; $ canonicalizedResource = $ this -> computeCanonicalizedResource ( $ url , $ queryParams ) ; $ stringToSign = array ( ) ; $ stringToSign [ ] = strtoupper ( $ httpMethod ) ; foreach ( $ this -> includedHeaders as $ header ) { $ stringToSign [ ] = Utilities :: tryGetValue ( $ headers , $ header ) ; } if ( count ( $ canonicalizedHeaders ) > 0 ) { $ stringToSign [ ] = implode ( "\n" , $ canonicalizedHeaders ) ; } $ stringToSign [ ] = $ canonicalizedResource ; $ stringToSign = implode ( "\n" , $ stringToSign ) ; return $ stringToSign ; } 
public function getAuthorizationHeader ( array $ headers , $ url , array $ queryParams , $ httpMethod ) { $ signature = $ this -> computeSignature ( $ headers , $ url , $ queryParams , $ httpMethod ) ; return 'SharedKey ' . $ this -> accountName . ':' . base64_encode ( hash_hmac ( 'sha256' , $ signature , base64_decode ( $ this -> accountKey ) , true ) ) ; } 
protected function computeCanonicalizedHeaders ( $ headers ) { $ canonicalizedHeaders = array ( ) ; $ normalizedHeaders = array ( ) ; $ validPrefix = Resources :: X_MS_HEADER_PREFIX ; if ( is_null ( $ normalizedHeaders ) ) { return $ canonicalizedHeaders ; } foreach ( $ headers as $ header => $ value ) { 
protected function computeCanonicalizedResourceForTable ( $ url , $ queryParams ) { $ queryParams = array_change_key_case ( $ queryParams ) ; 
protected function computeCanonicalizedResource ( $ url , $ queryParams ) { $ queryParams = array_change_key_case ( $ queryParams ) ; 
public function signRequest ( Request $ request ) { $ requestHeaders = HttpFormatter :: formatHeaders ( $ request -> getHeaders ( ) ) ; $ signedKey = $ this -> getAuthorizationHeader ( $ requestHeaders , $ request -> getUri ( ) , \ GuzzleHttp \ Psr7 \ parse_query ( $ request -> getUri ( ) -> getQuery ( ) ) , $ request -> getMethod ( ) ) ; return $ request -> withHeader ( Resources :: AUTHENTICATION , $ signedKey ) ; } 
public function toXml ( XmlSerializer $ serializer ) { $ properties = array ( XmlSerializer :: DEFAULT_TAG => Resources :: XTAG_SIGNED_IDENTIFIER , XmlSerializer :: ROOT_NAME => Resources :: XTAG_SIGNED_IDENTIFIERS ) ; return $ serializer -> serialize ( $ this -> toArray ( ) , $ properties ) ; } 
public function fromXmlArray ( array $ parsed = null ) { $ this -> setSignedIdentifiers ( array ( ) ) ; 
public function addSignedIdentifier ( $ id , \ DateTime $ start , \ DateTime $ expiry , $ permissions ) { Validate :: canCastAsString ( $ id , 'id' ) ; if ( $ start != null ) { Validate :: isDate ( $ start ) ; } Validate :: isDate ( $ expiry ) ; Validate :: canCastAsString ( $ permissions , 'permissions' ) ; $ accessPolicy = static :: createAccessPolicy ( ) ; $ accessPolicy -> setStart ( $ start ) ; $ accessPolicy -> setExpiry ( $ expiry ) ; $ accessPolicy -> setPermission ( $ permissions ) ; $ signedIdentifier = new SignedIdentifier ( ) ; $ signedIdentifier -> setId ( $ id ) ; $ signedIdentifier -> setAccessPolicy ( $ accessPolicy ) ; 
public function removeSignedIdentifier ( $ id ) { Validate :: canCastAsString ( $ id , 'id' ) ; 
public function setOperations ( array $ operations ) { $ this -> _operations = array ( ) ; foreach ( $ operations as $ operation ) { $ this -> addOperation ( $ operation ) ; } } 
public function addOperation ( $ operation ) { Validate :: isTrue ( $ operation instanceof BatchOperation , Resources :: INVALID_BO_TYPE_MSG ) ; $ this -> _operations [ ] = $ operation ; } 
public function addInsertEntity ( $ table , Entity $ entity ) { Validate :: canCastAsString ( $ table , 'table' ) ; Validate :: notNullOrEmpty ( $ entity , 'entity' ) ; $ operation = new BatchOperation ( ) ; $ type = BatchOperationType :: INSERT_ENTITY_OPERATION ; $ operation -> setType ( $ type ) ; $ operation -> addParameter ( BatchOperationParameterName :: BP_TABLE , $ table ) ; $ operation -> addParameter ( BatchOperationParameterName :: BP_ENTITY , $ entity ) ; $ this -> addOperation ( $ operation ) ; } 
public function addDeleteEntity ( $ table , $ partitionKey , $ rowKey , $ etag = null ) { Validate :: canCastAsString ( $ table , 'table' ) ; Validate :: isTrue ( ! is_null ( $ partitionKey ) , Resources :: NULL_TABLE_KEY_MSG ) ; Validate :: isTrue ( ! is_null ( $ rowKey ) , Resources :: NULL_TABLE_KEY_MSG ) ; $ operation = new BatchOperation ( ) ; $ type = BatchOperationType :: DELETE_ENTITY_OPERATION ; $ operation -> setType ( $ type ) ; $ operation -> addParameter ( BatchOperationParameterName :: BP_TABLE , $ table ) ; $ operation -> addParameter ( BatchOperationParameterName :: BP_ROW_KEY , $ rowKey ) ; $ operation -> addParameter ( BatchOperationParameterName :: BP_ETAG , $ etag ) ; $ operation -> addParameter ( BatchOperationParameterName :: BP_PARTITION_KEY , $ partitionKey ) ; $ this -> addOperation ( $ operation ) ; } 
public static function create ( array $ headers ) { $ result = new CopyFileResult ( ) ; $ headers = array_change_key_case ( $ headers ) ; $ date = $ headers [ Resources :: LAST_MODIFIED ] ; $ date = Utilities :: rfc1123ToDateTime ( $ date ) ; $ result -> setCopyStatus ( $ headers [ Resources :: X_MS_COPY_STATUS ] ) ; $ result -> setCopyID ( $ headers [ Resources :: X_MS_COPY_ID ] ) ; $ result -> setETag ( $ headers [ Resources :: ETAG ] ) ; $ result -> setLastModified ( $ date ) ; return $ result ; } 
public static function createFromListMessages ( array $ parsedResponse ) { $ timeNextVisible = $ parsedResponse [ 'TimeNextVisible' ] ; $ msg = self :: createFromPeekMessages ( $ parsedResponse ) ; $ date = Utilities :: rfc1123ToDateTime ( $ timeNextVisible ) ; $ msg -> setTimeNextVisible ( $ date ) ; $ msg -> setPopReceipt ( $ parsedResponse [ 'PopReceipt' ] ) ; return $ msg ; } 
public static function createFromPeekMessages ( array $ parsedResponse ) { $ msg = new QueueMessage ( ) ; $ expirationDate = $ parsedResponse [ 'ExpirationTime' ] ; $ insertionDate = $ parsedResponse [ 'InsertionTime' ] ; $ msg -> setDequeueCount ( intval ( $ parsedResponse [ 'DequeueCount' ] ) ) ; $ date = Utilities :: rfc1123ToDateTime ( $ expirationDate ) ; $ msg -> setExpirationDate ( $ date ) ; $ date = Utilities :: rfc1123ToDateTime ( $ insertionDate ) ; $ msg -> setInsertionDate ( $ date ) ; $ msg -> setMessageId ( $ parsedResponse [ 'MessageId' ] ) ; $ msg -> setMessageText ( $ parsedResponse [ 'MessageText' ] ) ; return $ msg ; } 
public static function createFromCreateMessage ( array $ parsedResponse ) { $ msg = new QueueMessage ( ) ; $ expirationDate = $ parsedResponse [ 'ExpirationTime' ] ; $ insertionDate = $ parsedResponse [ 'InsertionTime' ] ; $ timeNextVisible = $ parsedResponse [ 'TimeNextVisible' ] ; $ date = Utilities :: rfc1123ToDateTime ( $ expirationDate ) ; $ msg -> setExpirationDate ( $ date ) ; $ date = Utilities :: rfc1123ToDateTime ( $ insertionDate ) ; $ msg -> setInsertionDate ( $ date ) ; $ date = Utilities :: rfc1123ToDateTime ( $ timeNextVisible ) ; $ msg -> setTimeNextVisible ( $ date ) ; $ msg -> setMessageId ( $ parsedResponse [ 'MessageId' ] ) ; $ msg -> setPopReceipt ( $ parsedResponse [ 'PopReceipt' ] ) ; return $ msg ; } 
protected static function init ( ) { self :: $ useDevelopmentStorageSetting = self :: setting ( Resources :: USE_DEVELOPMENT_STORAGE_NAME , 'true' ) ; self :: $ developmentStorageProxyUriSetting = self :: settingWithFunc ( Resources :: DEVELOPMENT_STORAGE_PROXY_URI_NAME , Validate :: getIsValidUri ( ) ) ; self :: $ defaultEndpointsProtocolSetting = self :: setting ( Resources :: DEFAULT_ENDPOINTS_PROTOCOL_NAME , 'http' , 'https' ) ; self :: $ accountNameSetting = self :: setting ( Resources :: ACCOUNT_NAME_NAME ) ; self :: $ accountKeySetting = self :: settingWithFunc ( Resources :: ACCOUNT_KEY_NAME , 
private static function getDevelopmentStorageAccount ( $ proxyUri ) { if ( is_null ( $ proxyUri ) ) { return self :: developmentStorageAccount ( ) ; } $ scheme = parse_url ( $ proxyUri , PHP_URL_SCHEME ) ; $ host = parse_url ( $ proxyUri , PHP_URL_HOST ) ; $ prefix = $ scheme . "://" . $ host ; return new StorageServiceSettings ( Resources :: DEV_STORE_NAME , Resources :: DEV_STORE_KEY , $ prefix . ':10000/devstoreaccount1/' , $ prefix . ':10001/devstoreaccount1/' , $ prefix . ':10002/devstoreaccount1/' , null ) ; } 
public static function developmentStorageAccount ( ) { if ( is_null ( self :: $ devStoreAccount ) ) { self :: $ devStoreAccount = self :: getDevelopmentStorageAccount ( Resources :: DEV_STORE_URI ) ; } return self :: $ devStoreAccount ; } 
private static function getServiceEndpoint ( $ scheme , $ accountName , $ dnsPrefix , $ dnsSuffix = null , $ isSecondary = false ) { if ( $ isSecondary ) { $ accountName .= Resources :: SECONDARY_STRING ; } if ( $ dnsSuffix === null ) { $ dnsSuffix = Resources :: DEFAULT_ENDPOINT_SUFFIX ; } return sprintf ( Resources :: SERVICE_URI_FORMAT , $ scheme , $ accountName , $ dnsPrefix . $ dnsSuffix ) ; } 
private static function createStorageServiceSettings ( array $ settings , $ blobEndpointUri = null , $ queueEndpointUri = null , $ tableEndpointUri = null , $ fileEndpointUri = null , $ blobSecondaryEndpointUri = null , $ queueSecondaryEndpointUri = null , $ tableSecondaryEndpointUri = null , $ fileSecondaryEndpointUri = null ) { $ blobEndpointUri = Utilities :: tryGetValueInsensitive ( Resources :: BLOB_ENDPOINT_NAME , $ settings , $ blobEndpointUri ) ; $ queueEndpointUri = Utilities :: tryGetValueInsensitive ( Resources :: QUEUE_ENDPOINT_NAME , $ settings , $ queueEndpointUri ) ; $ tableEndpointUri = Utilities :: tryGetValueInsensitive ( Resources :: TABLE_ENDPOINT_NAME , $ settings , $ tableEndpointUri ) ; $ fileEndpointUri = Utilities :: tryGetValueInsensitive ( Resources :: FILE_ENDPOINT_NAME , $ settings , $ fileEndpointUri ) ; $ accountName = Utilities :: tryGetValueInsensitive ( Resources :: ACCOUNT_NAME_NAME , $ settings ) ; $ accountKey = Utilities :: tryGetValueInsensitive ( Resources :: ACCOUNT_KEY_NAME , $ settings ) ; $ sasToken = Utilities :: tryGetValueInsensitive ( Resources :: SAS_TOKEN_NAME , $ settings ) ; return new StorageServiceSettings ( $ accountName , $ accountKey , $ blobEndpointUri , $ queueEndpointUri , $ tableEndpointUri , $ fileEndpointUri , $ blobSecondaryEndpointUri , $ queueSecondaryEndpointUri , $ tableSecondaryEndpointUri , $ fileSecondaryEndpointUri , $ sasToken ) ; } 
public static function createFromConnectionString ( $ connectionString ) { $ tokenizedSettings = self :: parseAndValidateKeys ( $ connectionString ) ; 
public static function createFromConnectionStringForTokenCredential ( $ connectionString ) { 
public function encodeMimeMultipart ( array $ bodyPartContents ) { $ count = count ( $ bodyPartContents ) ; $ mimeType = Resources :: MULTIPART_MIXED_TYPE ; $ batchGuid = Utilities :: getGuid ( ) ; $ batchId = sprintf ( 'batch_%s' , $ batchGuid ) ; $ contentType1 = array ( 'content_type' => "$mimeType" ) ; $ changeSetGuid = Utilities :: getGuid ( ) ; $ changeSetId = sprintf ( 'changeset_%s' , $ changeSetGuid ) ; $ contentType2 = array ( 'content_type' => "$mimeType; boundary=$changeSetId" ) ; $ options = array ( 'encoding' => 'binary' , 'content_type' => Resources :: HTTP_TYPE ) ; $ eof = "\r\n" ; $ result = array ( ) ; $ result [ 'body' ] = Resources :: EMPTY_STRING ; $ result [ 'headers' ] = array ( ) ; $ batchBody = & $ result [ 'body' ] ; $ batchHeaders = & $ result [ 'headers' ] ; $ batchHeaders [ 'Content-Type' ] = $ mimeType . "; $eof boundary=\"$batchId\"" ; $ batchBody .= "--" . $ batchId . $ eof ; $ batchBody .= "Content-Type: $mimeType; boundary=\"$changeSetId\"" . $ eof ; $ batchBody .= $ eof ; for ( $ i = 0 ; $ i < count ( $ bodyPartContents ) ; $ i ++ ) { $ batchBody .= "--" . $ changeSetId . $ eof ; $ batchBody .= "Content-Transfer-Encoding: binary" . $ eof ; $ batchBody .= "Content-Type: " . Resources :: HTTP_TYPE . $ eof ; $ batchBody .= $ eof . $ bodyPartContents [ $ i ] . $ eof ; } $ batchBody .= "--" . $ changeSetId . "--" . $ eof ; $ batchBody .= $ eof ; $ batchBody .= "--" . $ batchId . "--" . $ eof ; return $ result ; } 
public function decodeMimeMultipart ( $ mimeBody ) { 
public static function create ( array $ parsedResponse , $ location = '' ) { $ result = new ListSharesResult ( ) ; $ serviceEndpoint = Utilities :: tryGetKeysChainValue ( $ parsedResponse , Resources :: XTAG_ATTRIBUTES , Resources :: XTAG_SERVICE_ENDPOINT ) ; $ result -> setAccountName ( Utilities :: tryParseAccountNameFromUrl ( $ serviceEndpoint ) ) ; $ result -> setPrefix ( Utilities :: tryGetValue ( $ parsedResponse , Resources :: QP_PREFIX ) ) ; $ result -> setMarker ( Utilities :: tryGetValue ( $ parsedResponse , Resources :: QP_MARKER ) ) ; $ nextMarker = Utilities :: tryGetValue ( $ parsedResponse , Resources :: QP_NEXT_MARKER ) ; if ( $ nextMarker != null ) { $ result -> setContinuationToken ( new MarkerContinuationToken ( $ nextMarker , $ location ) ) ; } $ result -> setMaxResults ( Utilities :: tryGetValue ( $ parsedResponse , Resources :: QP_MAX_RESULTS ) ) ; $ shares = array ( ) ; $ shareArrays = array ( ) ; if ( ! empty ( $ parsedResponse [ Resources :: QP_SHARES ] ) ) { $ array = $ parsedResponse [ Resources :: QP_SHARES ] [ Resources :: QP_SHARE ] ; $ shareArrays = Utilities :: getArray ( $ array ) ; } foreach ( $ shareArrays as $ shareArray ) { $ shares [ ] = Share :: create ( $ shareArray ) ; } $ result -> setShares ( $ shares ) ; return $ result ; } 
protected function setShares ( array $ shares ) { $ this -> shares = array ( ) ; foreach ( $ shares as $ share ) { $ this -> shares [ ] = clone $ share ; } } 
protected function onFulfilled ( RequestInterface $ request , array $ options ) { return function ( ResponseInterface $ response ) use ( $ request , $ options ) { $ isSecondary = Utilities :: requestSentToSecondary ( $ request , $ options ) ; if ( ! isset ( $ options [ 'retries' ] ) ) { $ options [ 'retries' ] = 0 ; } if ( call_user_func ( $ this -> decider , $ options [ 'retries' ] , $ request , $ response , null , $ isSecondary ) ) { return $ this -> retry ( $ request , $ options , $ response ) ; } 
protected function onRejected ( RequestInterface $ request , array $ options ) { return function ( $ reason ) use ( $ request , $ options ) { $ isSecondary = Utilities :: requestSentToSecondary ( $ request , $ options ) ; if ( ! isset ( $ options [ 'retries' ] ) ) { $ options [ 'retries' ] = 0 ; } if ( call_user_func ( $ this -> decider , $ options [ 'retries' ] , $ request , null , $ reason , $ isSecondary ) ) { return $ this -> retry ( $ request , $ options ) ; } return new RejectedPromise ( $ reason ) ; } ; } 
private function retry ( RequestInterface $ request , array $ options , ResponseInterface $ response = null ) { $ options [ 'delay' ] = call_user_func ( $ this -> intervalCalculator , ++ $ options [ 'retries' ] ) ; 
public static function applyAnd ( Filter $ left , Filter $ right ) { $ filter = new BinaryFilter ( $ left , 'and' , $ right ) ; return $ filter ; } 
public static function applyOr ( Filter $ left , Filter $ right ) { $ filter = new BinaryFilter ( $ left , 'or' , $ right ) ; return $ filter ; } 
public static function applyEq ( Filter $ left , Filter $ right ) { $ filter = new BinaryFilter ( $ left , 'eq' , $ right ) ; return $ filter ; } 
public static function applyNe ( Filter $ left , Filter $ right ) { $ filter = new BinaryFilter ( $ left , 'ne' , $ right ) ; return $ filter ; } 
public static function applyGe ( Filter $ left , Filter $ right ) { $ filter = new BinaryFilter ( $ left , 'ge' , $ right ) ; return $ filter ; } 
public static function applyGt ( Filter $ left , Filter $ right ) { $ filter = new BinaryFilter ( $ left , 'gt' , $ right ) ; return $ filter ; } 
public static function applyLt ( Filter $ left , Filter $ right ) { $ filter = new BinaryFilter ( $ left , 'lt' , $ right ) ; return $ filter ; } 
public static function applyLe ( Filter $ left , Filter $ right ) { $ filter = new BinaryFilter ( $ left , 'le' , $ right ) ; return $ filter ; } 
public function signRequest ( Request $ request ) { $ bearerToken = "Bearer " . $ this -> tokenRef ; return $ request -> withHeader ( Resources :: AUTHENTICATION , $ bearerToken ) ; } 
public static function create ( array $ parsed ) { $ result = new GetShareStatsResult ( ) ; $ result -> setShareUsage ( \ intval ( Utilities :: tryGetValueInsensitive ( Resources :: XTAG_SHARE_USAGE , $ parsed ) ) ) ; return $ result ; } 
public function setLocation ( $ location ) { Validate :: canCastAsString ( $ location , 'location' ) ; Validate :: isTrue ( $ location == LocationMode :: PRIMARY_ONLY || $ location == LocationMode :: SECONDARY_ONLY || $ location == '' , sprintf ( Resources :: INVALID_VALUE_MSG , 'location' , LocationMode :: PRIMARY_ONLY . ' or ' . LocationMode :: SECONDARY_ONLY ) ) ; $ this -> location = $ location ; } 
public static function objectSerialize ( $ targetObject , $ rootName ) { Validate :: notNull ( $ targetObject , 'targetObject' ) ; Validate :: canCastAsString ( $ rootName , 'rootName' ) ; $ contianer = new \ stdClass ( ) ; $ contianer -> $ rootName = $ targetObject ; return json_encode ( $ contianer ) ; } 
public function unserialize ( $ serialized ) { Validate :: canCastAsString ( $ serialized , 'serialized' ) ; $ json = json_decode ( $ serialized ) ; if ( $ json && ! is_array ( $ json ) ) { return get_object_vars ( $ json ) ; } else { return $ json ; } } 
public static function create ( $ parsedResponse ) { $ result = new PeekMessagesResult ( ) ; $ queueMessages = array ( ) ; if ( ! empty ( $ parsedResponse ) ) { $ rawMessages = Utilities :: getArray ( $ parsedResponse [ Resources :: QP_QUEUE_MESSAGE ] ) ; foreach ( $ rawMessages as $ value ) { $ message = QueueMessage :: createFromPeekMessages ( $ value ) ; $ queueMessages [ ] = $ message ; } } $ result -> setQueueMessages ( $ queueMessages ) ; return $ result ; } 
public static function create ( $ body , IODataReaderWriter $ serializer ) { $ result = new GetEntityResult ( ) ; $ result -> setEntity ( $ serializer -> parseEntity ( $ body ) ) ; return $ result ; } 
public static function createTableService ( $ connectionString , array $ options = [ ] ) { $ settings = StorageServiceSettings :: createFromConnectionString ( $ connectionString ) ; $ odataSerializer = new JsonODataReaderWriter ( ) ; $ mimeSerializer = new MimeReaderWriter ( ) ; $ primaryUri = Utilities :: tryAddUrlScheme ( $ settings -> getTableEndpointUri ( ) ) ; $ secondaryUri = Utilities :: tryAddUrlScheme ( $ settings -> getTableSecondaryEndpointUri ( ) ) ; $ tableWrapper = new TableRestProxy ( $ primaryUri , $ secondaryUri , $ odataSerializer , $ mimeSerializer , $ options ) ; 
private function createOperationsContexts ( array $ operations ) { $ contexts = array ( ) ; foreach ( $ operations as $ operation ) { $ context = null ; $ type = $ operation -> getType ( ) ; switch ( $ type ) { case BatchOperationType :: INSERT_ENTITY_OPERATION : case BatchOperationType :: UPDATE_ENTITY_OPERATION : case BatchOperationType :: MERGE_ENTITY_OPERATION : case BatchOperationType :: INSERT_REPLACE_ENTITY_OPERATION : case BatchOperationType :: INSERT_MERGE_ENTITY_OPERATION : $ table = $ operation -> getParameter ( BatchOperationParameterName :: BP_TABLE ) ; $ entity = $ operation -> getParameter ( BatchOperationParameterName :: BP_ENTITY ) ; $ context = $ this -> getOperationContext ( $ table , $ entity , $ type ) ; break ; case BatchOperationType :: DELETE_ENTITY_OPERATION : $ table = $ operation -> getParameter ( BatchOperationParameterName :: BP_TABLE ) ; $ partitionKey = $ operation -> getParameter ( BatchOperationParameterName :: BP_PARTITION_KEY ) ; $ rowKey = $ operation -> getParameter ( BatchOperationParameterName :: BP_ROW_KEY ) ; $ etag = $ operation -> getParameter ( BatchOperationParameterName :: BP_ETAG ) ; $ options = new DeleteEntityOptions ( ) ; $ options -> setETag ( $ etag ) ; $ context = $ this -> constructDeleteEntityContext ( $ table , $ partitionKey , $ rowKey , $ options ) ; break ; default : throw new \ InvalidArgumentException ( ) ; } $ contexts [ ] = $ context ; } return $ contexts ; } 
private function getOperationContext ( $ table , Entity $ entity , $ type ) { switch ( $ type ) { case BatchOperationType :: INSERT_ENTITY_OPERATION : return $ this -> constructInsertEntityContext ( $ table , $ entity , null ) ; case BatchOperationType :: UPDATE_ENTITY_OPERATION : return $ this -> constructPutOrMergeEntityContext ( $ table , $ entity , Resources :: HTTP_PUT , true , null ) ; case BatchOperationType :: MERGE_ENTITY_OPERATION : return $ this -> constructPutOrMergeEntityContext ( $ table , $ entity , Resources :: HTTP_MERGE , true , null ) ; case BatchOperationType :: INSERT_REPLACE_ENTITY_OPERATION : return $ this -> constructPutOrMergeEntityContext ( $ table , $ entity , Resources :: HTTP_PUT , false , null ) ; case BatchOperationType :: INSERT_MERGE_ENTITY_OPERATION : return $ this -> constructPutOrMergeEntityContext ( $ table , $ entity , Resources :: HTTP_MERGE , false , null ) ; default : throw new \ InvalidArgumentException ( ) ; } } 
private function createBatchRequestBody ( array $ operations , array $ contexts ) { $ mimeBodyParts = array ( ) ; $ contentId = 1 ; $ count = count ( $ operations ) ; Validate :: isTrue ( count ( $ operations ) == count ( $ contexts ) , Resources :: INVALID_OC_COUNT_MSG ) ; for ( $ i = 0 ; $ i < $ count ; $ i ++ ) { $ operation = $ operations [ $ i ] ; $ context = $ contexts [ $ i ] ; $ type = $ operation -> getType ( ) ; switch ( $ type ) { case BatchOperationType :: INSERT_ENTITY_OPERATION : case BatchOperationType :: UPDATE_ENTITY_OPERATION : case BatchOperationType :: MERGE_ENTITY_OPERATION : case BatchOperationType :: INSERT_REPLACE_ENTITY_OPERATION : case BatchOperationType :: INSERT_MERGE_ENTITY_OPERATION : $ contentType = $ context -> getHeader ( Resources :: CONTENT_TYPE ) ; $ body = $ context -> getBody ( ) ; $ contentType .= ';type=entry' ; $ context -> addOptionalHeader ( Resources :: CONTENT_TYPE , $ contentType ) ; 
private function constructDeleteEntityContext ( $ table , $ partitionKey , $ rowKey , DeleteEntityOptions $ options = null ) { Validate :: canCastAsString ( $ table , 'table' ) ; Validate :: notNullOrEmpty ( $ table , 'table' ) ; Validate :: isTrue ( ! is_null ( $ partitionKey ) , Resources :: NULL_TABLE_KEY_MSG ) ; Validate :: isTrue ( ! is_null ( $ rowKey ) , Resources :: NULL_TABLE_KEY_MSG ) ; $ method = Resources :: HTTP_DELETE ; $ headers = array ( ) ; $ queryParams = array ( ) ; $ statusCode = Resources :: STATUS_NO_CONTENT ; $ path = $ this -> getEntityPath ( $ table , $ partitionKey , $ rowKey ) ; if ( is_null ( $ options ) ) { $ options = new DeleteEntityOptions ( ) ; } $ etagObj = $ options -> getETag ( ) ; $ ETag = ! is_null ( $ etagObj ) ; $ this -> addOptionalHeader ( $ headers , Resources :: IF_MATCH , $ ETag ? $ etagObj : Resources :: ASTERISK ) ; $ this -> addOptionalHeader ( $ headers , Resources :: ACCEPT_HEADER , Resources :: JSON_CONTENT_TYPE ) ; $ options -> setLocationMode ( LocationMode :: PRIMARY_ONLY ) ; $ context = new HttpCallContext ( ) ; $ context -> setHeaders ( $ headers ) ; $ context -> setMethod ( $ method ) ; $ context -> setPath ( $ path ) ; $ context -> setQueryParameters ( $ queryParams ) ; $ context -> addStatusCode ( $ statusCode ) ; $ context -> setBody ( '' ) ; $ context -> setServiceOptions ( $ options ) ; return $ context ; } 
private function constructPutOrMergeEntityContext ( $ table , Entity $ entity , $ verb , $ useETag , TableServiceOptions $ options = null ) { Validate :: canCastAsString ( $ table , 'table' ) ; Validate :: notNullOrEmpty ( $ table , 'table' ) ; Validate :: notNullOrEmpty ( $ entity , 'entity' ) ; Validate :: isTrue ( $ entity -> isValid ( $ msg ) , $ msg ) ; $ method = $ verb ; $ headers = array ( ) ; $ queryParams = array ( ) ; $ statusCode = Resources :: STATUS_NO_CONTENT ; $ partitionKey = $ entity -> getPartitionKey ( ) ; $ rowKey = $ entity -> getRowKey ( ) ; $ path = $ this -> getEntityPath ( $ table , $ partitionKey , $ rowKey ) ; $ body = $ this -> odataSerializer -> getEntity ( $ entity ) ; if ( is_null ( $ options ) ) { $ options = new TableServiceOptions ( ) ; } if ( $ useETag ) { $ etag = $ entity -> getETag ( ) ; $ ifMatchValue = is_null ( $ etag ) ? Resources :: ASTERISK : $ etag ; $ this -> addOptionalHeader ( $ headers , Resources :: IF_MATCH , $ ifMatchValue ) ; } $ this -> addOptionalHeader ( $ headers , Resources :: CONTENT_TYPE , Resources :: JSON_CONTENT_TYPE ) ; $ this -> addOptionalHeader ( $ headers , Resources :: ACCEPT_HEADER , Resources :: JSON_FULL_METADATA_CONTENT_TYPE ) ; $ options -> setLocationMode ( LocationMode :: PRIMARY_ONLY ) ; $ context = new HttpCallContext ( ) ; $ context -> setBody ( $ body ) ; $ context -> setHeaders ( $ headers ) ; $ context -> setMethod ( $ method ) ; $ context -> setPath ( $ path ) ; $ context -> setQueryParameters ( $ queryParams ) ; $ context -> addStatusCode ( $ statusCode ) ; $ context -> setServiceOptions ( $ options ) ; return $ context ; } 
private function constructInsertEntityContext ( $ table , Entity $ entity , TableServiceCreateOptions $ options = null ) { Validate :: canCastAsString ( $ table , 'table' ) ; Validate :: notNullOrEmpty ( $ table , 'table' ) ; Validate :: notNullOrEmpty ( $ entity , 'entity' ) ; Validate :: isTrue ( $ entity -> isValid ( $ msg ) , $ msg ) ; $ method = Resources :: HTTP_POST ; $ context = new HttpCallContext ( ) ; $ headers = array ( ) ; $ queryParams = array ( ) ; $ statusCode = Resources :: STATUS_CREATED ; $ path = $ table ; $ body = $ this -> odataSerializer -> getEntity ( $ entity ) ; if ( is_null ( $ options ) ) { $ options = new TableServiceCreateOptions ( ) ; } $ this -> addOptionalHeader ( $ headers , Resources :: CONTENT_TYPE , Resources :: JSON_CONTENT_TYPE ) ; $ this -> addOptionalHeader ( $ headers , Resources :: ACCEPT_HEADER , $ options -> getAccept ( ) ) ; $ this -> addOptionalHeader ( $ headers , Resources :: PREFER , $ options -> getDoesReturnContent ( ) ? Resources :: RETURN_CONTENT : null ) ; $ options -> setLocationMode ( LocationMode :: PRIMARY_ONLY ) ; $ context -> setBody ( $ body ) ; $ context -> setHeaders ( $ headers ) ; $ context -> setMethod ( $ method ) ; $ context -> setPath ( $ path ) ; $ context -> setQueryParameters ( $ queryParams ) ; $ context -> addStatusCode ( $ statusCode ) ; $ context -> setServiceOptions ( $ options ) ; return $ context ; } 
private function getEntityPath ( $ table , $ partitionKey , $ rowKey ) { $ encodedPK = $ this -> encodeODataUriValue ( $ partitionKey ) ; $ encodedRK = $ this -> encodeODataUriValue ( $ rowKey ) ; return "$table(PartitionKey='$encodedPK',RowKey='$encodedRK')" ; } 
private function putOrMergeEntityAsyncImpl ( $ table , Entity $ entity , $ verb , $ useETag , TableServiceOptions $ options = null ) { $ context = $ this -> constructPutOrMergeEntityContext ( $ table , $ entity , $ verb , $ useETag , $ options ) ; return $ this -> sendContextAsync ( $ context ) -> then ( function ( $ response ) { return UpdateEntityResult :: create ( HttpFormatter :: formatHeaders ( $ response -> getHeaders ( ) ) ) ; } , null ) ; } 
private function buildFilterExpression ( Filter $ filter ) { $ e = Resources :: EMPTY_STRING ; $ this -> buildFilterExpressionRec ( $ filter , $ e ) ; return $ e ; } 
private function buildFilterExpressionRec ( Filter $ filter , & $ e ) { if ( is_null ( $ filter ) ) { return ; } if ( $ filter instanceof PropertyNameFilter ) { $ e .= $ filter -> getPropertyName ( ) ; } elseif ( $ filter instanceof ConstantFilter ) { $ value = $ filter -> getValue ( ) ; 
private function addOptionalQuery ( array $ queryParam , Query $ query ) { if ( ! is_null ( $ query ) ) { $ selectedFields = $ query -> getSelectFields ( ) ; if ( ! empty ( $ selectedFields ) ) { $ final = $ this -> encodeODataUriValues ( $ selectedFields ) ; $ this -> addOptionalQueryParam ( $ queryParam , Resources :: QP_SELECT , implode ( ',' , $ final ) ) ; } if ( ! is_null ( $ query -> getTop ( ) ) ) { $ final = strval ( $ this -> encodeODataUriValue ( $ query -> getTop ( ) ) ) ; $ this -> addOptionalQueryParam ( $ queryParam , Resources :: QP_TOP , $ final ) ; } if ( ! is_null ( $ query -> getFilter ( ) ) ) { $ final = $ this -> buildFilterExpression ( $ query -> getFilter ( ) ) ; $ this -> addOptionalQueryParam ( $ queryParam , Resources :: QP_FILTER , $ final ) ; } } return $ queryParam ; } 
private function encodeODataUriValues ( array $ values ) { $ list = array ( ) ; foreach ( $ values as $ value ) { $ list [ ] = $ this -> encodeODataUriValue ( $ value ) ; } return $ list ; } 
public function queryTablesAsync ( $ options = null ) { $ method = Resources :: HTTP_GET ; $ headers = array ( ) ; $ postParams = array ( ) ; $ queryParams = array ( ) ; $ path = 'Tables' ; if ( is_null ( $ options ) ) { $ options = new QueryTablesOptions ( ) ; } elseif ( is_string ( $ options ) ) { $ prefix = $ options ; $ options = new QueryTablesOptions ( ) ; $ options -> setPrefix ( $ prefix ) ; } elseif ( $ options instanceof Filter ) { $ filter = $ options ; $ options = new QueryTablesOptions ( ) ; $ options -> setFilter ( $ filter ) ; } $ query = $ options -> getQuery ( ) ; $ next = $ options -> getNextTableName ( ) ; $ prefix = $ options -> getPrefix ( ) ; if ( ! empty ( $ prefix ) ) { 
public function createTable ( $ table , TableServiceCreateOptions $ options = null ) { return $ this -> createTableAsync ( $ table , $ options ) -> wait ( ) ; } 
public function createTableAsync ( $ table , TableServiceCreateOptions $ options = null ) { Validate :: canCastAsString ( $ table , 'table' ) ; Validate :: notNullOrEmpty ( $ table , 'table' ) ; $ method = Resources :: HTTP_POST ; $ headers = array ( ) ; $ postParams = array ( ) ; $ queryParams = array ( ) ; $ path = 'Tables' ; $ body = $ this -> odataSerializer -> getTable ( $ table ) ; if ( is_null ( $ options ) ) { $ options = new TableServiceCreateOptions ( ) ; } $ this -> addOptionalHeader ( $ headers , Resources :: CONTENT_TYPE , Resources :: JSON_CONTENT_TYPE ) ; $ this -> addOptionalHeader ( $ headers , Resources :: ACCEPT_HEADER , $ options -> getAccept ( ) ) ; $ this -> addOptionalHeader ( $ headers , Resources :: PREFER , $ options -> getDoesReturnContent ( ) ? Resources :: RETURN_CONTENT : null ) ; $ options -> setLocationMode ( LocationMode :: PRIMARY_ONLY ) ; return $ this -> sendAsync ( $ method , $ headers , $ queryParams , $ postParams , $ path , Resources :: STATUS_CREATED , $ body , $ options ) ; } 
public function getTable ( $ table , GetTableOptions $ options = null ) { return $ this -> getTableAsync ( $ table , $ options ) -> wait ( ) ; } 
public function getTableAsync ( $ table , GetTableOptions $ options = null ) { Validate :: canCastAsString ( $ table , 'table' ) ; Validate :: notNullOrEmpty ( $ table , 'table' ) ; $ method = Resources :: HTTP_GET ; $ headers = array ( ) ; $ postParams = array ( ) ; $ queryParams = array ( ) ; $ path = "Tables('$table')" ; if ( is_null ( $ options ) ) { $ options = new GetTableOptions ( ) ; } $ this -> addOptionalHeader ( $ headers , Resources :: CONTENT_TYPE , Resources :: JSON_CONTENT_TYPE ) ; $ this -> addOptionalHeader ( $ headers , Resources :: ACCEPT_HEADER , $ options -> getAccept ( ) ) ; $ odataSerializer = $ this -> odataSerializer ; return $ this -> sendAsync ( $ method , $ headers , $ queryParams , $ postParams , $ path , Resources :: STATUS_OK , Resources :: EMPTY_STRING , $ options ) -> then ( function ( $ response ) use ( $ odataSerializer ) { return GetTableResult :: create ( $ response -> getBody ( ) , $ odataSerializer ) ; } , null ) ; } 
public function deleteTable ( $ table , TableServiceOptions $ options = null ) { $ this -> deleteTableAsync ( $ table , $ options ) -> wait ( ) ; } 
public function deleteTableAsync ( $ table , TableServiceOptions $ options = null ) { Validate :: canCastAsString ( $ table , 'table' ) ; Validate :: notNullOrEmpty ( $ table , 'table' ) ; $ method = Resources :: HTTP_DELETE ; $ headers = array ( ) ; $ postParams = array ( ) ; $ queryParams = array ( ) ; $ path = "Tables('$table')" ; if ( is_null ( $ options ) ) { $ options = new TableServiceOptions ( ) ; } return $ this -> sendAsync ( $ method , $ headers , $ queryParams , $ postParams , $ path , Resources :: STATUS_NO_CONTENT , Resources :: EMPTY_STRING , $ options ) ; } 
public function queryEntitiesAsync ( $ table , $ options = null ) { Validate :: canCastAsString ( $ table , 'table' ) ; Validate :: notNullOrEmpty ( $ table , 'table' ) ; $ method = Resources :: HTTP_GET ; $ headers = array ( ) ; $ postParams = array ( ) ; $ queryParams = array ( ) ; $ path = $ table ; if ( is_null ( $ options ) ) { $ options = new QueryEntitiesOptions ( ) ; } elseif ( is_string ( $ options ) ) { $ queryString = $ options ; $ options = new QueryEntitiesOptions ( ) ; $ options -> setFilter ( Filter :: applyQueryString ( $ queryString ) ) ; } elseif ( $ options instanceof Filter ) { $ filter = $ options ; $ options = new QueryEntitiesOptions ( ) ; $ options -> setFilter ( $ filter ) ; } $ queryParams = $ this -> addOptionalQuery ( $ queryParams , $ options -> getQuery ( ) ) ; $ this -> addOptionalQueryParam ( $ queryParams , Resources :: QP_NEXT_PK , $ options -> getNextPartitionKey ( ) ) ; $ this -> addOptionalQueryParam ( $ queryParams , Resources :: QP_NEXT_RK , $ options -> getNextRowKey ( ) ) ; $ this -> addOptionalHeader ( $ headers , Resources :: CONTENT_TYPE , Resources :: JSON_CONTENT_TYPE ) ; $ this -> addOptionalHeader ( $ headers , Resources :: ACCEPT_HEADER , $ options -> getAccept ( ) ) ; if ( ! is_null ( $ options -> getQuery ( ) ) ) { $ dsHeader = Resources :: DATA_SERVICE_VERSION ; $ maxdsValue = Resources :: MAX_DATA_SERVICE_VERSION_VALUE ; $ fields = $ options -> getQuery ( ) -> getSelectFields ( ) ; $ hasSelect = ! empty ( $ fields ) ; if ( $ hasSelect ) { $ this -> addOptionalHeader ( $ headers , $ dsHeader , $ maxdsValue ) ; } } $ odataSerializer = $ this -> odataSerializer ; return $ this -> sendAsync ( $ method , $ headers , $ queryParams , $ postParams , $ path , Resources :: STATUS_OK , Resources :: EMPTY_STRING , $ options ) -> then ( function ( $ response ) use ( $ odataSerializer ) { $ entities = $ odataSerializer -> parseEntities ( $ response -> getBody ( ) ) ; return QueryEntitiesResult :: create ( HttpFormatter :: formatHeaders ( $ response -> getHeaders ( ) ) , $ entities ) ; } , null ) ; } 
public function insertEntity ( $ table , Entity $ entity , TableServiceCreateOptions $ options = null ) { return $ this -> insertEntityAsync ( $ table , $ entity , $ options ) -> wait ( ) ; } 
public function insertEntityAsync ( $ table , Entity $ entity , TableServiceCreateOptions $ options = null ) { $ context = $ this -> constructInsertEntityContext ( $ table , $ entity , $ options ) ; $ odataSerializer = $ this -> odataSerializer ; return $ this -> sendContextAsync ( $ context ) -> then ( function ( $ response ) use ( $ odataSerializer ) { $ body = $ response -> getBody ( ) ; $ headers = HttpFormatter :: formatHeaders ( $ response -> getHeaders ( ) ) ; return InsertEntityResult :: create ( $ body , $ headers , $ odataSerializer ) ; } , null ) ; } 
public function insertOrMergeEntity ( $ table , Entity $ entity , TableServiceOptions $ options = null ) { return $ this -> insertOrMergeEntityAsync ( $ table , $ entity , $ options ) -> wait ( ) ; } 
public function insertOrMergeEntityAsync ( $ table , Entity $ entity , TableServiceOptions $ options = null ) { return $ this -> putOrMergeEntityAsyncImpl ( $ table , $ entity , Resources :: HTTP_MERGE , false , $ options ) ; } 
public function insertOrReplaceEntity ( $ table , Entity $ entity , TableServiceOptions $ options = null ) { return $ this -> insertOrReplaceEntityAsync ( $ table , $ entity , $ options ) -> wait ( ) ; } 
public function insertOrReplaceEntityAsync ( $ table , Entity $ entity , TableServiceOptions $ options = null ) { return $ this -> putOrMergeEntityAsyncImpl ( $ table , $ entity , Resources :: HTTP_PUT , false , $ options ) ; } 
public function updateEntity ( $ table , Entity $ entity , TableServiceOptions $ options = null ) { return $ this -> updateEntityAsync ( $ table , $ entity , $ options ) -> wait ( ) ; } 
public function updateEntityAsync ( $ table , Entity $ entity , TableServiceOptions $ options = null ) { return $ this -> putOrMergeEntityAsyncImpl ( $ table , $ entity , Resources :: HTTP_PUT , true , $ options ) ; } 
public function mergeEntity ( $ table , Entity $ entity , TableServiceOptions $ options = null ) { return $ this -> mergeEntityAsync ( $ table , $ entity , $ options ) -> wait ( ) ; } 
public function mergeEntityAsync ( $ table , Entity $ entity , TableServiceOptions $ options = null ) { return $ this -> putOrMergeEntityAsyncImpl ( $ table , $ entity , Resources :: HTTP_MERGE , true , $ options ) ; } 
public function deleteEntity ( $ table , $ partitionKey , $ rowKey , DeleteEntityOptions $ options = null ) { $ this -> deleteEntityAsync ( $ table , $ partitionKey , $ rowKey , $ options ) -> wait ( ) ; } 
public function deleteEntityAsync ( $ table , $ partitionKey , $ rowKey , DeleteEntityOptions $ options = null ) { $ context = $ this -> constructDeleteEntityContext ( $ table , $ partitionKey , $ rowKey , $ options ) ; return $ this -> sendContextAsync ( $ context ) ; } 
public function getEntity ( $ table , $ partitionKey , $ rowKey , GetEntityOptions $ options = null ) { return $ this -> getEntityAsync ( $ table , $ partitionKey , $ rowKey , $ options ) -> wait ( ) ; } 
public function getEntityAsync ( $ table , $ partitionKey , $ rowKey , GetEntityOptions $ options = null ) { Validate :: canCastAsString ( $ table , 'table' ) ; Validate :: notNullOrEmpty ( $ table , 'table' ) ; Validate :: isTrue ( ! is_null ( $ partitionKey ) , Resources :: NULL_TABLE_KEY_MSG ) ; Validate :: isTrue ( ! is_null ( $ rowKey ) , Resources :: NULL_TABLE_KEY_MSG ) ; $ method = Resources :: HTTP_GET ; $ headers = array ( ) ; $ queryParams = array ( ) ; $ path = $ this -> getEntityPath ( $ table , $ partitionKey , $ rowKey ) ; if ( is_null ( $ options ) ) { $ options = new GetEntityOptions ( ) ; } 
public function batch ( Models \ BatchOperations $ batchOperations , Models \ TableServiceOptions $ options = null ) { return $ this -> batchAsync ( $ batchOperations , $ options ) -> wait ( ) ; } 
public function batchAsync ( Models \ BatchOperations $ batchOperations , Models \ TableServiceOptions $ options = null ) { Validate :: notNullOrEmpty ( $ batchOperations , 'batchOperations' ) ; $ method = Resources :: HTTP_POST ; $ operations = $ batchOperations -> getOperations ( ) ; $ contexts = $ this -> createOperationsContexts ( $ operations ) ; $ mime = $ this -> createBatchRequestBody ( $ operations , $ contexts ) ; $ body = $ mime [ 'body' ] ; $ headers = $ mime [ 'headers' ] ; $ postParams = array ( ) ; $ queryParams = array ( ) ; $ path = '$batch' ; if ( is_null ( $ options ) ) { $ options = new TableServiceOptions ( ) ; } $ odataSerializer = $ this -> odataSerializer ; $ mimeSerializer = $ this -> mimeSerializer ; $ options -> setLocationMode ( LocationMode :: PRIMARY_ONLY ) ; $ this -> addOptionalHeader ( $ headers , Resources :: ACCEPT_HEADER , Resources :: JSON_FULL_METADATA_CONTENT_TYPE ) ; return $ this -> sendAsync ( $ method , $ headers , $ queryParams , $ postParams , $ path , Resources :: STATUS_ACCEPTED , $ body , $ options ) -> then ( function ( $ response ) use ( $ operations , $ contexts , $ odataSerializer , $ mimeSerializer ) { return BatchResult :: create ( $ response -> getBody ( ) , $ operations , $ contexts , $ odataSerializer , $ mimeSerializer ) ; } , null ) ; } 
public function getTableAcl ( $ table , Models \ TableServiceOptions $ options = null ) { return $ this -> getTableAclAsync ( $ table , $ options ) -> wait ( ) ; } 
public function getTableAclAsync ( $ table , Models \ TableServiceOptions $ options = null ) { Validate :: canCastAsString ( $ table , 'table' ) ; $ method = Resources :: HTTP_GET ; $ headers = array ( ) ; $ postParams = array ( ) ; $ queryParams = array ( ) ; $ statusCode = Resources :: STATUS_OK ; $ path = $ table ; if ( is_null ( $ options ) ) { $ options = new TableServiceOptions ( ) ; } $ this -> addOptionalQueryParam ( $ queryParams , Resources :: QP_COMP , 'acl' ) ; $ this -> addOptionalHeader ( $ headers , Resources :: ACCEPT_HEADER , Resources :: XML_CONTENT_TYPE ) ; $ dataSerializer = $ this -> dataSerializer ; $ promise = $ this -> sendAsync ( $ method , $ headers , $ queryParams , $ postParams , $ path , Resources :: STATUS_OK , Resources :: EMPTY_STRING , $ options ) ; return $ promise -> then ( function ( $ response ) use ( $ dataSerializer ) { $ parsed = $ dataSerializer -> unserialize ( $ response -> getBody ( ) ) ; return TableACL :: create ( $ parsed ) ; } , null ) ; } 
public function setTableAcl ( $ table , TableACL $ acl , TableServiceOptions $ options = null ) { $ this -> setTableAclAsync ( $ table , $ acl , $ options ) -> wait ( ) ; } 
public function setTableAclAsync ( $ table , TableACL $ acl , TableServiceOptions $ options = null ) { Validate :: canCastAsString ( $ table , 'table' ) ; Validate :: notNullOrEmpty ( $ acl , 'acl' ) ; $ method = Resources :: HTTP_PUT ; $ headers = array ( ) ; $ postParams = array ( ) ; $ queryParams = array ( ) ; $ body = $ acl -> toXml ( $ this -> dataSerializer ) ; $ path = $ table ; if ( is_null ( $ options ) ) { $ options = new TableServiceOptions ( ) ; } $ this -> addOptionalQueryParam ( $ queryParams , Resources :: QP_COMP , 'acl' ) ; $ this -> addOptionalHeader ( $ headers , Resources :: ACCEPT_HEADER , Resources :: XML_CONTENT_TYPE ) ; $ options -> setLocationMode ( LocationMode :: PRIMARY_ONLY ) ; return $ this -> sendAsync ( $ method , $ headers , $ queryParams , $ postParams , $ path , Resources :: STATUS_NO_CONTENT , $ body , $ options ) ; } 
public static function create ( array $ responseHeaders ) { $ result = static :: createMetadataResult ( $ responseHeaders ) ; $ result -> setQuota ( \ intval ( Utilities :: tryGetValueInsensitive ( Resources :: X_MS_SHARE_QUOTA , $ responseHeaders ) ) ) ; return $ result ; } 
public static function log ( $ var , $ tip = Resources :: EMPTY_STRING ) { if ( ! empty ( $ tip ) ) { error_log ( $ tip . "\n" , 3 , self :: $ _filePath ) ; } if ( is_array ( $ var ) || is_object ( $ var ) ) { error_log ( print_r ( $ var , true ) , 3 , self :: $ _filePath ) ; } else { error_log ( $ var . "\n" , 3 , self :: $ _filePath ) ; } } 
public static function create ( array $ parsedResponse , $ location = '' ) { $ result = new ListDirectoriesAndFilesResult ( ) ; $ serviceEndpoint = Utilities :: tryGetKeysChainValue ( $ parsedResponse , Resources :: XTAG_ATTRIBUTES , Resources :: XTAG_SERVICE_ENDPOINT ) ; $ result -> setAccountName ( Utilities :: tryParseAccountNameFromUrl ( $ serviceEndpoint ) ) ; $ nextMarker = Utilities :: tryGetValue ( $ parsedResponse , Resources :: QP_NEXT_MARKER ) ; if ( $ nextMarker != null ) { $ result -> setContinuationToken ( new MarkerContinuationToken ( $ nextMarker , $ location ) ) ; } $ result -> setMaxResults ( Utilities :: tryGetValue ( $ parsedResponse , Resources :: QP_MAX_RESULTS ) ) ; $ result -> setMarker ( Utilities :: tryGetValue ( $ parsedResponse , Resources :: QP_MARKER ) ) ; $ entries = Utilities :: tryGetValue ( $ parsedResponse , Resources :: QP_ENTRIES ) ; if ( empty ( $ entries ) ) { $ result -> setDirectories ( array ( ) ) ; $ result -> setFiles ( array ( ) ) ; } else { $ directoriesArray = Utilities :: tryGetValue ( $ entries , Resources :: QP_DIRECTORY ) ; $ filesArray = Utilities :: tryGetValue ( $ entries , Resources :: QP_FILE ) ; $ directories = array ( ) ; $ files = array ( ) ; if ( $ directoriesArray != null ) { if ( array_key_exists ( Resources :: QP_NAME , $ directoriesArray ) ) { $ directoriesArray = [ $ directoriesArray ] ; } foreach ( $ directoriesArray as $ directoryArray ) { $ directories [ ] = Directory :: create ( $ directoryArray ) ; } } if ( $ filesArray != null ) { if ( array_key_exists ( Resources :: QP_NAME , $ filesArray ) ) { $ filesArray = [ $ filesArray ] ; } foreach ( $ filesArray as $ fileArray ) { $ files [ ] = File :: create ( $ fileArray ) ; } } $ result -> setDirectories ( $ directories ) ; $ result -> setFiles ( $ files ) ; } return $ result ; } 
protected function setDirectories ( array $ directories ) { $ this -> directories = array ( ) ; foreach ( $ directories as $ directory ) { $ this -> directories [ ] = clone $ directory ; } } 
protected function setFiles ( array $ files ) { $ this -> files = array ( ) ; foreach ( $ files as $ file ) { $ this -> files [ ] = clone $ file ; } } 
public static function create ( array $ parsed ) { $ result = new Directory ( ) ; $ name = Utilities :: tryGetValue ( $ parsed , Resources :: QP_NAME ) ; $ result -> setName ( $ name ) ; return $ result ; } 
public static function create ( array $ headers ) { $ result = new UpdateEntityResult ( ) ; $ result -> setETag ( Utilities :: tryGetValueInsensitive ( Resources :: ETAG , $ headers ) ) ; return $ result ; } 
public function setQueryParameters ( array $ queryParams ) { $ this -> _queryParams = array ( ) ; foreach ( $ queryParams as $ key => $ value ) { $ this -> addQueryParameter ( $ key , $ value ) ; } } 
public function setStatusCodes ( array $ statusCodes ) { $ this -> _statusCodes = array ( ) ; foreach ( $ statusCodes as $ value ) { $ this -> addStatusCode ( $ value ) ; } } 
public function addHeader ( $ name , $ value ) { Validate :: canCastAsString ( $ name , 'name' ) ; Validate :: canCastAsString ( $ value , 'value' ) ; $ this -> _headers [ $ name ] = $ value ; } 
public function addOptionalHeader ( $ name , $ value ) { Validate :: canCastAsString ( $ name , 'name' ) ; Validate :: canCastAsString ( $ value , 'value' ) ; if ( ! empty ( $ value ) ) { $ this -> _headers [ $ name ] = $ value ; } } 
public function removeHeader ( $ name ) { Validate :: canCastAsString ( $ name , 'name' ) ; Validate :: notNullOrEmpty ( $ name , 'name' ) ; unset ( $ this -> _headers [ $ name ] ) ; } 
public function addQueryParameter ( $ name , $ value ) { Validate :: canCastAsString ( $ name , 'name' ) ; Validate :: canCastAsString ( $ value , 'value' ) ; $ this -> _queryParams [ $ name ] = $ value ; } 
public function addOptionalQueryParameter ( $ name , $ value ) { Validate :: canCastAsString ( $ name , 'name' ) ; Validate :: canCastAsString ( $ value , 'value' ) ; if ( ! empty ( $ value ) ) { $ this -> _queryParams [ $ name ] = $ value ; } } 
public function addHistory ( array $ entry ) { if ( $ this -> path !== '' ) { $ this -> appendNewEntryToPath ( $ entry ) ; } else { Validate :: isTrue ( array_key_exists ( 'request' , $ entry ) && array_key_exists ( 'options' , $ entry ) && ( array_key_exists ( 'response' , $ entry ) || array_key_exists ( 'reason' , $ entry ) ) , 'Given history entry not in correct format' ) ; $ this -> history [ ] = $ entry ; } ++ $ this -> count ; } 
protected function onFulfilled ( RequestInterface $ request , array $ options ) { $ reflection = $ this ; return function ( ResponseInterface $ response ) use ( $ reflection , $ request , $ options ) { $ reflection -> addHistory ( [ 'request' => $ request , 'response' => $ response , 'options' => $ options ] ) ; return $ response ; } ; } 
protected function onRejected ( RequestInterface $ request , array $ options ) { $ reflection = $ this ; return function ( $ reason ) use ( $ reflection , $ request , $ options ) { $ reflection -> addHistory ( [ 'request' => $ request , 'reason' => $ reason , 'options' => $ options ] ) ; return new RejectedPromise ( $ reason ) ; } ; } 
private function appendNewEntryToPath ( array $ entry ) { $ entryNoString = "Entry " . $ this -> count ; $ delimiter = str_pad ( $ entryNoString , self :: TITLE_LENGTH , '-' , STR_PAD_BOTH ) . PHP_EOL ; $ entryString = $ delimiter ; $ entryString .= sprintf ( "Time: %s\n" , ( new \ DateTime ( "now" , new \ DateTimeZone ( 'UTC' ) ) ) -> format ( 'Y-m-d H:i:s' ) ) ; $ entryString .= MessageSerializer :: objectSerialize ( $ entry [ 'request' ] ) ; if ( array_key_exists ( 'reason' , $ entry ) ) { $ entryString .= MessageSerializer :: objectSerialize ( $ entry [ 'reason' ] ) ; } elseif ( array_key_exists ( 'response' , $ entry ) ) { $ entryString .= MessageSerializer :: objectSerialize ( $ entry [ 'response' ] ) ; } $ entryString .= $ delimiter ; Utilities :: appendToFile ( $ this -> path , $ entryString ) ; } 
public static function create ( array $ headers , array $ entries ) { $ result = new QueryTablesResult ( ) ; $ headers = array_change_key_case ( $ headers ) ; $ result -> setTables ( $ entries ) ; $ nextTableName = Utilities :: tryGetValue ( $ headers , Resources :: X_MS_CONTINUATION_NEXTTABLENAME ) ; if ( $ nextTableName != null ) { $ result -> setContinuationToken ( new TableContinuationToken ( $ nextTableName , '' , '' , Utilities :: getLocationFromHeaders ( $ headers ) ) ) ; } return $ result ; } 
public static function create ( array $ parsedResponse = null ) { $ result = new ListMessagesResult ( ) ; $ queueMessages = array ( ) ; if ( ! empty ( $ parsedResponse ) ) { $ rawMessages = Utilities :: getArray ( $ parsedResponse [ 'QueueMessage' ] ) ; foreach ( $ rawMessages as $ value ) { $ message = QueueMessage :: createFromListMessages ( $ value ) ; $ queueMessages [ ] = $ message ; } } $ result -> setQueueMessages ( $ queueMessages ) ; return $ result ; } 
protected function setQueueMessages ( array $ queueMessages ) { $ this -> _queueMessages = array ( ) ; foreach ( $ queueMessages as $ value ) { $ this -> _queueMessages [ ] = clone $ value ; } } 
public static function create ( array $ parsedResponse ) { $ result = new Share ( ) ; $ result -> setName ( $ parsedResponse [ Resources :: QP_NAME ] ) ; $ result -> setMetadata ( Utilities :: tryGetValue ( $ parsedResponse , Resources :: QP_METADATA , array ( ) ) ) ; $ result -> setProperties ( ShareProperties :: create ( $ parsedResponse [ Resources :: QP_PROPERTIES ] ) ) ; return $ result ; } 
private static function _init ( ) { if ( ! self :: $ _isInitialized ) { self :: $ _sources = array ( ) ; 
public static function isInstanceOf ( $ objectInstance , $ classInstance , $ name ) { Validate :: notNull ( $ classInstance , 'classInstance' ) ; if ( is_null ( $ objectInstance ) ) { return true ; } $ objectType = gettype ( $ objectInstance ) ; $ classType = gettype ( $ classInstance ) ; if ( $ objectType === $ classType ) { return true ; } else { throw new \ InvalidArgumentException ( sprintf ( Resources :: INSTANCE_TYPE_VALIDATION_MSG , $ name , $ objectType , $ classType ) ) ; } } 
public static function isValidHostname ( $ hostname ) { if ( defined ( 'FILTER_VALIDATE_DOMAIN' ) ) { $ isValid = filter_var ( $ hostname , FILTER_VALIDATE_DOMAIN , FILTER_FLAG_HOSTNAME ) ; } else { 
public static function isValidUri ( $ uri ) { $ isValid = filter_var ( $ uri , FILTER_VALIDATE_URL ) ; if ( $ isValid ) { return true ; } else { throw new \ RuntimeException ( sprintf ( Resources :: INVALID_CONFIG_URI , $ uri ) ) ; } } 
public static function isA ( $ objectInstance , $ class , $ name ) { Validate :: canCastAsString ( $ class , 'class' ) ; Validate :: notNull ( $ objectInstance , 'objectInstance' ) ; Validate :: isObject ( $ objectInstance , 'objectInstance' ) ; $ objectType = get_class ( $ objectInstance ) ; if ( is_a ( $ objectInstance , $ class ) ) { return true ; } else { throw new \ InvalidArgumentException ( sprintf ( Resources :: INSTANCE_TYPE_VALIDATION_MSG , $ name , $ objectType , $ class ) ) ; } } 
public static function methodExists ( $ objectInstance , $ method , $ name ) { Validate :: canCastAsString ( $ method , 'method' ) ; Validate :: notNull ( $ objectInstance , 'objectInstance' ) ; Validate :: isObject ( $ objectInstance , 'objectInstance' ) ; if ( method_exists ( $ objectInstance , $ method ) ) { return true ; } else { throw new \ InvalidArgumentException ( sprintf ( Resources :: ERROR_METHOD_NOT_FOUND , $ method , $ name ) ) ; } } 
public static function isDateString ( $ value , $ name ) { Validate :: canCastAsString ( $ value , 'value' ) ; try { new \ DateTime ( $ value ) ; return true ; } catch ( \ Exception $ e ) { throw new \ InvalidArgumentException ( sprintf ( Resources :: ERROR_INVALID_DATE_STRING , $ name , $ value ) ) ; } } 
public static function hasKey ( $ key , $ name , array $ array ) { Validate :: isArray ( $ array , $ name ) ; if ( ! array_key_exists ( $ key , $ array ) ) { throw new \ UnexpectedValueException ( sprintf ( Resources :: INVALID_VALUE_MSG , $ name , sprintf ( Resources :: ERROR_KEY_NOT_EXIST , $ key ) ) ) ; } return true ; } 
public function getRangeString ( ) { $ rangeString = '' ; $ rangeString .= ( 'bytes=' . $ this -> start . '-' ) ; if ( $ this -> end != null ) { $ rangeString .= $ this -> end ; } return $ rangeString ; } 
public static function createQueueService ( $ connectionString , array $ options = [ ] ) { $ settings = StorageServiceSettings :: createFromConnectionString ( $ connectionString ) ; $ primaryUri = Utilities :: tryAddUrlScheme ( $ settings -> getQueueEndpointUri ( ) ) ; $ secondaryUri = Utilities :: tryAddUrlScheme ( $ settings -> getQueueSecondaryEndpointUri ( ) ) ; $ queueWrapper = new QueueRestProxy ( $ primaryUri , $ secondaryUri , $ settings -> getName ( ) , $ options ) ; 
public static function createQueueServiceWithTokenCredential ( & $ token , $ connectionString , array $ options = [ ] ) { $ settings = StorageServiceSettings :: createFromConnectionStringForTokenCredential ( $ connectionString ) ; $ primaryUri = Utilities :: tryAddUrlScheme ( $ settings -> getQueueEndpointUri ( ) ) ; $ secondaryUri = Utilities :: tryAddUrlScheme ( $ settings -> getQueueSecondaryEndpointUri ( ) ) ; $ queueWrapper = new QueueRestProxy ( $ primaryUri , $ secondaryUri , $ settings -> getName ( ) , $ options ) ; 
public function listQueuesAsync ( ListQueuesOptions $ options = null ) { $ method = Resources :: HTTP_GET ; $ headers = array ( ) ; $ postParams = array ( ) ; $ queryParams = array ( ) ; $ path = Resources :: EMPTY_STRING ; if ( is_null ( $ options ) ) { $ options = new ListQueuesOptions ( ) ; } $ maxResults = $ options -> getMaxResults ( ) ; $ include = $ options -> getIncludeMetadata ( ) ; $ include = $ include ? 'metadata' : null ; $ prefix = $ options -> getPrefix ( ) ; $ marker = $ options -> getNextMarker ( ) ; $ this -> addOptionalQueryParam ( $ queryParams , Resources :: QP_COMP , 'list' ) ; $ this -> addOptionalQueryParam ( $ queryParams , Resources :: QP_PREFIX , $ prefix ) ; $ this -> addOptionalQueryParam ( $ queryParams , Resources :: QP_MARKER , $ marker ) ; $ this -> addOptionalQueryParam ( $ queryParams , Resources :: QP_INCLUDE , $ include ) ; $ this -> addOptionalQueryParam ( $ queryParams , Resources :: QP_MAX_RESULTS , $ maxResults ) ; $ dataSerializer = $ this -> dataSerializer ; return $ this -> sendAsync ( $ method , $ headers , $ queryParams , $ postParams , $ path , Resources :: STATUS_OK , Resources :: EMPTY_STRING , $ options ) -> then ( function ( $ response ) use ( $ dataSerializer ) { $ parsed = $ dataSerializer -> unserialize ( $ response -> getBody ( ) ) ; return ListQueuesResult :: create ( $ parsed , Utilities :: getLocationFromHeaders ( $ response -> getHeaders ( ) ) ) ; } , null ) ; } 
public function clearMessages ( $ queueName , QueueServiceOptions $ options = null ) { $ this -> clearMessagesAsync ( $ queueName , $ options ) -> wait ( ) ; } 
public function createMessage ( $ queueName , $ messageText , CreateMessageOptions $ options = null ) { return $ this -> createMessageAsync ( $ queueName , $ messageText , $ options ) -> wait ( ) ; } 
public function createMessageAsync ( $ queueName , $ messageText , CreateMessageOptions $ options = null ) { Validate :: canCastAsString ( $ queueName , 'queueName' ) ; Validate :: notNullOrEmpty ( $ queueName , 'queueName' ) ; Validate :: canCastAsString ( $ messageText , 'messageText' ) ; $ method = Resources :: HTTP_POST ; $ headers = array ( ) ; $ postParams = array ( ) ; $ queryParams = array ( ) ; $ path = $ queueName . '/messages' ; $ body = Resources :: EMPTY_STRING ; $ message = new QueueMessage ( ) ; $ message -> setMessageText ( $ messageText ) ; $ body = $ message -> toXml ( $ this -> dataSerializer ) ; if ( is_null ( $ options ) ) { $ options = new CreateMessageOptions ( ) ; } $ this -> addOptionalHeader ( $ headers , Resources :: CONTENT_TYPE , Resources :: URL_ENCODED_CONTENT_TYPE ) ; $ visibility = $ options -> getVisibilityTimeoutInSeconds ( ) ; $ timeToLive = $ options -> getTimeToLiveInSeconds ( ) ; $ this -> addOptionalQueryParam ( $ queryParams , Resources :: QP_VISIBILITY_TIMEOUT , $ visibility ) ; $ this -> addOptionalQueryParam ( $ queryParams , Resources :: QP_MESSAGE_TTL , $ timeToLive ) ; $ options -> setLocationMode ( LocationMode :: PRIMARY_ONLY ) ; $ dataSerializer = $ this -> dataSerializer ; return $ this -> sendAsync ( $ method , $ headers , $ queryParams , $ postParams , $ path , Resources :: STATUS_CREATED , $ body , $ options ) -> then ( function ( $ response ) use ( $ dataSerializer ) { $ parsed = $ dataSerializer -> unserialize ( $ response -> getBody ( ) ) ; return CreateMessageResult :: create ( $ parsed ) ; } , null ) ; } 
public function createQueue ( $ queueName , Models \ CreateQueueOptions $ options = null ) { $ this -> createQueueAsync ( $ queueName , $ options ) -> wait ( ) ; } 
public function createQueueAsync ( $ queueName , Models \ CreateQueueOptions $ options = null ) { Validate :: canCastAsString ( $ queueName , 'queueName' ) ; Validate :: notNullOrEmpty ( $ queueName , 'queueName' ) ; $ method = Resources :: HTTP_PUT ; $ headers = array ( ) ; $ postParams = array ( ) ; $ queryParams = array ( ) ; $ path = $ queueName ; if ( is_null ( $ options ) ) { $ options = new CreateQueueOptions ( ) ; } $ metadata = $ options -> getMetadata ( ) ; $ headers = $ this -> generateMetadataHeaders ( $ metadata ) ; $ options -> setLocationMode ( LocationMode :: PRIMARY_ONLY ) ; return $ this -> sendAsync ( $ method , $ headers , $ queryParams , $ postParams , $ path , array ( Resources :: STATUS_CREATED , Resources :: STATUS_NO_CONTENT ) , Resources :: EMPTY_STRING , $ options ) ; } 
public function deleteMessage ( $ queueName , $ messageId , $ popReceipt , QueueServiceOptions $ options = null ) { $ this -> deleteMessageAsync ( $ queueName , $ messageId , $ popReceipt , $ options ) -> wait ( ) ; } 
public function deleteMessageAsync ( $ queueName , $ messageId , $ popReceipt , QueueServiceOptions $ options = null ) { Validate :: canCastAsString ( $ queueName , 'queueName' ) ; Validate :: notNullOrEmpty ( $ queueName , 'queueName' ) ; Validate :: canCastAsString ( $ messageId , 'messageId' ) ; Validate :: notNullOrEmpty ( $ messageId , 'messageId' ) ; Validate :: canCastAsString ( $ popReceipt , 'popReceipt' ) ; Validate :: notNullOrEmpty ( $ popReceipt , 'popReceipt' ) ; $ method = Resources :: HTTP_DELETE ; $ headers = array ( ) ; $ postParams = array ( ) ; $ queryParams = array ( ) ; $ path = $ queueName . '/messages/' . $ messageId ; $ body = Resources :: EMPTY_STRING ; if ( is_null ( $ options ) ) { $ options = new QueueServiceOptions ( ) ; } $ this -> addOptionalQueryParam ( $ queryParams , Resources :: QP_POPRECEIPT , $ popReceipt ) ; $ options -> setLocationMode ( LocationMode :: PRIMARY_ONLY ) ; return $ this -> sendAsync ( $ method , $ headers , $ queryParams , $ postParams , $ path , Resources :: STATUS_NO_CONTENT , $ body , $ options ) ; } 
public function deleteQueue ( $ queueName , QueueServiceOptions $ options = null ) { $ this -> deleteQueueAsync ( $ queueName , $ options ) -> wait ( ) ; } 
public function deleteQueueAsync ( $ queueName , QueueServiceOptions $ options = null ) { Validate :: canCastAsString ( $ queueName , 'queueName' ) ; Validate :: notNullOrEmpty ( $ queueName , 'queueName' ) ; $ method = Resources :: HTTP_DELETE ; $ headers = array ( ) ; $ postParams = array ( ) ; $ queryParams = array ( ) ; $ path = $ queueName ; if ( is_null ( $ options ) ) { $ options = new QueueServiceOptions ( ) ; } $ options -> setLocationMode ( LocationMode :: PRIMARY_ONLY ) ; return $ this -> sendAsync ( $ method , $ headers , $ queryParams , $ postParams , $ path , Resources :: STATUS_NO_CONTENT , Resources :: EMPTY_STRING , $ options ) ; } 
public function getQueueMetadata ( $ queueName , QueueServiceOptions $ options = null ) { return $ this -> getQueueMetadataAsync ( $ queueName , $ options ) -> wait ( ) ; } 
public function getQueueMetadataAsync ( $ queueName , QueueServiceOptions $ options = null ) { Validate :: canCastAsString ( $ queueName , 'queueName' ) ; Validate :: notNullOrEmpty ( $ queueName , 'queueName' ) ; $ method = Resources :: HTTP_GET ; $ headers = array ( ) ; $ postParams = array ( ) ; $ queryParams = array ( ) ; $ path = $ queueName ; $ body = Resources :: EMPTY_STRING ; if ( is_null ( $ options ) ) { $ options = new QueueServiceOptions ( ) ; } $ this -> addOptionalQueryParam ( $ queryParams , Resources :: QP_COMP , 'metadata' ) ; return $ this -> sendAsync ( $ method , $ headers , $ queryParams , $ postParams , $ path , Resources :: STATUS_OK , $ body , $ options ) -> then ( function ( $ response ) { $ responseHeaders = HttpFormatter :: formatHeaders ( $ response -> getHeaders ( ) ) ; $ metadata = Utilities :: getMetadataArray ( $ responseHeaders ) ; $ maxCount = intval ( Utilities :: tryGetValue ( $ responseHeaders , Resources :: X_MS_APPROXIMATE_MESSAGES_COUNT ) ) ; return new GetQueueMetadataResult ( $ maxCount , $ metadata ) ; } , null ) ; } 
public function listMessages ( $ queueName , ListMessagesOptions $ options = null ) { return $ this -> listMessagesAsync ( $ queueName , $ options ) -> wait ( ) ; } 
public function listMessagesAsync ( $ queueName , ListMessagesOptions $ options = null ) { Validate :: canCastAsString ( $ queueName , 'queueName' ) ; Validate :: notNullOrEmpty ( $ queueName , 'queueName' ) ; $ method = Resources :: HTTP_GET ; $ headers = array ( ) ; $ queryParams = array ( ) ; $ postParams = array ( ) ; $ path = $ queueName . '/messages' ; if ( is_null ( $ options ) ) { $ options = new ListMessagesOptions ( ) ; } $ messagesCount = $ options -> getNumberOfMessages ( ) ; $ visibility = $ options -> getVisibilityTimeoutInSeconds ( ) ; $ this -> addOptionalQueryParam ( $ queryParams , Resources :: QP_NUM_OF_MESSAGES , $ messagesCount ) ; $ this -> addOptionalQueryParam ( $ queryParams , Resources :: QP_VISIBILITY_TIMEOUT , $ visibility ) ; $ dataSerializer = $ this -> dataSerializer ; $ options -> setLocationMode ( LocationMode :: PRIMARY_ONLY ) ; return $ this -> sendAsync ( $ method , $ headers , $ queryParams , $ postParams , $ path , Resources :: STATUS_OK , Resources :: EMPTY_STRING , $ options ) -> then ( function ( $ response ) use ( $ dataSerializer ) { $ parsed = $ dataSerializer -> unserialize ( $ response -> getBody ( ) ) ; return ListMessagesResult :: create ( $ parsed ) ; } , null ) ; } 
public function peekMessages ( $ queueName , PeekMessagesOptions $ options = null ) { return $ this -> peekMessagesAsync ( $ queueName , $ options ) -> wait ( ) ; } 
public function peekMessagesAsync ( $ queueName , PeekMessagesOptions $ options = null ) { Validate :: canCastAsString ( $ queueName , 'queueName' ) ; Validate :: notNullOrEmpty ( $ queueName , 'queueName' ) ; $ method = Resources :: HTTP_GET ; $ headers = array ( ) ; $ queryParams = array ( ) ; $ postParams = array ( ) ; $ path = $ queueName . '/messages' ; if ( is_null ( $ options ) ) { $ options = new PeekMessagesOptions ( ) ; } $ messagesCount = $ options -> getNumberOfMessages ( ) ; $ this -> addOptionalQueryParam ( $ queryParams , Resources :: QP_PEEK_ONLY , 'true' ) ; $ this -> addOptionalQueryParam ( $ queryParams , Resources :: QP_NUM_OF_MESSAGES , $ messagesCount ) ; $ dataSerializer = $ this -> dataSerializer ; return $ this -> sendAsync ( $ method , $ headers , $ queryParams , $ postParams , $ path , Resources :: STATUS_OK , Resources :: EMPTY_STRING , $ options ) -> then ( function ( $ response ) use ( $ dataSerializer ) { $ parsed = $ dataSerializer -> unserialize ( $ response -> getBody ( ) ) ; return PeekMessagesResult :: create ( $ parsed ) ; } , null ) ; } 
public function setQueueMetadata ( $ queueName , array $ metadata = null , QueueServiceOptions $ options = null ) { $ this -> setQueueMetadataAsync ( $ queueName , $ metadata , $ options ) -> wait ( ) ; } 
public function setQueueMetadataAsync ( $ queueName , array $ metadata = null , QueueServiceOptions $ options = null ) { Validate :: canCastAsString ( $ queueName , 'queueName' ) ; Validate :: notNullOrEmpty ( $ queueName , 'queueName' ) ; Utilities :: validateMetadata ( $ metadata ) ; $ method = Resources :: HTTP_PUT ; $ headers = array ( ) ; $ queryParams = array ( ) ; $ postParams = array ( ) ; $ path = $ queueName ; $ body = Resources :: EMPTY_STRING ; if ( is_null ( $ options ) ) { $ options = new QueueServiceOptions ( ) ; } $ this -> addOptionalQueryParam ( $ queryParams , Resources :: QP_COMP , 'metadata' ) ; $ metadataHeaders = $ this -> generateMetadataHeaders ( $ metadata ) ; $ headers = $ metadataHeaders ; $ options -> setLocationMode ( LocationMode :: PRIMARY_ONLY ) ; return $ this -> sendAsync ( $ method , $ headers , $ queryParams , $ postParams , $ path , Resources :: STATUS_NO_CONTENT , $ body , $ options ) ; } 
public function updateMessage ( $ queueName , $ messageId , $ popReceipt , $ messageText , $ visibilityTimeoutInSeconds , QueueServiceOptions $ options = null ) { return $ this -> updateMessageAsync ( $ queueName , $ messageId , $ popReceipt , $ messageText , $ visibilityTimeoutInSeconds , $ options ) -> wait ( ) ; } 
public function updateMessageAsync ( $ queueName , $ messageId , $ popReceipt , $ messageText , $ visibilityTimeoutInSeconds , QueueServiceOptions $ options = null ) { Validate :: canCastAsString ( $ queueName , 'queueName' ) ; Validate :: notNullOrEmpty ( $ queueName , 'queueName' ) ; Validate :: canCastAsString ( $ messageId , 'messageId' ) ; Validate :: notNullOrEmpty ( $ messageId , 'messageId' ) ; Validate :: canCastAsString ( $ popReceipt , 'popReceipt' ) ; Validate :: notNullOrEmpty ( $ popReceipt , 'popReceipt' ) ; Validate :: canCastAsString ( $ messageText , 'messageText' ) ; Validate :: isInteger ( $ visibilityTimeoutInSeconds , 'visibilityTimeoutInSeconds' ) ; Validate :: notNull ( $ visibilityTimeoutInSeconds , 'visibilityTimeoutInSeconds' ) ; $ method = Resources :: HTTP_PUT ; $ headers = array ( ) ; $ postParams = array ( ) ; $ queryParams = array ( ) ; $ path = $ queueName . '/messages' . '/' . $ messageId ; $ body = Resources :: EMPTY_STRING ; if ( is_null ( $ options ) ) { $ options = new QueueServiceOptions ( ) ; } $ this -> addOptionalQueryParam ( $ queryParams , Resources :: QP_VISIBILITY_TIMEOUT , $ visibilityTimeoutInSeconds ) ; $ this -> addOptionalQueryParam ( $ queryParams , Resources :: QP_POPRECEIPT , $ popReceipt ) ; if ( ! empty ( $ messageText ) ) { $ this -> addOptionalHeader ( $ headers , Resources :: CONTENT_TYPE , Resources :: URL_ENCODED_CONTENT_TYPE ) ; $ message = new QueueMessage ( ) ; $ message -> setMessageText ( $ messageText ) ; $ body = $ message -> toXml ( $ this -> dataSerializer ) ; } $ options -> setLocationMode ( LocationMode :: PRIMARY_ONLY ) ; return $ this -> sendAsync ( $ method , $ headers , $ queryParams , $ postParams , $ path , Resources :: STATUS_NO_CONTENT , $ body , $ options ) -> then ( function ( $ response ) { $ responseHeaders = HttpFormatter :: formatHeaders ( $ response -> getHeaders ( ) ) ; return UpdateMessageResult :: create ( $ responseHeaders ) ; } , null ) ; } 
public function getQueueAcl ( $ queue , Models \ QueueServiceOptions $ options = null ) { return $ this -> getQueueAclAsync ( $ queue , $ options ) -> wait ( ) ; } 
public function getQueueAclAsync ( $ queue , Models \ QueueServiceOptions $ options = null ) { Validate :: canCastAsString ( $ queue , 'queue' ) ; $ method = Resources :: HTTP_GET ; $ headers = array ( ) ; $ postParams = array ( ) ; $ queryParams = array ( ) ; $ statusCode = Resources :: STATUS_OK ; $ path = $ queue ; if ( is_null ( $ options ) ) { $ options = new QueueServiceOptions ( ) ; } $ this -> addOptionalQueryParam ( $ queryParams , Resources :: QP_COMP , 'acl' ) ; $ dataSerializer = $ this -> dataSerializer ; $ promise = $ this -> sendAsync ( $ method , $ headers , $ queryParams , $ postParams , $ path , Resources :: STATUS_OK , Resources :: EMPTY_STRING , $ options ) ; return $ promise -> then ( function ( $ response ) use ( $ dataSerializer ) { $ parsed = $ dataSerializer -> unserialize ( $ response -> getBody ( ) ) ; return QueueACL :: create ( $ parsed ) ; } , null ) ; } 
public function setQueueAcl ( $ queue , Models \ QueueACL $ acl , Models \ QueueServiceOptions $ options = null ) { $ this -> setQueueAclAsync ( $ queue , $ acl , $ options ) -> wait ( ) ; } 
public function setQueueAclAsync ( $ queue , Models \ QueueACL $ acl , Models \ QueueServiceOptions $ options = null ) { Validate :: canCastAsString ( $ queue , 'queue' ) ; Validate :: notNullOrEmpty ( $ acl , 'acl' ) ; $ method = Resources :: HTTP_PUT ; $ headers = array ( ) ; $ postParams = array ( ) ; $ queryParams = array ( ) ; $ body = $ acl -> toXml ( $ this -> dataSerializer ) ; $ path = $ queue ; if ( is_null ( $ options ) ) { $ options = new QueueServiceOptions ( ) ; } $ this -> addOptionalQueryParam ( $ queryParams , Resources :: QP_COMP , 'acl' ) ; $ options -> setLocationMode ( LocationMode :: PRIMARY_ONLY ) ; return $ this -> sendAsync ( $ method , $ headers , $ queryParams , $ postParams , $ path , Resources :: STATUS_NO_CONTENT , $ body , $ options ) ; } 
public function generateAccountSharedAccessSignatureToken ( $ signedVersion , $ signedPermissions , $ signedService , $ signedResourceType , $ signedExpiry , $ signedStart = "" , $ signedIP = "" , $ signedProtocol = "" ) { 
protected function validateAndSanitizeSignedService ( $ signedService ) { 
protected function validateAndSanitizeSignedResourceType ( $ signedResourceType ) { 
protected function validateAndSanitizeSignedPermissions ( $ signedPermissions ) { 
protected function validateAndSanitizeSignedProtocol ( $ signedProtocol ) { Validate :: canCastAsString ( $ signedProtocol , 'signedProtocol' ) ; 
protected function validateAndSanitizeStringWithArray ( $ input , array $ array ) { $ result = '' ; foreach ( $ array as $ value ) { if ( strpos ( $ input , $ value ) !== false ) { 
protected static function generateCanonicalResource ( $ accountName , $ service , $ resource ) { static $ serviceMap = array ( Resources :: RESOURCE_TYPE_BLOB => 'blob' , Resources :: RESOURCE_TYPE_FILE => 'file' , Resources :: RESOURCE_TYPE_QUEUE => 'queue' , Resources :: RESOURCE_TYPE_TABLE => 'table' , ) ; $ serviceName = $ serviceMap [ $ service ] ; if ( Utilities :: startsWith ( $ resource , '/' ) ) { $ resource = substr ( $ resource , 1 ) ; } return sprintf ( '/%s/%s/%s' , $ serviceName , $ accountName , $ resource ) ; } 
public function toArray ( ) { $ array = array ( ) ; $ accessPolicyArray = array ( ) ; $ accessPolicyArray [ Resources :: XTAG_SIGNED_ID ] = $ this -> getId ( ) ; $ accessPolicyArray [ Resources :: XTAG_ACCESS_POLICY ] = $ this -> getAccessPolicy ( ) -> toArray ( ) ; $ array [ Resources :: XTAG_SIGNED_IDENTIFIER ] = $ accessPolicyArray ; return $ array ; } 
protected static function parseErrorMessage ( ResponseInterface $ response ) { 
public function getRequestID ( ) { $ requestID = '' ; if ( array_key_exists ( Resources :: X_MS_REQUEST_ID , $ this -> getResponse ( ) -> getHeaders ( ) ) ) { $ requestID = $ this -> getResponse ( ) -> getHeaders ( ) [ Resources :: X_MS_REQUEST_ID ] [ 0 ] ; } return $ requestID ; } 
public function getDate ( ) { $ date = '' ; if ( array_key_exists ( Resources :: DATE , $ this -> getResponse ( ) -> getHeaders ( ) ) ) { $ date = $ this -> getResponse ( ) -> getHeaders ( ) [ Resources :: DATE ] [ 0 ] ; } return $ date ; } 
public function setMiddlewares ( array $ middlewares ) { foreach ( $ middlewares as $ middleware ) { self :: validateIsMiddleware ( $ middleware ) ; } $ this -> middlewares = $ middlewares ; } 
private static function validateIsMiddleware ( $ middleware ) { if ( ! ( is_callable ( $ middleware ) || $ middleware instanceof IMiddleware ) ) { Validate :: isTrue ( false , Resources :: INVALID_TYPE_MSG . 'callable or IMiddleware' ) ; } } 
public static function create ( array $ parsedResponse ) { $ result = new ShareProperties ( ) ; $ date = $ parsedResponse [ Resources :: QP_LAST_MODIFIED ] ; $ date = Utilities :: rfc1123ToDateTime ( $ date ) ; $ result -> setLastModified ( $ date ) ; $ result -> setETag ( $ parsedResponse [ Resources :: QP_ETAG ] ) ; $ result -> setQuota ( $ parsedResponse [ Resources :: QP_QUOTA ] ) ; return $ result ; } 
public static function parseConnectionString ( $ argumentName , $ connectionString ) { Validate :: canCastAsString ( $ argumentName , 'argumentName' ) ; Validate :: notNullOrEmpty ( $ argumentName , 'argumentName' ) ; Validate :: canCastAsString ( $ connectionString , 'connectionString' ) ; Validate :: notNullOrEmpty ( $ connectionString , 'connectionString' ) ; $ parser = new ConnectionStringParser ( $ argumentName , $ connectionString ) ; return $ parser -> _parse ( ) ; } 
private function _parse ( ) { $ key = null ; $ value = null ; $ connectionStringValues = array ( ) ; while ( true ) { $ this -> _skipWhiteSpaces ( ) ; if ( $ this -> _pos == strlen ( $ this -> _value ) && $ this -> _state != ConnectionStringParser :: EXPECT_VALUE ) { 
private function _createException ( $ position , $ errorString ) { $ arguments = func_get_args ( ) ; 
private function _extractKey ( ) { $ key = null ; $ firstPos = $ this -> _pos ; $ ch = $ this -> _value [ $ this -> _pos ] ; if ( $ ch == '"' || $ ch == '\'' ) { $ this -> _pos ++ ; $ key = $ this -> _extractString ( $ ch ) ; } elseif ( $ ch == ';' || $ ch == '=' ) { // Key name was expected. throw $ this -> _createException ( $ firstPos , Resources :: ERROR_CONNECTION_STRING_MISSING_KEY ) ; } else { while ( $ this -> _pos < strlen ( $ this -> _value ) ) { $ ch = $ this -> _value [ $ this -> _pos ] ; // At this point we've read the key, break. if ( $ ch == '=' ) { break ; } $ this -> _pos ++ ; } $ key = rtrim ( substr ( $ this -> _value , $ firstPos , $ this -> _pos - $ firstPos ) ) ; } if ( strlen ( $ key ) == 0 ) { 
private function _extractString ( $ quote ) { $ firstPos = $ this -> _pos ; while ( $ this -> _pos < strlen ( $ this -> _value ) && $ this -> _value [ $ this -> _pos ] != $ quote ) { $ this -> _pos ++ ; } if ( $ this -> _pos == strlen ( $ this -> _value ) ) { 
private function _skipOperator ( $ operatorChar ) { if ( $ this -> _value [ $ this -> _pos ] != $ operatorChar ) { 
public static function create ( $ etag , \ DateTime $ lastModified , array $ parsed = null ) { $ result = new GetShareAclResult ( ) ; $ result -> setETag ( $ etag ) ; $ result -> setLastModified ( $ lastModified ) ; $ acl = ShareACL :: create ( $ parsed ) ; $ result -> setShareAcl ( $ acl ) ; return $ result ; } 
public static function create ( array $ headers , array $ parsed = null ) { $ result = new ListFileRangesResult ( ) ; $ headers = array_change_key_case ( $ headers ) ; $ date = $ headers [ Resources :: LAST_MODIFIED ] ; $ date = Utilities :: rfc1123ToDateTime ( $ date ) ; $ fileLength = intval ( $ headers [ Resources :: X_MS_CONTENT_LENGTH ] ) ; $ rawRanges = array ( ) ; if ( ! empty ( $ parsed [ 'Range' ] ) ) { $ rawRanges = Utilities :: getArray ( $ parsed [ 'Range' ] ) ; } $ ranges = array ( ) ; foreach ( $ rawRanges as $ value ) { $ ranges [ ] = new Range ( intval ( $ value [ 'Start' ] ) , intval ( $ value [ 'End' ] ) ) ; } $ result -> setRanges ( $ ranges ) ; $ result -> setContentLength ( $ fileLength ) ; $ result -> setETag ( $ headers [ Resources :: ETAG ] ) ; $ result -> setLastModified ( $ date ) ; return $ result ; } 
protected function setRanges ( array $ ranges ) { $ this -> ranges = array ( ) ; foreach ( $ ranges as $ range ) { $ this -> ranges [ ] = clone $ range ; } } 
public static function create ( array $ parsedResponse ) { $ result = new GetServiceStatsResult ( ) ; if ( Utilities :: arrayKeyExistsInsensitive ( Resources :: XTAG_GEO_REPLICATION , $ parsedResponse ) ) { $ geoReplication = $ parsedResponse [ Resources :: XTAG_GEO_REPLICATION ] ; if ( Utilities :: arrayKeyExistsInsensitive ( Resources :: XTAG_STATUS , $ geoReplication ) ) { $ result -> setStatus ( $ geoReplication [ Resources :: XTAG_STATUS ] ) ; } if ( Utilities :: arrayKeyExistsInsensitive ( Resources :: XTAG_LAST_SYNC_TIME , $ geoReplication ) ) { $ lastSyncTime = $ geoReplication [ Resources :: XTAG_LAST_SYNC_TIME ] ; $ result -> setLastSyncTime ( Utilities :: convertToDateTime ( $ lastSyncTime ) ) ; } } return $ result ; } 
protected function onRequest ( RequestInterface $ request ) { $ result = $ request ; 
protected static function parseAndValidateKeys ( $ connectionString ) { 
protected static function settingWithFunc ( $ name , $ predicate ) { $ requirement = array ( ) ; $ requirement [ Resources :: SETTING_NAME ] = $ name ; $ requirement [ Resources :: SETTING_CONSTRAINT ] = $ predicate ; return $ requirement ; } 
protected static function setting ( $ name ) { $ validValues = func_get_args ( ) ; 
protected static function matchedSpecification ( array $ settings ) { $ constraints = func_get_args ( ) ; 
public function signRequest ( Request $ request ) { 
public static function createFromHttpHeaders ( array $ parsed ) { $ result = new FileProperties ( ) ; $ clean = array_change_key_case ( $ parsed ) ; $ lastModified = Utilities :: tryGetValue ( $ parsed , Resources :: LAST_MODIFIED ) ; $ result -> setLastModified ( Utilities :: rfc1123ToDateTime ( $ lastModified ) ) ; $ result -> setContentLength ( Utilities :: tryGetValue ( $ parsed , Resources :: CONTENT_LENGTH ) ) ; $ result -> setContentType ( Utilities :: tryGetValue ( $ parsed , Resources :: CONTENT_TYPE ) ) ; $ result -> setETag ( Utilities :: tryGetValue ( $ parsed , Resources :: ETAG ) ) ; if ( Utilities :: tryGetValue ( $ parsed , Resources :: CONTENT_MD5 ) && ! Utilities :: tryGetValue ( $ parsed , Resources :: CONTENT_RANGE ) ) { $ result -> setContentMD5 ( Utilities :: tryGetValue ( $ parsed , Resources :: CONTENT_MD5 ) ) ; } else { $ result -> setContentMD5 ( Utilities :: tryGetValue ( $ parsed , Resources :: FILE_CONTENT_MD5 ) ) ; $ result -> setRangeContentMD5 ( Utilities :: tryGetValue ( $ parsed , Resources :: CONTENT_MD5 ) ) ; } $ result -> setContentEncoding ( Utilities :: tryGetValue ( $ parsed , Resources :: CONTENT_ENCODING ) ) ; $ result -> setContentLanguage ( Utilities :: tryGetValue ( $ parsed , Resources :: CONTENT_LANGUAGE ) ) ; $ result -> setCacheControl ( Utilities :: tryGetValue ( $ parsed , Resources :: CACHE_CONTROL ) ) ; $ result -> setContentDisposition ( Utilities :: tryGetValue ( $ parsed , Resources :: CONTENT_DISPOSITION ) ) ; $ result -> setContentRange ( Utilities :: tryGetValue ( $ parsed , Resources :: CONTENT_RANGE ) ) ; $ result -> setCopyCompletionTime ( Utilities :: tryGetValue ( $ parsed , Resources :: X_MS_COPY_COMPLETION_TIME ) ) ; $ result -> setCopyStatusDescription ( Utilities :: tryGetValue ( $ parsed , Resources :: X_MS_COPY_STATUS_DESCRIPTION ) ) ; $ result -> setCopyID ( Utilities :: tryGetValue ( $ parsed , Resources :: X_MS_COPY_ID ) ) ; $ result -> setCopyProgress ( Utilities :: tryGetValue ( $ parsed , Resources :: X_MS_COPY_PROGRESS ) ) ; $ result -> setCopySource ( Utilities :: tryGetValue ( $ parsed , Resources :: X_MS_COPY_SOURCE ) ) ; $ result -> setCopyStatus ( Utilities :: tryGetValue ( $ parsed , Resources :: X_MS_COPY_STATUS ) ) ; return $ result ; } 
public function setNextRowKey ( $ nextRowKey ) { if ( $ this -> continuationToken == null ) { $ this -> setContinuationToken ( new TableContinuationToken ( ) ) ; } $ this -> continuationToken -> setNextRowKey ( $ nextRowKey ) ; } 
public function setNextPartitionKey ( $ nextPartitionKey ) { if ( $ this -> continuationToken == null ) { $ this -> setContinuationToken ( new TableContinuationToken ( ) ) ; } $ this -> continuationToken -> setNextPartitionKey ( $ nextPartitionKey ) ; } 
public function setNextTableName ( $ nextTableName ) { if ( $ this -> continuationToken == null ) { $ this -> setContinuationToken ( new TableContinuationToken ( ) ) ; } $ this -> continuationToken -> setNextTableName ( $ nextTableName ) ; } 
public static function processType ( $ type ) { $ type = empty ( $ type ) ? self :: STRING : $ type ; Validate :: isTrue ( self :: isValid ( $ type ) , Resources :: INVALID_EDM_MSG ) ; return $ type ; } 
public static function validateEdmValue ( $ type , $ value , & $ condition = null ) { 
public static function serializeValue ( $ type , $ value ) { switch ( $ type ) { case null : return $ value ; case EdmType :: INT32 : return intval ( $ value ) ; case EdmType :: INT64 : case EdmType :: GUID : case EdmType :: STRING : return strval ( $ value ) ; case EdmType :: DOUBLE : return strval ( $ value ) ; case EdmType :: BINARY : return base64_encode ( $ value ) ; case EdmType :: DATETIME : return Utilities :: convertToEdmDateTime ( $ value ) ; case EdmType :: BOOLEAN : return ( is_null ( $ value ) ? '' : ( $ value == true ? true : false ) ) ; default : throw new \ InvalidArgumentException ( ) ; } } 
public static function serializeQueryValue ( $ type , $ value ) { switch ( $ type ) { case EdmType :: DATETIME : $ edmDate = Utilities :: convertToEdmDateTime ( $ value ) ; return 'datetime\'' . $ edmDate . '\'' ; case EdmType :: BINARY : return 'X\'' . implode ( '' , unpack ( "H*" , $ value ) ) . '\'' ; case EdmType :: BOOLEAN : return ( $ value ? 'true' : 'false' ) ; case EdmType :: DOUBLE : case EdmType :: INT32 : return $ value ; case EdmType :: INT64 : return $ value . 'L' ; case EdmType :: GUID : return 'guid\'' . $ value . '\'' ; case null : case EdmType :: STRING : 
public static function unserializeQueryValue ( $ type , $ value ) { 
public static function isValid ( $ type ) { switch ( $ type ) { case $ type == self :: DATETIME : case $ type == self :: BINARY : case $ type == self :: BOOLEAN : case $ type == self :: DOUBLE : case $ type == self :: GUID : case $ type == self :: INT32 : case $ type == self :: INT64 : case $ type == self :: STRING : case $ type == null : 
public static function create ( array $ parsedResponse ) { $ result = new ServiceProperties ( ) ; if ( array_key_exists ( Resources :: XTAG_DEFAULT_SERVICE_VERSION , $ parsedResponse ) && $ parsedResponse [ Resources :: XTAG_DEFAULT_SERVICE_VERSION ] != null ) { $ result -> setDefaultServiceVersion ( $ parsedResponse [ Resources :: XTAG_DEFAULT_SERVICE_VERSION ] ) ; } if ( array_key_exists ( Resources :: XTAG_LOGGING , $ parsedResponse ) ) { $ result -> setLogging ( Logging :: create ( $ parsedResponse [ Resources :: XTAG_LOGGING ] ) ) ; } $ result -> setHourMetrics ( Metrics :: create ( $ parsedResponse [ Resources :: XTAG_HOUR_METRICS ] ) ) ; if ( array_key_exists ( Resources :: XTAG_MINUTE_METRICS , $ parsedResponse ) ) { $ result -> setMinuteMetrics ( Metrics :: create ( $ parsedResponse [ Resources :: XTAG_MINUTE_METRICS ] ) ) ; } if ( array_key_exists ( Resources :: XTAG_CORS , $ parsedResponse ) && $ parsedResponse [ Resources :: XTAG_CORS ] != null ) { 
public function toArray ( ) { $ result = array ( ) ; if ( ! empty ( $ this -> getLogging ( ) ) ) { $ result [ Resources :: XTAG_LOGGING ] = $ this -> getLogging ( ) -> toArray ( ) ; } if ( ! empty ( $ this -> getHourMetrics ( ) ) ) { $ result [ Resources :: XTAG_HOUR_METRICS ] = $ this -> getHourMetrics ( ) -> toArray ( ) ; } if ( ! empty ( $ this -> getMinuteMetrics ( ) ) ) { $ result [ Resources :: XTAG_MINUTE_METRICS ] = $ this -> getMinuteMetrics ( ) -> toArray ( ) ; } $ corsesArray = $ this -> getCorsesArray ( ) ; if ( ! empty ( $ corsesArray ) ) { $ result [ Resources :: XTAG_CORS ] = $ corsesArray ; } if ( $ this -> defaultServiceVersion != null ) { $ result [ Resources :: XTAG_DEFAULT_SERVICE_VERSION ] = $ this -> defaultServiceVersion ; } return $ result ; } 
private function getCorsesArray ( ) { $ corsesArray = array ( ) ; if ( count ( $ this -> getCorses ( ) ) == 1 ) { $ corsesArray = array ( Resources :: XTAG_CORS_RULE => $ this -> getCorses ( ) [ 0 ] -> toArray ( ) ) ; } elseif ( $ this -> getCorses ( ) != array ( ) ) { foreach ( $ this -> getCorses ( ) as $ cors ) { $ corsesArray [ ] = [ Resources :: XTAG_CORS_RULE => $ cors -> toArray ( ) ] ; } } return $ corsesArray ; } 
public function toXml ( XmlSerializer $ xmlSerializer ) { $ properties = array ( XmlSerializer :: ROOT_NAME => self :: $ xmlRootName ) ; return $ xmlSerializer -> serialize ( $ this -> toArray ( ) , $ properties ) ; } 
private static function _init ( ) { if ( ! self :: $ _isInitialized ) { self :: $ _defaultSources = array ( self :: ENVIRONMENT_SOURCE => array ( __CLASS__ , 'environmentSource' ) ) ; self :: $ _isInitialized = true ; } } 
public function parseTableEntries ( $ body ) { $ tables = array ( ) ; $ result = json_decode ( $ body , true ) ; $ rawEntries = $ result [ Resources :: JSON_VALUE ] ; foreach ( $ rawEntries as $ entry ) { $ tables [ ] = $ entry [ Resources :: JSON_TABLE_NAME ] ; } return $ tables ; } 
public function getEntity ( Entity $ entity ) { $ entityProperties = $ entity -> getProperties ( ) ; $ properties = array ( ) ; foreach ( $ entityProperties as $ name => $ property ) { $ edmType = $ property -> getEdmType ( ) ; $ edmValue = $ property -> getValue ( ) ; if ( is_null ( $ edmValue ) ) { 
public function parseEntities ( $ body ) { $ rawEntities = json_decode ( $ body , true ) ; $ entities = array ( ) ; foreach ( $ rawEntities [ Resources :: JSON_VALUE ] as $ rawEntity ) { $ entities [ ] = $ this -> parseOneEntity ( $ rawEntity ) ; } return $ entities ; } 
public static function isValid ( $ paramName ) { switch ( $ paramName ) { case self :: BP_TABLE : case self :: BP_ENTITY : case self :: BP_PARTITION_KEY : case self :: BP_ROW_KEY : case self :: BP_ETAG : return true ; default : return false ; } } 
public function setStart ( \ DateTime $ start = null ) { if ( $ start != null ) { Validate :: isDate ( $ start ) ; } $ this -> start = $ start ; } 
private function validatePermission ( $ permission ) { $ validPermissions = static :: getResourceValidPermissions ( ) ; $ result = '' ; foreach ( $ validPermissions as $ validPermission ) { if ( strpos ( $ permission , $ validPermission ) !== false ) { 
public function toArray ( ) { $ array = array ( ) ; if ( $ this -> getStart ( ) != null ) { $ array [ Resources :: XTAG_SIGNED_START ] = Utilities :: convertToEdmDateTime ( $ this -> getStart ( ) ) ; } $ array [ Resources :: XTAG_SIGNED_EXPIRY ] = Utilities :: convertToEdmDateTime ( $ this -> getExpiry ( ) ) ; $ array [ Resources :: XTAG_SIGNED_PERMISSION ] = $ this -> getPermission ( ) ; return $ array ; } 
public static function isValid ( $ type ) { switch ( $ type ) { case self :: INSERT_ENTITY_OPERATION : case self :: UPDATE_ENTITY_OPERATION : case self :: DELETE_ENTITY_OPERATION : case self :: MERGE_ENTITY_OPERATION : case self :: INSERT_REPLACE_ENTITY_OPERATION : case self :: INSERT_MERGE_ENTITY_OPERATION : return true ; default : return false ; } } 
public static function createFileService ( $ connectionString , array $ options = [ ] ) { $ settings = StorageServiceSettings :: createFromConnectionString ( $ connectionString ) ; $ primaryUri = Utilities :: tryAddUrlScheme ( $ settings -> getFileEndpointUri ( ) ) ; $ secondaryUri = Utilities :: tryAddUrlScheme ( $ settings -> getFileSecondaryEndpointUri ( ) ) ; $ fileWrapper = new FileRestProxy ( $ primaryUri , $ secondaryUri , $ settings -> getName ( ) , $ options ) ; 
private function createPath ( $ share , $ directory = '' ) { if ( empty ( $ directory ) && ( $ directory != '0' ) ) { return empty ( $ share ) ? '/' : $ share ; } $ encodedFile = urlencode ( $ directory ) ; 
private function getSharePropertiesAsyncImpl ( $ share , FileServiceOptions $ options = null , $ operation = null ) { Validate :: canCastAsString ( $ share , 'share' ) ; Validate :: isTrue ( $ operation == 'properties' || $ operation == 'metadata' , Resources :: FILE_SHARE_PROPERTIES_OPERATION_INVALID ) ; $ method = Resources :: HTTP_GET ; $ headers = array ( ) ; $ queryParams = array ( ) ; $ postParams = array ( ) ; $ path = $ this -> createPath ( $ share ) ; if ( is_null ( $ options ) ) { $ options = new FileServiceOptions ( ) ; } $ this -> addOptionalQueryParam ( $ queryParams , Resources :: QP_REST_TYPE , 'share' ) ; $ this -> addOptionalQueryParam ( $ queryParams , Resources :: QP_TIMEOUT , $ options -> getTimeout ( ) ) ; if ( $ operation == 'metadata' ) { $ this -> addOptionalQueryParam ( $ queryParams , Resources :: QP_COMP , $ operation ) ; } return $ this -> sendAsync ( $ method , $ headers , $ queryParams , $ postParams , $ path , Resources :: STATUS_OK , Resources :: EMPTY_STRING , $ options ) -> then ( function ( $ response ) { $ responseHeaders = HttpFormatter :: formatHeaders ( $ response -> getHeaders ( ) ) ; return GetSharePropertiesResult :: create ( $ responseHeaders ) ; } , null ) ; } 
private function setSharePropertiesAsyncImpl ( $ share , array $ properties , FileServiceOptions $ options = null , $ operation = 'properties' ) { Validate :: canCastAsString ( $ share , 'share' ) ; Validate :: isTrue ( $ operation == 'properties' || $ operation == 'metadata' , Resources :: FILE_SHARE_PROPERTIES_OPERATION_INVALID ) ; Validate :: canCastAsString ( $ share , 'share' ) ; $ headers = array ( ) ; if ( $ operation == 'properties' ) { $ headers [ Resources :: X_MS_SHARE_QUOTA ] = $ properties [ Resources :: X_MS_SHARE_QUOTA ] ; } else { Utilities :: validateMetadata ( $ properties ) ; $ headers = $ this -> generateMetadataHeaders ( $ properties ) ; } $ method = Resources :: HTTP_PUT ; $ postParams = array ( ) ; $ queryParams = array ( ) ; $ path = $ this -> createPath ( $ share ) ; if ( is_null ( $ options ) ) { $ options = new FileServiceOptions ( ) ; } $ this -> addOptionalQueryParam ( $ queryParams , Resources :: QP_TIMEOUT , $ options -> getTimeout ( ) ) ; $ this -> addOptionalQueryParam ( $ queryParams , Resources :: QP_REST_TYPE , 'share' ) ; $ this -> addOptionalQueryParam ( $ queryParams , Resources :: QP_COMP , $ operation ) ; return $ this -> sendAsync ( $ method , $ headers , $ queryParams , $ postParams , $ path , Resources :: STATUS_OK , Resources :: EMPTY_STRING , $ options ) ; } 
private function multiplePutRangeConcurrentAsync ( $ share , $ path , $ content , Range $ range , PutFileRangeOptions $ options = null , $ useTransactionalMD5 = false ) { $ queryParams = array ( ) ; $ headers = array ( ) ; $ path = $ this -> createPath ( $ share , $ path ) ; $ selfInstance = $ this ; if ( $ options == null ) { $ options = new PutFileRangeOptions ( ) ; } $ this -> addOptionalQueryParam ( $ queryParams , Resources :: QP_COMP , 'range' ) ; $ this -> addOptionalQueryParam ( $ queryParams , Resources :: QP_TIMEOUT , $ options -> getTimeout ( ) ) ; $ this -> addOptionalHeader ( $ headers , Resources :: X_MS_WRITE , 'Update' ) ; $ counter = 0 ; 
public function listSharesAsync ( ListSharesOptions $ options = null ) { $ method = Resources :: HTTP_GET ; $ headers = array ( ) ; $ queryParams = array ( ) ; $ postParams = array ( ) ; $ path = Resources :: EMPTY_STRING ; if ( is_null ( $ options ) ) { $ options = new ListSharesOptions ( ) ; } $ this -> addOptionalQueryParam ( $ queryParams , Resources :: QP_COMP , 'list' ) ; $ this -> addOptionalQueryParam ( $ queryParams , Resources :: QP_TIMEOUT , $ options -> getTimeout ( ) ) ; $ this -> addOptionalQueryParam ( $ queryParams , Resources :: QP_PREFIX , $ options -> getPrefix ( ) ) ; $ this -> addOptionalQueryParam ( $ queryParams , Resources :: QP_MARKER , $ options -> getNextMarker ( ) ) ; $ this -> addOptionalQueryParam ( $ queryParams , Resources :: QP_MAX_RESULTS , $ options -> getMaxResults ( ) ) ; $ isInclude = $ options -> getIncludeMetadata ( ) ; $ isInclude = $ isInclude ? 'metadata' : null ; $ this -> addOptionalQueryParam ( $ queryParams , Resources :: QP_INCLUDE , $ isInclude ) ; $ dataSerializer = $ this -> dataSerializer ; return $ this -> sendAsync ( $ method , $ headers , $ queryParams , $ postParams , $ path , Resources :: STATUS_OK , Resources :: EMPTY_STRING , $ options ) -> then ( function ( $ response ) use ( $ dataSerializer ) { $ parsed = $ dataSerializer -> unserialize ( $ response -> getBody ( ) ) ; return ListSharesResult :: create ( $ parsed , Utilities :: getLocationFromHeaders ( $ response -> getHeaders ( ) ) ) ; } ) ; } 
public function createShare ( $ share , CreateShareOptions $ options = null ) { $ this -> createShareAsync ( $ share , $ options ) -> wait ( ) ; } 
public function createShareAsync ( $ share , CreateShareOptions $ options = null ) { Validate :: canCastAsString ( $ share , 'share' ) ; Validate :: notNullOrEmpty ( $ share , 'share' ) ; $ method = Resources :: HTTP_PUT ; $ postParams = array ( ) ; $ queryParams = array ( Resources :: QP_REST_TYPE => 'share' ) ; $ path = $ this -> createPath ( $ share ) ; if ( is_null ( $ options ) ) { $ options = new CreateShareOptions ( ) ; } $ metadata = $ options -> getMetadata ( ) ; $ headers = $ this -> generateMetadataHeaders ( $ metadata ) ; $ this -> addOptionalHeader ( $ headers , Resources :: X_MS_SHARE_QUOTA , $ options -> getQuota ( ) ) ; $ this -> addOptionalQueryParam ( $ queryParams , Resources :: QP_TIMEOUT , $ options -> getTimeout ( ) ) ; return $ this -> sendAsync ( $ method , $ headers , $ queryParams , $ postParams , $ path , Resources :: STATUS_CREATED , Resources :: EMPTY_STRING , $ options ) ; } 
public function deleteShare ( $ share , FileServiceOptions $ options = null ) { $ this -> deleteShareAsync ( $ share , $ options ) -> wait ( ) ; } 
public function getShareProperties ( $ share , FileServiceOptions $ options = null ) { return $ this -> getSharePropertiesAsync ( $ share , $ options ) -> wait ( ) ; } 
public function setShareProperties ( $ share , $ quota , FileServiceOptions $ options = null ) { $ this -> setSharePropertiesAsync ( $ share , $ quota , $ options ) -> wait ( ) ; } 
public function setSharePropertiesAsync ( $ share , $ quota , FileServiceOptions $ options = null ) { return $ this -> setSharePropertiesAsyncImpl ( $ share , [ Resources :: X_MS_SHARE_QUOTA => $ quota ] , $ options , 'properties' ) ; } 
public function getShareMetadata ( $ share , FileServiceOptions $ options = null ) { return $ this -> getShareMetadataAsync ( $ share , $ options ) -> wait ( ) ; } 
public function setShareMetadata ( $ share , array $ metadata , FileServiceOptions $ options = null ) { $ this -> setShareMetadataAsync ( $ share , $ metadata , $ options ) -> wait ( ) ; } 
public function setShareMetadataAsync ( $ share , array $ metadata , FileServiceOptions $ options = null ) { return $ this -> setSharePropertiesAsyncImpl ( $ share , $ metadata , $ options , 'metadata' ) ; } 
public function getShareAcl ( $ share , FileServiceOptions $ options = null ) { return $ this -> getShareAclAsync ( $ share , $ options ) -> wait ( ) ; } 
public function getShareAclAsync ( $ share , FileServiceOptions $ options = null ) { Validate :: canCastAsString ( $ share , 'share' ) ; $ method = Resources :: HTTP_GET ; $ headers = array ( ) ; $ postParams = array ( ) ; $ queryParams = array ( ) ; $ path = $ this -> createPath ( $ share ) ; if ( is_null ( $ options ) ) { $ options = new FileServiceOptions ( ) ; } $ this -> addOptionalQueryParam ( $ queryParams , Resources :: QP_REST_TYPE , 'share' ) ; $ this -> addOptionalQueryParam ( $ queryParams , Resources :: QP_COMP , 'acl' ) ; $ this -> addOptionalQueryParam ( $ queryParams , Resources :: QP_TIMEOUT , $ options -> getTimeout ( ) ) ; $ dataSerializer = $ this -> dataSerializer ; $ promise = $ this -> sendAsync ( $ method , $ headers , $ queryParams , $ postParams , $ path , Resources :: STATUS_OK , Resources :: EMPTY_STRING , $ options ) ; return $ promise -> then ( function ( $ response ) use ( $ dataSerializer ) { $ responseHeaders = HttpFormatter :: formatHeaders ( $ response -> getHeaders ( ) ) ; $ etag = Utilities :: tryGetValue ( $ responseHeaders , Resources :: ETAG ) ; $ modified = Utilities :: tryGetValue ( $ responseHeaders , Resources :: LAST_MODIFIED ) ; $ modifiedDate = Utilities :: convertToDateTime ( $ modified ) ; $ parsed = $ dataSerializer -> unserialize ( $ response -> getBody ( ) ) ; return GetShareAclResult :: create ( $ etag , $ modifiedDate , $ parsed ) ; } , null ) ; } 
public function setShareAcl ( $ share , ShareACL $ acl , FileServiceOptions $ options = null ) { $ this -> setShareAclAsync ( $ share , $ acl , $ options ) -> wait ( ) ; } 
public function setShareAclAsync ( $ share , ShareACL $ acl , FileServiceOptions $ options = null ) { Validate :: canCastAsString ( $ share , 'share' ) ; Validate :: notNullOrEmpty ( $ acl , 'acl' ) ; $ method = Resources :: HTTP_PUT ; $ headers = array ( ) ; $ postParams = array ( ) ; $ queryParams = array ( ) ; $ path = $ this -> createPath ( $ share ) ; $ body = $ acl -> toXml ( $ this -> dataSerializer ) ; if ( is_null ( $ options ) ) { $ options = new FileServiceOptions ( ) ; } $ this -> addOptionalQueryParam ( $ queryParams , Resources :: QP_REST_TYPE , 'share' ) ; $ this -> addOptionalQueryParam ( $ queryParams , Resources :: QP_COMP , 'acl' ) ; $ this -> addOptionalQueryParam ( $ queryParams , Resources :: QP_TIMEOUT , $ options -> getTimeout ( ) ) ; $ this -> addOptionalHeader ( $ headers , Resources :: CONTENT_TYPE , Resources :: URL_ENCODED_CONTENT_TYPE ) ; return $ this -> sendAsync ( $ method , $ headers , $ queryParams , $ postParams , $ path , Resources :: STATUS_OK , $ body , $ options ) ; } 
public function getShareStats ( $ share , FileServiceOptions $ options = null ) { return $ this -> getShareStatsAsync ( $ share , $ options ) -> wait ( ) ; } 
public function getShareStatsAsync ( $ share , FileServiceOptions $ options = null ) { Validate :: canCastAsString ( $ share , 'share' ) ; $ method = Resources :: HTTP_GET ; $ headers = array ( ) ; $ queryParams = array ( ) ; $ postParams = array ( ) ; $ path = $ this -> createPath ( $ share ) ; if ( is_null ( $ options ) ) { $ options = new FileServiceOptions ( ) ; } $ this -> addOptionalQueryParam ( $ queryParams , Resources :: QP_REST_TYPE , 'share' ) ; $ this -> addOptionalQueryParam ( $ queryParams , Resources :: QP_COMP , 'stats' ) ; $ this -> addOptionalQueryParam ( $ queryParams , Resources :: QP_TIMEOUT , $ options -> getTimeout ( ) ) ; $ dataSerializer = $ this -> dataSerializer ; return $ this -> sendAsync ( $ method , $ headers , $ queryParams , $ postParams , $ path , Resources :: STATUS_OK , Resources :: EMPTY_STRING , $ options ) -> then ( function ( $ response ) use ( $ dataSerializer ) { $ parsed = $ dataSerializer -> unserialize ( $ response -> getBody ( ) ) ; return GetShareStatsResult :: create ( $ parsed ) ; } , null ) ; } 
public function listDirectoriesAndFiles ( $ share , $ path = '' , ListDirectoriesAndFilesOptions $ options = null ) { return $ this -> listDirectoriesAndFilesAsync ( $ share , $ path , $ options ) -> wait ( ) ; } 
public function listDirectoriesAndFilesAsync ( $ share , $ path = '' , ListDirectoriesAndFilesOptions $ options = null ) { Validate :: notNull ( $ share , 'share' ) ; Validate :: canCastAsString ( $ share , 'share' ) ; Validate :: canCastAsString ( $ path , 'path' ) ; $ method = Resources :: HTTP_GET ; $ headers = array ( ) ; $ postParams = array ( ) ; $ queryParams = array ( ) ; $ path = $ this -> createPath ( $ share , $ path ) ; if ( is_null ( $ options ) ) { $ options = new ListDirectoriesAndFilesOptions ( ) ; } $ this -> addOptionalQueryParam ( $ queryParams , Resources :: QP_REST_TYPE , 'directory' ) ; $ this -> addOptionalQueryParam ( $ queryParams , Resources :: QP_COMP , 'list' ) ; $ this -> addOptionalQueryParam ( $ queryParams , Resources :: QP_PREFIX , $ options -> getPrefix ( ) ) ; $ this -> addOptionalQueryParam ( $ queryParams , Resources :: QP_MARKER , $ options -> getNextMarker ( ) ) ; $ this -> addOptionalQueryParam ( $ queryParams , Resources :: QP_MAX_RESULTS , $ options -> getMaxResults ( ) ) ; $ this -> addOptionalQueryParam ( $ queryParams , Resources :: QP_TIMEOUT , $ options -> getTimeout ( ) ) ; $ dataSerializer = $ this -> dataSerializer ; return $ this -> sendAsync ( $ method , $ headers , $ queryParams , $ postParams , $ path , Resources :: STATUS_OK , Resources :: EMPTY_STRING , $ options ) -> then ( function ( $ response ) use ( $ dataSerializer ) { $ parsed = $ dataSerializer -> unserialize ( $ response -> getBody ( ) ) ; return ListDirectoriesAndFilesResult :: create ( $ parsed , Utilities :: getLocationFromHeaders ( $ response -> getHeaders ( ) ) ) ; } , null ) ; } 
public function createDirectory ( $ share , $ path , CreateDirectoryOptions $ options = null ) { $ this -> createDirectoryAsync ( $ share , $ path , $ options ) -> wait ( ) ; } 
public function createDirectoryAsync ( $ share , $ path , CreateDirectoryOptions $ options = null ) { Validate :: canCastAsString ( $ share , 'share' ) ; Validate :: canCastAsString ( $ path , 'path' ) ; Validate :: notNullOrEmpty ( $ path , 'path' ) ; $ method = Resources :: HTTP_PUT ; $ postParams = array ( ) ; $ queryParams = array ( Resources :: QP_REST_TYPE => 'directory' ) ; $ path = $ this -> createPath ( $ share , $ path ) ; if ( is_null ( $ options ) ) { $ options = new CreateDirectoryOptions ( ) ; } $ this -> addOptionalQueryParam ( $ queryParams , Resources :: QP_TIMEOUT , $ options -> getTimeout ( ) ) ; $ metadata = $ options -> getMetadata ( ) ; $ headers = $ this -> generateMetadataHeaders ( $ metadata ) ; return $ this -> sendAsync ( $ method , $ headers , $ queryParams , $ postParams , $ path , Resources :: STATUS_CREATED , Resources :: EMPTY_STRING , $ options ) ; } 
public function deleteDirectory ( $ share , $ path , FileServiceOptions $ options = null ) { $ this -> deleteDirectoryAsync ( $ share , $ path , $ options ) -> wait ( ) ; } 
public function getDirectoryProperties ( $ share , $ path , FileServiceOptions $ options = null ) { return $ this -> getDirectoryPropertiesAsync ( $ share , $ path , $ options ) -> wait ( ) ; } 
public function getDirectoryPropertiesAsync ( $ share , $ path , FileServiceOptions $ options = null ) { Validate :: canCastAsString ( $ share , 'share' ) ; Validate :: canCastAsString ( $ path , 'path' ) ; $ method = Resources :: HTTP_GET ; $ headers = array ( ) ; $ postParams = array ( ) ; $ queryParams = array ( Resources :: QP_REST_TYPE => 'directory' ) ; $ path = $ this -> createPath ( $ share , $ path ) ; if ( is_null ( $ options ) ) { $ options = new FileServiceOptions ( ) ; } $ this -> addOptionalQueryParam ( $ queryParams , Resources :: QP_TIMEOUT , $ options -> getTimeout ( ) ) ; return $ this -> sendAsync ( $ method , $ headers , $ queryParams , $ postParams , $ path , Resources :: STATUS_OK , Resources :: EMPTY_STRING , $ options ) -> then ( function ( $ response ) { $ parsed = HttpFormatter :: formatHeaders ( $ response -> getHeaders ( ) ) ; return GetDirectoryPropertiesResult :: create ( $ parsed ) ; } , null ) ; } 
public function getDirectoryMetadata ( $ share , $ path , FileServiceOptions $ options = null ) { return $ this -> getDirectoryMetadataAsync ( $ share , $ path , $ options ) -> wait ( ) ; } 
public function setDirectoryMetadata ( $ share , $ path , array $ metadata , FileServiceOptions $ options = null ) { $ this -> setDirectoryMetadataAsync ( $ share , $ path , $ metadata , $ options ) -> wait ( ) ; } 
public function createFile ( $ share , $ path , $ size , CreateFileOptions $ options = null ) { return $ this -> createFileAsync ( $ share , $ path , $ size , $ options ) -> wait ( ) ; } 
public function createFileAsync ( $ share , $ path , $ size , CreateFileOptions $ options = null ) { Validate :: canCastAsString ( $ share , 'share' ) ; Validate :: notNullOrEmpty ( $ share , 'share' ) ; Validate :: canCastAsString ( $ path , 'path' ) ; Validate :: notNullOrEmpty ( $ path , 'path' ) ; Validate :: isInteger ( $ size , 'size' ) ; $ method = Resources :: HTTP_PUT ; $ postParams = array ( ) ; $ queryParams = array ( ) ; $ path = $ this -> createPath ( $ share , $ path ) ; if ( is_null ( $ options ) ) { $ options = new CreateFileOptions ( ) ; } Utilities :: validateMetadata ( $ options -> getMetadata ( ) ) ; $ headers = $ this -> generateMetadataHeaders ( $ options -> getMetadata ( ) ) ; $ this -> addOptionalHeader ( $ headers , Resources :: X_MS_TYPE , 'file' ) ; $ this -> addOptionalQueryParam ( $ queryParams , Resources :: QP_TIMEOUT , $ options -> getTimeout ( ) ) ; $ this -> addOptionalHeader ( $ headers , Resources :: X_MS_CONTENT_LENGTH , $ size ) ; $ this -> addOptionalHeader ( $ headers , Resources :: CONTENT_TYPE , $ options -> getContentType ( ) ) ; $ this -> addOptionalHeader ( $ headers , Resources :: CONTENT_ENCODING , $ options -> getContentEncoding ( ) ) ; $ this -> addOptionalHeader ( $ headers , Resources :: CONTENT_LANGUAGE , $ options -> getContentLanguage ( ) ) ; $ this -> addOptionalHeader ( $ headers , Resources :: CACHE_CONTROL , $ options -> getCacheControl ( ) ) ; $ this -> addOptionalHeader ( $ headers , Resources :: FILE_CONTENT_MD5 , $ options -> getContentMD5 ( ) ) ; $ this -> addOptionalHeader ( $ headers , Resources :: CONTENT_DISPOSITION , $ options -> getContentDisposition ( ) ) ; $ this -> addOptionalHeader ( $ headers , Resources :: CONTENT_DISPOSITION , $ options -> getContentDisposition ( ) ) ; return $ this -> sendAsync ( $ method , $ headers , $ queryParams , $ postParams , $ path , Resources :: STATUS_CREATED , Resources :: EMPTY_STRING , $ options ) ; } 
public function deleteFile ( $ share , $ path , FileServiceOptions $ options = null ) { $ this -> deleteFileAsync ( $ share , $ path , $ options ) -> wait ( ) ; } 
public function deleteFileAsync ( $ share , $ path , FileServiceOptions $ options = null ) { Validate :: canCastAsString ( $ share , 'share' ) ; Validate :: canCastAsString ( $ path , 'path' ) ; $ method = Resources :: HTTP_DELETE ; $ headers = array ( ) ; $ postParams = array ( ) ; $ queryParams = array ( ) ; $ path = $ this -> createPath ( $ share , $ path ) ; if ( is_null ( $ options ) ) { $ options = new FileServiceOptions ( ) ; } $ this -> addOptionalQueryParam ( $ queryParams , Resources :: QP_TIMEOUT , $ options -> getTimeout ( ) ) ; return $ this -> sendAsync ( $ method , $ headers , $ queryParams , $ postParams , $ path , Resources :: STATUS_ACCEPTED , Resources :: EMPTY_STRING , $ options ) ; } 
public function getFile ( $ share , $ path , GetFileOptions $ options = null ) { return $ this -> getFileAsync ( $ share , $ path , $ options ) -> wait ( ) ; } 
public function getFileAsync ( $ share , $ path , GetFileOptions $ options = null ) { Validate :: canCastAsString ( $ share , 'share' ) ; Validate :: canCastAsString ( $ path , 'path' ) ; $ method = Resources :: HTTP_GET ; $ headers = array ( ) ; $ postParams = array ( ) ; $ queryParams = array ( ) ; $ path = $ this -> createPath ( $ share , $ path ) ; if ( is_null ( $ options ) ) { $ options = new GetFileOptions ( ) ; } $ this -> addOptionalQueryParam ( $ queryParams , Resources :: QP_TIMEOUT , $ options -> getTimeout ( ) ) ; $ this -> addOptionalHeader ( $ headers , Resources :: X_MS_RANGE , $ options -> getRangeString ( ) == '' ? null : $ options -> getRangeString ( ) ) ; $ this -> addOptionalHeader ( $ headers , Resources :: X_MS_RANGE_GET_CONTENT_MD5 , $ options -> getRangeGetContentMD5 ( ) ? 'true' : null ) ; $ options -> setIsStreaming ( true ) ; return $ this -> sendAsync ( $ method , $ headers , $ queryParams , $ postParams , $ path , array ( Resources :: STATUS_OK , Resources :: STATUS_PARTIAL_CONTENT ) , Resources :: EMPTY_STRING , $ options ) -> then ( function ( $ response ) { $ metadata = Utilities :: getMetadataArray ( HttpFormatter :: formatHeaders ( $ response -> getHeaders ( ) ) ) ; return GetFileResult :: create ( HttpFormatter :: formatHeaders ( $ response -> getHeaders ( ) ) , $ response -> getBody ( ) , $ metadata ) ; } ) ; } 
public function getFileProperties ( $ share , $ path , FileServiceOptions $ options = null ) { return $ this -> getFilePropertiesAsync ( $ share , $ path , $ options ) -> wait ( ) ; } 
public function getFilePropertiesAsync ( $ share , $ path , FileServiceOptions $ options = null ) { Validate :: canCastAsString ( $ share , 'share' ) ; Validate :: canCastAsString ( $ path , 'path' ) ; $ method = Resources :: HTTP_HEAD ; $ headers = array ( ) ; $ queryParams = array ( ) ; $ postParams = array ( ) ; $ path = $ this -> createPath ( $ share , $ path ) ; if ( is_null ( $ options ) ) { $ options = new FileServiceOptions ( ) ; } $ this -> addOptionalQueryParam ( $ queryParams , Resources :: QP_TIMEOUT , $ options -> getTimeout ( ) ) ; return $ this -> sendAsync ( $ method , $ headers , $ queryParams , $ postParams , $ path , Resources :: STATUS_OK , Resources :: EMPTY_STRING , $ options ) -> then ( function ( $ response ) { $ parsed = HttpFormatter :: formatHeaders ( $ response -> getHeaders ( ) ) ; return FileProperties :: createFromHttpHeaders ( $ parsed ) ; } , null ) ; } 
public function setFileProperties ( $ share , $ path , FileProperties $ properties , FileServiceOptions $ options = null ) { $ this -> setFilePropertiesAsync ( $ share , $ path , $ properties , $ options ) -> wait ( ) ; } 
public function setFilePropertiesAsync ( $ share , $ path , FileProperties $ properties , FileServiceOptions $ options = null ) { Validate :: canCastAsString ( $ share , 'share' ) ; Validate :: canCastAsString ( $ path , 'path' ) ; $ headers = array ( ) ; $ method = Resources :: HTTP_PUT ; $ postParams = array ( ) ; $ queryParams = array ( Resources :: QP_COMP => 'properties' ) ; $ path = $ this -> createPath ( $ share , $ path ) ; if ( is_null ( $ options ) ) { $ options = new FileServiceOptions ( ) ; } $ this -> addOptionalQueryParam ( $ queryParams , Resources :: QP_TIMEOUT , $ options -> getTimeout ( ) ) ; $ this -> addOptionalHeader ( $ headers , Resources :: X_MS_CACHE_CONTROL , $ properties -> getCacheControl ( ) ) ; $ this -> addOptionalHeader ( $ headers , Resources :: X_MS_CONTENT_TYPE , $ properties -> getContentType ( ) ) ; $ this -> addOptionalHeader ( $ headers , Resources :: X_MS_CONTENT_MD5 , $ properties -> getContentMD5 ( ) ) ; $ this -> addOptionalHeader ( $ headers , Resources :: X_MS_CONTENT_ENCODING , $ properties -> getContentEncoding ( ) ) ; $ this -> addOptionalHeader ( $ headers , Resources :: X_MS_CONTENT_LANGUAGE , $ properties -> getContentLanguage ( ) ) ; $ this -> addOptionalHeader ( $ headers , Resources :: X_MS_CONTENT_DISPOSITION , $ properties -> getContentDisposition ( ) ) ; $ this -> addOptionalHeader ( $ headers , Resources :: X_MS_CONTENT_LENGTH , $ properties -> getContentLength ( ) ) ; return $ this -> sendAsync ( $ method , $ headers , $ queryParams , $ postParams , $ path , Resources :: STATUS_OK , Resources :: EMPTY_STRING , $ options ) ; } 
public function getFileMetadata ( $ share , $ path , FileServiceOptions $ options = null ) { return $ this -> getFileMetadataAsync ( $ share , $ path , $ options ) -> wait ( ) ; } 
public function setFileMetadata ( $ share , $ path , array $ metadata , FileServiceOptions $ options = null ) { return $ this -> setFileMetadataAsync ( $ share , $ path , $ metadata , $ options ) -> wait ( ) ; } 
public function setFileMetadataAsync ( $ share , $ path , array $ metadata , FileServiceOptions $ options = null ) { Validate :: canCastAsString ( $ share , 'share' ) ; Validate :: canCastAsString ( $ path , 'path' ) ; $ method = Resources :: HTTP_PUT ; $ postParams = array ( ) ; $ queryParams = array ( ) ; $ path = $ this -> createPath ( $ share , $ path ) ; Utilities :: validateMetadata ( $ metadata ) ; $ headers = $ this -> generateMetadataHeaders ( $ metadata ) ; if ( is_null ( $ options ) ) { $ options = new FileServiceOptions ( ) ; } $ this -> addOptionalQueryParam ( $ queryParams , Resources :: QP_COMP , 'metadata' ) ; $ this -> addOptionalQueryParam ( $ queryParams , Resources :: QP_TIMEOUT , $ options -> getTimeout ( ) ) ; return $ this -> sendAsync ( $ method , $ headers , $ queryParams , $ postParams , $ path , Resources :: STATUS_OK , Resources :: EMPTY_STRING , $ options ) ; } 
public function putFileRange ( $ share , $ path , $ content , Range $ range , PutFileRangeOptions $ options = null ) { $ this -> putFileRangeAsync ( $ share , $ path , $ content , $ range , $ options ) -> wait ( ) ; } 
public function putFileRangeAsync ( $ share , $ path , $ content , Range $ range , PutFileRangeOptions $ options = null ) { Validate :: canCastAsString ( $ share , 'share' ) ; Validate :: canCastAsString ( $ path , 'path' ) ; Validate :: notNullOrEmpty ( $ path , 'path' ) ; Validate :: notNullOrEmpty ( $ share , 'share' ) ; Validate :: notNull ( $ range -> getLength ( ) , Resources :: RESOURCE_RANGE_LENGTH_MUST_SET ) ; $ stream = Psr7 \ stream_for ( $ content ) ; $ method = Resources :: HTTP_PUT ; $ headers = array ( ) ; $ queryParams = array ( ) ; $ postParams = array ( ) ; $ path = $ this -> createPath ( $ share , $ path ) ; if ( $ options == null ) { $ options = new PutFileRangeOptions ( ) ; } $ this -> addOptionalQueryParam ( $ queryParams , Resources :: QP_TIMEOUT , $ options -> getTimeout ( ) ) ; $ this -> addOptionalHeader ( $ headers , Resources :: X_MS_RANGE , $ range -> getRangeString ( ) ) ; $ this -> addOptionalHeader ( $ headers , Resources :: CONTENT_LENGTH , $ range -> getLength ( ) ) ; $ this -> addOptionalHeader ( $ headers , Resources :: X_MS_WRITE , 'Update' ) ; $ this -> addOptionalHeader ( $ headers , Resources :: CONTENT_MD5 , $ options -> getContentMD5 ( ) ) ; $ this -> addOptionalQueryParam ( $ queryParams , Resources :: QP_COMP , 'range' ) ; return $ this -> sendAsync ( $ method , $ headers , $ queryParams , $ postParams , $ path , Resources :: STATUS_CREATED , $ stream , $ options ) ; } 
public function createFileFromContent ( $ share , $ path , $ content , CreateFileFromContentOptions $ options = null ) { $ this -> createFileFromContentAsync ( $ share , $ path , $ content , $ options ) -> wait ( ) ; } 
public function createFileFromContentAsync ( $ share , $ path , $ content , CreateFileFromContentOptions $ options = null ) { $ stream = Psr7 \ stream_for ( $ content ) ; $ size = $ stream -> getSize ( ) ; if ( $ options == null ) { $ options = new CreateFileFromContentOptions ( ) ; } 
public function clearFileRange ( $ share , $ path , Range $ range , FileServiceOptions $ options = null ) { $ this -> clearFileRangeAsync ( $ share , $ path , $ range , $ options ) -> wait ( ) ; } 
public function clearFileRangeAsync ( $ share , $ path , Range $ range , FileServiceOptions $ options = null ) { Validate :: canCastAsString ( $ share , 'share' ) ; Validate :: canCastAsString ( $ path , 'path' ) ; Validate :: notNullOrEmpty ( $ path , 'path' ) ; Validate :: notNullOrEmpty ( $ share , 'share' ) ; $ method = Resources :: HTTP_PUT ; $ headers = array ( ) ; $ queryParams = array ( ) ; $ postParams = array ( ) ; $ path = $ this -> createPath ( $ share , $ path ) ; if ( is_null ( $ options ) ) { $ options = new FileServiceOptions ( ) ; } $ this -> addOptionalHeader ( $ headers , Resources :: X_MS_RANGE , $ range -> getRangeString ( ) ) ; $ this -> addOptionalQueryParam ( $ queryParams , Resources :: QP_TIMEOUT , $ options -> getTimeout ( ) ) ; $ this -> addOptionalHeader ( $ headers , Resources :: X_MS_WRITE , 'Clear' ) ; $ this -> addOptionalQueryParam ( $ queryParams , Resources :: QP_COMP , 'range' ) ; return $ this -> sendAsync ( $ method , $ headers , $ queryParams , $ postParams , $ path , Resources :: STATUS_CREATED , Resources :: EMPTY_STRING , $ options ) ; } 
public function listFileRange ( $ share , $ path , Range $ range = null , FileServiceOptions $ options = null ) { return $ this -> listFileRangeAsync ( $ share , $ path , $ range , $ options ) -> wait ( ) ; } 
public function listFileRangeAsync ( $ share , $ path , Range $ range = null , FileServiceOptions $ options = null ) { Validate :: canCastAsString ( $ share , 'share' ) ; Validate :: canCastAsString ( $ path , 'path' ) ; Validate :: notNullOrEmpty ( $ path , 'path' ) ; Validate :: notNullOrEmpty ( $ share , 'share' ) ; $ method = Resources :: HTTP_GET ; $ headers = array ( ) ; $ queryParams = array ( ) ; $ postParams = array ( ) ; $ path = $ this -> createPath ( $ share , $ path ) ; if ( is_null ( $ options ) ) { $ options = new FileServiceOptions ( ) ; } if ( $ range != null ) { $ this -> addOptionalHeader ( $ headers , Resources :: X_MS_RANGE , $ range -> getRangeString ( ) ) ; } $ this -> addOptionalQueryParam ( $ queryParams , Resources :: QP_COMP , 'rangelist' ) ; $ this -> addOptionalQueryParam ( $ queryParams , Resources :: QP_TIMEOUT , $ options -> getTimeout ( ) ) ; $ dataSerializer = $ this -> dataSerializer ; return $ this -> sendAsync ( $ method , $ headers , $ queryParams , $ postParams , $ path , Resources :: STATUS_OK , Resources :: EMPTY_STRING , $ options ) -> then ( function ( $ response ) use ( $ dataSerializer ) { $ responseHeaders = HttpFormatter :: formatHeaders ( $ response -> getHeaders ( ) ) ; $ parsed = $ dataSerializer -> unserialize ( $ response -> getBody ( ) ) ; return ListFileRangesResult :: create ( $ responseHeaders , $ parsed ) ; } , null ) ; } 
public function copyFile ( $ share , $ path , $ sourcePath , array $ metadata = array ( ) , FileServiceOptions $ options = null ) { return $ this -> copyFileAsync ( $ share , $ path , $ sourcePath , $ metadata , $ options ) -> wait ( ) ; } 
public function copyFileAsync ( $ share , $ path , $ sourcePath , array $ metadata = array ( ) , FileServiceOptions $ options = null ) { Validate :: canCastAsString ( $ share , 'share' ) ; Validate :: canCastAsString ( $ path , 'path' ) ; Validate :: canCastAsString ( $ sourcePath , 'sourcePath' ) ; Validate :: notNullOrEmpty ( $ path , 'path' ) ; Validate :: notNullOrEmpty ( $ share , 'share' ) ; Validate :: notNullOrEmpty ( $ sourcePath , 'sourcePath' ) ; $ method = Resources :: HTTP_PUT ; $ queryParams = array ( ) ; $ postParams = array ( ) ; $ path = $ this -> createPath ( $ share , $ path ) ; Utilities :: validateMetadata ( $ metadata ) ; $ headers = $ this -> generateMetadataHeaders ( $ metadata ) ; if ( is_null ( $ options ) ) { $ options = new FileServiceOptions ( ) ; } $ this -> addOptionalHeader ( $ headers , Resources :: X_MS_COPY_SOURCE , $ sourcePath ) ; $ this -> addOptionalQueryParam ( $ queryParams , Resources :: QP_TIMEOUT , $ options -> getTimeout ( ) ) ; return $ this -> sendAsync ( $ method , $ headers , $ queryParams , $ postParams , $ path , Resources :: STATUS_ACCEPTED , Resources :: EMPTY_STRING , $ options ) -> then ( function ( $ response ) { $ headers = HttpFormatter :: formatHeaders ( $ response -> getHeaders ( ) ) ; return CopyFileResult :: create ( $ headers ) ; } , null ) ; } 
public function abortCopy ( $ share , $ path , $ copyID , FileServiceOptions $ options = null ) { return $ this -> abortCopyAsync ( $ share , $ path , $ copyID , $ options ) -> wait ( ) ; } 
public function abortCopyAsync ( $ share , $ path , $ copyID , FileServiceOptions $ options = null ) { Validate :: canCastAsString ( $ share , 'share' ) ; Validate :: canCastAsString ( $ path , 'path' ) ; Validate :: canCastAsString ( $ copyID , 'copyID' ) ; Validate :: notNullOrEmpty ( $ share , 'share' ) ; Validate :: notNullOrEmpty ( $ path , 'path' ) ; Validate :: notNullOrEmpty ( $ copyID , 'copyID' ) ; $ method = Resources :: HTTP_PUT ; $ headers = array ( ) ; $ postParams = array ( ) ; $ queryParams = array ( ) ; $ path = $ this -> createPath ( $ share , $ path ) ; if ( is_null ( $ options ) ) { $ options = new FileServiceOptions ( ) ; } $ this -> addOptionalQueryParam ( $ queryParams , Resources :: QP_TIMEOUT , $ options -> getTimeout ( ) ) ; $ this -> addOptionalQueryParam ( $ queryParams , Resources :: QP_COMP , 'copy' ) ; $ this -> addOptionalQueryParam ( $ queryParams , Resources :: QP_COPY_ID , $ copyID ) ; $ this -> addOptionalHeader ( $ headers , Resources :: X_MS_COPY_ACTION , 'abort' ) ; return $ this -> sendAsync ( $ method , $ headers , $ queryParams , $ postParams , $ path , Resources :: STATUS_NO_CONTENT , Resources :: EMPTY_STRING , $ options ) ; } 
public function setType ( $ type ) { Validate :: isTrue ( BatchOperationType :: isValid ( $ type ) , Resources :: INVALID_BO_TYPE_MSG ) ; $ this -> _type = $ type ; } 
public function addParameter ( $ name , $ value ) { Validate :: isTrue ( BatchOperationParameterName :: isValid ( $ name ) , Resources :: INVALID_BO_PN_MSG ) ; $ this -> _params [ $ name ] = $ value ; } 
private static function _constructResponses ( $ body , IMimeReaderWriter $ mimeSerializer ) { $ responses = array ( ) ; $ parts = $ mimeSerializer -> decodeMimeMultipart ( $ body ) ; 
private static function _compareUsingContentId ( $ r1 , $ r2 ) { $ h1 = array_change_key_case ( $ r1 -> headers ) ; $ h2 = array_change_key_case ( $ r2 -> headers ) ; $ c1 = Utilities :: tryGetValue ( $ h1 , Resources :: CONTENT_ID , 0 ) ; $ c2 = Utilities :: tryGetValue ( $ h2 , Resources :: CONTENT_ID , 0 ) ; return intval ( $ c1 ) >= intval ( $ c2 ) ; } 
public static function create ( $ body , array $ operations , array $ contexts , IODataReaderWriter $ odataSerializer , IMimeReaderWriter $ mimeSerializer ) { $ result = new BatchResult ( ) ; $ responses = self :: _constructResponses ( $ body , $ mimeSerializer ) ; $ callbackName = __CLASS__ . '::_compareUsingContentId' ; $ count = count ( $ responses ) ; $ entries = array ( ) ; 
private function sxml2arr ( $ sxml , array $ arr = null ) { foreach ( ( array ) $ sxml as $ key => $ value ) { if ( is_object ( $ value ) || ( is_array ( $ value ) ) ) { $ arr [ $ key ] = $ this -> sxml2arr ( $ value ) ; } else { $ arr [ $ key ] = $ value ; } } return $ arr ; } 
private function arr2xml ( \ XMLWriter $ xmlw , array $ data , $ defaultTag = null ) { foreach ( $ data as $ key => $ value ) { if ( $ key === Resources :: XTAG_ATTRIBUTES ) { foreach ( $ value as $ attributeName => $ attributeValue ) { $ xmlw -> writeAttribute ( $ attributeName , $ attributeValue ) ; } } elseif ( is_array ( $ value ) ) { if ( ! is_int ( $ key ) ) { if ( $ key != Resources :: EMPTY_STRING ) { $ xmlw -> startElement ( $ key ) ; } else { $ xmlw -> startElement ( $ defaultTag ) ; } } $ this -> arr2xml ( $ xmlw , $ value ) ; if ( ! is_int ( $ key ) ) { $ xmlw -> endElement ( ) ; } } else { $ xmlw -> writeElement ( $ key , $ value ) ; } } } 
private static function getInstanceAttributes ( $ targetObject , array $ methodArray ) { foreach ( $ methodArray as $ method ) { if ( $ method -> name == 'getAttributes' ) { $ classProperty = $ method -> invoke ( $ targetObject ) ; return $ classProperty ; } } return null ; } 
public static function objectSerialize ( $ targetObject , $ rootName ) { Validate :: notNull ( $ targetObject , 'targetObject' ) ; Validate :: canCastAsString ( $ rootName , 'rootName' ) ; $ xmlWriter = new \ XmlWriter ( ) ; $ xmlWriter -> openMemory ( ) ; $ xmlWriter -> setIndent ( true ) ; $ reflectionClass = new \ ReflectionClass ( $ targetObject ) ; $ methodArray = $ reflectionClass -> getMethods ( ) ; $ attributes = self :: getInstanceAttributes ( $ targetObject , $ methodArray ) ; $ xmlWriter -> startElement ( $ rootName ) ; if ( ! is_null ( $ attributes ) ) { foreach ( array_keys ( $ attributes ) as $ attributeKey ) { $ xmlWriter -> writeAttribute ( $ attributeKey , $ attributes [ $ attributeKey ] ) ; } } foreach ( $ methodArray as $ method ) { if ( ( strpos ( $ method -> name , 'get' ) === 0 ) && $ method -> isPublic ( ) && ( $ method -> name != 'getAttributes' ) ) { $ variableName = substr ( $ method -> name , 3 ) ; $ variableValue = $ method -> invoke ( $ targetObject ) ; if ( ! empty ( $ variableValue ) ) { if ( gettype ( $ variableValue ) === 'object' ) { $ xmlWriter -> writeRaw ( XmlSerializer :: objectSerialize ( $ variableValue , $ variableName ) ) ; } else { $ xmlWriter -> writeElement ( $ variableName , $ variableValue ) ; } } } } $ xmlWriter -> endElement ( ) ; return $ xmlWriter -> outputMemory ( true ) ; } 
public function serialize ( array $ array , array $ properties = null ) { $ xmlVersion = '1.0' ; $ xmlEncoding = 'UTF-8' ; $ standalone = Utilities :: tryGetValue ( $ properties , self :: STANDALONE ) ; $ defaultTag = Utilities :: tryGetValue ( $ properties , self :: DEFAULT_TAG ) ; $ rootName = Utilities :: tryGetValue ( $ properties , self :: ROOT_NAME ) ; $ docNamespace = Utilities :: tryGetValue ( $ array , Resources :: XTAG_NAMESPACE , null ) ; if ( ! is_array ( $ array ) ) { return false ; } $ xmlw = new \ XmlWriter ( ) ; $ xmlw -> openMemory ( ) ; $ xmlw -> setIndent ( true ) ; $ xmlw -> startDocument ( $ xmlVersion , $ xmlEncoding , $ standalone ) ; if ( is_null ( $ docNamespace ) ) { $ xmlw -> startElement ( $ rootName ) ; } else { foreach ( $ docNamespace as $ uri => $ prefix ) { $ xmlw -> startElementNS ( $ prefix , $ rootName , $ uri ) ; break ; } } unset ( $ array [ Resources :: XTAG_NAMESPACE ] ) ; self :: arr2xml ( $ xmlw , $ array , $ defaultTag ) ; $ xmlw -> endElement ( ) ; return $ xmlw -> outputMemory ( true ) ; } 
public static function create ( array $ parsedResponse ) { Validate :: hasKey ( Resources :: XTAG_ALLOWED_ORIGINS , 'parsedResponse' , $ parsedResponse ) ; Validate :: hasKey ( Resources :: XTAG_ALLOWED_METHODS , 'parsedResponse' , $ parsedResponse ) ; Validate :: hasKey ( Resources :: XTAG_ALLOWED_HEADERS , 'parsedResponse' , $ parsedResponse ) ; Validate :: hasKey ( Resources :: XTAG_EXPOSED_HEADERS , 'parsedResponse' , $ parsedResponse ) ; Validate :: hasKey ( Resources :: XTAG_MAX_AGE_IN_SECONDS , 'parsedResponse' , $ parsedResponse ) ; 
public function toArray ( ) { return array ( Resources :: XTAG_ALLOWED_ORIGINS => implode ( ',' , $ this -> getAllowedOrigins ( ) ) , Resources :: XTAG_ALLOWED_METHODS => implode ( ',' , $ this -> getAllowedMethods ( ) ) , Resources :: XTAG_ALLOWED_HEADERS => implode ( ',' , $ this -> getAllowedHeaders ( ) ) , Resources :: XTAG_EXPOSED_HEADERS => implode ( ',' , $ this -> getExposedHeaders ( ) ) , Resources :: XTAG_MAX_AGE_IN_SECONDS => $ this -> getMaxedAgeInSeconds ( ) ) ; } 
public function getServicePropertiesAsync ( ServiceOptions $ options = null ) { $ method = Resources :: HTTP_GET ; $ headers = array ( ) ; $ queryParams = array ( ) ; $ postParams = array ( ) ; $ path = Resources :: EMPTY_STRING ; if ( is_null ( $ options ) ) { $ options = new ServiceOptions ( ) ; } $ this -> addOptionalQueryParam ( $ queryParams , Resources :: QP_REST_TYPE , 'service' ) ; $ this -> addOptionalQueryParam ( $ queryParams , Resources :: QP_COMP , 'properties' ) ; $ dataSerializer = $ this -> dataSerializer ; return $ this -> sendAsync ( $ method , $ headers , $ queryParams , $ postParams , $ path , Resources :: STATUS_OK , Resources :: EMPTY_STRING , $ options ) -> then ( function ( $ response ) use ( $ dataSerializer ) { $ parsed = $ dataSerializer -> unserialize ( $ response -> getBody ( ) ) ; return GetServicePropertiesResult :: create ( $ parsed ) ; } , null ) ; } 
public function setServiceProperties ( ServiceProperties $ serviceProperties , ServiceOptions $ options = null ) { $ this -> setServicePropertiesAsync ( $ serviceProperties , $ options ) -> wait ( ) ; } 
public function setServicePropertiesAsync ( ServiceProperties $ serviceProperties , ServiceOptions $ options = null ) { Validate :: isTrue ( $ serviceProperties instanceof ServiceProperties , Resources :: INVALID_SVC_PROP_MSG ) ; $ method = Resources :: HTTP_PUT ; $ headers = array ( ) ; $ queryParams = array ( ) ; $ postParams = array ( ) ; $ path = Resources :: EMPTY_STRING ; $ body = $ serviceProperties -> toXml ( $ this -> dataSerializer ) ; if ( is_null ( $ options ) ) { $ options = new ServiceOptions ( ) ; } $ this -> addOptionalQueryParam ( $ queryParams , Resources :: QP_REST_TYPE , 'service' ) ; $ this -> addOptionalQueryParam ( $ queryParams , Resources :: QP_COMP , 'properties' ) ; $ this -> addOptionalHeader ( $ headers , Resources :: CONTENT_TYPE , Resources :: URL_ENCODED_CONTENT_TYPE ) ; $ options -> setLocationMode ( LocationMode :: PRIMARY_ONLY ) ; return $ this -> sendAsync ( $ method , $ headers , $ queryParams , $ postParams , $ path , Resources :: STATUS_ACCEPTED , $ body , $ options ) ; } 
public function getServiceStatsAsync ( ServiceOptions $ options = null ) { $ method = Resources :: HTTP_GET ; $ headers = array ( ) ; $ queryParams = array ( ) ; $ postParams = array ( ) ; $ path = Resources :: EMPTY_STRING ; if ( is_null ( $ options ) ) { $ options = new ServiceOptions ( ) ; } $ this -> addOptionalQueryParam ( $ queryParams , Resources :: QP_REST_TYPE , 'service' ) ; $ this -> addOptionalQueryParam ( $ queryParams , Resources :: QP_COMP , 'stats' ) ; $ dataSerializer = $ this -> dataSerializer ; $ options -> setLocationMode ( LocationMode :: SECONDARY_ONLY ) ; return $ this -> sendAsync ( $ method , $ headers , $ queryParams , $ postParams , $ path , Resources :: STATUS_OK , Resources :: EMPTY_STRING , $ options ) -> then ( function ( $ response ) use ( $ dataSerializer ) { $ parsed = $ dataSerializer -> unserialize ( $ response -> getBody ( ) ) ; return GetServiceStatsResult :: create ( $ parsed ) ; } , null ) ; } 
public static function create ( array $ parsedResponse , $ location = '' ) { $ result = new ListQueuesResult ( ) ; $ serviceEndpoint = Utilities :: tryGetKeysChainValue ( $ parsedResponse , Resources :: XTAG_ATTRIBUTES , Resources :: XTAG_SERVICE_ENDPOINT ) ; $ result -> setAccountName ( Utilities :: tryParseAccountNameFromUrl ( $ serviceEndpoint ) ) ; $ result -> setPrefix ( Utilities :: tryGetValue ( $ parsedResponse , Resources :: QP_PREFIX ) ) ; $ result -> setMarker ( Utilities :: tryGetValue ( $ parsedResponse , Resources :: QP_MARKER ) ) ; $ nextMarker = Utilities :: tryGetValue ( $ parsedResponse , Resources :: QP_NEXT_MARKER ) ; if ( $ nextMarker != null ) { $ result -> setContinuationToken ( new MarkerContinuationToken ( $ nextMarker , $ location ) ) ; } $ result -> setMaxResults ( Utilities :: tryGetValue ( $ parsedResponse , Resources :: QP_MAX_RESULTS ) ) ; $ queues = array ( ) ; $ rawQueues = array ( ) ; if ( ! empty ( $ parsedResponse [ 'Queues' ] ) ) { $ rawQueues = Utilities :: getArray ( $ parsedResponse [ 'Queues' ] [ 'Queue' ] ) ; } foreach ( $ rawQueues as $ value ) { $ queue = new Queue ( $ value [ 'Name' ] , $ serviceEndpoint . $ value [ 'Name' ] ) ; $ metadata = Utilities :: tryGetValue ( $ value , Resources :: QP_METADATA ) ; $ queue -> setMetadata ( is_null ( $ metadata ) ? array ( ) : $ metadata ) ; $ queues [ ] = $ queue ; } $ result -> setQueues ( $ queues ) ; return $ result ; } 
protected function setQueues ( array $ queues ) { $ this -> _queues = array ( ) ; foreach ( $ queues as $ queue ) { $ this -> _queues [ ] = clone $ queue ; } } 
public static function tryGetSecondaryEndpointFromPrimaryEndpoint ( $ uri ) { $ splitTokens = explode ( '.' , $ uri ) ; if ( count ( $ splitTokens ) > 0 && $ splitTokens [ 0 ] != '' ) { $ schemaAccountToken = $ splitTokens [ 0 ] ; $ schemaAccountSplitTokens = explode ( '/' , $ schemaAccountToken ) ; if ( count ( $ schemaAccountSplitTokens ) > 0 && $ schemaAccountSplitTokens [ 0 ] != '' ) { $ accountName = $ schemaAccountSplitTokens [ count ( $ schemaAccountSplitTokens ) - 1 ] ; $ schemaAccountSplitTokens [ count ( $ schemaAccountSplitTokens ) - 1 ] = $ accountName . Resources :: SECONDARY_STRING ; $ splitTokens [ 0 ] = implode ( '/' , $ schemaAccountSplitTokens ) ; $ secondaryUri = implode ( '.' , $ splitTokens ) ; return $ secondaryUri ; } } return null ; } 
public static function addIfNotEmpty ( $ key , $ value , array & $ array ) { if ( ! is_null ( $ array ) ) { Validate :: isArray ( $ array , 'array' ) ; } if ( ! empty ( $ value ) ) { $ array [ $ key ] = $ value ; } } 
private static function _sxml2arr ( $ sxml , array $ arr = null ) { foreach ( ( array ) $ sxml as $ key => $ value ) { if ( is_object ( $ value ) || ( is_array ( $ value ) ) ) { $ arr [ $ key ] = self :: _sxml2arr ( $ value ) ; } else { $ arr [ $ key ] = $ value ; } } return $ arr ; } 
public static function serialize ( array $ array , $ rootName , $ defaultTag = null , $ standalone = null ) { $ xmlVersion = '1.0' ; $ xmlEncoding = 'UTF-8' ; if ( ! is_array ( $ array ) ) { return false ; } $ xmlw = new \ XmlWriter ( ) ; $ xmlw -> openMemory ( ) ; $ xmlw -> startDocument ( $ xmlVersion , $ xmlEncoding , $ standalone ) ; $ xmlw -> startElement ( $ rootName ) ; self :: _arr2xml ( $ xmlw , $ array , $ defaultTag ) ; $ xmlw -> endElement ( ) ; return $ xmlw -> outputMemory ( true ) ; } 
private static function _arr2xml ( \ XMLWriter $ xmlw , array $ data , $ defaultTag = null ) { foreach ( $ data as $ key => $ value ) { if ( strcmp ( $ key , '@attributes' ) == 0 ) { foreach ( $ value as $ attributeName => $ attributeValue ) { $ xmlw -> writeAttribute ( $ attributeName , $ attributeValue ) ; } } elseif ( is_array ( $ value ) ) { if ( ! is_int ( $ key ) ) { if ( $ key != Resources :: EMPTY_STRING ) { $ xmlw -> startElement ( $ key ) ; } else { $ xmlw -> startElement ( $ defaultTag ) ; } } self :: _arr2xml ( $ xmlw , $ value ) ; if ( ! is_int ( $ key ) ) { $ xmlw -> endElement ( ) ; } continue ; } else { $ xmlw -> writeElement ( $ key , $ value ) ; } } } 
public static function toBoolean ( $ obj , $ skipNull = false ) { if ( $ skipNull && is_null ( $ obj ) ) { return null ; } return filter_var ( $ obj , FILTER_VALIDATE_BOOLEAN ) ; } 
public static function rfc1123ToDateTime ( $ date ) { $ timeZone = new \ DateTimeZone ( 'GMT' ) ; $ format = Resources :: AZURE_DATE_FORMAT ; return \ DateTime :: createFromFormat ( $ format , $ date , $ timeZone ) ; } 
public static function isoDate ( \ DateTimeInterface $ date ) { $ date = clone $ date ; $ date = $ date -> setTimezone ( new \ DateTimeZone ( 'UTC' ) ) ; return str_replace ( '+00:00' , 'Z' , $ date -> format ( 'c' ) ) ; } 
public static function convertToDateTime ( $ value ) { if ( $ value instanceof \ DateTime ) { return $ value ; } if ( substr ( $ value , - 1 ) == 'Z' ) { $ value = substr ( $ value , 0 , strlen ( $ value ) - 1 ) ; } return new \ DateTime ( $ value , new \ DateTimeZone ( 'UTC' ) ) ; } 
public static function tryGetValueInsensitive ( $ key , $ haystack , $ default = null ) { $ array = array_change_key_case ( $ haystack ) ; return Utilities :: tryGetValue ( $ array , strtolower ( $ key ) , $ default ) ; } 
public static function getGuid ( ) { 
public static function endsWith ( $ haystack , $ needle , $ ignoreCase = false ) { if ( $ ignoreCase ) { $ haystack = strtolower ( $ haystack ) ; $ needle = strtolower ( $ needle ) ; } $ length = strlen ( $ needle ) ; if ( $ length == 0 ) { return true ; } return ( substr ( $ haystack , - $ length ) === $ needle ) ; } 
public static function getEntityId ( $ entity , $ type , $ method = 'getId' ) { if ( is_string ( $ entity ) ) { return $ entity ; } else { Validate :: isA ( $ entity , $ type , 'entity' ) ; Validate :: methodExists ( $ entity , $ method , $ type ) ; return $ entity -> $ method ( ) ; } } 
public static function base256ToDec ( $ number ) { Validate :: canCastAsString ( $ number , 'number' ) ; $ result = 0 ; $ base = 1 ; for ( $ i = strlen ( $ number ) - 1 ; $ i >= 0 ; $ i -- ) { $ result = bcadd ( $ result , bcmul ( ord ( $ number [ $ i ] ) , $ base ) ) ; $ base = bcmul ( $ base , 256 ) ; } return $ result ; } 
public static function isStreamLargerThanSizeOrNotSeekable ( Stream $ stream , $ size ) { Validate :: isInteger ( $ size , 'size' ) ; Validate :: isTrue ( $ stream instanceof Stream , sprintf ( Resources :: INVALID_PARAM_MSG , 'stream' , 'Guzzle\Stream' ) ) ; $ result = true ; if ( $ stream -> isSeekable ( ) ) { $ position = $ stream -> tell ( ) ; try { $ stream -> seek ( $ size ) ; } catch ( \ RuntimeException $ e ) { $ pos = strpos ( $ e -> getMessage ( ) , 'to seek to stream position ' ) ; if ( $ pos == null ) { throw $ e ; } $ result = false ; } if ( $ stream -> eof ( ) ) { $ result = false ; } elseif ( $ stream -> read ( 1 ) == '' ) { $ result = false ; } $ stream -> seek ( $ position ) ; } return $ result ; } 
public static function appendToFile ( $ path , $ content ) { $ resource = @ fopen ( $ path , 'a+' ) ; if ( $ resource != null ) { fwrite ( $ resource , $ content ) ; fclose ( $ resource ) ; } } 
public static function allZero ( $ content ) { $ size = strlen ( $ content ) ; 
public static function appendDelimiter ( $ string , $ delimiter ) { if ( ! self :: endsWith ( $ string , $ delimiter ) ) { $ string .= $ delimiter ; } return $ string ; } 
public static function requestSentToSecondary ( \ Psr \ Http \ Message \ RequestInterface $ request , array $ options ) { $ uri = $ request -> getUri ( ) ; $ secondaryUri = $ options [ Resources :: ROS_SECONDARY_URI ] ; $ isSecondary = false ; if ( strpos ( ( string ) $ uri , ( string ) $ secondaryUri ) !== false ) { $ isSecondary = true ; } return $ isSecondary ; } 
public static function getLocationFromHeaders ( array $ headers ) { $ value = Utilities :: tryGetValue ( $ headers , Resources :: X_MS_CONTINUATION_LOCATION_MODE ) ; $ result = '' ; if ( \ is_string ( $ value ) ) { $ result = $ value ; } elseif ( ! empty ( $ value ) ) { $ result = $ value [ 0 ] ; } return $ result ; } 
public static function calculateContentMD5 ( $ content ) { Validate :: notNull ( $ content , 'content' ) ; Validate :: canCastAsString ( $ content , 'content' ) ; return base64_encode ( md5 ( $ content , true ) ) ; } 
public static function create ( array $ parsedResponse = null ) { $ result = new RetentionPolicy ( ) ; $ result -> setEnabled ( Utilities :: toBoolean ( $ parsedResponse [ 'Enabled' ] ) ) ; if ( $ result -> getEnabled ( ) ) { $ result -> setDays ( intval ( $ parsedResponse [ 'Days' ] ) ) ; } return $ result ; } 
protected static function validateResourceType ( $ resourceType ) { Validate :: isTrue ( $ resourceType == Resources :: RESOURCE_TYPE_SHARE || $ resourceType == Resources :: RESOURCE_TYPE_FILE , Resources :: INVALID_RESOURCE_TYPE ) ; } 
public static function create ( array $ headers ) { $ result = new UpdateMessageResult ( ) ; $ result -> setPopReceipt ( Utilities :: tryGetValueInsensitive ( Resources :: X_MS_POPRECEIPT , $ headers ) ) ; $ timeNextVisible = Utilities :: tryGetValueInsensitive ( Resources :: X_MS_TIME_NEXT_VISIBLE , $ headers ) ; $ date = Utilities :: rfc1123ToDateTime ( $ timeNextVisible ) ; $ result -> setTimeNextVisible ( $ date ) ; return $ result ; } 
public static function create ( $ type = self :: GENERAL_RETRY_TYPE , $ numberOfRetries = Resources :: DEFAULT_NUMBER_OF_RETRIES , $ interval = Resources :: DEFAULT_RETRY_INTERVAL , $ accumulationMethod = self :: LINEAR_INTERVAL_ACCUMULATION , $ retryConnect = false ) { 
protected static function createRetryDecider ( $ type , $ maxRetries , $ retryConnect ) { return function ( $ retries , $ request , $ response = null , $ exception = null , $ isSecondary = false ) use ( $ type , $ maxRetries , $ retryConnect ) { 
protected static function generalRetryDecider ( $ statusCode , $ isSecondary ) { $ retry = false ; if ( $ statusCode == 408 ) { $ retry = true ; } elseif ( $ statusCode >= 500 ) { if ( $ statusCode != 501 && $ statusCode != 505 ) { $ retry = true ; } } elseif ( $ isSecondary && $ statusCode == 404 ) { $ retry = true ; } return $ retry ; } 
protected function addOptionalQueryParam ( array & $ queryParameters , $ key , $ value ) { Validate :: isArray ( $ queryParameters , 'queryParameters' ) ; Validate :: canCastAsString ( $ key , 'key' ) ; Validate :: canCastAsString ( $ value , 'value' ) ; if ( ! is_null ( $ value ) && Resources :: EMPTY_STRING !== $ value ) { $ queryParameters [ $ key ] = $ value ; } } 
protected function addOptionalHeader ( array & $ headers , $ key , $ value ) { Validate :: isArray ( $ headers , 'headers' ) ; Validate :: canCastAsString ( $ key , 'key' ) ; Validate :: canCastAsString ( $ value , 'value' ) ; if ( ! is_null ( $ value ) && Resources :: EMPTY_STRING !== $ value ) { $ headers [ $ key ] = $ value ; } } 
public static function create ( array $ headers , StreamInterface $ body , array $ metadata ) { $ result = new GetFileResult ( ) ; $ result -> setContentStream ( $ body -> detach ( ) ) ; $ result -> setProperties ( FileProperties :: createFromHttpHeaders ( $ headers ) ) ; $ result -> setMetadata ( is_null ( $ metadata ) ? array ( ) : $ metadata ) ; return $ result ; } 
public static function createMetadataResult ( array $ responseHeaders ) { $ result = new static ( ) ; $ metadata = Utilities :: getMetadataArray ( $ responseHeaders ) ; $ date = Utilities :: tryGetValueInsensitive ( Resources :: LAST_MODIFIED , $ responseHeaders ) ; $ date = Utilities :: rfc1123ToDateTime ( $ date ) ; $ result -> setETag ( Utilities :: tryGetValueInsensitive ( Resources :: ETAG , $ responseHeaders ) ) ; $ result -> setMetadata ( $ metadata ) ; $ result -> setLastModified ( $ date ) ; return $ result ; } 
public static function objectSerialize ( $ targetObject ) { 
private static function serializeRequest ( $ request ) { $ headers = $ request -> getHeaders ( ) ; $ version = $ request -> getProtocolVersion ( ) ; $ uri = $ request -> getUri ( ) ; $ method = $ request -> getMethod ( ) ; $ resultString = "Request:\n" ; $ resultString .= "URI: {$uri}\nHTTP Version: {$version}\nMethod: {$method}\n" ; $ resultString .= self :: serializeHeaders ( $ headers ) ; return $ resultString ; } 
private static function serializeResponse ( $ response ) { $ headers = $ response -> getHeaders ( ) ; $ version = $ response -> getProtocolVersion ( ) ; $ status = $ response -> getStatusCode ( ) ; $ reason = $ response -> getReasonPhrase ( ) ; $ resultString = "Response:\n" ; $ resultString .= "Status Code: {$status}\nReason: {$reason}\n" ; $ resultString .= "HTTP Version: {$version}\n" ; $ resultString .= self :: serializeHeaders ( $ headers ) ; return $ resultString ; } 
private static function serializeHeaders ( array $ headers ) { $ resultString = "Headers:\n" ; foreach ( $ headers as $ key => $ value ) { $ resultString .= sprintf ( "%s: %s\n" , $ key , $ value [ 0 ] ) ; } return $ resultString ; } 
private static function serializeRequestException ( RequestException $ e ) { $ resultString = sprintf ( "Reason:\n%s\n" , $ e ) ; if ( $ e -> hasResponse ( ) ) { $ resultString .= self :: serializeResponse ( $ e -> getResponse ( ) ) ; } return $ resultString ; } 
public static function create ( $ parsedResponse ) { $ result = new CreateMessageResult ( ) ; if ( ! empty ( $ parsedResponse ) && ! empty ( $ parsedResponse [ Resources :: QP_QUEUE_MESSAGE ] ) ) { $ result -> setQueueMessage ( QueueMessage :: createFromCreateMessage ( $ parsedResponse [ Resources :: QP_QUEUE_MESSAGE ] ) ) ; } return $ result ; } 
public static function create ( $ body , $ headers , $ odataSerializer ) { $ result = new InsertEntityResult ( ) ; $ entity = $ odataSerializer -> parseEntity ( $ body ) ; $ entity -> setETag ( Utilities :: tryGetValue ( $ headers , Resources :: ETAG ) ) ; $ result -> setEntity ( $ entity ) ; return $ result ; } 
public static function create ( array $ headers , array $ entities ) { $ result = new QueryEntitiesResult ( ) ; $ headers = array_change_key_case ( $ headers ) ; $ nextPK = Utilities :: tryGetValue ( $ headers , Resources :: X_MS_CONTINUATION_NEXTPARTITIONKEY ) ; $ nextRK = Utilities :: tryGetValue ( $ headers , Resources :: X_MS_CONTINUATION_NEXTROWKEY ) ; if ( $ nextRK != null && $ nextPK != null ) { $ result -> setContinuationToken ( new TableContinuationToken ( '' , $ nextPK , $ nextRK , Utilities :: getLocationFromHeaders ( $ headers ) ) ) ; } $ result -> setEntities ( $ entities ) ; return $ result ; } 
public static function formatHeaders ( array $ headers ) { $ result = array ( ) ; foreach ( $ headers as $ key => $ value ) { if ( is_array ( $ value ) && count ( $ value ) == 1 ) { $ result [ strtolower ( $ key ) ] = $ value [ 0 ] ; } else { $ result [ strtolower ( $ key ) ] = $ value ; } } return $ result ; } 
public static function create ( array $ parsedResponse ) { $ result = new GetServicePropertiesResult ( ) ; $ result -> setValue ( ServiceProperties :: create ( $ parsedResponse ) ) ; return $ result ; } 
public static function create ( array $ parsed ) { $ result = new File ( ) ; $ name = Utilities :: tryGetValue ( $ parsed , Resources :: QP_NAME ) ; $ result -> setName ( $ name ) ; $ properties = Utilities :: tryGetValue ( $ parsed , Resources :: QP_PROPERTIES ) ; $ length = \ intval ( Utilities :: tryGetValue ( $ properties , Resources :: QP_CONTENT_LENGTH ) ) ; $ result -> setLength ( $ length ) ; return $ result ; } 
public function apply ( callable $ handler ) { $ result = $ handler ; foreach ( $ this -> middlewares as $ middleware ) { $ result = $ middleware ( $ result ) ; } return $ result ; } 
public function getAvailableIncludes ( ) { if ( $ this -> relations == [ '*' ] ) { return $ this -> resolveScopedIncludes ( $ this -> getCurrentScope ( ) ) ; } return array_keys ( $ this -> normalizeRelations ( $ this -> relations ) ) ; } 
protected function callIncludeMethod ( Scope $ scope , $ identifier , $ data ) { $ parameters = iterator_to_array ( $ scope -> getManager ( ) -> getIncludeParams ( $ scope -> getIdentifier ( $ identifier ) ) ) ; return $ this -> includeResource ( $ identifier , $ data , $ parameters ) ; } 
protected function resolveScopedIncludes ( Scope $ scope ) : array { $ level = count ( $ scope -> getParentScopes ( ) ) ; $ includes = $ scope -> getManager ( ) -> getRequestedIncludes ( ) ; return collect ( $ includes ) -> map ( function ( $ include ) { return explode ( '.' , $ include ) ; } ) -> filter ( function ( $ include ) use ( $ level ) { return count ( $ include ) > $ level ; } ) -> pluck ( $ level ) -> unique ( ) -> all ( ) ; } 
public function error ( $ errorCode = null , string $ message = null ) { $ this -> errorCode = $ errorCode ; $ this -> message = $ message ; return $ this ; } 
public function data ( array $ data = null ) { $ this -> data = array_merge ( ( array ) $ this -> data , ( array ) $ data ) ; return $ this ; } 
public function serializer ( $ serializer ) { if ( is_string ( $ serializer ) ) { $ serializer = new $ serializer ; } if ( ! $ serializer instanceof ErrorSerializer ) { throw new InvalidErrorSerializerException ; } $ this -> serializer = $ serializer ; return $ this ; } 
protected function getOutput ( ) : array { return $ this -> errorFactory -> make ( $ this -> serializer , $ this -> errorCode , $ this -> message , $ this -> data ) ; } 
public function resource ( $ data = null , $ transformer = null , string $ resourceKey = null ) { $ this -> resource = $ this -> resourceFactory -> make ( $ data , $ transformer , $ resourceKey ) ; if ( $ data instanceof CursorPaginator ) { $ this -> cursor ( $ this -> paginatorFactory -> makeCursor ( $ data ) ) ; } elseif ( $ data instanceof LengthAwarePaginator ) { $ this -> paginator ( $ this -> paginatorFactory -> make ( $ data ) ) ; } return $ this ; } 
public function cursor ( Cursor $ cursor ) { if ( $ this -> resource instanceof CollectionResource ) { $ this -> resource -> setCursor ( $ cursor ) ; } return $ this ; } 
public function paginator ( IlluminatePaginatorAdapter $ paginator ) { if ( $ this -> resource instanceof CollectionResource ) { $ this -> resource -> setPaginator ( $ paginator ) ; } return $ this ; } 
public function with ( $ relations ) { $ relations = is_array ( $ relations ) ? $ relations : func_get_args ( ) ; foreach ( $ relations as $ relation => $ constraint ) { if ( is_numeric ( $ relation ) ) { $ relation = $ constraint ; $ constraint = null ; } $ this -> with = array_merge ( $ this -> with , [ $ relation => $ constraint ] ) ; } return $ this ; } 
public function without ( $ relations ) { $ this -> without = array_merge ( $ this -> without , is_array ( $ relations ) ? $ relations : func_get_args ( ) ) ; return $ this ; } 
public function only ( $ fields ) { $ this -> only = array_merge ( $ this -> only , is_array ( $ fields ) ? $ fields : func_get_args ( ) ) ; return $ this ; } 
public function serializer ( $ serializer ) { if ( is_string ( $ serializer ) ) { $ serializer = new $ serializer ; } if ( ! $ serializer instanceof SerializerAbstract ) { throw new InvalidSuccessSerializerException ; } $ this -> serializer = $ serializer ; return $ this ; } 
public function transform ( ) { $ this -> prepareRelations ( $ this -> resource -> getData ( ) , $ this -> resource -> getTransformer ( ) ) ; return $ this -> transformFactory -> make ( $ this -> resource ? : new NullResource , $ this -> serializer , [ 'includes' => $ this -> with , 'excludes' => $ this -> without , 'fieldsets' => $ this -> only , ] ) ; } 
protected function prepareRelations ( $ data , $ transformer ) { if ( $ transformer instanceof Transformer ) { $ relations = $ transformer -> relations ( $ this -> with ) ; $ defaultRelations = $ this -> removeExcludedRelations ( $ transformer -> defaultRelations ( $ this -> with ) ) ; $ this -> with = array_merge ( $ relations , $ defaultRelations ) ; } if ( $ data instanceof Model || $ data instanceof Collection ) { $ this -> eagerLoadRelations ( $ data , $ this -> with , $ transformer ) ; } $ this -> with = array_keys ( $ this -> with ) ; } 
protected function removeExcludedRelations ( array $ relations ) : array { return array_filter ( $ relations , function ( $ relation ) { return ! in_array ( $ this -> stripParametersFromRelation ( $ relation ) , $ this -> without ) ; } , ARRAY_FILTER_USE_KEY ) ; } 
protected function eagerLoadRelations ( $ data , array $ requested , $ transformer ) { $ relations = collect ( array_keys ( $ requested ) ) -> reduce ( function ( $ eagerLoads , $ relation ) use ( $ requested , $ transformer ) { $ identifier = camel_case ( $ this -> stripParametersFromRelation ( $ relation ) ) ; if ( method_exists ( $ transformer , 'include' . ucfirst ( $ identifier ) ) ) { return $ eagerLoads ; } return array_merge ( $ eagerLoads , [ $ identifier => $ requested [ $ relation ] ? : function ( ) { } ] ) ; } , [ ] ) ; $ data -> load ( $ relations ) ; } 
public function make ( LengthAwarePaginator $ paginator ) : PaginatorInterface { $ paginator -> appends ( $ this -> parameters ) ; return new IlluminatePaginatorAdapter ( $ paginator ) ; } 
public function makeCursor ( CursorPaginator $ paginator ) : Cursor { return new Cursor ( $ paginator -> cursor ( ) , $ paginator -> previous ( ) , $ paginator -> next ( ) , $ paginator -> get ( ) -> count ( ) ) ; } 
public function paginator ( PaginatorInterface $ paginator ) { $ pagination = parent :: paginator ( $ paginator ) [ 'pagination' ] ; return [ 'pagination' => [ 'count' => $ pagination [ 'count' ] , 'total' => $ pagination [ 'total' ] , 'perPage' => $ pagination [ 'per_page' ] , 'currentPage' => $ pagination [ 'current_page' ] , 'totalPages' => $ pagination [ 'total_pages' ] , 'links' => $ pagination [ 'links' ] , ] , ] ; } 
public function cursor ( CursorInterface $ cursor ) { return [ 'cursor' => [ 'current' => $ cursor -> getCurrent ( ) , 'previous' => $ cursor -> getPrev ( ) , 'next' => $ cursor -> getNext ( ) , 'count' => ( int ) $ cursor -> getCount ( ) , ] , ] ; } 
public function mergeIncludes ( $ transformedData , $ includedData ) { foreach ( array_keys ( $ includedData ) as $ key ) { $ includedData [ $ key ] = $ includedData [ $ key ] [ 'data' ] ; } return array_merge ( $ transformedData , $ includedData ) ; } 
public function bind ( $ transformable , string $ resourceKey ) { $ this -> bindings = array_merge ( $ this -> bindings , is_array ( $ transformable ) ? $ transformable : [ $ transformable => $ resourceKey , ] ) ; } 
public function resolve ( $ data ) { $ transformable = $ this -> resolveTransformableItem ( $ data ) ; if ( is_object ( $ transformable ) && key_exists ( get_class ( $ transformable ) , $ this -> bindings ) ) { return $ this -> bindings [ get_class ( $ transformable ) ] ; } if ( $ transformable instanceof Model ) { return $ this -> resolveFromModel ( $ transformable ) ; } return 'data' ; } 
protected function resolveTransformableItem ( $ data ) { if ( is_array ( $ data ) || $ data instanceof Traversable ) { foreach ( $ data as $ item ) { return $ item ; } } return $ data ; } 
protected function resolveTransformer ( string $ transformer ) { $ transformerResolver = $ this -> resolveContainer ( ) -> make ( TransformerResolver :: class ) ; return $ transformerResolver -> resolve ( $ transformer ) ; } 
public function render ( $ request , Exception $ exception ) { if ( $ request -> wantsJson ( ) ) { $ this -> convertDefaultException ( $ exception ) ; if ( $ exception instanceof HttpException ) { return $ this -> renderResponse ( $ exception ) ; } } return parent :: render ( $ request , $ exception ) ; } 
public function make ( ErrorSerializer $ serializer , $ errorCode = null , string $ message = null , array $ data = null ) : array { if ( isset ( $ errorCode ) && ! isset ( $ message ) ) { $ message = $ this -> messageResolver -> resolve ( $ errorCode ) ; } return $ serializer -> format ( $ errorCode , $ message , $ data ) ; } 
public function make ( ResourceInterface $ resource , SerializerAbstract $ serializer , array $ options = [ ] ) { $ options = $ this -> parseOptions ( $ options , $ resource ) ; return $ this -> manager -> setSerializer ( $ serializer ) -> parseIncludes ( $ options [ 'includes' ] ) -> parseExcludes ( $ options [ 'excludes' ] ) -> parseFieldsets ( $ options [ 'fieldsets' ] ) -> createData ( $ resource ) -> toArray ( ) ; } 
protected function parseOptions ( array $ options , ResourceInterface $ resource ) : array { $ options = array_merge ( [ 'includes' => [ ] , 'excludes' => [ ] , 'fieldsets' => [ ] , ] , $ options ) ; if ( ! empty ( $ options [ 'fieldsets' ] ) ) { if ( is_null ( $ resourceKey = $ resource -> getResourceKey ( ) ) ) { throw new LogicException ( 'Filtering fields using sparse fieldsets require resource key to be set.' ) ; } $ options [ 'fieldsets' ] = $ this -> parseFieldsets ( $ options [ 'fieldsets' ] , $ resourceKey , $ options [ 'includes' ] ) ; } return $ options ; } 
protected function parseFieldsets ( array $ fieldsets , string $ resourceKey , array $ includes ) : array { $ includes = array_map ( function ( $ include ) use ( $ resourceKey ) { return "$resourceKey.$include" ; } , $ includes ) ; foreach ( $ fieldsets as $ key => $ fields ) { if ( is_numeric ( $ key ) ) { unset ( $ fieldsets [ $ key ] ) ; $ key = $ resourceKey ; } $ fields = $ this -> parseFieldset ( $ key , ( array ) $ fields , $ includes ) ; $ fieldsets [ $ key ] = array_unique ( array_merge ( key_exists ( $ key , $ fieldsets ) ? ( array ) $ fieldsets [ $ key ] : [ ] , $ fields ) ) ; } return array_map ( function ( $ fields ) { return implode ( ',' , $ fields ) ; } , $ fieldsets ) ; } 
protected function parseFieldset ( string $ key , array $ fields , array $ includes ) : array { $ childIncludes = array_reduce ( $ includes , function ( $ segments , $ include ) use ( $ key ) { return array_merge ( $ segments , $ this -> resolveChildIncludes ( $ key , $ include ) ) ; } , [ ] ) ; return array_merge ( $ fields , array_unique ( $ childIncludes ) ) ; } 
protected function resolveChildIncludes ( $ key , string $ include ) : array { if ( count ( $ segments = explode ( '.' , $ include ) ) <= 1 ) { return [ ] ; } $ relation = $ key === array_shift ( $ segments ) ? [ $ segments [ 0 ] ] : [ ] ; return array_merge ( $ relation , $ this -> resolveChildIncludes ( $ key , implode ( '.' , $ segments ) ) ) ; } 
public function success ( $ data = null , $ transformer = null , string $ resourceKey = null ) : SuccessResponseBuilder { return $ this -> successResponseBuilder -> transform ( $ data , $ transformer , $ resourceKey ) ; } 
public function error ( $ errorCode = null , string $ message = null ) : ErrorResponseBuilder { return $ this -> errorResponseBuilder -> error ( $ errorCode , $ message ) ; } 
public function register ( $ errorCode , string $ message ) { $ this -> messages = array_merge ( $ this -> messages , is_array ( $ errorCode ) ? $ errorCode : [ $ errorCode => $ message , ] ) ; } 
public function resolve ( $ errorCode ) { if ( key_exists ( $ errorCode , $ this -> messages ) ) { return $ this -> messages [ $ errorCode ] ; } if ( $ this -> translator -> has ( $ errorCode = "errors.$errorCode" ) ) { return $ this -> translator -> trans ( $ errorCode ) ; } return null ; } 
protected function cleanArray ( array $ data ) { $ parameters = [ ] ; foreach ( $ data as $ key => $ value ) { $ parameters [ in_array ( $ key , $ this -> except ) ? $ key : snake_case ( $ key ) ] = $ value ; } return $ parameters ; } 
public function bind ( $ transformable , $ transformer = null ) { $ this -> bindings = array_merge ( $ this -> bindings , is_array ( $ transformable ) ? $ transformable : [ $ transformable => $ transformer , ] ) ; } 
public function resolve ( $ transformer ) { if ( is_string ( $ transformer ) ) { return $ this -> container -> make ( $ transformer ) ; } if ( ! is_callable ( $ transformer ) && ! $ transformer instanceof Transformer ) { throw new InvalidTransformerException ; } return $ transformer ; } 
public function resolveFromData ( $ data ) { $ transformer = $ this -> resolveTransformer ( $ this -> resolveTransformableItem ( $ data ) ) ; return $ this -> resolve ( $ transformer ) ; } 
protected function resolveTransformer ( $ transformable ) { if ( is_object ( $ transformable ) && key_exists ( get_class ( $ transformable ) , $ this -> bindings ) ) { return $ this -> bindings [ get_class ( $ transformable ) ] ; } if ( $ transformable instanceof Transformable ) { return $ transformable -> transformer ( ) ; } return $ this -> resolve ( $ this -> fallback ) ; } 
public function register ( ) { if ( $ this -> app instanceof Laravel ) { $ this -> registerLaravelBindings ( ) ; } elseif ( $ this -> app instanceof Lumen ) { $ this -> registerLumenBindings ( ) ; } $ this -> registerSerializerBindings ( ) ; $ this -> registerErrorBindings ( ) ; $ this -> registerFractalBindings ( ) ; $ this -> registerTransformerBindings ( ) ; $ this -> registerResourceBindings ( ) ; $ this -> registerPaginationBindings ( ) ; $ this -> registerTransformationBindings ( ) ; $ this -> registerServiceBindings ( ) ; } 
protected function registerLaravelBindings ( ) { $ this -> app -> singleton ( ResponseFactoryContract :: class , function ( $ app ) { return $ this -> decorateResponseFactory ( $ app -> make ( LaravelResponseFactory :: class ) ) ; } ) ; } 
protected function registerLumenBindings ( ) { $ this -> app -> singleton ( ResponseFactoryContract :: class , function ( $ app ) { return $ this -> decorateResponseFactory ( $ app -> make ( LumenResponseFactory :: class ) ) ; } ) ; $ this -> app -> bind ( Translator :: class , function ( $ app ) { return $ app [ 'translator' ] ; } ) ; } 
protected function decorateResponseFactory ( ResponseFactoryContract $ factory ) : ResponseFactory { foreach ( $ this -> app -> config [ 'responder.decorators' ] as $ decorator ) { $ factory = new $ decorator ( $ factory ) ; } ; return $ factory ; } 
protected function registerSerializerBindings ( ) { $ this -> app -> bind ( ErrorSerializerContract :: class , function ( $ app ) { return $ app -> make ( $ app -> config [ 'responder.serializers.error' ] ) ; } ) ; $ this -> app -> bind ( SerializerAbstract :: class , function ( $ app ) { return $ app -> make ( $ app -> config [ 'responder.serializers.success' ] ) ; } ) ; } 
protected function registerErrorBindings ( ) { $ this -> app -> singleton ( ErrorMessageResolverContract :: class , function ( $ app ) { return $ app -> make ( ErrorMessageResolver :: class ) ; } ) ; $ this -> app -> singleton ( ErrorFactoryContract :: class , function ( $ app ) { return $ app -> make ( ErrorFactory :: class ) ; } ) ; $ this -> app -> bind ( ErrorResponseBuilder :: class , function ( $ app ) { return ( new ErrorResponseBuilder ( $ app -> make ( ResponseFactoryContract :: class ) , $ app -> make ( ErrorFactoryContract :: class ) ) ) -> serializer ( $ app -> make ( ErrorSerializerContract :: class ) ) ; } ) ; } 
protected function registerFractalBindings ( ) { $ this -> app -> bind ( Manager :: class , function ( $ app ) { return ( new Manager ) -> setRecursionLimit ( $ app -> config [ 'responder.recursion_limit' ] ) ; } ) ; } 
protected function registerTransformerBindings ( ) { $ this -> app -> singleton ( TransformerResolverContract :: class , function ( $ app ) { return new TransformerResolver ( $ app , $ app -> config [ 'responder.fallback_transformer' ] ) ; } ) ; BaseTransformer :: containerResolver ( function ( ) { return $ this -> app -> make ( Container :: class ) ; } ) ; } 
protected function registerResourceBindings ( ) { $ this -> app -> singleton ( ResourceKeyResolverContract :: class , function ( $ app ) { return $ app -> make ( ResourceKeyResolver :: class ) ; } ) ; $ this -> app -> singleton ( ResourceFactoryContract :: class , function ( $ app ) { return $ app -> make ( ResourceFactory :: class ) ; } ) ; } 
protected function registerPaginationBindings ( ) { $ this -> app -> bind ( PaginatorFactoryContract :: class , function ( $ app ) { return new PaginatorFactory ( $ app -> make ( Request :: class ) -> query ( ) ) ; } ) ; } 
protected function registerTransformationBindings ( ) { $ this -> app -> bind ( TransformFactoryContract :: class , function ( $ app ) { return $ app -> make ( FractalTransformFactory :: class ) ; } ) ; $ this -> app -> bind ( TransformBuilder :: class , function ( $ app ) { $ request = $ this -> app -> make ( Request :: class ) ; $ relations = $ request -> input ( $ this -> app -> config [ 'responder.load_relations_parameter' ] , [ ] ) ; $ fieldsets = $ request -> input ( $ app -> config [ 'responder.filter_fields_parameter' ] , [ ] ) ; return ( new TransformBuilder ( $ app -> make ( ResourceFactoryContract :: class ) , $ app -> make ( TransformFactoryContract :: class ) , $ app -> make ( PaginatorFactoryContract :: class ) ) ) -> serializer ( $ app -> make ( SerializerAbstract :: class ) ) -> with ( is_string ( $ relations ) ? explode ( ',' , $ relations ) : $ relations ) -> only ( $ fieldsets ) ; } ) ; } 
protected function bootLaravelApplication ( ) { if ( $ this -> app -> runningInConsole ( ) ) { $ this -> publishes ( [ __DIR__ . '/../config/responder.php' => config_path ( 'responder.php' ) , ] , 'config' ) ; $ this -> publishes ( [ __DIR__ . '/../resources/lang/en/errors.php' => base_path ( 'resources/lang/en/errors.php' ) , ] , 'lang' ) ; } } 
public function set ( $ data ) : CursorPaginator { $ this -> items = $ data instanceof Collection ? $ data : collect ( $ data ) ; return $ this ; } 
protected function buildClass ( $ name ) { $ replace = [ ] ; if ( ! $ this -> option ( 'model' ) && ! $ this -> option ( 'plain' ) ) { $ this -> input -> setOption ( 'model' , $ this -> resolveModelFromClassName ( ) ) ; } if ( $ this -> option ( 'model' ) ) { $ replace = $ this -> buildModelReplacements ( $ replace ) ; } return str_replace ( array_keys ( $ replace ) , array_values ( $ replace ) , parent :: buildClass ( $ name ) ) ; } 
protected function parseModel ( $ model ) { if ( preg_match ( '([^A-Za-z0-9_/\\\\])' , $ model ) ) { throw new InvalidArgumentException ( 'Model name contains invalid characters.' ) ; } $ model = trim ( str_replace ( '/' , '\\' , $ model ) , '\\' ) ; if ( ! starts_with ( $ model , $ rootNamespace = $ this -> laravel -> getNamespace ( ) ) ) { $ model = $ rootNamespace . $ model ; } return $ model ; } 
public function format ( $ errorCode = null , string $ message = null , array $ data = null ) : array { $ response = [ 'error' => [ 'code' => $ errorCode , 'message' => $ message , ] , ] ; if ( is_array ( $ data ) ) { $ response [ 'error' ] = array_merge ( $ response [ 'error' ] , $ data ) ; } return $ response ; } 
public function relations ( array $ requested = [ ] ) : array { $ requested = $ this -> normalizeRelations ( $ requested ) ; $ relations = $ this -> applyQueryConstraints ( $ this -> extractRelations ( $ requested ) ) ; $ nestedRelations = $ this -> nestedRelations ( $ requested , $ relations , 'relations' ) ; return array_merge ( $ relations , $ nestedRelations ) ; } 
public function defaultRelations ( array $ requested = [ ] ) : array { $ requested = $ this -> normalizeRelations ( $ requested ) ; $ relations = $ this -> applyQueryConstraints ( $ this -> normalizeRelations ( $ this -> load ) ) ; $ nestedRelations = $ this -> nestedRelations ( $ relations , array_merge ( $ relations , $ requested ) , 'defaultRelations' ) ; return array_merge ( $ relations , $ nestedRelations ) ; } 
protected function nestedRelations ( array $ requested , array $ available , string $ method ) : array { $ transformers = $ this -> mappedTransformers ( $ available ) ; return collect ( array_keys ( $ transformers ) ) -> reduce ( function ( $ nestedRelations , $ relation ) use ( $ requested , $ method , $ transformers ) { $ transformer = $ transformers [ $ relation ] ; $ children = $ this -> extractChildRelations ( $ requested , $ relation ) ; $ childRelations = $ this -> wrapChildRelations ( $ transformer -> $ method ( $ children ) , $ relation ) ; return array_merge ( $ nestedRelations , $ childRelations ) ; } , [ ] ) ; } 
protected function extractRelations ( array $ relations ) : array { $ available = $ this -> availableRelations ( ) ; return array_filter ( $ this -> mapRelations ( $ relations , function ( $ relation , $ constraint ) { $ identifier = explode ( '.' , $ relation ) [ 0 ] ; $ constraint = $ identifier === $ relation ? $ constraint : null ; return [ $ identifier => $ constraint ? : $ this -> resolveQueryConstraint ( $ identifier ) ] ; } ) , function ( $ relation ) use ( $ available ) { return array_has ( $ available , explode ( ':' , $ relation ) [ 0 ] ) ; } , ARRAY_FILTER_USE_KEY ) ; } 
protected function extractChildRelations ( array $ relations , string $ identifier ) : array { return array_reduce ( array_keys ( $ relations ) , function ( $ nested , $ relation ) use ( $ relations , $ identifier ) { if ( ! starts_with ( $ relation , "$identifier." ) ) { return $ nested ; } $ nestedIdentifier = explode ( '.' , $ relation ) ; array_shift ( $ nestedIdentifier ) ; return array_merge ( $ nested , [ implode ( '.' , $ nestedIdentifier ) => $ relations [ $ relation ] ] ) ; } , [ ] ) ; } 
protected function wrapChildRelations ( array $ nestedRelations , string $ relation ) : array { return $ this -> mapRelations ( $ nestedRelations , function ( $ nestedRelation , $ constraint ) use ( $ relation ) { return [ "$relation.$nestedRelation" => $ constraint ] ; } ) ; } 
protected function normalizeRelations ( array $ relations ) : array { return array_reduce ( array_keys ( $ relations ) , function ( $ normalized , $ relation ) use ( $ relations ) { if ( is_numeric ( $ relation ) ) { return array_merge ( $ normalized , [ $ relations [ $ relation ] => null ] ) ; } return array_merge ( $ normalized , [ $ relation => $ relations [ $ relation ] ] ) ; } , [ ] ) ; } 
protected function mapRelations ( array $ relations , callable $ callback ) : array { $ mapped = [ ] ; foreach ( $ relations as $ identifier => $ value ) { $ mapped = array_merge ( $ mapped , $ callback ( $ identifier , $ value ) ) ; } return $ mapped ; } 
protected function applyQueryConstraints ( array $ relations ) : array { return $ this -> mapRelations ( $ relations , function ( $ relation , $ constraint ) { return [ $ relation => is_callable ( $ constraint ) ? $ constraint : $ this -> resolveQueryConstraint ( $ relation ) ] ; } ) ; } 
protected function resolveQueryConstraint ( string $ identifier ) { if ( ! method_exists ( $ this , $ method = 'load' . ucfirst ( camel_case ( $ identifier ) ) ) ) { return null ; } return function ( $ query ) use ( $ method ) { return $ this -> $ method ( $ query ) ; } ; } 
protected function resolveRelation ( Model $ model , string $ identifier ) { $ identifier = camel_case ( $ identifier ) ; $ relation = $ model -> $ identifier ; if ( method_exists ( $ this , $ method = 'filter' . ucfirst ( $ identifier ) ) ) { return $ this -> $ method ( $ relation ) ; } return $ relation ; } 
protected function mappedTransformers ( array $ relations ) : array { $ transformers = collect ( $ this -> availableRelations ( ) ) -> filter ( function ( $ transformer ) { return ! is_null ( $ transformer ) ; } ) -> map ( function ( $ transformer ) { return $ this -> resolveTransformer ( $ transformer ) ; } ) -> all ( ) ; return array_intersect_key ( $ transformers , $ relations ) ; } 
protected function resource ( $ data = null , $ transformer = null , string $ resourceKey = null ) : ResourceInterface { if ( $ data instanceof ResourceInterface ) { return $ data ; } $ resourceFactory = $ this -> resolveContainer ( ) -> make ( ResourceFactory :: class ) ; return $ resourceFactory -> make ( $ data , $ transformer , $ resourceKey ) ; } 
protected function includeResource ( string $ identifier , $ data , array $ parameters ) : ResourceInterface { $ transformer = $ this -> mappedTransformerClass ( $ identifier ) ; if ( method_exists ( $ this , $ method = 'include' . ucfirst ( camel_case ( $ identifier ) ) ) ) { $ resource = $ this -> resource ( $ this -> $ method ( $ data , collect ( $ parameters ) ) , $ transformer , $ identifier ) ; } elseif ( $ data instanceof Model ) { $ resource = $ this -> includeResourceFromModel ( $ data , $ identifier , $ transformer ) ; } else { throw new LogicException ( 'Relation [' . $ identifier . '] not found in [' . get_class ( $ this ) . '].' ) ; } return $ resource ; } 
protected function includeResourceFromModel ( Model $ model , string $ identifier , $ transformer = null ) : ResourceInterface { $ data = $ this -> resolveRelation ( $ model , $ identifier ) ; if ( ! $ this -> shouldCacheResource ( $ data ) ) { return $ this -> resource ( $ data , $ transformer , $ identifier ) ; } elseif ( key_exists ( $ identifier , $ this -> resources ) ) { return $ this -> resources [ $ identifier ] -> setData ( $ data ) ; } return $ this -> resources [ $ identifier ] = $ this -> resource ( $ data , $ transformer , $ identifier ) ; } 
protected function shouldCacheResource ( $ data ) : bool { return is_array ( $ data ) || $ data instanceof Countable ? count ( $ data ) > 0 : is_null ( $ data ) ; } 
public function make ( $ data = null , $ transformer = null , string $ resourceKey = null ) : ResourceInterface { if ( $ data instanceof ResourceInterface ) { return $ this -> makeFromResource ( $ data , $ transformer , $ resourceKey ) ; } elseif ( is_null ( $ data = $ this -> normalizer -> normalize ( $ data ) ) ) { return $ this -> instatiateResource ( $ data , null , $ resourceKey ) ; } $ transformer = $ this -> resolveTransformer ( $ data , $ transformer ) ; $ resourceKey = $ this -> resolveResourceKey ( $ data , $ resourceKey ) ; return $ this -> instatiateResource ( $ data , $ transformer , $ resourceKey ) ; } 
public function makeFromResource ( ResourceInterface $ resource , $ transformer = null , string $ resourceKey = null ) : ResourceInterface { $ transformer = $ this -> resolveTransformer ( $ resource -> getData ( ) , $ transformer ? : $ resource -> getTransformer ( ) ) ; $ resourceKey = $ this -> resolveResourceKey ( $ resource -> getData ( ) , $ resourceKey ? : $ resource -> getResourceKey ( ) ) ; return $ resource -> setTransformer ( $ transformer ) -> setResourceKey ( $ resourceKey ) ; } 
protected function instatiateResource ( $ data , $ transformer = null , string $ resourceKey = null ) : ResourceInterface { if ( is_null ( $ data ) ) { return new NullResource ( null , null , $ resourceKey ) ; } elseif ( $ this -> shouldCreateCollection ( $ data ) ) { return new CollectionResource ( $ data , $ transformer , $ resourceKey ) ; } elseif ( is_scalar ( $ data ) ) { return new Primitive ( $ data , $ transformer , $ resourceKey ) ; } return new ItemResource ( $ data , $ transformer , $ resourceKey ) ; } 
protected function shouldCreateCollection ( $ data ) : bool { if ( is_array ( $ data ) ) { return ! Arr :: isAssoc ( $ data ) && ! is_scalar ( Arr :: first ( $ data ) ) ; } return $ data instanceof Traversable ; } 
protected function resolveTransformer ( $ data , $ transformer ) { if ( isset ( $ transformer ) ) { return $ this -> transformerResolver -> resolve ( $ transformer ) ; } return $ this -> transformerResolver -> resolveFromData ( $ data ) ; } 
protected function resolveResourceKey ( $ data , string $ resourceKey = null ) { return isset ( $ resourceKey ) ? $ resourceKey : $ this -> resourceKeyResolver -> resolve ( $ data ) ; } 
public function decorator ( $ decorator ) { $ decorators = is_array ( $ decorator ) ? $ decorator : func_get_args ( ) ; foreach ( $ decorators as $ decorator ) { $ this -> responseFactory = new $ decorator ( $ this -> responseFactory ) ; } ; return $ this ; } 
public function respond ( int $ status = null , array $ headers = [ ] ) : JsonResponse { if ( ! is_null ( $ status ) ) { $ this -> setStatusCode ( $ status ) ; } return $ this -> responseFactory -> make ( $ this -> getOutput ( ) , $ this -> status , $ headers ) ; } 
public function normalize ( $ data = null ) { if ( $ this -> isInstanceOf ( $ data , [ Builder :: class , EloquentBuilder :: class , CursorPaginator :: class ] ) ) { return $ data -> get ( ) ; } elseif ( $ data instanceof Paginator ) { return $ data -> getCollection ( ) ; } elseif ( $ data instanceof Relation ) { return $ this -> normalizeRelation ( $ data ) ; } return $ data ; } 
protected function normalizeRelation ( Relation $ relation ) { if ( $ this -> isInstanceOf ( $ relation , [ BelongsTo :: class , HasOne :: class , MorphOne :: class , MorphTo :: class ] ) ) { return $ relation -> first ( ) ; } return $ relation -> get ( ) ; } 
public function transform ( $ data = null , $ transformer = null , string $ resourceKey = null ) : SuccessResponseBuilder { $ this -> transformBuilder -> resource ( $ data , $ transformer , $ resourceKey ) ; return $ this ; } 
protected function convert ( Exception $ exception , array $ convert ) { foreach ( $ convert as $ source => $ target ) { if ( $ exception instanceof $ source ) { if ( is_callable ( $ target ) ) { $ target ( $ exception ) ; } throw new $ target ; } } } 
protected function convertDefaultException ( Exception $ exception ) { $ this -> convert ( $ exception , array_diff_key ( [ AuthenticationException :: class => UnauthenticatedException :: class , AuthorizationException :: class => UnauthorizedException :: class , NotFoundHttpException :: class => PageNotFoundException :: class , ModelNotFoundException :: class => PageNotFoundException :: class , BaseRelationNotFoundException :: class => RelationNotFoundException :: class , ValidationException :: class => function ( $ exception ) { throw new ValidationFailedException ( $ exception -> validator ) ; } , ] , array_flip ( $ this -> dontConvert ) ) ) ; } 
protected function renderResponse ( HttpException $ exception ) : JsonResponse { return app ( Responder :: class ) -> error ( $ exception -> errorCode ( ) , $ exception -> message ( ) ) -> data ( $ exception -> data ( ) ) -> respond ( $ exception -> statusCode ( ) , $ exception -> getHeaders ( ) ) ; } 
public function success ( $ data = null , $ transformer = null , string $ resourceKey = null ) : SuccessResponseBuilder { return app ( Responder :: class ) -> success ( ... func_get_args ( ) ) ; } 
public function error ( $ errorCode = null , string $ message = null ) : ErrorResponseBuilder { return app ( Responder :: class ) -> error ( ... func_get_args ( ) ) ; } 
public function make ( array $ data , int $ status , array $ headers = [ ] ) : JsonResponse { return $ this -> factory -> make ( array_merge ( [ 'status' => $ status , ] , $ data ) , $ status , $ headers ) ; } 
public function make ( array $ data , int $ status , array $ headers = [ ] ) : JsonResponse { $ response = $ this -> factory -> make ( $ data , $ status , $ headers ) ; $ response -> setEncodingOptions ( $ response -> getEncodingOptions ( ) | JSON_PRETTY_PRINT ) ; return $ response ; } 
public function make ( $ data = null , $ transformer = null , string $ resourceKey = null ) : TransformBuilder { return $ this -> transformBuilder -> resource ( $ data , $ transformer , $ resourceKey ) -> serializer ( new NoopSerializer ) ; } 
public function make ( array $ data , int $ status , array $ headers = [ ] ) : JsonResponse { array_walk_recursive ( $ data , function ( & $ value ) { if ( is_string ( $ value ) ) { $ value = e ( $ value ) ; } } ) ; return $ this -> factory -> make ( $ data , $ status , $ headers ) ; } 
protected function configureTerminal ( ) : void { $ this -> assertTerminalIsValidTTY ( ) ; $ this -> terminal -> disableCanonicalMode ( ) ; $ this -> terminal -> disableEchoBack ( ) ; $ this -> terminal -> disableCursor ( ) ; $ this -> terminal -> clear ( ) ; } 
public function addItems ( array $ items ) : void { foreach ( $ items as $ item ) { $ this -> items [ ] = $ item ; } $ this -> selectFirstItem ( ) ; } 
public function setItems ( array $ items ) : void { $ this -> selectedItem = null ; $ this -> items = $ items ; $ this -> selectFirstItem ( ) ; } 
private function selectFirstItem ( ) : void { if ( null === $ this -> selectedItem ) { foreach ( $ this -> items as $ key => $ item ) { if ( $ item -> canSelect ( ) ) { $ this -> selectedItem = $ key ; break ; } } } } 
public function addCustomControlMapping ( string $ input , callable $ callable ) : void { if ( isset ( $ this -> defaultControlMappings [ $ input ] ) || isset ( $ this -> customControlMappings [ $ input ] ) ) { throw new \ InvalidArgumentException ( 'Cannot rebind this input' ) ; } $ this -> customControlMappings [ $ input ] = $ callable ; } 
public function removeCustomControlMapping ( string $ input ) : void { if ( ! isset ( $ this -> customControlMappings [ $ input ] ) ) { throw new \ InvalidArgumentException ( 'This input is not registered' ) ; } unset ( $ this -> customControlMappings [ $ input ] ) ; } 
private function display ( ) : void { $ this -> draw ( ) ; $ reader = new NonCanonicalReader ( $ this -> terminal ) ; $ reader -> addControlMappings ( $ this -> defaultControlMappings ) ; while ( $ this -> isOpen ( ) ) { $ char = $ reader -> readCharacter ( ) ; if ( ! $ char -> isHandledControl ( ) ) { $ rawChar = $ char -> get ( ) ; if ( isset ( $ this -> customControlMappings [ $ rawChar ] ) ) { $ this -> customControlMappings [ $ rawChar ] ( $ this ) ; } continue ; } switch ( $ char -> getControl ( ) ) { case InputCharacter :: UP : case InputCharacter :: DOWN : $ this -> moveSelectionVertically ( $ char -> getControl ( ) ) ; $ this -> draw ( ) ; break ; case InputCharacter :: LEFT : case InputCharacter :: RIGHT : $ this -> moveSelectionHorizontally ( $ char -> getControl ( ) ) ; $ this -> draw ( ) ; break ; case InputCharacter :: ENTER : $ this -> executeCurrentItem ( ) ; break ; } } } 
protected function moveSelectionVertically ( string $ direction ) : void { $ itemKeys = array_keys ( $ this -> items ) ; $ increments = 0 ; do { $ increments ++ ; if ( $ increments > count ( $ itemKeys ) ) { 
protected function moveSelectionHorizontally ( string $ direction ) : void { if ( ! $ this -> items [ $ this -> selectedItem ] instanceof SplitItem ) { return ; } $ item = $ this -> items [ $ this -> selectedItem ] ; $ itemKeys = array_keys ( $ item -> getItems ( ) ) ; $ selectedItemIndex = $ item -> getSelectedItemIndex ( ) ; do { $ direction === 'LEFT' ? $ selectedItemIndex -- : $ selectedItemIndex ++ ; if ( ! array_key_exists ( $ selectedItemIndex , $ item -> getItems ( ) ) ) { $ selectedItemIndex = $ direction === 'LEFT' ? end ( $ itemKeys ) : reset ( $ itemKeys ) ; } } while ( ! $ item -> canSelectIndex ( $ selectedItemIndex ) ) ; $ item -> setSelectedItemIndex ( $ selectedItemIndex ) ; } 
public function getSelectedItem ( ) : MenuItemInterface { if ( null === $ this -> selectedItem ) { throw new \ RuntimeException ( 'No selected item' ) ; } $ item = $ this -> items [ $ this -> selectedItem ] ; return $ item instanceof SplitItem ? $ item -> getSelectedItem ( ) : $ item ; } 
protected function executeCurrentItem ( ) : void { $ item = $ this -> getSelectedItem ( ) ; if ( $ item -> canSelect ( ) ) { $ callable = $ item -> getSelectAction ( ) ; if ( $ callable ) { $ callable ( $ this ) ; } } } 
public function redraw ( bool $ clear = false ) : void { if ( $ clear ) { $ this -> terminal -> clear ( ) ; } $ this -> assertOpen ( ) ; $ this -> draw ( ) ; } 
protected function draw ( ) : void { $ frame = new Frame ; $ frame -> newLine ( 2 ) ; if ( $ this -> style -> getBorderTopWidth ( ) > 0 ) { $ frame -> addRows ( $ this -> style -> getBorderTopRows ( ) ) ; } if ( $ this -> style -> getPaddingTopBottom ( ) > 0 ) { $ frame -> addRows ( $ this -> style -> getPaddingTopBottomRows ( ) ) ; } if ( $ this -> title ) { $ frame -> addRows ( $ this -> drawMenuItem ( new StaticItem ( $ this -> title ) ) ) ; $ frame -> addRows ( $ this -> drawMenuItem ( new LineBreakItem ( $ this -> style -> getTitleSeparator ( ) ) ) ) ; } array_map ( function ( $ item , $ index ) use ( $ frame ) { $ frame -> addRows ( $ this -> drawMenuItem ( $ item , $ index === $ this -> selectedItem ) ) ; } , $ this -> items , array_keys ( $ this -> items ) ) ; if ( $ this -> style -> getPaddingTopBottom ( ) > 0 ) { $ frame -> addRows ( $ this -> style -> getPaddingTopBottomRows ( ) ) ; } if ( $ this -> style -> getBorderBottomWidth ( ) > 0 ) { $ frame -> addRows ( $ this -> style -> getBorderBottomRows ( ) ) ; } $ frame -> newLine ( 2 ) ; $ this -> terminal -> moveCursorToTop ( ) ; foreach ( $ frame -> getRows ( ) as $ row ) { if ( $ row == "\n" ) { $ this -> terminal -> clearLine ( ) ; } $ this -> terminal -> write ( $ row ) ; } $ this -> terminal -> clearDown ( ) ; $ this -> currentFrame = $ frame ; } 
protected function drawMenuItem ( MenuItemInterface $ item , bool $ selected = false ) : array { $ rows = $ item -> getRows ( $ this -> style , $ selected ) ; if ( $ item instanceof SplitItem ) { $ selected = false ; } $ invertedColoursSetCode = $ selected ? $ this -> style -> getInvertedColoursSetCode ( ) : '' ; $ invertedColoursUnsetCode = $ selected ? $ this -> style -> getInvertedColoursUnsetCode ( ) : '' ; if ( $ this -> style -> getBorderLeftWidth ( ) || $ this -> style -> getBorderRightWidth ( ) ) { $ borderColour = $ this -> style -> getBorderColourCode ( ) ; } else { $ borderColour = '' ; } return array_map ( function ( $ row ) use ( $ invertedColoursSetCode , $ invertedColoursUnsetCode , $ borderColour ) { return sprintf ( "%s%s%s%s%s%s%s%s%s%s%s%s\n" , str_repeat ( ' ' , $ this -> style -> getMargin ( ) ) , $ borderColour , str_repeat ( ' ' , $ this -> style -> getBorderLeftWidth ( ) ) , $ this -> style -> getColoursSetCode ( ) , $ invertedColoursSetCode , str_repeat ( ' ' , $ this -> style -> getPaddingLeftRight ( ) ) , $ row , str_repeat ( ' ' , $ this -> style -> getRightHandPadding ( mb_strlen ( s :: stripAnsiEscapeSequence ( $ row ) ) ) ) , $ invertedColoursUnsetCode , $ borderColour , str_repeat ( ' ' , $ this -> style -> getBorderRightWidth ( ) ) , $ this -> style -> getColoursResetCode ( ) ) ; } , $ rows ) ; } 
public function close ( ) : void { $ menu = $ this ; do { $ menu -> closeThis ( ) ; $ menu = $ menu -> getParent ( ) ; } while ( null !== $ menu ) ; $ this -> tearDownTerminal ( ) ; } 
private function setDefaultSelectedItem ( ) : void { foreach ( $ this -> items as $ index => $ item ) { if ( $ item -> canSelect ( ) ) { $ this -> canBeSelected = true ; $ this -> selectedItemIndex = $ index ; return ; } } $ this -> canBeSelected = false ; $ this -> selectedItemIndex = null ; } 
public function getRows ( MenuStyle $ style , bool $ selected = false ) : array { $ numberOfItems = count ( $ this -> items ) ; if ( $ numberOfItems === 0 ) { throw new \ RuntimeException ( sprintf ( 'There should be at least one item added to: %s' , __CLASS__ ) ) ; } if ( ! $ selected ) { $ this -> setDefaultSelectedItem ( ) ; } $ length = $ style -> getDisplaysExtra ( ) ? floor ( $ style -> getContentWidth ( ) / $ numberOfItems ) - ( mb_strlen ( $ style -> getItemExtra ( ) ) + 2 ) : floor ( $ style -> getContentWidth ( ) / $ numberOfItems ) ; $ length -= $ this -> gutter ; $ length = ( int ) $ length ; $ missingLength = $ style -> getContentWidth ( ) % $ numberOfItems ; return $ this -> buildRows ( array_map ( function ( $ index , $ item ) use ( $ selected , $ length , $ style ) { $ isSelected = $ selected && $ index === $ this -> selectedItemIndex ; $ marker = $ item -> canSelect ( ) ? sprintf ( '%s' , $ style -> getMarker ( $ isSelected ) ) : '' ; $ itemExtra = '' ; if ( $ style -> getDisplaysExtra ( ) ) { $ itemExtra = $ item -> showsItemExtra ( ) ? sprintf ( ' %s' , $ style -> getItemExtra ( ) ) : sprintf ( ' %s' , str_repeat ( ' ' , mb_strlen ( $ style -> getItemExtra ( ) ) ) ) ; } return $ this -> buildCell ( explode ( "\n" , StringUtil :: wordwrap ( sprintf ( '%s%s' , $ marker , $ item -> getText ( ) ) , $ length , sprintf ( "\n%s" , str_repeat ( ' ' , mb_strlen ( $ marker ) ) ) ) ) , $ length , $ style , $ isSelected , $ itemExtra ) ; } , array_keys ( $ this -> items ) , $ this -> items ) , $ style , $ missingLength , $ length ) ; } 
public function canSelectIndex ( int $ index ) : bool { return isset ( $ this -> items [ $ index ] ) && $ this -> items [ $ index ] -> canSelect ( ) ; } 
public function setSelectedItemIndex ( int $ index ) : void { if ( ! isset ( $ this -> items [ $ index ] ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Index: "%s" does not exist' , $ index ) ) ; } $ this -> selectedItemIndex = $ index ; } 
public function getSelectedItem ( ) : MenuItemInterface { if ( null === $ this -> selectedItemIndex ) { throw new \ RuntimeException ( 'No item is selected' ) ; } return $ this -> items [ $ this -> selectedItemIndex ] ; } 
public function getRows ( MenuStyle $ style , bool $ selected = false ) : array { return explode ( "\n" , rtrim ( str_repeat ( sprintf ( "%s\n" , mb_substr ( str_repeat ( $ this -> breakChar , $ style -> getContentWidth ( ) ) , 0 , $ style -> getContentWidth ( ) ) ) , $ this -> lines ) ) ) ; } 
public static function wordwrap ( string $ string , int $ width , string $ break = "\n" ) : string { return implode ( $ break , array_map ( function ( string $ line ) use ( $ width , $ break ) { $ line = rtrim ( $ line ) ; if ( mb_strlen ( $ line ) <= $ width ) { return $ line ; } $ words = explode ( ' ' , $ line ) ; $ line = '' ; $ actual = '' ; foreach ( $ words as $ word ) { if ( mb_strlen ( $ actual . $ word ) <= $ width ) { $ actual .= $ word . ' ' ; } else { if ( $ actual !== '' ) { $ line .= rtrim ( $ actual ) . $ break ; } $ actual = $ word . ' ' ; } } return $ line . trim ( $ actual ) ; } , explode ( "\n" , $ string ) ) ) ; } 
public function getRows ( MenuStyle $ style , bool $ selected = false ) : array { $ marker = sprintf ( "%s" , $ style -> getMarker ( $ selected ) ) ; $ length = $ style -> getDisplaysExtra ( ) ? $ style -> getContentWidth ( ) - ( mb_strlen ( $ style -> getItemExtra ( ) ) + 2 ) : $ style -> getContentWidth ( ) ; $ rows = explode ( "\n" , StringUtil :: wordwrap ( sprintf ( '%s%s' , $ marker , $ this -> text ) , $ length , sprintf ( "\n%s" , str_repeat ( ' ' , mb_strlen ( $ marker ) ) ) ) ) ; return array_map ( function ( $ row , $ key ) use ( $ style , $ length ) { $ text = $ this -> disabled ? $ style -> getDisabledItemText ( $ row ) : $ row ; if ( $ key === 0 ) { return $ this -> showItemExtra ? sprintf ( '%s%s %s' , $ text , str_repeat ( ' ' , $ length - mb_strlen ( $ row ) ) , $ style -> getItemExtra ( ) ) : $ text ; } return $ text ; } , $ rows , array_keys ( $ rows ) ) ; } 
private function generateColoursSetCode ( ) : void { if ( ! ctype_digit ( $ this -> fg ) ) { $ fgCode = self :: $ availableForegroundColors [ $ this -> fg ] ; } else { $ fgCode = sprintf ( "38;5;%s" , $ this -> fg ) ; } if ( ! ctype_digit ( $ this -> bg ) ) { $ bgCode = self :: $ availableBackgroundColors [ $ this -> bg ] ; } else { $ bgCode = sprintf ( "48;5;%s" , $ this -> bg ) ; } $ this -> coloursSetCode = sprintf ( "\033[%s;%sm" , $ fgCode , $ bgCode ) ; } 
protected function calculateContentWidth ( ) : void { $ this -> contentWidth = $ this -> width - ( $ this -> paddingLeftRight * 2 ) - ( $ this -> borderRightWidth + $ this -> borderLeftWidth ) ; if ( $ this -> contentWidth < 0 ) { $ this -> contentWidth = 0 ; } } 
public function getRightHandPadding ( int $ contentLength ) : int { $ rightPadding = $ this -> getContentWidth ( ) - $ contentLength + $ this -> getPaddingLeftRight ( ) ; if ( $ rightPadding < 0 ) { $ rightPadding = 0 ; } return $ rightPadding ; } 
public function setBorder ( int $ topWidth , $ rightWidth = null , $ bottomWidth = null , $ leftWidth = null , string $ colour = null ) : self { if ( ! is_int ( $ rightWidth ) ) { $ colour = $ rightWidth ; $ rightWidth = $ bottomWidth = $ leftWidth = $ topWidth ; } elseif ( ! is_int ( $ bottomWidth ) ) { $ colour = $ bottomWidth ; $ bottomWidth = $ topWidth ; $ leftWidth = $ rightWidth ; } elseif ( ! is_int ( $ leftWidth ) ) { $ colour = $ leftWidth ; $ leftWidth = $ rightWidth ; } $ this -> borderTopWidth = $ topWidth ; $ this -> borderRightWidth = $ rightWidth ; $ this -> borderBottomWidth = $ bottomWidth ; $ this -> borderLeftWidth = $ leftWidth ; if ( is_string ( $ colour ) ) { $ this -> setBorderColour ( $ colour ) ; } elseif ( $ colour !== null ) { throw new \ InvalidArgumentException ( 'Invalid colour' ) ; } $ this -> calculateContentWidth ( ) ; $ this -> generateBorderRows ( ) ; $ this -> generatePaddingTopBottomRows ( ) ; return $ this ; } 
public function display ( ) : void { $ this -> assertMenuOpen ( ) ; $ this -> terminal -> moveCursorToRow ( $ this -> y ) ; $ this -> emptyRow ( ) ; $ this -> write ( sprintf ( "%s%s%s%s%s\n" , $ this -> style -> getColoursSetCode ( ) , str_repeat ( ' ' , $ this -> style -> getPaddingLeftRight ( ) ) , $ this -> text , str_repeat ( ' ' , $ this -> style -> getPaddingLeftRight ( ) ) , $ this -> style -> getColoursResetCode ( ) ) ) ; $ this -> emptyRow ( ) ; $ this -> terminal -> moveCursorToTop ( ) ; $ reader = new NonCanonicalReader ( $ this -> terminal ) ; $ reader -> readCharacter ( ) ; $ this -> parentMenu -> redraw ( ) ; } 
protected function calculateCoordinates ( ) : void { 
protected function emptyRow ( ) : void { $ this -> write ( sprintf ( "%s%s%s%s%s\n" , $ this -> style -> getColoursSetCode ( ) , str_repeat ( ' ' , $ this -> style -> getPaddingLeftRight ( ) ) , str_repeat ( ' ' , mb_strlen ( $ this -> text ) ) , str_repeat ( ' ' , $ this -> style -> getPaddingLeftRight ( ) ) , $ this -> style -> getColoursResetCode ( ) ) ) ; } 
protected function write ( string $ text , int $ column = null ) : void { $ this -> terminal -> moveCursorToColumn ( $ column ? : $ this -> x ) ; $ this -> terminal -> write ( $ text ) ; } 
public function getRows ( MenuStyle $ style , bool $ selected = false ) : array { if ( $ this -> artLength > $ style -> getContentWidth ( ) ) { $ alternate = new StaticItem ( $ this -> alternateText ) ; return $ alternate -> getRows ( $ style , false ) ; } $ padding = $ style -> getContentWidth ( ) - $ this -> artLength ; return array_map ( function ( $ row ) use ( $ padding ) { switch ( $ this -> position ) { case self :: POSITION_LEFT : break ; case self :: POSITION_RIGHT : $ row = sprintf ( '%s%s' , str_repeat ( ' ' , $ padding ) , $ row ) ; break ; case self :: POSITION_CENTER : default : $ left = ( int ) ceil ( $ padding / 2 ) ; $ row = sprintf ( '%s%s' , str_repeat ( ' ' , $ left ) , $ row ) ; break ; } return $ row ; } , explode ( "\n" , $ this -> text ) ) ; } 
public function setText ( string $ text ) : void { $ this -> text = implode ( "\n" , array_map ( function ( string $ line ) { return rtrim ( $ line , ' ' ) ; } , explode ( "\n" , $ text ) ) ) ; $ this -> calculateArtLength ( ) ; } 
private function calculateArtLength ( ) : void { $ this -> artLength = ( int ) max ( array_map ( 'mb_strlen' , explode ( "\n" , $ this -> text ) ) ) ; } 
public static function map256To8 ( int $ colourCode ) : string { if ( ! isset ( self :: $ coloursMap [ $ colourCode ] ) ) { throw new \ InvalidArgumentException ( 'Invalid colour code' ) ; } return self :: $ coloursMap [ $ colourCode ] ; } 
public static function validateColour ( Terminal $ terminal , string $ colour , string $ fallback = null ) : string { if ( ! ctype_digit ( $ colour ) ) { return static :: validateColourName ( $ colour ) ; } Assertion :: between ( $ colour , 0 , 255 , 'Invalid colour code' ) ; if ( $ terminal -> getColourSupport ( ) >= 256 ) { return $ colour ; } if ( $ fallback !== null ) { return static :: validateColourName ( $ fallback ) ; } return static :: map256To8 ( ( int ) $ colour ) ; } 
public function display ( string $ confirmText = 'OK' ) : void { $ this -> assertMenuOpen ( ) ; $ this -> terminal -> moveCursorToRow ( $ this -> y ) ; $ promptWidth = mb_strlen ( $ this -> text ) + 4 ; $ this -> emptyRow ( ) ; $ this -> write ( sprintf ( "%s%s%s%s%s\n" , $ this -> style -> getColoursSetCode ( ) , str_repeat ( ' ' , $ this -> style -> getPaddingLeftRight ( ) ) , $ this -> text , str_repeat ( ' ' , $ this -> style -> getPaddingLeftRight ( ) ) , $ this -> style -> getColoursResetCode ( ) ) ) ; $ this -> emptyRow ( ) ; $ confirmText = sprintf ( ' < %s > ' , $ confirmText ) ; $ leftFill = ( int ) ( ( $ promptWidth / 2 ) - ( mb_strlen ( $ confirmText ) / 2 ) ) ; $ this -> write ( sprintf ( "%s%s%s%s%s%s%s\n" , $ this -> style -> getColoursSetCode ( ) , str_repeat ( ' ' , $ leftFill ) , $ this -> style -> getInvertedColoursSetCode ( ) , $ confirmText , $ this -> style -> getInvertedColoursUnsetCode ( ) , str_repeat ( ' ' , ( int ) ceil ( $ promptWidth - $ leftFill - mb_strlen ( $ confirmText ) ) ) , $ this -> style -> getColoursResetCode ( ) ) ) ; $ this -> write ( sprintf ( "%s%s%s%s%s\n" , $ this -> style -> getColoursSetCode ( ) , str_repeat ( ' ' , $ this -> style -> getPaddingLeftRight ( ) ) , str_repeat ( ' ' , mb_strlen ( $ this -> text ) ) , str_repeat ( ' ' , $ this -> style -> getPaddingLeftRight ( ) ) , $ this -> style -> getColoursResetCode ( ) ) ) ; $ this -> terminal -> moveCursorToTop ( ) ; $ reader = new NonCanonicalReader ( $ this -> terminal ) ; while ( $ char = $ reader -> readCharacter ( ) ) { if ( $ char -> isControl ( ) && $ char -> getControl ( ) === InputCharacter :: ENTER ) { $ this -> parentMenu -> redraw ( ) ; return ; } } } 
public function getRows ( MenuStyle $ style , bool $ selected = false ) : array { return explode ( "\n" , StringUtil :: wordwrap ( $ this -> text , $ style -> getContentWidth ( ) ) ) ; } 
public function DataContrast ( $ fee , $ time , $ Minute = 3 , $ Remarks = false ) { 
public function getSyncKey ( ) { try { $ html = ( new \ GuzzleHttp \ Client ( ) ) -> request ( 'POST' , "https://" . $ this -> url . "/cgi-bin/mmwebwx-bin/webwxinit?r=695888609" , [ 'timeout' => 10 , 'headers' => [ 'Accept' => 'application/json, text/javascript' , 'Accept-Encoding' => 'gzip, deflate, br' , 'Accept-Language' => 'en-US,en;q=0.9,zh-CN;q=0.8,zh;q=0.7' , 'Connection' => 'keep-alive' , 'Content-Length' => '295' , 'Content-Type' => 'application/json;charset=UTF-8' , 'Cookie' => $ this -> cookie , 'Host' => $ this -> url , 'Origin' => 'https://' . $ this -> url , 'Referer' => 'https://' . $ this -> url . '/' , 'User-Agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.106 Safari/537.36' ] , 'body' => '{"BaseRequest":{"Uin":' . Cookie :: getCookieName ( 'wxuin' , $ this -> cookie ) . ',"Sid":"' . Cookie :: getCookieName ( 'wxsid' , $ this -> cookie ) . '","Skey":' . '"","DeviceID":"e453731506754000"}}' ] ) -> getBody ( ) ; return json_decode ( $ html -> getContents ( ) , true ) ; } catch ( GuzzleException $ e ) { throw new PayException ( '访问出错', 500); } catch ( PayException $ e ) { throw new PayException ( $ e -> getMessage ( ) , $ e -> getCode ( ) ) ; } catch ( \ Exception $ e ) { throw new PayException ( '处理出错', 444); } } 
public function DataContrast ( $ fee , $ time , $ Minute = 3 , $ Remarks = false ) { 
public static function getCookieName ( $ name = 'uid' , $ cookie = false ) { $ getCookie = explode ( $ name . '=' , $ cookie ) ; if ( count ( $ getCookie ) <= 1 ) throw new PayException ( 'cookie有误', 44 5 ; if ( $ name == 'uid' ) return explode ( '"' , $ getCookie [ 1 ] ) [ 0 ] ; else return explode ( ';' , $ getCookie [ 1 ] ) [ 0 ] ; } 
protected function buildClient ( array $ config ) : Client { $ clientBuilder = ClientBuilder :: create ( ) ; 
public function register ( ) { $ app = $ this -> app ; $ app -> singleton ( 'elasticsearch.factory' , function ( $ app ) { return new Factory ( ) ; } ) ; $ app -> singleton ( 'elasticsearch' , function ( $ app ) { return new Manager ( $ app , $ app [ 'elasticsearch.factory' ] ) ; } ) ; $ app -> alias ( 'elasticsearch' , Manager :: class ) ; $ app -> singleton ( Client :: class , function ( $ app ) { return $ app [ 'elasticsearch' ] -> connection ( ) ; } ) ; } 
public function connection ( string $ name = null ) : Client { $ name = $ name ? : $ this -> getDefaultConnection ( ) ; if ( ! isset ( $ this -> connections [ $ name ] ) ) { $ client = $ this -> makeConnection ( $ name ) ; $ this -> connections [ $ name ] = $ client ; } return $ this -> connections [ $ name ] ; } 
protected function makeConnection ( string $ name ) : Client { $ config = $ this -> getConfig ( $ name ) ; return $ this -> factory -> make ( $ config ) ; } 
protected function getConfig ( string $ name ) { $ connections = $ this -> app [ 'config' ] [ 'elasticsearch.connections' ] ; if ( null === $ config = array_get ( $ connections , $ name ) ) { throw new \ InvalidArgumentException ( "Elasticsearch connection [$name] not configured." ) ; } return $ config ; } 
public function Compress ( & $ curl_headers , & $ requestBody ) { if ( ! function_exists ( 'gzencode' ) ) { return ; } $ requestBody = gzencode ( $ requestBody ) ; $ curl_headers [ 'content-encoding' ] = 'deflate' ; $ curl_headers [ 'content-length' ] = strlen ( $ requestBody ) ; } 
public static function update ( $ objToUpdate , array $ data ) { $ classOfObj = get_class ( $ objToUpdate ) ; if ( strcmp ( $ classOfObj , FacadeHelper :: simpleAppendClassNameSpace ( "Account" ) ) != 0 ) { throw new \ Exception ( "Target object class:{" . $ classOfObj . "} is not an instance of Account." ) ; } $ newAccountObj = Account :: create ( $ data ) ; $ clonedOfObj = FacadeHelper :: cloneObj ( $ objToUpdate ) ; FacadeHelper :: mergeObj ( $ clonedOfObj , $ newAccountObj ) ; return $ clonedOfObj ; } 
public function __isset ( $ key ) { $ this -> parse ( ) ; if ( isset ( $ this -> _ruleMap [ $ key ] ) ) { $ key = $ this -> _ruleMap [ $ key ] ; return isset ( $ this -> _options [ $ key ] ) ; } return false ; } 
public function addArguments ( $ argv ) { if ( ! is_array ( $ argv ) ) { require_once 'Zend/Console/Getopt/Exception.php' ; throw new Zend_Console_Getopt_Exception ( "Parameter #1 to addArguments should be an array" ) ; } $ this -> _argv = array_merge ( $ this -> _argv , $ argv ) ; $ this -> _parsed = false ; return $ this ; } 
public function setArguments ( $ argv ) { if ( ! is_array ( $ argv ) ) { require_once 'Zend/Console/Getopt/Exception.php' ; throw new Zend_Console_Getopt_Exception ( "Parameter #1 to setArguments should be an array" ) ; } $ this -> _argv = $ argv ; $ this -> _parsed = false ; return $ this ; } 
public function setOptions ( $ getoptConfig ) { if ( isset ( $ getoptConfig ) ) { foreach ( $ getoptConfig as $ key => $ value ) { $ this -> setOption ( $ key , $ value ) ; } } return $ this ; } 
public function setOption ( $ configKey , $ configValue ) { if ( $ configKey !== null ) { $ this -> _getoptConfig [ $ configKey ] = $ configValue ; } return $ this ; } 
public function addRules ( $ rules ) { $ ruleMode = $ this -> _getoptConfig [ 'ruleMode' ] ; switch ( $ this -> _getoptConfig [ 'ruleMode' ] ) { case self :: MODE_ZEND : if ( is_array ( $ rules ) ) { $ this -> _addRulesModeZend ( $ rules ) ; break ; } * Call addRulesModeFoo() for ruleMode 'foo'. * The developer should subclass Getopt and * provide this method. */ $ method = '_addRulesMode' . ucfirst ( $ ruleMode ) ; $ this -> $ method ( $ rules ) ; } $ this -> _parsed = false ; return $ this ; } 
public function toString ( ) { $ this -> parse ( ) ; $ s = array ( ) ; foreach ( $ this -> _options as $ flag => $ value ) { $ s [ ] = $ flag . '=' . ( $ value === true ? 'true' : $ value ) ; } return implode ( ' ' , $ s ) ; } 
public function toArray ( ) { $ this -> parse ( ) ; $ s = array ( ) ; foreach ( $ this -> _options as $ flag => $ value ) { $ s [ ] = $ flag ; if ( $ value !== true ) { $ s [ ] = $ value ; } } return $ s ; } 
public function toJson ( ) { $ this -> parse ( ) ; $ j = array ( ) ; foreach ( $ this -> _options as $ flag => $ value ) { $ j [ 'options' ] [ ] = array ( 'option' => array ( 'flag' => $ flag , 'parameter' => $ value ) ) ; } require_once 'Zend/Json.php' ; $ json = Zend_Json :: encode ( $ j ) ; return $ json ; } 
public function toXml ( ) { $ this -> parse ( ) ; $ doc = new DomDocument ( '1.0' , 'utf-8' ) ; $ optionsNode = $ doc -> createElement ( 'options' ) ; $ doc -> appendChild ( $ optionsNode ) ; foreach ( $ this -> _options as $ flag => $ value ) { $ optionNode = $ doc -> createElement ( 'option' ) ; $ optionNode -> setAttribute ( 'flag' , utf8_encode ( $ flag ) ) ; if ( $ value !== true ) { $ optionNode -> setAttribute ( 'parameter' , utf8_encode ( $ value ) ) ; } $ optionsNode -> appendChild ( $ optionNode ) ; } $ xml = $ doc -> saveXML ( ) ; return $ xml ; } 
public function getOption ( $ flag ) { $ this -> parse ( ) ; if ( $ this -> _getoptConfig [ self :: CONFIG_IGNORECASE ] ) { $ flag = strtolower ( $ flag ) ; } if ( isset ( $ this -> _ruleMap [ $ flag ] ) ) { $ flag = $ this -> _ruleMap [ $ flag ] ; if ( isset ( $ this -> _options [ $ flag ] ) ) { return $ this -> _options [ $ flag ] ; } } return null ; } 
public function getUsageMessage ( ) { $ usage = "Usage: {$this->_progname} [ options ]\n" ; $ maxLen = 20 ; $ lines = array ( ) ; foreach ( $ this -> _rules as $ rule ) { $ flags = array ( ) ; if ( is_array ( $ rule [ 'alias' ] ) ) { foreach ( $ rule [ 'alias' ] as $ flag ) { $ flags [ ] = ( strlen ( $ flag ) == 1 ? '-' : '--' ) . $ flag ; } } $ linepart [ 'name' ] = implode ( '|' , $ flags ) ; if ( isset ( $ rule [ 'param' ] ) && $ rule [ 'param' ] != 'none' ) { $ linepart [ 'name' ] .= ' ' ; switch ( $ rule [ 'param' ] ) { case 'optional' : $ linepart [ 'name' ] .= "[ <{$rule['paramType']}> ]" ; break ; case 'required' : $ linepart [ 'name' ] .= "<{$rule['paramType']}>" ; break ; } } if ( strlen ( $ linepart [ 'name' ] ) > $ maxLen ) { $ maxLen = strlen ( $ linepart [ 'name' ] ) ; } $ linepart [ 'help' ] = '' ; if ( isset ( $ rule [ 'help' ] ) ) { $ linepart [ 'help' ] .= $ rule [ 'help' ] ; } $ lines [ ] = $ linepart ; } foreach ( $ lines as $ linepart ) { $ usage .= sprintf ( "%s %s\n" , str_pad ( $ linepart [ 'name' ] , $ maxLen ) , $ linepart [ 'help' ] ) ; } return $ usage ; } 
public function setAliases ( $ aliasMap ) { foreach ( $ aliasMap as $ flag => $ alias ) { if ( $ this -> _getoptConfig [ self :: CONFIG_IGNORECASE ] ) { $ flag = strtolower ( $ flag ) ; $ alias = strtolower ( $ alias ) ; } if ( ! isset ( $ this -> _ruleMap [ $ flag ] ) ) { continue ; } $ flag = $ this -> _ruleMap [ $ flag ] ; if ( isset ( $ this -> _rules [ $ alias ] ) || isset ( $ this -> _ruleMap [ $ alias ] ) ) { $ o = ( strlen ( $ alias ) == 1 ? '-' : '--' ) . $ alias ; require_once 'Zend/Console/Getopt/Exception.php' ; throw new Zend_Console_Getopt_Exception ( "Option \"$o\" is being defined more than once." ) ; } $ this -> _rules [ $ flag ] [ 'alias' ] [ ] = $ alias ; $ this -> _ruleMap [ $ alias ] = $ flag ; } return $ this ; } 
public function setHelp ( $ helpMap ) { foreach ( $ helpMap as $ flag => $ help ) { if ( ! isset ( $ this -> _ruleMap [ $ flag ] ) ) { continue ; } $ flag = $ this -> _ruleMap [ $ flag ] ; $ this -> _rules [ $ flag ] [ 'help' ] = $ help ; } return $ this ; } 
public function parse ( ) { if ( $ this -> _parsed === true ) { return ; } $ argv = $ this -> _argv ; $ this -> _options = array ( ) ; $ this -> _remainingArgs = array ( ) ; while ( count ( $ argv ) > 0 ) { if ( $ argv [ 0 ] == '--' ) { array_shift ( $ argv ) ; if ( $ this -> _getoptConfig [ self :: CONFIG_DASHDASH ] ) { $ this -> _remainingArgs = array_merge ( $ this -> _remainingArgs , $ argv ) ; break ; } } if ( substr ( $ argv [ 0 ] , 0 , 2 ) == '--' ) { $ this -> _parseLongOption ( $ argv ) ; } elseif ( substr ( $ argv [ 0 ] , 0 , 1 ) == '-' && ( '-' != $ argv [ 0 ] || count ( $ argv ) > 1 ) ) { $ this -> _parseShortOptionCluster ( $ argv ) ; } elseif ( $ this -> _getoptConfig [ self :: CONFIG_PARSEALL ] ) { $ this -> _remainingArgs [ ] = array_shift ( $ argv ) ; } else { $ this -> _remainingArgs = array_merge ( $ this -> _remainingArgs , $ argv ) ; break ; } } $ this -> _parsed = true ; return $ this ; } 
protected function _parseLongOption ( & $ argv ) { $ optionWithParam = ltrim ( array_shift ( $ argv ) , '-' ) ; $ l = explode ( '=' , $ optionWithParam , 2 ) ; $ flag = array_shift ( $ l ) ; $ param = array_shift ( $ l ) ; if ( isset ( $ param ) ) { array_unshift ( $ argv , $ param ) ; } $ this -> _parseSingleOption ( $ flag , $ argv ) ; } 
protected function _parseShortOptionCluster ( & $ argv ) { $ flagCluster = ltrim ( array_shift ( $ argv ) , '-' ) ; foreach ( str_split ( $ flagCluster ) as $ flag ) { $ this -> _parseSingleOption ( $ flag , $ argv ) ; } } 
protected function _parseSingleOption ( $ flag , & $ argv ) { if ( $ this -> _getoptConfig [ self :: CONFIG_IGNORECASE ] ) { $ flag = strtolower ( $ flag ) ; } if ( ! isset ( $ this -> _ruleMap [ $ flag ] ) ) { require_once 'Zend/Console/Getopt/Exception.php' ; throw new Zend_Console_Getopt_Exception ( "Option \"$flag\" is not recognized." , $ this -> getUsageMessage ( ) ) ; } $ realFlag = $ this -> _ruleMap [ $ flag ] ; switch ( $ this -> _rules [ $ realFlag ] [ 'param' ] ) { case 'required' : if ( count ( $ argv ) > 0 ) { $ param = array_shift ( $ argv ) ; $ this -> _checkParameterType ( $ realFlag , $ param ) ; } else { require_once 'Zend/Console/Getopt/Exception.php' ; throw new Zend_Console_Getopt_Exception ( "Option \"$flag\" requires a parameter." , $ this -> getUsageMessage ( ) ) ; } break ; case 'optional' : if ( count ( $ argv ) > 0 && substr ( $ argv [ 0 ] , 0 , 1 ) != '-' ) { $ param = array_shift ( $ argv ) ; $ this -> _checkParameterType ( $ realFlag , $ param ) ; } else { $ param = true ; } break ; default : $ param = true ; } $ this -> _options [ $ realFlag ] = $ param ; } 
protected function _checkParameterType ( $ flag , $ param ) { $ type = 'string' ; if ( isset ( $ this -> _rules [ $ flag ] [ 'paramType' ] ) ) { $ type = $ this -> _rules [ $ flag ] [ 'paramType' ] ; } switch ( $ type ) { case 'word' : if ( preg_match ( '/\W/' , $ param ) ) { require_once 'Zend/Console/Getopt/Exception.php' ; throw new Zend_Console_Getopt_Exception ( "Option \"$flag\" requires a single-word parameter, but was given \"$param\"." , $ this -> getUsageMessage ( ) ) ; } break ; case 'integer' : if ( preg_match ( '/\D/' , $ param ) ) { require_once 'Zend/Console/Getopt/Exception.php' ; throw new Zend_Console_Getopt_Exception ( "Option \"$flag\" requires an integer parameter, but was given \"$param\"." , $ this -> getUsageMessage ( ) ) ; } break ; case 'string' : default : break ; } return true ; } 
protected function _addRulesModeGnu ( $ rules ) { $ ruleArray = array ( ) ; preg_match_all ( '/([a-zA-Z0-9]:?)/' , $ rules , $ ruleArray ) ; foreach ( $ ruleArray [ 1 ] as $ rule ) { $ r = array ( ) ; $ flag = substr ( $ rule , 0 , 1 ) ; if ( $ this -> _getoptConfig [ self :: CONFIG_IGNORECASE ] ) { $ flag = strtolower ( $ flag ) ; } $ r [ 'alias' ] [ ] = $ flag ; if ( substr ( $ rule , 1 , 1 ) == ':' ) { $ r [ 'param' ] = 'required' ; $ r [ 'paramType' ] = 'string' ; } else { $ r [ 'param' ] = 'none' ; } $ this -> _rules [ $ flag ] = $ r ; $ this -> _ruleMap [ $ flag ] = $ flag ; } } 
protected function _addRulesModeZend ( $ rules ) { foreach ( $ rules as $ ruleCode => $ helpMessage ) { 
public function getOAuthHeader ( $ uri , $ queryParameters , $ httpMethod ) { $ this -> sign ( $ uri , $ queryParameters , $ httpMethod ) ; foreach ( $ this -> oauthParameters as $ k => $ v ) { $ this -> oauthParameters [ $ k ] = $ k . '="' . rawurlencode ( $ v ) . '"' ; } return 'OAuth ' . implode ( ',' , $ this -> oauthParameters ) ; } 
public function sign ( $ uri , $ queryParameters , $ httpMethod ) { $ baseString = $ this -> getBaseString ( $ uri , $ httpMethod , $ queryParameters ) ; $ oauthSignature = $ this -> signUsingHmacSha1 ( $ baseString ) ; $ this -> oauthParameters [ 'oauth_signature' ] = $ oauthSignature ; } 
public function getBaseString ( $ uri , $ method , array $ parameters = array ( ) ) { $ baseString = $ this -> prepareHttpMethod ( $ method ) . '&' . $ this -> prepareURL ( $ uri ) . '&' . $ this -> prepareQueryParams ( $ parameters ) ; return $ baseString ; } 
private function prepareHttpMethod ( $ method ) { $ trimmedMethod = trim ( $ method ) ; $ upperMethod = strtoupper ( $ trimmedMethod ) ; return rawurlencode ( $ method ) ; } 
private function prepareQueryParams ( $ queryParameters ) { $ appendedQueryParams = $ this -> appendOAuthPartsTo ( $ queryParameters ) ; array_walk_recursive ( $ appendedQueryParams , function ( & $ key , & $ value ) { $ key = rawurlencode ( $ key ) ; $ value = rawurlencode ( $ value ) ; } ) ; uksort ( $ appendedQueryParams , 'strcmp' ) ; $ pairs = [ ] ; foreach ( $ appendedQueryParams as $ parameter => $ value ) { if ( is_array ( $ value ) ) { 
public function signUsingHmacSha1 ( $ baseString ) { $ key = rawurlencode ( $ this -> consumerSecret ) . '&' . rawurlencode ( $ this -> oauthTokenSecret ) ; return base64_encode ( hash_hmac ( self :: SIGNATURE_METHOD , $ baseString , $ key , TRUE ) ) ; } 
private function setNonce ( $ length = 6 ) { $ result = '' ; $ cLength = strlen ( self :: NONCE_CHARS ) ; for ( $ i = 0 ; $ i < $ length ; $ i ++ ) { $ rnum = rand ( 0 , $ cLength - 1 ) ; $ result .= substr ( self :: NONCE_CHARS , $ rnum , 1 ) ; } $ this -> oauthNonce = $ result ; } 
private function appendOAuthPartsTo ( array $ queryParameters = null ) { if ( $ queryParameters == null ) { $ queryParameters = array ( ) ; } $ queryParameters [ 'oauth_consumer_key' ] = $ this -> consumerKey ; $ queryParameters [ 'oauth_token' ] = $ this -> oauthToken ; $ queryParameters [ 'oauth_signature_method' ] = 'HMAC-SHA1' ; $ queryParameters [ 'oauth_timestamp' ] = $ this -> oauthTimeStamp ; $ queryParameters [ 'oauth_nonce' ] = $ this -> oauthNonce ; $ queryParameters [ 'oauth_version' ] = '1.0' ; return $ queryParameters ; } 
public function getString ( ) { if ( empty ( $ this -> sql ) || empty ( $ this -> entity ) ) { return null ; } $ query = "" ; $ query .= $ this -> sql ; if ( 0 == count ( $ this -> projection ) ) { $ query .= " " . "*" ; } else { if ( count ( $ this -> projection ) ) { $ query .= " " . implode ( ", " , $ this -> projection ) ; } } $ query .= " FROM " . $ this -> entity ; if ( ! empty ( $ this -> whereClause ) ) { if ( count ( $ this -> whereClause ) ) { $ query .= " WHERE " . implode ( " AND " , $ this -> whereClause ) ; } } if ( ! empty ( $ this -> orderByClause ) ) { $ query .= " ORDERBY " . $ this -> orderByClause ; } if ( ! empty ( $ this -> startposition ) ) { $ query .= " STARTPOSITION " . $ this -> startposition ; } if ( ! empty ( $ this -> maxresults ) ) { $ query .= " MAXRESULTS " . $ this -> maxresults ; } return $ query ; } 
public static function createClient ( $ clientName = CoreConstants :: CLIENT_CURL ) { if ( $ clientName == CoreConstants :: CLIENT_CURL ) { if ( extension_loaded ( 'curl' ) ) { return new CurlHttpClient ( ) ; } else { throw new SdkException ( "curl extension is not enabled. Cannot create curl http client for the SDK." ) ; } } if ( strcasecmp ( $ clientName , CoreConstants :: CLIENT_GUZZLE ) == 0 || strcasecmp ( $ clientName , CoreConstants :: CLIENT_GUZZLE_FULL ) == 0 ) { if ( class_exists ( 'GuzzleHttp\Client' ) ) { return new GuzzleHttpClient ( ) ; } else { throw new SdkException ( "guzzle client cannot be found. Cannot create guzzle http client for the SDK." ) ; } } throw new SdkException ( "The client Name you passed is not supported. Please use either 'curl' or 'guzzle' for the client Name." ) ; } 
public static function update ( $ objToUpdate , array $ data ) { $ data = JournalEntry :: changeArrayName ( $ data ) ; $ classOfObj = get_class ( $ objToUpdate ) ; if ( strcmp ( $ classOfObj , FacadeHelper :: simpleAppendClassNameSpace ( "JournalEntry" ) ) != 0 ) { throw new \ Exception ( "Target object class:{" . $ classOfObj . "} is not an instance of JournalEntry." ) ; } $ newJournalEntryObj = JournalEntry :: create ( $ data ) ; $ clonedOfObj = FacadeHelper :: cloneObj ( $ objToUpdate ) ; FacadeHelper :: mergeObj ( $ clonedOfObj , $ newJournalEntryObj ) ; return $ clonedOfObj ; } 
public function GetLogDestination ( ) { if ( $ this -> EnableServiceRequestsLogging ) { if ( false === file_exists ( $ this -> ServiceRequestLoggingLocation ) ) { $ this -> ServiceRequestLoggingLocation = sys_get_temp_dir ( ) ; } } return $ this -> ServiceRequestLoggingLocation ; } 
public function LogPlatformRequests ( $ xml , $ url , $ headers , $ isRequest ) { if ( $ this -> EnableServiceRequestsLogging ) { if ( false === file_exists ( $ this -> ServiceRequestLoggingLocation ) ) { $ this -> ServiceRequestLoggingLocation = sys_get_temp_dir ( ) ; } 
public function isAllowed ( $ entity , $ operation ) { 
private function prepareDom ( ) { $ this -> dom = new \ DOMDocument ( '1.0' , 'UTF-8' ) ; if ( $ this -> debug ) { $ this -> dom -> formatOutput = true ; } $ this -> wsDefinitions = $ this -> dom -> createElementNS ( $ this -> namespaces [ 'wsdl' ] , 'wsdl:definitions' ) ; $ this -> dom -> appendChild ( $ this -> wsDefinitions ) ; $ this -> wsDefinitions -> setAttribute ( 'name' , $ this -> wsdlName ) ; $ this -> wsDefinitions -> setAttribute ( 'targetNamespace' , $ this -> wsdlTargetNamespace ) ; $ this -> dom -> createAttributeNS ( $ this -> wsdlTargetNamespace , $ this -> targetNsPrefix . ':definitions' ) ; 
private function prepareReflection ( ) { $ methods = $ this -> getClassMethods ( ) ; foreach ( $ methods as $ method ) { $ this -> methodsMeta [ $ method -> name ] = $ this -> getMethodIO ( $ method -> name ) ; } } 
public function toXml ( ) { if ( is_string ( $ this -> wsdlXmlSource ) && $ this -> wsdlXmlSource != '' ) { return $ this -> wsdlXmlSource ; } else { $ this -> prepareDom ( ) ; $ this -> prepareReflection ( ) ; $ this -> prepare ( ) ; $ this -> wsdlXmlSource = $ this -> dom -> saveXML ( ) ; return $ this -> wsdlXmlSource ; } } 
protected function getTypeName ( $ type ) { 
private function addImportToSchema ( $ namespace , $ code ) { if ( array_key_exists ( $ namespace , $ this -> docNamespaces ) ) { if ( in_array ( $ namespace , $ this -> importedNamespaces ) ) { return ; } 
public function getSchemaLocation ( $ ns ) { if ( $ this -> getSchemasPath ( ) == null ) { throw new \ RuntimeException ( "Schemas path is not specified - cannot start search for imports" ) ; } if ( ! file_exists ( $ this -> getSchemasPath ( ) ) ) { throw new \ RuntimeException ( "Schemas path doesn't exist - cannot start search for imports" ) ; } if ( $ this -> getPublicPath ( ) == null || ! file_exists ( $ this -> getPublicPath ( ) ) ) { throw new \ RuntimeException ( "Public folder for imported schemas is not specified or is not exist - cannot save imports" ) ; } if ( ! is_readable ( $ this -> getSchemasPath ( ) ) ) { throw new \ RuntimeException ( $ this -> getSchemasPath ( ) . " is not readable" ) ; } if ( ! is_writeable ( $ this -> getPublicPath ( ) ) ) { throw new \ RuntimeException ( $ this -> getPublicPath ( ) . " is not writable" ) ; } 
public function importsToAbsUrl ( $ schemaPath , $ relPath = '' ) { $ dom = new \ DOMDocument ( ) ; $ dom -> load ( $ schemaPath ) ; $ xpath = new \ DOMXPath ( $ dom ) ; $ query = "//*[local-name()='schema']/*[local-name()='import']" ; $ imports = $ xpath -> query ( $ query ) ; $ urlParts = parse_url ( $ this -> getLocation ( ) ) ; $ rootUrl = $ this -> composeUrl ( $ urlParts ) ; $ url = $ rootUrl . $ this -> getPublicUrl ( ) . "/" . basename ( $ schemaPath ) ; if ( ! is_object ( $ imports -> item ( 0 ) ) ) { return $ url ; } $ urlParts = parse_url ( $ this -> getLocation ( ) ) ; $ rootUrl = $ this -> composeUrl ( $ urlParts ) ; foreach ( $ imports as $ import ) { $ scPath = realpath ( $ relPath . DIRECTORY_SEPARATOR . $ import -> getAttribute ( 'schemaLocation' ) ) ; $ copiedSchema = $ this -> copyToPublic ( $ scPath , true ) ; $ schemaUrl = $ rootUrl . $ this -> getPublicUrl ( ) . "/" . basename ( $ copiedSchema ) ; $ import -> setAttribute ( 'schemaLocation' , $ schemaUrl ) ; $ this -> importsToAbsUrl ( $ copiedSchema , dirname ( $ scPath ) ) ; } $ dom -> save ( $ schemaPath ) ; return $ url ; } 
protected function getClassNamespace ( $ class ) { $ refl = new \ ReflectionClass ( $ class ) ; $ docs = $ this -> common -> parseDocComments ( $ refl -> getDocComment ( ) ) ; if ( ! array_key_exists ( "xmlNamespace" , $ docs ) ) { throw new \ RuntimeException ( 'Cannot find namespace in class description in ' . $ class ) ; } return $ docs [ 'xmlNamespace' ] ; } 
public function isTargetNamespaceEqualsTo ( $ schema , $ ns ) { $ dom = new \ DOMDocument ( ) ; $ dom -> load ( $ schema ) ; $ xpath = new \ DOMXPath ( $ dom ) ; $ query = "//*[local-name()='schema']/@targetNamespace" ; $ tNs = $ xpath -> query ( $ query ) ; if ( ! is_object ( $ tNs -> item ( 0 ) ) ) { return false ; } if ( $ tNs -> item ( 0 ) -> nodeValue === $ ns ) { return true ; } else { return false ; } } 
public function copyToPublic ( $ path , $ overwrite = false ) { $ publicPath = realpath ( $ this -> getPublicPath ( ) ) ; $ targetFilePath = $ publicPath . DIRECTORY_SEPARATOR . basename ( $ path ) ; if ( ( $ overwrite === true && file_exists ( $ targetFilePath ) ) || ! file_exists ( $ targetFilePath ) ) { if ( ! copy ( $ path , $ targetFilePath ) ) { throw new \ RuntimeException ( "Cannot copy " . basename ( $ path ) . " to " . $ publicPath ) ; } } return $ targetFilePath ; } 
public function composeUrl ( $ parts ) { $ url = "" ; if ( array_key_exists ( 'scheme' , $ parts ) ) { $ url .= $ parts [ 'scheme' ] . "://" ; } if ( array_key_exists ( 'host' , $ parts ) ) { $ url .= $ parts [ 'host' ] ; } if ( array_key_exists ( 'port' , $ parts ) ) { $ url .= ":" . $ parts [ 'port' ] ; } if ( array_key_exists ( 'path' , $ parts ) ) { } return $ url ; } 
private function get_class_vars_fix_order ( $ className ) { $ propNames = array ( ) ; $ parentClassName = get_parent_class ( $ className ) ; $ classMembersOnlyInherited = array ( ) ; if ( $ parentClassName ) { $ classMembersOnlyInherited = $ this -> get_class_vars_fix_order ( get_parent_class ( $ className ) ) ; } $ classMembersIncludingInherited = array_keys ( get_class_vars ( $ className ) ) ; $ classMembersNotInherited = array_diff ( $ classMembersIncludingInherited , $ classMembersOnlyInherited ) ; $ orderedClassMembers = array_merge ( $ classMembersOnlyInherited , $ classMembersNotInherited ) ; return $ orderedClassMembers ; } 
private function castToStringZero ( $ prop , $ obj ) { if ( $ this -> isEmptyInt ( $ prop -> getValue ( $ obj ) ) ) { 
public function Log ( $ idsTraceLevel , $ messageToWrite ) { $ fileToWrite = CoreConstants :: DEFAULT_LOGGINGLOCATION . '/executionlog.txt' ; if ( file_exists ( $ fileToWrite ) && is_writable ( $ fileToWrite ) ) { file_put_contents ( $ fileToWrite , $ messageToWrite . "\n" , FILE_APPEND ) ; } } 
public static function ReadConfigurationFromFile ( $ filePath , $ OAuthOption = CoreConstants :: OAUTH1 ) { $ ippConfig = new IppConfiguration ( ) ; try { if ( isset ( $ filePath ) && file_exists ( $ filePath ) ) { $ xmlObj = simplexml_load_file ( $ filePath ) ; } else { 
public static function initializeAPIEntityRules ( $ xmlObj , $ ippConfig ) { $ rules = CoreConstants :: getQuickBooksOnlineAPIEntityRules ( ) ; LocalConfigReader :: initOperationControlList ( $ ippConfig , $ rules ) ; $ specialConfig = LocalConfigReader :: populateJsonOnlyEntities ( $ xmlObj ) ; if ( is_array ( $ specialConfig ) && ( $ ippConfig -> OpControlList instanceof OperationControlList ) ) { $ ippConfig -> OpControlList -> appendRules ( $ specialConfig ) ; } } 
public static function initOperationControlList ( $ ippConfig , $ array ) { $ ippConfig -> OpControlList = new OperationControlList ( OperationControlList :: getDefaultList ( true ) ) ; $ ippConfig -> OpControlList -> appendRules ( $ array ) ; } 
public static function setupMinorVersion ( $ ippConfig , $ xmlObj ) { if ( isset ( $ xmlObj ) && isset ( $ xmlObj -> intuit -> ipp -> minorVersion ) ) { $ ippConfig -> minorVersion = ( int ) $ xmlObj -> intuit -> ipp -> minorVersion ; } } 
public static function populateJsonOnlyEntities ( $ xmlObj ) { if ( isset ( $ xmlObj ) && isset ( $ xmlObj -> intuit -> ipp -> specialConfiguration ) ) { $ specialCnf = $ xmlObj -> intuit -> ipp -> specialConfiguration ; if ( ! $ specialCnf instanceof SimpleXMLElement ) { return false ; } if ( ! $ specialCnf -> children ( ) instanceof SimpleXMLElement ) { return false ; } if ( ! $ specialCnf -> children ( ) -> count ( ) ) { return false ; } $ rules = array ( ) ; foreach ( $ specialCnf -> children ( ) as $ entity ) { if ( ! $ entity -> attributes ( ) -> count ( ) ) { continue ; } $ name = self :: decorateEntity ( $ entity -> getName ( ) ) ; if ( ! array_key_exists ( $ name , $ rules ) ) { $ rules [ $ name ] = array ( ) ; } foreach ( $ entity -> attributes ( ) as $ attr ) { $ rules [ $ name ] [ $ attr -> getName ( ) ] = filter_var ( ( string ) $ entity -> attributes ( ) , FILTER_VALIDATE_BOOLEAN ) ; } } return $ rules ; } return false ; } 
public static function initializeOAuthSettings ( $ xmlObj , $ ippConfig , $ OAuthOption ) { 
public static function initializeRequestAndResponseSerializationAndCompressionFormat ( $ xmlObj , $ ippConfig ) { LocalConfigReader :: intializeMessage ( $ ippConfig ) ; $ requestSerializationFormat = null ; $ requestCompressionFormat = null ; $ responseSerializationFormat = null ; $ responseCompressionFormat = null ; if ( isset ( $ xmlObj ) && isset ( $ xmlObj -> intuit -> ipp -> message -> request ) ) { $ requestAttr = $ xmlObj -> intuit -> ipp -> message -> request -> attributes ( ) ; $ requestSerializationFormat = ( string ) $ requestAttr -> serializationFormat ; $ requestCompressionFormat = ( string ) $ requestAttr -> compressionFormat ; } 
public static function intializaeServiceBaseURLAndLogger ( $ xmlObj , $ ippConfig ) { 
public function getEntity ( $ key ) { foreach ( $ this -> entities as $ entityKey => $ entityVal ) { if ( $ entityKey == $ key ) { return $ entityVal ; } } return null ; } 
public static function cleanPhpClassNameToIntuitEntityName ( $ phpClassName ) { 
public static function update ( $ objToUpdate , array $ data ) { $ classOfObj = get_class ( $ objToUpdate ) ; if ( strcmp ( $ classOfObj , FacadeHelper :: simpleAppendClassNameSpace ( "Payment" ) ) != 0 ) { throw new \ Exception ( "Target object class:{" . $ classOfObj . "} is not an instance of Payment." ) ; } $ newPaymentObj = Payment :: create ( $ data ) ; $ clonedOfObj = FacadeHelper :: cloneObj ( $ objToUpdate ) ; FacadeHelper :: mergeObj ( $ clonedOfObj , $ newPaymentObj ) ; return $ clonedOfObj ; } 
public static function HandleErrors ( $ response ) { 
public static function HandleErrorsXml ( $ responseXml ) { $ errCodeNode = $ responseXml -> { UtilityConstants :: ERRCODEXPATH } ; if ( $ errCodeNode == null ) { return ; } if ( ( int ) $ errCodeNode ) { throw new IdsException ( 'HandleErrors error code (UtilityConstants::ERRCODEXPATH): ' . ( int ) $ errCodeNode ) ; } $ errTextNode = $ responseXml -> { UtilityConstants :: ERRTEXTXPATH } ; if ( $ errTextNode == null ) { throw new IdsException ( 'HandleErrors error code (UtilityConstants::ERRTEXTXPATH): ' . ( int ) $ errCodeNode ) ; } $ errorText = ( string ) $ errTextNode ; $ errDetailNode = $ responseXml -> { UtilityConstants :: ERRDETAILXPATH } ; $ errorDetail = $ errDetailNode != null ? ( string ) $ errDetailNode : null ; if ( ! $ errorDetail ) { throw new IdsException ( 'HandleErrors error code (UtilityConstants::ERRDETAILXPATH): ' . ( string ) $ errorDetail ) ; } throw new IdsException ( 'HandleErrors error code: ' . $ errorText ) ; } 
public static function IsValidXml ( $ inputString ) { if ( 0 !== strpos ( $ inputString , '<' ) ) { return false ; } try { $ doc = simplexml_load_string ( $ inputString ) ; } catch ( \ Exception $ e ) { return false ; } return true ; } 
public function verifyConfiguration ( ) { if ( ( $ this -> strategy === CoreConstants :: EXPORT_STRATEGY ) && ! empty ( $ this -> strategy ) ) { if ( is_null ( $ this -> exportDir ) ) { throw new SdkException ( "Invalid value for exportDirectory property. It can not be null with 'export' strategy. " ) ; } 
public static function loadWebServicesClassAndReturnNames ( $ dir = null ) { if ( $ dir == null ) { $ dir = dirname ( __DIR__ ) . DIRECTORY_SEPARATOR . UtilityConstants :: WEBHOOKSDIR ; } $ webhooksClassNames = array ( ) ; foreach ( glob ( "{$dir}/*.php" ) as $ fileName ) { require_once ( $ fileName ) ; 
public static function isValidWebhooksClass ( $ className , $ classCollection = null ) { if ( ! isset ( $ classCollection ) ) { $ classCollection = ReflectionUtil :: loadWebServicesClassAndReturnNames ( ) ; } if ( ! isset ( $ className ) || trim ( $ className ) === '' ) { return null ; } $ singlerClassName = ClassNamingUtil :: singularize ( $ className ) ; $ capitalFirstSinglerClassName = ucfirst ( $ singlerClassName ) ; foreach ( $ classCollection as $ k => $ v ) { if ( strcmp ( $ capitalFirstSinglerClassName , $ v ) == 0 ) { return $ capitalFirstSinglerClassName ; } } return null ; } 
public static function constructObjectFromWebhooksArray ( $ array , $ arrayContainerClassName ) { $ clazz = ReflectionUtil :: isValidWebhooksClass ( $ arrayContainerClassName ) ; if ( ! isset ( $ clazz ) ) { return null ; } $ wrapObject = new $ clazz ( ) ; if ( isset ( $ array ) && ! empty ( $ array ) ) { foreach ( $ array as $ key => $ value ) { if ( is_array ( $ value ) ) { 
public function setOptions ( $ options ) { if ( $ options instanceof Zend_Config ) { $ options = $ options -> toArray ( ) ; } foreach ( $ options as $ key => $ value ) { switch ( $ key ) { case 'actor' : $ this -> setActor ( $ value ) ; break ; case 'classmap' : case 'classMap' : $ this -> setClassmap ( $ value ) ; break ; case 'encoding' : $ this -> setEncoding ( $ value ) ; break ; case 'soapVersion' : case 'soap_version' : $ this -> setSoapVersion ( $ value ) ; break ; case 'uri' : $ this -> setUri ( $ value ) ; break ; case 'wsdl' : $ this -> setWsdl ( $ value ) ; break ; case 'featues' : $ this -> setSoapFeatures ( $ value ) ; break ; case 'cache_wsdl' : $ this -> setWsdlCache ( $ value ) ; break ; default : break ; } } return $ this ; } 
public function getOptions ( ) { $ options = array ( ) ; if ( null !== $ this -> _actor ) { $ options [ 'actor' ] = $ this -> _actor ; } if ( null !== $ this -> _classmap ) { $ options [ 'classmap' ] = $ this -> _classmap ; } if ( null !== $ this -> _encoding ) { $ options [ 'encoding' ] = $ this -> _encoding ; } if ( null !== $ this -> _soapVersion ) { $ options [ 'soap_version' ] = $ this -> _soapVersion ; } if ( null !== $ this -> _uri ) { $ options [ 'uri' ] = $ this -> _uri ; } if ( null !== $ this -> _features ) { $ options [ 'features' ] = $ this -> _features ; } if ( null !== $ this -> _wsdlCache ) { $ options [ 'cache_wsdl' ] = $ this -> _wsdlCache ; } return $ options ; } 
public function setSoapVersion ( $ version ) { if ( ! in_array ( $ version , array ( SOAP_1_1 , SOAP_1_2 ) ) ) { require_once 'Zend/Soap/Server/Exception.php' ; throw new Zend_Soap_Server_Exception ( 'Invalid soap version specified' ) ; } $ this -> _soapVersion = $ version ; return $ this ; } 
public function validateUrn ( $ urn ) { $ scheme = parse_url ( $ urn , PHP_URL_SCHEME ) ; if ( $ scheme === false || $ scheme === null ) { require_once 'Zend/Soap/Server/Exception.php' ; throw new Zend_Soap_Server_Exception ( 'Invalid URN' ) ; } return true ; } 
public function setClassmap ( $ classmap ) { if ( ! is_array ( $ classmap ) ) { require_once 'Zend/Soap/Server/Exception.php' ; throw new Zend_Soap_Server_Exception ( 'Classmap must be an array' ) ; } foreach ( $ classmap as $ type => $ class ) { if ( ! class_exists ( $ class ) ) { require_once 'Zend/Soap/Server/Exception.php' ; throw new Zend_Soap_Server_Exception ( 'Invalid class in class map' ) ; } } $ this -> _classmap = $ classmap ; return $ this ; } 
public function addFunction ( $ function , $ namespace = '' ) { 
public function setClass ( $ class , $ namespace = '' , $ argv = null ) { if ( isset ( $ this -> _class ) ) { require_once 'Zend/Soap/Server/Exception.php' ; throw new Zend_Soap_Server_Exception ( 'A class has already been registered with this soap server instance' ) ; } if ( ! is_string ( $ class ) ) { require_once 'Zend/Soap/Server/Exception.php' ; throw new Zend_Soap_Server_Exception ( 'Invalid class argument (' . gettype ( $ class ) . ')' ) ; } if ( ! class_exists ( $ class ) ) { require_once 'Zend/Soap/Server/Exception.php' ; throw new Zend_Soap_Server_Exception ( 'Class "' . $ class . '" does not exist' ) ; } $ this -> _class = $ class ; if ( 1 < func_num_args ( ) ) { $ argv = func_get_args ( ) ; array_shift ( $ argv ) ; $ this -> _classArgs = $ argv ; } return $ this ; } 
public function setObject ( $ object ) { if ( ! is_object ( $ object ) ) { require_once 'Zend/Soap/Server/Exception.php' ; throw new Zend_Soap_Server_Exception ( 'Invalid object argument (' . gettype ( $ object ) . ')' ) ; } if ( isset ( $ this -> _object ) ) { require_once 'Zend/Soap/Server/Exception.php' ; throw new Zend_Soap_Server_Exception ( 'An object has already been registered with this soap server instance' ) ; } $ this -> _object = $ object ; return $ this ; } 
public function getFunctions ( ) { $ functions = array ( ) ; if ( null !== $ this -> _class ) { $ functions = get_class_methods ( $ this -> _class ) ; } elseif ( null !== $ this -> _object ) { $ functions = get_class_methods ( $ this -> _object ) ; } return array_merge ( ( array ) $ this -> _functions , $ functions ) ; } 
public function setPersistence ( $ mode ) { if ( ! in_array ( $ mode , array ( SOAP_PERSISTENCE_SESSION , SOAP_PERSISTENCE_REQUEST ) ) ) { require_once 'Zend/Soap/Server/Exception.php' ; throw new Zend_Soap_Server_Exception ( 'Invalid persistence mode specified' ) ; } $ this -> _persistence = $ mode ; return $ this ; } 
protected function _setRequest ( $ request ) { if ( $ request instanceof DOMDocument ) { $ xml = $ request -> saveXML ( ) ; } elseif ( $ request instanceof DOMNode ) { $ xml = $ request -> ownerDocument -> saveXML ( ) ; } elseif ( $ request instanceof SimpleXMLElement ) { $ xml = $ request -> asXML ( ) ; } elseif ( is_object ( $ request ) || is_string ( $ request ) ) { if ( is_object ( $ request ) ) { $ xml = $ request -> __toString ( ) ; } else { $ xml = $ request ; } $ dom = new DOMDocument ( ) ; if ( strlen ( $ xml ) == 0 || ! $ dom -> loadXML ( $ xml ) ) { require_once 'Zend/Soap/Server/Exception.php' ; throw new Zend_Soap_Server_Exception ( 'Invalid XML' ) ; } } $ this -> _request = $ xml ; return $ this ; } 
protected function _getSoap ( ) { $ options = $ this -> getOptions ( ) ; $ server = new SoapServer ( $ this -> _wsdl , $ options ) ; if ( ! empty ( $ this -> _functions ) ) { $ server -> addFunction ( $ this -> _functions ) ; } if ( ! empty ( $ this -> _class ) ) { $ args = $ this -> _classArgs ; array_unshift ( $ args , $ this -> _class ) ; call_user_func_array ( array ( $ server , 'setClass' ) , $ args ) ; } if ( ! empty ( $ this -> _object ) ) { $ server -> setObject ( $ this -> _object ) ; } if ( null !== $ this -> _persistence ) { $ server -> setPersistence ( $ this -> _persistence ) ; } return $ server ; } 
public function handle ( $ request = null ) { if ( null === $ request ) { $ request = file_get_contents ( 'php://input' ) ; } * @see Zend_Soap_Server_Exception */ require_once 'Zend/Soap/Server/Exception.php' ; try { $ this -> _setRequest ( $ request ) ; } catch ( Zend_Soap_Server_Exception $ e ) { $ setRequestException = $ e ; } $ soap = $ this -> _getSoap ( ) ; ob_start ( ) ; if ( $ setRequestException instanceof Exception ) { 
public function deregisterFaultException ( $ class ) { if ( in_array ( $ class , $ this -> _faultExceptions , true ) ) { $ index = array_search ( $ class , $ this -> _faultExceptions ) ; unset ( $ this -> _faultExceptions [ $ index ] ) ; return true ; } return false ; } 
public function fault ( $ fault = null , $ code = "Receiver" ) { if ( $ fault instanceof Exception ) { $ class = get_class ( $ fault ) ; if ( in_array ( $ class , $ this -> _faultExceptions ) ) { $ message = $ fault -> getMessage ( ) ; $ eCode = $ fault -> getCode ( ) ; $ code = empty ( $ eCode ) ? $ code : $ eCode ; } else { $ message = 'Unknown error' ; } } elseif ( is_string ( $ fault ) ) { $ message = $ fault ; } else { $ message = 'Unknown error' ; } $ allowedFaultModes = array ( 'VersionMismatch' , 'MustUnderstand' , 'DataEncodingUnknown' , 'Sender' , 'Receiver' , 'Server' ) ; if ( ! in_array ( $ code , $ allowedFaultModes ) ) { $ code = "Receiver" ; } return new SoapFault ( $ code , $ message ) ; } 
public function handlePhpErrors ( $ errno , $ errstr , $ errfile = null , $ errline = null , array $ errcontext = null ) { throw $ this -> fault ( $ errstr , "Receiver" ) ; } 
public function getAccessToken ( ) { if ( isset ( $ this -> oauth2AccessToken ) && ! empty ( $ this -> oauth2AccessToken ) ) { return $ this -> oauth2AccessToken ; } else { throw new SdkException ( "Can't get OAuth 2 Access Token Object. It is not set yet." ) ; } } 
public function getClientID ( ) { if ( isset ( $ this -> clientID ) && ! empty ( $ this -> clientID ) ) { return ( String ) $ this -> clientID ; } else { throw new SdkException ( "Can't get OAuth 2 Client ID. It is not set." ) ; } } 
public function getClientSecret ( ) { if ( isset ( $ this -> clientSecret ) && ! empty ( $ this -> clientSecret ) ) { return ( String ) $ this -> clientSecret ; } else { throw new SdkException ( "Can't get OAuth 2 Client Secret. It is not set." ) ; } } 
public function getScope ( ) { if ( isset ( $ this -> scope ) && ! empty ( $ this -> scope ) ) { return ( String ) $ this -> scope ; } else { throw new SdkException ( "Can't get OAuth 2 Scope. It is not set." ) ; } } 
public function getRedirectURL ( ) { if ( isset ( $ this -> redirectUri ) && ! empty ( $ this -> redirectUri ) ) { return ( String ) $ this -> redirectUri ; } else { throw new SdkException ( "Can't get OAuth 2 redirectUri. It is not set." ) ; } } 
public function getState ( ) { if ( isset ( $ this -> state ) && ! empty ( $ this -> state ) ) { return ( String ) $ this -> state ; } else { throw new SdkException ( "Can't get OAuth 2 state. It is not set." ) ; } } 
public function getAuthorizationCodeURL ( ) { $ parameters = array ( 'client_id' => $ this -> getClientID ( ) , 'scope' => $ this -> getScope ( ) , 'redirect_uri' => $ this -> getRedirectURL ( ) , 'response_type' => 'code' , 'state' => $ this -> getState ( ) ) ; $ authorizationRequestUrl = CoreConstants :: OAUTH2_AUTHORIZATION_REQUEST_URL ; $ authorizationRequestUrl .= '?' . http_build_query ( $ parameters , null , '&' , PHP_QUERY_RFC1738 ) ; return $ authorizationRequestUrl ; } 
public function exchangeAuthorizationCodeForToken ( $ code , $ realmID ) { if ( ! isset ( $ code ) ) { throw new SdkException ( "The code is not set. Can't exchange for OAuth 2 Access Token." ) ; } $ parameters = array ( 'grant_type' => 'authorization_code' , 'code' => ( String ) $ code , 'redirect_uri' => $ this -> getRedirectURL ( ) ) ; $ authorizationHeaderInfo = $ this -> generateAuthorizationHeader ( ) ; $ http_header = array ( 'Accept' => 'application/json' , 'Authorization' => $ authorizationHeaderInfo , 'Content-Type' => 'application/x-www-form-urlencoded' ) ; $ intuitResponse = $ this -> curlHttpClient -> makeAPICall ( CoreConstants :: OAUTH2_TOKEN_ENDPOINT_URL , CoreConstants :: HTTP_POST , $ http_header , http_build_query ( $ parameters ) , null , true ) ; $ this -> faultHandler = $ intuitResponse -> getFaultHandler ( ) ; if ( $ this -> faultHandler ) { throw new ServiceException ( "Exchange Authorization Code for Access Token failed. Body: [" . $ this -> faultHandler -> getResponseBody ( ) . "]." , $ this -> faultHandler -> getHttpStatusCode ( ) ) ; } else { $ this -> faultHandler = false ; $ this -> oauth2AccessToken = $ this -> parseNewAccessTokenFromResponse ( $ intuitResponse -> getBody ( ) , $ realmID ) ; return $ this -> getAccessToken ( ) ; } } 
public function refreshToken ( ) { $ refreshToken = $ this -> getAccessToken ( ) -> getRefreshToken ( ) ; $ http_header = $ this -> constructRefreshTokenHeader ( ) ; $ requestBody = $ this -> constructRefreshTokenBody ( $ refreshToken ) ; $ intuitResponse = $ this -> curlHttpClient -> makeAPICall ( CoreConstants :: OAUTH2_TOKEN_ENDPOINT_URL , CoreConstants :: HTTP_POST , $ http_header , $ requestBody , null , true ) ; $ this -> faultHandler = $ intuitResponse -> getFaultHandler ( ) ; if ( $ this -> faultHandler ) { throw new ServiceException ( "Refresh OAuth 2 Access token with Refresh Token failed. Body: [" . $ this -> faultHandler -> getResponseBody ( ) . "]." , $ this -> faultHandler -> getHttpStatusCode ( ) ) ; } else { $ this -> faultHandler = false ; $ this -> oauth2AccessToken = $ this -> parseNewAccessTokenFromResponse ( $ intuitResponse -> getBody ( ) ) ; return $ this -> getAccessToken ( ) ; } } 
public function revokeToken ( $ accessTokenOrRefreshToken ) { if ( ! isset ( $ accessTokenOrRefreshToken ) ) { throw new SdkException ( "The refresh token or access token is not set. Can't revoke OAuth 2 Token." ) ; } $ parameters = array ( "token" => ( String ) $ accessTokenOrRefreshToken ) ; $ authorizationHeaderInfo = $ this -> generateAuthorizationHeader ( ) ; $ http_header = array ( 'Accept' => 'application/json' , 'Authorization' => $ authorizationHeaderInfo , 'Content-Type' => 'application/json' ) ; $ intuitResponse = $ this -> curlHttpClient -> makeAPICall ( CoreConstants :: REVOCATION_ENDPONT , CoreConstants :: HTTP_POST , $ http_header , json_encode ( $ parameters ) , null , true ) ; $ this -> faultHandler = $ intuitResponse -> getFaultHandler ( ) ; if ( $ this -> faultHandler ) { throw new ServiceException ( "Revoke Token failed. Body: [" . $ this -> faultHandler -> getResponseBody ( ) . "]." , $ this -> faultHandler -> getHttpStatusCode ( ) ) ; } else { $ this -> faultHandler = false ; return true ; } } 
public function OAuth1ToOAuth2Migration ( $ consumerKey , $ consumerSecret , $ accessToken , $ accessTokenSecret , $ scope ) { $ oauth1Encrypter = new OAuth1 ( $ consumerKey , $ consumerSecret , $ accessToken , $ accessTokenSecret ) ; $ parameters = array ( 'scope' => $ scope , 'redirect_uri' => "https://developer.intuit.com/v2/OAuth2Playground/RedirectUrl" , 'client_id' => $ this -> getClientID ( ) , 'client_secret' => $ this -> getClientSecret ( ) ) ; $ baseURL = "https://developer.api.intuit.com/v2/oauth2/tokens/migrate" ; $ authorizationHeaderInfo = $ oauth1Encrypter -> getOAuthHeader ( $ baseURL , array ( ) , "POST" ) ; $ http_header = array ( 'Accept' => 'application/json' , 'Authorization' => $ authorizationHeaderInfo , 'Content-Type' => 'application/json' ) ; $ intuitResponse = $ this -> curlHttpClient -> makeAPICall ( $ baseURL , CoreConstants :: HTTP_POST , $ http_header , json_encode ( $ parameters ) , null , false ) ; $ this -> faultHandler = $ intuitResponse -> getFaultHandler ( ) ; if ( $ this -> faultHandler ) { throw new ServiceException ( "Migrate OAuth 1 token to OAuth 2 token failed. Body: [" . $ this -> faultHandler -> getResponseBody ( ) . "]." , $ this -> faultHandler -> getHttpStatusCode ( ) ) ; } else { $ this -> faultHandler = false ; $ this -> oauth2AccessToken = $ this -> parseNewAccessTokenFromResponse ( $ intuitResponse -> getBody ( ) ) ; return $ this -> getAccessToken ( ) ; } } 
private function parseNewAccessTokenFromResponse ( $ body , $ realmID = null ) { if ( is_string ( $ body ) ) { $ json_body = json_decode ( $ body , true ) ; if ( json_last_error ( ) === JSON_ERROR_NONE ) { $ tokenExpiresTime = $ json_body [ CoreConstants :: EXPIRES_IN ] ; $ refreshToken = $ json_body [ CoreConstants :: OAUTH2_REFRESH_GRANTYPE ] ; $ refreshTokenExpiresTime = $ json_body [ CoreConstants :: X_REFRESH_TOKEN_EXPIRES_IN ] ; $ accessToken = $ json_body [ CoreConstants :: ACCESS_TOKEN ] ; $ this -> checkIfEmptyValueReturned ( $ tokenExpiresTime , $ refreshToken , $ refreshTokenExpiresTime , $ accessToken ) ; 
private function checkIfEmptyValueReturned ( $ tokenExpiresTime , $ refreshToken , $ refreshTokenExpiresTime , $ accessToken ) { if ( empty ( $ tokenExpiresTime ) ) { throw new SdkException ( "Error Retrieve RefreshToken from Response. Token Expires In Time is Empty." ) ; } if ( empty ( $ refreshToken ) ) { throw new SdkException ( "Error Retrieve RefreshToken from Response. Refresh Token is Empty." ) ; } if ( empty ( $ refreshTokenExpiresTime ) ) { throw new SdkException ( "Error Retrieve RefreshToken from Response. Refresh Token Expires Time is Empty." ) ; } if ( empty ( $ accessToken ) ) { throw new SdkException ( "Error Retrieve RefreshToken from Response. Access Token is Empty." ) ; } } 
private function generateAuthorizationHeader ( ) { $ encodedClientIDClientSecrets = base64_encode ( $ this -> getClientID ( ) . ':' . $ this -> getClientSecret ( ) ) ; $ authorizationheader = CoreConstants :: OAUTH2_AUTHORIZATION_TYPE . $ encodedClientIDClientSecrets ; return $ authorizationheader ; } 
private function constructRefreshTokenHeader ( ) { $ authorizationHeaderInfo = $ this -> generateAuthorizationHeader ( ) ; $ http_header = array ( 'Accept' => CoreConstants :: CONTENTTYPE_APPLICATIONJSON , 'Authorization' => $ authorizationHeaderInfo , 'Content-Type' => CoreConstants :: CONTENTTYPE_URLFORMENCODED , 'connection' => 'close' ) ; return $ http_header ; } 
private function checkResult ( $ result ) { $ this -> lastError = json_last_error ( ) ; if ( JSON_ERROR_NONE !== $ this -> lastError ) { IdsExceptionManager :: HandleException ( $ this -> getMessageFromErrorCode ( $ this -> lastError ) ) ; } 
private function getMessageFromErrorCode ( $ error ) { if ( function_exists ( 'json_last_error_msg' ) ) { return json_last_error_msg ( ) ; } $ errors = array ( JSON_ERROR_NONE => null , JSON_ERROR_DEPTH => 'Maximum stack depth exceeded' , JSON_ERROR_STATE_MISMATCH => 'Underflow or the modes mismatch' , JSON_ERROR_CTRL_CHAR => 'Unexpected control character found' , JSON_ERROR_SYNTAX => 'Syntax error, malformed JSON' , JSON_ERROR_UTF8 => 'Malformed UTF-8 characters, possibly incorrectly encoded' ) ; return array_key_exists ( $ error , $ errors ) ? $ errors [ $ error ] : "Unknown error ({$error})" ; } 
private function convertObject ( $ object , $ limitToOne ) { if ( $ object instanceof \ stdClass ) { $ result = array ( ) ; $ vars = get_object_vars ( $ object ) ; if ( empty ( $ vars ) ) { return null ; } foreach ( $ vars as $ key => $ value ) { $ className = self :: decorateIntuitEntityToPhpClassName ( $ key ) ; if ( ! class_exists ( $ className ) ) { continue ; } $ entity = DomainEntityBuilder :: create ( $ className , $ value ) ; if ( $ limitToOne ) { return $ entity ; } $ result [ ] = $ entity ; } if ( empty ( $ result ) ) { 
public function Serialize ( $ entity ) { $ this -> collectResourceURL ( $ entity ) ; $ arrayObj = $ this -> customerConvertObjectToArray ( $ entity ) ; $ array = $ this -> removeNullProperties ( $ arrayObj ) ; return $ this -> checkResult ( json_encode ( $ array , true ) ) ; } 
private function removeNullProperties ( $ val ) { $ filterArray = array_filter ( $ val ) ; $ returned = array ( ) ; foreach ( $ filterArray as $ k => $ v ) { if ( is_array ( $ v ) ) { if ( FacadeHelper :: isRecurrsiveArray ( $ v ) ) { $ list = array ( ) ; foreach ( $ v as $ kk => $ vv ) { $ list [ ] = array_filter ( $ vv ) ; } $ returned [ $ k ] = $ list ; } } else { $ returned [ $ k ] = $ v ; } } return $ returned ; } 
public function Deserialize ( $ message , $ limitToOne = false ) { return $ this -> convertObject ( $ this -> checkResult ( json_decode ( $ message ) ) , $ limitToOne ) ; } 
public function addComplexType ( $ type ) { if ( ! class_exists ( $ type ) ) { require_once "Zend/Soap/Wsdl/Exception.php" ; throw new Zend_Soap_Wsdl_Exception ( sprintf ( "Cannot add a complex type %s that is not an object or where " . "class could not be found in 'DefaultComplexType' strategy." , $ type ) ) ; } $ dom = $ this -> getContext ( ) -> toDomDocument ( ) ; $ class = new ReflectionClass ( $ type ) ; $ complexType = $ dom -> createElement ( 'xsd:complexType' ) ; $ complexType -> setAttribute ( 'name' , $ type ) ; $ all = $ dom -> createElement ( 'xsd:all' ) ; foreach ( $ class -> getProperties ( ) as $ property ) { if ( $ property -> isPublic ( ) && preg_match_all ( '/@var\s+([^\s]+)/m' , $ property -> getDocComment ( ) , $ matches ) ) { $ element = $ dom -> createElement ( 'xsd:element' ) ; $ element -> setAttribute ( 'name' , $ property -> getName ( ) ) ; $ element -> setAttribute ( 'type' , $ this -> getContext ( ) -> getType ( trim ( $ matches [ 1 ] [ 0 ] ) ) ) ; $ all -> appendChild ( $ element ) ; } } $ complexType -> appendChild ( $ all ) ; $ this -> getContext ( ) -> getSchema ( ) -> appendChild ( $ complexType ) ; $ this -> getContext ( ) -> addType ( $ type ) ; return "tns:$type" ; } 
public function getWsdl ( $ class = null ) { $this->addTypes(); $this->addMessages(); $this->addPortType(); $this->addBindings(); $this->addServices(); $dom = $this->wsdl->toDomDocument(); if ($this->debug) { $dom->formatOutput = true; }*/ return $ this -> wsdl -> toXml ( ) ; 
private function addBindings ( ) { $ this -> binding = $ this -> wsdl -> addBinding ( $ this -> refl -> getShortName ( ) . $ this -> bindingNameSuffix , $ this -> targetNsPrefix . ":" . $ this -> getBindingTypeName ( ) ) ; $ this -> wsdl -> addSoapBinding ( $ this -> binding , $ this -> getSoapBindingStyle ( ) , $ this -> getSoapBindingTransport ( ) ) ; $ this -> addBindingOperations ( ) ; return $ this -> binding ; } 
private function addPortType ( ) { $ this -> portType = $ this -> wsdl -> addPortType ( $ this -> getPortName ( ) ) ; $ this -> addPortOperations ( ) ; return $ this -> portType ; } 
public function addTypes ( ) { $ methods = $ this -> getClassMethods ( ) ; foreach ( $ methods as $ method ) { $ data = $ this -> getMethodIO ( $ method -> name ) ; $ element = array ( 'name' => $ method -> name , 'sequence' => array ( ) ) ; if ( array_key_exists ( "params" , $ data ) ) { foreach ( $ data [ 'params' ] as $ param ) { if ( $ this -> isLocalType ( $ this -> getTypeName ( $ param [ 'type' ] ) ) ) { array_push ( $ element [ 'sequence' ] , array ( 'name' => $ param [ 'name' ] , 'type' => $ this -> getTypeName ( $ param [ 'type' ] ) ) ) ; } else { array_push ( $ element [ 'sequence' ] , array ( 'ref' => $ this -> getTypeName ( $ param [ 'type' ] ) ) ) ; } } $ this -> wsdl -> addElement ( $ element ) ; } if ( array_key_exists ( "return" , $ data ) ) { $ return = "" ; if ( $ this -> isLocalType ( $ this -> getTypeName ( $ data [ 'return' ] [ 'type' ] ) ) ) { $ return = array ( 'name' => $ method -> name . $ this -> responseSuffix , 'sequence' => array ( array ( 'name' => 'Response' , 'type' => $ this -> getTypeName ( $ data [ 'return' ] [ 'type' ] ) ) ) ) ; } else { $ return = array ( 'name' => $ method -> name . $ this -> responseSuffix , 'sequence' => array ( array ( 'ref' => $ this -> getTypeName ( $ data [ 'return' ] [ 'type' ] ) ) ) ) ; } $ this -> wsdl -> addElement ( $ return ) ; } } } 
public function addBindingOperations ( ) { $ methods = $ this -> getClassMethods ( ) ; 
private function addPortOperations ( ) { $ methods = $ this -> getClassMethods ( ) ; foreach ( $ methods as $ method ) { $ data = $ this -> getMethodIO ( $ method -> name ) ; $ input = false ; $ output = false ; $ bindingInput = false ; $ bindingOutput = false ; if ( array_key_exists ( "params" , $ data ) ) { $ input = $ this -> targetNsPrefix . ":" . $ method -> name . $ this -> requestSuffix ; } if ( array_key_exists ( "return" , $ data ) ) { $ output = $ this -> targetNsPrefix . ":" . $ method -> name . $ this -> responseSuffix ; } $ this -> wsdl -> addPortOperation ( $ this -> portType , $ method -> name , $ input , $ output ) ; } } 
public function isLocalType ( $ type ) { if ( preg_match ( '/:/' , $ type ) ) { list ( $ ns , $ typeName ) = explode ( ":" , $ type ) ; if ( $ ns == $ this -> targetNsPrefix || $ ns == $ this -> xmlSchemaPreffix ) { return true ; 
public function addMessages ( ) { $ methods = $ this -> getClassMethods ( ) ; $ messages = array ( ) ; foreach ( $ methods as $ method ) { $ data = $ this -> getMethodIO ( $ method -> name ) ; $ input = false ; $ output = false ; 
private function getMethodIO ( $ method ) { $ methodDocs = $ this -> refl -> getMethod ( $ method ) -> getDocComment ( ) ; return $ this -> parseDocComments ( $ methodDocs ) ; } 
private function addServices ( ) { $ this -> wsdl -> addService ( $ this -> getServiceName ( ) , $ this -> getPortName ( ) , $ this -> getBindingName ( ) , $ this -> getLocation ( ) ) ; } 
private function getTypeName ( $ type ) { 
private function addImportToSchema ( $ namespace , $ code ) { if ( array_key_exists ( $ namespace , $ this -> namespaces ) ) { if ( in_array ( $ namespace , $ this -> importedNamespaces ) ) { return ; } $ dom = $ this -> wsdl -> toDomDocument ( ) ; $ dom -> createAttributeNs ( $ namespace , $ code . ":definitions" ) ; $ importEl = $ dom -> createElement ( $ this -> xmlSchemaPreffix . ":import" ) ; $ nsAttr = $ dom -> createAttribute ( "namespace" ) ; $ txtNode = $ dom -> createTextNode ( $ namespace ) ; $ nsAttr -> appendChild ( $ txtNode ) ; $ nsAttr2 = $ dom -> createAttribute ( "schemaLocation" ) ; $ schemaLocation = $ this -> getSchemaLocation ( $ namespace ) ; $ publicSchema = $ this -> copyToPublic ( $ schemaLocation , true ) ; $ publicSchema = $ this -> copyToPublic ( $ schemaLocation , true ) ; $ schemaUrl = $ this -> importsToAbsUrl ( $ publicSchema , $ this -> getSchemasPath ( ) ) ; $ txtNode2 = $ dom -> createTextNode ( $ schemaUrl ) ; $ nsAttr2 -> appendChild ( $ txtNode2 ) ; $ importEl -> appendChild ( $ nsAttr ) ; $ importEl -> appendChild ( $ nsAttr2 ) ; $ this -> wsdl -> getSchema ( ) ; $ xpath = new \ DOMXPath ( $ dom ) ; $ query = "//*[local-name()='types']/child::*/*" ; $ firstElement = $ xpath -> query ( $ query ) ; if ( ! is_object ( $ firstElement -> item ( 0 ) ) ) { $ query = "//*[local-name()='types']/child::*" ; $ schema = $ xpath -> query ( $ query ) ; $ schema -> item ( 0 ) -> appendChild ( $ importEl ) ; } else { $ this -> wsdl -> getSchema ( ) -> insertBefore ( $ importEl , $ firstElement -> item ( 0 ) ) ; } array_push ( $ this -> importedNamespaces , $ namespace ) ; } } 
private function addType ( $ type ) { if ( ! in_array ( $ type , $ this -> basicTypes ) ) { $ typeName = $ this -> getShortName ( $ type ) ; $ typeNamespace = $ this -> getClassNamespace ( $ type ) ; $ nsCode = $ this -> getNsCode ( $ typeNamespace , true ) ; } else { return $ type ; } } 
private function getTargetNS ( $ xpath ) { $ query = "//*[local-name()='schema' and namespace-uri()='http://www.w3.org/2001/XMLSchema']/@targetNamespace" ; $ targetNs = $ xpath -> query ( $ query ) ; if ( $ targetNs ) { foreach ( $ targetNs as $ entry ) { return $ entry -> nodeValue ; } } } 
public function getNamespaces ( $ xpath ) { $ query = "//namespace::*" ; $ entries = $ xpath -> query ( $ query ) ; $ nspaces = array ( ) ; foreach ( $ entries as $ entry ) { if ( $ entry -> nodeValue == "http://www.w3.org/2001/XMLSchema" ) { $ this -> xsdNs = preg_replace ( '/xmlns:(.*)/' , "$1" , $ entry -> nodeName ) ; } if ( 
public function saveClasses ( $ dir , $ createDirectory = false ) { $ this -> setXmlSource ( $ this -> getXML ( ) -> saveXML ( ) ) ; $ this -> savePhpFiles ( $ dir , $ createDirectory ) ; } 
public function loadImports ( $ dom , $ xsdFile = '' ) { $ xpath = new \ DOMXPath ( $ dom ) ; $ query = "//*[local-name()='import' and namespace-uri()='http://www.w3.org/2001/XMLSchema']" ; $ entries = $ xpath -> query ( $ query ) ; if ( $ entries -> length == 0 ) { return $ dom ; } foreach ( $ entries as $ entry ) { 
public function loadIncludes ( $ dom , $ filepath = '' , $ namespace = '' ) { $ xpath = new \ DOMXPath ( $ dom ) ; $ query = "//*[local-name()='include' and namespace-uri()='http://www.w3.org/2001/XMLSchema']" ; $ includes = $ xpath -> query ( $ query ) ; foreach ( $ includes as $ entry ) { $ parent = $ entry -> parentNode ; $ xsd = new \ DOMDocument ( ) ; $ xsdFileName = realpath ( $ filepath . DIRECTORY_SEPARATOR . $ entry -> getAttribute ( "schemaLocation" ) ) ; if ( $ this -> debug ) { print ( 'Including ' . $ xsdFileName . "\n" ) ; } if ( ! file_exists ( $ xsdFileName ) ) { if ( $ this -> debug ) { print $ xsdFileName . " is not found \n" ; } continue ; } $ result = $ xsd -> load ( $ xsdFileName , LIBXML_DTDLOAD | LIBXML_DTDATTR | LIBXML_NOENT | LIBXML_XINCLUDE ) ; if ( $ result ) { $ mxpath = new \ DOMXPath ( $ xsd ) ; $ this -> shortNamespaces = array_merge ( $ this -> shortNamespaces , $ this -> getNamespaces ( $ mxpath ) ) ; } foreach ( $ xsd -> documentElement -> childNodes as $ node ) { if ( $ node -> nodeName == $ this -> xsdNs . ":include" ) { $ loc = realpath ( $ filepath . DIRECTORY_SEPARATOR . $ node -> getAttribute ( 'schemaLocation' ) ) ; $ node -> setAttribute ( 'schemaLocation' , $ loc ) ; if ( $ this -> debug ) { print ( 'Change included schema location to ' . $ loc . " \n" ) ; } $ newNode = $ dom -> importNode ( $ node , true ) ; $ parent -> insertBefore ( $ newNode , $ entry ) ; } else { if ( $ namespace != '' ) { $ newNodeNs = $ xsd -> createAttribute ( "namespace" ) ; $ textEl = $ xsd -> createTextNode ( $ namespace ) ; $ newNodeNs -> appendChild ( $ textEl ) ; $ node -> appendChild ( $ newNodeNs ) ; } $ newNode = $ dom -> importNode ( $ node , true ) ; $ parent -> insertBefore ( $ newNode , $ entry ) ; } } $ parent -> removeChild ( $ entry ) ; } if ( $ this -> debug ) { print_r ( "\n------------------------------------\n" ) ; } return $ dom ; } 
public function getXML ( ) { try { $ xsl = new \ XSLTProcessor ( ) ; $ xslDom = new \ DOMDocument ( ) ; $ xslDom -> load ( dirname ( __FILE__ ) . "/xsd2php2.xsl" ) ; $ xsl -> registerPHPFunctions ( ) ; $ xsl -> importStyleSheet ( $ xslDom ) ; $ dom = $ xsl -> transformToDoc ( $ this -> dom ) ; $ dom -> formatOutput = true ; return $ dom ; } catch ( \ Exception $ e ) { throw new \ Exception ( "Error interpreting XSD document (" . $ e -> getMessage ( ) . ")" ) ; } } 
private function savePhpFiles ( $ dir , $ createDirectory = false ) { if ( ! file_exists ( $ dir ) && $ createDirectory === false ) { throw new \ RuntimeException ( $ dir . " does not exist" ) ; } if ( ! file_exists ( $ dir ) && $ createDirectory === true ) { 
private function getPHP ( ) { $ phpfile = $ this -> getXmlForPhp ( ) ; if ( $ phpfile == '' && $ this -> getXmlSource ( ) == '' ) { throw new \ RuntimeException ( 'There is no XML generated' ) ; } $ dom = new \ DOMDocument ( ) ; * In general it's stange to give to Type name's namespace. Reconsider this part */ if ( $ prop -> getAttribute ( 'namespace' ) != '' && $ prop -> getAttribute ( 'namespace' ) != $ this -> xsdNs ) { $ ns = "" ; if ( $ prop -> getAttribute ( 'namespace' ) == "#default#" ) { $ ns = $ this -> namespaceToPhp ( $ this -> targetNamespace ) ; } else { $ ns = $ this -> namespaceToPhp ( $ this -> expandNS ( $ prop -> getAttribute ( 'namespace' ) ) ) ; } $ properties [ $ i ] [ "docs" ] [ 'var' ] = $ ns . '\\' . $ this -> classPrefix . $ prop -> getAttribute ( 'type' ) ; } else { $ properties [ $ i ] [ "docs" ] [ 'var' ] = $ prop -> getAttribute ( 'type' ) ; } 
private function expandNS ( $ ns ) { if ( $ ns == "#default#" ) { $ ns = $ this -> targetNamespace ; } foreach ( $ this -> shortNamespaces as $ shortNs => $ longNs ) { if ( $ ns == $ shortNs ) { $ ns = $ longNs ; } } return $ ns ; } 
public function namespaceToPhp ( $ xmlNS ) { $ ns = $ xmlNS ; $ ns = $ this -> expandNS ( $ ns ) ; if ( preg_match ( '/urn:/' , $ ns ) ) { if (preg_match('/http:\/\//', $ns)) { $ns = preg_replace('/http:\/\//', '', $ns); $ns = preg_replace('/\//','\\', $ns); $ns = preg_replace('/\./', '\\',$ns); }*/ $ matches = array ( ) ; if ( preg_match ( "#((http|https|ftp)://(\S*?\.\S*?))(\s|\;|\)|\]|\[|\{|\}|,|\"|'|:|\<|$|\.\s)#" , $ ns , $ matches ) ) { $ elements = explode ( "/" , $ matches [ 3 ] ) ; $ domain = $ elements [ 0 ] ; array_shift ( $ elements ) ; //print_r($domain."\n"); $ ns = implode ( "\\" , array_reverse ( explode ( "." , $ domain ) ) ) ; //$ns = preg_replace('/\./', '\\', ); //print $ns."\n"; foreach ( $ elements as $ key => $ value ) { if ( $ value != '' ) { $ value = preg_replace ( '/\./' , '_' , $ value ) ; $ ns .= "\\" . $ value ; } } } $ ns = explode ( '\\' , $ ns ) ; $ i = 0 ; foreach ( $ ns as $ elem ) { if ( preg_match ( '/^([0-9]+)(.*)$/' , $ elem ) ) { $ ns [ $ i ] = "_" . $ elem ; } if ( in_array ( $ elem , $ this -> reservedWords ) ) { $ ns [ $ i ] = "_" . $ elem ; } $ i ++ ; } $ ns = implode ( '\\' , $ ns ) ; return $ ns ; } 
public function setBaseURL ( $ baseURL ) { if ( strcasecmp ( $ baseURL , CoreConstants :: DEVELOPMENT_SANDBOX ) == 0 ) { $ this -> baseURL = CoreConstants :: SANDBOX_DEVELOPMENT ; } else if ( strcasecmp ( $ baseURL , CoreConstants :: PRODUCTION_QBO ) == 0 ) { $ this -> baseURL = CoreConstants :: QBO_BASEURL ; } else { $ this -> baseURL = $ baseURL ; } } 
public function getRefreshTokenValidationPeriodInSeconds ( ) { if ( isset ( $ this -> refreshTokenValidationPeriod ) && ! empty ( $ this -> refreshTokenValidationPeriod ) ) { return $ this -> refreshTokenValidationPeriod ; } else { throw new SdkException ( "The validation period for OAuth 2 refresh Token is not set." ) ; } } 
public function getAccessTokenValidationPeriodInSeconds ( ) { if ( isset ( $ this -> accessTokenValidationPeriod ) && ! empty ( $ this -> accessTokenValidationPeriod ) ) { return $ this -> accessTokenValidationPeriod ; } else { throw new SdkException ( "The validation period for OAuth 2 access Token is not set." ) ; } } 
public function getRefreshToken ( ) { if ( isset ( $ this -> refresh_token ) && ! empty ( $ this -> refresh_token ) ) return $ this -> refresh_token ; else throw new SdkException ( "The OAuth 2 Refresh Token is not set in the Access Token Object." ) ; } 
public function getAccessToken ( ) { if ( isset ( $ this -> accessTokenKey ) && ! empty ( $ this -> accessTokenKey ) ) return $ this -> accessTokenKey ; else throw new SdkException ( "The OAuth 2 Access Token is not set in the Access Token Object." ) ; } 
public function updateAccessToken ( $ tokenExpiresTime , $ refreshToken , $ refreshTokenExpiresTime , $ accessToken ) { $ this -> setAccessToken ( $ accessToken ) ; $ this -> setRefreshToken ( $ refreshToken ) ; $ this -> setAccessTokenValidationPeriodInSeconds ( $ tokenExpiresTime ) ; $ this -> setRefreshTokenValidationPeriodInSeconds ( $ refreshTokenExpiresTime ) ; $ this -> setAccessTokenExpiresAt ( time ( ) + $ tokenExpiresTime ) ; $ this -> setRefreshTokenExpiresAt ( time ( ) + $ refreshTokenExpiresTime ) ; } 
public static function update ( $ objToUpdate , array $ data ) { $ classOfObj = get_class ( $ objToUpdate ) ; if ( strcmp ( $ classOfObj , FacadeHelper :: simpleAppendClassNameSpace ( "CreditMemo" ) ) != 0 ) { throw new \ Exception ( "Target object class:{" . $ classOfObj . "} is not an instance of CreditMemo." ) ; } $ newCreditMemoObj = CreditMemo :: create ( $ data ) ; $ clonedOfObj = FacadeHelper :: cloneObj ( $ objToUpdate ) ; FacadeHelper :: mergeObj ( $ clonedOfObj , $ newCreditMemoObj ) ; return $ clonedOfObj ; } 
public function addComplexType ( $ type ) { if ( in_array ( $ type , $ this -> _inProcess ) ) { require_once "Zend/Soap/Wsdl/Exception.php" ; throw new Zend_Soap_Wsdl_Exception ( "Infinite recursion, cannot nest '" . $ type . "' into itself." ) ; } $ this -> _inProcess [ $ type ] = $ type ; $ nestingLevel = $ this -> _getNestedCount ( $ type ) ; if ( $ nestingLevel > 1 ) { require_once "Zend/Soap/Wsdl/Exception.php" ; throw new Zend_Soap_Wsdl_Exception ( "ArrayOfTypeComplex cannot return nested ArrayOfObject deeper than " . "one level. Use array object properties to return deep nested data. " ) ; } $ singularType = $ this -> _getSingularPhpType ( $ type ) ; if ( ! class_exists ( $ singularType ) ) { require_once "Zend/Soap/Wsdl/Exception.php" ; throw new Zend_Soap_Wsdl_Exception ( sprintf ( "Cannot add a complex type %s that is not an object or where " . "class could not be found in 'DefaultComplexType' strategy." , $ type ) ) ; } if ( $ nestingLevel == 1 ) { 
public static function update ( $ objToUpdate , array $ data ) { $ classOfObj = get_class ( $ objToUpdate ) ; if ( strcmp ( $ classOfObj , FacadeHelper :: simpleAppendClassNameSpace ( "Line" ) ) != 0 ) { throw new \ Exception ( "Target object class:{" . $ classOfObj . "} is not an instance of Line." ) ; } $ newLineObj = Line :: create ( $ data ) ; $ clonedOfObj = FacadeHelper :: cloneObj ( $ objToUpdate ) ; FacadeHelper :: mergeObj ( $ clonedOfObj , $ newLineObj ) ; return $ clonedOfObj ; } 
private static function getXmlFromObj ( $ phpObj ) { if ( ! $ phpObj ) { $ this -> IDSLogger -> CustomLogger -> Log ( TraceLevel :: Error , "Encountered an error parsing the xmlFromObj." ) ; $ this -> IDSLogger -> CustomLogger -> Log ( TraceLevel :: Error , "Stack Trace: " . implode ( "\n" , debug_backtrace ( ) ) ) ; return false ; } $ php2xml = new Php2Xml ( CoreConstants :: PHP_CLASS_PREFIX ) ; $ php2xml -> overrideAsSingleNamespace = 'http://schema.intuit.com/finance/v3' ; try { return $ php2xml -> getXml ( $ phpObj ) ; } catch ( \ Exception $ e ) { $ this -> IDSLogger -> CustomLogger -> Log ( TraceLevel :: Error , "Encountered an error parsing the batch response." . $ e -> getMessage ( ) ) ; $ this -> IDSLogger -> CustomLogger -> Log ( TraceLevel :: Error , "Object: " . var_export ( $ phpObj , true ) ) ; $ this -> IDSLogger -> CustomLogger -> Log ( TraceLevel :: Error , "Stack Trace: " . $ e -> getTraceAsString ( ) ) ; return false ; } } 
public static function getPostXmlFromArbitraryEntity ( $ entity , & $ urlResource ) { if ( null == $ entity ) { return false ; } $ xmlElementName = XmlObjectSerializer :: cleanPhpClassNameToIntuitEntityName ( get_class ( $ entity ) ) ; $ xmlElementName = trim ( $ xmlElementName ) ; $ urlResource = strtolower ( $ xmlElementName ) ; $ httpsPostBody = XmlObjectSerializer :: getXmlFromObj ( $ entity ) ; return $ httpsPostBody ; } 
private static function PhpObjFromXml ( $ className , $ xmlStr ) { $ className = trim ( $ className ) ; if ( class_exists ( $ className , CoreConstants :: USE_AUTOLOADER ) ) { $ phpObj = new $ className ; } elseif ( class_exists ( CoreConstants :: NAMEPSACE_DATA_PREFIX . $ className , CoreConstants :: USE_AUTOLOADER ) ) { $ className = CoreConstants :: NAMEPSACE_DATA_PREFIX . $ className ; $ phpObj = new $ className ; } else { throw new \ Exception ( "Can't find corresponding CLASS for className" . $ className . "during unmarshall XML into POPO Object" ) ; } $ bind = new Bind ( CoreConstants :: PHP_CLASS_PREFIX ) ; $ bind -> overrideAsSingleNamespace = 'http://schema.intuit.com/finance/v3' ; $ bind -> bindXml ( $ xmlStr , $ phpObj ) ; return $ phpObj ; } 
private static function ParseArbitraryResultObjects ( $ responseXml , $ bLimitToOne ) { if ( ! $ responseXml ) { return null ; } $ resultObject = null ; $ resultObjects = null ; $ responseXmlObj = simplexml_load_string ( $ responseXml ) ; foreach ( $ responseXmlObj as $ oneXmlObj ) { $ oneXmlElementName = ( string ) $ oneXmlObj -> getName ( ) ; 
public static function cleanPhpClassNameToIntuitEntityName ( $ phpClassName ) { $ phpClassName = trim ( $ phpClassName ) ; 
public function Deserialize ( $ message , $ bLimitToOne = false ) { if ( ! $ message ) { return null ; } $ resultObject = null ; $ resultObjects = null ; $ responseXmlObj = simplexml_load_string ( $ message ) ; 
public function setupOption ( $ k , $ v ) { if ( $ this -> isCurlSet ( ) ) { curl_setopt ( $ this -> curl , $ k , $ v ) ; } else { throw new SdkException ( "cURL instance is not set when calling setup Option." ) ; } } 
public function versionOfTLS ( ) { $ tlsVersion = "" ; $ curl = curl_init ( ) ; curl_setopt ( $ curl , CURLOPT_URL , "https://www.howsmyssl.com/a/check" ) ; curl_setopt ( $ curl , CURLOPT_SSLVERSION , 6 ) ; curl_setopt ( $ curl , CURLOPT_RETURNTRANSFER , true ) ; $ curlVersionResponse = curl_exec ( $ curl ) ; if ( $ curlVersionResponse === false ) { throw new SdkException ( "Error in checking cURL version for TLS 1.2. Error Num:[" . curl_errno ( $ curl ) . "] Error message:[" . curl_error ( $ curl ) . "]" ) ; } else { $ tlsVersion = json_decode ( $ curlVersionResponse ) -> tls_version ; } curl_close ( $ curl ) ; return $ tlsVersion ; } 
public function getInfo ( $ type ) { if ( $ this -> isCurlSet ( ) ) { return curl_getinfo ( $ this -> curl , $ type ) ; } else { throw new SdkException ( "cURL instance is not set when trying to get info from the type:" . $ type ) ; } } 
public static function HandleException ( $ errorMessage = null , $ errorCode = null , $ source = null , $ innerException = null ) { $ message = implode ( ", " , array ( $ errorMessage , $ errorCode , $ source ) ) ; throw new IdsException ( $ message ) ; } 
private function extractVarValueFromComment ( $ text ) { $ matches = array ( ) ; $ result = preg_match_all ( self :: REGULAR_GET_VAR , $ text , $ matches ) ; 
private function verifyVariableType ( $ value ) { 
private function generateObjectNames ( $ value ) { $ reversiveStack = array ( ) ; $ reversiveStack [ ] = $ value ; 
private function completeProperty ( $ a , ReflectionProperty $ p ) { if ( ! $ a instanceof AbstractEntity ) { throw new InvalidArgumentException ( "Expected instance of AbstractEntity here" ) ; } $ a -> setName ( $ p -> getName ( ) ) ; $ a -> setClass ( $ p -> getDeclaringClass ( ) ) ; } 
public function unmarshal ( $ xml ) { 
public function bindXml ( $ xml , $ model ) { *Vish Singh: Solution to Bug # IPP-4748 *Add Check if the class Exists. @Hao */ if ( class_exists ( $ className , CoreConstants :: USE_AUTOLOADER ) ) { 
public static function GetSerializer ( $ serviceContext , $ isRequest ) { $ serviceContext -> IppConfiguration -> Logger -> RequestLog -> Log ( TraceLevel :: Info , "GetSerializer" ) ; $ serializer = null ; if ( $ isRequest ) { switch ( $ serviceContext -> IppConfiguration -> Message -> Request -> SerializationFormat ) { case SerializationFormat :: Xml : $ serviceContext -> IppConfiguration -> Logger -> RequestLog -> Log ( TraceLevel :: Info , "GetSerializer(Request): Xml" ) ; $ serializer = new XmlObjectSerializer ( ) ; break ; case SerializationFormat :: Json : $ serviceContext -> IppConfiguration -> Logger -> RequestLog -> Log ( TraceLevel :: Info , "GetSerializer(Request): JSON" ) ; $ serializer = new JsonObjectSerializer ( ) ; break ; case SerializationFormat :: Custom : 
public static function CheckNullResponseAndThrowException ( $ response ) { if ( ! $ response ) { $ messageToWrite = 'Response Null or Empty' ; $ backTrace = debug_backtrace ( ) ; $ callerFileName = $ backTrace [ 0 ] [ 'file' ] ; $ callerFileLineNumber = $ backTrace [ 0 ] [ 'line' ] ; $ callerFunctionName = $ backTrace [ 0 ] [ 'function' ] ; $ logMessage = implode ( " - " , array ( date ( 'Y-m-d H:i:s' ) , $ callerFileName , $ callerFileLineNumber , $ callerFunctionName , $ messageToWrite ) ) ; throw new IdsException ( $ logMessage ) ; } } 
public static function GetCompressor ( $ serviceContext , $ isRequest ) { $ compressor = null ; if ( $ isRequest ) { switch ( $ serviceContext -> IppConfiguration -> Message -> Request -> CompressionFormat ) { case CompressionFormat :: GZip : $ compressor = new GZipCompressor ( ) ; break ; case CompressionFormat :: Deflate : $ compressor = new DeflateCompressor ( ) ; break ; } } else { switch ( $ serviceContext -> IppConfiguration -> Message -> Response -> CompressionFormat ) { case CompressionFormat :: GZip : $ compressor = new GZipCompressor ( ) ; break ; case CompressionFormat :: Deflate : $ compressor = new DeflateCompressor ( ) ; break ; } } return $ compressor ; } 
public static function GetRequestLogging ( $ serviceContext ) { $ requestLogger = null ; try { if ( isset ( $ serviceContext -> IppConfiguration ) && isset ( $ serviceContext -> IppConfiguration -> Logger ) && isset ( $ serviceContext -> IppConfiguration -> Logger -> RequestLog ) && isset ( $ serviceContext -> IppConfiguration -> Logger -> RequestLog -> EnableRequestResponseLogging ) && isset ( $ serviceContext -> IppConfiguration -> Logger -> RequestLog -> ServiceRequestLoggingLocation ) ) { $ requestLogger = new LogRequestsToDisk ( $ serviceContext -> IppConfiguration -> Logger -> RequestLog -> EnableRequestResponseLogging , $ serviceContext -> IppConfiguration -> Logger -> RequestLog -> ServiceRequestLoggingLocation ) ; } else { $ requestLogger = new LogRequestsToDisk ( false , null ) ; } } catch ( \ Exception $ e ) { $ requestLogger = new LogRequestsToDisk ( false , null ) ; } return $ requestLogger ; } 
public function connectTypeToStrategy ( $ type , $ strategy ) { if ( ! is_string ( $ type ) ) { require_once "Zend/Soap/Wsdl/Exception.php" ; throw new Zend_Soap_Wsdl_Exception ( "Invalid type given to Composite Type Map." ) ; } $ this -> _typeMap [ $ type ] = $ strategy ; return $ this ; } 
public function getDefaultStrategy ( ) { $ strategy = $ this -> _defaultStrategy ; if ( is_string ( $ strategy ) && class_exists ( $ strategy ) ) { $ strategy = new $ strategy ; } if ( ! ( $ strategy instanceof Zend_Soap_Wsdl_Strategy_Interface ) ) { require_once "Zend/Soap/Wsdl/Exception.php" ; throw new Zend_Soap_Wsdl_Exception ( "Default Strategy for Complex Types is not a valid strategy object." ) ; } $ this -> _defaultStrategy = $ strategy ; return $ strategy ; } 
public function getStrategyOfType ( $ type ) { if ( isset ( $ this -> _typeMap [ $ type ] ) ) { $ strategy = $ this -> _typeMap [ $ type ] ; if ( is_string ( $ strategy ) && class_exists ( $ strategy ) ) { $ strategy = new $ strategy ( ) ; } if ( ! ( $ strategy instanceof Zend_Soap_Wsdl_Strategy_Interface ) ) { require_once "Zend/Soap/Wsdl/Exception.php" ; throw new Zend_Soap_Wsdl_Exception ( "Strategy for Complex Type '" . $ type . "' is not a valid strategy object." ) ; } $ this -> _typeMap [ $ type ] = $ strategy ; } else { $ strategy = $ this -> getDefaultStrategy ( ) ; } return $ strategy ; } 
public function addComplexType ( $ type ) { if ( ! ( $ this -> _context instanceof Zend_Soap_Wsdl ) ) { require_once "Zend/Soap/Wsdl/Exception.php" ; throw new Zend_Soap_Wsdl_Exception ( "Cannot add complex type '" . $ type . "', no context is set for this composite strategy." ) ; } $ strategy = $ this -> getStrategyOfType ( $ type ) ; $ strategy -> setContext ( $ this -> _context ) ; return $ strategy -> addComplexType ( $ type ) ; } 
private function makeReflection ( ) { if ( ! class_exists ( $ this -> getOriginalClassName ( ) ) ) { throw new InvalidArgumentException ( 'Class name ' . $ this -> getOriginalClassName ( ) . ' not exists' ) ; } $ this -> reflection = new ReflectionClass ( $ this -> getOriginalClassName ( ) ) ; } 
private function populatePropertyComments ( ) { if ( is_null ( $ this -> properties ) ) { throw new UnexpectedValueException ( 'Properties are expected here' ) ; } if ( ! is_array ( $ this -> properties ) ) { throw new UnexpectedValueException ( 'Properties should be provided as array' ) ; } 
private function forgeInstance ( $ instance ) { $ reflection = new ReflectionClass ( $ instance ) ; foreach ( $ reflection -> getProperties ( ) as $ key => $ property ) { if ( ! $ property instanceof ReflectionProperty ) { continue ; } $ entity = $ this -> getEntityFromModel ( $ key , $ property -> getName ( ) ) ; $ value = $ property -> getValue ( $ instance ) ; if ( is_array ( $ value ) ) { $ this -> processPropertyValues ( $ instance , $ property , $ entity , $ value ) ; } else { $ this -> processPropertyValue ( $ instance , $ property , $ entity , $ value ) ; } } return $ instance ; } 
private function processPropertyValues ( $ instance , $ property , $ model , $ values ) { $ changed = false ; foreach ( $ values as & $ value ) { if ( ! $ this -> isMorhing ( $ model , $ value ) ) { continue ; } $ newType = $ model -> getType ( ) ; 
public static function create ( $ type , $ values ) { $ i = new static ( $ type ) ; $ i -> usePropertyValues ( $ values ) ; return $ i -> createInstance ( ) ; } 
private function isMorhing ( $ entity , $ value ) { if ( ! $ entity instanceof ObjectEntity ) { return false ; } 
private function processPropertyValue ( $ instance , $ property , $ model , $ value ) { if ( $ this -> isMorhing ( $ model , $ value ) ) { $ newType = $ model -> getType ( ) ; $ new = static :: create ( $ newType , ( array ) $ value ) ; $ property -> setValue ( $ instance , $ new ) ; } } 
private function getEntityFromModel ( $ index , $ propertyName ) { $ entity = $ this -> model [ $ index ] ; if ( $ entity -> getName ( ) === $ propertyName ) { return $ entity ; } 
public function updateServiceContextSettingsForOthers ( $ serviceContext ) { $ this -> setupServiceContext ( $ serviceContext ) ; $ this -> setupSerializers ( ) ; $ this -> useMinorVersion ( ) ; $ this -> setupRestHandler ( $ serviceContext ) ; } 
protected function setupRestHandler ( $ serviceContext ) { if ( isset ( $ serviceContext ) ) { $ client = ClientFactory :: createClient ( $ this -> getClientName ( ) ) ; $ this -> restHandler = new SyncRestHandler ( $ serviceContext , $ client ) ; } else { throw new SdkException ( "Can not set the Rest Client based on null ServiceContext." ) ; } return $ this ; } 
public function useXml ( ) { $ serviceContext = $ this -> getServiceContext ( ) ; $ serviceContext -> useXml ( ) ; $ this -> updateServiceContextSettingsForOthers ( $ serviceContext ) ; return $ this ; } 
public function useJson ( ) { $ serviceContext = $ this -> getServiceContext ( ) ; $ serviceContext -> useJson ( ) ; $ this -> updateServiceContextSettingsForOthers ( $ serviceContext ) ; return $ this ; } 
public function setLogLocation ( $ new_log_location ) { $ restHandler = $ this -> restHandler ; $ loggerUsedByRestHandler = $ restHandler -> getRequestLogger ( ) ; $ loggerUsedByRestHandler -> setLogDirectory ( $ new_log_location ) ; return $ this ; } 
public function setMinorVersion ( $ newMinorVersion ) { $ serviceContext = $ this -> getServiceContext ( ) ; $ serviceContext -> setMinorVersion ( $ newMinorVersion ) ; $ this -> updateServiceContextSettingsForOthers ( $ serviceContext ) ; return $ this ; } 
public function disableLog ( ) { $ restHandler = $ this -> restHandler ; $ loggerUsedByRestHandler = $ restHandler -> getRequestLogger ( ) ; $ loggerUsedByRestHandler -> setLogStatus ( false ) ; return $ this ; } 
public function enableLog ( ) { $ restHandler = $ this -> restHandler ; $ loggerUsedByRestHandler = $ restHandler -> getRequestLogger ( ) ; $ loggerUsedByRestHandler -> setLogStatus ( true ) ; return $ this ; } 
public function setClientName ( $ clientName ) { $ this -> clientName = $ clientName ; $ serviceContext = $ this -> getServiceContext ( ) ; $ this -> setupRestHandler ( $ serviceContext ) ; return $ this ; } 
public static function Configure ( $ settings ) { if ( isset ( $ settings ) ) { if ( is_array ( $ settings ) ) { $ ServiceContext = ServiceContext :: ConfigureFromPassedArray ( $ settings ) ; if ( ! isset ( $ ServiceContext ) ) { throw new SdkException ( 'Construct ServiceContext from OAuthSettigs failed.' ) ; } $ DataServiceInstance = new DataService ( $ ServiceContext ) ; } elseif ( is_string ( $ settings ) ) { $ ServiceContext = ServiceContext :: ConfigureFromLocalFile ( $ settings ) ; if ( ! isset ( $ ServiceContext ) ) { throw new SdkException ( 'Construct ServiceContext from File failed.' ) ; } $ DataServiceInstance = new DataService ( $ ServiceContext ) ; } if ( $ ServiceContext -> IppConfiguration -> OAuthMode == CoreConstants :: OAUTH2 ) { $ oauth2Config = $ ServiceContext -> IppConfiguration -> Security ; if ( $ oauth2Config instanceof OAuth2AccessToken ) { $ DataServiceInstance -> configureOAuth2LoginHelper ( $ oauth2Config , $ settings ) ; } else { throw new SdkException ( "SDK Error. OAuth mode is not OAuth 2." ) ; } } return $ DataServiceInstance ; } else { throw new SdkException ( "Passed Null to Configure method. It expects either a file path for the config file or an array containing OAuth settings and BaseURL." ) ; } } 
private function configureOAuth2LoginHelper ( $ oauth2Conifg , $ settings ) { $ refreshToken = CoreConstants :: getRefreshTokenFromArray ( $ settings ) ; if ( isset ( $ refreshToken ) ) { 
public function updateOAuth2Token ( $ newOAuth2AccessToken ) { try { $ this -> serviceContext -> updateOAuth2Token ( $ newOAuth2AccessToken ) ; $ realmID = $ newOAuth2AccessToken -> getRealmID ( ) ; $ this -> serviceContext -> realmId = $ realmID ; $ this -> setupRestHandler ( $ this -> serviceContext ) ; } catch ( SdkException $ e ) { $ this -> serviceContext -> IppConfiguration -> Logger -> CustomLogger -> Log ( TraceLevel :: Error , "Encountered an error while updating OAuth2Token." . $ e -> getMessage ( ) ) ; $ this -> serviceContext -> IppConfiguration -> Logger -> CustomLogger -> Log ( TraceLevel :: Error , "Stack Trace: " . $ e -> getTraceAsString ( ) ) ; } return $ this ; } 
public function setupSerializers ( ) { $ this -> responseSerializer = CoreHelper :: GetSerializer ( $ this -> serviceContext , false ) ; $ this -> requestSerializer = CoreHelper :: GetSerializer ( $ this -> serviceContext , true ) ; } 
private function getXmlFromObj ( $ phpObj ) { if ( ! $ phpObj ) { $ this -> serviceContext -> IppConfiguration -> Logger -> CustomLogger -> Log ( TraceLevel :: Error , "getXmlFromObj NULL arg." ) ; return false ; } $ php2xml = new Php2Xml ( CoreConstants :: PHP_CLASS_PREFIX ) ; $ php2xml -> overrideAsSingleNamespace = 'http://schema.intuit.com/finance/v3' ; try { return $ php2xml -> getXml ( $ phpObj ) ; } catch ( \ Exception $ e ) { $ this -> serviceContext -> IppConfiguration -> Logger -> CustomLogger -> Log ( TraceLevel :: Error , "Encountered an error parsing Object to XML." . $ e -> getMessage ( ) ) ; $ this -> serviceContext -> IppConfiguration -> Logger -> CustomLogger -> Log ( TraceLevel :: Error , "Stack Trace: " . $ e -> getTraceAsString ( ) ) ; return false ; } } 
private static function decorateIntuitEntityToPhpClassName ( $ intuitEntityName ) { $ className = CoreConstants :: PHP_CLASS_PREFIX . $ intuitEntityName ; $ className = trim ( $ className ) ; return $ className ; } 
private static function cleanPhpClassNameToIntuitEntityName ( $ phpClassName ) { $ phpClassName = self :: removeNameSpaceFromPhpClassName ( $ phpClassName ) ; if ( 0 == strpos ( $ phpClassName , CoreConstants :: PHP_CLASS_PREFIX ) ) { return substr ( $ phpClassName , strlen ( CoreConstants :: PHP_CLASS_PREFIX ) ) ; } return null ; } 
private function sendRequestParseResponseBodyAndHandleHttpError ( $ entity , $ uri , $ httpsPostBody , $ CALLINGMETHOD , $ boundaryString = null , $ email = null ) { switch ( $ CALLINGMETHOD ) { case DataService :: DELETE : case DataService :: ADD : case DataService :: VOID : case DataService :: UPDATE : $ requestParameters = $ this -> initPostRequest ( $ entity , $ uri ) ; break ; case DataService :: FINDBYID : if ( $ this -> serviceContext -> IppConfiguration -> Message -> Request -> SerializationFormat == SerializationFormat :: Json ) { $ requestParameters = new RequestParameters ( $ uri , 'GET' , CoreConstants :: CONTENTTYPE_APPLICATIONJSON , null ) ; } else { $ requestParameters = new RequestParameters ( $ uri , 'GET' , CoreConstants :: CONTENTTYPE_APPLICATIONXML , null ) ; } break ; case DataService :: UPLOAD : if ( ! isset ( $ boundaryString ) ) { throw new \ Exception ( "Upload Image has unset value: boundaryString." ) ; } 
public function Update ( $ entity ) { $ this -> serviceContext -> IppConfiguration -> Logger -> RequestLog -> Log ( TraceLevel :: Info , "Called Method: Update." ) ; (CoreConstants::IntuitServicesTypeQBO == $this->serviceContext->serviceType)) { $urlResource = 'companyInfo'; $uri = implode(CoreConstants::SLASH_CHAR, array('company', $this->serviceContext->realmId, $urlResource . '?operation=update')); }*/ else { 
public function FindById ( $ entity , $ Id = null ) { $ this -> serviceContext -> IppConfiguration -> Logger -> RequestLog -> Log ( TraceLevel :: Info , "Called Method FindById." ) ; if ( is_object ( $ entity ) ) { $ httpsPostBody = $ this -> executeObjectSerializer ( $ entity , $ urlResource ) ; 
public function Add ( $ entity ) { $ this -> serviceContext -> IppConfiguration -> Logger -> RequestLog -> Log ( TraceLevel :: Info , "Called Method Add." ) ; 
public function Delete ( $ entity ) { $ this -> serviceContext -> IppConfiguration -> Logger -> RequestLog -> Log ( TraceLevel :: Info , "Called Method Delete." ) ; 
public function Upload ( $ imgBits , $ fileName , $ mimeType , $ objAttachable ) { $ this -> serviceContext -> IppConfiguration -> Logger -> RequestLog -> Log ( TraceLevel :: Info , "Called Method Upload." ) ; 
public function DownloadPDF ( $ entity , $ dir = null ) { $ this -> validateEntityId ( $ entity ) ; $ this -> verifyOperationAccess ( $ entity , __FUNCTION__ ) ; 
public function SendEmail ( $ entity , $ email = null ) { $ this -> validateEntityId ( $ entity ) ; $ this -> verifyOperationAccess ( $ entity , __FUNCTION__ ) ; $ entityId = $ this -> getIDString ( $ entity -> Id ) ; $ uri = implode ( CoreConstants :: SLASH_CHAR , array ( 'company' , $ this -> serviceContext -> realmId , self :: getEntityResourceName ( $ entity ) , $ entityId , 'send' ) ) ; if ( is_null ( $ email ) ) { $ this -> logInfo ( "Entity " . get_class ( $ entity ) . " with id=" . $ entityId . " is using default email" ) ; } else { $ this -> logInfo ( "Entity " . get_class ( $ entity ) . " with id=" . $ entityId . " is using $email" ) ; if ( ! $ this -> verifyEmailAddress ( $ email ) ) { $ this -> logError ( "Valid email is expected, but received $email" ) ; throw new SdkException ( "Valid email is expected, but received $email" ) ; } } return $ this -> sendRequestParseResponseBodyAndHandleHttpError ( $ entity , $ uri , null , DataService :: SENDEMAIL , null , $ email ) ; } 
public function Query ( $ query , $ startPosition = null , $ maxResults = null ) { $ this -> serviceContext -> IppConfiguration -> Logger -> RequestLog -> Log ( TraceLevel :: Info , "Called Method Query." ) ; if ( 'QBO' == $ this -> serviceContext -> serviceType ) { $ httpsContentType = CoreConstants :: CONTENTTYPE_APPLICATIONTEXT ; } else { $ httpsContentType = CoreConstants :: CONTENTTYPE_TEXTPLAIN ; } $ httpsUri = implode ( CoreConstants :: SLASH_CHAR , array ( 'company' , $ this -> serviceContext -> realmId , 'query' ) ) ; $ httpsPostBody = $ this -> appendPaginationInfo ( $ query , $ startPosition , $ maxResults ) ; $ requestParameters = $ this -> getPostRequestParameters ( $ httpsUri , $ httpsContentType ) ; $ restRequestHandler = $ this -> getRestHandler ( ) ; list ( $ responseCode , $ responseBody ) = $ restRequestHandler -> sendRequest ( $ requestParameters , $ httpsPostBody , null , $ this -> isThrownExceptionOnError ( ) ) ; $ faultHandler = $ restRequestHandler -> getFaultHandler ( ) ; if ( $ faultHandler ) { $ this -> lastError = $ faultHandler ; return null ; } else { $ this -> lastError = false ; $ parsedResponseBody = null ; try { $ responseXmlObj = simplexml_load_string ( $ responseBody ) ; if ( $ responseXmlObj && $ responseXmlObj -> QueryResponse ) { $ tmpXML = $ responseXmlObj -> QueryResponse -> asXML ( ) ; } $ parsedResponseBody = $ this -> responseSerializer -> Deserialize ( $ tmpXML , false ) ; $ this -> serviceContext -> IppConfiguration -> Logger -> CustomLogger -> Log ( TraceLevel :: Info , $ parsedResponseBody ) ; } catch ( \ Exception $ e ) { throw new \ Exception ( "Exception appears in converting Response to XML." ) ; } return $ parsedResponseBody ; } } 
private function appendPaginationInfo ( $ query , $ startPosition , $ maxResults ) { $ query = trim ( $ query ) ; if ( isset ( $ startPosition ) && ! empty ( $ startPosition ) ) { if ( stripos ( $ query , "STARTPOSITION" ) === false ) { if ( stripos ( $ query , "MAXRESULTS" ) !== false ) { 
public function FindAll ( $ entityName , $ pageNumber = 0 , $ pageSize = 500 ) { $ this -> serviceContext -> IppConfiguration -> Logger -> RequestLog -> Log ( TraceLevel :: Info , "Called Method FindAll." ) ; $ phpClassName = DataService :: decorateIntuitEntityToPhpClassName ( $ entityName ) ; 
public function CDC ( $ entityList , $ changedSince ) { $ this -> serviceContext -> IppConfiguration -> Logger -> CustomLogger -> Log ( TraceLevel :: Info , "Called Method CDC." ) ; 
protected function executeObjectSerializer ( $ entity , & $ urlResource ) { 
protected function initPostRequest ( $ entity , $ uri ) { return $ this -> isJsonOnly ( $ entity ) ? $ this -> getPostJsonRequest ( $ uri ) : $ this -> getPostRequest ( $ uri ) ; } 
protected function getRequestParameters ( $ uri , $ method , $ type , $ apiName = null ) { return new RequestParameters ( $ uri , $ method , $ type , $ apiName ) ; } 
private function fixTaxServicePayload ( $ entity , $ content ) { if ( $ this -> isTaxServiceSafe ( $ entity ) ) { 
public function getExportFileNameForPDF ( $ entity , $ ext , $ usetimestamp = true ) { 
protected function processDownloadedContent ( ContentWriter $ writer , $ responseCode , $ fileName = null , $ dir ) { $ writer -> setPrefix ( $ this -> getPrefixFromSettings ( ) ) ; try { if ( isset ( $ dir ) && ! empty ( $ dir ) ) { $ writer -> saveFile ( $ dir , $ fileName ) ; } else if ( $ this -> isTempFile ( ) ) { $ writer -> saveTemp ( ) ; } elseif ( $ this -> isFileExport ( ) ) { $ writer -> saveFile ( $ this -> getFileExportDir ( ) , $ fileName ) ; } else { $ writer -> saveAsHandler ( ) ; } 
private function isAllowed ( $ entity , $ method ) { $ className = get_class ( $ entity ) ; if ( ! $ className ) { $ this -> logError ( "Intuit entity is expected here instead of $entity" ) ; throw new IdsException ( 'Unexpected Argument Exception' ) ; } $ classArray = explode ( '\\' , $ className ) ; $ trimedClassName = end ( $ classArray ) ; return $ this -> serviceContext -> IppConfiguration -> OpControlList -> isAllowed ( $ trimedClassName , $ method ) ; } 
public function CreateNewBatch ( ) { $ batch = new Batch ( $ this -> serviceContext , $ this -> getRestHandler ( ) , $ this -> isThrownExceptionOnError ( ) ) ; return $ batch ; } 
private function convertToTimestamp ( $ str ) { $ result = date_parse ( $ str ) ; if ( ! $ result ) { return false ; } if ( empty ( $ result ) || ! is_array ( $ result ) ) { return false ; } extract ( $ result ) ; if ( ! empty ( $ errors ) ) { throw new SdkException ( "SDK failed to parse date value \"$str\":" . ( is_array ( $ errors ) ? implode ( "\n" , $ errors ) : $ errors ) ) ; } 
public function isValidTimeStamp ( $ timestamp ) { return ( ( string ) ( int ) $ timestamp === $ timestamp ) && ( $ timestamp <= PHP_INT_MAX ) && ( $ timestamp >= ~ PHP_INT_MAX ) ; } 
protected function verifyChangedSince ( $ value ) { if ( is_int ( $ value ) ) { return $ value ; } 
public function getCompanyInfo ( ) { $ currentServiceContext = $ this -> getServiceContext ( ) ; if ( ! isset ( $ currentServiceContext ) || empty ( $ currentServiceContext -> realmId ) ) { throw new SdkException ( "Please Setup Service Context before making get CompanyInfo call." ) ; } 
private function getIDString ( $ id ) { if ( $ id instanceof IPPid || $ id instanceof QuickBooksOnline \ API \ Data \ IPPid ) { return ( String ) $ id -> value ; } else { return ( String ) $ id ; } } 
public static function getQuickBooksOnlineAPIEntityRules ( ) { return array ( '*' => array ( "DownloadPDF" => false , "jsonOnly" => false , "SendEmail" => false ) , "IPPTaxService" => array ( '*' => false , 'Add' => true , 'jsonOnly' => true ) , "IPPSalesReceipt" => array ( "DownloadPDF" => true , "SendEmail" => true ) , "IPPInvoice" => array ( "DownloadPDF" => true , "SendEmail" => true ) , "IPPEstimate" => array ( "DownloadPDF" => true , "SendEmail" => true ) , ) ; } 
public static function getAccessTokenFromArray ( array $ settings ) { if ( array_key_exists ( 'accessTokenKey' , $ settings ) ) { return $ settings [ 'accessTokenKey' ] ; } else if ( array_key_exists ( 'accessToken' , $ settings ) ) { return $ settings [ 'accessToken' ] ; } else if ( array_key_exists ( 'AccessToken' , $ settings ) ) { return $ settings [ 'AccessToken' ] ; } else { return null ; } } 
public static function getRefreshTokenFromArray ( array $ settings ) { if ( array_key_exists ( 'refreshTokenKey' , $ settings ) ) { return $ settings [ 'refreshTokenKey' ] ; } else if ( array_key_exists ( 'refreshToken' , $ settings ) ) { return $ settings [ 'refreshToken' ] ; } else if ( array_key_exists ( 'RefreshToken' , $ settings ) ) { return $ settings [ 'RefreshToken' ] ; } else { return null ; } } 
public static function getRedirectURL ( array $ settings ) { if ( array_key_exists ( 'redirectURL' , $ settings ) ) { return $ settings [ 'redirectURL' ] ; } else if ( array_key_exists ( 'RedirectUrl' , $ settings ) ) { return $ settings [ 'RedirectUrl' ] ; } else if ( array_key_exists ( 'redirecturl' , $ settings ) ) { return $ settings [ 'redirecturl' ] ; } else if ( array_key_exists ( 'redirectUrl' , $ settings ) ) { return $ settings [ 'redirectUrl' ] ; } else if ( array_key_exists ( 'RedirectURL' , $ settings ) ) { return $ settings [ 'RedirectURL' ] ; } else if ( array_key_exists ( 'redirectURI' , $ settings ) ) { return $ settings [ 'redirectURI' ] ; } else if ( array_key_exists ( 'RedirectUri' , $ settings ) ) { return $ settings [ 'RedirectUri' ] ; } else if ( array_key_exists ( 'redirecturi' , $ settings ) ) { return $ settings [ 'redirecturl' ] ; } else if ( array_key_exists ( 'redirectUri' , $ settings ) ) { return $ settings [ 'redirectUrl' ] ; } else if ( array_key_exists ( 'RedirectURI' , $ settings ) ) { return $ settings [ 'RedirectURI' ] ; } else { return null ; } } 
public function saveTemp ( ) { $ this -> tempPath = $ this -> createTempFile ( ) ; if ( is_writable ( $ this -> getTempPath ( ) ) ) { $ result = file_put_contents ( $ this -> getTempPath ( ) , $ this -> getContent ( ) ) ; if ( false === $ result ) { throw new SdkException ( 'Unable to put content into temp file: ' . $ this -> getTempPath ( ) ) ; } if ( empty ( $ result ) ) { throw new SdkException ( 'Empty or zero file was received: ' . $ this -> getTempPath ( ) ) ; } $ this -> bytes = $ result ; return true ; } throw new SdkException ( 'Unable to write temp file: ' . $ this -> tempPath ) ; } 
public function saveAsHandler ( ) { $ this -> handler = tmpfile ( ) ; if ( false === $ this -> handler ) { throw new SdkException ( 'Unable to create a handler for tempfile in ' . sys_get_temp_dir ( ) ) ; } if ( empty ( $ this -> handler ) ) { throw new SdkException ( 'Handler has an invalid state. It is empty.' ) ; } $ this -> tempPath = $ this -> getPathFromHandler ( ) ; if ( empty ( $ this -> tempPath ) ) { throw new SdkException ( 'Unable to locate path from stream source' ) ; } $ result = fwrite ( $ this -> handler , $ this -> getContent ( ) ) ; if ( false === $ result ) { throw new SdkException ( 'Unable to write content into temp file: ' . $ this -> getTempPath ( ) ) ; } if ( empty ( $ result ) ) { throw new SdkException ( 'Empty or zero file was received: ' . $ this -> getTempPath ( ) ) ; } if ( - 1 === fseek ( $ this -> handler , 0 ) ) { throw new SdkException ( 'Unable to reset file pointer in the file ' . $ this -> getTempPath ( ) ) ; } $ this -> bytes = $ result ; } 
public function saveFile ( $ dir , $ name = null ) { if ( empty ( $ dir ) ) { throw new SdkException ( "Directory is empty." ) ; } if ( ! file_exists ( $ dir ) ) { throw new SdkException ( "Directory ($dir) doesn't exist." ) ; } if ( ! is_writable ( $ dir ) ) { throw new SdkException ( "Directory ($dir) is not writable" ) ; } $ this -> tempPath = $ dir . DIRECTORY_SEPARATOR . $ this -> generateFileName ( $ name ) ; if ( file_exists ( $ this -> tempPath ) ) { throw new SdkException ( "File ($this->tempPath) already exists" ) ; } try { $ result = file_put_contents ( $ this -> tempPath , $ this -> getContent ( ) ) ; } catch ( \ Exception $ e ) { if ( ! is_writable ( $ this -> tempPath ) ) { throw new SdkException ( "File ({$this->tempPath}) is not writable" ) ; } throw new SdkException ( "Error was thrown: " . $ e -> getMessage ( ) . "\File: " . $ e -> getFile ( ) . " on line " . $ e -> getLine ( ) ) ; } if ( false === $ result ) { throw new SdkException ( 'Unable to write content into temp file: ' . $ this -> tempPath ) ; } $ this -> bytes = $ result ; } 
private function generateFileName ( $ name ) { $ filename = is_null ( $ name ) ? $ this -> getUniqId ( ) : $ name ; return is_null ( $ this -> getPrefix ( ) ) ? $ filename : $ this -> getPrefix ( ) . $ filename ; } 
public static function update ( $ objToUpdate , array $ data ) { $ classOfObj = get_class ( $ objToUpdate ) ; if ( strcmp ( $ classOfObj , FacadeHelper :: simpleAppendClassNameSpace ( "Estimate" ) ) != 0 ) { throw new \ Exception ( "Target object class:{" . $ classOfObj . "} is not an instance of Estimate." ) ; } $ newEstimateObj = Estimate :: create ( $ data ) ; $ clonedOfObj = FacadeHelper :: cloneObj ( $ objToUpdate ) ; FacadeHelper :: mergeObj ( $ clonedOfObj , $ newEstimateObj ) ; return $ clonedOfObj ; } 
private function generateErrorFromOAuthMsg ( $ OAuthException ) { if ( get_class ( $ OAuthException ) == 'OAuthException' ) { $ this -> httpStatusCode = $ OAuthException -> getCode ( ) ; $ this -> helpMsg = $ OAuthException -> getMessage ( ) ; $ this -> responseBody = $ OAuthException -> lastResponse ; } else { throw new \ Exception ( "OAuthException required for generate error from Intuit. The passed parameters for Fault handler is not OAuthException" ) ; } } 
public function parseResponse ( $ message ) { $ xmlObj = simplexml_load_string ( $ message ) ; if ( ! $ this -> isTheErrorBodyInStandardFormat ( $ xmlObj ) ) { return ; } $ type = ( string ) $ xmlObj -> Fault -> attributes ( ) [ 'type' ] ; if ( isset ( $ type ) && ! empty ( $ type ) ) { $ this -> intuitErrorType = $ type ; } $ code = ( string ) $ xmlObj -> Fault -> Error -> attributes ( ) [ 'code' ] ; if ( isset ( $ code ) && ! empty ( $ code ) ) { $ this -> intuitErrorCode = $ code ; } $ element = ( string ) $ xmlObj -> Fault -> Error -> attributes ( ) [ 'element' ] ; if ( isset ( $ element ) && ! empty ( $ element ) ) { $ this -> intuitErrorElement = $ element ; } $ message = ( string ) $ xmlObj -> Fault -> Error -> Message ; if ( isset ( $ message ) && ! empty ( $ message ) ) { $ this -> intuitErrorMessage = $ message ; } $ detail = ( string ) $ xmlObj -> Fault -> Error -> Detail ; if ( isset ( $ detail ) && ! empty ( $ detail ) ) { $ this -> intuitErrorDetail = $ detail ; } } 
private function isTheErrorBodyInStandardFormat ( $ xmlObj ) { if ( ! isset ( $ xmlObj -> Fault ) || ! isset ( $ xmlObj -> Fault -> Error ) ) { return false ; } return true ; } 
public static function update ( $ objToUpdate , array $ data ) { $ classOfObj = get_class ( $ objToUpdate ) ; if ( strcmp ( $ classOfObj , FacadeHelper :: simpleAppendClassNameSpace ( "Deposit" ) ) != 0 ) { throw new \ Exception ( "Target object class:{" . $ classOfObj . "} is not an instance of Deposit." ) ; } $ newDepositObj = Deposit :: create ( $ data ) ; $ clonedOfObj = FacadeHelper :: cloneObj ( $ objToUpdate ) ; FacadeHelper :: mergeObj ( $ clonedOfObj , $ newDepositObj ) ; return $ clonedOfObj ; } 
public static function update ( $ objToUpdate , array $ data ) { $ classOfObj = get_class ( $ objToUpdate ) ; if ( strcmp ( $ classOfObj , FacadeHelper :: simpleAppendClassNameSpace ( "Customer" ) ) != 0 ) { throw new \ Exception ( "Target object class:{" . $ classOfObj . "} is not an instance of Customer." ) ; } $ newCustomerObj = Customer :: create ( $ data ) ; $ clonedOfObj = FacadeHelper :: cloneObj ( $ objToUpdate ) ; FacadeHelper :: mergeObj ( $ clonedOfObj , $ newCustomerObj ) ; return $ clonedOfObj ; } 
private function setResponseAsItIs ( $ passedHeaders , $ passedBody , $ passedHttpResponseCode ) { if ( isset ( $ passedHeaders ) && isset ( $ passedBody ) && isset ( $ passedHttpResponseCode ) ) { $ this -> headers = $ passedHeaders ; $ this -> body = $ passedBody ; $ this -> httpResponseCode = $ passedHttpResponseCode ; $ this -> setContentType ( CoreConstants :: CONTENT_TYPE , $ passedHeaders [ CoreConstants :: CONTENT_TYPE ] ) ; $ this -> setIntuitTid ( CoreConstants :: INTUIT_TID , $ passedHeaders [ CoreConstants :: INTUIT_TID ] ) ; $ this -> setFaultHandler ( $ passedBody , $ passedHttpResponseCode , $ this -> getIntuitTid ( ) ) ; } else { throw new SdkException ( "Passed Headers, body, or status code is Null." ) ; } } 
private function parseResponseToIntuitResponse ( $ passedHeaders , $ passedBody , $ passedHttpResponseCode , $ clientName ) { if ( $ clientName == CoreConstants :: CLIENT_CURL ) { if ( isset ( $ passedHeaders ) ) { $ this -> setHeaders ( $ passedHeaders ) ; } else { throw new SdkException ( "The response header from cURL is null." ) ; } if ( isset ( $ passedBody ) ) { $ this -> body = $ passedBody ; } else { throw new SdkException ( "The Http Response Body from cURL is null." ) ; } if ( isset ( $ passedHttpResponseCode ) ) { $ this -> httpResponseCode = ( int ) $ passedHttpResponseCode ; $ this -> setFaultHandler ( $ this -> getBody ( ) , $ this -> getStatusCode ( ) , $ this -> getIntuitTid ( ) ) ; } else { throw new SdkException ( "Passed Http status code from cURL is null." ) ; } } else { throw new SdkException ( "This should not be thrown. IntuitResponse currently don't support parse other client response to Intuit Response other than curl." ) ; } } 
private function setFaultHandler ( $ body , $ httpResponseCode , $ tid ) { 
public function setHeaders ( $ rawHeaders ) { $ rawHeaders = str_replace ( "\r\n" , "\n" , $ rawHeaders ) ; $ response_headers_rows = explode ( "\n" , trim ( $ rawHeaders ) ) ; foreach ( $ response_headers_rows as $ line ) { if ( strpos ( $ line , ': ' ) == false ) { continue ; } else { list ( $ key , $ value ) = explode ( ': ' , $ line ) ; $ this -> headers [ $ key ] = $ value ; 
private function setContentType ( $ key , $ val ) { $ trimedKey = trim ( $ key ) ; if ( strcasecmp ( $ trimedKey , CoreConstants :: CONTENT_TYPE ) == 0 ) { $ this -> contentType = trim ( $ val ) ; } } 
private function setIntuitTid ( $ key , $ val ) { $ trimedKey = trim ( $ key ) ; if ( strcasecmp ( $ trimedKey , CoreConstants :: INTUIT_TID ) == 0 ) { $ this -> intuit_tid = trim ( $ val ) ; } } 
public static function update ( $ objToUpdate , array $ data ) { $ classOfObj = get_class ( $ objToUpdate ) ; if ( strcmp ( $ classOfObj , FacadeHelper :: simpleAppendClassNameSpace ( "Department" ) ) != 0 ) { throw new \ Exception ( "Target object class:{" . $ classOfObj . "} is not an instance of Department." ) ; } $ newDepartmentObj = Department :: create ( $ data ) ; $ clonedOfObj = FacadeHelper :: cloneObj ( $ objToUpdate ) ; FacadeHelper :: mergeObj ( $ clonedOfObj , $ newDepartmentObj ) ; return $ clonedOfObj ; } 
public function GetAppMenu ( ) { $ this -> requestXmlDocument = '' ; $ uriFragment = implode ( CoreConstants :: SLASH_CHAR , array ( 'v1' , 'Account' , 'AppMenu' ) ) ; $ requestParameters = new RequestParameters ( null , 'GET' , null , $ uriFragment ) ; list ( $ respCode , $ respHtml ) = $ this -> restRequestHandler -> sendRequest ( $ requestParameters , $ this -> requestXmlDocument , null ) ; return $ respHtml ; } 
public function Reconnect ( ) { $ this -> requestXmlDocument = '' ; $ uriFragment = implode ( CoreConstants :: SLASH_CHAR , array ( 'v1' , 'Connection' , 'Reconnect' ) ) ; $ requestParameters = new RequestParameters ( null , 'GET' , null , $ uriFragment ) ; list ( $ respCode , $ respXml ) = $ this -> restRequestHandler -> sendRequest ( $ requestParameters , $ this -> requestXmlDocument , null ) ; return simplexml_load_string ( $ respXml ) ; } 
public function setUri ( $ uri ) { if ( $ uri instanceof Zend_Uri_Http ) { $ uri = $ uri -> getUri ( ) ; } $ oldUri = $ this -> _uri ; $ this -> _uri = $ uri ; if ( $ this -> _dom !== null ) { 
public function setComplexTypeStrategy ( $ strategy ) { if ( $ strategy === true ) { require_once "Zend/Soap/Wsdl/Strategy/DefaultComplexType.php" ; $ strategy = new Zend_Soap_Wsdl_Strategy_DefaultComplexType ( ) ; } elseif ( $ strategy === false ) { require_once "Zend/Soap/Wsdl/Strategy/AnyType.php" ; $ strategy = new Zend_Soap_Wsdl_Strategy_AnyType ( ) ; } elseif ( is_string ( $ strategy ) ) { if ( class_exists ( $ strategy ) ) { $ strategy = new $ strategy ( ) ; } else { require_once "Zend/Soap/Wsdl/Exception.php" ; throw new Zend_Soap_Wsdl_Exception ( sprintf ( "Strategy with name '%s does not exist." , $ strategy ) ) ; } } if ( ! ( $ strategy instanceof Zend_Soap_Wsdl_Strategy_Interface ) ) { require_once "Zend/Soap/Wsdl/Exception.php" ; throw new Zend_Soap_Wsdl_Exception ( "Set a strategy that is not of type 'Zend_Soap_Wsdl_Strategy_Interface'" ) ; } $ this -> _strategy = $ strategy ; return $ this ; } 
public function addMessage ( $ name , $ parts ) { $ message = $ this -> _dom -> createElement ( 'message' ) ; $ message -> setAttribute ( 'name' , $ name ) ; if ( sizeof ( $ parts ) > 0 ) { foreach ( $ parts as $ name => $ type ) { $ part = $ this -> _dom -> createElement ( 'part' ) ; $ part -> setAttribute ( 'name' , $ name ) ; if ( is_array ( $ type ) ) { foreach ( $ type as $ key => $ value ) { $ part -> setAttribute ( $ key , $ value ) ; } } else { $ part -> setAttribute ( 'type' , $ type ) ; } $ message -> appendChild ( $ part ) ; } } $ this -> _wsdl -> appendChild ( $ message ) ; return $ message ; } 
public function addPortType ( $ name ) { $ portType = $ this -> _dom -> createElement ( 'portType' ) ; $ portType -> setAttribute ( 'name' , $ name ) ; $ this -> _wsdl -> appendChild ( $ portType ) ; return $ portType ; } 
public function addPortOperation ( $ portType , $ name , $ input = false , $ output = false , $ fault = false ) { $ operation = $ this -> _dom -> createElement ( 'operation' ) ; $ operation -> setAttribute ( 'name' , $ name ) ; if ( is_string ( $ input ) && ( strlen ( trim ( $ input ) ) >= 1 ) ) { $ node = $ this -> _dom -> createElement ( 'input' ) ; $ node -> setAttribute ( 'message' , $ input ) ; $ operation -> appendChild ( $ node ) ; } if ( is_string ( $ output ) && ( strlen ( trim ( $ output ) ) >= 1 ) ) { $ node = $ this -> _dom -> createElement ( 'output' ) ; $ node -> setAttribute ( 'message' , $ output ) ; $ operation -> appendChild ( $ node ) ; } if ( is_string ( $ fault ) && ( strlen ( trim ( $ fault ) ) >= 1 ) ) { $ node = $ this -> _dom -> createElement ( 'fault' ) ; $ node -> setAttribute ( 'message' , $ fault ) ; $ operation -> appendChild ( $ node ) ; } $ portType -> appendChild ( $ operation ) ; return $ operation ; } 
public function addBinding ( $ name , $ portType ) { $ binding = $ this -> _dom -> createElement ( 'binding' ) ; $ binding -> setAttribute ( 'name' , $ name ) ; $ binding -> setAttribute ( 'type' , $ portType ) ; $ this -> _wsdl -> appendChild ( $ binding ) ; return $ binding ; } 
public function addBindingOperation ( $ binding , $ name , $ input = false , $ output = false , $ fault = false ) { $ operation = $ this -> _dom -> createElement ( 'operation' ) ; $ operation -> setAttribute ( 'name' , $ name ) ; if ( is_array ( $ input ) ) { $ node = $ this -> _dom -> createElement ( 'input' ) ; $ soap_node = $ this -> _dom -> createElement ( 'soap:body' ) ; foreach ( $ input as $ name => $ value ) { $ soap_node -> setAttribute ( $ name , $ value ) ; } $ node -> appendChild ( $ soap_node ) ; $ operation -> appendChild ( $ node ) ; } if ( is_array ( $ output ) ) { $ node = $ this -> _dom -> createElement ( 'output' ) ; $ soap_node = $ this -> _dom -> createElement ( 'soap:body' ) ; foreach ( $ output as $ name => $ value ) { $ soap_node -> setAttribute ( $ name , $ value ) ; } $ node -> appendChild ( $ soap_node ) ; $ operation -> appendChild ( $ node ) ; } if ( is_array ( $ fault ) ) { $ node = $ this -> _dom -> createElement ( 'fault' ) ; if ( isset ( $ fault [ 'name' ] ) ) { $ node -> setAttribute ( 'name' , $ fault [ 'name' ] ) ; } $ soap_node = $ this -> _dom -> createElement ( 'soap:body' ) ; foreach ( $ output as $ name => $ value ) { $ soap_node -> setAttribute ( $ name , $ value ) ; } $ node -> appendChild ( $ soap_node ) ; $ operation -> appendChild ( $ node ) ; } $ binding -> appendChild ( $ operation ) ; return $ operation ; } 
public function addSoapBinding ( $ binding , $ style = 'document' , $ transport = 'http://schemas.xmlsoap.org/soap/http' ) { $ soap_binding = $ this -> _dom -> createElement ( 'soap:binding' ) ; $ soap_binding -> setAttribute ( 'style' , $ style ) ; $ soap_binding -> setAttribute ( 'transport' , $ transport ) ; $ binding -> appendChild ( $ soap_binding ) ; return $ soap_binding ; } 
public function addSoapOperation ( $ binding , $ soap_action ) { if ( $ soap_action instanceof Zend_Uri_Http ) { $ soap_action = $ soap_action -> getUri ( ) ; } $ soap_operation = $ this -> _dom -> createElement ( 'soap:operation' ) ; $ soap_operation -> setAttribute ( 'soapAction' , $ soap_action ) ; $ binding -> insertBefore ( $ soap_operation , $ binding -> firstChild ) ; return $ soap_operation ; } 
public function addService ( $ name , $ port_name , $ binding , $ location ) { if ( $ location instanceof Zend_Uri_Http ) { $ location = $ location -> getUri ( ) ; } $ service = $ this -> _dom -> createElement ( 'service' ) ; $ service -> setAttribute ( 'name' , $ name ) ; $ port = $ this -> _dom -> createElement ( 'port' ) ; $ port -> setAttribute ( 'name' , $ port_name ) ; $ port -> setAttribute ( 'binding' , $ binding ) ; $ soap_address = $ this -> _dom -> createElement ( 'soap:address' ) ; $ soap_address -> setAttribute ( 'location' , $ location ) ; $ port -> appendChild ( $ soap_address ) ; $ service -> appendChild ( $ port ) ; $ this -> _wsdl -> appendChild ( $ service ) ; return $ service ; } 
public function addDocumentation ( $ input_node , $ documentation ) { if ( $ input_node === $ this ) { $ node = $ this -> _dom -> documentElement ; } else { $ node = $ input_node ; } $ doc = $ this -> _dom -> createElement ( 'documentation' ) ; $ doc_cdata = $ this -> _dom -> createTextNode ( $ documentation ) ; $ doc -> appendChild ( $ doc_cdata ) ; if ( $ node -> hasChildNodes ( ) ) { $ node -> insertBefore ( $ doc , $ node -> firstChild ) ; } else { $ node -> appendChild ( $ doc ) ; } return $ doc ; } 
public function addTypes ( $ types ) { if ( $ types instanceof DomDocument ) { $ dom = $ this -> _dom -> importNode ( $ types -> documentElement ) ; $ this -> _wsdl -> appendChild ( $ types -> documentElement ) ; } elseif ( $ types instanceof DomNode || $ types instanceof DomElement || $ types instanceof DomDocumentFragment ) { $ dom = $ this -> _dom -> importNode ( $ types ) ; $ this -> _wsdl -> appendChild ( $ dom ) ; } } 
public function addType ( $ type ) { if ( ! in_array ( $ type , $ this -> _includedTypes ) ) { $ this -> _includedTypes [ ] = $ type ; } return $ this ; } 
public function dump ( $ filename = false ) { if ( ! $ filename ) { echo $ this -> toXML ( ) ; return true ; } else { return file_put_contents ( $ filename , $ this -> toXML ( ) ) ; } } 
public function addSchemaTypeSection ( ) { if ( $ this -> _schema === null ) { $ this -> _schema = $ this -> _dom -> createElement ( 'xsd:schema' ) ; $ this -> _schema -> setAttribute ( 'targetNamespace' , $ this -> _uri ) ; $ types = $ this -> _dom -> createElement ( 'types' ) ; $ types -> appendChild ( $ this -> _schema ) ; $ this -> _wsdl -> appendChild ( $ types ) ; } return $ this ; } 
public function addComplexType ( $ type ) { if ( in_array ( $ type , $ this -> getTypes ( ) ) ) { return "tns:$type" ; } $ this -> addSchemaTypeSection ( ) ; $ strategy = $ this -> getComplexTypeStrategy ( ) ; $ strategy -> setContext ( $ this ) ; 
private function _parseElement ( $ element ) { if ( ! is_array ( $ element ) ) { require_once "Zend/Soap/Wsdl/Exception.php" ; throw new Zend_Soap_Wsdl_Exception ( "The 'element' parameter needs to be an associative array." ) ; } $ elementXml = $ this -> _dom -> createElement ( 'xsd:element' ) ; foreach ( $ element as $ key => $ value ) { if ( in_array ( $ key , array ( 'sequence' , 'all' , 'choice' ) ) ) { if ( is_array ( $ value ) ) { $ complexType = $ this -> _dom -> createElement ( 'xsd:complexType' ) ; if ( count ( $ value ) > 0 ) { $ container = $ this -> _dom -> createElement ( 'xsd:' . $ key ) ; foreach ( $ value as $ subelement ) { $ subelementXml = $ this -> _parseElement ( $ subelement ) ; $ container -> appendChild ( $ subelementXml ) ; } $ complexType -> appendChild ( $ container ) ; } $ elementXml -> appendChild ( $ complexType ) ; } } else { $ elementXml -> setAttribute ( $ key , $ value ) ; } } return $ elementXml ; } 
public function addElement ( $ element ) { $ schema = $ this -> getSchema ( ) ; $ elementXml = $ this -> _parseElement ( $ element ) ; $ schema -> appendChild ( $ elementXml ) ; return 'tns:' . $ element [ 'name' ] ; } 
public static function update ( $ objToUpdate , array $ data ) { $ classOfObj = get_class ( $ objToUpdate ) ; if ( strcmp ( $ classOfObj , FacadeHelper :: simpleAppendClassNameSpace ( "PurchaseOrder" ) ) != 0 ) { throw new \ Exception ( "Target object class:{" . $ classOfObj . "} is not an instance of PurchaseOrder." ) ; } $ newPurchaseOrderObj = PurchaseOrder :: create ( $ data ) ; $ clonedOfObj = FacadeHelper :: cloneObj ( $ objToUpdate ) ; FacadeHelper :: mergeObj ( $ clonedOfObj , $ newPurchaseOrderObj ) ; return $ clonedOfObj ; } 
public static function ConfigureFromPassedArray ( array $ settings ) { ServiceContext :: checkIfOAuthIsValid ( $ settings ) ; if ( strcasecmp ( $ settings [ 'auth_mode' ] , CoreConstants :: OAUTH1 ) == 0 ) { $ OAuthConfig = new OAuthRequestValidator ( $ settings [ 'accessTokenKey' ] , $ settings [ 'accessTokenSecret' ] , $ settings [ 'consumerKey' ] , $ settings [ 'consumerSecret' ] ) ; } else { $ OAuthConfig = new OAuth2AccessToken ( $ settings [ 'ClientID' ] , $ settings [ 'ClientSecret' ] , CoreConstants :: getAccessTokenFromArray ( $ settings ) , CoreConstants :: getRefreshTokenFromArray ( $ settings ) ) ; } $ QBORealmID = array_key_exists ( 'QBORealmID' , $ settings ) ? $ settings [ 'QBORealmID' ] : null ; $ baseURL = array_key_exists ( 'baseUrl' , $ settings ) ? $ settings [ 'baseUrl' ] : null ; if ( strcasecmp ( $ baseURL , CoreConstants :: DEVELOPMENT_SANDBOX ) == 0 ) { $ baseURL = CoreConstants :: SANDBOX_DEVELOPMENT ; } else if ( strcasecmp ( $ baseURL , CoreConstants :: PRODUCTION_QBO ) == 0 ) { $ baseURL = CoreConstants :: QBO_BASEURL ; } $ checkedBaseURL = ServiceContext :: checkAndAddBaseURLSlash ( $ baseURL ) ; if ( $ OAuthConfig instanceof OAuth2AccessToken ) { $ OAuthConfig -> setRealmID ( $ QBORealmID ) ; $ OAuthConfig -> setBaseURL ( $ checkedBaseURL ) ; } $ serviceType = CoreConstants :: IntuitServicesTypeQBO ; $ IppConfiguration = LocalConfigReader :: ReadConfigurationFromParameters ( $ OAuthConfig , $ checkedBaseURL , CoreConstants :: DEFAULT_LOGGINGLOCATION , CoreConstants :: DEFAULT_SDK_MINOR_VERSION ) ; $ serviceContextInstance = new ServiceContext ( $ QBORealmID , $ serviceType , $ OAuthConfig , $ IppConfiguration ) ; return $ serviceContextInstance ; } 
public static function checkIfOAuthIsValid ( array $ settings ) { if ( ! isset ( $ settings ) || empty ( $ settings ) ) { throw new SdkException ( "Empty OAuth Array passed. Can't construct ServiceContext based on Empty Array." ) ; } if ( ! isset ( $ settings [ 'auth_mode' ] ) ) { throw new SdkException ( "No OAuth 1 or OAuth 2 Mode specified. Can't validate OAuth tokens." ) ; } $ mode = $ settings [ 'auth_mode' ] ; 
private static function checkAndAddBaseURLSlash ( $ baseURL ) { $ lastChar = substr ( $ baseURL , - 1 ) ; if ( strcmp ( $ lastChar , "/" ) != 0 ) { $ baseURL = $ baseURL . "/" ; } return $ baseURL ; } 
public function getBaseURL ( ) { $ this -> IppConfiguration -> Logger -> RequestLog -> Log ( TraceLevel :: Info , "Called GetBaseURL method." ) ; try { if ( $ this -> serviceType === CoreConstants :: IntuitServicesTypeQBO ) { $ baseurl = $ this -> IppConfiguration -> BaseUrl -> Qbo . implode ( CoreConstants :: SLASH_CHAR , array ( CoreConstants :: VERSION ) ) . CoreConstants :: SLASH_CHAR ; } else if ( $ this -> serviceType === CoreConstants :: IntuitServicesTypeIPP ) { $ this -> IppConfiguration -> BaseUrl -> Ipp = CoreConstants :: IPP_BASEURL ; $ baseurl = $ this -> IppConfiguration -> BaseUrl -> Ipp ; } } catch ( \ Exception $ e ) { throw new \ Exception ( "Base URL is not setup" ) ; } return $ baseurl ; } 
public function useXml ( ) { $ this -> IppConfiguration -> Message -> Request -> CompressionFormat = CompressionFormat :: None ; $ this -> IppConfiguration -> Message -> Response -> CompressionFormat = CompressionFormat :: None ; $ this -> IppConfiguration -> Message -> Request -> SerializationFormat = SerializationFormat :: Xml ; $ this -> IppConfiguration -> Message -> Response -> SerializationFormat = SerializationFormat :: Xml ; } 
public function useJson ( ) { $ this -> IppConfiguration -> Message -> Request -> CompressionFormat = CompressionFormat :: None ; $ this -> IppConfiguration -> Message -> Response -> CompressionFormat = CompressionFormat :: None ; $ this -> IppConfiguration -> Message -> Request -> SerializationFormat = SerializationFormat :: Json ; $ this -> IppConfiguration -> Message -> Response -> SerializationFormat = SerializationFormat :: Json ; } 
public function disableLog ( ) { try { $ _ippConfigInstance = $ this -> getIppConfig ( ) ; LocalConfigReader :: setupLogger ( $ _ippConfigInstance , CoreConstants :: DEFAULT_LOGGINGLOCATION , "FALSE" ) ; } catch ( \ Exception $ e ) { throw new \ Exception ( "Error in disable Log." ) ; } } 
public function setLogLocation ( $ new_log_location ) { try { $ _ippConfigInstance = $ this -> getIppConfig ( ) ; LocalConfigReader :: setupLogger ( $ _ippConfigInstance , $ new_log_location , "TRUE" ) ; } catch ( \ Exception $ e ) { throw new \ Exception ( "Error in setting up new Log Configuration: " . $ new_log_location ) ; } } 
public function updateOAuth2Token ( $ OAuth2AccessToken ) { if ( $ OAuth2AccessToken instanceof OAuth2AccessToken && $ this -> requestValidator instanceof OAuth2AccessToken ) { $ this -> IppConfiguration -> Security = $ OAuth2AccessToken ; $ this -> requestValidator = $ OAuth2AccessToken ; } } 
public function Log ( $ idsTraceLevel , $ messageToWrite ) { if ( ( int ) $ this -> traceSwitchLevel < ( int ) $ idsTraceLevel ) { return ; } $ backTrace = debug_backtrace ( ) ; $ callerFileName = $ backTrace [ 0 ] [ 'file' ] ; $ callerFileLineNumber = $ backTrace [ 0 ] [ 'line' ] ; $ callerFunctionName = $ backTrace [ 0 ] [ 'function' ] ; $ logMessage = implode ( " - " , array ( date ( 'Y-m-d H:i:s' ) , $ callerFileName , $ callerFileLineNumber , $ callerFunctionName , $ messageToWrite ) ) ; parent :: Log ( $ idsTraceLevel , $ logMessage ) ; } 
public function getPhpCode ( ) { $ code = "\n" ; if ( $ this -> extendsNamespace != '' ) { if ( false === $ this -> overrideAsSingleNamespace ) { $ code .= "use " . $ this -> extendsNamespace . ";\n" ; } } if ( ! empty ( $ this -> classDocBlock ) ) { $ code .= $ this -> getDocBlock ( $ this -> classDocBlock ) ; } if ( $ this -> name == $ this -> classPrefix . $ this -> extends ) { $ this -> name = $ this -> name . "Wrapper" ; } $ code .= 'class ' . $ this -> name . "\n" ; if ( $ this -> extends != '' ) { if ( $ this -> extendsNamespace != '' ) { $ nsLastName = array_reverse ( explode ( '\\' , $ this -> extendsNamespace ) ) ; $ code .= "\t" . 'extends ' . $ this -> classPrefix . $ nsLastName [ 0 ] ; 
public function getClassProperties ( $ props , $ indent = "\t" ) { $ code = $ indent . "\n" ; foreach ( $ props as $ prop ) { if ( ! empty ( $ prop [ 'docs' ] ) ) { $ code .= $ indent . $ this -> getDocBlock ( $ prop [ 'docs' ] , $ indent ) ; } $ code .= $ indent . 'public $' . $ prop [ 'name' ] . ";\n" ; } return $ code ; } 
public function getDocBlock ( $ docs , $ indent = "" ) { $ code = '/**' . "\n" ; foreach ( $ docs as $ key => $ value ) { $ code .= $ indent . ' * @' . $ key . ' ' . $ value . "\n" ; } $ code .= $ indent . ' */' . "\n" ; return $ code ; } 
public static function update ( $ objToUpdate , array $ data ) { $ classOfObj = get_class ( $ objToUpdate ) ; if ( strcmp ( $ classOfObj , FacadeHelper :: simpleAppendClassNameSpace ( "Purchase" ) ) != 0 ) { throw new \ Exception ( "Target object class:{" . $ classOfObj . "} is not an instance of Purchase." ) ; } $ newPurchaseObj = Purchase :: create ( $ data ) ; $ clonedOfObj = FacadeHelper :: cloneObj ( $ objToUpdate ) ; FacadeHelper :: mergeObj ( $ clonedOfObj , $ newPurchaseObj ) ; return $ clonedOfObj ; } 
public function getResult ( ) { if ( isset ( $ this -> entity ) ) { return $ this -> entity ; } else if ( isset ( $ this -> entities ) ) { return $ this -> entities ; } else { return null ; } } 
public function setUri ( $ uri ) { if ( ! is_string ( $ uri ) && ! ( $ uri instanceof Zend_Uri ) ) { require_once "Zend/Soap/AutoDiscover/Exception.php" ; throw new Zend_Soap_AutoDiscover_Exception ( "No uri given to Zend_Soap_AutoDiscover::setUri as string or Zend_Uri instance." ) ; } $ this -> _uri = $ uri ; 
public function getUri ( ) { if ( $ this -> _uri !== null ) { $ uri = $ this -> _uri ; } else { $ schema = $ this -> getSchema ( ) ; $ host = $ this -> getHostName ( ) ; $ scriptName = $ this -> getRequestUriWithoutParameters ( ) ; $ uri = Zend_Uri :: factory ( $ schema . '://' . $ host . $ scriptName ) ; $ this -> setUri ( $ uri ) ; } return $ uri ; } 
public function setBindingStyle ( array $ bindingStyle = array ( ) ) { if ( isset ( $ bindingStyle [ 'style' ] ) ) { $ this -> _bindingStyle [ 'style' ] = $ bindingStyle [ 'style' ] ; } if ( isset ( $ bindingStyle [ 'transport' ] ) ) { $ this -> _bindingStyle [ 'transport' ] = $ bindingStyle [ 'transport' ] ; } return $ this ; } 
protected function getRequestUriWithoutParameters ( ) { if ( isset ( $ _SERVER [ 'HTTP_X_REWRITE_URL' ] ) ) { 
public function setComplexTypeStrategy ( $ strategy ) { $ this -> _strategy = $ strategy ; if ( $ this -> _wsdl instanceof Zend_Soap_Wsdl ) { $ this -> _wsdl -> setComplexTypeStrategy ( $ strategy ) ; } return $ this ; } 
public function setClass ( $ class , $ namespace = '' , $ argv = null ) { $ uri = $ this -> getUri ( ) ; $ wsdl = new Zend_Soap_Wsdl ( $ class , $ uri , $ this -> _strategy ) ; 
public function addFunction ( $ function , $ namespace = '' ) { static $ port ; static $ operation ; static $ binding ; if ( ! is_array ( $ function ) ) { $ function = ( array ) $ function ; } $ uri = $ this -> getUri ( ) ; if ( ! ( $ this -> _wsdl instanceof Zend_Soap_Wsdl ) ) { $ parts = explode ( '.' , basename ( $ _SERVER [ 'SCRIPT_NAME' ] ) ) ; $ name = $ parts [ 0 ] ; $ wsdl = new Zend_Soap_Wsdl ( $ name , $ uri , $ this -> _strategy ) ; 
protected function _addFunctionToWsdl ( $ function , $ wsdl , $ port , $ binding ) { $ uri = $ this -> getUri ( ) ; 
public function dump ( $ filename ) { if ( $ this -> _wsdl !== null ) { return $ this -> _wsdl -> dump ( $ filename ) ; } else { require_once "Zend/Soap/AutoDiscover/Exception.php" ; throw new Zend_Soap_AutoDiscover_Exception ( "Cannot dump autodiscovered contents, WSDL file has not been generated yet." ) ; } } 
public static function update ( $ objToUpdate , array $ data ) { $ classOfObj = get_class ( $ objToUpdate ) ; if ( strcmp ( $ classOfObj , FacadeHelper :: simpleAppendClassNameSpace ( "Class" ) ) != 0 ) { throw new \ Exception ( "Target object class:{" . $ classOfObj . "} is not an instance of Class." ) ; } $ newClassObj = QuickBookClass :: create ( $ data ) ; $ clonedOfObj = FacadeHelper :: cloneObj ( $ objToUpdate ) ; FacadeHelper :: mergeObj ( $ clonedOfObj , $ newClassObj ) ; return $ clonedOfObj ; } 
public function updateContext ( $ newServiceContext ) { if ( isset ( $ newServiceContext ) && $ newServiceContext instanceof ServiceContext ) { $ this -> context = $ newServiceContext ; } else { throw new SdkException ( "Cannot Update Service Context. The service context either is undefined or not an instance of ServiceContext." ) ; } } 
public function sendRequest ( $ requestParameters , $ requestBody , $ specifiedRequestUri , $ throwExceptionOnError = false ) { 
private function OAuth1APICall ( $ baseURL , $ queryParameters , $ HttpMethod , $ requestUri , $ requestParameters , $ requestBody , $ throwExceptionOnError ) { $ AuthorizationHeader = $ this -> getOAuth1AuthorizationHeader ( $ baseURL , $ queryParameters , $ HttpMethod ) ; $ httpHeaders = $ this -> setCommonHeadersForPHPSDK ( $ AuthorizationHeader , $ requestUri , $ requestParameters -> ContentType , $ requestBody ) ; 
private function getOAuth1AuthorizationHeader ( $ baseURL , $ queryParameters , $ HttpMethod ) { $ oauth1 = new OAuth1 ( $ this -> context -> requestValidator -> ConsumerKey , $ this -> context -> requestValidator -> ConsumerSecret , $ this -> context -> requestValidator -> AccessToken , $ this -> context -> requestValidator -> AccessTokenSecret ) ; $ AuthorizationHeader = $ oauth1 -> getOAuthHeader ( $ baseURL , $ queryParameters , $ HttpMethod ) ; return $ AuthorizationHeader ; } 
private function OAuth2APICall ( $ baseURL , $ queryParameters , $ HttpMethod , $ requestUri , $ requestParameters , $ requestBody , $ throwExceptionOnError ) { $ AuthorizationHeader = $ this -> getOAuth2AuthorizationHeader ( $ this -> context -> requestValidator ) ; 
private function getOAuth2AuthorizationHeader ( $ OAuth2AccessToken ) { if ( ! $ OAuth2AccessToken instanceof OAuth2AccessToken ) { throw new SdkException ( "Internal Error. The OAuth 2 configuration is not complete." ) ; } $ accessToken = $ OAuth2AccessToken -> getAccessToken ( ) ; $ AuthorizationHeader = "Bearer " . $ accessToken ; return $ AuthorizationHeader ; } 
private function setCommonHeadersForPHPSDK ( $ AuthorizationHeader , $ requestUri , $ ContentType , $ requestBody ) { $ httpHeaders = array ( 'Authorization' => $ AuthorizationHeader , 'host' => parse_url ( $ requestUri , PHP_URL_HOST ) , 'user-agent' => CoreConstants :: USERAGENT , 'accept' => $ this -> getAcceptContentType ( $ ContentType ) , 'connection' => 'close' , 'content-type' => $ ContentType , 'content-length' => strlen ( $ requestBody ) ) ; return $ httpHeaders ; } 
public function LogAPIResponseToLog ( $ body , $ requestUri , $ httpHeaders ) { if ( strcasecmp ( $ httpHeaders [ CoreConstants :: CONTENT_TYPE ] , CoreConstants :: CONTENTTYPE_APPLICATIONXML ) == 0 || strcasecmp ( $ httpHeaders [ CoreConstants :: CONTENT_TYPE ] , CoreConstants :: CONTENTTYPE_APPLICATIONXML_WITH_CHARSET ) == 0 ) { $ body = $ this -> parseStringToDom ( $ body ) ; } $ this -> RequestLogging -> LogPlatformRequests ( $ body , $ requestUri , $ httpHeaders , false ) ; } 
public function LogAPIRequestToLog ( $ requestBody , $ requestUri , $ httpHeaders ) { $ this -> RequestLogging -> LogPlatformRequests ( $ requestBody , $ requestUri , $ httpHeaders , true ) ; if ( $ requestBody && $ this -> RequestCompressor ) { $ this -> RequestCompressor -> Compress ( $ httpHeaders , $ requestBody ) ; } if ( $ this -> ResponseCompressor ) { $ this -> ResponseCompressor -> PrepareDecompress ( $ httpHeaders ) ; } } 
private function parseStringToDom ( $ string ) { $ dom = new \ DOMDocument ( ) ; $ dom -> preserveWhiteSpace = FALSE ; $ dom -> loadXML ( $ string ) ; $ dom -> formatOutput = TRUE ; return $ dom -> saveXml ( ) ; } 
private function resetCompressorAndSerializer ( ) { $ this -> RequestCompressor = CoreHelper :: GetCompressor ( $ this -> context , true ) ; $ this -> ResponseCompressor = CoreHelper :: GetCompressor ( $ this -> context , false ) ; $ this -> RequestSerializer = CoreHelper :: GetSerializer ( $ this -> context , true ) ; $ this -> ResponseSerializer = CoreHelper :: GetSerializer ( $ this -> context , false ) ; } 
private function getDestinationURL ( $ requestParameters , $ oMode , $ specifiedRequestUri ) { 
private function appendMinorVersionToRequestURI ( $ requestUri ) { $ setMinorVersion = $ this -> context -> minorVersion ; if ( isset ( $ setMinorVersion ) ) { if ( $ this -> queryToArray ( $ requestUri ) == false ) { 
private function checkHTTPMethod ( $ requestParameters ) { $ verb = $ requestParameters -> HttpVerbType ; if ( strcasecmp ( $ verb , CoreConstants :: HTTP_POST ) == 0 ) { return CoreConstants :: HTTP_POST ; } else if ( strcasecmp ( $ verb , CoreConstants :: HTTP_GET ) == 0 ) { return CoreConstants :: HTTP_GET ; } else { throw new SdkException ( "Internal Error. Unsupported HTTP Method:" . $ verb ) ; } } 
private function parseURL ( $ url ) { $ query_str = parse_url ( $ url , PHP_URL_QUERY ) ; parse_str ( $ query_str , $ parameters ) ; return $ parameters ; } 
private function getAcceptContentType ( $ value ) { if ( CoreConstants :: CONTENTTYPE_APPLICATIONXML === $ value ) { return $ value ; } if ( CoreConstants :: CONTENTTYPE_APPLICATIONJSON === $ value ) { return $ value ; } if ( CoreConstants :: CONTENTTYPE_APPLICATIONPDF === $ value ) { return $ value ; } if ( CoreConstants :: CONTENTTYPE_OCTETSTREAM === $ value ) { if ( $ this -> ResponseSerializer instanceof XmlObjectSerializer ) { return CoreConstants :: CONTENTTYPE_APPLICATIONXML ; } if ( $ this -> ResponseSerializer instanceof JsonObjectSerializer ) { return CoreConstants :: CONTENTTYPE_APPLICATIONJSON ; } } return "*/*" ; } 
private function queryToArray ( $ qry ) { $ result = array ( ) ; 
public function GetResponseSyncRest ( $ requestParameters , $ requestBody , $ oauthRequestUri ) { $ handler = new FaultHandler ( $ this -> context ) ; 
public function verifyPayLoad ( $ payLoad , $ sig , $ algo = null ) { $ encryptedPayload = $ this -> encryptPayLoadBasedOnToken ( $ payLoad , $ algo ) ; if ( strcmp ( $ sig , $ encryptedPayload ) == 0 ) { return true ; } else { return false ; } } 
private function encryptPayLoadBasedOnToken ( $ payLoad , $ hashAlgorithm = null ) { if ( $ hashAlgorithm == null ) { $ hashAlgorithm = TokenVerifier :: HASH_ALGORITHM ; } $ hashedPayLoad = hash_hmac ( $ hashAlgorithm , $ payLoad , $ this -> verifierToken ) ; $ encodedHashedPayLoad = base64_encode ( hex2bin ( $ hashedPayLoad ) ) ; return $ encodedHashedPayLoad ; } 
public static function update ( $ objToUpdate , array $ data ) { $ classOfObj = get_class ( $ objToUpdate ) ; if ( strcmp ( $ classOfObj , FacadeHelper :: simpleAppendClassNameSpace ( "Employee" ) ) != 0 ) { throw new \ Exception ( "Target object class:{" . $ classOfObj . "} is not an instance of Employee." ) ; } $ newEmployeeObj = Employee :: create ( $ data ) ; $ clonedOfObj = FacadeHelper :: cloneObj ( $ objToUpdate ) ; FacadeHelper :: mergeObj ( $ clonedOfObj , $ newEmployeeObj ) ; return $ clonedOfObj ; } 
public function IntuitBatchResponse ( $ id ) { if ( array_key_exists ( $ id , $ this -> intuitBatchItemResponses ) ) { return $ this -> intuitBatchItemResponses [ $ id ] ; } else { return null ; } } 
public function AddQuery ( $ query , $ id ) { if ( ! $ query ) { $ exception = new IdsException ( 'StringParameterNullOrEmpty: query' ) ; IdsExceptionManager :: HandleException ( $ exception ) ; } if ( ! $ id ) { $ exception = new IdsException ( 'StringParameterNullOrEmpty: id' ) ; IdsExceptionManager :: HandleException ( $ exception ) ; } if ( count ( $ this -> batchRequests ) > 25 ) { $ exception = new IdsException ( 'BatchItemsExceededException' ) ; IdsExceptionManager :: HandleException ( $ exception ) ; } $ batchItem = new IPPBatchItemRequest ( ) ; $ batchItem -> Query = $ query ; $ batchItem -> bId = $ id ; $ batchItem -> operationSpecified = true ; 
public function AddEntity ( $ entity , $ id , $ operation ) { if ( ! $ entity ) { $ exception = new IdsException ( 'StringParameterNullOrEmpty: entity' ) ; IdsExceptionManager :: HandleException ( $ exception ) ; } if ( ! $ id ) { $ exception = new IdsException ( 'StringParameterNullOrEmpty: id' ) ; IdsExceptionManager :: HandleException ( $ exception ) ; } if ( ! $ operation ) { $ exception = new IdsException ( 'StringParameterNullOrEmpty: operation' ) ; IdsExceptionManager :: HandleException ( $ exception ) ; } foreach ( $ this -> batchRequests as $ oneBatchRequest ) { if ( $ oneBatchRequest -> bId == $ id ) { $ exception = new IdsException ( 'BatchIdAlreadyUsed' ) ; IdsExceptionManager :: HandleException ( $ exception ) ; } } $ batchItem = new IPPBatchItemRequest ( ) ; $ batchItem -> IntuitObject = $ entity ; $ batchItem -> bId = $ id ; $ batchItem -> operation = $ operation ; $ batchItem -> operationSpecified = true ; $ this -> batchRequests [ ] = $ batchItem ; } 
public function Remove ( $ id ) { if ( ! $ id ) { $ exception = new IdsException ( 'BatchItemIdNotFound: id' ) ; IdsExceptionManager :: HandleException ( $ exception ) ; } $ revisedBatchRequests = array ( ) ; foreach ( $ this -> batchRequests as $ oneBatchRequest ) { if ( $ oneBatchRequest -> bId == $ id ) { 
public function ExecuteWithRequestID ( $ requestID ) { if ( isset ( $ requestID ) && ! empty ( $ requestID ) ) { $ this -> sendRequest ( $ requestID ) ; } else { throw new \ Exception ( "ExecuteWithRequestID called with Empty or Null request ID" ) ; } } 
private function arrayToMessageAndCode ( array $ array ) { if ( empty ( $ array ) ) { return array ( null , null ) ; } if ( 1 == count ( $ array ) ) { $ item = array_pop ( $ array ) ; return array ( $ item -> message , $ item -> code ) ; } $ message = "" ; $ code = "" ; foreach ( $ array as $ item ) { $ message .= "Exception: " . $ item -> message . "\n" ; if ( empty ( $ code ) && ! empty ( $ item -> code ) ) { $ code = $ item -> code ; } } return array ( $ message , $ code ) ; } 
public function IterateFaultAndPrepareException ( $ fault ) { if ( ! $ this -> verifyFault ( $ fault ) ) { return null ; } 
private function ProcessBatchItemResponse ( $ oneXmlObj ) { $ result = new IntuitBatchResponse ( ) ; if ( null == $ oneXmlObj ) { return $ result ; } if ( isset ( $ oneXmlObj [ "bId" ] ) ) { $ bid = ( String ) $ oneXmlObj [ "bId" ] ; $ result -> batchItemId = $ bid ; } else { throw new \ Exception ( "No bid Found on the Batch Response." ) ; } $ firstChild = null ; foreach ( $ oneXmlObj -> children ( ) as $ oneChild ) { $ firstChild = $ oneChild ; break ; } if ( ! $ firstChild ) { return $ result ; } $ firstChildName = ( string ) $ firstChild -> getName ( ) ; switch ( $ firstChildName ) { 
public function setOptions ( $ options ) { if ( $ options instanceof Zend_Config ) { $ options = $ options -> toArray ( ) ; } foreach ( $ options as $ key => $ value ) { switch ( $ key ) { case 'classmap' : case 'classMap' : $ this -> setClassmap ( $ value ) ; break ; case 'encoding' : $ this -> setEncoding ( $ value ) ; break ; case 'soapVersion' : case 'soap_version' : $ this -> setSoapVersion ( $ value ) ; break ; case 'wsdl' : $ this -> setWsdl ( $ value ) ; break ; case 'uri' : $ this -> setUri ( $ value ) ; break ; case 'location' : $ this -> setLocation ( $ value ) ; break ; case 'style' : $ this -> setStyle ( $ value ) ; break ; case 'use' : $ this -> setEncodingMethod ( $ value ) ; break ; case 'login' : $ this -> setHttpLogin ( $ value ) ; break ; case 'password' : $ this -> setHttpPassword ( $ value ) ; break ; case 'proxy_host' : $ this -> setProxyHost ( $ value ) ; break ; case 'proxy_port' : $ this -> setProxyPort ( $ value ) ; break ; case 'proxy_login' : $ this -> setProxyLogin ( $ value ) ; break ; case 'proxy_password' : $ this -> setProxyPassword ( $ value ) ; break ; case 'local_cert' : $ this -> setHttpsCertificate ( $ value ) ; break ; case 'passphrase' : $ this -> setHttpsCertPassphrase ( $ value ) ; break ; case 'compression' : $ this -> setCompressionOptions ( $ value ) ; break ; case 'stream_context' : $ this -> setStreamContext ( $ value ) ; break ; case 'features' : $ this -> setSoapFeatures ( $ value ) ; break ; case 'cache_wsdl' : $ this -> setWsdlCache ( $ value ) ; break ; case 'useragent' : case 'userAgent' : case 'user_agent' : $ this -> setUserAgent ( $ value ) ; break ; 
public function getOptions ( ) { $ options = array ( ) ; $ options [ 'classmap' ] = $ this -> getClassmap ( ) ; $ options [ 'encoding' ] = $ this -> getEncoding ( ) ; $ options [ 'soap_version' ] = $ this -> getSoapVersion ( ) ; $ options [ 'wsdl' ] = $ this -> getWsdl ( ) ; $ options [ 'uri' ] = $ this -> getUri ( ) ; $ options [ 'location' ] = $ this -> getLocation ( ) ; $ options [ 'style' ] = $ this -> getStyle ( ) ; $ options [ 'use' ] = $ this -> getEncodingMethod ( ) ; $ options [ 'login' ] = $ this -> getHttpLogin ( ) ; $ options [ 'password' ] = $ this -> getHttpPassword ( ) ; $ options [ 'proxy_host' ] = $ this -> getProxyHost ( ) ; $ options [ 'proxy_port' ] = $ this -> getProxyPort ( ) ; $ options [ 'proxy_login' ] = $ this -> getProxyLogin ( ) ; $ options [ 'proxy_password' ] = $ this -> getProxyPassword ( ) ; $ options [ 'local_cert' ] = $ this -> getHttpsCertificate ( ) ; $ options [ 'passphrase' ] = $ this -> getHttpsCertPassphrase ( ) ; $ options [ 'compression' ] = $ this -> getCompressionOptions ( ) ; * ugly hack as I don't know if checking for '=== null' * breaks some other option */ if ( $ key == 'user_agent' ) { if ( $ value === null ) { unset ( $ options [ $ key ] ) ; } } else { if ( $ value == null ) { unset ( $ options [ $ key ] ) ; } } } return $ options ; } 
public function setSoapVersion ( $ version ) { if ( ! in_array ( $ version , array ( SOAP_1_1 , SOAP_1_2 ) ) ) { require_once 'Zend/Soap/Client/Exception.php' ; throw new Zend_Soap_Client_Exception ( 'Invalid soap version specified. Use SOAP_1_1 or SOAP_1_2 constants.' ) ; } $ this -> _soapVersion = $ version ; $ this -> _soapClient = null ; return $ this ; } 
public function setClassmap ( array $ classmap ) { foreach ( $ classmap as $ type => $ class ) { if ( ! class_exists ( $ class ) ) { require_once 'Zend/Soap/Client/Exception.php' ; throw new Zend_Soap_Client_Exception ( 'Invalid class in class map' ) ; } } $ this -> _classmap = $ classmap ; $ this -> _soapClient = null ; return $ this ; } 
public function setEncoding ( $ encoding ) { if ( ! is_string ( $ encoding ) ) { require_once 'Zend/Soap/Client/Exception.php' ; throw new Zend_Soap_Client_Exception ( 'Invalid encoding specified' ) ; } $ this -> _encoding = $ encoding ; $ this -> _soapClient = null ; return $ this ; } 
public function setUri ( $ uri ) { $ this -> validateUrn ( $ uri ) ; $ this -> _uri = $ uri ; $ this -> _soapClient = null ; return $ this ; } 
public function setLocation ( $ location ) { $ this -> validateUrn ( $ location ) ; $ this -> _location = $ location ; $ this -> _soapClient = null ; return $ this ; } 
public function setStyle ( $ style ) { if ( ! in_array ( $ style , array ( SOAP_RPC , SOAP_DOCUMENT ) ) ) { require_once 'Zend/Soap/Client/Exception.php' ; throw new Zend_Soap_Client_Exception ( 'Invalid request style specified. Use SOAP_RPC or SOAP_DOCUMENT constants.' ) ; } $ this -> _style = $ style ; $ this -> _soapClient = null ; return $ this ; } 
public function setEncodingMethod ( $ use ) { if ( ! in_array ( $ use , array ( SOAP_ENCODED , SOAP_LITERAL ) ) ) { require_once 'Zend/Soap/Client/Exception.php' ; throw new Zend_Soap_Client_Exception ( 'Invalid message encoding method. Use SOAP_ENCODED or SOAP_LITERAL constants.' ) ; } $ this -> _use = $ use ; $ this -> _soapClient = null ; return $ this ; } 
public function setProxyPort ( $ proxyPort ) { $ this -> _proxy_port = ( int ) $ proxyPort ; $ this -> _soapClient = null ; return $ this ; } 
public function setHttpsCertificate ( $ localCert ) { if ( ! is_readable ( $ localCert ) ) { require_once 'Zend/Soap/Client/Exception.php' ; throw new Zend_Soap_Client_Exception ( 'Invalid HTTPS client certificate path.' ) ; } $ this -> _local_cert = $ localCert ; $ this -> _soapClient = null ; return $ this ; } 
public function setStreamContext ( $ context ) { if ( ! is_resource ( $ context ) || get_resource_type ( $ context ) !== "stream-context" ) { require_once "Zend/Soap/Client/Exception.php" ; throw new Zend_Soap_Client_Exception ( "Invalid stream context resource given." ) ; } $ this -> _stream_context = $ context ; return $ this ; } 
public function setUserAgent ( $ userAgent ) { if ( $ userAgent === null ) { $ this -> _user_agent = null ; } else { $ this -> _user_agent = ( string ) $ userAgent ; } return $ this ; } 
public function _doRequest ( Zend_Soap_Client_Common $ client , $ request , $ location , $ action , $ version , $ one_way = null ) { 
protected function _initSoapClientObject ( ) { $ wsdl = $ this -> getWsdl ( ) ; $ options = array_merge ( $ this -> getOptions ( ) , array ( 'trace' => true ) ) ; if ( $ wsdl == null ) { if ( ! isset ( $ options [ 'location' ] ) ) { require_once 'Zend/Soap/Client/Exception.php' ; throw new Zend_Soap_Client_Exception ( '\'location\' parameter is required in non-WSDL mode.' ) ; } if ( ! isset ( $ options [ 'uri' ] ) ) { require_once 'Zend/Soap/Client/Exception.php' ; throw new Zend_Soap_Client_Exception ( '\'uri\' parameter is required in non-WSDL mode.' ) ; } } else { if ( isset ( $ options [ 'use' ] ) ) { require_once 'Zend/Soap/Client/Exception.php' ; throw new Zend_Soap_Client_Exception ( '\'use\' parameter only works in non-WSDL mode.' ) ; } if ( isset ( $ options [ 'style' ] ) ) { require_once 'Zend/Soap/Client/Exception.php' ; throw new Zend_Soap_Client_Exception ( '\'style\' parameter only works in non-WSDL mode.' ) ; } } unset ( $ options [ 'wsdl' ] ) ; $ this -> _soapClient = new Zend_Soap_Client_Common ( array ( $ this , '_doRequest' ) , $ wsdl , $ options ) ; } 
public function addSoapInputHeader ( SoapHeader $ header , $ permanent = false ) { if ( $ permanent ) { $ this -> _permanentSoapInputHeaders [ ] = $ header ; } else { $ this -> _soapInputHeaders [ ] = $ header ; } return $ this ; } 
public function getFunctions ( ) { if ( $ this -> getWsdl ( ) == null ) { require_once 'Zend/Soap/Client/Exception.php' ; throw new Zend_Soap_Client_Exception ( '\'getFunctions\' method is available only in WSDL mode.' ) ; } $ soapClient = $ this -> getSoapClient ( ) ; return $ soapClient -> __getFunctions ( ) ; } 
public function getTypes ( ) { if ( $ this -> getWsdl ( ) == null ) { require_once 'Zend/Soap/Client/Exception.php' ; throw new Zend_Soap_Client_Exception ( '\'getTypes\' method is available only in WSDL mode.' ) ; } $ soapClient = $ this -> getSoapClient ( ) ; return $ soapClient -> __getTypes ( ) ; } 
public function addComplexType ( $ type ) { $ nestedCounter = $ this -> _getNestedCount ( $ type ) ; if ( $ nestedCounter > 0 ) { $ singularType = $ this -> _getSingularType ( $ type ) ; for ( $ i = 1 ; $ i <= $ nestedCounter ; $ i ++ ) { $ complexTypeName = substr ( $ this -> _getTypeNameBasedOnNestingLevel ( $ singularType , $ i ) , 4 ) ; $ childTypeName = $ this -> _getTypeNameBasedOnNestingLevel ( $ singularType , $ i - 1 ) ; $ this -> _addElementFromWsdlAndChildTypes ( $ complexTypeName , $ childTypeName ) ; } 
protected function _getTypeNameBasedOnNestingLevel ( $ singularType , $ level ) { if ( $ level == 0 ) { 
protected function _addElementFromWsdlAndChildTypes ( $ arrayType , $ childTypeName ) { if ( ! in_array ( $ arrayType , $ this -> getContext ( ) -> getTypes ( ) ) ) { $ dom = $ this -> getContext ( ) -> toDomDocument ( ) ; $ complexType = $ dom -> createElement ( 'xsd:complexType' ) ; $ complexType -> setAttribute ( 'name' , $ arrayType ) ; $ sequence = $ dom -> createElement ( 'xsd:sequence' ) ; $ element = $ dom -> createElement ( 'xsd:element' ) ; $ element -> setAttribute ( 'name' , 'item' ) ; $ element -> setAttribute ( 'type' , $ childTypeName ) ; $ element -> setAttribute ( 'minOccurs' , 0 ) ; $ element -> setAttribute ( 'maxOccurs' , 'unbounded' ) ; $ sequence -> appendChild ( $ element ) ; $ complexType -> appendChild ( $ sequence ) ; $ this -> getContext ( ) -> getSchema ( ) -> appendChild ( $ complexType ) ; $ this -> getContext ( ) -> addType ( $ arrayType ) ; } } 
public function prepare ( ) { $ this -> dom -> createAttributeNS ( $ this -> namespaces [ 'soap' ] , 'soap:definitions' ) ; $ this -> dom -> createAttributeNS ( $ this -> namespaces [ $ this -> xmlSchemaPreffix ] , $ this -> xmlSchemaPreffix . ':definitions' ) ; 
private function extractTypes ( ) { $ allEl = array ( ) ; $ allImp = array ( ) ; $ methods = array ( ) ; foreach ( $ this -> methodsMeta as $ methodName => $ data ) { $ elements = array ( ) ; $ input = false ; $ output = false ; if ( count ( $ data [ 'params' ] ) == 1 ) { $ type = $ this -> common -> phpTypeToSoap ( $ data [ 'params' ] [ 0 ] [ 'type' ] ) ; $ els = array ( ) ; if ( $ type === false ) { $ type = $ this -> getTypeName ( $ data [ 'params' ] [ 0 ] [ 'type' ] ) ; $ els [ ] = $ this -> createRefElement ( $ type ) ; } else { $ els [ ] = $ this -> createSimpleElement ( ucfirst ( $ data [ 'params' ] [ 0 ] [ 'name' ] ) , $ data [ 'params' ] [ 0 ] [ 'type' ] ) ; } $ elements [ ] = $ this -> createElementWithComplexType ( ucfirst ( $ methodName ) , $ els ) ; $ this -> addMessage ( ucfirst ( $ methodName ) , $ this -> targetNsPrefix . ":" . ucfirst ( $ methodName ) ) ; $ input = true ; } elseif ( $ data [ 'params' ] > 1 ) { $ els = array ( ) ; foreach ( $ data [ 'params' ] as $ input ) { $ type = $ this -> common -> phpTypeToSoap ( $ input [ 'type' ] ) ; if ( $ type === false ) { $ type = $ this -> getTypeName ( $ input [ 'type' ] ) ; $ els [ ] = $ this -> createRefElement ( $ type ) ; } else { $ els [ ] = $ this -> createSimpleElement ( ucfirst ( $ input [ 'name' ] ) , $ input [ 'type' ] ) ; } } $ elements [ ] = $ this -> createElementWithComplexType ( ucfirst ( $ methodName ) , $ els ) ; $ this -> addMessage ( ucfirst ( $ methodName ) , $ this -> targetNsPrefix . ":" . ucfirst ( $ methodName ) ) ; $ input = true ; } if ( array_key_exists ( 'return' , $ data ) ) { $ type = $ this -> common -> phpTypeToSoap ( $ data [ 'return' ] [ 'type' ] ) ; if ( $ type === false ) { 
private function addBindingOperations ( $ operation , $ input = false , $ output = false ) { $ el = $ this -> dom -> createElement ( 'wsdl:operation' ) ; $ el -> setAttribute ( 'name' , $ operation ) ; $ soapOperation = $ this -> dom -> createElement ( 'soap:operation' ) ; $ soapOperation -> setAttribute ( 'soapAction' , $ this -> wsdlTargetNamespace . "/" . $ operation ) ; $ el -> appendChild ( $ soapOperation ) ; if ( $ input === true ) { $ inp = $ this -> dom -> createElement ( 'wsdl:input' ) ; $ body = $ this -> dom -> createElement ( 'soap:body' ) ; $ body -> setAttribute ( 'use' , 'literal' ) ; $ inp -> appendChild ( $ body ) ; $ el -> appendChild ( $ inp ) ; } if ( $ output === true ) { $ out = $ this -> dom -> createElement ( 'wsdl:output' ) ; $ body = $ this -> dom -> createElement ( 'soap:body' ) ; $ body -> setAttribute ( 'use' , 'literal' ) ; $ out -> appendChild ( $ body ) ; $ el -> appendChild ( $ out ) ; } $ this -> wsBinding -> appendChild ( $ el ) ; } 
private function addPortOperations ( $ operation , $ input = false , $ output = false ) { $ el = $ this -> dom -> createElement ( "wsdl:operation" ) ; $ el -> setAttribute ( 'name' , $ operation ) ; if ( $ input === true ) { $ input = $ this -> dom -> createElement ( 'wsdl:input' ) ; $ input -> setAttribute ( 'message' , $ this -> targetNsPrefix . ":" . $ operation ) ; } if ( $ output === true ) { $ output = $ this -> dom -> createElement ( 'wsdl:output' ) ; $ output -> setAttribute ( 'message' , $ this -> targetNsPrefix . ":" . $ operation . "Response" ) ; } $ el -> appendChild ( $ input ) ; $ el -> appendChild ( $ output ) ; $ this -> wsPortType -> appendChild ( $ el ) ; } 
private function addMessage ( $ name , $ type ) { $ el = $ this -> dom -> createElement ( "wsdl:message" ) ; $ el -> setAttribute ( 'name' , $ name ) ; $ parts = $ this -> dom -> createElement ( "wsdl:part" ) ; $ parts -> setAttribute ( 'name' , $ name ) ; $ parts -> setAttribute ( 'element' , $ type ) ; $ el -> appendChild ( $ parts ) ; 
private function createRefElement ( $ ref ) { $ el = $ this -> dom -> createElement ( $ this -> xmlSchemaPreffix . ':element' ) ; $ el -> setAttribute ( 'ref' , $ ref ) ; return $ el ; } 
private function createElementWithComplexType ( $ name , $ elements ) { 
private function createSimpleElement ( $ name , $ type ) { $ el = $ this -> dom -> createElement ( $ this -> xmlSchemaPreffix . ':element' ) ; $ el -> setAttribute ( 'name' , $ name ) ; if ( preg_match ( '/:/' , $ type ) ) { $ el -> setAttribute ( 'type' , $ type ) ; } else { $ el -> setAttribute ( 'type' , $ this -> xmlSchemaPreffix . ':' . $ type ) ; } return $ el ; } 
public function resolveNamespace ( $ shortNs ) { if ( ! ( $ this -> dom instanceof \ DOMDocument ) ) { throw new RuntimeException ( "DOM is not initialized" ) ; } if ( ! is_array ( $ this -> namespaces ) ) { $ this -> namespaces = $ this -> getDocNamespaces ( $ this -> dom ) ; } if ( array_key_exists ( $ shortNs , $ this -> namespaces ) ) { return $ this -> namespaces [ $ shortNs ] ; } else { return $ shortNs ; } } 
public function parseDocComments ( $ comments ) { $ comments = explode ( "\n" , $ comments ) ; $ commentsOut = array ( ) ; $ params = array ( ) ; foreach ( $ comments as $ com ) { if ( preg_match ( '/@/' , $ com ) ) { $ com = preg_replace ( '/\* /' , '' , $ com ) ; $ com = preg_replace ( '/@([a-zA-Z]*)( *)(.*)/' , '$1|$3' , $ com ) ; $ com = explode ( '|' , $ com ) ; 
public static function isAssociateArray ( array $ arr ) { if ( ! empty ( $ arr ) ) { foreach ( $ arr as $ k => $ v ) { if ( is_int ( $ k ) ) { return false ; } } return true ; } return false ; } 
public static function getWebhooksEvent ( $ payLoad ) { JsonValidator :: validate ( $ payLoad ) ; $ string_arry = json_decode ( $ payLoad , true ) ; $ obj = ReflectionUtil :: constructObjectFromWebhooksArray ( $ string_arry , WebhooksService :: WEBHOOKSWRAPPERNAME ) ; return $ obj ; } 
public static function verifyPayload ( $ token , $ payload , $ intuitHeaderSignature ) { $ verifier = new TokenVerifier ( $ token ) ; return $ verifier -> verifyPayLoad ( $ payload , $ intuitHeaderSignature ) ; } 
public static function reflectArrayToObject ( $ classNameOrKeyName , $ data , $ throwException = TRUE ) { if ( ! isset ( $ classNameOrKeyName ) ) { throw new \ Exception ( "The Class Name or Key Name cannot be NULL when generating Objects." ) ; } if ( ! isset ( $ data ) || empty ( $ data ) ) { throw new \ Exception ( "The passed data cannot be NULL." ) ; } if ( is_object ( $ data ) ) { if ( ! FacadeHelper :: checkIfTheObjectIsAnInstanceOfTheClass ( $ classNameOrKeyName , $ data ) ) { throw new \ Exception ( "The assigned object is not an instance of required object:{" . $ classNameOrKeyName . "}." ) ; } else { return $ data ; } } 
private static function isKeyInComplexList ( $ key , $ complexList = NULL ) { if ( isset ( $ complexList ) ) { $ ObjectMap = $ complexList ; } else { $ ObjectMap = FacadeClassMapper :: classMethodToList ( ) ; } foreach ( $ ObjectMap as $ objectMethodName => $ entityType ) { if ( in_array ( $ key , $ entityType ) ) { return $ objectMethodName ; } } return false ; } 
private static function setKeyInComplexList ( $ objectMethodName , $ targetObject , $ key , $ val ) { $ reflectionClassOfTargetObject = new \ ReflectionClass ( $ targetObject ) ; $ setObject = FacadeHelper :: getComplexListObject ( $ objectMethodName , $ key , $ val ) ; $ property = $ reflectionClassOfTargetObject -> getProperty ( $ key ) ; if ( $ property instanceof \ ReflectionProperty ) { $ property -> setValue ( $ targetObject , $ setObject ) ; return true ; } else { throw new \ Exception ( "No Reflection Property Found." ) ; } } 
private static function getComplexListObject ( $ objectMethodName , $ key , $ val ) { 
public static function getClassMethod ( $ className , $ methodName ) { try { $ helperRefelctionMethod = new \ ReflectionMethod ( $ className , $ methodName ) ; return $ helperRefelctionMethod ; } catch ( \ Exception $ e ) { return null ; } } 
public static function getIPPReferenceTypeBasedOnArray ( $ data ) { $ trimedDataArray = FacadeHelper :: trimSpacesForArrayKeys ( $ data ) ; if ( is_object ( $ trimedDataArray ) ) { if ( $ trimedDataArray instanceof IPPReferenceType ) { return $ trimedDataArray ; } else { throw new \ Exception ( "The assigned obj to IPPReferenceType is not matched with IPPReferenceType." ) ; } } 
public static function getIPPId ( $ data ) { 
public static function mergeObj ( $ objA , $ objB ) { if ( get_class ( $ objA ) != get_class ( $ objB ) ) throw new \ Exception ( "Can't assign object value to a different type." ) ; $ property_fields = get_object_vars ( $ objA ) ; foreach ( $ property_fields as $ propertyName => $ val ) { $ BsValue = $ objB -> $ propertyName ; if ( isset ( $ BsValue ) ) { $ objA -> $ propertyName = $ BsValue ; } } return $ objA ; } 
public static function trimSpacesForArrayKeys ( $ data ) { if ( ! isset ( $ data ) || empty ( $ data ) ) return $ data ; if ( is_array ( $ data ) ) { if ( FacadeHelper :: isArrayOfObj ( $ data ) ) { return $ data ; } else { $ trimedKeys = array_map ( 'trim' , array_keys ( $ data ) ) ; $ trimedResult = array_combine ( $ trimedKeys , $ data ) ; return $ trimedResult ; } } else { if ( is_object ( $ data ) ) { return $ data ; } else { return trim ( $ data ) ; } } } 
private function handleErrors ( ) { if ( $ this -> basecURL -> errno ( ) || $ this -> basecURL -> error ( ) ) { $ errorMsg = $ this -> basecURL -> error ( ) ; $ errorNumber = $ this -> basecURL -> errno ( ) ; throw new SdkException ( "cURL error during making API call. cURL Error Number:[" . $ errorNumber . "] with error:[" . $ errorMsg . "]" ) ; } } 
private function getHeaders ( $ headers ) { if ( ! isset ( $ headers ) || empty ( $ headers ) ) { throw new SdkException ( "Error. The headers set for cURL are either NULL or Empty" ) ; } else { $ convertedHeaders = $ this -> convertHeaderArrayToHeaders ( $ headers ) ; return $ convertedHeaders ; } } 
private function setSSL ( & $ curl_opt , $ verifySSL ) { $ tlsVersion = $ this -> basecURL -> versionOfTLS ( ) ; $ versions = [ 'TLS 1.2' , 'TLS 1.3' ] ; if ( ! in_array ( $ tlsVersion , $ versions ) ) { throw new SdkException ( "Error. Checking TLS 1.2/1.3 version failed. Please make sure your PHP cURL supports TSL 1.2/1.3" ) ; } if ( $ verifySSL ) { $ curl_opt [ CURLOPT_SSL_VERIFYPEER ] = true ; $ curl_opt [ CURLOPT_SSL_VERIFYHOST ] = 2 ; 
public function convertHeaderArrayToHeaders ( array $ headerArray ) { $ headers = array ( ) ; foreach ( $ headerArray as $ k => $ v ) { $ headers [ ] = $ k . ":" . $ v ; } return $ headers ; } 
public function process ( ) : void { $ this -> parse ( ) ; $ this -> fixer -> startFile ( $ this ) ; foreach ( $ this -> tokens as $ stackPtr => $ token ) { if ( isset ( $ this -> tokenListeners [ $ token [ 'code' ] ] ) === false ) { continue ; } foreach ( $ this -> tokenListeners [ $ token [ 'code' ] ] as $ sniff ) { if ( $ this -> skipper -> shouldSkipCheckerAndFile ( $ sniff , $ this -> fileInfo ) ) { continue ; } $ this -> reportActiveSniffClass ( $ sniff ) ; $ sniff -> process ( $ this , $ stackPtr ) ; } } $ this -> fixedCount += $ this -> fixer -> getFixCount ( ) ; } 
public function addFixableError ( $ error , $ stackPtr , $ code , $ data = [ ] , $ severity = 0 ) : bool { $ this -> appliedCheckersCollector -> addFileInfoAndChecker ( $ this -> fileInfo , $ this -> resolveFullyQualifiedCode ( $ code ) ) ; return ! $ this -> shouldSkipError ( $ error , $ code , $ data ) ; } 
public function addError ( $ error , $ stackPtr , $ code , $ data = [ ] , $ severity = 0 , $ fixable = false ) : bool { if ( $ this -> shouldSkipError ( $ error , $ code , $ data ) ) { return false ; } return parent :: addError ( $ error , $ stackPtr , $ code , $ data , $ severity , $ fixable ) ; } 
public function addWarning ( $ warning , $ stackPtr , $ code , $ data = [ ] , $ severity = 0 , $ fixable = false ) : bool { if ( ! $ this -> isSniffClassWarningAllowed ( $ this -> activeSniffClass ) ) { return false ; } return $ this -> addError ( $ warning , $ stackPtr , $ code , $ data , $ severity , $ fixable ) ; } 
protected function addMessage ( $ isError , $ message , $ line , $ column , $ sniffClassOrCode , $ data , $ severity , $ isFixable = false ) : bool { if ( ! $ isError ) { 
protected function build ( ContainerBuilder $ containerBuilder ) : void { 
private function fileMatchesPattern ( SmartFileInfo $ smartFileInfo , string $ ignoredPath ) : bool { $ ignoredPath = $ this -> normalizeForFnmatch ( $ ignoredPath ) ; return $ smartFileInfo -> endsWith ( $ ignoredPath ) || $ smartFileInfo -> fnmatches ( $ ignoredPath ) ; } 
public function resolveFromInput ( InputInterface $ input ) : void { $ sources = $ input -> getArgument ( Option :: SOURCE ) ; $ this -> setSources ( $ sources ) ; $ this -> isFixer = ( bool ) $ input -> getOption ( Option :: FIX ) ; $ this -> shouldClearCache = ( bool ) $ input -> getOption ( Option :: CLEAR_CACHE ) ; $ this -> showProgressBar = $ this -> canShowProgressBar ( $ input ) ; $ this -> showErrorTable = ! ( bool ) $ input -> getOption ( Option :: NO_ERROR_TABLE ) ; } 
public function changeConfigurationFile ( string $ configurationFile ) : void { $ this -> storeConfigurationDataHash ( $ this -> fileHashComputer -> compute ( $ configurationFile ) ) ; } 
public function createContainerBuilderAndConfig ( ContainerBuilder $ containerBuilder , string $ config ) : DelegatingLoader { $ fileLocator = new SimpleFileLocator ( dirname ( $ config ) ) ; return $ this -> createFromContainerBuilderAndFileLocator ( $ containerBuilder , $ fileLocator ) ; } 
public function up ( ) { $ connection = config ( 'taggable.connection' ) ; if ( ! Schema :: connection ( $ connection ) -> hasTable ( 'taggable_tags' ) ) { Schema :: connection ( $ connection ) -> create ( 'taggable_tags' , function ( Blueprint $ table ) { $ table -> increments ( 'tag_id' ) ; $ table -> string ( 'name' ) ; $ table -> string ( 'normalized' ) ; $ table -> timestamps ( ) ; $ table -> index ( 'normalized' ) ; } ) ; } if ( ! Schema :: connection ( $ connection ) -> hasTable ( 'taggable_taggables' ) ) { Schema :: connection ( $ connection ) -> create ( 'taggable_taggables' , function ( Blueprint $ table ) { $ table -> unsignedInteger ( 'tag_id' ) ; $ table -> unsignedInteger ( 'taggable_id' ) ; $ table -> string ( 'taggable_type' ) ; $ table -> timestamps ( ) ; $ table -> index ( [ 'tag_id' , 'taggable_id' ] , 'i_taggable_fwd' ) ; $ table -> index ( [ 'taggable_id' , 'tag_id' ] , 'i_taggable_rev' ) ; $ table -> index ( 'taggable_type' , 'i_taggable_type' ) ; } ) ; } } 
public function down ( ) { $ connection = config ( 'taggable.connection' ) ; if ( Schema :: connection ( $ connection ) -> hasTable ( 'taggable_tags' ) ) { Schema :: connection ( $ connection ) -> drop ( 'taggable_tags' ) ; } if ( Schema :: connection ( $ connection ) -> hasTable ( 'taggable_taggables' ) ) { Schema :: connection ( $ connection ) -> drop ( 'taggable_taggables' ) ; } } 
public function setNameAttribute ( $ value ) { $ value = trim ( $ value ) ; $ this -> attributes [ 'name' ] = $ value ; $ this -> attributes [ 'normalized' ] = app ( TagService :: class ) -> normalize ( $ value ) ; } 
public function scopeByName ( Builder $ query , string $ value ) : Builder { $ normalized = app ( TagService :: class ) -> normalize ( $ value ) ; return $ query -> where ( 'normalized' , $ normalized ) ; } 
protected static function bootTaggable ( ) : void { static :: deleting ( function ( $ model ) { if ( ! method_exists ( $ model , 'runSoftDelete' ) || $ model -> isForceDeleting ( ) ) { $ model -> detag ( ) ; } } ) ; } 
public function tag ( $ tags ) : self { $ tags = app ( TagService :: class ) -> buildTagArray ( $ tags ) ; foreach ( $ tags as $ tagName ) { $ this -> addOneTag ( $ tagName ) ; $ this -> load ( 'tags' ) ; } event ( new ModelTagged ( $ this , $ tags ) ) ; return $ this ; } 
public function untag ( $ tags ) : self { $ tags = app ( TagService :: class ) -> buildTagArray ( $ tags ) ; foreach ( $ tags as $ tagName ) { $ this -> removeOneTag ( $ tagName ) ; } event ( new ModelUntagged ( $ this , $ tags ) ) ; return $ this -> load ( 'tags' ) ; } 
protected function addOneTag ( string $ tagName ) : void { $ tag = app ( TagService :: class ) -> findOrCreate ( $ tagName ) ; $ tagKey = $ tag -> getKey ( ) ; if ( ! $ this -> getAttribute ( 'tags' ) -> contains ( $ tagKey ) ) { $ this -> tags ( ) -> attach ( $ tagKey ) ; } } 
protected function removeOneTag ( string $ tagName ) : void { $ tag = app ( TagService :: class ) -> find ( $ tagName ) ; if ( $ tag ) { $ this -> tags ( ) -> detach ( $ tag ) ; } } 
public function hasTag ( $ tag ) : bool { if ( $ tag instanceof Tag ) { $ normalized = $ tag -> getAttribute ( 'normalized' ) ; } else { $ normalized = app ( TagService :: class ) -> normalize ( $ tag ) ; } return in_array ( $ normalized , $ this -> getTagArrayNormalizedAttribute ( ) , true ) ; } 
public function scopeWithAllTags ( Builder $ query , $ tags ) : Builder { $ service = app ( TagService :: class ) ; $ normalized = $ service -> buildTagArrayNormalized ( $ tags ) ; 
public function scopeIsTagged ( Builder $ query ) : Builder { $ alias = $ this -> taggableCreateNewAlias ( __FUNCTION__ ) ; return $ this -> prepareTableJoin ( $ query , 'inner' , $ alias ) ; } 
public function scopeWithoutAllTags ( Builder $ query , $ tags , bool $ includeUntagged = false ) : Builder { $ service = app ( TagService :: class ) ; $ normalized = $ service -> buildTagArrayNormalized ( $ tags ) ; $ tagKeys = $ service -> getTagModelKeys ( $ normalized ) ; $ tagKeyList = implode ( ',' , $ tagKeys ) ; $ alias = $ this -> taggableCreateNewAlias ( __FUNCTION__ ) ; $ morphTagKeyName = $ this -> getQualifiedRelatedPivotKeyNameWithAlias ( $ alias ) ; $ query = $ this -> prepareTableJoin ( $ query , 'left' , $ alias ) -> havingRaw ( "COUNT(DISTINCT CASE WHEN ({$morphTagKeyName} IN ({$tagKeyList})) THEN {$morphTagKeyName} ELSE NULL END) < ?" , [ count ( $ tagKeys ) ] ) ; if ( ! $ includeUntagged ) { $ query -> havingRaw ( "COUNT(DISTINCT {$morphTagKeyName}) > 0" ) ; } return $ query ; } 
public function scopeIsNotTagged ( Builder $ query ) : Builder { $ alias = $ this -> taggableCreateNewAlias ( __FUNCTION__ ) ; $ morphForeignKeyName = $ this -> getQualifiedForeignPivotKeyNameWithAlias ( $ alias ) ; return $ this -> prepareTableJoin ( $ query , 'left' , $ alias ) -> havingRaw ( "COUNT(DISTINCT {$morphForeignKeyName}) = 0" ) ; } 
private function prepareTableJoin ( Builder $ query , string $ joinType , string $ alias ) : Builder { $ morphTable = $ this -> tags ( ) -> getTable ( ) ; $ morphTableAlias = $ morphTable . '_' . $ alias ; $ modelKeyName = $ this -> getQualifiedKeyName ( ) ; $ morphForeignKeyName = $ this -> getQualifiedForeignPivotKeyNameWithAlias ( $ alias ) ; $ morphTypeName = $ morphTableAlias . '.' . $ this -> tags ( ) -> getMorphType ( ) ; $ morphClass = $ this -> tags ( ) -> getMorphClass ( ) ; $ closure = function ( JoinClause $ join ) use ( $ modelKeyName , $ morphForeignKeyName , $ morphTypeName , $ morphClass ) { $ join -> on ( $ modelKeyName , $ morphForeignKeyName ) -> where ( $ morphTypeName , $ morphClass ) ; } ; return $ query -> select ( $ this -> getTable ( ) . '.*' ) -> join ( $ morphTable . ' as ' . $ morphTableAlias , $ closure , null , null , $ joinType ) -> groupBy ( $ modelKeyName ) ; } 
public static function renameTag ( string $ oldTag , string $ newTag ) : int { return app ( TagService :: class ) -> renameTags ( $ oldTag , $ newTag , static :: class ) ; } 
public static function popularTags ( int $ limit = null , int $ minCount = 1 ) : array { $ tags = app ( TagService :: class ) -> getPopularTags ( $ limit , static :: class , $ minCount ) ; return $ tags -> pluck ( 'taggable_count' , 'name' ) -> all ( ) ; } 
private function getQualifiedRelatedPivotKeyNameWithAlias ( string $ alias ) : string { $ morph = $ this -> tags ( ) ; return $ morph -> getTable ( ) . '_' . $ alias . '.' . $ morph -> getRelatedPivotKeyName ( ) ; } 
private function getQualifiedForeignPivotKeyNameWithAlias ( string $ alias ) : string { $ morph = $ this -> tags ( ) ; return $ morph -> getTable ( ) . '_' . $ alias . '.' . $ morph -> getForeignPivotKeyName ( ) ; } 
private function taggableCreateNewAlias ( string $ scope ) : string { $ this -> taggableAliasSequence ++ ; $ alias = strtolower ( $ scope ) . '_' . $ this -> taggableAliasSequence ; return $ alias ; } 
public function findOrCreate ( string $ tagName ) : Tag { $ tag = $ this -> find ( $ tagName ) ; if ( ! $ tag ) { $ tag = $ this -> tagModel :: create ( [ 'name' => $ tagName ] ) ; } return $ tag ; } 
public function buildTagArray ( $ tags ) : array { if ( is_array ( $ tags ) ) { $ array = $ tags ; } elseif ( $ tags instanceof BaseCollection ) { $ array = $ this -> buildTagArray ( $ tags -> all ( ) ) ; } elseif ( is_string ( $ tags ) ) { $ array = preg_split ( '#[' . preg_quote ( config ( 'taggable.delimiters' ) , '#' ) . ']#' , $ tags , null , PREG_SPLIT_NO_EMPTY ) ; } else { throw new \ ErrorException ( __CLASS__ . '::' . __METHOD__ . ' expects parameter 1 to be string, array or Collection; ' . gettype ( $ tags ) . ' given' ) ; } return array_filter ( array_map ( 'trim' , $ array ) ) ; } 
public function getTagModelKeys ( array $ normalized = [ ] ) : array { if ( count ( $ normalized ) === 0 ) { return [ ] ; } return $ this -> tagModel :: whereIn ( 'normalized' , $ normalized ) -> pluck ( 'tag_id' ) -> toArray ( ) ; } 
public function makeTagList ( Model $ model , string $ field = 'name' ) : string { $ tags = $ this -> makeTagArray ( $ model , $ field ) ; return $ this -> joinList ( $ tags ) ; } 
public function makeTagArray ( Model $ model , string $ field = 'name' ) : array { $ tags = $ model -> tags ; return $ tags -> pluck ( $ field ) -> all ( ) ; } 
public function getAllTags ( $ class = null ) : Collection { if ( $ class === null ) { return $ this -> tagModel :: all ( ) ; } if ( $ class instanceof Model ) { $ class = get_class ( $ class ) ; } $ tagTable = $ this -> getQualifiedTagTableName ( ) ; $ pivotTable = $ this -> getQualifiedPivotTableName ( $ class ) ; $ sql = "SELECT DISTINCT t.* FROM {$pivotTable} tt LEFT JOIN {$tagTable} t ON tt.tag_id=t.tag_id WHERE tt.taggable_type = ?" ; return $ this -> tagModel :: fromQuery ( $ sql , [ $ class ] ) ; } 
public function getAllUnusedTags ( ) : Collection { $ tagTable = $ this -> getQualifiedTagTableName ( ) ; $ pivotTable = $ this -> getQualifiedPivotTableName ( ) ; $ sql = "SELECT t.* FROM {$tagTable} t LEFT JOIN {$pivotTable} tt ON tt.tag_id=t.tag_id WHERE tt.taggable_id IS NULL" ; return $ this -> tagModel :: fromQuery ( $ sql ) ; } 
public function getPopularTags ( int $ limit = null , $ class = null , int $ minCount = 1 ) : Collection { $ tagTable = $ this -> getQualifiedTagTableName ( ) ; $ pivotTable = $ this -> getQualifiedPivotTableName ( ) ; $ sql = "SELECT t.*, COUNT(t.tag_id) AS taggable_count FROM {$tagTable} t LEFT JOIN {$pivotTable} tt ON tt.tag_id=t.tag_id" ; $ bindings = [ ] ; if ( $ class ) { $ sql .= ' WHERE tt.taggable_type = ?' ; $ bindings [ ] = ( $ class instanceof Model ) ? get_class ( $ class ) : $ class ; } 
public function renameTags ( string $ oldName , string $ newName , $ class = null ) : int { 
private function getQualifiedTagTableName ( ) : string { $ tag = new $ this -> tagModel ; return $ tag -> getConnection ( ) -> getTablePrefix ( ) . $ tag -> getTable ( ) ; } 
private function getQualifiedPivotTableName ( string $ class = null ) : string { $ instance = $ class ? new $ class : new class extends Model { use Taggable ; } ; return $ instance -> tags ( ) -> getConnection ( ) -> getTablePrefix ( ) . $ instance -> tags ( ) -> getTable ( ) ; } 
protected function saveCompoundParameterData ( array $ compoundData ) { foreach ( $ compoundData as $ name => $ value ) { $ matchExists = false ; foreach ( $ this -> parameterNameMapper as $ regex => $ parameterName ) { if ( preg_match ( $ regex , $ name , $ matches ) === 1 ) { $ parameterLastIndex = '' ; if ( isset ( $ matches [ 1 ] ) ) { $ parameterLastIndex = $ matches [ 1 ] ; } $ matchExists = true ; $ this -> parameters [ $ parameterName . $ parameterLastIndex ] = $ value ; break ; } } if ( ! $ matchExists ) { throw new \ InvalidArgumentException ( "Unknown parameter $name for " . get_class ( $ this ) . ' data' ) ; } } } 
public function build ( $ url , array $ singleParameters , array $ compoundParameters ) { $ singlesPost = $ this -> getSingleParametersPayload ( $ singleParameters ) ; $ compoundsPost = $ this -> getCompoundParametersPayload ( $ compoundParameters ) ; $ this -> payloadParameters = array_merge ( $ singlesPost , $ compoundsPost ) ; if ( ! empty ( $ this -> cacheBuster ) ) { $ this -> payloadParameters [ 'z' ] = $ this -> cacheBuster ; } $ query = http_build_query ( $ this -> payloadParameters , null , ini_get ( 'arg_separator.output' ) , PHP_QUERY_RFC3986 ) ; return $ url . '?' . $ query ; } 
private function getSingleParametersPayload ( array $ singleParameters ) { $ postData = [ ] ; $ cacheBuster = new CacheBuster ( ) ; foreach ( $ singleParameters as $ parameterObj ) { if ( $ parameterObj -> getName ( ) === $ cacheBuster -> getName ( ) ) { $ this -> cacheBuster = $ parameterObj -> getValue ( ) ; continue ; } $ postData [ $ parameterObj -> getName ( ) ] = $ parameterObj -> getValue ( ) ; } return $ postData ; } 
private function getCompoundParametersPayload ( array $ compoundParameters ) { $ postData = [ ] ; foreach ( $ compoundParameters as $ compoundCollection ) { $ parameterArray = $ compoundCollection -> getParametersArray ( ) ; $ postData = array_merge ( $ postData , $ parameterArray ) ; } return $ postData ; } 
protected function addIndex ( $ string , $ index ) { if ( empty ( $ string ) ) { throw new InvalidNameException ( 'Name attribute not defined for class ' . get_class ( $ this ) ) ; } if ( strpos ( $ string , $ this -> indexPlaceholder ) !== false ) { if ( ! is_numeric ( $ index ) || $ index < $ this -> minIndex ( ) || $ index > $ this -> maxIndex ( ) ) { throw new InvalidIndexException ( 'When setting parameter ' . get_class ( $ this ) . ' a numeric index between 1 - 200 must be passed for the second argument' ) ; } } return str_replace ( $ this -> indexPlaceholder , $ index , $ string ) ; } 
public function getDebugResponse ( ) { $ debugResponse = [ ] ; if ( ! empty ( $ this -> responseBody ) ) { $ debugResponse = json_decode ( $ this -> responseBody , true ) ; $ debugResponse = ( is_array ( $ debugResponse ) ) ? $ debugResponse : [ ] ; } return $ debugResponse ; } 
protected function getEndpoint ( ) { return ( $ this -> isDebug ) ? $ this -> uriScheme . $ this -> debugEndpoint : $ this -> uriScheme . $ this -> endpoint ; } 
protected function sendHit ( $ methodName ) { $ hitType = strtoupper ( substr ( $ methodName , 4 ) ) ; $ hitConstant = $ this -> getParameterClassConstant ( 'TheIconic\Tracking\GoogleAnalytics\Parameters\Hit\HitType::HIT_TYPE_' . $ hitType , 'Hit type ' . $ hitType . ' is not defined, check spelling' ) ; $ this -> setHitType ( $ hitConstant ) ; if ( ! $ this -> hasMinimumRequiredParameters ( ) ) { throw new InvalidPayloadDataException ( ) ; } if ( $ this -> isDisabled ) { return new NullAnalyticsResponse ( ) ; } return $ this -> getHttpClient ( ) -> post ( $ this -> getUrl ( ) , $ this -> getHttpClientOptions ( ) ) ; } 
protected function getHttpClientOptions ( ) { $ options = [ 'async' => $ this -> isAsyncRequest ] ; if ( isset ( $ this -> options [ 'timeout' ] ) ) { $ options [ 'timeout' ] = $ this -> options [ 'timeout' ] ; } return $ options ; } 
public function getUrl ( ) { $ prepareUrl = new PrepareUrl ; return $ prepareUrl -> build ( $ this -> getEndpoint ( ) , $ this -> singleParameters , $ this -> compoundParametersCollections ) ; } 
protected function hasMinimumRequiredParameters ( ) { $ minimumRequiredParameters = [ 'v' => false , 'tid' => false , 'cid' => false , 'uid' => false , 't' => false , ] ; foreach ( $ minimumRequiredParameters as $ parameterName => $ isParamPresent ) { if ( array_key_exists ( $ parameterName , $ this -> singleParameters ) ) { $ minimumRequiredParameters [ $ parameterName ] = true ; } } if ( ! $ minimumRequiredParameters [ 'cid' ] && $ minimumRequiredParameters [ 'uid' ] ) { $ minimumRequiredParameters [ 'cid' ] = true ; } if ( ! $ minimumRequiredParameters [ 'uid' ] && $ minimumRequiredParameters [ 'cid' ] ) { $ minimumRequiredParameters [ 'uid' ] = true ; } return ! in_array ( false , $ minimumRequiredParameters , true ) ; } 
protected function setParameterActionTo ( $ parameter , $ action ) { $ actionConstant = $ this -> getParameterClassConstant ( 'TheIconic\Tracking\GoogleAnalytics\Parameters\EnhancedEcommerce\\' . $ parameter . 'Action::ACTION_' . strtoupper ( $ action ) , $ parameter . ' action ' . $ action . ' does not exist, check spelling' ) ; $ function = 'set' . $ parameter . 'Action' ; $ this -> $ function ( $ actionConstant ) ; return $ this ; } 
protected function setParameter ( $ methodName , array $ methodArguments ) { $ parameterClass = substr ( $ methodName , 3 ) ; $ fullParameterClass = $ this -> getFullParameterClass ( $ parameterClass , $ methodName ) ; $ parameterIndex = $ this -> getIndexFromArguments ( $ methodArguments ) ; $ parameterObject = new $ fullParameterClass ( $ parameterIndex ) ; if ( ! isset ( $ methodArguments [ 0 ] ) ) { throw new \ InvalidArgumentException ( 'For Analytics object, you must specify a value to be set for ' . $ methodName ) ; } else { $ parameterObject -> setValue ( $ methodArguments [ 0 ] ) ; } $ this -> singleParameters [ $ parameterObject -> getName ( ) ] = $ parameterObject ; return $ this ; } 
protected function addItem ( $ methodName , array $ methodArguments ) { $ parameterClass = substr ( $ methodName , 3 ) ; $ fullParameterClass = $ this -> getFullParameterClass ( $ parameterClass , $ methodName ) ; if ( ! isset ( $ methodArguments [ 0 ] ) ) { throw new \ InvalidArgumentException ( 'You must specify a ' . $ parameterClass . ' to be add for ' . $ methodName ) ; } else { $ parameterObject = new $ fullParameterClass ( $ methodArguments [ 0 ] ) ; } $ collectionIndex = $ this -> getIndexFromArguments ( $ methodArguments ) ; if ( isset ( $ this -> compoundParametersCollections [ $ parameterClass . $ collectionIndex ] ) ) { $ this -> compoundParametersCollections [ $ parameterClass . $ collectionIndex ] -> add ( $ parameterObject ) ; } else { $ fullParameterCollectionClass = $ fullParameterClass . 'Collection' ; $ parameterObjectCollection = new $ fullParameterCollectionClass ( $ collectionIndex ) ; $ parameterObjectCollection -> add ( $ parameterObject ) ; $ this -> compoundParametersCollections [ $ parameterClass . $ collectionIndex ] = $ parameterObjectCollection ; } return $ this ; } 
protected function getParameter ( $ methodName , array $ methodArguments ) { $ parameterClass = substr ( $ methodName , 3 ) ; $ fullParameterClass = $ this -> getFullParameterClass ( $ parameterClass , $ methodName ) ; 
protected function getIndexFromArguments ( $ methodArguments ) { $ index = '' ; if ( isset ( $ methodArguments [ 1 ] ) && is_numeric ( $ methodArguments [ 1 ] ) ) { $ index = $ methodArguments [ 1 ] ; } return $ index ; } 
protected function getFullParameterClass ( $ parameterClass , $ methodName ) { if ( empty ( $ this -> availableParameters [ $ parameterClass ] ) ) { throw new \ BadMethodCallException ( 'Method ' . $ methodName . ' not defined for Analytics class' ) ; } else { return '\\TheIconic\\Tracking\\GoogleAnalytics\\Parameters\\' . $ this -> availableParameters [ $ parameterClass ] ; } } 
public function post ( $ url , array $ options = [ ] ) { $ request = new Request ( 'GET' , $ url , [ 'User-Agent' => self :: PHP_GA_MEASUREMENT_PROTOCOL_USER_AGENT ] ) ; $ opts = $ this -> parseOptions ( $ options ) ; $ response = $ this -> getClient ( ) -> sendAsync ( $ request , [ 'synchronous' => ! $ opts [ 'async' ] , 'timeout' => $ opts [ 'timeout' ] , 'connect_timeout' => $ opts [ 'timeout' ] , ] ) ; if ( $ opts [ 'async' ] ) { self :: $ promises [ ] = $ response ; } else { $ response = $ response -> wait ( ) ; } return $ this -> getAnalyticsResponse ( $ request , $ response ) ; } 
private function parseOptions ( array $ options ) { $ defaultOptions = [ 'timeout' => static :: REQUEST_TIMEOUT_SECONDS , 'async' => false , ] ; $ opts = [ ] ; foreach ( $ defaultOptions as $ option => $ value ) { $ opts [ $ option ] = isset ( $ options [ $ option ] ) ? $ options [ $ option ] : $ defaultOptions [ $ option ] ; } if ( ! is_int ( $ opts [ 'timeout' ] ) || $ opts [ 'timeout' ] <= 0 ) { throw new \ UnexpectedValueException ( 'The timeout must be an integer with a value greater than 0' ) ; } if ( ! is_bool ( $ opts [ 'async' ] ) ) { throw new \ UnexpectedValueException ( 'The async option must be boolean' ) ; } return $ opts ; } 
public function getReadableItems ( ) { $ readablesItems = [ ] ; foreach ( $ this -> items as $ key => $ item ) { array_push ( $ readablesItems , $ item -> getReadableParameters ( ) ) ; } return $ readablesItems ; } 
public function register ( ) { $ configPath = __DIR__ . '/../config/report-generator.php' ; $ this -> mergeConfigFrom ( $ configPath , 'report-generator' ) ; $ this -> app -> bind ( 'pdf.report.generator' , function ( $ app ) { return new PdfReport ( $ app ) ; } ) ; $ this -> app -> bind ( 'excel.report.generator' , function ( $ app ) { return new ExcelReport ( $ app ) ; } ) ; $ this -> app -> bind ( 'csv.report.generator' , function ( $ app ) { return new CSVReport ( $ app ) ; } ) ; $ this -> app -> register ( 'Maatwebsite\Excel\ExcelServiceProvider' ) ; $ this -> registerAliases ( ) ; } 
public function addSupportedBrand ( $ name , $ expression ) { $ known_brands = array_keys ( $ this -> supported_cards ) ; if ( in_array ( $ name , $ known_brands ) ) { return false ; } $ this -> supported_cards [ $ name ] = $ expression ; return true ; } 
protected function setYearParameter ( $ key , $ value ) { 
public function validate ( ) { $ requiredParameters = array ( 'number' => 'credit card number' , 'expiryMonth' => 'expiration month' , 'expiryYear' => 'expiration year' ) ; foreach ( $ requiredParameters as $ key => $ val ) { if ( ! $ this -> getParameter ( $ key ) ) { throw new InvalidCreditCardException ( "The $val is required" ) ; } } if ( $ this -> getExpiryDate ( 'Ym' ) < gmdate ( 'Ym' ) ) { throw new InvalidCreditCardException ( 'Card has expired' ) ; } if ( ! Helper :: validateLuhn ( $ this -> getNumber ( ) ) ) { throw new InvalidCreditCardException ( 'Card number is invalid' ) ; } if ( ! is_null ( $ this -> getNumber ( ) ) && ! preg_match ( '/^\d{12,19}$/i' , $ this -> getNumber ( ) ) ) { throw new InvalidCreditCardException ( 'Card number should have 12 to 19 digits' ) ; } } 
public function getNumberMasked ( $ mask = 'X' ) { $ maskLength = strlen ( $ this -> getNumber ( ) ) - 4 ; return str_repeat ( $ mask , $ maskLength ) . $ this -> getNumberLastFour ( ) ; } 
public function getBrand ( ) { foreach ( $ this -> getSupportedBrands ( ) as $ brand => $ val ) { if ( preg_match ( $ val , $ this -> getNumber ( ) ) ) { return $ brand ; } } } 
protected function getTrackByPattern ( $ pattern ) { if ( $ tracks = $ this -> getTracks ( ) ) { if ( preg_match ( $ pattern , $ tracks , $ matches ) === 1 ) { return $ matches [ 0 ] ; } } } 
protected function listFirstLastName ( $ fullName ) { $ names = explode ( ' ' , $ fullName , 2 ) ; return [ $ names [ 0 ] , isset ( $ names [ 1 ] ) ? $ names [ 1 ] : null ] ; } 
public function setBillingName ( $ value ) { $ names = $ this -> listFirstLastName ( $ value ) ; $ this -> setBillingFirstName ( $ names [ 0 ] ) ; $ this -> setBillingLastName ( $ names [ 1 ] ) ; return $ this ; } 
public function setShippingName ( $ value ) { $ names = $ this -> listFirstLastName ( $ value ) ; $ this -> setShippingFirstName ( $ names [ 0 ] ) ; $ this -> setShippingLastName ( $ names [ 1 ] ) ; return $ this ; } 
public function getBirthday ( $ format = 'Y-m-d' ) { $ value = $ this -> getParameter ( 'birthday' ) ; return $ value ? $ value -> format ( $ format ) : null ; } 
public function setBirthday ( $ value ) { if ( $ value ) { $ value = new DateTime ( $ value , new DateTimeZone ( 'UTC' ) ) ; } else { $ value = null ; } return $ this -> setParameter ( 'birthday' , $ value ) ; } 
public function initialize ( array $ parameters = array ( ) ) { if ( null !== $ this -> response ) { throw new RuntimeException ( 'Request cannot be modified after it has been sent!' ) ; } $ this -> parameters = new ParameterBag ; Helper :: initialize ( $ this , $ parameters ) ; return $ this ; } 
protected function setParameter ( $ key , $ value ) { if ( null !== $ this -> response ) { throw new RuntimeException ( 'Request cannot be modified after it has been sent!' ) ; } return $ this -> traitSetParameter ( $ key , $ value ) ; } 
public function setCard ( $ value ) { if ( $ value && ! $ value instanceof CreditCard ) { $ value = new CreditCard ( $ value ) ; } return $ this -> setParameter ( 'card' , $ value ) ; } 
public function getAmount ( ) { $ money = $ this -> getMoney ( ) ; if ( $ money !== null ) { $ moneyFormatter = new DecimalMoneyFormatter ( $ this -> getCurrencies ( ) ) ; return $ moneyFormatter -> format ( $ money ) ; } } 
public function setMoney ( Money $ value ) { $ currency = $ value -> getCurrency ( ) -> getCode ( ) ; $ this -> setCurrency ( $ currency ) ; return $ this -> setParameter ( 'amount' , $ value ) ; } 
public function setCurrency ( $ value ) { if ( $ value !== null ) { $ value = strtoupper ( $ value ) ; } return $ this -> setParameter ( 'currency' , $ value ) ; } 
public function getCurrencyNumeric ( ) { if ( ! $ this -> getCurrency ( ) ) { return null ; } $ currency = new Currency ( $ this -> getCurrency ( ) ) ; if ( $ this -> getCurrencies ( ) -> contains ( $ currency ) ) { return ( string ) $ this -> getCurrencies ( ) -> numericCodeFor ( $ currency ) ; } } 
public function getCurrencyDecimalPlaces ( ) { if ( $ this -> getCurrency ( ) ) { $ currency = new Currency ( $ this -> getCurrency ( ) ) ; if ( $ this -> getCurrencies ( ) -> contains ( $ currency ) ) { return $ this -> getCurrencies ( ) -> subunitFor ( $ currency ) ; } } return 2 ; } 
public function formatCurrency ( $ amount ) { $ money = $ this -> getMoney ( ( string ) $ amount ) ; $ formatter = new DecimalMoneyFormatter ( $ this -> getCurrencies ( ) ) ; return $ formatter -> format ( $ money ) ; } 
public function replace ( array $ items = array ( ) ) { $ this -> items = array ( ) ; foreach ( $ items as $ item ) { $ this -> add ( $ item ) ; } } 
public function add ( $ item ) { if ( $ item instanceof ItemInterface ) { $ this -> items [ ] = $ item ; } else { $ this -> items [ ] = new Item ( $ item ) ; } } 
protected function validateRedirect ( ) { if ( ! $ this instanceof RedirectResponseInterface || ! $ this -> isRedirect ( ) ) { throw new RuntimeException ( 'This response does not support redirection.' ) ; } if ( empty ( $ this -> getRedirectUrl ( ) ) ) { throw new RuntimeException ( 'The given redirectUrl cannot be empty.' ) ; } if ( ! in_array ( $ this -> getRedirectMethod ( ) , [ 'GET' , 'POST' ] ) ) { throw new RuntimeException ( 'Invalid redirect method "' . $ this -> getRedirectMethod ( ) . '".' ) ; } } 
public static function camelCase ( $ str ) { $ str = self :: convertToLowercase ( $ str ) ; return preg_replace_callback ( '/_([a-z])/' , function ( $ match ) { return strtoupper ( $ match [ 1 ] ) ; } , $ str ) ; } 
public static function validateLuhn ( $ number ) { $ str = '' ; foreach ( array_reverse ( str_split ( $ number ) ) as $ i => $ c ) { $ str .= $ i % 2 ? $ c * 2 : $ c ; } return array_sum ( str_split ( $ str ) ) % 10 === 0 ; } 
public static function getGatewayShortName ( $ className ) { if ( 0 === strpos ( $ className , '\\' ) ) { $ className = substr ( $ className , 1 ) ; } if ( 0 === strpos ( $ className , 'Omnipay\\' ) ) { return trim ( str_replace ( '\\' , '_' , substr ( $ className , 8 , - 7 ) ) , '_' ) ; } return '\\' . $ className ; } 
public static function getGatewayClassName ( $ shortName ) { if ( 0 === strpos ( $ shortName , '\\' ) ) { return $ shortName ; } 
public function getData ( ) { $ this -> validate ( 'app_id' , 'mch_id' , 'out_trade_no' , 'cert_path' , 'key_path' ) ; $ data = [ 'appid' => $ this -> getAppId ( ) , 'mch_id' => $ this -> getMchId ( ) , 'sub_appid' => $ this -> getSubAppId ( ) , 'sub_mch_id' => $ this -> getSubMchId ( ) , 'device_info' => $ this -> getDeviceInfo ( ) , 
public function getData ( ) { $ this -> validate ( 'app_id' , 'mch_id' , 'partner_trade_no' , 'cert_path' , 'key_path' ) ; $ data = array ( 'mch_appid' => $ this -> getAppId ( ) , 'mchid' => $ this -> getMchId ( ) , 'device_info' => $ this -> getDeviceInfo ( ) , 
public function sendData ( $ data ) { $ body = Helper :: array2xml ( $ data ) ; $ client = new Client ( ) ; $ options = [ 'body' => $ body , 'verify' => true , 'cert' => $ this -> getCertPath ( ) , 'ssl_key' => $ this -> getKeyPath ( ) , ] ; $ response = $ client -> request ( 'POST' , $ this -> endpoint , $ options ) -> getBody ( ) ; $ responseData = Helper :: xml2array ( $ response ) ; return $ this -> response = new PromotionTransferResponse ( $ this , $ responseData ) ; } 
public function getData ( ) { $ this -> validate ( 'app_id' , 'mch_id' ) ; $ queryIdEmpty = ! $ this -> getTransactionId ( ) && ! $ this -> getOutTradeNo ( ) ; $ queryIdEmpty = ( $ queryIdEmpty && ! $ this -> getOutRefundNo ( ) && ! $ this -> getRefundId ( ) ) ; if ( $ queryIdEmpty ) { $ message = "The 'transaction_id' or 'out_trade_no' or 'out_refund_no' or 'refund_id' parameter is required" ; throw new InvalidRequestException ( $ message ) ; } $ data = array ( 'appid' => $ this -> getAppId ( ) , 'mch_id' => $ this -> getMchId ( ) , 'sub_appid' => $ this -> getSubAppId ( ) , 'sub_mch_id' => $ this -> getSubMchId ( ) , 'device_info' => $ this -> getDeviceInfo ( ) , 'transaction_id' => $ this -> getTransactionId ( ) , 'out_trade_no' => $ this -> getOutTradeNo ( ) , 'out_refund_no' => $ this -> getOutRefundNo ( ) , 'refund_id' => $ this -> getRefundId ( ) , 'nonce_str' => md5 ( uniqid ( ) ) , ) ; $ data = array_filter ( $ data ) ; $ data [ 'sign' ] = Helper :: sign ( $ data , $ this -> getApiKey ( ) ) ; return $ data ; } 
public function getData ( ) { $ this -> validate ( 'app_id' , 'mch_id' , 'body' , 'out_trade_no' , 'total_fee' , 'auth_code' ) ; $ data = array ( 'appid' => $ this -> getAppId ( ) , 
public function getData ( ) { $ this -> validate ( 'app_id' , 'mch_id' , 'body' , 'out_trade_no' , 'total_fee' , 'notify_url' , 'trade_type' , 'spbill_create_ip' ) ; $ tradeType = strtoupper ( $ this -> getTradeType ( ) ) ; if ( $ tradeType == 'JSAPI' ) { $ this -> validate ( 'open_id' ) ; } $ data = array ( 'appid' => $ this -> getAppId ( ) , 
public function getData ( ) { $ this -> validate ( 'app_id' , 'mch_id' , 'bill_date' ) ; $ data = array ( 'appid' => $ this -> getAppId ( ) , 'mch_id' => $ this -> getMchId ( ) , 'sub_appid' => $ this -> getSubAppId ( ) , 'sub_mch_id' => $ this -> getSubMchId ( ) , 'device_info' => $ this -> getDeviceInfo ( ) , 'bill_date' => $ this -> getBillDate ( ) , 'bill_type' => $ this -> getBillType ( ) , 
public function sendData ( $ data ) { $ responseData = $ this -> post ( $ this -> endpoint , $ data , 120 ) ; return $ this -> response = new DownloadBillResponse ( $ this , $ responseData ) ; } 
public function getData ( ) { $ data = $ this -> getRequestParams ( ) ; if ( is_string ( $ data ) ) { $ data = Helper :: xml2array ( $ data ) ; } return $ data ; } 
public function sendData ( $ data ) { $ options = array ( CURLOPT_SSL_VERIFYPEER => true , CURLOPT_SSL_VERIFYHOST => 2 , CURLOPT_SSLCERTTYPE => 'PEM' , CURLOPT_SSLKEYTYPE => 'PEM' , CURLOPT_SSLCERT => $ this -> getCertPath ( ) , CURLOPT_SSLKEY => $ this -> getKeyPath ( ) , ) ; $ body = Helper :: array2xml ( $ data ) ; $ request = $ this -> httpClient -> request ( 'POST' , $ this -> endpoint , $ options , $ body ) ; $ response = $ request -> getBody ( ) ; $ responseData = Helper :: xml2array ( $ response ) ; return $ this -> response = new QueryTransferResponse ( $ this , $ responseData ) ; } 
public function getData ( ) { $ this -> validate ( 'app_id' , 'mch_id' , 'auth_code' ) ; $ data = array ( 'appid' => $ this -> getAppId ( ) , 'mch_id' => $ this -> getMchId ( ) , 'sub_mch_id' => $ this -> getSubMchId ( ) , 'auth_code' => $ this -> getAuthCode ( ) , 'nonce_str' => md5 ( uniqid ( ) ) , ) ; $ data = array_filter ( $ data ) ; $ data [ 'sign' ] = Helper :: sign ( $ data , $ this -> getApiKey ( ) ) ; return $ data ; } 
public function sendData ( $ data ) { $ request = $ this -> httpClient -> request ( 'POST' , $ this -> endpoint , [ ] , Helper :: array2xml ( $ data ) ) ; $ response = $ request -> getBody ( ) ; $ responseData = Helper :: xml2array ( $ response ) ; return $ this -> response = new CloseOrderResponse ( $ this , $ responseData ) ; } 
protected function getFixedQueryBuilder ( QueryBuilder $ queryBuilder ) { $ queryBuilderId = clone $ queryBuilder ; $ rootAlias = current ( $ queryBuilderId -> getRootAliases ( ) ) ; SELECT DISTINCT x FROM tab ORDER BY y; For any particular x-value in the table there might be many different y values. Which one will you use to sort that x-value in the output? */ $ queryId = $ queryBuilderId -> getQuery ( ) ; $ queryId -> setHint ( Query :: HINT_CUSTOM_TREE_WALKERS , [ OrderByToSelectWalker :: class ] ) ; $ results = $ queryId -> execute ( [ ] , Query :: HYDRATE_ARRAY ) ; $ platform = $ queryBuilderId -> getEntityManager ( ) -> getConnection ( ) -> getDatabasePlatform ( ) ; $ idxMatrix = [ ] ; foreach ( $ results as $ id ) { foreach ( $ idNames as $ idName ) { 
private function getModelName ( ContainerBuilder $ container , $ name ) { if ( '%' === $ name [ 0 ] ) { return $ container -> getParameter ( substr ( $ name , 1 , - 1 ) ) ; } return $ name ; } 
public function getParentMetadataForProperty ( $ baseClass , $ propertyFullName ) { $ nameElements = explode ( '.' , $ propertyFullName ) ; $ lastPropertyName = array_pop ( $ nameElements ) ; $ class = $ baseClass ; $ parentAssociationMappings = [ ] ; foreach ( $ nameElements as $ nameElement ) { $ metadata = $ this -> getMetadata ( $ class ) ; if ( isset ( $ metadata -> associationMappings [ $ nameElement ] ) ) { $ parentAssociationMappings [ ] = $ metadata -> associationMappings [ $ nameElement ] ; $ class = $ metadata -> getAssociationTargetClass ( $ nameElement ) ; continue ; } break ; } $ properties = \ array_slice ( $ nameElements , \ count ( $ parentAssociationMappings ) ) ; $ properties [ ] = $ lastPropertyName ; return [ $ this -> getMetadata ( $ class ) , implode ( '.' , $ properties ) , $ parentAssociationMappings ] ; } 
public function getEntityManager ( $ class ) { if ( \ is_object ( $ class ) ) { $ class = \ get_class ( $ class ) ; } if ( ! isset ( $ this -> cache [ $ class ] ) ) { $ em = $ this -> registry -> getManagerForClass ( $ class ) ; if ( ! $ em ) { throw new \ RuntimeException ( sprintf ( 'No entity manager defined for class %s' , $ class ) ) ; } $ this -> cache [ $ class ] = $ em ; } return $ this -> cache [ $ class ] ; } 
private function createSelectExpressionItem ( PathExpression $ pathExpression ) { if ( PathExpression :: TYPE_SINGLE_VALUED_ASSOCIATION === $ pathExpression -> type ) { $ identity = new IdentityFunction ( 'identity' ) ; $ identity -> pathExpression = clone $ pathExpression ; return $ identity ; } return clone $ pathExpression ; } 
private function getOperator ( $ type ) { $ choices = [ NumberType :: TYPE_EQUAL => '=' , NumberType :: TYPE_GREATER_EQUAL => '>=' , NumberType :: TYPE_GREATER_THAN => '>' , NumberType :: TYPE_LESS_EQUAL => '<=' , NumberType :: TYPE_LESS_THAN => '<' , ] ; return $ choices [ $ type ] ?? false ; } 
protected function getPager ( $ pagerType ) { switch ( $ pagerType ) { case Pager :: TYPE_DEFAULT : return new Pager ( ) ; case Pager :: TYPE_SIMPLE : return new SimplePager ( ) ; default : throw new \ RuntimeException ( sprintf ( 'Unknown pager type "%s".' , $ pagerType ) ) ; } } 
public function getConfigTreeBuilder ( ) { $ treeBuilder = new TreeBuilder ( 'sonata_doctrine_orm_admin' ) ; 
protected function handleMultiple ( ProxyQueryInterface $ queryBuilder , $ alias , $ data ) { if ( 0 === \ count ( $ data [ 'value' ] ) ) { return ; } $ parameterName = $ this -> getNewParameterName ( $ queryBuilder ) ; if ( isset ( $ data [ 'type' ] ) && EqualType :: TYPE_IS_NOT_EQUAL === $ data [ 'type' ] ) { $ this -> applyWhere ( $ queryBuilder , $ queryBuilder -> expr ( ) -> notIn ( $ alias , ':' . $ parameterName ) ) ; } else { $ this -> applyWhere ( $ queryBuilder , $ queryBuilder -> expr ( ) -> in ( $ alias , ':' . $ parameterName ) ) ; } $ queryBuilder -> setParameter ( $ parameterName , $ data [ 'value' ] ) ; } 
protected function handleModel ( ProxyQueryInterface $ queryBuilder , $ alias , $ data ) { if ( empty ( $ data [ 'value' ] ) ) { return ; } $ parameterName = $ this -> getNewParameterName ( $ queryBuilder ) ; if ( isset ( $ data [ 'type' ] ) && EqualType :: TYPE_IS_NOT_EQUAL === $ data [ 'type' ] ) { $ this -> applyWhere ( $ queryBuilder , sprintf ( '%s != :%s' , $ alias , $ parameterName ) ) ; } else { $ this -> applyWhere ( $ queryBuilder , sprintf ( '%s = :%s' , $ alias , $ parameterName ) ) ; } $ queryBuilder -> setParameter ( $ parameterName , $ data [ 'value' ] ) ; } 
protected function getParentMetadataForProperty ( $ baseClass , $ propertyFullName , ModelManagerInterface $ modelManager ) { try { return $ modelManager -> getParentMetadataForProperty ( $ baseClass , $ propertyFullName ) ; } catch ( MappingException $ e ) { 
protected function handleMultiple ( ProxyQueryInterface $ queryBuilder , $ alias , $ data ) { if ( 0 === \ count ( $ data [ 'value' ] ) ) { return ; } $ parameterName = $ this -> getNewParameterName ( $ queryBuilder ) ; if ( isset ( $ data [ 'type' ] ) && EqualType :: TYPE_IS_NOT_EQUAL === $ data [ 'type' ] ) { $ or = $ queryBuilder -> expr ( ) -> orX ( ) ; $ or -> add ( $ queryBuilder -> expr ( ) -> notIn ( $ alias , ':' . $ parameterName ) ) ; if ( ClassMetadata :: MANY_TO_MANY === $ this -> getOption ( 'mapping_type' ) ) { $ or -> add ( sprintf ( '%s.%s IS EMPTY' , $ this -> getParentAlias ( $ queryBuilder , $ alias ) , $ this -> getFieldName ( ) ) ) ; } else { $ or -> add ( $ queryBuilder -> expr ( ) -> isNull ( sprintf ( 'IDENTITY(%s.%s)' , $ this -> getParentAlias ( $ queryBuilder , $ alias ) , $ this -> getFieldName ( ) ) ) ) ; } $ this -> applyWhere ( $ queryBuilder , $ or ) ; } else { $ this -> applyWhere ( $ queryBuilder , $ queryBuilder -> expr ( ) -> in ( $ alias , ':' . $ parameterName ) ) ; } $ queryBuilder -> setParameter ( $ parameterName , $ data [ 'value' ] ) ; } 
private function getParentAlias ( ProxyQueryInterface $ queryBuilder , $ alias ) { $ parentAlias = $ rootAlias = current ( $ queryBuilder -> getRootAliases ( ) ) ; $ joins = $ queryBuilder -> getDQLPart ( 'join' ) ; if ( isset ( $ joins [ $ rootAlias ] ) ) { foreach ( $ joins [ $ rootAlias ] as $ join ) { if ( $ join -> getAlias ( ) === $ alias ) { $ parts = explode ( '.' , $ join -> getJoin ( ) ) ; $ parentAlias = $ parts [ 0 ] ; break ; } } } return $ parentAlias ; } 
private function getOperator ( $ type ) { $ choices = [ EqualType :: TYPE_IS_EQUAL => 'INSTANCE OF' , EqualType :: TYPE_IS_NOT_EQUAL => 'NOT INSTANCE OF' , ] ; return $ choices [ $ type ] ?? false ; } 
private function getOperator ( $ type ) { $ choices = [ ChoiceType :: TYPE_CONTAINS => 'LIKE' , ChoiceType :: TYPE_NOT_CONTAINS => 'NOT LIKE' , ChoiceType :: TYPE_EQUAL => '=' , ] ; return $ choices [ $ type ] ?? false ; } 
protected function _findByName ( $ Context , $ realmID , $ resource , $ name , $ xml = '' ) { $ IPP = $ Context -> IPP ( ) ; if ( $ IPP -> flavor ( ) == QuickBooks_IPP_IDS :: FLAVOR_DESKTOP ) { if ( ! $ xml ) { $ xml = '' ; $ xml .= '<?xml version="1.0" encoding="UTF-8"?>' . QUICKBOOKS_CRLF ; $ xml .= '<' . $ resource . 'Query xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://www.intuit.com/sb/cdm/' . $ IPP -> version ( ) . '">' . QUICKBOOKS_CRLF ; $ xml .= ' <FirstLastInside>' . QuickBooks_XML :: encode ( $ name ) . '</FirstLastInside>' . QUICKBOOKS_CRLF ; $ xml .= '</' . $ resource . 'Query>' ; } } else { $ xml = http_build_query ( array ( 'Filter' => 'Name :EQUALS: ' . $ name ) ) ; } $ return = $ IPP -> IDS ( $ Context , $ realmID , $ resource , QuickBooks_IPP_IDS :: OPTYPE_QUERY , $ xml ) ; $ this -> _setLastRequestResponse ( $ Context -> lastRequest ( ) , $ Context -> lastResponse ( ) ) ; $ this -> _setLastDebug ( $ Context -> lastDebug ( ) ) ; if ( count ( $ return ) ) { return $ return [ 0 ] ; } return null ; } 
protected function _add ( $ Context , $ realmID , $ resource , $ Object ) { $ IPP = $ Context -> IPP ( ) ; switch ( $ IPP -> version ( ) ) { case QuickBooks_IPP_IDS :: VERSION_2 : return $ this -> _add_v2 ( $ Context , $ realmID , $ resource , $ Object ) ; case QuickBooks_IPP_IDS :: VERSION_3 : return $ this -> _add_v3 ( $ Context , $ realmID , $ resource , $ Object ) ; } } 
protected function _update ( $ Context , $ realmID , $ resource , $ Object , $ ID ) { $ IPP = $ Context -> IPP ( ) ; switch ( $ IPP -> version ( ) ) { case QuickBooks_IPP_IDS :: VERSION_2 : return $ this -> _update_v2 ( $ Context , $ realmID , $ resource , $ Object , $ ID ) ; case QuickBooks_IPP_IDS :: VERSION_3 : return $ this -> _update_v3 ( $ Context , $ realmID , $ resource , $ Object , $ ID ) ; } return false ; } 
protected function _findById ( $ Context , $ realmID , $ resource , $ IDType , $ xml_or_IDType = '' , $ query = null ) { $ IPP = $ Context -> IPP ( ) ; $ flavor = $ IPP -> flavor ( ) ; if ( ! $ xml_or_IDType ) { if ( $ flavor == QuickBooks_IPP_IDS :: FLAVOR_DESKTOP ) { $ parse = QuickBooks_IPP_IDS :: parseIDType ( $ IDType ) ; $ xml_or_IDType = '' ; $ xml_or_IDType .= '<?xml version="1.0" encoding="UTF-8"?>' . QUICKBOOKS_CRLF ; $ xml_or_IDType .= '<' . $ resource . 'Query xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://www.intuit.com/sb/cdm/' . $ IPP -> version ( ) . '">' . QUICKBOOKS_CRLF ; if ( $ resource == QuickBooks_IPP_IDS :: RESOURCE_CUSTOMER ) { $ xml_or_IDType .= '<CustomFieldEnable>true</CustomFieldEnable>' ; } if ( $ query ) { $ xml_or_IDType .= $ query ; } $ xml_or_IDType .= ' <' . QuickBooks_IPP_IDS :: resourceToKeyType ( $ resource ) . 'Set>' . QUICKBOOKS_CRLF ; $ xml_or_IDType .= ' <Id idDomain="' . $ parse [ 'domain' ] . '">' . $ parse [ 'ID' ] . '</Id>' . QUICKBOOKS_CRLF ; $ xml_or_IDType .= ' </' . QuickBooks_IPP_IDS :: resourceToKeyType ( $ resource ) . 'Set>' . QUICKBOOKS_CRLF ; $ xml_or_IDType .= '</' . $ resource . 'Query>' ; } else if ( $ flavor == QuickBooks_IPP_IDS :: FLAVOR_ONLINE ) { $ xml_or_IDType = $ IDType ; } } $ return = $ IPP -> IDS ( $ Context , $ realmID , $ resource , QuickBooks_IPP_IDS :: OPTYPE_FINDBYID , $ xml_or_IDType ) ; $ this -> _setLastRequestResponse ( $ Context -> lastRequest ( ) , $ Context -> lastResponse ( ) ) ; $ this -> _setLastDebug ( $ Context -> lastDebug ( ) ) ; if ( count ( $ return ) ) { return $ return [ 0 ] ; } return null ; } 
protected function _setError ( $ errcode , $ errtext = '' , $ errdetail = '' ) { $ this -> _errcode = $ errcode ; $ this -> _errtext = $ errtext ; $ this -> _errdetail = $ errdetail ; } 
public function authenticate ( $ user , $ pass ) { $ req = new QuickBooks_Request_Authenticate ( $ user , $ pass ) ; $ resp = parent :: __soapCall ( 'authenticate' , array ( $ req ) ) ; $ tmp = current ( $ resp ) ; return current ( $ tmp ) ; } 
public function isSalesAndPurchase ( $ enable = null ) { $ current = $ this -> _is_sales_and_purchase ; if ( ! is_null ( $ enable ) ) { $ this -> _is_sales_and_purchase = ( boolean ) $ enable ; } return $ current ; } 
public function isSalesOrPurchase ( $ enable = null ) { $ current = ! $ this -> _is_sales_and_purchase ; if ( ! is_null ( $ enable ) ) { $ this -> _is_sales_and_purchase = ! ( boolean ) $ enable ; } return $ current ; } 
public function setParentApplicationID ( $ id ) { return $ this -> set ( 'ParentRef ' . QUICKBOOKS_API_APPLICATIONID , $ this -> encodeApplicationID ( QUICKBOOKS_OBJECT_CUSTOMER , QUICKBOOKS_LISTID , $ id ) ) ; } 
public function setCreditCardInfo ( $ cardno , $ expmonth , $ expyear , $ name , $ address , $ postalcode ) { 
public function getCreditCardInfo ( $ part = null , $ defaults = array ( ) ) { if ( ! is_null ( $ part ) ) { return $ this -> get ( 'CreditCardInfo ' . $ part ) ; } return $ this -> getArray ( 'CreditCardInfo *' , $ defaults ) ; } 
public function add ( $ Context , $ realmID , $ Object ) { return parent :: _add ( $ Context , $ realmID , QuickBooks_IPP_IDS :: RESOURCE_SALESRECEIPT , $ Object ) ; } 
public function findById ( $ Context , $ realmID , $ IDType ) { $ xml = null ; return parent :: _findById ( $ Context , $ realmID , QuickBooks_IPP_IDS :: RESOURCE_CLASS , $ IDType , $ xml ) ; } 
public function add ( $ Context , $ realmID , $ Object ) { return parent :: _add ( $ Context , $ realmID , QuickBooks_IPP_IDS :: RESOURCE_CLASS , $ Object ) ; } 
public function setItemGroupApplicationID ( $ value ) { return $ this -> set ( 'ItemGroupRef ' . QUICKBOOKS_API_APPLICATIONID , $ this -> encodeApplicationID ( QUICKBOOKS_OBJECT_ITEMGROUP , QUICKBOOKS_LISTID , $ value ) ) ; } 
static protected function _guid ( $ surround = true ) { $ guid = sprintf ( '%04x%04x-%04x-%03x4-%04x-%04x%04x%04x' , mt_rand ( 0 , 65535 ) , mt_rand ( 0 , 65535 ) , mt_rand ( 0 , 65535 ) , mt_rand ( 0 , 4095 ) , bindec ( substr_replace ( sprintf ( '%016b' , mt_rand ( 0 , 65535 ) ) , '01' , 6 , 2 ) ) , mt_rand ( 0 , 65535 ) , mt_rand ( 0 , 65535 ) , mt_rand ( 0 , 65535 ) ) ; if ( $ surround ) { $ guid = '{' . $ guid . '}' ; } return $ guid ; } 
public function findById ( $ Context , $ realmID , $ ID ) { $ xml = null ; return parent :: _findById ( $ Context , $ realmID , QuickBooks_IPP_IDS :: RESOURCE_EMPLOYEE , $ ID , null , $ xml ) ; } 
static public function create ( $ dsn_or_conn , $ config = array ( ) , $ hooks = array ( ) , $ log_level = QUICKBOOKS_LOG_NORMAL ) { static $ instances = array ( ) ; if ( ! is_array ( $ hooks ) ) { $ hooks = array ( ) ; } static $static = 0; $static++; print('Constructed new instance ' . $static . ' [' . $key . ']' . "\n"); mysql_query("INSERT INTO quickbooks_log ( msg, log_datetime ) VALUES ( 'Here is my " . $static . " key: " . $key . "', NOW() )"); */ 
public function signature ( $ method , $ keyfile = null ) { $ this -> _signature = $ method ; $ this -> _keyfile = $ keyfile ; } 
public function sign ( $ method , $ url , $ oauth_token = null , $ oauth_token_secret = null , $ params = array ( ) ) { if ( ! is_array ( $ params ) ) { $ params = array ( ) ; } $ params = array_merge ( $ params , array ( 'oauth_consumer_key' => $ this -> _oauth_consumer_key , 'oauth_signature_method' => $ this -> _signature , 'oauth_nonce' => $ this -> _nonce ( ) , 'oauth_timestamp' => $ this -> _timestamp ( ) , 'oauth_version' => $ this -> _version , ) ) ; print('<pre>'); print('BASE STRING IS [' . $signature_and_basestring[0] . ']' . "\n\n"); print('SIGNATURE IS: [' . $params['oauth_signature'] . ']'); print('</pre>'); */ $ normalized = $ this -> _normalize ( $ params ) ; if ( false !== ( $ pos = strpos ( $ url , '?' ) ) ) { $ url = substr ( $ url , 0 , $ pos ) ; } $ normalized_url = $ url . '?' . $ normalized ; 
protected function _generateSignature_RSA ( $ sbs , $ method , $ url , $ params = array ( ) ) { print('key id is: ['); print_r($res); print(']'); print("\n\n\n"); */ $ signature = null ; $ retr = openssl_sign ( $ sbs , $ signature , $ res ) ; openssl_free_key ( $ res ) ; return array ( 0 => $ sbs , 1 => base64_encode ( $ signature ) , ) ; } 
protected function _generateSignature_HMAC ( $ sbs , $ method , $ url , $ params = array ( ) ) { $ secret = $ this -> _escape ( $ this -> _oauth_consumer_secret ) ; $ secret .= '&' ; if ( ! empty ( $ params [ 'oauth_secret' ] ) ) { $ secret .= $ this -> _escape ( $ params [ 'oauth_secret' ] ) ; } 
public function setPayeeEntityApplicationID ( $ value ) { return $ this -> set ( 'PayeeEntityRef ' . QUICKBOOKS_API_APPLICATIONID , $ this -> encodeApplicationID ( QUICKBOOKS_OBJECT_PAYEEENTITY , QUICKBOOKS_LISTID , $ value ) ) ; } 
public function handleError500 ( $ requestID , $ user , $ action , $ ID , $ extra , & $ err , $ xml , $ errnum , $ errmsg ) { mail ( 'your-email@your-domain.com' , 'QuickBooks error occured!' , 'The following error occured: ' . $ errnum . ': ' . $ errmsg ) ; 
public function hookLoginSuccess ( $ requestID , $ user , $ hook , & $ err , $ hook_data , $ callback_config ) { if ( $ this -> _dsn ) { QuickBooks_Utilities :: log ( $ this -> _dsn , 'This user logged in and the user login hook was called: ' . $ user . ', params: ' . print_r ( $ hook_data , true ) ) ; return true ; } return false ; } 
public function isRepeatable ( $ path ) { $ paths = $ this -> _isRepeatablePaths ( ) ; if ( isset ( $ paths [ $ path ] ) ) { return $ paths [ $ path ] ; } return false ; } 
public function exists ( $ path , $ case_doesnt_matter = true , $ is_end_element = false ) { $ ordered_paths = $ this -> _reorderPathsPaths ( ) ; if ( in_array ( $ path , $ ordered_paths ) ) { return true ; } else if ( $ case_doesnt_matter ) { foreach ( $ ordered_paths as $ ordered_path ) { if ( strtolower ( $ path ) == strtolower ( $ ordered_path ) ) { return true ; } } } return false ; } 
public function reorderPaths ( $ unordered_paths , $ allow_application_id = true , $ allow_application_editsequence = true ) { $ ordered_paths = $ this -> _reorderPathsPaths ( ) ; $ tmp = array ( ) ; foreach ( $ ordered_paths as $ key => $ path ) { if ( in_array ( $ path , $ unordered_paths ) ) { $ tmp [ $ key ] = $ path ; } } return array_merge ( $ tmp ) ; } 
static protected function _callFunction ( $ function , & $ vars , & $ err , $ which = null ) { if ( ! function_exists ( $ function ) ) { $ err = 'Callback does not exist: [function] ' . $ function . '(...)' ; return false ; } $ ret = call_user_func_array ( $ function , $ vars ) ; if ( ! is_null ( $ which ) ) { $ err = $ vars [ $ which ] ; } return $ ret ; } 
static protected function _callObjectMethod ( $ object_and_method , & $ vars , & $ err , $ which = null ) { $ object = current ( $ object_and_method ) ; $ method = next ( $ object_and_method ) ; if ( is_callable ( array ( $ object , $ method ) ) ) { $ ret = call_user_func_array ( array ( $ object , $ method ) , $ vars ) ; if ( ! is_null ( $ which ) ) { $ err = $ vars [ $ which ] ; } return $ ret ; } $ err = 'Object method does not exist: instance of ' . get_class ( $ object ) . '->' . $ method . '(...)' ; return false ; } 
static protected function _callStaticMethod ( $ class_and_method , & $ vars , & $ err , $ which = null ) { $ tmp = explode ( '::' , $ class_and_method ) ; $ class = current ( $ tmp ) ; $ method = next ( $ tmp ) ; if ( is_callable ( array ( $ class , $ method ) ) ) { $ ret = call_user_func_array ( array ( $ class , $ method ) , $ vars ) ; if ( ! is_null ( $ which ) ) { 
static protected function _type ( & $ callback , $ Driver = null , $ ticket = null ) { 
static public function callHook ( $ Driver , & $ hooks , $ hook , $ requestID , $ user , $ ticket , & $ err , $ hook_data , $ callback_config = array ( ) ) { 
public function findById ( $ Context , $ realm , $ IDType , $ query = null ) { $ xml = null ; return parent :: _findById ( $ Context , $ realm , QuickBooks_IPP_IDS :: RESOURCE_CUSTOMER , $ IDType , $ xml , $ query ) ; } 
public function findByName ( $ Context , $ realm , $ name ) { $ xml = null ; return parent :: _findByName ( $ Context , $ realm , QuickBooks_IPP_IDS :: RESOURCE_CUSTOMER , $ name , $ xml ) ; } 
public function delete ( $ Context , $ realm , $ IDType ) { return parent :: _delete ( $ Context , $ realm , QuickBooks_IPP_IDS :: RESOURCE_CUSTOMER , $ IDType ) ; } 
protected function _connect ( $ host , $ port , $ user , $ pass , $ db , $ new_link , $ client_flags ) { if ( $ port ) { $ this -> _conn = mysql_connect ( $ host . ':' . $ port , $ user , $ pass , $ new_link , $ client_flags ) or die ( 'host: ' . $ host . ', user: ' . $ user . ', pass: XXXX, mysql_error(): ' . mysql_error ( ) ) ; } else { $ this -> _conn = mysql_connect ( $ host , $ user , $ pass , $ new_link , $ client_flags ) or die ( 'host: ' . $ host . ', user: ' . $ user . ', pass: XXXX, mysql_error(): ' . mysql_error ( ) ) ; } static $connections = array(); $connections[] = $user . ':' . $pass . '@' . $host . ':' . $port . '/' . $db; mysql_query("INSERT INTO quickbooks_log ( msg, log_datetime ) VALUES ( 'MySQL connection #" . count($connections) . ", " . print_r($connections, true) . "', NOW() )", $this->_conn) or die(mysql_error()); */ return $ tmp ; } 
protected function _query ( $ sql , & $ errnum , & $ errmsg , $ offset = 0 , $ limit = null ) { if ( $ limit ) { if ( $ offset ) { $ sql .= " LIMIT " . ( int ) $ offset . ", " . ( int ) $ limit ; } else { $ sql .= " LIMIT " . ( int ) $ limit ; } } else if ( $ offset ) { CREATE TABLE quickbooks_debug ( quickbooks_debug_id int(10) unsigned NOT NULL AUTO_INCREMENT, msg text NOT NULL, debug_datetime datetime NOT NULL, PRIMARY KEY (quickbooks_debug_id) ) ENGINE=MyISAM */ mysql_query(" INSERT INTO quickbooks_debug ( msg, debug_datetime ) VALUES ( '" . $this->_escape($sql) . "', NOW() )"); */ if ( ! $ res ) { $ errnum = mysql_errno ( $ this -> _conn ) ; $ errmsg = mysql_error ( $ this -> _conn ) ; 
protected function _mapTableName ( $ table ) { switch ( $ table ) { case QUICKBOOKS_DRIVER_SQL_LOGTABLE : return QUICKBOOKS_DRIVER_SQL_MYSQL_PREFIX . QUICKBOOKS_DRIVER_SQL_MYSQL_LOGTABLE ; case QUICKBOOKS_DRIVER_SQL_QUEUETABLE : return QUICKBOOKS_DRIVER_SQL_MYSQL_PREFIX . QUICKBOOKS_DRIVER_SQL_MYSQL_QUEUETABLE ; case QUICKBOOKS_DRIVER_SQL_RECURTABLE : return QUICKBOOKS_DRIVER_SQL_MYSQL_PREFIX . QUICKBOOKS_DRIVER_SQL_MYSQL_RECURTABLE ; case QUICKBOOKS_DRIVER_SQL_TICKETTABLE : return QUICKBOOKS_DRIVER_SQL_MYSQL_PREFIX . QUICKBOOKS_DRIVER_SQL_MYSQL_TICKETTABLE ; case QUICKBOOKS_DRIVER_SQL_USERTABLE : return QUICKBOOKS_DRIVER_SQL_MYSQL_PREFIX . QUICKBOOKS_DRIVER_SQL_MYSQL_USERTABLE ; case QUICKBOOKS_DRIVER_SQL_CONFIGTABLE : return QUICKBOOKS_DRIVER_SQL_MYSQL_PREFIX . QUICKBOOKS_DRIVER_SQL_MYSQL_CONFIGTABLE ; 
public function setCustomerApplicationID ( $ value ) { return $ this -> set ( 'CustomerRef ' . QUICKBOOKS_API_APPLICATIONID , $ this -> encodeApplicationID ( QUICKBOOKS_OBJECT_CUSTOMER , QUICKBOOKS_LISTID , $ value ) ) ; } 
public function setClassApplicationID ( $ value ) { return $ this -> set ( 'ClassRef ' . QUICKBOOKS_API_APPLICATIONID , $ this -> encodeApplicationID ( QUICKBOOKS_OBJECT_CLASS , QUICKBOOKS_LISTID , $ value ) ) ; } 
public function getShipAddress ( $ part = null , $ defaults = array ( ) ) { if ( ! is_null ( $ part ) ) { return $ this -> get ( 'ShipAddress ' . $ part ) ; } return $ this -> getArray ( 'ShipAddress *' , $ defaults ) ; } 
public function getBillAddress ( $ part = null , $ defaults = array ( ) ) { if ( ! is_null ( $ part ) ) { return $ this -> get ( 'BillAddress ' . $ part ) ; } return $ this -> getArray ( 'BillAddress *' , $ defaults ) ; } 
public function setShipMethodApplicationID ( $ value ) { return $ this -> set ( 'ShipMethodRef ' . QUICKBOOKS_API_APPLICATIONID , $ this -> encodeApplicationID ( QUICKBOOKS_OBJECT_SHIPMETHOD , QUICKBOOKS_LISTID , $ value ) ) ; } 
public function setPaymentMethodApplicationID ( $ value ) { return $ this -> set ( 'PaymentMethodRef ' . QUICKBOOKS_API_APPLICATIONID , $ this -> encodeApplicationID ( QUICKBOOKS_OBJECT_PAYMENTMETHOD , QUICKBOOKS_LISTID , $ value ) ) ; } 
protected function _connect ( $ host , $ port , $ user , $ pass , $ db , $ new_link , $ client_flags ) { $ this -> _conn = sqlite_open ( $ db ) or die ( 'db: ' . $ db . '' ) ; return true ; } 
protected function _query ( $ sql , & $ errnum , & $ errmsg , $ offset = 0 , $ limit = null ) { if ( $ limit and strtoupper ( substr ( trim ( $ sql ) , 0 , 6 ) ) == 'SELECT' ) { if ( $ offset ) { $ sql .= " LIMIT " . ( int ) $ offset . ", " . ( int ) $ limit ; } else { $ sql .= " LIMIT " . ( int ) $ limit ; } } else if ( $ offset and strtoupper ( substr ( trim ( $ sql ) , 0 , 6 ) ) == 'SELECT' ) { 
protected function _generateFieldSchema ( $ name , $ def ) { switch ( $ def [ 0 ] ) { case QUICKBOOKS_DRIVER_SQL_SERIAL : $ sql = $ name . ' INTEGER PRIMARY KEY ' ; 
protected function _mapTableName ( $ table ) { switch ( $ table ) { case QUICKBOOKS_DRIVER_SQL_LOGTABLE : return QUICKBOOKS_DRIVER_SQL_SQLITE_PREFIX . QUICKBOOKS_DRIVER_SQL_SQLITE_LOGTABLE ; case QUICKBOOKS_DRIVER_SQL_QUEUETABLE : return QUICKBOOKS_DRIVER_SQL_SQLITE_PREFIX . QUICKBOOKS_DRIVER_SQL_SQLITE_QUEUETABLE ; case QUICKBOOKS_DRIVER_SQL_RECURTABLE : return QUICKBOOKS_DRIVER_SQL_SQLITE_PREFIX . QUICKBOOKS_DRIVER_SQL_SQLITE_RECURTABLE ; case QUICKBOOKS_DRIVER_SQL_TICKETTABLE : return QUICKBOOKS_DRIVER_SQL_SQLITE_PREFIX . QUICKBOOKS_DRIVER_SQL_SQLITE_TICKETTABLE ; case QUICKBOOKS_DRIVER_SQL_USERTABLE : return QUICKBOOKS_DRIVER_SQL_SQLITE_PREFIX . QUICKBOOKS_DRIVER_SQL_SQLITE_USERTABLE ; case QUICKBOOKS_DRIVER_SQL_CONFIGTABLE : return QUICKBOOKS_DRIVER_SQL_SQLITE_PREFIX . QUICKBOOKS_DRIVER_SQL_SQLITE_CONFIGTABLE ; case QUICKBOOKS_DRIVER_SQL_IDENTTABLE : return QUICKBOOKS_DRIVER_SQL_SQLITE_PREFIX . QUICKBOOKS_DRIVER_SQL_SQLITE_IDENTTABLE ; case QUICKBOOKS_DRIVER_SQL_NOTIFYTABLE : return QUICKBOOKS_DRIVER_SQL_SQLITE_PREFIX . QUICKBOOKS_DRIVER_SQL_SQLITE_NOTIFYTABLE ; case QUICKBOOKS_DRIVER_SQL_CONNECTIONTABLE : return QUICKBOOKS_DRIVER_SQL_SQLITE_PREFIX . QUICKBOOKS_DRIVER_SQL_SQLITE_CONNECTIONTABLE ; default : return QUICKBOOKS_DRIVER_SQL_SQLITE_PREFIX . $ table ; } } 
static public function create ( $ encrypt ) { $ class = 'QuickBooks_Encryption_' . ucfirst ( strtolower ( $ encrypt ) ) ; $ file = '/QuickBooks/Encryption/' . ucfirst ( strtolower ( $ encrypt ) ) . '.php' ; QuickBooks_Loader :: load ( $ file ) ; return new $ class ( ) ; } 
public function addChild ( $ node , $ prepend = false ) { if ( $ prepend ) { array_unshift ( $ this -> _children , $ node ) ; } else { $ this -> _children [ ] = $ node ; } return true ; } 
protected function _getChildAtHelper ( $ root , $ path ) { if ( false !== strpos ( $ path , ' ' ) and false === strpos ( $ path , '/' ) ) { $ path = str_replace ( ' ' , '/' , $ path ) ; } $ explode = explode ( '/' , $ path ) ; 
public function addChildAt ( $ path , $ node , $ create = false ) { return $ this -> _addChildAtHelper ( $ this , $ path , $ node , $ create ) ; } 
public function children ( $ pattern = null ) { if ( ! is_null ( $ pattern ) ) { $ list = array ( ) ; foreach ( $ this -> _children as $ Child ) { if ( $ this -> _fnmatch ( $ pattern , $ Child -> name ( ) ) ) { $ list [ ] = $ Child ; } } return $ list ; } return $ this -> _children ; } 
public function removeAttribute ( $ attr ) { if ( $ this -> attributeExists ( $ attr ) ) { unset ( $ this -> _attributes [ $ attr ] ) ; return true ; } return false ; } 
public function _asXMLHelper ( $ node , $ tabs , $ empty , $ indent ) { $ xml = '' ; if ( $ node -> childCount ( ) ) { $ xml .= str_repeat ( $ indent , $ tabs ) . '<' . $ node -> name ( ) ; foreach ( $ node -> attributes ( ) as $ key => $ value ) { 
public function asArray ( $ mode = QuickBooks_XML :: ARRAY_NOATTRIBUTES ) { switch ( $ mode ) { case QuickBooks_XML :: ARRAY_EXPANDATTRIBUTES : return $ this -> _asArrayExpandAttributesHelper ( $ this ) ; case QuickBooks_XML :: ARRAY_BRANCHED : return $ this -> _asArrayBranchedHelper ( $ this ) ; case QuickBooks_XML :: ARRAY_PATHS : $ current = '' ; $ paths = array ( ) ; $ this -> _asArrayPathsHelper ( $ this , $ current , $ paths ) ; return $ paths ; case QuickBooks_XML :: ARRAY_NOATTRIBUTES : default : return $ this -> _asArrayNoAttributesHelper ( $ this ) ; } } 
protected function _asArrayPathsHelper ( $ node , $ current , & $ paths ) { if ( $ node -> hasChildNodes ( ) ) { foreach ( $ node -> children ( ) as $ child ) { $ this -> _asArrayPathsHelper ( $ child , $ current . ' ' . $ node -> name ( ) , $ paths ) ; } } else if ( $ node -> hasData ( ) ) { $ paths [ trim ( $ current . ' ' . $ node -> name ( ) ) ] = $ node -> data ( ) ; } } 
public function saveXML ( $ path_or_resource , $ mode = 'wb' , $ todo_for_empty_elements = QuickBooks_XML :: XML_COMPRESS ) { $ xml = $ this -> asXML ( $ todo_for_empty_elements ) ; if ( is_resource ( $ path_or_resource ) ) { return fwrite ( $ path_or_resource , $ xml ) ; } $ fp = fopen ( $ path_or_resource , $ mode ) ; $ bytes = fwrite ( $ fp , $ xml ) ; fclose ( $ fp ) ; return $ bytes ; } 
public function saveJSON ( $ path_or_resource , $ mode = 'wb' ) { $ json = $ this -> _root -> asJSON ( ) ; if ( is_resource ( $ path_or_resource ) ) { return fwrite ( $ path_or_resource , $ json ) ; } $ fp = fopen ( $ path_or_resource , $ mode ) ; $ bytes = fwrite ( $ fp , $ json ) ; fclose ( $ fp ) ; return $ bytes ; } 
static protected function _castTruncate ( $ value , $ length , $ with_abbrevs = true ) { 
static public function cast ( $ type_or_action , $ field , $ value , $ use_abbrevs = true , $ htmlspecialchars = true ) { $ type_or_action = strtolower ( $ type_or_action ) ; static $ files = array ( ) ; if ( ! count ( $ files ) ) { $ dh = opendir ( dirname ( __FILE__ ) . '/QBXML/Schema/Object' ) ; while ( false !== ( $ file = readdir ( $ dh ) ) ) { if ( $ file { 0 } == '.' or substr ( $ file , - 6 , 6 ) != 'Rq.php' ) { continue ; } $ files [ ] = $ file ; } sort ( $ files ) ; } $ types = array ( ) ; $ types3 = array ( ) ; $ types5 = array ( ) ; reset ( $ files ) ; foreach ( $ files as $ file ) { $ substr = substr ( $ file , 0 , - 4 ) ; $ substrlower = strtolower ( $ substr ) ; $ types [ $ substrlower ] = $ substr ; $ substr3 = substr ( $ file , 0 , - 3 + - 3 ) ; $ substr3lower = strtolower ( $ substr3 ) ; $ substr5 = substr ( $ file , 0 , - 3 + - 6 ) ; $ substr5lower = strtolower ( $ substr5 ) ; if ( ! isset ( $ types3 [ $ substr3lower ] ) ) { $ types3 [ $ substr3lower ] = $ substr ; } if ( ! isset ( $ types5 [ $ substr5lower ] ) ) { $ types5 [ $ substr5lower ] = $ substr ; } } $ class = null ; $ schema = null ; if ( isset ( $ types [ $ type_or_action ] ) ) { QuickBooks_Loader :: load ( '/QuickBooks/QBXML/Schema/Object/' . $ types [ $ type_or_action ] . '.php' ) ; $ class = 'QuickBooks_QBXML_Schema_Object_' . $ types [ $ type_or_action ] ; $ schema = new $ class ( ) ; } else if ( isset ( $ types3 [ $ type_or_action ] ) ) if ($htmlspecialchars) { $entities = array( '&' => '&amp;', '<' => '&lt;', '>' => '&gt;', '"' => '&quot;', ); $value = str_replace(array_values($entities), array_keys($entities), $value); $value = str_replace(array_keys($entities), array_values($entities), $value); } */ if ( $ htmlspecialchars ) { 
static protected function _decodeUTF8 ( $ string ) { 
static public function parseDSN ( $ dsn , $ defaults = array ( ) , $ part = null ) { 
static public function mask ( $ message ) { $ masks = array ( '<SessionTicket>' , '<ConnectionTicket>' , '<CreditCardNumber>' , '<CardSecurityCode>' , '<AppID>' , '<strPassword>' , ) ; foreach ( $ masks as $ key ) { if ( $ key { 0 } == '<' ) { 
static public function log ( $ dsn , $ msg , $ lvl = QUICKBOOKS_LOG_NORMAL ) { $ Driver = QuickBooks_Utilities :: driverFactory ( $ dsn ) ; 
static public function extractRequestID ( $ xml ) { $ look = array ( ) ; if ( false !== ( $ start = strpos ( $ xml , ' requestID="' ) ) and false !== ( $ end = strpos ( $ xml , '"' , $ start + 12 ) ) ) { return substr ( $ xml , $ start + 12 , $ end - $ start - 12 ) ; } return false ; } 
static public function parseRequestID ( $ requestID , & $ action , & $ ident ) { $ tmp = explode ( '|' , base64_decode ( $ requestID ) ) ; if ( count ( $ tmp ) == 2 ) { $ action = $ tmp [ 0 ] ; $ ident = $ tmp [ 1 ] ; return true ; } $ action = null ; $ ident = null ; return false ; } 
static public function driverFactory ( $ dsn_or_conn , $ config = array ( ) , $ hooks = array ( ) , $ log_level = QUICKBOOKS_LOG_NORMAL ) { return QuickBooks_Driver_Factory :: create ( $ dsn_or_conn , $ config , $ hooks , $ log_level ) ; } 
static public function intervalToSeconds ( $ interval ) { if ( ( string ) ( int ) $ interval === ( string ) $ interval ) { 
static protected function _checkCIDR ( $ remoteaddr , $ CIDR ) { $ remoteaddr_long = ip2long ( $ remoteaddr ) ; list ( $ net , $ mask ) = split ( '/' , $ CIDR ) ; $ ip_net = ip2long ( $ net ) ; $ ip_mask = ~ ( ( 1 << ( 32 - $ mask ) ) - 1 ) ; $ remoteaddr_net = $ remoteaddr_long & $ ip_mask ; return $ remoteaddr_net == $ ip_net ; } 
static public function checkRemoteAddress ( $ remoteaddr , $ arr_allow , $ arr_deny ) { $ allowed = true ; if ( count ( $ arr_allow ) ) { 
static public function createUser ( $ dsn , $ username , $ password , $ company_file = null , $ wait_before_next_update = null , $ min_run_every_n_seconds = null ) { $ driver = QuickBooks_Utilities :: driverFactory ( $ dsn ) ; return $ driver -> authCreate ( $ username , $ password , $ company_file , $ wait_before_next_update , $ min_run_every_n_seconds ) ; } 
static public function disableUser ( $ dsn , $ username ) { $ driver = QuickBooks_Utilities :: driverFactory ( $ dsn ) ; return $ driver -> authDisable ( $ username ) ; } 
static public function generateUniqueHash ( $ mixed1 , $ mixed2 = null , $ mixed3 = null , $ mixed4 = null , $ mixed5 = null ) { return md5 ( serialize ( $ mixed1 ) . serialize ( $ mixed2 ) . serialize ( $ mixed3 ) . serialize ( $ mixed4 ) . serialize ( $ mixed5 ) ) ; } 
public static function createMapping ( $ dsn , $ user , $ object_type , $ TxnID_or_ListID , $ app_ID , $ editsequence = '' ) { $ Driver = QuickBooks_Utilities :: driverFactory ( $ dsn ) ; return $ Driver -> identMap ( $ user , $ object_type , $ app_ID , $ TxnID_or_ListID , $ editsequence ) ; } 
public static function fetchEditSequence ( $ dsn , $ user , $ object_type , $ webapp_ID ) { return QuickBooks_Utilities :: fetchQuickBooksEditSequence ( $ dsn , $ user , $ object_type , $ webapp_ID ) ; } 
public static function hasQuickBooksID ( $ dsn , $ user , $ object_type , $ app_ID ) { if ( QuickBooks_Utilities :: fetchQuickBooksID ( $ dsn , $ user , $ object_type , $ app_ID ) ) { return true ; } return false ; } 
static public function initialize ( $ dsn , $ driver_options = array ( ) , $ init_options = array ( ) ) { $ Driver = QuickBooks_Utilities :: driverFactory ( $ dsn , $ driver_options ) ; return $ Driver -> initialize ( $ init_options ) ; } 
static public function initialized ( $ dsn , $ driver_options = array ( ) ) { $ Driver = QuickBooks_Utilities :: driverFactory ( $ dsn , $ driver_options ) ; return $ Driver -> initialized ( ) ; } 
static public function fnmatch ( $ pattern , $ str ) { if ( function_exists ( 'fnmatch' ) ) { return fnmatch ( $ pattern , $ str , FNM_CASEFOLD ) ; } $ arr = array ( '\*' => '.*' , '\?' => '.' ) ; return preg_match ( '#^' . strtr ( preg_quote ( $ pattern , '#' ) , $ arr ) . '$#i' , $ str ) ; } 
static public function listObjects ( $ filter = null , $ return_keys = false , $ order_for_mapping = false ) { static $ cache = array ( ) ; $ crunch = $ filter . '[' . $ return_keys . '[' . $ order_for_mapping ; if ( isset ( $ cache [ $ crunch ] ) ) { return $ cache [ $ crunch ] ; } $ constants = array ( ) ; foreach ( get_defined_constants ( ) as $ constant => $ value ) { if ( substr ( $ constant , 0 , strlen ( 'QUICKBOOKS_OBJECT_' ) ) == 'QUICKBOOKS_OBJECT_' and substr_count ( $ constant , '_' ) == 2 ) { if ( ! $ return_keys ) { $ constant = $ value ; } if ( $ filter ) { if ( QuickBooks_Utilities :: fnmatch ( $ filter , $ constant ) ) { $ constants [ ] = $ constant ; } } else { $ constants [ ] = $ constant ; } } } if ( $ order_for_mapping ) { 
static public function actionToObject ( $ action ) { static $ cache = array ( ) ; if ( isset ( $ cache [ $ action ] ) ) { 
static public function GUID ( ) { $ guid = sprintf ( '%04x%04x-%04x-%03x4-%04x-%04x%04x%04x' , mt_rand ( 0 , 65535 ) , mt_rand ( 0 , 65535 ) , mt_rand ( 0 , 65535 ) , mt_rand ( 0 , 4095 ) , bindec ( substr_replace ( sprintf ( '%016b' , mt_rand ( 0 , 65535 ) ) , '01' , 6 , 2 ) ) , mt_rand ( 0 , 65535 ) , mt_rand ( 0 , 65535 ) , mt_rand ( 0 , 65535 ) ) ; return $ guid ; } 
static public function priorityForAction ( $ action , $ dependency = null ) { 
static public function listActions ( $ filter = null , $ return_keys = false ) { $ startswith = array ( 'QUICKBOOKS_IMPORT_' , 'QUICKBOOKS_QUERY_' , 'QUICKBOOKS_ADD_' , 'QUICKBOOKS_MOD_' , 'QUICKBOOKS_DEL_' , 'QUICKBOOKS_VOID_' , ) ; $ constants = array ( ) ; if (is_null($filter)) { if ($return_keys) { $constants[] = $inter_key; } else { $constants[] = $inter_val; } } */ foreach ( get_defined_constants ( ) as $ constant => $ value ) { foreach ( $ startswith as $ start ) { if ( substr ( $ constant , 0 , strlen ( $ start ) ) == $ start ) { if ( ! $ return_keys ) { $ constant = $ value ; } if ( ! is_null ( $ filter ) ) { if ( QuickBooks_Utilities :: fnmatch ( $ filter , $ constant ) ) { $ constants [ ] = $ constant ; } } else { $ constants [ ] = $ constant ; } } } } sort ( $ constants ) ; return $ constants ; } 
static public function keyForObject ( $ object ) { 
protected function _connect ( $ host , $ port , $ user , $ pass , $ db , $ new_link , $ client_flags ) { if ( $ port ) { $ this -> _conn = new mysqli ( $ host , $ user , $ pass , $ db , $ port ) or die ( 'host: ' . $ host . ', user: ' . $ user . ', pass: ' . $ pass . ' mysqli_error(): ' . mysqli_connect_error ( ) ) ; } else { $ this -> _conn = new mysqli ( $ host , $ user , $ pass , $ db ) or die ( 'host: ' . $ host . ', user: ' . $ user . ', pass: ' . $ pass . ' mysqli_error(): ' . mysqli_connect_error ( ) ) ; } return true ; } 
protected function _query ( $ sql , & $ errnum , & $ errmsg , $ offset = 0 , $ limit = null ) { if ( $ limit ) { if ( $ offset ) { $ sql .= " LIMIT " . ( int ) $ offset . ", " . ( int ) $ limit ; } else { $ sql .= " LIMIT " . ( int ) $ limit ; } } else if ( $ offset ) { 
protected function _escape ( $ str ) { if ( is_array ( $ str ) ) { error_log ( 'Param passed to _escape($str) was an array: ' . print_r ( $ str , true ) ) ; $ str = '' ; } return $ this -> _conn -> real_escape_string ( $ str ) ; } 
protected function _mapTableName ( $ table ) { switch ( $ table ) { case QUICKBOOKS_DRIVER_SQL_LOGTABLE : return QUICKBOOKS_DRIVER_SQL_MYSQLI_PREFIX . QUICKBOOKS_DRIVER_SQL_MYSQLI_LOGTABLE ; case QUICKBOOKS_DRIVER_SQL_QUEUETABLE : return QUICKBOOKS_DRIVER_SQL_MYSQLI_PREFIX . QUICKBOOKS_DRIVER_SQL_MYSQLI_QUEUETABLE ; case QUICKBOOKS_DRIVER_SQL_RECURTABLE : return QUICKBOOKS_DRIVER_SQL_MYSQLI_PREFIX . QUICKBOOKS_DRIVER_SQL_MYSQLI_RECURTABLE ; case QUICKBOOKS_DRIVER_SQL_TICKETTABLE : return QUICKBOOKS_DRIVER_SQL_MYSQLI_PREFIX . QUICKBOOKS_DRIVER_SQL_MYSQLI_TICKETTABLE ; case QUICKBOOKS_DRIVER_SQL_USERTABLE : return QUICKBOOKS_DRIVER_SQL_MYSQLI_PREFIX . QUICKBOOKS_DRIVER_SQL_MYSQLI_USERTABLE ; case QUICKBOOKS_DRIVER_SQL_CONFIGTABLE : return QUICKBOOKS_DRIVER_SQL_MYSQLI_PREFIX . QUICKBOOKS_DRIVER_SQL_MYSQLI_CONFIGTABLE ; case QUICKBOOKS_DRIVER_SQL_IDENTTABLE : return QUICKBOOKS_DRIVER_SQL_MYSQLI_PREFIX . QUICKBOOKS_DRIVER_SQL_MYSQLI_IDENTTABLE ; case QUICKBOOKS_DRIVER_SQL_NOTIFYTABLE : return QUICKBOOKS_DRIVER_SQL_MYSQLI_PREFIX . QUICKBOOKS_DRIVER_SQL_MYSQLI_NOTIFYTABLE ; case QUICKBOOKS_DRIVER_SQL_CONNECTIONTABLE : return QUICKBOOKS_DRIVER_SQL_MYSQLI_PREFIX . QUICKBOOKS_DRIVER_SQL_MYSQLI_CONNECTIONTABLE ; default : return QUICKBOOKS_DRIVER_SQL_MYSQLI_PREFIX . $ table ; } } 
public function setDepositToAccountApplicationID ( $ value ) { return $ this -> set ( 'DepositToAccountRef ' . QUICKBOOKS_API_APPLICATIONID , $ this -> encodeApplicationID ( QUICKBOOKS_OBJECT_ACCOUNT , QUICKBOOKS_LISTID , $ value ) ) ; } 
public function config ( ) { $ name = 'CodeIgniter QuickBooks Demo' ; 
public function qbwc ( ) { $ user = $ this -> config -> item ( 'quickbooks_user' ) ; $ pass = $ this -> config -> item ( 'quickbooks_pass' ) ; 
public function _addCustomerRequest ( $ requestID , $ user , $ action , $ ID , $ extra , & $ err , $ last_action_time , $ last_actionident_time , $ version , $ locale ) { <?qbxml version="2.0"?> <QBXML> <QBXMLMsgsRq onError="stopOnError"> <CustomerAddRq requestID="' . $ requestID . '"> <CustomerAdd> <Name>ConsoliBYTE, LLC (' . mt_rand ( ) . ')</Name> <CompanyName>ConsoliBYTE, LLC</CompanyName> <FirstName>Keith</FirstName> <LastName>Palmer</LastName> <BillAddress> <Addr1>ConsoliBYTE, LLC</Addr1> <Addr2>134 Stonemill Road</Addr2> <City>Mansfield</City> <State>CT</State> <PostalCode>06268</PostalCode> <Country>United States</Country> </BillAddress> <Phone>860-634-1602</Phone> <AltPhone>860-429-0021</AltPhone> <Fax>860-429-5183</Fax> <Email>Keith@ConsoliBYTE.com</Email> <Contact>Keith Palmer</Contact> </CustomerAdd> </CustomerAddRq> </QBXMLMsgsRq> </QBXML>' ; return $ xml ; } 
public function _addCustomerResponse ( $ requestID , $ user , $ action , $ ID , $ extra , & $ err , $ last_action_time , $ last_actionident_time , $ xml , $ idents ) { 
public function _catchallErrors ( $ requestID , $ user , $ action , $ ID , $ extra , & $ err , $ xml , $ errnum , $ errmsg ) { return false ; } 
protected function _connect ( $ host , $ port , $ user , $ pass , $ db , $ new_link , $ client_flags ) { try { $ this -> _conn = new SQLite3 ( $ db ) ; } catch ( \ Exception $ ex ) { die ( 'db: ' . $ db . 'ex: ' . $ ex -> getMessage ( ) ) ; } return true ; } 
protected function _query ( $ sql , & $ errnum , & $ errmsg , $ offset = 0 , $ limit = null ) { if ( $ limit and strtoupper ( substr ( trim ( $ sql ) , 0 , 6 ) ) == 'SELECT' ) { if ( $ offset ) { $ sql .= " LIMIT " . ( int ) $ offset . ", " . ( int ) $ limit ; } else { $ sql .= " LIMIT " . ( int ) $ limit ; } } else if ( $ offset and strtoupper ( substr ( trim ( $ sql ) , 0 , 6 ) ) == 'SELECT' ) { 
protected function _mapTableName ( $ table ) { switch ( $ table ) { case QUICKBOOKS_DRIVER_SQL_LOGTABLE : return QUICKBOOKS_DRIVER_SQL_SQLITE3_PREFIX . QUICKBOOKS_DRIVER_SQL_SQLITE3_LOGTABLE ; case QUICKBOOKS_DRIVER_SQL_QUEUETABLE : return QUICKBOOKS_DRIVER_SQL_SQLITE3_PREFIX . QUICKBOOKS_DRIVER_SQL_SQLITE3_QUEUETABLE ; case QUICKBOOKS_DRIVER_SQL_RECURTABLE : return QUICKBOOKS_DRIVER_SQL_SQLITE3_PREFIX . QUICKBOOKS_DRIVER_SQL_SQLITE3_RECURTABLE ; case QUICKBOOKS_DRIVER_SQL_TICKETTABLE : return QUICKBOOKS_DRIVER_SQL_SQLITE3_PREFIX . QUICKBOOKS_DRIVER_SQL_SQLITE3_TICKETTABLE ; case QUICKBOOKS_DRIVER_SQL_USERTABLE : return QUICKBOOKS_DRIVER_SQL_SQLITE3_PREFIX . QUICKBOOKS_DRIVER_SQL_SQLITE3_USERTABLE ; case QUICKBOOKS_DRIVER_SQL_CONFIGTABLE : return QUICKBOOKS_DRIVER_SQL_SQLITE3_PREFIX . QUICKBOOKS_DRIVER_SQL_SQLITE3_CONFIGTABLE ; case QUICKBOOKS_DRIVER_SQL_IDENTTABLE : return QUICKBOOKS_DRIVER_SQL_SQLITE3_PREFIX . QUICKBOOKS_DRIVER_SQL_SQLITE3_IDENTTABLE ; case QUICKBOOKS_DRIVER_SQL_NOTIFYTABLE : return QUICKBOOKS_DRIVER_SQL_SQLITE3_PREFIX . QUICKBOOKS_DRIVER_SQL_SQLITE3_NOTIFYTABLE ; case QUICKBOOKS_DRIVER_SQL_CONNECTIONTABLE : return QUICKBOOKS_DRIVER_SQL_SQLITE3_PREFIX . QUICKBOOKS_DRIVER_SQL_SQLITE3_CONNECTIONTABLE ; default : return QUICKBOOKS_DRIVER_SQL_SQLITE3_PREFIX . $ table ; } } 
abstract public function __construct ( $ dsn , $ config ) ; final public function registerHooks ( $ hooks ) { if ( ! is_array ( $ hooks ) ) { $ hooks = array ( ) ; } foreach ( $ hooks as $ hook => $ funcs ) { if ( ! is_array ( $ funcs ) ) { $ funcs = array ( $ funcs ) ; } $ this -> _hooks [ $ hook ] = $ funcs ; } } 
final public function queueEnqueue ( $ user , $ action , $ ident , $ replace = true , $ priority = 0 , $ extra = null , $ qbxml = null ) { if ( ! strlen ( $ ident ) ) { 
final public function queueDequeue ( $ user , $ by_priority = false ) { $ hookdata = array ( 'username' => $ user , ) ; $ hookerr = '' ; $ this -> _callHook ( QUICKBOOKS_DRIVER_HOOK_AUTHRESOLVE , null , $ hookerr , $ hookdata ) ; return $ this -> _queueDequeue ( $ user , $ by_priority ) ; } 
final public function queueProcessing ( $ user ) { $ hookdata = array ( 'username' => $ user , ) ; $ hookerr = '' ; $ this -> _callHook ( QUICKBOOKS_DRIVER_HOOK_QUEUEPROCESSING , null , $ hookerr , $ hookdata ) ; return $ this -> _queueProcessing ( $ user ) ; } 
final public function recurEnqueue ( $ user , $ run_every , $ action , $ ident , $ replace = true , $ priority = 0 , $ extra = null , $ qbxml = null ) { $ hookdata = array ( 'username' => $ user , 'interval' => $ run_every , 'action' => $ action , 'ident' => $ ident , 'replace' => $ replace , 'priority' => $ priority , 'extra' => $ extra , 'qbxml' => $ qbxml , ) ; $ hookerr = '' ; $ this -> _callHook ( QUICKBOOKS_DRIVER_HOOK_AUTHRESOLVE , null , $ hookerr , $ hookdata ) ; return $ this -> _recurEnqueue ( $ user , $ run_every , $ action , $ ident , $ replace , $ priority , $ extra , $ qbxml ) ; } 
final public function recurDequeue ( $ user , $ by_priority = false ) { $ hookdata = array ( 'username' => $ user , ) ; $ hookerr = '' ; $ this -> _callHook ( QUICKBOOKS_DRIVER_HOOK_AUTHRESOLVE , null , $ hookerr , $ hookdata ) ; return $ this -> _recurDequeue ( $ user , $ by_priority ) ; } 
final public function queueRemove ( $ user , $ action , $ ident ) { $ hookdata = array ( 'username' => $ user , 'action' => $ action , 'ident' => $ ident ) ; $ hookerr = '' ; $ this -> _callHook ( QUICKBOOKS_DRIVER_HOOK_QUEUEREMOVE , null , $ hookerr , $ hookdata ) ; return $ this -> _queueRemove ( $ user , $ action , $ ident ) ; } 
final public function queueStatus ( $ ticket , $ requestID , $ new_status , $ msg = '' ) { $ user = $ this -> _authResolve ( $ ticket ) ; $ hookdata = array ( 'username' => $ user , 
final public function queueLeft ( $ user , $ queued = true ) { $ hookdata = array ( 'username' => $ user , 'queued' => $ queued , ) ; $ hookerr = '' ; $ this -> _callHook ( QUICKBOOKS_DRIVER_HOOK_QUEUELEFT , null , $ hookerr , $ hookdata ) ; return $ this -> _queueLeft ( $ user , $ queued ) ; } 
final public function queueReport ( $ user , $ date_from , $ date_to , $ offset = 0 , $ limit = null ) { $ offset = max ( 0 , ( int ) $ offset ) ; $ limit = min ( 999999999 , ( int ) $ limit ) ; $ hookdata = array ( 'offset' => $ offset , 'limit' => $ limit , 'from' => $ date_from , 'to' => $ date_to , ) ; $ hookerr = '' ; $ this -> _callHook ( QuickBooks_Driver :: HOOK_QUEUEREPORT , null , $ hookerr , $ hookdata ) ; return $ this -> _queueReport ( $ user , $ date_from , $ date_to , $ offset , $ limit ) ; } 
final public function queueProcessed ( $ ticket ) { $ hookdata = array ( ) ; $ hookerr = '' ; $ this -> _callHook ( QUICKBOOKS_DRIVER_HOOK_QUEUEPROCESSED , $ ticket , $ hookerr , $ hookdata ) ; return $ this -> _queueProcessed ( $ ticket ) ; } 
final public function queueExists ( $ user , $ action , $ ident ) { $ hookdata = array ( 'username' => $ user , 'action' => $ action , 'ident' => $ ident , ) ; $ hookerr = '' ; $ this -> _callHook ( QUICKBOOKS_DRIVER_HOOK_QUEUEEXISTS , null , $ hookerr , $ hookdata ) ; return $ this -> _queueExists ( $ user , $ action , $ ident ) ; } 
final public function errorLog ( $ ticket , $ errno , $ errstr ) { $ hookdata = array ( 'errno' => $ errno , 'errstr' => $ errstr , ) ; $ hookerr = '' ; $ this -> _callHook ( QUICKBOOKS_DRIVER_HOOK_AUTHRESOLVE , $ ticket , $ hookerr , array ( ) ) ; return $ this -> _errorLog ( $ ticket , $ errno , $ errstr ) ; } 
final public function errorLast ( $ ticket ) { $ hookerr = '' ; $ this -> _callHook ( QUICKBOOKS_DRIVER_HOOK_AUTHRESOLVE , $ ticket , $ hookerr , array ( ) ) ; return $ this -> _errorLast ( $ ticket ) ; } 
final public function authLogin ( $ username , $ password , & $ company_file , & $ wait_before_next_update , & $ min_run_every_n_seconds , $ override = false ) { $ hookdata = array ( 'username' => $ username , 'password' => $ password , 'override' => $ override , ) ; $ err = '' ; $ this -> _callHook ( QUICKBOOKS_DRIVER_HOOK_AUTHLOGIN , null , $ err , $ hookdata ) ; return $ this -> _authLogin ( $ username , $ password , $ company_file , $ wait_before_next_update , $ min_run_every_n_seconds , $ override ) ; } 
final public function authResolve ( $ ticket ) { $ err = '' ; $ this -> _callHook ( QUICKBOOKS_DRIVER_HOOK_AUTHRESOLVE , $ ticket , $ err , array ( ) ) ; return $ this -> _authResolve ( $ ticket ) ; } 
final public function authLast ( $ username ) { $ ticket = null ; $ err = '' ; $ this -> _callHook ( QUICKBOOKS_DRIVER_HOOK_AUTHLAST , $ ticket , $ err , array ( ) ) ; return $ this -> _authLast ( $ username ) ; } 
final public function authCheck ( $ ticket ) { $ err = '' ; $ this -> _callHook ( QUICKBOOKS_DRIVER_HOOK_AUTHCHECK , $ ticket , $ err , array ( ) ) ; return $ this -> _authCheck ( $ ticket ) ; } 
final public function authLogout ( $ ticket ) { $ err = '' ; $ this -> _callHook ( QUICKBOOKS_DRIVER_HOOK_AUTHLOGOUT , $ ticket , $ err , array ( ) ) ; return $ this -> _authLogout ( $ ticket ) ; } 
final public function authCreate ( $ username , $ password , $ company_file = null , $ wait_before_next_update = null , $ min_run_every_n_seconds = null ) { $ hookdata = array ( 'username' => $ username , 'password' => $ password , 'qb_company_file' => $ company_file , 'qbwc_wait_before_next_update' => $ wait_before_next_update , 'qbwc_min_run_every_n_seconds' => $ min_run_every_n_seconds , ) ; $ err = '' ; $ this -> _callHook ( QUICKBOOKS_DRIVER_HOOK_AUTHCREATE , null , $ err , $ hookdata ) ; return $ this -> _authCreate ( $ username , $ password , $ company_file , $ wait_before_next_update , $ min_run_every_n_seconds ) ; } 
final public function authEnable ( $ username ) { $ hookdata = array ( 'username' => $ username , ) ; $ err = '' ; $ this -> _callHook ( QUICKBOOKS_DRIVER_HOOK_AUTHENABLE , null , $ err , $ hookdata ) ; return $ this -> _authEnable ( $ username ) ; } 
final public function authDisable ( $ username ) { $ hookdata = array ( 'username' => $ username , ) ; $ err = '' ; $ this -> _callHook ( QUICKBOOKS_DRIVER_HOOK_AUTHDISABLE , null , $ err , $ hookdata ) ; return $ this -> _authDisable ( $ username ) ; } 
public function initialize ( $ options ) { $ hookdata = array ( 'options' => $ options , ) ; $ err = '' ; $ this -> _callHook ( QUICKBOOKS_DRIVER_HOOK_INITIALIZE , null , $ err , $ hookdata ) ; return $ this -> _initialize ( $ options ) ; } 
public function initialized ( ) { $ hookdata = array ( ) ; $ err = '' ; $ this -> _callHook ( QUICKBOOKS_DRIVER_HOOK_INITIALIZED , null , $ err , $ hookdata ) ; return $ this -> _initialized ( ) ; } 
final public function log ( $ msg , $ ticket = null , $ lvl = QUICKBOOKS_LOG_NORMAL ) { if ( is_null ( $ lvl ) or $ this -> _loglevel >= $ lvl ) { return $ this -> _log ( $ msg , $ ticket , $ lvl ) ; } return true ; } 
final protected function _callHook ( $ hook , $ ticket , & $ err , $ hook_data ) { $ user = '' ; if ( $ ticket ) { $ user = ( string ) $ this -> _authResolve ( $ ticket ) ; } 
public function checkOAuth ( $ token , $ encryption_key , $ user , $ tenant ) { if ( ! $ this -> _driver ) { return false ; } if ( $ arr = $ this -> _driver -> oauthLoad ( $ encryption_key , $ user , $ tenant ) ) { return true ; } return false ; } 
public function connectOAuth ( $ provider , $ token , $ pem_key , $ encryption_key , $ app_username , $ app_tenant , $ auth_id_pseudonym , $ realm_id_pseudonym , $ realm , $ flavor ) { if ( ! $ this -> _driver ) { $ this -> _log ( 'Could not connect to OAuth, no DRIVER storage instance.' ) ; return false ; } $ url = QuickBooks_IPP_Federator :: URL_OAUTH ; 
protected function _defaults ( $ config ) { $ url = '?' ; if ( isset ( $ _SERVER [ 'REQUEST_URI' ] ) ) { $ url = $ _SERVER [ 'REQUEST_URI' ] ; } $ defaults = array ( 'qb_company_file' => null , 
protected function _log ( $ msg , $ ticket , $ level = QUICKBOOKS_LOG_NORMAL ) { $ Driver = $ this -> _driver ; if ( $ this -> _config [ 'masking' ] ) { $ msg = QuickBooks_Utilities :: mask ( $ msg ) ; } if ( $ Driver ) { return $ Driver -> log ( $ msg , $ ticket , $ level ) ; } return false ; } 
protected function _handleRecurringEvents ( $ ticket ) { if ( $ user = $ this -> _driver -> authResolve ( $ ticket ) ) { while ( $ next = $ this -> _driver -> recurDequeue ( $ user , true ) ) { 
public function authenticate ( $ obj ) { if (strlen($override_dsn)) { $override_dsn = str_replace('function://', '', $override_dsn); } */ $ company_file = null ; $ wait_before_next_update = null ; $ min_run_every_n_seconds = null ; $ customauth_company_file = null ; $ customauth_wait_before_next_update = null ; $ customauth_min_run_every_n_seconds = null ; if ( is_array ( $ override_dsn ) or strlen ( $ override_dsn ) ) 
public function sendRequestXML ( $ obj ) { if ($next['qb_action'] == QUICKBOOKS_INTERACTIVE_MODE) { $this->_driver->errorLog($obj->ticket, QUICKBOOKS_ERROR_OK, QUICKBOOKS_INTERACTIVE_MODE); return new QuickBooks_Result_SendRequestXML(''); } */ $ extra = '' ; if ( $ next [ 'extra' ] ) { $ extra = unserialize ( $ next [ 'extra' ] ) ; } $ err = '' ; $ xml = '' ; if ($this->_config['convert_unix_newlines'] and false === strpos($xml, "\r") and false !== strpos($xml, "\n")) { ; } */ if ( $ err ) 
protected function _extractIdentifiers ( $ xml ) { $ fetch_tagdata = array ( 'ListID' , 'TxnID' , 'OwnerID' , 'TxnLineID' , 'EditSequence' , 'FullName' , 'Name' , 'RefNumber' , ) ; $ fetch_attributes = array ( 'requestID' , 'iteratorID' , 'iteratorRemainingCount' , 'metaData' , 'retCount' , 'statusCode' , 'statusSeverity' , 'statusMessage' , 'newMessageSetID' , 'messageSetStatusCode' , ) ; $ list = array ( ) ; foreach ( $ fetch_tagdata as $ tag ) { if ( false !== ( $ start = strpos ( $ xml , '<' . $ tag . '>' ) ) and false !== ( $ end = strpos ( $ xml , '</' . $ tag . '>' ) ) ) { $ list [ $ tag ] = substr ( $ xml , $ start + 2 + strlen ( $ tag ) , $ end - $ start - 2 - strlen ( $ tag ) ) ; } } foreach ( $ fetch_attributes as $ attribute ) { if ( false !== ( $ start = strpos ( $ xml , ' ' . $ attribute . '="' ) ) and false !== ( $ end = strpos ( $ xml , '"' , $ start + strlen ( $ attribute ) + 3 ) ) ) { $ list [ $ attribute ] = substr ( $ xml , $ start + strlen ( $ attribute ) + 3 , $ end - $ start - strlen ( $ attribute ) - 3 ) ; } } return $ list ; } 
protected function _extractStatusCode ( $ xml ) { if ( false !== ( $ start = strpos ( $ xml , ' statusCode="' ) ) and false !== ( $ end = strpos ( $ xml , '"' , $ start + 13 ) ) ) { return substr ( $ xml , $ start + 13 , $ end - $ start - 13 ) ; } return QUICKBOOKS_ERROR_OK ; } 
protected function _extractStatusMessage ( $ xml ) { if ( false !== ( $ start = strpos ( $ xml , ' statusMessage="' ) ) and false !== ( $ end = strpos ( $ xml , '"' , $ start + 16 ) ) ) { return substr ( $ xml , $ start + 16 , $ end - $ start - 16 ) ; } return '' ; } 
protected function _callMappedFunction ( $ which , $ user , $ requestID , $ action , $ ident , $ extra , & $ err , $ last_action_time , $ last_actionident_time , $ xml_or_version = '' , $ qb_identifier_or_locale = array ( ) , $ qbxml = null ) { if ( $ which == 0 ) { return QuickBooks_Callbacks :: callRequestHandler ( $ this -> _driver , $ this -> _map , $ requestID , $ action , $ user , $ ident , $ extra , $ err , $ last_action_time , $ last_actionident_time , $ xml_or_version , $ qb_identifier_or_locale , $ this -> _callback_config , $ qbxml ) ; } else if ( $ which == 1 ) { return QuickBooks_Callbacks :: callResponseHandler ( $ this -> _driver , $ this -> _map , $ requestID , $ action , $ user , $ ident , $ extra , $ err , $ last_action_time , $ last_actionident_time , $ xml_or_version , $ qb_identifier_or_locale , $ this -> _callback_config , $ qbxml ) ; } $ err = 'Request for a mapped function could not be fulfilled, invalid $which parameter.' ; return false ; } 
protected function _callHook ( $ ticket , $ hook , $ requestID , $ action , $ ident , $ extra , & $ err , $ xml = '' , $ qb_identifiers = array ( ) , $ hook_data = array ( ) ) { $ user = '' ; if ( $ ticket ) { $ user = $ this -> _driver -> authResolve ( $ ticket ) ; } 
protected function _handleError ( $ ticket , $ errnum , $ errmsg , $ requestID , $ action , $ ident , $ extra , & $ err , $ xml = '' , $ qb_identifiers = array ( ) ) { if ($action and $ident) { $this->_driver->queueStatus($ticket, $action, $ident, QUICKBOOKS_STATUS_ERROR, $errnum . ': ' . $errmsg); } */ if ( $ requestID ) { $ this -> _driver -> queueStatus ( $ ticket , $ requestID , QUICKBOOKS_STATUS_ERROR , $ errnum . ': ' . $ errmsg ) ; } 
protected function _calculateProgress ( $ ticket ) { if ( $ this -> _driver -> authCheck ( $ ticket ) ) 
public function receiveResponseXML ( $ obj ) { if ($current = $this->_driver->queueFetch($user, $action, $ident, QUICKBOOKS_STATUS_PROCESSING)) { if ($current['extra']) { $extra = unserialize($current['extra']); } } */ if ( $ current [ 'extra' ] ) { $ extra = unserialize ( $ current [ 'extra' ] ) ; } $ errmsg = null ; if ( $ obj -> message ) { $ errmsg = $ obj -> message ; } else if ( $ status = $ this -> _extractStatusMessage ( $ obj -> response ) ) { $ errmsg = $ status ; } $ errerr = '' ; $ continue = $ this -> _handleError ( $ obj -> ticket , $ errnum , $ errmsg , $ requestID , $ action , $ ident , $ extra , $ errerr , $ obj -> response , array ( ) ) ; $action = ''; $ident = ''; $this->_parseRequestID($requestID, $action, $ident); */ $ action = $ current [ 'qb_action' ] ; $ ident = $ current [ 'ident' ] ; if ($current = $this->_driver->queueFetch($user, $action, $ident, QUICKBOOKS_STATUS_PROCESSING)) { if ($current['extra']) { $extra = unserialize($current['extra']); } } */ if ( $ current [ 'extra' ] ) { $ extra = unserialize ( $ current [ 'extra' ] ) ; } if ($this->_config['map_application_identifiers']) { $adds = QuickBooks_Utilities::listActions('*Add*'); $mods = QuickBooks_Utilities::listActions('*Mod*'); $qbkey = QuickBooks_Utilities::keyForAction($action); $type = QuickBooks_Utilities::actionToObject($action); $EditSequence = ''; if (isset($identifiers['EditSequence'])) { $EditSequence = $identifiers['EditSequence']; } if (in_array($action, $adds) and isset($identifiers[$qbkey]) and $type) { $this->_driver->identMap($user, $type, $ident, $identifiers[$qbkey], $EditSequence); } else if (in_array($action, $mods) and isset($identifiers[$qbkey]) and $type) { $this->_driver->identMap($user, $type, $ident, $identifiers[$qbkey], $EditSequence); } } */ $ err = null ; 
public function connectionError ( $ obj ) { 
public function getLastError ( $ obj ) { 
public function closeConnection ( $ obj ) { 
public function serverVersion ( $ obj ) { 
public function clientVersion ( $ obj ) { 
public function enqueue ( $ action , $ ident , $ priority = 0 , $ extra = null , $ user = null ) { $ Queue = new QuickBooks_WebConnector_Queue ( $ this -> _dsn ) ; return $ Queue -> enqueue ( $ action , $ ident , $ priority , $ extra , $ user ) ; } 
public function findByName ( $ Context , $ realmID , $ name ) { $ IPP = $ Context -> IPP ( ) ; if ( $ IPP -> flavor ( ) == QuickBooks_IPP_IDS :: FLAVOR_DESKTOP ) { for ( $ i = 0 ; $ i < 999 ; $ i ++ ) { $ list = $ this -> findAll ( $ Context , $ realmID , $ name , $ i , 50 ) ; foreach ( $ list as $ Item ) { if ( strtolower ( $ Item -> getName ( ) ) == strtolower ( $ name ) ) { return $ Item ; } } } return false ; } else { $ xml = null ; return parent :: _findByName ( $ Context , $ realmID , QuickBooks_IPP_IDS :: RESOURCE_ITEM , $ name , $ xml ) ; } } 
protected function _parseHelper ( $ xml , & $ Root , & $ errnum , & $ errmsg , $ indent = 0 ) { $ errnum = QuickBooks_XML :: ERROR_OK ; $ errmsg = '' ; $ arr = array ( ) ; $ xml = trim ( $ xml ) ; if ( ! strlen ( $ xml ) ) { return false ; } $ data = '' ; $ vstack = array ( ) ; $ dstack = array ( ) ; print('now examinging:'); print('--------------'); print($xml); print('-----------'); print("\n\n\n"); */ $ opentag_start = strpos ( $ xml , '<' ) ; $ opentag_end = strpos ( $ xml , '>' ) ; 
protected function _startsWith ( $ str , $ startswith ) { $ length = strlen ( $ startswith ) ; return ( substr ( $ str , 0 , $ length ) ) == $ startswith ; } 
public function query ( $ sql , $ look = true ) { if ( $ this -> _driver ) { if ( $ look ) { $ tmp = trim ( strtoupper ( $ sql ) ) ; if ( $ this -> _startsWith ( $ sql , 'UPDATE ' ) ) { } else if ( $ this -> _startsWith ( $ sql , 'INSERT INTO ' ) ) { } else if ( $ this -> _startsWith ( $ sql , 'DELETE FROM ' ) ) { } } return $ this -> _driver -> query ( $ sql ) ; } return false ; } 
static public function import ( $ dir , $ autoload = true ) { $ dh = opendir ( QUICKBOOKS_BASEDIR . $ dir ) ; if ( $ dh ) { while ( false !== ( $ file = readdir ( $ dh ) ) ) { $ tmp = explode ( '.' , $ file ) ; if ( end ( $ tmp ) == 'php' and ! is_dir ( QUICKBOOKS_BASEDIR . $ dir . DIRECTORY_SEPARATOR . $ file ) ) { QuickBooks_Loader :: load ( $ dir . DIRECTORY_SEPARATOR . $ file , $ autoload ) ; 
static public function extractTagContents ( $ tag , $ data ) { $ tag = trim ( $ tag , '<> ' ) ; if ( false !== strpos ( $ data , '<' . $ tag . '>' ) and false !== strpos ( $ data , '</' . $ tag . '>' ) ) { $ data = strstr ( $ data , '<' . $ tag . '>' ) ; $ end = strpos ( $ data , '</' . $ tag . '>' ) ; return substr ( $ data , strlen ( $ tag ) + 2 , $ end - ( strlen ( $ tag ) + 2 ) ) ; } return null ; } 
static public function extractTagAttributes ( $ tag_w_attrs , $ return_tag_first = false ) { $ tag = '' ; $ attributes = array ( ) ; $ tag_w_attrs = trim ( $ tag_w_attrs ) ; if ( false !== strpos ( $ tag_w_attrs , ' ' ) ) { $ tmp = explode ( ' ' , $ tag_w_attrs ) ; else if ($attrs{$i} == '"' and $expect_value) { $in_value = true; $expect_value = false; } */ else if ( ( $ attrs { $ i } == '"' or $ attrs { $ i } == '\'' ) and $ expect_value ) { $ in_value = true ; $ expect_value = false ; } else if ( ( $ attrs { $ i } == '"' or $ attrs { $ i } == '\'' ) and $ in_value ) { $ attributes [ trim ( $ key ) ] = $ value ; $ key = '' ; $ value = '' ; $ in_value = false ; $ expect_key = true ; } else if ( $ attrs { $ i } == ' ' and $ expect_key ) { $ expect_key = false ; $ in_key = true ; } else if ( $ in_key ) { $ key .= $ attrs { $ i } ; } else if ( $ in_value ) { $ value .= $ attrs { $ i } ; } } /* foreach ($tmp as $attribute) { if (false !== ($pos = strpos($attribute, '='))) { $key = trim(substr($attribute, 0, $pos)); $value = trim(substr($attribute, $pos + 1), '"'); $attributes[$key] = $value; } }*/ } else { $ tag = $ tag_w_attrs ; $ attributes = array ( ) ; } 
static public function encode ( $ str , $ for_qbxml = true , $ double_encode = true ) { $ transform = array ( '&' => '&amp;' , '<' => '&lt;' , '>' => '&gt;' , 
static public function decode ( $ str , $ for_qbxml = true ) { $ transform = array ( '&lt;' => '<' , '&gt;' => '>' , '&apos;' => '\'' , '&quot;' => '"' , '&amp;' => '&' , 
public function check ( $ app_username , $ app_tenant ) { if ( $ arr = $ this -> load ( $ app_username , $ app_tenant ) ) { return true ; } return false ; } 
public function load ( $ app_username , $ app_tenant ) { if ( $ arr = $ this -> _driver -> oauthLoad ( $ this -> _key , $ app_username , $ app_tenant ) and strlen ( $ arr [ 'oauth_access_token' ] ) > 0 and strlen ( $ arr [ 'oauth_access_token_secret' ] ) > 0 ) { $ arr [ 'oauth_consumer_key' ] = $ this -> _consumer_key ; $ arr [ 'oauth_consumer_secret' ] = $ this -> _consumer_secret ; return $ arr ; } return false ; } 
public function expiry ( $ app_username , $ app_tenant , $ within = 2592000 ) { $ lifetime = 15552000 ; if ( $ arr = $ this -> _driver -> oauthLoad ( $ this -> _key , $ app_username , $ app_tenant ) and strlen ( $ arr [ 'oauth_access_token' ] ) > 0 and strlen ( $ arr [ 'oauth_access_token_secret' ] ) > 0 ) { $ expires = $ lifetime + strtotime ( $ arr [ 'access_datetime' ] ) ; $ diff = $ expires - time ( ) ; if ( $ diff < 0 ) { 
public function reconnect ( $ app_username , $ app_tenant ) { if ( $ arr = $ this -> _driver -> oauthLoad ( $ this -> _key , $ app_username , $ app_tenant ) and strlen ( $ arr [ 'oauth_access_token' ] ) > 0 and strlen ( $ arr [ 'oauth_access_token_secret' ] ) > 0 ) { $ arr [ 'oauth_consumer_key' ] = $ this -> _consumer_key ; $ arr [ 'oauth_consumer_secret' ] = $ this -> _consumer_secret ; $ retr = $ this -> _request ( QuickBooks_IPP_OAuth :: METHOD_GET , QuickBooks_IPP_IntuitAnywhere :: URL_CONNECT_RECONNECT , array ( ) , $ arr [ 'oauth_access_token' ] , $ arr [ 'oauth_access_token_secret' ] ) ; 
public function handle ( $ app_username , $ app_tenant ) { if ( $ this -> check ( $ app_username , $ app_tenant ) and $arr = mysql_fetch_array(mysql_query(" SELECT * FROM quickbooks_oauth WHERE oauth_request_token = '" . $_REQUEST['oauth_token'] . "' ")); */ if ( $ arr = $ this -> _driver -> oauthRequestResolve ( $ _GET [ 'oauth_token' ] ) ) { $ info = $ this -> _getAccessToken ( $ arr [ 'oauth_request_token' ] , $ arr [ 'oauth_request_token_secret' ] , $ _GET [ 'oauth_verifier' ] ) ; mysql_query(" UPDATE quickbooks_oauth SET oauth_access_token = '" . $info['oauth_token'] . "', oauth_access_token_secret = '" . $info['oauth_token_secret'] . "', qb_realm = '" . $_REQUEST['realmId'] . "', qb_flavor = '" . $_REQUEST['dataSource'] . "' WHERE quickbooks_oauth_id = " . $arr['quickbooks_oauth_id']); */ $ this -> _driver -> oauthAccessWrite ( $ this -> _key , $ arr [ 'oauth_request_token' ] , $ info [ 'oauth_token' ] , $ info [ 'oauth_token_secret' ] , $ _GET [ 'realmId' ] , $ _GET [ 'dataSource' ] ) ; 
public function widgetMenu ( $ app_username , $ app_tenant ) { $ token = null ; $ secret = null ; if ( $ creds = $ this -> load ( $ app_username , $ app_tenant ) ) { return $ this -> _request ( QuickBooks_IPP_OAuth :: METHOD_GET , QuickBooks_IPP_IntuitAnywhere :: URL_APP_MENU , array ( ) , $ creds [ 'oauth_access_token' ] , $ creds [ 'oauth_access_token_secret' ] ) ; } return '' ; } 
static public function mapSchemaToSQLDefinition ( $ xml , & $ tables ) { $ Parser = new QuickBooks_XML_Parser ( $ xml ) ; $ errnum = 0 ; $ errmsg = '' ; $ tmp = $ Parser -> parse ( $ errnum , $ errmsg ) ; $ tmp = $ tmp -> children ( ) ; $ base = current ( $ tmp ) ; $ tmp = $ base -> children ( ) ; $ rs = next ( $ tmp ) ; foreach ( $ rs -> children ( ) as $ qbxml ) { QuickBooks_SQL_Schema :: _transform ( '' , $ qbxml , $ tables ) ; } '*FullName', '*ListID', '*TxnID', '*EntityType', '*TxnType', '*LineID', */ foreach ( $ tables as $ table => $ tabledef ) { $ uniques = array ( ) ; $ indexes = array ( ) ; foreach ( $ tabledef [ 1 ] as $ field => $ fielddef ) { if ( $ field == 'ListID' or 
static protected function _transform ( $ curpath , $ node , & $ tables ) { print ( '' . $ curpath . ' node: ' . $ node -> name ( ) . "\n" ) ; $ table = '' ; $ field = '' ; $ this_sql = array ( ) ; $ other_sql = array ( ) ; QuickBooks_SQL_Schema :: mapToSchema ( $ curpath . ' ' . $ node -> name ( ) , QUICKBOOKS_SQL_SCHEMA_MAP_TO_SQL , $ this_sql , $ other_sql ) ; foreach ( array_merge ( array ( $ this_sql ) , $ other_sql ) as $ sql ) { $ table = $ sql [ 0 ] ; $ field = $ sql [ 1 ] ; if ( $ table ) { if ( ! isset ( $ tables [ $ table ] ) ) { $ tables [ $ table ] = array ( 0 => $ table , 1 => array ( ) , 
static public function mapPrimaryKey ( $ path_or_tablefield , $ mode , & $ map , $ options = array ( ) ) { static $ xml_to_sql = array ( 'AccountRet' => array ( 'Account' , 'ListID' ) , 'AccountRet TaxLineInfoRet' => array ( 'Account_TaxLineInfo' , array ( 'Account_ListID' , 'TaxLineInfo_TaxLineID' ) ) , 'AccountRet DataExtRet' => array ( 'DataExt' , array ( 'EntityType' , 'TxnType' , 'Entity_ListID' , 'Txn_TxnID' ) ) , 'BillingRateRet' => array ( 'BillingRate' , 'ListID' ) , 'BillingRateRet BillingRatePerItemRet' => array ( 'BillingRate_BillingRatePerItem' , array ( 'BillingRate_ListID' , 'Item_ListID' ) ) , 'BillPaymentCheckRet' => array ( 'BillPaymentCheck' , 'TxnID' ) , 'BillPaymentCheckRet AppliedToTxnRet' => array ( 'BillPaymentCheck_AppliedToTxn' , array ( 'ToTxnID' , 'FromTxnID' ) ) , 'BillPaymentCheckRet DataExtRet' => array ( 'DataExt' , array ( 'EntityType' , 'TxnType' , 'Entity_ListID' , 'Txn_TxnID' ) ) , 'BillPaymentCreditCardRet' => array ( 'BillPaymentCreditCard' , 'TxnID' ) , 'BillPaymentCreditCardRet AppliedToTxnRet' => array ( 'BillPaymentCreditCard_AppliedToTxn' , array ( 'ToTxnID' , 'FromTxnID' ) ) , 'BillPaymentCreditCardRet DataExtRet' => array ( 'DataExt' , array ( 'EntityType' , 'TxnType' , 'Entity_ListID' , 'Txn_TxnID' ) ) , 'BillRet' => array ( 'Bill' , 'TxnID' ) , 'BillRet LinkedTxn' => array ( 'Bill_LinkedTxn' , array ( 'ToTxnID' , 'FromTxnID' ) ) , 'BillRet ExpenseLineRet' => array ( 'Bill_ExpenseLine' , array ( 'Bill_TxnID' , 'TxnLineID' ) ) , 'BillRet ItemLineRet' => array ( 'Bill_ItemLine' , array ( 'Bill_TxnID' , 'TxnLineID' ) ) , 'BillRet ItemGroupLineRet' => array ( 'Bill_ItemGroupLine' , array ( 'Bill_TxnID' , 'TxnLineID' ) ) , 'BillRet ItemGroupLineRet ItemLineRet' => array ( 'Bill_ItemGroupLine_ItemLine' , array ( 'Bill_TxnID' , 'Bill_ItemGroupLine_TxnLineID' , 'TxnLineID' ) ) , 'BillRet DataExtRet' => array ( 'DataExt' , array ( 'EntityType' , 'TxnType' , 'Entity_ListID' , 'Txn_TxnID' ) ) , 'BillToPayRet BillToPay' => array ( 'BillToPay' , 'TxnID' ) , 'BillToPayRet CreditToApply' => array ( 'CreditToApply' , 'TxnID' ) , 'BuildAssemblyRet' => array ( 'BuildAssembly' , 'TxnID' ) , 'ChargeRet' => array ( 'Charge' , 'TxnID' ) , 'ChargeRet DataExtRet' => array ( 'DataExt' , array ( 'EntityType' , 'TxnType' , 'Entity_ListID' , 'Txn_TxnID' ) ) , 'CheckRet' => array ( 'Check' , 'TxnID' ) , 'CheckRet ExpenseLineRet' => array ( 'Check_ExpenseLine' , array ( 'Check_TxnID' , 'TxnLineID' ) ) , 'CheckRet ItemLineRet' => array ( 'Check_ItemLine' , array ( 'Check_TxnID' , 'TxnLineID' ) ) , 'CheckRet ItemGroupLineRet' => array ( 'Check_ItemGroupLine' , array ( 'Check_TxnID' , 'TxnLineID' ) ) , 'CheckRet ItemGroupLineRet ItemLineRet' => array ( 'Check_ItemGroupLine_ItemLine' , array ( 'Check_TxnID' , 'Check_ItemGroupLine_TxnLineID' , 'TxnLineID' ) ) , 'CheckRet DataExtRet' => array ( 'DataExt' , array ( 'EntityType' , 'TxnType' , 'Entity_ListID' , 'Txn_TxnID' ) ) , 'CheckRet LinkedTxn' => array ( 'Check_LinkedTxn' , array ( 'ToTxnID' , 'FromTxnID' ) ) , 'ClassRet' => array ( 'Class' , 'ListID' ) , 'CompanyRet' => array ( 'Company' , 'CompanyName' ) , 'CompanyRet SubscribedServices Services' => array ( 'Company_SubscribedServices_Services' , array ( 'Company_CompanyName' , 'Name' ) ) , 'CompanyRet DataExtRet' => array ( 'DataExt' , array ( 'EntityType' , 'TxnType' , 'Entity_ListID' , 'Txn_TxnID' ) ) , 'HostRet' => array ( 'Host' , 'ProductName' ) , 'PreferencesRet' => array ( 'Preferences' , 'qbsql_external_id' ) , 'CreditCardChargeRet' => array ( 'CreditCardCharge' , 'TxnID' ) , 'CreditCardChargeRet ExpenseLineRet' => array ( 'CreditCardCharge_ExpenseLine' , array ( 'CreditCardCharge_TxnID' , 'TxnLineID' ) ) , 'CreditCardChargeRet ItemLineRet' => array ( 'CreditCardCharge_ItemLine' , array ( 'CreditCardCharge_TxnID' , 'TxnLineID' ) ) , 'CreditCardChargeRet ItemGroupLineRet' => array ( 'CreditCardCharge_ItemGroupLine' , array ( 'CreditCardCharge_TxnID' , 'TxnLineID' ) ) , 'CreditCardChargeRet ItemGroupLineRet ItemLineRet' => array ( 'CreditCardCharge_ItemGroupLine_ItemLine' , array ( 'CreditCardCharge_TxnID' , 'CreditCardCharge_ItemGroupLine_TxnLineID' , 'TxnLineID' ) ) , 'CreditCardChargeRet DataExtRet' => array ( 'DataExt' , array ( 'EntityType' , 'TxnType' , 'Entity_ListID' , 'Txn_TxnID' ) ) , 'CreditCardCreditRet' => array ( 'CreditCardCredit' , 'TxnID' ) , 'CreditCardCreditRet ExpenseLineRet' => array ( 'CreditCardCredit_ExpenseLine' , array ( 'CreditCardCredit_TxnID' , 'TxnLineID' ) ) , 'CreditCardCreditRet ItemLineRet' => array ( 'CreditCardCredit_ItemLine' , array ( 'CreditCardCredit_TxnID' , 'TxnLineID' ) ) , 'CreditCardCreditRet ItemGroupLineRet' => array ( 'CreditCardCredit_ItemGroupLine' , array ( 'CreditCardCredit_TxnID' , 'TxnLineID' ) ) , 'CreditCardCreditRet ItemGroupLineRet ItemLineRet' => array ( 'CreditCardCredit_ItemGroupLine_ItemLine' , array ( 'CreditCardCredit_TxnID' , 'CreditCardCredit_ItemGroupLine_TxnLineID' , 'TxnLineID' ) ) , 'CreditCardCreditRet DataExtRet' => array ( 'DataExt' , array ( 'EntityType' , 'TxnType' , 'Entity_ListID' , 'Txn_TxnID' ) ) , 'CreditMemoRet' => array ( 'CreditMemo' , 'TxnID' ) , 'CreditMemoRet CreditMemoLineRet' => array ( 'CreditMemo_CreditMemoLine' , array ( 'CreditMemo_TxnID' , 'TxnLineID' ) ) , 'CreditMemoRet CreditMemoLineGroupRet' => array ( 'CreditMemo_CreditMemoLineGroup' , array ( 'CreditMemo_TxnID' , 'TxnLineID' ) ) , 
static public function mapToSchema ( $ path_or_tablefield , $ mode , & $ map , & $ others , $ options = array ( ) ) { static $ xml_to_sql = array ( 'AccountRet' => array ( 'Account' , null ) , 'AccountRet ParentRef' => array ( null , null ) , 'AccountRet ParentRef *' => array ( 'Account' , 'Parent_*' ) , 'AccountRet TaxLineInfoRet' => array ( 'Account_TaxLineInfo' , null ) , array( 'InventoryAdjustment_InventoryAdjustmentLine', 'QuantityAdjustment_NewQuantity' ), array( 'InventoryAdjustment_InventoryAdjustmentLine', 'QuantityAdjustment_QuantityDifference' ), array( 'InventoryAdjustment_InventoryAdjustmentLine', 'ValueAdjustment_NewQuantity' ), array( 'InventoryAdjustment_InventoryAdjustmentLine', 'ValueAdjustment_QuantityDifference' ), array( 'InventoryAdjustment_InventoryAdjustmentLine', 'ValueAdjustment_NewValue' ), array( 'InventoryAdjustment_InventoryAdjustmentLine', 'ValueAdjustment_ValueDifference' ), */ ) , 'InvoiceRet InvoiceLineRet' => array ( array ( 'Invoice_InvoiceLine' , 'Invoice_TxnID' ) , array ( 'Invoice_InvoiceLine' , 'SortOrder' ) , ) , 'InvoiceRet InvoiceLineGroupRet' => array ( array ( 'Invoice_InvoiceLineGroup' , 'Invoice_TxnID' ) , array ( 'Invoice_InvoiceLineGroup' , 'SortOrder' ) , ) , 'InvoiceRet InvoiceLineGroupRet InvoiceLineRet' => array ( array ( 'Invoice_InvoiceLineGroup_InvoiceLine' , 'Invoice_TxnID' ) , array ( 'Invoice_InvoiceLineGroup_InvoiceLine' , 'Invoice_InvoiceLineGroup_TxnLineID' ) , array ( 'Invoice_InvoiceLineGroup_InvoiceLine' , 'SortOrder' ) , ) , 'InvoiceRet LinkedTxn' => array ( array ( 'Invoice_LinkedTxn' , 'FromTxnID' ) , array ( 'Invoice_LinkedTxn' , 'Invoice_TxnID' ) , array ( 'Invoice_LinkedTxn' , 'LinkType' ) , ) , 'ItemGroupRet ItemGroupLine' => array ( array ( 'ItemGroup_ItemGroupLine' , 'ItemGroup_ListID' ) , array ( 'ItemGroup_ItemGroupLine' , 'SortOrder' ) , ) , 'ItemInventoryAssemblyRet ItemInventoryAssemblyLine' => array ( array ( 'ItemInventoryAssembly_ItemInventoryAssemblyLine' , 'ItemInventoryAssembly_ListID' ) , array ( 'ItemInventoryAssembly_ItemInventoryAssemblyLine' , 'SortOrder' ) , ) , 'ItemReceiptRet ExpenseLineRet' => array ( array ( 'ItemReceipt_ExpenseLine' , 'ItemReceipt_TxnID' ) , array ( 'ItemReceipt_ExpenseLine' , 'SortOrder' ) , ) , 'ItemReceiptRet ItemLineRet' => array ( array ( 'ItemReceipt_ItemLine' , 'ItemReceipt_TxnID' ) , array ( 'ItemReceipt_ItemLine' , 'SortOrder' ) , ) , 'ItemReceiptRet ItemGroupLineRet' => array ( array ( 'ItemReceipt_ItemGroupLine' , 'ItemReceipt_TxnID' ) , array ( 'ItemReceipt_ItemGroupLine' , 'SortOrder' ) , ) , 'ItemReceiptRet ItemGroupLineRet ItemLineRet' => array ( array ( 'ItemReceipt_ItemGroupLine_ItemLine' , 'ItemReceipt_TxnID' ) , array ( 'ItemReceipt_ItemGroupLine_ItemLine' , 'ItemReceipt_ItemGroupLine_TxnLineID' ) , array ( 'ItemReceipt_ItemGroupLine_ItemLine' , 'SortOrder' ) , ) , 'ItemReceiptRet LinkedTxn' => array ( array ( 'ItemReceipt_LinkedTxn' , 'FromTxnID' ) , array ( 'ItemReceipt_LinkedTxn' , 'ItemReceipt_TxnID' ) , array ( 'ItemReceipt_LinkedTxn' , 'LinkType' ) , ) , 'ItemSalesTaxGroupRet ItemSalesTaxRef' => array ( array ( 'ItemSalesTaxGroup_ItemSalesTax' , 'ItemSalesTaxGroup_ListID' ) , ) , 'JournalEntryRet JournalDebitLine' => array ( array ( 'JournalEntry_JournalDebitLine' , 'JournalEntry_TxnID' ) , array ( 'JournalEntry_JournalDebitLine' , 'SortOrder' ) , ) , 'JournalEntryRet JournalCreditLine' => array ( array ( 'JournalEntry_JournalCreditLine' , 'JournalEntry_TxnID' ) , array ( 'JournalEntry_JournalCreditLine' , 'SortOrder' ) , ) , 'PriceLevelRet PriceLevelPerItemRet' => array ( array ( 'PriceLevel_PriceLevelPerItem' , 'PriceLevel_ListID' ) , ) , 'PurchaseOrderRet PurchaseOrderLineRet' => array ( array ( 'PurchaseOrder_PurchaseOrderLine' , 'PurchaseOrder_TxnID' ) , array ( 'PurchaseOrder_PurchaseOrderLine' , 'SortOrder' ) , ) , 'PurchaseOrderRet PurchaseOrderLineGroupRet' => array ( array ( 'PurchaseOrder_PurchaseOrderLineGroup' , 'PurchaseOrder_TxnID' ) , array ( 'PurchaseOrder_PurchaseOrderLineGroup' , 'SortOrder' ) , ) , 'PurchaseOrderRet PurchaseOrderLineGroupRet PurchaseOrderLineRet' => array ( array ( 'PurchaseOrder_PurchaseOrderLineGroup_PurchaseOrderLine' , 'PurchaseOrder_TxnID' ) , array ( 'PurchaseOrder_PurchaseOrderLineGroup_PurchaseOrderLine' , 'PurchaseOrder_PurchaseOrderLineGroup_TxnLineID' ) , array ( 'PurchaseOrder_PurchaseOrderLineGroup_PurchaseOrderLine' , 'SortOrder' ) , ) , 'PurchaseOrderRet LinkedTxn' => array ( array ( 'PurchaseOrder_LinkedTxn' , 'FromTxnID' ) , array ( 'PurchaseOrder_LinkedTxn' , 'PurchaseOrder_TxnID' ) , array ( 'PurchaseOrder_LinkedTxn' , 'LinkType' ) , ) , 'ReceivePaymentRet AppliedToTxnRet' => array ( array ( 'ReceivePayment_AppliedToTxn' , 'FromTxnID' ) , array ( 'ReceivePayment_AppliedToTxn' , 'ReceivePayment_TxnID' ) , ) , 'SalesOrderRet SalesOrderLineRet' => array ( array ( 'SalesOrder_SalesOrderLine' , 'SalesOrder_TxnID' ) , array ( 'SalesOrder_SalesOrderLine' , 'SortOrder' ) , ) , 'SalesOrderRet SalesOrderLineGroupRet' => array ( array ( 'SalesOrder_SalesOrderLineGroup' , 'SalesOrder_TxnID' ) , array ( 'SalesOrder_SalesOrderLineGroup' , 'SortOrder' ) , ) , 'SalesOrderRet SalesOrderLineGroupRet SalesOrderLineRet' => array ( array ( 'SalesOrder_SalesOrderLineGroup_SalesOrderLine' , 'SalesOrder_TxnID' ) , array ( 'SalesOrder_SalesOrderLineGroup_SalesOrderLine' , 'SalesOrder_SalesOrderLineGroup_TxnLineID' ) , array ( 'SalesOrder_SalesOrderLineGroup_SalesOrderLine' , 'SortOrder' ) , ) , 'SalesOrderRet LinkedTxn' => array ( array ( 'SalesOrder_LinkedTxn' , 'FromTxnID' ) , array ( 'SalesOrder_LinkedTxn' , 'SalesOrder_TxnID' ) , array ( 'SalesOrder_LinkedTxn' , 'LinkType' ) , ) , 'SalesReceiptRet SalesReceiptLineRet' => array ( array ( 'SalesReceipt_SalesReceiptLine' , 'SalesReceipt_TxnID' ) , array ( 'SalesReceipt_SalesReceiptLine' , 'SortOrder' ) , ) , 'SalesReceiptRet SalesReceiptLineGroupRet' => array ( array ( 'SalesReceipt_SalesReceiptLineGroup' , 'SalesReceipt_TxnID' ) , array ( 'SalesReceipt_SalesReceiptLineGroup' , 'SortOrder' ) , ) , 'SalesReceiptRet SalesReceiptLineGroupRet SalesReceiptLineRet' => array ( array ( 'SalesReceipt_SalesReceiptLineGroup_SalesReceiptLine' , 'SalesReceipt_TxnID' ) , array ( 'SalesReceipt_SalesReceiptLineGroup_SalesReceiptLine' , 'SalesReceipt_SalesReceiptLineGroup_TxnLineID' ) , array ( 'SalesReceipt_SalesReceiptLineGroup_SalesReceiptLine' , 'SortOrder' ) , ) , 'UnitOfMeasureSetRet RelatedUnit' => array ( array ( 'UnitOfMeasureSet_RelatedUnit' , 'UnitOfMeasureSet_ListID' ) , ) , 'UnitOfMeasureSetRet DefaultUnit' => array ( array ( 'UnitOfMeasureSet_DefaultUnit' , 'UnitOfMeasureSet_ListID' ) , ) , 'VendorCreditRet ExpenseLineRet' => array ( array ( 'VendorCredit_ExpenseLine' , 'VendorCredit_TxnID' ) , array ( 'VendorCredit_ExpenseLine' , 'SortOrder' ) , ) , 'VendorCreditRet ItemLineRet' => array ( array ( 'VendorCredit_ItemLine' , 'VendorCredit_TxnID' ) , array ( 'VendorCredit_ItemLine' , 'SortOrder' ) , ) , 'VendorCreditRet ItemGroupLineRet' => array ( array ( 'VendorCredit_ItemGroupLine' , 'VendorCredit_TxnID' ) , array ( 'VendorCredit_ItemGroupLine' , 'SortOrder' ) , ) , 'VendorCreditRet ItemGroupLineRet ItemLineRet' => array ( array ( 'VendorCredit_ItemGroupLine_ItemLine' , 'VendorCredit_TxnID' ) , array ( 'VendorCredit_ItemGroupLine_ItemLine' , 'VendorCredit_ItemGroupLine_TxnLineID' ) , array ( 'VendorCredit_ItemGroupLine_ItemLine' , 'SortOrder' ) , ) , 'VendorCreditRet LinkedTxn' => array ( array ( 'VendorCredit_LinkedTxn' , 'FromTxnID' ) , array ( 'VendorCredit_LinkedTxn' , 'VendorCredit_TxnID' ) , array ( 'VendorCredit_LinkedTxn' , 'LinkType' ) , ) , 'WorkersCompCodeRet RateHistory' => array ( array ( 'WorkersCompCode_RateHistory' , 'WorkersCompCode_ListID' ) , ) , ) ; if ( $ mode == QUICKBOOKS_SQL_SCHEMA_MAP_TO_SQL ) if ($options['uppercase_tables']) { $table_and_field[0] = strtoupper($table_and_field[0]); } else if ($options['lowercase_tables']) { $table_and_field[0] = strtolower($table_and_field[0]); } if ($options['uppercase_fields']) { $table_and_field[1] = strtoupper($table_and_field[1]); } else if ($options['lowercase_fields']) { $table_and_field[1] = strtolower($table_and_field[1]); } */ $ map = array ( $ table_and_field [ 0 ] , str_replace ( '*' , $ match , $ table_and_field [ 1 ] ) , ) ; QuickBooks_SQL_Schema :: _applyOptions ( $ map , QUICKBOOKS_SQL_SCHEMA_MAP_TO_SQL , $ options ) ; break ; } } } } else if ( $ pattern == $ path ) { $ map = $ table_and_field ; QuickBooks_SQL_Schema :: _applyOptions ( $ map , QUICKBOOKS_SQL_SCHEMA_MAP_TO_SQL , $ options ) ; if ( isset ( $ xml_to_sql_others [ $ pattern ] ) ) { $ others = $ xml_to_sql_others [ $ pattern ] ; foreach ( $ others as $ key => $ other ) { QuickBooks_SQL_Schema :: _applyOptions ( $ other , QUICKBOOKS_SQL_SCHEMA_MAP_TO_SQL , $ options ) ; $ others [ $ key ] = $ other ; } } break ; } } 
static public function mapFieldToSQLDefinition ( $ object_type , $ field , $ qb_type ) { { case 'invoice': switch ($field) { default: break; } default: switch ($field) { case 'isactive': $default = true; break; default: break; } break; }*/ 
static public function catchall ( $ requestID , $ user , $ action , $ ident , $ extra , & $ err , $ xml , $ errnum , $ errmsg , $ config ) { $ Driver = QuickBooks_Driver_Singleton :: getInstance ( ) ; $ ignore = array ( QUICKBOOKS_IMPORT_DELETEDTXNS => true , QUICKBOOKS_QUERY_DELETEDTXNS => true , QUICKBOOKS_IMPORT_DELETEDLISTS => true , QUICKBOOKS_QUERY_DELETEDLISTS => true , QUICKBOOKS_VOID_TRANSACTION => true , QUICKBOOKS_DELETE_TRANSACTION => true , QUICKBOOKS_DELETE_LIST => true , ) ; if ( isset ( $ ignore [ $ action ] ) ) { $Parser = new QuickBooks_XML($xml); $errnumTemp = 0; $errmsgTemp = ''; $Doc = $Parser->parse($errnumTemp, $errmsgTemp); $Root = $Doc->getRoot(); $emailStr = var_export($Root->children(), true); $List = $Root->getChildAt('QBXML QBXMLMsgsRs '.QuickBooks_Utilities::actionToResponse($action)); $Node = current($List->children()); */ $ map = array ( ) ; $ others = array ( ) ; QuickBooks_SQL_Schema :: mapToSchema ( trim ( QuickBooks_Utilities :: actionToXMLElement ( $ action ) ) , QUICKBOOKS_SQL_SCHEMA_MAP_TO_SQL , $ map , $ others ) ; $ object = new QuickBooks_SQL_Object ( $ map [ 0 ] , trim ( QuickBooks_Utilities :: actionToXMLElement ( $ action ) ) ) ; $ table = $ object -> table ( ) ; $ existing = null ; if ( $ table and is_numeric ( $ ident ) ) { $ multipart = array ( QUICKBOOKS_DRIVER_SQL_FIELD_ID => $ ident ) ; $ existing = $ Driver -> get ( QUICKBOOKS_DRIVER_SQL_PREFIX_SQL . $ table , $ multipart ) ; } switch ( $ errnum ) { case 1 : UPDATE " . QUICKBOOKS_DRIVER_SQL_PREFIX_SQL . "receivepayment_appliedtotxn SET qbsql_to_skip = 1 WHERE ReceivePayment_TxnID = '%s' " , $ db_errnum , $ db_errmsg , null , null , array ( $ existing [ 'TxnID' ] ) ) ; return true ; } break ; case 3250 : // This feature is not enabled or not available in this version of QuickBooks. // Do nothing (this can be safely ignored) return true ; case 3260 : // Insufficient permission level to perform this action. case 3261 : // The integrated application has no permission to ac... // There's nothing we can do about this, if they don't grant the user permission, just skip it return true ; case 3100 : // Name of List Element is already in use. break ; case '0x8004040D' : // The ticket parameter is invalid (how does this happen!?!) return true ; } // This is our catch-all which marks the item as errored out if ( strstr ( $ xml , 'statusSeverity="Info"' ) === false ) // If it's NOT just an Info message. { $ multipart = array ( QUICKBOOKS_DRIVER_SQL_FIELD_ID => $ ident ) ; $ object -> set ( QUICKBOOKS_DRIVER_SQL_FIELD_ERROR_NUMBER , $ errnum ) ; $ object -> set ( QUICKBOOKS_DRIVER_SQL_FIELD_ERROR_MESSAGE , $ errmsg ) ; 
public function getTimeCreated ( $ format = null ) { if ( ! is_null ( $ format ) ) { return date ( $ format , strtotime ( $ this -> get ( 'TimeCreated' ) ) ) ; } return $ this -> get ( 'TimeCreated' ) ; } 
public function getTimeModified ( $ format = null ) { if ( ! is_null ( $ format ) ) { return date ( $ format , strtotime ( $ this -> get ( 'TimeModified' ) ) ) ; } return $ this -> get ( 'TimeModified' ) ; } 
public function set ( $ key , $ value , $ cast = true ) { if ( is_array ( $ value ) ) { $ this -> _object [ $ key ] = $ value ; } else { 
public function get ( $ key , $ default = null ) { if ( isset ( $ this -> _object [ $ key ] ) ) { return $ this -> _object [ $ key ] ; } return $ default ; } 
public function getFullNameType ( $ fullname_key , $ name_key , $ parent_key , $ default = null ) { $ fullname = $ this -> get ( $ fullname_key ) ; if ( ! $ fullname ) { $ name = $ this -> get ( $ name_key ) ; $ parent = $ this -> get ( $ parent_key ) ; if ( $ name and $ parent ) { $ fullname = $ parent . ':' . $ name ; } else { $ fullname = $ name ; } } return $ fullname ; } 
public function setFullNameType ( $ fullname_key , $ name_key , $ parent_key , $ value ) { if ( false !== strpos ( $ value , ':' ) ) { if ( $ name_key and $ parent_key ) { 
public function setBooleanType ( $ key , $ value ) { 
public function setDateType ( $ key , $ date , $ dont_allow_19691231 = true ) { if ( $ date == '1969-12-31' and $ dont_allow_19691231 ) { return false ; } if ( ! strlen ( $ date ) or $ date == '0' ) { return false ; } 
public function getDateType ( $ key , $ format = 'Y-m-d' ) { if ( ! strlen ( $ format ) ) { $ format = 'Y-m-d' ; } if ( $ this -> exists ( $ key ) and $ this -> get ( $ key ) ) { return date ( $ format , strtotime ( $ this -> get ( $ key ) ) ) ; } return null ; } 
public function remove ( $ key ) { if ( isset ( $ this -> _object [ $ key ] ) ) { unset ( $ this -> _object [ $ key ] ) ; return true ; } return false ; } 
protected function _schema ( $ request ) { if ( strtolower ( substr ( $ request , - 2 , 2 ) ) != 'rq' ) { $ request = $ request . 'Rq' ; } $ class = 'QuickBooks_QBXML_Schema_Object_' . $ request ; $ file = 'QuickBooks/QBXML/Schema/Object/' . $ request . '.php' ; include_once $ file ; if ( class_exists ( $ class ) ) { return new $ class ( ) ; } return false ; } 
public function asXML ( $ root = null , $ parent = null , $ object = null ) { if ( is_null ( $ root ) ) { $ root = $ this -> object ( ) ; } if ( is_null ( $ object ) ) { $ object = $ this -> _object ; } $ Node = new QuickBooks_XML_Node ( $ root ) ; foreach ( $ object as $ key => $ value ) { if ( is_array ( $ value ) ) { $ Node -> setChildDataAt ( $ root . ' ' . $ key , '' , true ) ; foreach ( $ value as $ sub ) { 
public function asQBXML ( $ request , $ version = null , $ locale = null , $ root = null ) { $ todo_for_empty_elements = QuickBooks_XML :: XML_DROP ; $ indent = "\t" ; 
static public function fromXML ( $ XML , $ action_or_object = null ) { if ( ! $ action_or_object or $ action_or_object == QUICKBOOKS_QUERY_ITEM ) { $ action_or_object = $ XML -> name ( ) ; } $ type = QuickBooks_Utilities :: actionToObject ( $ action_or_object ) ; $ exceptions = array ( QUICKBOOKS_OBJECT_SERVICEITEM => 'ServiceItem' , QUICKBOOKS_OBJECT_INVENTORYITEM => 'InventoryItem' , QUICKBOOKS_OBJECT_NONINVENTORYITEM => 'NonInventoryItem' , QUICKBOOKS_OBJECT_DISCOUNTITEM => 'DiscountItem' , QUICKBOOKS_OBJECT_FIXEDASSETITEM => 'FixedAssetItem' , QUICKBOOKS_OBJECT_GROUPITEM => 'GroupItem' , QUICKBOOKS_OBJECT_OTHERCHARGEITEM => 'OtherChargeItem' , QUICKBOOKS_OBJECT_SALESTAXITEM => 'SalesTaxItem' , QUICKBOOKS_OBJECT_SALESTAXGROUPITEM => 'SalesTaxGroupItem' , QUICKBOOKS_OBJECT_SUBTOTALITEM => 'SubtotalItem' , QUICKBOOKS_OBJECT_INVENTORYASSEMBLYITEM => 'InventoryAssemblyItem' , ) ; if ( isset ( $ exceptions [ $ type ] ) ) { $ type = $ exceptions [ $ type ] ; } 
static public function fromQBXML ( $ qbxml , $ action_or_object = null ) { $ errnum = null ; $ errmsg = null ; $ Parser = new QuickBooks_XML_Parser ( $ qbxml ) ; if ( $ Doc = $ Parser -> parse ( $ errnum , $ errmsg ) ) { $ XML = $ Doc -> getRoot ( ) ; return QuickBooks_QBXML_Object :: fromXML ( $ XML , $ action_or_object ) ; } return false ; } 
protected function _initialized ( ) { $ required = array ( SELECT table_name AS name FROM INFORMATION_SCHEMA.Tables WHERE TABLE_TYPE = 'BASE TABLE' " , $ errnum , $ errmsg ) ; while ( $ arr = $ this -> _fetch ( $ res ) ) { $ table = current ( $ arr ) ; if ( isset ( $ required [ $ table ] ) ) { $ required [ $ table ] = true ; } } foreach ( $ required as $ table => $ exists ) { if ( ! $ exists ) { return false ; } } return true ; } 
protected function _connect ( $ host , $ port , $ user , $ pass , $ db , $ new_link , $ client_flags ) { mssql_min_message_severity ( QUICKBOOKS_DRIVER_SQL_MSSQL_MESSAGE_LEVEL ) ; mssql_min_error_severity ( QUICKBOOKS_DRIVER_SQL_MSSQL_ERROR_LEVEL ) ; if ( $ port ) { $ this -> _conn = mssql_connect ( $ host , $ user , $ pass , $ new_link ) or die ( 'host: ' . $ host . ', user: ' . $ user . ', pass: ' . $ pass . ' mysql_error(): ' . mssql_get_last_message ( ) ) ; } else { $ this -> _conn = mssql_connect ( $ host . ':' . $ port , $ user , $ pass , $ new_link ) or die ( 'host: ' . $ host . ', user: ' . $ user . ', pass: ' . $ pass . ' mysql_error(): ' . mssql_get_last_message ( ) ) ; } return mssql_select_db ( $ db , $ this -> _conn ) ; } 
protected function _fetch ( $ res ) { $ arr = mssql_fetch_assoc ( $ res ) ; 
protected function _query ( $ sql , & $ errnum , & $ errmsg , $ offset = 0 , $ limit = null ) { if ( $ limit ) { $ sql = str_replace ( array ( "SELECT " , "SELECT\n" , "SELECT\r" ) , 'SELECT TOP ' . ( int ) $ limit . ' ' . "\n" , $ sql ) ; if ( $ offset ) { } else { } } else if ( $ offset ) { 
public function last ( ) { $ errnum = 0 ; $ errmsg = null ; if ( $ res = $ this -> _query ( "SELECT SCOPE_IDENTITY() AS last_insert_id" ) ) { $ arr = $ this -> _fetch ( $ res ) ; return $ arr [ 'last_insert_id' ] ; } return 0 ; } 
protected function _generateFieldSchema ( $ name , $ def ) { $ sql = '' ; switch ( $ def [ 0 ] ) { case QUICKBOOKS_DRIVER_SQL_SERIAL : $ sql = $ name . ' integer NOT NULL IDENTITY(1, 1) ' ; { print('LIST ID:'); print_r($def); }*/ if ( ! empty ( $ def [ 1 ] ) ) { $ sql .= '(' . ( int ) $ def [ 1 ] . ') ' ; } if ( isset ( $ def [ 2 ] ) ) { if ( strtolower ( $ def [ 2 ] ) == 'null' ) { $ sql .= ' NULL ' ; } else if ( $ def [ 2 ] === false ) { $ sql .= ' NOT NULL ' ; } else { $ sql .= " NOT NULL DEFAULT '" . $ def [ 2 ] . "' " ; } } else { $ sql .= ' NOT NULL ' ; } return $ sql ; case QUICKBOOKS_DRIVER_SQL_CHAR : $ sql = $ name . ' CHAR' ; if ( ! empty ( $ def [ 1 ] ) ) { $ sql .= '(' . ( int ) $ def [ 1 ] . ') ' ; } if ( isset ( $ def [ 2 ] ) ) { if ( strtolower ( $ def [ 2 ] ) == 'null' ) { $ sql .= ' NULL ' ; } else { $ sql .= " NOT NULL DEFAULT '" . $ def [ 2 ] . "' " ; } } else { $ sql .= ' NOT NULL ' ; } return $ sql ; case QUICKBOOKS_DRIVER_SQL_TEXT : $ sql = $ name . ' TEXT ' ; if ( isset ( $ def [ 2 ] ) ) { if ( strtolower ( $ def [ 2 ] ) == 'null' ) { $ sql .= ' NULL ' ; } else { $ sql .= " NOT NULL DEFAULT '" . $ def [ 2 ] . "' " ; } } else { $ sql .= ' NOT NULL ' ; } return $ sql ; case QUICKBOOKS_DRIVER_SQL_INTEGER : $ sql = $ name . ' INTEGER ' ; if ( isset ( $ def [ 2 ] ) ) { if ( strtolower ( $ def [ 2 ] ) == 'null' ) { $ sql .= ' NULL ' ; } else { $ sql .= ' DEFAULT ' . ( int ) $ def [ 2 ] ; } } return $ sql ; case QUICKBOOKS_DRIVER_SQL_BOOLEAN : $ sql = $ name . ' tinyint ' ; if ( isset ( $ def [ 2 ] ) ) { if ( strtolower ( $ def [ 2 ] ) == 'null' ) { $ sql .= ' NULL ' ; } else if ( $ def [ 2 ] ) { $ sql .= ' DEFAULT 1 ' ; } else { $ sql .= ' DEFAULT 0 ' ; } } return $ sql ; default : return parent :: _generateFieldSchema ( $ name , $ def ) ; } } 
protected function _mapTableName ( $ table ) { switch ( $ table ) { case QUICKBOOKS_DRIVER_SQL_LOGTABLE : return QUICKBOOKS_DRIVER_SQL_MSSQL_PREFIX . QUICKBOOKS_DRIVER_SQL_MSSQL_LOGTABLE ; case QUICKBOOKS_DRIVER_SQL_QUEUETABLE : return QUICKBOOKS_DRIVER_SQL_MSSQL_PREFIX . QUICKBOOKS_DRIVER_SQL_MSSQL_QUEUETABLE ; case QUICKBOOKS_DRIVER_SQL_RECURTABLE : return QUICKBOOKS_DRIVER_SQL_MSSQL_PREFIX . QUICKBOOKS_DRIVER_SQL_MSSQL_RECURTABLE ; case QUICKBOOKS_DRIVER_SQL_TICKETTABLE : return QUICKBOOKS_DRIVER_SQL_MSSQL_PREFIX . QUICKBOOKS_DRIVER_SQL_MSSQL_TICKETTABLE ; case QUICKBOOKS_DRIVER_SQL_USERTABLE : return QUICKBOOKS_DRIVER_SQL_MSSQL_PREFIX . QUICKBOOKS_DRIVER_SQL_MSSQL_USERTABLE ; case QUICKBOOKS_DRIVER_SQL_CONFIGTABLE : return QUICKBOOKS_DRIVER_SQL_MSSQL_PREFIX . QUICKBOOKS_DRIVER_SQL_MSSQL_CONFIGTABLE ; case QUICKBOOKS_DRIVER_SQL_IDENTTABLE : return QUICKBOOKS_DRIVER_SQL_MSSQL_PREFIX . QUICKBOOKS_DRIVER_SQL_MSSQL_IDENTTABLE ; case QUICKBOOKS_DRIVER_SQL_NOTIFYTABLE : return QUICKBOOKS_DRIVER_SQL_MSSQL_PREFIX . QUICKBOOKS_DRIVER_SQL_MSSQL_NOTIFYTABLE ; case QUICKBOOKS_DRIVER_SQL_CONNECTIONTABLE : return QUICKBOOKS_DRIVER_SQL_MSSQL_PREFIX . QUICKBOOKS_DRIVER_SQL_MSSQL_CONNECTIONTABLE ; case QUICKBOOKS_DRIVER_SQL_OAUTHTABLE : return QUICKBOOKS_DRIVER_SQL_MSSQL_PREFIX . QUICKBOOKS_DRIVER_SQL_MSSQL_OAUTHTABLE ; default : return $ table ; } } 
public function asList ( $ request ) { switch ( $ request ) { case 'ReceivePaymentAddRq' : if ( isset ( $ this -> _object [ 'AppliedToTxn' ] ) ) { $ this -> _object [ 'AppliedToTxnAdd' ] = $ this -> _object [ 'AppliedToTxn' ] ; } break ; case 'ReceivePaymentModRq' : if ( isset ( $ this -> _object [ 'AppliedToTxn' ] ) ) { $ this -> _object [ 'AppliedToTxnMod' ] = $ this -> _object [ 'AppliedToTxn' ] ; } break ; } return parent :: asList ( $ request ) ; } 
public function add ( $ Context , $ realmID , $ Object ) { return parent :: _add ( $ Context , $ realmID , QuickBooks_IPP_IDS :: RESOURCE_DEPARTMENT , $ Object ) ; } 
public function getName ( ) { if ( ! $ this -> exists ( 'Name' ) ) { if ( ! is_null ( $ this -> getFirstName ( ) ) || ! is_null ( $ this -> getLastName ( ) ) ) { $ this -> setNameAsFirstLast ( ) ; } } return $ this -> get ( 'Name' ) ; } 
public function setFullName ( $ name ) { if ( is_null ( $ name ) ) { $ name = $ this -> getName ( ) ; } $ this -> set ( 'FullName' , $ name ) ; } 
public function setNameAsFirstLast ( ) { $ first = $ this -> getFirstName ( ) ; $ last = $ this -> getLastName ( ) ; if ( is_null ( $ first ) ) { $ first = '' ; } if ( is_null ( $ last ) ) { $ last = '' ; } return $ this -> set ( 'Name' , $ first . ' ' . $ last ) ; } 
public function add ( $ Context , $ realmID , $ Object ) { return parent :: _add ( $ Context , $ realmID , QuickBooks_IPP_IDS :: RESOURCE_ITEMCONSOLIDATED , $ Object ) ; } 
public function setOverrideItemAccountApplicationID ( $ value ) { return $ this -> set ( 'OverrideItemAccountRef ' . QUICKBOOKS_API_APPLICATIONID , $ this -> encodeApplicationID ( QUICKBOOKS_OBJECT_OVERRIDEITEMACCOUNT , QUICKBOOKS_LISTID , $ value ) ) ; } 
protected function _sqlDefaults ( $ config ) { $ tmp = array ( 
public function setPayeeEntityApplicationID ( $ value ) { return $ this -> set ( 'PayeeEntityRef ' . QUICKBOOKS_API_APPLICATIONID , $ this -> encodeApplicationID ( QUICKBOOKS_OBJECT_VENDOR , QUICKBOOKS_LISTID , $ value ) ) ; } 
public function status ( $ user = null , $ levels = array ( ) ) { $ Driver = $ this -> _driver ; if ( ! $ user ) { $ user = $ Driver -> authDefault ( ) ; } if ( ! count ( $ levels ) ) { $ levels = array ( 60 * 60 * 12 => array ( QuickBooks_Status_Report :: STATUS_NOTICE , 'Notice: A connection has not been made in %d days, %d hours and %d minutes.' ) , 60 * 60 * 24 => array ( QuickBooks_Status_Report :: STATUS_CAUTION , 'Caution: A connection has not been made in %d days, %d hours and %d minutes.' ) , 60 * 60 * 36 => array ( QuickBooks_Status_Report :: STATUS_WARNING , 'Warning! A connection has not been made in %d days, %d hours and %d minutes.' ) , 60 * 60 * 48 => array ( QuickBooks_Status_Report :: STATUS_DANGER , 'DANGER! A connection has not been made in %d days, %d hours and %d minutes! Contact support to get this issue resolved!' ) , ) ; } if ( ! isset ( $ levels [ 0 ] ) ) { $ levels [ 0 ] = array ( QuickBooks_Status_Report :: STATUS_OK , 'Status is OK. Last connection made %d days, %d hours, and %d minutes ago.' ) ; } if ( ! isset ( $ levels [ - 1 ] ) ) { $ levels [ - 1 ] = array ( QuickBooks_Status_Report :: STATUS_UNKNOWN , 'Status is unknown.' ) ; } 
public function delete ( $ Context , $ realmID , $ IDType ) { return parent :: _delete ( $ Context , $ realmID , QuickBooks_IPP_IDS :: RESOURCE_PURCHASEORDER , $ IDType ) ; } 
protected function _read ( $ mixed ) { if ( empty ( $ mixed ) ) { return '' ; } else if ( is_resource ( $ mixed ) and get_resource_type ( $ mixed ) == 'stream' ) { $ buffer = '' ; $ tmp = '' ; while ( $ tmp = fread ( $ mixed , 8192 ) ) { $ buffer .= $ tmp ; } return $ buffer ; } else if ( substr ( trim ( $ mixed ) , 0 , 6 ) == '{"warn' ) { 
public function load ( $ xml_or_file ) { $ xml_or_file = $ this -> _read ( $ xml_or_file ) ; $ this -> _xml = $ xml_or_file ; return $ this -> _backend -> load ( $ xml_or_file ) ; } 
public function parse ( & $ errnum , & $ errmsg ) { if ( ! strlen ( $ this -> _xml ) ) { $ errnum = QuickBooks_XML :: ERROR_CONTENT ; $ errmsg = 'No XML content to parse.' ; return false ; } 
public function asQBXML ( $ request , $ version = null , $ locale = null , $ root = null ) { return parent :: asQBXML ( $ request , $ version , $ locale , $ root ) ; } 
protected function _connect ( $ host , $ port , $ user , $ pass , $ db , $ new_link , $ client_flags = null ) { $ this -> _schema = null ; $ tmp = array ( ) ; if ( $ host ) { $ tmp [ ] = 'host=' . $ host ; } if ( ( int ) $ port ) { $ tmp [ ] = 'port=' . ( int ) $ port ; } if ( $ user ) { $ tmp [ ] = 'user=' . $ user ; } if ( $ pass ) { $ tmp [ ] = 'password=' . $ pass ; } if ( $ db ) { if ( false !== strpos ( $ db , '.' ) ) { $ explode = explode ( '.' , $ db ) ; 
protected function _fetch ( $ res , $ print = false ) { $ arr = pg_fetch_assoc ( $ res ) ; $ booleans = array ( QUICKBOOKS_DRIVER_SQL_FIELD_TO_SYNC , QUICKBOOKS_DRIVER_SQL_FIELD_TO_VOID , QUICKBOOKS_DRIVER_SQL_FIELD_TO_DELETE , QUICKBOOKS_DRIVER_SQL_FIELD_TO_SKIP , QUICKBOOKS_DRIVER_SQL_FIELD_FLAG_SKIPPED , QUICKBOOKS_DRIVER_SQL_FIELD_FLAG_DELETED , QUICKBOOKS_DRIVER_SQL_FIELD_FLAG_VOIDED ) ; if ( $ arr ) { foreach ( $ arr as $ key => $ value ) { if ( in_array ( $ key , $ booleans ) ) { if ( $ value == 'f' ) { $ value = false ; } else if ( $ value == 't' ) { $ value = true ; } else { $ value = null ; } $ arr [ $ key ] = $ value ; } } } if ( is_array ( $ arr ) ) { reset ( $ arr ) ; } return $ arr ; } 
protected function _query ( $ sql , & $ errnum , & $ errmsg , $ offset = 0 , $ limit = null ) { if ( strtoupper ( substr ( trim ( $ sql ) , 0 , 6 ) ) != 'UPDATE' ) { 
public function last ( ) { $ errnum = 0 ; $ errmsg = '' ; pg_attribute.attname, format_type(pg_attribute.atttypid, pg_attribute.atttypmod) FROM pg_index, pg_class, pg_attribute WHERE pg_class.oid = '" . $ this -> last_insert_table . "'::regclass AND indrelid = pg_class.oid AND pg_attribute.attrelid = pg_class.oid AND pg_attribute.attnum = any(pg_index.indkey) AND indisprimary" ; $ res = $ this -> query ( $ sql , $ errnum , $ errmsg ) ; $ sequence = pg_fetch_result ( $ res , 0 , 0 ) ; // get the last ID $ sql = "select currval(pg_get_serial_sequence('" . $ this -> last_insert_table . "', '" . $ sequence . "'));" ; $ res = $ this -> query ( $ sql , $ errnum , $ errmsg ) ; $ last_insert_id = pg_fetch_result ( $ res , 0 , 0 ) ; return $ last_insert_id ; } 
protected function _mapTableName ( $ table ) { switch ( $ table ) { case QUICKBOOKS_DRIVER_SQL_LOGTABLE : return QUICKBOOKS_DRIVER_SQL_PGSQL_PREFIX . QUICKBOOKS_DRIVER_SQL_PGSQL_LOGTABLE ; case QUICKBOOKS_DRIVER_SQL_QUEUETABLE : return QUICKBOOKS_DRIVER_SQL_PGSQL_PREFIX . QUICKBOOKS_DRIVER_SQL_PGSQL_QUEUETABLE ; case QUICKBOOKS_DRIVER_SQL_RECURTABLE : return QUICKBOOKS_DRIVER_SQL_PGSQL_PREFIX . QUICKBOOKS_DRIVER_SQL_PGSQL_RECURTABLE ; case QUICKBOOKS_DRIVER_SQL_TICKETTABLE : return QUICKBOOKS_DRIVER_SQL_PGSQL_PREFIX . QUICKBOOKS_DRIVER_SQL_PGSQL_TICKETTABLE ; case QUICKBOOKS_DRIVER_SQL_USERTABLE : return QUICKBOOKS_DRIVER_SQL_PGSQL_PREFIX . QUICKBOOKS_DRIVER_SQL_PGSQL_USERTABLE ; case QUICKBOOKS_DRIVER_SQL_CONFIGTABLE : return QUICKBOOKS_DRIVER_SQL_PGSQL_PREFIX . QUICKBOOKS_DRIVER_SQL_PGSQL_CONFIGTABLE ; case QUICKBOOKS_DRIVER_SQL_IDENTTABLE : return QUICKBOOKS_DRIVER_SQL_PGSQL_PREFIX . QUICKBOOKS_DRIVER_SQL_PGSQL_IDENTTABLE ; case QUICKBOOKS_DRIVER_SQL_NOTIFYTABLE : return QUICKBOOKS_DRIVER_SQL_PGSQL_PREFIX . QUICKBOOKS_DRIVER_SQL_PGSQL_NOTIFYTABLE ; case QUICKBOOKS_DRIVER_SQL_CONNECTIONTABLE : return QUICKBOOKS_DRIVER_SQL_PGSQL_PREFIX . QUICKBOOKS_DRIVER_SQL_PGSQL_CONNECTIONTABLE ; default : return QUICKBOOKS_DRIVER_SQL_PGSQL_PREFIX . $ table ; } } 
protected function _generateFieldSchema ( $ name , $ def ) { switch ( $ def [ 0 ] ) { case QUICKBOOKS_DRIVER_SQL_INTEGER : $ sql = '"' . $ name . '" INTEGER ' ; if ( isset ( $ def [ 2 ] ) ) { if ( strtolower ( $ def [ 2 ] ) == 'null' ) { $ sql .= ' DEFAULT NULL ' ; } else { $ sql .= ' DEFAULT ' . ( int ) $ def [ 2 ] ; } } break ; case QUICKBOOKS_DRIVER_SQL_DECIMAL : $ sql = '"' . $ name . '" DECIMAL ' ; if ( ! empty ( $ def [ 1 ] ) ) { $ tmp = explode ( ',' , $ def [ 1 ] ) ; if ( count ( $ tmp ) == 2 ) { $ sql .= '(' . ( int ) $ tmp [ 0 ] . ',' . ( int ) $ tmp [ 1 ] . ') ' ; } } if ( isset ( $ def [ 2 ] ) ) { if ( strtolower ( $ def [ 2 ] ) == 'null' ) { $ sql .= ' NULL ' ; } else { if ( isset ( $ tmp ) and count ( $ tmp ) == 2 ) { $ sql .= ' DEFAULT ' . sprintf ( '%01.' . ( int ) $ tmp [ 1 ] . 'f' , ( float ) $ def [ 2 ] ) ; } else { $ sql .= ' DEFAULT ' . sprintf ( '%01.2f' , ( float ) $ def [ 2 ] ) ; } } } if ( isset ( $ tmp ) ) { unset ( $ tmp ) ; } break ; case QUICKBOOKS_DRIVER_SQL_FLOAT : $ sql = '"' . $ name . '" FLOAT ' ; if ( isset ( $ def [ 2 ] ) ) { if ( strtolower ( $ def [ 2 ] ) == 'null' ) { $ sql .= ' NULL ' ; } else { $ sql .= ' DEFAULT ' . sprintf ( '%01.2f' , ( float ) $ def [ 2 ] ) ; } } break ; case QUICKBOOKS_DRIVER_SQL_BOOLEAN : $ sql = '"' . $ name . '" BOOLEAN ' ; if ( isset ( $ def [ 2 ] ) ) { if ( strtolower ( $ def [ 2 ] ) == 'null' ) { $ sql .= ' DEFAULT NULL ' ; } else if ( $ def [ 2 ] ) { $ sql .= ' DEFAULT TRUE ' ; } else { $ sql .= ' DEFAULT FALSE ' ; } } else { $ sql .= ' NOT NULL ' ; } break ; case QUICKBOOKS_DRIVER_SQL_SERIAL : $ sql = '"' . $ name . '" SERIAL NOT NULL ' ; $sql = $name . ' tinyint(1) '; if (isset($def[2])) { if (strtolower($def[2]) == 'null') { $sql .= ' DEFAULT NULL '; } else if ($def[2]) { $sql .= ' DEFAULT 1 '; } else { $sql .= ' DEFAULT 0 '; } } return $sql;*/ case QUICKBOOKS_DRIVER_SQL_VARCHAR : $ sql = '"' . $ name . '" VARCHAR' ; if ( ! empty ( $ def [ 1 ] ) ) { $ sql .= '(' . ( int ) $ def [ 1 ] . ') ' ; } if ( isset ( $ def [ 2 ] ) ) { if ( strtolower ( $ def [ 2 ] ) == 'null' ) { $ sql .= ' DEFAULT NULL ' ; } else if ( $ def [ 2 ] === false ) { $ sql .= ' NOT NULL ' ; } else { $ sql .= " NOT NULL DEFAULT '" . $ def [ 2 ] . "' " ; } } else { $ sql .= ' NOT NULL ' ; } break ; case QUICKBOOKS_DRIVER_SQL_CHAR : $ sql = '"' . $ name . '" CHAR' ; if ( ! empty ( $ def [ 1 ] ) ) { $ sql .= '(' . ( int ) $ def [ 1 ] . ') ' ; } if ( isset ( $ def [ 2 ] ) ) { if ( strtolower ( $ def [ 2 ] ) == 'null' ) { $ sql .= ' DEFAULT NULL ' ; } else { $ sql .= " NOT NULL DEFAULT '" . $ def [ 2 ] . "' " ; } } else { $ sql .= ' NOT NULL ' ; } break ; default : case QUICKBOOKS_DRIVER_SQL_TEXT : $ sql = '"' . $ name . '" TEXT ' ; if ( isset ( $ def [ 2 ] ) ) { if ( strtolower ( $ def [ 2 ] ) == 'null' ) { $ sql .= ' DEFAULT NULL ' ; } else { $ sql .= " NOT NULL DEFAULT '" . $ def [ 2 ] . "' " ; } } else { $ sql .= ' NOT NULL ' ; } break ; } return $ sql ; } 
public function insert ( $ table , $ object , $ discov_and_resync = true ) { $ this -> last_insert_table = $ table ; return parent :: insert ( $ table , $ object , $ discov_and_resync ) ; } 
public function encrypt ( $ key , $ data , $ hex = false ) { if ( $ hex ) { $ key = pack ( 'H*' , $ key ) ; } $ keys [ ] = '' ; $ boxs [ ] = '' ; $ cipher = '' ; $ key_length = strlen ( $ key ) ; $ data_length = strlen ( $ data ) ; for ( $ i = 0 ; $ i < 256 ; $ i ++ ) { $ keys [ $ i ] = ord ( $ key [ $ i % $ key_length ] ) ; $ boxs [ $ i ] = $ i ; } $ j = 0 ; for ( $ i = 0 ; $ i < 256 ; $ i ++ ) { $ j = ( $ j + $ boxs [ $ i ] + $ keys [ $ i ] ) % 256 ; $ tmp = $ boxs [ $ i ] ; $ boxs [ $ i ] = $ boxs [ $ j ] ; $ boxs [ $ j ] = $ tmp ; } $ a = 0 ; $ j = 0 ; for ( $ i = 0 ; $ i < $ data_length ; $ i ++ ) { $ a = ( $ a + 1 ) % 256 ; $ j = ( $ j + $ boxs [ $ a ] ) % 256 ; $ tmp = $ boxs [ $ a ] ; $ boxs [ $ a ] = $ boxs [ $ j ] ; $ boxs [ $ j ] = $ tmp ; $ k = $ boxs [ ( ( $ boxs [ $ a ] + $ boxs [ $ j ] ) % 256 ) ] ; $ cipher .= chr ( ord ( $ data [ $ i ] ) ^ $ k ) ; } return $ cipher ; } 
public function delete ( $ Context , $ realmID , $ IDType ) { return parent :: _delete ( $ Context , $ realmID , QuickBooks_IPP_IDS :: RESOURCE_TIMEACTIVITY , $ IDType ) ; } 
static public function e1_notfound ( $ requestID , $ user , $ action , $ ident , $ extra , & $ err , $ xml , $ errnum , $ errmsg , $ config ) { return QuickBooks_Callbacks_API_Errors :: e500_notfound ( $ requestID , $ user , $ action , $ ident , $ extra , $ err , $ xml , $ errnum , $ errmsg , $ config ) ; } 
static public function e500_notfound ( $ requestID , $ user , $ action , $ ident , $ extra , & $ err , $ xml , $ errnum , $ errmsg , $ config ) { $extra['callbacks'], $method, $action, $ID, $err, $qbxml, $qbobject, $qbres */ 
protected function _ticketResolve ( $ ticket ) { static $ cache = array ( ) ; if ( ! $ ticket ) { return 0 ; } $ errnum = 0 ; $ errmsg = '' ; if ( isset ( $ cache [ $ ticket ] ) ) { return $ cache [ $ ticket ] ; } else if ( $ arr = $ this -> _fetch ( $ this -> _query ( " SELECT quickbooks_ticket_id FROM " . $ this -> _mapTableName ( QUICKBOOKS_DRIVER_SQL_TICKETTABLE ) . " WHERE ticket = '" . $ this -> _escape ( $ ticket ) . "' " , $ errnum , $ errmsg , 0 , 1 ) ) ) { $ cache [ $ ticket ] = $ arr [ 'quickbooks_ticket_id' ] ; return $ arr [ 'quickbooks_ticket_id' ] ; } return 0 ; } 
protected function _configWrite ( $ user , $ module , $ key , $ value , $ type , $ opts ) { $ errnum = 0 ; $ errmsg = '' ; if ( $ arr = $ this -> _fetch ( $ this -> _query ( " SELECT quickbooks_config_id FROM " . $ this -> _mapTableName ( QUICKBOOKS_DRIVER_SQL_CONFIGTABLE ) . " WHERE qb_username = '" . $ this -> _escape ( $ user ) . "' AND module = '" . $ this -> _escape ( $ module ) . "' AND cfgkey = '" . $ this -> _escape ( $ key ) . "' " , $ errnum , $ errmsg , 0 , 1 ) ) ) { $ this -> _query ( " UPDATE " . $ this -> _mapTableName ( QUICKBOOKS_DRIVER_SQL_CONFIGTABLE ) . " SET cfgval = '" . $ this -> _escape ( $ value ) . "', mod_datetime = '" . date ( 'Y-m-d H:i:s' ) . "' WHERE quickbooks_config_id = " . $ arr [ 'quickbooks_config_id' ] , $ errnum , $ errmsg ) ; } else { return $ this -> _query ( " INSERT INTO " . $ this -> _mapTableName ( QUICKBOOKS_DRIVER_SQL_CONFIGTABLE ) . " ( qb_username, module, cfgkey, cfgval, cfgtype, cfgopts, write_datetime, mod_datetime ) VALUES ( '" . $ this -> _escape ( $ user ) . "', '" . $ this -> _escape ( $ module ) . "', '" . $ this -> _escape ( $ key ) . "', '" . $ this -> _escape ( $ value ) . "', '" . $ this -> _escape ( $ type ) . "', '" . $ this -> _escape ( serialize ( $ opts ) ) . "', '" . date ( 'Y-m-d H:i:s' ) . "', '" . date ( 'Y-m-d H:i:s' ) . "' ) " , $ errnum , $ errmsg ) ; } } 
protected function _configRead ( $ user , $ module , $ key , & $ type , & $ opts ) { $ errnum = 0 ; $ errmsg = '' ; $ sql = " SELECT cfgval, cfgtype, cfgopts FROM " . $ this -> _mapTableName ( QUICKBOOKS_DRIVER_SQL_CONFIGTABLE ) . " WHERE qb_username = '" . $ this -> _escape ( $ user ) . "' AND module = '" . $ this -> _escape ( $ module ) . "' AND cfgkey = '" . $ this -> _escape ( $ key ) . "' " ; 
protected function _authCreate ( $ username , $ password , $ company_file = null , $ wait_before_next_update = null , $ min_run_every_n_seconds = null ) { $ errnum = 0 ; $ errmsg = '' ; if ( ! $ this -> _count ( $ this -> _query ( "SELECT qb_username FROM " . $ this -> _mapTableName ( QUICKBOOKS_DRIVER_SQL_USERTABLE ) . " WHERE qb_username = '" . $ this -> _escape ( $ username ) . "' " , $ errnum , $ errmsg , 0 , 1 ) ) ) { return $ this -> _query ( " INSERT INTO " . $ this -> _mapTableName ( QUICKBOOKS_DRIVER_SQL_USERTABLE ) . " ( qb_username, qb_password, qb_company_file, qbwc_wait_before_next_update, qbwc_min_run_every_n_seconds, status, write_datetime, touch_datetime ) VALUES ( '" . $ this -> _escape ( $ username ) . "', '" . $ this -> _escape ( $ this -> _hash ( $ password ) ) . "', '" . $ this -> _escape ( $ company_file ) . "', " . ( int ) $ wait_before_next_update . ", " . ( int ) $ min_run_every_n_seconds . ", '" . QUICKBOOKS_USER_ENABLED . "', '" . date ( 'Y-m-d H:i:s' ) . "', '" . date ( 'Y-m-d H:i:s' ) . "' ) " , $ errnum , $ errmsg ) ; } return false ; } 
protected function _authEnable ( $ username ) { $ errnum = 0 ; $ errmsg = '' ; return $ this -> _query ( " UPDATE " . $ this -> _mapTableName ( QUICKBOOKS_DRIVER_SQL_USERTABLE ) . " SET status = '" . QUICKBOOKS_USER_ENABLED . "', touch_datetime = '" . date ( 'Y-m-d H:i:s' ) . "' WHERE qb_username = '" . $ this -> _escape ( $ username ) . "' " ) ; } 
protected function _authDisable ( $ username ) { $ errnum = 0 ; $ errmsg = '' ; return $ this -> _query ( " UPDATE " . $ this -> _mapTableName ( QUICKBOOKS_DRIVER_SQL_USERTABLE ) . " SET status = '" . QUICKBOOKS_USER_DISABLED . "', touch_datetime = '" . date ( 'Y-m-d H:i:s' ) . "' WHERE qb_username = '" . $ this -> _escape ( $ username ) . "' " ) ; } 
protected function _authDefault ( ) { $ errnum = 0 ; $ errmsg = '' ; if ( $ arr = $ this -> _fetch ( $ this -> _query ( " SELECT qb_username FROM " . $ this -> _mapTableName ( QUICKBOOKS_DRIVER_SQL_USERTABLE ) . " WHERE status = '" . QUICKBOOKS_USER_ENABLED . "' " , $ errnum , $ errmsg , 0 , 1 ) ) ) { return $ arr [ 'qb_username' ] ; } return '' ; } 
protected function _authLast ( $ username ) { $ errnum = 0 ; $ errmsg = '' ; if ( $ arr = $ this -> _fetch ( $ this -> _query ( " SELECT write_datetime, touch_datetime FROM " . $ this -> _mapTableName ( QUICKBOOKS_DRIVER_SQL_TICKETTABLE ) . " WHERE qb_username = '" . $ this -> _escape ( $ username ) . "' ORDER BY quickbooks_ticket_id DESC " , $ errnum , $ errmsg , 0 , 1 ) ) ) { return array ( $ arr [ 'write_datetime' ] , $ arr [ 'touch_datetime' ] , ) ; } return null ; } 
protected function _authLogin ( $ username , $ password , & $ company_file , & $ wait_before_next_update , & $ min_run_every_n_seconds , $ override = false ) { $ errnum = 0 ; $ errmsg = '' ; if ( $ override ) SELECT * FROM " . $ this -> _mapTableName ( QUICKBOOKS_DRIVER_SQL_USERTABLE ) . " WHERE qb_username = '" . $ this -> _escape ( $ username ) . "' AND ( qb_password = '" . $ this -> _escape ( $ this -> _hash ( $ password ) ) . "' OR qb_password = '" . $ this -> _escape ( $ plain_text ) . "' OR qb_password = '" . $ this -> _escape ( $ plain_md5 ) . "' OR qb_password = '" . $ this -> _escape ( $ plain_sha1 ) . "' ) AND status = '" . QUICKBOOKS_USER_ENABLED . "' " , $ errnum , $ errmsg , 0 , 1 ) ) ) { //$ticket = md5((string) microtime() . $username . $this->_mapTableName(QUICKBOOKS_DRIVER_SQL_SALT)); $ ticket = QuickBooks_WebConnector_QWC :: GUID ( false ) ; $ this -> _query ( " INSERT INTO " . $ this -> _mapTableName ( QUICKBOOKS_DRIVER_SQL_TICKETTABLE ) . " ( qb_username, ticket, ipaddr, write_datetime, touch_datetime ) VALUES ( '" . $ this -> _escape ( $ username ) . "', '" . $ this -> _escape ( $ ticket ) . "', '" . $ _SERVER [ 'REMOTE_ADDR' ] . "', '" . date ( 'Y-m-d H:i:s' ) . "', '" . date ( 'Y-m-d H:i:s' ) . "' ) " , $ errnum , $ errmsg ) ; $ this -> _query ( " UPDATE " . $ this -> _mapTableName ( QUICKBOOKS_DRIVER_SQL_USERTABLE ) . " SET touch_datetime = '" . date ( 'Y-m-d H:i:s' ) . "' WHERE qb_username = '" . $ this -> _escape ( $ username ) . "' " , $ errnum , $ errmsg ) ; if ( isset ( $ arr ) and is_array ( $ arr ) ) 
protected function _authCheck ( $ ticket ) { $ errnum = 0 ; $ errmsg = '' ; if ( $ arr = $ this -> _fetch ( $ this -> _query ( " SELECT quickbooks_ticket_id FROM " . $ this -> _mapTableName ( QUICKBOOKS_DRIVER_SQL_TICKETTABLE ) . " WHERE ticket = '" . $ this -> _escape ( $ ticket ) . "' AND touch_datetime > '" . date ( 'Y-m-d H:i:s' , time ( ) - QUICKBOOKS_TIMEOUT ) . "' " , $ errnum , $ errmsg , 0 , 1 ) ) ) { $ this -> _query ( " UPDATE " . $ this -> _mapTableName ( QUICKBOOKS_DRIVER_SQL_TICKETTABLE ) . " SET touch_datetime = '" . date ( 'Y-m-d H:i:s' ) . "' WHERE quickbooks_ticket_id = " . $ arr [ 'quickbooks_ticket_id' ] , $ errnum , $ errmsg ) ; return true ; } return false ; } 
protected function _errorLog ( $ ticket , $ errnum , $ errmsg ) { if ( $ ticket_id = $ this -> _ticketResolve ( $ ticket ) ) { $ db_errnum = 0 ; $ db_errmsg = '' ; return $ this -> _query ( " UPDATE " . $ this -> _mapTableName ( QUICKBOOKS_DRIVER_SQL_TICKETTABLE ) . " SET lasterror_num = '" . $ this -> _escape ( $ errnum ) . "', lasterror_msg = '" . $ this -> _escape ( substr ( $ errmsg , 0 , 255 ) ) . "' WHERE quickbooks_ticket_id = " . ( int ) $ ticket_id , $ db_errnum , $ db_errmsg ) ; } return false ; } 
protected function _errorLast ( $ ticket ) { $ errnum = 0 ; $ errmsg = '' ; if ( $ ticket_id = $ this -> _ticketResolve ( $ ticket ) ) { if ( $ arr = $ this -> _fetch ( $ this -> _query ( "SELECT lasterror_num, lasterror_msg FROM " . $ this -> _mapTableName ( QUICKBOOKS_DRIVER_SQL_TICKETTABLE ) . " WHERE quickbooks_ticket_id = '" . $ ticket_id . "' " , $ errnum , $ errmsg , 0 , 1 ) ) ) { if ( $ arr [ 'lasterror_msg' ] == QUICKBOOKS_NOOP ) { return QUICKBOOKS_NOOP ; } return $ arr [ 'lasterror_num' ] . ': ' . $ arr [ 'lasterror_msg' ] ; } } return 'Error fetching last error.' ; } 
protected function _recurEnqueue ( $ user , $ run_every , $ action , $ ident , $ replace = true , $ priority = 0 , $ extra = null , $ qbxml = null ) { $ errnum = 0 ; $ errmsg = '' ; SELECT recur_lasttime FROM " . $ this -> _mapTableName ( QUICKBOOKS_DRIVER_SQL_RECURTABLE ) . " WHERE qb_username = '" . $ this -> _escape ( $ user ) . "' AND qb_action = '" . $ this -> _escape ( $ action ) . "' AND ident = '" . $ this -> _escape ( $ ident ) . "' " , $ errnum , $ errmsg ) ) ) { $ this -> _query ( " DELETE FROM " . $ this -> _mapTableName ( QUICKBOOKS_DRIVER_SQL_RECURTABLE ) . " WHERE qb_username = '" . $ this -> _escape ( $ user ) . "' AND qb_action = '" . $ this -> _escape ( $ action ) . "' AND ident = '" . $ this -> _escape ( $ ident ) . "' " , $ errnum , $ errmsg ) ; $ recur_lasttime = $ existing [ 'recur_lasttime' ] ; } } if ( $ extra ) { $ extra = serialize ( $ extra ) ; } return $ this -> _query ( " INSERT INTO " . $ this -> _mapTableName ( QUICKBOOKS_DRIVER_SQL_RECURTABLE ) . " ( qb_username, qb_action, ident, extra, qbxml, priority, run_every, recur_lasttime, enqueue_datetime ) VALUES ( '" . $ this -> _escape ( $ user ) . "', '" . $ this -> _escape ( $ action ) . "', '" . $ this -> _escape ( $ ident ) . "', '" . $ this -> _escape ( $ extra ) . "', '" . $ this -> _escape ( $ qbxml ) . "', " . ( int ) $ priority . ", " . ( int ) $ run_every . ", " . $ recur_lasttime . ", '" . date ( 'Y-m-d H:i:s' ) . "' ) " , $ errnum , $ errmsg ) ; } 
protected function _recurDequeue ( $ user , $ by_priority = false ) { $ errnum = 0 ; $ errmsg = '' ; $ sql = " SELECT * FROM " . $ this -> _mapTableName ( QUICKBOOKS_DRIVER_SQL_RECURTABLE ) . " WHERE qb_username = '" . $ this -> _escape ( $ user ) . "' AND recur_lasttime + run_every <= " . time ( ) ; if ( $ by_priority ) { $ sql .= ' ORDER BY priority DESC ' ; } if ( $ arr = $ this -> _fetch ( $ this -> _query ( $ sql . ' ' , $ errnum , $ errmsg , 0 , 1 ) ) ) { 
protected function _queueRemove ( $ user , $ action , $ ident ) { $ errnum = 0 ; $ errmsg = '' ; return $ this -> _query ( " UPDATE " . $ this -> _mapTableName ( QUICKBOOKS_DRIVER_SQL_QUEUETABLE ) . " SET qb_status = '" . QUICKBOOKS_STATUS_REMOVED . "' WHERE qb_username = '" . $ this -> _escape ( $ user ) . "' AND qb_action = '" . $ this -> _escape ( $ action ) . "' AND ident = '" . $ this -> _escape ( $ ident ) . "' AND qb_status = '" . QUICKBOOKS_STATUS_QUEUED . "' " , $ errnum , $ errmsg ) ; } 
protected function _queueEnqueue ( $ user , $ action , $ ident , $ replace = true , $ priority = 0 , $ extra = null , $ qbxml = null ) { $ errnum = 0 ; $ errmsg = '' ; if ( $ replace ) { $ this -> _query ( " DELETE FROM " . $ this -> _mapTableName ( QUICKBOOKS_DRIVER_SQL_QUEUETABLE ) . " WHERE qb_username = '" . $ this -> _escape ( $ user ) . "' AND qb_action = '" . $ this -> _escape ( $ action ) . "' AND ident = '" . $ this -> _escape ( $ ident ) . "' AND qb_status = '" . QUICKBOOKS_STATUS_QUEUED . "' " , $ errnum , $ errmsg ) ; } if ( $ extra ) { $ extra = serialize ( $ extra ) ; } return $ this -> _query ( " INSERT INTO " . $ this -> _mapTableName ( QUICKBOOKS_DRIVER_SQL_QUEUETABLE ) . " ( qb_username, qb_action, ident, extra, qbxml, priority, qb_status, enqueue_datetime ) VALUES ( '" . $ this -> _escape ( $ user ) . "', '" . $ this -> _escape ( $ action ) . "', '" . $ this -> _escape ( $ ident ) . "', '" . $ this -> _escape ( $ extra ) . "', '" . $ this -> _escape ( $ qbxml ) . "', " . ( int ) $ priority . ", '" . QUICKBOOKS_STATUS_QUEUED . "', '" . date ( 'Y-m-d H:i:s' ) . "' ) " , $ errnum , $ errmsg ) ; } 
protected function _queueProcessing ( $ user ) { $ errnum = 0 ; $ errmsg = '' ; SELECT quickbooks_queue_id, qb_action, ident, qb_status, dequeue_datetime FROM " . $ this -> _mapTableName ( QUICKBOOKS_DRIVER_SQL_QUEUETABLE ) . " WHERE dequeue_datetime IS NOT NULL ORDER BY dequeue_datetime DESC " ; $ res = $ this -> _query ( $ sql , $ errnum , $ errmsg , 0 , 1 ) ; if ( $ arr = $ this -> _fetch ( $ res ) and $ arr [ 'qb_status' ] == QUICKBOOKS_STATUS_PROCESSING and 
protected function _queueDequeue ( $ user , $ by_priority = false ) { $ errnum = 0 ; $ errmsg = '' ; $ sql = " SELECT * FROM " . $ this -> _mapTableName ( QUICKBOOKS_DRIVER_SQL_QUEUETABLE ) . " WHERE qb_username = '" . $ this -> _escape ( $ user ) . "' AND qb_status = '" . QUICKBOOKS_STATUS_QUEUED . "' " ; if ( $ by_priority ) { $ sql .= ' ORDER BY priority DESC, ident ASC ' ; } return $ this -> _fetch ( $ this -> _query ( $ sql , $ errnum , $ errmsg , 0 , 1 ) ) ; } 
protected function _queueLeft ( $ user , $ queued = true ) { $ errnum = 0 ; $ errmsg = '' ; SELECT COUNT(*) AS num_left FROM " . $ this -> _mapTableName ( QUICKBOOKS_DRIVER_SQL_QUEUETABLE ) . " WHERE qb_username = '" . $ this -> _escape ( $ user ) . "' " ; if ( $ queued ) { $ sql .= " AND qb_status = '" . QUICKBOOKS_STATUS_QUEUED . "' " ; } $ arr = $ this -> _fetch ( $ this -> _query ( $ sql , $ errnum , $ errmsg ) ) ; return $ arr [ 'num_left' ] ; } 
protected function _queueStatus ( $ ticket , $ requestID , $ new_status , $ msg = null ) { $ errnum = 0 ; $ errmsg = '' ; if ( $ ticket_id = $ this -> _ticketResolve ( $ ticket ) ) { $ user = $ this -> authResolve ( $ ticket ) ; UPDATE " . $ this -> _mapTableName ( QUICKBOOKS_DRIVER_SQL_TICKETTABLE ) . " SET processed = processed + 1, lasterror_num = NULL, lasterror_msg = NULL WHERE quickbooks_ticket_id = " . ( int ) $ ticket_id . " " , $ errnum , $ errmsg ) ; } if ( $ new_status == QUICKBOOKS_STATUS_PROCESSING ) { /* $this->_query(" UPDATE " . $this->_mapTableName(QUICKBOOKS_DRIVER_SQL_QUEUETABLE) . " SET qb_status = '" . $this->_escape($new_status) . "', msg = '" . $this->_escape($msg) . "', quickbooks_ticket_id = " . (int) $ticket_id . ", dequeue_datetime = '" . date('Y-m-d H:i:s') . "' WHERE qb_username = '" . $this->_escape($user) . "' AND qb_action = '" . $this->_escape($action) . "' AND ident = '" . $this->_escape($ident) . "' AND qb_status = '" . QUICKBOOKS_STATUS_QUEUED . "' ", $errnum, $errmsg, 0, 1); */ $ this -> _query ( " UPDATE " . $ this -> _mapTableName ( QUICKBOOKS_DRIVER_SQL_QUEUETABLE ) . " SET qb_status = '" . $ this -> _escape ( $ new_status ) . "', msg = '" . $ this -> _escape ( $ msg ) . "', quickbooks_ticket_id = " . ( int ) $ ticket_id . ", dequeue_datetime = '" . date ( 'Y-m-d H:i:s' ) . "' WHERE quickbooks_queue_id = " . ( int ) $ requestID . " AND qb_username = '" . $ this -> _escape ( $ user ) . "' AND qb_status = '" . $ this -> _escape ( QUICKBOOKS_STATUS_QUEUED ) . "' " , $ errnum , $ errmsg , null , null ) ; //print('running processing status query! ' . $user . ', ' . $action . ', ' . $ident . ', new: ' . $new_status); // If we're currently processing, then no error is occuring... $ errnum = null ; $ errmsg = null ; $ this -> _query ( " UPDATE " . $ this -> _mapTableName ( QUICKBOOKS_DRIVER_SQL_TICKETTABLE ) . " SET lasterror_num = NULL, lasterror_msg = NULL WHERE quickbooks_ticket_id = " . ( int ) $ ticket_id , $ errnum , $ errmsg , null , null ) ; } else if ( $ new_status == QUICKBOOKS_STATUS_SUCCESS ) { // You can only update to a SUCCESS status if you're currently // in a PROCESSING status /* $sql = " UPDATE " . $this->_mapTableName(QUICKBOOKS_DRIVER_SQL_QUEUETABLE) . " SET qb_status = '" . $this->_escape($new_status) . "', msg = '" . $this->_escape($msg) . "' WHERE quickbooks_ticket_id = " . (int) $ticket_id . " AND qb_username = '" . $this->_escape($user) . "' AND qb_action = '" . $this->_escape($action) . "' AND ident = '" . $this->_escape($ident) . "' AND qb_status = '" . QUICKBOOKS_STATUS_PROCESSING . "' "; */ $ sql = " UPDATE " . $ this -> _mapTableName ( QUICKBOOKS_DRIVER_SQL_QUEUETABLE ) . " SET qb_status = '" . $ this -> _escape ( $ new_status ) . "', msg = '" . $ this -> _escape ( $ msg ) . "' WHERE quickbooks_ticket_id = " . ( int ) $ ticket_id . " AND qb_username = '" . $ this -> _escape ( $ user ) . "' AND quickbooks_queue_id = " . ( int ) $ requestID . " AND qb_status = '" . QUICKBOOKS_STATUS_PROCESSING . "' " ; $ this -> _query ( $ sql , $ errnum , $ errmsg , null , null ) ; } else { // There are some statuses which *can not be updated* because // they're already removed from the queue. These are listed in // the NOT IN section /* $sql = " UPDATE " . $this->_mapTableName(QUICKBOOKS_DRIVER_SQL_QUEUETABLE) . " SET qb_status = '" . $this->_escape($new_status) . "', msg = '" . $this->_escape($msg) . "' WHERE quickbooks_ticket_id = " . (int) $ticket_id . " AND qb_username = '" . $this->_escape($user) . "' AND qb_action = '" . $this->_escape($action) . "' AND ident = '" . $this->_escape($ident) . "' AND qb_status NOT IN ( '" . QUICKBOOKS_STATUS_SUCCESS . "', '" . QUICKBOOKS_STATUS_HANDLED . "', '" . QUICKBOOKS_STATUS_CANCELLED . "', '" . QUICKBOOKS_STATUS_REMOVED . "' ) "; */ $ sql = " UPDATE " . $ this -> _mapTableName ( QUICKBOOKS_DRIVER_SQL_QUEUETABLE ) . " SET qb_status = '" . $ this -> _escape ( $ new_status ) . "', msg = '" . $ this -> _escape ( $ msg ) . "' WHERE quickbooks_ticket_id = " . ( int ) $ ticket_id . " AND qb_username = '" . $ this -> _escape ( $ user ) . "' AND quickbooks_queue_id = " . ( int ) $ requestID . " AND qb_status NOT IN ( '" . QUICKBOOKS_STATUS_SUCCESS . "', '" . QUICKBOOKS_STATUS_HANDLED . "', '" . QUICKBOOKS_STATUS_CANCELLED . "', '" . QUICKBOOKS_STATUS_REMOVED . "' ) " ; $ this -> _query ( $ sql , $ errnum , $ errmsg , null , null ) ; // If that got marked as a NoOp, we should also remove the NoOp // status from the quickbooks_ticket table, or we can get stuck // in an infinite loop (we're all done, last request returns a // no op, get last error is called, returns no op, send request // is called and returns a no op because there's nothing to do, // get last error is called and retuns a no op, etc. etc. etc. /* if ($new_status == QUICKBOOKS_STATUS_NOOP) { $errnum = null; $errmsg = null; $this->_query(" UPDATE " . $this->_mapTableName(QUICKBOOKS_DRIVER_SQL_TICKETTABLE) . " SET lasterror_num = NULL, lasterror_msg = NULL WHERE quickbooks_ticket_id = " . (int) $ticket_id, $errnum, $errmsg, 0, 1); }*/ } return true ; } return false ; } 
protected function _queueProcessed ( $ ticket ) { $ errnum = 0 ; $ errmsg = '' ; if ( $ arr = $ this -> _fetch ( $ this -> _query ( " SELECT processed FROM " . $ this -> _mapTableName ( QUICKBOOKS_DRIVER_SQL_TICKETTABLE ) . " WHERE ticket = '" . $ this -> _escape ( $ ticket ) . "' " , $ errnum , $ errmsg , 0 , 1 ) ) ) { return $ arr [ 'processed' ] ; } return 0 ; } 
protected function _queueExists ( $ user , $ action , $ ident ) { $ errnum = 0 ; $ errmsg = '' ; return $ this -> _count ( $ this -> _query ( " SELECT quickbooks_queue_id FROM " . $ this -> _mapTableName ( QUICKBOOKS_DRIVER_SQL_QUEUETABLE ) . " WHERE qb_username = '" . $ this -> _escape ( $ user ) . "' AND qb_action = '" . $ this -> escape ( $ action ) . "' AND ident = '" . $ this -> escape ( $ ident ) . "' AND qb_status = '" . QUICKBOOKS_STATUS_QUEUED . "' " , $ errnum , $ errmsg ) ) > 0 ; } 
protected function _truncate ( $ table , $ max_history ) { SELECT quickbooks_queue_id FROM " . $ this -> _mapTableName ( $ table ) . " WHERE qb_status IN ( '" . QUICKBOOKS_STATUS_SUCCESS . "', '" . QUICKBOOKS_STATUS_HANDLED . "', '" . QUICKBOOKS_STATUS_CANCELLED . "', '" . QUICKBOOKS_STATUS_NOOP . "' ) ORDER BY quickbooks_queue_id ASC LIMIT " ; $ field = 'quickbooks_queue_id' ; break ; case QUICKBOOKS_DRIVER_SQL_TICKETTABLE : $ sql = "SELECT quickbooks_ticket_id FROM " . $ this -> _mapTableName ( $ table ) . " ORDER BY quickbooks_ticket_id ASC LIMIT " ; $ field = 'quickbooks_ticket_id' ; break ; } // How big is the log file? Should we auto-truncate it? $ errnum = 0 ; $ errmsg = '' ; $ arr = $ this -> _fetch ( $ this -> _query ( "SELECT COUNT(" . $ field . ") AS counter FROM " . $ this -> _mapTableName ( $ table ) , $ errnum , $ errmsg ) ) ; if ( $ arr [ 'counter' ] > $ max_history ) { // Truncate the log to the size specified $ start = time ( ) ; $ cutoff = 3 ; // 3 seconds max cutoff time to avoid timeouts $ limit = 100 ; $ list = array ( ) ; $ errnum = 0 ; $ errmsg = '' ; $ res = $ this -> _query ( $ sql . floor ( $ max_history / 2 ) , $ errnum , $ errmsg ) ; while ( $ arr = $ this -> _fetch ( $ res ) and time ( ) - $ start < $ cutoff ) { // Delete it batches of $limit, keep under $cutoff seconds $ list [ ] = current ( $ arr ) ; if ( count ( $ list ) > $ limit ) { $ errnum = 0 ; $ errmsg = '' ; $ this -> _query ( "DELETE FROM " . $ this -> _mapTableName ( $ table ) . " WHERE " . $ field . " IN ( " . implode ( ', ' , $ list ) . " )" , $ errnum , $ errmsg ) ; $ list = array ( ) ; } } } return ; } 
protected function _log ( $ msg , $ ticket = null , $ log_level = QUICKBOOKS_LOG_NORMAL , $ cur_log_level = null ) { static $ batch = 0 ; INSERT INTO " . $ this -> _mapTableName ( QUICKBOOKS_DRIVER_SQL_LOGTABLE ) . " ( quickbooks_ticket_id, batch, msg, log_datetime ) VALUES ( " . $ ticket_id . ", " . $ batch . ", '" . $ this -> _escape ( $ msg ) . "', '" . date ( 'Y-m-d H:i:s' ) . "' ) " , $ errnum , $ errmsg ) ; } else { return $ this -> _query ( " INSERT INTO " . $ this -> _mapTableName ( QUICKBOOKS_DRIVER_SQL_LOGTABLE ) . " ( batch, msg, log_datetime ) VALUES ( " . $ batch . ", '" . $ this -> _escape ( $ msg ) . "', '" . date ( 'Y-m-d H:i:s' ) . "' ) " , $ errnum , $ errmsg ) ; } } 
public function query ( $ sql , & $ errnum , & $ errmsg , $ offset = 0 , $ limit = null , $ vars = array ( ) ) { if ( is_array ( $ vars ) and count ( $ vars ) ) { foreach ( $ vars as $ key => $ value ) { $ vars [ $ key ] = $ this -> escape ( $ value ) ; } array_unshift ( $ vars , $ sql ) ; $ sql = call_user_func_array ( 'sprintf' , $ vars ) ; } 
public function fields ( $ table , $ with_field_names_as_keys = false ) { static $ cache = array ( ) ; if ( isset ( $ cache [ $ table ] ) ) { return $ cache [ $ table ] ; } 
public function select ( $ table , $ restrict , $ order = array ( ) , $ offset = null , $ limit = null ) { $ list = array ( ) ; if ( count ( $ restrict ) ) { $ where = array ( ) ; foreach ( $ restrict as $ field => $ value ) { $ where [ ] = $ field . " = '" . $ this -> _escape ( $ value ) . "' " ; } $ where = " WHERE " . implode ( ' AND ' , $ where ) . " " ; } else { $ where = "" ; } $ orderby = "" ; if ( is_array ( $ order ) and count ( $ order ) ) { $ orderby = array ( ) ; foreach ( $ order as $ field => $ direction ) { $ orderby [ ] = " " . $ field . " " . $ direction ; } $ orderby = " ORDER BY " . implode ( ', ' , $ orderby ) ; } $ errnum = 0 ; $ errmsg = '' ; if ( $ res = $ this -> _query ( "SELECT * FROM " . $ this -> _escape ( $ table ) . " " . $ where . " " . $ orderby , $ errnum , $ errmsg , $ offset , $ limit ) ) { while ( $ arr = $ this -> _fetch ( $ res ) ) { $ list [ ] = $ arr ; } } return $ list ; } 
public function update ( $ table , $ object , $ where = array ( ) , $ resync = true , $ discov = null , $ derive = true ) { $set[] = $field . ' = ' . (int) $value; } else {*/ UPDATE " . $ this -> _escape ( $ table ) . " SET " . QUICKBOOKS_DRIVER_SQL_FIELD_DISCOVER . " = " . QUICKBOOKS_DRIVER_SQL_FIELD_RESYNC . " WHERE " . implode ( ' AND ' , $ wheres ) , $ errnum , $ errmsg ) ; } return $ return ; } 
public function insert ( $ table , $ object , $ discov_and_resync = true ) { $ sql = '' ; $ avail = $ this -> fields ( $ table , true ) ; foreach ($object as $field => $value) { $fields[] = $field; $values[] = " '" . $this->_escape($value) . "' "; } */ if ($table == 'pricemodel_tierset') { print_r($object); print($sql); exit; } */ $ errnum = 0 ; $ errmsg = '' ; return $ this -> _query ( $ sql , $ errnum , $ errmsg ) ; } 
public function interactive ( $ priority = 0 , $ user = null ) { if ( $ this -> _driver ) { $ tmp = array_merge ( range ( 'a' , 'z' ) , range ( 0 , 9 ) ) ; shuffle ( $ tmp ) ; $ random = substr ( implode ( '' , $ tmp ) , 0 , 8 ) ; if ( ! $ user ) { $ user = $ this -> _user ; } return $ this -> _driver -> queueEnqueue ( QUICKBOOKS_INTERACTIVE_MODE , $ random , true , $ priority , $ user ) ; } return false ; } 
public function recurring ( $ run_every , $ action , $ ident = null , $ priority = 0 , $ extra = null , $ user = null , $ qbxml = null , $ replace = true ) { $ run_every = QuickBooks_Utilities :: intervalToSeconds ( $ run_every ) ; if ( ! strlen ( $ ident ) ) { $ tmp = array_merge ( array ( 'a' , 'z' ) , range ( 0 , 9 ) ) ; shuffle ( $ tmp ) ; $ ident = substr ( implode ( '' , $ tmp ) , 0 , 8 ) ; } if ( $ this -> _driver ) { 
public function enqueue ( $ action , $ ident = null , $ priority = 0 , $ extra = null , $ user = null , $ qbxml = null , $ replace = true ) { if ( ! strlen ( $ ident ) ) { if (!$user) { $user = $this->_driver->authDefault(); } */ 
public function exists ( $ action , $ ident , $ user = null ) { if ( $ this -> _driver ) { 
public function size ( $ user = null ) { if ( $ this -> _driver ) { 
public function remove ( $ action , $ ident , $ user = null ) { if ( $ this -> _driver ) { 
public function setAddress ( $ addr1 , $ addr2 = '' , $ addr3 = '' , $ addr4 = '' , $ addr5 = '' , $ city = '' , $ state = '' , $ province = '' , $ postalcode = '' , $ country = '' , $ note = '' ) { for ( $ i = 1 ; $ i <= 5 ; $ i ++ ) { $ this -> set ( 'Address Addr' . $ i , $ { 'addr' . $ i } ) ; } $ this -> set ( 'Address City' , $ city ) ; $ this -> set ( 'Address State' , $ state ) ; $ this -> set ( 'Address Province' , $ province ) ; $ this -> set ( 'Address PostalCode' , $ postalcode ) ; $ this -> set ( 'Address Country' , $ country ) ; $ this -> set ( 'Address Note' , $ note ) ; } 
public function getAddress ( $ part = null , $ defaults = array ( ) ) { if ( ! is_null ( $ part ) ) { return $ this -> get ( 'Address ' . $ part ) ; } return $ this -> getArray ( 'Address *' , $ defaults ) ; } 
public function authenticate ( $ username , $ password , $ token ) { $ this -> _username = $ username ; $ this -> _password = $ password ; $ this -> _token = $ token ; $ url = 'https://workplace.intuit.com/db/main?act=API_Authenticate' ; $ action = 'API_Authenticate' ; $ xml = '<?xml version="1.0" encoding="UTF-8" ?> <qdbapi> <username>' . $ username . '</username> <password>' . $ password . '</password> <apptoken>' . $ token . '</apptoken> </qdbapi>' ; $ Context = null ; $ response = $ this -> _request ( $ Context , QuickBooks_IPP :: REQUEST_IPP , $ url , $ action , $ xml ) ; if ( ! $ this -> _hasErrors ( $ response ) and $ ticket = QuickBooks_XML :: extractTagContents ( 'ticket' , $ response ) ) { $ this -> _ticket = $ ticket ; $ cookies = array ( 'scache' , 'ptest' , 'stest' , 'luid' , 'TICKET' , 'qbn.ticket' , 'qbn.tkt' , 'qbn.authid' , 'qbn.gauthid' , 'qbn.agentid' , 'iamValidationTime' ) ; foreach ( $ cookies as $ cookie ) { if ( $ value = $ this -> _extractCookie ( $ cookie , $ response ) ) { $ this -> _cookies [ $ cookie ] = $ value ; } } return new QuickBooks_IPP_Context ( $ this , $ ticket , $ token ) ; } return false ; } 
public function context ( $ ticket = null , $ token = null , $ check_if_valid = true ) { $ Context = null ; if ( $ this -> _authmode == QuickBooks_IPP :: AUTHMODE_OAUTH ) { $ Context = new QuickBooks_IPP_Context ( $ this , null , $ token ) ; 
public function authMode ( $ authmode = null , $ authuser = null , $ authcred = null , $ authsign = null , $ authkey = null ) { if ( $ authmode ) { $ this -> _authmode = $ authmode ; $ this -> _authuser = $ authuser ; $ this -> _authcred = $ authcred ; $ this -> _authsign = $ authsign ; $ this -> _authkey = $ authkey ; } return $ this -> _authmode ; } 
public function provisionUser ( $ Context , $ email , $ fname , $ lname , $ roleid = null , $ udata = null ) { $ url = 'https://workplace.intuit.com/db/' . $ this -> _dbid ; $ action = 'API_ProvisionUser' ; $ xml = '<qdbapi> <ticket>' . $ Context -> ticket ( ) . '</ticket> <apptoken>' . $ Context -> token ( ) . '</apptoken>' ; if ( $ roleid ) { $ xml .= '<roleid>' . $ roleid . '</roleid>' ; } $ xml .= ' <email>' . $ email . '</email> <fname>' . $ fname . '</fname> <lname>' . $ lname . '</lname>' ; if ( $ udata ) { $ xml .= '<udata>' . $ udata . '</udata>' ; } $ xml .= ' </qdbapi>' ; $ response = $ this -> _request ( $ Context , QuickBooks_IPP :: REQUEST_IPP , $ url , $ action , $ xml ) ; if ( $ this -> _hasErrors ( $ response ) ) { return false ; } return true ; } 
public function IDS ( $ Context , $ realm , $ resource , $ optype , $ xml = '' , $ ID = null ) { $ IPP = $ Context -> IPP ( ) ; switch ( $ IPP -> version ( ) ) { case QuickBooks_IPP_IDS :: VERSION_3 : default : return $ this -> _IDS_v3 ( $ Context , $ realm , $ resource , $ optype , $ xml , $ ID ) ; } } 
public function findById ( $ Context , $ realmID ) { $ xml = null ; 
public function setVendorApplicationID ( $ value ) { return $ this -> set ( 'VendorRef ' . QUICKBOOKS_API_APPLICATIONID , $ this -> encodeApplicationID ( QUICKBOOKS_OBJECT_VENDOR , QUICKBOOKS_LISTID , $ value ) ) ; } 
public function add ( $ Context , $ realmID , $ Object ) { return parent :: _add ( $ Context , $ realmID , QuickBooks_IPP_IDS :: RESOURCE_VENDORCREDIT , $ Object ) ; } 
public function delete ( $ Context , $ realmID , $ IDType ) { return parent :: _delete ( $ Context , $ realmID , QuickBooks_IPP_IDS :: RESOURCE_VENDORCREDIT , $ IDType ) ; } 
public function GetErrors ( ) { 
public function GetLogs ( ) { $ query = DB :: select ( ) -> from ( 'quickbooks_logs' ) ; $ logentries = $ this -> _db -> query ( Database :: SELECT , $ query , FALSE ) -> as_array ( ) ; return $ logentries ; } 
public function GetQueueBreakdown ( ) { $ metrics = array ( ) ; 
protected function _request ( $ method ) { $ start = microtime ( true ) ; if ( ! function_exists ( 'curl_init' ) ) { die ( 'You must have the PHP cURL extension (php.net/curl) enabled to use this (' . QUICKBOOKS_PACKAGE_NAME . ' v' . QUICKBOOKS_PACKAGE_VERSION . ').' ) ; } $ this -> _log ( 'Using CURL to send request!' , QUICKBOOKS_LOG_DEVELOP ) ; $ return = $ this -> _requestCurl ( $ method , $ errnum , $ errmsg ) ; if ( $ errnum ) { $ this -> _setError ( $ errnum , $ errmsg ) ; } 
public function signOn ( ) { $ this -> _setError ( QuickBooks_MerchantService :: ERROR_OK ) ; $ xml = '' ; $ xml .= '<?xml version="1.0" ?>' . QUICKBOOKS_CRLF ; $ xml .= '<?qbmsxml version="4.1"?>' . QUICKBOOKS_CRLF ; $ xml .= '<QBMSXML>' . QUICKBOOKS_CRLF ; $ xml .= ' <SignonMsgsRq>' . QUICKBOOKS_CRLF ; if ( $ this -> _certificate ) { $ this -> _log ( 'Signing on a HOSTED QBMS application.' , QUICKBOOKS_LOG_DEBUG ) ; $ xml .= ' <SignonAppCertRq>' . QUICKBOOKS_CRLF ; $ xml .= ' <ClientDateTime>' . date ( 'Y-m-d\TH:i:s' ) . '</ClientDateTime>' . QUICKBOOKS_CRLF ; $ xml .= ' <ApplicationLogin>' . $ this -> _application_login . '</ApplicationLogin>' . QUICKBOOKS_CRLF ; $ xml .= ' <ConnectionTicket>' . $ this -> _ticket_connection . '</ConnectionTicket>' . QUICKBOOKS_CRLF ; $ xml .= ' </SignonAppCertRq>' . QUICKBOOKS_CRLF ; } else { $ this -> _log ( 'Signing on as a DESKTOP QBMS application.' , QUICKBOOKS_LOG_DEBUG ) ; $ xml .= ' <SignonDesktopRq>' . QUICKBOOKS_CRLF ; $ xml .= ' <ClientDateTime>' . date ( 'Y-m-d\TH:i:s' ) . '</ClientDateTime>' . QUICKBOOKS_CRLF ; $ xml .= ' <ApplicationLogin>' . $ this -> _application_login . '</ApplicationLogin>' . QUICKBOOKS_CRLF ; $ xml .= ' <ConnectionTicket>' . $ this -> _ticket_connection . '</ConnectionTicket>' . QUICKBOOKS_CRLF ; $ xml .= ' </SignonDesktopRq>' . QUICKBOOKS_CRLF ; } $ xml .= ' </SignonMsgsRq>' . QUICKBOOKS_CRLF ; $ xml .= '</QBMSXML>' . QUICKBOOKS_CRLF ; $ errnum = QuickBooks_MerchantService :: ERROR_OK ; $ errmsg = '' ; $ response = $ this -> _request ( $ xml , $ errnum , $ errmsg ) ; if ( $ errnum ) { $ this -> _setError ( QuickBooks_MerchantService :: ERROR_SOCKET , $ errnum . ': ' . $ errmsg ) ; return false ; } $ code = $ this -> _extractAttribute ( 'statusCode' , $ response ) ; $ message = $ this -> _extractAttribute ( 'statusMessage' , $ response ) ; $ severity = $ this -> _extractAttribute ( 'statusSeverity' , $ response ) ; $ this -> _log ( 'SignOn (initial) response: ' . $ severity . '/' . $ code . ': ' . $ message , QUICKBOOKS_LOG_DEBUG ) ; if ( $ code != QuickBooks_MerchantService :: ERROR_OK ) { $ this -> _setError ( $ code , $ message ) ; return false ; } if ( $ ticket = $ this -> _extractTagContents ( 'SessionTicket' , $ response ) ) { $ this -> _ticket_session = $ ticket ; return true ; } $ this -> _setError ( QuickBooks_MerchantService :: ERROR_INTERNAL , 'Could not locate SessionTicket in response.' ) ; return false ; } 
protected function _transRequestID ( $ type , $ Obj , $ amount , $ force_new_transaction = true ) { $ rand = '' ; if ( $ force_new_transaction ) { $ rand = mt_rand ( ) . microtime ( ) ; } return md5 ( $ type . '-' . serialize ( $ Obj ) . '-' . $ amount . '-' . $ rand ) ; } 
protected function _doQBMS ( $ type , $ path , $ xml , $ CreditCard = null , $ Transaction = null ) { $ errnum = QuickBooks_MerchantService :: ERROR_OK ; $ errmsg = '' ; $ response = $ this -> _request ( $ xml , $ errnum , $ errmsg ) ; if ( $ errnum ) { $ this -> _setError ( QuickBooks_MerchantService :: ERROR_SOCKET , $ errnum . ': ' . $ errmsg ) ; return false ; } $ signon_code = $ this -> _extractAttribute ( 'statusCode' , $ response , 0 ) ; $ signon_message = '' ; $ signon_severity = $ this -> _extractAttribute ( 'statusSeverity' , $ response , 0 ) ; if ( $ signon_code != QuickBooks_MerchantService :: ERROR_OK ) { $ signon_message = $ this -> _extractAttribute ( 'statusMessage' , $ response , 0 ) ; } $ this -> _log ( 'SignOn (with session) response: ' . $ signon_severity . '/' . $ signon_code . ': ' . $ signon_message , QUICKBOOKS_LOG_DEBUG ) ; if ( $ signon_code != QuickBooks_MerchantService :: ERROR_OK ) { $ this -> _setError ( $ signon_code , $ signon_message ) ; return false ; } $ qbms_code = $ this -> _extractAttribute ( 'statusCode' , $ response , 1 ) ; $ qbms_message = $ this -> _extractAttribute ( 'statusMessage' , $ response , 0 ) ; 
public function refund ( $ Card , $ amount , $ salestax = null , $ comment = null , $ is_card_present = false , $ is_ecommerce = true , $ force_new_transaction = true ) { $ this -> _setError ( QuickBooks_MerchantService :: ERROR_OK ) ; $ this -> _log ( 'refund()' , QUICKBOOKS_LOG_VERBOSE ) ; if ( ! $ this -> isSignedOn ( ) ) { $ this -> signOn ( ) ; if ( $ this -> errorNumber ( ) ) { return false ; } } 
protected function _gateway ( ) { if ( $ this -> _test ) { $ this -> _log ( 'Using TEST gateway: ' . $ this -> _test_gateway , QUICKBOOKS_LOG_DEVELOP ) ; return $ this -> _test_gateway ; } $ this -> _log ( 'Using LIVE gateway: ' . $ this -> _live_gateway , QUICKBOOKS_LOG_DEVELOP ) ; return $ this -> _live_gateway ; } 
static public function initialize ( $ dsn = null , $ user = null , $ config = array ( ) , $ return_boolean = true ) { static $ instance ; if ( empty ( $ instance ) ) { if ( empty ( $ dsn ) ) { return false ; } $ instance = new QuickBooks_WebConnector_Queue ( $ dsn , $ user , $ config ) ; } if ( $ return_boolean and $ instance ) { return true ; } return $ instance ; } 
protected function _adapterFactory ( $ adapter , $ wsdl , $ soap_options , $ loglevel ) { $ adapter = ucfirst ( strtolower ( $ adapter ) ) ; $ file = '/QuickBooks/Adapter/Server/' . $ adapter . '.php' ; $ class = 'QuickBooks_Adapter_Server_' . $ adapter ; QuickBooks_Loader :: load ( $ file ) ; if ( class_exists ( $ class ) ) { return new $ class ( $ wsdl , $ soap_options ) ; } return null ; } 
final protected function _defaults ( $ arr ) { $ defaults = array ( 'error_handler' => '' , 'use_builtin_error_handler' => false , 'time_limit' => 0 , 'log_to_file' => null , 'log_to_syslog' => null , 'masking' => true , ) ; $ arr = array_merge ( $ defaults , $ arr ) ; return $ arr ; } 
protected function _merge ( $ arr1 , $ arr2 , $ array_of_arrays = false ) { if ( $ array_of_arrays ) { foreach ( $ arr2 as $ key => $ funcs ) { if ( ! is_array ( $ funcs ) ) { $ funcs = array ( $ funcs ) ; } if ( isset ( $ arr1 [ $ key ] ) ) { if ( ! is_array ( $ arr1 [ $ key ] ) ) { $ arr1 [ $ key ] = array ( $ arr1 [ $ key ] ) ; } $ arr1 [ $ key ] = array_merge ( $ arr1 [ $ key ] , $ funcs ) ; } else { $ arr1 [ $ key ] = $ funcs ; } } return $ arr1 ; } else { 
protected function _headers ( ) { if ( $ _SERVER [ 'REQUEST_METHOD' ] == 'POST' ) { header ( 'Content-Type: text/xml' ) ; } else if ( isset ( $ _GET [ 'wsdl' ] ) or isset ( $ _GET [ 'WSDL' ] ) ) { header ( 'Content-Type: text/xml' ) ; } else { header ( 'Content-Type: text/plain' ) ; } return true ; } 
public function handle ( $ return = false , $ debug = false ) { if (isset($this->_hooks[QUICKBOOKS_SERVER_HOOK_PREHANDLE])) { foreach ($this->_hooks[QUICKBOOKS_SERVER_HOOK_PREHANDLE] as $func) { $func($input, $this->_callback_config); } } */ $ hook_data = array ( 'input' => $ input , ) ; $ err = '' ; $ this -> _callHooks ( QUICKBOOKS_SERVER_HOOK_PREHANDLE , null , null , null , $ err , $ hook_data ) ; if (isset($this->_hooks[QUICKBOOKS_SERVER_HOOK_POSTHANDLE])) { foreach ($this->_hooks[QUICKBOOKS_SERVER_HOOK_POSTHANDLE] as $func) { $func($output, $this->_callback_config); } } */ $ hook_data = array ( 'input' => $ input , 'output' => $ output , ) ; $ err = '' ; $ this -> _callHooks ( QUICKBOOKS_SERVER_HOOK_POSTHANDLE , null , null , null , $ err , $ hook_data ) ; print("\n"); print('Registered hooks: ' . "\n"); foreach ($this->_hooks as $hook => $arr) { if (!is_array($arr)) { continue; } print(' - ' . $hook . QUICKBOOKS_CRLF); foreach ($arr as $x) { $y = current(explode("\n", print_r($x, true))); print(' ' . $y . QUICKBOOKS_CRLF); } } */ print ( "\n" ) ; print ( 'Detected input: ' . "\n" ) ; print ( $ input ) ; print ( "\n" ) ; print ( "\n" ) ; print ( 'Timestamp: ' . "\n" ) ; print ( ' - ' . date ( 'Y-m-d H:i:s' ) . ' -- process ' . round ( microtime ( true ) - QUICKBOOKS_TIMESTAMP , 5 ) . "\n" ) ; } return ; } } 
public function setEntityApplicationID ( $ value ) { return $ this -> set ( 'EntityRef ' . QUICKBOOKS_API_APPLICATIONID , $ this -> encodeApplicationID ( QUICKBOOKS_OBJECT_ENTITY , QUICKBOOKS_LISTID , $ value ) ) ; } 
public function setItemSalesTaxApplicationID ( $ value ) { return $ this -> set ( 'ItemSalesTaxRef ' . QUICKBOOKS_API_APPLICATIONID , $ this -> encodeApplicationID ( QUICKBOOKS_OBJECT_ITEMSALESTAX , QUICKBOOKS_LISTID , $ value ) ) ; } 
static public function e0x80040400_foundanerror ( $ requestID , $ user , $ action , $ ident , $ extra , & $ err , $ xml , $ errnum , $ errmsg , $ config ) { if ( $ action == QUICKBOOKS_QUERY_UNITOFMEASURESET ) { 
static function salt ( ) { $ tmp = array_merge ( range ( 'a' , 'z' ) , range ( 'A' , 'Z' ) , range ( 0 , 9 ) ) ; shuffle ( $ tmp ) ; $ salt = substr ( implode ( '' , $ tmp ) , 0 , 32 ) ; return $ salt ; } 
public function action_index ( ) { 
function _quickbooks_customer_mod_request ( $ requestID , $ user , $ action , $ ID , $ extra , & $ err , $ last_action_time , $ last_actionident_time , $ version , $ locale ) { Kohana :: $ log -> add ( Log :: NOTICE , "\nCustomer Modification QBXML:\n" . $ qbxml ) ; } 
protected function _requestFactory ( $ request ) { $ class = 'QuickBooks_WebConnector_Request_' . ucfirst ( strtolower ( $ request ) ) ; $ file = '/QuickBooks/WebConnector/Request/' . ucfirst ( strtolower ( $ request ) ) . '.php' ; 
public function handle ( $ raw_http_input ) { <SOAP-ENV:Envelope xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/" xmlns:ns1="http://developer.intuit.com/"> <SOAP-ENV:Body><ns1:' . $ method . 'Response>' ; $ vars = get_object_vars ( $ Response ) ; $ soap .= $ this -> _serialize ( $ vars ) ; $ soap .= '</ns1:' . $ method . 'Response> </SOAP-ENV:Body> </SOAP-ENV:Envelope>' ; print ( $ soap ) ; return true ; } else { $ soap = '' ; $ soap .= '<?xml version="1.0" encoding="UTF-8"?>' . QUICKBOOKS_CRLF ; $ soap .= '<SOAP-ENV:Envelope xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/">' . QUICKBOOKS_CRLF ; $ soap .= ' <SOAP-ENV:Body>' . QUICKBOOKS_CRLF ; $ soap .= ' <SOAP-ENV:Fault>' . QUICKBOOKS_CRLF ; $ soap .= ' <faultcode>SOAP-ENV:Client</faultcode>' . QUICKBOOKS_CRLF ; $ soap .= ' <faultstring>Bad Request: ' . htmlspecialchars ( $ errnum ) . ': ' . htmlspecialchars ( $ errmsg ) . '</faultstring>' . QUICKBOOKS_CRLF ; $ soap .= ' </SOAP-ENV:Fault>' . QUICKBOOKS_CRLF ; $ soap .= ' </SOAP-ENV:Body>' . QUICKBOOKS_CRLF ; $ soap .= '</SOAP-ENV:Envelope>' . QUICKBOOKS_CRLF ; print ( $ soap ) ; return false ; } } 
public function walk ( $ callback ) { 
public function charge ( $ Context , $ Object_or_token , $ amount , $ currency = 'USD' , $ description = '' , array $ context = array ( ) ) { $ capture = true ; return $ this -> _chargeOrAuth ( $ Context , $ Object_or_token , $ amount , $ currency , $ capture , $ description , $ context ) ; } 
public function authorize ( $ Context , $ Object_or_token , $ amount , $ currency = 'USD' , $ description = '' , array $ context = array ( ) ) { $ capture = false ; return $ this -> _chargeOrAuth ( $ Context , $ Object_or_token , $ amount , $ currency , $ capture , $ description , $ context ) ; } 
public function getCharge ( $ Context , $ id ) { $ resp = $ this -> _http ( $ Context , QuickBooks_Payments :: URL_CHARGE . '/' . $ id , null ) ; $ data = json_decode ( $ resp , true ) ; $ ignore_declines = true ; if ( $ this -> _handleError ( $ data , $ ignore_declines ) ) { return false ; } return new QuickBooks_Payments_Transaction ( $ data ) ; } 
public function getDebit ( $ Context , $ id ) { $ resp = $ this -> _http ( $ Context , QuickBooks_Payments :: URL_ECHECK . '/' . $ id , null ) ; $ data = json_decode ( $ resp , true ) ; $ ignore_declines = true ; if ( $ this -> _handleError ( $ data , $ ignore_declines ) ) { return false ; } return new QuickBooks_Payments_Transaction ( $ data ) ; } 
public function refund ( $ Context , $ id , $ amount , $ context = array ( ) ) { $ url = str_replace ( '<id>' , $ id , QuickBooks_Payments :: URL_REFUND ) ; $ payload = array ( 'amount' => $ amount , 'context' => array ( 'mobile' => false , 'isEcommerce' => false , 'recurring' => false , ) , ) ; $ resp = $ this -> _http ( $ Context , $ url , json_encode ( $ payload ) ) ; $ data = json_decode ( $ resp , true ) ; if ( $ this -> _handleError ( $ data ) ) { return false ; } return new QuickBooks_Payments_Transaction ( $ data ) ; } 
public function storeCard ( $ Context , $ id , $ Object ) { $ id = str_replace ( array ( '{' , '}' , '-' ) , '' , $ id ) ; $ url = str_replace ( '<id>' , $ id , QuickBooks_Payments :: URL_CARD ) ; if ( $ Object instanceof QuickBooks_Payments_CreditCard ) { $ payload = $ Object -> toArray ( ) ; } else { $ this -> _setError ( ) ; return false ; } $ resp = $ this -> _http ( $ Context , $ url , json_encode ( $ payload ) ) ; $ data = json_decode ( $ resp , true ) ; if ( $ this -> _handleError ( $ data ) ) { return false ; } return QuickBooks_Payments_CreditCard :: fromArray ( $ data ) ; } 
public function storeCardFromToken ( $ Context , $ id , $ token ) { $ id = str_replace ( array ( '{' , '}' , '-' ) , '' , $ id ) ; $ url = str_replace ( '<id>' , $ id , QuickBooks_Payments :: URL_CARD . '/createFromToken' ) ; $ payload = array ( 'value' => $ token ) ; $ resp = $ this -> _http ( $ Context , $ url , json_encode ( $ payload ) ) ; $ data = json_decode ( $ resp , true ) ; if ( $ this -> _handleError ( $ data ) ) { return false ; } return QuickBooks_Payments_CreditCard :: fromArray ( $ data ) ; } 
public function getCard ( $ Context , $ id , $ card_id ) { $ id = str_replace ( array ( '{' , '}' , '-' ) , '' , $ id ) ; $ url = str_replace ( '<id>' , $ id , QuickBooks_Payments :: URL_CARD . '/' . $ card_id ) ; $ resp = $ this -> _http ( $ Context , $ url ) ; $ data = json_decode ( $ resp , true ) ; if ( $ this -> _handleError ( $ data ) ) { return false ; } return QuickBooks_Payments_CreditCard :: fromArray ( $ data ) ; } 
public function getCards ( $ Context , $ id ) { $ id = str_replace ( array ( '{' , '}' , '-' ) , '' , $ id ) ; $ url = str_replace ( '<id>' , $ id , QuickBooks_Payments :: URL_CARD ) ; $ resp = $ this -> _http ( $ Context , $ url , null ) ; $ data = json_decode ( $ resp , true ) ; if ( $ this -> _handleError ( $ data ) ) { return false ; } $ cards = array ( ) ; foreach ( $ data as $ card ) { $ cards [ ] = QuickBooks_Payments_CreditCard :: fromArray ( $ card ) ; } return $ cards ; } 
public function deleteCard ( $ Context , $ id , $ card_id ) { $ id = str_replace ( array ( '{' , '}' , '-' ) , '' , $ id ) ; $ url = str_replace ( '<id>' , $ id , QuickBooks_Payments :: URL_CARD . '/' . $ card_id ) ; $ resp = $ this -> _http ( $ Context , $ url , null , 'DELETE' ) ; $ data = json_decode ( $ resp , true ) ; if ( $ this -> _handleError ( $ data ) ) { return false ; } return true ; } 
protected function _handleError ( $ data , $ ignore_declines = false ) { if ( ! $ data ) { 
protected function _setError ( $ errnum , $ errmsg = '' , $ type = null , $ detail = null , $ infolink = null ) { $ this -> _last_errnum = $ errnum ; $ this -> _last_errmsg = $ errmsg ; $ this -> _last_errtype = $ type ; $ this -> _last_errdetail = $ detail ; $ this -> _last_errinfolink = $ infolink ; } 
protected function _http ( $ Context , $ url_path , $ raw_body = null , $ operation = null ) { if ( $ operation !== null ) { $ method = $ operation ; } else { $ method = 'GET' ; if ( $ raw_body ) { $ method = 'POST' ; } } $ url = $ this -> _getBaseURL ( ) . $ url_path ; $ authcreds = $ Context -> authcreds ( ) ; $ params = array ( ) ; $ OAuth = new QuickBooks_IPP_OAuth ( $ this -> _oauth_consumer_key , $ this -> _oauth_consumer_secret ) ; $ signed = $ OAuth -> sign ( $ method , $ url , $ authcreds [ 'oauth_access_token' ] , $ authcreds [ 'oauth_access_token_secret' ] , $ params ) ; 
protected static function _mapToQuickBooksID ( $ func , $ user , $ type , $ ID ) { if ( strlen ( $ func ) ) { if ( false === strpos ( $ func , '::' ) ) { return $ func ( $ type , $ ID ) ; } else { $ tmp = explode ( '::' , $ func ) ; return call_user_func ( array ( $ tmp [ 0 ] , $ tmp [ 1 ] ) , $ type , $ ID ) ; } } else { $ editsequence = '' ; $ extra = null ; 
static protected function _mapToApplicationID ( $ func , $ user , $ type , $ ListID_or_TxnID ) { if ( strlen ( $ func ) ) { if ( false === strpos ( $ func , '::' ) ) { return $ func ( $ type , $ ListID_or_TxnID ) ; } else { $ tmp = explode ( '::' , $ func ) ; return call_user_func ( array ( $ tmp [ 0 ] , $ tmp [ 1 ] ) , $ type , $ ListID_or_TxnID ) ; } } else { $ extra = null ; $ Driver = QuickBooks_Driver_Singleton :: getInstance ( ) ; return $ Driver -> identToApplication ( $ user , $ type , $ ListID_or_TxnID , $ extra ) ; } } 
public static function ShipMethodAddRequest ( $ requestID , $ user , $ action , $ ID , $ extra , & $ err , $ last_action_time , $ last_actionident_time , $ version , $ locale , $ config = array ( ) , $ qbxml = null ) { return QuickBooks_Callbacks_API_Callbacks :: _doAddRequest ( $ requestID , $ user , $ action , $ ID , $ extra , $ err , $ last_action_time , $ last_actionident_time , $ version , $ locale , $ config , $ qbxml ) ; } 
static public function onAuthenticate ( $ requestID , $ user , $ hook , & $ err , $ hook_data , $ callback_config ) { $sql_query = array(); foreach (QuickBooks_Utilities::listActions('*QUERY*') as $action) { $sql_query[$action] = QuickBooks_Utilities::priorityForAction($action); } $sql_query = QuickBooks_Callbacks_SQL_Callbacks::_filterActions($sql_query, $callback_config['_only_query'], $callback_config['_dont_query'], QUICKBOOKS_QUERY); */ foreach ($sql_audit as $action => $priority) { if (!isset($sql_map[$action])) { continue; } $Driver->queueEnqueue($user, $action, 1, true, $priority); } */ SELECT " . QUICKBOOKS_DRIVER_SQL_FIELD_ID . ", " . QUICKBOOKS_DRIVER_SQL_FIELD_ERROR_NUMBER . " FROM " . QUICKBOOKS_DRIVER_SQL_PREFIX_SQL . $ table_and_field [ 0 ] . " WHERE " . QUICKBOOKS_DRIVER_SQL_FIELD_DISCOVER . " IS NOT NULL AND " . QUICKBOOKS_DRIVER_SQL_FIELD_RESYNC . " IS NOT NULL AND " . QUICKBOOKS_DRIVER_SQL_FIELD_MODIFY . " > " . QUICKBOOKS_DRIVER_SQL_FIELD_RESYNC . " AND " . QUICKBOOKS_DRIVER_SQL_FIELD_TO_DELETE . " != 1 AND " . QUICKBOOKS_DRIVER_SQL_FIELD_FLAG_DELETED . " != 1 AND " . QUICKBOOKS_DRIVER_SQL_FIELD_TO_VOID . " != 1 AND " . QUICKBOOKS_DRIVER_SQL_FIELD_TO_SKIP . " != 1 AND " . QUICKBOOKS_DRIVER_SQL_FIELD_MODIFY . " <= '" . $ NOW . "' " ; $ errnum = 0 ; $ errmsg = '' ; $ res = $ Driver -> query ( $ sql , $ errnum , $ errmsg ) ; while ( $ arr = $ Driver -> fetch ( $ res ) ) { if ( strlen ( $ arr [ QUICKBOOKS_DRIVER_SQL_FIELD_ERROR_NUMBER ] ) ) { // Do not sync this record until the error is resolved continue ; } // Queue up this MOD request $ Driver -> queueEnqueue ( $ user , $ action , $ arr [ QUICKBOOKS_DRIVER_SQL_FIELD_ID ] , true , $ priority ) ; $ actions [ ] = $ action ; // Mark the record as enqueued - let's wait until the hashing is in for this //$Driver->query(..., $errnum, $errmsg); } } } } //print('4 [' . (microtime(true) - $start) . ']' . "\n\n"); $start = microtime(true); if ( $ mode == QuickBooks_WebConnector_Server_SQL :: MODE_WRITEONLY or $ mode == QuickBooks_WebConnector_Server_SQL :: MODE_READWRITE ) { // Check if any *voided* objects need to be voided in QuickBooks foreach ( $ sql_add as $ action => $ priority ) { $ object = QuickBooks_Utilities :: actionToObject ( $ action ) ; $ dependency = null ; if ( $ object == QUICKBOOKS_OBJECT_BILL ) { // Bill VOID dependency is PurchaseOrderMod because we want to be able to manually close POs (but need to VOID the bills first) $ dependency = QUICKBOOKS_MOD_PURCHASEORDER ; } $ priority = QuickBooks_Utilities :: priorityForAction ( QUICKBOOKS_VOID_TRANSACTION , $ dependency ) ; $ table_and_field = array ( ) ; // Convert to table and primary key, select qbsql id QuickBooks_SQL_Schema :: mapPrimaryKey ( $ object , QUICKBOOKS_SQL_SCHEMA_MAP_TO_SQL , $ table_and_field ) ; //$Driver->log('Searching table: ' . print_r($table_and_field, true) . ' for VOIDED records.', null, QUICKBOOKS_LOG_DEBUG); if ( ! empty ( $ table_and_field [ 0 ] ) ) { $ sql = " SELECT " . QUICKBOOKS_DRIVER_SQL_FIELD_ID . " FROM " . QUICKBOOKS_DRIVER_SQL_PREFIX_SQL . $ table_and_field [ 0 ] . " WHERE " . QUICKBOOKS_DRIVER_SQL_FIELD_DISCOVER . " IS NOT NULL AND " . QUICKBOOKS_DRIVER_SQL_FIELD_TO_DELETE . " != 1 AND " . QUICKBOOKS_DRIVER_SQL_FIELD_FLAG_DELETED . " != 1 AND " . QUICKBOOKS_DRIVER_SQL_FIELD_TO_VOID . " = 1 AND " . QUICKBOOKS_DRIVER_SQL_FIELD_FLAG_VOIDED . " != 1 AND " . QUICKBOOKS_DRIVER_SQL_FIELD_MODIFY . " <= '" . $ NOW . "' " ; $ errnum = 0 ; $ errmsg = '' ; $ res = $ Driver -> query ( $ sql , $ errnum , $ errmsg ) ; $ extra = array ( 'object' => $ object , ) ; while ( $ arr = $ Driver -> fetch ( $ res ) ) { $ Driver -> queueEnqueue ( $ user , QUICKBOOKS_VOID_TRANSACTION , $ arr [ QUICKBOOKS_DRIVER_SQL_FIELD_ID ] , true , $ priority , $ extra ) ; } } } } //print('5 [' . (microtime(true) - $start) . ']' . "\n\n"); $start = microtime(true); if ( $ mode == QuickBooks_WebConnector_Server_SQL :: MODE_WRITEONLY or $ mode == QuickBooks_WebConnector_Server_SQL :: MODE_READWRITE ) { // Check if any *deleted* objects need to be deleted from QuickBooks foreach ( $ sql_add as $ action => $ priority ) { break ; $ priority = 1000 - $ priority ; $ object = QuickBooks_Utilities :: actionToObject ( $ action ) ; $ table_and_field = array ( ) ; // Convert to table and primary key, select qbsql id QuickBooks_SQL_Schema :: mapPrimaryKey ( $ object , QUICKBOOKS_SQL_SCHEMA_MAP_TO_SQL , $ table_and_field ) ; // Delete if it's marked for deletion and it hasn't been deleted already if ( ! empty ( $ table_and_field [ 0 ] ) ) { $ sql = " SELECT " . QUICKBOOKS_DRIVER_SQL_FIELD_ID . " FROM " . QUICKBOOKS_DRIVER_SQL_PREFIX_SQL . $ table_and_field [ 0 ] . " WHERE " . QUICKBOOKS_DRIVER_SQL_FIELD_TO_DELETE . " = 1 AND " . QUICKBOOKS_DRIVER_SQL_FIELD_FLAG_DELETED . " != 1 AND " . QUICKBOOKS_DRIVER_SQL_FIELD_MODIFY . " <= '" . $ NOW . "' " ; $ errnum = 0 ; $ errmsg = '' ; $ res = $ Driver -> query ( $ sql , $ errnum , $ errmsg ) ; $ key = QuickBooks_Utilities :: keyForAction ( $ action ) ; if ( $ key == 'ListID' ) { $ useAction = 'ListDel' ; } else { $ useAction = 'TxnDel' ; } $ extra [ 'objectType' ] = $ object ; while ( $ arr = $ Driver -> fetch ( $ res ) ) { $ Driver -> queueEnqueue ( $ user , $ useAction , $ extra [ 'objectType' ] . $ arr [ QUICKBOOKS_DRIVER_SQL_FIELD_ID ] , true , $ priority , $ extra ) ; } } } } //print('6 [' . (microtime(true) - $start) . ']' . "\n\n"); $start = microtime(true); /* // This makes sure that timestamps are set up for every action we're doing (fixes a bug where timestamps never get recorded on initial sync without iterator) foreach ($actions as $action) { $module = __CLASS__; $key_curr = QuickBooks_Callbacks_SQL_Callbacks::_keySyncCurr($action); $key_prev = QuickBooks_Callbacks_SQL_Callbacks::_keySyncPrev($action); $type = null; $opts = null; $curr_sync_datetime = $Driver->configRead($user, $module, $key_curr, $type, $opts); // last sync started... $prev_sync_datetime = $Driver->configRead($user, $module, $key_prev, $type, $opts); // last sync started... $datetime = QuickBooks_Utilities::datetime('1983-01-02'); if (!$curr_sync_datetime) { $Driver->configWrite($user, $module, $key_curr, $datetime, null); } if (!$prev_sync_datetime) { $Driver->configWrite($user, $module, $key_prev, $datetime, null); } } */ //print("\n\n" . 'here [ ' . (microtime(true) - $_start) . ']' . "\n\n\n"); return true ; } 
static protected function _filterActions ( $ action_to_priority , $ only_do , $ dont_do , $ type ) { $ start = microtime ( true ) ; foreach ( $ action_to_priority as $ action => $ priority ) { 
protected static function _requiredVersion ( $ required , $ current , $ locale = QUICKBOOKS_LOCALE_US , $ action = null ) { if ( $ locale == QUICKBOOKS_LOCALE_US ) { return $ current >= $ required ; } return true ; } 
protected static function _requiredVersionForElement ( $ required , $ current , $ element , $ locale = QUICKBOOKS_LOCALE_US , $ action = null ) { if ( $ locale = QUICKBOOKS_LOCALE_US ) { if ( $ current >= $ required ) { return $ element ; } } return '' ; } 
protected static function _buildIterator ( $ extra , $ version = null , $ locale = null ) { $ xml = "" ; if ( $ locale == QUICKBOOKS_LOCALE_CA or $ locale == QUICKBOOKS_LOCALE_UK or $ locale == QUICKBOOKS_LOCALE_AU ) { return '' ; } if ( is_array ( $ extra ) and ! empty ( $ extra [ 'iteratorID' ] ) ) { $ xml .= ' iterator="Continue" iteratorID="' . $ extra [ 'iteratorID' ] . '" ' ; } else { $ xml .= ' iterator="Start" ' ; } $ xml .= '>' . "\n" ; $ xml .= "\t" . '<MaxReturned>' ; if ( is_array ( $ extra ) and ! empty ( $ extra [ 'maxReturned' ] ) ) { $ xml .= $ extra [ 'maxReturned' ] ; } else { $ xml .= QUICKBOOKS_SERVER_SQL_ITERATOR_MAXRETURNED ; } $ xml .= '</MaxReturned' ; return $ xml ; } 
public static function InventoryLevelsResponse ( $ requestID , $ user , $ action , $ ID , $ extra , & $ err , $ last_action_time , $ last_actionident_time , $ xml , $ idents , $ callback_config = array ( ) ) { $ Driver = QuickBooks_Driver_Singleton :: getInstance ( ) ; $ col_defs = array ( ) ; Inventory for "another inventory": Array ( [FullName] => another inventory [Blank] => another inventory [ItemDesc] => [ItemVendor] => [ReorderPoint] => 5 [QuantityOnHand] => 35 [SuggestedReorder] => false [QuantityOnOrder] => 0 [EarliestReceiptDate] => [SalesPerWeek] => 0 ) */ $ Driver -> log ( 'Inventory for "' . $ item [ 'FullName' ] . '": ' . print_r ( $ item , true ) , null , QUICKBOOKS_LOG_DEBUG ) ; UPDATE " . QUICKBOOKS_DRIVER_SQL_PREFIX_SQL . "iteminventory SET QuantityOnHand = " . ( float ) $ item [ 'QuantityOnHand' ] . ", QuantityOnOrder = " . ( float ) $ item [ 'QuantityOnOrder' ] . ", QuantityOnSalesOrder = " . ( float ) $ item [ 'QuantityOnSalesOrder' ] . ", qbsql_resync_datetime = '%s', qbsql_modify_timestamp = '%s' WHERE FullName = '%s' AND qbsql_resync_datetime = qbsql_modify_timestamp " ; $ datetime = date ( 'Y-m-d H:i:s' ) ; $ vars1 = array ( $ datetime , $ datetime , $ item [ 'FullName' ] ) ; $ errnum = null ; $ errmsg = null ; $ Driver -> query ( $ sql1 , $ errnum , $ errmsg , 0 , 1 , $ vars1 ) ; //$Driver->log($sql1, null, QUICKBOOKS_LOG_DEBUG); if ( ! $ Driver -> affected ( ) ) { $ sql2 = " UPDATE " . QUICKBOOKS_DRIVER_SQL_PREFIX_SQL . "iteminventory SET QuantityOnHand = " . ( float ) $ item [ 'QuantityOnHand' ] . ", QuantityOnOrder = " . ( float ) $ item [ 'QuantityOnOrder' ] . ", QuantityOnSalesOrder = " . ( float ) $ item [ 'QuantityOnSalesOrder' ] . " WHERE FullName = '%s' " ; $ vars2 = array ( $ item [ 'FullName' ] ) ; $ errnum = null ; $ errmsg = null ; $ Driver -> query ( $ sql2 , $ errnum , $ errmsg , 0 , 1 , $ vars2 ) ; 
public static function ListDeletedQueryRequest ( $ requestID , $ user , $ action , $ ID , $ extra , & $ err , $ last_action_time , $ last_actionident_time , $ version , $ locale , $ config = array ( ) ) { $ xml = '' ; if ( ! QuickBooks_Callbacks_SQL_Callbacks :: _requiredVersion ( 2.0 , $ version , $ locale , QUICKBOOKS_DEL_LIST ) ) { return QUICKBOOKS_SKIP ; } $ xml .= '<?xml version="1.0" encoding="utf-8"?> <?qbxml version="' . QuickBooks_Callbacks_SQL_Callbacks :: _version ( $ version , $ locale ) . '"?> <QBXML> <QBXMLMsgsRq onError="' . QUICKBOOKS_SERVER_SQL_ON_ERROR . '"> <ListDeletedQueryRq requestID="' . $ requestID . '"> <ListDelType>Account</ListDelType> <ListDelType>BillingRate</ListDelType> <ListDelType>Class</ListDelType> <ListDelType>Customer</ListDelType> <ListDelType>CustomerMsg</ListDelType> <ListDelType>CustomerType</ListDelType> <ListDelType>DateDrivenTerms</ListDelType> <ListDelType>Employee</ListDelType> <ListDelType>ItemDiscount</ListDelType> <ListDelType>ItemFixedAsset</ListDelType> <ListDelType>ItemGroup</ListDelType> <ListDelType>ItemInventory</ListDelType> <ListDelType>ItemInventoryAssembly</ListDelType> <ListDelType>ItemNonInventory</ListDelType> <ListDelType>ItemOtherCharge</ListDelType> <ListDelType>ItemPayment</ListDelType> <ListDelType>ItemSalesTax</ListDelType> <ListDelType>ItemSalesTaxGroup</ListDelType> <ListDelType>ItemService</ListDelType> <ListDelType>ItemSubtotal</ListDelType> <ListDelType>JobType</ListDelType> <ListDelType>OtherName</ListDelType> <ListDelType>PaymentMethod</ListDelType> <ListDelType>PayrollItemNonWage</ListDelType> <ListDelType>PayrollItemWage</ListDelType> <ListDelType>PriceLevel</ListDelType> <ListDelType>SalesRep</ListDelType> <ListDelType>SalesTaxCode</ListDelType> <ListDelType>ShipMethod</ListDelType> <ListDelType>StandardTerms</ListDelType> <ListDelType>ToDo</ListDelType> <ListDelType>UnitOfMeasureSet</ListDelType> <ListDelType>Vehicle</ListDelType> <ListDelType>Vendor</ListDelType> <ListDelType>VendorType</ListDelType> ' . QuickBooks_Callbacks_SQL_Callbacks :: _buildFilter ( $ user , $ action , $ extra , true ) . ' </ListDeletedQueryRq> </QBXMLMsgsRq> </QBXML>' ; return $ xml ; } 
public static function ListDeletedQueryResponse ( $ requestID , $ user , $ action , $ ID , $ extra , & $ err , $ last_action_time , $ last_actionident_time , $ xml , $ idents , $ config = array ( ) ) { $ Driver = QuickBooks_Driver_Singleton :: getInstance ( ) ; $ Parser = new QuickBooks_XML_Parser ( $ xml ) ; $ errnum = 0 ; $ errmsg = '' ; $ Doc = $ Parser -> parse ( $ errnum , $ errmsg ) ; $ Root = $ Doc -> getRoot ( ) ; $ List = $ Root -> getChildAt ( 'QBXML QBXMLMsgsRs ListDeletedQueryRs' ) ; foreach ( $ List -> children ( ) as $ Node ) { $ map = array ( ) ; $ others = array ( ) ; QuickBooks_SQL_Schema :: mapToSchema ( trim ( QuickBooks_Utilities :: objectToXMLElement ( $ Node -> getChildDataAt ( 'ListDeletedRet ListDelType' ) ) ) , QUICKBOOKS_SQL_SCHEMA_MAP_TO_SQL , $ map , $ others ) ; if ( isset ( $ map [ 0 ] ) ) { $ table = $ map [ 0 ] ; $ data = array ( 'qbsql_flag_deleted' => 1 , ) ; $ multipart = array ( 'ListID' => $ Node -> getChildDataAt ( 'ListDeletedRet ListID' ) ) ; $ Driver -> update ( QUICKBOOKS_DRIVER_SQL_PREFIX_SQL . $ table , $ data , array ( $ multipart ) ) ; } } return true ; } 
public static function TxnVoidRequest ( $ requestID , $ user , $ action , $ ID , $ extra , & $ err , $ last_action_time , $ last_actionident_time , $ version , $ locale , $ config = array ( ) ) { $ Driver = QuickBooks_Driver_Singleton :: getInstance ( ) ; if ( $ arr = $ Driver -> get ( QUICKBOOKS_DRIVER_SQL_PREFIX_SQL . strtolower ( $ extra [ 'object' ] ) , array ( QUICKBOOKS_DRIVER_SQL_FIELD_ID => $ ID ) ) ) { $ xml = '' ; $ xml .= '<?xml version="1.0" encoding="utf-8"?> <?qbxml version="' . QuickBooks_Callbacks_SQL_Callbacks :: _version ( $ version , $ locale ) . '"?> <QBXML> <QBXMLMsgsRq onError="stopOnError"> <TxnVoidRq requestID="' . $ requestID . '"> <TxnVoidType>' . $ extra [ 'object' ] . '</TxnVoidType> <TxnID>' . $ arr [ 'TxnID' ] . '</TxnID> </TxnVoidRq> </QBXMLMsgsRq> </QBXML>' ; return $ xml ; } return '' ; } 
public static function TxnVoidResponse ( $ requestID , $ user , $ action , $ ID , $ extra , & $ err , $ last_action_time , $ last_actionident_time , $ xml , $ idents , $ config = array ( ) ) { $ Driver = QuickBooks_Driver_Singleton :: getInstance ( ) ; 
public static function CustomerDeriveRequest ( $ requestID , $ user , $ action , $ ID , $ extra , & $ err , $ last_action_time , $ last_actionident_time , $ version , $ locale , $ config = array ( ) ) { if ( ! empty ( $ extra [ 'ListID' ] ) ) { $ xml = '' ; $ xml .= '<?xml version="1.0" encoding="utf-8"?> <?qbxml version="' . $ version . '"?> <QBXML> <QBXMLMsgsRq onError="' . QUICKBOOKS_SERVER_SQL_ON_ERROR . '"> <CustomerQueryRq requestID="' . $ requestID . '"> <ListID>' . $ extra [ 'ListID' ] . '</ListID> </CustomerQueryRq> </QBXMLMsgsRq> </QBXML>' ; return $ xml ; } else if ( ! empty ( $ extra [ 'FullName' ] ) ) { $ xml = '' ; $ xml .= '<?xml version="1.0" encoding="utf-8"?> <?qbxml version="' . $ version . '"?> <QBXML> <QBXMLMsgsRq onError="' . QUICKBOOKS_SERVER_SQL_ON_ERROR . '"> <CustomerQueryRq requestID="' . $ requestID . '"> <FullName>' . QuickBooks_Cast :: cast ( QUICKBOOKS_OBJECT_CUSTOMER , 'FullName' , $ extra [ 'FullName' ] ) . '</FullName> </CustomerQueryRq> </QBXMLMsgsRq> </QBXML>' ; return $ xml ; } $ err = '' . __METHOD__ . ' called without a proper $extra array: ' . print_r ( $ extra , true ) ; return '' ; 
public static function CustomerDeriveResponse ( $ requestID , $ user , $ action , $ ID , $ extra , & $ err , $ last_action_time , $ last_actionident_time , $ xml , $ idents , $ config = array ( ) ) { return QuickBooks_Callbacks_SQL_Callbacks :: _deriveResponse ( 'QBXML QBXMLMsgsRs CustomerQueryRs' , QUICKBOOKS_OBJECT_CUSTOMER , $ requestID , $ user , $ action , $ ID , $ extra , $ err , $ last_action_time , $ last_actionident_time , $ xml , $ idents , $ config ) ; } 
public static function InvoiceDeriveRequest ( $ requestID , $ user , $ action , $ ID , $ extra , & $ err , $ last_action_time , $ last_actionident_time , $ version , $ locale , $ config = array ( ) ) { <?qbxml version="' . $ version . '"?> <QBXML> <QBXMLMsgsRq onError="' . QUICKBOOKS_SERVER_SQL_ON_ERROR . '"> <InvoiceQueryRq requestID="' . $ requestID . '"> <TxnID>' . $ extra [ 'TxnID' ] . '</TxnID> </InvoiceQueryRq> </QBXMLMsgsRq> </QBXML>' ; return $ xml ; } else if ( $ arr = $ Driver -> get ( QUICKBOOKS_DRIVER_SQL_PREFIX_SQL . 'invoice' , array ( QUICKBOOKS_DRIVER_SQL_FIELD_ID => $ ID ) ) ) { $ xml = '' ; $ xml .= '<?xml version="1.0" encoding="utf-8"?> <?qbxml version="' . $ version . '"?> <QBXML> <QBXMLMsgsRq onError="' . QUICKBOOKS_SERVER_SQL_ON_ERROR . '"> <InvoiceQueryRq requestID="' . $ requestID . '"> <TxnID>' . $ arr [ 'TxnID' ] . '</TxnID> </InvoiceQueryRq> </QBXMLMsgsRq> </QBXML>' ; return $ xml ; } $ err = '' . __METHOD__ . ' called without a proper $extra array: ' . print_r ( $ extra , true ) ; return '' ; 
public static function InvoiceDeriveResponse ( $ requestID , $ user , $ action , $ ID , $ extra , & $ err , $ last_action_time , $ last_actionident_time , $ xml , $ idents , $ config = array ( ) ) { return QuickBooks_Callbacks_SQL_Callbacks :: _deriveResponse ( 'QBXML QBXMLMsgsRs InvoiceQueryRs' , QUICKBOOKS_OBJECT_INVOICE , $ requestID , $ user , $ action , $ ID , $ extra , $ err , $ last_action_time , $ last_actionident_time , $ xml , $ idents , $ config ) ; } 
public static function SalesReceiptModRequest ( $ requestID , $ user , $ action , $ ID , $ extra , & $ err , $ last_action_time , $ last_actionident_time , $ version , $ locale , $ config = array ( ) ) { $ Driver = QuickBooks_Driver_Singleton :: getInstance ( ) ; if ( $ SalesReceipt = $ Driver -> get ( QUICKBOOKS_DRIVER_SQL_PREFIX_SQL . 'salesreceipt' , array ( QUICKBOOKS_DRIVER_SQL_FIELD_ID => $ ID ) ) ) { return QuickBooks_Callbacks_SQL_Callbacks :: _AddRequest ( QUICKBOOKS_OBJECT_SALESRECEIPT , $ SalesReceipt , $ requestID , $ user , $ action , $ ID , $ extra , $ err , $ last_action_time , $ last_actionident_time , $ version , $ locale , $ config ) ; } return '' ; } 
public static function JobTypeAddRequest ( $ requestID , $ user , $ action , $ ID , $ extra , & $ err , $ last_action_time , $ last_actionident_time , $ version , $ locale , $ config = array ( ) ) { $ Driver = QuickBooks_Driver_Singleton :: getInstance ( ) ; if ( $ JobType = $ Driver -> get ( QUICKBOOKS_DRIVER_SQL_PREFIX_SQL . 'jobtype' , array ( QUICKBOOKS_DRIVER_SQL_FIELD_ID => $ ID ) ) ) { return QuickBooks_Callbacks_SQL_Callbacks :: _AddRequest ( QUICKBOOKS_OBJECT_JOBTYPE , $ JobType , $ requestID , $ user , $ action , $ ID , $ extra , $ err , $ last_action_time , $ last_actionident_time , $ version , $ locale , $ config ) ; } return '' ; } 
protected static function _AddRequest ( $ type , $ Object , $ requestID , $ user , $ action , $ ID , $ extra , & $ err , $ last_action_time , $ last_actionident_time , $ version , $ locale , $ config = array ( ) ) { ( strlen($Object->get($begi . 'City')) or strlen($Object->get($begi . 'State')) or strlen($Object->get($begi . 'Country')) or strlen($Object->get($begi . 'PostalCode')) )) { continue; } */ ; </QBXMLMsgsRq> </QBXML>' ; return $ xml ; } 
protected static function _updateRelatives ( $ table , $ user , $ action , $ ID , $ object , $ extra , $ callback_config = array ( ) , $ deleteDataExt = false , $ fullDelete = false ) { $ update_relatives_map = array ( 'account' => array ( 'id_field' => 'ListID' , 'relatives' => array ( 'invoice' => 'ARAccount_ListID' ) ) , 'bill' => array ( 'id_field' => 'TxnID' , 'relatives' => array ( 'billpaymentcheck_appliedtotxn' => 'ToTxnID' , 'billpaymentcreditcard_appliedtotxn' => 'ToTxnID' , "billingrate" => array( "id_field" => "ListID", "relatives" => array( "billingrate_billingrateperitem" => "BillingRate_ListID" ) ), "billpaymentcheck" => array( "id_field" => "ListID", "relatives" => array( "billpaymentcheck_appliedtotxn" => "FromTxnID", "dataext" => "Entity_ListID" ) ), "billpaymentcreditcard" => array( "id_field" => "ListID", "relatives" => array( "billpaymentcreditcard_appliedtotxn" => "FromTxnID", "dataext" => "Entity_ListID" ) ), "charge" => array( "id_field" => "TxnID", "relatives" => array( "dataext" => "Txn_TxnID" ) ), "check" => array( "id_field" => "TxnID", "relatives" => array( "check_expenseline" => "Check_TxnID", "check_itemgroupline" => "Check_TxnID", "check_itemgroupline_itemline" => "Check_TxnID", "check_itemline" => "Check_TxnID", "check_linkedtxn" => "FromTxnID", "dataext" => "Txn_TxnID" ) ), "company" => array( "id_field" => "CompanyName", "relatives" => array( "company_subscribedservices_service" => "Company_CompanyName" ) ), "creditcardcharge" => array( "id_field" => "TxnID", "relatives" => array( "creditcardcharge_expenseline" => "CreditCardCharge_TxnID", "creditcardcharge_itemgroupline" => "CreditCardCharge_TxnID", "creditcardcharge_itemgroupline_itemline" => "CreditCardCharge_TxnID", "creditcardcharge_itemline" => "CreditCardCharge_TxnID", "dataext" => "Txn_TxnID" ) ), "creditcardcredit" => array( "id_field" => "TxnID", "relatives" => array( "creditcardcredit_expenseline" => "CreditCardCredit_TxnID", "creditcardcredit_itemgroupline" => "CreditCardCredit_TxnID", "creditcardcredit_itemgroupline_itemline" => "CreditCardCredit_TxnID", "creditcardcredit_itemline" => "CreditCardCredit_TxnID", "dataext" => "Txn_TxnID" ) ), "creditmemo" => array( "id_field" => "TxnID", "relatives" => array( "creditmemo_creditmemoline" => "CreditMemo_TxnID", "creditmemo_creditmemolinegroup" => "CreditMemo_TxnID", "creditmemo_creditmemolinegroup_creditmemoline" => "CreditMemo_TxnID", "creditmemo_linkedtxn" => "FromTxnID", "dataext" => "Txn_TxnID" ) ), "creditmemolinegroup" => array( "id_field" => "TxnLineID", "relatives" => array( "dataext" => "Txn_TxnID" ) ), "creditmemolinegroup_creditmemoline" => array( "id_field" => "TxnLineID", "relatives" => array( "dataext" => "Txn_TxnID" ) ), */ 'customer' => array ( 'id_field' => 'ListID' , 'relatives' => array ( 'estimate' => 'Customer_ListID' , 'salesorder' => 'Customer_ListID' , 'purchaseorder_purchaseorderline' => 'Customer_ListID' , 'invoice' => 'Customer_ListID' , 'receivepayment' => 'Customer_ListID' , 'purchaseorder' => 'ShipToEntity_ListID' , 'salesreceipt' => 'Customer_ListID' , ) ) , "employee" => array ( "id_field" => "ListID" , "relatives" => array ( "salesrep" => "SalesRepEntity_ListID" ) ) , 'invoice' => array ( 'id_field' => 'TxnID' , 'relatives' => array ( 'estimate_linkedtxn' => 'ToTxnID' , 'salesorder_linkedtxn' => 'ToTxnID' , 'receivepayment_appliedtotxn' => 'ToTxnID' , "invoice_invoiceline" => array( "id_field" => "TxnLineID", "relatives" => array( "dataext" => "Txn_TxnID" ) ), "invoice_invoicelinegroup" => array( "id_field" => "TxnLineID", "relatives" => array( "dataext" => "Txn_TxnID" ) ), "invoice_invoicelinegroup_invoiceline" => array( "id_field" => "TxnLineID", "relatives" => array( "dataext" => "Txn_TxnID" ) ), "itemgroup" => array( "id_field" => "ListID", "relatives" => array( "itemgroup_itemgroupline" => "ItemGroup_ListID", "dataext" => "Entity_ListID" ) ), */ "iteminventory" => array ( "id_field" => "ListID" , "relatives" => array ( "estimate_estimateline" => "Item_ListID" , "salesorder_salesorderline" => "Item_ListID" , "purchaseorder_purchaseorderline" => "Item_ListID" , "invoice_invoiceline" => "Item_ListID" ) ) , "itemnoninventory" => array ( "id_field" => "ListID" , "relatives" => array ( "estimate_estimateline" => "Item_ListID" , "salesorder_salesorderline" => "Item_ListID" , "purchaseorder_purchaseorderline" => "Item_ListID" , "invoice_invoiceline" => "Item_ListID" ) ) , "itemdiscount" => array ( "id_field" => "ListID" , "relatives" => array ( "estimate_estimateline" => "Item_ListID" , "salesorder_salesorderline" => "Item_ListID" , "purchaseorder_purchaseorderline" => "Item_ListID" , "invoice_invoiceline" => "Item_ListID" ) ) , "itemfixedasset" => array ( "id_field" => "ListID" , "relatives" => array ( "estimate_estimateline" => "Item_ListID" , "salesorder_salesorderline" => "Item_ListID" , "purchaseorder_purchaseorderline" => "Item_ListID" , "invoice_invoiceline" => "Item_ListID" ) ) , "itemothercharge" => array ( "id_field" => "ListID" , "relatives" => array ( "estimate_estimateline" => "Item_ListID" , "salesorder_salesorderline" => "Item_ListID" , "purchaseorder_purchaseorderline" => "Item_ListID" , "invoice_invoiceline" => "Item_ListID" ) ) , "itempayment" => array ( "id_field" => "ListID" , "relatives" => array ( "estimate_estimateline" => "Item_ListID" , "salesorder_salesorderline" => "Item_ListID" , "purchaseorder_purchaseorderline" => "Item_ListID" , "invoice_invoiceline" => "Item_ListID" ) ) , "itemsalestax" => array ( "id_field" => "ListID" , "relatives" => array ( "estimate_estimateline" => "Item_ListID" , "salesorder_salesorderline" => "Item_ListID" , "purchaseorder_purchaseorderline" => "Item_ListID" , "invoice_invoiceline" => "Item_ListID" ) ) , "itemservice" => array ( "id_field" => "ListID" , "relatives" => array ( "estimate_estimateline" => "Item_ListID" , "salesorder_salesorderline" => "Item_ListID" , "purchaseorder_purchaseorderline" => "Item_ListID" , "invoice_invoiceline" => "Item_ListID" ) ) , "itemsubtotal" => array ( "id_field" => "ListID" , "relatives" => array ( "estimate_estimateline" => "Item_ListID" , "salesorder_salesorderline" => "Item_ListID" , "purchaseorder_purchaseorderline" => "Item_ListID" , "invoice_invoiceline" => "Item_ListID" ) ) , "purchaseorder" => array ( "id_field" => 'TxnID' , "relatives" => array ( "purchaseorder_purchaseorderline" => array( "id_field" => "TxnLineID", "relatives" => array( "dataext" => "Txn_TxnID" ) ), "purchaseorder_purchaseorderlinegroup" => array( "id_field" => "TxnLineID", "relatives" => array( "dataext" => "Txn_TxnID" ) ), "purchaseorder_purchaseorderlinegroup_purchaseorderline" => array( "id_field" => "TxnLineID", "relatives" => array( "dataext" => "Txn_TxnID" ) ), "receievepayment" => array( "id_field" => "TxnID", "relatives" => array( "receivepayment_appliedtotxn" => "FromTxnID", "dataext" => "Txn_TxnID" ) ), "salesorder" => array( "id_field" => "TxnID", "relatives" => array( "salesorder_salesorderline" => "SalesOrder_TxnID", "salesorder_salesorderlinegroup" => "SalesOrder_TxnID", "salesorder_salesorderlinegroup_salesorderline" => "SalesOrder_TxnID", "salesorder_linkedtxn" => "FromTxnID", "dataext" => "Entity_ListID" ) ), "salesorder_salesorderline" => array( "id_field" => "TxnLineID", "relatives" => array( "dataext" => "Txn_TxnID" ) ), "salesorder_salesorderlinegroup" => array( "id_field" => "TxnLineID", "relatives" => array( "dataext" => "Txn_TxnID" ) ), "salesorder_salesorderlinegroup_salesorderline" => array( "id_field" => "TxnLineID", "relatives" => array( "dataext" => "Txn_TxnID" ) ), "salesreceipt" => array( "id_field" => "TxnID", "relatives" => array( "salesreceipt_salesreceiptline" => "SalesReceipt_TxnID", "salesreceipt_salesreceiptlinegroup" => "SalesReceipt_TxnID", "salesreceipt_salesreceiptlinegroup_salesreceiptline" => "SalesReceipt_TxnID", "dataext" => "Txn_TxnID" ) ), "salesreceipt_salesreceiptline" => array( "id_field" => "TxnLineID", "relatives" => array( "dataext" => "Txn_TxnID" ) ), "salereceipt_salesreceiptlinegroup" => array( "id_field" => "TxnLineID", "relatives" => array( "dataext" => "Txn_TxnID" ) ), "salesreceipt_salesreceiptlinegroup_salesreceiptline" => array( "id_field" => "TxnLineID", "relatives" => array( "dataext" => "Txn_TxnID" ) ), */ "salesrep" => array ( "id_field" => "ListID" , "relatives" => array ( "estimate" => "SalesRep_ListID" , "salesorder" => "SalesRep_ListID" , "invoice" => "SalesRep_ListID" ) ) , "salestaxcode" => array ( "id_field" => "ListID" , "relatives" => array ( "iteminventory" => "SalesTaxCode_ListID" , "iteminventoryassembly" => "SalesTaxCode_ListID" , "itemnoninventory" => "SalesTaxCode_ListID" , "itemothercharge" => "SalesTaxCode_ListID" , "itemservice" => "SalesTaxCode_ListID" , "customer" => "SalesTaxCode_ListID" , "estimate" => "CustomerSalesTaxCode_ListID" , "salesorder" => "CustomerSalesTaxCode_ListID" , "invoice" => "CustomerSalesTaxCode_ListID" ) ) , "vendor" => array ( "id_field" => "ListID" , "relatives" => array ( "purchaseorder" => "Vendor_ListID" ) ) , ) ; $ Driver = QuickBooks_Driver_Singleton :: getInstance ( ) ; if ( ! isset ( $ update_relatives_map [ $ table ] ) ) { 
protected static function _buildFilter ( $ user , $ action , $ extra , $ filter_wrap = false ) { $ Driver = QuickBooks_Driver_Singleton :: getInstance ( ) ; $ xml = '' ; $ type = '' ; $ key_prev = QuickBooks_Callbacks_SQL_Callbacks :: _keySyncPrev ( $ action ) ; $ key_curr = QuickBooks_Callbacks_SQL_Callbacks :: _keySyncCurr ( $ action ) ; $ module = __CLASS__ ; 
public function flushGroups ( array $ groups ) { $ this -> ensureCacheGroupsExist ( $ groups ) ; foreach ( $ groups as $ group ) { $ this -> cacheManager -> flushCachesInGroup ( $ group ) ; } } 
public function flushByTags ( array $ tags , $ group = null ) { foreach ( $ tags as $ tag ) { if ( $ group === null ) { $ this -> cacheManager -> flushCachesByTag ( $ tag ) ; } else { $ this -> cacheManager -> flushCachesInGroupByTag ( $ group , $ tag ) ; } } } 
public function flushByTagsAndGroups ( array $ tags , array $ groups = null ) { if ( $ groups === null ) { $ this -> flushByTags ( $ tags ) ; } else { $ this -> ensureCacheGroupsExist ( $ groups ) ; foreach ( $ groups as $ group ) { $ this -> flushByTags ( $ tags , $ group ) ; } } } 
public function find ( string $ possibleName ) : string { $ allCommands = $ this -> getNames ( ) ; $ expr = preg_replace_callback ( '{([^:]+|)}' , function ( $ matches ) { return preg_quote ( $ matches [ 1 ] , '/' ) . '[^:]*' ; } , $ possibleName ) ; $ commands = preg_grep ( '{^' . $ expr . '}' , $ allCommands ) ; if ( empty ( $ commands ) ) { $ commands = preg_grep ( '{^' . $ expr . '}i' , $ allCommands ) ; } 
public function run ( ScriptEvent $ event ) : bool { $ composer = $ event -> getComposer ( ) ; $ composerConfig = $ composer -> getConfig ( ) ; $ basePath = realpath ( substr ( $ composerConfig -> get ( 'vendor-dir' ) , 0 , - strlen ( $ composerConfig -> get ( 'vendor-dir' , $ composerConfig :: RELATIVE_PATHS ) ) ) ) ; $ commandConfiguration = [ ] ; foreach ( $ this -> extractPackageMapFromComposer ( $ composer ) as $ item ) { list ( $ package , $ installPath ) = $ item ; $ installPath = ( $ installPath ? : $ basePath ) ; $ packageName = $ package -> getName ( ) ; $ packageType = $ package -> getType ( ) ; if ( in_array ( $ packageType , [ 'metapackage' , 'typo3-cms-extension' , 'typo3-cms-framework' ] , true ) ) { 
public function isCompatible ( $ extensionKey , $ configOnly = false ) { try { if ( $ configOnly ) { return $ this -> canLoadExtLocalconfFile ( $ extensionKey ) ; } return $ this -> canLoadExtTablesFile ( $ extensionKey ) ; } catch ( \ Throwable $ e ) { return false ; } } 
private function canLoadExtLocalconfFile ( $ extensionKey ) { $ activePackages = $ this -> packageManager -> getActivePackages ( ) ; foreach ( $ activePackages as $ package ) { $ this -> loadExtLocalconfForExtension ( $ package -> getPackageKey ( ) ) ; if ( $ package -> getPackageKey ( ) === $ extensionKey ) { break ; } } return true ; } 
private function canLoadExtTablesFile ( $ extensionKey ) { $ activePackages = $ this -> packageManager -> getActivePackages ( ) ; foreach ( $ activePackages as $ package ) { 
private function loadExtLocalconfForExtension ( $ extensionKey ) { $ extensionInfo = $ GLOBALS [ 'TYPO3_LOADED_EXT' ] [ $ extensionKey ] ; 
private function loadExtTablesForExtension ( $ extensionKey ) { $ extensionInfo = $ GLOBALS [ 'TYPO3_LOADED_EXT' ] [ $ extensionKey ] ; 
private function ensureInstallationIsPossible ( array $ options ) { $ integrityCheck = $ options [ 'integrityCheck' ] ?? false ; if ( ! $ integrityCheck ) { return ; } $ isInteractive = $ options [ 'interactive' ] ?? $ this -> output -> getSymfonyConsoleInput ( ) -> isInteractive ( ) ; $ forceInstall = $ options [ 'forceInstall' ] ?? false ; $ localConfFile = PATH_typo3conf . 'LocalConfiguration.php' ; $ packageStatesFile = PATH_typo3conf . 'PackageStates.php' ; if ( ! $ forceInstall && file_exists ( $ localConfFile ) ) { $ this -> output -> outputLine ( ) ; $ this -> output -> outputLine ( '<error>TYPO3 seems to be already set up!</error>' ) ; $ proceed = $ isInteractive ; if ( $ isInteractive ) { $ this -> output -> outputLine ( ) ; $ this -> output -> outputLine ( '<info>If you continue, your <code>typo3conf/LocalConfiguration.php</code></info>' ) ; $ this -> output -> outputLine ( '<info>and <code>typo3conf/PackageStates.php</code> files will be deleted!</info>' ) ; $ this -> output -> outputLine ( ) ; $ proceed = $ this -> output -> askConfirmation ( '<info>Do you really want to proceed?</info> (<comment>no</comment>) ' , false ) ; } if ( ! $ proceed ) { $ this -> output -> outputLine ( '<error>Installation aborted!</error>' ) ; throw new InstallationFailedException ( 'Installation aborted by user' , 1529926774 ) ; } } @ unlink ( $ localConfFile ) ; @ unlink ( $ packageStatesFile ) ; clearstatcache ( ) ; if ( file_exists ( $ localConfFile ) ) { $ this -> output -> outputLine ( ) ; $ this -> output -> outputLine ( '<error>Unable to delete configuration file!</error>' ) ; $ this -> output -> outputLine ( '<error>Installation aborted!</error>' ) ; throw new InstallationFailedException ( 'Installation aborted because of insufficient premissions' , 1529926810 ) ; } } 
private function executeActionWithArguments ( $ actionName , array $ arguments = [ ] , array $ options = [ ] ) { $ actionName = strtolower ( $ actionName ) ; 
public function runCommand ( $ task = null , $ force = false , $ taskId = null ) { if ( $ taskId !== null ) { 
protected function executeScheduledTasks ( ) { 
protected function executeSingleTask ( $ taskId , $ forceExecution ) { 
public function getSafeUpdates ( ) { $ sqlStatements = $ this -> sqlReader -> getCreateTableStatementArray ( $ this -> sqlReader -> getTablesDefinitionString ( ) ) ; $ addCreateChange = $ this -> schemaMigrator -> getUpdateSuggestions ( $ sqlStatements ) ; 
public function getDestructiveUpdates ( ) { $ sqlStatements = $ this -> sqlReader -> getCreateTableStatementArray ( $ this -> sqlReader -> getTablesDefinitionString ( ) ) ; 
public function migrate ( array $ statements , array $ selectedStatements ) { return $ this -> schemaMigrator -> migrate ( $ this -> sqlReader -> getCreateTableStatementArray ( $ this -> sqlReader -> getTablesDefinitionString ( ) ) , $ selectedStatements ) ; } 
protected function renderReference ( OutputInterface $ output ) : int { putenv ( 'TYPO3_CONSOLE_RENDERING_REFERENCE=1' ) ; $ _SERVER [ 'PHP_SELF' ] = Application :: COMMAND_NAME ; $ application = $ this -> getApplication ( ) ; $ applicationDescription = new ApplicationDescription ( $ application , null , true ) ; $ commands = $ applicationDescription -> getCommands ( ) ; $ allCommands = [ ] ; foreach ( $ commands as $ command ) { if ( in_array ( $ command -> getName ( ) , $ this -> skipCommands , true ) ) { continue ; } $ argumentDescriptions = [ ] ; $ optionDescriptions = [ ] ; $ command -> mergeApplicationDefinition ( false ) ; $ commandDefinition = $ command -> getNativeDefinition ( ) ; foreach ( $ commandDefinition -> getArguments ( ) as $ argument ) { $ argumentDescriptions [ $ argument -> getName ( ) ] = $ this -> transformMarkup ( $ argument -> getDescription ( ) ) ; } foreach ( $ commandDefinition -> getOptions ( ) as $ option ) { if ( $ application -> getDefinition ( ) -> hasOption ( $ option -> getName ( ) ) ) { 
public function lockCommand ( $ redirectUrl = null ) { if ( @ is_file ( PATH_typo3conf . 'LOCK_BACKEND' ) ) { $ this -> outputLine ( '<warning>Backend is already locked.</warning>' ) ; $ this -> quit ( 0 ) ; } \ TYPO3 \ CMS \ Core \ Utility \ GeneralUtility :: writeFile ( PATH_typo3conf . 'LOCK_BACKEND' , ( string ) $ redirectUrl ) ; if ( ! @ is_file ( PATH_typo3conf . 'LOCK_BACKEND' ) ) { $ this -> outputLine ( '<error>Could not create lock file \'typo3conf/LOCK_BACKEND\'.</error>' ) ; $ this -> quit ( 2 ) ; } else { $ this -> outputLine ( '<info>Backend has been locked. Access is denied for every user until it is unlocked again.</info>' ) ; if ( $ redirectUrl !== null ) { $ this -> outputLine ( 'Any access to the backend will be redirected to: \'' . $ redirectUrl . '\'' ) ; } } } 
public function unlockCommand ( ) { if ( ! @ is_file ( PATH_typo3conf . 'LOCK_BACKEND' ) ) { $ this -> outputLine ( '<warning>Backend is already unlocked.</warning>' ) ; $ this -> quit ( 0 ) ; } unlink ( PATH_typo3conf . 'LOCK_BACKEND' ) ; if ( @ is_file ( PATH_typo3conf . 'LOCK_BACKEND' ) ) { $ this -> outputLine ( '<error>Could not remove lock file \'typo3conf/LOCK_BACKEND\'.</error>' ) ; $ this -> quit ( 2 ) ; } else { $ this -> outputLine ( '<info>Backend lock is removed. User can now access the backend again.</info>' ) ; } } 
public function lockForEditorsCommand ( ) { $ this -> ensureConfigValueModifiable ( ) ; $ lockedForEditors = $ this -> configurationService -> getLocal ( 'BE/adminOnly' ) !== self :: LOCK_TYPE_UNLOCKED ; if ( ! $ lockedForEditors ) { $ this -> configurationService -> setLocal ( 'BE/adminOnly' , self :: LOCK_TYPE_ADMIN ) ; $ this -> outputLine ( '<info>Locked backend for editor access.</info>' ) ; } else { $ this -> outputLine ( '<warning>The backend was already locked for editors, hence nothing was done.</warning>' ) ; } } 
public function unlockForEditorsCommand ( ) { $ this -> ensureConfigValueModifiable ( ) ; $ lockedForEditors = $ this -> configurationService -> getLocal ( 'BE/adminOnly' ) !== self :: LOCK_TYPE_UNLOCKED ; if ( $ lockedForEditors ) { $ this -> configurationService -> setLocal ( 'BE/adminOnly' , self :: LOCK_TYPE_UNLOCKED ) ; $ this -> outputLine ( '<info>Unlocked backend for editors.</info>' ) ; } else { $ this -> outputLine ( '<warning>The backend was not locked for editors.</warning>' ) ; } } 
public function createAdminCommand ( string $ username , string $ password ) { $ givenUsername = $ username ; $ username = strtolower ( preg_replace ( '/\\s/i' , '' , $ username ) ) ; if ( $ givenUsername !== $ username ) { $ this -> outputLine ( '<warning>Given username "%s" contains invalid characters. Using "%s" instead.</warning>' , [ $ givenUsername , $ username ] ) ; } if ( strlen ( $ username ) < 4 ) { $ this -> outputLine ( '<error>Username must be at least 4 characters.</error>' ) ; $ this -> quit ( 1 ) ; } if ( strlen ( $ password ) < 8 ) { $ this -> outputLine ( '<error>Password must be at least 8 characters.</error>' ) ; $ this -> quit ( 1 ) ; } $ connectionPool = GeneralUtility :: makeInstance ( ConnectionPool :: class ) ; $ userExists = $ connectionPool -> getConnectionForTable ( 'be_users' ) -> count ( 'uid' , 'be_users' , [ 'username' => $ username ] ) ; if ( $ userExists ) { $ this -> outputLine ( '<error>A user with username "%s" already exists.</error>' , [ $ username ] ) ; $ this -> quit ( 1 ) ; } $ adminUserFields = [ 'username' => $ username , 'password' => $ this -> salt -> getHashedPassword ( $ password ) , 'admin' => 1 , 'tstamp' => $ GLOBALS [ 'EXEC_TIME' ] , 'crdate' => $ GLOBALS [ 'EXEC_TIME' ] , ] ; $ connectionPool -> getConnectionForTable ( 'be_users' ) -> insert ( 'be_users' , $ adminUserFields ) ; $ this -> outputLine ( '<info>Created admin user with username "%s".</info>' , [ $ username ] ) ; } 
protected function execute ( InputInterface $ input , OutputInterface $ output ) { if ( $ this -> command === null ) { $ this -> command = $ this -> getApplication ( ) -> find ( $ input -> getArgument ( 'command_name' ) ) ; } if ( $ this -> command instanceof CommandControllerCommand && $ this -> command -> isLateCommand ( ) ) { $ output -> writeln ( '<warning>Registering commands via $GLOBALS[\'TYPO3_CONF_VARS\'][\'SC_OPTIONS\'][\'extbase\'][\'commandControllers\'] is deprecated and will be removed with 6.0. Register Symfony commands in Configuration/Commands.php instead.</warning>' ) ; } $ helper = new DescriptorHelper ( ) ; 
public function listWizards ( $ includeDone = false ) { if ( empty ( $ this -> listCache ) ) { $ availableUpgradeWizards = [ ] ; foreach ( $ this -> wizardRegistry as $ identifier => $ className ) { $ updateObject = $ this -> factory -> create ( $ identifier ) ; $ shortIdentifier = $ this -> factory -> getShortIdentifier ( $ identifier ) ; $ availableUpgradeWizards [ $ shortIdentifier ] = [ 'className' => $ className , 'title' => $ updateObject -> getTitle ( ) , 'done' => false , ] ; $ explanation = '' ; $ wizardImplementsInterface = $ updateObject instanceof UpgradeWizardInterface && ! $ updateObject instanceof AbstractUpdate ; $ markedAsDone = $ this -> registry -> get ( 'installUpdate' , $ className , false ) || $ this -> registry -> get ( 'installUpdate' , $ identifier , false ) ; if ( $ wizardImplementsInterface ) { $ explanation = $ updateObject -> getDescription ( ) ; $ wizardClaimsExecution = $ updateObject -> updateNecessary ( ) ; } else { $ wizardClaimsExecution = $ updateObject -> checkForUpdate ( $ explanation ) ; } if ( $ markedAsDone || ! $ wizardClaimsExecution ) { $ availableUpgradeWizards [ $ shortIdentifier ] [ 'done' ] = true ; } $ availableUpgradeWizards [ $ shortIdentifier ] [ 'explanation' ] = html_entity_decode ( strip_tags ( $ explanation ) ) ; } $ this -> listCache = $ availableUpgradeWizards ; } return array_filter ( $ this -> listCache , function ( $ info ) use ( $ includeDone ) { return $ includeDone || ! $ info [ 'done' ] ; } ) ; } 
public function setupCommand ( $ force = false , $ skipIntegrityCheck = false , $ skipExtensionSetup = false , $ installStepsConfig = null , $ databaseDriver = 'mysqli' , $ databaseUserName = '' , $ databaseUserPassword = '' , $ databaseHostName = '127.0.0.1' , $ databasePort = '3306' , $ databaseSocket = '' , $ databaseName = null , $ useExistingDatabase = false , $ adminUserName = null , $ adminPassword = null , $ siteName = 'New TYPO3 Console site' , $ webServerConfig = 'none' , $ siteSetupType = 'no' , $ nonInteractive = false ) { $ isInteractive = $ this -> output -> getSymfonyConsoleInput ( ) -> isInteractive ( ) ; if ( $ nonInteractive ) { 
public function generatePackageStatesCommand ( array $ frameworkExtensions = [ ] , array $ excludedExtensions = [ ] , $ activateDefault = false ) { if ( $ activateDefault && CompatibilityScripts :: isComposerMode ( ) ) { 
public function fixFolderStructureCommand ( ) { $ folderStructureFactory = new ExtensionFactory ( $ this -> packageManager ) ; $ fixedStatusObjects = $ folderStructureFactory -> getStructure ( ) -> fix ( ) ; if ( empty ( $ fixedStatusObjects ) ) { $ this -> outputLine ( '<info>No action performed!</info>' ) ; } else { $ this -> outputLine ( '<info>The following directory structure has been fixed:</info>' ) ; foreach ( $ fixedStatusObjects as $ fixedStatusObject ) { $ this -> outputLine ( $ fixedStatusObject -> getTitle ( ) ) ; } } } 
public function extensionSetupIfPossibleCommand ( ) { $ commandDispatcher = CommandDispatcher :: createFromCommandRun ( ) ; try { $ this -> outputLine ( $ commandDispatcher -> executeCommand ( 'database:updateschema' ) ) ; $ this -> outputLine ( $ commandDispatcher -> executeCommand ( 'cache:flush' ) ) ; $ this -> outputLine ( $ commandDispatcher -> executeCommand ( 'extension:setupactive' ) ) ; } catch ( FailedSubProcessCommandException $ e ) { $ this -> outputLine ( '<warning>Extension setup skipped.</warning>' ) ; } } 
public function databaseConnectCommand ( $ databaseUserName = '' , $ databaseUserPassword = '' , $ databaseHostName = '127.0.0.1' , $ databasePort = '3306' , $ databaseSocket = '' , $ databaseDriver = 'mysqli' ) { $ this -> executeActionWithArguments ( 'databaseConnect' , [ 'host' => $ databaseHostName , 'port' => $ databasePort , 'username' => $ databaseUserName , 'password' => $ databaseUserPassword , 'socket' => $ databaseSocket , 'driver' => $ databaseDriver ] ) ; } 
public function databaseSelectCommand ( $ databaseName , $ useExistingDatabase = false ) { $ selectType = $ useExistingDatabase ? 'existing' : 'new' ; $ this -> executeActionWithArguments ( 'databaseSelect' , [ 'type' => $ selectType , $ selectType => $ databaseName ] ) ; } 
private function executeActionWithArguments ( $ actionName , array $ arguments = [ ] , $ dryRun = false ) { $ this -> outputLine ( serialize ( $ this -> installStepActionExecutor -> executeActionWithArguments ( $ actionName , $ arguments , $ dryRun ) ) ) ; } 
public static function createFromComposerRun ( ... $ arguments ) : self { if ( isset ( $ arguments [ 0 ] ) && $ arguments [ 0 ] instanceof ScriptEvent ) { 
public static function createFromCommandRun ( array $ commandLine = [ ] , array $ environmentVars = [ ] , PhpExecutableFinder $ phpFinder = null ) : self { if ( ! isset ( $ _SERVER [ 'argv' ] [ 0 ] ) && strpos ( $ _SERVER [ 'argv' ] [ 0 ] , Application :: COMMAND_NAME ) === false ) { throw new RuntimeException ( 'Tried to create typo3 command runner from wrong context' , 1484945065 ) ; } $ typo3CommandPath = $ _SERVER [ 'argv' ] [ 0 ] ; return self :: create ( $ typo3CommandPath , $ commandLine , $ environmentVars , $ phpFinder ) ; } 
public static function create ( $ typo3CommandPath , array $ commandLine = [ ] , array $ environmentVars = [ ] , PhpExecutableFinder $ phpFinder = null ) : self { $ environmentVars [ 'TYPO3_CONSOLE_SUB_PROCESS' ] = true ; $ phpFinder = $ phpFinder ? : new PhpExecutableFinder ( ) ; if ( ! ( $ php = $ phpFinder -> find ( false ) ) ) { throw new RuntimeException ( 'The "php" binary could not be found.' , 1485128615 ) ; } array_unshift ( $ commandLine , $ typo3CommandPath ) ; $ phpArguments = $ phpFinder -> findArguments ( ) ; if ( getenv ( 'PHP_INI_PATH' ) ) { $ phpArguments [ ] = '-c' ; $ phpArguments [ ] = getenv ( 'PHP_INI_PATH' ) ; } 
public function executeCommand ( $ command , array $ arguments = [ ] , array $ envVars = [ ] , $ input = null ) : string { $ envVars = array_replace ( $ this -> environmentVars , $ envVars ) ; $ commandLine = $ this -> commandLinePrefix ; $ commandLine [ ] = $ command ; foreach ( $ arguments as $ argumentName => $ argumentValue ) { if ( is_int ( $ argumentName ) ) { $ commandLine [ ] = $ argumentValue ; } else { $ commandLine [ ] = $ this -> getDashedArgumentName ( $ argumentName ) ; $ commandLine [ ] = is_array ( $ argumentValue ) ? implode ( ',' , $ argumentValue ) : $ argumentValue ; } } $ process = $ this -> getProcess ( $ commandLine , $ envVars , $ input ) ; $ process -> run ( ) ; $ output = str_replace ( "\r\n" , "\n" , trim ( $ process -> getOutput ( ) ) ) ; if ( ! $ process -> isSuccessful ( ) ) { throw FailedSubProcessCommandException :: forProcess ( $ command , $ process ) ; } return $ output ; } 
public function handleException ( \ Throwable $ exception ) { $ this -> exceptionRenderer -> render ( $ exception , $ this -> output -> getErrorOutput ( ) ) ; echo PHP_EOL ; exit ( 1 ) ; } 
public function create ( string $ identifier ) { $ upgradeWizard = $ this -> objectManager -> get ( $ this -> getClassNameFromIdentifier ( $ identifier ) ) ; if ( $ upgradeWizard instanceof AbstractUpdate ) { $ upgradeWizard -> setIdentifier ( $ identifier ) ; } if ( $ upgradeWizard instanceof ChattyInterface ) { $ output = new BufferedOutput ( ) ; $ upgradeWizard -> setOutput ( $ output ) ; } return $ upgradeWizard ; } 
public static function expandSchemaUpdateTypes ( array $ schemaUpdateTypes ) { $ expandedSchemaUpdateTypes = [ ] ; $ schemaUpdateTypeConstants = array_values ( self :: getConstants ( ) ) ; 
protected function describeInputArgument ( InputArgument $ argument , array $ options = [ ] ) { $ totalWidth = isset ( $ options [ 'total_width' ] ) ? $ options [ 'total_width' ] : Helper :: strlen ( $ argument -> getName ( ) ) ; $ spacingWidth = $ totalWidth - strlen ( $ argument -> getName ( ) ) ; 
protected function describeInputOption ( InputOption $ option , array $ options = [ ] ) { $ totalWidth = $ options [ 'total_width' ] ?? $ this -> calculateTotalWidthForOptions ( [ $ option ] ) ; 
protected function describeApplication ( Application $ application , array $ options = [ ] ) { $ describedNamespace = isset ( $ options [ 'namespace' ] ) ? $ options [ 'namespace' ] : null ; $ description = new ApplicationDescription ( $ application , $ describedNamespace ) ; if ( isset ( $ options [ 'raw_text' ] ) && $ options [ 'raw_text' ] ) { $ width = $ this -> getColumnWidth ( $ description -> getCommands ( ) ) ; foreach ( $ description -> getCommands ( ) as $ command ) { $ this -> writeText ( sprintf ( "%-{$width}s %s" , $ command -> getName ( ) , $ command -> getDescription ( ) ) , $ options ) ; $ this -> writeText ( "\n" ) ; } } else { if ( '' !== $ help = $ application -> getHelp ( ) ) { $ this -> writeText ( "$help\n\n" , $ options ) ; } $ this -> writeText ( "<comment>Usage:</comment>\n" , $ options ) ; $ this -> writeText ( " command [options] [arguments]\n\n" , $ options ) ; $ this -> describeInputDefinition ( new InputDefinition ( $ application -> getDefinition ( ) -> getOptions ( ) ) , $ options ) ; $ this -> writeText ( "\n" ) ; $ this -> writeText ( "\n" ) ; $ commands = $ description -> getCommands ( ) ; if ( $ application instanceof \ Helhum \ Typo3Console \ Mvc \ Cli \ Symfony \ Application ) { $ showUnavailable = $ options [ 'show_unavailable' ] ?? false ; $ commands = array_filter ( $ commands , function ( $ command ) use ( $ application , $ showUnavailable ) { return $ showUnavailable || $ application -> isCommandAvailable ( $ command ) ; } ) ; } $ namespaces = $ description -> getNamespaces ( ) ; if ( $ describedNamespace && $ namespaces ) { 
private function wordWrap ( string $ stringToWrap , int $ indent , $ maxWidth ) : string { $ wrapped = $ maxWidth === null ? $ stringToWrap : wordwrap ( $ stringToWrap , $ maxWidth , "\n" , true ) ; return preg_replace ( '/\s*[\r\n]\s*/' , "\n" . str_repeat ( ' ' , $ indent ) , $ wrapped ) ; } 
private function writeText ( $ content , array $ options = [ ] ) { $ this -> write ( isset ( $ options [ 'raw_text' ] ) && $ options [ 'raw_text' ] ? strip_tags ( $ content ) : $ content , ! isset ( $ options [ 'raw_output' ] ) || ! $ options [ 'raw_output' ] ) ; } 
private function getColumnWidth ( array $ commands ) { $ widths = [ ] ; foreach ( $ commands as $ command ) { if ( $ command instanceof Command ) { $ widths [ ] = Helper :: strlen ( $ command -> getName ( ) ) ; foreach ( $ command -> getAliases ( ) as $ alias ) { $ widths [ ] = Helper :: strlen ( $ alias ) ; } } else { $ widths [ ] = Helper :: strlen ( $ command ) ; } } return $ widths ? max ( $ widths ) + 2 : 0 ; } 
public function requestCommand ( $ requestUrl ) { 
protected function makeAbsolute ( $ url ) { $ parsedUrl = parse_url ( $ url ) ; $ scheme = isset ( $ parsedUrl [ 'scheme' ] ) ? $ parsedUrl [ 'scheme' ] : 'http' ; $ host = isset ( $ parsedUrl [ 'host' ] ) ? $ parsedUrl [ 'host' ] : 'localhost' ; $ path = isset ( $ parsedUrl [ 'path' ] ) ? $ parsedUrl [ 'path' ] : '/' ; $ query = isset ( $ parsedUrl [ 'query' ] ) ? '?' . $ parsedUrl [ 'query' ] : '' ; return $ scheme . '://' . $ host . '/' . ltrim ( $ path , '/' ) . $ query ; } 
public function render ( array $ upgradeWizardResults , ConsoleOutput $ output ) { if ( empty ( $ upgradeWizardResults ) ) { return ; } foreach ( $ upgradeWizardResults as $ identifier => $ result ) { $ output -> outputLine ( ) ; if ( ! $ result -> hasPerformed ( ) ) { $ output -> outputLine ( '<warning>Skipped upgrade wizard "%s" because it was not scheduled for execution or marked as done.</warning>' , [ $ identifier ] ) ; } else { $ output -> outputLine ( '<em>Successfully executed upgrade wizard "%s".</em>' , [ $ identifier ] ) ; } if ( ! empty ( $ messages = array_filter ( $ result -> getMessages ( ) ) ) ) { $ this -> printMessages ( $ messages , 'Messages' , $ output ) ; } if ( ! empty ( $ queries = array_filter ( $ result -> getSqlQueries ( ) ) ) ) { $ this -> printMessages ( $ queries , 'SQL Queries executed' , $ output ) ; } } } 
public function checkExtensionConstraintsCommand ( array $ extensionKeys = [ ] , $ typo3Version = TYPO3_version ) { if ( empty ( $ extensionKeys ) ) { $ failedPackageMessages = $ this -> upgradeHandling -> matchAllExtensionConstraints ( $ typo3Version ) ; } else { $ failedPackageMessages = [ ] ; foreach ( $ extensionKeys as $ extensionKey ) { try { if ( ! empty ( $ result = $ this -> upgradeHandling -> matchExtensionConstraints ( $ extensionKey , $ typo3Version ) ) ) { $ failedPackageMessages [ $ extensionKey ] = $ result ; } } catch ( UnknownPackageException $ e ) { $ this -> outputLine ( '<warning>Extension "%s" is not found in the system</warning>' , [ $ extensionKey ] ) ; } } } foreach ( $ failedPackageMessages as $ constraintMessage ) { $ this -> outputLine ( '<error>%s</error>' , [ $ constraintMessage ] ) ; } if ( empty ( $ failedPackageMessages ) ) { $ this -> outputLine ( '<info>All third party extensions claim to be compatible with TYPO3 version %s</info>' , [ $ typo3Version ] ) ; } else { $ this -> quit ( 1 ) ; } } 
public function listCommand ( $ all = false ) { $ verbose = $ this -> output -> getSymfonyConsoleOutput ( ) -> isVerbose ( ) ; $ messages = [ ] ; $ wizards = $ this -> upgradeHandling -> executeInSubProcess ( 'listWizards' , [ ] , $ messages ) ; $ listRenderer = new UpgradeWizardListRenderer ( ) ; $ this -> outputLine ( '<comment>Wizards scheduled for execution:</comment>' ) ; $ listRenderer -> render ( $ wizards [ 'scheduled' ] , $ this -> output , $ verbose ) ; if ( $ all ) { $ this -> outputLine ( PHP_EOL . '<comment>Wizards marked as done:</comment>' ) ; $ listRenderer -> render ( $ wizards [ 'done' ] , $ this -> output , $ verbose ) ; } $ this -> outputLine ( ) ; foreach ( $ messages as $ message ) { $ this -> outputLine ( $ message ) ; } } 
public function wizardCommand ( $ identifier , array $ arguments = [ ] , $ force = false ) { $ messages = [ ] ; $ result = $ this -> upgradeHandling -> executeInSubProcess ( 'executeWizard' , [ $ identifier , $ arguments , $ force ] , $ messages ) ; ( new UpgradeWizardResultRenderer ( ) ) -> render ( [ $ identifier => $ result ] , $ this -> output ) ; $ this -> outputLine ( ) ; foreach ( $ messages as $ message ) { $ this -> outputLine ( $ message ) ; } } 
public function allCommand ( array $ arguments = [ ] ) { $ verbose = $ this -> output -> getSymfonyConsoleOutput ( ) -> isVerbose ( ) ; $ this -> outputLine ( PHP_EOL . '<i>Initiating TYPO3 upgrade</i>' . PHP_EOL ) ; $ messages = [ ] ; $ results = $ this -> upgradeHandling -> executeAll ( $ arguments , $ this -> output , $ messages ) ; $ this -> outputLine ( PHP_EOL . PHP_EOL . '<i>Successfully upgraded TYPO3 to version %s</i>' , [ TYPO3_version ] ) ; if ( $ verbose ) { $ this -> outputLine ( ) ; $ this -> outputLine ( '<comment>Upgrade report:</comment>' ) ; ( new UpgradeWizardResultRenderer ( ) ) -> render ( $ results , $ this -> output ) ; } $ this -> outputLine ( ) ; foreach ( $ messages as $ message ) { $ this -> outputLine ( $ message ) ; } } 
public function subProcessCommand ( $ upgradeCommand , $ arguments ) { $ arguments = unserialize ( $ arguments , [ 'allowed_classes' => false ] ) ; $ result = $ this -> upgradeHandling -> $ upgradeCommand ( ... $ arguments ) ; $ this -> output ( serialize ( $ result ) ) ; } 
public function checkExtensionCompatibilityCommand ( $ extensionKey , $ configOnly = false ) { $ this -> output ( \ json_encode ( $ this -> upgradeHandling -> isCompatible ( $ extensionKey , $ configOnly ) ) ) ; } 
public function executeSilentConfigurationUpgradesIfNeeded ( ) { if ( ! file_exists ( $ this -> configurationManager -> getLocalConfigurationFileLocation ( ) ) ) { return ; } 
public function setupExtensions ( array $ packages ) { foreach ( $ packages as $ package ) { $ this -> extensionFactory -> getExtensionStructure ( $ package ) -> fix ( ) ; $ this -> callInstaller ( 'importInitialFiles' , [ PathUtility :: stripPathSitePrefix ( $ package -> getPackagePath ( ) ) , $ package -> getPackageKey ( ) ] ) ; $ this -> extensionConfiguration -> saveDefaultConfiguration ( $ package -> getPackageKey ( ) ) ; } $ this -> schemaService -> updateSchema ( SchemaUpdateType :: expandSchemaUpdateTypes ( [ 'safe' ] ) ) ; foreach ( $ packages as $ package ) { $ relativeExtensionPath = PathUtility :: stripPathSitePrefix ( $ package -> getPackagePath ( ) ) ; $ extensionKey = $ package -> getPackageKey ( ) ; $ this -> callInstaller ( 'importStaticSqlFile' , [ $ relativeExtensionPath ] ) ; $ this -> callInstaller ( 'importT3DFile' , [ $ relativeExtensionPath ] ) ; $ this -> callInstaller ( 'emitAfterExtensionInstallSignal' , [ $ extensionKey ] ) ; } } 
public function getStructure ( ) { $ structure = $ this -> getDefaultStructureDefinition ( ) ; $ structure [ 'children' ] = $ this -> appendStructureDefinition ( $ structure [ 'children' ] , $ this -> createExtensionStructureDefinition ( $ this -> packageManager -> getActivePackages ( ) ) ) ; return new StructureFacade ( new RootNode ( $ structure ) ) ; } 
public function getExtensionStructure ( PackageInterface $ package ) { $ structure = [ 'name' => substr ( PATH_site , 0 , - 1 ) , 'targetPermission' => $ GLOBALS [ 'TYPO3_CONF_VARS' ] [ 'SYS' ] [ 'folderCreateMask' ] , 'children' => $ this -> appendStructureDefinition ( [ ] , $ this -> createExtensionStructureDefinition ( [ $ package ] ) ) , ] ; return new StructureFacade ( new RootNode ( $ structure ) ) ; } 
private function createExtensionStructureDefinition ( array $ packages ) { $ structureBase = [ ] ; foreach ( $ packages as $ package ) { $ extensionConfiguration = $ this -> packageManager -> getExtensionConfiguration ( $ package ) ; if ( isset ( $ extensionConfiguration [ 'uploadfolder' ] ) && ( bool ) $ extensionConfiguration [ 'uploadfolder' ] ) { $ structureBase [ ] = $ this -> getExtensionUploadDirectory ( $ package -> getPackageKey ( ) ) ; } if ( ! empty ( $ extensionConfiguration [ 'createDirs' ] ) ) { foreach ( explode ( ',' , $ extensionConfiguration [ 'createDirs' ] ) as $ directoryToCreate ) { $ absolutePath = GeneralUtility :: getFileAbsFileName ( trim ( $ directoryToCreate ) ) ; 
private function getDirectoryNodeByPath ( $ path ) { $ baseNode = [ ] ; $ parts = explode ( '/' , $ path ) ; $ node = & $ baseNode ; foreach ( $ parts as $ part ) { $ node [ 0 ] = [ 'name' => $ part , 'type' => DirectoryNode :: class , 'targetPermission' => $ GLOBALS [ 'TYPO3_CONF_VARS' ] [ 'SYS' ] [ 'folderCreateMask' ] , 'children' => [ ] , ] ; 
private function appendStructureDefinition ( array $ original , array $ additional ) { foreach ( $ additional as $ additionalStructure ) { $ structureKey = false ; foreach ( $ original as $ key => $ originalStructure ) { if ( $ originalStructure [ 'name' ] === $ additionalStructure [ 'name' ] ) { $ structureKey = $ key ; } } if ( $ structureKey === false ) { 
public function generateXsd ( $ viewHelperNamespace , $ xsdNamespace ) { $ viewHelperNamespace = rtrim ( $ viewHelperNamespace , '_\\' ) . $ this -> getDelimiterFromNamespace ( $ viewHelperNamespace ) ; $ classNames = $ this -> getClassNamesInNamespace ( $ viewHelperNamespace ) ; if ( count ( $ classNames ) === 0 ) { throw new Exception ( sprintf ( 'No ViewHelpers found in namespace "%s"' , $ viewHelperNamespace ) , 1330029328 ) ; } return $ this -> generateXsdFromClassNames ( $ classNames , $ xsdNamespace ) ; } 
public function generateXsdFromClassFiles ( array $ viewHelperPaths , $ xsdNamespace ) { $ classNames = $ this -> getClassNamesInPaths ( $ viewHelperPaths ) ; if ( count ( $ classNames ) === 0 ) { throw new Exception ( sprintf ( 'No ViewHelpers found in paths "%s"' , implode ( ',' , $ viewHelperPaths ) ) , 1464982249 ) ; } return $ this -> generateXsdFromClassNames ( $ classNames , $ xsdNamespace ) ; } 
protected function generateXsdFromClassNames ( array $ classNames , $ xsdNamespace ) { if ( count ( $ classNames ) === 0 ) { throw new Exception ( sprintf ( 'No ViewHelper classes given' ) , 1464984856 ) ; } $ xmlRootNode = new \ SimpleXMLElement ( '<?xml version="1.0" encoding="UTF-8"?> <xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema" targetNamespace="' . $ xsdNamespace . '"></xsd:schema>' ) ; foreach ( $ classNames as $ className ) { $ this -> generateXmlForClassName ( $ className , $ xmlRootNode ) ; } return $ xmlRootNode -> asXML ( ) ; } 
protected function generateXmlForClassName ( $ className , \ SimpleXMLElement $ xmlRootNode ) { $ reflectionClass = new \ ReflectionClass ( $ className ) ; $ tagName = $ this -> getTagNameForClass ( $ className ) ; $ xsdElement = $ xmlRootNode -> addChild ( 'xsd:element' ) ; $ xsdElement [ 'name' ] = $ tagName ; $ this -> docCommentParser -> parseDocComment ( $ reflectionClass -> getDocComment ( ) ) ; $ this -> addDocumentation ( $ this -> docCommentParser -> getDescription ( ) , $ xsdElement ) ; $ xsdComplexType = $ xsdElement -> addChild ( 'xsd:complexType' ) ; $ xsdComplexType [ 'mixed' ] = 'true' ; $ xsdSequence = $ xsdComplexType -> addChild ( 'xsd:sequence' ) ; $ xsdAny = $ xsdSequence -> addChild ( 'xsd:any' ) ; $ xsdAny [ 'minOccurs' ] = '0' ; $ xsdAny [ 'maxOccurs' ] = 'unbounded' ; $ this -> addAttributes ( $ className , $ xsdComplexType ) ; } 
protected function addAttributes ( $ className , \ SimpleXMLElement $ xsdElement ) { $ viewHelper = $ this -> objectManager -> get ( $ className ) ; $ argumentDefinitions = $ viewHelper -> prepareArguments ( ) ; foreach ( $ argumentDefinitions as $ argumentDefinition ) { $ xsdAttribute = $ xsdElement -> addChild ( 'xsd:attribute' ) ; $ xsdAttribute [ 'type' ] = 'xsd:string' ; $ xsdAttribute [ 'name' ] = $ argumentDefinition -> getName ( ) ; $ this -> addDocumentation ( $ argumentDefinition -> getDescription ( ) , $ xsdAttribute ) ; if ( $ argumentDefinition -> isRequired ( ) ) { $ xsdAttribute [ 'use' ] = 'required' ; } } } 
protected function addDocumentation ( $ documentation , \ SimpleXMLElement $ xsdParentNode ) { $ xsdAnnotation = $ xsdParentNode -> addChild ( 'xsd:annotation' ) ; $ this -> addChildWithCData ( $ xsdAnnotation , 'xsd:documentation' , $ documentation ) ; } 
protected function getClassNamesInPaths ( array $ paths ) { $ viewHelperClassFiles = [ ] ; foreach ( $ paths as $ path ) { $ viewHelperClassFiles = array_merge ( $ viewHelperClassFiles , GeneralUtility :: getAllFilesAndFoldersInPath ( [ ] , $ path , 'php' ) ) ; } $ affectedViewHelperClassNames = [ ] ; foreach ( $ viewHelperClassFiles as $ filePathAndFilename ) { try { $ potentialViewHelperClassName = $ this -> getClassNameFromFile ( $ filePathAndFilename ) ; } catch ( ParsingException $ e ) { continue ; } if ( strpos ( $ potentialViewHelperClassName , 'ViewHelpers' ) === false ) { continue ; } if ( is_subclass_of ( $ potentialViewHelperClassName , \ TYPO3 \ CMS \ Fluid \ Core \ ViewHelper \ AbstractViewHelper :: class ) || is_subclass_of ( $ potentialViewHelperClassName , \ TYPO3Fluid \ Fluid \ Core \ ViewHelper \ AbstractViewHelper :: class ) ) { if ( ! class_exists ( $ potentialViewHelperClassName ) ) { require $ filePathAndFilename ; } $ classReflection = new \ ReflectionClass ( $ potentialViewHelperClassName ) ; if ( $ classReflection -> isAbstract ( ) === true ) { continue ; } $ affectedViewHelperClassNames [ ] = $ potentialViewHelperClassName ; } } sort ( $ affectedViewHelperClassNames ) ; return $ affectedViewHelperClassNames ; } 
protected function getClassNamesInNamespace ( $ namespace ) { $ packageKey = $ this -> getPackageKeyFromNamespace ( $ namespace ) ; $ viewHelperClassFilePaths [ ] = $ this -> packageManager -> getPackage ( $ packageKey ) -> getPackagePath ( ) . 'Classes/ViewHelpers/' ; if ( $ packageKey === 'fluid' ) { $ viewHelperClassFilePaths [ ] = realpath ( PATH_site . 'typo3/' ) . '/../vendor/typo3fluid/fluid/src/ViewHelpers/' ; } return $ this -> getClassNamesInPaths ( $ viewHelperClassFilePaths ) ; } 
protected function getTagNameForClass ( $ className ) { 
protected function addChildWithCData ( \ SimpleXMLElement $ parentXmlNode , $ childNodeName , $ childNodeValue ) { $ parentDomNode = dom_import_simplexml ( $ parentXmlNode ) ; $ domDocument = new \ DOMDocument ( ) ; $ childNode = $ domDocument -> appendChild ( $ domDocument -> createElement ( $ childNodeName ) ) ; $ childNode -> appendChild ( $ domDocument -> createCDATASection ( $ childNodeValue ) ) ; $ childNodeTarget = $ parentDomNode -> ownerDocument -> importNode ( $ childNode , true ) ; $ parentDomNode -> appendChild ( $ childNodeTarget ) ; return simplexml_import_dom ( $ childNodeTarget ) ; } 
public function processRequest ( RequestInterface $ request , ResponseInterface $ response ) { if ( ! $ request instanceof Request ) { throw new UnsupportedRequestTypeException ( sprintf ( '%s only supports command line requests – requests of type "%s" given.', s atic:: cl ass, g t_class($ r e quest)) , 1 00787096); } if ( $ response instanceof Response ) { $ output = $ this -> objectManager -> get ( ConsoleOutput :: class , $ response -> getOutput ( ) , $ response -> getInput ( ) ) ; } $ this -> output = $ output ?? $ this -> objectManager -> get ( ConsoleOutput :: class ) ; $ this -> request = $ request ; $ this -> request -> setDispatched ( true ) ; $ this -> response = $ response ; $ this -> commandMethodName = $ this -> resolveCommandMethodName ( ) ; $ this -> initializeCommandMethodArguments ( ) ; $ this -> mapRequestArgumentsToControllerArguments ( ) ; $ this -> callCommandMethod ( ) ; } 
protected function resolveCommandMethodName ( ) { $ commandMethodName = $ this -> request -> getControllerCommandName ( ) . 'Command' ; if ( ! is_callable ( [ $ this , $ commandMethodName ] ) ) { throw new NoSuchCommandException ( sprintf ( 'A command method "%s()" does not exist in controller "%s".' , $ commandMethodName , get_class ( $ this ) ) , 1300902143 ) ; } return $ commandMethodName ; } 
protected function mapRequestArgumentsToControllerArguments ( ) { foreach ( $ this -> arguments as $ argument ) { $ argumentName = $ argument -> getName ( ) ; if ( $ this -> request -> hasArgument ( $ argumentName ) ) { $ argument -> setValue ( $ this -> request -> getArgument ( $ argumentName ) ) ; continue ; } if ( ! $ argument -> isRequired ( ) ) { continue ; } $ argumentValue = null ; $ commandArgumentDefinition = $ this -> objectManager -> get ( CommandArgumentDefinition :: class , $ argumentName , true , null ) ; while ( $ argumentValue === null ) { $ argumentValue = $ this -> output -> ask ( sprintf ( '<comment>Please specify the required argument "%s":</comment> ' , $ commandArgumentDefinition -> getDashedName ( ) ) ) ; } $ argument -> setValue ( $ argumentValue ) ; } } 
protected function callCommandMethod ( ) { $ preparedArguments = [ ] ; foreach ( $ this -> arguments as $ argument ) { $ preparedArguments [ ] = $ argument -> getValue ( ) ; } $ commandResult = $ this -> { $ this -> commandMethodName } ( ... $ preparedArguments ) ; if ( $ commandResult !== null ) { $ this -> outputLine ( ( string ) $ commandResult ) ; $ this -> output -> getSymfonyConsoleOutput ( ) -> getErrorOutput ( ) -> writeln ( '<warning>Returning a string from a command method is deprecated.</warning>' ) ; $ this -> output -> getSymfonyConsoleOutput ( ) -> getErrorOutput ( ) -> writeln ( '<warning>Please use $this->outputLine() instead.</warning>' ) ; } } 
protected function outputFormatted ( $ text = '' , array $ arguments = [ ] , $ leftPadding = 0 ) { $ this -> output -> outputFormatted ( $ text , $ arguments , $ leftPadding ) ; } 
protected function createDefaultLogger ( $ minimumLevel = LogLevel :: DEBUG , $ options = [ ] ) { $ options [ 'output' ] = $ this -> output -> getSymfonyConsoleOutput ( ) ; $ logger = new Logger ( get_class ( $ this ) ) ; $ logger -> addWriter ( $ minimumLevel , new ConsoleWriter ( $ options ) ) ; return $ logger ; } 
public function getShortDescription ( ) : string { $ lines = explode ( LF , $ this -> commandReflection -> getDescription ( ) ) ; return ! empty ( $ lines ) ? trim ( $ lines [ 0 ] ) : '<no description available>' ; } 
public function getDescription ( ) : string { $ lines = explode ( LF , $ this -> commandReflection -> getDescription ( ) ) ; array_shift ( $ lines ) ; $ descriptionLines = [ ] ; foreach ( $ lines as $ line ) { $ trimmedLine = trim ( $ line ) ; if ( $ descriptionLines !== [ ] || $ trimmedLine !== '' ) { $ descriptionLines [ ] = $ trimmedLine ; } } return implode ( LF , $ descriptionLines ) ; } 
public function getArgumentDefinitions ( ) : array { if ( $ this -> argumentDefinitions !== null ) { return $ this -> argumentDefinitions ; } if ( ! $ this -> hasArguments ( ) ) { return $ this -> argumentDefinitions = [ ] ; } $ this -> argumentDefinitions = [ ] ; $ commandParameters = $ this -> commandReflection -> getParameters ( ) ; $ commandParameterTags = $ this -> commandReflection -> getTagsValues ( ) [ 'param' ] ; $ i = 0 ; $ definedArguments = $ this -> getDefinedArguments ( ) ; $ definedOptions = $ this -> getDefinedOptions ( ) ; foreach ( $ commandParameters as $ commandParameterName => $ commandParameterDefinition ) { $ description = '' ; if ( isset ( $ commandParameterTags [ $ i ] ) ) { $ explodedAnnotation = preg_split ( '/\s+/' , $ commandParameterTags [ $ i ] , 3 ) ; $ description = ! empty ( $ explodedAnnotation [ 2 ] ) ? $ explodedAnnotation [ 2 ] : '' ; } $ dataType = $ commandParameterDefinition [ 'type' ] ?? 'null' ; if ( $ commandParameterDefinition [ 'array' ] ) { $ dataType = 'array' ; } $ default = $ commandParameterDefinition [ 'defaultValue' ] ?? null ; $ required = $ commandParameterDefinition [ 'optional' ] !== true ; $ isArgument = isset ( $ definedArguments [ $ commandParameterName ] ) || ( $ required && ! isset ( $ definedOptions [ $ commandParameterName ] ) ) ; $ argumentDefinition = new CommandArgumentDefinition ( $ commandParameterName , $ required , $ description , $ dataType , $ default , $ isArgument ) ; if ( $ isArgument ) { $ this -> arguments [ ] = $ argumentDefinition ; } else { $ this -> options [ ] = $ argumentDefinition ; } $ this -> argumentDefinitions [ ] = $ argumentDefinition ; $ i ++ ; } return $ this -> argumentDefinitions ; } 
private function parseDefinitions ( ) : array { $ definitions = [ ] ; $ reader = new AnnotationReader ( ) ; $ method = new \ ReflectionMethod ( $ this -> controllerClassName , $ this -> controllerCommandMethod ) ; foreach ( $ reader -> getMethodAnnotations ( $ method ) as $ annotation ) { if ( $ annotation instanceof Option ) { $ definitions [ 'Option' ] [ ] = $ annotation ; } if ( $ annotation instanceof Argument ) { $ definitions [ 'Argument' ] [ ] = $ annotation ; } if ( $ annotation instanceof Validate ) { $ definitions [ 'Validate' ] = $ annotation ; } } return $ definitions ; } 
public function getSynopsis ( $ short = false ) : string { $ key = $ short ? 'short' : 'long' ; if ( isset ( $ this -> synopsis [ $ key ] ) ) { return $ this -> synopsis [ $ key ] ; } $ elements = [ ] ; if ( $ short && $ this -> hasOptions ( ) ) { $ elements [ ] = '[options]' ; } elseif ( ! $ short ) { foreach ( $ this -> getOptions ( ) as $ argumentDefinition ) { $ value = '' ; if ( $ argumentDefinition -> acceptsValue ( ) ) { $ value = ' ' . strtoupper ( $ argumentDefinition -> getOptionName ( ) ) ; } $ elements [ ] = sprintf ( '[%s%s]' , $ argumentDefinition -> getDashedName ( ) , $ value ) ; } } if ( count ( $ elements ) && $ this -> hasRequiredArguments ( ) ) { $ elements [ ] = '[--]' ; } foreach ( $ this -> getArguments ( ) as $ argumentDefinition ) { $ elements [ ] = '<' . $ argumentDefinition -> getName ( ) . '>' ; } return $ this -> synopsis [ $ key ] = implode ( ' ' , $ elements ) ; } 
public function getRelatedCommandIdentifiers ( ) : array { if ( ! isset ( $ this -> commandReflection -> getTagsValues ( ) [ 'see' ] ) ) { return [ ] ; } $ relatedCommandIdentifiers = [ ] ; foreach ( $ this -> commandReflection -> getTagsValues ( ) [ 'see' ] as $ tagValue ) { if ( preg_match ( '/^[\\w\\._]+:[\\w]+:[\\w]+$/' , $ tagValue ) === 1 ) { $ relatedCommandIdentifiers [ ] = $ tagValue ; } } return $ relatedCommandIdentifiers ; } 
public function removeStep ( $ stepIdentifier ) { $ removedOccurrences = 0 ; foreach ( $ this -> steps as $ previousStepIdentifier => $ steps ) { foreach ( $ steps as $ index => $ step ) { if ( $ step -> getIdentifier ( ) === $ stepIdentifier ) { unset ( $ this -> steps [ $ previousStepIdentifier ] [ $ index ] ) ; $ removedOccurrences ++ ; } } } if ( $ removedOccurrences === 0 ) { throw new Exception ( sprintf ( 'Cannot remove sequence step with identifier "%s" because no such step exists in the given sequence.' , $ stepIdentifier ) , 1322591669 ) ; } } 
public function invoke ( Bootstrap $ bootstrap ) { if ( isset ( $ this -> steps [ 'start' ] ) ) { foreach ( $ this -> steps [ 'start' ] as $ step ) { $ this -> invokeStep ( $ step , $ bootstrap ) ; } } } 
protected function invokeStep ( Step $ step , Bootstrap $ bootstrap ) { $ identifier = $ step -> getIdentifier ( ) ; try { $ step ( $ bootstrap ) ; } catch ( \ Throwable $ e ) { throw new StepFailedException ( $ step , $ e ) ; } if ( isset ( $ this -> steps [ $ identifier ] ) ) { foreach ( $ this -> steps [ $ identifier ] as $ followingStep ) { $ this -> invokeStep ( $ followingStep , $ bootstrap ) ; } } } 
public function activateCommand ( array $ extensionKeys ) { 
public function deactivateCommand ( array $ extensionKeys ) { 
public function setupCommand ( array $ extensionKeys ) { $ verbose = $ this -> output -> getSymfonyConsoleOutput ( ) -> isVerbose ( ) ; $ packages = [ ] ; foreach ( $ extensionKeys as $ extensionKey ) { $ packages [ ] = $ this -> packageManager -> getPackage ( $ extensionKey ) ; } $ this -> setupExtensions ( $ packages , $ verbose ) ; } 
private function setupExtensions ( array $ packages , $ verbose = false ) { $ extensionSetupResultRenderer = new ExtensionSetupResultRenderer ( $ this -> signalSlotDispatcher ) ; $ extensionSetup = new ExtensionSetup ( new ExtensionFactory ( $ this -> packageManager ) , $ this -> getExtensionInstaller ( ) ) ; $ extensionSetup -> setupExtensions ( $ packages ) ; $ extensionKeysAsString = implode ( '", "' , array_map ( function ( PackageInterface $ package ) { return $ package -> getPackageKey ( ) ; } , $ packages ) ) ; if ( count ( $ packages ) === 1 ) { $ this -> outputLine ( '<info>Extension "%s" is now set up.</info>' , [ $ extensionKeysAsString ] ) ; } else { $ this -> outputLine ( '<info>Extensions "%s" are now set up.</info>' , [ $ extensionKeysAsString ] ) ; } if ( $ verbose ) { $ this -> outputLine ( ) ; $ extensionSetupResultRenderer -> renderSchemaResult ( $ this -> output ) ; $ extensionSetupResultRenderer -> renderExtensionDataImportResult ( $ this -> output ) ; $ extensionSetupResultRenderer -> renderExtensionFileImportResult ( $ this -> output ) ; $ extensionSetupResultRenderer -> renderImportedStaticDataResult ( $ this -> output ) ; } } 
public function setupActiveCommand ( ) { $ verbose = $ this -> output -> getSymfonyConsoleOutput ( ) -> isVerbose ( ) ; $ this -> setupExtensions ( $ this -> packageManager -> getActivePackages ( ) , $ verbose ) ; } 
public function removeInactiveCommand ( $ force = false ) { $ this -> outputLine ( '<warning>This command is deprecated and will be removed with TYPO3 Console 6.0</warning>' ) ; if ( $ force ) { $ activePackages = $ this -> packageManager -> getActivePackages ( ) ; $ this -> packageManager -> scanAvailablePackages ( ) ; foreach ( $ this -> packageManager -> getAvailablePackages ( ) as $ package ) { if ( empty ( $ activePackages [ $ package -> getPackageKey ( ) ] ) ) { $ this -> packageManager -> unregisterPackage ( $ package ) ; if ( is_dir ( $ package -> getPackagePath ( ) ) ) { GeneralUtility :: flushDirectory ( $ package -> getPackagePath ( ) ) ; $ removedPaths [ ] = PathUtility :: stripPathSitePrefix ( $ package -> getPackagePath ( ) ) ; } } } $ this -> packageManager -> forceSortAndSavePackageStates ( ) ; if ( ! empty ( $ removedPaths ) ) { $ this -> outputLine ( '<info>The following directories have been removed:</info>' . chr ( 10 ) . implode ( chr ( 10 ) , $ removedPaths ) ) ; } else { $ this -> outputLine ( '<info>Nothing was removed</info>' ) ; } } else { $ this -> outputLine ( '<warning>Operation not confirmed and has been skipped</warning>' ) ; $ this -> quit ( 1 ) ; } } 
public function listCommand ( $ active = false , $ inactive = false , $ raw = false ) { $ extensionInformation = [ ] ; if ( ! $ active || $ inactive ) { $ this -> emitPackagesMayHaveChangedSignal ( ) ; $ packages = $ this -> packageManager -> getAvailablePackages ( ) ; } else { $ packages = $ this -> packageManager -> getActivePackages ( ) ; } foreach ( $ packages as $ package ) { if ( $ inactive && $ this -> packageManager -> isPackageActive ( $ package -> getPackageKey ( ) ) ) { continue ; } $ metaData = $ package -> getPackageMetaData ( ) ; $ extensionInformation [ ] = [ 'package_key' => $ package -> getPackageKey ( ) , 'version' => $ metaData -> getVersion ( ) , 'description' => $ metaData -> getDescription ( ) , ] ; } if ( $ raw ) { $ this -> outputLine ( '%s' , [ implode ( PHP_EOL , array_column ( $ extensionInformation , 'package_key' ) ) ] ) ; } else { $ this -> output -> outputTable ( $ extensionInformation , [ 'Extension key' , 'Version' , 'Description' ] ) ; } } 
public function forceFlushDatabaseCacheTables ( ) { 
public function handleError ( $ errorLevel , $ errorMessage , $ errorFile , $ errorLine ) { if ( error_reporting ( ) === 0 ) { return ; } $ errorLevels = [ E_WARNING => 'Warning' , E_NOTICE => 'Notice' , E_USER_ERROR => 'User Error' , E_USER_WARNING => 'User Warning' , E_USER_NOTICE => 'User Notice' , E_STRICT => 'Runtime Notice' , E_RECOVERABLE_ERROR => 'Catchable Fatal Error' , ] ; if ( in_array ( $ errorLevel , ( array ) $ this -> exceptionalErrors , true ) ) { throw new \ TYPO3 \ CMS \ Core \ Error \ Exception ( $ errorLevels [ $ errorLevel ] . ': ' . $ errorMessage . ' in ' . $ errorFile . ' line ' . $ errorLine , 1 ) ; } } 
public function executeActionWithArguments ( $ actionName , array $ arguments = [ ] , $ dryRun = false ) { return $ this -> executeAction ( $ this -> createActionWithNameAndArguments ( $ actionName , $ arguments ) , $ dryRun ) ; } 
public static function register ( Event $ event , ScriptDispatcher $ scriptDispatcher ) { $ scriptDispatcher -> addInstallerScript ( new PopulateCommandConfiguration ( ) , 70 ) ; if ( ! class_exists ( \ TYPO3 \ CMS \ Core \ Composer \ InstallerScripts :: class ) && ! class_exists ( \ Helhum \ Typo3ComposerSetup \ Composer \ InstallerScripts :: class ) && $ event -> getComposer ( ) -> getRepositoryManager ( ) -> getLocalRepository ( ) -> findPackage ( 'typo3/cms' , new EmptyConstraint ( ) ) !== null ) { 
public function convertFrom ( $ source , $ targetType , array $ convertedChildProperties = [ ] , PropertyMappingConfigurationInterface $ configuration = null ) : array { if ( is_string ( $ source ) ) { if ( $ source === '' ) { return [ ] ; } return array_filter ( array_map ( 'trim' , explode ( $ this -> getConfiguredStringDelimiter ( $ configuration ) , $ source ) ) ) ; } return $ source ; } 
public function executeSilentConfigurationUpgradesIfNeeded ( ) { if ( ! file_exists ( $ this -> configurationManager -> getLocalConfigurationFileLocation ( ) ) ) { return ; } $ upgradeService = $ this -> objectManager -> get ( SilentConfigurationUpgradeService :: class ) ; $ count = 0 ; do { try { $ count ++ ; $ upgradeService -> execute ( ) ; $ redirect = false ; } catch ( RedirectException $ e ) { $ redirect = true ; $ this -> configurationManager -> exportConfiguration ( ) ; if ( $ count > 20 ) { throw new RuntimeException ( 'Too many loops when silently upgrading configuration' , 1493897404 , $ e ) ; } } } while ( $ redirect === true ) ; } 
public function render ( SchemaUpdateResult $ result , ConsoleOutput $ output , $ includeStatements = false , $ maxStatementLength = 60 ) { $ tableRows = [ ] ; foreach ( $ result -> getPerformedUpdates ( ) as $ type => $ performedUpdates ) { $ row = [ self :: $ schemaUpdateTypeLabels [ ( string ) $ type ] , count ( $ performedUpdates ) ] ; if ( $ includeStatements ) { $ row = [ self :: $ schemaUpdateTypeLabels [ ( string ) $ type ] , implode ( chr ( 10 ) . chr ( 10 ) , $ this -> getTruncatedQueries ( $ performedUpdates , $ maxStatementLength ) ) ] ; } $ tableRows [ ] = $ row ; } $ tableHeader = [ 'Type' , 'Updates' ] ; if ( $ includeStatements ) { $ tableHeader = [ 'Type' , 'SQL Statements' ] ; } if ( ! empty ( $ tableRows ) ) { $ output -> outputTable ( $ tableRows , $ tableHeader ) ; } } 
public function renderErrors ( SchemaUpdateResult $ result , ConsoleOutput $ output , $ includeStatements = false , $ maxStatementLength = 90 ) { $ tableRows = [ ] ; $ messageLength = $ includeStatements ? ( int ) ( $ maxStatementLength * .3 ) : $ maxStatementLength ; $ statementLength = ( int ) ( $ maxStatementLength * 0.6 ) ; foreach ( $ result -> getErrors ( ) as $ type => $ errors ) { $ typeLabel = self :: $ schemaUpdateTypeLabels [ ( string ) $ type ] ; foreach ( $ errors as $ error ) { $ row = [ $ typeLabel , implode ( PHP_EOL , $ this -> getTruncatedQueries ( [ $ error [ 'message' ] ] , $ messageLength ) ) ] ; if ( $ includeStatements ) { $ row = [ $ typeLabel , implode ( PHP_EOL , $ this -> getTruncatedQueries ( [ $ error [ 'statement' ] ] , $ statementLength ) ) , implode ( PHP_EOL , $ this -> getTruncatedQueries ( [ $ error [ 'message' ] ] , $ messageLength ) ) ] ; } $ tableRows [ ] = $ row ; $ tableRows [ ] = $ includeStatements ? [ '' , '' , '' ] : [ '' , '' ] ; $ typeLabel = '' ; } } $ tableHeader = [ 'Type' , 'Message' ] ; if ( $ includeStatements ) { $ tableHeader = [ 'Type' , 'SQL Statement' , 'Message' ] ; } $ output -> outputTable ( $ tableRows , $ tableHeader ) ; } 
protected function getTruncatedQueries ( array $ queries , int $ truncateAt ) : array { foreach ( $ queries as & $ query ) { $ truncatedLines = [ ] ; foreach ( explode ( chr ( 10 ) , $ query ) as $ line ) { $ truncatedLines [ ] = wordwrap ( $ line , $ truncateAt , chr ( 10 ) , true ) ; } $ query = implode ( chr ( 10 ) , $ truncatedLines ) ; } return $ queries ; } 
public function output ( $ text , array $ arguments = [ ] ) { if ( $ arguments !== [ ] ) { $ text = vsprintf ( $ text , $ arguments ) ; } if ( getenv ( 'TYPO3_CONSOLE_SUB_PROCESS' ) ) { $ this -> output -> write ( $ text , false , OutputInterface :: OUTPUT_RAW ) ; } else { $ this -> output -> write ( $ text ) ; } } 
public function outputTable ( $ rows , $ headers = null ) { $ table = $ this -> getTable ( ) ; if ( $ headers !== null ) { $ table -> setHeaders ( $ headers ) ; } $ table -> setRows ( $ rows ) ; $ table -> render ( ) ; } 
public function select ( $ question , $ choices , $ default = null , $ multiSelect = false , $ attempts = false ) { $ question = ( new ChoiceQuestion ( $ question , $ choices , $ default ) ) -> setMultiselect ( $ multiSelect ) -> setMaxAttempts ( $ attempts ) -> setErrorMessage ( 'Value "%s" is invalid' ) ; return $ this -> getQuestionHelper ( ) -> ask ( $ this -> getInput ( ) , $ this -> output , $ question ) ; } 
public function ask ( $ question , $ default = null , array $ autocomplete = null ) { $ question = ( new Question ( $ question , $ default ) ) -> setAutocompleterValues ( $ autocomplete ) ; return $ this -> getQuestionHelper ( ) -> ask ( $ this -> getInput ( ) , $ this -> output , $ question ) ; } 
public function askConfirmation ( $ question , $ default = true ) { $ question = new ConfirmationQuestion ( $ question , $ default ) ; return $ this -> getQuestionHelper ( ) -> ask ( $ this -> getInput ( ) , $ this -> output , $ question ) ; } 
public function askHiddenResponse ( $ question , $ fallback = true ) { $ question = ( new Question ( $ question ) ) -> setHidden ( true ) -> setHiddenFallback ( $ fallback ) ; return $ this -> getQuestionHelper ( ) -> ask ( $ this -> getInput ( ) , $ this -> output , $ question ) ; } 
public function askAndValidate ( $ question , $ validator , $ attempts = false , $ default = null , array $ autocomplete = null ) { $ question = ( new Question ( $ question , $ default ) ) -> setValidator ( $ validator ) -> setMaxAttempts ( $ attempts ) -> setAutocompleterValues ( $ autocomplete ) ; return $ this -> getQuestionHelper ( ) -> ask ( $ this -> getInput ( ) , $ this -> output , $ question ) ; } 
public function askHiddenResponseAndValidate ( $ question , $ validator , $ attempts = false , $ fallback = true ) { $ question = ( new Question ( $ question ) ) -> setValidator ( $ validator ) -> setMaxAttempts ( $ attempts ) -> setHidden ( true ) -> setHiddenFallback ( $ fallback ) ; return $ this -> getQuestionHelper ( ) -> ask ( $ this -> getInput ( ) , $ this -> output , $ question ) ; } 
protected function checkOrUpdateReferenceIndex ( $ dryRun , ReferenceIndexIntegrityDelegateInterface $ delegate = null ) { $ processedTables = [ ] ; $ errorCount = 0 ; $ recordCount = 0 ; $ this -> callDelegateForEvent ( $ delegate , 'willStartOperation' , [ $ this -> persistenceContext -> countAllRecordsOfAllTables ( ) ] ) ; 
protected function execute ( InputInterface $ input , OutputInterface $ output ) { $ helper = new DescriptorHelper ( ) ; $ helper -> register ( 'txt' , new TextDescriptor ( ) ) ; $ helper -> describe ( $ output , $ this -> getApplication ( ) , [ 'format' => $ input -> getOption ( 'format' ) , 'raw_text' => $ input -> getOption ( 'raw' ) , 'show_unavailable' => $ input -> getOption ( 'all' ) , 'namespace' => $ input -> getArgument ( 'namespace' ) , 'screen_width' => ( new Terminal ( ) ) -> getWidth ( ) - 4 , ] ) ; $ application = $ this -> getApplication ( ) ; if ( ! $ application instanceof Application ) { return 0 ; } if ( ! $ input -> getArgument ( 'namespace' ) && ! $ application -> isFullyCapable ( ) && ! $ input -> getOption ( 'all' ) ) { $ outputHelper = new SymfonyStyle ( $ input , $ output ) ; $ messages = [ '' , sprintf ( '<comment>TYPO3 %s.</comment>' , $ application -> hasErrors ( ) ? 'has errors' : 'is not fully set up' ) , '<comment>Command list is reduced to only show low level commands.</comment>' , sprintf ( '<comment>Not listed commands will not work until %s.</comment>' , $ application -> hasErrors ( ) ? 'the errors are fixed' : 'TYPO3 is set up' ) , sprintf ( '<comment>Run "%s --all" to list all commands.</comment>' , $ _SERVER [ 'PHP_SELF' ] ) , ] ; $ outputHelper -> getErrorStyle ( ) -> writeln ( $ messages ) ; } return null ; } 
public function writeLog ( \ TYPO3 \ CMS \ Core \ Log \ LogRecord $ record ) { $ this -> output -> write ( $ this -> wrapMessage ( vsprintf ( $ record -> getMessage ( ) , $ record -> getData ( ) ) , $ record -> getLevel ( ) ) , true ) ; return $ this ; } 
public function getPerformedUpdateTypes ( ) { $ typesCount = [ ] ; foreach ( $ this -> performedUpdates as $ type => $ performedUpdates ) { $ typesCount [ $ type ] = count ( $ performedUpdates ) ; } return $ typesCount ; } 
public function addPerformedUpdates ( SchemaUpdateType $ schemaUpdateType , array $ updates ) { $ this -> performedUpdates [ ( string ) $ schemaUpdateType ] = array_merge ( ( array ) $ this -> performedUpdates [ ( string ) $ schemaUpdateType ] , $ updates ) ; } 
public function addErrors ( SchemaUpdateType $ schemaUpdateType , array $ errors , array $ statements = [ ] ) { $ collectedErrors = [ ] ; foreach ( $ errors as $ id => $ error ) { $ collectedErrors [ ] = [ 'message' => $ error , 'statement' => $ statements [ $ id ] , ] ; } $ this -> errors [ ( string ) $ schemaUpdateType ] = array_merge ( ( array ) $ this -> errors [ ( string ) $ schemaUpdateType ] , $ collectedErrors ) ; } 
public function removeCommand ( array $ paths , $ force = false ) { foreach ( $ paths as $ path ) { if ( ! $ this -> configurationService -> localIsActive ( $ path ) ) { $ this -> outputLine ( '<warning>It seems that configuration for path "%s" is overridden.</warning>' , [ $ path ] ) ; $ this -> outputLine ( '<warning>Removing the new value might have no effect.</warning>' ) ; } if ( ! $ force && $ this -> configurationService -> hasLocal ( $ path ) ) { $ reallyDelete = $ this -> output -> askConfirmation ( 'Remove ' . $ path . ' from system configuration (TYPO3_CONF_VARS)? (yes/<b>no</b>): ' , false ) ; if ( ! $ reallyDelete ) { continue ; } } $ removed = $ this -> configurationService -> removeLocal ( $ path ) ; if ( $ removed ) { $ this -> outputLine ( '<info>Removed "%s" from system configuration.</info>' , [ $ path ] ) ; } else { $ this -> outputLine ( '<warning>Path "%s" seems invalid or empty. Nothing done!</warning>' , [ $ path ] ) ; } } } 
public function showCommand ( $ path ) { $ hasActive = $ this -> configurationService -> hasActive ( $ path ) ; $ hasLocal = $ this -> configurationService -> hasLocal ( $ path ) ; if ( ! $ hasActive && ! $ hasLocal ) { $ this -> outputLine ( '<error>No configuration found for path "%s"</error>' , [ $ path ] ) ; $ this -> quit ( 1 ) ; } $ active = null ; if ( $ hasActive ) { $ active = $ this -> configurationService -> getActive ( $ path ) ; } if ( $ this -> configurationService -> localIsActive ( $ path ) && $ hasActive ) { $ this -> outputLine ( $ this -> consoleRenderer -> render ( $ active ) ) ; } else { $ local = null ; if ( $ hasLocal ) { $ local = $ this -> configurationService -> getLocal ( $ path ) ; } $ this -> outputLine ( $ this -> consoleRenderer -> renderDiff ( $ local , $ active ) ) ; } } 
public function showActiveCommand ( $ path , $ json = false ) { if ( ! $ this -> configurationService -> hasActive ( $ path ) ) { $ this -> outputLine ( '<error>No configuration found for path "%s"</error>' , [ $ path ] ) ; $ this -> quit ( 1 ) ; } $ active = $ this -> configurationService -> getActive ( $ path ) ; $ this -> outputLine ( $ this -> consoleRenderer -> render ( $ active , $ json ) ) ; } 
public function showLocalCommand ( $ path , $ json = false ) { if ( ! $ this -> configurationService -> hasLocal ( $ path ) ) { $ this -> outputLine ( '<error>No configuration found for path "%s"</error>' , [ $ path ] ) ; $ this -> quit ( 1 ) ; } $ active = $ this -> configurationService -> getLocal ( $ path ) ; $ this -> outputLine ( $ this -> consoleRenderer -> render ( $ active , $ json ) ) ; } 
public function setCommand ( $ path , $ value , $ json = false ) { if ( ! $ this -> configurationService -> localIsActive ( $ path ) ) { $ this -> outputLine ( '<warning>It seems that configuration for path "%s" is overridden.</warning>' , [ $ path ] ) ; $ this -> outputLine ( '<warning>Writing the new value might have no effect.</warning>' ) ; } $ encodedValue = $ value ; if ( $ json ) { $ encodedValue = @ json_decode ( $ value , true ) ; } if ( $ encodedValue === null && strtolower ( $ value ) !== 'null' ) { $ this -> outputLine ( '<error>Could not decode value "%s" as json.</error>' , [ $ value ] ) ; $ this -> quit ( 2 ) ; } $ setWasAllowed = $ this -> configurationService -> setLocal ( $ path , $ encodedValue ) ; $ isApplied = $ this -> configurationService -> hasLocal ( $ path ) ; if ( ! $ setWasAllowed ) { $ this -> outputLine ( '<warning>Could not set value "%s" for configuration path "%s".</warning>' , [ $ value , $ path ] ) ; $ this -> outputLine ( '<warning>Possible reasons: configuration path is not allowed, configuration is not writable or type of value does not match given type.</warning>' , [ $ value , $ path ] ) ; $ this -> quit ( 1 ) ; } if ( $ isApplied ) { $ this -> outputLine ( '<info>Successfully set value for path "%s".</info>' , [ $ path ] ) ; } else { $ this -> outputLine ( '<warning>Value "%s" for configuration path "%s" seems not applied.</warning>' , [ $ value , $ path ] ) ; $ this -> outputLine ( '<warning>Possible reasons: changed value in AdditionalConfiguration.php or extension ext_localconf.php</warning>' ) ; } } 
public function afterInstallation ( $ keyOfInstalledExtension ) { if ( self :: EXTKEY !== $ keyOfInstalledExtension ) { return ; } $ scriptName = $ this -> isWindowsOs ( ) ? 'Scripts/' . Application :: COMMAND_NAME . '.bat' : Application :: COMMAND_NAME ; $ success = $ this -> safeCopy ( PATH_site . self :: BINARY_PATH . $ scriptName , PATH_site . basename ( $ scriptName ) ) ; if ( ! $ success ) { self :: addFlashMessage ( sprintf ( self :: COPY_FAILED_MESSAGE , $ scriptName ) , sprintf ( self :: COPY_FAILED_MESSAGE_TITLE , $ scriptName , PATH_site ) , AbstractMessage :: WARNING ) ; } else { self :: addFlashMessage ( sprintf ( self :: COPY_SUCCESS_MESSAGE , $ scriptName ) ) ; } } 
protected function addFlashMessage ( $ messageBody , $ messageTitle = '' , $ severity = AbstractMessage :: OK , $ storeInSession = true ) { if ( PHP_SAPI === 'cli' ) { return ; } if ( ! is_string ( $ messageBody ) ) { throw new \ InvalidArgumentException ( 'The message body must be of type string, "' . gettype ( $ messageBody ) . '" given.' , 1418250286 ) ; } $ flashMessage = GeneralUtility :: makeInstance ( \ TYPO3 \ CMS \ Core \ Messaging \ FlashMessage :: class , $ messageBody , $ messageTitle , $ severity , $ storeInSession ) ; $ queue = GeneralUtility :: makeInstance ( \ TYPO3 \ CMS \ Core \ Messaging \ FlashMessageQueue :: class , self :: EM_FLASH_MESSAGE_QUEUE_ID ) ; $ queue -> enqueue ( $ flashMessage ) ; } 
private function safeCopy ( $ fullSourcePath , $ fullTargetPath , $ relativeWebDir = '' ) { if ( file_exists ( $ fullTargetPath ) ) { if ( ! is_file ( $ fullTargetPath ) ) { require __DIR__ . \'/typo3conf/ext/typo3_console/Scripts/typo3-console.php\';' , $ proxyFileContent ) ; $ success = file_put_contents ( $ fullTargetPath , $ proxyFileContent ) ; } if ( $ success && ! $ this -> isWindowsOs ( ) ) { $ success = @ chmod ( $ fullTargetPath , 0755 ) ; } if ( $ success ) { $ success = @ file_put_contents ( $ fullTargetPath , str_replace ( '{$relative-web-dir}' , $ relativeWebDir , file_get_contents ( $ fullTargetPath ) ) ) ; } return $ success ; } 
protected function createDeprecatedDefinition ( ) : array { return [ new InputOption ( 'force' , null , InputOption :: VALUE_NONE , 'Cache is forcibly flushed (low level operations are performed)' ) , new InputArgument ( 'force' , null , 'Cache is forcibly flushed (low level operations are performed)' , false ) , new InputArgument ( 'filesOnly' , null , 'Only file caches are flushed' , false ) , ] ; } 
public function generateXsdCommand ( $ phpNamespace , $ xsdNamespace = null , $ targetFile = null ) { if ( $ xsdNamespace === null ) { $ phpNamespace = rtrim ( $ phpNamespace , '_\\' ) ; if ( strpos ( $ phpNamespace , '\\' ) === false ) { $ search = [ 'Tx_' , '_' ] ; $ replace = [ '' , '/' ] ; } else { $ search = '\\' ; $ replace = '/' ; } $ xsdNamespace = sprintf ( 'http://typo3.org/ns/%s' , str_replace ( $ search , $ replace , $ phpNamespace ) ) ; } $ xsdSchema = '' ; try { $ xsdSchema = $ this -> xsdGenerator -> generateXsd ( $ phpNamespace , $ xsdNamespace ) ; } catch ( Service \ Exception $ exception ) { $ this -> outputLine ( 'An error occurred while trying to generate the XSD schema:' ) ; $ this -> outputLine ( '%s' , [ $ exception -> getMessage ( ) ] ) ; $ this -> quit ( 1 ) ; } if ( $ targetFile === null ) { echo $ xsdSchema ; } else { file_put_contents ( $ targetFile , $ xsdSchema ) ; } } 
private static function initializePackageManagement ( Bootstrap $ bootstrap ) { $ packageManager = CompatibilityScripts :: createPackageManager ( ) ; $ bootstrap -> setEarlyInstance ( PackageManager :: class , $ packageManager ) ; GeneralUtility :: setSingletonInstance ( PackageManager :: class , $ packageManager ) ; ExtensionManagementUtility :: setPackageManager ( $ packageManager ) ; $ packageManager -> init ( ) ; } 
public static function provideCleanClassImplementations ( ) { self :: overrideImplementation ( \ TYPO3 \ CMS \ Extbase \ Command \ HelpCommandController :: class , \ Helhum \ Typo3Console \ Command \ HelpCommandController :: class ) ; self :: overrideImplementation ( \ TYPO3 \ CMS \ Extbase \ Mvc \ Cli \ Command :: class , \ Helhum \ Typo3Console \ Mvc \ Cli \ Command :: class ) ; 
public static function overrideImplementation ( $ originalClassName , $ overrideClassName ) { self :: registerImplementation ( $ originalClassName , $ overrideClassName ) ; $ GLOBALS [ 'TYPO3_CONF_VARS' ] [ 'SYS' ] [ 'Objects' ] [ $ originalClassName ] [ 'className' ] = $ overrideClassName ; class_alias ( $ overrideClassName , $ originalClassName ) ; } 
private static function registerImplementation ( $ className , $ alternativeClassName ) { $ extbaseObjectContainer = \ TYPO3 \ CMS \ Core \ Utility \ GeneralUtility :: makeInstance ( \ TYPO3 \ CMS \ Extbase \ Object \ Container \ Container :: class ) ; $ extbaseObjectContainer -> registerImplementation ( $ className , $ alternativeClassName ) ; } 
public function setLocal ( $ path , $ value , $ targetType = '' ) { try { $ value = $ this -> convertToTargetType ( $ path , $ value , $ targetType ) ; return $ this -> configurationManager -> setLocalConfigurationValueByPath ( $ path , $ value ) ; } catch ( TypesAreNotConvertibleException $ e ) { return false ; } } 
public function localIsActive ( $ path ) { if ( $ this -> hasLocal ( $ path ) ) { return $ this -> hasActive ( $ path ) && $ this -> getLocal ( $ path ) === $ this -> getActive ( $ path ) ; } return ! $ this -> hasActive ( $ path ) ; } 
public function convertToTargetType ( $ path , $ value , $ targetType = '' ) { $ targetType = $ targetType ? : $ this -> getType ( $ path ) ; $ actualType = gettype ( $ value ) ; if ( $ actualType !== $ targetType && $ targetType !== 'NULL' ) { if ( $ this -> isTypeConvertible ( $ targetType , $ actualType ) ) { switch ( $ targetType ) { case 'integer' : $ value = ( int ) $ value ; break ; case 'float' : case 'double' : $ value = ( float ) $ value ; break ; case 'boolean' : $ value = ( bool ) $ value ; break ; case 'string' : $ value = ( string ) $ value ; break ; default : 
private function getType ( $ path ) { $ value = null ; if ( $ this -> hasActive ( $ path ) ) { $ value = $ this -> getActive ( $ path ) ; } if ( $ this -> hasLocal ( $ path ) ) { $ value = $ this -> getLocal ( $ path ) ; } if ( $ this -> hasDefault ( $ path ) ) { $ value = $ this -> getDefault ( $ path ) ; } return gettype ( $ value ) ; } 
private function isTypeConvertible ( $ targetType , $ actualType ) { if ( in_array ( $ targetType , [ 'array' , 'object' , 'resource' ] , true ) ) { return false ; } if ( in_array ( $ actualType , [ 'array' , 'object' , 'resource' ] , true ) ) { return false ; } return true ; } 
public function isCommandAvailable ( Command $ command ) : bool { if ( ! $ this -> isFullyCapable ( ) && in_array ( $ command -> getName ( ) , [ 
protected function configure ( ) { $ this -> setDescription ( $ this -> commandDefinition -> getShortDescription ( ) ) ; $ this -> setHelp ( $ this -> commandDefinition -> getDescription ( ) ) ; $ strict = $ this -> commandDefinition -> shouldValidateInputStrict ( ) ; if ( ! $ strict ) { $ this -> ignoreValidationErrors ( ) ; } $ this -> setDefinition ( $ this -> commandDefinition -> getInputDefinitions ( ) ) ; } 
public function setApplication ( BaseApplication $ application = null ) { if ( $ application !== null && ! $ application instanceof Application ) { throw new RuntimeException ( 'Command controller commands only work with TYPO3 Console Applications' , 1506381781 ) ; } $ this -> application = $ application ; parent :: setApplication ( $ application ) ; } 
protected function execute ( InputInterface $ input , OutputInterface $ output ) { 
private function ensureRequiredEnvironment ( ) { if ( ! in_array ( PHP_SAPI , [ 'cli' , 'phpdbg' ] , true ) || ! isset ( $ _SERVER [ 'argc' ] , $ _SERVER [ 'argv' ] ) ) { echo 'The command line must be executed with a cli PHP binary! The current PHP sapi type is "' . PHP_SAPI . '".' . PHP_EOL ; exit ( 1 ) ; } if ( ini_get ( 'memory_limit' ) !== '-1' ) { @ ini_set ( 'memory_limit' , '-1' ) ; } if ( ini_get ( 'max_execution_time' ) !== '0' ) { @ ini_set ( 'max_execution_time' , '0' ) ; } } 
public static function initializeCompatibilityLayer ( ClassLoader $ classLoader ) { $ typo3Branch = '95' ; if ( method_exists ( Bootstrap :: class , 'setCacheHashOptions' ) ) { $ typo3Branch = '87' ; } if ( $ typo3Branch === '95' ) { return ; } $ classLoader = self :: $ nonComposerCompatClassLoader ?? $ classLoader ; $ compatibilityNamespace = 'Helhum\\Typo3Console\\TYPO3v' . $ typo3Branch . '\\' ; spl_autoload_register ( function ( $ className ) use ( $ classLoader , $ compatibilityNamespace ) { if ( strpos ( $ className , 'Helhum\\Typo3Console\\' ) !== 0 ) { 
public function initialize ( string $ runLevel = null ) { if ( ! $ this -> initialized ) { self :: initializeCompatibilityLayer ( $ this -> classLoader ) ; Scripts :: baseSetup ( $ this -> bootstrap ) ; $ this -> initialized = true ; } if ( $ runLevel !== null ) { $ this -> runLevel -> runSequence ( $ runLevel ) ; } } 
public function handle ( InputInterface $ input ) : int { $ this -> initialize ( ) ; $ commandCollection = new CommandCollection ( $ this -> runLevel , new CommandConfiguration ( GeneralUtility :: makeInstance ( PackageManager :: class ) ) ) ; $ application = new Application ( $ this -> runLevel , CompatibilityScripts :: isComposerMode ( ) ) ; $ application -> setCommandLoader ( $ commandCollection ) ; 
public function executeActionWithArguments ( $ actionName , array $ arguments = [ ] , $ dryRun = false ) { $ actionMethod = 'execute' . ucfirst ( $ actionName ) . 'Action' ; $ checkMethod = 'check' . ucfirst ( $ actionName ) . 'Action' ; $ messages = [ ] ; $ needsExecution = file_exists ( PATH_site . 'FIRST_INSTALL' ) ; if ( is_callable ( [ $ this -> installerController , $ checkMethod ] ) ) { $ needsExecution = ! \ json_decode ( ( string ) $ this -> installerController -> $ checkMethod ( ) -> getBody ( ) , true ) [ 'success' ] ; } if ( $ needsExecution && ! $ dryRun ) { $ request = ( $ this -> requestFactory ) ( $ arguments ) ; try { $ response = \ json_decode ( ( string ) $ this -> installerController -> $ actionMethod ( $ request ) -> getBody ( ) , true ) ; if ( ! $ response [ 'success' ] ) { $ messages = $ response [ 'status' ] ; } } catch ( \ Throwable $ e ) { $ messages = [ [ 'severity' => AbstractMessage :: ERROR , 'message' => $ e -> getMessage ( ) , ] , ] ; } $ this -> silentConfigurationUpgrade -> executeSilentConfigurationUpgradesIfNeeded ( ) ; $ needsExecution = false ; } return new InstallStepResponse ( $ needsExecution , $ messages ) ; } 
public function render ( \ Throwable $ exception , OutputInterface $ output , Application $ application = null ) { if ( getenv ( 'TYPO3_CONSOLE_SUB_PROCESS' ) ) { $ output -> write ( \ json_encode ( $ this -> serializeException ( $ exception ) ) , false , OutputInterface :: VERBOSITY_QUIET ) ; return ; } $ output -> writeln ( '' , OutputInterface :: VERBOSITY_QUIET ) ; do { $ this -> outputException ( $ exception , $ output ) ; if ( $ output -> isVerbose ( ) ) { $ this -> outputCode ( $ exception , $ output ) ; $ this -> outputCommand ( $ exception , $ output ) ; $ this -> outputTrace ( $ exception , $ output ) ; $ output -> writeln ( '' ) ; } $ exception = $ exception -> getPrevious ( ) ; if ( $ exception ) { $ output -> writeln ( '<comment>Caused by:</comment>' , OutputInterface :: VERBOSITY_QUIET ) ; } } while ( $ exception ) ; $ this -> outputSynopsis ( $ output , $ application ) ; } 
private function outputException ( \ Throwable $ exception , OutputInterface $ output ) { $ exceptionClass = get_class ( $ exception ) ; if ( $ exception instanceof SubProcessException ) { $ exceptionClass = $ exception -> getPreviousExceptionClass ( ) ; } $ title = sprintf ( '[ %s ]' , $ exceptionClass ) ; $ messageLength = Helper :: strlen ( $ title ) ; $ maxWidth = $ this -> terminal -> getWidth ( ) ? $ this -> terminal -> getWidth ( ) - 1 : PHP_INT_MAX ; $ lines = [ ] ; foreach ( preg_split ( '/\r?\n/' , trim ( $ exception -> getMessage ( ) ) ) as $ line ) { foreach ( $ this -> splitStringByWidth ( $ line , $ maxWidth - 4 ) as $ splitLine ) { $ lines [ ] = $ splitLine ; $ messageLength = max ( Helper :: strlen ( $ splitLine ) , $ messageLength ) ; } } $ messages = [ ] ; $ messages [ ] = $ emptyLine = $ this -> padMessage ( '' , $ messageLength ) ; $ messages [ ] = $ this -> padMessage ( $ title , $ messageLength ) ; foreach ( $ lines as $ line ) { $ messages [ ] = $ this -> padMessage ( OutputFormatter :: escape ( $ line ) , $ messageLength ) ; } $ messages [ ] = $ emptyLine ; $ messages [ ] = '' ; $ output -> writeln ( $ messages , OutputInterface :: VERBOSITY_QUIET ) ; } 
private function outputTrace ( \ Throwable $ exception , OutputInterface $ output ) { $ output -> writeln ( '<comment>Exception trace:</comment>' ) ; $ backtraceSteps = $ this -> getTrace ( $ exception ) ; foreach ( $ backtraceSteps as $ index => $ step ) { $ traceLine = '#' . $ index . ' ' ; if ( isset ( $ backtraceSteps [ $ index ] [ 'class' ] ) ) { $ traceLine .= $ backtraceSteps [ $ index ] [ 'class' ] ; } if ( isset ( $ backtraceSteps [ $ index ] [ 'function' ] ) ) { $ traceLine .= ( isset ( $ backtraceSteps [ $ index ] [ 'class' ] ) ? $ backtraceSteps [ $ index ] [ 'type' ] : '' ) . $ backtraceSteps [ $ index ] [ 'function' ] . '()' ; } $ output -> writeln ( sprintf ( '<info>%s</info>' , $ traceLine ) ) ; if ( isset ( $ backtraceSteps [ $ index ] [ 'file' ] ) ) { $ output -> writeln ( ' ' . $ this -> getPossibleShortenedFileName ( $ backtraceSteps [ $ index ] [ 'file' ] ) . ( isset ( $ backtraceSteps [ $ index ] [ 'line' ] ) ? ':' . $ backtraceSteps [ $ index ] [ 'line' ] : '' ) ) ; } } } 
private function getPossibleShortenedFileName ( $ fileName ) : string { $ pathPrefixes = [ ] ; if ( getenv ( 'TYPO3_PATH_COMPOSER_ROOT' ) ) { $ pathPrefixes = [ getenv ( 'TYPO3_PATH_COMPOSER_ROOT' ) . '/' ] ; } $ pathPrefixes [ ] = PATH_site ; $ fileName = str_replace ( $ pathPrefixes , '' , $ fileName ) ; $ pathPosition = strpos ( $ fileName , 'typo3conf/ext/' ) ; $ pathAndFilename = ( $ pathPosition !== false ) ? substr ( $ fileName , $ pathPosition ) : $ fileName ; $ pathPosition = strpos ( $ pathAndFilename , 'typo3/sysext/' ) ; return ( $ pathPosition !== false ) ? substr ( $ pathAndFilename , $ pathPosition ) : $ pathAndFilename ; } 
public function errorCommand ( \ TYPO3 \ CMS \ Extbase \ Mvc \ Exception \ CommandException $ exception ) { $ this -> outputLine ( '<error>%s</error>' , [ $ exception -> getMessage ( ) ] ) ; if ( $ exception instanceof \ TYPO3 \ CMS \ Extbase \ Mvc \ Exception \ AmbiguousCommandIdentifierException ) { $ this -> outputLine ( 'Please specify the complete command identifier. Matched commands:' ) ; foreach ( $ exception -> getMatchingCommands ( ) as $ matchingCommand ) { $ this -> outputLine ( ' %s' , [ $ matchingCommand -> getCommandIdentifier ( ) ] ) ; } } $ this -> outputLine ( ) ; $ this -> outputLine ( 'See <info>list</info> for an overview of all available commands' ) ; $ this -> outputLine ( 'or <info>help</info> <command> for a detailed description of the corresponding command.' ) ; $ this -> quit ( 1 ) ; } 
public function updateSchemaCommand ( array $ schemaUpdateTypes = [ 'safe' ] , $ dryRun = false ) { $ verbose = $ this -> output -> getSymfonyConsoleOutput ( ) -> isVerbose ( ) ; try { $ expandedSchemaUpdateTypes = SchemaUpdateType :: expandSchemaUpdateTypes ( $ schemaUpdateTypes ) ; } catch ( InvalidEnumerationValueException $ e ) { $ this -> outputLine ( sprintf ( '<error>%s</error>' , $ e -> getMessage ( ) ) ) ; $ this -> quit ( 1 ) ; } $ result = $ this -> schemaService -> updateSchema ( $ expandedSchemaUpdateTypes , $ dryRun ) ; if ( $ result -> hasPerformedUpdates ( ) ) { $ this -> output -> outputLine ( '<info>The following database schema updates %s performed:</info>' , [ $ dryRun ? 'should be' : 'were' ] ) ; $ this -> schemaUpdateResultRenderer -> render ( $ result , $ this -> output , $ verbose ) ; } else { $ this -> output -> outputLine ( '<info>No schema updates %s performed for update type%s:%s</info>' , [ $ dryRun ? 'must be' : 'were' , count ( $ expandedSchemaUpdateTypes ) > 1 ? 's' : '' , PHP_EOL . '"' . implode ( '", "' , $ expandedSchemaUpdateTypes ) . '"' , ] ) ; } if ( $ result -> hasErrors ( ) ) { $ this -> outputLine ( ) ; $ this -> output -> outputLine ( '<error>The following errors occurred:</error>' ) ; $ this -> schemaUpdateResultRenderer -> renderErrors ( $ result , $ this -> output , $ verbose ) ; $ this -> quit ( 1 ) ; } } 
public function importCommand ( $ interactive = false , string $ connection = 'Default' ) { $ availableConnectionNames = $ this -> connectionConfiguration -> getAvailableConnectionNames ( 'mysql' ) ; if ( empty ( $ availableConnectionNames ) || ! in_array ( $ connection , $ availableConnectionNames , true ) ) { $ this -> output ( '<error>No suitable MySQL connection found for import.</error>' ) ; $ this -> quit ( 2 ) ; } $ mysqlCommand = new MysqlCommand ( $ this -> connectionConfiguration -> build ( $ connection ) , [ ] , $ this -> output -> getSymfonyConsoleOutput ( ) ) ; $ exitCode = $ mysqlCommand -> mysql ( $ interactive ? [ ] : [ '--skip-column-names' ] , STDIN , null , $ interactive ) ; $ this -> quit ( $ exitCode ) ; } 
public function render ( array $ upgradeWizardList , ConsoleOutput $ output , $ verbose = false ) { if ( empty ( $ upgradeWizardList ) ) { $ output -> outputLine ( '<info>None</info>' ) ; return ; } $ tableHeader = [ 'Identifier' , 'Title' ] ; if ( $ verbose ) { $ tableHeader = [ 'Identifier' , 'Description' ] ; } $ tableRows = [ ] ; foreach ( $ upgradeWizardList as $ identifier => $ info ) { $ row = [ $ identifier , wordwrap ( $ info [ 'title' ] , 40 ) , ] ; if ( $ verbose ) { $ row = [ $ identifier , wordwrap ( $ info [ 'explanation' ] , 40 ) , ] ; } $ tableRows [ ] = $ row ; $ tableRows [ ] = new TableSeparator ( ) ; } array_pop ( $ tableRows ) ; $ output -> outputTable ( $ tableRows , $ tableHeader ) ; } 
public function executeInSubProcess ( $ command , array $ arguments = [ ] , array & $ messages = [ ] ) { $ messages = $ this -> ensureUpgradeIsPossible ( ) ; return @ unserialize ( $ this -> commandDispatcher -> executeCommand ( 'upgrade:subprocess' , [ $ command , serialize ( $ arguments ) ] ) ) ; } 
public function renderSchemaResult ( ConsoleOutput $ output , SchemaUpdateResultRenderer $ schemaUpdateResultRenderer = null ) { if ( ! isset ( $ this -> results [ 'renderSchemaResult' ] ) ) { return ; } $ result = reset ( $ this -> results [ 'renderSchemaResult' ] ) ; if ( $ result -> hasPerformedUpdates ( ) ) { $ schemaUpdateResultRenderer = $ schemaUpdateResultRenderer ? : new SchemaUpdateResultRenderer ( ) ; $ output -> outputLine ( '<info>The following database schema updates were performed:</info>' ) ; $ schemaUpdateResultRenderer -> render ( $ result , $ output , true ) ; } else { $ output -> outputLine ( '<info>No schema updates were performed for update types:%s</info>' , [ PHP_EOL . '"' . implode ( '", "' , SchemaUpdateType :: expandSchemaUpdateTypes ( [ 'safe' ] ) ) . '"' , ] ) ; } } 
public function renderImportedStaticDataResult ( ConsoleOutput $ output ) { if ( ! isset ( $ this -> results [ 'renderImportedStaticDataResult' ] ) ) { return ; } foreach ( $ this -> results [ 'renderImportedStaticDataResult' ] as $ pathToStaticSqlFile ) { 
public function renderExtensionFileImportResult ( ConsoleOutput $ output ) { if ( ! isset ( $ this -> results [ 'renderExtensionFileImportResult' ] ) ) { return ; } foreach ( $ this -> results [ 'renderExtensionFileImportResult' ] as $ destinationAbsolutePath ) { $ output -> outputFormatted ( '<info>Files from extension was imported to path "%s"</info>' , [ PathUtility :: stripPathSitePrefix ( $ destinationAbsolutePath ) ] ) ; } } 
public function renderExtensionDataImportResult ( ConsoleOutput $ output ) { if ( ! isset ( $ this -> results [ 'renderExtensionDataImportResult' ] ) ) { return ; } foreach ( $ this -> results [ 'renderExtensionDataImportResult' ] as $ importedFile ) { $ output -> outputFormatted ( '<info>Data from from file "%s" was imported</info>' , [ $ importedFile ] ) ; } } 
public function updateReferenceIndexCommand ( $ dryRun = false , $ showProgress = false ) { $ verbose = $ this -> output -> getSymfonyConsoleOutput ( ) -> isVerbose ( ) ; $ this -> outputLine ( '<info>' . ( $ dryRun ? 'Checking' : 'Updating' ) . ' reference index. This may take a while …</info>'); $ operation = $ dryRun ? 'checkReferenceIndex' : 'updateReferenceIndex' ; list ( $ errorCount , $ recordCount , $ processedTables ) = $ this -> persistenceIntegrityService -> { $ operation } ( $ this -> createReferenceIndexDelegateWithOptions ( $ dryRun , $ verbose , $ showProgress ) ) ; if ( $ errorCount > 0 ) { $ this -> outputLine ( '<info>%d errors were ' . ( $ dryRun ? 'found' : 'fixed' ) . ', while ' . ( $ dryRun ? 'checking' : 'updating' ) . ' reference index for %d records from %d tables.</info>' , [ $ errorCount , $ recordCount , count ( $ processedTables ) ] ) ; } else { $ this -> outputLine ( ) ; $ this -> outputLine ( '<info>Index integrity was perfect!</info>' ) ; } } 
public function updateSchema ( array $ schemaUpdateTypes , $ dryRun = false ) { $ updateStatements = [ SchemaUpdateType :: GROUP_SAFE => $ this -> schemaUpdate -> getSafeUpdates ( ) , SchemaUpdateType :: GROUP_DESTRUCTIVE => $ this -> schemaUpdate -> getDestructiveUpdates ( ) , ] ; $ updateResult = new SchemaUpdateResult ( ) ; foreach ( $ schemaUpdateTypes as $ schemaUpdateType ) { foreach ( $ schemaUpdateType -> getStatementTypes ( ) as $ statementType => $ statementGroup ) { if ( isset ( $ updateStatements [ $ statementGroup ] [ $ statementType ] ) ) { $ statements = $ updateStatements [ $ statementGroup ] [ $ statementType ] ; if ( empty ( $ statements ) ) { continue ; } if ( $ dryRun ) { $ updateResult -> addPerformedUpdates ( $ schemaUpdateType , $ statements ) ; } else { $ result = $ this -> schemaUpdate -> migrate ( $ statements , 
public function getMaximumAvailableRunLevel ( ) : string { if ( ! file_exists ( PATH_site . 'typo3conf/PackageStates.php' ) || ! file_exists ( PATH_site . 'typo3conf/LocalConfiguration.php' ) ) { return self :: LEVEL_COMPILE ; } return $ this -> error ? self :: LEVEL_COMPILE : self :: LEVEL_FULL ; } 
private function buildSequence ( string $ runLevel ) : Sequence { if ( is_callable ( [ $ this , $ runLevel ] ) ) { return $ this -> { $ runLevel } ( $ runLevel ) ; } throw new InvalidArgumentException ( 'Invalid run level "' . $ runLevel . '"' , 1402075492 ) ; } 
private function buildEssentialSequence ( string $ identifier ) : Sequence { $ sequence = new Sequence ( $ identifier ) ; $ this -> addStep ( $ sequence , 'helhum.typo3console:coreconfiguration' ) ; $ this -> addStep ( $ sequence , 'helhum.typo3console:providecleanclassimplementations' ) ; $ this -> addStep ( $ sequence , 'helhum.typo3console:disabledcaching' ) ; $ this -> addStep ( $ sequence , 'helhum.typo3console:errorhandling' ) ; return $ sequence ; } 
private function buildBasicRuntimeSequence ( string $ identifier = self :: LEVEL_MINIMAL ) : Sequence { $ sequence = $ this -> buildEssentialSequence ( $ identifier ) ; $ this -> addStep ( $ sequence , 'helhum.typo3console:extensionconfiguration' ) ; return $ sequence ; } 
private function buildExtendedRuntimeSequence ( ) : Sequence { $ sequence = $ this -> buildBasicRuntimeSequence ( self :: LEVEL_FULL ) ; $ this -> addStep ( $ sequence , 'helhum.typo3console:caching' ) ; 
public function flushGroupsCommand ( array $ groups ) { try { $ this -> cacheService -> flushGroups ( $ groups ) ; $ this -> outputLine ( 'Flushed all caches for group(s): "' . implode ( '","' , $ groups ) . '".' ) ; } catch ( NoSuchCacheGroupException $ e ) { $ this -> outputLine ( $ e -> getMessage ( ) ) ; $ this -> quit ( 1 ) ; } } 
public function flushTagsCommand ( array $ tags , array $ groups = null ) { try { $ this -> cacheService -> flushByTagsAndGroups ( $ tags , $ groups ) ; if ( $ groups === null ) { $ this -> outputLine ( 'Flushed caches by tags "' . implode ( '","' , $ tags ) . '".' ) ; } else { $ this -> outputLine ( 'Flushed caches by tags "' . implode ( '","' , $ tags ) . '" in groups: "' . implode ( '","' , $ groups ) . '".' ) ; } } catch ( NoSuchCacheGroupException $ e ) { $ this -> outputLine ( $ e -> getMessage ( ) ) ; $ this -> quit ( 1 ) ; } } 
public function listGroupsCommand ( ) { $ groups = $ this -> cacheService -> getValidCacheGroups ( ) ; sort ( $ groups ) ; switch ( count ( $ groups ) ) { case 0 : $ this -> outputLine ( 'No cache groups are registered.' ) ; break ; case 1 : $ this -> outputLine ( 'The following cache group is registered: "' . implode ( '", "' , $ groups ) . '".' ) ; break ; default : $ this -> outputLine ( 'The following cache groups are registered: "' . implode ( '", "' , $ groups ) . '".' ) ; break ; } } 
public function create ( string $ name , array $ config ) : Dictionary { if ( ! isset ( $ config [ 'content' ] ) ) { throw new InvalidArgumentException ( sprintf ( 'The key content for dictionary %s must be set.' , $ name ) ) ; } $ content = $ config [ 'content' ] ; $ values = [ ] ; foreach ( $ content as $ value ) { $ builtValue = $ this -> transformer -> transform ( $ value ) ; $ values [ $ builtValue ] = $ builtValue ; } return new Dictionary \ Simple ( $ name , $ values ) ; } 
public function create ( string $ name , array $ config ) : Dictionary { if ( ! isset ( $ config [ 'service' ] ) ) { throw new InvalidArgumentException ( sprintf ( 'The "service" config key must be set for the dictionary named "%s".' , $ name ) ) ; } $ service = $ this -> container -> get ( $ config [ 'service' ] ) ; $ callable = [ $ service ] ; if ( isset ( $ config [ 'method' ] ) ) { $ callable [ ] = $ config [ 'method' ] ; } if ( false === \ is_callable ( $ callable ) ) { throw new InvalidArgumentException ( sprintf ( 'You must provide a valid callable for the dictionary named "%s".' , $ name ) ) ; } return new Dictionary \ Invokable ( $ name , $ callable ) ; } 
public function create ( string $ name , array $ config ) : Dictionary { if ( ! isset ( $ config [ 'dictionaries' ] ) ) { throw new InvalidArgumentException ( sprintf ( 'Dictionary of type %s must contains a key "dictionaries".' , self :: TYPE ) ) ; } $ dictionaries = array_map ( function ( $ name ) { return $ this -> dictionaries [ $ name ] ; } , $ config [ 'dictionaries' ] ) ; return new Dictionary \ Combined ( $ name , $ dictionaries ) ; } 
public function offsetGet ( $ offset ) { if ( false === $ this -> offsetExists ( $ offset ) ) { throw new DictionaryNotFoundException ( $ offset , array_keys ( $ this -> dictionaries ) ) ; } return $ this -> get ( $ offset ) ; } 
public function process ( ContainerBuilder $ container ) : void { foreach ( $ container -> findTaggedServiceIds ( self :: TAG_FACTORY ) as $ id => $ tags ) { $ container -> findDefinition ( Aggregate :: class ) -> addMethodCall ( 'addFactory' , [ new Reference ( $ id ) ] ) ; } } 
public function create ( string $ name , array $ config ) : Dictionary { return $ this -> factory -> create ( $ name , $ config ) ; } 
public function create ( string $ name , array $ config ) : Dictionary { foreach ( $ this -> factories as $ factory ) { if ( $ factory -> supports ( $ config ) ) { return $ factory -> create ( $ name , $ config ) ; } } throw new InvalidArgumentException ( sprintf ( 'The dictionary with named "%s" cannot be created.' , $ name ) ) ; } 
public function supports ( array $ config ) : bool { foreach ( $ this -> factories as $ factory ) { if ( $ factory -> supports ( $ config ) ) { return true ; } } return false ; } 
public function configureOptions ( OptionsResolver $ resolver ) : void { $ dictionaries = $ this -> dictionaries ; $ choices = function ( Options $ options ) use ( $ dictionaries ) { $ name = $ options [ 'name' ] ; $ choices = $ dictionaries [ $ name ] -> getValues ( ) ; return array_flip ( $ choices ) ; } ; $ resolver -> setDefault ( 'choices' , $ choices ) -> setRequired ( [ 'name' ] ) -> setAllowedValues ( 'name' , array_keys ( iterator_to_array ( $ this -> dictionaries ) ) ) ; } 
public function offsetSet ( $ offset , $ value ) : void { $ this -> hydrate ( ) ; $ this -> values [ $ offset ] = $ value ; } 
private function hydrate ( ) : void { if ( null !== $ this -> values ) { return ; } $ values = \ call_user_func_array ( $ this -> callable , $ this -> callableArgs ) ; if ( false === \ is_array ( $ values ) ) { throw new InvalidArgumentException ( 'Dictionary callable must return an array or an instance of ArrayAccess.' ) ; } $ this -> values = $ values ; } 
public function process ( ContainerBuilder $ container ) : void { foreach ( $ container -> findTaggedServiceIds ( self :: TAG_DICTIONARY ) as $ id => $ tags ) { $ container -> getDefinition ( Collection :: class ) -> addMethodCall ( 'add' , [ new Reference ( $ id ) ] ) ; } } 
public function offsetSet ( $ offset , $ value ) : void { $ this -> dictionary -> offsetSet ( $ offset , $ value ) ; $ this -> trace ( ) ; } 
private function trace ( ) : void { $ this -> collector -> addDictionary ( $ this -> dictionary -> getName ( ) , $ this -> dictionary -> getKeys ( ) , array_values ( $ this -> dictionary -> getValues ( ) ) ) ; } 
public function create ( string $ name , array $ config ) : Dictionary { if ( false === $ this -> factory -> supports ( $ config ) ) { throw new InvalidArgumentException ( sprintf ( 'The dictionary with named "%s" cannot be created.' , $ name ) ) ; } $ extends = $ config [ 'extends' ] ; unset ( $ config [ 'extends' ] ) ; $ dictionaries = [ ] ; $ dictionaries [ ] = $ this -> dictionaries [ $ extends ] ; $ dictionaries [ ] = $ this -> factory -> create ( $ name , $ config ) ; return new Dictionary \ Combined ( $ name , $ dictionaries ) ; } 
public function getConfigTreeBuilder ( ) { $ builder = new TreeBuilder ( ) ; $ builder -> root ( 'knp_dictionary' ) -> children ( ) -> arrayNode ( 'dictionaries' ) -> useAttributeAsKey ( 'name' ) -> prototype ( 'array' ) -> beforeNormalization ( ) -> always ( ) -> then ( function ( $ values ) { if ( false === array_key_exists ( 'type' , $ values ) ) { if ( false === array_key_exists ( 'content' , $ values ) ) { return [ 'type' => 'value' , 'content' => $ values ] ; } return array_merge ( $ values , [ 'type' => 'value' ] ) ; } return $ values ; } ) -> end ( ) -> children ( ) -> scalarNode ( 'type' ) -> defaultValue ( 'value' ) -> end ( ) -> scalarNode ( 'extends' ) -> end ( ) -> arrayNode ( 'dictionaries' ) -> normalizeKeys ( false ) -> prototype ( 'scalar' ) -> end ( ) -> end ( ) -> arrayNode ( 'content' ) -> normalizeKeys ( false ) -> prototype ( 'scalar' ) -> end ( ) -> end ( ) -> scalarNode ( 'service' ) -> end ( ) -> scalarNode ( 'method' ) -> end ( ) -> end ( ) -> end ( ) -> end ( ) -> end ( ) ; return $ builder ; } 
public function process ( ContainerBuilder $ container ) : void { if ( false === $ container -> has ( DictionaryDataCollector :: class ) ) { return ; } foreach ( $ container -> findTaggedServiceIds ( DictionaryRegistrationPass :: TAG_DICTIONARY ) as $ id => $ tags ) { $ serviceId = sprintf ( '%s.%s.traceable' , $ id , md5 ( $ id ) ) ; $ dictionary = new Reference ( sprintf ( '%s.inner' , $ serviceId ) ) ; $ traceable = new Definition ( Traceable :: class , [ $ dictionary , new Reference ( DictionaryDataCollector :: class ) ] ) ; $ traceable -> setDecoratedService ( $ id ) ; $ container -> setDefinition ( $ serviceId , $ traceable ) ; } } 
public function transform ( $ value ) { foreach ( $ this -> transformers as $ transformer ) { if ( $ transformer -> supports ( $ value ) ) { return $ transformer -> transform ( $ value ) ; } } return $ value ; } 
public function supports ( $ value ) : bool { foreach ( $ this -> transformers as $ transformer ) { if ( $ transformer -> supports ( $ value ) ) { return true ; } } return false ; } 
public function create ( string $ name , array $ config ) : Dictionary { if ( ! isset ( $ config [ 'service' ] ) ) { throw new InvalidArgumentException ( sprintf ( 'The "service" config key must be set for the dictionary named "%s".' , $ name ) ) ; } $ service = $ this -> container -> get ( $ config [ 'service' ] ) ; if ( false === $ service instanceof Traversable ) { throw new InvalidArgumentException ( sprintf ( 'You must provide a valid instance of Traversable for the dictionary named "%s".' , $ name ) ) ; } return new Dictionary \ Iterator ( $ name , $ callable ) ; } 
public function build ( ContainerBuilder $ container ) : void { $ container -> addCompilerPass ( new Compiler \ DictionaryBuildingPass ( ) ) ; $ container -> addCompilerPass ( new Compiler \ DictionaryFactoryBuildingPass ( ) ) ; $ container -> addCompilerPass ( new Compiler \ DictionaryRegistrationPass ( ) ) ; $ container -> addCompilerPass ( new Compiler \ DictionaryTracePass ( ) ) ; } 
public function process ( ContainerBuilder $ container ) : void { $ configuration = $ container -> getParameter ( 'knp_dictionary.configuration' ) ; foreach ( $ configuration [ 'dictionaries' ] as $ name => $ config ) { $ container -> setDefinition ( sprintf ( 'knp_dictionary.dictionary.%s' , $ name ) , $ this -> createDefinition ( $ name , $ config ) ) ; } } 
public function validate ( $ value , Constraint $ constraint ) : void { if ( false === $ constraint instanceof Dictionary ) { throw new UnexpectedTypeException ( $ constraint , __NAMESPACE__ . '\Dictionary' ) ; } if ( null === $ value || '' === $ value ) { return ; } $ dictionary = $ this -> dictionaries [ $ constraint -> name ] ; $ values = $ dictionary -> getKeys ( ) ; if ( false === \ in_array ( $ value , $ values ) ) { $ this -> context -> addViolation ( $ constraint -> message , [ '{{ key }}' => $ value , '{{ keys }}' => implode ( ', ' , $ values ) ] ) ; } } 
public function supports ( $ value ) : bool { if ( false === \ is_string ( $ value ) ) { return false ; } $ matches = [ ] ; if ( 0 === preg_match ( $ this -> pattern , $ value , $ matches ) ) { return false ; } if ( false === class_exists ( $ matches [ 'class' ] ) && false === interface_exists ( $ matches [ 'class' ] ) ) { return false ; } $ constants = ( new ReflectionClass ( $ matches [ 'class' ] ) ) -> getConstants ( ) ; return array_key_exists ( $ matches [ 'constant' ] , $ constants ) ; } 
public function transform ( $ value ) { $ matches = [ ] ; preg_match ( $ this -> pattern , $ value , $ matches ) ; return ( new ReflectionClass ( $ matches [ 'class' ] ) ) -> getConstant ( $ matches [ 'constant' ] ) ; } 
public function indexAction ( Request $ request ) { $ queryParameters = $ request -> query -> all ( ) ; $ translator = $ this -> get ( 'translator' ) ; $ isJson = $ request -> get ( 'json' ) ? true : false ; if ( $ isJson ) { unset ( $ queryParameters [ 'json' ] ) ; } $ fileManager = $ this -> newFileManager ( $ queryParameters ) ; 
public function renameFileAction ( Request $ request , $ fileName ) { $ translator = $ this -> get ( 'translator' ) ; $ queryParameters = $ request -> query -> all ( ) ; $ formRename = $ this -> createRenameForm ( ) ; $ formRename -> handleRequest ( $ request ) ; if ( $ formRename -> isSubmitted ( ) && $ formRename -> isValid ( ) ) { $ data = $ formRename -> getData ( ) ; $ extension = $ data [ 'extension' ] ? '.' . $ data [ 'extension' ] : '' ; $ newfileName = $ data [ 'name' ] . $ extension ; if ( $ newfileName !== $ fileName && isset ( $ data [ 'name' ] ) ) { $ fileManager = $ this -> newFileManager ( $ queryParameters ) ; $ NewfilePath = $ fileManager -> getCurrentPath ( ) . DIRECTORY_SEPARATOR . $ newfileName ; $ OldfilePath = realpath ( $ fileManager -> getCurrentPath ( ) . DIRECTORY_SEPARATOR . $ fileName ) ; if ( 0 !== strpos ( $ NewfilePath , $ fileManager -> getCurrentPath ( ) ) ) { $ this -> addFlash ( 'danger' , $ translator -> trans ( 'file.renamed.unauthorized' ) ) ; } else { $ fs = new Filesystem ( ) ; try { $ fs -> rename ( $ OldfilePath , $ NewfilePath ) ; $ this -> addFlash ( 'success' , $ translator -> trans ( 'file.renamed.success' ) ) ; 
public function uploadFileAction ( Request $ request ) { $ fileManager = $ this -> newFileManager ( $ request -> query -> all ( ) ) ; $ options = [ 'upload_dir' => $ fileManager -> getCurrentPath ( ) . DIRECTORY_SEPARATOR , 'upload_url' => $ fileManager -> getImagePath ( ) , 'accept_file_types' => $ fileManager -> getRegex ( ) , 'print_response' => false , ] ; if ( isset ( $ fileManager -> getConfiguration ( ) [ 'upload' ] ) ) { $ options += $ fileManager -> getConfiguration ( ) [ 'upload' ] ; } $ this -> dispatch ( FileManagerEvents :: PRE_UPDATE , [ 'options' => & $ options ] ) ; $ uploadHandler = new UploadHandler ( $ options ) ; $ response = $ uploadHandler -> response ; foreach ( $ response [ 'files' ] as $ file ) { if ( isset ( $ file -> error ) ) { $ file -> error = $ this -> get ( 'translator' ) -> trans ( $ file -> error ) ; } if ( ! $ fileManager -> getImagePath ( ) ) { $ file -> url = $ this -> generateUrl ( 'file_manager_file' , array_merge ( $ fileManager -> getQueryParameters ( ) , [ 'fileName' => $ file -> url ] ) ) ; } } $ this -> dispatch ( FileManagerEvents :: POST_UPDATE , [ 'response' => & $ response ] ) ; return new JsonResponse ( $ response ) ; } 
public function binaryFileResponseAction ( Request $ request , $ fileName ) { $ fileManager = $ this -> newFileManager ( $ request -> query -> all ( ) ) ; return new BinaryFileResponse ( $ fileManager -> getCurrentPath ( ) . DIRECTORY_SEPARATOR . urldecode ( $ fileName ) ) ; } 
public function deleteAction ( Request $ request ) { $ form = $ this -> createDeleteForm ( ) ; $ form -> handleRequest ( $ request ) ; $ queryParameters = $ request -> query -> all ( ) ; if ( $ form -> isSubmitted ( ) && $ form -> isValid ( ) ) { 
private function retrieveSubDirectories ( FileManager $ fileManager , $ path , $ parent = DIRECTORY_SEPARATOR , $ baseFolderName = false ) { $ directories = new Finder ( ) ; $ directories -> in ( $ path ) -> ignoreUnreadableDirs ( ) -> directories ( ) -> depth ( 0 ) -> sortByType ( ) -> filter ( function ( SplFileInfo $ file ) { return $ file -> isReadable ( ) ; } ) ; if ( $ baseFolderName ) { $ directories -> name ( $ baseFolderName ) ; } $ directoriesList = null ; foreach ( $ directories as $ directory ) { $ fileName = $ baseFolderName ? '' : $ parent . $ directory -> getFilename ( ) ; $ queryParameters = $ fileManager -> getQueryParameters ( ) ; $ queryParameters [ 'route' ] = $ fileName ; $ queryParametersRoute = $ queryParameters ; unset ( $ queryParametersRoute [ 'route' ] ) ; $ filesNumber = $ this -> retrieveFilesNumber ( $ directory -> getPathname ( ) , $ fileManager -> getRegex ( ) ) ; $ fileSpan = $ filesNumber > 0 ? " <span class='label label-default'>{$filesNumber}</span>" : '' ; $ directoriesList [ ] = [ 'text' => $ directory -> getFilename ( ) . $ fileSpan , 'icon' => 'far fa-folder-open' , 'children' => $ this -> retrieveSubDirectories ( $ fileManager , $ directory -> getPathname ( ) , $ fileName . DIRECTORY_SEPARATOR ) , 'a_attr' => [ 'href' => $ fileName ? $ this -> generateUrl ( 'file_manager' , $ queryParameters ) : $ this -> generateUrl ( 'file_manager' , $ queryParametersRoute ) , ] , 'state' => [ 'selected' => $ fileManager -> getCurrentRoute ( ) === $ fileName , 'opened' => true , ] , ] ; } return $ directoriesList ; } 
private function retrieveFilesNumber ( $ path , $ regex ) { $ files = new Finder ( ) ; $ files -> in ( $ path ) -> files ( ) -> depth ( 0 ) -> name ( $ regex ) ; return iterator_count ( $ files ) ; } 
private function getBasePath ( $ queryParameters ) { $ conf = $ queryParameters [ 'conf' ] ; $ managerConf = $ this -> getParameter ( 'artgris_file_manager' ) [ 'conf' ] ; if ( isset ( $ managerConf [ $ conf ] [ 'dir' ] ) ) { return $ managerConf [ $ conf ] ; } if ( isset ( $ managerConf [ $ conf ] [ 'service' ] ) ) { $ extra = isset ( $ queryParameters [ 'extra' ] ) ? $ queryParameters [ 'extra' ] : [ ] ; $ conf = $ this -> get ( $ managerConf [ $ conf ] [ 'service' ] ) -> getConf ( $ extra ) ; return $ conf ; } throw new \ RuntimeException ( 'Please define a "dir" or a "service" parameter in your config.yml' ) ; } 
private function newFileManager ( $ queryParameters ) { if ( ! isset ( $ queryParameters [ 'conf' ] ) ) { throw new \ RuntimeException ( 'Please define a conf parameter in your route' ) ; } $ webDir = $ this -> getParameter ( 'artgris_file_manager' ) [ 'web_dir' ] ; $ this -> fileManager = new FileManager ( $ queryParameters , $ this -> getBasePath ( $ queryParameters ) , $ this -> getKernelRoute ( ) , $ this -> get ( 'router' ) , $ webDir ) ; return $ this -> fileManager ; } 
public function getConfigTreeBuilder ( ) { $ treeBuilder = new TreeBuilder ( ) ; $ rootNode = $ treeBuilder -> root ( 'artgris_file_manager' ) ; $ rootNode -> children ( ) -> scalarNode ( 'web_dir' ) -> defaultValue ( 'web' ) -> end ( ) -> arrayNode ( 'conf' ) -> prototype ( 'array' ) -> children ( ) -> scalarNode ( 'dir' ) -> end ( ) -> enumNode ( 'type' ) -> values ( [ 'file' , 'image' , 'media' ] ) -> end ( ) -> booleanNode ( 'tree' ) -> end ( ) -> enumNode ( 'view' ) -> values ( [ 'thumbnail' , 'list' ] ) -> defaultValue ( 'list' ) -> end ( ) -> scalarNode ( 'regex' ) -> end ( ) -> scalarNode ( 'service' ) -> end ( ) -> scalarNode ( 'accept' ) -> end ( ) -> arrayNode ( 'upload' ) -> children ( ) -> integerNode ( 'min_file_size' ) -> end ( ) -> integerNode ( 'max_file_size' ) -> end ( ) -> integerNode ( 'max_width' ) -> end ( ) -> integerNode ( 'max_height' ) -> end ( ) -> integerNode ( 'min_width' ) -> end ( ) -> integerNode ( 'min_height' ) -> end ( ) -> integerNode ( 'image_library' ) -> end ( ) -> arrayNode ( 'image_versions' ) -> prototype ( 'array' ) -> children ( ) -> booleanNode ( 'auto_orient' ) -> end ( ) -> booleanNode ( 'crop' ) -> end ( ) -> integerNode ( 'max_width' ) -> end ( ) -> integerNode ( 'max_height' ) -> end ( ) -> end ( ) -> end ( ) -> end ( ) -> booleanNode ( 'override' ) -> defaultValue ( false ) -> end ( ) -> end ( ) -> end ( ) -> end ( ) -> end ( ) -> end ( ) -> end ( ) ; return $ treeBuilder ; } 
public function getParent ( ) { $ queryParentParameters = $ this -> queryParameters ; $ parentRoute = dirname ( $ this -> getCurrentRoute ( ) ) ; if ( DIRECTORY_SEPARATOR !== $ parentRoute ) { $ queryParentParameters [ 'route' ] = dirname ( $ this -> getCurrentRoute ( ) ) ; } else { unset ( $ queryParentParameters [ 'route' ] ) ; } $ parentRoute = $ this -> router -> generate ( 'file_manager' , $ queryParentParameters ) ; return $ this -> getRoute ( ) ? $ parentRoute : null ; } 
public function toJSON ( $ data , $ options = 0 ) { 
public function getDescription ( ) { $ id = $ this -> getTransactionId ( ) ; $ desc = parent :: getDescription ( ) ; if ( empty ( $ id ) ) { return $ desc ; } elseif ( empty ( $ desc ) ) { return $ id ; } else { return "$id : $desc" ; } } 
public function isSuccessful ( ) { $ success = isset ( $ this -> data [ 'ACK' ] ) && in_array ( $ this -> data [ 'ACK' ] , array ( 'Success' , 'SuccessWithWarning' ) ) ; return ! $ this -> isRedirect ( ) && $ success ; } 
public function getTransactionReference ( ) { if ( $ this -> isSuccessful ( ) && isset ( $ this -> data [ 'PAYMENTINFO_0_TRANSACTIONID' ] ) ) { return $ this -> data [ 'PAYMENTINFO_0_TRANSACTIONID' ] ; } return parent :: getTransactionReference ( ) ; } 
public function getToken ( $ createIfNeeded = true ) { if ( $ createIfNeeded && ! $ this -> hasToken ( ) ) { $ response = $ this -> createToken ( ) -> send ( ) ; if ( $ response -> isSuccessful ( ) ) { $ data = $ response -> getData ( ) ; if ( isset ( $ data [ 'access_token' ] ) ) { $ this -> setToken ( $ data [ 'access_token' ] ) ; $ this -> setTokenExpires ( time ( ) + $ data [ 'expires_in' ] ) ; } } } return $ this -> getParameter ( 'token' ) ; } 
public function hasToken ( ) { $ token = $ this -> getParameter ( 'token' ) ; $ expires = $ this -> getTokenExpires ( ) ; if ( ! empty ( $ expires ) && ! is_numeric ( $ expires ) ) { $ expires = strtotime ( $ expires ) ; } return ! empty ( $ token ) && time ( ) < $ expires ; } 
public function createRequest ( $ class , array $ parameters = array ( ) ) { if ( ! $ this -> hasToken ( ) && $ class != '\Omnipay\PayPal\Message\RestTokenRequest' ) { 
public function add ( $ item ) { if ( $ item instanceof ItemInterface ) { $ this -> items [ ] = $ item ; } else { $ this -> items [ ] = new PayPalItem ( $ item ) ; } } 
public function setStartTime ( $ value ) { if ( $ value instanceof \ DateTime ) { $ value -> setTimezone ( new \ DateTimeZone ( 'UTC' ) ) ; $ value = $ value -> format ( 'Y-m-d\TH:i:s\Z' ) ; } return $ this -> setParameter ( 'startTime' , $ value ) ; } 
public function setEndTime ( $ value ) { if ( $ value instanceof \ DateTime ) { $ value -> setTimezone ( new \ DateTimeZone ( 'UTC' ) ) ; $ value = $ value -> format ( 'Y-m-d\TH:i:s\Z' ) ; } return $ this -> setParameter ( 'endTime' , $ value ) ; } 
public function getAll ( $ type ) { $ all = [ ] ; foreach ( $ this -> issues as $ version => $ issues ) { if ( isset ( $ issues [ $ type ] ) ) { foreach ( $ issues [ $ type ] as $ issue_name => $ issue_value ) { if ( is_int ( $ issue_name ) ) { if ( $ type !== 'functions_usage' ) $ all [ $ issue_value ] = array ( $ issue_value , $ version ) ; else $ all [ ] = array ( $ issue_value , $ version ) ; } else $ all [ $ issue_name ] = array ( $ issue_value , $ version ) ; } } } return $ all ; } 
public function run ( ) { try { $ this -> setTarget ( ) ; $ this -> setMaxSize ( ) ; $ this -> setExcludeList ( ) ; $ this -> setSkipChecks ( ) ; $ this -> setFileExtensions ( ) ; $ this -> scanFiles ( ) ; $ this -> printReport ( ) ; $ this -> printMemoryUsage ( ) ; if ( $ this -> hasIssue ) exit ( 1 ) ; } catch ( Exception $ e ) { $ this -> exitWithError ( $ e -> getMessage ( ) , 128 ) ; } } 
public function setTarget ( ) { if ( empty ( $ this -> args [ '--target' ] ) ) { $ this -> analyzer -> setTargetPhpVersion ( PhpCodeFixer :: getLatestSupportedTargetVersion ( ) ) ; } else { $ this -> analyzer -> setTargetPhpVersion ( $ this -> args [ '--target' ] ) ; } } 
public function setMaxSize ( ) { static $ size_units = [ 'kb' , 'mb' , 'gb' ] ; if ( ! empty ( $ this -> args [ '--max-size' ] ) ) { foreach ( $ size_units as $ unit ) { if ( stripos ( $ this -> args [ '--max-size' ] , $ unit ) > 0 ) { $ max_size_value = ( int ) stristr ( $ this -> args [ '--max-size' ] , $ unit , true ) ; $ max_size = $ max_size_value * pow ( 1024 , array_search ( $ unit , $ size_units ) + 1 ) ; break ; } } if ( ! isset ( $ max_size ) ) { if ( ( int ) $ this -> args [ '--max-size' ] > 0 ) $ max_size = ( int ) $ this -> args [ '--max-size' ] ; } if ( isset ( $ max_size ) ) { $ this -> analyzer -> setFileSizeLimit ( $ max_size ) ; $ this -> echoInfoLine ( 'Max file size set to: ' . $ this -> formatSize ( '%.3F Ui' , $ max_size ) ) ; } } } 
protected function setExcludeList ( ) { if ( ! empty ( $ this -> args [ '--exclude' ] ) ) { $ this -> analyzer -> setExcludedFilesList ( $ excluded = array_map ( function ( $ dir ) { return trim ( strtolower ( $ dir ) , '/\\ ' ) ; } , explode ( ',' , $ this -> args [ '--exclude' ] ) ) ) ; $ this -> echoInfoLine ( 'Excluding the following files / directories: ' . implode ( ', ' , $ excluded ) ) ; } } 
protected function setSkipChecks ( ) { if ( ! empty ( $ this -> args [ '--skip-checks' ] ) ) { $ this -> analyzer -> setSkippedChecks ( $ skipped_checks = array_map ( 'strtolower' , explode ( ',' , $ this -> args [ '--skip-checks' ] ) ) ) ; $ this -> echoInfoLine ( 'Skipping checks containing any of the following values: ' . implode ( ', ' , $ skipped_checks ) ) ; } } 
protected function setFileExtensions ( ) { if ( ! empty ( $ this -> args [ '--file-extensions' ] ) ) { $ exts = array_map ( 'strtolower' , array_map ( 'trim' , explode ( ',' , $ this -> args [ '--file-extensions' ] ) ) ) ; if ( ! empty ( $ exts ) ) { $ this -> analyzer -> setFileExtensions ( $ exts ) ; $ this -> echoInfoLine ( 'File extensions set to: ' . implode ( ', ' , $ exts ) ) ; } } } 
protected function scanFiles ( ) { $ this -> analyzer -> initialize ( ) ; $ this -> reports = [ ] ; foreach ( $ this -> args [ 'FILES' ] as $ file ) { if ( is_dir ( $ file ) ) { TerminalInfo :: echoWithColor ( 'Scanning ' . $ file . ' ...' . PHP_EOL , TerminalInfo :: GRAY_TEXT ) ; $ this -> reports [ ] = $ this -> analyzer -> checkDir ( rtrim ( realpath ( $ file ) , DIRECTORY_SEPARATOR ) ) ; } else if ( is_file ( $ file ) ) { $ report = new Report ( 'File ' . basename ( $ file ) , dirname ( realpath ( $ file ) ) ) ; $ report = $ this -> analyzer -> checkFile ( realpath ( $ file ) , $ report ) ; if ( $ report instanceof Report ) { $ this -> reports [ ] = $ report ; } } } } 
protected function printReport ( ) { 
public function normalizeAndTruncatePath ( $ path , $ maxLength ) { $ truncated = 1 ; $ path_parts = explode ( '/' , str_replace ( '\\' , '/' , $ path ) ) ; $ total_parts = count ( $ path_parts ) ; while ( strlen ( $ path ) > $ maxLength ) { if ( ( $ truncated + 1 ) === $ total_parts ) break ; $ part_to_modify = $ total_parts - 1 - $ truncated ; $ chars_to_truncate = min ( strlen ( $ path_parts [ $ part_to_modify ] ) - 1 , strlen ( $ path ) - $ maxLength ) ; if ( ( strlen ( $ path ) - $ maxLength + 2 ) < strlen ( $ path_parts [ $ part_to_modify ] ) ) $ chars_to_truncate += 2 ; $ path_parts [ $ part_to_modify ] = substr ( $ path_parts [ $ part_to_modify ] , 0 , - $ chars_to_truncate ) . '..' ; $ path = implode ( '/' , $ path_parts ) ; $ truncated ++ ; } return $ path ; } 
public function formatSize ( $ format , $ bytes , $ unit = null ) { $ units = [ 'B' , 'KB' , 'MB' , 'GB' , 'TB' , 'PB' , 'EB' , 'ZB' , 'YB' ] ; $ bytes = max ( $ bytes , 0 ) ; $ unit = strtoupper ( $ unit ) ; if ( substr ( $ format , - 1 ) === 'i' ) { $ multiplier = 1024 ; $ format = substr ( $ format , 0 , - 1 ) ; } else $ multiplier = 1000 ; if ( $ unit === null || ! in_array ( $ unit , $ units ) ) { $ pow = floor ( ( $ bytes ? log ( $ bytes ) : 0 ) / log ( $ multiplier ) ) ; $ pow = min ( $ pow , count ( $ units ) - 1 ) ; $ bytes /= pow ( $ multiplier , $ pow ) ; $ unit = $ units [ $ pow ] ; } else { $ pow = array_search ( $ unit , $ units ) ; $ bytes /= pow ( $ multiplier , $ pow ) ; } if ( $ multiplier == 1024 ) $ unit = ( strlen ( $ unit ) == 2 ) ? substr ( $ unit , 0 , 1 ) . 'iB' : $ unit ; if ( strpos ( $ format , 'u' ) !== false ) $ format = str_replace ( 'u' , strtolower ( $ unit ) , $ format ) ; else $ format = str_replace ( 'U' , $ unit , $ format ) ; return sprintf ( $ format , $ bytes ) ; } 
public function exitWithError ( $ message , $ code = 128 ) { fwrite ( STDERR , TerminalInfo :: colorize ( $ message , TerminalInfo :: RED_BACKGROUND ) . PHP_EOL ) ; exit ( $ code ) ; } 
public function initialize ( ) { // init issues bank $ this -> issuesBank = new IssuesBank ( ) ; foreach ( static :: $ availableVersions as $ version ) { $ version_issues = include dirname ( dirname ( __FILE__ ) ) . '/data/' . $ version . '.php' ; foreach ( $ version_issues as $ issues_type => $ issues_list ) { $ this -> issuesBank -> import ( $ version , $ issues_type , $ issues_list ) ; } if ( $ version == $ this -> targetPhpVersion ) break ; } } 
public static function makeFunctionCallTree ( array $ tokens ) { $ tree = [ ] ; $ braces_level = 0 ; $ i = 1 ; while ( isset ( $ tokens [ $ i ] ) ) { if ( $ tokens [ $ i ] == '(' ) $ braces_level ++ ; else if ( $ tokens [ $ i ] == ')' ) $ braces_level -- ; else $ tree [ $ braces_level ] [ ] = $ tokens [ $ i ] ; $ i ++ ; } return $ tree ; } 
public static function divideByComma ( array $ tokens ) { $ delimited = [ ] ; $ comma = 0 ; foreach ( $ tokens as $ token ) { if ( $ token == ',' ) $ comma ++ ; else $ delimited [ $ comma ] [ ] = $ token ; } return $ delimited ; } 
public static function trimSpaces ( array $ tokens ) { $ trimmed = [ ] ; foreach ( $ tokens as $ token ) { if ( is_array ( $ token ) ) { if ( $ token [ 0 ] == T_WHITESPACE ) continue ; else $ trimmed [ ] = self :: trimSpaces ( $ token ) ; } else $ trimmed [ ] = $ token ; } return $ trimmed ; } 
protected static function callFunctionUsageChecker ( $ checker , $ functionName , array $ callTokens ) { require_once dirname ( dirname ( __FILE__ ) ) . '/data/' . $ checker . '.php' ; $ checker = __NAMESPACE__ . '\\' . $ checker ; $ result = $ checker ( $ callTokens , $ functionName ) ; return $ result ; } 
public function add ( $ version , $ type , $ text , $ replacement , $ file , $ line ) { if ( $ this -> removablePath !== null && strncasecmp ( $ file , $ this -> removablePath , strlen ( $ this -> removablePath ) ) === 0 ) $ file = substr ( $ file , strlen ( $ this -> removablePath ) ) ; $ this -> records [ $ version ] [ ] = [ $ type , $ text , $ replacement , $ file , $ line ] ; } 
static public function isColorsCapable ( ) { if ( self :: $ colorsCapability === null ) { if ( ! static :: isUnixPlatform ( ) ) self :: $ colorsCapability = false ; else if ( ! static :: isInteractive ( ) ) self :: $ colorsCapability = false ; else { $ tput_presence = static :: exec ( 'which tput' ) ; if ( strlen ( trim ( $ tput_presence [ 0 ] ) ) === 0 ) self :: $ colorsCapability = false ; else { $ tput_colors = static :: exec ( 'tput colors' ) ; self :: $ colorsCapability = ( int ) $ tput_colors [ 0 ] > 0 ; } } } return self :: $ colorsCapability ; } 
static public function echoWithColor ( $ text , $ color , $ backgroundColor = null ) { if ( static :: isColorsCapable ( ) ) fwrite ( STDOUT , $ backgroundColor . $ color . $ text . self :: RESET_COLOR ) ; else fwrite ( STDOUT , $ text ) ; } 
static protected function getWindowsTerminalSize ( ) { $ output = self :: exec ( 'mode' , $ returnCode ) ; if ( $ returnCode !== 0 ) return [ 25 , 80 ] ; foreach ( $ output as $ i => $ line ) { if ( strpos ( $ line , ' CON' ) !== false ) { $ sizes = [ $ output [ $ i + 2 ] , $ output [ $ i + 3 ] ] ; break ; } } if ( ! isset ( $ sizes ) ) return [ 25 , 80 ] ; return array_map ( function ( $ val ) { list ( , $ val ) = explode ( ':' , $ val ) ; return trim ( $ val ) ; } , $ sizes ) ; } 
public function getProperty ( $ name ) { $ betterReflectionProperty = $ this -> betterReflectionClass -> getProperty ( $ name ) ; if ( $ betterReflectionProperty === null ) { throw new CoreReflectionException ( sprintf ( 'Property "%s" does not exist' , $ name ) ) ; } return new ReflectionProperty ( $ betterReflectionProperty ) ; } 
public function getReflectionConstants ( ) { return array_map ( static function ( BetterReflectionClassConstant $ betterConstant ) : ReflectionClassConstant { return new ReflectionClassConstant ( $ betterConstant ) ; } , $ this -> betterReflectionClass -> getReflectionConstants ( ) ) ; } 
public function getInterfaces ( ) { $ interfaces = $ this -> betterReflectionClass -> getInterfaces ( ) ; $ wrappedInterfaces = [ ] ; foreach ( $ interfaces as $ key => $ interface ) { $ wrappedInterfaces [ $ key ] = new self ( $ interface ) ; } return $ wrappedInterfaces ; } 
public function getTraits ( ) { $ traits = $ this -> betterReflectionClass -> getTraits ( ) ; $ wrappedTraits = [ ] ; foreach ( $ traits as $ key => $ trait ) { $ wrappedTraits [ $ key ] = new self ( $ trait ) ; } return $ wrappedTraits ; } 
public function getParentClass ( ) { $ parentClass = $ this -> betterReflectionClass -> getParentClass ( ) ; if ( $ parentClass === null ) { return false ; } return new self ( $ parentClass ) ; } 
public function isSubclassOf ( $ class ) { $ realParentClassNames = $ this -> betterReflectionClass -> getParentClassNames ( ) ; $ parentClassNames = array_combine ( array_map ( static function ( string $ parentClassName ) : string { return strtolower ( $ parentClassName ) ; } , $ realParentClassNames ) , $ realParentClassNames ) ; $ realParentClassName = $ parentClassNames [ strtolower ( $ class ) ] ?? $ class ; return $ this -> betterReflectionClass -> isSubclassOf ( $ realParentClassName ) || $ this -> implementsInterface ( $ class ) ; } 
public function getStaticPropertyValue ( $ name , $ default = null ) { $ betterReflectionProperty = $ this -> betterReflectionClass -> getProperty ( $ name ) ; if ( $ betterReflectionProperty === null ) { if ( func_num_args ( ) === 2 ) { return $ default ; } throw new CoreReflectionException ( sprintf ( 'Property "%s" does not exist' , $ name ) ) ; } $ property = new ReflectionProperty ( $ betterReflectionProperty ) ; if ( ! $ property -> isAccessible ( ) ) { throw new CoreReflectionException ( sprintf ( 'Property "%s" is not accessible' , $ name ) ) ; } if ( ! $ property -> isStatic ( ) ) { throw new CoreReflectionException ( sprintf ( 'Property "%s" is not static' , $ name ) ) ; } return $ property -> getValue ( ) ; } 
public function setStaticPropertyValue ( $ name , $ value ) { $ betterReflectionProperty = $ this -> betterReflectionClass -> getProperty ( $ name ) ; if ( $ betterReflectionProperty === null ) { throw new CoreReflectionException ( sprintf ( 'Property "%s" does not exist' , $ name ) ) ; } $ property = new ReflectionProperty ( $ betterReflectionProperty ) ; if ( ! $ property -> isAccessible ( ) ) { throw new CoreReflectionException ( sprintf ( 'Property "%s" is not accessible' , $ name ) ) ; } if ( ! $ property -> isStatic ( ) ) { throw new CoreReflectionException ( sprintf ( 'Property "%s" is not static' , $ name ) ) ; } $ property -> setValue ( $ value ) ; } 
public function implementsInterface ( $ interface ) { $ realInterfaceNames = $ this -> betterReflectionClass -> getInterfaceNames ( ) ; $ interfaceNames = array_combine ( array_map ( static function ( string $ interfaceName ) : string { return strtolower ( $ interfaceName ) ; } , $ realInterfaceNames ) , $ realInterfaceNames ) ; $ realInterfaceName = $ interfaceNames [ strtolower ( $ interface ) ] ?? $ interface ; return $ this -> betterReflectionClass -> implementsInterface ( $ realInterfaceName ) ; } 
protected function createLocatedSource ( Identifier $ identifier ) : ? LocatedSource { $ potentiallyLocatedFile = $ this -> attemptAutoloadForIdentifier ( $ identifier ) ; if ( ! ( $ potentiallyLocatedFile && file_exists ( $ potentiallyLocatedFile ) ) ) { return null ; } return new LocatedSource ( file_get_contents ( $ potentiallyLocatedFile ) , $ potentiallyLocatedFile ) ; } 
private function attemptAutoloadForIdentifier ( Identifier $ identifier ) : ? string { if ( $ identifier -> isClass ( ) ) { return $ this -> locateClassByName ( $ identifier -> getName ( ) ) ; } if ( $ identifier -> isFunction ( ) ) { return $ this -> locateFunctionByName ( $ identifier -> getName ( ) ) ; } return null ; } 
private function locateClassByName ( string $ className ) : ? string { if ( class_exists ( $ className , false ) || interface_exists ( $ className , false ) || trait_exists ( $ className , false ) ) { $ filename = ( new ReflectionClass ( $ className ) ) -> getFileName ( ) ; if ( ! is_string ( $ filename ) ) { return null ; } return $ filename ; } self :: $ autoloadLocatedFile = null ; self :: $ currentAstLocator = $ this -> astLocator ; 
private function locateFunctionByName ( string $ functionName ) : ? string { if ( ! function_exists ( $ functionName ) ) { return null ; } $ reflection = new ReflectionFunction ( $ functionName ) ; $ reflectionFileName = $ reflection -> getFileName ( ) ; if ( ! is_string ( $ reflectionFileName ) ) { return null ; } return $ reflectionFileName ; } 
public function stream_open ( $ path , $ mode , $ options , & $ opened_path ) : bool { self :: $ autoloadLocatedFile = $ path ; return false ; } 
public function url_stat ( $ path , $ flags ) { stream_wrapper_restore ( 'file' ) ; if ( $ flags & STREAM_URL_STAT_QUIET ) { set_error_handler ( static function ( ) { 
public function locateIdentifier ( Reflector $ reflector , Identifier $ identifier ) : ? Reflection { $ locatedSource = $ this -> createLocatedSource ( $ identifier ) ; if ( ! $ locatedSource ) { return null ; } try { return $ this -> astLocator -> findReflection ( $ reflector , $ locatedSource , $ identifier ) ; } catch ( IdentifierNotFound $ exception ) { return null ; } } 
final public function locateIdentifiersByType ( Reflector $ reflector , IdentifierType $ identifierType ) : array { $ locatedSource = $ this -> createLocatedSource ( new Identifier ( Identifier :: WILDCARD , $ identifierType ) ) ; if ( ! $ locatedSource ) { return [ ] ; } return $ this -> astLocator -> findReflectionsOfType ( $ reflector , $ locatedSource , $ identifierType ) ; } 
private function compileConstFetch ( Node \ Expr \ ConstFetch $ constNode , CompilerContext $ context ) { $ firstName = reset ( $ constNode -> name -> parts ) ; switch ( $ firstName ) { case 'null' : return null ; case 'false' : return false ; case 'true' : return true ; default : if ( ! defined ( $ firstName ) ) { throw Exception \ UnableToCompileNode :: becauseOfNotFoundConstantReference ( $ context , $ constNode ) ; } return constant ( $ firstName ) ; } } 
private function compileClassConstFetch ( Node \ Expr \ ClassConstFetch $ node , CompilerContext $ context ) { $ nodeName = $ node -> name -> name ; $ className = $ node -> class -> toString ( ) ; if ( $ nodeName === 'class' ) { return $ className ; } $ classInfo = null ; if ( $ className === 'self' || $ className === 'static' ) { $ classInfo = $ this -> getConstantDeclaringClass ( $ nodeName , $ context -> getSelf ( ) ) ; } if ( $ classInfo === null ) { $ classInfo = $ context -> getReflector ( ) -> reflect ( $ className ) ; } $ reflectionConstant = $ classInfo -> getReflectionConstant ( $ nodeName ) ; if ( ! $ reflectionConstant instanceof ReflectionClassConstant ) { throw Exception \ UnableToCompileNode :: becauseOfNotFoundClassConstantReference ( $ context , $ classInfo , $ node ) ; } return $ this -> __invoke ( $ reflectionConstant -> getAst ( ) -> consts [ $ reflectionConstant -> getPositionInAst ( ) ] -> value , new CompilerContext ( $ context -> getReflector ( ) , $ classInfo ) ) ; } 
private function compileDirConstant ( CompilerContext $ context ) : string { return FileHelper :: normalizeWindowsPath ( dirname ( realpath ( $ context -> getFileName ( ) ) ) ) ; } 
private function computeReflections ( string $ filename ) : array { $ singleFileSourceLocator = new SingleFileSourceLocator ( $ filename , $ this -> astLocator ) ; $ reflector = new ClassReflector ( new AggregateSourceLocator ( [ $ singleFileSourceLocator , $ this -> sourceLocator ] ) ) ; return array_merge ( $ singleFileSourceLocator -> locateIdentifiersByType ( $ reflector , new IdentifierType ( IdentifierType :: IDENTIFIER_CLASS ) ) , $ singleFileSourceLocator -> locateIdentifiersByType ( $ reflector , new IdentifierType ( IdentifierType :: IDENTIFIER_FUNCTION ) ) ) ; } 
private function containsLine ( $ reflection , int $ lineNumber ) : bool { if ( ! method_exists ( $ reflection , 'getStartLine' ) ) { throw new InvalidArgumentException ( 'Reflection does not have getStartLine method' ) ; } if ( ! method_exists ( $ reflection , 'getEndLine' ) ) { throw new InvalidArgumentException ( 'Reflection does not have getEndLine method' ) ; } return $ lineNumber >= $ reflection -> getStartLine ( ) && $ lineNumber <= $ reflection -> getEndLine ( ) ; } 
public function reflect ( string $ className ) : Reflection { $ identifier = new Identifier ( $ className , new IdentifierType ( IdentifierType :: IDENTIFIER_CLASS ) ) ; $ classInfo = $ this -> sourceLocator -> locateIdentifier ( $ this , $ identifier ) ; if ( $ classInfo === null ) { throw Exception \ IdentifierNotFound :: fromIdentifier ( $ identifier ) ; } return $ classInfo ; } 
public function getAllClasses ( ) : array { $ allClasses = $ this -> sourceLocator -> locateIdentifiersByType ( $ this , new IdentifierType ( IdentifierType :: IDENTIFIER_CLASS ) ) ; return $ allClasses ; } 
public static function createFromName ( string $ className , string $ propertyName ) : self { return ReflectionClass :: createFromName ( $ className ) -> getProperty ( $ propertyName ) ; } 
public static function createFromInstance ( $ instance , string $ propertyName ) : self { return ReflectionClass :: createFromInstance ( $ instance ) -> getProperty ( $ propertyName ) ; } 
public static function createFromNode ( Reflector $ reflector , PropertyNode $ node , int $ positionInNode , ? Namespace_ $ declaringNamespace , ReflectionClass $ declaringClass , ReflectionClass $ implementingClass , bool $ declaredAtCompileTime = true ) : self { $ prop = new self ( ) ; $ prop -> reflector = $ reflector ; $ prop -> node = $ node ; $ prop -> positionInNode = $ positionInNode ; $ prop -> declaringNamespace = $ declaringNamespace ; $ prop -> declaringClass = $ declaringClass ; $ prop -> implementingClass = $ implementingClass ; $ prop -> declaredAtCompileTime = $ declaredAtCompileTime ; return $ prop ; } 
public function setVisibility ( int $ newVisibility ) : void { $ this -> node -> flags &= ~ Class_ :: MODIFIER_PRIVATE & ~ Class_ :: MODIFIER_PROTECTED & ~ Class_ :: MODIFIER_PUBLIC ; switch ( $ newVisibility ) { case CoreReflectionProperty :: IS_PRIVATE : $ this -> node -> flags |= Class_ :: MODIFIER_PRIVATE ; break ; case CoreReflectionProperty :: IS_PROTECTED : $ this -> node -> flags |= Class_ :: MODIFIER_PROTECTED ; break ; case CoreReflectionProperty :: IS_PUBLIC : $ this -> node -> flags |= Class_ :: MODIFIER_PUBLIC ; break ; default : throw new InvalidArgumentException ( 'Visibility should be \ReflectionProperty::IS_PRIVATE, ::IS_PROTECTED or ::IS_PUBLIC constants' ) ; } } 
public function getModifiers ( ) : int { $ val = 0 ; $ val += $ this -> isStatic ( ) ? CoreReflectionProperty :: IS_STATIC : 0 ; $ val += $ this -> isPublic ( ) ? CoreReflectionProperty :: IS_PUBLIC : 0 ; $ val += $ this -> isProtected ( ) ? CoreReflectionProperty :: IS_PROTECTED : 0 ; $ val += $ this -> isPrivate ( ) ? CoreReflectionProperty :: IS_PRIVATE : 0 ; return $ val ; } 
public function getDocBlockTypeStrings ( ) : array { $ stringTypes = [ ] ; foreach ( $ this -> getDocBlockTypes ( ) as $ type ) { $ stringTypes [ ] = ( string ) $ type ; } return $ stringTypes ; } 
public function getDefaultValue ( ) { $ defaultValueNode = $ this -> node -> props [ $ this -> positionInNode ] -> default ; if ( $ defaultValueNode === null ) { return null ; } return ( new CompileNodeToValue ( ) ) -> __invoke ( $ defaultValueNode , new CompilerContext ( $ this -> reflector , $ this -> getDeclaringClass ( ) ) ) ; } 
public function getValue ( $ object = null ) { $ declaringClassName = $ this -> getDeclaringClass ( ) -> getName ( ) ; if ( $ this -> isStatic ( ) ) { $ this -> assertClassExist ( $ declaringClassName ) ; return Closure :: bind ( function ( string $ declaringClassName , string $ propertyName ) { return $ declaringClassName :: $ { $ propertyName } ; } , null , $ declaringClassName ) -> __invoke ( $ declaringClassName , $ this -> getName ( ) ) ; } $ instance = $ this -> assertObject ( $ object ) ; return Closure :: bind ( function ( $ instance , string $ propertyName ) { return $ instance -> { $ propertyName } ; } , $ instance , $ declaringClassName ) -> __invoke ( $ instance , $ this -> getName ( ) ) ; } 
public function setValue ( $ object , $ value = null ) : void { $ declaringClassName = $ this -> getDeclaringClass ( ) -> getName ( ) ; if ( $ this -> isStatic ( ) ) { $ this -> assertClassExist ( $ declaringClassName ) ; Closure :: bind ( function ( string $ declaringClassName , string $ propertyName , $ value ) : void { $ declaringClassName :: $ { $ propertyName } = $ value ; } , null , $ declaringClassName ) -> __invoke ( $ declaringClassName , $ this -> getName ( ) , func_num_args ( ) === 2 ? $ value : $ object ) ; return ; } $ instance = $ this -> assertObject ( $ object ) ; Closure :: bind ( function ( $ instance , string $ propertyName , $ value ) : void { $ instance -> { $ propertyName } = $ value ; } , $ instance , $ declaringClassName ) -> __invoke ( $ instance , $ this -> getName ( ) , $ value ) ; } 
private function assertObject ( $ object ) { if ( $ object === null ) { throw NoObjectProvided :: create ( ) ; } if ( ! is_object ( $ object ) ) { throw NotAnObject :: fromNonObject ( $ object ) ; } $ declaringClassName = $ this -> getDeclaringClass ( ) -> getName ( ) ; if ( get_class ( $ object ) !== $ declaringClassName ) { throw ObjectNotInstanceOfClass :: fromClassName ( $ declaringClassName ) ; } return $ object ; } 
public function locateIdentifiersByType ( Reflector $ reflector , IdentifierType $ identifierType ) : array { return array_filter ( [ $ this -> getReflectionClass ( $ reflector , $ identifierType ) ] ) ; } 
public function resolvePossibleFilePaths ( Identifier $ identifier ) : array { if ( ! $ identifier -> isClass ( ) ) { return [ ] ; } $ className = $ identifier -> getName ( ) ; foreach ( $ this -> mappings as $ prefix => $ paths ) { if ( strpos ( $ className , $ prefix ) === 0 ) { return array_map ( static function ( string $ path ) use ( $ className ) : string { return rtrim ( $ path , '/' ) . '/' . str_replace ( [ '\\' , '_' ] , '/' , $ className ) . '.php' ; } , $ paths ) ; } } return [ ] ; } 
private static function assertValidMapping ( array $ mappings ) : void { foreach ( $ mappings as $ prefix => $ paths ) { if ( $ prefix === '' ) { throw InvalidPrefixMapping :: emptyPrefixGiven ( ) ; } if ( $ paths === [ ] ) { throw InvalidPrefixMapping :: emptyPrefixMappingGiven ( $ prefix ) ; } foreach ( $ paths as $ path ) { if ( ! is_dir ( $ path ) ) { throw InvalidPrefixMapping :: prefixMappingIsNotADirectory ( $ prefix , $ path ) ; } } } } 
public static function createFromNode ( Reflector $ reflector , FunctionNode $ node , LocatedSource $ locatedSource , ? NamespaceNode $ namespaceNode = null ) : self { $ function = new self ( ) ; $ function -> populateFunctionAbstract ( $ reflector , $ node , $ locatedSource , $ namespaceNode ) ; return $ function ; } 
public function invokeArgs ( array $ args = [ ] ) { $ this -> assertIsNoClosure ( ) ; $ functionName = $ this -> getName ( ) ; $ this -> assertFunctionExist ( $ functionName ) ; return $ functionName ( ... $ args ) ; } 
protected function createLocatedSource ( Identifier $ identifier ) : ? LocatedSource { if ( $ identifier -> getType ( ) -> getName ( ) !== IdentifierType :: IDENTIFIER_CLASS ) { return null ; } $ filename = $ this -> classLoader -> findFile ( $ identifier -> getName ( ) ) ; if ( ! $ filename ) { return null ; } return new LocatedSource ( file_get_contents ( $ filename ) , $ filename ) ; } 
public function findReflectionsOfType ( Reflector $ reflector , LocatedSource $ locatedSource , IdentifierType $ identifierType ) : array { try { return $ this -> findReflectionsInTree -> __invoke ( $ reflector , $ this -> parser -> parse ( $ locatedSource -> getSource ( ) ) , $ identifierType , $ locatedSource ) ; } catch ( Throwable $ exception ) { throw Exception \ ParseToAstFailure :: fromLocatedSource ( $ locatedSource , $ exception ) ; } } 
private function findInArray ( array $ reflections , Identifier $ identifier ) : Reflection { $ identifierName = strtolower ( $ identifier -> getName ( ) ) ; foreach ( $ reflections as $ reflection ) { if ( strtolower ( $ reflection -> getName ( ) ) === $ identifierName ) { return $ reflection ; } } throw IdentifierNotFound :: fromIdentifier ( $ identifier ) ; } 
protected function createLocatedSource ( Identifier $ identifier ) : ? LocatedSource { return new LocatedSource ( file_get_contents ( $ this -> fileName ) , $ this -> fileName ) ; } 
public function locateIdentifier ( Reflector $ reflector , Identifier $ identifier ) : ? Reflection { return $ this -> aggregateSourceLocator -> locateIdentifier ( $ reflector , $ identifier ) ; } 
public function locateIdentifiersByType ( Reflector $ reflector , IdentifierType $ identifierType ) : array { return $ this -> aggregateSourceLocator -> locateIdentifiersByType ( $ reflector , $ identifierType ) ; } 
public static function createFromClassNameAndMethod ( string $ className , string $ methodName , string $ parameterName ) : self { return ReflectionClass :: createFromName ( $ className ) -> getMethod ( $ methodName ) -> getParameter ( $ parameterName ) ; } 
public static function createFromClassInstanceAndMethod ( $ instance , string $ methodName , string $ parameterName ) : self { return ReflectionClass :: createFromInstance ( $ instance ) -> getMethod ( $ methodName ) -> getParameter ( $ parameterName ) ; } 
public static function createFromClosure ( Closure $ closure , string $ parameterName ) : ReflectionParameter { return ReflectionFunction :: createFromClosure ( $ closure ) -> getParameter ( $ parameterName ) ; } 
public static function createFromSpec ( $ spec , string $ parameterName ) : self { if ( is_array ( $ spec ) && count ( $ spec ) === 2 && is_string ( $ spec [ 1 ] ) ) { if ( is_object ( $ spec [ 0 ] ) ) { return self :: createFromClassInstanceAndMethod ( $ spec [ 0 ] , $ spec [ 1 ] , $ parameterName ) ; } return self :: createFromClassNameAndMethod ( $ spec [ 0 ] , $ spec [ 1 ] , $ parameterName ) ; } if ( is_string ( $ spec ) ) { return ReflectionFunction :: createFromName ( $ spec ) -> getParameter ( $ parameterName ) ; } if ( $ spec instanceof Closure ) { return self :: createFromClosure ( $ spec , $ parameterName ) ; } throw new InvalidArgumentException ( 'Could not create reflection from the spec given' ) ; } 
public static function createFromNode ( Reflector $ reflector , ParamNode $ node , ? Namespace_ $ declaringNamespace , ReflectionFunctionAbstract $ function , int $ parameterIndex ) : self { $ param = new self ( ) ; $ param -> reflector = $ reflector ; $ param -> node = $ node ; $ param -> declaringNamespace = $ declaringNamespace ; $ param -> function = $ function ; $ param -> parameterIndex = $ parameterIndex ; return $ param ; } 
public function allowsNull ( ) : bool { if ( ! $ this -> hasType ( ) ) { return true ; } if ( $ this -> node -> type instanceof NullableType ) { return true ; } if ( ! $ this -> isDefaultValueAvailable ( ) ) { return false ; } return $ this -> getDefaultValue ( ) === null ; } 
public function getType ( ) : ? ReflectionType { $ type = $ this -> node -> type ; if ( $ type === null ) { return null ; } if ( $ type instanceof NullableType ) { $ type = $ type -> type ; } return ReflectionType :: createFromTypeAndReflector ( ( string ) $ type , $ this -> allowsNull ( ) , $ this -> reflector ) ; } 
public function setType ( string $ newParameterType ) : void { $ this -> node -> type = new Node \ Name ( $ newParameterType ) ; } 
public function getClass ( ) : ? ReflectionClass { $ className = $ this -> getClassName ( ) ; if ( $ className === null ) { return null ; } if ( ! $ this -> reflector instanceof ClassReflector ) { throw new RuntimeException ( sprintf ( 'Unable to reflect class type because we were not given a "%s", but a "%s" instead' , ClassReflector :: class , get_class ( $ this -> reflector ) ) ) ; } return $ this -> reflector -> reflect ( $ className ) ; } 
public function invoke ( $ args = null ) { try { return $ this -> betterReflectionFunction -> invoke ( ... func_get_args ( ) ) ; } catch ( Throwable $ e ) { throw new CoreReflectionException ( $ e -> getMessage ( ) , 0 , $ e ) ; } } 
public function invokeArgs ( array $ args ) { try { return $ this -> betterReflectionFunction -> invokeArgs ( $ args ) ; } catch ( Throwable $ e ) { throw new CoreReflectionException ( $ e -> getMessage ( ) , 0 , $ e ) ; } } 
public function isBuiltin ( ) : bool { $ type = ( string ) $ this -> betterReflectionType ; if ( $ type === 'self' || $ type === 'parent' ) { return false ; } return $ this -> betterReflectionType -> isBuiltin ( ) ; } 
protected function createLocatedSource ( Identifier $ identifier ) : ? LocatedSource { return $ this -> getClassSource ( $ identifier ) ?? $ this -> getFunctionSource ( $ identifier ) ; } 
public function getParameters ( ) { $ parameters = $ this -> betterReflectionMethod -> getParameters ( ) ; $ wrappedParameters = [ ] ; foreach ( $ parameters as $ key => $ parameter ) { $ wrappedParameters [ $ key ] = new ReflectionParameter ( $ parameter ) ; } return $ wrappedParameters ; } 
public function getClosure ( $ object = null ) { try { return $ this -> betterReflectionMethod -> getClosure ( $ object ) ; } catch ( NoObjectProvided | NotAnObject $ e ) { return null ; } catch ( Throwable $ e ) { throw new CoreReflectionException ( $ e -> getMessage ( ) , 0 , $ e ) ; } } 
public function invoke ( $ object = null , $ args = null ) { if ( ! $ this -> isAccessible ( ) ) { throw new CoreReflectionException ( 'Method not accessible' ) ; } try { return $ this -> betterReflectionMethod -> invoke ( ... func_get_args ( ) ) ; } catch ( NoObjectProvided | NotAnObject $ e ) { return null ; } catch ( Throwable $ e ) { throw new CoreReflectionException ( $ e -> getMessage ( ) , 0 , $ e ) ; } } 
public function invokeArgs ( $ object = null , array $ args = [ ] ) { if ( ! $ this -> isAccessible ( ) ) { throw new CoreReflectionException ( 'Method not accessible' ) ; } try { return $ this -> betterReflectionMethod -> invokeArgs ( $ object , $ args ) ; } catch ( NoObjectProvided | NotAnObject $ e ) { return null ; } catch ( Throwable $ e ) { throw new CoreReflectionException ( $ e -> getMessage ( ) , 0 , $ e ) ; } } 
public function resolvePossibleFilePaths ( Identifier $ identifier ) : array { if ( ! $ identifier -> isClass ( ) ) { return [ ] ; } $ className = $ identifier -> getName ( ) ; $ matchingPrefixes = $ this -> matchingPrefixes ( $ className ) ; return array_values ( array_filter ( array_merge ( [ ] , ... array_map ( static function ( array $ paths , string $ prefix ) use ( $ className ) : array { $ subPath = ltrim ( str_replace ( '\\' , '/' , substr ( $ className , strlen ( $ prefix ) ) ) , '/' ) ; if ( $ subPath === '' ) { return [ ] ; } return array_map ( static function ( string $ path ) use ( $ subPath ) : string { return rtrim ( $ path , '/' ) . '/' . $ subPath . '.php' ; } , $ paths ) ; } , $ matchingPrefixes , array_keys ( $ matchingPrefixes ) ) ) ) ) ; } 
protected function createLocatedSource ( Identifier $ identifier ) : ? LocatedSource { $ classReflection = $ this -> getInternalReflectionClass ( $ identifier ) ; if ( $ classReflection === null ) { return null ; } $ stub = $ this -> stubber -> generateClassStub ( $ classReflection ) ; if ( $ stub === null ) { return null ; } return new EvaledLocatedSource ( $ stub ) ; } 
public function reflect ( string $ functionName ) : Reflection { $ identifier = new Identifier ( $ functionName , new IdentifierType ( IdentifierType :: IDENTIFIER_FUNCTION ) ) ; $ functionInfo = $ this -> sourceLocator -> locateIdentifier ( $ this -> classReflector , $ identifier ) ; if ( $ functionInfo === null ) { throw Exception \ IdentifierNotFound :: fromIdentifier ( $ identifier ) ; } return $ functionInfo ; } 
public function getAllFunctions ( ) : array { $ allFunctions = $ this -> sourceLocator -> locateIdentifiersByType ( $ this , new IdentifierType ( IdentifierType :: IDENTIFIER_FUNCTION ) ) ; return $ allFunctions ; } 
public function locateIdentifier ( Reflector $ reflector , Identifier $ identifier ) : ? Reflection { return $ this -> getAggregatedSourceLocator ( ) -> locateIdentifier ( $ reflector , $ identifier ) ; } 
public function locateIdentifiersByType ( Reflector $ reflector , IdentifierType $ identifierType ) : array { return $ this -> getAggregatedSourceLocator ( ) -> locateIdentifiersByType ( $ reflector , $ identifierType ) ; } 
public static function createFromNode ( Reflector $ reflector , MethodNode $ node , ? Namespace_ $ namespace , ReflectionClass $ declaringClass , ReflectionClass $ implementingClass ) : self { $ method = new self ( ) ; $ method -> declaringClass = $ declaringClass ; $ method -> implementingClass = $ implementingClass ; $ method -> methodNode = $ node ; $ method -> populateFunctionAbstract ( $ reflector , $ node , $ declaringClass -> getLocatedSource ( ) , $ namespace ) ; return $ method ; } 
public static function createFromName ( string $ className , string $ methodName ) : self { return ReflectionClass :: createFromName ( $ className ) -> getMethod ( $ methodName ) ; } 
public static function createFromInstance ( $ instance , string $ methodName ) : self { return ReflectionClass :: createFromInstance ( $ instance ) -> getMethod ( $ methodName ) ; } 
public function getPrototype ( ) : self { $ currentClass = $ this -> getDeclaringClass ( ) ; while ( $ currentClass ) { foreach ( $ currentClass -> getImmediateInterfaces ( ) as $ interface ) { if ( $ interface -> hasMethod ( $ this -> getName ( ) ) ) { return $ interface -> getMethod ( $ this -> getName ( ) ) ; } } $ currentClass = $ currentClass -> getParentClass ( ) ; if ( $ currentClass === null || ! $ currentClass -> hasMethod ( $ this -> getName ( ) ) ) { break ; } $ prototype = $ currentClass -> getMethod ( $ this -> getName ( ) ) -> findPrototype ( ) ; if ( $ prototype !== null ) { return $ prototype ; } } throw new Exception \ MethodPrototypeNotFound ( sprintf ( 'Method %s::%s does not have a prototype' , $ this -> getDeclaringClass ( ) -> getName ( ) , $ this -> getName ( ) ) ) ; } 
public function getModifiers ( ) : int { $ val = 0 ; $ val += $ this -> isStatic ( ) ? CoreReflectionMethod :: IS_STATIC : 0 ; $ val += $ this -> isPublic ( ) ? CoreReflectionMethod :: IS_PUBLIC : 0 ; $ val += $ this -> isProtected ( ) ? CoreReflectionMethod :: IS_PROTECTED : 0 ; $ val += $ this -> isPrivate ( ) ? CoreReflectionMethod :: IS_PRIVATE : 0 ; $ val += $ this -> isAbstract ( ) ? CoreReflectionMethod :: IS_ABSTRACT : 0 ; $ val += $ this -> isFinal ( ) ? CoreReflectionMethod :: IS_FINAL : 0 ; return $ val ; } 
public function isConstructor ( ) : bool { if ( strtolower ( $ this -> getName ( ) ) === '__construct' ) { return true ; } $ declaringClass = $ this -> getDeclaringClass ( ) ; if ( $ declaringClass -> inNamespace ( ) ) { return false ; } return strtolower ( $ this -> getName ( ) ) === strtolower ( $ declaringClass -> getShortName ( ) ) ; } 
public function getClosure ( $ object = null ) : Closure { $ declaringClassName = $ this -> getDeclaringClass ( ) -> getName ( ) ; if ( $ this -> isStatic ( ) ) { $ this -> assertClassExist ( $ declaringClassName ) ; return function ( ... $ args ) { return $ this -> callStaticMethod ( $ args ) ; } ; } $ instance = $ this -> assertObject ( $ object ) ; return function ( ... $ args ) use ( $ instance ) { return $ this -> callObjectMethod ( $ instance , $ args ) ; } ; } 
public function invokeArgs ( $ object = null , array $ args = [ ] ) { $ declaringClassName = $ this -> getDeclaringClass ( ) -> getName ( ) ; if ( $ this -> isStatic ( ) ) { $ this -> assertClassExist ( $ declaringClassName ) ; return $ this -> callStaticMethod ( $ args ) ; } return $ this -> callObjectMethod ( $ this -> assertObject ( $ object ) , $ args ) ; } 
private function callStaticMethod ( array $ args ) { $ declaringClassName = $ this -> getDeclaringClass ( ) -> getName ( ) ; return Closure :: bind ( function ( string $ declaringClassName , string $ methodName , array $ methodArgs ) { return $ declaringClassName :: { $ methodName } ( ... $ methodArgs ) ; } , null , $ declaringClassName ) -> __invoke ( $ declaringClassName , $ this -> getName ( ) , $ args ) ; } 
private function callObjectMethod ( $ object , array $ args ) { return Closure :: bind ( function ( $ object , string $ methodName , array $ methodArgs ) { return $ object -> { $ methodName } ( ... $ methodArgs ) ; } , $ object , $ this -> getDeclaringClass ( ) -> getName ( ) ) -> __invoke ( $ object , $ this -> getName ( ) , $ args ) ; } 
public function getDeclaringClass ( ) { $ declaringClass = $ this -> betterReflectionParameter -> getDeclaringClass ( ) ; if ( $ declaringClass === null ) { return null ; } return new ReflectionClass ( $ declaringClass ) ; } 
private function prefixWithPackagePath ( array $ paths , string $ trimmedInstallationPath , array $ package ) : array { $ prefix = $ this -> packagePrefixPath ( $ trimmedInstallationPath , $ package ) ; return array_map ( function ( array $ paths ) use ( $ prefix ) : array { return $ this -> prefixPaths ( $ paths , $ prefix ) ; } , $ paths ) ; } 
private function prefixPaths ( array $ paths , string $ prefix ) : array { return array_map ( static function ( string $ path ) use ( $ prefix ) { return $ prefix . $ path ; } , $ paths ) ; } 
public static function export ( ? string $ className ) : string { if ( $ className === null ) { throw new InvalidArgumentException ( 'Class name must be provided' ) ; } return self :: createFromName ( $ className ) -> __toString ( ) ; } 
public static function createFromNode ( Reflector $ reflector , ClassLikeNode $ node , LocatedSource $ locatedSource , ? NamespaceNode $ namespace = null ) : self { $ class = new self ( ) ; $ class -> reflector = $ reflector ; $ class -> locatedSource = $ locatedSource ; $ class -> node = $ node ; if ( $ namespace !== null ) { $ class -> declaringNamespace = $ namespace ; } return $ class ; } 
public function getShortName ( ) : string { if ( ! $ this -> isAnonymous ( ) ) { return $ this -> node -> name -> name ; } $ fileName = $ this -> getFileName ( ) ; if ( $ fileName === null ) { $ fileName = sha1 ( $ this -> locatedSource -> getSource ( ) ) ; } return sprintf ( '%s%c%s(%d)' , self :: ANONYMOUS_CLASS_NAME_PREFIX , "\0" , $ fileName , $ this -> getStartLine ( ) ) ; } 
public function getName ( ) : string { if ( ! $ this -> inNamespace ( ) ) { return $ this -> getShortName ( ) ; } return $ this -> node -> namespacedName -> toString ( ) ; } 
private function getAllMethods ( ) : array { return array_merge ( [ ] , array_map ( function ( ClassMethod $ methodNode ) : ReflectionMethod { return ReflectionMethod :: createFromNode ( $ this -> reflector , $ methodNode , $ this -> declaringNamespace , $ this , $ this ) ; } , $ this -> node -> getMethods ( ) ) , ... array_map ( function ( ReflectionClass $ trait ) : array { return array_map ( function ( ReflectionMethod $ method ) use ( $ trait ) : ReflectionMethod { $ methodAst = $ method -> getAst ( ) ; return ReflectionMethod :: createFromNode ( $ this -> reflector , $ methodAst , $ this -> declaringNamespace , $ trait , $ this ) ; } , $ trait -> getMethods ( ) ) ; } , $ this -> getTraits ( ) ) , ... array_map ( static function ( ReflectionClass $ ancestor ) : array { return $ ancestor -> getMethods ( ) ; } , array_values ( array_merge ( array_filter ( [ $ this -> getParentClass ( ) ] ) , $ this -> getInterfaces ( ) ) ) ) ) ; } 
private function getMethodsIndexedByName ( ) : array { if ( $ this -> cachedMethods !== null ) { return $ this -> cachedMethods ; } $ this -> cachedMethods = [ ] ; $ traitAliases = $ this -> getTraitAliases ( ) ; foreach ( $ this -> getAllMethods ( ) as $ method ) { $ methodName = $ method -> getName ( ) ; $ methodNameWithClassName = sprintf ( '%s::%s' , $ method -> getDeclaringClass ( ) -> getName ( ) , $ methodName ) ; foreach ( $ traitAliases as $ methodAlias => $ traitMethodNameWithTraitName ) { if ( $ methodNameWithClassName !== $ traitMethodNameWithTraitName ) { continue ; } if ( isset ( $ this -> cachedMethods [ $ methodAlias ] ) ) { continue ; } $ this -> cachedMethods [ $ methodAlias ] = $ method ; } if ( isset ( $ this -> cachedMethods [ $ methodName ] ) ) { continue ; } $ this -> cachedMethods [ $ methodName ] = $ method ; } return $ this -> cachedMethods ; } 
public function getMethods ( ? int $ filter = null ) : array { if ( $ filter === null ) { return array_values ( $ this -> getMethodsIndexedByName ( ) ) ; } return array_values ( array_filter ( $ this -> getMethodsIndexedByName ( ) , static function ( ReflectionMethod $ method ) use ( $ filter ) : bool { return ( bool ) ( $ filter & $ method -> getModifiers ( ) ) ; } ) ) ; } 
public function getImmediateMethods ( ? int $ filter = null ) : array { $ methods = array_map ( function ( ClassMethod $ methodNode ) : ReflectionMethod { return ReflectionMethod :: createFromNode ( $ this -> reflector , $ methodNode , $ this -> declaringNamespace , $ this , $ this ) ; } , $ this -> node -> getMethods ( ) ) ; $ methodsByName = [ ] ; foreach ( $ methods as $ method ) { if ( $ filter !== null && ! ( $ filter & $ method -> getModifiers ( ) ) ) { continue ; } $ methodsByName [ $ method -> getName ( ) ] = $ method ; } return $ methodsByName ; } 
public function getMethod ( string $ methodName ) : ReflectionMethod { $ methods = $ this -> getMethodsIndexedByName ( ) ; if ( ! isset ( $ methods [ $ methodName ] ) ) { throw new OutOfBoundsException ( 'Could not find method: ' . $ methodName ) ; } return $ methods [ $ methodName ] ; } 
public function hasMethod ( string $ methodName ) : bool { try { $ this -> getMethod ( $ methodName ) ; return true ; } catch ( OutOfBoundsException $ exception ) { return false ; } } 
public function getConstant ( string $ name ) { $ reflectionConstant = $ this -> getReflectionConstant ( $ name ) ; if ( ! $ reflectionConstant ) { return null ; } return $ reflectionConstant -> getValue ( ) ; } 
public function getImmediateReflectionConstants ( ) : array { if ( $ this -> cachedReflectionConstants !== null ) { return $ this -> cachedReflectionConstants ; } $ constants = array_merge ( [ ] , ... array_map ( function ( ConstNode $ constNode ) : array { $ constants = [ ] ; foreach ( $ constNode -> consts as $ constantPositionInNode => $ constantNode ) { $ constants [ ] = ReflectionClassConstant :: createFromNode ( $ this -> reflector , $ constNode , $ constantPositionInNode , $ this ) ; } return $ constants ; } , array_filter ( $ this -> node -> stmts , static function ( Node \ Stmt $ stmt ) : bool { return $ stmt instanceof ConstNode ; } ) ) ) ; return $ this -> cachedReflectionConstants = array_combine ( array_map ( static function ( ReflectionClassConstant $ constant ) : string { return $ constant -> getName ( ) ; } , $ constants ) , $ constants ) ; } 
public function getReflectionConstants ( ) : array { 
public function getConstructor ( ) : ReflectionMethod { $ constructors = array_filter ( $ this -> getMethods ( ) , static function ( ReflectionMethod $ method ) : bool { return $ method -> isConstructor ( ) ; } ) ; if ( ! isset ( $ constructors [ 0 ] ) ) { throw new OutOfBoundsException ( 'Could not find method: __construct' ) ; } return $ constructors [ 0 ] ; } 
public function getImmediateProperties ( ? int $ filter = null ) : array { if ( $ this -> cachedImmediateProperties === null ) { $ properties = [ ] ; foreach ( $ this -> node -> stmts as $ stmt ) { if ( ! ( $ stmt instanceof PropertyNode ) ) { continue ; } foreach ( $ stmt -> props as $ propertyPositionInNode => $ propertyNode ) { $ prop = ReflectionProperty :: createFromNode ( $ this -> reflector , $ stmt , $ propertyPositionInNode , $ this -> declaringNamespace , $ this , $ this ) ; $ properties [ $ prop -> getName ( ) ] = $ prop ; } } $ this -> cachedImmediateProperties = $ properties ; } if ( $ filter === null ) { return $ this -> cachedImmediateProperties ; } return array_filter ( $ this -> cachedImmediateProperties , static function ( ReflectionProperty $ property ) use ( $ filter ) : bool { return ( bool ) ( $ filter & $ property -> getModifiers ( ) ) ; } ) ; } 
public function getProperties ( ? int $ filter = null ) : array { if ( $ this -> cachedProperties === null ) { 
public function getProperty ( string $ name ) : ? ReflectionProperty { $ properties = $ this -> getProperties ( ) ; if ( ! isset ( $ properties [ $ name ] ) ) { return null ; } return $ properties [ $ name ] ; } 
public function getParentClass ( ) : ? ReflectionClass { if ( ! ( $ this -> node instanceof ClassNode ) || $ this -> node -> extends === null ) { return null ; } 
public function getParentClassNames ( ) : array { return array_map ( static function ( self $ parentClass ) : string { return $ parentClass -> getName ( ) ; } , array_slice ( array_reverse ( $ this -> getInheritanceClassHierarchy ( ) ) , 1 ) ) ; } 
public function getModifiers ( ) : int { $ val = 0 ; $ val += $ this -> isAbstract ( ) ? CoreReflectionClass :: IS_EXPLICIT_ABSTRACT : 0 ; $ val += $ this -> isFinal ( ) ? CoreReflectionClass :: IS_FINAL : 0 ; return $ val ; } 
public function getTraits ( ) : array { return array_map ( function ( Node \ Name $ importedTrait ) : ReflectionClass { return $ this -> reflectClassForNamedNode ( $ importedTrait ) ; } , array_merge ( [ ] , ... array_map ( static function ( TraitUse $ traitUse ) : array { return $ traitUse -> traits ; } , array_filter ( $ this -> node -> stmts , static function ( Node $ node ) : bool { return $ node instanceof TraitUse ; } ) ) ) ) ; } 
private function reflectClassForNamedNode ( Node \ Name $ node ) : self { 
public function getTraitAliases ( ) : array { $ traitUsages = array_filter ( $ this -> node -> stmts , static function ( Node $ node ) : bool { return $ node instanceof TraitUse ; } ) ; $ resolvedAliases = [ ] ; foreach ( $ traitUsages as $ traitUsage ) { $ traitNames = $ traitUsage -> traits ; $ adaptations = $ traitUsage -> adaptations ; foreach ( $ adaptations as $ adaptation ) { $ usedTrait = $ adaptation -> trait ; if ( $ usedTrait === null ) { $ usedTrait = $ traitNames [ 0 ] ; } if ( ! ( $ adaptation instanceof Node \ Stmt \ TraitUseAdaptation \ Alias ) ) { continue ; } if ( ! $ adaptation -> newName ) { continue ; } $ resolvedAliases [ $ adaptation -> newName -> name ] = sprintf ( '%s::%s' , $ usedTrait -> toString ( ) , $ adaptation -> method -> toString ( ) ) ; } } return $ resolvedAliases ; } 
public function isInstance ( $ object ) : bool { if ( ! is_object ( $ object ) ) { throw NotAnObject :: fromNonObject ( $ object ) ; } $ className = $ this -> getName ( ) ; 
public function isSubclassOf ( string $ className ) : bool { return in_array ( ltrim ( $ className , '\\' ) , array_map ( static function ( self $ reflectionClass ) : string { return $ reflectionClass -> getName ( ) ; } , array_slice ( array_reverse ( $ this -> getInheritanceClassHierarchy ( ) ) , 1 ) ) , true ) ; } 
public function implementsInterface ( string $ interfaceName ) : bool { return in_array ( ltrim ( $ interfaceName , '\\' ) , $ this -> getInterfaceNames ( ) , true ) ; } 
public function isInstantiable ( ) : bool { 
public function isCloneable ( ) : bool { if ( ! $ this -> isInstantiable ( ) ) { return false ; } if ( ! $ this -> hasMethod ( '__clone' ) ) { return true ; } return $ this -> getMethod ( '__clone' ) -> isPublic ( ) ; } 
private function getInterfacesHierarchy ( ) : array { if ( ! $ this -> isInterface ( ) ) { throw NotAnInterfaceReflection :: fromReflectionClass ( $ this ) ; } $ node = $ this -> node ; return array_merge ( [ $ this -> getName ( ) => $ this ] , ... array_map ( function ( Node \ Name $ interfaceName ) : array { return $ this -> reflectClassForNamedNode ( $ interfaceName ) -> getInterfacesHierarchy ( ) ; } , $ node -> extends ) ) ; } 
public function getStaticPropertyValue ( string $ propertyName ) { $ property = $ this -> getProperty ( $ propertyName ) ; if ( ! $ property || ! $ property -> isStatic ( ) ) { throw PropertyDoesNotExist :: fromName ( $ propertyName ) ; } return $ property -> getValue ( ) ; } 
public function setStaticPropertyValue ( string $ propertyName , $ value ) : void { $ property = $ this -> getProperty ( $ propertyName ) ; if ( ! $ property || ! $ property -> isStatic ( ) ) { throw PropertyDoesNotExist :: fromName ( $ propertyName ) ; } $ property -> setValue ( $ value ) ; } 
public function setFinal ( bool $ isFinal ) : void { if ( ! $ this -> node instanceof ClassNode ) { throw NotAClassReflection :: fromReflectionClass ( $ this ) ; } if ( $ isFinal === true ) { $ this -> node -> flags |= ClassNode :: MODIFIER_FINAL ; return ; } $ this -> node -> flags &= ~ ClassNode :: MODIFIER_FINAL ; } 
public function removeMethod ( string $ methodName ) : bool { $ lowerName = strtolower ( $ methodName ) ; foreach ( $ this -> node -> stmts as $ key => $ stmt ) { if ( $ stmt instanceof ClassMethod && $ lowerName === $ stmt -> name -> toLowerString ( ) ) { unset ( $ this -> node -> stmts [ $ key ] , $ this -> cachedMethods ) ; return true ; } } return false ; } 
public function addMethod ( string $ methodName ) : void { $ this -> node -> stmts [ ] = new ClassMethod ( $ methodName ) ; unset ( $ this -> cachedMethods ) ; } 
public function addProperty ( string $ propertyName , int $ visibility = CoreReflectionProperty :: IS_PUBLIC , bool $ static = false ) : void { $ type = 0 ; switch ( $ visibility ) { case CoreReflectionProperty :: IS_PRIVATE : $ type |= ClassNode :: MODIFIER_PRIVATE ; break ; case CoreReflectionProperty :: IS_PROTECTED : $ type |= ClassNode :: MODIFIER_PROTECTED ; break ; default : $ type |= ClassNode :: MODIFIER_PUBLIC ; break ; } if ( $ static ) { $ type |= ClassNode :: MODIFIER_STATIC ; } $ this -> node -> stmts [ ] = new PropertyNode ( $ type , [ new Node \ Stmt \ PropertyProperty ( $ propertyName ) ] ) ; $ this -> cachedProperties = null ; $ this -> cachedImmediateProperties = null ; } 
public function removeProperty ( string $ propertyName ) : bool { $ lowerName = strtolower ( $ propertyName ) ; foreach ( $ this -> node -> stmts as $ key => $ stmt ) { if ( ! ( $ stmt instanceof PropertyNode ) ) { continue ; } $ propertyNames = array_map ( static function ( Node \ Stmt \ PropertyProperty $ propertyProperty ) : string { return $ propertyProperty -> name -> toLowerString ( ) ; } , $ stmt -> props ) ; if ( in_array ( $ lowerName , $ propertyNames , true ) ) { $ this -> cachedProperties = null ; $ this -> cachedImmediateProperties = null ; unset ( $ this -> node -> stmts [ $ key ] ) ; return true ; } } return false ; } 
public function isMatchingReflector ( Reflection $ reflector ) : bool { if ( $ this -> name === self :: IDENTIFIER_CLASS ) { return $ reflector instanceof ReflectionClass ; } if ( $ this -> name === self :: IDENTIFIER_FUNCTION ) { return $ reflector instanceof ReflectionFunction ; } return false ; } 
public function parse ( string $ code , ? ErrorHandler $ errorHandler = null ) : ? array { 
public function locateIdentifier ( Reflector $ reflector , Identifier $ identifier ) : ? Reflection { foreach ( $ this -> sourceLocators as $ sourceLocator ) { $ located = $ sourceLocator -> locateIdentifier ( $ reflector , $ identifier ) ; if ( $ located ) { return $ located ; } } return null ; } 
public function locateIdentifiersByType ( Reflector $ reflector , IdentifierType $ identifierType ) : array { return array_merge ( [ ] , ... array_map ( static function ( SourceLocator $ sourceLocator ) use ( $ reflector , $ identifierType ) { return $ sourceLocator -> locateIdentifiersByType ( $ reflector , $ identifierType ) ; } , $ this -> sourceLocators ) ) ; } 
public function generateClassStub ( CoreReflectionClass $ classReflection ) : ? string { if ( $ classReflection -> isUserDefined ( ) ) { return null ; } $ stub = $ this -> getStub ( $ classReflection -> getExtensionName ( ) , $ this -> getClassNodeVisitor ( $ classReflection ) ) ; if ( $ classReflection -> getName ( ) === Traversable :: class ) { 
public function generateFunctionStub ( CoreReflectionFunction $ functionReflection ) : ? string { if ( $ functionReflection -> isUserDefined ( ) ) { return null ; } return $ this -> getStub ( $ functionReflection -> getExtensionName ( ) , $ this -> getFunctionNodeVisitor ( $ functionReflection ) ) ; } 
public static function export ( $ instance = null ) : string { if ( $ instance === null ) { throw new InvalidArgumentException ( 'Class instance must be provided' ) ; } return self :: createFromInstance ( $ instance ) -> __toString ( ) ; } 
public static function createFromInstance ( $ object ) : ReflectionClass { if ( ! is_object ( $ object ) ) { throw new InvalidArgumentException ( 'Can only create from an instance of an object' ) ; } $ className = get_class ( $ object ) ; if ( strpos ( $ className , ReflectionClass :: ANONYMOUS_CLASS_NAME_PREFIX ) === 0 ) { $ reflector = new ClassReflector ( new AnonymousClassObjectSourceLocator ( $ object , ( new BetterReflection ( ) ) -> phpParser ( ) ) ) ; } else { $ reflector = ( new BetterReflection ( ) ) -> classReflector ( ) ; } return new self ( $ reflector , $ reflector -> reflect ( $ className ) , $ object ) ; } 
private function getRuntimeProperties ( ? int $ filter = null ) : array { if ( ! $ this -> reflectionClass -> isInstance ( $ this -> object ) ) { throw new InvalidArgumentException ( 'Cannot reflect runtime properties of a separate class' ) ; } 
private function createPropertyNodeFromReflection ( CoreReflectionProperty $ property , $ instance ) : PropertyNode { $ builder = new PropertyNodeBuilder ( $ property -> getName ( ) ) ; $ builder -> setDefault ( $ property -> getValue ( $ instance ) ) ; if ( $ property -> isPublic ( ) ) { $ builder -> makePublic ( ) ; } return $ builder -> getNode ( ) ; } 
public function getProperties ( ? int $ filter = null ) : array { return array_merge ( $ this -> reflectionClass -> getProperties ( $ filter ) , $ this -> getRuntimeProperties ( $ filter ) ) ; } 
public function getImmediateProperties ( ? int $ filter = null ) : array { return array_merge ( $ this -> reflectionClass -> getImmediateProperties ( $ filter ) , $ this -> getRuntimeProperties ( $ filter ) ) ; } 
public function getProperty ( string $ name ) : ? ReflectionProperty { $ runtimeProperties = $ this -> getRuntimeProperties ( ) ; if ( isset ( $ runtimeProperties [ $ name ] ) ) { return $ runtimeProperties [ $ name ] ; } return $ this -> reflectionClass -> getProperty ( $ name ) ; } 
public function hasProperty ( string $ name ) : bool { $ runtimeProperties = $ this -> getRuntimeProperties ( ) ; return isset ( $ runtimeProperties [ $ name ] ) || $ this -> reflectionClass -> hasProperty ( $ name ) ; } 
public function setStaticPropertyValue ( string $ propertyName , $ value ) : void { $ this -> reflectionClass -> setStaticPropertyValue ( $ propertyName , $ value ) ; } 
public function addProperty ( string $ methodName , int $ visibility = CoreReflectionProperty :: IS_PUBLIC , bool $ static = false ) : void { $ this -> reflectionClass -> addProperty ( $ methodName , $ visibility , $ static ) ; } 
public function getMethods ( $ filter = null ) { $ methods = $ this -> betterReflectionObject -> getMethods ( ) ; $ wrappedMethods = [ ] ; foreach ( $ methods as $ key => $ method ) { $ wrappedMethods [ $ key ] = new ReflectionMethod ( $ method ) ; } return $ wrappedMethods ; } 
public function getProperty ( $ name ) { $ property = $ this -> betterReflectionObject -> getProperty ( $ name ) ; if ( $ property === null ) { throw new CoreReflectionException ( sprintf ( 'Property "%s" does not exist' , $ name ) ) ; } return new ReflectionProperty ( $ property ) ; } 
public function getProperties ( $ filter = null ) { $ properties = $ this -> betterReflectionObject -> getProperties ( ) ; $ wrappedProperties = [ ] ; foreach ( $ properties as $ key => $ property ) { $ wrappedProperties [ $ key ] = new ReflectionProperty ( $ property ) ; } return $ wrappedProperties ; } 
public function getInterfaces ( ) { $ interfaces = $ this -> betterReflectionObject -> getInterfaces ( ) ; $ wrappedInterfaces = [ ] ; foreach ( $ interfaces as $ key => $ interface ) { $ wrappedInterfaces [ $ key ] = new ReflectionClass ( $ interface ) ; } return $ wrappedInterfaces ; } 
public function getTraits ( ) { $ traits = $ this -> betterReflectionObject -> getTraits ( ) ; $ wrappedTraits = [ ] ; foreach ( $ traits as $ key => $ trait ) { $ wrappedTraits [ $ key ] = new ReflectionClass ( $ trait ) ; } return $ wrappedTraits ; } 
public function getParentClass ( ) { $ parentClass = $ this -> betterReflectionObject -> getParentClass ( ) ; if ( $ parentClass === null ) { return false ; } return new ReflectionClass ( $ parentClass ) ; } 
public function isSubclassOf ( $ class ) { $ realParentClassNames = $ this -> betterReflectionObject -> getParentClassNames ( ) ; $ parentClassNames = array_combine ( array_map ( static function ( string $ parentClassName ) : string { return strtolower ( $ parentClassName ) ; } , $ realParentClassNames ) , $ realParentClassNames ) ; $ realParentClassName = $ parentClassNames [ strtolower ( $ class ) ] ?? $ class ; return $ this -> betterReflectionObject -> isSubclassOf ( $ realParentClassName ) ; } 
protected function populateFunctionAbstract ( Reflector $ reflector , Node \ FunctionLike $ node , LocatedSource $ locatedSource , ? NamespaceNode $ declaringNamespace = null ) : void { $ this -> reflector = $ reflector ; $ this -> node = $ node ; $ this -> locatedSource = $ locatedSource ; $ this -> declaringNamespace = $ declaringNamespace ; $ this -> setNodeOptionalFlag ( ) ; } 
private function setNodeOptionalFlag ( ) : void { $ overallOptionalFlag = true ; $ lastParamIndex = count ( $ this -> node -> params ) - 1 ; for ( $ i = $ lastParamIndex ; $ i >= 0 ; $ i -- ) { $ hasDefault = ( $ this -> node -> params [ $ i ] -> default !== null ) ; 
public function getName ( ) : string { if ( ! $ this -> inNamespace ( ) ) { return $ this -> getShortName ( ) ; } return $ this -> getNamespaceName ( ) . '\\' . $ this -> getShortName ( ) ; } 
public function getShortName ( ) : string { if ( $ this -> node instanceof Node \ Expr \ Closure ) { return self :: CLOSURE_NAME ; } return $ this -> node -> name -> name ; } 
public function getNumberOfRequiredParameters ( ) : int { return count ( array_filter ( $ this -> getParameters ( ) , static function ( ReflectionParameter $ p ) : bool { return ! $ p -> isOptional ( ) ; } ) ) ; } 
public function getParameters ( ) : array { $ parameters = [ ] ; foreach ( $ this -> node -> params as $ paramIndex => $ paramNode ) { $ parameters [ ] = ReflectionParameter :: createFromNode ( $ this -> reflector , $ paramNode , $ this -> declaringNamespace , $ this , $ paramIndex ) ; } return $ parameters ; } 
public function getParameter ( string $ parameterName ) : ? ReflectionParameter { foreach ( $ this -> getParameters ( ) as $ parameter ) { if ( $ parameter -> getName ( ) === $ parameterName ) { return $ parameter ; } } return null ; } 
public function isVariadic ( ) : bool { $ parameters = $ this -> getParameters ( ) ; foreach ( $ parameters as $ parameter ) { if ( $ parameter -> isVariadic ( ) ) { return true ; } } return false ; } 
private function nodeIsOrContainsYield ( Node $ node ) : bool { if ( $ node instanceof YieldNode ) { return true ; } foreach ( $ node -> getSubNodeNames ( ) as $ nodeName ) { $ nodeProperty = $ node -> $ nodeName ; if ( $ nodeProperty instanceof Node && $ this -> nodeIsOrContainsYield ( $ nodeProperty ) ) { return true ; } if ( ! is_array ( $ nodeProperty ) ) { continue ; } foreach ( $ nodeProperty as $ nodePropertyArrayItem ) { if ( $ nodePropertyArrayItem instanceof Node && $ this -> nodeIsOrContainsYield ( $ nodePropertyArrayItem ) ) { return true ; } } } return false ; } 
public function isGenerator ( ) : bool { if ( $ this -> node === null ) { return false ; } return $ this -> nodeIsOrContainsYield ( $ this -> node ) ; } 
public function getReturnType ( ) : ? ReflectionType { $ returnType = $ this -> node -> getReturnType ( ) ; if ( $ returnType === null ) { return null ; } if ( $ returnType instanceof NullableType ) { return ReflectionType :: createFromTypeAndReflector ( ( string ) $ returnType -> type , true , $ this -> reflector ) ; } return ReflectionType :: createFromTypeAndReflector ( ( string ) $ returnType , false , $ this -> reflector ) ; } 
public function setReturnType ( string $ newReturnType ) : void { $ this -> node -> returnType = new Node \ Name ( $ newReturnType ) ; } 
public function getBodyCode ( ? PrettyPrinterAbstract $ printer = null ) : string { if ( $ printer === null ) { $ printer = new StandardPrettyPrinter ( ) ; } return $ printer -> prettyPrint ( $ this -> getBodyAst ( ) ) ; } 
public function setBodyFromClosure ( Closure $ newBody ) : void { $ closureReflection = ( new ClosureSourceLocator ( $ newBody , $ this -> loadStaticParser ( ) ) ) -> locateIdentifier ( $ this -> reflector , new Identifier ( self :: CLOSURE_NAME , new IdentifierType ( IdentifierType :: IDENTIFIER_FUNCTION ) ) ) ; $ functionNode = $ closureReflection -> getNode ( ) ; $ this -> node -> stmts = $ functionNode -> stmts ; } 
public function setBodyFromString ( string $ newBody ) : void { $ this -> node -> stmts = $ this -> loadStaticParser ( ) -> parse ( '<?php ' . $ newBody ) ; } 
public function setBodyFromAst ( array $ nodes ) : void { 
public function addParameter ( string $ parameterName ) : void { $ this -> node -> params [ ] = new ParamNode ( new Node \ Expr \ Variable ( $ parameterName ) ) ; } 
public function removeParameter ( string $ parameterName ) : void { $ lowerName = strtolower ( $ parameterName ) ; foreach ( $ this -> node -> params as $ key => $ paramNode ) { if ( $ paramNode -> var instanceof Node \ Expr \ Error ) { throw new LogicException ( 'PhpParser left an "Error" node in the parameters AST, this should NOT happen' ) ; } if ( ! is_string ( $ paramNode -> var -> name ) || strtolower ( $ paramNode -> var -> name ) !== $ lowerName ) { continue ; } unset ( $ this -> node -> params [ $ key ] ) ; } } 
public function getReturnStatementsAst ( ) : array { $ visitor = new ReturnNodeVisitor ( ) ; $ traverser = new NodeTraverser ( ) ; $ traverser -> addVisitor ( $ visitor ) ; $ traverser -> traverse ( $ this -> node -> getStmts ( ) ) ; return $ visitor -> getReturnNodes ( ) ; } 
public function getValue ( $ object = null ) { if ( ! $ this -> isAccessible ( ) ) { throw new CoreReflectionException ( 'Property not accessible' ) ; } try { return $ this -> betterReflectionProperty -> getValue ( $ object ) ; } catch ( NoObjectProvided | NotAnObject $ e ) { return null ; } catch ( Throwable $ e ) { throw new CoreReflectionException ( $ e -> getMessage ( ) , 0 , $ e ) ; } } 
public function setValue ( $ object , $ value = null ) { if ( ! $ this -> isAccessible ( ) ) { throw new CoreReflectionException ( 'Property not accessible' ) ; } try { $ this -> betterReflectionProperty -> setValue ( $ object , $ value ) ; } catch ( NoObjectProvided | NotAnObject $ e ) { return null ; } catch ( Throwable $ e ) { throw new CoreReflectionException ( $ e -> getMessage ( ) , 0 , $ e ) ; } } 
public function locateIdentifier ( Reflector $ reflector , Identifier $ identifier ) : ? Reflection { foreach ( $ this -> mapping -> resolvePossibleFilePaths ( $ identifier ) as $ file ) { if ( ! file_exists ( $ file ) ) { continue ; } try { return $ this -> astLocator -> findReflection ( $ reflector , new LocatedSource ( file_get_contents ( $ file ) , $ file ) , $ identifier ) ; } catch ( IdentifierNotFound $ exception ) { 
public function locateIdentifiersByType ( Reflector $ reflector , IdentifierType $ identifierType ) : array { return ( new DirectoriesSourceLocator ( $ this -> mapping -> directories ( ) , $ this -> astLocator ) ) -> locateIdentifiersByType ( $ reflector , $ identifierType ) ; } 
private function prefixWithInstallationPath ( array $ paths , string $ trimmedInstallationPath ) : array { return array_map ( function ( array $ paths ) use ( $ trimmedInstallationPath ) : array { return $ this -> prefixPaths ( $ paths , $ trimmedInstallationPath ) ; } , $ paths ) ; } 
public function generateClassStub ( CoreReflectionClass $ classReflection ) : ? string { foreach ( $ this -> sourceStubbers as $ sourceStubber ) { $ stub = $ sourceStubber -> generateClassStub ( $ classReflection ) ; if ( $ stub !== null ) { return $ stub ; } } return null ; } 
public function generateFunctionStub ( CoreReflectionFunction $ functionReflection ) : ? string { foreach ( $ this -> sourceStubbers as $ sourceStubber ) { $ stub = $ sourceStubber -> generateFunctionStub ( $ functionReflection ) ; if ( $ stub !== null ) { return $ stub ; } } return null ; } 
public function locateIdentifier ( Reflector $ reflector , Identifier $ identifier ) : ? Reflection { return $ this -> getReflectionFunction ( $ reflector , $ identifier -> getType ( ) ) ; } 
public function locateIdentifiersByType ( Reflector $ reflector , IdentifierType $ identifierType ) : array { return array_filter ( [ $ this -> getReflectionFunction ( $ reflector , $ identifierType ) ] ) ; } 
public static function createFromNode ( Reflector $ reflector , ClassConst $ node , int $ positionInNode , ReflectionClass $ owner ) : self { $ ref = new self ( ) ; $ ref -> node = $ node ; $ ref -> positionInNode = $ positionInNode ; $ ref -> owner = $ owner ; $ ref -> reflector = $ reflector ; return $ ref ; } 
public function getValue ( ) { if ( $ this -> valueWasCached !== false ) { return $ this -> value ; } $ this -> value = ( new CompileNodeToValue ( ) ) -> __invoke ( $ this -> node -> consts [ $ this -> positionInNode ] -> value , new CompilerContext ( $ this -> reflector , $ this -> getDeclaringClass ( ) ) ) ; $ this -> valueWasCached = true ; return $ this -> value ; } 
public function getModifiers ( ) : int { $ val = 0 ; $ val += $ this -> isPublic ( ) ? ReflectionProperty :: IS_PUBLIC : 0 ; $ val += $ this -> isProtected ( ) ? ReflectionProperty :: IS_PROTECTED : 0 ; $ val += $ this -> isPrivate ( ) ? ReflectionProperty :: IS_PRIVATE : 0 ; return $ val ; } 
public function generateConstantAnnotations ( string $ className , string $ constantName ) : array { $ resource = $ this -> classes [ $ className ] [ 'constants' ] [ $ constantName ] [ 'resource' ] ; $ annotations = $ this -> formatDoc ( ( string ) $ resource -> get ( 'rdfs:comment' ) , true ) ; $ annotations [ 0 ] = sprintf ( '@var string %s' , $ annotations [ 0 ] ) ; return $ annotations ; } 
public function generateFieldAnnotations ( string $ className , string $ fieldName ) : array { $ field = $ this -> classes [ $ className ] [ 'fields' ] [ $ fieldName ] ; $ comment = $ field [ 'resource' ] ? $ field [ 'resource' ] -> get ( 'rdfs:comment' ) : '' ; $ annotations = $ this -> formatDoc ( ( string ) $ comment , true ) ; $ annotations [ 0 ] = sprintf ( '@var %s %s' , $ this -> toPhpDocType ( $ field ) , $ annotations [ 0 ] ) ; $ annotations [ ] = '' ; return $ annotations ; } 
public function generateGetterAnnotations ( string $ className , string $ fieldName ) : array { if ( ! $ this -> isDocUseful ( $ className , $ fieldName ) ) { return [ ] ; } return [ sprintf ( '@return %s' , $ this -> toPhpDocType ( $ this -> classes [ $ className ] [ 'fields' ] [ $ fieldName ] ) ) ] ; } 
public function generateSetterAnnotations ( string $ className , string $ fieldName ) : array { if ( ! $ this -> isDocUseful ( $ className , $ fieldName ) ) { return [ ] ; } $ field = $ this -> classes [ $ className ] [ 'fields' ] [ $ fieldName ] ; return [ sprintf ( '@param %s $%s' , $ this -> toPhpDocType ( $ this -> classes [ $ className ] [ 'fields' ] [ $ fieldName ] ) , $ field [ 'name' ] ) ] ; } 
public function generateRemoverAnnotations ( string $ className , string $ fieldName ) : array { if ( ! $ this -> isDocUseful ( $ className , $ fieldName , true ) ) { return [ ] ; } return [ sprintf ( '@param %s $%s' , $ this -> toPhpType ( $ this -> classes [ $ className ] [ 'fields' ] [ $ fieldName ] , true ) , Inflector :: singularize ( $ fieldName ) ) ] ; } 
private function generateDoc ( string $ className , bool $ interface = false ) : array { $ resource = $ this -> classes [ $ className ] [ 'resource' ] ; $ annotations = [ ] ; if ( ! $ interface && isset ( $ this -> classes [ $ className ] [ 'interfaceName' ] ) ) { $ annotations [ ] = '{@inheritdoc}' ; $ annotations [ ] = '' ; } else { $ annotations = $ this -> formatDoc ( ( string ) $ resource -> get ( 'rdfs:comment' ) ) ; $ annotations [ ] = '' ; $ annotations [ ] = sprintf ( '@see %s %s' , $ resource -> getUri ( ) , 'Documentation on Schema.org' ) ; } if ( $ this -> config [ 'author' ] ) { $ annotations [ ] = sprintf ( '@author %s' , $ this -> config [ 'author' ] ) ; } return $ annotations ; } 
private function formatDoc ( string $ doc , bool $ indent = false ) : array { $ doc = explode ( "\n" , $ this -> htmlToMarkdown -> convert ( $ doc ) ) ; if ( $ indent ) { $ count = count ( $ doc ) ; for ( $ i = 1 ; $ i < $ count ; ++ $ i ) { $ doc [ $ i ] = self :: INDENT . $ doc [ $ i ] ; } } return $ doc ; } 
public function extract ( ) : array { $ properties = [ ] ; foreach ( $ this -> graphs as $ graph ) { foreach ( $ graph -> allOfType ( 'rdf:Property' ) as $ property ) { $ properties [ $ property -> localName ( ) ] = $ this -> extractForProperty ( $ property ) ; } } return $ properties ; } 
private function extractForProperty ( \ EasyRdf_Resource $ property ) : string { $ localName = $ property -> localName ( ) ; $ fromGoodRelations = $ this -> goodRelationsBridge -> extractCardinality ( $ localName ) ; if ( false !== $ fromGoodRelations ) { return $ fromGoodRelations ; } $ comment = $ property -> get ( 'rdfs:comment' ) -> getValue ( ) ; if ( 
public function generate ( array $ config ) : void { $ baseClass = [ 'constants' => [ ] , 'fields' => [ ] , 'uses' => [ ] , 'hasConstructor' => false , 'parentHasConstructor' => false , 'hasChild' => false , 'abstract' => false , ] ; $ typesToGenerate = [ ] ; if ( ! $ config [ 'types' ] ) { foreach ( $ this -> graphs as $ graph ) { $ typesToGenerate = $ graph -> allOfType ( 'rdfs:Class' ) ; } } else { foreach ( $ config [ 'types' ] as $ typeName => $ typeConfig ) { $ resource = null ; foreach ( $ this -> graphs as $ graph ) { $ resources = $ graph -> resources ( ) ; if ( isset ( $ resources [ $ typeConfig [ 'vocabularyNamespace' ] . $ typeName ] ) ) { $ resource = $ graph -> resource ( $ typeConfig [ 'vocabularyNamespace' ] . $ typeName , 'rdfs:Class' ) ; break ; } } if ( $ resource ) { $ typesToGenerate [ $ typeName ] = $ resource ; } elseif ( empty ( $ graph ) ) { $ this -> logger -> warning ( 'Type "{typeName}" cannot be found and there is no graph to generate entity.' ) ; } else { $ this -> logger -> warning ( 'Type "{typeName}" cannot be found. Using "{guessFrom}" type to generate entity.' , [ 'typeName' => $ typeName , 'guessFrom' => $ typeConfig [ 'guessFrom' ] ] ) ; $ type = $ graph -> resource ( $ typeConfig [ 'vocabularyNamespace' ] . $ typeConfig [ 'guessFrom' ] , 'rdfs:Class' ) ; $ typesToGenerate [ $ typeName ] = $ type ; } } } $ classes = [ ] ; $ propertiesMap = $ this -> createPropertiesMap ( $ typesToGenerate ) ; foreach ( $ typesToGenerate as $ typeName => $ type ) { $ typeName = is_string ( $ typeName ) ? $ typeName : $ type -> localName ( ) ; $ typeConfig = $ config [ 'types' ] [ $ typeName ] ?? null ; $ class = $ baseClass ; $ comment = $ type -> get ( 'rdfs:comment' ) ; $ class [ 'name' ] = $ typeName ; $ class [ 'label' ] = $ comment ? $ comment -> getValue ( ) : '' ; $ class [ 'resource' ] = $ type ; $ class [ 'config' ] = $ typeConfig ; $ class [ 'isEnum' ] = $ this -> isEnum ( $ type ) ; if ( $ class [ 'isEnum' ] ) { $ class [ 'namespace' ] = $ typeConfig [ 'namespace' ] ?? $ config [ 'namespaces' ] [ 'enum' ] ; $ class [ 'parent' ] = 'Enum' ; $ class [ 'uses' ] [ ] = Enum :: class ; 
private function isEnum ( \ EasyRdf_Resource $ type ) : bool { $ subClassOf = $ type -> get ( 'rdfs:subClassOf' ) ; return $ subClassOf && self :: SCHEMA_ORG_ENUMERATION === $ subClassOf -> getUri ( ) ; } 
private function getParentClasses ( \ EasyRdf_Resource $ resource , array $ parentClasses = [ ] ) { if ( [ ] === $ parentClasses ) { return $ this -> getParentClasses ( $ resource , [ $ resource -> getUri ( ) ] ) ; } $ subclasses = $ resource -> all ( 'rdfs:subClassOf' ) ; if ( empty ( $ subclasses ) ) { return $ parentClasses ; } $ parentClass = $ subclasses [ 0 ] ; $ parentClasses [ ] = $ parentClass -> getUri ( ) ; foreach ( $ this -> graphs as $ graph ) { foreach ( $ graph -> allOfType ( 'rdfs:Class' ) as $ type ) { if ( $ type -> getUri ( ) === $ parentClass -> getUri ( ) ) { $ parentClasses = $ this -> getParentClasses ( $ type , $ parentClasses ) ; break 2 ; } } } return $ parentClasses ; } 
private function createPropertiesMap ( array $ types ) { $ typesAsString = [ ] ; $ map = [ ] ; foreach ( $ types as $ type ) { 
private function generateField ( array $ config , array $ class , \ EasyRdf_Resource $ type , $ typeName , $ propertyName , \ EasyRdf_Resource $ property = null ) { $ typeConfig = $ config [ 'types' ] [ $ typeName ] ?? null ; $ typesDefined = ! empty ( $ config [ 'types' ] ) ; 
private function namespaceToDir ( array $ config , string $ namespace ) : string { if ( null !== ( $ prefix = $ config [ 'namespaces' ] [ 'prefix' ] ?? null ) && 0 === strpos ( $ namespace , $ prefix ) ) { $ namespace = substr ( $ namespace , strlen ( $ prefix ) ) ; } return sprintf ( '%s/%s/' , $ config [ 'output' ] , strtr ( $ namespace , '\\' , '/' ) ) ; } 
private function fixCs ( array $ files ) : void { $ fileInfos = [ ] ; foreach ( $ files as $ file ) { $ fileInfos [ ] = new \ SplFileInfo ( $ file ) ; } $ fixers = ( new FixerFactory ( ) ) -> registerBuiltInFixers ( ) -> useRuleSet ( new RuleSet ( [ '@Symfony' => true , 'array_syntax' => [ 'syntax' => 'short' ] , 'phpdoc_order' => true , 'declare_strict_types' => true , ] ) ) -> getFixers ( ) ; $ runner = new Runner ( new \ ArrayIterator ( $ fileInfos ) , $ fixers , new NullDiffer ( ) , null , new ErrorsManager ( ) , new Linter ( ) , false , new NullCacheManager ( ) ) ; $ runner -> fix ( ) ; } 
public function exist ( string $ id ) : bool { foreach ( $ this -> relations as $ relation ) { $ result = $ relation -> xpath ( sprintf ( '//*[@rdf:about="%s"]' , $ this -> getPropertyUrl ( $ id ) ) ) ; if ( ! empty ( $ result ) ) { return true ; } } return false ; } 
public function extractCardinality ( string $ id ) { foreach ( $ this -> relations as $ relation ) { $ result = $ relation -> xpath ( sprintf ( '//*[@rdf:about="%s"]/rdfs:label' , $ this -> getPropertyUrl ( $ id ) ) ) ; if ( count ( $ result ) ) { preg_match ( '/\(.\.\..\)/' , $ result [ 0 ] -> asXML ( ) , $ matches ) ; return $ matches [ 0 ] ; } } return false ; } 
private function getPropertyUrl ( string $ id ) : string { $ propertyId = $ this -> datatypePropertiesTable [ $ id ] ?? $ this -> objectPropertiesTable [ $ id ] ?? $ id ; return self :: GOOD_RELATIONS_NAMESPACE . $ propertyId ; } 
protected function configure ( ) : void { if ( file_exists ( 'composer.json' ) && is_file ( 'composer.json' ) && is_readable ( 'composer.json' ) ) { $ composer = json_decode ( file_get_contents ( 'composer.json' ) , true ) ; foreach ( $ composer [ 'autoload' ] [ 'psr-4' ] ?? [ ] as $ prefix => $ output ) { if ( '' === $ prefix ) { continue ; } $ this -> namespacePrefix = $ prefix ; $ this -> defaultOutput = $ output ; break ; } } $ this -> setName ( 'generate-types' ) -> setDescription ( 'Generate types' ) -> addArgument ( 'output' , $ this -> defaultOutput ? InputArgument :: OPTIONAL : InputArgument :: REQUIRED , 'The output directory' , $ this -> defaultOutput ) -> addArgument ( 'config' , InputArgument :: OPTIONAL , 'The config file to use (default to "schema.yaml" in the current directory, will generate all types if no config file exists)' ) ; } 
protected function execute ( InputInterface $ input , OutputInterface $ output ) : void { $ defaultOutput = $ this -> defaultOutput ? realpath ( $ this -> defaultOutput ) : null ; $ outputDir = $ input -> getArgument ( 'output' ) ; $ configArgument = $ input -> getArgument ( 'config' ) ; if ( $ dir = realpath ( $ input -> getArgument ( 'output' ) ) ) { if ( ! is_dir ( $ dir ) ) { if ( ! $ this -> defaultOutput ) { throw new \ InvalidArgumentException ( sprintf ( 'The file "%s" is not a directory.' , $ dir ) ) ; } $ dir = $ defaultOutput ; $ configArgument = $ outputDir ; } if ( ! is_writable ( $ dir ) ) { throw new \ InvalidArgumentException ( sprintf ( 'The "%s" directory is not writable.' , $ dir ) ) ; } $ outputDir = $ dir ; } elseif ( ! @ mkdir ( $ outputDir , 0777 , true ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Cannot create the "%s" directory. Check that the parent directory is writable.' , $ outputDir ) ) ; } else { $ outputDir = realpath ( $ outputDir ) ; } if ( $ configArgument ) { if ( ! file_exists ( $ configArgument ) ) { throw new \ InvalidArgumentException ( sprintf ( 'The file "%s" doesn\'t exist.' , $ configArgument ) ) ; } if ( ! is_file ( $ configArgument ) ) { throw new \ InvalidArgumentException ( sprintf ( '"%s" isn\'t a file.' , $ configArgument ) ) ; } if ( ! is_readable ( $ configArgument ) ) { throw new \ InvalidArgumentException ( sprintf ( 'The file "%s" isn\'t readable.' , $ configArgument ) ) ; } $ parser = new Parser ( ) ; $ config = $ parser -> parse ( file_get_contents ( $ configArgument ) ) ; unset ( $ parser ) ; } elseif ( is_readable ( self :: DEFAULT_CONFIG_FILE ) ) { $ parser = new Parser ( ) ; $ config = $ parser -> parse ( file_get_contents ( self :: DEFAULT_CONFIG_FILE ) ) ; unset ( $ parser ) ; } else { $ config = [ ] ; } $ processor = new Processor ( ) ; $ configuration = new TypesGeneratorConfiguration ( $ dir === $ defaultOutput ? $ this -> namespacePrefix : null ) ; $ processedConfiguration = $ processor -> processConfiguration ( $ configuration , [ $ config ] ) ; $ processedConfiguration [ 'output' ] = $ outputDir ; if ( ! $ processedConfiguration [ 'output' ] ) { throw new \ RuntimeException ( 'The specified output is invalid' ) ; } $ graphs = [ ] ; foreach ( $ processedConfiguration [ 'rdfa' ] as $ rdfa ) { $ graph = new \ EasyRdf_Graph ( ) ; if ( 'http: 
protected function toPhpType ( array $ field , bool $ adderOrRemover = false ) : string { $ range = $ field [ 'range' ] ; if ( $ field [ 'isEnum' ] ) { if ( $ field [ 'isArray' ] ) { return 'string[]' ; } return 'string' ; } $ data = false ; switch ( $ range ) { case 'Boolean' : $ data = 'bool' ; break ; case 'Date' : case 'DateTime' : case 'Time' : $ data = '\\' . \ DateTimeInterface :: class ; break ; case 'Number' : case 'Float' : $ data = 'float' ; break ; case 'Integer' : $ data = 'integer' ; break ; case 'Text' : case 'URL' : $ data = 'string' ; break ; } if ( false !== $ data ) { if ( $ field [ 'isArray' ] ) { return sprintf ( '%s[]' , $ data ) ; } return $ data ; } if ( isset ( $ this -> classes [ $ field [ 'range' ] ] [ 'interfaceName' ] ) ) { $ range = $ this -> classes [ $ field [ 'range' ] ] [ 'interfaceName' ] ; } if ( $ field [ 'isArray' ] && ! $ adderOrRemover ) { if ( $ this -> config [ 'doctrine' ] [ 'useCollection' ] ) { return sprintf ( 'Collection<%s>' , $ range ) ; } return sprintf ( '%s[]' , $ range ) ; } return $ range ; } 
protected function execute ( InputInterface $ input , OutputInterface $ output ) : void { $ configuration = new TypesGeneratorConfiguration ( ) ; $ dumper = new YamlReferenceDumper ( ) ; $ output -> writeln ( $ dumper -> dump ( $ configuration ) ) ; } 
public function generateFieldAnnotations ( string $ className , string $ fieldName ) : array { $ field = $ this -> classes [ $ className ] [ 'fields' ] [ $ fieldName ] ; if ( $ field [ 'isId' ] ) { return $ this -> generateIdAnnotations ( ) ; } $ annotations = [ ] ; if ( $ field [ 'isEnum' ] ) { $ type = $ field [ 'isArray' ] ? 'simple_array' : 'string' ; } else { switch ( $ field [ 'range' ] ) { case 'Boolean' : $ type = 'boolean' ; break ; case 'Date' : case 'DateTime' : $ type = 'date' ; break ; case 'Time' : $ type = 'time' ; break ; case 'Number' : case 'Float' : $ type = 'float' ; break ; case 'Integer' : $ type = 'integer' ; break ; case 'Text' : case 'URL' : $ type = 'string' ; break ; } } if ( isset ( $ type ) ) { $ annotation = '@MongoDB\Field' ; if ( $ field [ 'isArray' ] ) { $ type = 'collection' ; } $ annotation .= sprintf ( '(type="%s")' , $ type ) ; $ annotations [ ] = $ annotation ; } else { if ( CardinalitiesExtractor :: CARDINALITY_0_1 === $ field [ 'cardinality' ] || CardinalitiesExtractor :: CARDINALITY_1_1 === $ field [ 'cardinality' ] || CardinalitiesExtractor :: CARDINALITY_N_0 === $ field [ 'cardinality' ] || CardinalitiesExtractor :: CARDINALITY_N_1 === $ field [ 'cardinality' ] ) { $ annotations [ ] = sprintf ( '@MongoDB\ReferenceOne(targetDocument="%s", simple=true))' , $ this -> getRelationName ( $ field [ 'range' ] ) ) ; } elseif ( CardinalitiesExtractor :: CARDINALITY_0_N === $ field [ 'cardinality' ] || CardinalitiesExtractor :: CARDINALITY_1_N === $ field [ 'cardinality' ] || CardinalitiesExtractor :: CARDINALITY_N_N === $ field [ 'cardinality' ] ) { $ annotations [ ] = sprintf ( '@MongoDB\ReferenceMany(targetDocument="%s", simple=true)' , $ this -> getRelationName ( $ field [ 'range' ] ) ) ; } } return $ annotations ; } 
public function generateClassAnnotations ( string $ className ) : array { $ resource = $ this -> classes [ $ className ] [ 'resource' ] ; return [ sprintf ( '@ApiResource(iri="%s")' , $ resource -> getUri ( ) ) ] ; } 
public function generateFieldAnnotations ( string $ className , string $ fieldName ) : array { return $ this -> classes [ $ className ] [ 'fields' ] [ $ fieldName ] [ 'isCustom' ] ? [ ] : [ sprintf ( '@ApiProperty(iri="http://schema.org/%s")' , $ fieldName ) ] ; } 
public function generateClassAnnotations ( string $ className ) : array { $ class = $ this -> classes [ $ className ] ; if ( $ class [ 'isEnum' ] ) { return [ ] ; } if ( isset ( $ this -> config [ 'types' ] [ $ class [ 'resource' ] -> localName ( ) ] [ 'doctrine' ] [ 'inheritanceMapping' ] ) ) { $ inheritanceMapping = $ this -> config [ 'types' ] [ $ class [ 'resource' ] -> localName ( ) ] [ 'doctrine' ] [ 'inheritanceMapping' ] ; } else { $ inheritanceMapping = '@ORM\Entity' ; if ( $ class [ 'abstract' ] ) { $ inheritanceMapping = '@ORM\MappedSuperclass' ; } if ( $ class [ 'embeddable' ] ) { $ inheritanceMapping = '@ORM\Embeddable' ; } } return [ '' , $ inheritanceMapping ] ; } 
public function generateFieldAnnotations ( string $ className , string $ fieldName ) : array { $ field = $ this -> classes [ $ className ] [ 'fields' ] [ $ fieldName ] ; if ( $ field [ 'isId' ] ) { return $ this -> generateIdAnnotations ( ) ; } $ annotations = [ ] ; $ field [ 'relationTableName' ] = null ; if ( isset ( $ this -> config [ 'types' ] [ $ className ] [ 'properties' ] [ $ fieldName ] ) ) { $ field [ 'relationTableName' ] = $ this -> config [ 'types' ] [ $ className ] [ 'properties' ] [ $ fieldName ] [ 'relationTableName' ] ; } if ( $ field [ 'isEnum' ] ) { $ type = $ field [ 'isArray' ] ? 'simple_array' : 'string' ; } else { switch ( $ field [ 'range' ] ) { case 'Boolean' : $ type = 'boolean' ; break ; case 'Date' : $ type = 'date' ; break ; case 'DateTime' : $ type = 'datetime' ; break ; case 'Time' : $ type = 'time' ; break ; case 'Number' : case 'Float' : $ type = 'float' ; break ; case 'Integer' : $ type = 'integer' ; break ; case 'Text' : case 'URL' : $ type = 'text' ; break ; } } if ( isset ( $ type ) ) { $ annotation = '@ORM\Column' ; $ isColumnHasProperties = false ; if ( $ field [ 'ormColumn' ] ) { $ annotation .= sprintf ( '(%s)' , $ field [ 'ormColumn' ] ) ; } else { if ( 'string' !== $ type || $ field [ 'isNullable' ] || $ field [ 'isUnique' ] ) { $ isColumnHasProperties = true ; } if ( $ field [ 'isArray' ] ) { $ type = 'simple_array' ; } if ( $ isColumnHasProperties ) { $ annotation .= '(' ; } if ( 'string' !== $ type ) { $ annotation .= sprintf ( 'type="%s"' , $ type ) ; } if ( 'string' !== $ type && $ field [ 'isNullable' ] ) { $ annotation .= ', ' ; } if ( $ field [ 'isNullable' ] ) { $ annotation .= 'nullable=true' ; } if ( $ field [ 'isUnique' ] && $ field [ 'isNullable' ] ) { $ annotation .= ', ' ; } if ( $ field [ 'isUnique' ] ) { $ annotation .= 'unique=true' ; } if ( $ isColumnHasProperties ) { $ annotation .= ')' ; } } $ annotations [ ] = $ annotation ; } elseif ( $ field [ 'isEmbedded' ] ) { $ columnPrefix = $ field [ 'columnPrefix' ] ? ', columnPrefix=true' : ', columnPrefix=false' ; $ annotations [ ] = sprintf ( '@ORM\Embedded(class="%s"%s)' , $ this -> getRelationName ( $ field [ 'range' ] ) , $ columnPrefix ) ; } else { switch ( $ field [ 'cardinality' ] ) { case CardinalitiesExtractor :: CARDINALITY_0_1 : $ annotations [ ] = sprintf ( '@ORM\OneToOne(targetEntity="%s")' , $ this -> getRelationName ( $ field [ 'range' ] ) ) ; break ; case CardinalitiesExtractor :: CARDINALITY_1_1 : $ annotations [ ] = sprintf ( '@ORM\OneToOne(targetEntity="%s")' , $ this -> getRelationName ( $ field [ 'range' ] ) ) ; $ annotations [ ] = '@ORM\JoinColumn(nullable=false)' ; break ; case CardinalitiesExtractor :: CARDINALITY_UNKNOWN : case CardinalitiesExtractor :: CARDINALITY_N_0 : $ annotations [ ] = sprintf ( '@ORM\ManyToOne(targetEntity="%s")' , $ this -> getRelationName ( $ field [ 'range' ] ) ) ; break ; case CardinalitiesExtractor :: CARDINALITY_N_1 : $ annotations [ ] = sprintf ( '@ORM\ManyToOne(targetEntity="%s")' , $ this -> getRelationName ( $ field [ 'range' ] ) ) ; $ annotations [ ] = '@ORM\JoinColumn(nullable=false)' ; break ; case CardinalitiesExtractor :: CARDINALITY_0_N : $ annotations [ ] = sprintf ( '@ORM\ManyToMany(targetEntity="%s")' , $ this -> getRelationName ( $ field [ 'range' ] ) ) ; $ name = $ field [ 'relationTableName' ] ? sprintf ( 'name="%s", ' , $ field [ 'relationTableName' ] ) : '' ; $ annotations [ ] = '@ORM\JoinTable(' . $ name . 'inverseJoinColumns={@ORM\JoinColumn(unique=true)})' ; break ; case CardinalitiesExtractor :: CARDINALITY_1_N : $ annotations [ ] = sprintf ( '@ORM\ManyToMany(targetEntity="%s")' , $ this -> getRelationName ( $ field [ 'range' ] ) ) ; $ name = $ field [ 'relationTableName' ] ? sprintf ( 'name="%s", ' , $ field [ 'relationTableName' ] ) : '' ; $ annotations [ ] = '@ORM\JoinTable(' . $ name . 'inverseJoinColumns={@ORM\JoinColumn(nullable=false, unique=true)})' ; break ; case CardinalitiesExtractor :: CARDINALITY_N_N : $ annotations [ ] = sprintf ( '@ORM\ManyToMany(targetEntity="%s")' , $ this -> getRelationName ( $ field [ 'range' ] ) ) ; if ( $ field [ 'relationTableName' ] ) { $ annotations [ ] = sprintf ( '@ORM\JoinTable(name="%s")' , $ field [ 'relationTableName' ] ) ; } break ; } } return $ annotations ; } 
public function generateUses ( string $ className ) : array { $ resource = $ this -> classes [ $ className ] [ 'resource' ] ; $ subClassOf = $ resource -> get ( 'rdfs:subClassOf' ) ; $ typeIsEnum = $ subClassOf && TypesGenerator :: SCHEMA_ORG_ENUMERATION === $ subClassOf -> getUri ( ) ; return $ typeIsEnum ? [ ] : [ 'Doctrine\ORM\Mapping as ORM' ] ; } 
private function getRelationName ( string $ range ) : string { $ class = $ this -> classes [ $ range ] ; if ( isset ( $ class [ 'interfaceName' ] ) ) { return $ class [ 'interfaceName' ] ; } if ( isset ( $ this -> config [ 'types' ] [ $ class [ 'name' ] ] [ 'namespaces' ] [ 'class' ] ) ) { return sprintf ( '%s\\%s' , $ this -> config [ 'types' ] [ $ class [ 'name' ] ] [ 'namespaces' ] [ 'class' ] , $ class [ 'name' ] ) ; } if ( isset ( $ this -> config [ 'namespaces' ] [ 'entity' ] ) ) { return sprintf ( '%s\\%s' , $ this -> config [ 'namespaces' ] [ 'entity' ] , $ class [ 'name' ] ) ; } return $ class [ 'name' ] ; } 
protected function configure ( ) : void { $ this -> setName ( 'extract-cardinalities' ) -> setDescription ( 'Extract properties\' cardinality' ) -> addOption ( 'schemaorg-file' , 's' , InputOption :: VALUE_REQUIRED , 'The path or URL of the Schema.org RDFa file to use.' , TypesGeneratorConfiguration :: SCHEMA_ORG_RDFA_URL ) -> addOption ( 'goodrelations-file' , 'g' , InputOption :: VALUE_REQUIRED , 'The path or URL of the GoodRelations OWL file to use.' , TypesGeneratorConfiguration :: GOOD_RELATIONS_OWL_URL ) ; } 
protected function execute ( InputInterface $ input , OutputInterface $ output ) : void { $ schemaOrgFile = $ input -> getOption ( 'schemaorg-file' ) ; $ relations = [ ] ; $ schemaOrg = new \ EasyRdf_Graph ( ) ; if ( 'http://' === substr ( $ schemaOrgFile , 0 , 7 ) || 'https://' === substr ( $ schemaOrgFile , 0 , 8 ) ) { $ schemaOrg -> load ( $ input -> getOption ( 'schemaorg-file' ) , 'rdfa' ) ; } else { $ schemaOrg -> parseFile ( $ input -> getOption ( 'schemaorg-file' ) , 'rdfa' ) ; } $ relations [ ] = $ schemaOrg ; $ goodRelations = [ new \ SimpleXMLElement ( $ input -> getOption ( 'goodrelations-file' ) , 0 , true ) ] ; $ goodRelationsBridge = new GoodRelationsBridge ( $ goodRelations ) ; $ cardinalitiesExtractor = new CardinalitiesExtractor ( $ relations , $ goodRelationsBridge ) ; $ result = $ cardinalitiesExtractor -> extract ( ) ; $ output -> writeln ( json_encode ( $ result , JSON_PRETTY_PRINT ) ) ; } 
public function generateFieldAnnotations ( string $ className , string $ fieldName ) : array { $ field = $ this -> classes [ $ className ] [ 'fields' ] [ $ fieldName ] ; if ( $ field [ 'isId' ] ) { if ( 'uuid' === $ this -> config [ 'id' ] [ 'generationStrategy' ] ) { return [ '@Assert\Uuid' ] ; } return [ ] ; } $ asserts = [ ] ; if ( ! $ field [ 'isArray' ] ) { switch ( $ field [ 'range' ] ) { case 'URL' : $ asserts [ ] = '@Assert\Url' ; break ; case 'Date' : $ asserts [ ] = '@Assert\Date' ; break ; case 'DateTime' : $ asserts [ ] = '@Assert\DateTime' ; break ; case 'Time' : $ asserts [ ] = '@Assert\Time' ; break ; } if ( isset ( $ field [ 'resource' ] ) && 'email' === $ field [ 'resource' ] -> localName ( ) ) { $ asserts [ ] = '@Assert\Email' ; } if ( ! $ asserts && $ this -> config [ 'validator' ] [ 'assertType' ] ) { $ phpType = $ this -> toPhpType ( $ field ) ; if ( in_array ( $ phpType , [ 'boolean' , 'float' , 'integer' , 'string' ] , true ) ) { $ asserts [ ] = sprintf ( '@Assert\Type(type="%s")' , $ phpType ) ; } } } if ( ! $ field [ 'isNullable' ] ) { $ asserts [ ] = '@Assert\NotNull' ; } if ( $ field [ 'isEnum' ] ) { $ assert = sprintf ( '@Assert\Choice(callback={"%s", "toArray"}' , $ field [ 'range' ] ) ; if ( $ field [ 'isArray' ] ) { $ assert .= ', multiple=true' ; } $ assert .= ')' ; $ asserts [ ] = $ assert ; } return $ asserts ; } 
public function generateUses ( string $ className ) : array { if ( $ this -> classes [ $ className ] [ 'isEnum' ] ) { return [ ] ; } $ uses = [ ] ; $ uses [ ] = 'Symfony\Component\Validator\Constraints as Assert' ; $ uses [ ] = UniqueEntity :: class ; foreach ( $ this -> classes [ $ className ] [ 'fields' ] as $ field ) { if ( $ field [ 'isEnum' ] ) { $ enumClass = $ this -> classes [ $ field [ 'range' ] ] ; $ enumNamespace = isset ( $ enumClass [ 'namespaces' ] [ 'class' ] ) && $ enumClass [ 'namespaces' ] [ 'class' ] ? $ enumClass [ 'namespaces' ] [ 'class' ] : $ this -> config [ 'namespaces' ] [ 'enum' ] ; $ use = sprintf ( '%s\%s' , $ enumNamespace , $ field [ 'range' ] ) ; if ( ! in_array ( $ use , $ uses , true ) ) { $ uses [ ] = $ use ; } } } return $ uses ; } 
public function generateClassAnnotations ( string $ className ) : array { if ( $ this -> classes [ $ className ] [ 'isEnum' ] ) { return [ ] ; } $ annotation = [ ] ; $ uniqueFields = [ ] ; foreach ( $ this -> classes [ $ className ] [ 'fields' ] as $ field ) { if ( false === $ field [ 'isUnique' ] ) { continue ; } $ uniqueFields [ ] = $ field [ 'name' ] ; } if ( ! $ uniqueFields ) { return [ ] ; } if ( 1 === count ( $ uniqueFields ) ) { $ annotation [ ] = sprintf ( '@UniqueEntity("%s")' , $ uniqueFields [ 0 ] ) ; } else { $ annotation [ ] = sprintf ( '@UniqueEntity(fields={"%s"})' , implode ( '","' , $ uniqueFields ) ) ; } return $ annotation ; } 
public function generateFieldAnnotations ( string $ className , string $ fieldName ) : array { if ( null === $ field = $ this -> config [ 'types' ] [ $ className ] [ 'properties' ] ?? null ) { return [ ] ; } if ( false === $ this -> classes [ $ className ] [ 'fields' ] [ $ fieldName ] [ 'isId' ] && $ groups = $ field [ $ fieldName ] [ 'groups' ] ?? false ) { return [ sprintf ( '@Groups({"%s"})' , implode ( '", "' , $ groups ) ) ] ; } return [ ] ; } 
public function getConfigTreeBuilder ( ) : TreeBuilder { $ namespacePrefix = $ this -> defaultPrefix ?? 'AppBundle\\' ; $ treeBuilder = new TreeBuilder ( ) ; $ rootNode = $ treeBuilder -> root ( 'config' ) ; $ rootNode -> children ( ) -> arrayNode ( 'rdfa' ) -> info ( 'RDFa files' ) -> defaultValue ( [ [ 'uri' => self :: SCHEMA_ORG_RDFA_URL , 'format' => 'rdfa' ] ] ) -> beforeNormalization ( ) -> ifArray ( ) -> then ( function ( array $ v ) { return array_map ( function ( $ rdfa ) { return is_scalar ( $ rdfa ) ? [ 'uri' => $ rdfa , 'format' => null ] : $ rdfa ; } , $ v ) ; } ) -> end ( ) -> arrayPrototype ( ) -> children ( ) -> scalarNode ( 'uri' ) -> defaultValue ( self :: SCHEMA_ORG_RDFA_URL ) -> info ( 'RDFa URI to use' ) -> example ( 'https://schema.org/docs/schema_org_rdfa.html' ) -> end ( ) -> scalarNode ( 'format' ) -> defaultNull ( ) -> info ( 'RDFa URI data format' ) -> example ( 'rdfxml' ) -> end ( ) -> end ( ) -> end ( ) -> end ( ) -> arrayNode ( 'relations' ) -> info ( 'OWL relation files to use' ) -> example ( 'https://purl.org/goodrelations/v1.owl' ) -> defaultValue ( [ self :: GOOD_RELATIONS_OWL_URL ] ) -> prototype ( 'scalar' ) -> end ( ) -> end ( ) -> booleanNode ( 'debug' ) -> defaultFalse ( ) -> info ( 'Debug mode' ) -> end ( ) -> arrayNode ( 'id' ) -> addDefaultsIfNotSet ( ) -> info ( 'IDs configuration' ) -> children ( ) -> booleanNode ( 'generate' ) -> defaultTrue ( ) -> info ( 'Automatically add an id field to entities' ) -> end ( ) -> enumNode ( 'generationStrategy' ) -> defaultValue ( 'auto' ) -> values ( [ 'auto' , 'none' , 'uuid' , 'mongoid' ] ) -> info ( 'The ID generation strategy to use ("none" to not let the database generate IDs).' ) -> end ( ) -> booleanNode ( 'writable' ) -> defaultFalse ( ) -> info ( 'Is the ID writable? Only applicable if "generationStrategy" is "uuid".' ) -> end ( ) -> end ( ) -> end ( ) -> booleanNode ( 'useInterface' ) -> defaultFalse ( ) -> info ( 'Generate interfaces and use Doctrine\'s Resolve Target Entity feature' ) -> end ( ) -> booleanNode ( 'checkIsGoodRelations' ) -> defaultFalse ( ) -> info ( 'Emit a warning if a property is not derived from GoodRelations' ) -> end ( ) -> scalarNode ( 'header' ) -> defaultFalse ( ) -> info ( 'A license or any text to use as header of generated files' ) -> example ( ' 
private function createNewFile ( ) { $ this -> fileCount ++ ; $ filePath = $ this -> getCurrentFilePath ( ) ; $ this -> writtenFilePaths [ ] = $ filePath ; if ( file_exists ( $ filePath ) ) { $ filePath = realpath ( $ filePath ) ; if ( is_writable ( $ filePath ) ) { unlink ( $ filePath ) ; } else { throw new \ RuntimeException ( "File \"$filePath\" is not writable." ) ; } } if ( $ this -> useGzip ) { if ( function_exists ( 'deflate_init' ) && function_exists ( 'deflate_add' ) ) { $ this -> writerBackend = new DeflateWriter ( $ filePath ) ; } else { $ this -> writerBackend = new TempFileGZIPWriter ( $ filePath ) ; } } else { $ this -> writerBackend = new PlainFileWriter ( $ filePath ) ; } $ this -> writer = new XMLWriter ( ) ; $ this -> writer -> openMemory ( ) ; $ this -> writer -> startDocument ( '1.0' , 'UTF-8' ) ; $ this -> writer -> setIndent ( $ this -> useIndent ) ; $ this -> writer -> startElement ( 'urlset' ) ; $ this -> writer -> writeAttribute ( 'xmlns' , 'http://www.sitemaps.org/schemas/sitemap/0.9' ) ; if ( $ this -> useXhtml ) { $ this -> writer -> writeAttribute ( 'xmlns:xhtml' , 'http://www.w3.org/1999/xhtml' ) ; } $ this -> writer -> text ( "\n" ) ; $ this -> flush ( true ) ; } 
private function finishFile ( ) { if ( $ this -> writer !== null ) { $ this -> writer -> endElement ( ) ; $ this -> writer -> endDocument ( ) ; $ this -> urlsCount = 0 ; $ this -> flush ( 0 ) ; $ this -> writerBackend -> finish ( ) ; $ this -> writerBackend = null ; $ this -> byteCount = 0 ; } } 
private function flush ( $ footSize = 10 ) { $ data = $ this -> writer -> flush ( true ) ; $ dataSize = mb_strlen ( $ data , '8bit' ) ; if ( $ this -> byteCount + $ dataSize + $ footSize > $ this -> maxBytes ) { if ( $ this -> urlsCount <= 1 ) { throw new \ OverflowException ( 'The buffer size is too big for the defined file size limit' ) ; } $ this -> finishFile ( ) ; $ this -> createNewFile ( ) ; } $ this -> writerBackend -> append ( $ data ) ; $ this -> byteCount += $ dataSize ; } 
public function addItem ( $ location , $ lastModified = null , $ changeFrequency = null , $ priority = null ) { if ( $ this -> urlsCount >= $ this -> maxUrls ) { $ this -> finishFile ( ) ; } if ( $ this -> writerBackend === null ) { $ this -> createNewFile ( ) ; } if ( is_array ( $ location ) ) { $ this -> addMultiLanguageItem ( $ location , $ lastModified , $ changeFrequency , $ priority ) ; } else { $ this -> addSingleLanguageItem ( $ location , $ lastModified , $ changeFrequency , $ priority ) ; } $ this -> urlsCount ++ ; if ( $ this -> urlsCount % $ this -> bufferSize === 0 ) { $ this -> flush ( ) ; } } 
private function addSingleLanguageItem ( $ location , $ lastModified , $ changeFrequency , $ priority ) { $ this -> validateLocation ( $ location ) ; $ this -> writer -> startElement ( 'url' ) ; $ this -> writer -> writeElement ( 'loc' , $ location ) ; if ( $ lastModified !== null ) { $ this -> writer -> writeElement ( 'lastmod' , date ( 'c' , $ lastModified ) ) ; } if ( $ changeFrequency !== null ) { if ( ! in_array ( $ changeFrequency , $ this -> validFrequencies , true ) ) { throw new \ InvalidArgumentException ( 'Please specify valid changeFrequency. Valid values are: ' . implode ( ', ' , $ this -> validFrequencies ) . "You have specified: {$changeFrequency}." ) ; } $ this -> writer -> writeElement ( 'changefreq' , $ changeFrequency ) ; } if ( $ priority !== null ) { if ( ! is_numeric ( $ priority ) || $ priority < 0 || $ priority > 1 ) { throw new \ InvalidArgumentException ( "Please specify valid priority. Valid values range from 0.0 to 1.0. You have specified: {$priority}." ) ; } $ this -> writer -> writeElement ( 'priority' , number_format ( $ priority , 1 , '.' , ',' ) ) ; } $ this -> writer -> endElement ( ) ; } 
private function addMultiLanguageItem ( $ locations , $ lastModified , $ changeFrequency , $ priority ) { foreach ( $ locations as $ language => $ url ) { $ this -> validateLocation ( $ url ) ; $ this -> writer -> startElement ( 'url' ) ; $ this -> writer -> writeElement ( 'loc' , $ url ) ; if ( $ lastModified !== null ) { $ this -> writer -> writeElement ( 'lastmod' , date ( 'c' , $ lastModified ) ) ; } if ( $ changeFrequency !== null ) { if ( ! in_array ( $ changeFrequency , $ this -> validFrequencies , true ) ) { throw new \ InvalidArgumentException ( 'Please specify valid changeFrequency. Valid values are: ' . implode ( ', ' , $ this -> validFrequencies ) . "You have specified: {$changeFrequency}." ) ; } $ this -> writer -> writeElement ( 'changefreq' , $ changeFrequency ) ; } if ( $ priority !== null ) { if ( ! is_numeric ( $ priority ) || $ priority < 0 || $ priority > 1 ) { throw new \ InvalidArgumentException ( "Please specify valid priority. Valid values range from 0.0 to 1.0. You have specified: {$priority}." ) ; } $ this -> writer -> writeElement ( 'priority' , number_format ( $ priority , 1 , '.' , ',' ) ) ; } foreach ( $ locations as $ hreflang => $ href ) { $ this -> writer -> startElement ( 'xhtml:link' ) ; $ this -> writer -> startAttribute ( 'rel' ) ; $ this -> writer -> text ( 'alternate' ) ; $ this -> writer -> endAttribute ( ) ; $ this -> writer -> startAttribute ( 'hreflang' ) ; $ this -> writer -> text ( $ hreflang ) ; $ this -> writer -> endAttribute ( ) ; $ this -> writer -> startAttribute ( 'href' ) ; $ this -> writer -> text ( $ href ) ; $ this -> writer -> endAttribute ( ) ; $ this -> writer -> endElement ( ) ; } $ this -> writer -> endElement ( ) ; } } 
public function getSitemapUrls ( $ baseUrl ) { $ urls = array ( ) ; foreach ( $ this -> writtenFilePaths as $ file ) { $ urls [ ] = $ baseUrl . pathinfo ( $ file , PATHINFO_BASENAME ) ; } return $ urls ; } 
public function setUseGzip ( $ value ) { if ( $ value && ! extension_loaded ( 'zlib' ) ) { throw new \ RuntimeException ( 'Zlib extension must be enabled to gzip the sitemap.' ) ; } if ( $ this -> writerBackend !== null && $ value != $ this -> useGzip ) { throw new \ RuntimeException ( 'Cannot change the gzip value once items have been added to the sitemap.' ) ; } $ this -> useGzip = $ value ; } 
private function createNewFile ( ) { $ this -> writer = new XMLWriter ( ) ; $ this -> writer -> openMemory ( ) ; $ this -> writer -> startDocument ( '1.0' , 'UTF-8' ) ; $ this -> writer -> setIndent ( true ) ; $ this -> writer -> startElement ( 'sitemapindex' ) ; $ this -> writer -> writeAttribute ( 'xmlns' , 'http://www.sitemaps.org/schemas/sitemap/0.9' ) ; } 
public function addSitemap ( $ location , $ lastModified = null ) { if ( false === filter_var ( $ location , FILTER_VALIDATE_URL ) ) { throw new \ InvalidArgumentException ( "The location must be a valid URL. You have specified: {$location}." ) ; } if ( $ this -> writer === null ) { $ this -> createNewFile ( ) ; } $ this -> writer -> startElement ( 'sitemap' ) ; $ this -> writer -> writeElement ( 'loc' , $ location ) ; if ( $ lastModified !== null ) { $ this -> writer -> writeElement ( 'lastmod' , date ( 'c' , $ lastModified ) ) ; } $ this -> writer -> endElement ( ) ; } 
public function write ( ) { if ( $ this -> writer instanceof XMLWriter ) { $ this -> writer -> endElement ( ) ; $ this -> writer -> endDocument ( ) ; $ filePath = $ this -> getFilePath ( ) ; if ( $ this -> useGzip ) { $ filePath = 'compress.zlib://' . $ filePath ; } file_put_contents ( $ filePath , $ this -> writer -> flush ( ) ) ; } } 
private function write ( $ data , $ flushMode ) { assert ( $ this -> file !== null ) ; $ compressedChunk = deflate_add ( $ this -> deflateContext , $ data , $ flushMode ) ; fwrite ( $ this -> file , $ compressedChunk ) ; } 
public function finish ( ) { $ this -> write ( '' , ZLIB_FINISH ) ; $ this -> file = null ; $ this -> deflateContext = null ; } 
public function append ( $ data ) { assert ( $ this -> tempFile !== null ) ; fwrite ( $ this -> tempFile , $ data ) ; } 
public function finish ( ) { assert ( $ this -> tempFile !== null ) ; $ file = fopen ( 'compress.zlib://' . $ this -> filename , 'wb' ) ; rewind ( $ this -> tempFile ) ; stream_copy_to_stream ( $ this -> tempFile , $ file ) ; fclose ( $ file ) ; fclose ( $ this -> tempFile ) ; $ this -> tempFile = null ; } 
public function setExpirationDate ( $ date ) { if ( is_int ( $ date ) || ctype_digit ( strval ( $ date ) ) ) { $ expirationDate = intval ( $ date ) ; } else { $ expirationDate = strtotime ( $ date ) ; } if ( $ expirationDate === false ) { throw new InvalidArgumentException ( sprintf ( 'Invalid expiration date format: "%s". Please use a ' . 'format compatible with PHP\'s strtotime().' , $ date ) ) ; } if ( $ expirationDate !== 0 && $ expirationDate < time ( ) + 86400 ) { throw new InvalidArgumentException ( 'Expiration date must be at least a day in the future.' ) ; } // GnuPG suffers from the 2038 bug if ( $ expirationDate > 2147483647 ) { throw new InvalidArgumentException ( 'Expiration date must not be greater than 2038-01-19T03:14:07.' ) ; } $ this -> expirationDate = $ expirationDate ; return $ this ; } 
public function setKeyParams ( $ algorithm , $ size = 0 , $ usage = 0 ) { $ algorithm = intval ( $ algorithm ) ; if ( $ algorithm === Crypt_GPG_SubKey :: ALGORITHM_ELGAMAL_ENC ) { throw new Crypt_GPG_InvalidKeyParamsException ( 'Primary key algorithm must be capable of signing. The ' . 'Elgamal algorithm can only encrypt.' , 0 , $ algorithm , $ size , $ usage ) ; } if ( $ size != 0 ) { $ size = intval ( $ size ) ; } if ( $ usage != 0 ) { $ usage = intval ( $ usage ) ; } $ usageEncrypt = Crypt_GPG_SubKey :: USAGE_ENCRYPT ; if ( $ algorithm === Crypt_GPG_SubKey :: ALGORITHM_DSA && ( $ usage & $ usageEncrypt ) === $ usageEncrypt ) { throw new Crypt_GPG_InvalidKeyParamsException ( 'The DSA algorithm is not capable of encrypting. Please ' . 'specify a different algorithm or do not include encryption ' . 'as a usage for the primary key.' , 0 , $ algorithm , $ size , $ usage ) ; } $ this -> keyAlgorithm = $ algorithm ; if ( $ size != 0 ) { $ this -> keySize = $ size ; } if ( $ usage != 0 ) { $ this -> keyUsage = $ usage ; } return $ this ; } 
public function setSubKeyParams ( $ algorithm , $ size = '' , $ usage = 0 ) { $ algorithm = intval ( $ algorithm ) ; if ( $ size != 0 ) { $ size = intval ( $ size ) ; } if ( $ usage != 0 ) { $ usage = intval ( $ usage ) ; } $ usageSign = Crypt_GPG_SubKey :: USAGE_SIGN ; if ( $ algorithm === Crypt_GPG_SubKey :: ALGORITHM_ELGAMAL_ENC && ( $ usage & $ usageSign ) === $ usageSign ) { throw new Crypt_GPG_InvalidKeyParamsException ( 'The Elgamal algorithm is not capable of signing. Please ' . 'specify a different algorithm or do not include signing ' . 'as a usage for the sub-key.' , 0 , $ algorithm , $ size , $ usage ) ; } $ usageEncrypt = Crypt_GPG_SubKey :: USAGE_ENCRYPT ; if ( $ algorithm === Crypt_GPG_SubKey :: ALGORITHM_DSA && ( $ usage & $ usageEncrypt ) === $ usageEncrypt ) { throw new Crypt_GPG_InvalidKeyParamsException ( 'The DSA algorithm is not capable of encrypting. Please ' . 'specify a different algorithm or do not include encryption ' . 'as a usage for the sub-key.' , 0 , $ algorithm , $ size , $ usage ) ; } $ this -> subKeyAlgorithm = $ algorithm ; if ( $ size != 0 ) { $ this -> subKeySize = $ size ; } if ( $ usage != 0 ) { $ this -> subKeyUsage = $ usage ; } return $ this ; } 
public function generateKey ( $ name , $ email = '' , $ comment = '' ) { $ handle = uniqid ( 'key' , true ) ; $ userId = $ this -> getUserId ( $ name , $ email , $ comment ) ; $ keyParams = array ( 'Key-Type' => $ this -> keyAlgorithm , 'Key-Length' => $ this -> keySize , 'Key-Usage' => $ this -> getUsage ( $ this -> keyUsage ) , 'Subkey-Type' => $ this -> subKeyAlgorithm , 'Subkey-Length' => $ this -> subKeySize , 'Subkey-Usage' => $ this -> getUsage ( $ this -> subKeyUsage ) , 'Name-Real' => $ userId -> getName ( ) , 'Handle' => $ handle , ) ; if ( $ this -> expirationDate != 0 ) { 
protected function getUsage ( $ usage ) { $ map = array ( Crypt_GPG_SubKey :: USAGE_ENCRYPT => 'encrypt' , Crypt_GPG_SubKey :: USAGE_SIGN => 'sign' , Crypt_GPG_SubKey :: USAGE_CERTIFY => 'cert' , Crypt_GPG_SubKey :: USAGE_AUTHENTICATION => 'auth' , ) ; 
protected function getUserId ( $ name , $ email = '' , $ comment = '' ) { if ( $ name instanceof Crypt_GPG_UserId ) { $ userId = $ name ; } else { $ userId = new Crypt_GPG_UserId ( ) ; $ userId -> setName ( $ name ) -> setEmail ( $ email ) -> setComment ( $ comment ) ; } return $ userId ; } 
public static function parse ( $ string ) { $ userId = new Crypt_GPG_UserId ( ) ; $ name = '' ; $ email = '' ; $ comment = '' ; 
public function isRunning ( ) { $ running = false ; if ( function_exists ( 'posix_getpgid' ) ) { $ running = false !== posix_getpgid ( $ this -> pid ) ; } elseif ( PHP_OS === 'WINNT' ) { $ command = 'tasklist /fo csv /nh /fi ' . escapeshellarg ( 'PID eq ' . $ this -> pid ) ; $ result = exec ( $ command ) ; $ parts = explode ( ',' , $ result ) ; $ running = ( count ( $ parts ) > 1 && trim ( $ parts [ 1 ] , '"' ) == $ this -> pid ) ; } else { $ result = exec ( 'ps -p ' . escapeshellarg ( $ this -> pid ) . ' -o pid=' ) ; $ running = ( trim ( $ result ) == $ this -> pid ) ; } return $ running ; } 
public function terminate ( ) { if ( function_exists ( 'posix_kill' ) ) { posix_kill ( $ this -> pid , 15 ) ; } elseif ( PHP_OS === 'WINNT' ) { exec ( 'taskkill /PID ' . escapeshellarg ( $ this -> pid ) ) ; } else { exec ( 'kill -15 ' . escapeshellarg ( $ this -> pid ) ) ; } } 
public function setOperation ( $ operation ) { $ op = null ; $ opArg = null ; 
public function handleStatus ( $ line ) { $ tokens = explode ( ' ' , $ line ) ; switch ( $ tokens [ 0 ] ) { case 'NODATA' : $ this -> errorCode = Crypt_GPG :: ERROR_NO_DATA ; break ; case 'DECRYPTION_OKAY' : 
public function handleError ( $ line ) { if ( stripos ( $ line , 'gpg: WARNING: ' ) !== false ) { $ this -> data [ 'Warnings' ] [ ] = substr ( $ line , 14 ) ; } if ( $ this -> errorCode !== Crypt_GPG :: ERROR_NONE ) { return ; } $ pattern = '/no valid OpenPGP data found/' ; if ( preg_match ( $ pattern , $ line ) === 1 ) { $ this -> errorCode = Crypt_GPG :: ERROR_NO_DATA ; return ; } $ pattern = '/No secret key|secret key not available/' ; if ( preg_match ( $ pattern , $ line ) === 1 ) { $ this -> errorCode = Crypt_GPG :: ERROR_KEY_NOT_FOUND ; return ; } $ pattern = '/No public key|public key not found/' ; if ( preg_match ( $ pattern , $ line ) === 1 ) { $ this -> errorCode = Crypt_GPG :: ERROR_KEY_NOT_FOUND ; return ; } $ pattern = '/can\'t (?:access|open) `(.*?)\'/' ; if ( preg_match ( $ pattern , $ line , $ matches ) === 1 ) { $ this -> data [ 'ErrorFilename' ] = $ matches [ 1 ] ; $ this -> errorCode = Crypt_GPG :: ERROR_FILE_PERMISSIONS ; return ; } 
public function throwException ( $ exitcode = 0 ) { if ( $ exitcode > 0 && $ this -> errorCode === Crypt_GPG :: ERROR_NONE ) { $ this -> errorCode = $ this -> setErrorCode ( $ exitcode ) ; } if ( $ this -> errorCode === Crypt_GPG :: ERROR_NONE ) { return ; } $ code = $ this -> errorCode ; $ note = "Please use the 'debug' option when creating the Crypt_GPG " . "object, and file a bug report at " . Crypt_GPG :: BUG_URI ; switch ( $ this -> operation ) { case 'version' : throw new Crypt_GPG_Exception ( 'Unknown error getting GnuPG version information. ' . $ note , $ code ) ; case 'list-secret-keys' : case 'list-public-keys' : case 'list-keys' : switch ( $ code ) { case Crypt_GPG :: ERROR_KEY_NOT_FOUND : 
protected function setErrorCode ( $ exitcode ) { if ( $ this -> needPassphrase > 0 ) { return Crypt_GPG :: ERROR_MISSING_PASSPHRASE ; } if ( $ this -> operation == 'import' ) { return Crypt_GPG :: ERROR_NONE ; } if ( $ this -> operation == 'decrypt' && ! empty ( $ this -> data [ 'DecryptionOkay' ] ) ) { if ( ! empty ( $ this -> data [ 'IgnoreVerifyErrors' ] ) ) { return Crypt_GPG :: ERROR_NONE ; } if ( ! empty ( $ this -> data [ 'MissingKeys' ] ) ) { return Crypt_GPG :: ERROR_KEY_NOT_FOUND ; } } return Crypt_GPG :: ERROR_UNKNOWN ; } 
public function setData ( $ name , $ value ) { switch ( $ name ) { case 'Handle' : $ this -> data [ $ name ] = strval ( $ value ) ; break ; case 'IgnoreVerifyErrors' : $ this -> data [ $ name ] = ( bool ) $ value ; break ; } } 
protected function badPassException ( $ code , $ message ) { $ badPassphrases = array_diff_key ( isset ( $ this -> data [ 'BadPassphrases' ] ) ? $ this -> data [ 'BadPassphrases' ] : array ( ) , isset ( $ this -> data [ 'MissingPassphrases' ] ) ? $ this -> data [ 'MissingPassphrases' ] : array ( ) ) ; $ missingPassphrases = array_intersect_key ( isset ( $ this -> data [ 'BadPassphrases' ] ) ? $ this -> data [ 'BadPassphrases' ] : array ( ) , isset ( $ this -> data [ 'MissingPassphrases' ] ) ? $ this -> data [ 'MissingPassphrases' ] : array ( ) ) ; if ( count ( $ badPassphrases ) > 0 ) { $ message .= ' Incorrect passphrase provided for keys: "' . implode ( '", "' , $ badPassphrases ) . '".' ; } if ( count ( $ missingPassphrases ) > 0 ) { $ message .= ' No passphrase provided for keys: "' . implode ( '", "' , $ missingPassphrases ) . '".' ; } return new Crypt_GPG_BadPassphraseException ( $ message , $ code , $ badPassphrases , $ missingPassphrases ) ; } 
protected function getPin ( $ key ) { $ passphrase = '' ; $ keyIdLength = mb_strlen ( $ key , '8bit' ) ; if ( $ keyIdLength && ! empty ( $ _ENV [ 'PINENTRY_USER_DATA' ] ) ) { $ passphrases = json_decode ( $ _ENV [ 'PINENTRY_USER_DATA' ] , true ) ; foreach ( $ passphrases as $ _keyId => $ pass ) { $ keyId = $ key ; $ _keyIdLength = mb_strlen ( $ _keyId , '8bit' ) ; 
public function getHashAlgorithmName ( ) { if ( ! isset ( self :: $ hashAlgorithmNames [ $ this -> hashAlgorithm ] ) ) { return null ; } return self :: $ hashAlgorithmNames [ $ this -> hashAlgorithm ] ; } 
public function setCanSign ( $ canSign ) { if ( $ canSign ) { $ this -> _usage |= self :: USAGE_SIGN ; } else { $ this -> _usage &= ~ self :: USAGE_SIGN ; } return $ this ; } 
public function setCanEncrypt ( $ canEncrypt ) { if ( $ canEncrypt ) { $ this -> _usage |= self :: USAGE_ENCRYPT ; } else { $ this -> _usage &= ~ self :: USAGE_ENCRYPT ; } return $ this ; } 
public static function parse ( $ string ) { $ tokens = explode ( ':' , $ string ) ; $ subKey = new Crypt_GPG_SubKey ( ) ; $ subKey -> setId ( $ tokens [ 4 ] ) ; $ subKey -> setLength ( $ tokens [ 2 ] ) ; $ subKey -> setAlgorithm ( $ tokens [ 3 ] ) ; $ subKey -> setCreationDate ( self :: _parseDate ( $ tokens [ 5 ] ) ) ; $ subKey -> setExpirationDate ( self :: _parseDate ( $ tokens [ 6 ] ) ) ; if ( $ tokens [ 1 ] == 'r' ) { $ subKey -> setRevoked ( true ) ; } $ usage = 0 ; $ usage_map = array ( 'a' => self :: USAGE_AUTHENTICATION , 'c' => self :: USAGE_CERTIFY , 'e' => self :: USAGE_ENCRYPT , 's' => self :: USAGE_SIGN , ) ; foreach ( $ usage_map as $ key => $ flag ) { if ( strpos ( $ tokens [ 11 ] , $ key ) !== false ) { $ usage |= $ flag ; } } $ subKey -> setUsage ( $ usage ) ; return $ subKey ; } 
private static function _parseDate ( $ string ) { if ( $ string == '' ) { $ timestamp = 0 ; } else { 
public function deletePublicKey ( $ keyId ) { $ fingerprint = $ this -> getFingerprint ( $ keyId ) ; if ( $ fingerprint === null ) { throw new Crypt_GPG_KeyNotFoundException ( 'Public key not found: ' . $ keyId , self :: ERROR_KEY_NOT_FOUND , $ keyId ) ; } $ operation = '--delete-key ' . escapeshellarg ( $ fingerprint ) ; $ arguments = array ( '--batch' , '--yes' ) ; $ this -> engine -> reset ( ) ; $ this -> engine -> setOperation ( $ operation , $ arguments ) ; $ this -> engine -> run ( ) ; } 
public function getFingerprint ( $ keyId , $ format = self :: FORMAT_NONE ) { $ output = '' ; $ operation = '--list-keys ' . escapeshellarg ( $ keyId ) ; $ arguments = array ( '--with-colons' , '--with-fingerprint' ) ; $ this -> engine -> reset ( ) ; $ this -> engine -> setOutput ( $ output ) ; $ this -> engine -> setOperation ( $ operation , $ arguments ) ; $ this -> engine -> run ( ) ; $ fingerprint = null ; foreach ( explode ( PHP_EOL , $ output ) as $ line ) { if ( mb_substr ( $ line , 0 , 3 , '8bit' ) == 'fpr' ) { $ lineExp = explode ( ':' , $ line ) ; $ fingerprint = $ lineExp [ 9 ] ; switch ( $ format ) { case self :: FORMAT_CANONICAL : $ fingerprintExp = str_split ( $ fingerprint , 4 ) ; $ format = '%s %s %s %s %s %s %s %s %s %s' ; $ fingerprint = vsprintf ( $ format , $ fingerprintExp ) ; break ; case self :: FORMAT_X509 : $ fingerprintExp = str_split ( $ fingerprint , 2 ) ; $ fingerprint = implode ( ':' , $ fingerprintExp ) ; break ; } break ; } } return $ fingerprint ; } 
public function encrypt ( $ data , $ armor = self :: ARMOR_ASCII ) { return $ this -> _encrypt ( $ data , false , null , $ armor ) ; } 
public function encryptFile ( $ filename , $ encryptedFile = null , $ armor = self :: ARMOR_ASCII ) { return $ this -> _encrypt ( $ filename , true , $ encryptedFile , $ armor ) ; } 
public function encryptAndSign ( $ data , $ armor = self :: ARMOR_ASCII ) { return $ this -> _encryptAndSign ( $ data , false , null , $ armor ) ; } 
public function encryptAndSignFile ( $ filename , $ signedFile = null , $ armor = self :: ARMOR_ASCII ) { return $ this -> _encryptAndSign ( $ filename , true , $ signedFile , $ armor ) ; } 
public function decryptAndVerify ( $ encryptedData , $ ignoreVerifyErrors = false ) { return $ this -> _decryptAndVerify ( $ encryptedData , false , null , $ ignoreVerifyErrors ) ; } 
public function decryptAndVerifyFile ( $ encryptedFile , $ decryptedFile = null , $ ignoreVerifyErrors = false ) { return $ this -> _decryptAndVerify ( $ encryptedFile , true , $ decryptedFile , $ ignoreVerifyErrors ) ; } 
public function sign ( $ data , $ mode = self :: SIGN_MODE_NORMAL , $ armor = self :: ARMOR_ASCII , $ textmode = self :: TEXT_RAW ) { return $ this -> _sign ( $ data , false , null , $ mode , $ armor , $ textmode ) ; } 
public function signFile ( $ filename , $ signedFile = null , $ mode = self :: SIGN_MODE_NORMAL , $ armor = self :: ARMOR_ASCII , $ textmode = self :: TEXT_RAW ) { return $ this -> _sign ( $ filename , true , $ signedFile , $ mode , $ armor , $ textmode ) ; } 
public function addDecryptKey ( $ key , $ passphrase = null ) { $ this -> _addKey ( $ this -> decryptKeys , false , false , $ key , $ passphrase ) ; return $ this ; } 
public function addEncryptKey ( $ key ) { $ this -> _addKey ( $ this -> encryptKeys , true , false , $ key ) ; return $ this ; } 
public function addSignKey ( $ key , $ passphrase = null ) { $ this -> _addKey ( $ this -> signKeys , false , true , $ key , $ passphrase ) ; return $ this ; } 
protected function _addKey ( array & $ array , $ encrypt , $ sign , $ key , $ passphrase = null ) { $ subKeys = array ( ) ; if ( is_scalar ( $ key ) ) { $ keys = $ this -> getKeys ( $ key ) ; if ( count ( $ keys ) == 0 ) { throw new Crypt_GPG_KeyNotFoundException ( 'Key not found: ' . $ key , self :: ERROR_KEY_NOT_FOUND , $ key ) ; } $ key = $ keys [ 0 ] ; } if ( $ key instanceof Crypt_GPG_Key ) { if ( $ encrypt && ! $ key -> canEncrypt ( ) ) { throw new InvalidArgumentException ( 'Key "' . $ key . '" cannot encrypt.' ) ; } if ( $ sign && ! $ key -> canSign ( ) ) { throw new InvalidArgumentException ( 'Key "' . $ key . '" cannot sign.' ) ; } foreach ( $ key -> getSubKeys ( ) as $ subKey ) { $ canEncrypt = $ subKey -> canEncrypt ( ) ; $ canSign = $ subKey -> canSign ( ) ; if ( ( $ encrypt && $ sign && $ canEncrypt && $ canSign ) || ( $ encrypt && ! $ sign && $ canEncrypt ) || ( ! $ encrypt && $ sign && $ canSign ) || ( ! $ encrypt && ! $ sign ) ) { 
protected function _importKey ( $ key , $ isFile ) { $ result = array ( ) ; $ arguments = array ( ) ; $ input = $ this -> _prepareInput ( $ key , $ isFile , false ) ; $ version = $ this -> engine -> getVersion ( ) ; if ( version_compare ( $ version , '1.0.5' , 'ge' ) && version_compare ( $ version , '1.0.7' , 'lt' ) ) { $ arguments [ ] = '--allow-secret-key-import' ; } if ( empty ( $ this -> passphrases ) ) { $ arguments [ ] = '--batch' ; } $ this -> engine -> reset ( ) ; $ this -> engine -> setPins ( $ this -> passphrases ) ; $ this -> engine -> setOperation ( '--import' , $ arguments ) ; $ this -> engine -> setInput ( $ input ) ; $ this -> engine -> run ( ) ; return $ this -> engine -> getProcessData ( 'Import' ) ; } 
protected function _exportKey ( $ keyId , $ armor = true , $ private = false ) { $ fingerprint = $ this -> getFingerprint ( $ keyId ) ; if ( $ fingerprint === null ) { throw new Crypt_GPG_KeyNotFoundException ( 'Key not found: ' . $ keyId , self :: ERROR_KEY_NOT_FOUND , $ keyId ) ; } $ keyData = '' ; $ operation = $ private ? '--export-secret-keys' : '--export' ; $ operation .= ' ' . escapeshellarg ( $ fingerprint ) ; $ arguments = $ armor ? array ( '--armor' ) : array ( ) ; $ this -> engine -> reset ( ) ; $ this -> engine -> setPins ( $ this -> passphrases ) ; $ this -> engine -> setOutput ( $ keyData ) ; $ this -> engine -> setOperation ( $ operation , $ arguments ) ; $ this -> engine -> run ( ) ; return $ keyData ; } 
protected function _encrypt ( $ data , $ isFile , $ outputFile , $ armor ) { if ( ! $ this -> hasEncryptKeys ( ) ) { throw new Crypt_GPG_KeyNotFoundException ( 'No encryption keys specified.' ) ; } $ input = $ this -> _prepareInput ( $ data , $ isFile ) ; $ output = $ this -> _prepareOutput ( $ outputFile , $ input ) ; $ arguments = $ armor ? array ( '--armor' ) : array ( ) ; foreach ( $ this -> encryptKeys as $ key ) { $ arguments [ ] = '--recipient ' . escapeshellarg ( $ key [ 'fingerprint' ] ) ; } $ this -> engine -> reset ( ) ; $ this -> engine -> setInput ( $ input ) ; $ this -> engine -> setOutput ( $ output ) ; $ this -> engine -> setOperation ( '--encrypt' , $ arguments ) ; $ this -> engine -> run ( ) ; if ( $ outputFile === null ) { return $ output ; } } 
protected function _decrypt ( $ data , $ isFile , $ outputFile ) { $ input = $ this -> _prepareInput ( $ data , $ isFile , false ) ; $ output = $ this -> _prepareOutput ( $ outputFile , $ input ) ; $ this -> engine -> reset ( ) ; $ this -> engine -> setPins ( $ this -> decryptKeys ) ; $ this -> engine -> setOperation ( '--decrypt --skip-verify' ) ; $ this -> engine -> setInput ( $ input ) ; $ this -> engine -> setOutput ( $ output ) ; $ this -> engine -> run ( ) ; if ( $ outputFile === null ) { return $ output ; } } 
protected function _sign ( $ data , $ isFile , $ outputFile , $ mode , $ armor , $ textmode ) { if ( ! $ this -> hasSignKeys ( ) ) { throw new Crypt_GPG_KeyNotFoundException ( 'No signing keys specified.' ) ; } $ input = $ this -> _prepareInput ( $ data , $ isFile ) ; $ output = $ this -> _prepareOutput ( $ outputFile , $ input ) ; switch ( $ mode ) { case self :: SIGN_MODE_DETACHED : $ operation = '--detach-sign' ; break ; case self :: SIGN_MODE_CLEAR : $ operation = '--clearsign' ; break ; case self :: SIGN_MODE_NORMAL : default : $ operation = '--sign' ; break ; } $ arguments = array ( ) ; if ( $ armor ) { $ arguments [ ] = '--armor' ; } if ( $ textmode ) { $ arguments [ ] = '--textmode' ; } foreach ( $ this -> signKeys as $ key ) { $ arguments [ ] = '--local-user ' . escapeshellarg ( $ key [ 'fingerprint' ] ) ; } $ this -> engine -> reset ( ) ; $ this -> engine -> setPins ( $ this -> signKeys ) ; $ this -> engine -> setInput ( $ input ) ; $ this -> engine -> setOutput ( $ output ) ; $ this -> engine -> setOperation ( $ operation , $ arguments ) ; $ this -> engine -> run ( ) ; if ( $ outputFile === null ) { return $ output ; } } 
protected function _verify ( $ data , $ isFile , $ signature ) { if ( $ signature == '' ) { $ operation = '--verify' ; $ arguments = array ( ) ; } else { 
protected function _decryptAndVerify ( $ data , $ isFile , $ outputFile , $ ignoreVerifyErrors = false ) { $ input = $ this -> _prepareInput ( $ data , $ isFile , false ) ; $ output = $ this -> _prepareOutput ( $ outputFile , $ input ) ; $ this -> engine -> reset ( ) ; $ this -> engine -> setPins ( $ this -> decryptKeys ) ; $ this -> engine -> setInput ( $ input ) ; $ this -> engine -> setOutput ( $ output ) ; $ this -> engine -> setOperation ( '--decrypt' ) ; $ this -> engine -> setProcessData ( 'IgnoreVerifyErrors' , $ ignoreVerifyErrors ) ; $ this -> engine -> run ( ) ; $ return = array ( 'data' => null , 'signatures' => $ this -> engine -> getProcessData ( 'Signatures' ) ) ; if ( $ outputFile === null ) { $ return [ 'data' ] = $ output ; } return $ return ; } 
protected function _prepareInput ( $ data , $ isFile = false , $ allowEmpty = true ) { if ( $ isFile ) { $ input = @ fopen ( $ data , 'rb' ) ; if ( $ input === false ) { throw new Crypt_GPG_FileException ( 'Could not open input file "' . $ data . '"' , 0 , $ data ) ; } } else { $ input = strval ( $ data ) ; if ( ! $ allowEmpty && $ input === '' ) { throw new Crypt_GPG_NoDataException ( 'No valid input data found.' , self :: ERROR_NO_DATA ) ; } } return $ input ; } 
protected function _prepareOutput ( $ outputFile , $ input = null ) { if ( $ outputFile === null ) { $ output = '' ; } else { $ output = @ fopen ( $ outputFile , 'wb' ) ; if ( $ output === false ) { if ( is_resource ( $ input ) ) { fclose ( $ input ) ; } throw new Crypt_GPG_FileException ( 'Could not open output file "' . $ outputFile . '"' , 0 , $ outputFile ) ; } } return $ output ; } 
protected function _getKeys ( $ keyId = '' ) { 
public function sendCommand ( $ command ) { if ( array_key_exists ( self :: FD_COMMAND , $ this -> _openPipes ) ) { $ this -> _commandBuffer .= $ command . PHP_EOL ; } } 
public function reset ( ) { $ this -> _operation = '' ; $ this -> _arguments = array ( ) ; $ this -> _input = null ; $ this -> _message = null ; $ this -> _output = '' ; $ this -> _commandBuffer = '' ; $ this -> _statusHandlers = array ( ) ; $ this -> _errorHandlers = array ( ) ; if ( $ this -> _debug ) { $ this -> addStatusHandler ( array ( $ this , '_handleDebugStatus' ) ) ; $ this -> addErrorHandler ( array ( $ this , '_handleDebugError' ) ) ; } $ this -> _processHandler = new Crypt_GPG_ProcessHandler ( $ this ) ; $ this -> addStatusHandler ( array ( $ this -> _processHandler , 'handleStatus' ) ) ; $ this -> addErrorHandler ( array ( $ this -> _processHandler , 'handleError' ) ) ; } 
public function run ( ) { if ( $ this -> _operation === '' ) { throw new Crypt_GPG_InvalidOperationException ( 'No GPG operation specified. Use Crypt_GPG_Engine::setOperation() ' . 'before calling Crypt_GPG_Engine::run().' ) ; } $ this -> _openSubprocess ( ) ; $ this -> _process ( ) ; $ this -> _closeSubprocess ( ) ; } 
public function setOperation ( $ operation , array $ arguments = array ( ) ) { $ this -> _operation = $ operation ; $ this -> _arguments = $ arguments ; $ this -> _processHandler -> setOperation ( $ operation ) ; } 
public function setPins ( array $ keys ) { $ envKeys = array ( ) ; foreach ( $ keys as $ keyId => $ key ) { $ envKeys [ $ keyId ] = is_array ( $ key ) ? $ key [ 'passphrase' ] : $ key ; } $ _ENV [ 'PINENTRY_USER_DATA' ] = json_encode ( $ envKeys ) ; } 
public function getVersion ( ) { if ( $ this -> _version == '' ) { $ options = array ( 'homedir' => $ this -> _homedir , 'binary' => $ this -> _binary , 'debug' => $ this -> _debug , 'agent' => $ this -> _agent , ) ; $ engine = new self ( $ options ) ; $ info = '' ; 
public function getProcessData ( $ name ) { if ( $ this -> _processHandler ) { switch ( $ name ) { case 'SignatureInfo' : if ( $ data = $ this -> _processHandler -> getData ( 'SigCreated' ) ) { return new Crypt_GPG_SignatureCreationInfo ( $ data ) ; } break ; case 'Signatures' : case 'Warnings' : return ( array ) $ this -> _processHandler -> getData ( $ name ) ; default : return $ this -> _processHandler -> getData ( $ name ) ; } } } 
public function setProcessData ( $ name , $ value ) { if ( $ this -> _processHandler ) { $ this -> _processHandler -> setData ( $ name , $ value ) ; } } 
private function _process ( ) { $ this -> _debug ( 'BEGIN PROCESSING' ) ; $ this -> _commandBuffer = '' ; 
private function _openSubprocess ( ) { $ version = $ this -> getVersion ( ) ; 
private function _closeSubprocess ( ) { 
private function _closeAgentLaunchProcess ( ) { if ( is_resource ( $ this -> _agentProcess ) ) { $ this -> _debug ( 'CLOSING GPG-AGENT LAUNCH PROCESS' ) ; 
private function _closePipe ( $ pipeNumber ) { $ pipeNumber = intval ( $ pipeNumber ) ; if ( array_key_exists ( $ pipeNumber , $ this -> _openPipes ) ) { fflush ( $ this -> _openPipes [ $ pipeNumber ] ) ; fclose ( $ this -> _openPipes [ $ pipeNumber ] ) ; unset ( $ this -> _openPipes [ $ pipeNumber ] ) ; } } 
private function _closeIdleAgents ( ) { if ( $ this -> _gpgconf ) { 
private function _findBinary ( $ name ) { $ binary = '' ; if ( $ this -> _isDarwin ) { $ locations = array ( '/opt/local/bin/' , 
private function _getPinEntry ( ) { 
private function _debug ( $ text ) { if ( $ this -> _debug ) { if ( php_sapi_name ( ) === 'cli' ) { foreach ( explode ( PHP_EOL , $ text ) as $ line ) { echo "Crypt_GPG DEBUG: " , $ line , PHP_EOL ; } } else if ( is_callable ( $ this -> _debug ) ) { call_user_func ( $ this -> _debug , $ text ) ; } else { 
public function getPrimaryKey ( ) { $ primary_key = null ; if ( count ( $ this -> _subKeys ) > 0 ) { $ primary_key = $ this -> _subKeys [ 0 ] ; } return $ primary_key ; } 
public function canSign ( ) { $ canSign = false ; foreach ( $ this -> _subKeys as $ subKey ) { if ( $ subKey -> canSign ( ) ) { $ canSign = true ; break ; } } return $ canSign ; } 
public function canEncrypt ( ) { $ canEncrypt = false ; foreach ( $ this -> _subKeys as $ subKey ) { if ( $ subKey -> canEncrypt ( ) ) { $ canEncrypt = true ; break ; } } return $ canEncrypt ; } 
public function setLogFilename ( $ filename ) { if ( is_resource ( $ this -> logFile ) ) { fflush ( $ this -> logFile ) ; fclose ( $ this -> logFile ) ; $ this -> logFile = null ; } if ( $ filename != '' ) { if ( ( $ this -> logFile = fopen ( $ filename , 'w' ) ) === false ) { $ this -> log ( 'Unable to open log file "' . $ filename . '" ' . 'for writing.' . PHP_EOL , self :: VERBOSITY_ERRORS ) ; exit ( 1 ) ; } else { stream_set_write_buffer ( $ this -> logFile , 0 ) ; } } return $ this ; } 
protected function log ( $ data , $ level ) { if ( $ this -> verbosity >= $ level ) { if ( is_resource ( $ this -> logFile ) ) { fwrite ( $ this -> logFile , $ data ) ; fflush ( $ this -> logFile ) ; } else { $ this -> parser -> outputter -> stderr ( $ data ) ; } } return $ this ; } 
protected function connect ( ) { 
protected function parseCommand ( $ line ) { $ this -> log ( '<- ' . $ line . PHP_EOL , self :: VERBOSITY_ALL ) ; $ parts = explode ( ' ' , $ line , 2 ) ; $ command = $ parts [ 0 ] ; if ( count ( $ parts ) === 2 ) { $ data = $ parts [ 1 ] ; } else { $ data = null ; } switch ( $ command ) { case 'SETDESC' : return $ this -> sendSetDescription ( $ data ) ; case 'MESSAGE' : return $ this -> sendMessage ( ) ; case 'CONFIRM' : return $ this -> sendConfirm ( ) ; case 'GETINFO' : return $ this -> sendGetInfo ( $ data ) ; case 'GETPIN' : return $ this -> sendGetPin ( $ data ) ; case 'RESET' : return $ this -> sendReset ( ) ; case 'BYE' : return $ this -> sendBye ( ) ; default : return $ this -> sendNotImplementedOK ( ) ; } } 
protected function initPinsFromENV ( ) { if ( ( $ userData = getenv ( 'PINENTRY_USER_DATA' ) ) !== false ) { $ pins = json_decode ( $ userData , true ) ; if ( $ pins === null ) { $ this -> log ( '-- failed to parse user data' . PHP_EOL , self :: VERBOSITY_ERRORS ) ; } else { $ this -> pins = $ pins ; $ this -> log ( '-- got user data [not showing passphrases]' . PHP_EOL , self :: VERBOSITY_ALL ) ; } } return $ this ; } 
protected function disconnect ( ) { $ this -> log ( '-- disconnecting' . PHP_EOL , self :: VERBOSITY_ALL ) ; fflush ( $ this -> stdout ) ; fclose ( $ this -> stdout ) ; fclose ( $ this -> stdin ) ; $ this -> stdin = null ; $ this -> stdout = null ; $ this -> log ( '-- disconnected' . PHP_EOL , self :: VERBOSITY_ALL ) ; if ( is_resource ( $ this -> logFile ) ) { fflush ( $ this -> logFile ) ; fclose ( $ this -> logFile ) ; $ this -> logFile = null ; } return $ this ; } 
protected function sendSetDescription ( $ text ) { $ text = rawurldecode ( $ text ) ; $ matches = array ( ) ; 
protected function sendGetPin ( ) { $ foundPin = '' ; if ( is_array ( $ this -> currentPin ) ) { $ keyIdLength = mb_strlen ( $ this -> currentPin [ 'keyId' ] , '8bit' ) ; 
protected function sendGetInfo ( $ data ) { $ parts = explode ( ' ' , $ data , 2 ) ; $ command = reset ( $ parts ) ; switch ( $ command ) { case 'pid' : return $ this -> sendGetInfoPID ( ) ; default : return $ this -> send ( $ this -> getOK ( ) ) ; } return $ this ; } 
protected function getData ( $ data ) { 
protected function getWordWrappedData ( $ data , $ prefix ) { $ lines = array ( ) ; do { if ( mb_strlen ( $ data , '8bit' ) > 997 ) { $ line = $ prefix . ' ' . mb_strcut ( $ data , 0 , 996 , 'utf-8' ) . "\\\n" ; $ lines [ ] = $ line ; $ lineLength = mb_strlen ( $ line , '8bit' ) - 1 ; $ dataLength = mb_substr ( $ data , '8bit' ) ; $ data = mb_substr ( $ data , $ lineLength , $ dataLength - $ lineLength , '8bit' ) ; } else { $ lines [ ] = $ prefix . ' ' . $ data . "\n" ; $ data = '' ; } } while ( $ data != '' ) ; return implode ( '' , $ lines ) ; } 
protected function send ( $ data ) { $ this -> log ( '-> ' . $ data , self :: VERBOSITY_ALL ) ; fwrite ( $ this -> stdout , $ data ) ; fflush ( $ this -> stdout ) ; return $ this ; } 
public function saveGettextFunctions ( Translations $ translations , array $ options ) { $ functions = $ options [ 'functions' ] ; $ file = $ options [ 'file' ] ; foreach ( $ this -> getFunctions ( $ options [ 'constants' ] ) as $ function ) { list ( $ name , $ line , $ args ) = $ function ; if ( ! isset ( $ functions [ $ name ] ) ) { continue ; } $ context = null ; $ plural = null ; switch ( $ functions [ $ name ] ) { case 'text_domain' : case 'gettext' : list ( $ original , $ domain ) = array_pad ( $ args , 2 , null ) ; break ; case 'text_context_domain' : list ( $ original , $ context , $ domain ) = array_pad ( $ args , 3 , null ) ; break ; case 'single_plural_number_domain' : list ( $ original , $ plural , $ number , $ domain ) = array_pad ( $ args , 4 , null ) ; break ; case 'single_plural_number_context_domain' : list ( $ original , $ plural , $ number , $ context , $ domain ) = array_pad ( $ args , 5 , null ) ; break ; case 'single_plural_domain' : list ( $ original , $ plural , $ domain ) = array_pad ( $ args , 3 , null ) ; break ; case 'single_plural_context_domain' : list ( $ original , $ plural , $ context , $ domain ) = array_pad ( $ args , 4 , null ) ; break ; default : 
public static function toString ( Translations $ translations , array $ options = [ ] ) { $ options += static :: $ options ; $ domain = $ translations -> getDomain ( ) ? : 'messages' ; $ messages = static :: buildMessages ( $ translations ) ; $ configuration = [ '' => [ 'domain' => $ domain , 'lang' => $ translations -> getLanguage ( ) ? : 'en' , 'plural-forms' => $ translations -> getHeader ( 'Plural-Forms' ) ? : 'nplurals=2; plural=(n != 1);' , ] , ] ; $ data = [ 'translation-revision-date' => $ translations -> getHeader ( 'PO-Revision-Date' ) , 'generator' => 'WP-CLI/' . WP_CLI_VERSION , 'source' => $ options [ 'source' ] , 'domain' => $ domain , 'locale_data' => [ $ domain => $ configuration + $ messages , ] , ] ; return json_encode ( $ data , $ options [ 'json' ] ) ; } 
public static function buildMessages ( Translations $ translations ) { $ plural_forms = $ translations -> getPluralForms ( ) ; $ number_of_plurals = is_array ( $ plural_forms ) ? ( $ plural_forms [ 0 ] - 1 ) : null ; $ messages = [ ] ; $ context_glue = chr ( 4 ) ; foreach ( $ translations as $ translation ) { if ( $ translation -> isDisabled ( ) ) { continue ; } $ key = $ translation -> getOriginal ( ) ; if ( $ translation -> hasContext ( ) ) { $ key = $ translation -> getContext ( ) . $ context_glue . $ key ; } if ( $ translation -> hasPluralTranslations ( true ) ) { $ message = $ translation -> getPluralTranslations ( $ number_of_plurals ) ; array_unshift ( $ message , $ translation -> getTranslation ( ) ) ; } else { $ message = [ $ translation -> getTranslation ( ) ] ; } $ messages [ $ key ] = $ message ; } return $ messages ; } 
public static function fromString ( $ string , Translations $ translations , array $ options = [ ] ) { if ( ! array_key_exists ( 'file' , $ options ) || substr ( $ options [ 'file' ] , - 7 ) !== '.js.map' ) { return ; } $ options [ 'file' ] = substr ( $ options [ 'file' ] , 0 , - 7 ) . '.js' ; try { $ options += static :: $ options ; $ map_object = json_decode ( $ string ) ; if ( ! isset ( $ map_object -> sourcesContent ) || ! is_array ( $ map_object -> sourcesContent ) ) { return ; } $ string = implode ( "\n" , $ map_object -> sourcesContent ) ; $ functions = new JsFunctionsScanner ( $ string ) ; $ functions -> enableCommentsExtraction ( $ options [ 'extractComments' ] ) ; $ functions -> saveGettextFunctions ( $ translations , $ options ) ; } catch ( PeastException $ e ) { WP_CLI :: debug ( sprintf ( 'Could not parse file %1$s.map: %2$s (line %3$d, column %4$d in the concatenated sourcesContent)' , $ options [ 'file' ] , $ e -> getMessage ( ) , $ e -> getPosition ( ) -> getLine ( ) , $ e -> getPosition ( ) -> getColumn ( ) ) ) ; } } 
public static function fromString ( $ string , Translations $ translations , array $ options = [ ] ) { try { $ options += static :: $ options ; $ functions = new JsFunctionsScanner ( $ string ) ; $ functions -> enableCommentsExtraction ( $ options [ 'extractComments' ] ) ; $ functions -> saveGettextFunctions ( $ translations , $ options ) ; } catch ( PeastException $ e ) { WP_CLI :: debug ( sprintf ( 'Could not parse file %1$s: %2$s (line %3$d, column %4$d)' , $ options [ 'file' ] , $ e -> getMessage ( ) , $ e -> getPosition ( ) -> getLine ( ) , $ e -> getPosition ( ) -> getColumn ( ) ) ) ; } } 
public static function setCommentBeforeHeaders ( $ comment ) { $ comments = explode ( "\n" , $ comment ) ; foreach ( $ comments as $ line ) { if ( '' !== trim ( $ line ) ) { static :: $ comments_before_headers [ ] = '# ' . $ line ; } } } 
public static function toString ( Translations $ translations , array $ options = [ ] ) { $ lines = static :: $ comments_before_headers ; $ lines [ ] = 'msgid ""' ; $ lines [ ] = 'msgstr ""' ; $ plural_form = $ translations -> getPluralForms ( ) ; $ plural_size = is_array ( $ plural_form ) ? ( $ plural_form [ 0 ] - 1 ) : 1 ; foreach ( $ translations -> getHeaders ( ) as $ name => $ value ) { $ lines [ ] = sprintf ( '"%s: %s\\n"' , $ name , $ value ) ; } $ lines [ ] = '' ; foreach ( $ translations as $ translation ) { if ( $ translation -> hasComments ( ) ) { foreach ( $ translation -> getComments ( ) as $ comment ) { $ lines [ ] = '# ' . $ comment ; } } if ( $ translation -> hasExtractedComments ( ) ) { foreach ( $ translation -> getExtractedComments ( ) as $ comment ) { $ lines [ ] = '#. ' . $ comment ; } } foreach ( $ translation -> getReferences ( ) as $ reference ) { $ lines [ ] = '#: ' . $ reference [ 0 ] . ( null !== $ reference [ 1 ] ? ':' . $ reference [ 1 ] : '' ) ; } if ( $ translation -> hasFlags ( ) ) { $ lines [ ] = '#, ' . implode ( ',' , $ translation -> getFlags ( ) ) ; } $ prefix = $ translation -> isDisabled ( ) ? '#~ ' : '' ; if ( $ translation -> hasContext ( ) ) { $ lines [ ] = $ prefix . 'msgctxt ' . self :: convertString ( $ translation -> getContext ( ) ) ; } self :: addLines ( $ lines , $ prefix . 'msgid' , $ translation -> getOriginal ( ) ) ; if ( $ translation -> hasPlural ( ) ) { self :: addLines ( $ lines , $ prefix . 'msgid_plural' , $ translation -> getPlural ( ) ) ; for ( $ i = 0 ; $ i <= $ plural_size ; $ i ++ ) { self :: addLines ( $ lines , $ prefix . 'msgstr[' . $ i . ']' , '' ) ; } } else { self :: addLines ( $ lines , $ prefix . 'msgstr' , $ translation -> getTranslation ( ) ) ; } $ lines [ ] = '' ; } return implode ( "\n" , $ lines ) ; } 
private static function addLines ( array & $ lines , $ name , $ value ) { $ newlines = self :: multilineQuote ( $ value ) ; if ( count ( $ newlines ) === 1 ) { $ lines [ ] = $ name . ' ' . $ newlines [ 0 ] ; } else { $ lines [ ] = $ name . ' ""' ; foreach ( $ newlines as $ line ) { $ lines [ ] = $ line ; } } } 
public function handle_arguments ( $ args , $ assoc_args ) { $ array_arguments = array ( 'headers' ) ; $ assoc_args = Utils \ parse_shell_arrays ( $ assoc_args , $ array_arguments ) ; $ this -> source = realpath ( $ args [ 0 ] ) ; $ this -> slug = Utils \ get_flag_value ( $ assoc_args , 'slug' , Utils \ basename ( $ this -> source ) ) ; $ this -> skip_js = Utils \ get_flag_value ( $ assoc_args , 'skip-js' , $ this -> skip_js ) ; $ this -> skip_audit = Utils \ get_flag_value ( $ assoc_args , 'skip-audit' , $ this -> skip_audit ) ; $ this -> headers = Utils \ get_flag_value ( $ assoc_args , 'headers' , $ this -> headers ) ; $ this -> file_comment = Utils \ get_flag_value ( $ assoc_args , 'file-comment' ) ; $ this -> package_name = Utils \ get_flag_value ( $ assoc_args , 'package-name' ) ; $ ignore_domain = Utils \ get_flag_value ( $ assoc_args , 'ignore-domain' , false ) ; if ( ! $ this -> source || ! is_dir ( $ this -> source ) ) { WP_CLI :: error ( 'Not a valid source directory!' ) ; } $ this -> main_file_data = $ this -> get_main_file_data ( ) ; if ( $ ignore_domain ) { WP_CLI :: debug ( 'Extracting all strings regardless of text domain' , 'make-pot' ) ; } if ( ! $ ignore_domain ) { $ this -> domain = $ this -> slug ; if ( ! empty ( $ this -> main_file_data [ 'Text Domain' ] ) ) { $ this -> domain = $ this -> main_file_data [ 'Text Domain' ] ; } $ this -> domain = Utils \ get_flag_value ( $ assoc_args , 'domain' , $ this -> domain ) ; WP_CLI :: debug ( sprintf ( 'Extracting all strings with text domain "%s"' , $ this -> domain ) , 'make-pot' ) ; } 
protected function get_main_file_data ( ) { $ files = new IteratorIterator ( new DirectoryIterator ( $ this -> source ) ) ; foreach ( $ files as $ file ) { 
protected function extract_strings ( ) { $ translations = new Translations ( ) ; 
protected function audit_strings ( $ translations ) { foreach ( $ translations as $ translation ) { $ references = $ translation -> getReferences ( ) ; 
protected function get_file_comment ( ) { if ( '' === $ this -> file_comment ) { return '' ; } if ( isset ( $ this -> file_comment ) ) { return implode ( "\n" , explode ( '\n' , $ this -> file_comment ) ) ; } if ( isset ( $ this -> main_file_data [ 'Theme Name' ] ) ) { if ( isset ( $ this -> main_file_data [ 'License' ] ) ) { return sprintf ( "Copyright (C) %1\$s %2\$s\nThis file is distributed under the %3\$s." , date ( 'Y' ) , $ this -> main_file_data [ 'Author' ] , $ this -> main_file_data [ 'License' ] ) ; } return sprintf ( "Copyright (C) %1\$s %2\$s\nThis file is distributed under the same license as the %3\$s theme." , date ( 'Y' ) , $ this -> main_file_data [ 'Author' ] , $ this -> main_file_data [ 'Theme Name' ] ) ; } if ( isset ( $ this -> main_file_data [ 'Plugin Name' ] ) ) { if ( isset ( $ this -> main_file_data [ 'License' ] ) ) { return sprintf ( "Copyright (C) %1\$s %2\$s\nThis file is distributed under the %3\$s." , date ( 'Y' ) , $ this -> main_file_data [ 'Author' ] , $ this -> main_file_data [ 'License' ] ) ; } return sprintf ( "Copyright (C) %1\$s %2\$s\nThis file is distributed under the same license as the %3\$s plugin." , date ( 'Y' ) , $ this -> main_file_data [ 'Author' ] , $ this -> main_file_data [ 'Plugin Name' ] ) ; } return '' ; } 
protected function set_default_headers ( $ translations ) { $ name = null ; $ version = $ this -> get_wp_version ( ) ; $ bugs_address = null ; if ( ! $ version && isset ( $ this -> main_file_data [ 'Version' ] ) ) { $ version = $ this -> main_file_data [ 'Version' ] ; } if ( isset ( $ this -> main_file_data [ 'Theme Name' ] ) ) { $ name = $ this -> main_file_data [ 'Theme Name' ] ; $ bugs_address = sprintf ( 'https://wordpress.org/support/theme/%s' , $ this -> slug ) ; } elseif ( isset ( $ this -> main_file_data [ 'Plugin Name' ] ) ) { $ name = $ this -> main_file_data [ 'Plugin Name' ] ; $ bugs_address = sprintf ( 'https://wordpress.org/support/plugin/%s' , $ this -> slug ) ; } if ( null !== $ this -> package_name ) { $ name = $ this -> package_name ; } if ( null !== $ name ) { $ translations -> setHeader ( 'Project-Id-Version' , $ name . ( $ version ? ' ' . $ version : '' ) ) ; } if ( null !== $ bugs_address ) { $ translations -> setHeader ( 'Report-Msgid-Bugs-To' , $ bugs_address ) ; } $ translations -> setHeader ( 'Last-Translator' , 'FULL NAME <EMAIL@ADDRESS>' ) ; $ translations -> setHeader ( 'Language-Team' , 'LANGUAGE <LL@li.org>' ) ; $ translations -> setHeader ( 'X-Generator' , 'WP-CLI ' . WP_CLI_VERSION ) ; foreach ( $ this -> headers as $ key => $ value ) { $ translations -> setHeader ( $ key , $ value ) ; } } 
private function get_wp_version ( ) { $ version_php = $ this -> source . '/wp-includes/version.php' ; if ( ! file_exists ( $ version_php ) || ! is_readable ( $ version_php ) ) { return false ; } return preg_match ( '/\$wp_version\s*=\s*\'(.*?)\';/' , file_get_contents ( $ version_php ) , $ matches ) ? $ matches [ 1 ] : false ; } 
protected static function get_file_data ( $ file , $ headers ) { 
public static function get_file_data_from_string ( $ string , $ headers ) { foreach ( $ headers as $ field => $ regex ) { if ( preg_match ( '/^[ \t\/*#@]*' . preg_quote ( $ regex , '/' ) . ':(.*)$/mi' , $ string , $ match ) && $ match [ 1 ] ) { $ headers [ $ field ] = static :: _cleanup_header_comment ( $ match [ 1 ] ) ; } else { $ headers [ $ field ] = '' ; } } return $ headers ; } 
public function saveGettextFunctions ( Translations $ translations , array $ options ) { * Traverse through JS code to find and extract gettext functions. * * Make sure translator comments in front of variable declarations * and inside nested call expressions are available when parsing the function call. */ $ traverser -> addFunction ( function ( $ node ) use ( & $ translations , $ options , & $ all_comments ) { $ functions = $ options [ 'functions' ] ; $ file = $ options [ 'file' ] ; foreach ( $ node -> getLeadingComments ( ) as $ comment ) { $ all_comments [ ] = $ comment ; } if ( 'CallExpression' !== $ node -> getType ( ) ) { return ; } $ callee = $ this -> resolveExpressionCallee ( $ node ) ; if ( ! $ callee || ! isset ( $ functions [ $ callee [ 'name' ] ] ) ) { return ; } foreach ( $ node -> getArguments ( ) as $ argument ) { 
private function resolveExpressionCallee ( Node \ CallExpression $ node ) { $ callee = $ node -> getCallee ( ) ; 
private function commentPrecedesNode ( Node \ Comment $ comment , Node \ Node $ node ) { 
public static function fromFile ( $ file , Translations $ translations , array $ options = [ ] ) { foreach ( static :: getFiles ( $ file ) as $ f ) { 
public static function fromDirectory ( $ dir , Translations $ translations , array $ options = [ ] ) { $ dir = Utils \ normalize_path ( $ dir ) ; static :: $ dir = $ dir ; $ include = isset ( $ options [ 'include' ] ) ? $ options [ 'include' ] : [ ] ; $ exclude = isset ( $ options [ 'exclude' ] ) ? $ options [ 'exclude' ] : [ ] ; $ files = static :: getFilesFromDirectory ( $ dir , $ include , $ exclude , $ options [ 'extensions' ] ) ; if ( ! empty ( $ files ) ) { static :: fromFile ( $ files , $ translations , $ options ) ; } static :: $ dir = '' ; } 
protected static function calculateMatchScore ( SplFileInfo $ file , array $ matchers = [ ] ) { if ( empty ( $ matchers ) ) { return 0 ; } if ( in_array ( $ file -> getBasename ( ) , $ matchers , true ) ) { return 10 ; } 
protected static function containsMatchingChildren ( SplFileInfo $ dir , array $ matchers = [ ] ) { if ( empty ( $ matchers ) ) { return false ; } $ root_relative_path = str_replace ( static :: $ dir , '' , $ dir -> getPathname ( ) ) ; foreach ( $ matchers as $ path_or_file ) { 
public static function getFilesFromDirectory ( $ dir , array $ include = [ ] , array $ exclude = [ ] , $ extensions = [ ] ) { $ filtered_files = [ ] ; $ files = new RecursiveIteratorIterator ( new RecursiveCallbackFilterIterator ( new RecursiveDirectoryIterator ( $ dir , RecursiveDirectoryIterator :: SKIP_DOTS | RecursiveDirectoryIterator :: UNIX_PATHS ) , function ( $ file , $ key , $ iterator ) use ( $ include , $ exclude , $ extensions ) { 
protected function make_json ( $ source_file , $ destination ) { $ mapping = [ ] ; $ translations = new Translations ( ) ; $ result = [ ] ; PoExtractor :: fromFile ( $ source_file , $ translations ) ; $ base_file_name = basename ( $ source_file , '.po' ) ; foreach ( $ translations as $ index => $ translation ) { 
protected function build_json_files ( $ mapping , $ base_file_name , $ destination ) { $ result = [ ] ; foreach ( $ mapping as $ file => $ translations ) { $ hash = md5 ( $ file ) ; $ destination_file = "${destination}/{$base_file_name}-{$hash}.json" ; $ success = JedGenerator :: toFile ( $ translations , $ destination_file , [ 'json' => $ this -> json_options , 'source' => $ file , ] ) ; if ( ! $ success ) { WP_CLI :: warning ( sprintf ( 'Could not create file %s' , basename ( $ destination_file , '.json' ) ) ) ; continue ; } $ result [ ] = $ destination_file ; } return $ result ; } 
protected function remove_js_strings_from_po_file ( $ source_file ) { $ translations = new Translations ( ) ; PoExtractor :: fromFile ( $ source_file , $ translations ) ; foreach ( $ translations -> getArrayCopy ( ) as $ translation ) { if ( ! $ translation -> hasReferences ( ) ) { continue ; } foreach ( $ translation -> getReferences ( ) as $ reference ) { $ file = $ reference [ 0 ] ; if ( substr ( $ file , - 3 ) !== '.js' ) { continue 2 ; } } unset ( $ translations [ $ translation -> getId ( ) ] ) ; } return PoGenerator :: toFile ( $ translations , $ source_file ) ; } 
public function blockForm ( $ form , FormStateInterface $ form_state ) { $ form [ 'button_text' ] = [ '#type' => 'textfield' , '#title' => t ( 'Button text' ) , '#default_value' => $ this -> configuration [ 'button_text' ] ?? 'Reset Filters' , ] ; $ form [ 'button_class' ] = [ '#type' => 'textfield' , '#title' => t ( 'Button class' ) , '#default_value' => $ this -> configuration [ 'button_class' ] ?? 'btn btn-outline-primary btn-sm btn-reset' , ] ; $ form [ 'button_target' ] = [ '#type' => 'textfield' , '#title' => t ( 'Button target' ) , '#default_value' => $ this -> configuration [ 'button_target' ] ?? '/products' , ] ; $ form [ 'button_icon_class' ] = [ '#type' => 'textfield' , '#title' => t ( 'Button icon class' ) , '#default_value' => $ this -> configuration [ 'button_icon_class' ] ?? 'fas fa-times' , ] ; return $ form ; } 
public function blockSubmit ( $ form , FormStateInterface $ formState ) { $ this -> configuration [ 'button_text' ] = $ formState -> getValue ( 'button_text' ) ; $ this -> configuration [ 'button_class' ] = $ formState -> getValue ( 'button_class' ) ; $ this -> configuration [ 'button_target' ] = '/' . ltrim ( $ formState -> getValue ( 'button_target' ) , '/' ) ; $ this -> configuration [ 'button_icon_class' ] = $ formState -> getValue ( 'button_icon_class' ) ; } 
public function build ( ) { if ( ! isset ( $ _REQUEST [ 'f' ] ) ) { return [ '#markup' => '' , '#cache' => [ 'contexts' => [ 'url.query_args:f' ] , ] , ] ; } $ link_content_markups = [ ] ; if ( ! empty ( $ this -> configuration [ 'button_icon_class' ] ) ) { $ link_content_markups [ ] = [ '#type' => 'html_tag' , '#tag' => 'span' , '#attributes' => [ 'class' => $ this -> configuration [ 'button_icon_class' ] , ] , ] ; } $ link_content_markups [ ] = [ '#markup' => $ this -> t ( $ this -> configuration [ 'button_text' ] ) , ] ; return [ [ '#type' => 'link' , '#title' => $ link_content_markups , '#attributes' => [ 'class' => $ this -> configuration [ 'button_class' ] , 'target' => '_self' , ] , '#url' => URL :: fromUserInput ( $ this -> configuration [ 'button_target' ] ) , '#cache' => [ 'contexts' => [ 'url.query_args:f' ] , ] , ] , ] ; } 
public function buildForm ( array $ form , FormStateInterface $ form_state ) { if ( empty ( $ this -> paragraph ) ) { return $ form ; } $ form [ 'name' ] = [ '#type' => 'textfield' , '#title_display' => 'invisible' , '#title' => $ this -> t ( 'Name' ) , '#required' => TRUE , '#attributes' => [ 'placeholder' => $ this -> t ( 'Enter your name' ) ] , ] ; $ form [ 'mail' ] = [ '#type' => 'email' , '#title_display' => 'invisible' , '#title' => $ this -> t ( 'E-mail' ) , '#required' => TRUE , '#attributes' => [ 'placeholder' => $ this -> t ( 'Enter you email to get download link' ) ] , ] ; $ file = $ this -> paragraph -> get ( 'field_file_download' ) -> getValue ( ) ; $ form [ 'file_id' ] = [ '#type' => 'value' , '#value' => $ file [ 0 ] [ 'target_id' ] ] ; $ form [ 'submit' ] = [ '#type' => 'submit' , '#value' => $ this -> paragraph -> get ( 'field_d_p_sf_download_button' ) -> value , ] ; 
public function submitForm ( array & $ form , FormStateInterface $ form_state ) { 
public function blockSubmit ( $ form , FormStateInterface $ formState ) { $ this -> configuration [ 'button_text' ] = $ formState -> getValue ( 'button_text' ) ; $ this -> configuration [ 'button_class' ] = $ formState -> getValue ( 'button_class' ) ; } 
public function markUpdatesSuccessful ( array $ names , $ checkListPoints = TRUE ) { if ( $ this -> updateChecklist === FALSE ) { return ; } $ this -> setSuccessfulByHook ( $ names , TRUE ) ; if ( $ checkListPoints ) { $ this -> checkListPoints ( $ names ) ; } } 
public function markAllUpdates ( $ status = TRUE ) { if ( $ this -> updateChecklist === FALSE ) { return ; } $ keys = [ ] ; foreach ( $ this -> updateChecklist -> items as $ versionItems ) { foreach ( $ versionItems as $ key => $ item ) { if ( is_array ( $ item ) ) { $ keys [ ] = $ key ; } } } $ this -> setSuccessfulByHook ( $ keys , $ status ) ; $ this -> checkAllListPoints ( $ status ) ; } 
protected function setSuccessfulByHook ( array $ keys , $ status = TRUE ) { foreach ( $ keys as $ key ) { if ( $ update = Update :: load ( $ key ) ) { $ update -> setSuccessfulByHook ( $ status ) -> save ( ) ; } else { Update :: create ( [ 'id' => $ key , 'successful_by_hook' => $ status , ] ) -> save ( ) ; } } } 
protected function checkListPoints ( array $ names ) { $ drooplerUpdateConfig = $ this -> configFactory -> getEditable ( 'checklistapi.progress.d_update' ) ; $ user = $ this -> account -> id ( ) ; $ time = time ( ) ; foreach ( $ names as $ name ) { if ( $ drooplerUpdateConfig && ! $ drooplerUpdateConfig -> get ( ChecklistapiChecklist :: PROGRESS_CONFIG_KEY . ".#items.$name" ) ) { $ drooplerUpdateConfig -> set ( ChecklistapiChecklist :: PROGRESS_CONFIG_KEY . ".#items.$name" , [ '#completed' => time ( ) , '#uid' => $ user , ] ) ; } } $ drooplerUpdateConfig -> set ( ChecklistapiChecklist :: PROGRESS_CONFIG_KEY . '.#completed_items' , count ( $ drooplerUpdateConfig -> get ( ChecklistapiChecklist :: PROGRESS_CONFIG_KEY . ".#items" ) ) ) -> set ( ChecklistapiChecklist :: PROGRESS_CONFIG_KEY . '.#changed' , $ time ) -> set ( ChecklistapiChecklist :: PROGRESS_CONFIG_KEY . '.#changed_by' , $ user ) -> save ( ) ; } 
protected function checkAllListPoints ( $ status = TRUE ) { $ drooplerUpdateConfig = $ this -> configFactory -> getEditable ( 'checklistapi.progress.d_update' ) ; $ user = $ this -> account -> id ( ) ; $ time = time ( ) ; $ drooplerUpdateConfig -> set ( ChecklistapiChecklist :: PROGRESS_CONFIG_KEY . '.#changed' , $ time ) -> set ( ChecklistapiChecklist :: PROGRESS_CONFIG_KEY . '.#changed_by' , $ user ) ; $ exclude = [ '#title' , '#description' , '#weight' , ] ; foreach ( $ this -> updateChecklist -> items as $ versionItems ) { foreach ( $ versionItems as $ itemName => $ item ) { if ( ! in_array ( $ itemName , $ exclude ) ) { if ( $ status ) { $ drooplerUpdateConfig -> set ( ChecklistapiChecklist :: PROGRESS_CONFIG_KEY . ".#items.$itemName" , [ '#completed' => $ time , '#uid' => $ user , ] ) ; } else { $ drooplerUpdateConfig -> clear ( ChecklistapiChecklist :: PROGRESS_CONFIG_KEY . ".#items.$itemName" ) ; } } } } $ drooplerUpdateConfig -> set ( ChecklistapiChecklist :: PROGRESS_CONFIG_KEY . '.#completed_items' , count ( $ drooplerUpdateConfig -> get ( ChecklistapiChecklist :: PROGRESS_CONFIG_KEY . ".#items" ) ) ) -> save ( ) ; } 
public function saveProgress ( array $ values ) { $ user = \ Drupal :: currentUser ( ) ; $ time = time ( ) ; $ num_changed_items = 0 ; $ progress = [ '#changed' => $ time , '#changed_by' => $ user -> id ( ) , '#completed_items' => 0 , '#items' => [ ] , ] ; $ status = [ 'positive' => [ ] , 'negative' => [ ] , ] ; $ drooplerUpdateConfig = $ this -> configFactory -> getEditable ( 'checklistapi.progress.d_update' ) ; $ savedProgress = $ drooplerUpdateConfig -> get ( ChecklistapiChecklist :: PROGRESS_CONFIG_KEY ) ; foreach ( $ values as $ group_key => $ group ) { foreach ( $ group as $ item_key => $ item ) { $ old_item = ( ! empty ( $ savedProgress [ '#items' ] [ $ item_key ] ) ) ? $ savedProgress [ '#items' ] [ $ item_key ] : 0 ; if ( $ item ) { 
public function getChangedTimeAcrossTranslations ( ) { $ changed = $ this -> getUntranslated ( ) -> getChangedTime ( ) ; foreach ( $ this -> getTranslationLanguages ( FALSE ) as $ language ) { $ translation_changed = $ this -> getTranslation ( $ language -> getId ( ) ) -> getChangedTime ( ) ; $ changed = max ( $ translation_changed , $ changed ) ; } return $ changed ; } 
public function render ( ) { $ output = '<h3>' . t ( 'Droopler is a Drupal 8 profile designed to kickstart a new webpage in a few minutes' ) . '</h3>' ; $ output .= '<p>' . t ( 'More info about Droopler - <a href=":link">See official Droopler website</a>.' , [ ':link' => 'https://droopler.com/' ] ) . '</p>' ; $ output .= '<h3>' . t ( 'Support' ) . '</h3>' ; $ output .= '<p>' . t ( 'Do You need support with Droopler? - <a href=":link">Droptica.com</a>.' , [ ':link' => 'https://droptica.com' ] ) . '</p>' ; $ output .= '<h3>' . t ( 'Github' ) . '</h3>' ; $ output .= '<p>' . t ( '<a href=":link">https://github.com/droptica/droopler_project</a> - Boilerplate for new projects based on Droopler. If you wish to use Droopler - fork (or download) this repository. It contains a minimum set of code to start your new website.' , [ ':link' => 'https://github.com/droptica/droopler_project' ] ) . '</p>' ; $ output .= '<p>' . t ( '<a href=":link">https://github.com/droptica/droopler</a> - This is Drupal installation profile.' , [ ':link' => 'https://github.com/droptica/droopler' ] ) . '</p>' ; return [ '#type' => 'markup' , '#markup' => '<div class="container">' . $ output . '</div>' , ] ; } 
public function generateHashFromDatabase ( $ configName ) { $ config = \ Drupal :: config ( $ configName ) -> getRawData ( ) ; if ( empty ( $ config ) ) { return FALSE ; } unset ( $ config [ 'uuid' ] ) ; unset ( $ config [ 'lang' ] ) ; unset ( $ config [ 'langcode' ] ) ; $ configString = serialize ( $ config ) ; return md5 ( $ configString ) ; } 
public function compare ( $ configName , $ hash = NULL ) { if ( empty ( $ hash ) ) { return TRUE ; } else { return $ this -> generateHashFromDatabase ( $ configName ) == $ hash ; } } 
public function importConfig ( $ module , $ name , $ hash ) { $ configPath = drupal_get_path ( 'module' , $ module ) . '/config/install' ; $ source = new FileStorage ( $ configPath ) ; $ data = $ source -> read ( $ name ) ; if ( ! $ data || ! $ this -> configManager -> compare ( $ name , $ hash ) ) { return false ; } return $ this -> configStorage -> write ( $ name , $ data ) ; } 
public function importConfigs ( array $ configs ) { $ status = [ ] ; foreach ( $ configs as $ module => $ config ) { foreach ( $ config as $ configName => $ configHash ) { $ status [ ] = $ this -> importConfig ( $ module , $ configName , $ configHash ) ; } } return ! in_array ( false , $ status ) ; } 
public function installModules ( array $ modules , $ enableDependencies = TRUE ) { if ( empty ( $ modules ) || ! is_array ( $ modules ) ) { return FALSE ; } $ moduleData = system_rebuild_module_data ( ) ; $ modules = array_combine ( $ modules , $ modules ) ; if ( $ missing_modules = array_diff_key ( $ modules , $ moduleData ) ) { return FALSE ; } return $ this -> moduleInstaller -> install ( $ modules , $ enableDependencies ) ; } 
public function checkLink ( $ link_hash , $ paragraph_id ) { 
private function getSubscribeFileEntity ( $ field_name , $ field_value ) { $ subscribe_file_entity = \ Drupal :: entityTypeManager ( ) -> getStorage ( 'SubscribeFileEntity' ) -> loadByProperties ( [ $ field_name => $ field_value ] ) ; if ( empty ( $ subscribe_file_entity ) ) { throw new NotFoundHttpException ( ) ; } return reset ( $ subscribe_file_entity ) ; } 
private function checkLinkActive ( $ entity ) { $ created = $ entity -> get ( 'created' ) -> get ( 0 ) -> getValue ( ) ; if ( time ( ) > $ created [ 'value' ] + 86400 ) { $ this -> goHomeWithMessage ( t ( 'Link is not active, please add your email again' ) ) ; } } 
private function goHomeWithMessage ( $ message ) { drupal_set_message ( $ message ) ; $ url = Url :: fromRoute ( '<front>' ) ; $ response = new RedirectResponse ( $ url -> toString ( ) ) ; $ response -> send ( ) ; } 
public function getFile ( $ file_hash ) { $ entity = $ this -> getSubscribeFileEntity ( 'file_hash' , $ file_hash ) ; $ this -> checkLinkActive ( $ entity ) ; $ file = File :: load ( $ entity -> get ( 'fid' ) -> getValue ( ) [ 0 ] [ 'value' ] ) ; $ uri = $ file -> getFileUri ( ) ; $ response = new BinaryFileResponse ( $ uri ) ; $ response -> setContentDisposition ( ResponseHeaderBag :: DISPOSITION_ATTACHMENT ) ; return $ response ; } 
public function process ( ContainerBuilder $ container ) { if ( ! $ container -> hasDefinition ( 'apy_grid.registry' ) ) { return ; } $ definition = $ container -> getDefinition ( 'apy_grid.registry' ) ; $ types = $ container -> findTaggedServiceIds ( 'apy_grid.type' ) ; foreach ( $ types as $ id => $ tag ) { $ definition -> addMethodCall ( 'addType' , [ new Reference ( $ id ) ] ) ; } $ columns = $ container -> findTaggedServiceIds ( 'apy_grid.column' ) ; foreach ( $ columns as $ id => $ tag ) { $ definition -> addMethodCall ( 'addColumn' , [ new Reference ( $ id ) ] ) ; } } 
public function getColumnsFromMapping ( $ columnExtensions ) { $ columns = new \ SplObjectStorage ( ) ; foreach ( $ this -> getFields ( ) as $ value ) { $ params = $ this -> getFieldMapping ( $ value ) ; $ type = $ this -> getFieldMappingType ( $ value ) ; if ( $ columnExtensions -> hasExtensionForColumnType ( $ type ) ) { $ column = clone $ columnExtensions -> getExtensionForColumnType ( $ type ) ; $ column -> __initialize ( $ params ) ; $ columns -> attach ( $ column ) ; } else { throw new \ Exception ( sprintf ( 'No suitable Column Extension found for column type: %s' , $ type ) ) ; } } return $ columns ; } 
public function prepareRow ( $ row ) { if ( is_callable ( $ this -> prepareRowCallback ) ) { return call_user_func ( $ this -> prepareRowCallback , $ row ) ; } return $ row ; } 
protected function getItemsFromData ( $ columns ) { $ items = [ ] ; foreach ( $ this -> data as $ key => $ item ) { foreach ( $ columns as $ column ) { $ fieldName = $ column -> getField ( ) ; $ fieldValue = '' ; if ( $ this instanceof Entity ) { 
public function executeFromData ( $ columns , $ page = 0 , $ limit = 0 , $ maxResults = null ) { 
public function getTotalCountFromData ( $ maxResults = null ) { return $ maxResults === null ? $ this -> count : min ( $ this -> count , $ maxResults ) ; } 
protected function prepareStringForLikeCompare ( $ input , $ type = null ) { if ( $ type === 'array' ) { $ outputString = str_replace ( ':{i:0;' , ':{' , serialize ( $ input ) ) ; } else { $ outputString = $ this -> removeAccents ( $ input ) ; } return $ outputString ; } 
public function getConfigTreeBuilder ( ) { $ treeBuilder = new TreeBuilder ( ) ; $ rootNode = $ treeBuilder -> root ( 'apy_data_grid' ) ; $ rootNode -> children ( ) -> arrayNode ( 'limits' ) -> performNoDeepMerging ( ) -> beforeNormalization ( ) -> ifTrue ( function ( $ v ) { return ! is_array ( $ v ) ; } ) -> then ( function ( $ v ) { return [ $ v ] ; } ) -> end ( ) -> defaultValue ( [ 20 => '20' , 50 => '50' , 100 => '100' ] ) -> prototype ( 'scalar' ) -> end ( ) -> end ( ) -> booleanNode ( 'persistence' ) -> defaultFalse ( ) -> end ( ) -> scalarNode ( 'theme' ) -> defaultValue ( 'APYDataGridBundle::blocks.html.twig' ) -> end ( ) -> scalarNode ( 'no_data_message' ) -> defaultValue ( 'No data' ) -> end ( ) -> scalarNode ( 'no_result_message' ) -> defaultValue ( 'No result' ) -> end ( ) -> scalarNode ( 'actions_columns_size' ) -> defaultValue ( - 1 ) -> end ( ) -> scalarNode ( 'actions_columns_title' ) -> defaultValue ( 'Actions' ) -> end ( ) -> scalarNode ( 'actions_columns_separator' ) -> defaultValue ( '<br />' ) -> end ( ) 
public function getPrimaryFieldValue ( ) { if ( null === $ this -> primaryField ) { throw new \ InvalidArgumentException ( 'Primary column must be defined' ) ; } if ( is_array ( $ this -> primaryField ) ) { return array_intersect_key ( $ this -> fields , array_flip ( $ this -> primaryField ) ) ; } if ( ! isset ( $ this -> fields [ $ this -> primaryField ] ) ) { throw new \ InvalidArgumentException ( 'Primary field not added to fields' ) ; } return $ this -> fields [ $ this -> primaryField ] ; } 
public function execute ( $ columns , $ page = 0 , $ limit = 0 , $ maxResults = null , $ gridDataJunction = Column :: DATA_CONJUNCTION ) { return $ this -> executeFromData ( $ columns , $ page , $ limit , $ maxResults ) ; } 
public function setData ( $ data ) { $ this -> data = $ data ; if ( ! is_array ( $ this -> data ) || empty ( $ this -> data ) ) { throw new \ InvalidArgumentException ( 'Data should be an array with content' ) ; } 
public function create ( $ type = null , Source $ source = null , array $ options = [ ] ) { return $ this -> createBuilder ( $ type , $ source , $ options ) -> getGrid ( ) ; } 
public function createBuilder ( $ type = 'grid' , Source $ source = null , array $ options = [ ] ) { $ type = $ this -> resolveType ( $ type ) ; $ options = $ this -> resolveOptions ( $ type , $ source , $ options ) ; $ builder = new GridBuilder ( $ this -> container , $ this , $ type -> getName ( ) , $ options ) ; $ builder -> setType ( $ type ) ; $ type -> buildGrid ( $ builder , $ options ) ; return $ builder ; } 
public function createColumn ( $ name , $ type , array $ options = [ ] ) { if ( ! $ type instanceof Column ) { if ( ! is_string ( $ type ) ) { throw new UnexpectedTypeException ( $ type , 'string, APY\DataGridBundle\Grid\Column\Column' ) ; } $ column = clone $ this -> registry -> getColumn ( $ type ) ; $ column -> __initialize ( array_merge ( [ 'id' => $ name , 'title' => $ name , 'field' => $ name , 'source' => true , ] , $ options ) ) ; } else { $ column = $ type ; $ column -> setId ( $ name ) ; } return $ column ; } 
private function resolveType ( $ type ) { if ( ! $ type instanceof GridTypeInterface ) { if ( ! is_string ( $ type ) ) { throw new UnexpectedTypeException ( $ type , 'string, APY\DataGridBundle\Grid\GridTypeInterface' ) ; } $ type = $ this -> registry -> getType ( $ type ) ; } return $ type ; } 
private function resolveOptions ( GridTypeInterface $ type , Source $ source = null , array $ options = [ ] ) { $ resolver = new OptionsResolver ( ) ; $ type -> configureOptions ( $ resolver ) ; if ( null !== $ source && ! isset ( $ options [ 'source' ] ) ) { $ options [ 'source' ] = $ source ; } $ options = $ resolver -> resolve ( $ options ) ; return $ options ; } 
public function execute ( $ columns , $ page = 0 , $ limit = 0 , $ maxResults = null , $ gridDataJunction = Column :: DATA_CONJUNCTION ) { $ this -> query = $ this -> getQueryBuilder ( ) ; $ validColumns = [ ] ; foreach ( $ columns as $ column ) { 
protected function addReferencedFields ( Row $ row , $ resource ) { foreach ( $ this -> referencedColumns as $ parent => $ subColumns ) { $ node = $ this -> getClassProperties ( $ resource ) ; if ( isset ( $ node [ strtolower ( $ parent ) ] ) ) { $ node = $ node [ strtolower ( $ parent ) ] ; foreach ( $ subColumns as $ field ) { $ getter = 'get' . ucfirst ( $ field ) ; if ( method_exists ( $ node , $ getter ) ) { $ row -> setField ( $ parent . '.' . $ field , $ node -> $ getter ( ) ) ; } else { throw new \ Exception ( sprintf ( 'Method %s for Document %s not exists' , $ getter , $ this -> referencedMappings [ $ parent ] ) ) ; } } } } return $ row ; } 
public function getFieldsMetadata ( $ class , $ group = 'default' ) { $ result = [ ] ; foreach ( $ this -> odmMetadata -> getReflectionProperties ( ) as $ property ) { $ name = $ property -> getName ( ) ; $ mapping = $ this -> odmMetadata -> getFieldMapping ( $ name ) ; $ values = [ 'title' => $ name , 'source' => true ] ; if ( isset ( $ mapping [ 'fieldName' ] ) ) { $ values [ 'field' ] = $ mapping [ 'fieldName' ] ; $ values [ 'id' ] = $ mapping [ 'fieldName' ] ; } if ( isset ( $ mapping [ 'id' ] ) && $ mapping [ 'id' ] == 'id' ) { $ values [ 'primary' ] = true ; } switch ( $ mapping [ 'type' ] ) { case 'id' : case 'string' : case 'bin_custom' : case 'bin_func' : case 'bin_md5' : case 'bin' : case 'bin_uuid' : case 'file' : case 'key' : case 'increment' : $ values [ 'type' ] = 'text' ; break ; case 'int' : case 'float' : $ values [ 'type' ] = 'number' ; break ; case 'boolean' : $ values [ 'type' ] = 'boolean' ; break ; case 'date' : case 'timestamp' : $ values [ 'type' ] = 'date' ; break ; case 'collection' : $ values [ 'type' ] = 'array' ; break ; case 'one' : $ values [ 'type' ] = 'array' ; if ( isset ( $ mapping [ 'reference' ] ) && $ mapping [ 'reference' ] === true ) { $ this -> referencedMappings [ $ name ] = $ mapping [ 'targetDocument' ] ; } break ; case 'many' : $ values [ 'type' ] = 'array' ; break ; default : $ values [ 'type' ] = 'text' ; } $ result [ $ name ] = $ values ; } return $ result ; } 
public function add ( $ name , $ type , array $ options = [ ] ) { if ( ! $ type instanceof Column ) { if ( ! is_string ( $ type ) ) { throw new UnexpectedTypeException ( $ type , 'string, APY\DataGridBundle\Grid\Column\Column' ) ; } $ type = $ this -> factory -> createColumn ( $ name , $ type , $ options ) ; } $ this -> columns [ $ name ] = $ type ; return $ this ; } 
public function get ( $ name ) { if ( ! $ this -> has ( $ name ) ) { throw new InvalidArgumentException ( sprintf ( 'The column with the name "%s" does not exist.' , $ name ) ) ; } $ column = $ this -> columns [ $ name ] ; return $ column ; } 
public function getGrid ( ) { $ config = $ this -> getGridConfig ( ) ; $ grid = new Grid ( $ this -> container , $ config -> getName ( ) , $ config ) ; foreach ( $ this -> columns as $ column ) { $ grid -> addColumn ( $ column ) ; } if ( ! empty ( $ this -> actions ) ) { foreach ( $ this -> actions as $ columnId => $ actions ) { foreach ( $ actions as $ action ) { $ grid -> addRowAction ( $ action ) ; } } } $ grid -> initialize ( ) ; return $ grid ; } 
public function getGrid ( Twig_Environment $ environment , $ grid , $ theme = null , $ id = '' , array $ params = [ ] , $ withjs = true ) { $ this -> initGrid ( $ grid , $ theme , $ id , $ params ) ; 
public function getGridHtml ( Twig_Environment $ environment , $ grid , $ theme = null , $ id = '' , array $ params = [ ] ) { return $ this -> getGrid ( $ environment , $ grid , $ theme , $ id , $ params , false ) ; } 
public function getGrid_ ( Twig_Environment $ environment , $ name , $ grid ) { return $ this -> renderBlock ( $ environment , 'grid_' . $ name , [ 'grid' => $ grid ] ) ; } 
public function getGridPager ( Twig_Environment $ environment , $ grid ) { return $ this -> renderBlock ( $ environment , 'grid_pager' , [ 'grid' => $ grid , 'pagerfanta' => $ this -> pagerFantaDefs [ 'enable' ] ] ) ; } 
public function getGridCell ( Twig_Environment $ environment , $ column , $ row , $ grid ) { $ value = $ column -> renderCell ( $ row -> getField ( $ column -> getId ( ) ) , $ row , $ this -> router ) ; $ id = $ this -> names [ $ grid -> getHash ( ) ] ; if ( ( $ id != '' && ( $ this -> hasBlock ( $ environment , $ block = 'grid_' . $ id . '_column_' . $ column -> getRenderBlockId ( ) . '_cell' ) || $ this -> hasBlock ( $ environment , $ block = 'grid_' . $ id . '_column_' . $ column -> getType ( ) . '_cell' ) || $ this -> hasBlock ( $ environment , $ block = 'grid_' . $ id . '_column_' . $ column -> getParentType ( ) . '_cell' ) || $ this -> hasBlock ( $ environment , $ block = 'grid_' . $ id . '_column_id_' . $ column -> getRenderBlockId ( ) . '_cell' ) || $ this -> hasBlock ( $ environment , $ block = 'grid_' . $ id . '_column_type_' . $ column -> getType ( ) . '_cell' ) || $ this -> hasBlock ( $ environment , $ block = 'grid_' . $ id . '_column_type_' . $ column -> getParentType ( ) . '_cell' ) ) ) || $ this -> hasBlock ( $ environment , $ block = 'grid_column_' . $ column -> getRenderBlockId ( ) . '_cell' ) || $ this -> hasBlock ( $ environment , $ block = 'grid_column_' . $ column -> getType ( ) . '_cell' ) || $ this -> hasBlock ( $ environment , $ block = 'grid_column_' . $ column -> getParentType ( ) . '_cell' ) || $ this -> hasBlock ( $ environment , $ block = 'grid_column_id_' . $ column -> getRenderBlockId ( ) . '_cell' ) || $ this -> hasBlock ( $ environment , $ block = 'grid_column_type_' . $ column -> getType ( ) . '_cell' ) || $ this -> hasBlock ( $ environment , $ block = 'grid_column_type_' . $ column -> getParentType ( ) . '_cell' ) ) { return $ this -> renderBlock ( $ environment , $ block , [ 'grid' => $ grid , 'column' => $ column , 'row' => $ row , 'value' => $ value ] ) ; } return $ this -> renderBlock ( $ environment , 'grid_column_cell' , [ 'grid' => $ grid , 'column' => $ column , 'row' => $ row , 'value' => $ value ] ) ; } 
public function getGridFilter ( Twig_Environment $ environment , $ column , $ grid , $ submitOnChange = true ) { $ id = $ this -> names [ $ grid -> getHash ( ) ] ; if ( ( $ id != '' && ( $ this -> hasBlock ( $ environment , $ block = 'grid_' . $ id . '_column_' . $ column -> getRenderBlockId ( ) . '_filter' ) || $ this -> hasBlock ( $ environment , $ block = 'grid_' . $ id . '_column_id_' . $ column -> getRenderBlockId ( ) . '_filter' ) || $ this -> hasBlock ( $ environment , $ block = 'grid_' . $ id . '_column_type_' . $ column -> getType ( ) . '_filter' ) || $ this -> hasBlock ( $ environment , $ block = 'grid_' . $ id . '_column_type_' . $ column -> getParentType ( ) . '_filter' ) ) || $ this -> hasBlock ( $ environment , $ block = 'grid_' . $ id . '_column_filter_type_' . $ column -> getFilterType ( ) ) ) || $ this -> hasBlock ( $ environment , $ block = 'grid_column_' . $ column -> getRenderBlockId ( ) . '_filter' ) || $ this -> hasBlock ( $ environment , $ block = 'grid_column_id_' . $ column -> getRenderBlockId ( ) . '_filter' ) || $ this -> hasBlock ( $ environment , $ block = 'grid_column_type_' . $ column -> getType ( ) . '_filter' ) || $ this -> hasBlock ( $ environment , $ block = 'grid_column_type_' . $ column -> getParentType ( ) . '_filter' ) || $ this -> hasBlock ( $ environment , $ block = 'grid_column_filter_type_' . $ column -> getFilterType ( ) ) ) { return $ this -> renderBlock ( $ environment , $ block , [ 'grid' => $ grid , 'column' => $ column , 'submitOnChange' => $ submitOnChange && $ column -> isFilterSubmitOnChange ( ) ] ) ; } return '' ; } 
public function getGridColumnOperator ( Twig_Environment $ environment , $ column , $ grid , $ operator , $ submitOnChange = true ) { return $ this -> renderBlock ( $ environment , 'grid_column_operator' , [ 'grid' => $ grid , 'column' => $ column , 'submitOnChange' => $ submitOnChange , 'op' => $ operator ] ) ; } 
public function getGridUrl ( $ section , $ grid , $ param = null ) { $ prefix = $ grid -> getRouteUrl ( ) . ( strpos ( $ grid -> getRouteUrl ( ) , '?' ) ? '&' : '?' ) . $ grid -> getHash ( ) . '[' ; switch ( $ section ) { case 'order' : if ( $ param -> isSorted ( ) ) { return $ prefix . Grid :: REQUEST_QUERY_ORDER . ']=' . $ param -> getId ( ) . '|' . ( $ param -> getOrder ( ) == 'asc' ? 'desc' : 'asc' ) ; } else { return $ prefix . Grid :: REQUEST_QUERY_ORDER . ']=' . $ param -> getId ( ) . '|asc' ; } case 'page' : return $ prefix . Grid :: REQUEST_QUERY_PAGE . ']=' . $ param ; case 'limit' : return $ prefix . Grid :: REQUEST_QUERY_LIMIT . ']=' ; case 'reset' : return $ prefix . Grid :: REQUEST_QUERY_RESET . ']=' ; case 'export' : return $ prefix . Grid :: REQUEST_QUERY_EXPORT . ']=' . $ param ; } } 
public function getGridSearch ( \ Twig_Environment $ environment , $ grid , $ theme = null , $ id = '' , array $ params = [ ] ) { $ this -> initGrid ( $ grid , $ theme , $ id , $ params ) ; return $ this -> renderBlock ( $ environment , 'grid_search' , [ 'grid' => $ grid ] ) ; } 
protected function renderBlock ( Twig_Environment $ environment , $ name , $ parameters ) { foreach ( $ this -> getTemplates ( $ environment ) as $ template ) { if ( $ template -> hasBlock ( $ name , [ ] ) ) { return $ template -> renderBlock ( $ name , array_merge ( $ environment -> getGlobals ( ) , $ parameters , $ this -> params ) ) ; } } throw new \ InvalidArgumentException ( sprintf ( 'Block "%s" doesn\'t exist in grid template "%s".' , $ name , $ this -> theme ) ) ; } 
protected function hasBlock ( Twig_Environment $ environment , $ name ) { foreach ( $ this -> getTemplates ( $ environment ) as $ template ) { if ( $ template -> hasBlock ( $ name , [ ] ) ) { return true ; } } return false ; } 
protected function getTemplates ( Twig_Environment $ environment ) { if ( empty ( $ this -> templates ) ) { if ( $ this -> theme instanceof Twig_Template ) { $ this -> templates [ ] = $ this -> theme ; $ this -> templates [ ] = $ environment -> loadTemplate ( $ this -> defaultTemplate ) ; } elseif ( is_string ( $ this -> theme ) ) { $ this -> templates = $ this -> getTemplatesFromString ( $ environment , $ this -> theme ) ; } elseif ( $ this -> theme === null ) { $ this -> templates = $ this -> getTemplatesFromString ( $ environment , $ this -> defaultTemplate ) ; } else { throw new \ Exception ( 'Unable to load template' ) ; } } return $ this -> templates ; } 
protected function getTemplatesFromString ( Twig_Environment $ environment , $ theme ) { $ this -> templates = [ ] ; $ template = $ environment -> loadTemplate ( $ theme ) ; while ( $ template instanceof \ Twig_Template ) { $ this -> templates [ ] = $ template ; $ template = $ template -> getParent ( [ ] ) ; } return $ this -> templates ; } 
public function walkSelectStatement ( SelectStatement $ AST ) { $ rootComponents = [ ] ; foreach ( $ this -> _getQueryComponents ( ) as $ dqlAlias => $ qComp ) { if ( array_key_exists ( 'parent' , $ qComp ) && $ qComp [ 'parent' ] === null && $ qComp [ 'nestingLevel' ] == 0 ) { $ rootComponents [ ] = [ $ dqlAlias => $ qComp ] ; } } if ( count ( $ rootComponents ) > 1 ) { throw new \ RuntimeException ( 'Cannot count query which selects two FROM components, cannot make distinction' ) ; } $ root = reset ( $ rootComponents ) ; $ parentName = key ( $ root ) ; $ parent = current ( $ root ) ; $ pathExpression = new PathExpression ( PathExpression :: TYPE_STATE_FIELD | PathExpression :: TYPE_SINGLE_VALUED_ASSOCIATION , $ parentName , $ parent [ 'metadata' ] -> getSingleIdentifierFieldName ( ) ) ; $ pathExpression -> type = PathExpression :: TYPE_STATE_FIELD ; 
public function initialize ( ) { $ config = $ this -> config ; if ( ! $ config ) { return $ this ; } $ this -> setPersistence ( $ config -> isPersisted ( ) ) ; 
public function handleRequest ( Request $ request ) { if ( null === $ this -> source ) { throw new \ LogicException ( self :: SOURCE_NOT_SETTED_EX_MSG ) ; } $ this -> request = $ request ; $ this -> session = $ request -> getSession ( ) ; $ this -> createHash ( ) ; $ this -> requestData = $ request -> get ( $ this -> hash ) ; $ this -> processPersistence ( ) ; $ this -> sessionData = ( array ) $ this -> session -> get ( $ this -> hash ) ; $ this -> processLazyParameters ( ) ; if ( ! empty ( $ this -> requestData ) ) { $ this -> processRequestData ( ) ; } if ( $ this -> newSession ) { $ this -> setDefaultSessionData ( ) ; } $ this -> processPermanentFilters ( ) ; $ this -> processSessionData ( ) ; $ this -> prepare ( ) ; return $ this ; } 
public function setSource ( Source $ source ) { if ( $ this -> source !== null ) { throw new \ InvalidArgumentException ( self :: SOURCE_ALREADY_SETTED_EX_MSG ) ; } $ this -> source = $ source ; $ this -> source -> initialise ( $ this -> container ) ; 
public function isReadyForRedirect ( ) { if ( $ this -> source === null ) { throw new \ Exception ( self :: SOURCE_NOT_SETTED_EX_MSG ) ; } if ( $ this -> redirect !== null ) { return $ this -> redirect ; } $ this -> createHash ( ) ; $ this -> requestData = ( array ) $ this -> request -> get ( $ this -> hash ) ; $ this -> processPersistence ( ) ; $ this -> sessionData = ( array ) $ this -> session -> get ( $ this -> hash ) ; $ this -> processLazyParameters ( ) ; 
protected function processRequestData ( ) { $ this -> processMassActions ( $ this -> getFromRequest ( self :: REQUEST_QUERY_MASS_ACTION ) ) ; if ( $ this -> processExports ( $ this -> getFromRequest ( self :: REQUEST_QUERY_EXPORT ) ) || $ this -> processTweaks ( $ this -> getFromRequest ( self :: REQUEST_QUERY_TWEAK ) ) ) { return ; } $ filtering = $ this -> processRequestFilters ( ) ; $ this -> processPage ( $ this -> getFromRequest ( self :: REQUEST_QUERY_PAGE ) , $ filtering ) ; $ this -> processOrder ( $ this -> getFromRequest ( self :: REQUEST_QUERY_ORDER ) ) ; $ this -> processLimit ( $ this -> getFromRequest ( self :: REQUEST_QUERY_LIMIT ) ) ; $ this -> saveSession ( ) ; } 
protected function processMassActions ( $ actionId ) { if ( $ actionId > - 1 && '' !== $ actionId ) { if ( array_key_exists ( $ actionId , $ this -> massActions ) ) { $ action = $ this -> massActions [ $ actionId ] ; $ actionAllKeys = ( boolean ) $ this -> getFromRequest ( self :: REQUEST_QUERY_MASS_ACTION_ALL_KEYS_SELECTED ) ; $ actionKeys = $ actionAllKeys === false ? array_keys ( ( array ) $ this -> getFromRequest ( MassActionColumn :: ID ) ) : [ ] ; $ this -> processSessionData ( ) ; if ( $ actionAllKeys ) { $ this -> page = 0 ; $ this -> limit = 0 ; } $ this -> prepare ( ) ; if ( $ actionAllKeys === true ) { foreach ( $ this -> rows as $ row ) { $ actionKeys [ ] = $ row -> getPrimaryFieldValue ( ) ; } } if ( is_callable ( $ action -> getCallback ( ) ) ) { $ this -> massActionResponse = call_user_func ( $ action -> getCallback ( ) , $ actionKeys , $ actionAllKeys , $ this -> session , $ action -> getParameters ( ) ) ; } elseif ( strpos ( $ action -> getCallback ( ) , ':' ) !== false ) { $ path = array_merge ( [ 'primaryKeys' => $ actionKeys , 'allPrimaryKeys' => $ actionAllKeys , '_controller' => $ action -> getCallback ( ) , ] , $ action -> getParameters ( ) ) ; $ subRequest = $ this -> request -> duplicate ( [ ] , null , $ path ) ; $ this -> massActionResponse = $ this -> container -> get ( 'http_kernel' ) -> handle ( $ subRequest , \ Symfony \ Component \ HttpKernel \ HttpKernelInterface :: SUB_REQUEST ) ; } else { throw new \ RuntimeException ( sprintf ( self :: MASS_ACTION_CALLBACK_NOT_VALID_EX_MSG , $ action -> getCallback ( ) ) ) ; } } else { throw new \ OutOfBoundsException ( sprintf ( self :: MASS_ACTION_NOT_DEFINED_EX_MSG , $ actionId ) ) ; } } } 
protected function processExports ( $ exportId ) { if ( $ exportId > - 1 && '' !== $ exportId ) { if ( array_key_exists ( $ exportId , $ this -> exports ) ) { $ this -> isReadyForExport = true ; $ this -> processSessionData ( ) ; $ this -> page = 0 ; $ this -> limit = 0 ; $ this -> prepare ( ) ; $ export = $ this -> exports [ $ exportId ] ; if ( $ export instanceof ContainerAwareInterface ) { $ export -> setContainer ( $ this -> container ) ; } $ export -> computeData ( $ this ) ; $ this -> exportResponse = $ export -> getResponse ( ) ; return true ; } else { throw new \ OutOfBoundsException ( sprintf ( self :: EXPORT_NOT_DEFINED_EX_MSG , $ exportId ) ) ; } } return false ; } 
protected function processTweaks ( $ tweakId ) { if ( $ tweakId !== null ) { if ( array_key_exists ( $ tweakId , $ this -> tweaks ) ) { $ tweak = $ this -> tweaks [ $ tweakId ] ; $ saveAsActive = false ; if ( isset ( $ tweak [ 'reset' ] ) ) { $ this -> sessionData = [ ] ; $ this -> session -> remove ( $ this -> hash ) ; } if ( isset ( $ tweak [ 'filters' ] ) ) { $ this -> defaultFilters = [ ] ; $ this -> setDefaultFilters ( $ tweak [ 'filters' ] ) ; $ this -> processDefaultFilters ( ) ; $ saveAsActive = true ; } if ( isset ( $ tweak [ 'order' ] ) ) { $ this -> processOrder ( $ tweak [ 'order' ] ) ; $ saveAsActive = true ; } if ( isset ( $ tweak [ 'massAction' ] ) ) { $ this -> processMassActions ( $ tweak [ 'massAction' ] ) ; } if ( isset ( $ tweak [ 'page' ] ) ) { $ this -> processPage ( $ tweak [ 'page' ] ) ; $ saveAsActive = true ; } if ( isset ( $ tweak [ 'limit' ] ) ) { $ this -> processLimit ( $ tweak [ 'limit' ] ) ; $ saveAsActive = true ; } if ( isset ( $ tweak [ 'export' ] ) ) { $ this -> processExports ( $ tweak [ 'export' ] ) ; } if ( $ saveAsActive ) { $ activeTweaks = $ this -> getActiveTweaks ( ) ; $ activeTweaks [ $ tweak [ 'group' ] ] = $ tweakId ; $ this -> set ( 'tweaks' , $ activeTweaks ) ; } if ( isset ( $ tweak [ 'removeActiveTweaksGroups' ] ) ) { $ removeActiveTweaksGroups = ( array ) $ tweak [ 'removeActiveTweaksGroups' ] ; $ activeTweaks = $ this -> getActiveTweaks ( ) ; foreach ( $ removeActiveTweaksGroups as $ id ) { if ( isset ( $ activeTweaks [ $ id ] ) ) { unset ( $ activeTweaks [ $ id ] ) ; } } $ this -> set ( 'tweaks' , $ activeTweaks ) ; } if ( isset ( $ tweak [ 'removeActiveTweaks' ] ) ) { $ removeActiveTweaks = ( array ) $ tweak [ 'removeActiveTweaks' ] ; $ activeTweaks = $ this -> getActiveTweaks ( ) ; foreach ( $ removeActiveTweaks as $ id ) { if ( array_key_exists ( $ id , $ this -> tweaks ) ) { if ( isset ( $ activeTweaks [ $ this -> tweaks [ $ id ] [ 'group' ] ] ) ) { unset ( $ activeTweaks [ $ this -> tweaks [ $ id ] [ 'group' ] ] ) ; } } } $ this -> set ( 'tweaks' , $ activeTweaks ) ; } if ( isset ( $ tweak [ 'addActiveTweaks' ] ) ) { $ addActiveTweaks = ( array ) $ tweak [ 'addActiveTweaks' ] ; $ activeTweaks = $ this -> getActiveTweaks ( ) ; foreach ( $ addActiveTweaks as $ id ) { if ( array_key_exists ( $ id , $ this -> tweaks ) ) { $ activeTweaks [ $ this -> tweaks [ $ id ] [ 'group' ] ] = $ id ; } } $ this -> set ( 'tweaks' , $ activeTweaks ) ; } $ this -> saveSession ( ) ; return true ; } else { throw new \ OutOfBoundsException ( sprintf ( self :: TWEAK_NOT_DEFINED_EX_MSG , $ tweakId ) ) ; } } return false ; } 
protected function processFilters ( $ permanent = true ) { foreach ( ( $ permanent ? $ this -> permanentFilters : $ this -> defaultFilters ) as $ columnId => $ value ) { $ column = $ this -> columns -> getColumnById ( $ columnId ) ; if ( $ permanent ) { 
protected function processSessionData ( ) { 
protected function prepare ( ) { if ( $ this -> prepared ) { return $ this ; } if ( $ this -> source -> isDataLoaded ( ) ) { $ this -> rows = $ this -> source -> executeFromData ( $ this -> columns -> getIterator ( true ) , $ this -> page , $ this -> limit , $ this -> maxResults ) ; } else { $ this -> rows = $ this -> source -> execute ( $ this -> columns -> getIterator ( true ) , $ this -> page , $ this -> limit , $ this -> maxResults , $ this -> dataJunction ) ; } if ( ! $ this -> rows instanceof Rows ) { throw new \ Exception ( self :: NO_ROWS_RETURNED_EX_MSG ) ; } if ( count ( $ this -> rows ) == 0 && $ this -> page > 0 ) { $ this -> page = 0 ; $ this -> prepare ( ) ; return $ this ; } 
protected function set ( $ key , $ data ) { 
public function getColumn ( $ columnId ) { foreach ( $ this -> lazyAddColumn as $ column ) { if ( $ column [ 'column' ] -> getId ( ) == $ columnId ) { return $ column [ 'column' ] ; } } return $ this -> columns -> getColumnById ( $ columnId ) ; } 
public function hasColumn ( $ columnId ) { foreach ( $ this -> lazyAddColumn as $ column ) { if ( $ column [ 'column' ] -> getId ( ) == $ columnId ) { return true ; } } return $ this -> columns -> hasColumnById ( $ columnId ) ; } 
public function setColumnsOrder ( array $ columnIds , $ keepOtherColumns = true ) { $ this -> columns -> setColumnsOrder ( $ columnIds , $ keepOtherColumns ) ; return $ this ; } 
public function addMassAction ( MassActionInterface $ action ) { if ( $ action -> getRole ( ) === null || $ this -> securityContext -> isGranted ( $ action -> getRole ( ) ) ) { $ this -> massActions [ ] = $ action ; } return $ this ; } 
public function addTweak ( $ title , array $ tweak , $ id = null , $ group = null ) { if ( $ id !== null && ! preg_match ( '/^[0-9a-zA-Z_\+-]+$/' , $ id ) ) { throw new \ InvalidArgumentException ( sprintf ( self :: TWEAK_MALFORMED_ID_EX_MSG , $ id ) ) ; } $ tweak = array_merge ( [ 'id' => $ id , 'title' => $ title , 'group' => $ group ] , $ tweak ) ; if ( isset ( $ id ) ) { $ this -> tweaks [ $ id ] = $ tweak ; } else { $ this -> tweaks [ ] = $ tweak ; } return $ this ; } 
public function getTweaks ( ) { $ separator = strpos ( $ this -> getRouteUrl ( ) , '?' ) ? '&' : '?' ; $ url = $ this -> getRouteUrl ( ) . $ separator . $ this -> getHash ( ) . '[' . self :: REQUEST_QUERY_TWEAK . ']=' ; foreach ( $ this -> tweaks as $ id => $ tweak ) { $ this -> tweaks [ $ id ] = array_merge ( $ tweak , [ 'url' => $ url . $ id ] ) ; } return $ this -> tweaks ; } 
public function getTweak ( $ id ) { $ tweaks = $ this -> getTweaks ( ) ; if ( isset ( $ tweaks [ $ id ] ) ) { return $ tweaks [ $ id ] ; } throw new \ InvalidArgumentException ( sprintf ( self :: NOT_VALID_TWEAK_ID_EX_MSG , $ id ) ) ; } 
public function getTweaksGroup ( $ group ) { $ tweaksGroup = $ this -> getTweaks ( ) ; foreach ( $ tweaksGroup as $ id => $ tweak ) { if ( $ tweak [ 'group' ] != $ group ) { unset ( $ tweaksGroup [ $ id ] ) ; } } return $ tweaksGroup ; } 
public function addRowAction ( RowActionInterface $ action ) { if ( $ action -> getRole ( ) === null || $ this -> securityContext -> isGranted ( $ action -> getRole ( ) ) ) { $ this -> rowActions [ $ action -> getColumn ( ) ] [ ] = $ action ; } return $ this ; } 
public function setTemplate ( $ template ) { if ( $ template !== null ) { if ( $ template instanceof \ Twig_Template ) { $ template = '__SELF__' . $ template -> getTemplateName ( ) ; } elseif ( ! is_string ( $ template ) ) { throw new \ Exception ( self :: TWIG_TEMPLATE_LOAD_EX_MSG ) ; } $ this -> set ( self :: REQUEST_QUERY_TEMPLATE , $ template ) ; $ this -> saveSession ( ) ; } return $ this ; } 
public function addExport ( ExportInterface $ export ) { if ( $ export -> getRole ( ) === null || $ this -> securityContext -> isGranted ( $ export -> getRole ( ) ) ) { $ this -> exports [ ] = $ export ; } return $ this ; } 
public function getRouteUrl ( ) { if ( $ this -> routeUrl === null ) { $ this -> routeUrl = $ this -> router -> generate ( $ this -> request -> get ( '_route' ) , $ this -> getRouteParameters ( ) ) ; } return $ this -> routeUrl ; } 
protected function setFilters ( array $ filters , $ permanent = true ) { foreach ( $ filters as $ columnId => $ value ) { if ( $ permanent ) { $ this -> permanentFilters [ $ columnId ] = $ value ; } else { $ this -> defaultFilters [ $ columnId ] = $ value ; } } return $ this ; } 
public function setLimits ( $ limits ) { if ( is_array ( $ limits ) ) { if ( ( int ) key ( $ limits ) === 0 ) { $ this -> limits = array_combine ( $ limits , $ limits ) ; } else { $ this -> limits = $ limits ; } } elseif ( is_int ( $ limits ) ) { $ this -> limits = [ $ limits => ( string ) $ limits ] ; } else { throw new \ InvalidArgumentException ( self :: NOT_VALID_LIMIT_EX_MSG ) ; } return $ this ; } 
public function setPage ( $ page ) { if ( ( int ) $ page >= 0 ) { $ this -> page = ( int ) $ page ; } else { throw new \ InvalidArgumentException ( self :: PAGE_NOT_VALID_EX_MSG ) ; } return $ this ; } 
public function getPageCount ( ) { $ pageCount = 1 ; if ( $ this -> getLimit ( ) > 0 ) { $ pageCount = ceil ( $ this -> getTotalCount ( ) / $ this -> getLimit ( ) ) ; } 
public function setMaxResults ( $ maxResults = null ) { if ( ( is_int ( $ maxResults ) && $ maxResults < 0 ) && $ maxResults !== null ) { throw new \ InvalidArgumentException ( self :: NOT_VALID_MAX_RESULT_EX_MSG ) ; } $ this -> maxResults = $ maxResults ; return $ this ; } 
public function isTitleSectionVisible ( ) { if ( $ this -> showTitles === true ) { foreach ( $ this -> columns as $ column ) { if ( $ column -> getTitle ( ) != '' ) { return true ; } } } return false ; } 
public function isFilterSectionVisible ( ) { if ( $ this -> showFilters === true ) { foreach ( $ this -> columns as $ column ) { if ( $ column -> isFilterable ( ) && $ column -> getType ( ) != 'massaction' && $ column -> getType ( ) != 'actions' ) { return true ; } } } return false ; } 
public function isPagerSectionVisible ( ) { $ limits = $ this -> getLimits ( ) ; if ( empty ( $ limits ) ) { return false ; } 
public function showColumns ( $ columnIds ) { foreach ( ( array ) $ columnIds as $ columnId ) { $ this -> lazyHideShowColumns [ $ columnId ] = true ; } return $ this ; } 
public function hideColumns ( $ columnIds ) { foreach ( ( array ) $ columnIds as $ columnId ) { $ this -> lazyHideShowColumns [ $ columnId ] = false ; } return $ this ; } 
public function getGridResponse ( $ param1 = null , $ param2 = null , Response $ response = null ) { $ isReadyForRedirect = $ this -> isReadyForRedirect ( ) ; if ( $ this -> isReadyForExport ( ) ) { return $ this -> getExportResponse ( ) ; } if ( $ this -> isMassActionRedirect ( ) ) { return $ this -> getMassActionResponse ( ) ; } if ( $ isReadyForRedirect ) { return new RedirectResponse ( $ this -> getRouteUrl ( ) ) ; } else { if ( is_array ( $ param1 ) || $ param1 === null ) { $ parameters = ( array ) $ param1 ; $ view = $ param2 ; } else { $ parameters = ( array ) $ param2 ; $ view = $ param1 ; } $ parameters = array_merge ( [ 'grid' => $ this ] , $ parameters ) ; if ( $ view === null ) { return $ parameters ; } else { return $ this -> container -> get ( 'templating' ) -> renderResponse ( $ view , $ parameters , $ response ) ; } } } 
public function getRawData ( $ columnNames = null , $ namedIndexes = true ) { if ( $ columnNames === null ) { foreach ( $ this -> getColumns ( ) as $ column ) { $ columnNames [ ] = $ column -> getId ( ) ; } } $ columnNames = ( array ) $ columnNames ; $ result = [ ] ; foreach ( $ this -> rows as $ row ) { $ resultRow = [ ] ; foreach ( $ columnNames as $ columnName ) { if ( $ namedIndexes ) { $ resultRow [ $ columnName ] = $ row -> getField ( $ columnName ) ; } else { $ resultRow [ ] = $ row -> getField ( $ columnName ) ; } } $ result [ ] = $ resultRow ; } return $ result ; } 
public function getFilters ( ) { if ( $ this -> hash === null ) { throw new \ Exception ( self :: GET_FILTERS_NO_REQUEST_HANDLED_EX_MSG ) ; } if ( $ this -> sessionFilters === null ) { $ this -> sessionFilters = [ ] ; $ session = $ this -> sessionData ; $ requestQueries = [ self :: REQUEST_QUERY_MASS_ACTION_ALL_KEYS_SELECTED , self :: REQUEST_QUERY_MASS_ACTION , self :: REQUEST_QUERY_EXPORT , self :: REQUEST_QUERY_PAGE , self :: REQUEST_QUERY_LIMIT , self :: REQUEST_QUERY_ORDER , self :: REQUEST_QUERY_TEMPLATE , self :: REQUEST_QUERY_RESET , MassActionColumn :: ID , ] ; foreach ( $ requestQueries as $ request_query ) { unset ( $ session [ $ request_query ] ) ; } foreach ( $ session as $ columnId => $ sessionFilter ) { if ( isset ( $ sessionFilter [ 'operator' ] ) ) { $ operator = $ sessionFilter [ 'operator' ] ; unset ( $ sessionFilter [ 'operator' ] ) ; } else { $ operator = $ this -> getColumn ( $ columnId ) -> getDefaultOperator ( ) ; } if ( ! isset ( $ sessionFilter [ 'to' ] ) && isset ( $ sessionFilter [ 'from' ] ) ) { $ sessionFilter = $ sessionFilter [ 'from' ] ; } $ this -> sessionFilters [ $ columnId ] = new Filter ( $ operator , $ sessionFilter ) ; } } return $ this -> sessionFilters ; } 
public function getFilter ( $ columnId ) { if ( $ this -> hash === null ) { throw new \ Exception ( self :: GET_FILTERS_NO_REQUEST_HANDLED_EX_MSG ) ; } $ sessionFilters = $ this -> getFilters ( ) ; return isset ( $ sessionFilters [ $ columnId ] ) ? $ sessionFilters [ $ columnId ] : null ; } 
public function hasFilter ( $ columnId ) { if ( $ this -> hash === null ) { throw new \ Exception ( self :: HAS_FILTER_NO_REQUEST_HANDLED_EX_MSG ) ; } return $ this -> getFilter ( $ columnId ) !== null ; } 
protected function getTranslationFieldNameWithParents ( $ column ) { $ name = $ column -> getField ( ) ; if ( $ column -> getIsManualField ( ) ) { return $ column -> getField ( ) ; } if ( strpos ( $ name , '.' ) !== false ) { $ previousParent = '' ; $ elements = explode ( '.' , $ name ) ; while ( $ element = array_shift ( $ elements ) ) { if ( count ( $ elements ) > 0 ) { $ previousParent .= '_' . $ element ; } } } elseif ( strpos ( $ name , ':' ) !== false ) { $ previousParent = $ this -> getTableAlias ( ) ; } else { return $ this -> getTableAlias ( ) . '.' . $ name ; } $ matches = array ( ) ; if ( $ column -> hasDQLFunction ( $ matches ) ) { return $ previousParent . '.' . $ matches [ 'field' ] ; } return $ column -> getField ( ) ; } 
protected function getGroupByFieldName ( $ fieldName ) { if ( strpos ( $ fieldName , '.' ) !== false ) { $ previousParent = '' ; $ elements = explode ( '.' , $ fieldName ) ; while ( $ element = array_shift ( $ elements ) ) { if ( count ( $ elements ) > 0 ) { $ previousParent .= '_' . $ element ; } else { $ name = $ previousParent . '.' . $ element ; } } } else { if ( ( $ pos = strpos ( $ fieldName , ':' ) ) !== false ) { $ fieldName = substr ( $ fieldName , 0 , $ pos ) ; } return $ this -> getTableAlias ( ) . '.' . $ fieldName ; } return $ name ; } 
public function initQueryBuilder ( QueryBuilder $ queryBuilder ) { $ this -> queryBuilder = clone $ queryBuilder ; 
public function execute ( $ columns , $ page = 0 , $ limit = 0 , $ maxResults = null , $ gridDataJunction = Column :: DATA_CONJUNCTION ) { $ this -> query = $ this -> getQueryBuilder ( ) ; $ this -> querySelectfromSource = clone $ this -> query ; $ bindIndex = 123 ; $ serializeColumns = [ ] ; $ where = $ gridDataJunction === Column :: DATA_CONJUNCTION ? $ this -> query -> expr ( ) -> andx ( ) : $ this -> query -> expr ( ) -> orx ( ) ; $ columnsById = [ ] ; foreach ( $ columns as $ column ) { $ columnsById [ $ column -> getId ( ) ] = $ column ; } foreach ( $ columns as $ column ) { 
public function renderCell ( $ value , $ row , $ router ) { if ( is_callable ( $ this -> callback ) ) { return call_user_func ( $ this -> callback , $ value , $ row , $ router ) ; } $ value = is_bool ( $ value ) ? ( int ) $ value : $ value ; if ( array_key_exists ( ( string ) $ value , $ this -> values ) ) { $ value = $ this -> values [ $ value ] ; } return $ value ; } 
public function isVisible ( $ isExported = false ) { $ visible = $ isExported && $ this -> export !== null ? $ this -> export : $ this -> visible ; if ( $ visible && $ this -> authorizationChecker !== null && $ this -> getRole ( ) !== null ) { return $ this -> authorizationChecker -> isGranted ( $ this -> getRole ( ) ) ; } return $ visible ; } 
public function setOrder ( $ order ) { if ( $ order !== null ) { $ this -> order = $ order ; $ this -> isSorted = true ; } return $ this ; } 
public function setSize ( $ size ) { if ( $ size < - 1 ) { throw new \ InvalidArgumentException ( sprintf ( 'Unsupported column size %s, use positive value or -1 for auto resize' , $ size ) ) ; } $ this -> size = $ size ; return $ this ; } 
public function setData ( $ data ) { $ this -> data = [ 'operator' => $ this -> getDefaultOperator ( ) , 'from' => static :: DEFAULT_VALUE , 'to' => static :: DEFAULT_VALUE ] ; $ hasValue = false ; if ( isset ( $ data [ 'from' ] ) && $ this -> isQueryValid ( $ data [ 'from' ] ) ) { $ this -> data [ 'from' ] = $ data [ 'from' ] ; $ hasValue = true ; } if ( isset ( $ data [ 'to' ] ) && $ this -> isQueryValid ( $ data [ 'to' ] ) ) { $ this -> data [ 'to' ] = $ data [ 'to' ] ; $ hasValue = true ; } $ isNullOperator = ( isset ( $ data [ 'operator' ] ) && ( $ data [ 'operator' ] === self :: OPERATOR_ISNULL || $ data [ 'operator' ] === self :: OPERATOR_ISNOTNULL ) ) ; if ( ( $ hasValue || $ isNullOperator ) && isset ( $ data [ 'operator' ] ) && $ this -> hasOperator ( $ data [ 'operator' ] ) ) { $ this -> data [ 'operator' ] = $ data [ 'operator' ] ; } return $ this ; } 
public function getData ( ) { $ result = [ ] ; $ hasValue = false ; if ( $ this -> data [ 'from' ] != $ this :: DEFAULT_VALUE ) { $ result [ 'from' ] = $ this -> data [ 'from' ] ; $ hasValue = true ; } if ( $ this -> data [ 'to' ] != $ this :: DEFAULT_VALUE ) { $ result [ 'to' ] = $ this -> data [ 'to' ] ; $ hasValue = true ; } $ isNullOperator = ( isset ( $ this -> data [ 'operator' ] ) && ( $ this -> data [ 'operator' ] === self :: OPERATOR_ISNULL || $ this -> data [ 'operator' ] === self :: OPERATOR_ISNOTNULL ) ) ; if ( $ hasValue || $ isNullOperator ) { $ result [ 'operator' ] = $ this -> data [ 'operator' ] ; } return $ result ; } 
public function setAlign ( $ align ) { if ( ! in_array ( $ align , self :: $ aligns ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Unsupported align %s, just left, right and center are supported' , $ align ) ) ; } $ this -> align = $ align ; return $ this ; } 
public function getOperators ( ) { 
public function addColumn ( Column $ column , $ position = 0 ) { $ column -> setAuthorizationChecker ( $ this -> authorizationChecker ) ; if ( $ position == 0 ) { $ this -> columns [ ] = $ column ; } else { if ( $ position > 0 ) { -- $ position ; } else { $ position = max ( 0 , count ( $ this -> columns ) + $ position ) ; } $ head = array_slice ( $ this -> columns , 0 , $ position ) ; $ tail = array_slice ( $ this -> columns , $ position ) ; $ this -> columns = array_merge ( $ head , [ $ column ] , $ tail ) ; } return $ this ; } 
public function getColumnById ( $ columnId ) { if ( ( $ column = $ this -> hasColumnById ( $ columnId , true ) ) === false ) { throw new \ InvalidArgumentException ( sprintf ( self :: MISSING_COLUMN_EX_MSG , $ columnId ) ) ; } return $ column ; } 
public function hasColumnById ( $ columnId , $ returnColumn = false ) { foreach ( $ this -> columns as $ column ) { if ( $ column -> getId ( ) == $ columnId ) { return $ returnColumn ? $ column : true ; } } return false ; } 
public function setColumnsOrder ( array $ columnIds , $ keepOtherColumns = true ) { $ reorderedColumns = [ ] ; $ columnsIndexedByIds = [ ] ; foreach ( $ this -> columns as $ column ) { $ columnsIndexedByIds [ $ column -> getId ( ) ] = $ column ; } foreach ( $ columnIds as $ columnId ) { if ( isset ( $ columnsIndexedByIds [ $ columnId ] ) ) { $ reorderedColumns [ ] = $ columnsIndexedByIds [ $ columnId ] ; unset ( $ columnsIndexedByIds [ $ columnId ] ) ; } } if ( $ keepOtherColumns ) { $ this -> columns = array_merge ( $ reorderedColumns , array_values ( $ columnsIndexedByIds ) ) ; } else { $ this -> columns = $ reorderedColumns ; } return $ this ; } 
public function createGrid ( $ id = null ) { $ grid = $ this -> container -> get ( 'grid' ) ; if ( $ id !== null ) { $ grid -> setId ( $ id ) ; } $ this -> grids -> attach ( $ grid ) ; return $ grid ; } 
public function getGridManagerResponse ( $ param1 = null , $ param2 = null , Response $ response = null ) { $ isReadyForRedirect = $ this -> isReadyForRedirect ( ) ; if ( $ this -> isReadyForExport ( ) ) { return $ this -> exportGrid -> getExportResponse ( ) ; } if ( $ this -> isMassActionRedirect ( ) ) { return $ this -> massActionGrid -> getMassActionResponse ( ) ; } if ( $ isReadyForRedirect ) { return new RedirectResponse ( $ this -> getRouteUrl ( ) ) ; } else { if ( is_array ( $ param1 ) || $ param1 === null ) { $ parameters = ( array ) $ param1 ; $ view = $ param2 ; } else { $ parameters = ( array ) $ param2 ; $ view = $ param1 ; } $ i = 1 ; $ this -> grids -> rewind ( ) ; while ( $ this -> grids -> valid ( ) ) { $ parameters = array_merge ( [ 'grid' . $ i => $ this -> grids -> current ( ) ] , $ parameters ) ; $ this -> grids -> next ( ) ; ++ $ i ; } if ( $ view === null ) { return $ parameters ; } return $ this -> container -> get ( 'templating' ) -> renderResponse ( $ view , $ parameters , $ response ) ; } } 
public function buildGrid ( GridBuilder $ builder , array $ options = [ ] ) { $ builder -> setRoute ( $ options [ 'route' ] ) -> setRouteParameters ( $ options [ 'route_parameters' ] ) -> setPersistence ( $ options [ 'persistence' ] ) -> setPage ( $ options [ 'page' ] ) -> setMaxResults ( $ options [ 'max_results' ] ) -> setMaxPerPage ( $ options [ 'max_per_page' ] ) -> setFilterable ( $ options [ 'filterable' ] ) -> setSortable ( $ options [ 'sortable' ] ) -> setSortBy ( $ options [ 'sort_by' ] ) -> setOrder ( $ options [ 'order' ] ) -> setGroupBy ( $ options [ 'group_by' ] ) ; if ( ! empty ( $ options [ 'source' ] ) ) { $ builder -> setSource ( $ options [ 'source' ] ) ; } } 
public function configureOptions ( OptionsResolver $ resolver ) { $ resolver -> setDefaults ( [ 'source' => null , 'group_by' => null , 'sort_by' => null , 'order' => 'asc' , 'page' => 1 , 'route' => '' , 'route_parameters' => [ ] , 'persistence' => false , 'max_per_page' => 10 , 'max_results' => null , 'filterable' => true , 'sortable' => true , ] ) ; $ allowedTypes = [ 'source' => [ 'null' , 'APY\DataGridBundle\Grid\Source\Source' ] , 'group_by' => [ 'null' , 'string' , 'array' ] , 'route_parameters' => 'array' , 'persistence' => 'bool' , 'filterable' => 'bool' , 'sortable' => 'bool' , ] ; $ allowedValues = [ 'order' => [ 'asc' , 'desc' ] , ] ; if ( method_exists ( $ resolver , 'setDefault' ) ) { 
protected function getDatetime ( $ data , \ DateTimeZone $ timezone ) { if ( $ data instanceof \ DateTime || $ data instanceof \ DateTimeImmutable ) { return $ data -> setTimezone ( $ timezone ) ; } 
public function addRouteParameters ( $ routeParameters ) { $ routeParameters = ( array ) $ routeParameters ; foreach ( $ routeParameters as $ key => $ routeParameter ) { if ( is_int ( $ key ) ) { $ this -> routeParameters [ ] = $ routeParameter ; } else { $ this -> routeParameters [ $ key ] = $ routeParameter ; } } return $ this ; } 
public function getRouteParametersMapping ( $ name ) { return isset ( $ this -> routeParametersMapping [ $ name ] ) ? $ this -> routeParametersMapping [ $ name ] : null ; } 
public function render ( $ row ) { foreach ( $ this -> callbacks as $ callback ) { if ( is_callable ( $ callback ) ) { if ( null === call_user_func ( $ callback , $ this , $ row ) ) { return ; } } } return $ this ; } 
public function addType ( GridTypeInterface $ type ) { $ name = $ type -> getName ( ) ; if ( $ this -> hasType ( $ name ) ) { throw new TypeAlreadyExistsException ( $ name ) ; } $ this -> types [ $ name ] = $ type ; return $ this ; } 
public function getType ( $ name ) { if ( ! $ this -> hasType ( $ name ) ) { throw new TypeNotFoundException ( $ name ) ; } $ type = $ this -> types [ $ name ] ; return $ type ; } 
public function addColumn ( Column $ column ) { $ type = $ column -> getType ( ) ; if ( $ this -> hasColumn ( $ type ) ) { throw new ColumnAlreadyExistsException ( $ type ) ; } $ this -> columns [ $ type ] = $ column ; return $ this ; } 
public function getColumn ( $ type ) { if ( ! $ this -> hasColumn ( $ type ) ) { throw new ColumnNotFoundException ( $ type ) ; } $ column = $ this -> columns [ $ type ] ; return $ column ; } 
public function setContainer ( ContainerInterface $ container = null ) { $ this -> container = $ container ; $ this -> twig = $ this -> container -> get ( 'twig' ) ; return $ this ; } 
public function getResponse ( ) { 
protected function getGridData ( $ grid ) { $ result = [ ] ; $ this -> grid = $ grid ; if ( $ this -> grid -> isTitleSectionVisible ( ) ) { $ result [ 'titles' ] = $ this -> getGridTitles ( ) ; } $ result [ 'rows' ] = $ this -> getGridRows ( ) ; return $ result ; } 
protected function getFlatGridData ( $ grid ) { $ data = $ this -> getGridData ( $ grid ) ; $ flatData = [ ] ; if ( isset ( $ data [ 'titles' ] ) ) { $ flatData [ ] = $ data [ 'titles' ] ; } return array_merge ( $ flatData , $ data [ 'rows' ] ) ; } 
protected function renderBlock ( $ name , $ parameters ) { foreach ( $ this -> getTemplates ( ) as $ template ) { if ( $ template -> hasBlock ( $ name , [ ] ) ) { return $ template -> renderBlock ( $ name , array_merge ( $ parameters , $ this -> params ) ) ; } } throw new \ InvalidArgumentException ( sprintf ( 'Block "%s" doesn\'t exist in grid template "%s".' , $ name , 'ee' ) ) ; } 
protected function getTemplates ( ) { if ( empty ( $ this -> templates ) ) { $ this -> setTemplate ( $ this -> grid -> getTemplate ( ) ) ; } return $ this -> templates ; } 
public function setTemplate ( $ template ) { if ( is_string ( $ template ) ) { if ( substr ( $ template , 0 , 8 ) === '__SELF__' ) { $ this -> templates = $ this -> getTemplatesFromString ( substr ( $ template , 8 ) ) ; $ this -> templates [ ] = $ this -> twig -> loadTemplate ( static :: DEFAULT_TEMPLATE ) ; } else { $ this -> templates = $ this -> getTemplatesFromString ( $ template ) ; } } elseif ( $ this -> templates === null ) { $ this -> templates [ ] = $ this -> twig -> loadTemplate ( static :: DEFAULT_TEMPLATE ) ; } else { throw new \ Exception ( 'Unable to load template' ) ; } return $ this ; } 
public function getParameter ( $ name ) { if ( ! $ this -> hasParameter ( $ name ) ) { throw new \ InvalidArgumentException ( sprintf ( 'The parameter "%s" must be defined.' , $ name ) ) ; } return $ this -> parameters [ $ name ] ; } 
public function getActionsToRender ( $ row ) { $ list = $ this -> rowActions ; foreach ( $ list as $ i => $ a ) { $ action = clone $ a ; $ list [ $ i ] = $ action -> render ( $ row ) ; if ( null === $ list [ $ i ] ) { unset ( $ list [ $ i ] ) ; } } return $ list ; } 
public function process ( ContainerBuilder $ container ) { if ( ! $ container -> hasDefinition ( 'jms_translation.extractor.file_extractor' ) ) { return ; } $ extractor = new Definition ( 'APY\DataGridBundle\Translation\ColumnTitleAnnotationTranslationExtractor' ) ; $ extractor -> setPublic ( false ) -> addTag ( 'jms_translation.file_visitor' ) ; $ container -> setDefinition ( 'grid.translation_extractor' , $ extractor ) ; } 
public function add ( $ object ) { if ( $ object instanceof Item ) { if ( $ object -> ruleName && $ this -> getRule ( $ object -> ruleName ) === null ) { $ rule = $ this -> createRule ( $ object -> ruleName ) ; $ this -> addRule ( $ rule ) ; } return $ this -> addItem ( $ object ) ; } elseif ( $ object instanceof Rule ) { return $ this -> addRule ( $ object ) ; } throw new InvalidArgumentException ( 'Adding unsupported object type.' ) ; } 
public function up ( ) { $ this -> createIndex ( $ this -> index , $ this -> authManager -> assignmentTable , $ this -> column ) ; } 
protected function checkAccessRecursive ( $ user , $ itemName , $ params , $ assignments ) { if ( ( $ item = $ this -> getItem ( $ itemName ) ) === null ) { return false ; } $ this -> debug ( $ item instanceof Role ? "Checking role: $itemName" : "Checking permission: $itemName" , __METHOD__ ) ; if ( ! $ this -> executeRule ( $ user , $ item , $ params ) ) { return false ; } if ( isset ( $ assignments [ $ itemName ] ) || in_array ( $ itemName , $ this -> defaultRoles ) ) { return true ; } $ query = new Query ( ) ; $ parents = $ query -> select ( [ 'parent' ] ) -> from ( $ this -> itemChildTable ) -> where ( [ 'child' => $ itemName ] ) -> column ( $ this -> db ) ; foreach ( $ parents as $ parent ) { if ( $ this -> checkAccessRecursive ( $ user , $ parent , $ params , $ assignments ) ) { return true ; } } return false ; } 
public function getRule ( $ name ) { if ( $ this -> rules !== null ) { return isset ( $ this -> rules [ $ name ] ) ? $ this -> rules [ $ name ] : null ; } $ row = ( new Query ( ) ) -> select ( [ 'data' ] ) -> from ( $ this -> ruleTable ) -> where ( [ 'name' => $ name ] ) -> one ( $ this -> db ) ; if ( $ row === false ) { return ; } $ data = $ row [ 'data' ] ; if ( is_resource ( $ data ) ) { $ data = stream_get_contents ( $ data ) ; } return unserialize ( $ data ) ; } 
public function reassign ( $ sessionId , $ userId ) { if ( get_class ( $ this -> getStorage ( ) ) === 'yii2mod\cart\storage\DatabaseStorage' ) { if ( ! empty ( $ this -> items ) ) { $ storage = $ this -> getStorage ( ) ; $ storage -> reassign ( $ sessionId , $ userId ) ; self :: init ( ) ; } } } 
public function clear ( $ save = true ) : self { $ this -> items = [ ] ; $ save && $ this -> storage -> save ( $ this ) ; return $ this ; } 
public function add ( CartItemInterface $ element , $ save = true ) : self { $ this -> addItem ( $ element ) ; $ save && $ this -> storage -> save ( $ this ) ; return $ this ; } 
public function remove ( $ uniqueId , $ save = true ) : self { if ( ! isset ( $ this -> items [ $ uniqueId ] ) ) { throw new InvalidParamException ( 'Item not found' ) ; } unset ( $ this -> items [ $ uniqueId ] ) ; $ save && $ this -> storage -> save ( $ this ) ; return $ this ; } 
public function getItems ( $ itemType = null ) : array { $ items = $ this -> items ; if ( ! is_null ( $ itemType ) ) { $ items = array_filter ( $ items , function ( $ item ) use ( $ itemType ) { return is_a ( $ item , $ itemType ) ; } ) ; } return $ items ; } 
public function getAttributeTotal ( $ attribute , $ itemType = null ) : int { $ sum = 0 ; foreach ( $ this -> getItems ( $ itemType ) as $ model ) { $ sum += $ model -> { $ attribute } ; } return $ sum ; } 
public function load ( Cart $ cart ) { $ items = [ ] ; $ identifier = $ this -> getIdentifier ( Yii :: $ app -> session -> getId ( ) ) ; $ query = new Query ( ) ; $ query -> select ( $ this -> dataField ) -> from ( $ this -> table ) -> where ( [ $ this -> idField => $ identifier ] ) ; if ( $ data = $ query -> createCommand ( $ this -> _db ) -> queryScalar ( ) ) { $ items = unserialize ( $ data ) ; } return $ items ; } 
protected function getIdentifier ( $ default ) { $ id = $ default ; if ( $ this -> _user instanceof User && ! $ this -> _user -> getIsGuest ( ) ) { $ id = $ this -> _user -> getId ( ) ; } return $ id ; } 
public function reassign ( $ sourceId , $ destinationId ) { $ command = $ this -> _db -> createCommand ( ) ; $ command -> delete ( $ this -> table , [ $ this -> idField => $ destinationId ] ) -> execute ( ) ; $ command -> update ( $ this -> table , [ $ this -> idField => $ destinationId ] , [ $ this -> idField => $ sourceId ] ) -> execute ( ) ; } 
private function setHeaders ( ) { $ pluginAgent = $ this -> additionalPluginHeaders ( ) ; $ userAgent = array ( 'bindings_version' => Conekta :: VERSION , 'lang' => 'php' , 'lang_version' => phpversion ( ) , 'publisher' => 'conekta' , 'uname' => php_uname ( ) , ) ; if ( array_filter ( $ pluginAgent ) ) { $ userAgent = array_merge ( $ userAgent , $ pluginAgent ) ; } $ headers = array ( 'Accept: application/vnd.conekta-v' . Conekta :: $ apiVersion . '+json' , 'Accept-Language: ' . Conekta :: $ locale , 'X-Conekta-Client-User-Agent: ' . json_encode ( $ userAgent ) , 'User-Agent: Conekta/v1 PhpBindings/' . Conekta :: VERSION , 'Authorization: Basic ' . base64_encode ( $ this -> apiKey . ':' ) , 'Content-Type: application/json' ) ; return $ headers ; } 
public function request ( $ method , $ url , $ params = null ) { $ jsonParams = json_encode ( $ params ) ; $ headers = $ this -> setHeaders ( ) ; $ curl = curl_init ( ) ; $ method = strtolower ( $ method ) ; $ opts = array ( ) ; switch ( $ method ) { case 'get' : $ opts [ CURLOPT_HTTPGET ] = 1 ; $ url = $ this -> buildQueryParamsUrl ( $ url , $ params ) ; break ; case 'post' : $ opts [ CURLOPT_POST ] = 1 ; $ opts [ CURLOPT_POSTFIELDS ] = $ jsonParams ; break ; case 'put' : $ opts [ CURLOPT_RETURNTRANSFER ] = 1 ; $ opts [ CURLOPT_CUSTOMREQUEST ] = 'PUT' ; $ opts [ CURLOPT_POSTFIELDS ] = $ jsonParams ; break ; case 'delete' : $ opts [ CURLOPT_CUSTOMREQUEST ] = 'DELETE' ; $ url = $ this -> buildSegmentParamsUrl ( $ url , $ params ) ; break ; default : throw new \ Exception ( 'Wrong method' ) ; } $ url = $ this -> apiUrl ( $ url ) ; $ opts [ CURLOPT_URL ] = $ url ; $ opts [ CURLOPT_RETURNTRANSFER ] = true ; $ opts [ CURLOPT_CONNECTTIMEOUT ] = 30 ; $ opts [ CURLOPT_TIMEOUT ] = 80 ; $ opts [ CURLOPT_RETURNTRANSFER ] = true ; $ opts [ CURLOPT_HTTPHEADER ] = $ headers ; $ opts [ CURLOPT_SSLVERSION ] = 6 ; $ opts [ CURLOPT_CAINFO ] = dirname ( __FILE__ ) . '/../ssl_data/ca_bundle.crt' ; curl_setopt_array ( $ curl , $ opts ) ; $ response = curl_exec ( $ curl ) ; $ responseCode = curl_getinfo ( $ curl , CURLINFO_HTTP_CODE ) ; curl_close ( $ curl ) ; $ jsonResponse = json_decode ( $ response , true ) ; if ( $ responseCode != 200 ) { throw Handler :: errorHandler ( $ jsonResponse , $ responseCode ) ; } return $ jsonResponse ; } 
private function buildQueryParamsUrl ( $ url , $ params ) { if ( ! is_null ( $ params ) ) { $ params = http_build_query ( $ params ) ; $ url = $ url . '?' . $ params ; } return $ url ; } 
private function buildSegmentParamsUrl ( $ url , $ params ) { if ( ! is_array ( $ params ) ) { $ url = $ url . urlencode ( $ params ) ; } return $ url ; } 
public function login ( $ connection = null , $ state = null , $ additional_params = [ 'scope' => 'openid profile email' ] , $ response_type = 'code' ) { $ additional_params [ 'response_type' ] = $ response_type ; $ this -> auth0 -> login ( $ state , $ connection , $ additional_params ) ; } 
public function getUser ( ) { 
public function rememberUser ( $ value = null ) { if ( $ value !== null ) { $ this -> rememberUser = $ value ; } return $ this -> rememberUser ; } 
public function decodeJWT ( $ encUser ) { try { $ cache = \ App :: make ( '\Auth0\SDK\Helpers\Cache\CacheHandler' ) ; } catch ( BindingResolutionException $ e ) { $ cache = null ; } $ secret_base64_encoded = config ( 'laravel-auth0.secret_base64_encoded' ) ; if ( is_null ( $ secret_base64_encoded ) ) { $ secret_base64_encoded = true ; } $ verifier = new JWTVerifier ( [ 'valid_audiences' => [ config ( 'laravel-auth0.client_id' ) , config ( 'laravel-auth0.api_identifier' ) ] , 'supported_algs' => config ( 'laravel-auth0.supported_algs' , [ 'HS256' ] ) , 'client_secret' => config ( 'laravel-auth0.client_secret' ) , 'authorized_iss' => config ( 'laravel-auth0.authorized_issuers' ) , 'secret_base64_encoded' => $ secret_base64_encoded , 'cache' => $ cache , 'guzzle_options' => config ( 'laravel-auth0.guzzle_options' ) , ] ) ; $ this -> apiuser = $ verifier -> verifyAndDecode ( $ encUser ) ; return $ this -> apiuser ; } 
public function callback ( ) { 
public function set ( $ key , $ value ) { $ key_name = $ this -> getSessionKeyName ( $ key ) ; Session :: put ( $ key_name , $ value ) ; } 
public function get ( $ key , $ default = null ) { $ key_name = $ this -> getSessionKeyName ( $ key ) ; return Session :: get ( $ key_name , $ default ) ; } 
public function retrieveByCredentials ( array $ credentials ) { if ( ! isset ( $ credentials [ 'api_token' ] ) ) { return false ; } $ encUser = $ credentials [ 'api_token' ] ; try { $ decodedJWT = $ this -> auth0 -> decodeJWT ( $ encUser ) ; } catch ( CoreException $ e ) { return null ; } catch ( InvalidTokenException $ e ) { return null ; } return $ this -> userRepository -> getUserByDecodedJWT ( $ decodedJWT ) ; } 
public function boot ( ) { \ Auth :: provider ( 'auth0' , function ( $ app , array $ config ) { return $ app -> make ( Auth0UserProvider :: class ) ; } ) ; $ this -> publishes ( [ __DIR__ . '/../../config/config.php' => config_path ( 'laravel-auth0.php' ) , ] ) ; $ laravel = app ( ) ; $ oldInfoHeaders = ApiClient :: getInfoHeadersData ( ) ; if ( $ oldInfoHeaders ) { $ infoHeaders = InformationHeaders :: Extend ( $ oldInfoHeaders ) ; $ infoHeaders -> setEnvironment ( 'Laravel' , $ laravel :: VERSION ) ; $ infoHeaders -> setPackage ( 'laravel-auth0' , self :: SDK_VERSION ) ; ApiClient :: setInfoHeadersData ( $ infoHeaders ) ; } } 
public function register ( ) { 
public function getUserByIdentifier ( $ identifier ) { 
public static function isMutable ( $ name , $ gender = null ) { $ name = S :: lower ( $ name ) ; if ( in_array ( $ name , static :: $ immutableNames , true ) ) { return false ; } if ( $ gender === null ) { $ gender = static :: detectGender ( $ name ) ; } 
public static function getCase ( $ number , $ case , $ gender = self :: MALE ) { $ case = static :: canonizeCase ( $ case ) ; $ forms = static :: getCases ( $ number , $ gender ) ; return $ forms [ $ case ] ; } 
public static function isMutable ( $ name ) { $ name = S :: lower ( $ name ) ; 
public static function getCases ( $ name ) { $ name = S :: lower ( $ name ) ; 
public static function getCases ( $ number , $ gender = self :: MALE ) { 
public static function length ( $ string ) { if ( function_exists ( 'mb_strlen' ) ) { return mb_strlen ( $ string , static :: getEncoding ( ) ) ; } if ( function_exists ( 'iconv_strlen' ) ) { return iconv_strlen ( $ string , static :: getEncoding ( ) ) ; } return false ; } 
public static function slice ( $ string , $ start , $ end = null ) { if ( $ end !== null ) { $ end -= $ start ; } if ( function_exists ( 'mb_substr' ) ) { return mb_substr ( $ string , $ start , $ end , static :: getEncoding ( ) ) ; } if ( function_exists ( 'iconv_substr' ) ) { return iconv_substr ( $ string , $ start , $ end ? : iconv_strlen ( $ string ) , static :: getEncoding ( ) ) ; } return false ; } 
public static function lower ( $ string ) { if ( function_exists ( 'mb_strtolower' ) ) { return mb_strtolower ( $ string , static :: getEncoding ( ) ) ; } return static :: replaceByMap ( $ string , static :: $ cyrillicAlphabet [ 0 ] , static :: $ cyrillicAlphabet [ 1 ] ) ; } 
public static function upper ( $ string ) { if ( function_exists ( 'mb_strtoupper' ) ) { return mb_strtoupper ( $ string , static :: getEncoding ( ) ) ; } return static :: replaceByMap ( $ string , static :: $ cyrillicAlphabet [ 1 ] , static :: $ cyrillicAlphabet [ 0 ] ) ; } 
public static function name ( $ string ) { if ( strpos ( $ string , '-' ) !== false ) { return implode ( '-' , array_map ( [ __CLASS__ , __FUNCTION__ ] , explode ( '-' , $ string ) ) ) ; } return static :: upper ( static :: slice ( $ string , 0 , 1 ) ) . static :: lower ( static :: slice ( $ string , 1 ) ) ; } 
public static function countChars ( $ string , array $ chars ) { if ( function_exists ( 'mb_split' ) ) { return count ( mb_split ( '(' . implode ( '|' , $ chars ) . ')' , $ string ) ) - 1 ; } $ counter = 0 ; foreach ( $ chars as $ char ) { $ counter += substr_count ( $ string , $ char ) ; } return $ counter ; } 
public static function isMutable ( $ word , $ animateness = false ) { $ word = S :: lower ( $ word ) ; if ( in_array ( S :: slice ( $ word , - 1 ) , [ 'у', и', ' ', ' о , 'ю ' , tr u e || i _a ray($wor d , sta t c::$im mu t ableWords, tru e ) { return false ; } return true ; } 
public static function detectGender ( $ word ) { $ word = S :: lower ( $ word ) ; $ last = S :: slice ( $ word , - 1 ) ; 
public static function getDeclension ( $ word , $ animateness = false ) { $ word = S :: lower ( $ word ) ; $ last = S :: slice ( $ word , - 1 ) ; if ( isset ( static :: $ abnormalExceptions [ $ word ] ) || in_array ( $ word , static :: $ abnormalExceptions , true ) ) { return 2 ; } if ( in_array ( $ last , [ 'а', я'], t ue) & S : sl ice($ w o rd, - ) ! ' я') { return 1 ; } elseif ( static :: isConsonant ( $ last ) || in_array ( $ last , [ 'о', е', ' '], t r e) || ( $ last == 'ь' & tatic: :i sConsonant( S : :s lice( $ w ord, 2 , 1 ) ) & s tatic: :i sHissingConsonant( S : :s lice( $ w ord, 2 , 1 ) ) && ( in_array ( $ word , static :: $ masculineWithSoft , true ) ) || in_array ( $ word , static :: $ masculineWithSoftAndRunAwayVowels , true ) ) ) { return 2 ; } else { return 3 ; } } 
public static function getCases ( $ word , $ animateness = false ) { $ word = S :: lower ( $ word ) ; 
public static function declinateFirstDeclension ( $ word ) { $ word = S :: lower ( $ word ) ; $ prefix = S :: slice ( $ word , 0 , - 1 ) ; $ last = S :: slice ( $ word , - 1 ) ; $ soft_last = static :: checkLastConsonantSoftness ( $ word ) ; $ forms = [ Cases :: IMENIT => $ word , ] ; 
public static function declinateSecondDeclension ( $ word , $ animateness = false ) { $ word = S :: lower ( $ word ) ; $ last = S :: slice ( $ word , - 1 ) ; $ soft_last = $ last == 'й' | i n_array( $ l ast, ' ь', ' ', ' ё , 'ю ' 'я' ] tru e ) && ( ( static :: isConsonant ( S :: slice ( $ word , - 2 , - 1 ) ) && ! static :: isHissingConsonant ( S :: slice ( $ word , - 2 , - 1 ) ) ) || S :: slice ( $ word , - 2 , - 1 ) == 'и') ) ; $ prefix = static :: getPrefixOfSecondDeclension ( $ word , $ last ) ; $ forms = [ Cases :: IMENIT => $ word , ] ; // RODIT $ forms [ Cases :: RODIT ] = static :: chooseVowelAfterConsonant ( $ last , $ soft_last , $ prefix . 'я', p refix. ' а'); // DAT $ forms [ Cases :: DAT ] = static :: chooseVowelAfterConsonant ( $ last , $ soft_last , $ prefix . 'ю', p refix. ' у'); // VINIT if ( in_array ( $ last , [ 'о', е', ' '], t r e)) { $ forms [ Cases :: VINIT ] = $ word ; } else { $ forms [ Cases :: VINIT ] = static :: getVinitCaseByAnimateness ( $ forms , $ animateness ) ; } 
public static function declinateThirdDeclension ( $ word ) { $ word = S :: lower ( $ word ) ; $ prefix = S :: slice ( $ word , 0 , - 1 ) ; return [ Cases :: IMENIT => $ word , Cases :: RODIT => $ prefix . 'и', Cases :: DAT => $ prefix . 'и', Cases :: VINIT => $ word , Cases :: TVORIT => $ prefix . 'ью', Cases :: PREDLOJ => $ prefix . 'и', ] ; } 
public static function declinateAdjective ( $ word , $ animateness ) { $ prefix = S :: slice ( $ word , 0 , - 2 ) ; switch ( S :: slice ( $ word , - 2 ) ) { 
public static function getCase ( $ word , $ case , $ animateness = false ) { $ case = static :: canonizeCase ( $ case ) ; $ forms = static :: getCases ( $ word , $ animateness ) ; return $ forms [ $ case ] ; } 
public static function pluralize ( $ word , $ count = 2 , $ animateness = false , $ case = null ) { 
protected static function declinateSubstative ( $ word , $ animateness ) { $ prefix = S :: slice ( $ word , 0 , - 1 ) ; $ last = S :: slice ( $ word , - 1 ) ; $ runaway_vowels_list = static :: getRunAwayVowelsList ( ) ; if ( isset ( $ runaway_vowels_list [ $ word ] ) ) { $ vowel_offset = $ runaway_vowels_list [ $ word ] ; $ word = S :: slice ( $ word , 0 , $ vowel_offset ) . S :: slice ( $ word , $ vowel_offset + 1 ) ; } if ( ( $ declension = NounDeclension :: getDeclension ( $ word ) ) == NounDeclension :: SECOND_DECLENSION ) { $ soft_last = $ last == 'й' | i n_array( $ l ast, ' ь', ' ', ' ё , 'ю ' 'я' ] tru e ) && ( ( static :: isConsonant ( S :: slice ( $ word , - 2 , - 1 ) ) && ! static :: isHissingConsonant ( S :: slice ( $ word , - 2 , - 1 ) ) ) || S :: slice ( $ word , - 2 , - 1 ) == 'и') ) ; $ prefix = NounDeclension :: getPrefixOfSecondDeclension ( $ word , $ last ) ; } elseif ( $ declension == NounDeclension :: FIRST_DECLENSION ) { $ soft_last = static :: checkLastConsonantSoftness ( $ word ) ; } else { $ soft_last = in_array ( S :: slice ( $ word , - 2 ) , [ 'чь', ' ь', 'т ь , 'нь' ] true) ; } $ forms = [ ] ; if ( in_array ( $ last , [ 'ч', г'], f lse) | i _array(S : : sl ice($ w o rd, - ) , [ ч ь', 'с ь , 'ть' , 'нь'], rue) || ( static :: isVowel ( $ last ) && in_array ( S :: slice ( $ word , - 2 , - 1 ) , [ 'ч', к'], t ue)) ) { / before ч, чь, сь, ч+vowel, к+vowel $ forms [ Cases :: IMENIT ] = $ prefix . 'и'; } elseif ( in_array ( $ last , [ 'н', ц', ' ', ' т ], t r u )) { $ forms [ Cases :: IMENIT ] = $ prefix . 'ы'; } else { $ forms [ Cases :: IMENIT ] = static :: chooseVowelAfterConsonant ( $ last , $ soft_last , $ prefix . 'я', p refix. ' а'); } 
protected static function declinateAdjective ( $ word , $ animateness ) { $ prefix = S :: slice ( $ word , 0 , - 2 ) ; $ vowel = static :: isHissingConsonant ( S :: slice ( $ prefix , - 1 ) ) ? 'и' ы'; return [ Cases :: IMENIT => $ prefix . $ vowel . 'е', Cases :: RODIT => $ prefix . $ vowel . 'х', Cases :: DAT => $ prefix . $ vowel . 'м', Cases :: VINIT => $ prefix . $ vowel . ( $ animateness ? 'х' е'), Cases :: TVORIT => $ prefix . $ vowel . 'ми', Cases :: PREDLOJ => $ prefix . $ vowel . 'х', ] ; } 
public static function composeCasesFromWords ( array $ words , $ delimiter = ' ' ) { $ cases = [ ] ; foreach ( CasesHelper :: getAllCases ( ) as $ case ) { $ composed_case = [ ] ; foreach ( $ words as $ wordCases ) { $ composed_case [ ] = $ wordCases [ $ case ] ; } $ cases [ $ case ] = implode ( $ delimiter , $ composed_case ) ; } return $ cases ; } 
public static function spellUnit ( $ count , $ unit ) { if ( ! isset ( static :: $ units [ $ unit ] ) ) { throw new InvalidArgumentException ( 'Unknown time unit: ' . $ unit ) ; } return pluralize ( $ count , static :: $ units [ $ unit ] ) ; } 
public static function isPaired ( $ consonant ) { $ consonant = S :: lower ( $ consonant ) ; return array_key_exists ( $ consonant , static :: $ pairs ) || ( array_search ( $ consonant , static :: $ pairs ) !== false ) ; } 
public static function checkLastConsonantSoftness ( $ word ) { if ( ( $ substring = S :: findLastPositionForOneOfChars ( S :: lower ( $ word ) , static :: $ consonants ) ) !== false ) { if ( in_array ( S :: slice ( $ substring , 0 , 1 ) , [ 'й', ч', ' '], t r e)) { / always soft consonants return true ; } elseif ( S :: length ( $ substring ) > 1 && in_array ( S :: slice ( $ substring , 1 , 2 ) , [ 'е', ё', ' ', ' ю , 'я ' 'ь' ] tru e ) { / / o sonants are soft if they are trailed with these vowels return true ; } } return false ; } 
public static function choosePrepositionByFirstLetter ( $ word , $ prepositionWithVowel , $ preposition ) { if ( in_array ( S :: lower ( S :: slice ( $ word , 0 , 1 ) ) , [ 'а', о', ' ', ' у , 'э ' , tr u e ) { return $ prepositionWithVowel ; } else { return $ preposition ; } } 
public static function chooseVowelAfterConsonant ( $ last , $ softLast , $ afterSoft , $ afterHard ) { if ( ( RussianLanguage :: isHissingConsonant ( $ last ) && ! in_array ( $ last , [ 'ж', ч'], t ue)) | / static::isVelarConsonant($last) ||*/ $ o ftLast) { return $ afterSoft ; } else { return $ afterHard ; } } 
public static function in ( $ word ) { $ normalized = trim ( S :: lower ( $ word ) ) ; if ( in_array ( S :: slice ( $ normalized , 0 , 1 ) , [ 'в', ф'], t ue)) return 'во '.$ w o rd; return 'в '. $ w ord; } 
public static function with ( $ word ) { $ normalized = trim ( S :: lower ( $ word ) ) ; if ( in_array ( S :: slice ( $ normalized , 0 , 1 ) , [ 'c' , 'з', ш', ' '], t r e) & & st tic::i sC onsonant(S: : s li ce($n o r malized, 1 , 2 ) | | S: s li ce($n o r malized, 0 , 1 ) = = 'щ ) return 'со '.$ w o rd; return 'с '. $ w ord; } 
public static function about ( $ word ) { $ normalized = trim ( S :: lower ( $ word ) ) ; if ( static :: isVowel ( S :: slice ( $ normalized , 0 , 1 ) ) && ! in_array ( S :: slice ( $ normalized , 0 , 1 ) , [ 'е', ё', ' ', ' я ], t r u )) return 'об '.$ w o rd; if ( in_array ( S :: slice ( $ normalized , 0 , 3 ) , [ 'все', ' в ё', 'всю ' 'что', ' не'], tr u )) return 'обо '.$w o r d; return 'о '. $ w ord; } 
public static function chooseEndingBySonority ( $ word , $ ifSonorous , $ ifDeaf ) { $ last = S :: slice ( $ word , - 1 ) ; if ( static :: isSonorousConsonant ( $ last ) ) return $ ifSonorous ; if ( static :: isDeafConsonant ( $ last ) ) return $ ifDeaf ; throw new \ Exception ( 'Not implemented' ) ; } 
private function removeDefaultArguments ( Invocation \ StaticInvocation $ invocation ) { $ remover = function ( ) { MockFunctionGenerator :: removeDefaultArguments ( $ this -> parameters ) ; } ; $ remover -> bindTo ( $ invocation , Invocation \ StaticInvocation :: class ) ( ) ; } 
public function getFunctionMock ( $ namespace , $ name ) { $ delegateBuilder = new MockDelegateFunctionBuilder ( ) ; $ delegateBuilder -> build ( $ name ) ; $ mock = $ this -> getMockBuilder ( $ delegateBuilder -> getFullyQualifiedClassName ( ) ) -> getMockForAbstractClass ( ) ; $ mock -> __phpunit_getInvocationMocker ( ) -> addMatcher ( new DefaultArgumentRemover ( ) ) ; $ functionMockBuilder = new MockBuilder ( ) ; $ functionMockBuilder -> setNamespace ( $ namespace ) -> setName ( $ name ) -> setFunctionProvider ( $ mock ) ; $ functionMock = $ functionMockBuilder -> build ( ) ; $ functionMock -> enable ( ) ; $ this -> registerForTearDown ( $ functionMock ) ; $ proxy = new MockObjectProxy ( $ mock ) ; return $ proxy ; } 
public function registerForTearDown ( Deactivatable $ deactivatable ) { $ result = $ this -> getTestResultObject ( ) ; $ result -> addListener ( new MockDisabler ( $ deactivatable ) ) ; } 
public static function defineFunctionMock ( $ namespace , $ name ) { $ functionMockBuilder = new MockBuilder ( ) ; $ functionMockBuilder -> setNamespace ( $ namespace ) -> setName ( $ name ) -> setFunction ( function ( ) { } ) -> build ( ) -> define ( ) ; } 
public function start ( ) { try { $ this -> server = IoServer :: factory ( new HttpServer ( new WsServer ( $ this ) ) , $ this -> port ) ; $ this -> trigger ( self :: EVENT_WEBSOCKET_OPEN ) ; $ this -> clients = new \ SplObjectStorage ( ) ; $ this -> server -> run ( ) ; return true ; } catch ( \ Exception $ e ) { $ errorEvent = new ExceptionEvent ( [ 'exception' => $ e ] ) ; $ this -> trigger ( self :: EVENT_WEBSOCKET_OPEN_ERROR , $ errorEvent ) ; return false ; } } 
function onOpen ( ConnectionInterface $ conn ) { $ this -> trigger ( self :: EVENT_CLIENT_CONNECTED , new WSClientEvent ( [ 'client' => $ conn ] ) ) ; $ this -> clients -> attach ( $ conn ) ; } 
function onClose ( ConnectionInterface $ conn ) { $ this -> trigger ( self :: EVENT_CLIENT_DISCONNECTED , new WSClientEvent ( [ 'client' => $ conn ] ) ) ; $ this -> clients -> detach ( $ conn ) ; } 
function onError ( ConnectionInterface $ conn , \ Exception $ e ) { $ this -> trigger ( self :: EVENT_CLIENT_ERROR , new WSClientErrorEvent ( [ 'client' => $ conn , 'exception' => $ e ] ) ) ; if ( $ this -> closeConnectionOnError ) { $ conn -> close ( ) ; } } 
function onMessage ( ConnectionInterface $ from , $ msg ) { $ this -> trigger ( self :: EVENT_CLIENT_MESSAGE , new WSClientMessageEvent ( [ 'client' => $ from , 'message' => $ msg ] ) ) ; if ( $ this -> runClientCommands ) { $ command = $ this -> getCommand ( $ from , $ msg ) ; if ( $ command && method_exists ( $ this , 'command' . ucfirst ( $ command ) ) ) { $ this -> trigger ( self :: EVENT_CLIENT_RUN_COMMAND , new WSClientCommandEvent ( [ 'client' => $ from , 'command' => $ command ] ) ) ; $ result = call_user_func ( [ $ this , 'command' . ucfirst ( $ command ) ] , $ from , $ msg ) ; $ this -> trigger ( self :: EVENT_CLIENT_END_COMMAND , new WSClientCommandEvent ( [ 'client' => $ from , 'command' => $ command , 'result' => $ result ] ) ) ; } } } 
public static function flag ( $ code = 'default' ) { if ( $ code == 'default' ) { $ code = app ( ) -> getLocale ( ) ; } $ name = self :: getName ( $ code ) ; $ code = self :: country ( $ code ) ; return view ( 'vendor.language.flag' , compact ( 'code' , 'name' ) ) ; } 
public static function country ( $ locale = 'default' ) { if ( $ locale == 'default' ) { $ locale = app ( ) -> getLocale ( ) ; } if ( config ( 'language.mode.code' , 'short' ) == 'short' ) { $ code = strtolower ( substr ( self :: getLongCode ( $ locale ) , 3 ) ) ; } else { $ code = strtolower ( substr ( $ locale , 3 ) ) ; } return $ code ; } 
public static function allowed ( $ locale = null ) { if ( $ locale ) { return in_array ( $ locale , array_keys ( self :: allowed ( ) ) ) ; } if ( config ( 'language.allowed' ) ) { return self :: names ( array_merge ( config ( 'language.allowed' ) , [ config ( 'app.locale' ) ] ) ) ; } else { return self :: names ( [ config ( 'app.locale' ) ] ) ; } } 
public static function names ( $ codes ) { 
public static function codes ( $ langs ) { 
public static function getCode ( $ name = 'default' ) { if ( $ name == 'default' ) { $ name = self :: getName ( ) ; } return self :: codes ( [ $ name ] ) [ $ name ] ; } 
public static function getLongCode ( $ short = 'default' ) { if ( $ short == 'default' ) { $ short = app ( ) -> getLocale ( ) ; } $ long = 'en-GB' ; 
public static function getName ( $ code = 'default' ) { if ( $ code == 'default' ) { $ code = app ( ) -> getLocale ( ) ; } return self :: names ( [ $ code ] ) [ $ code ] ; } 
public function boot ( Router $ router ) { if ( ! $ this -> app -> routesAreCached ( ) ) { require __DIR__ . '/Routes/web.php' ; } $ this -> publishes ( [ __DIR__ . '/Config/language.php' => config_path ( 'language.php' ) , __DIR__ . '/Migrations/2020_01_01_000000_add_locale_column.php' => database_path ( 'migrations/2020_01_01_000000_add_locale_column.php' ) , __DIR__ . '/Resources/views/flag.blade.php' => resource_path ( 'views/vendor/language/flag.blade.php' ) , __DIR__ . '/Resources/views/flags.blade.php' => resource_path ( 'views/vendor/language/flags.blade.php' ) , ] , 'language' ) ; $ router -> aliasMiddleware ( 'language' , config ( 'language.middleware' ) ) ; $ this -> app -> register ( IdentifyServiceProvider :: class ) ; $ this -> app -> singleton ( 'language' , function ( $ app ) { return new Language ( $ app ) ; } ) ; } 
private function setLocale ( $ locale , $ request ) { 
public function home ( $ locale , Request $ request ) { $ this -> setLocale ( $ locale , $ request ) ; $ url = config ( 'language.url' ) ? url ( '/' . $ locale ) : url ( '/' ) ; return redirect ( $ url ) ; } 
public function back ( $ locale , Request $ request ) { $ this -> setLocale ( $ locale , $ request ) ; $ session = $ request -> session ( ) ; if ( config ( 'language.url' ) ) { $ previous_url = substr ( str_replace ( env ( 'APP_URL' ) , '' , $ session -> previousUrl ( ) ) , 7 ) ; if ( strlen ( $ previous_url ) == 3 ) { $ previous_url = substr ( $ previous_url , 3 ) ; } else { $ previous_url = substr ( $ previous_url , strrpos ( $ previous_url , '/' ) + 1 ) ; } $ url = rtrim ( env ( 'APP_URL' ) , '/' ) . '/' . $ locale . '/' . ltrim ( $ previous_url , '/' ) ; $ session -> setPreviousUrl ( $ url ) ; } return redirect ( $ session -> previousUrl ( ) ) ; } 
private function setLocale ( $ locale ) { 
public function handle ( $ request , Closure $ next ) { if ( $ request -> has ( 'lang' ) ) { $ this -> setLocale ( $ request -> get ( 'lang' ) ) ; } elseif ( auth ( ) -> check ( ) ) { $ this -> setUserLocale ( ) ; } else { $ this -> setSystemLocale ( $ request ) ; } return $ next ( $ request ) ; } 
public function indexWhere ( $ callable ) { foreach ( $ this -> elements as $ i => $ element ) { if ( call_user_func ( $ callable , $ element ) === true ) { return $ i ; } } return - 1 ; } 
public function get ( $ index ) { if ( ! isset ( $ this -> elements [ $ index ] ) ) { throw new OutOfBoundsException ( sprintf ( 'The index "%s" does not exist in this sequence.' , $ index ) ) ; } return $ this -> elements [ $ index ] ; } 
public function remove ( $ index ) { if ( ! isset ( $ this -> elements [ $ index ] ) ) { throw new OutOfBoundsException ( sprintf ( 'The index "%d" is not in the interval [0, %d).' , $ index , count ( $ this -> elements ) ) ) ; } $ element = $ this -> elements [ $ index ] ; unset ( $ this -> elements [ $ index ] ) ; $ this -> elements = array_values ( $ this -> elements ) ; return $ element ; } 
public function update ( $ index , $ value ) { if ( ! isset ( $ this -> elements [ $ index ] ) ) { throw new \ InvalidArgumentException ( sprintf ( 'There is no element at index "%d".' , $ index ) ) ; } $ this -> elements [ $ index ] = $ value ; } 
public function takeWhile ( $ callable ) { $ newElements = array ( ) ; for ( $ i = 0 , $ c = count ( $ this -> elements ) ; $ i < $ c ; $ i ++ ) { if ( call_user_func ( $ callable , $ this -> elements [ $ i ] ) !== true ) { break ; } $ newElements [ ] = $ this -> elements [ $ i ] ; } return $ this -> createNew ( $ newElements ) ; } 
public function setServer ( $ host , $ port , $ secure = null ) { $ this -> host = $ host ; $ this -> port = $ port ; $ this -> secure = $ secure ; if ( ! $ this -> ehlo ) $ this -> ehlo = $ host ; $ this -> logger && $ this -> logger -> debug ( "Set: the server" ) ; return $ this ; } 
public function setAuth ( $ username , $ password ) { $ this -> username = $ username ; $ this -> password = $ password ; $ this -> logger && $ this -> logger -> debug ( "Set: the auth login" ) ; return $ this ; } 
public function setOAuth ( $ accessToken ) { $ this -> oauthToken = $ accessToken ; $ this -> logger && $ this -> logger -> debug ( "Set: the auth oauthbearer" ) ; return $ this ; } 
public function send ( Message $ message ) { $ this -> logger && $ this -> logger -> debug ( 'Set: a message will be sent' ) ; $ this -> message = $ message ; $ this -> connect ( ) -> ehlo ( ) ; if ( $ this -> secure === 'tls' || $ this -> secure === 'tlsv1.0' || $ this -> secure === 'tlsv1.1' | $ this -> secure === 'tlsv1.2' ) { $ this -> starttls ( ) -> ehlo ( ) ; } if ( $ this -> username !== null || $ this -> password !== null ) { $ this -> authLogin ( ) ; } elseif ( $ this -> oauthToken !== null ) { $ this -> authOAuthBearer ( ) ; } $ this -> mailFrom ( ) -> rcptTo ( ) -> data ( ) -> quit ( ) ; return fclose ( $ this -> smtp ) ; } 
protected function connect ( ) { $ this -> logger && $ this -> logger -> debug ( "Connecting to {$this->host} at {$this->port}" ) ; $ host = ( $ this -> secure == 'ssl' ) ? 'ssl://' . $ this -> host : $ this -> host ; $ this -> smtp = @ fsockopen ( $ host , $ this -> port ) ; 
protected function starttls ( ) { $ in = "STARTTLS" . $ this -> CRLF ; $ code = $ this -> pushStack ( $ in ) ; if ( $ code !== '220' ) { throw new CodeException ( '220' , $ code , array_pop ( $ this -> resultStack ) ) ; } if ( $ this -> secure !== 'tls' && version_compare ( phpversion ( ) , '5.6.0' , '<' ) ) { throw new CryptoException ( 'Crypto type expected PHP 5.6 or greater' ) ; } switch ( $ this -> secure ) { case 'tlsv1.0' : $ crypto_type = STREAM_CRYPTO_METHOD_TLSv1_0_CLIENT ; break ; case 'tlsv1.1' : $ crypto_type = STREAM_CRYPTO_METHOD_TLSv1_1_CLIENT ; break ; case 'tlsv1.2' : $ crypto_type = STREAM_CRYPTO_METHOD_TLSv1_2_CLIENT ; break ; default : $ crypto_type = STREAM_CRYPTO_METHOD_TLS_CLIENT ; break ; } if ( ! \ stream_socket_enable_crypto ( $ this -> smtp , true , $ crypto_type ) ) { throw new CryptoException ( "Start TLS failed to enable crypto" ) ; } return $ this ; } 
protected function authLogin ( ) { $ in = "AUTH LOGIN" . $ this -> CRLF ; $ code = $ this -> pushStack ( $ in ) ; if ( $ code !== '334' ) { throw new CodeException ( '334' , $ code , array_pop ( $ this -> resultStack ) ) ; } $ in = base64_encode ( $ this -> username ) . $ this -> CRLF ; $ code = $ this -> pushStack ( $ in ) ; if ( $ code !== '334' ) { throw new CodeException ( '334' , $ code , array_pop ( $ this -> resultStack ) ) ; } $ in = base64_encode ( $ this -> password ) . $ this -> CRLF ; $ code = $ this -> pushStack ( $ in ) ; if ( $ code !== '235' ) { throw new CodeException ( '235' , $ code , array_pop ( $ this -> resultStack ) ) ; } return $ this ; } 
protected function authOAuthBearer ( ) { $ authStr = sprintf ( "n,a=%s,%shost=%s%sport=%s%sauth=Bearer %s%s%s" , $ this -> message -> getFromEmail ( ) , chr ( 1 ) , $ this -> host , chr ( 1 ) , $ this -> port , chr ( 1 ) , $ this -> oauthToken , chr ( 1 ) , chr ( 1 ) ) ; $ authStr = base64_encode ( $ authStr ) ; $ in = "AUTH OAUTHBEARER $authStr" . $ this -> CRLF ; $ code = $ this -> pushStack ( $ in ) ; if ( $ code !== '235' ) { throw new CodeException ( '235' , $ code , array_pop ( $ this -> resultStack ) ) ; } return $ this ; } 
protected function authXOAuth2 ( ) { $ authStr = sprintf ( "user=%s%sauth=Bearer %s%s%s" , $ this -> message -> getFromEmail ( ) , chr ( 1 ) , $ this -> oauthToken , chr ( 1 ) , chr ( 1 ) ) ; $ authStr = base64_encode ( $ authStr ) ; $ in = "AUTH XOAUTH2 $authStr" . $ this -> CRLF ; $ code = $ this -> pushStack ( $ in ) ; if ( $ code !== '235' ) { throw new CodeException ( '235' , $ code , array_pop ( $ this -> resultStack ) ) ; } return $ this ; } 
protected function rcptTo ( ) { $ to = array_merge ( $ this -> message -> getTo ( ) , $ this -> message -> getCc ( ) , $ this -> message -> getBcc ( ) ) ; foreach ( $ to as $ toEmail => $ _ ) { $ in = "RCPT TO:<" . $ toEmail . ">" . $ this -> CRLF ; $ code = $ this -> pushStack ( $ in ) ; if ( $ code !== '250' ) { throw new CodeException ( '250' , $ code , array_pop ( $ this -> resultStack ) ) ; } } return $ this ; } 
protected function data ( ) { $ in = "DATA" . $ this -> CRLF ; $ code = $ this -> pushStack ( $ in ) ; if ( $ code !== '354' ) { throw new CodeException ( '354' , $ code , array_pop ( $ this -> resultStack ) ) ; } $ in = $ this -> message -> toString ( ) ; $ code = $ this -> pushStack ( $ in ) ; if ( $ code !== '250' ) { throw new CodeException ( '250' , $ code , array_pop ( $ this -> resultStack ) ) ; } return $ this ; } 
protected function quit ( ) { $ in = "QUIT" . $ this -> CRLF ; $ code = $ this -> pushStack ( $ in ) ; if ( $ code !== '221' ) { throw new CodeException ( '221' , $ code , array_pop ( $ this -> resultStack ) ) ; } return $ this ; } 
protected function getCode ( ) { while ( $ str = fgets ( $ this -> smtp , 515 ) ) { $ this -> logger && $ this -> logger -> debug ( "Got: " . $ str ) ; $ this -> resultStack [ ] = $ str ; if ( substr ( $ str , 3 , 1 ) == " " ) { $ code = substr ( $ str , 0 , 3 ) ; return $ code ; } } throw new SMTPException ( "SMTP Server did not respond with anything I recognized" ) ; } 
public function setServer ( $ host , $ port , $ secure = null ) { $ this -> smtp -> setServer ( $ host , $ port , $ secure ) ; return $ this ; } 
public function setFrom ( $ name , $ email ) { $ this -> fromName = $ name ; $ this -> fromEmail = $ email ; return $ this ; } 
public function setFakeFrom ( $ name , $ email ) { $ this -> fakeFromName = $ name ; $ this -> fakeFromEmail = $ email ; return $ this ; } 
protected function createHeader ( ) { $ this -> header [ 'Date' ] = date ( 'r' ) ; $ fromName = "" ; $ fromEmail = $ this -> fromEmail ; if ( ! empty ( $ this -> fromName ) ) { $ fromName = sprintf ( "=?utf-8?B?%s?= " , base64_encode ( $ this -> fromName ) ) ; } if ( ! empty ( $ this -> fakeFromEmail ) ) { if ( ! empty ( $ this -> fakeFromName ) ) { $ fromName = sprintf ( "=?utf-8?B?%s?= " , base64_encode ( $ this -> fakeFromName ) ) ; } $ fromEmail = $ this -> fakeFromEmail ; } $ this -> header [ 'Return-Path' ] = $ fromEmail ; $ this -> header [ 'From' ] = $ fromName . "<" . $ fromEmail . ">" ; $ this -> header [ 'To' ] = '' ; foreach ( $ this -> to as $ toEmail => $ toName ) { if ( ! empty ( $ toName ) ) { $ toName = sprintf ( "=?utf-8?B?%s?= " , base64_encode ( $ toName ) ) ; } $ this -> header [ 'To' ] .= $ toName . "<" . $ toEmail . ">, " ; } $ this -> header [ 'To' ] = substr ( $ this -> header [ 'To' ] , 0 , - 2 ) ; $ this -> header [ 'Cc' ] = '' ; foreach ( $ this -> cc as $ toEmail => $ toName ) { if ( ! empty ( $ toName ) ) { $ toName = sprintf ( "=?utf-8?B?%s?= " , base64_encode ( $ toName ) ) ; } $ this -> header [ 'Cc' ] .= $ toName . "<" . $ toEmail . ">, " ; } $ this -> header [ 'Cc' ] = substr ( $ this -> header [ 'Cc' ] , 0 , - 2 ) ; $ this -> header [ 'Bcc' ] = '' ; foreach ( $ this -> bcc as $ toEmail => $ toName ) { if ( ! empty ( $ toName ) ) { $ toName = sprintf ( "=?utf-8?B?%s?= " , base64_encode ( $ toName ) ) ; } $ this -> header [ 'Bcc' ] .= $ toName . "<" . $ toEmail . ">, " ; } $ this -> header [ 'Bcc' ] = substr ( $ this -> header [ 'Bcc' ] , 0 , - 2 ) ; $ replyToName = "" ; if ( ! empty ( $ this -> replyToEmail ) ) { if ( ! empty ( $ this -> replyToName ) ) { $ replyToName = sprintf ( "=?utf-8?B?%s?= " , base64_encode ( $ this -> replyToName ) ) ; } $ this -> header [ 'Reply-To' ] = $ replyToName . "<" . $ this -> replyToEmail . ">" ; } if ( empty ( $ this -> subject ) ) { $ subject = '' ; } else { $ subject = sprintf ( "=?utf-8?B?%s?= " , base64_encode ( $ this -> subject ) ) ; } $ this -> header [ 'Subject' ] = $ subject ; $ this -> header [ 'Message-ID' ] = '<' . md5 ( uniqid ( ) ) . '@' . $ this -> fromEmail . '>' ; $ this -> header [ 'X-Priority' ] = '3' ; $ this -> header [ 'X-Mailer' ] = 'Mailer (https://github.com/txthinking/Mailer)' ; $ this -> header [ 'MIME-Version' ] = '1.0' ; if ( ! empty ( $ this -> attachment ) ) { $ this -> boundaryMixed = md5 ( md5 ( time ( ) . 'TxMailer' ) . uniqid ( ) ) ; $ this -> header [ 'Content-Type' ] = "multipart/mixed; \r\n\tboundary=\"" . $ this -> boundaryMixed . "\"" ; } $ this -> boundaryAlternative = md5 ( md5 ( time ( ) . 'TXMailer' ) . uniqid ( ) ) ; return $ this ; } 
protected function createBody ( ) { $ in = "" ; $ in .= "Content-Type: multipart/alternative; boundary=\"$this->boundaryAlternative\"" . $ this -> CRLF ; $ in .= $ this -> CRLF ; $ in .= "--" . $ this -> boundaryAlternative . $ this -> CRLF ; $ in .= "Content-Type: text/plain; charset=\"" . $ this -> charset . "\"" . $ this -> CRLF ; $ in .= "Content-Transfer-Encoding: base64" . $ this -> CRLF ; $ in .= $ this -> CRLF ; $ in .= chunk_split ( base64_encode ( $ this -> body ) ) . $ this -> CRLF ; $ in .= $ this -> CRLF ; $ in .= "--" . $ this -> boundaryAlternative . $ this -> CRLF ; $ in .= "Content-Type: text/html; charset=\"" . $ this -> charset . "\"" . $ this -> CRLF ; $ in .= "Content-Transfer-Encoding: base64" . $ this -> CRLF ; $ in .= $ this -> CRLF ; $ in .= chunk_split ( base64_encode ( $ this -> body ) ) . $ this -> CRLF ; $ in .= $ this -> CRLF ; $ in .= "--" . $ this -> boundaryAlternative . "--" . $ this -> CRLF ; return $ in ; } 
protected function createBodyWithAttachment ( ) { $ in = "" ; $ in .= $ this -> CRLF ; $ in .= $ this -> CRLF ; $ in .= '--' . $ this -> boundaryMixed . $ this -> CRLF ; $ in .= "Content-Type: multipart/alternative; boundary=\"$this->boundaryAlternative\"" . $ this -> CRLF ; $ in .= $ this -> CRLF ; $ in .= "--" . $ this -> boundaryAlternative . $ this -> CRLF ; $ in .= "Content-Type: text/plain; charset=\"" . $ this -> charset . "\"" . $ this -> CRLF ; $ in .= "Content-Transfer-Encoding: base64" . $ this -> CRLF ; $ in .= $ this -> CRLF ; $ in .= chunk_split ( base64_encode ( $ this -> body ) ) . $ this -> CRLF ; $ in .= $ this -> CRLF ; $ in .= "--" . $ this -> boundaryAlternative . $ this -> CRLF ; $ in .= "Content-Type: text/html; charset=\"" . $ this -> charset . "\"" . $ this -> CRLF ; $ in .= "Content-Transfer-Encoding: base64" . $ this -> CRLF ; $ in .= $ this -> CRLF ; $ in .= chunk_split ( base64_encode ( $ this -> body ) ) . $ this -> CRLF ; $ in .= $ this -> CRLF ; $ in .= "--" . $ this -> boundaryAlternative . "--" . $ this -> CRLF ; foreach ( $ this -> attachment as $ name => $ path ) { $ in .= $ this -> CRLF ; $ in .= '--' . $ this -> boundaryMixed . $ this -> CRLF ; $ in .= "Content-Type: application/octet-stream; name=\"" . $ name . "\"" . $ this -> CRLF ; $ in .= "Content-Transfer-Encoding: base64" . $ this -> CRLF ; $ in .= "Content-Disposition: attachment; filename=\"" . $ name . "\"" . $ this -> CRLF ; $ in .= $ this -> CRLF ; $ in .= chunk_split ( base64_encode ( file_get_contents ( $ path ) ) ) . $ this -> CRLF ; } $ in .= $ this -> CRLF ; $ in .= $ this -> CRLF ; $ in .= '--' . $ this -> boundaryMixed . '--' . $ this -> CRLF ; return $ in ; } 
public function findFile ( $ class ) { $ file = wincache_ucache_get ( $ this -> prefix . $ class , $ success ) ; if ( ! $ success ) { wincache_ucache_set ( $ this -> prefix . $ class , $ file = $ this -> decorated -> findFile ( $ class ) ? : null , 0 ) ; } return $ file ; } 
public function findFile ( $ class ) { $ file = apcu_fetch ( $ this -> prefix . $ class , $ success ) ; if ( ! $ success ) { apcu_store ( $ this -> prefix . $ class , $ file = $ this -> decorated -> findFile ( $ class ) ? : null ) ; } return $ file ; } 
public static function load ( $ classes , $ cacheDir , $ name , $ autoReload , $ adaptive = false , $ extension = '.php' ) { 
public static function inline ( $ classes , $ cache , array $ excluded ) { $ declared = array ( ) ; foreach ( self :: getOrderedClasses ( $ excluded ) as $ class ) { $ declared [ $ class -> getName ( ) ] = true ; } '(?: ^<\?php\s.declare.\(.strict_types.=.1.\).; | \b__halt_compiler.\(.\) | \b__(?:DIR|FILE)__\b )'isx REGEX ; $ dontInlineRegex = str_replace ( '.' , $ spacesRegex , $ dontInlineRegex ) ; $ cacheDir = explode ( '/' , str_replace ( DIRECTORY_SEPARATOR , '/' , $ cacheDir ) ) ; $ files = array ( ) ; $ content = '' ; foreach ( self :: getOrderedClasses ( $ classes ) as $ class ) { if ( isset ( $ declared [ $ class -> getName ( ) ] ) ) { continue ; } $ declared [ $ class -> getName ( ) ] = true ; $ files [ $ class -> getName ( ) ] = $ file = $ class -> getFileName ( ) ; $ c = file_get_contents ( $ file ) ; if ( preg_match ( $ dontInlineRegex , $ c ) ) { $ file = explode ( '/' , str_replace ( DIRECTORY_SEPARATOR , '/' , $ file ) ) ; for ( $ i = 0 ; isset ( $ file [ $ i ] , $ cacheDir [ $ i ] ) ; ++ $ i ) { if ( $ file [ $ i ] !== $ cacheDir [ $ i ] ) { break ; } } if ( 1 >= $ i ) { $ file = var_export ( implode ( '/' , $ file ) , true ) ; } else { $ file = array_slice ( $ file , $ i ) ; $ file = str_repeat ( '../' , count ( $ cacheDir ) - $ i ) . implode ( '/' , $ file ) ; $ file = '__DIR__.' . var_export ( '/' . $ file , true ) ; } $ c = "\nnamespace {require $file;}" ; } else { $ c = preg_replace ( array ( '/^\s*<\?php/' , '/\?>\s*$/' ) , '' , $ c ) ; 
public static function fixNamespaceDeclarations ( $ source ) { if ( ! function_exists ( 'token_get_all' ) || ! self :: $ useTokenizer ) { if ( preg_match ( '/(^|\s)namespace(.*?)\s*;/' , $ source ) ) { $ source = preg_replace ( '/(^|\s)namespace(.*?)\s*;/' , "$1namespace$2\n{" , $ source ) . "}\n" ; } return $ source ; } $ rawChunk = '' ; $ output = '' ; $ inNamespace = false ; $ tokens = token_get_all ( $ source ) ; for ( $ i = 0 ; isset ( $ tokens [ $ i ] ) ; ++ $ i ) { $ token = $ tokens [ $ i ] ; if ( ! isset ( $ token [ 1 ] ) || 'b"' === $ token ) { $ rawChunk .= $ token ; } elseif ( in_array ( $ token [ 0 ] , array ( T_COMMENT , T_DOC_COMMENT ) ) ) { 
private static function writeCacheFile ( $ file , $ content ) { $ dir = dirname ( $ file ) ; if ( ! is_writable ( $ dir ) ) { throw new \ RuntimeException ( sprintf ( 'Cache directory "%s" is not writable.' , $ dir ) ) ; } $ tmpFile = tempnam ( $ dir , basename ( $ file ) ) ; if ( false !== @ file_put_contents ( $ tmpFile , $ content ) && @ rename ( $ tmpFile , $ file ) ) { @ chmod ( $ file , 0666 & ~ umask ( ) ) ; return ; } throw new \ RuntimeException ( sprintf ( 'Failed to write cache file "%s".' , $ file ) ) ; } 
private static function getOrderedClasses ( array $ classes ) { $ map = array ( ) ; self :: $ seen = array ( ) ; foreach ( $ classes as $ class ) { try { $ reflectionClass = new \ ReflectionClass ( $ class ) ; } catch ( \ ReflectionException $ e ) { throw new \ InvalidArgumentException ( sprintf ( 'Unable to load class "%s"' , $ class ) ) ; } $ map = array_merge ( $ map , self :: getClassHierarchy ( $ reflectionClass ) ) ; } return $ map ; } 
public function addPrefixes ( array $ prefixes ) { foreach ( $ prefixes as $ prefix => $ path ) { $ this -> addPrefix ( $ prefix , $ path ) ; } } 
public function addPrefix ( $ prefix , $ paths ) { if ( ! $ prefix ) { foreach ( ( array ) $ paths as $ path ) { $ this -> fallbackDirs [ ] = $ path ; } return ; } if ( isset ( $ this -> prefixes [ $ prefix ] ) ) { if ( is_array ( $ paths ) ) { $ this -> prefixes [ $ prefix ] = array_unique ( array_merge ( $ this -> prefixes [ $ prefix ] , $ paths ) ) ; } elseif ( ! in_array ( $ paths , $ this -> prefixes [ $ prefix ] ) ) { $ this -> prefixes [ $ prefix ] [ ] = $ paths ; } } else { $ this -> prefixes [ $ prefix ] = array_unique ( ( array ) $ paths ) ; } } 
public function findFile ( $ class ) { if ( xcache_isset ( $ this -> prefix . $ class ) ) { $ file = xcache_get ( $ this -> prefix . $ class ) ; } else { $ file = $ this -> decorated -> findFile ( $ class ) ? : null ; xcache_set ( $ this -> prefix . $ class , $ file ) ; } return $ file ; } 
public function parse ( $ text ) { $ this -> prepare ( ) ; if ( ltrim ( $ text ) === '' ) { return '' ; } $ text = str_replace ( [ "\r\n" , "\n\r" , "\r" ] , "\n" , $ text ) ; $ this -> prepareMarkers ( $ text ) ; $ absy = $ this -> parseBlocks ( explode ( "\n" , $ text ) ) ; $ markup = $ this -> renderAbsy ( $ absy ) ; $ this -> cleanup ( ) ; return $ markup ; } 
public function parseParagraph ( $ text ) { $ this -> prepare ( ) ; if ( ltrim ( $ text ) === '' ) { return '' ; } $ text = str_replace ( [ "\r\n" , "\n\r" , "\r" ] , "\n" , $ text ) ; $ this -> prepareMarkers ( $ text ) ; $ absy = $ this -> parseInline ( $ text ) ; $ markup = $ this -> renderAbsy ( $ absy ) ; $ this -> cleanup ( ) ; return $ markup ; } 
protected function detectLineType ( $ lines , $ current ) { $ line = $ lines [ $ current ] ; $ blockTypes = $ this -> blockTypes ( ) ; foreach ( $ blockTypes as $ blockType ) { if ( $ this -> { 'identify' . $ blockType } ( $ line , $ lines , $ current ) ) { return $ blockType ; } } 
protected function parseBlocks ( $ lines ) { if ( $ this -> _depth >= $ this -> maximumNestingLevel ) { 
protected function parseBlock ( $ lines , $ current ) { 
protected function consumeParagraph ( $ lines , $ current ) { 
protected function inlineMarkers ( ) { $ markers = [ ] ; 
protected function prepareMarkers ( $ text ) { $ this -> _inlineMarkers = [ ] ; foreach ( $ this -> inlineMarkers ( ) as $ marker => $ method ) { if ( strpos ( $ text , $ marker ) !== false ) { $ m = $ marker [ 0 ] ; 
protected function parseInline ( $ text ) { if ( $ this -> _depth >= $ this -> maximumNestingLevel ) { 
protected function parseEmphStrong ( $ text ) { $ marker = $ text [ 0 ] ; if ( ! isset ( $ text [ 1 ] ) ) { return [ [ 'text' , $ text [ 0 ] ] , 1 ] ; } if ( $ marker == $ text [ 1 ] ) { 
protected function identifyHtml ( $ line , $ lines , $ current ) { if ( $ line [ 0 ] !== '<' || isset ( $ line [ 1 ] ) && $ line [ 1 ] == ' ' ) { return false ; 
protected function consumeHtml ( $ lines , $ current ) { $ content = [ ] ; if ( strncmp ( $ lines [ $ current ] , '<!--' , 4 ) === 0 ) { 
protected function parseInlineHtml ( $ text ) { if ( strpos ( $ text , '>' ) !== false ) { if ( preg_match ( '~^</?(\w+\d?)( .*?)?>~s' , $ text , $ matches ) ) { 
protected function identifyFencedCode ( $ line ) { return ( $ line [ 0 ] === '`' && strncmp ( $ line , '```' , 3 ) === 0 ) || ( $ line [ 0 ] === '~' && strncmp ( $ line , '~~~' , 3 ) === 0 ) || ( isset ( $ line [ 3 ] ) && ( ( $ line [ 3 ] === '`' && strncmp ( ltrim ( $ line ) , '```' , 3 ) === 0 ) || ( $ line [ 3 ] === '~' && strncmp ( ltrim ( $ line ) , '~~~' , 3 ) === 0 ) ) ) ; } 
protected function consumeFencedCode ( $ lines , $ current ) { $ line = ltrim ( $ lines [ $ current ] ) ; $ fence = substr ( $ line , 0 , $ pos = strrpos ( $ line , $ line [ 0 ] ) + 1 ) ; $ language = rtrim ( substr ( $ line , $ pos ) ) ; 
protected function identifyHeadline ( $ line , $ lines , $ current ) { return ( 
protected function consumeHeadline ( $ lines , $ current ) { if ( $ lines [ $ current ] [ 0 ] === '#' ) { 
protected function replaceEscape ( $ text ) { $ strtr = [ ] ; foreach ( $ this -> escapeCharacters as $ char ) { $ strtr [ "\\$char" ] = $ char ; } return strtr ( $ text , $ strtr ) ; } 
protected function parseLink ( $ markdown ) { if ( ! in_array ( 'parseLink' , array_slice ( $ this -> context , 1 ) ) && ( $ parts = $ this -> parseLinkOrImage ( $ markdown ) ) !== false ) { list ( $ text , $ url , $ title , $ offset , $ key ) = $ parts ; return [ [ 'link' , 'text' => $ this -> parseInline ( $ text ) , 'url' => $ url , 'title' => $ title , 'refkey' => $ key , 'orig' => substr ( $ markdown , 0 , $ offset ) , ] , $ offset ] ; } else { 
protected function parseImage ( $ markdown ) { if ( ( $ parts = $ this -> parseLinkOrImage ( substr ( $ markdown , 1 ) ) ) !== false ) { list ( $ text , $ url , $ title , $ offset , $ key ) = $ parts ; return [ [ 'image' , 'text' => $ text , 'url' => $ url , 'title' => $ title , 'refkey' => $ key , 'orig' => substr ( $ markdown , 0 , $ offset + 1 ) , ] , $ offset + 1 ] ; } else { 
protected function parseLt ( $ text ) { if ( strpos ( $ text , '>' ) !== false ) { if ( ! in_array ( 'parseLink' , $ this -> context ) ) { 
protected function parseInlineCode ( $ text ) { if ( preg_match ( '/^(``+)\s(.+?)\s\1/s' , $ text , $ matches ) ) { 
protected function consumeParagraph ( $ lines , $ current ) { 
protected function renderText ( $ text ) { if ( $ this -> enableNewlines ) { $ br = $ this -> html5 ? "<br>\n" : "<br />\n" ; return strtr ( $ text [ 1 ] , [ " \n" => $ br , "\n" => $ br ] ) ; } else { return parent :: renderText ( $ text ) ; } } 
protected function consumeParagraph ( $ lines , $ current ) { 
protected function consumeCode ( $ lines , $ current ) { 
protected function identifyUl ( $ line ) { $ l = $ line [ 0 ] ; return ( $ l === '-' || $ l === '+' || $ l === '*' ) && ( isset ( $ line [ 1 ] ) && ( ( $ l1 = $ line [ 1 ] ) === ' ' || $ l1 === "\t" ) ) || ( $ l === ' ' && preg_match ( '/^ {0,3}[\-\+\*][ \t]/' , $ line ) ) ; } 
protected function renderList ( $ block ) { $ type = $ block [ 'list' ] ; if ( ! empty ( $ block [ 'attr' ] ) ) { $ output = "<$type " . $ this -> generateHtmlAttributes ( $ block [ 'attr' ] ) . ">\n" ; } else { $ output = "<$type>\n" ; } foreach ( $ block [ 'items' ] as $ item => $ itemLines ) { $ output .= '<li>' . $ this -> renderAbsy ( $ itemLines ) . "</li>\n" ; } return $ output . "</$type>\n" ; } 
private function generateHtmlAttributes ( $ attributes ) { foreach ( $ attributes as $ name => $ value ) { $ attributes [ $ name ] = "$name=\"$value\"" ; } return implode ( ' ' , $ attributes ) ; } 
protected function consumeQuote ( $ lines , $ current ) { 
protected function consumeReference ( $ lines , $ current ) { while ( isset ( $ lines [ $ current ] ) && preg_match ( '/^ {0,3}\[(.+?)\]:\s*(.+?)(?:\s+[\(\'"](.+?)[\)\'"])?\s*(' . $ this -> _specialAttributesRegex . ')?\s*$/' , $ lines [ $ current ] , $ matches ) ) { $ label = strtolower ( $ matches [ 1 ] ) ; $ this -> references [ $ label ] = [ 'url' => $ this -> replaceEscape ( $ matches [ 2 ] ) , ] ; if ( isset ( $ matches [ 3 ] ) ) { $ this -> references [ $ label ] [ 'title' ] = $ matches [ 3 ] ; } else { // title may be on the next line if ( isset ( $ lines [ $ current + 1 ] ) && preg_match ( '/^\s+[\(\'"](.+?)[\)\'"]\s*$/' , $ lines [ $ current + 1 ] , $ matches ) ) { $ this -> references [ $ label ] [ 'title' ] = $ matches [ 1 ] ; $ current ++ ; } } if ( isset ( $ matches [ 5 ] ) ) { $ this -> references [ $ label ] [ 'attributes' ] = $ matches [ 5 ] ; } $ current ++ ; } return [ false , -- $ current ] ; } 
protected function consumeFencedCode ( $ lines , $ current ) { 
protected function renderHeadline ( $ block ) { foreach ( $ block [ 'content' ] as $ i => $ element ) { if ( $ element [ 0 ] === 'specialAttributes' ) { unset ( $ block [ 'content' ] [ $ i ] ) ; $ block [ 'attributes' ] = $ element [ 1 ] ; } } $ tag = 'h' . $ block [ 'level' ] ; $ attributes = $ this -> renderAttributes ( $ block ) ; return "<$tag$attributes>" . rtrim ( $ this -> renderAbsy ( $ block [ 'content' ] ) , "# \t" ) . "</$tag>\n" ; } 
protected function parseStrike ( $ markdown ) { if ( preg_match ( '/^~~(.+?)~~/' , $ markdown , $ matches ) ) { return [ [ 'strike' , $ this -> parseInline ( $ matches [ 1 ] ) ] , strlen ( $ matches [ 0 ] ) ] ; } return [ [ 'text' , $ markdown [ 0 ] . $ markdown [ 1 ] ] , 2 ] ; } 
protected function identifyTable ( $ line , $ lines , $ current ) { return strpos ( $ line , '|' ) !== false && isset ( $ lines [ $ current + 1 ] ) && preg_match ( '~^\\s*\\|?(\\s*:?-[\\-\\s]*:?\\s*\\|?)*\\s*$~' , $ lines [ $ current + 1 ] ) && strpos ( $ lines [ $ current + 1 ] , '|' ) !== false && isset ( $ lines [ $ current + 2 ] ) && trim ( $ lines [ $ current + 1 ] ) !== '' ; } 
protected function consumeTable ( $ lines , $ current ) { 
protected function renderTable ( $ block ) { $ head = '' ; $ body = '' ; $ cols = $ block [ 'cols' ] ; $ first = true ; foreach ( $ block [ 'rows' ] as $ row ) { $ cellTag = $ first ? 'th' : 'td' ; $ tds = '' ; foreach ( $ row as $ c => $ cell ) { $ align = empty ( $ cols [ $ c ] ) ? '' : ' align="' . $ cols [ $ c ] . '"' ; $ tds .= "<$cellTag$align>" . trim ( $ this -> renderAbsy ( $ cell ) ) . "</$cellTag>" ; } if ( $ first ) { $ head .= "<tr>$tds</tr>\n" ; } else { $ body .= "<tr>$tds</tr>\n" ; } $ first = false ; } return $ this -> composeTable ( $ head , $ body ) ; } 
protected function parseUrl ( $ markdown ) { $ pattern = <<<REGEXP /(?(R) # in case of recursion match parentheses \(((?>[^\s()]+)|(?R))*\) | # else match a link with title ^(https?|ftp):\/\/(([^\s<>()]+)|(?R))+(?<![\.,:;\'"!\?\s]) )/x REGEXP ; if ( ! in_array ( 'parseLink' , $ this -> context ) && preg_match ( $ pattern , $ markdown , $ matches ) ) { return [ [ 'autoUrl' , $ matches [ 0 ] ] , strlen ( $ matches [ 0 ] ) ] ; } return [ [ 'text' , substr ( $ markdown , 0 , 4 ) ] , 4 ] ; } 
protected function doExecute ( ProfileContext $ context ) { MessageContextHelper :: asSamlMessage ( $ context -> getOutboundContext ( ) ) -> setVersion ( $ this -> version ) ; $ this -> logger -> debug ( sprintf ( 'Message Version set to "%s"' , $ this -> version ) , LogHelper :: getActionContext ( $ context , $ this ) ) ; } 
private function getTrustOptions ( EntityDescriptor $ idpEd ) { $ trustOptions = $ this -> container -> getPartyContainer ( ) -> getTrustOptionsStore ( ) -> get ( $ this -> idpEntityId ) ? : new TrustOptions ( ) ; $ wantAuthnRequestsSigned = $ idpEd -> getFirstIdpSsoDescriptor ( ) -> getWantAuthnRequestsSigned ( ) ; if ( null !== $ wantAuthnRequestsSigned ) { $ trustOptions -> setSignAuthnRequest ( $ wantAuthnRequestsSigned ) ; } return $ trustOptions ; } 
public function execute ( ContextInterface $ context ) { if ( $ context instanceof ProfileContext ) { $ this -> doExecute ( $ context ) ; } else { $ message = sprintf ( 'Expected ProfileContext but got %s' , get_class ( $ context ) ) ; $ this -> logger -> emergency ( $ message , array ( 'context' => $ context ) ) ; throw new LightSamlContextException ( $ context , $ message ) ; } } 
public function resolve ( CriteriaSet $ criteriaSet , array $ candidates ) { if ( false === $ criteriaSet -> has ( LocationCriteria :: class ) ) { return $ candidates ; } $ result = array ( ) ; foreach ( $ criteriaSet -> get ( LocationCriteria :: class ) as $ locationCriteria ) { foreach ( $ candidates as $ endpointReference ) { if ( $ endpointReference -> getEndpoint ( ) -> getLocation ( ) == $ locationCriteria -> getLocation ( ) ) { $ result [ ] = $ endpointReference ; } } } return $ result ; } 
public function setUse ( $ use ) { $ use = trim ( $ use ) ; if ( false != $ use && self :: USE_ENCRYPTION != $ use && self :: USE_SIGNING != $ use ) { throw new \ InvalidArgumentException ( sprintf ( "Invalid use value '%s'" , $ use ) ) ; } $ this -> use = $ use ; return $ this ; } 
public function serialize ( \ DOMNode $ parent , SerializationContext $ context ) { $ result = $ this -> createElement ( 'KeyDescriptor' , SamlConstants :: NS_METADATA , $ parent , $ context ) ; $ this -> attributesToXml ( array ( 'use' ) , $ result ) ; $ keyInfo = $ this -> createElement ( 'ds:KeyInfo' , SamlConstants :: NS_XMLDSIG , $ result , $ context ) ; $ xData = $ this -> createElement ( 'ds:X509Data' , SamlConstants :: NS_XMLDSIG , $ keyInfo , $ context ) ; $ xCert = $ this -> createElement ( 'ds:X509Certificate' , SamlConstants :: NS_XMLDSIG , $ xData , $ context ) ; $ xCert -> nodeValue = $ this -> getCertificate ( ) -> getData ( ) ; } 
public function execute ( ContextInterface $ context ) { try { $ this -> mainAction -> execute ( $ context ) ; } catch ( \ Exception $ ex ) { $ exceptionContext = $ context -> getSubContext ( ProfileContexts :: EXCEPTION , ExceptionContext :: class ) ; $ exceptionContext -> addException ( $ ex ) ; $ this -> errorAction -> execute ( $ context ) ; } } 
public function decryptMulti ( array $ inputKeys ) { $ lastException = null ; foreach ( $ inputKeys as $ key ) { if ( $ key instanceof CredentialInterface ) { $ key = $ key -> getPrivateKey ( ) ; } if ( false == $ key instanceof XMLSecurityKey ) { throw new \ InvalidArgumentException ( 'Expected XMLSecurityKey' ) ; } try { return $ this -> decrypt ( $ key ) ; } catch ( \ Exception $ ex ) { $ lastException = $ ex ; } } if ( $ lastException ) { throw $ lastException ; } throw new LightSamlSecurityException ( 'No key provided for decryption' ) ; } 
public function decrypt ( XMLSecurityKey $ inputKey ) { $ this -> symmetricKey = $ this -> loadSymmetricKey ( ) ; $ this -> symmetricKeyInfo = $ this -> loadSymmetricKeyInfo ( $ this -> symmetricKey ) ; if ( $ this -> symmetricKeyInfo -> isEncrypted ) { $ this -> decryptSymmetricKey ( $ inputKey ) ; } else { $ this -> symmetricKey = $ inputKey ; } $ decrypted = $ this -> decryptCipher ( ) ; $ result = $ this -> buildXmlElement ( $ decrypted ) ; return $ result ; } 
protected function buildXmlElement ( $ decrypted ) { $ xml = sprintf ( '<root xmlns:saml="urn:oasis:names:tc:SAML:2.0:assertion" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">%s</root>' , $ decrypted ) ; $ newDoc = new \ DOMDocument ( ) ; if ( false == @ $ newDoc -> loadXML ( $ xml ) ) { throw new LightSamlXmlException ( 'Failed to parse decrypted XML. Maybe the wrong sharedkey was used?' ) ; } $ decryptedElement = $ newDoc -> firstChild -> firstChild ; if ( null == $ decryptedElement ) { throw new LightSamlSecurityException ( 'Missing encrypted element.' ) ; } if ( false == $ decryptedElement instanceof \ DOMElement ) { throw new LightSamlXmlException ( 'Decrypted element was not actually a DOMElement.' ) ; } return $ decryptedElement ; } 
protected function decryptCipher ( ) { $ decrypted = $ this -> xmlEnc -> decryptNode ( $ this -> symmetricKey , false ) ; if ( false == is_string ( $ decrypted ) ) { throw new \ LogicException ( 'Expected decrypted string' ) ; } return $ decrypted ; } 
protected function decryptSymmetricKey ( XMLSecurityKey $ inputKey ) { $ encKey = $ this -> symmetricKeyInfo -> encryptedCtx ; $ this -> symmetricKeyInfo -> key = $ inputKey -> key ; $ keySize = $ this -> symmetricKey -> getSymmetricKeySize ( ) ; if ( null === $ keySize ) { 
protected function loadSymmetricKeyInfo ( XMLSecurityKey $ symmetricKey ) { $ symmetricKeyInfo = $ this -> xmlEnc -> locateKeyInfo ( $ symmetricKey ) ; if ( false == $ symmetricKeyInfo ) { throw new LightSamlXmlException ( 'Could not locate <dsig:KeyInfo> for the encrypted key' ) ; } return $ symmetricKeyInfo ; } 
protected function doExecute ( ProfileContext $ context ) { $ message = MessageContextHelper :: asSamlMessage ( $ context -> getInboundContext ( ) ) ; if ( false == $ message -> getIssuer ( ) ) { $ message = 'Inbound message must have Issuer element' ; $ this -> logger -> emergency ( $ message , LogHelper :: getActionErrorContext ( $ context , $ this ) ) ; throw new LightSamlContextException ( $ context , $ message ) ; } if ( $ this -> allowedFormat && $ message -> getIssuer ( ) -> getValue ( ) && $ message -> getIssuer ( ) -> getFormat ( ) && $ message -> getIssuer ( ) -> getFormat ( ) != $ this -> allowedFormat ) { $ message = sprintf ( "Response Issuer Format if set must have value '%s' but it was '%s'" , $ this -> allowedFormat , $ message -> getIssuer ( ) -> getFormat ( ) ) ; $ this -> logger -> emergency ( $ message , LogHelper :: getActionErrorContext ( $ context , $ this ) ) ; throw new LightSamlContextException ( $ context , $ message ) ; } try { $ this -> nameIdValidator -> validateNameId ( $ message -> getIssuer ( ) ) ; } catch ( LightSamlValidationException $ ex ) { throw new LightSamlContextException ( $ context , $ ex -> getMessage ( ) , 0 , $ ex ) ; } } 
public function validateSubject ( Subject $ subject ) { if ( false == $ subject -> getNameID ( ) && false == $ subject -> getAllSubjectConfirmations ( ) ) { throw new LightSamlValidationException ( 'Subject MUST contain either an identifier or a subject confirmation' ) ; } if ( $ subject -> getNameID ( ) ) { $ this -> nameIdValidator -> validateNameId ( $ subject -> getNameID ( ) ) ; } foreach ( $ subject -> getAllSubjectConfirmations ( ) as $ subjectConfirmation ) { $ this -> validateSubjectConfirmation ( $ subjectConfirmation ) ; } } 
protected function validateSubjectConfirmation ( SubjectConfirmation $ subjectConfirmation ) { if ( false == Helper :: validateRequiredString ( $ subjectConfirmation -> getMethod ( ) ) ) { throw new LightSamlValidationException ( 'Method attribute of SubjectConfirmation MUST contain at least one non-whitespace character' ) ; } if ( false == Helper :: validateWellFormedUriString ( $ subjectConfirmation -> getMethod ( ) ) ) { throw new LightSamlValidationException ( 'SubjectConfirmation element has Method attribute which is not a wellformed absolute uri.' ) ; } if ( $ subjectConfirmation -> getNameID ( ) ) { $ this -> nameIdValidator -> validateNameId ( $ subjectConfirmation -> getNameID ( ) ) ; } if ( $ subjectConfirmation -> getSubjectConfirmationData ( ) ) { $ this -> validateSubjectConfirmationData ( $ subjectConfirmation -> getSubjectConfirmationData ( ) ) ; } } 
public function loadPem ( $ data ) { $ pattern = '/^-----BEGIN CERTIFICATE-----([^-]*)^-----END CERTIFICATE-----/m' ; if ( false == preg_match ( $ pattern , $ data , $ matches ) ) { throw new \ InvalidArgumentException ( 'Invalid PEM encoded certificate' ) ; } $ this -> data = preg_replace ( '/\s+/' , '' , $ matches [ 1 ] ) ; $ this -> parse ( ) ; return $ this ; } 
public function loadFromFile ( $ filename ) { if ( ! is_file ( $ filename ) ) { throw new \ InvalidArgumentException ( sprintf ( "File not found '%s'" , $ filename ) ) ; } $ content = file_get_contents ( $ filename ) ; $ this -> loadPem ( $ content ) ; return $ this ; } 
public function validate ( XMLSecurityKey $ key ) { if ( null == $ this -> signature ) { return false ; } if ( false == $ this -> signature -> validateReference ( ) ) { throw new LightSamlSecurityException ( 'Digest validation failed' ) ; } $ key = $ this -> castKeyIfNecessary ( $ key ) ; if ( false == $ this -> signature -> verify ( $ key ) ) { throw new LightSamlSecurityException ( 'Unable to verify Signature' ) ; } return true ; } 
public function getAlgorithm ( ) { $ xpath = new \ DOMXPath ( $ this -> signature -> sigNode instanceof \ DOMDocument ? $ this -> signature -> sigNode : $ this -> signature -> sigNode -> ownerDocument ) ; $ xpath -> registerNamespace ( 'ds' , XMLSecurityDSig :: XMLDSIGNS ) ; $ list = $ xpath -> query ( './ds:SignedInfo/ds:SignatureMethod' , $ this -> signature -> sigNode ) ; if ( ! $ list || 0 == $ list -> length ) { throw new LightSamlXmlException ( 'Missing SignatureMethod element' ) ; } $ sigMethod = $ list -> item ( 0 ) ; if ( ! $ sigMethod -> hasAttribute ( 'Algorithm' ) ) { throw new LightSamlXmlException ( 'Missing Algorithm-attribute on SignatureMethod element.' ) ; } $ algorithm = $ sigMethod -> getAttribute ( 'Algorithm' ) ; return $ algorithm ; } 
public function deserialize ( \ DOMNode $ node , DeserializationContext $ context ) { $ this -> checkXmlNodeName ( $ node , 'Signature' , SamlConstants :: NS_XMLDSIG ) ; $ this -> signature = new XMLSecurityDSig ( ) ; $ this -> signature -> idKeys [ ] = $ this -> getIDName ( ) ; $ this -> signature -> sigNode = $ node ; $ this -> signature -> canonicalizeSignedInfo ( ) ; $ this -> key = null ; $ key = new XMLSecurityKey ( XMLSecurityKey :: RSA_SHA1 , array ( 'type' => 'public' ) ) ; XMLSecEnc :: staticLocateKeyInfo ( $ key , $ node ) ; if ( $ key -> name || $ key -> key ) { $ this -> key = $ key ; } $ this -> certificates = array ( ) ; $ list = $ context -> getXpath ( ) -> query ( './ds:KeyInfo/ds:X509Data/ds:X509Certificate' , $ node ) ; foreach ( $ list as $ certNode ) { $ certData = trim ( $ certNode -> textContent ) ; $ certData = str_replace ( array ( "\r" , "\n" , "\t" , ' ' ) , '' , $ certData ) ; $ this -> certificates [ ] = $ certData ; } } 
public function validateMulti ( array $ credentialCandidates ) { $ lastException = null ; foreach ( $ credentialCandidates as $ credential ) { if ( false == $ credential instanceof CredentialInterface ) { throw new \ InvalidArgumentException ( 'Expected CredentialInterface' ) ; } if ( null == $ credential -> getPublicKey ( ) ) { continue ; } try { $ result = $ this -> validate ( $ credential -> getPublicKey ( ) ) ; if ( false === $ result ) { return null ; } return $ credential ; } catch ( LightSamlSecurityException $ ex ) { $ lastException = $ ex ; } } if ( $ lastException ) { throw $ lastException ; } else { throw new LightSamlSecurityException ( 'No public key available for signature verification' ) ; } } 
protected function castKeyIfNecessary ( XMLSecurityKey $ key ) { $ algorithm = $ this -> getAlgorithm ( ) ; if ( ! in_array ( $ algorithm , [ XMLSecurityKey :: RSA_SHA1 , XMLSecurityKey :: RSA_SHA256 , XMLSecurityKey :: RSA_SHA384 , XMLSecurityKey :: RSA_SHA512 , ] ) ) { throw new LightSamlSecurityException ( sprintf ( 'Unsupported signing algorithm: "%s"' , $ algorithm ) ) ; } if ( $ algorithm != $ key -> type ) { $ key = KeyHelper :: castKey ( $ key , $ algorithm ) ; } return $ key ; } 
public function resolve ( CriteriaSet $ criteriaSet , array $ arrCredentials = array ( ) ) { if ( false == $ criteriaSet -> has ( CredentialNameCriteria :: class ) ) { return $ arrCredentials ; } $ result = array ( ) ; foreach ( $ criteriaSet -> get ( CredentialNameCriteria :: class ) as $ criteria ) { foreach ( $ arrCredentials as $ credential ) { $ arrCredentialNames = $ credential -> getKeyNames ( ) ; $ criteriaName = $ criteria -> getName ( ) ; foreach ( $ arrCredentialNames as $ credentialName ) { if ( $ credentialName == $ criteriaName ) { $ result [ ] = $ credential ; break ; } } } } return $ result ; } 
public function resolve ( CriteriaSet $ criteriaSet , array $ arrCredentials = array ( ) ) { $ result = array ( ) ; foreach ( $ criteriaSet -> get ( EntityIdCriteria :: class ) as $ criteria ) { $ result = array_merge ( $ result , $ this -> credentialStore -> getByEntityId ( $ criteria -> getEntityId ( ) ) ) ; } return $ result ; } 
public function resolve ( CriteriaSet $ criteriaSet , array $ candidates ) { if ( false === $ criteriaSet -> has ( ServiceTypeCriteria :: class ) ) { return $ candidates ; } $ result = array ( ) ; foreach ( $ criteriaSet -> get ( ServiceTypeCriteria :: class ) as $ serviceTypeCriteria ) { foreach ( $ candidates as $ endpointReference ) { $ type = $ serviceTypeCriteria -> getServiceType ( ) ; if ( $ endpointReference -> getEndpoint ( ) instanceof $ type ) { $ result [ ] = $ endpointReference ; } } } return $ result ; } 
public static function asSamlMessage ( MessageContext $ context ) { $ message = $ context -> getMessage ( ) ; if ( $ message ) { return $ message ; } throw new LightSamlContextException ( $ context , 'Missing SamlMessage' ) ; } 
public static function asAuthnRequest ( MessageContext $ context ) { $ message = $ context -> getMessage ( ) ; if ( $ message instanceof AuthnRequest ) { return $ message ; } throw new LightSamlContextException ( $ context , 'Expected AuthnRequest' ) ; } 
public static function asAbstractRequest ( MessageContext $ context ) { $ message = $ context -> getMessage ( ) ; if ( $ message instanceof AbstractRequest ) { return $ message ; } throw new LightSamlContextException ( $ context , 'Expected AbstractRequest' ) ; } 
public static function asResponse ( MessageContext $ context ) { $ message = $ context -> getMessage ( ) ; if ( $ message instanceof Response ) { return $ message ; } throw new LightSamlContextException ( $ context , 'Expected Response' ) ; } 
public static function asStatusResponse ( MessageContext $ context ) { $ message = $ context -> getMessage ( ) ; if ( $ message instanceof StatusResponse ) { return $ message ; } throw new LightSamlContextException ( $ context , 'Expected StatusResponse' ) ; } 
public static function asLogoutRequest ( MessageContext $ context ) { $ message = $ context -> getMessage ( ) ; if ( $ message instanceof LogoutRequest ) { return $ message ; } throw new LightSamlContextException ( $ context , 'Expected LogoutRequest' ) ; } 
public static function asLogoutResponse ( MessageContext $ context ) { $ message = $ context -> getMessage ( ) ; if ( $ message instanceof LogoutResponse ) { return $ message ; } throw new LightSamlContextException ( $ context , 'Expected LogoutResponse' ) ; } 
protected function doExecute ( ProfileContext $ context ) { $ this -> flush ( $ context -> getInboundContext ( ) -> getSubContext ( ProfileContexts :: REQUEST_STATE , null ) ) ; foreach ( $ context as $ child ) { if ( $ child instanceof AssertionContext ) { $ this -> flush ( $ child -> getSubContext ( ProfileContexts :: REQUEST_STATE , null ) ) ; } } } 
protected function getPartyEntityDescriptor ( ProfileContext $ context , EntityDescriptorStoreInterface $ entityDescriptorProvider , $ entityId ) { $ partyEntityDescriptor = $ entityDescriptorProvider -> get ( $ entityId ) ; if ( null === $ partyEntityDescriptor ) { $ message = sprintf ( "Unknown issuer '%s'" , $ entityId ) ; $ this -> logger -> emergency ( $ message , LogHelper :: getActionErrorContext ( $ context , $ this ) ) ; throw new LightSamlContextException ( $ context , $ message ) ; } return $ partyEntityDescriptor ; } 
public function getOtherPartyId ( $ partyId ) { if ( $ partyId == $ this -> idpEntityId ) { return $ this -> spEntityId ; } elseif ( $ partyId == $ this -> spEntityId ) { return $ this -> idpEntityId ; } throw new LightSamlException ( sprintf ( 'Party "%s" is not included in sso session between "%s" and "%s"' , $ partyId , $ this -> idpEntityId , $ this -> spEntityId ) ) ; } 
public function unserialize ( $ serialized ) { $ data = unserialize ( $ serialized ) ; 
protected function doExecute ( AssertionContext $ context ) { if ( $ context -> getAssertion ( ) -> getAllAuthnStatements ( ) && $ context -> getAssertion ( ) -> hasBearerSubject ( ) ) { $ this -> validateBearerAssertion ( $ context ) ; } } 
public function serialize ( \ DOMNode $ parent , SerializationContext $ context ) { if ( ! $ this -> lang ) { throw new LightSamlXmlException ( 'Lang is required' ) ; } $ result = $ this -> createElement ( 'Organization' , SamlConstants :: NS_METADATA , $ parent , $ context ) ; $ elements = array ( 'OrganizationName' , 'OrganizationDisplayName' , 'OrganizationURL' ) ; $ this -> singleElementsToXml ( $ elements , $ result , $ context , SamlConstants :: NS_METADATA ) ; foreach ( $ result -> childNodes as $ node ) { if ( $ node instanceof \ DOMElement ) { if ( in_array ( $ node -> tagName , $ elements ) ) { $ node -> setAttribute ( 'xml:lang' , $ this -> lang ) ; } } } } 
protected function supportsSession ( Assertion $ assertion ) { return $ assertion -> hasBearerSubject ( ) && null != $ assertion -> getSubject ( ) && null != $ assertion -> getSubject ( ) -> getNameID ( ) ; } 
protected function createSession ( SsoState $ ssoState , Assertion $ assertion , \ DateTime $ now , $ ownEntityId , $ partyEntityId ) { $ ssoSession = new SsoSessionState ( ) ; $ ssoSession -> setIdpEntityId ( $ partyEntityId ) -> setSpEntityId ( $ ownEntityId ) -> setNameId ( $ assertion -> getSubject ( ) -> getNameID ( ) -> getValue ( ) ) -> setNameIdFormat ( $ assertion -> getSubject ( ) -> getNameID ( ) -> getFormat ( ) ) -> setSessionIndex ( $ assertion -> getFirstAuthnStatement ( ) -> getSessionIndex ( ) ) -> setSessionInstant ( $ assertion -> getFirstAuthnStatement ( ) -> getAuthnInstantDateTime ( ) ) -> setFirstAuthOn ( $ now ) -> setLastAuthOn ( $ now ) ; $ ssoState -> addSsoSession ( $ ssoSession ) ; return $ ssoSession ; } 
protected function filterSessions ( SsoState $ ssoState , Assertion $ assertion , $ ownEntityId , $ partyEntityId ) { return $ ssoState -> filter ( $ partyEntityId , $ ownEntityId , $ assertion -> getSubject ( ) -> getNameID ( ) -> getValue ( ) , $ assertion -> getSubject ( ) -> getNameID ( ) -> getFormat ( ) , $ assertion -> getFirstAuthnStatement ( ) -> getSessionIndex ( ) ) ; } 
protected function validateBearerAssertion ( AssertionContext $ context ) { if ( null == $ context -> getAssertion ( ) -> getId ( ) ) { $ message = 'Bearer Assertion must have ID attribute' ; $ this -> logger -> error ( $ message , LogHelper :: getActionErrorContext ( $ context , $ this ) ) ; throw new LightSamlContextException ( $ context , $ message ) ; } if ( null == $ context -> getAssertion ( ) -> getIssuer ( ) ) { $ message = 'Bearer Assertion must have Issuer element' ; $ this -> logger -> error ( $ message , LogHelper :: getActionErrorContext ( $ context , $ this ) ) ; throw new LightSamlContextException ( $ context , $ message ) ; } if ( $ this -> idStore -> has ( $ context -> getAssertion ( ) -> getIssuer ( ) -> getValue ( ) , $ context -> getAssertion ( ) -> getId ( ) ) ) { $ message = sprintf ( "Repeated assertion id '%s' of issuer '%s'" , $ context -> getAssertion ( ) -> getId ( ) , $ context -> getAssertion ( ) -> getIssuer ( ) -> getValue ( ) ) ; $ this -> logger -> error ( $ message , LogHelper :: getActionErrorContext ( $ context , $ this , [ 'id' => $ context -> getAssertion ( ) -> getId ( ) , 'issuer' => $ context -> getAssertion ( ) -> getIssuer ( ) -> getValue ( ) , ] ) ) ; throw new LightSamlContextException ( $ context , $ message ) ; } $ this -> idStore -> set ( $ context -> getAssertion ( ) -> getIssuer ( ) -> getValue ( ) , $ context -> getAssertion ( ) -> getId ( ) , $ this -> getIdExpiryTime ( $ context ) ) ; } 
protected function getIdExpiryTime ( AssertionContext $ context ) { $ result = null ; $ bearerConfirmations = $ context -> getAssertion ( ) -> getSubject ( ) -> getBearerConfirmations ( ) ; if ( null == $ bearerConfirmations ) { throw new \ LogicException ( 'Bearer assertion must have bearer subject confirmations' ) ; } foreach ( $ bearerConfirmations as $ subjectConfirmation ) { if ( null == $ subjectConfirmation -> getSubjectConfirmationData ( ) ) { $ message = 'Bearer SubjectConfirmation must have SubjectConfirmationData element' ; $ this -> logger -> error ( $ message , LogHelper :: getActionErrorContext ( $ context , $ this ) ) ; throw new LightSamlContextException ( $ context , $ message ) ; } $ dt = $ subjectConfirmation -> getSubjectConfirmationData ( ) -> getNotOnOrAfterDateTime ( ) ; if ( null == $ dt ) { $ message = 'Bearer SubjectConfirmation must have NotOnOrAfter attribute' ; $ this -> logger -> error ( $ message , LogHelper :: getActionErrorContext ( $ context , $ this ) ) ; throw new LightSamlContextException ( $ context , $ message ) ; } if ( null == $ result || $ result -> getTimestamp ( ) < $ dt -> getTimestamp ( ) ) { $ result = $ dt ; } } if ( null == $ result ) { $ message = 'Unable to find NotOnOrAfter attribute in bearer assertion' ; $ this -> logger -> error ( $ message , LogHelper :: getActionErrorContext ( $ context , $ this ) ) ; throw new LightSamlContextException ( $ context , $ message ) ; } return $ result ; } 
public function doExecute ( ProfileContext $ context ) { $ binding = $ this -> bindingFactory -> create ( $ context -> getEndpoint ( ) -> getBinding ( ) ) ; $ outboundContext = $ context -> getOutboundContext ( ) ; $ context -> getHttpResponseContext ( ) -> setResponse ( $ binding -> send ( $ outboundContext ) ) ; $ this -> logger -> info ( 'Sending message' , LogHelper :: getActionContext ( $ context , $ this , array ( 'message' => $ outboundContext -> getSerializationContext ( ) -> getDocument ( ) -> saveXML ( ) , ) ) ) ; } 
public function setAllowCreate ( $ allowCreate ) { if ( null === $ allowCreate ) { $ this -> allowCreate = null ; } elseif ( is_string ( $ allowCreate ) || is_int ( $ allowCreate ) ) { $ this -> allowCreate = 0 == strcasecmp ( $ allowCreate , 'true' ) || true === $ allowCreate || 1 == $ allowCreate ; } else { $ this -> allowCreate = ( bool ) $ allowCreate ; } return $ this ; } 
public function serialize ( \ DOMNode $ parent , SerializationContext $ context ) { $ result = $ this -> createElement ( 'NameIDPolicy' , SamlConstants :: NS_PROTOCOL , $ parent , $ context ) ; $ this -> attributesToXml ( array ( 'Format' , 'SPNameQualifier' , 'AllowCreate' ) , $ result ) ; } 
protected function doExecute ( ProfileContext $ context ) { $ endpoint = $ context -> getEndpoint ( ) ; MessageContextHelper :: asSamlMessage ( $ context -> getOutboundContext ( ) ) -> setDestination ( $ endpoint -> getLocation ( ) ) ; $ this -> logger -> debug ( sprintf ( 'Destination set to "%s"' , $ endpoint -> getLocation ( ) ) , LogHelper :: getActionContext ( $ context , $ this ) ) ; } 
public function addIfNone ( CriteriaInterface $ criteria ) { if ( false == $ this -> has ( get_class ( $ criteria ) ) ) { $ this -> add ( $ criteria ) ; } return $ this ; } 
public function addAll ( CriteriaSet $ criteriaSet ) { foreach ( $ criteriaSet -> all ( ) as $ criteria ) { $ this -> add ( $ criteria ) ; } return $ this ; } 
public function addIf ( $ condition , $ callback ) { if ( $ condition ) { $ criteria = call_user_func ( $ callback ) ; if ( $ criteria ) { $ this -> add ( $ criteria ) ; } } return $ this ; } 
public function get ( $ class ) { $ result = array ( ) ; foreach ( $ this -> criterions as $ criteria ) { if ( $ criteria instanceof $ class ) { $ result [ ] = $ criteria ; } } return $ result ; } 
public static function createPublicKey ( X509Certificate $ certificate ) { if ( null == $ certificate -> getSignatureAlgorithm ( ) ) { throw new LightSamlSecurityException ( 'Unrecognized certificate signature algorithm' ) ; } $ key = new XMLSecurityKey ( $ certificate -> getSignatureAlgorithm ( ) , array ( 'type' => 'public' ) ) ; $ key -> loadKey ( $ certificate -> toPem ( ) , false , true ) ; return $ key ; } 
public static function castKey ( XMLSecurityKey $ key , $ algorithm ) { if ( false == is_string ( $ algorithm ) ) { throw new \ InvalidArgumentException ( 'Algorithm must be string' ) ; } 
public function decryptMultiAssertion ( array $ inputKeys , DeserializationContext $ deserializationContext ) { $ dom = $ this -> decryptMulti ( $ inputKeys ) ; return $ this -> getAssertionFromDom ( $ dom , $ deserializationContext ) ; } 
public function decryptAssertion ( $ credential , DeserializationContext $ deserializationContext ) { $ dom = $ this -> decrypt ( $ credential ) ; return $ this -> getAssertionFromDom ( $ dom , $ deserializationContext ) ; } 
protected function getAssertionFromDom ( \ DOMElement $ dom , DeserializationContext $ deserializationContext ) { $ deserializationContext -> setDocument ( $ dom -> ownerDocument ) ; $ assertion = new Assertion ( ) ; $ assertion -> deserialize ( $ dom , $ deserializationContext ) ; return $ assertion ; } 
private function validate ( $ xml , $ schema ) { $ result = [ ] ; libxml_clear_errors ( ) ; $ doc = new \ DOMDocument ( ) ; set_error_handler ( function ( $ errno , $ errstr , $ errfile , $ errline , array $ errcontext ) use ( & $ result ) { $ error = new XsdError ( XsdError :: FATAL , $ errno , $ errstr , 0 , 0 ) ; $ result [ ] = $ error ; } ) ; $ schemaFile = __DIR__ . '/../../../../../xsd/' . $ schema ; if ( ! is_file ( $ schemaFile ) ) { throw new LightSamlXmlException ( 'Invalid schema specified' ) ; } $ ok = @ $ doc -> loadXML ( $ xml ) ; if ( ! $ ok ) { restore_error_handler ( ) ; return [ new XsdError ( XsdError :: FATAL , 0 , 'Invalid XML' , 0 , 0 ) , ] ; } @ $ doc -> schemaValidate ( $ schemaFile ) ; $ errors = libxml_get_errors ( ) ; foreach ( $ errors as $ error ) { $ err = XsdError :: fromLibXMLError ( $ error ) ; $ result [ ] = $ err ; } restore_error_handler ( ) ; return $ result ; } 
public static function getTimestampFromValue ( $ value ) { if ( is_string ( $ value ) ) { return self :: parseSAMLTime ( $ value ) ; } elseif ( $ value instanceof \ DateTime ) { return $ value -> getTimestamp ( ) ; } elseif ( is_int ( $ value ) ) { return $ value ; } else { throw new \ InvalidArgumentException ( ) ; } } 
public static function parseSAMLTime ( $ time ) { $ matches = [ ] ; if ( 0 == preg_match ( '/^(\\d\\d\\d\\d)-(\\d\\d)-(\\d\\d)T(\\d\\d):(\\d\\d):(\\d\\d)(?:\\.\\d+)?(Z|[+-]\\d\\d:\\d\\d)$/D' , $ time , $ matches ) ) { throw new \ InvalidArgumentException ( 'Invalid SAML2 timestamp: ' . $ time ) ; } return strtotime ( $ time ) ; } 
public static function validateWellFormedUriString ( $ value ) { $ value = trim ( $ value ) ; if ( '' == $ value || strlen ( $ value ) > 65520 ) { return false ; } if ( preg_match ( '|\s|' , $ value ) ) { return false ; } $ parts = parse_url ( $ value ) ; if ( isset ( $ parts [ 'scheme' ] ) ) { if ( $ parts [ 'scheme' ] != rawurlencode ( $ parts [ 'scheme' ] ) ) { return false ; } } else { return false ; } return true ; } 
public function addSingleSignOnService ( SingleSignOnService $ singleSignOnService ) { if ( false == is_array ( $ this -> singleSignOnServices ) ) { $ this -> singleSignOnServices = array ( ) ; } $ this -> singleSignOnServices [ ] = $ singleSignOnService ; return $ this ; } 
public function getAllSingleSignOnServicesByUrl ( $ url ) { $ result = array ( ) ; foreach ( $ this -> getAllSingleSignOnServices ( ) as $ svc ) { if ( $ svc -> getLocation ( ) == $ url ) { $ result [ ] = $ svc ; } } return $ result ; } 
public function getAllSingleSignOnServicesByBinding ( $ binding ) { $ result = array ( ) ; foreach ( $ this -> getAllSingleSignOnServices ( ) as $ svc ) { if ( $ svc -> getBinding ( ) == $ binding ) { $ result [ ] = $ svc ; } } return $ result ; } 
public function getFirstSingleSignOnService ( $ binding = null ) { foreach ( $ this -> getAllSingleSignOnServices ( ) as $ svc ) { if ( null == $ binding || $ svc -> getBinding ( ) == $ binding ) { return $ svc ; } } return null ; } 
public function addAttribute ( Attribute $ attribute ) { if ( false == is_array ( $ this -> attributes ) ) { $ this -> attributes = array ( ) ; } $ this -> attributes [ ] = $ attribute ; return $ this ; } 
public function resolve ( CriteriaSet $ criteriaSet , array $ arrCredentials = array ( ) ) { if ( false == $ criteriaSet -> has ( X509CredentialCriteria :: class ) ) { return $ arrCredentials ; } $ result = array ( ) ; foreach ( $ arrCredentials as $ credential ) { if ( $ credential instanceof X509CredentialInterface ) { $ result [ ] = $ credential ; } } return $ result ; } 
protected function getCriteriaSet ( ProfileContext $ context , $ location ) { $ result = parent :: getCriteriaSet ( $ context , $ location ) ; $ result -> add ( new ServiceTypeCriteria ( AssertionConsumerService :: class ) ) ; return $ result ; } 
public function serialize ( ) { $ nonce = $ this -> getNonce ( ) ; return serialize ( array ( $ this -> id , $ nonce , $ this -> parameters -> serialize ( ) ) ) ; } 
public function unserialize ( $ serialized ) { $ nonce = null ; $ this -> parameters = new ParameterBag ( ) ; list ( $ this -> id , $ nonce , $ parameters ) = unserialize ( $ serialized ) ; $ this -> parameters -> unserialize ( $ parameters ) ; } 
public function execute ( ContextInterface $ context ) { $ this -> beforeAction ( $ context ) ; $ this -> action -> execute ( $ context ) ; $ this -> afterAction ( $ context ) ; } 
public function resolve ( CriteriaSet $ criteriaSet , array $ candidates ) { $ result = $ candidates ; foreach ( $ this -> resolvers as $ resolver ) { $ result = $ resolver -> resolve ( $ criteriaSet , $ result ) ; } return $ result ; } 
public function get ( $ entityId ) { if ( null == $ this -> object ) { $ this -> load ( ) ; } if ( $ this -> object instanceof EntityDescriptor ) { if ( $ this -> object -> getEntityID ( ) == $ entityId ) { return $ this -> object ; } else { return null ; } } else { return $ this -> object -> getByEntityId ( $ entityId ) ; } } 
public function debugPrintTree ( $ depth = 0 ) { $ arr = array ( ) ; if ( $ this -> assertionAction instanceof DebugPrintTreeActionInterface ) { $ arr = array_merge ( $ arr , $ this -> assertionAction -> debugPrintTree ( ) ) ; } else { $ arr [ get_class ( $ this -> assertionAction ) ] = array ( ) ; } $ result = array ( static :: class => $ arr , ) ; return $ result ; } 
public function validateTimeRestrictions ( Assertion $ assertion , $ now , $ allowedSecondsSkew ) { if ( $ allowedSecondsSkew < 0 ) { $ allowedSecondsSkew = - 1 * $ allowedSecondsSkew ; } $ this -> validateConditions ( $ assertion , $ now , $ allowedSecondsSkew ) ; $ this -> validateAuthnStatements ( $ assertion , $ now , $ allowedSecondsSkew ) ; $ this -> validateSubject ( $ assertion , $ now , $ allowedSecondsSkew ) ; } 
public function resolve ( CriteriaSet $ criteriaSet , array $ arrCredentials = array ( ) ) { if ( false == $ criteriaSet -> has ( PublicKeyThumbprintCriteria :: class ) ) { return $ arrCredentials ; } $ result = array ( ) ; foreach ( $ criteriaSet -> get ( PublicKeyThumbprintCriteria :: class ) as $ criteria ) { foreach ( $ arrCredentials as $ credential ) { if ( $ credential -> getPublicKey ( ) && $ credential -> getPublicKey ( ) -> getX509Thumbprint ( ) == $ criteria -> getThumbprint ( ) ) { $ result [ ] = $ credential ; } } } return $ result ; } 
public function getBindingByRequest ( Request $ request ) { $ bindingType = $ this -> detectBindingType ( $ request ) ; return $ this -> create ( $ bindingType ) ; } 
public function create ( $ bindingType ) { $ result = null ; switch ( $ bindingType ) { case SamlConstants :: BINDING_SAML2_HTTP_REDIRECT : $ result = new HttpRedirectBinding ( ) ; break ; case SamlConstants :: BINDING_SAML2_HTTP_POST : $ result = new HttpPostBinding ( ) ; break ; case SamlConstants :: BINDING_SAML2_HTTP_ARTIFACT : throw new \ LogicException ( 'Artifact binding not implemented' ) ; case SamlConstants :: BINDING_SAML2_SOAP : throw new \ LogicException ( 'SOAP binding not implemented' ) ; } if ( $ result ) { $ result -> setEventDispatcher ( $ this -> eventDispatcher ) ; return $ result ; } throw new LightSamlBindingException ( sprintf ( "Unknown binding type '%s'" , $ bindingType ) ) ; } 
public function detectBindingType ( Request $ request ) { $ requestMethod = trim ( strtoupper ( $ request -> getMethod ( ) ) ) ; if ( 'GET' == $ requestMethod ) { return $ this -> processGET ( $ request ) ; } elseif ( 'POST' == $ requestMethod ) { return $ this -> processPOST ( $ request ) ; } return null ; } 
protected function processGET ( Request $ request ) { $ get = $ request -> query -> all ( ) ; if ( array_key_exists ( 'SAMLRequest' , $ get ) || array_key_exists ( 'SAMLResponse' , $ get ) ) { return SamlConstants :: BINDING_SAML2_HTTP_REDIRECT ; } elseif ( array_key_exists ( 'SAMLart' , $ get ) ) { return SamlConstants :: BINDING_SAML2_HTTP_ARTIFACT ; } return null ; } 
protected function processPOST ( Request $ request ) { $ post = $ request -> request -> all ( ) ; if ( array_key_exists ( 'SAMLRequest' , $ post ) || array_key_exists ( 'SAMLResponse' , $ post ) ) { return SamlConstants :: BINDING_SAML2_HTTP_POST ; } elseif ( array_key_exists ( 'SAMLart' , $ post ) ) { return SamlConstants :: BINDING_SAML2_HTTP_ARTIFACT ; } else { if ( $ contentType = $ request -> headers -> get ( 'CONTENT_TYPE' ) ) { 
public function get ( $ entityId ) { return isset ( $ this -> options [ $ entityId ] ) ? $ this -> options [ $ entityId ] : null ; } 
public function send ( MessageContext $ context , $ destination = null ) { $ message = MessageContextHelper :: asSamlMessage ( $ context ) ; $ destination = $ message -> getDestination ( ) ? $ message -> getDestination ( ) : $ destination ; $ serializationContext = $ context -> getSerializationContext ( ) ; $ message -> serialize ( $ serializationContext -> getDocument ( ) , $ serializationContext ) ; $ msgStr = $ serializationContext -> getDocument ( ) -> saveXML ( ) ; $ this -> dispatchSend ( $ msgStr ) ; $ msgStr = base64_encode ( $ msgStr ) ; $ type = $ message instanceof AbstractRequest ? 'SAMLRequest' : 'SAMLResponse' ; $ data = array ( $ type => $ msgStr ) ; if ( $ message -> getRelayState ( ) ) { $ data [ 'RelayState' ] = $ message -> getRelayState ( ) ; } $ result = new SamlPostResponse ( $ destination , $ data ) ; $ result -> renderContent ( ) ; return $ result ; } 
protected function validateInResponseTo ( $ inResponseTo , AssertionContext $ context ) { $ requestState = $ this -> requestStore -> get ( $ inResponseTo ) ; if ( null == $ requestState ) { $ message = sprintf ( "Unknown InResponseTo '%s'" , $ inResponseTo ) ; $ this -> logger -> emergency ( $ message , LogHelper :: getActionErrorContext ( $ context , $ this ) ) ; throw new LightSamlContextException ( $ context , $ message ) ; } return $ requestState ; } 
public function add ( CredentialInterface $ credential ) { $ this -> checkEntityIdExistence ( $ credential -> getEntityId ( ) ) ; $ this -> credentials [ $ credential -> getEntityId ( ) ] [ ] = $ credential ; return $ this ; } 
public function resolve ( CriteriaSet $ criteriaSet , array $ arrCredentials = array ( ) ) { if ( false == $ criteriaSet -> has ( MetadataCriteria :: class ) ) { return $ arrCredentials ; } $ result = array ( ) ; foreach ( $ criteriaSet -> get ( MetadataCriteria :: class ) as $ criteria ) { foreach ( $ arrCredentials as $ credential ) { $ metadataContext = $ credential -> getCredentialContext ( ) -> get ( MetadataCredentialContext :: class ) ; if ( false == $ metadataContext || MetadataCriteria :: TYPE_IDP == $ criteria -> getMetadataType ( ) && $ metadataContext -> getRoleDescriptor ( ) instanceof IdpSsoDescriptor || MetadataCriteria :: TYPE_SP == $ criteria -> getMetadataType ( ) && $ metadataContext -> getRoleDescriptor ( ) instanceof SpSsoDescriptor ) { $ result [ ] = $ credential ; } } } return $ result ; } 
public function addAudience ( $ audience ) { if ( false == is_array ( $ this -> audience ) ) { $ this -> audience = array ( ) ; } $ this -> audience [ ] = ( string ) $ audience ; return $ this ; } 
public function setCount ( $ count ) { $ this -> count = null !== $ count ? intval ( $ count ) : null ; return $ this ; } 
public function setSsoSessions ( array $ ssoSessions ) { $ this -> ssoSessions = array ( ) ; foreach ( $ ssoSessions as $ ssoSession ) { $ this -> addSsoSession ( $ ssoSession ) ; } return $ this ; } 
public function filter ( $ idpEntityId , $ spEntityId , $ nameId , $ nameIdFormat , $ sessionIndex ) { $ result = array ( ) ; foreach ( $ this -> ssoSessions as $ ssoSession ) { if ( ( ! $ idpEntityId || $ ssoSession -> getIdpEntityId ( ) === $ idpEntityId ) && ( ! $ spEntityId || $ ssoSession -> getSpEntityId ( ) === $ spEntityId ) && ( ! $ nameId || $ ssoSession -> getNameId ( ) === $ nameId ) && ( ! $ nameIdFormat || $ ssoSession -> getNameIdFormat ( ) === $ nameIdFormat ) && ( ! $ sessionIndex || $ ssoSession -> getSessionIndex ( ) === $ sessionIndex ) ) { $ result [ ] = $ ssoSession ; } } return $ result ; } 
public function modify ( $ callback ) { $ this -> ssoSessions = array_values ( array_filter ( $ this -> ssoSessions , $ callback ) ) ; return $ this ; } 
public function unserialize ( $ serialized ) { $ data = unserialize ( $ serialized ) ; 
public function map ( $ callable ) { foreach ( $ this -> children as $ k => $ action ) { $ newAction = call_user_func ( $ callable , $ action ) ; if ( $ newAction ) { $ this -> children [ $ k ] = $ newAction ; } } } 
public function execute ( ContextInterface $ context ) { foreach ( $ this -> children as $ action ) { $ action -> execute ( $ context ) ; } } 
public function add ( ActionInterface $ action , $ priority = false ) { if ( false === $ priority ) { ++ $ this -> biggestPriority ; $ priority = $ this -> biggestPriority ; } elseif ( false === is_int ( $ priority ) ) { throw new \ InvalidArgumentException ( 'Expected integer value for priority' ) ; } elseif ( $ priority > $ this -> biggestPriority ) { $ this -> biggestPriority = $ priority ; } if ( false === isset ( $ this -> actions [ $ priority ] ) ) { $ this -> actions [ $ priority ] = array ( ) ; } $ this -> actions [ $ priority ] [ ] = $ action ; return $ this ; } 
public function execute ( ContextInterface $ context ) { $ this -> eventDispatcher -> dispatch ( $ this -> event , new GenericEvent ( $ context ) ) ; } 
public static function loadXml ( $ xml ) { $ context = new DeserializationContext ( ) ; $ context -> getDocument ( ) -> loadXML ( $ xml ) ; $ ed = new self ( ) ; $ ed -> deserialize ( $ context -> getDocument ( ) , $ context ) ; return $ ed ; } 
public function setValidUntil ( $ validUntil ) { $ value = Helper :: getTimestampFromValue ( $ validUntil ) ; if ( $ value < 0 ) { throw new \ InvalidArgumentException ( 'Invalid validUntil' ) ; } $ this -> validUntil = $ value ; return $ this ; } 
public function addItem ( $ item ) { if ( false == $ item instanceof self && false == $ item instanceof EntityDescriptor ) { throw new \ InvalidArgumentException ( 'Expected EntitiesDescriptor or EntityDescriptor' ) ; } if ( $ item === $ this ) { throw new \ InvalidArgumentException ( 'Circular reference detected' ) ; } if ( $ item instanceof self ) { if ( $ item -> containsItem ( $ this ) ) { throw new \ InvalidArgumentException ( 'Circular reference detected' ) ; } } $ this -> items [ ] = $ item ; return $ this ; } 
public function containsItem ( $ item ) { if ( false == $ item instanceof self && false == $ item instanceof EntityDescriptor ) { throw new \ InvalidArgumentException ( 'Expected EntitiesDescriptor or EntityDescriptor' ) ; } foreach ( $ this -> items as $ i ) { if ( $ i === $ item ) { return true ; } if ( $ i instanceof self ) { if ( $ i -> containsItem ( $ item ) ) { return true ; } } } return false ; } 
public function getByEntityId ( $ entityId ) { foreach ( $ this -> getAllEntityDescriptors ( ) as $ entityDescriptor ) { if ( $ entityDescriptor -> getEntityID ( ) == $ entityId ) { return $ entityDescriptor ; } } return null ; } 
public function serialize ( \ DOMNode $ parent , SerializationContext $ context ) { $ result = $ this -> createElement ( 'EntitiesDescriptor' , SamlConstants :: NS_METADATA , $ parent , $ context ) ; $ this -> attributesToXml ( array ( 'validUntil' , 'cacheDuration' , 'ID' , 'Name' ) , $ result ) ; $ this -> singleElementsToXml ( array ( 'Signature' ) , $ result , $ context ) ; $ this -> manyElementsToXml ( $ this -> getAllItems ( ) , $ result , $ context ) ; } 
protected function doExecute ( AssertionContext $ context ) { $ signature = $ context -> getAssertion ( ) -> getSignature ( ) ; if ( null === $ signature ) { if ( $ this -> requireSignature ) { $ message = 'Assertions must be signed' ; $ this -> logger -> critical ( $ message , LogHelper :: getActionErrorContext ( $ context , $ this ) ) ; throw new LightSamlContextException ( $ context , $ message ) ; } else { $ this -> logger -> debug ( 'Assertion is not signed' , LogHelper :: getActionContext ( $ context , $ this ) ) ; return ; } } if ( $ signature instanceof AbstractSignatureReader ) { $ metadataType = ProfileContext :: ROLE_IDP === $ context -> getProfileContext ( ) -> getOwnRole ( ) ? MetadataCriteria :: TYPE_SP : MetadataCriteria :: TYPE_IDP ; $ credential = $ this -> signatureValidator -> validate ( $ signature , $ context -> getAssertion ( ) -> getIssuer ( ) -> getValue ( ) , $ metadataType ) ; if ( $ credential ) { $ keyNames = $ credential -> getKeyNames ( ) ; $ this -> logger -> debug ( sprintf ( 'Assertion signature validated with key "%s"' , implode ( ', ' , $ keyNames ) ) , LogHelper :: getActionContext ( $ context , $ this , array ( 'credential' => $ credential , ) ) ) ; } else { $ this -> logger -> warning ( 'Assertion signature verification was not performed' , LogHelper :: getActionContext ( $ context , $ this ) ) ; } } else { $ message = 'Expected AbstractSignatureReader' ; $ this -> logger -> critical ( $ message , LogHelper :: getActionErrorContext ( $ context , $ this ) ) ; throw new LightSamlModelException ( $ message ) ; } } 
public function resolve ( CriteriaSet $ criteriaSet , array $ arrCredentials = array ( ) ) { if ( false == $ criteriaSet -> has ( PrivateKeyCriteria :: class ) ) { return $ arrCredentials ; } $ result = array ( ) ; foreach ( $ arrCredentials as $ credential ) { if ( $ credential -> getPrivateKey ( ) ) { $ result [ ] = $ credential ; } } return $ result ; } 
public function getSubContext ( $ name , $ class = null ) { if ( isset ( $ this -> subContexts [ $ name ] ) ) { return $ this -> subContexts [ $ name ] ; } if ( $ class ) { $ result = $ this -> createSubContext ( $ class ) ; $ this -> addSubContext ( $ name , $ result ) ; return $ result ; } return null ; } 
public function addSubContext ( $ name , $ subContext ) { if ( false === is_object ( $ subContext ) ) { throw new \ InvalidArgumentException ( 'Expected object or ContextInterface' ) ; } $ existing = isset ( $ this -> subContexts [ $ name ] ) ? $ this -> subContexts [ $ name ] : null ; if ( $ existing === $ subContext ) { return $ this ; } $ this -> subContexts [ $ name ] = $ subContext ; if ( $ subContext instanceof ContextInterface ) { $ subContext -> setParent ( $ this ) ; } if ( $ existing instanceof ContextInterface ) { $ existing -> setParent ( null ) ; } return $ this ; } 
public function removeSubContext ( $ name ) { $ subContext = $ this -> getSubContext ( $ name , false ) ; if ( $ subContext ) { $ subContext -> setParent ( null ) ; unset ( $ this -> subContexts [ $ name ] ) ; } return $ this ; } 
public function debugPrintTree ( $ ownName = 'root' ) { $ result = array ( $ ownName => static :: class , ) ; if ( $ this -> subContexts ) { $ arr = array ( ) ; foreach ( $ this -> subContexts as $ name => $ subContext ) { if ( $ subContext instanceof ContextInterface ) { $ arr = array_merge ( $ arr , $ subContext -> debugPrintTree ( $ name ) ) ; } else { $ arr = array_merge ( $ arr , array ( $ name => get_class ( $ subContext ) ) ) ; } } $ result [ $ ownName . '__children' ] = $ arr ; } return $ result ; } 
public function getPath ( $ path ) { if ( is_string ( $ path ) ) { $ path = explode ( '/' , $ path ) ; } elseif ( false === is_array ( $ path ) ) { throw new \ InvalidArgumentException ( 'Expected string or array' ) ; } $ name = array_shift ( $ path ) ; $ subContext = $ this -> getSubContext ( $ name ) ; if ( null == $ subContext ) { return null ; } if ( empty ( $ path ) ) { return $ subContext ; } else { return $ subContext -> getPath ( $ path ) ; } } 
public static function getEncryptedAssertionReader ( AssertionContext $ context ) { $ result = $ context -> getEncryptedAssertion ( ) ; if ( $ result instanceof EncryptedAssertionReader ) { return $ result ; } throw new LightSamlContextException ( $ context , 'Expected EncryptedAssertionReader' ) ; } 
protected function doExecute ( AssertionContext $ context ) { if ( null === $ context -> getAssertion ( ) -> getIssuer ( ) ) { $ message = 'Assertion element must have an issuer element' ; $ this -> logger -> error ( $ message , LogHelper :: getActionErrorContext ( $ context , $ this ) ) ; throw new LightSamlContextException ( $ context , $ message ) ; } if ( false == $ this -> idpEntityDescriptorProvider -> has ( $ context -> getAssertion ( ) -> getIssuer ( ) -> getValue ( ) ) ) { $ message = sprintf ( "Unknown issuer '%s'" , $ context -> getAssertion ( ) -> getIssuer ( ) -> getValue ( ) ) ; $ this -> logger -> error ( $ message , LogHelper :: getActionErrorContext ( $ context , $ this , [ 'messageIssuer' => $ context -> getAssertion ( ) -> getIssuer ( ) -> getValue ( ) , ] ) ) ; throw new LightSamlContextException ( $ context , $ message ) ; } $ this -> logger -> debug ( sprintf ( 'Known assertion issuer: "%s"' , $ context -> getAssertion ( ) -> getIssuer ( ) -> getValue ( ) ) , LogHelper :: getActionContext ( $ context , $ this ) ) ; } 
public function resolve ( CriteriaSet $ criteriaSet , array $ candidates ) { if ( false === $ criteriaSet -> has ( DescriptorTypeCriteria :: class ) ) { return $ candidates ; } $ result = array ( ) ; foreach ( $ criteriaSet -> get ( DescriptorTypeCriteria :: class ) as $ descriptorTypeCriteria ) { foreach ( $ candidates as $ endpointReference ) { $ type = $ descriptorTypeCriteria -> getDescriptorType ( ) ; if ( $ endpointReference -> getDescriptor ( ) instanceof $ type ) { $ result [ ] = $ endpointReference ; } } } return $ result ; } 
protected function doExecute ( ProfileContext $ context ) { $ message = MessageContextHelper :: asSamlMessage ( $ context -> getInboundContext ( ) ) ; $ destination = $ message -> getDestination ( ) ; if ( null == $ destination ) { return ; } $ criteriaSet = $ this -> getCriteriaSet ( $ context , $ destination ) ; $ endpoints = $ this -> endpointResolver -> resolve ( $ criteriaSet , $ context -> getOwnEntityDescriptor ( ) -> getAllEndpoints ( ) ) ; if ( $ endpoints ) { return ; } $ message = sprintf ( 'Invalid inbound message destination "%s"' , $ destination ) ; $ this -> logger -> emergency ( $ message , LogHelper :: getActionErrorContext ( $ context , $ this ) ) ; throw new LightSamlContextException ( $ context , $ message ) ; } 
protected function getCriteriaSet ( ProfileContext $ context , $ location ) { $ criteriaSet = new CriteriaSet ( [ new DescriptorTypeCriteria ( ProfileContext :: ROLE_IDP === $ context -> getOwnRole ( ) ? IdpSsoDescriptor :: class : SpSsoDescriptor :: class ) , new LocationCriteria ( $ location ) , ] ) ; return $ criteriaSet ; } 
public function getBearerAssertions ( ) { $ result = array ( ) ; if ( $ this -> getAllAssertions ( ) ) { foreach ( $ this -> getAllAssertions ( ) as $ assertion ) { if ( $ assertion -> hasBearerSubject ( ) ) { $ result [ ] = $ assertion ; } } 
public function removeAssertion ( Assertion $ removedAssertion ) { $ arr = array ( ) ; $ hasThatAssertion = false ; foreach ( $ this -> getAllAssertions ( ) as $ assertion ) { if ( $ assertion !== $ removedAssertion ) { $ arr [ ] = $ assertion ; } else { $ hasThatAssertion = true ; } } if ( false === $ hasThatAssertion ) { throw new \ InvalidArgumentException ( 'Response does not have assertion specified to be removed' ) ; } return $ this ; } 
public function hasAudience ( $ value ) { if ( is_array ( $ this -> audience ) ) { foreach ( $ this -> audience as $ a ) { if ( $ a == $ value ) { return true ; } } } return false ; } 
public static function fromLibXMLError ( \ LibXMLError $ error ) { return new self ( isset ( self :: $ levelMap [ $ error -> level ] ) ? self :: $ levelMap [ $ error -> level ] : 'Unknown' , $ error -> code , $ error -> message , $ error -> line , $ error -> column ) ; } 
public function addAssertionConsumerService ( AssertionConsumerService $ assertionConsumerService ) { if ( false == is_array ( $ this -> assertionConsumerServices ) ) { $ this -> assertionConsumerServices = array ( ) ; } if ( null === $ assertionConsumerService -> getIndex ( ) ) { $ assertionConsumerService -> setIndex ( count ( $ this -> assertionConsumerServices ) ) ; } $ this -> assertionConsumerServices [ ] = $ assertionConsumerService ; return $ this ; } 
public function getAllAssertionConsumerServicesByBinding ( $ binding ) { $ result = array ( ) ; foreach ( $ this -> getAllAssertionConsumerServices ( ) as $ svc ) { if ( $ svc -> getBinding ( ) == $ binding ) { $ result [ ] = $ svc ; } } return $ result ; } 
public function getAllAssertionConsumerServicesByUrl ( $ url ) { $ result = array ( ) ; foreach ( $ this -> getAllAssertionConsumerServices ( ) as $ svc ) { if ( $ svc -> getLocation ( ) == $ url ) { $ result [ ] = $ svc ; } } return $ result ; } 
public function getAssertionConsumerServicesByIndex ( $ index ) { foreach ( $ this -> getAllAssertionConsumerServices ( ) as $ svc ) { if ( $ svc -> getIndex ( ) == $ index ) { return $ svc ; } } return null ; } 
public function getFirstAssertionConsumerService ( $ binding = null ) { foreach ( $ this -> getAllAssertionConsumerServices ( ) as $ svc ) { if ( null == $ binding || $ svc -> getBinding ( ) == $ binding ) { return $ svc ; } } return null ; } 
public function set ( RequestState $ state ) { $ arr = $ this -> getArray ( ) ; $ arr [ $ state -> getId ( ) ] = $ state ; $ this -> setArray ( $ arr ) ; return $ this ; } 
public function get ( $ id ) { $ result = null ; $ arr = $ this -> getArray ( ) ; if ( false == is_array ( $ arr ) ) { $ arr = array ( ) ; $ this -> setArray ( $ arr ) ; } if ( isset ( $ arr [ $ id ] ) ) { $ result = $ arr [ $ id ] ; } if ( $ result instanceof RequestState ) { return $ result ; } return null ; } 
public function remove ( $ id ) { $ arr = $ this -> getArray ( ) ; $ result = isset ( $ arr [ $ id ] ) ; unset ( $ arr [ $ id ] ) ; $ this -> setArray ( $ arr ) ; return $ result ; } 
public function set ( SsoState $ ssoState ) { $ ssoState -> setLocalSessionId ( $ this -> session -> getId ( ) ) ; $ this -> session -> set ( $ this -> key , $ ssoState ) ; } 
protected function doExecute ( AssertionContext $ context ) { $ this -> assertionTimeValidator -> validateTimeRestrictions ( $ context -> getAssertion ( ) , $ this -> timeProvider -> getTimestamp ( ) , $ this -> allowedSecondsSkew ) ; } 
public function getAllSingleLogoutServicesByBinding ( $ binding ) { $ result = array ( ) ; foreach ( $ this -> getAllSingleLogoutServices ( ) as $ svc ) { if ( $ binding == $ svc -> getBinding ( ) ) { $ result [ ] = $ svc ; } } return $ result ; } 
public function getFirstSingleLogoutService ( $ binding = null ) { foreach ( $ this -> getAllSingleLogoutServices ( ) as $ svc ) { if ( null == $ binding || $ binding == $ svc -> getBinding ( ) ) { return $ svc ; } } return null ; } 
public function hasNameIDFormat ( $ nameIdFormat ) { if ( $ this -> nameIDFormats ) { foreach ( $ this -> nameIDFormats as $ format ) { if ( $ format == $ nameIdFormat ) { return true ; } } } return false ; } 
public function addKeyName ( $ keyName ) { $ keyName = trim ( $ keyName ) ; if ( $ keyName ) { $ this -> keyNames [ ] = $ keyName ; } return $ this ; } 
public function resolve ( CriteriaSet $ criteriaSet , array $ candidates ) { if ( false === $ criteriaSet -> has ( IndexCriteria :: class ) ) { return $ candidates ; } $ result = array ( ) ; foreach ( $ criteriaSet -> get ( IndexCriteria :: class ) as $ indexCriteria ) { foreach ( $ candidates as $ endpointReference ) { $ endpoint = $ endpointReference -> getEndpoint ( ) ; if ( $ endpoint instanceof IndexedEndpoint ) { if ( $ endpoint -> getIndex ( ) == $ indexCriteria -> getIndex ( ) ) { $ result [ ] = $ endpointReference ; } } } } return $ result ; } 
public function addException ( \ Exception $ exception ) { if ( $ this -> exception ) { if ( null == $ this -> nextExceptionContext ) { $ this -> nextExceptionContext = new self ( $ exception ) ; return $ this -> nextExceptionContext ; } else { return $ this -> nextExceptionContext -> addException ( $ exception ) ; } } else { $ this -> exception = $ exception ; } return $ this ; } 
public function validateNameId ( AbstractNameID $ nameId ) { if ( false == $ nameId -> getFormat ( ) ) { return ; } $ this -> validateFormat ( $ nameId ) ; $ validatorMethod = isset ( self :: $ formatValidators [ $ nameId -> getFormat ( ) ] ) ? self :: $ formatValidators [ $ nameId -> getFormat ( ) ] : null ; if ( $ validatorMethod ) { $ this -> { $ validatorMethod } ( $ nameId ) ; } } 
public function setAttributes ( array $ attributes ) { $ this -> attributes = [ ] ; foreach ( $ attributes as $ attribute ) { $ this -> add ( $ attribute ) ; } return $ this ; } 
public function addExtraCredential ( CredentialInterface $ credential ) { if ( null === $ credential -> getEntityId ( ) ) { throw new \ InvalidArgumentException ( 'Extra credential must have entityID' ) ; } $ this -> extraCredentials [ ] = $ credential ; return $ this ; } 
public function set ( $ entityId , $ id , \ DateTime $ expiryTime ) { if ( false == isset ( $ this -> store [ $ entityId ] ) ) { $ this -> store [ $ entityId ] = array ( ) ; } $ this -> store [ $ entityId ] [ $ id ] = $ expiryTime ; } 
public function resolve ( CriteriaSet $ criteriaSet , array $ candidates ) { if ( false === $ criteriaSet -> has ( BindingCriteria :: class ) ) { return $ candidates ; } $ arrOrdered = array ( ) ; foreach ( $ criteriaSet -> get ( BindingCriteria :: class ) as $ bindingCriteria ) { foreach ( $ candidates as $ endpointReference ) { $ preference = $ bindingCriteria -> getPreference ( $ endpointReference -> getEndpoint ( ) -> getBinding ( ) ) ; if ( null !== $ preference ) { $ arrOrdered [ $ preference ] [ ] = $ endpointReference ; } } } ksort ( $ arrOrdered ) ; $ result = array ( ) ; foreach ( $ arrOrdered as $ arr ) { foreach ( $ arr as $ endpointReference ) { $ result [ ] = $ endpointReference ; } } return $ result ; } 
public function getSignature ( AbstractProfileContext $ context ) { $ credential = $ this -> getSigningCredential ( $ context ) ; if ( null == $ credential ) { throw new LightSamlContextException ( $ context , 'Unable to find signing credential' ) ; } $ trustOptions = $ context -> getProfileContext ( ) -> getTrustOptions ( ) ; $ signature = new SignatureWriter ( $ credential -> getCertificate ( ) , $ credential -> getPrivateKey ( ) , $ trustOptions -> getSignatureDigestAlgorithm ( ) ) ; return $ signature ; } 
private function getSigningCredential ( AbstractProfileContext $ context ) { $ profileContext = $ context -> getProfileContext ( ) ; $ entityDescriptor = $ profileContext -> getOwnEntityDescriptor ( ) ; $ query = $ this -> credentialResolver -> query ( ) ; $ query -> add ( new EntityIdCriteria ( $ entityDescriptor -> getEntityID ( ) ) ) -> add ( new UsageCriteria ( UsageType :: SIGNING ) ) -> add ( new X509CredentialCriteria ( ) ) -> addIf ( ProfileContext :: ROLE_IDP === $ profileContext -> getOwnRole ( ) , function ( ) { return new MetadataCriteria ( MetadataCriteria :: TYPE_IDP , SamlConstants :: VERSION_20 ) ; } ) -> addIf ( ProfileContext :: ROLE_SP === $ profileContext -> getOwnRole ( ) , function ( ) { return new MetadataCriteria ( MetadataCriteria :: TYPE_SP , SamlConstants :: VERSION_20 ) ; } ) ; $ query -> resolve ( ) ; $ result = $ query -> firstCredential ( ) ; if ( $ result && false === $ result instanceof X509CredentialInterface ) { throw new \ LogicException ( sprintf ( 'Expected X509CredentialInterface but got %s' , get_class ( $ result ) ) ) ; } return $ result ; } 
public function setSsoSessionState ( SsoSessionState $ ssoSessionState ) { $ this -> ssoSessionState = $ ssoSessionState ; $ this -> allSsoSessionsTerminated = false ; return $ this ; } 
public function addAttributeValue ( $ attributeValue ) { if ( false == is_array ( $ this -> attributeValue ) ) { $ this -> attributeValue = array ( ) ; } $ this -> attributeValue [ ] = $ attributeValue ; return $ this ; } 
public function setAttributeValue ( $ attributeValue ) { if ( false == is_array ( $ attributeValue ) ) { $ attributeValue = array ( $ attributeValue ) ; } $ this -> attributeValue = $ attributeValue ; return $ this ; } 
public function equals ( $ nameId , $ format ) { if ( false == $ this -> getSubject ( ) ) { return false ; } if ( false == $ this -> getSubject ( ) -> getNameID ( ) ) { return false ; } if ( $ this -> getSubject ( ) -> getNameID ( ) -> getValue ( ) != $ nameId ) { return false ; } if ( $ this -> getSubject ( ) -> getNameID ( ) -> getFormat ( ) != $ format ) { return false ; } return true ; } 
public function hasSessionIndex ( $ sessionIndex ) { if ( null == $ this -> getAllAuthnStatements ( ) ) { return false ; } foreach ( $ this -> getAllAuthnStatements ( ) as $ authnStatement ) { if ( $ authnStatement -> getSessionIndex ( ) == $ sessionIndex ) { return true ; } } return false ; } 
public function serialize ( \ DOMNode $ parent , SerializationContext $ context ) { $ this -> prepareForXml ( ) ; $ result = $ this -> createElement ( 'Assertion' , SamlConstants :: NS_ASSERTION , $ parent , $ context ) ; $ this -> attributesToXml ( array ( 'ID' , 'Version' , 'IssueInstant' ) , $ result ) ; $ this -> singleElementsToXml ( array ( 'Issuer' , 'Subject' , 'Conditions' ) , $ result , $ context ) ; foreach ( $ this -> items as $ item ) { $ item -> serialize ( $ result , $ context ) ; } 
public function getBearerConfirmations ( ) { $ result = array ( ) ; if ( $ this -> getAllSubjectConfirmations ( ) ) { foreach ( $ this -> getAllSubjectConfirmations ( ) as $ confirmation ) { if ( SamlConstants :: CONFIRMATION_METHOD_BEARER == $ confirmation -> getMethod ( ) ) { $ result [ ] = $ confirmation ; break ; } } } return $ result ; } 
public function serialize ( \ DOMNode $ parent , SerializationContext $ context ) { $ result = $ this -> createElement ( 'Subject' , SamlConstants :: NS_ASSERTION , $ parent , $ context ) ; $ this -> singleElementsToXml ( array ( 'NameID' ) , $ result , $ context ) ; $ this -> manyElementsToXml ( $ this -> getAllSubjectConfirmations ( ) , $ result , $ context , null ) ; } 
protected function doExecute ( ProfileContext $ context ) { $ bindingType = $ this -> bindingFactory -> detectBindingType ( $ context -> getHttpRequest ( ) ) ; if ( null == $ bindingType ) { $ message = 'Unable to resolve binding type, invalid or unsupported http request' ; $ this -> logger -> critical ( $ message , LogHelper :: getActionErrorContext ( $ context , $ this ) ) ; throw new LightSamlBindingException ( $ message ) ; } $ this -> logger -> debug ( sprintf ( 'Detected binding type: %s' , $ bindingType ) , LogHelper :: getActionContext ( $ context , $ this ) ) ; $ binding = $ this -> bindingFactory -> create ( $ bindingType ) ; $ binding -> receive ( $ context -> getHttpRequest ( ) , $ context -> getInboundContext ( ) ) ; $ context -> getInboundContext ( ) -> setBindingType ( $ bindingType ) ; $ this -> logger -> info ( 'Received message' , LogHelper :: getActionContext ( $ context , $ this , array ( 'message' => $ context -> getInboundContext ( ) -> getDeserializationContext ( ) -> getDocument ( ) -> saveXML ( ) , ) ) ) ; } 
public function add ( $ entityDescriptor ) { if ( $ entityDescriptor instanceof EntityDescriptor ) { if ( false == $ entityDescriptor -> getEntityID ( ) ) { throw new \ InvalidArgumentException ( 'EntityDescriptor must have entityId set' ) ; } $ this -> descriptors [ $ entityDescriptor -> getEntityID ( ) ] = $ entityDescriptor ; } elseif ( $ entityDescriptor instanceof EntitiesDescriptor ) { foreach ( $ entityDescriptor -> getAllItems ( ) as $ item ) { $ this -> add ( $ item ) ; } } else { throw new \ InvalidArgumentException ( 'Expected EntityDescriptor or EntitiesDescriptor' ) ; } return $ this ; } 
public function get ( $ entityId ) { if ( isset ( $ this -> descriptors [ $ entityId ] ) ) { return $ this -> descriptors [ $ entityId ] ; } return null ; } 
protected function doExecute ( ProfileContext $ context ) { MessageContextHelper :: asSamlMessage ( $ context -> getOutboundContext ( ) ) -> setIssueInstant ( $ this -> timeProvider -> getTimestamp ( ) ) ; $ this -> logger -> info ( sprintf ( 'Message IssueInstant set to "%s"' , MessageContextHelper :: asSamlMessage ( $ context -> getOutboundContext ( ) ) -> getIssueInstantString ( ) ) , LogHelper :: getActionContext ( $ context , $ this ) ) ; } 
public function resolve ( CriteriaSet $ criteriaSet , array $ arrCredentials = array ( ) ) { if ( false == $ criteriaSet -> has ( UsageCriteria :: class ) ) { return $ arrCredentials ; } $ result = array ( ) ; foreach ( $ criteriaSet -> get ( UsageCriteria :: class ) as $ criteria ) { foreach ( $ arrCredentials as $ credential ) { if ( false == $ credential -> getUsageType ( ) || $ criteria -> getUsage ( ) == $ credential -> getUsageType ( ) ) { $ result [ ] = $ credential ; } } } return $ result ; } 
protected function createRootElement ( \ DOMNode $ parent , SerializationContext $ context ) { return $ this -> createElement ( 'saml:EncryptedAssertion' , SamlConstants :: NS_ASSERTION , $ parent , $ context ) ; } 
public function getByEntityId ( $ entityId ) { if ( $ entityId != $ this -> entityId ) { return [ ] ; } if ( null == $ this -> credential ) { $ certificate = X509Certificate :: fromFile ( $ this -> certificatePath ) ; $ this -> credential = new X509Credential ( $ certificate , KeyHelper :: createPrivateKey ( $ this -> keyPath , $ this -> password , true , $ certificate -> getSignatureAlgorithm ( ) ) ) ; $ this -> credential -> setEntityId ( $ this -> entityId ) ; } return [ $ this -> credential ] ; } 
public function resolve ( CriteriaSet $ criteriaSet , array $ arrCredentials = array ( ) ) { if ( false == $ criteriaSet -> has ( AlgorithmCriteria :: class ) ) { return $ arrCredentials ; } $ result = array ( ) ; foreach ( $ criteriaSet -> get ( AlgorithmCriteria :: class ) as $ criteria ) { foreach ( $ arrCredentials as $ credential ) { if ( ( $ credential -> getPrivateKey ( ) && $ credential -> getPrivateKey ( ) -> getAlgorith ( ) == $ criteria -> getAlgorithm ( ) ) || ( $ credential -> getPublicKey ( ) && $ credential -> getPublicKey ( ) -> getAlgorith ( ) == $ criteria -> getAlgorithm ( ) ) ) { $ result [ ] = $ credential ; } } } return $ result ; } 
public function serialize ( \ DOMNode $ parent , SerializationContext $ context ) { $ result = $ this -> createElement ( 'Conditions' , SamlConstants :: NS_ASSERTION , $ parent , $ context ) ; $ this -> attributesToXml ( array ( 'NotBefore' , 'NotOnOrAfter' ) , $ result ) ; foreach ( $ this -> items as $ item ) { $ item -> serialize ( $ result , $ context ) ; } } 
public static function fromFile ( $ path ) { $ deserializatonContext = new DeserializationContext ( ) ; $ xml = file_get_contents ( $ path ) ; return self :: fromXML ( $ xml , $ deserializatonContext ) ; } 
public static function fromXML ( $ xml , DeserializationContext $ context ) { if ( false == is_string ( $ xml ) ) { throw new \ InvalidArgumentException ( 'Expecting string' ) ; } $ context -> getDocument ( ) -> loadXML ( $ xml ) ; $ node = $ context -> getDocument ( ) -> firstChild ; while ( $ node && $ node instanceof \ DOMComment ) { $ node = $ node -> nextSibling ; } if ( null === $ node ) { throw new LightSamlXmlException ( 'Empty XML' ) ; } if ( SamlConstants :: NS_METADATA !== $ node -> namespaceURI ) { throw new LightSamlXmlException ( sprintf ( "Invalid namespace '%s' of the root XML element, expected '%s'" , $ node -> namespaceURI , SamlConstants :: NS_METADATA ) ) ; } $ map = array ( 'EntityDescriptor' => '\LightSaml\Model\Metadata\EntityDescriptor' , 'EntitiesDescriptor' => '\LightSaml\Model\Metadata\EntitiesDescriptor' , ) ; $ rootElementName = $ node -> localName ; if ( array_key_exists ( $ rootElementName , $ map ) ) { if ( $ class = $ map [ $ rootElementName ] ) { $ result = new $ class ( ) ; } else { throw new \ LogicException ( 'Deserialization of %s root element is not implemented' ) ; } } else { throw new LightSamlXmlException ( sprintf ( "Unknown SAML metadata '%s'" , $ rootElementName ) ) ; } $ result -> deserialize ( $ node , $ context ) ; return $ result ; } 
protected function doExecute ( ProfileContext $ context ) { $ ownEntityDescriptor = $ context -> getOwnEntityDescriptor ( ) ; $ issuer = new Issuer ( $ ownEntityDescriptor -> getEntityID ( ) ) ; $ issuer -> setFormat ( SamlConstants :: NAME_ID_FORMAT_ENTITY ) ; MessageContextHelper :: asSamlMessage ( $ context -> getOutboundContext ( ) ) -> setIssuer ( $ issuer ) ; $ this -> logger -> debug ( sprintf ( 'Issuer set to "%s"' , $ ownEntityDescriptor -> getEntityID ( ) ) , LogHelper :: getActionContext ( $ context , $ this ) ) ; } 
public function get ( $ entityId ) { foreach ( $ this -> children as $ store ) { $ result = $ store -> get ( $ entityId ) ; if ( $ result ) { return $ result ; } } return null ; } 
public function has ( $ entityId ) { foreach ( $ this -> children as $ store ) { if ( $ store -> has ( $ entityId ) ) { return true ; } } return false ; } 
protected function getCriteriaSet ( ProfileContext $ context ) { $ criteriaSet = new CriteriaSet ( ) ; $ bindings = $ this -> getBindings ( $ context ) ; if ( $ bindings ) { $ criteriaSet -> add ( new BindingCriteria ( $ bindings ) ) ; } $ descriptorType = $ this -> getDescriptorType ( $ context ) ; if ( $ descriptorType ) { $ criteriaSet -> add ( new DescriptorTypeCriteria ( $ descriptorType ) ) ; } $ serviceType = $ this -> getServiceType ( $ context ) ; if ( $ serviceType ) { $ criteriaSet -> add ( new ServiceTypeCriteria ( $ serviceType ) ) ; } return $ criteriaSet ; } 
public function addOwnCredential ( CredentialInterface $ credential ) { if ( null == $ credential -> getPrivateKey ( ) ) { throw new LightSamlBuildException ( 'Own credential must have private key' ) ; } $ this -> ownCredentials [ ] = $ credential ; return $ this ; } 
public function validateAssertion ( Assertion $ assertion ) { $ this -> validateAssertionAttributes ( $ assertion ) ; $ this -> validateSubject ( $ assertion ) ; $ this -> validateConditions ( $ assertion ) ; $ this -> validateStatements ( $ assertion ) ; } 
protected function validateAssertionAttributes ( Assertion $ assertion ) { if ( false == Helper :: validateRequiredString ( $ assertion -> getVersion ( ) ) ) { throw new LightSamlValidationException ( 'Assertion element must have the Version attribute set.' ) ; } if ( SamlConstants :: VERSION_20 != $ assertion -> getVersion ( ) ) { throw new LightSamlValidationException ( 'Assertion element must have the Version attribute value equal to 2.0.' ) ; } if ( false == Helper :: validateRequiredString ( $ assertion -> getId ( ) ) ) { throw new LightSamlValidationException ( 'Assertion element must have the ID attribute set.' ) ; } if ( false == Helper :: validateIdString ( $ assertion -> getId ( ) ) ) { throw new LightSamlValidationException ( 'Assertion element must have an ID attribute with at least 16 characters (the equivalent of 128 bits).' ) ; } if ( false == $ assertion -> getIssueInstantTimestamp ( ) ) { throw new LightSamlValidationException ( 'Assertion element must have the IssueInstant attribute set.' ) ; } if ( false == $ assertion -> getIssuer ( ) ) { throw new LightSamlValidationException ( 'Assertion element must have an issuer element.' ) ; } $ this -> nameIdValidator -> validateNameId ( $ assertion -> getIssuer ( ) ) ; } 
protected function validateSubject ( Assertion $ assertion ) { if ( false == $ assertion -> getSubject ( ) ) { if ( false == $ assertion -> getAllItems ( ) ) { throw new LightSamlValidationException ( 'Assertion with no Statements must have a subject.' ) ; } foreach ( $ assertion -> getAllItems ( ) as $ item ) { if ( $ item instanceof AuthnStatement || $ item instanceof AttributeStatement ) { throw new LightSamlValidationException ( 'AuthnStatement, AuthzDecisionStatement and AttributeStatement require a subject.' ) ; } } } else { $ this -> subjectValidator -> validateSubject ( $ assertion -> getSubject ( ) ) ; } } 
protected function validateProxyRestriction ( ProxyRestriction $ item ) { if ( null === $ item -> getCount ( ) || '' === $ item -> getCount ( ) || intval ( $ item -> getCount ( ) ) != $ item -> getCount ( ) || $ item -> getCount ( ) < 0 ) { throw new LightSamlValidationException ( 'Count attribute of ProxyRestriction MUST BE a non-negative integer' ) ; } if ( $ item -> getAllAudience ( ) ) { foreach ( $ item -> getAllAudience ( ) as $ audience ) { if ( false == Helper :: validateWellFormedUriString ( $ audience ) ) { throw new LightSamlValidationException ( 'ProxyRestriction Audience MUST BE a wellformed uri' ) ; } } } } 
protected function validateAudienceRestriction ( AudienceRestriction $ item ) { if ( false == $ item -> getAllAudience ( ) ) { return ; } foreach ( $ item -> getAllAudience ( ) as $ audience ) { if ( false == Helper :: validateWellFormedUriString ( $ audience ) ) { throw new LightSamlValidationException ( 'AudienceRestriction MUST BE a wellformed uri' ) ; } } } 
public function validate ( XMLSecurityKey $ key ) { if ( null == $ this -> getSignature ( ) ) { return false ; } $ key = $ this -> castKeyIfNecessary ( $ key ) ; $ signature = base64_decode ( $ this -> getSignature ( ) ) ; if ( false == $ key -> verifySignature ( $ this -> getData ( ) , $ signature ) ) { throw new LightSamlSecurityException ( 'Unable to validate signature on query string' ) ; } return true ; } 
public function serialize ( \ DOMNode $ parent , SerializationContext $ context ) { $ this -> prepareForXml ( ) ; if ( SamlConstants :: NS_ASSERTION == $ parent -> namespaceURI ) { $ result = $ this -> createElement ( $ this -> getElementName ( ) , SamlConstants :: NS_ASSERTION , $ parent , $ context ) ; } else { $ result = $ this -> createElement ( 'saml:' . $ this -> getElementName ( ) , SamlConstants :: NS_ASSERTION , $ parent , $ context ) ; } $ this -> attributesToXml ( array ( 'Format' , 'NameQualifier' , 'SPNameQualifier' , 'SPProvidedID' ) , $ result ) ; $ result -> nodeValue = $ this -> getValue ( ) ; } 
public function addContactPerson ( ContactPerson $ contactPerson ) { if ( false == is_array ( $ this -> contactPersons ) ) { $ this -> contactPersons = array ( ) ; } $ this -> contactPersons [ ] = $ contactPerson ; return $ this ; } 
public function addKeyDescriptor ( KeyDescriptor $ keyDescriptor ) { if ( false == is_array ( $ this -> keyDescriptors ) ) { $ this -> keyDescriptors = array ( ) ; } $ this -> keyDescriptors [ ] = $ keyDescriptor ; return $ this ; } 
public function getAllKeyDescriptorsByUse ( $ use ) { $ result = array ( ) ; foreach ( $ this -> getAllKeyDescriptors ( ) as $ kd ) { if ( $ kd -> getUse ( ) == $ use ) { $ result [ ] = $ kd ; } } return $ result ; } 
public function getFirstKeyDescriptor ( $ use = null ) { if ( $ this -> getAllKeyDescriptors ( ) ) { foreach ( $ this -> getAllKeyDescriptors ( ) as $ kd ) { if ( null == $ use || $ kd -> getUse ( ) == $ use ) { return $ kd ; } } } return ; } 
public function addOrganization ( Organization $ organization ) { if ( false == is_array ( $ this -> organizations ) ) { $ this -> organizations = array ( ) ; } $ this -> organizations [ ] = $ organization ; return $ this ; } 
public function addSignature ( Signature $ signature ) { if ( false == is_array ( $ this -> signatures ) ) { $ this -> signatures = array ( ) ; } $ this -> signatures [ ] = $ signature ; return $ this ; } 
public function serialize ( \ DOMNode $ parent , SerializationContext $ context ) { $ this -> attributesToXml ( array ( 'protocolSupportEnumeration' , 'ID' , 'validUntil' , 'cacheDuration' , 'errorURL' ) , $ parent ) ; $ this -> manyElementsToXml ( $ this -> getAllSignatures ( ) , $ parent , $ context , null ) ; $ this -> manyElementsToXml ( $ this -> getAllKeyDescriptors ( ) , $ parent , $ context , null ) ; $ this -> manyElementsToXml ( $ this -> getAllOrganizations ( ) , $ parent , $ context , null ) ; $ this -> manyElementsToXml ( $ this -> getAllContactPersons ( ) , $ parent , $ context , null ) ; } 
public function validateStatement ( AbstractStatement $ statement ) { if ( $ statement instanceof AuthnStatement ) { $ this -> validateAuthnStatement ( $ statement ) ; } elseif ( $ statement instanceof AttributeStatement ) { $ this -> validateAttributeStatement ( $ statement ) ; } else { throw new LightSamlValidationException ( sprintf ( "Unsupported Statement type '%s'" , get_class ( $ statement ) ) ) ; } } 
public function get ( $ class ) { foreach ( $ this -> contexts as $ context ) { if ( get_class ( $ context ) == $ class || is_subclass_of ( $ context , $ class ) ) { return $ context ; } } return null ; } 
public function setIsPassive ( $ isPassive ) { $ this -> isPassive = 0 == strcasecmp ( $ isPassive , 'true' ) || true === $ isPassive || 1 == $ isPassive ; return $ this ; } 
public function setForceAuthn ( $ forceAuthn ) { $ this -> forceAuthn = 0 == strcasecmp ( $ forceAuthn , 'true' ) || true === $ forceAuthn || 1 == $ forceAuthn ; return $ this ; } 
public function setAttributeConsumingServiceIndex ( $ attributeConsumingServiceIndex ) { $ this -> attributeConsumingServiceIndex = null !== $ attributeConsumingServiceIndex ? intval ( ( ( string ) $ attributeConsumingServiceIndex ) ) : null ; return $ this ; } 
public function setAssertionConsumerServiceIndex ( $ assertionConsumerServiceIndex ) { $ this -> assertionConsumerServiceIndex = null !== $ assertionConsumerServiceIndex ? intval ( ( string ) $ assertionConsumerServiceIndex ) : null ; return $ this ; } 
public function serialize ( \ DOMNode $ parent , SerializationContext $ context ) { $ result = $ this -> createElement ( 'AuthnRequest' , SamlConstants :: NS_PROTOCOL , $ parent , $ context ) ; parent :: serialize ( $ result , $ context ) ; $ this -> attributesToXml ( array ( 'ForceAuthn' , 'IsPassive' , 'ProtocolBinding' , 'AssertionConsumerServiceIndex' , 'AssertionConsumerServiceURL' , 'AttributeConsumingServiceIndex' , 'ProviderName' , ) , $ result ) ; $ this -> singleElementsToXml ( array ( 'Subject' , 'NameIDPolicy' , 'Conditions' ) , $ result , $ context ) ; 
private function shouldSignMessage ( ProfileContext $ context ) { $ message = $ context -> getOutboundMessage ( ) ; if ( $ message instanceof LogoutRequest ) { return true ; } $ trustOptions = $ context -> getTrustOptions ( ) ; if ( $ message instanceof AuthnRequest ) { return $ trustOptions -> getSignAuthnRequest ( ) ; } elseif ( $ message instanceof Response ) { return $ trustOptions -> getSignResponse ( ) ; } throw new \ LogicException ( sprintf ( 'Unexpected message type "%s"' , get_class ( $ message ) ) ) ; } 
public function getPreference ( $ binding ) { return isset ( $ this -> bindings [ $ binding ] ) ? $ this -> bindings [ $ binding ] : null ; } 
public static function create ( SigningOptions $ options ) { $ writer = new self ( $ options -> getCertificate ( ) , $ options -> getPrivateKey ( ) ) ; $ writer -> signingOptions = $ options ; return $ writer ; } 
public static function createByKeyAndCertificate ( X509Certificate $ certificate , XMLSecurityKey $ xmlSecurityKey ) { $ signingOptions = new SigningOptions ( $ xmlSecurityKey , $ certificate ) ; return self :: create ( $ signingOptions ) ; } 
public function send ( MessageContext $ context , $ destination = null ) { $ destination = $ context -> getMessage ( ) -> getDestination ( ) ? $ context -> getMessage ( ) -> getDestination ( ) : $ destination ; $ url = $ this -> getRedirectURL ( $ context , $ destination ) ; return new RedirectResponse ( $ url ) ; } 
protected function processData ( array $ data , MessageContext $ context ) { $ msg = $ this -> getMessageStringFromData ( $ data ) ; $ encoding = $ this -> getEncodingFromData ( $ data ) ; $ msg = $ this -> decodeMessageString ( $ msg , $ encoding ) ; $ this -> dispatchReceive ( $ msg ) ; $ deserializationContext = $ context -> getDeserializationContext ( ) ; $ message = SamlMessage :: fromXML ( $ msg , $ deserializationContext ) ; $ this -> loadRelayState ( $ message , $ data ) ; $ this -> loadSignature ( $ message , $ data ) ; $ context -> setMessage ( $ message ) ; } 
protected function decodeMessageString ( $ msg , $ encoding ) { $ msg = base64_decode ( $ msg ) ; switch ( $ encoding ) { case SamlConstants :: ENCODING_DEFLATE : return gzinflate ( $ msg ) ; break ; default : throw new LightSamlBindingException ( sprintf ( "Unknown encoding '%s'" , $ encoding ) ) ; } } 
protected function getRedirectURL ( MessageContext $ context , $ destination ) { $ message = MessageContextHelper :: asSamlMessage ( $ context ) ; $ signature = $ message -> getSignature ( ) ; if ( $ signature && false == $ signature instanceof SignatureWriter ) { throw new LightSamlBindingException ( 'Signature must be SignatureWriter' ) ; } $ xml = $ this -> getMessageEncodedXml ( $ message , $ context ) ; $ msg = $ this -> addMessageToUrl ( $ message , $ xml ) ; $ this -> addRelayStateToUrl ( $ msg , $ message ) ; $ this -> addSignatureToUrl ( $ msg , $ signature ) ; return $ this -> getDestinationUrl ( $ msg , $ message , $ destination ) ; } 
protected function getMessageEncodedXml ( SamlMessage $ message , MessageContext $ context ) { $ message -> setSignature ( null ) ; $ serializationContext = $ context -> getSerializationContext ( ) ; $ message -> serialize ( $ serializationContext -> getDocument ( ) , $ serializationContext ) ; $ xml = $ serializationContext -> getDocument ( ) -> saveXML ( ) ; $ this -> dispatchSend ( $ xml ) ; $ xml = gzdeflate ( $ xml ) ; $ xml = base64_encode ( $ xml ) ; return $ xml ; } 
protected function addMessageToUrl ( SamlMessage $ message , $ xml ) { if ( $ message instanceof AbstractRequest ) { $ msg = 'SAMLRequest=' ; } else { $ msg = 'SAMLResponse=' ; } $ msg .= urlencode ( $ xml ) ; return $ msg ; } 
protected function getDestinationUrl ( $ msg , SamlMessage $ message , $ destination ) { $ destination = $ message -> getDestination ( ) ? $ message -> getDestination ( ) : $ destination ; if ( false === strpos ( $ destination , '?' ) ) { $ destination .= '?' . $ msg ; } else { $ destination .= '&' . $ msg ; } return $ destination ; } 
protected function parseQuery ( Request $ request ) { $ sigQuery = $ relayState = $ sigAlg = '' ; $ data = $ this -> parseQueryString ( $ request -> server -> get ( 'QUERY_STRING' ) , false ) ; $ result = array ( ) ; foreach ( $ data as $ name => $ value ) { $ result [ $ name ] = urldecode ( $ value ) ; switch ( $ name ) { case 'SAMLRequest' : case 'SAMLResponse' : $ sigQuery = $ name . '=' . $ value ; break ; case 'RelayState' : $ relayState = '&RelayState=' . $ value ; break ; case 'SigAlg' : $ sigAlg = '&SigAlg=' . $ value ; break ; } } $ result [ 'SignedQuery' ] = $ sigQuery . $ relayState . $ sigAlg ; return $ result ; } 
private function buildOwnEntityDescriptorProvider ( \ LightSaml \ Credential \ X509Certificate $ certificate ) { return new \ LightSaml \ Builder \ EntityDescriptor \ SimpleEntityDescriptorBuilder ( self :: OWN_ENTITY_ID , 'https://localhost/lightsaml/lightSAML/web/sp/acs.php' , null , $ certificate ) ; } 
public function validate ( AbstractSignatureReader $ signature , $ issuer , $ metadataType ) { $ query = $ this -> credentialResolver -> query ( ) ; $ query -> add ( new EntityIdCriteria ( $ issuer ) ) -> add ( new MetadataCriteria ( $ metadataType , SamlConstants :: VERSION_20 ) ) -> add ( new UsageCriteria ( UsageType :: SIGNING ) ) ; if ( $ signature -> getKey ( ) && $ signature -> getKey ( ) -> getX509Thumbprint ( ) ) { $ query -> add ( new PublicKeyThumbprintCriteria ( $ signature -> getKey ( ) -> getX509Thumbprint ( ) ) ) ; } $ query -> resolve ( ) ; $ credentialCandidates = $ query -> allCredentials ( ) ; if ( empty ( $ credentialCandidates ) ) { throw new LightSamlSecurityException ( 'No credentials resolved for signature verification' ) ; } $ credential = $ signature -> validateMulti ( $ credentialCandidates ) ; return $ credential ; } 
public function getByEntityId ( $ entityId ) { $ entityDescriptor = $ this -> entityDescriptorProvider -> get ( $ entityId ) ; if ( false == $ entityDescriptor ) { return array ( ) ; } return $ this -> extractCredentials ( $ entityDescriptor ) ; } 
protected function extractCredentials ( EntityDescriptor $ entityDescriptor ) { $ result = array ( ) ; foreach ( $ entityDescriptor -> getAllIdpSsoDescriptors ( ) as $ idpDescriptor ) { $ this -> handleDescriptor ( $ idpDescriptor , $ entityDescriptor , $ result ) ; } foreach ( $ entityDescriptor -> getAllSpSsoDescriptors ( ) as $ spDescriptor ) { $ this -> handleDescriptor ( $ spDescriptor , $ entityDescriptor , $ result ) ; } return $ result ; } 
public function buildFromOwnCredentialStore ( EntityDescriptorStoreInterface $ idpEntityDescriptorStore , EntityDescriptorStoreInterface $ spEntityDescriptorStore , $ ownEntityId , CredentialStoreInterface $ ownCredentialStore , array $ extraCredentials = null ) { return $ this -> build ( $ idpEntityDescriptorStore , $ spEntityDescriptorStore , $ ownCredentialStore -> getByEntityId ( $ ownEntityId ) , $ extraCredentials ) ; } 
public function build ( EntityDescriptorStoreInterface $ idpEntityDescriptorStore , EntityDescriptorStoreInterface $ spEntityDescriptorStore , array $ ownCredentials , array $ extraCredentials = null ) { if ( empty ( $ ownCredentials ) ) { throw new LightSamlBuildException ( 'There are no own credentials' ) ; } $ store = new CompositeCredentialStore ( ) ; $ store -> add ( new MetadataCredentialStore ( $ idpEntityDescriptorStore ) ) ; $ store -> add ( new MetadataCredentialStore ( $ spEntityDescriptorStore ) ) ; $ ownCredentialsStore = new StaticCredentialStore ( ) ; foreach ( $ ownCredentials as $ credential ) { $ ownCredentialsStore -> add ( $ credential ) ; } $ store -> add ( $ ownCredentialsStore ) ; $ extraCredentialsStore = new StaticCredentialStore ( ) ; $ store -> add ( $ extraCredentialsStore ) ; foreach ( $ this -> extraCredentials as $ credential ) { $ extraCredentialsStore -> add ( $ credential ) ; } if ( $ extraCredentials ) { foreach ( $ extraCredentials as $ credential ) { $ extraCredentialsStore -> add ( $ credential ) ; } } return $ store ; } 
public static function isProtocolValid ( $ value ) { static $ arr = array ( self :: PROTOCOL_SAML2 , self :: PROTOCOL_SAML1 , self :: PROTOCOL_SAML11 , self :: PROTOCOL_SHIB1 , self :: PROTOCOL_WS_FED , ) ; return in_array ( $ value , $ arr ) ; } 
public static function isNsValid ( $ value ) { static $ arr = array ( self :: NS_PROTOCOL , self :: NS_METADATA , self :: NS_ASSERTION , self :: NS_XMLDSIG , ) ; return in_array ( $ value , $ arr ) ; } 
public static function isNameIdFormatValid ( $ value ) { static $ arr = array ( self :: NAME_ID_FORMAT_NONE , self :: NAME_ID_FORMAT_ENTITY , self :: NAME_ID_FORMAT_PERSISTENT , self :: NAME_ID_FORMAT_TRANSIENT , self :: NAME_ID_FORMAT_EMAIL , self :: NAME_ID_FORMAT_SHIB_NAME_ID , self :: NAME_ID_FORMAT_X509_SUBJECT_NAME , self :: NAME_ID_FORMAT_WINDOWS , self :: NAME_ID_FORMAT_KERBEROS , self :: NAME_ID_FORMAT_UNSPECIFIED , ) ; return in_array ( $ value , $ arr ) ; } 
public static function isBindingValid ( $ value ) { static $ arr = array ( self :: BINDING_SAML2_HTTP_REDIRECT , self :: BINDING_SAML2_HTTP_POST , self :: BINDING_SAML2_HTTP_ARTIFACT , self :: BINDING_SAML2_SOAP , self :: BINDING_SAML2_HTTP_POST_SIMPLE_SIGN , self :: BINDING_SHIB1_AUTHN_REQUEST , self :: BINDING_SAML1_BROWSER_POST , self :: BINDING_SAML1_ARTIFACT1 , self :: BINDING_WS_FED_WEB_SVC , ) ; return in_array ( $ value , $ arr ) ; } 
public static function isStatusValid ( $ value ) { static $ arr = array ( self :: STATUS_SUCCESS , self :: STATUS_REQUESTER , self :: STATUS_RESPONDER , self :: STATUS_VERSION_MISMATCH , self :: STATUS_NO_PASSIVE , self :: STATUS_PARTIAL_LOGOUT , self :: STATUS_PROXY_COUNT_EXCEEDED , self :: STATUS_INVALID_NAME_ID_POLICY , self :: STATUS_UNSUPPORTED_BINDING , ) ; return in_array ( $ value , $ arr ) ; } 
public static function isConfirmationMethodValid ( $ value ) { static $ arr = array ( self :: CONFIRMATION_METHOD_BEARER , self :: CONFIRMATION_METHOD_HOK , self :: CONFIRMATION_METHOD_SENDER_VOUCHES , ) ; return in_array ( $ value , $ arr ) ; } 
public static function isAuthnContextValid ( $ value ) { static $ arr = array ( self :: AUTHN_CONTEXT_PASSWORD , self :: AUTHN_CONTEXT_UNSPECIFIED , self :: AUTHN_CONTEXT_PASSWORD_PROTECTED_TRANSPORT , self :: AUTHN_CONTEXT_WINDOWS , ) ; return in_array ( $ value , $ arr ) ; } 
public static function isLogoutReasonValid ( $ value ) { static $ arr = array ( self :: LOGOUT_REASON_USER , self :: LOGOUT_REASON_ADMIN , self :: LOGOUT_REASON_GLOBAL_TIMEOUT , self :: LOGOUT_REASON_SP_TIMEOUT , ) ; return in_array ( $ value , $ arr ) ; } 
public function setID ( $ id ) { $ this -> id = null !== $ id ? ( string ) $ id : null ; return $ this ; } 
public function addItem ( $ item ) { if ( false == $ item instanceof IdpSsoDescriptor && false == $ item instanceof SpSsoDescriptor ) { throw new \ InvalidArgumentException ( 'EntityDescriptor item must be IdpSsoDescriptor or SpSsoDescriptor' ) ; } if ( false == is_array ( $ this -> items ) ) { $ this -> items = array ( ) ; } $ this -> items [ ] = $ item ; return $ this ; } 
public function serialize ( \ DOMNode $ parent , SerializationContext $ context ) { $ result = $ this -> createElement ( 'EntityDescriptor' , SamlConstants :: NS_METADATA , $ parent , $ context ) ; $ this -> attributesToXml ( array ( 'entityID' , 'validUntil' , 'cacheDuration' , 'ID' ) , $ result ) ; $ this -> manyElementsToXml ( $ this -> getAllItems ( ) , $ result , $ context , null ) ; if ( $ this -> organizations ) { $ this -> manyElementsToXml ( $ this -> organizations , $ result , $ context , null ) ; } if ( $ this -> contactPersons ) { $ this -> manyElementsToXml ( $ this -> contactPersons , $ result , $ context , null ) ; } $ this -> singleElementsToXml ( array ( 'Signature' ) , $ result , $ context ) ; } 
public function getByEntityId ( $ entityId ) { $ result = array ( ) ; foreach ( $ this -> stores as $ store ) { $ result = array_merge ( $ result , $ store -> getByEntityId ( $ entityId ) ) ; } return $ result ; } 
protected function createElement ( $ name , $ namespace , \ DOMNode $ parent , SerializationContext $ context ) { if ( $ namespace ) { $ result = $ context -> getDocument ( ) -> createElementNS ( $ namespace , $ name ) ; } else { $ result = $ context -> getDocument ( ) -> createElement ( $ name ) ; } $ parent -> appendChild ( $ result ) ; return $ result ; } 
private function oneElementToXml ( $ name , \ DOMNode $ parent , SerializationContext $ context , $ namespace = null ) { $ value = $ this -> getPropertyValue ( $ name ) ; if ( null == $ value ) { return ; } if ( $ value instanceof SamlElementInterface ) { $ value -> serialize ( $ parent , $ context ) ; } elseif ( is_string ( $ value ) ) { if ( $ namespace ) { $ node = $ context -> getDocument ( ) -> createElementNS ( $ namespace , $ name , $ value ) ; } else { $ node = $ context -> getDocument ( ) -> createElement ( $ name , $ value ) ; } $ parent -> appendChild ( $ node ) ; } else { throw new \ LogicException ( sprintf ( "Element '%s' must implement SamlElementInterface or be a string" , $ name ) ) ; } } 
protected function manyElementsToXml ( $ value , \ DOMNode $ node , SerializationContext $ context , $ nodeName = null , $ namespaceUri = null ) { if ( false == $ value ) { return ; } if ( false == is_array ( $ value ) ) { throw new \ LogicException ( 'value must be array or null' ) ; } foreach ( $ value as $ object ) { if ( $ object instanceof SamlElementInterface ) { if ( $ nodeName ) { throw new \ LogicException ( 'nodeName should not be specified when serializing array of SamlElementInterface' ) ; } $ object -> serialize ( $ node , $ context ) ; } elseif ( $ nodeName ) { if ( $ namespaceUri ) { $ child = $ context -> getDocument ( ) -> createElementNS ( $ namespaceUri , $ nodeName , ( string ) $ object ) ; } else { $ child = $ context -> getDocument ( ) -> createElement ( $ nodeName , ( string ) $ object ) ; } $ node -> appendChild ( $ child ) ; } else { throw new \ LogicException ( 'Can handle only array of AbstractSamlModel or strings with nodeName parameter specified' ) ; } } } 
protected function manyElementsFromXml ( \ DOMElement $ node , DeserializationContext $ context , $ nodeName , $ namespacePrefix , $ class , $ methodName ) { if ( $ namespacePrefix ) { $ query = sprintf ( '%s:%s' , $ namespacePrefix , $ nodeName ) ; } else { $ query = sprintf ( '%s' , $ nodeName ) ; } foreach ( $ context -> getXpath ( ) -> query ( $ query , $ node ) as $ xml ) { if ( $ class ) { $ object = new $ class ( ) ; if ( false == $ object instanceof SamlElementInterface ) { throw new \ LogicException ( sprintf ( "Node '%s' class '%s' must implement SamlElementInterface" , $ nodeName , $ class ) ) ; } $ object -> deserialize ( $ xml , $ context ) ; $ this -> { $ methodName } ( $ object ) ; } else { $ object = $ xml -> textContent ; $ this -> { $ methodName } ( $ object ) ; } } } 
protected function singleAttributeToXml ( $ name , \ DOMElement $ element ) { $ value = $ this -> getPropertyValue ( $ name ) ; if ( null !== $ value && '' !== $ value ) { if ( is_bool ( $ value ) ) { $ element -> setAttribute ( $ name , $ value ? 'true' : 'false' ) ; } else { $ element -> setAttribute ( $ name , $ value ) ; } return true ; } return false ; } 
protected function oneElementFromXml ( \ DOMElement $ node , DeserializationContext $ context , $ elementName , $ class , $ namespacePrefix ) { if ( $ namespacePrefix ) { $ query = sprintf ( './%s:%s' , $ namespacePrefix , $ elementName ) ; } else { $ query = sprintf ( './%s' , $ elementName ) ; } $ arr = $ context -> getXpath ( ) -> query ( $ query , $ node ) ; $ value = $ arr -> length > 0 ? $ arr -> item ( 0 ) : null ; if ( $ value ) { $ setter = 'set' . $ elementName ; if ( false == method_exists ( $ this , $ setter ) ) { throw new \ LogicException ( sprintf ( "Unable to find setter for element '%s' in class '%s'" , $ elementName , get_class ( $ this ) ) ) ; } if ( $ class ) { $ object = new $ class ( ) ; if ( false == $ object instanceof \ LightSaml \ Model \ SamlElementInterface ) { throw new \ LogicException ( sprintf ( "Specified class '%s' for element '%s' must implement SamlElementInterface" , $ class , $ elementName ) ) ; } $ object -> deserialize ( $ value , $ context ) ; } else { $ object = $ value -> textContent ; } $ this -> { $ setter } ( $ object ) ; } } 
private function getPropertyValue ( $ name ) { if ( false !== ( $ pos = strpos ( $ name , ':' ) ) ) { $ name = substr ( $ name , $ pos + 1 ) ; } $ getter = 'get' . $ name . 'String' ; if ( false == method_exists ( $ this , $ getter ) ) { $ getter = 'get' . $ name ; } if ( false == method_exists ( $ this , $ getter ) ) { throw new \ LogicException ( sprintf ( "Unable to find getter method for '%s' on '%s'" , $ name , get_class ( $ this ) ) ) ; } $ value = $ this -> { $ getter } ( ) ; return $ value ; } 
public function encrypt ( AbstractSamlModel $ object , XMLSecurityKey $ key ) { $ oldKey = $ key ; $ key = new XMLSecurityKey ( $ this -> keyTransportEncryption , [ 'type' => 'public' ] ) ; $ key -> loadKey ( $ oldKey -> key ) ; $ serializationContext = new SerializationContext ( ) ; $ object -> serialize ( $ serializationContext -> getDocument ( ) , $ serializationContext ) ; $ enc = new XMLSecEnc ( ) ; $ enc -> setNode ( $ serializationContext -> getDocument ( ) -> firstChild ) ; $ enc -> type = XMLSecEnc :: Element ; switch ( $ key -> type ) { case XMLSecurityKey :: TRIPLEDES_CBC : case XMLSecurityKey :: AES128_CBC : case XMLSecurityKey :: AES192_CBC : case XMLSecurityKey :: AES256_CBC : $ symmetricKey = $ key ; break ; case XMLSecurityKey :: RSA_1_5 : case XMLSecurityKey :: RSA_SHA1 : case XMLSecurityKey :: RSA_SHA256 : case XMLSecurityKey :: RSA_SHA384 : case XMLSecurityKey :: RSA_SHA512 : case XMLSecurityKey :: RSA_OAEP_MGF1P : $ symmetricKey = new XMLSecurityKey ( $ this -> blockEncryptionAlgorithm ) ; $ symmetricKey -> generateSessionKey ( ) ; $ enc -> encryptKey ( $ key , $ symmetricKey ) ; break ; default : throw new LightSamlException ( sprintf ( 'Unknown key type for encryption: "%s"' , $ key -> type ) ) ; } $ this -> encryptedElement = $ enc -> encryptNode ( $ symmetricKey ) ; return $ serializationContext ; } 
public function serialize ( \ DOMNode $ parent , SerializationContext $ context ) { if ( null === $ this -> encryptedElement ) { throw new LightSamlException ( 'Encrypted element missing' ) ; } $ root = $ this -> createRootElement ( $ parent , $ context ) ; $ root -> appendChild ( $ context -> getDocument ( ) -> importNode ( $ this -> encryptedElement , true ) ) ; } 
public static function getActionContext ( ContextInterface $ context , ActionInterface $ action , array $ extraData = null ) { return self :: getContext ( $ context , $ action , $ extraData , false ) ; } 
public static function getActionErrorContext ( ContextInterface $ context , ActionInterface $ action , array $ extraData = null ) { return self :: getContext ( $ context , $ action , $ extraData , true ) ; } 
private static function getContext ( ContextInterface $ context , ActionInterface $ action = null , array $ extraData = null , $ logWholeContext = false ) { $ topContext = $ context -> getTopParent ( ) ; $ result = array ( ) ; if ( $ topContext instanceof ProfileContext ) { $ result [ 'profile_id' ] = $ topContext -> getProfileId ( ) ; $ result [ 'own_role' ] = $ topContext -> getOwnRole ( ) ; } if ( $ action ) { $ result [ 'action' ] = get_class ( $ action ) ; } $ result [ 'top_context_id' ] = spl_object_hash ( $ topContext ) ; if ( $ logWholeContext ) { $ result [ 'top_context' ] = $ topContext ; } if ( $ extraData ) { $ result = array_merge ( $ result , $ extraData ) ; } return $ result ; } 
public static function createElement ( DOMDocument $ document , $ name , array $ attributes = [ ] ) : DOMElement { $ element = $ document -> createElement ( $ name ) ; foreach ( $ attributes as $ attribName => $ attribValue ) { $ element -> setAttribute ( $ attribName , $ attribValue ) ; } return $ element ; } 
public static function createElementWithText ( DOMDocument $ document , string $ name , string $ text , array $ attributes = [ ] ) : DOMElement { $ element = self :: createElement ( $ document , $ name , $ attributes ) ; $ wrappedText = $ document -> createCDATASection ( $ text ) ; $ element -> appendChild ( $ wrappedText ) ; return $ element ; } 
private static function validateImages ( array $ images ) : bool { $ valid = false ; foreach ( $ images as $ image ) { if ( $ image -> getType ( ) === Image :: TYPE_DEFAULT ) { $ valid = true ; break ; } } if ( ! $ valid ) { throw new BaseImageMissingException ( ) ; } return $ valid ; } 
public static function checkForEmptyValue ( string $ valueName , $ value ) : string { $ value = trim ( $ value ) ; if ( $ value === '' ) { throw new EmptyValueNotAllowedException ( $ valueName ) ; } return $ value ; } 
public static function validateUrl ( string $ url ) : string { if ( ! filter_var ( $ url , FILTER_VALIDATE_URL ) || ! preg_match ( '/http[s]?:\/\/.*/' , $ url ) ) { throw new InvalidUrlException ( ) ; } return $ url ; } 
public static function checkForIllegalCsvPropertyKeys ( string $ propertyKey ) : void { if ( strpos ( $ propertyKey , "\t" ) !== false || strpos ( $ propertyKey , "\n" ) !== false ) { throw new BadPropertyKeyException ( $ propertyKey ) ; } } 
public static function create ( int $ type , int $ itemsPerPage = 20 , array $ csvProperties = [ ] ) : Exporter { if ( $ itemsPerPage < 1 ) { throw new InvalidArgumentException ( 'At least one item must be exported per page.' ) ; } switch ( $ type ) { case self :: TYPE_XML : $ exporter = new XMLExporter ( $ itemsPerPage ) ; break ; case self :: TYPE_CSV : $ exporter = new CSVExporter ( $ itemsPerPage , $ csvProperties ) ; break ; default : throw new InvalidArgumentException ( 'Unsupported exporter type.' ) ; } return $ exporter ; } 
public function addValue ( string $ value , ? string $ usergroup = null ) : void { if ( array_key_exists ( $ usergroup , $ this -> getAllValues ( ) ) ) { throw new DuplicateValueForUsergroupException ( $ this -> getKey ( ) , $ usergroup ) ; } $ this -> values [ $ usergroup ] = DataHelper :: checkForEmptyValue ( 'propertyValue' , $ value ) ; } 
private function validateWithSchema ( DOMDocument $ document ) : void { $ validationErrors = [ ] ; set_error_handler ( function ( $ errno , $ errstr ) use ( & $ validationErrors ) { array_push ( $ validationErrors , $ errstr ) ; } ) ; $ isValid = $ document -> schemaValidate ( Constant :: $ XSD_SCHEMA_PATH ) ; restore_error_handler ( ) ; if ( ! $ isValid ) { throw new XMLSchemaViolationException ( $ validationErrors ) ; } } 
public function addName ( string $ name , string $ usergroup = '' ) : void { $ this -> name -> setValue ( $ name , $ usergroup ) ; } 
public function addSummary ( string $ summary , string $ usergroup = '' ) : void { $ this -> summary -> setValue ( $ summary , $ usergroup ) ; } 
public function addDescription ( string $ description , string $ usergroup = '' ) : void { $ this -> description -> setValue ( $ description , $ usergroup ) ; } 
public function addPrice ( $ price , $ usergroup = '' ) : void { if ( $ this -> price === null ) { $ this -> price = new Price ( ) ; } $ this -> price -> setValue ( $ price , $ usergroup ) ; } 
public function addBonus ( float $ bonus , string $ usergroup = '' ) : void { $ this -> bonus -> setValue ( $ bonus , $ usergroup ) ; } 
public function addSalesFrequency ( int $ salesFrequency , string $ usergroup = '' ) : void { $ this -> salesFrequency -> setValue ( $ salesFrequency , $ usergroup ) ; } 
public function addDateAdded ( DateTime $ dateAdded , string $ usergroup = '' ) : void { $ this -> dateAdded -> setDateValue ( $ dateAdded , $ usergroup ) ; } 
public function addSort ( int $ sort , string $ usergroup = '' ) : void { $ this -> sort -> setValue ( $ sort , $ usergroup ) ; } 
protected function validate ( $ value ) { $ value = trim ( $ value ) ; if ( $ value === '' ) { throw new EmptyValueNotAllowedException ( $ this -> getValueName ( ) ) ; } return $ value ; } 
public function get ( $ name ) { if ( ! $ this -> has ( $ name ) ) { throw new InvalidArgumentException ( sprintf ( 'Hook named "%s" is not present' , $ name ) ) ; } return file_get_contents ( $ this -> getPath ( $ name ) ) ; } 
public function setSymlink ( $ name , $ file ) { if ( $ this -> has ( $ name ) ) { throw new LogicException ( sprintf ( 'A hook "%s" is already defined' , $ name ) ) ; } $ path = $ this -> getPath ( $ name ) ; if ( false === symlink ( $ file , $ path ) ) { throw new RuntimeException ( sprintf ( 'Unable to create hook "%s"' , $ name , $ path ) ) ; } } 
public function set ( $ name , $ content ) { if ( $ this -> has ( $ name ) ) { throw new LogicException ( sprintf ( 'A hook "%s" is already defined' , $ name ) ) ; } $ path = $ this -> getPath ( $ name ) ; file_put_contents ( $ path , $ content ) ; chmod ( $ path , 0777 ) ; } 
public function remove ( $ name ) { if ( ! $ this -> has ( $ name ) ) { throw new LogicException ( sprintf ( 'The hook "%s" was not found' , $ name ) ) ; } unlink ( $ this -> getPath ( $ name ) ) ; } 
public function countCommits ( ) { if ( null !== $ this -> revisions && count ( $ this -> revisions ) ) { $ output = $ this -> repository -> run ( 'rev-list' , array_merge ( array ( '--count' ) , $ this -> revisions -> getAsTextArray ( ) , array ( '--' ) , $ this -> paths ) ) ; } else { $ output = $ this -> repository -> run ( 'rev-list' , array_merge ( array ( '--count' , '--all' , '--' ) , $ this -> paths ) ) ; } return ( int ) $ output ; } 
private function initDir ( $ gitDir , $ workingDir = null ) { $ realGitDir = realpath ( $ gitDir ) ; if ( false === $ realGitDir ) { throw new InvalidArgumentException ( sprintf ( 'Directory "%s" does not exist or is not a directory' , $ gitDir ) ) ; } elseif ( ! is_dir ( $ realGitDir ) ) { throw new InvalidArgumentException ( sprintf ( 'Directory "%s" does not exist or is not a directory' , $ realGitDir ) ) ; } elseif ( null === $ workingDir && is_dir ( $ realGitDir . '/.git' ) ) { $ workingDir = $ realGitDir ; $ realGitDir = $ realGitDir . '/.git' ; } $ this -> gitDir = $ realGitDir ; $ this -> workingDir = $ workingDir ; } 
public function getHead ( ) { $ file = $ this -> gitDir . '/HEAD' ; if ( ! file_exists ( $ file ) ) { $ message = sprintf ( 'Unable to find HEAD file ("%s")' , $ file ) ; if ( null !== $ this -> logger ) { $ this -> logger -> error ( $ message ) ; } if ( true === $ this -> debug ) { throw new RuntimeException ( $ message ) ; } } $ content = trim ( file_get_contents ( $ file ) ) ; if ( null !== $ this -> logger ) { $ this -> logger -> debug ( 'HEAD file read: ' . $ content ) ; } if ( preg_match ( '/^ref: (.+)$/' , $ content , $ vars ) ) { return $ this -> getReferences ( ) -> get ( $ vars [ 1 ] ) ; } elseif ( preg_match ( '/^[0-9a-f]{40}$/' , $ content ) ) { return $ this -> getCommit ( $ content ) ; } $ message = sprintf ( 'Unexpected HEAD file content (file: %s). Content of file: %s' , $ file , $ content ) ; if ( null !== $ this -> logger ) { $ this -> logger -> error ( $ message ) ; } if ( true === $ this -> debug ) { throw new RuntimeException ( $ message ) ; } } 
public function getReferences ( ) { if ( null === $ this -> referenceBag ) { $ this -> referenceBag = new ReferenceBag ( $ this ) ; } return $ this -> referenceBag ; } 
public function getCommit ( $ hash ) { if ( ! isset ( $ this -> objects [ $ hash ] ) ) { $ this -> objects [ $ hash ] = new Commit ( $ this , $ hash ) ; } return $ this -> objects [ $ hash ] ; } 
public function getTree ( $ hash ) { if ( ! isset ( $ this -> objects [ $ hash ] ) ) { $ this -> objects [ $ hash ] = new Tree ( $ this , $ hash ) ; } return $ this -> objects [ $ hash ] ; } 
public function getBlob ( $ hash ) { if ( ! isset ( $ this -> objects [ $ hash ] ) ) { $ this -> objects [ $ hash ] = new Blob ( $ this , $ hash ) ; } return $ this -> objects [ $ hash ] ; } 
public function getLog ( $ revisions = null , $ paths = null , $ offset = null , $ limit = null ) { return new Log ( $ this , $ revisions , $ paths , $ offset , $ limit ) ; } 
public function getSize ( ) { $ commandlineArguments = array ( 'du' , '-skc' , $ this -> gitDir ) ; $ commandline = $ this -> normalizeCommandlineArguments ( $ commandlineArguments ) ; $ process = new Process ( $ commandline ) ; $ process -> run ( ) ; if ( ! preg_match ( '/(\d+)\s+total$/' , trim ( $ process -> getOutput ( ) ) , $ vars ) ) { $ message = sprintf ( "Unable to parse process output\ncommand: %s\noutput: %s" , $ process -> getCommandLine ( ) , $ process -> getOutput ( ) ) ; if ( null !== $ this -> logger ) { $ this -> logger -> error ( $ message ) ; } if ( true === $ this -> debug ) { throw new RuntimeException ( 'unable to parse repository size output' ) ; } return ; } return $ vars [ 1 ] ; } 
public function shell ( $ command , array $ env = array ( ) ) { $ argument = sprintf ( '%s \'%s\'' , $ command , $ this -> gitDir ) ; $ prefix = '' ; foreach ( $ env as $ name => $ value ) { $ prefix .= sprintf ( 'export %s=%s;' , escapeshellarg ( $ name ) , escapeshellarg ( $ value ) ) ; } proc_open ( $ prefix . 'git shell -c ' . escapeshellarg ( $ argument ) , array ( STDIN , STDOUT , STDERR ) , $ pipes ) ; } 
public function getDescription ( ) { $ file = $ this -> gitDir . '/description' ; $ exists = is_file ( $ file ) ; if ( null !== $ this -> logger && true === $ this -> debug ) { if ( false === $ exists ) { $ this -> logger -> debug ( sprintf ( 'no description file in repository ("%s")' , $ file ) ) ; } else { $ this -> logger -> debug ( sprintf ( 'reading description file in repository ("%s")' , $ file ) ) ; } } if ( false === $ exists ) { return static :: DEFAULT_DESCRIPTION ; } return file_get_contents ( $ this -> gitDir . '/description' ) ; } 
public function setDescription ( $ description ) { $ file = $ this -> gitDir . '/description' ; if ( null !== $ this -> logger && true === $ this -> debug ) { $ this -> logger -> debug ( sprintf ( 'change description file content to "%s" (file: %s)' , $ description , $ file ) ) ; } file_put_contents ( $ file , $ description ) ; return $ this ; } 
public function run ( $ command , $ args = array ( ) ) { $ process = $ this -> getProcess ( $ command , $ args ) ; if ( $ this -> logger ) { $ this -> logger -> info ( sprintf ( 'run command: %s "%s" ' , $ command , implode ( ' ' , $ args ) ) ) ; $ before = microtime ( true ) ; } $ process -> run ( ) ; $ output = $ process -> getOutput ( ) ; if ( $ this -> logger && $ this -> debug ) { $ duration = microtime ( true ) - $ before ; $ this -> logger -> debug ( sprintf ( 'last command (%s) duration: %sms' , $ command , sprintf ( '%.2f' , $ duration * 1000 ) ) ) ; $ this -> logger -> debug ( sprintf ( 'last command (%s) return code: %s' , $ command , $ process -> getExitCode ( ) ) ) ; $ this -> logger -> debug ( sprintf ( 'last command (%s) output: %s' , $ command , $ output ) ) ; } if ( ! $ process -> isSuccessful ( ) ) { $ error = sprintf ( "error while running %s\n output: \"%s\"" , $ command , $ process -> getErrorOutput ( ) ) ; if ( $ this -> logger ) { $ this -> logger -> error ( $ error ) ; } if ( $ this -> debug ) { throw new ProcessException ( $ process ) ; } return ; } return $ output ; } 
public function cloneTo ( $ path , $ bare = true , array $ options = array ( ) ) { return Admin :: cloneTo ( $ path , $ this -> gitDir , $ bare , $ options ) ; } 
private function getProcess ( $ command , $ args = array ( ) ) { $ base = array ( $ this -> command , '--git-dir' , $ this -> gitDir ) ; if ( $ this -> workingDir ) { $ base = array_merge ( $ base , array ( '--work-tree' , $ this -> workingDir ) ) ; } $ base [ ] = $ command ; $ commandlineArguments = array_merge ( $ base , $ args ) ; $ commandline = $ this -> normalizeCommandlineArguments ( $ commandlineArguments ) ; $ process = new Process ( $ commandline ) ; $ process -> setEnv ( $ this -> environmentVariables ) ; $ process -> setTimeout ( $ this -> processTimeout ) ; $ process -> setIdleTimeout ( $ this -> processTimeout ) ; return $ process ; } 
public function getParents ( ) { $ result = array ( ) ; foreach ( $ this -> getData ( 'parentHashes' ) as $ parentHash ) { $ result [ ] = $ this -> repository -> getCommit ( $ parentHash ) ; } return $ result ; } 
public function getShortMessage ( $ length = 50 , $ preserve = false , $ separator = '...' ) { $ message = $ this -> getData ( 'subjectMessage' ) ; if ( StringHelper :: strlen ( $ message ) > $ length ) { if ( $ preserve && false !== ( $ breakpoint = StringHelper :: strpos ( $ message , ' ' , $ length ) ) ) { $ length = $ breakpoint ; } return rtrim ( StringHelper :: substr ( $ message , 0 , $ length ) ) . $ separator ; } return $ message ; } 
public function getIncludingBranches ( $ local = true , $ remote = true ) { $ arguments = array ( '--contains' , $ this -> revision ) ; if ( $ local && $ remote ) { $ arguments [ ] = '-a' ; } elseif ( ! $ local && $ remote ) { $ arguments [ ] = '-r' ; } elseif ( ! $ local && ! $ remote ) { throw new InvalidArgumentException ( 'You should a least set one argument to true' ) ; } try { $ result = $ this -> repository -> run ( 'branch' , $ arguments ) ; } catch ( ProcessException $ e ) { return array ( ) ; } if ( ! $ result ) { return array ( ) ; } $ branchesName = explode ( "\n" , trim ( str_replace ( '*' , '' , $ result ) ) ) ; $ branchesName = array_filter ( $ branchesName , function ( $ v ) { return false === StringHelper :: strpos ( $ v , '->' ) ; } ) ; $ branchesName = array_map ( 'trim' , $ branchesName ) ; $ references = $ this -> repository -> getReferences ( ) ; $ branches = array ( ) ; foreach ( $ branchesName as $ branchName ) { if ( false === $ local ) { $ branches [ ] = $ references -> getRemoteBranch ( $ branchName ) ; } elseif ( 0 === StringHelper :: strrpos ( $ branchName , 'remotes/' ) ) { $ branches [ ] = $ references -> getRemoteBranch ( str_replace ( 'remotes/' , '' , $ branchName ) ) ; } else { $ branches [ ] = $ references -> getBranch ( $ branchName ) ; } } return $ branches ; } 
public static function init ( $ path , $ bare = true , array $ options = array ( ) ) { $ process = static :: getProcess ( 'init' , array_merge ( array ( '-q' ) , $ bare ? array ( '--bare' ) : array ( ) , array ( $ path ) ) , $ options ) ; $ process -> run ( ) ; if ( ! $ process -> isSuccessFul ( ) ) { throw new RuntimeException ( sprintf ( "Error on repository initialization, command wasn't successful (%s). Error output:\n%s" , $ process -> getCommandLine ( ) , $ process -> getErrorOutput ( ) ) ) ; } return new Repository ( $ path , $ options ) ; } 
public static function isValidRepository ( $ url , array $ options = array ( ) ) { $ process = static :: getProcess ( 'ls-remote' , array ( $ url ) , $ options ) ; $ process -> run ( ) ; return $ process -> isSuccessFul ( ) ; } 
public static function cloneTo ( $ path , $ url , $ bare = true , array $ options = array ( ) ) { $ args = $ bare ? array ( '--bare' ) : array ( ) ; return static :: cloneRepository ( $ path , $ url , $ args , $ options ) ; } 
public static function cloneBranchTo ( $ path , $ url , $ branch , $ bare = true , $ options = array ( ) ) { $ args = array ( '--branch' , $ branch ) ; if ( $ bare ) { $ args [ ] = '--bare' ; } return static :: cloneRepository ( $ path , $ url , $ args , $ options ) ; } 
public static function cloneRepository ( $ path , $ url , array $ args = array ( ) , array $ options = array ( ) ) { $ process = static :: getProcess ( 'clone' , array_merge ( array ( '-q' ) , $ args , array ( $ url , $ path ) ) , $ options ) ; $ process -> run ( ) ; if ( ! $ process -> isSuccessFul ( ) ) { throw new RuntimeException ( sprintf ( 'Error while initializing repository: %s' , $ process -> getErrorOutput ( ) ) ) ; } return new Repository ( $ path , $ options ) ; } 
private static function getProcess ( $ command , array $ args = array ( ) , array $ options = array ( ) ) { $ is_windows = defined ( 'PHP_WINDOWS_VERSION_BUILD' ) ; $ options = array_merge ( array ( 'environment_variables' => $ is_windows ? array ( 'PATH' => getenv ( 'PATH' ) ) : array ( ) , 'command' => 'git' , 'process_timeout' => 3600 , ) , $ options ) ; $ commandline = array_merge ( array ( $ options [ 'command' ] , $ command ) , $ args ) ; 
public function getGroupedLines ( ) { $ result = array ( ) ; $ commit = null ; $ current = array ( ) ; foreach ( $ this -> getLines ( ) as $ lineNumber => $ line ) { if ( $ commit !== $ line -> getCommit ( ) ) { if ( count ( $ current ) ) { $ result [ ] = array ( $ commit , $ current ) ; } $ commit = $ line -> getCommit ( ) ; $ current = array ( ) ; } $ current [ $ lineNumber ] = $ line ; } if ( count ( $ current ) ) { $ result [ ] = array ( $ commit , $ current ) ; } return $ result ; } 
public function getLines ( ) { if ( null !== $ this -> lines ) { return $ this -> lines ; } $ args = array ( '-p' ) ; if ( null !== $ this -> lineRange ) { $ args [ ] = '-L' ; $ args [ ] = $ this -> lineRange ; } $ args [ ] = $ this -> revision -> getRevision ( ) ; $ args [ ] = '--' ; $ args [ ] = $ this -> file ; $ parser = new BlameParser ( $ this -> repository ) ; $ parser -> parse ( $ this -> repository -> run ( 'blame' , $ args ) ) ; $ this -> lines = $ parser -> lines ; return $ this -> lines ; } 
public function get ( $ fullname ) { $ this -> initialize ( ) ; if ( ! isset ( $ this -> references [ $ fullname ] ) ) { throw new ReferenceNotFoundException ( $ fullname ) ; } return $ this -> references [ $ fullname ] ; } 
public function getBranches ( ) { $ this -> initialize ( ) ; $ result = array ( ) ; foreach ( $ this -> references as $ reference ) { if ( $ reference instanceof Reference \ Branch ) { $ result [ ] = $ reference ; } } return $ result ; } 
public function getLocalBranches ( ) { $ result = array ( ) ; foreach ( $ this -> getBranches ( ) as $ branch ) { if ( $ branch -> isLocal ( ) ) { $ result [ ] = $ branch ; } } return $ result ; } 
public function getRemoteBranches ( ) { $ result = array ( ) ; foreach ( $ this -> getBranches ( ) as $ branch ) { if ( $ branch -> isRemote ( ) ) { $ result [ ] = $ branch ; } } return $ result ; } 
public function getContent ( ) { if ( null === $ this -> content ) { $ this -> content = $ this -> repository -> run ( 'cat-file' , array ( '-p' , $ this -> hash ) ) ; } return $ this -> content ; } 
public function getMimetype ( ) { if ( null === $ this -> mimetype ) { $ finfo = new \ finfo ( FILEINFO_MIME ) ; $ this -> mimetype = $ finfo -> buffer ( $ this -> getContent ( ) ) ; } return $ this -> mimetype ; } 
public function toArray ( ) { return array ( 'rawDiff' => $ this -> rawDiff , 'files' => array_map ( function ( File $ file ) { return $ file -> toArray ( ) ; } , $ this -> files ) , ) ; } 
public function parse ( $ text ) { $ text = str_replace ( array ( "\r\n" , "\r" ) , "\n" , $ text ) ; foreach ( $ this -> quoteHeadersRegex as $ regex ) { if ( preg_match ( $ regex , $ text , $ matches ) ) { $ text = str_replace ( $ matches [ 1 ] , str_replace ( "\n" , ' ' , $ matches [ 1 ] ) , $ text ) ; } } $ fragment = null ; $ text_array = explode ( "\n" , $ text ) ; while ( ( $ line = array_pop ( $ text_array ) ) !== NULL ) { $ line = ltrim ( $ line , "\n" ) ; if ( ! $ this -> isSignature ( $ line ) ) { $ line = rtrim ( $ line ) ; } if ( $ fragment ) { $ first = reset ( $ fragment -> lines ) ; if ( $ this -> isSignature ( $ first ) ) { $ fragment -> isSignature = true ; $ this -> addFragment ( $ fragment ) ; $ fragment = null ; } elseif ( empty ( $ line ) && $ this -> isQuoteHeader ( $ first ) ) { $ fragment -> isQuoted = true ; $ this -> addFragment ( $ fragment ) ; $ fragment = null ; } } $ isQuoted = $ this -> isQuote ( $ line ) ; if ( null === $ fragment || ! $ this -> isFragmentLine ( $ fragment , $ line , $ isQuoted ) ) { if ( $ fragment ) { $ this -> addFragment ( $ fragment ) ; } $ fragment = new FragmentDTO ( ) ; $ fragment -> isQuoted = $ isQuoted ; } array_unshift ( $ fragment -> lines , $ line ) ; } if ( $ fragment ) { $ this -> addFragment ( $ fragment ) ; } $ email = $ this -> createEmail ( $ this -> fragments ) ; $ this -> fragments = array ( ) ; return $ email ; } 
protected function createEmail ( array $ fragmentDTOs ) { $ fragments = array ( ) ; foreach ( $ fragmentDTOs as $ fragment ) { $ fragments [ ] = new Fragment ( preg_replace ( "/^\n/" , '' , implode ( "\n" , $ fragment -> lines ) ) , $ fragment -> isHidden , $ fragment -> isSignature , $ fragment -> isQuoted ) ; } return new Email ( $ fragments ) ; } 
public function orderBy ( $ column , $ direction = OrderBy :: ASC , $ table = null ) { return $ this -> select -> orderBy ( $ column , $ direction , $ table ) ; } 
public function setFunctionAsColumn ( $ funcName , array $ arguments , $ alias ) { $ this -> columnFuncs [ $ alias ] = [ 'func' => $ funcName , 'args' => $ arguments ] ; return $ this ; } 
public function count ( $ columnName = '*' , $ alias = '' ) { $ table = $ this -> select -> getTable ( ) ; $ count = 'COUNT(' ; $ count .= ( $ columnName !== '*' ) ? "$table.{$columnName}" : '*' ; $ count .= ')' ; if ( isset ( $ alias ) && \ strlen ( $ alias ) > 0 ) { $ count .= ' AS "' . $ alias . '"' ; } $ this -> columns = array ( $ count ) ; $ this -> isCount = true ; return $ this ; } 
public function getColumns ( ) { if ( \ is_null ( $ this -> select -> getTable ( ) ) ) { throw new QueryException ( 'No table specified for the Select instance' ) ; } return SyntaxFactory :: createColumns ( $ this -> columns , $ this -> select -> getTable ( ) ) ; } 
public function write ( Minus $ minus ) { $ first = $ this -> writer -> write ( $ minus -> getFirst ( ) ) ; $ second = $ this -> writer -> write ( $ minus -> getSecond ( ) ) ; return $ first . "\n" . Minus :: MINUS . "\n" . $ second ; } 
public function selectToColumn ( $ alias , Select $ select ) { $ selectAsColumn = $ this -> write ( $ select ) ; if ( ! empty ( $ selectAsColumn ) ) { $ selectAsColumn = '(' . $ selectAsColumn . ')' ; } $ column = array ( $ alias => $ selectAsColumn ) ; return SyntaxFactory :: createColumn ( $ column , null ) ; } 
public function write ( Select $ select ) { if ( $ select -> isJoinSelect ( ) ) { return $ this -> writer -> writeJoin ( $ select ) ; } return $ this -> writeSelectQuery ( $ select ) ; } 
protected function writeSelectQuery ( Select $ select ) { $ parts = [ 'SELECT' ] ; if ( $ select -> isDistinct ( ) ) { $ parts [ ] = 'DISTINCT' ; } $ this -> writeSelectColumns ( $ select , $ parts ) ; $ this -> writeSelectFrom ( $ select , $ parts ) ; $ this -> writeSelectJoins ( $ select , $ parts ) ; $ this -> writeSelectWhere ( $ select , $ parts ) ; $ this -> writeSelectGroupBy ( $ select , $ parts ) ; $ this -> writeSelectHaving ( $ select , $ parts ) ; $ this -> writeSelectOrderBy ( $ select , $ parts ) ; $ this -> writeSelectLimit ( $ select , $ parts ) ; return AbstractBaseWriter :: writeQueryComment ( $ select ) . implode ( ' ' , \ array_filter ( $ parts ) ) ; } 
public function writeSelectColumns ( Select $ select , array & $ parts ) { if ( $ select -> isCount ( ) === false ) { $ columns = $ this -> writeColumnAlias ( $ select -> getAllColumns ( ) , $ this -> columnWriter -> writeSelectsAsColumns ( $ select ) , $ this -> columnWriter -> writeValueAsColumns ( $ select ) , $ this -> columnWriter -> writeFuncAsColumns ( $ select ) ) ; $ parts = \ array_merge ( $ parts , [ implode ( ', ' , $ columns ) ] ) ; return $ this ; } $ columns = $ select -> getColumns ( ) ; $ column = \ array_pop ( $ columns ) ; $ columnList = $ column -> getName ( ) ; $ parts = \ array_merge ( $ parts , [ $ columnList ] ) ; return $ this ; } 
protected function writeColumnAlias ( $ tableColumns , $ selectAsColumns , $ valueAsColumns , $ funcAsColumns ) { $ columns = \ array_merge ( $ tableColumns , $ selectAsColumns , $ valueAsColumns , $ funcAsColumns ) ; \ array_walk ( $ columns , function ( & $ column ) { $ column = $ this -> columnWriter -> writeColumnWithAlias ( $ column ) ; } ) ; return $ columns ; } 
public function writeSelectFrom ( Select $ select , array & $ parts ) { $ parts = \ array_merge ( $ parts , [ 'FROM ' . $ this -> writer -> writeTableWithAlias ( $ select -> getTable ( ) ) ] ) ; return $ this ; } 
public function writeSelectJoins ( Select $ select , array & $ parts ) { $ parts = \ array_merge ( $ parts , [ $ this -> writeSelectAggrupation ( $ select , $ this -> writer , 'getAllJoins' , 'writeJoin' , ' ' ) ] ) ; return $ this ; } 
protected function writeSelectAggrupation ( Select $ select , $ writer , $ getMethod , $ writeMethod , $ glue , $ prepend = '' ) { $ str = '' ; $ joins = $ select -> $ getMethod ( ) ; if ( ! empty ( $ joins ) ) { \ array_walk ( $ joins , function ( & $ join ) use ( $ writer , $ writeMethod ) { $ join = $ writer -> $ writeMethod ( $ join ) ; } ) ; $ str = $ prepend . implode ( $ glue , $ joins ) ; } return $ str ; } 
public function writeSelectWhere ( Select $ select , array & $ parts ) { $ str = '' ; $ wheres = $ this -> writeSelectWheres ( $ select -> getAllWheres ( ) ) ; $ wheres = \ array_filter ( $ wheres ) ; if ( \ count ( $ wheres ) > 0 ) { $ str = 'WHERE ' ; $ separator = ' ' . $ this -> writer -> writeConjunction ( $ select -> getWhereOperator ( ) ) . ' ' ; $ str .= \ implode ( $ separator , $ wheres ) ; } $ parts = \ array_merge ( $ parts , [ $ str ] ) ; return $ this ; } 
protected function writeSelectWheres ( array $ wheres ) { $ whereWriter = WriterFactory :: createWhereWriter ( $ this -> writer , $ this -> placeholderWriter ) ; \ array_walk ( $ wheres , function ( & $ where ) use ( & $ whereWriter ) { $ where = $ whereWriter -> writeWhere ( $ where ) ; } ) ; return $ wheres ; } 
public function writeSelectGroupBy ( Select $ select , array & $ parts ) { $ groupBy = $ this -> writeSelectAggrupation ( $ select , $ this -> columnWriter , 'getGroupBy' , 'writeColumn' , ', ' , 'GROUP BY ' ) ; $ parts = \ array_merge ( $ parts , [ $ groupBy ] ) ; return $ this ; } 
public function writeSelectHaving ( Select $ select , array & $ parts ) { $ str = '' ; $ havingArray = $ select -> getAllHavings ( ) ; if ( \ count ( $ havingArray ) > 0 ) { $ placeholder = $ this -> placeholderWriter ; $ writer = $ this -> writer ; $ str = 'HAVING ' ; $ separator = ' ' . $ select -> getHavingOperator ( ) . ' ' ; $ havingArray = $ this -> getHavingConditions ( $ havingArray , $ select , $ writer , $ placeholder ) ; $ str .= \ implode ( $ separator , $ havingArray ) ; } $ parts = \ array_merge ( $ parts , [ $ str ] ) ; return $ this ; } 
protected function getHavingConditions ( array & $ havingArray , Select $ select , GenericBuilder $ writer , PlaceholderWriter $ placeholder ) { \ array_walk ( $ havingArray , function ( & $ having ) use ( $ select , $ writer , $ placeholder ) { $ whereWriter = WriterFactory :: createWhereWriter ( $ writer , $ placeholder ) ; $ clauses = $ whereWriter -> writeWhereClauses ( $ having ) ; $ having = \ implode ( $ this -> writer -> writeConjunction ( $ select -> getHavingOperator ( ) ) , $ clauses ) ; } ) ; return $ havingArray ; } 
protected function writeSelectOrderBy ( Select $ select , array & $ parts ) { $ str = '' ; if ( \ count ( $ select -> getAllOrderBy ( ) ) ) { $ orderByArray = $ select -> getAllOrderBy ( ) ; \ array_walk ( $ orderByArray , function ( & $ orderBy ) { $ orderBy = $ this -> writeOrderBy ( $ orderBy ) ; } ) ; $ str = 'ORDER BY ' ; $ str .= \ implode ( ', ' , $ orderByArray ) ; } $ parts = \ array_merge ( $ parts , [ $ str ] ) ; return $ this ; } 
public function writeOrderBy ( OrderBy $ orderBy ) { $ column = $ this -> columnWriter -> writeColumn ( $ orderBy -> getColumn ( ) ) ; return $ column . ' ' . $ orderBy -> getDirection ( ) ; } 
protected function writeSelectLimit ( Select $ select , array & $ parts ) { $ mask = $ this -> getStartingLimit ( $ select ) . $ this -> getLimitCount ( $ select ) ; $ limit = '' ; if ( $ mask !== '00' ) { $ start = $ this -> placeholderWriter -> add ( $ select -> getLimitStart ( ) ) ; $ count = $ this -> placeholderWriter -> add ( $ select -> getLimitCount ( ) ) ; $ limit = "LIMIT {$start}, {$count}" ; } $ parts = \ array_merge ( $ parts , [ $ limit ] ) ; return $ this ; } 
public function write ( Insert $ insert ) { $ columns = $ insert -> getColumns ( ) ; if ( empty ( $ columns ) ) { throw new QueryException ( 'No columns were defined for the current schema.' ) ; } $ columns = $ this -> writeQueryColumns ( $ columns ) ; $ values = $ this -> writeQueryValues ( $ insert -> getValues ( ) ) ; $ table = $ this -> writer -> writeTable ( $ insert -> getTable ( ) ) ; $ comment = AbstractBaseWriter :: writeQueryComment ( $ insert ) ; return $ comment . "INSERT INTO {$table} ($columns) VALUES ($values)" ; } 
protected function writeCommaSeparatedValues ( $ collection , $ writer , $ method ) { \ array_walk ( $ collection , function ( & $ data ) use ( $ writer , $ method ) { $ data = $ writer -> $ method ( $ data ) ; } ) ; return \ implode ( ', ' , $ collection ) ; } 
public function writeColumnName ( Column $ column ) { if ( $ column -> isAll ( ) ) { return '*' ; } if ( false !== strpos ( $ column -> getName ( ) , '(' ) ) { return parent :: writeColumnName ( $ column ) ; } return $ this -> wrapper ( parent :: writeColumnName ( $ column ) ) ; } 
public function conjunction ( $ operator ) { if ( false === \ in_array ( $ operator , [ self :: CONJUNCTION_AND , self :: CONJUNCTION_OR , self :: CONJUNCTION_OR_NOT , self :: CONJUNCTION_AND_NOT ] ) ) { throw new QueryException ( "Invalid conjunction specified, must be one of AND or OR, but '" . $ operator . "' was found." ) ; } $ this -> conjunction = $ operator ; return $ this ; } 
public function subWhere ( $ operator = 'OR' ) { $ filter = QueryFactory :: createWhere ( $ this -> query ) ; $ filter -> conjunction ( $ operator ) ; $ filter -> setTable ( $ this -> getTable ( ) ) ; $ this -> subWheres [ ] = $ filter ; return $ filter ; } 
protected function compare ( $ column , $ value , $ operator ) { $ column = $ this -> prepareColumn ( $ column ) ; $ this -> comparisons [ ] = [ 'subject' => $ column , 'conjunction' => $ operator , 'target' => $ value , ] ; return $ this ; } 
protected function prepareColumn ( $ column ) { 
protected function genericMatch ( array & $ columns , array & $ values , $ mode ) { $ this -> match [ ] = [ 'columns' => $ columns , 'values' => $ values , 'mode' => $ mode , ] ; return $ this ; } 
public function between ( $ column , $ a , $ b ) { $ column = $ this -> prepareColumn ( $ column ) ; $ this -> betweens [ ] = [ 'subject' => $ column , 'a' => $ a , 'b' => $ b ] ; return $ this ; } 
public function notBetween ( $ column , $ a , $ b ) { $ column = $ this -> prepareColumn ( $ column ) ; $ this -> notBetweens [ ] = [ 'subject' => $ column , 'a' => $ a , 'b' => $ b ] ; return $ this ; } 
public function isNull ( $ column ) { $ column = $ this -> prepareColumn ( $ column ) ; $ this -> isNull [ ] = [ 'subject' => $ column ] ; return $ this ; } 
public function isNotNull ( $ column ) { $ column = $ this -> prepareColumn ( $ column ) ; $ this -> isNotNull [ ] = [ 'subject' => $ column ] ; return $ this ; } 
public function addBitClause ( $ column , $ value ) { $ column = $ this -> prepareColumn ( $ column ) ; $ this -> booleans [ ] = [ 'subject' => $ column , 'value' => $ value ] ; return $ this ; } 
public function write ( Update $ update ) { $ values = $ update -> getValues ( ) ; if ( empty ( $ values ) ) { throw new QueryException ( 'No values to update in Update query.' ) ; } $ parts = array ( 'UPDATE ' . $ this -> writer -> writeTable ( $ update -> getTable ( ) ) . ' SET ' , $ this -> writeUpdateValues ( $ update ) , ) ; AbstractBaseWriter :: writeWhereCondition ( $ update , $ this -> writer , $ this -> placeholderWriter , $ parts ) ; AbstractBaseWriter :: writeLimitCondition ( $ update , $ this -> placeholderWriter , $ parts ) ; $ comment = AbstractBaseWriter :: writeQueryComment ( $ update ) ; return $ comment . implode ( ' ' , $ parts ) ; } 
protected function writeUpdateValues ( Update $ update ) { $ assigns = [ ] ; foreach ( $ update -> getValues ( ) as $ column => $ value ) { $ newColumn = array ( $ column ) ; $ column = $ this -> columnWriter -> writeColumn ( SyntaxFactory :: createColumn ( $ newColumn , $ update -> getTable ( ) ) ) ; $ value = $ this -> writer -> writePlaceholderValue ( $ value ) ; $ assigns [ ] = "$column = $value" ; } return \ implode ( ', ' , $ assigns ) ; } 
public function writeWhere ( Where $ where ) { $ clauses = $ this -> writeWhereClauses ( $ where ) ; $ clauses = \ array_filter ( $ clauses ) ; if ( empty ( $ clauses ) ) { return '' ; } return \ implode ( $ this -> writer -> writeConjunction ( $ where -> getConjunction ( ) ) , $ clauses ) ; } 
public function writeWhereClauses ( Where $ where ) { $ whereArray = [ ] ; $ this -> writeWhereMatches ( $ where , $ whereArray ) ; $ this -> writeWhereIns ( $ where , $ whereArray ) ; $ this -> writeWhereNotIns ( $ where , $ whereArray ) ; $ this -> writeWhereBetweens ( $ where , $ whereArray ) ; $ this -> writeWhereNotBetweens ( $ where , $ whereArray ) ; $ this -> writeWhereComparisons ( $ where , $ whereArray ) ; $ this -> writeWhereIsNulls ( $ where , $ whereArray ) ; $ this -> writeWhereIsNotNulls ( $ where , $ whereArray ) ; $ this -> writeWhereBooleans ( $ where , $ whereArray ) ; $ this -> writeExists ( $ where , $ whereArray ) ; $ this -> writeNotExists ( $ where , $ whereArray ) ; $ this -> writeSubWheres ( $ where , $ whereArray ) ; return $ whereArray ; } 
protected function writeWhereMatches ( Where $ where , array & $ whereArray ) { $ matches = [ ] ; foreach ( $ where -> getMatches ( ) as $ values ) { $ columns = SyntaxFactory :: createColumns ( $ values [ 'columns' ] , $ where -> getTable ( ) ) ; $ columnNames = $ this -> getColumnNames ( $ columns ) ; $ columnValues = array ( \ implode ( ' ' , $ values [ 'values' ] ) ) ; $ columnValues = \ implode ( ', ' , $ this -> writer -> writeValues ( $ columnValues ) ) ; $ matches [ ] = \ str_replace ( [ '{{columnNames}}' , '{{columnValues}}' ] , [ $ columnNames , $ columnValues ] , $ this -> matchMode [ $ values [ 'mode' ] ] ) ; } $ whereArray = \ array_merge ( $ whereArray , $ matches ) ; } 
protected function getColumnNames ( $ columns ) { $ columnNames = [ ] ; foreach ( $ columns as & $ column ) { $ columnNames [ ] = $ this -> columnWriter -> writeColumn ( $ column ) ; } return \ implode ( ', ' , $ columnNames ) ; } 
protected function writeWhereIns ( Where $ where , array & $ whereArray ) { $ whereArray = \ array_merge ( $ whereArray , $ this -> writeWhereIn ( $ where , 'getIns' , 'IN' ) ) ; } 
protected function writeWhereIn ( Where $ where , $ method , $ operation ) { $ collection = [ ] ; foreach ( $ where -> $ method ( ) as $ column => $ values ) { $ newColumn = array ( $ column ) ; $ column = SyntaxFactory :: createColumn ( $ newColumn , $ where -> getTable ( ) ) ; $ column = $ this -> columnWriter -> writeColumn ( $ column ) ; $ values = $ this -> writer -> writeValues ( $ values ) ; $ values = \ implode ( ', ' , $ values ) ; $ collection [ ] = "({$column} $operation ({$values}))" ; } return $ collection ; } 
protected function writeWhereNotIns ( Where $ where , array & $ whereArray ) { $ whereArray = \ array_merge ( $ whereArray , $ this -> writeWhereIn ( $ where , 'getNotIns' , 'NOT IN' ) ) ; } 
protected function writeWhereBetweens ( Where $ where , array & $ whereArray ) { $ between = $ where -> getBetweens ( ) ; \ array_walk ( $ between , function ( & $ between ) { $ between = '(' . $ this -> columnWriter -> writeColumn ( $ between [ 'subject' ] ) . ' BETWEEN ' . $ this -> writer -> writePlaceholderValue ( $ between [ 'a' ] ) . ' AND ' . $ this -> writer -> writePlaceholderValue ( $ between [ 'b' ] ) . ')' ; } ) ; $ whereArray = \ array_merge ( $ whereArray , $ between ) ; } 
protected function writeWhereNotBetweens ( Where $ where , array & $ whereArray ) { $ between = $ where -> getNotBetweens ( ) ; \ array_walk ( $ between , function ( & $ between ) { $ between = '(' . $ this -> columnWriter -> writeColumn ( $ between [ 'subject' ] ) . ' NOT BETWEEN ' . $ this -> writer -> writePlaceholderValue ( $ between [ 'a' ] ) . ' AND ' . $ this -> writer -> writePlaceholderValue ( $ between [ 'b' ] ) . ')' ; } ) ; $ whereArray = \ array_merge ( $ whereArray , $ between ) ; } 
protected function writeWhereComparisons ( Where $ where , array & $ whereArray ) { $ comparisons = $ where -> getComparisons ( ) ; \ array_walk ( $ comparisons , function ( & $ comparison ) { if ( ! is_array ( $ comparison ) ) { return ; } $ str = $ this -> writeWherePartialCondition ( $ comparison [ 'subject' ] ) ; $ str .= $ this -> writer -> writeConjunction ( $ comparison [ 'conjunction' ] ) ; $ str .= $ this -> writeWherePartialCondition ( $ comparison [ 'target' ] ) ; $ comparison = "($str)" ; } ) ; $ whereArray = \ array_merge ( $ whereArray , $ comparisons ) ; } 
protected function writeWherePartialCondition ( & $ subject ) { if ( $ subject instanceof Column ) { $ str = $ this -> columnWriter -> writeColumn ( $ subject ) ; } elseif ( $ subject instanceof Select ) { $ selectWriter = WriterFactory :: createSelectWriter ( $ this -> writer , $ this -> placeholderWriter ) ; $ str = '(' . $ selectWriter -> write ( $ subject ) . ')' ; } else { $ str = $ this -> writer -> writePlaceholderValue ( $ subject ) ; } return $ str ; } 
protected function writeWhereIsNulls ( Where $ where , array & $ whereArray ) { $ whereArray = \ array_merge ( $ whereArray , $ this -> writeWhereIsNullable ( $ where , 'getNull' , 'writeIsNull' ) ) ; } 
protected function writeWhereIsNullable ( Where $ where , $ getMethod , $ writeMethod ) { $ collection = $ where -> $ getMethod ( ) ; \ array_walk ( $ collection , function ( & $ collection ) use ( $ writeMethod ) { $ collection = '(' . $ this -> columnWriter -> writeColumn ( $ collection [ 'subject' ] ) . $ this -> writer -> $ writeMethod ( ) . ')' ; } ) ; return $ collection ; } 
protected function writeWhereIsNotNulls ( Where $ where , array & $ whereArray ) { $ whereArray = \ array_merge ( $ whereArray , $ this -> writeWhereIsNullable ( $ where , 'getNotNull' , 'writeIsNotNull' ) ) ; } 
protected function writeWhereBooleans ( Where $ where , array & $ whereArray ) { $ booleans = $ where -> getBooleans ( ) ; $ placeholderWriter = $ this -> placeholderWriter ; \ array_walk ( $ booleans , function ( & $ boolean ) use ( & $ placeholderWriter ) { $ column = $ this -> columnWriter -> writeColumn ( $ boolean [ 'subject' ] ) ; $ value = $ this -> placeholderWriter -> add ( $ boolean [ 'value' ] ) ; $ boolean = '(ISNULL(' . $ column . ', 0) = ' . $ value . ')' ; } ) ; $ whereArray = \ array_merge ( $ whereArray , $ booleans ) ; } 
protected function writeExists ( Where $ where , array & $ whereArray ) { $ whereArray = \ array_merge ( $ whereArray , $ this -> writeExistence ( $ where , 'getExists' , 'EXISTS' ) ) ; } 
protected function writeExistence ( Where $ where , $ method , $ operation ) { $ exists = [ ] ; foreach ( $ where -> $ method ( ) as $ select ) { $ exists [ ] = "$operation (" . $ this -> writer -> write ( $ select , false ) . ')' ; } return $ exists ; } 
protected function writeNotExists ( Where $ where , array & $ whereArray ) { $ whereArray = \ array_merge ( $ whereArray , $ this -> writeExistence ( $ where , 'getNotExists' , 'NOT EXISTS' ) ) ; } 
protected function writeSubWheres ( Where $ where , array & $ whereArray ) { $ subWheres = $ where -> getSubWheres ( ) ; \ array_walk ( $ subWheres , function ( & $ subWhere ) { $ subWhere = "({$this->writeWhere($subWhere)})" ; } ) ; $ whereArray = \ array_merge ( $ whereArray , $ subWheres ) ; } 
public function leftJoin ( $ table , $ selfColumn = null , $ refColumn = null , $ columns = [ ] ) { return $ this -> joinQuery -> leftJoin ( $ table , $ selfColumn , $ refColumn , $ columns ) ; } 
public function join ( $ table , $ selfColumn = null , $ refColumn = null , $ columns = [ ] , $ joinType = null ) { return $ this -> joinQuery -> join ( $ table , $ selfColumn , $ refColumn , $ columns , $ joinType ) ; } 
public function addJoin ( Select $ select , $ selfColumn , $ refColumn ) { return $ this -> joinQuery -> addJoin ( $ select , $ selfColumn , $ refColumn ) ; } 
public function rightJoin ( $ table , $ selfColumn = null , $ refColumn = null , $ columns = [ ] ) { return $ this -> joinQuery -> rightJoin ( $ table , $ selfColumn , $ refColumn , $ columns ) ; } 
public function crossJoin ( $ table , $ selfColumn = null , $ refColumn = null , $ columns = [ ] ) { return $ this -> joinQuery -> crossJoin ( $ table , $ selfColumn , $ refColumn , $ columns ) ; } 
public function innerJoin ( $ table , $ selfColumn = null , $ refColumn = null , $ columns = [ ] ) { return $ this -> joinQuery -> innerJoin ( $ table , $ selfColumn , $ refColumn , $ columns ) ; } 
public function setFunctionAsColumn ( $ funcName , array $ arguments , $ alias ) { return $ this -> columnQuery -> setFunctionAsColumn ( $ funcName , $ arguments , $ alias ) ; } 
protected function getAllOperation ( $ data , $ operation ) { $ collection = [ ] ; if ( ! is_null ( $ data ) ) { $ collection [ ] = $ data ; } foreach ( $ this -> joinQuery -> getJoins ( ) as $ join ) { $ collection = \ array_merge ( $ collection , $ join -> $ operation ( ) ) ; } return $ collection ; } 
public function limit ( $ start , $ count = 0 ) { $ this -> limitStart = $ start ; $ this -> limitCount = $ count ; return $ this ; } 
public function having ( $ havingOperator = 'AND' ) { if ( ! isset ( $ this -> having ) ) { $ this -> having = QueryFactory :: createWhere ( $ this ) ; } if ( ! in_array ( $ havingOperator , array ( Where :: CONJUNCTION_AND , Where :: CONJUNCTION_OR ) ) ) { throw new QueryException ( "Invalid conjunction specified, must be one of AND or OR, but '" . $ havingOperator . "' was found." ) ; } $ this -> havingOperator = $ havingOperator ; return $ this -> having ; } 
public function orderBy ( $ column , $ direction = OrderBy :: ASC , $ table = null ) { $ current = parent :: orderBy ( $ column , $ direction , $ table ) ; if ( $ this -> getParentQuery ( ) != null ) { $ this -> getParentQuery ( ) -> orderBy ( $ column , $ direction , \ is_null ( $ table ) ? $ this -> getTable ( ) : $ table ) ; } return $ current ; } 
public function writeSelectsAsColumns ( Select $ select ) { $ selectAsColumns = $ select -> getColumnSelects ( ) ; if ( ! empty ( $ selectAsColumns ) ) { $ selectWriter = WriterFactory :: createSelectWriter ( $ this -> writer , $ this -> placeholderWriter ) ; $ selectAsColumns = $ this -> selectColumnToQuery ( $ selectAsColumns , $ selectWriter ) ; } return $ selectAsColumns ; } 
protected function selectColumnToQuery ( array & $ selectAsColumns , SelectWriter $ selectWriter ) { \ array_walk ( $ selectAsColumns , function ( & $ column ) use ( & $ selectWriter ) { $ keys = \ array_keys ( $ column ) ; $ key = \ array_pop ( $ keys ) ; $ values = \ array_values ( $ column ) ; $ value = $ values [ 0 ] ; if ( \ is_numeric ( $ key ) ) { $ key = $ this -> writer -> writeTableName ( $ value -> getTable ( ) ) ; } $ column = $ selectWriter -> selectToColumn ( $ key , $ value ) ; } ) ; return $ selectAsColumns ; } 
public function writeValueAsColumns ( Select $ select ) { $ valueAsColumns = $ select -> getColumnValues ( ) ; $ newColumns = [ ] ; if ( ! empty ( $ valueAsColumns ) ) { foreach ( $ valueAsColumns as $ alias => $ value ) { $ value = $ this -> writer -> writePlaceholderValue ( $ value ) ; $ newValueColumn = array ( $ alias => $ value ) ; $ newColumns [ ] = SyntaxFactory :: createColumn ( $ newValueColumn , null ) ; } } return $ newColumns ; } 
public function writeFuncAsColumns ( Select $ select ) { $ funcAsColumns = $ select -> getColumnFuncs ( ) ; $ newColumns = [ ] ; if ( ! empty ( $ funcAsColumns ) ) { foreach ( $ funcAsColumns as $ alias => $ value ) { $ funcName = $ value [ 'func' ] ; $ funcArgs = ( ! empty ( $ value [ 'args' ] ) ) ? '(' . implode ( ', ' , $ value [ 'args' ] ) . ')' : '' ; $ newFuncColumn = array ( $ alias => $ funcName . $ funcArgs ) ; $ newColumns [ ] = SyntaxFactory :: createColumn ( $ newFuncColumn , null ) ; } } return $ newColumns ; } 
public function writeColumnWithAlias ( Column $ column ) { if ( ( $ alias = $ column -> getAlias ( ) ) && ! $ column -> isAll ( ) ) { return $ this -> writeColumn ( $ column ) . ' AS ' . $ this -> writer -> writeColumnAlias ( $ alias ) ; } return $ this -> writeColumn ( $ column ) ; } 
public function writeColumn ( Column $ column ) { $ alias = $ column -> getTable ( ) -> getAlias ( ) ; $ table = ( $ alias ) ? $ this -> writer -> writeTableAlias ( $ alias ) : $ this -> writer -> writeTable ( $ column -> getTable ( ) ) ; $ columnString = ( empty ( $ table ) ) ? '' : "{$table}." ; $ columnString .= $ this -> writer -> writeColumnName ( $ column ) ; return $ columnString ; } 
public function write ( Delete $ delete ) { $ table = $ this -> writer -> writeTable ( $ delete -> getTable ( ) ) ; $ parts = array ( "DELETE FROM {$table}" ) ; AbstractBaseWriter :: writeWhereCondition ( $ delete , $ this -> writer , $ this -> placeholderWriter , $ parts ) ; AbstractBaseWriter :: writeLimitCondition ( $ delete , $ this -> placeholderWriter , $ parts ) ; $ comment = AbstractBaseWriter :: writeQueryComment ( $ delete ) ; return $ comment . implode ( ' ' , $ parts ) ; } 
public function select ( $ table = null , array $ columns = null ) { return $ this -> injectBuilder ( QueryFactory :: createSelect ( $ table , $ columns ) ) ; } 
public function insert ( $ table = null , array $ values = null ) { return $ this -> injectBuilder ( QueryFactory :: createInsert ( $ table , $ values ) ) ; } 
public function update ( $ table = null , array $ values = null ) { return $ this -> injectBuilder ( QueryFactory :: createUpdate ( $ table , $ values ) ) ; } 
public function writeFormatted ( QueryInterface $ query ) { if ( null === $ this -> sqlFormatter ) { $ this -> sqlFormatter = ( new \ ReflectionClass ( $ this -> sqlFormatterClass ) ) -> newInstance ( ) ; } return $ this -> sqlFormatter -> format ( $ this -> write ( $ query ) ) ; } 
public function write ( QueryInterface $ query , $ resetPlaceholders = true ) { if ( $ resetPlaceholders ) { $ this -> placeholderWriter -> reset ( ) ; } $ queryPart = $ query -> partName ( ) ; if ( false === empty ( $ this -> queryWriterArray [ $ queryPart ] ) ) { $ this -> createQueryObject ( $ queryPart ) ; return $ this -> queryWriterInstances [ $ queryPart ] -> write ( $ query ) ; } throw new \ RuntimeException ( 'Query builder part not defined.' ) ; } 
public function writeJoin ( Select $ select ) { if ( null === $ this -> whereWriter ) { $ this -> whereWriter = WriterFactory :: createWhereWriter ( $ this , $ this -> placeholderWriter ) ; } $ sql = ( $ select -> getJoinType ( ) ) ? "{$select->getJoinType()} " : '' ; $ sql .= 'JOIN ' ; $ sql .= $ this -> writeTableWithAlias ( $ select -> getTable ( ) ) ; $ sql .= ' ON ' ; $ sql .= $ this -> whereWriter -> writeWhere ( $ select -> getJoinCondition ( ) ) ; return $ sql ; } 
public function writeTableWithAlias ( Table $ table ) { $ alias = ( $ table -> getAlias ( ) ) ? " AS {$this->writeTableAlias($table->getAlias())}" : '' ; $ schema = ( $ table -> getSchema ( ) ) ? "{$table->getSchema()}." : '' ; return $ schema . $ this -> writeTableName ( $ table ) . $ alias ; } 
public function writeTable ( Table $ table ) { $ schema = ( $ table -> getSchema ( ) ) ? "{$table->getSchema()}." : '' ; return $ schema . $ this -> writeTableName ( $ table ) ; } 
public function writeValues ( array & $ values ) { \ array_walk ( $ values , function ( & $ value ) { $ value = $ this -> writePlaceholderValue ( $ value ) ; } ) ; return $ values ; } 
public function writeColumnName ( Column $ column ) { $ name = $ column -> getName ( ) ; if ( $ name === Column :: ALL ) { return $ this -> writeColumnAll ( ) ; } return $ name ; } 
public static function createColumns ( array & $ arguments , $ table = null ) { $ createdColumns = [ ] ; foreach ( $ arguments as $ index => $ column ) { if ( ! is_object ( $ column ) ) { $ newColumn = array ( $ column ) ; $ column = self :: createColumn ( $ newColumn , $ table ) ; if ( ! is_numeric ( $ index ) ) { $ column -> setAlias ( $ index ) ; } $ createdColumns [ ] = $ column ; } else if ( $ column instanceof Column ) { $ createdColumns [ ] = $ column ; } } return \ array_filter ( $ createdColumns ) ; } 
public static function createColumn ( array & $ argument , $ table = null ) { $ columnName = \ array_values ( $ argument ) ; $ columnName = $ columnName [ 0 ] ; $ columnAlias = \ array_keys ( $ argument ) ; $ columnAlias = $ columnAlias [ 0 ] ; if ( \ is_numeric ( $ columnAlias ) || \ strpos ( $ columnName , '*' ) !== false ) { $ columnAlias = null ; } return new Column ( $ columnName , ( string ) $ table , $ columnAlias ) ; } 
public static function createTable ( $ table ) { $ tableName = $ table ; if ( \ is_array ( $ table ) ) { $ tableName = \ current ( $ table ) ; $ tableAlias = \ key ( $ table ) ; } $ newTable = new Table ( $ tableName ) ; if ( isset ( $ tableAlias ) && ! is_numeric ( $ tableAlias ) ) { $ newTable -> setAlias ( $ tableAlias ) ; } return $ newTable ; } 
public function setValues ( array $ values ) { $ this -> values = \ array_filter ( $ values , function ( $ value ) { if ( is_int ( $ value ) ) { return true ; } return $ value ; } ) ; return $ this ; } 
public function getSql ( $ formatted = false ) { if ( $ formatted ) { return $ this -> getBuilder ( ) -> writeFormatted ( $ this ) ; } return $ this -> getBuilder ( ) -> write ( $ this ) ; } 
public function where ( $ whereOperator = 'AND' ) { if ( ! isset ( $ this -> where ) ) { $ this -> where = $ this -> filter ( ) ; } $ this -> where -> conjunction ( $ whereOperator ) ; return $ this -> where ; } 
public function orderBy ( $ column , $ direction = OrderBy :: ASC , $ table = null ) { $ newColumn = array ( $ column ) ; $ column = SyntaxFactory :: createColumn ( $ newColumn , \ is_null ( $ table ) ? $ this -> getTable ( ) : $ table ) ; $ this -> orderBy [ ] = new OrderBy ( $ column , $ direction ) ; return $ this ; } 
public function setComment ( $ comment ) { 
public function add ( $ value ) { $ placeholderKey = ':v' . $ this -> counter ; $ this -> placeholders [ $ placeholderKey ] = $ this -> setValidSqlValue ( $ value ) ; ++ $ this -> counter ; return $ placeholderKey ; } 
protected function setValidSqlValue ( $ value ) { $ value = $ this -> writeNullSqlString ( $ value ) ; $ value = $ this -> writeStringAsSqlString ( $ value ) ; $ value = $ this -> writeBooleanSqlString ( $ value ) ; return $ value ; } 
protected function writeNullSqlString ( $ value ) { if ( \ is_null ( $ value ) || ( \ is_string ( $ value ) && empty ( $ value ) ) ) { $ value = $ this -> writeNull ( ) ; } return $ value ; } 
protected function abstractWrite ( QueryPartInterface $ setClass , $ setOperation , $ glue ) { $ selects = [ ] ; foreach ( $ setClass -> $ setOperation ( ) as $ select ) { $ selects [ ] = $ this -> writer -> write ( $ select , false ) ; } return \ implode ( "\n" . $ glue . "\n" , $ selects ) ; } 
public function setTable ( $ table ) { $ newTable = array ( $ table ) ; $ this -> table = SyntaxFactory :: createTable ( $ newTable ) ; return $ this ; } 
public function setAlias ( $ alias ) { if ( 0 == \ strlen ( $ alias ) ) { $ this -> alias = null ; return $ this ; } if ( $ this -> isAll ( ) ) { throw new QueryException ( "Can't use alias because column name is ALL (*)" ) ; } $ this -> alias = ( string ) $ alias ; return $ this ; } 
public function join ( $ table , $ selfColumn = null , $ refColumn = null , $ columns = [ ] , $ joinType = null ) { if ( ! isset ( $ this -> joins [ $ table ] ) ) { $ select = QueryFactory :: createSelect ( $ table ) ; $ select -> setColumns ( $ columns ) ; $ select -> setJoinType ( $ joinType ) ; $ select -> setParentQuery ( $ this -> select ) ; $ this -> addJoin ( $ select , $ selfColumn , $ refColumn ) ; } return $ this -> joins [ $ table ] ; } 
public function addJoin ( Select $ select , $ selfColumn , $ refColumn ) { $ select -> isJoin ( true ) ; $ table = $ select -> getTable ( ) -> getName ( ) ; if ( ! isset ( $ this -> joins [ $ table ] ) ) { if ( ! $ selfColumn instanceof Column ) { $ newColumn = array ( $ selfColumn ) ; $ selfColumn = SyntaxFactory :: createColumn ( $ newColumn , $ this -> select -> getTable ( ) ) ; } $ select -> joinCondition ( ) -> equals ( $ refColumn , $ selfColumn ) ; $ this -> joins [ $ table ] = $ select ; } return $ this -> joins [ $ table ] ; } 
public function crossJoin ( $ table , $ selfColumn = null , $ refColumn = null , $ columns = [ ] ) { return $ this -> join ( $ table , $ selfColumn , $ refColumn , $ columns , self :: JOIN_CROSS ) ; } 
public function joinCondition ( ) { if ( ! isset ( $ this -> joinCondition ) ) { $ this -> joinCondition = QueryFactory :: createWhere ( $ this -> select ) ; } return $ this -> joinCondition ; } 
public function get ( $ columns = [ '*' ] ) { $ builder = $ this -> applyScopes ( ) ; $ closure = function ( ) use ( $ builder , $ columns ) { 
public function pluck ( $ column , $ key = null ) : Collection { $ builder = $ this -> toBase ( ) ; $ closure = function ( ) use ( $ builder , $ column , $ key ) { $ results = $ builder -> pluck ( $ column , $ key ) ; 
public static function bootCacheableEloquent ( ) : void { static :: updated ( function ( Model $ cachedModel ) { ! $ cachedModel -> isCacheClearEnabled ( ) || $ cachedModel :: forgetCache ( ) ; } ) ; static :: created ( function ( Model $ cachedModel ) { ! $ cachedModel -> isCacheClearEnabled ( ) || $ cachedModel :: forgetCache ( ) ; } ) ; static :: deleted ( function ( Model $ cachedModel ) { ! $ cachedModel -> isCacheClearEnabled ( ) || $ cachedModel :: forgetCache ( ) ; } ) ; } 
protected static function storeCacheKey ( string $ modelName , string $ cacheKey ) : void { $ keysFile = storage_path ( 'framework/cache/data/rinvex.cacheable.json' ) ; $ cacheKeys = static :: getCacheKeys ( $ keysFile ) ; if ( ! isset ( $ cacheKeys [ $ modelName ] ) || ! in_array ( $ cacheKey , $ cacheKeys [ $ modelName ] ) ) { $ cacheKeys [ $ modelName ] [ ] = $ cacheKey ; file_put_contents ( $ keysFile , json_encode ( $ cacheKeys ) ) ; } } 
protected static function getCacheKeys ( $ file ) : array { if ( ! file_exists ( $ file ) ) { $ dir = dirname ( $ file ) ; is_dir ( $ dir ) || mkdir ( $ dir ) ; file_put_contents ( $ file , null ) ; } return json_decode ( file_get_contents ( $ file ) , true ) ? : [ ] ; } 
protected static function flushCacheKeys ( string $ modelName ) : array { $ flushedKeys = [ ] ; $ keysFile = storage_path ( 'framework/cache/data/rinvex.cacheable.json' ) ; $ cacheKeys = static :: getCacheKeys ( $ keysFile ) ; if ( isset ( $ cacheKeys [ $ modelName ] ) ) { $ flushedKeys = $ cacheKeys [ $ modelName ] ; unset ( $ cacheKeys [ $ modelName ] ) ; file_put_contents ( $ keysFile , json_encode ( $ cacheKeys ) ) ; } return $ flushedKeys ; } 
public static function forgetCache ( ) { static :: fireCacheFlushEvent ( 'cache.flushing' ) ; 
protected static function fireCacheFlushEvent ( $ event , $ halt = true ) { if ( ! isset ( static :: $ dispatcher ) ) { return true ; } 
public function resetCacheConfig ( ) { ! $ this -> cacheDriver || $ this -> cacheDriver = null ; ! $ this -> cacheLifetime || $ this -> cacheLifetime = - 1 ; return $ this ; } 
protected function generateCacheKey ( $ builder , array $ columns ) : string { $ query = $ builder instanceof Builder ? $ builder -> getQuery ( ) : $ builder ; $ vars = [ 'aggregate' => $ query -> aggregate , 'columns' => $ query -> columns , 'distinct' => $ query -> distinct , 'from' => $ query -> from , 'joins' => $ query -> joins , 'wheres' => $ query -> wheres , 'groups' => $ query -> groups , 'havings' => $ query -> havings , 'orders' => $ query -> orders , 'limit' => $ query -> limit , 'offset' => $ query -> offset , 'unions' => $ query -> unions , 'unionLimit' => $ query -> unionLimit , 'unionOffset' => $ query -> unionOffset , 'unionOrders' => $ query -> unionOrders , 'lock' => $ query -> lock , ] ; return md5 ( json_encode ( [ $ vars , $ columns , static :: class , $ this -> getCacheDriver ( ) , $ this -> getCacheLifetime ( ) , $ builder instanceof Builder ? $ builder -> getEagerLoads ( ) : null , $ builder -> getBindings ( ) , $ builder -> toSql ( ) , ] ) ) ; } 
public function cacheQuery ( $ builder , array $ columns , Closure $ closure ) { $ modelName = $ this -> getMorphClass ( ) ; $ lifetime = $ this -> getCacheLifetime ( ) ; $ cacheKey = $ this -> generateCacheKey ( $ builder , $ columns ) ; 
public static function validate ( HppRequest $ hppRequest ) { self :: Initialise ( ) ; $ violations = self :: $ validator -> validate ( $ hppRequest ) ; if ( $ violations -> count ( ) > 0 ) { $ validationMessages = array ( ) ; foreach ( $ violations as $ violation ) { $ validationMessages [ ] = $ violation -> getMessage ( ) ; } $ message = "HppRequest failed validation with the following errors:" ; foreach ( $ validationMessages as $ validationMessage ) { $ message .= $ validationMessage . '.' ; } self :: $ logger -> info ( $ message ) ; throw new RealexValidationException ( "HppRequest failed validation" , $ validationMessages ) ; } } 
public static function validateResponse ( HppResponse $ hppResponse , $ secret ) { self :: Initialise ( ) ; if ( ! $ hppResponse -> isHashValid ( $ secret ) ) { self :: $ logger -> error ( "HppResponse contains an invalid security hash." ) ; throw new RealexValidationException ( "HppResponse contains an invalid security hash" , array ( "HppResponse contains an invalid security hash" ) ) ; } } 
public function validate ( $ hppRequest , Constraint $ constraint ) { foreach ( $ hppRequest -> getSupplementaryData ( ) as $ supplementaryData ) { if ( strlen ( $ supplementaryData ) > $ this -> maxLength ) { $ this -> context -> buildViolation ( $ constraint -> message ) -> atPath ( 'supplementaryData' ) -> addViolation ( ) ; } } } 
public function requestToJson ( HppRequest $ hppRequest , $ encoded = true ) { $ this -> logger -> info ( "Converting HppRequest to JSON." ) ; $ json = null ; 
public function requestFromJson ( $ json , $ encoded = true ) { $ this -> logger -> info ( "Converting JSON to HppRequest." ) ; 
public function responseToJson ( HppResponse $ hppResponse ) { $ this -> logger -> info ( "Converting HppResponse to JSON." ) ; $ json = null ; 
public function responseFromJson ( $ json , $ encoded = true ) { $ this -> logger -> info ( "Converting JSON to HppResponse." ) ; 
public function addAutoSettleFlag ( $ autoSettleFlag ) { if ( is_bool ( $ autoSettleFlag ) ) { $ this -> autoSettleFlag = $ autoSettleFlag ? Flag :: TRUE : Flag :: FALSE ; } else { $ this -> autoSettleFlag = $ autoSettleFlag ; } return $ this ; } 
public function addReturnTss ( $ returnTss ) { if ( is_bool ( $ returnTss ) ) { $ this -> returnTss = $ returnTss ? Flag :: TRUE : Flag :: FALSE ; } else { $ this -> returnTss = $ returnTss ; } return $ this ; } 
public function addValidateCardOnly ( $ validateCardOnly ) { if ( is_bool ( $ validateCardOnly ) ) { $ this -> validateCardOnly = $ validateCardOnly ? Flag :: TRUE : Flag :: FALSE ; } else { $ this -> validateCardOnly = $ validateCardOnly ; } return $ this ; } 
public function addDccEnable ( $ dccEnable ) { if ( is_bool ( $ dccEnable ) ) { $ this -> dccEnable = $ dccEnable ? Flag :: TRUE : Flag :: FALSE ; } else { $ this -> dccEnable = $ dccEnable ; } return $ this ; } 
public function addCardStorageEnable ( $ cardStorageEnable ) { if ( is_bool ( $ cardStorageEnable ) ) { $ this -> cardStorageEnable = $ cardStorageEnable ? Flag :: TRUE : Flag :: FALSE ; } else { $ this -> cardStorageEnable = $ cardStorageEnable ; } return $ this ; } 
public function addOfferSaveCard ( $ offerSaveCard ) { if ( is_bool ( $ offerSaveCard ) ) { $ this -> offerSaveCard = $ offerSaveCard ? Flag :: TRUE : Flag :: FALSE ; } else { $ this -> offerSaveCard = $ offerSaveCard ; } return $ this ; } 
public function addPayerExists ( $ payerExists ) { if ( is_bool ( $ payerExists ) ) { $ this -> payerExists = $ payerExists ? Flag :: TRUE : Flag :: FALSE ; } else { $ this -> payerExists = $ payerExists ; } return $ this ; } 
public function addHppVersion ( $ hppVersion ) { if ( is_bool ( $ hppVersion ) ) { $ this -> cardStorageEnable = $ hppVersion ? Flag :: TRUE : Flag :: FALSE ; } else { $ this -> hppVersion = $ hppVersion ; } return $ this ; } 
public function generateDefaults ( $ secret ) { 
public function hash ( $ secret ) { 
public function encode ( $ charSet ) { $ this -> account = base64_encode ( $ this -> account ) ; $ this -> amount = base64_encode ( $ this -> amount ) ; $ this -> autoSettleFlag = base64_encode ( $ this -> autoSettleFlag ) ; $ this -> billingCode = base64_encode ( $ this -> billingCode ) ; $ this -> billingCountry = base64_encode ( $ this -> billingCountry ) ; $ this -> cardPaymentButtonText = base64_encode ( $ this -> cardPaymentButtonText ) ; $ this -> cardStorageEnable = base64_encode ( $ this -> cardStorageEnable ) ; $ this -> commentOne = base64_encode ( $ this -> commentOne ) ; $ this -> commentTwo = base64_encode ( $ this -> commentTwo ) ; $ this -> currency = base64_encode ( $ this -> currency ) ; $ this -> customerNumber = base64_encode ( $ this -> customerNumber ) ; $ this -> hash = base64_encode ( $ this -> hash ) ; $ this -> language = base64_encode ( $ this -> language ) ; $ this -> merchantId = base64_encode ( $ this -> merchantId ) ; $ this -> offerSaveCard = base64_encode ( $ this -> offerSaveCard ) ; $ this -> orderId = base64_encode ( $ this -> orderId ) ; $ this -> payerExists = base64_encode ( $ this -> payerExists ) ; $ this -> payerReference = base64_encode ( $ this -> payerReference ) ; $ this -> paymentReference = base64_encode ( $ this -> paymentReference ) ; $ this -> productId = base64_encode ( $ this -> productId ) ; $ this -> returnTss = base64_encode ( $ this -> returnTss ) ; $ this -> shippingCode = base64_encode ( $ this -> shippingCode ) ; $ this -> shippingCountry = base64_encode ( $ this -> shippingCountry ) ; $ this -> timeStamp = base64_encode ( $ this -> timeStamp ) ; $ this -> variableReference = base64_encode ( $ this -> variableReference ) ; $ this -> validateCardOnly = base64_encode ( $ this -> validateCardOnly ) ; $ this -> dccEnable = base64_encode ( $ this -> dccEnable ) ; $ this -> hppVersion = base64_encode ( $ this -> hppVersion ) ; $ this -> hppSelectStoredCard = base64_encode ( $ this -> hppSelectStoredCard ) ; $ this -> postResponse = base64_encode ( $ this -> postResponse ) ; $ this -> postDimensions = base64_encode ( $ this -> postDimensions ) ; if ( is_array ( $ this -> supplementaryData ) ) { foreach ( $ this -> supplementaryData as $ key => $ value ) { $ this -> supplementaryData [ $ key ] = base64_encode ( $ value ) ; } } return $ this ; } 
public function decode ( $ charSet ) { $ this -> account = base64_decode ( $ this -> account ) ; $ this -> amount = base64_decode ( $ this -> amount ) ; $ this -> autoSettleFlag = base64_decode ( $ this -> autoSettleFlag ) ; $ this -> billingCode = base64_decode ( $ this -> billingCode ) ; $ this -> billingCountry = base64_decode ( $ this -> billingCountry ) ; $ this -> cardPaymentButtonText = base64_decode ( $ this -> cardPaymentButtonText ) ; $ this -> cardStorageEnable = base64_decode ( $ this -> cardStorageEnable ) ; $ this -> commentOne = base64_decode ( $ this -> commentOne ) ; $ this -> commentTwo = base64_decode ( $ this -> commentTwo ) ; $ this -> currency = base64_decode ( $ this -> currency ) ; $ this -> customerNumber = base64_decode ( $ this -> customerNumber ) ; $ this -> hash = base64_decode ( $ this -> hash ) ; $ this -> language = base64_decode ( $ this -> language ) ; $ this -> merchantId = base64_decode ( $ this -> merchantId ) ; $ this -> offerSaveCard = base64_decode ( $ this -> offerSaveCard ) ; $ this -> orderId = base64_decode ( $ this -> orderId ) ; $ this -> payerExists = base64_decode ( $ this -> payerExists ) ; $ this -> payerReference = base64_decode ( $ this -> payerReference ) ; $ this -> paymentReference = base64_decode ( $ this -> paymentReference ) ; $ this -> productId = base64_decode ( $ this -> productId ) ; $ this -> returnTss = base64_decode ( $ this -> returnTss ) ; $ this -> shippingCode = base64_decode ( $ this -> shippingCode ) ; $ this -> shippingCountry = base64_decode ( $ this -> shippingCountry ) ; $ this -> timeStamp = base64_decode ( $ this -> timeStamp ) ; $ this -> variableReference = base64_decode ( $ this -> variableReference ) ; $ this -> validateCardOnly = base64_decode ( $ this -> validateCardOnly ) ; $ this -> dccEnable = base64_decode ( $ this -> dccEnable ) ; $ this -> hppVersion = base64_decode ( $ this -> hppVersion ) ; $ this -> hppSelectStoredCard = base64_decode ( $ this -> hppSelectStoredCard ) ; $ this -> postResponse = base64_decode ( $ this -> postResponse ) ; $ this -> postDimensions = base64_decode ( $ this -> postDimensions ) ; if ( is_array ( $ this -> supplementaryData ) ) { foreach ( $ this -> supplementaryData as $ key => $ value ) { $ this -> supplementaryData [ $ key ] = base64_decode ( $ value ) ; } } return $ this ; } 
public function formatRequest ( $ charSet ) { $ this -> account = $ this -> nullToEmptyString ( $ this -> account ) ; $ this -> amount = $ this -> nullToEmptyString ( $ this -> amount ) ; $ this -> autoSettleFlag = $ this -> nullToEmptyString ( $ this -> autoSettleFlag ) ; $ this -> billingCode = $ this -> nullToEmptyString ( $ this -> billingCode ) ; $ this -> billingCountry = $ this -> nullToEmptyString ( $ this -> billingCountry ) ; $ this -> cardPaymentButtonText = $ this -> nullToEmptyString ( $ this -> cardPaymentButtonText ) ; $ this -> cardStorageEnable = $ this -> nullToEmptyString ( $ this -> cardStorageEnable ) ; $ this -> commentOne = $ this -> nullToEmptyString ( $ this -> commentOne ) ; $ this -> commentTwo = $ this -> nullToEmptyString ( $ this -> commentTwo ) ; $ this -> currency = $ this -> nullToEmptyString ( $ this -> currency ) ; $ this -> customerNumber = $ this -> nullToEmptyString ( $ this -> customerNumber ) ; $ this -> hash = $ this -> nullToEmptyString ( $ this -> hash ) ; $ this -> language = $ this -> nullToEmptyString ( $ this -> language ) ; $ this -> merchantId = $ this -> nullToEmptyString ( $ this -> merchantId ) ; $ this -> offerSaveCard = $ this -> nullToEmptyString ( $ this -> offerSaveCard ) ; $ this -> orderId = $ this -> nullToEmptyString ( $ this -> orderId ) ; $ this -> payerExists = $ this -> nullToEmptyString ( $ this -> payerExists ) ; $ this -> payerReference = $ this -> nullToEmptyString ( $ this -> payerReference ) ; $ this -> paymentReference = $ this -> nullToEmptyString ( $ this -> paymentReference ) ; $ this -> productId = $ this -> nullToEmptyString ( $ this -> productId ) ; $ this -> returnTss = $ this -> nullToEmptyString ( $ this -> returnTss ) ; $ this -> shippingCode = $ this -> nullToEmptyString ( $ this -> shippingCode ) ; $ this -> shippingCountry = $ this -> nullToEmptyString ( $ this -> shippingCountry ) ; $ this -> timeStamp = $ this -> nullToEmptyString ( $ this -> timeStamp ) ; $ this -> variableReference = $ this -> nullToEmptyString ( $ this -> variableReference ) ; $ this -> validateCardOnly = $ this -> nullToEmptyString ( $ this -> validateCardOnly ) ; $ this -> dccEnable = $ this -> nullToEmptyString ( $ this -> dccEnable ) ; $ this -> hppVersion = $ this -> nullToEmptyString ( $ this -> hppVersion ) ; $ this -> hppSelectStoredCard = $ this -> nullToEmptyString ( $ this -> hppSelectStoredCard ) ; $ this -> postResponse = $ this -> nullToEmptyString ( $ this -> postResponse ) ; $ this -> postDimensions = $ this -> nullToEmptyString ( $ this -> postDimensions ) ; if ( is_array ( $ this -> supplementaryData ) ) { foreach ( $ this -> supplementaryData as $ key => $ value ) { $ this -> supplementaryData [ $ key ] = $ this -> nullToEmptyString ( $ value ) ; } } return $ this ; } 
public function validate ( $ hppRequest , Constraint $ constraint ) { 
public function validate ( $ hppRequest , Constraint $ constraint ) { foreach ( $ hppRequest -> getSupplementaryData ( ) as $ supplementaryData ) { if ( ! preg_match ( $ constraint -> pattern , $ supplementaryData ) ) { $ this -> context -> buildViolation ( $ constraint -> message ) -> atPath ( 'supplementaryData' ) -> addViolation ( ) ; } } } 
public static function GetLogger ( $ className ) { if ( ! self :: IsInitialised ( ) ) { self :: Initialise ( ) ; } $ logger = Logger :: getLogger ( $ className ) ; return $ logger ; } 
public static function generateHash ( $ toHash , $ secret ) { 
public static function toJson ( $ hppObject ) { self :: Initialise ( ) ; $ mapper = self :: $ mappers [ get_class ( $ hppObject ) ] ; return $ mapper -> WriteValueAsString ( $ hppObject ) ; } 
public static function fromJsonHppRequest ( $ json ) { self :: Initialise ( ) ; $ mapper = self :: $ mappers [ HppRequest :: GetClassName ( ) ] ; return $ mapper -> ReadValue ( $ json ) ; } 
public static function fromJsonHppResponse ( $ json ) { self :: Initialise ( ) ; $ mapper = self :: $ mappers [ HppResponse :: GetClassName ( ) ] ; return $ mapper -> ReadValue ( $ json ) ; } 
public function generateHash ( $ secret ) { 
public function encode ( $ charset ) { $ this -> merchantId = base64_encode ( $ this -> merchantId ) ; $ this -> account = base64_encode ( $ this -> account ) ; $ this -> amount = base64_encode ( $ this -> amount ) ; $ this -> authCode = base64_encode ( $ this -> authCode ) ; $ this -> batchId = base64_encode ( $ this -> batchId ) ; $ this -> cavv = base64_encode ( $ this -> cavv ) ; $ this -> cvnResult = base64_encode ( $ this -> cvnResult ) ; $ this -> eci = base64_encode ( $ this -> eci ) ; $ this -> commentOne = base64_encode ( $ this -> commentOne ) ; $ this -> commentTwo = base64_encode ( $ this -> commentTwo ) ; $ this -> message = base64_encode ( $ this -> message ) ; $ this -> pasRef = base64_encode ( $ this -> pasRef ) ; $ this -> hash = base64_encode ( $ this -> hash ) ; $ this -> result = base64_encode ( $ this -> result ) ; $ this -> xid = base64_encode ( $ this -> xid ) ; $ this -> orderId = base64_encode ( $ this -> orderId ) ; $ this -> timeStamp = base64_encode ( $ this -> timeStamp ) ; $ this -> AVSAddressResult = base64_encode ( $ this -> AVSAddressResult ) ; $ this -> AVSPostCodeResult = base64_encode ( $ this -> AVSPostCodeResult ) ; if ( is_array ( $ this -> tss ) ) { foreach ( $ this -> tss as $ key => $ value ) { $ this -> tss [ $ key ] = base64_encode ( $ value ) ; } } if ( is_array ( $ this -> supplementaryData ) ) { foreach ( $ this -> supplementaryData as $ key => $ value ) { $ this -> supplementaryData [ $ key ] = base64_encode ( $ value ) ; } } return $ this ; } 
public function decode ( $ charset ) { $ this -> merchantId = base64_decode ( $ this -> merchantId ) ; $ this -> account = base64_decode ( $ this -> account ) ; $ this -> amount = base64_decode ( $ this -> amount ) ; $ this -> authCode = base64_decode ( $ this -> authCode ) ; $ this -> batchId = base64_decode ( $ this -> batchId ) ; $ this -> cavv = base64_decode ( $ this -> cavv ) ; $ this -> cvnResult = base64_decode ( $ this -> cvnResult ) ; $ this -> eci = base64_decode ( $ this -> eci ) ; $ this -> commentOne = base64_decode ( $ this -> commentOne ) ; $ this -> commentTwo = base64_decode ( $ this -> commentTwo ) ; $ this -> message = base64_decode ( $ this -> message ) ; $ this -> pasRef = base64_decode ( $ this -> pasRef ) ; $ this -> hash = base64_decode ( $ this -> hash ) ; $ this -> result = base64_decode ( $ this -> result ) ; $ this -> xid = base64_decode ( $ this -> xid ) ; $ this -> orderId = base64_decode ( $ this -> orderId ) ; $ this -> timeStamp = base64_decode ( $ this -> timeStamp ) ; $ this -> AVSAddressResult = base64_decode ( $ this -> AVSAddressResult ) ; $ this -> AVSPostCodeResult = base64_decode ( $ this -> AVSPostCodeResult ) ; if ( is_array ( $ this -> tss ) ) { foreach ( $ this -> tss as $ key => $ value ) { $ this -> tss [ $ key ] = base64_decode ( $ value ) ; } } if ( is_array ( $ this -> supplementaryData ) ) { foreach ( $ this -> supplementaryData as $ key => $ value ) { $ this -> supplementaryData [ $ key ] = base64_decode ( $ value ) ; } } return $ this ; } 
public function isValidValue ( $ value ) { if ( is_null ( $ value ) ) return true ; foreach ( $ this -> getConfig ( ) -> get ( 'values' ) as $ item ) { if ( $ value === $ item [ 'name' ] || $ value === $ item [ 'value' ] ) { return true ; } } return false ; } 
public function addDirectives ( $ directives ) { if ( ! is_array ( $ directives ) ) { throw new \ Exception ( 'addDirectives accept only array of directives' ) ; } foreach ( $ directives as $ directive ) { $ this -> addDirective ( $ directive ) ; } return $ this ; } 
public function addDirective ( DirectiveInterface $ directive ) { $ directiveName = $ this -> getDirectiveName ( $ directive ) ; if ( $ this -> isDirectiveNameRegistered ( $ directiveName ) ) return $ this ; $ this -> directivesList [ $ directiveName ] = $ directive ; return $ this ; } 
public function getField ( AbstractObjectType $ type , $ fieldName ) { $ typeName = $ type -> getName ( ) ; if ( ! array_key_exists ( $ typeName , $ this -> typeFieldLookupTable ) ) { $ this -> typeFieldLookupTable [ $ typeName ] = [ ] ; } if ( ! array_key_exists ( $ fieldName , $ this -> typeFieldLookupTable [ $ typeName ] ) ) { $ this -> typeFieldLookupTable [ $ typeName ] [ $ fieldName ] = $ type -> getField ( $ fieldName ) ; } return $ this -> typeFieldLookupTable [ $ typeName ] [ $ fieldName ] ; } 
protected function validList ( $ value , $ returnValue = false ) { $ itemType = $ this -> config -> get ( 'itemType' ) ; if ( $ value && $ itemType -> isInputType ( ) ) { foreach ( $ value as $ item ) { if ( ! $ itemType -> isValidValue ( $ item ) ) { return $ returnValue ? $ item : false ; } } } return true ; } 
public function reduceQuery ( ExecutionContextInterface $ executionContext , array $ reducers ) { $ this -> executionContext = $ executionContext ; $ schema = $ executionContext -> getSchema ( ) ; foreach ( $ reducers as $ reducer ) { foreach ( $ executionContext -> getRequest ( ) -> getAllOperations ( ) as $ operation ) { $ this -> doVisit ( $ operation , $ operation instanceof Mutation ? $ schema -> getMutationType ( ) : $ schema -> getQueryType ( ) , $ reducer ) ; } } } 
protected function doVisit ( Query $ query , $ currentLevelSchema , $ reducer ) { if ( ! ( $ currentLevelSchema instanceof AbstractObjectType ) || ! $ currentLevelSchema -> hasField ( $ query -> getName ( ) ) ) { return ; } if ( $ operationField = $ currentLevelSchema -> getField ( $ query -> getName ( ) ) ) { $ coroutine = $ this -> walkQuery ( $ query , $ operationField ) ; if ( $ results = $ coroutine -> current ( ) ) { $ queryCost = 0 ; while ( $ results ) { * @var Query|FieldAst $queryField * @var Field $astField */ $ cost = $ reducer -> visit ( $ queryField -> getKeyValueArguments ( ) , $ astField -> getConfig ( ) , $ childCost ) ; $ queryCost += $ cost ; $ results = $ coroutine -> send ( $ cost ) ; } } } } 
protected function walkQuery ( $ queryNode , FieldInterface $ currentLevelAST ) { $ childrenScore = 0 ; if ( ! ( $ queryNode instanceof FieldAst ) ) { foreach ( $ queryNode -> getFields ( ) as $ queryField ) { if ( $ queryField instanceof FragmentInterface ) { if ( $ queryField instanceof FragmentReference ) { $ queryField = $ this -> executionContext -> getRequest ( ) -> getFragment ( $ queryField -> getName ( ) ) ; } 
public static function getScalarType ( $ type ) { if ( TypeService :: isScalarType ( $ type ) ) { if ( is_object ( $ type ) ) { return $ type ; } if ( empty ( self :: $ objectsHash [ $ type ] ) ) { $ name = ucfirst ( $ type ) ; $ name = $ name == 'Datetime' ? 'DateTime' : $ name ; $ name = $ name == 'Datetimetz' ? 'DateTimeTz' : $ name ; $ className = 'Youshido\GraphQL\Type\Scalar\\' . $ name . 'Type' ; self :: $ objectsHash [ $ type ] = new $ className ( ) ; } return self :: $ objectsHash [ $ type ] ; } else { throw new ConfigurationException ( 'Configuration problem with type ' . $ type ) ; } } 
protected function scan ( ) { if ( $ this -> pos >= strlen ( $ this -> source ) ) { return new Token ( Token :: TYPE_END , $ this -> getLine ( ) , $ this -> getColumn ( ) ) ; } $ ch = $ this -> source [ $ this -> pos ] ; switch ( $ ch ) { case Token :: TYPE_LPAREN : ++ $ this -> pos ; return new Token ( Token :: TYPE_LPAREN , $ this -> getLine ( ) , $ this -> getColumn ( ) ) ; case Token :: TYPE_RPAREN : ++ $ this -> pos ; return new Token ( Token :: TYPE_RPAREN , $ this -> getLine ( ) , $ this -> getColumn ( ) ) ; case Token :: TYPE_LBRACE : ++ $ this -> pos ; return new Token ( Token :: TYPE_LBRACE , $ this -> getLine ( ) , $ this -> getColumn ( ) ) ; case Token :: TYPE_RBRACE : ++ $ this -> pos ; return new Token ( Token :: TYPE_RBRACE , $ this -> getLine ( ) , $ this -> getColumn ( ) ) ; case Token :: TYPE_COMMA : ++ $ this -> pos ; return new Token ( Token :: TYPE_COMMA , $ this -> getLine ( ) , $ this -> getColumn ( ) ) ; case Token :: TYPE_LSQUARE_BRACE : ++ $ this -> pos ; return new Token ( Token :: TYPE_LSQUARE_BRACE , $ this -> getLine ( ) , $ this -> getColumn ( ) ) ; case Token :: TYPE_RSQUARE_BRACE : ++ $ this -> pos ; return new Token ( Token :: TYPE_RSQUARE_BRACE , $ this -> getLine ( ) , $ this -> getColumn ( ) ) ; case Token :: TYPE_REQUIRED : ++ $ this -> pos ; return new Token ( Token :: TYPE_REQUIRED , $ this -> getLine ( ) , $ this -> getColumn ( ) ) ; case Token :: TYPE_AT : ++ $ this -> pos ; return new Token ( Token :: TYPE_AT , $ this -> getLine ( ) , $ this -> getColumn ( ) ) ; case Token :: TYPE_COLON : ++ $ this -> pos ; return new Token ( Token :: TYPE_COLON , $ this -> getLine ( ) , $ this -> getColumn ( ) ) ; case Token :: TYPE_EQUAL : ++ $ this -> pos ; return new Token ( Token :: TYPE_EQUAL , $ this -> getLine ( ) , $ this -> getColumn ( ) ) ; case Token :: TYPE_POINT : if ( $ this -> checkFragment ( ) ) { return new Token ( Token :: TYPE_FRAGMENT_REFERENCE , $ this -> getLine ( ) , $ this -> getColumn ( ) ) ; } return new Token ( Token :: TYPE_POINT , $ this -> getLine ( ) , $ this -> getColumn ( ) ) ; case Token :: TYPE_VARIABLE : ++ $ this -> pos ; return new Token ( Token :: TYPE_VARIABLE , $ this -> getLine ( ) , $ this -> getColumn ( ) ) ; } if ( $ ch === '_' || ( 'a' <= $ ch && $ ch <= 'z' ) || ( 'A' <= $ ch && $ ch <= 'Z' ) ) { return $ this -> scanWord ( ) ; } if ( $ ch === '-' || ( '0' <= $ ch && $ ch <= '9' ) ) { return $ this -> scanNumber ( ) ; } if ( $ ch === '"' ) { return $ this -> scanString ( ) ; } throw $ this -> createException ( 'Can\t recognize token type' ) ; } 
protected function scanString ( ) { $ len = strlen ( $ this -> source ) ; $ this -> pos ++ ; $ value = '' ; while ( $ this -> pos < $ len ) { $ ch = $ this -> source [ $ this -> pos ] ; if ( $ ch === '"' ) { $ token = new Token ( Token :: TYPE_STRING , $ this -> getLine ( ) , $ this -> getColumn ( ) , $ value ) ; $ this -> pos ++ ; return $ token ; } if ( $ ch === '\\' && ( $ this -> pos < ( $ len - 1 ) ) ) { $ this -> pos ++ ; $ ch = $ this -> source [ $ this -> pos ] ; switch ( $ ch ) { case '"' : case '\\' : case '/' : break ; case 'b' : $ ch = sprintf ( "%c" , 8 ) ; break ; case 'f' : $ ch = "\f" ; break ; case 'n' : $ ch = "\n" ; break ; case 'r' : $ ch = "\r" ; break ; case 'u' : $ codepoint = substr ( $ this -> source , $ this -> pos + 1 , 4 ) ; if ( ! preg_match ( '/[0-9A-Fa-f]{4}/' , $ codepoint ) ) { throw $ this -> createException ( sprintf ( 'Invalid string unicode escape sequece "%s"' , $ codepoint ) ) ; } $ ch = html_entity_decode ( "&#x{$codepoint};" , ENT_QUOTES , 'UTF-8' ) ; $ this -> pos += 4 ; break ; default : throw $ this -> createException ( sprintf ( 'Unexpected string escaped character "%s"' , $ ch ) ) ; break ; } } $ value .= $ ch ; $ this -> pos ++ ; } throw $ this -> createUnexpectedTokenTypeException ( Token :: TYPE_END ) ; } 
private function getFieldConfigRules ( ) { return [ 'name' => [ 'type' => TypeService :: TYPE_STRING , 'required' => true ] , 'type' => [ 'type' => TypeService :: TYPE_ANY , 'required' => true ] , 'args' => [ 'type' => TypeService :: TYPE_ARRAY ] , 'description' => [ 'type' => TypeService :: TYPE_STRING ] , 'resolve' => [ 'type' => TypeService :: TYPE_CALLABLE ] , 'isDeprecated' => [ 'type' => TypeService :: TYPE_BOOLEAN ] , 'deprecationReason' => [ 'type' => TypeService :: TYPE_STRING ] , 'cost' => [ 'type' => TypeService :: TYPE_ANY ] ] ; } 
public function getFieldAST ( $ fieldName ) { $ field = null ; foreach ( $ this -> getFieldASTList ( ) as $ fieldAST ) { if ( $ fieldAST -> getName ( ) === $ fieldName ) { $ field = $ fieldAST ; break ; } } return $ field ; } 
public function resolveDefaultValue ( $ value ) { $ resolvedValue = $ value -> getConfig ( ) -> getDefaultValue ( ) ; return $ resolvedValue === null ? $ resolvedValue : str_replace ( '"' , '' , json_encode ( $ resolvedValue ) ) ; } 
public function getFragment ( $ name ) { foreach ( $ this -> fragments as $ fragment ) { if ( $ fragment -> getName ( ) == $ name ) { return $ fragment ; } } return null ; } 
public function setVariables ( $ variables ) { if ( ! is_array ( $ variables ) ) { $ variables = json_decode ( $ variables , true ) ; } $ this -> variables = $ variables ; foreach ( $ this -> variableReferences as $ reference ) { if ( ! $ reference -> getVariable ( ) ) continue ; $ variableName = $ reference -> getVariable ( ) -> getName ( ) ; if ( ! array_key_exists ( $ variableName , $ variables ) ) continue ; $ reference -> getVariable ( ) -> setValue ( $ variables [ $ variableName ] ) ; $ reference -> setValue ( $ variables [ $ variableName ] ) ; } return $ this ; } 
public function resolveLocations ( DirectiveInterface $ value ) { $ directiveConfig = $ value -> getConfig ( ) ; $ locations = $ directiveConfig -> getLocations ( ) ; return $ locations ; } 
public static function edgeDefinition ( AbstractType $ type , $ name = null , $ config = [ ] ) { $ name = $ name ? : $ type -> getName ( ) ; $ edgeFields = ! empty ( $ config [ 'edgeFields' ] ) ? $ config [ 'edgeFields' ] : [ ] ; $ edgeType = new ObjectType ( [ 'name' => $ name . 'Edge' , 'description' => 'An edge in a connection.' , 'fields' => array_merge ( [ 'node' => [ 'type' => $ type , 'description' => 'The item at the end of the edge' , 'resolve' => [ __CLASS__ , 'getNode' ] , ] , 'cursor' => [ 'type' => TypeMap :: TYPE_STRING , 'description' => 'A cursor for use in pagination' ] ] , $ edgeFields ) ] ) ; return $ edgeType ; } 
public static function connectionDefinition ( AbstractType $ type , $ name = null , $ config = [ ] ) { $ name = $ name ? : $ type -> getName ( ) ; $ connectionFields = ! empty ( $ config [ 'connectionFields' ] ) ? $ config [ 'connectionFields' ] : [ ] ; $ connectionType = new ObjectType ( [ 'name' => $ name . 'Connection' , 'description' => 'A connection to a list of items.' , 'fields' => array_merge ( [ 'totalCount' => [ 'type' => new NonNullType ( new IntType ( ) ) , 'description' => 'How many nodes.' , 'resolve' => [ __CLASS__ , 'getTotalCount' ] , ] , 'pageInfo' => [ 'type' => new NonNullType ( new PageInfoType ( ) ) , 'description' => 'Information to aid in pagination.' , 'resolve' => [ __CLASS__ , 'getPageInfo' ] , ] , 'edges' => [ 'type' => new ListType ( self :: edgeDefinition ( $ type , $ name , $ config ) ) , 'description' => 'A list of edges.' , 'resolve' => [ __CLASS__ , 'getEdges' ] , ] ] , $ connectionFields ) ] ) ; return $ connectionType ; } 
public static function unpackDeferredResults ( $ result ) { while ( $ result instanceof DeferredResult ) { $ result = $ result -> result ; } if ( is_array ( $ result ) ) { foreach ( $ result as $ key => $ value ) { $ result [ $ key ] = static :: unpackDeferredResults ( $ value ) ; } } return $ result ; } 
protected function deferredResolve ( $ resolvedValue , FieldInterface $ field , callable $ callback ) { if ( $ resolvedValue instanceof DeferredResolverInterface ) { $ deferredResult = new DeferredResult ( $ resolvedValue , function ( $ resolvedValue ) use ( $ field , $ callback ) { 
public static function cursorToKey ( $ cursor ) { if ( $ decoded = base64_decode ( $ cursor ) ) { return substr ( $ decoded , strlen ( self :: PREFIX ) ) ; } return null ; } 
public static function cursorToOffsetWithDefault ( $ cursor , $ default , $ array = [ ] ) { if ( ! is_string ( $ cursor ) ) { return $ default ; } $ key = self :: cursorToKey ( $ cursor ) ; if ( empty ( $ array ) ) { $ offset = $ key ; } else { $ offset = array_search ( $ key , array_keys ( $ array ) ) ; } return is_null ( $ offset ) ? $ default : ( int ) $ offset ; } 
public function getValue ( ) { if ( null === $ this -> value ) { if ( $ this -> hasDefaultValue ( ) ) { return $ this -> defaultValue ; } throw new \ LogicException ( 'Value is not set for variable "' . $ this -> name . '"' ) ; } return $ this -> value ; } 
public function getDirective ( $ name ) { $ directive = null ; if ( isset ( $ this -> directives [ $ name ] ) ) { $ directive = $ this -> directives [ $ name ] ; } return $ directive ; } 
protected function parseValue ( ) { switch ( $ this -> lookAhead -> getType ( ) ) { case Token :: TYPE_LSQUARE_BRACE : return $ this -> parseList ( ) ; case Token :: TYPE_LBRACE : return $ this -> parseObject ( ) ; case Token :: TYPE_VARIABLE : return $ this -> parseVariableReference ( ) ; case Token :: TYPE_NUMBER : case Token :: TYPE_STRING : case Token :: TYPE_IDENTIFIER : case Token :: TYPE_NULL : case Token :: TYPE_TRUE : case Token :: TYPE_FALSE : $ token = $ this -> lex ( ) ; return new Literal ( $ token -> getData ( ) , new Location ( $ token -> getLine ( ) , $ token -> getColumn ( ) ) ) ; } throw $ this -> createUnexpectedException ( $ this -> lookAhead ) ; } 
public static function buildMutation ( $ name , array $ args , $ output , callable $ resolveFunction ) { if ( ! is_array ( $ output ) || ( is_object ( $ output ) && ! ( $ output instanceof AbstractObjectType ) ) ) { throw new \ Exception ( 'Output can be instance of AbstractObjectType or array of fields' ) ; } return new Field ( [ 'name' => $ name , 'args' => [ new InputField ( [ 'name' => 'input' , 'type' => new NonNullType ( new InputObjectType ( [ 'name' => ucfirst ( $ name ) . 'Input' , 'fields' => array_merge ( $ args , [ new InputField ( [ 'name' => 'clientMutationId' , 'type' => new NonNullType ( new StringType ( ) ) ] ) ] ) ] ) ) ] ) ] , 'type' => new ObjectType ( [ 'fields' => is_object ( $ output ) ? $ output : array_merge ( $ output , [ new Field ( [ 'name' => 'clientMutationId' , 'type' => new NonNullType ( new StringType ( ) ) ] ) ] ) , 'name' => ucfirst ( $ name ) . 'Payload' ] ) , 'resolve' => function ( $ value , $ args , ResolveInfo $ info ) use ( $ resolveFunction ) { $ resolveValue = $ resolveFunction ( $ value , $ args [ 'input' ] , $ args , $ info ) ; if ( is_object ( $ resolveValue ) ) { $ resolveValue -> clientMutationId = $ args [ 'input' ] [ 'clientMutationId' ] ; } elseif ( is_array ( $ resolveValue ) ) { $ resolveValue [ 'clientMutationId' ] = $ args [ 'input' ] [ 'clientMutationId' ] ; } return $ resolveValue ; } ] ) ; } 
public function visit ( array $ args , FieldConfig $ fieldConfig , $ childScore = 0 ) { $ cost = $ fieldConfig -> get ( 'cost' , null ) ; if ( is_callable ( $ cost ) ) { $ cost = $ cost ( $ args , $ fieldConfig , $ childScore ) ; } $ cost = is_null ( $ cost ) ? $ this -> defaultScore : $ cost ; $ this -> memo += $ cost ; if ( $ this -> memo > $ this -> maxScore ) { throw new \ Exception ( 'query exceeded max allowed complexity of ' . $ this -> maxScore ) ; } return $ cost ; } 
public function get ( $ key , $ defaultValue = null ) { return $ this -> has ( $ key ) ? $ this -> data [ $ key ] : $ defaultValue ; } 
public function validate ( AbstractSchema $ schema ) { if ( ! $ schema -> getQueryType ( ) -> hasFields ( ) ) { throw new ConfigurationException ( 'Schema has to have fields' ) ; } $ this -> configValidator = ConfigValidator :: getInstance ( ) ; foreach ( $ schema -> getQueryType ( ) -> getConfig ( ) -> getFields ( ) as $ field ) { $ this -> configValidator -> assertValidConfig ( $ field -> getConfig ( ) ) ; if ( $ field -> getType ( ) instanceof AbstractObjectType ) { $ this -> assertInterfaceImplementationCorrect ( $ field -> getType ( ) ) ; } } } 
protected function assertInterfaceImplementationCorrect ( AbstractObjectType $ type ) { if ( ! $ type -> getInterfaces ( ) ) { return ; } foreach ( $ type -> getInterfaces ( ) as $ interface ) { foreach ( $ interface -> getConfig ( ) -> getFields ( ) as $ intField ) { $ this -> assertFieldsIdentical ( $ intField , $ type -> getConfig ( ) -> getField ( $ intField -> getName ( ) ) , $ interface ) ; } } } 
protected function assertFieldsIdentical ( $ intField , $ objField , AbstractInterfaceType $ interface ) { $ isValid = true ; if ( $ intField -> getType ( ) -> isCompositeType ( ) !== $ objField -> getType ( ) -> isCompositeType ( ) ) { $ isValid = false ; } if ( $ intField -> getType ( ) -> getNamedType ( ) -> getName ( ) != $ objField -> getType ( ) -> getNamedType ( ) -> getName ( ) ) { $ isValid = false ; } if ( ! $ isValid ) { throw new ConfigurationException ( sprintf ( 'Implementation of %s is invalid for the field %s' , $ interface -> getName ( ) , $ objField -> getName ( ) ) ) ; } } 
private function getReplacementsAndClear ( Tokens $ tokens , array $ indices , int $ direction ) : array { return \ array_map ( static function ( int $ index ) use ( $ tokens , $ direction ) : Token { $ clone = $ tokens [ $ index ] ; if ( $ tokens [ $ index + $ direction ] -> isWhitespace ( ) ) { $ tokens -> clearAt ( $ index + $ direction ) ; } $ tokens -> clearAt ( $ index ) ; return $ clone ; } , $ indices ) ; } 
public function onOpen ( SwooleWebsocketServer $ server , SwooleHttpRequest $ swooleRequest ) : void { $ this -> log ( sprintf ( 'Server: handshake success with fd %s' , $ swooleRequest -> fd ) ) ; $ this -> setClientPathInfo ( $ swooleRequest -> fd , $ swooleRequest -> server [ 'path_info' ] ) ; $ request = $ this -> normalizeRequest ( $ swooleRequest ) ; $ request -> setPathInfo ( $ this -> normalizePathInfo ( $ request -> getPathInfo ( ) , self :: OPEN ) ) ; $ this -> setPreRequestMatched ( $ request , [ $ server , $ request , $ swooleRequest -> fd ] ) ; $ response = $ this -> dispatchRouter ( $ request ) ; } 
public function onMessage ( SwooleWebsocketServer $ server , SwooleWebsocketFrame $ frame ) : void { $ this -> log ( sprintf ( 'Receive from fd %d:%s,opcode:%d,fin:%d' , $ frame -> fd , $ frame -> data , $ frame -> opcode , $ frame -> finish ) ) ; if ( false === ( $ pathInfo = $ this -> getClientPathInfo ( $ frame -> fd ) ) ) { return ; } $ request = $ this -> createRequestWithPathInfo ( $ pathInfo , self :: MESSAGE ) ; $ this -> setPreRequestMatched ( $ request , [ $ server , $ frame , $ frame -> fd ] ) ; $ response = $ this -> dispatchRouter ( $ request ) ; } 
public function onWebsocketClose ( SwooleWebsocketServer $ server , int $ fd , int $ reactorId ) : void { $ this -> log ( sprintf ( 'Server close, fd %d, reactorId %d.' , $ fd , $ reactorId ) ) ; $ clientInfo = $ this -> server -> getClientInfo ( $ fd ) ; if ( $ clientInfo [ 'websocket_status' ] <= 0 ) { return ; } 
protected function setPreRequestMatched ( IRequest $ request , array $ data ) : void { $ this -> container -> make ( IRouter :: class ) -> setPreRequestMatched ( $ request , [ IRouter :: VARS => $ data ] ) ; } 
protected function createRequestWithPathInfo ( string $ pathInfo , string $ type ) : IRequest { $ request = new Request ( ) ; $ request -> setPathInfo ( $ this -> normalizePathInfo ( $ pathInfo , $ type ) ) ; return $ request ; } 
protected function createServer ( ) : void { $ this -> server = new SwooleWebsocketServer ( $ this -> option [ 'host' ] , ( int ) ( $ this -> option [ 'port' ] ) ) ; $ this -> initServer ( ) ; } 
protected function getClientPathInfo ( int $ fd ) { $ key = self :: PATHINFO . $ fd ; $ pathInfo = $ this -> container -> make ( $ key ) ; if ( $ key === $ pathInfo ) { return false ; } return $ pathInfo ; } 
protected function setClientPathInfo ( int $ fd , string $ pathInfo ) : void { $ this -> container -> instance ( self :: PATHINFO . $ fd , $ pathInfo ) ; } 
public function makeConnect ( ) { if ( empty ( $ this -> option [ 'path' ] ) ) { throw new InvalidArgumentException ( 'The local requires path option.' ) ; } return new AdapterLocal ( $ this -> option [ 'path' ] , $ this -> option [ 'write_flags' ] , $ this -> option [ 'link_handling' ] , $ this -> option [ 'permissions' ] ) ; } 
public function handle ( IApp $ app , IOption $ option ) : void { $ this -> app = $ app ; $ this -> parser = $ this -> createParser ( ) ; $ this -> html = $ this -> getHtmlView ( ) ; $ this -> line ( 'Start to cache view.' ) ; foreach ( $ this -> paths ( ) as $ path ) { $ this -> compiles ( $ this -> findFiles ( [ $ path ] ) , $ path ) ; } $ this -> info ( 'View files cache successed.' ) ; } 
protected function compiles ( Finder $ finder , string $ path ) : void { if ( 0 === count ( $ finder ) ) { $ this -> comment ( sprintf ( 'Compile files not found in path `%s` and skipped.' , $ path ) ) ; return ; } $ this -> info ( sprintf ( 'Start to compiles path `%s`' , $ path ) ) ; $ progressBar = new ProgressBar ( new ConsoleOutput ( ) , count ( $ finder ) ) ; $ progressBar -> setFormat ( '[View:cache]%current%/%max% [%bar%] %percent:3s%% %elapsed:6s%/%estimated:-6s% %memory:6s%' ) ; foreach ( $ finder as $ file ) { $ progressBar -> advance ( ) ; $ this -> parser -> doCompile ( $ file -> getRealPath ( ) , $ this -> html -> getCachePath ( $ file -> getRealPath ( ) ) ) ; } $ progressBar -> finish ( ) ; $ this -> line ( '' ) ; } 
protected function composerPaths ( ) : array { $ path = $ this -> app -> path ( ) . '/composer.json' ; if ( ! is_file ( $ path ) ) { return [ ] ; } $ options = $ this -> getFileContent ( $ path ) ; $ paths = ! empty ( $ options [ 'extra' ] [ 'leevel-console' ] [ 'view-cache' ] [ 'paths' ] ) ? $ options [ 'extra' ] [ 'leevel-console' ] [ 'view-cache' ] [ 'paths' ] : [ ] ; $ path = $ this -> app -> path ( ) ; $ paths = array_map ( function ( string $ value ) use ( $ path ) { if ( ! is_file ( $ value ) ) { $ value = $ path . '/' . $ value ; } if ( ! is_dir ( $ value ) ) { throw new RuntimeException ( sprintf ( 'View dir %s is not exist.' , $ value ) ) ; } return $ value ; } , $ paths ) ; return $ paths ; } 
public function status ( IServer $ server ) : void { 
public function header ( ) : array { return [ 'X-RateLimit-Time' => $ this -> time , 
protected function saveData ( int $ count ) : void { $ this -> cache -> set ( $ this -> getKey ( ) , $ this -> getImplodeData ( $ this -> endTime ( ) , $ count ) ) ; } 
protected function getData ( ) : array { if ( ( $ data = $ this -> cache -> get ( $ this -> getKey ( ) ) ) ) { $ data = $ this -> getExplodeData ( $ data ) ; } else { $ data = [ $ this -> getInitEndTime ( ) , $ this -> getInitCount ( ) , ] ; } return $ data ; } 
protected function getExplodeData ( string $ data ) : array { return array_map ( function ( $ v ) { return ( int ) ( $ v ) ; } , explode ( static :: SEPARATE , $ data ) ) ; } 
public static function dump ( $ var , ... $ moreVars ) { VarDumper :: dump ( $ var ) ; foreach ( $ moreVars as $ var ) { VarDumper :: dump ( $ var ) ; } if ( 1 < func_num_args ( ) ) { return func_get_args ( ) ; } return $ var ; } 
public static function dumpRoadRunner ( $ var , ... $ moreVars ) { static $ dumper ; if ( null === $ dumper ) { $ dumper = new Debug \ Dumper ( ) ; $ dumper -> setRenderer ( Debug \ Dumper :: ERROR_LOG , new Debug \ Renderer \ ConsoleRenderer ( ) ) ; } $ dumper -> dump ( $ var , Debug \ Dumper :: ERROR_LOG ) ; foreach ( $ moreVars as $ var ) { $ dumper -> dump ( $ var ) ; } if ( 1 < func_num_args ( ) ) { return func_get_args ( ) ; } return $ var ; } 
public function handle ( IApp $ app , IOption $ option ) : void { $ input = [ 'path' => $ this -> path ( ) , 'testsdir' => $ app -> path ( 'vendor/hunzhiwange/framework/tests' ) , 'outputdir' => $ option -> get ( 'console\\framework_doc_outputdir' ) , ] ; $ this -> call ( 'make:doc' , $ input ) ; } 
public function set ( string $ name , $ data , ? int $ expire = null ) : void { if ( $ expire ) { $ this -> handle -> setex ( $ name , $ expire , $ data ) ; } else { $ this -> handle -> set ( $ name , $ data ) ; } } 
public function makeTransport ( ) { $ transport = new Swift_SmtpTransport ( $ this -> option [ 'host' ] , $ this -> option [ 'port' ] ) ; if ( null !== $ this -> option [ 'encryption' ] ) { $ transport -> setEncryption ( $ this -> option [ 'encryption' ] ) ; } if ( null !== $ this -> option [ 'username' ] ) { $ transport -> setUsername ( $ this -> option [ 'username' ] ) ; $ transport -> setPassword ( $ this -> option [ 'password' ] ) ; } return $ transport ; } 
public function matchPreLoad ( array $ entitys , Collection $ result , string $ relation ) : array { return $ this -> matchPreLoadOneOrMany ( $ entitys , $ result , $ relation , 'one' ) ; } 
public function handle ( IApp $ app ) : void { $ this -> app = $ app ; $ this -> line ( 'Start to cache autoload.' ) ; if ( false === $ this -> ignore ( ) ) { $ this -> line ( 'Exec composer dump-autoload -o.' ) ; exec ( $ this -> normalizeComposerCommand ( ) ) ; } $ data = $ this -> data ( ) ; $ cachePath = $ this -> autoloadCachedPath ( ) ; $ this -> writeCache ( $ cachePath , $ data ) ; $ this -> info ( sprintf ( 'Autoload file %s cache successed.' , $ cachePath ) ) ; } 
protected function data ( ) : string { $ data = [ ] ; $ data [ ] = $ this -> replaceIncludeFile ( file_get_contents ( $ this -> app -> path ( 'vendor/composer/ClassLoader.php' ) ) ) ; $ data [ ] = $ this -> replaceComposerPath ( $ this -> dataInit ( ) ) ; $ data [ ] = $ this -> dataHelper ( ) ; $ data [ ] = $ this -> dataLoader ( ) ; unlink ( $ this -> app -> path ( 'vendor/composer/ComposerStaticInit.php' ) ) ; return implode ( PHP_EOL . PHP_EOL , $ data ) . PHP_EOL ; } 
protected function dataInit ( ) : string { list ( $ lengths , $ prefixs ) = $ this -> prefixesPsr4 ( ) ; return '/** * Define the root path. */ define(\'LEEVEL_COMPOSER\', __DIR__.\'/composer\'); /** * generated by `php leevel autoload`. */ class ComposerStaticInit { public static $files = ' . var_export ( $ this -> files ( ) , true ) . '; public static $prefixLengthsPsr4 = ' . var_export ( $ lengths , true ) . '; public static $prefixDirsPsr4 = ' . var_export ( $ prefixs , true ) . '; public static $prefixesPsr0 = []; public static $classMap = ' . var_export ( $ this -> classMap ( ) , true ) . '; public static function getInitializer(ClassLoader $loader) { return \Closure::bind(function () use ($loader) { $loader->prefixLengthsPsr4 = ComposerStaticInit::$prefixLengthsPsr4; $loader->prefixDirsPsr4 = ComposerStaticInit::$prefixDirsPsr4; $loader->prefixesPsr0 = ComposerStaticInit::$prefixesPsr0; $loader->classMap = ComposerStaticInit::$classMap; }, null, ClassLoader::class); } }' ; } 
protected function dataHelper ( ) : string { $ autoloadFiles = [ ] ; foreach ( $ this -> files ( ) as $ file ) { foreach ( $ this -> appHelpers ( ) as $ whiteFile ) { if ( false !== strpos ( $ file , $ whiteFile ) ) { $ autoloadFiles [ ] = "require_once '" . $ this -> replaceComposerPath ( $ file ) . "';" ; } } } $ autoloadFiles = $ this -> replaceComposerPath ( implode ( PHP_EOL , $ autoloadFiles ) ) ; return <<<eot foreach (ComposerStaticInit::\$files as \$fileIdentifier => \$_) { \$GLOBALS['__composer_autoload_files'][\$fileIdentifier] = true; } {$autoloadFiles} eot ; } 
protected function prefixesPsr4 ( ) : array { $ lengths = $ prefixs = [ ] ; $ composerStaticClass = $ this -> composerStaticClass ( ) ; $ prefixesPsr4 = $ composerStaticClass :: $ prefixDirsPsr4 ; foreach ( $ this -> optimizeNamespaces ( ) as $ prefix ) { $ first = $ prefix [ 0 ] ; $ prefix .= '\\' ; $ lengths [ $ first ] [ $ prefix ] = strlen ( $ prefix ) ; if ( isset ( $ prefixesPsr4 [ $ prefix ] ) ) { $ prefixs [ $ prefix ] = $ prefixesPsr4 [ $ prefix ] ; } } return [ $ lengths , $ prefixs ] ; } 
protected function classMap ( ) : array { $ result = [ ] ; $ optimizeNamespaces = $ this -> optimizeNamespaces ( ) ; $ composerStaticClass = $ this -> composerStaticClass ( ) ; $ classMap = $ composerStaticClass :: $ classMap ; foreach ( $ classMap as $ key => $ value ) { list ( $ namespace ) = explode ( '\\' , $ key ) ; if ( in_array ( $ namespace , $ optimizeNamespaces , true ) ) { $ result [ $ key ] = $ value ; } } return $ result ; } 
protected function composerStaticClass ( ) : string { static $ staticClass ; if ( $ staticClass ) { return $ staticClass ; } $ content = file_get_contents ( $ this -> app -> path ( 'vendor/autoload.php' ) ) ; if ( preg_match ( '/ComposerAutoloaderInit(\S{32})::getLoader/' , $ content , $ matches ) ) { $ staticContent = file_get_contents ( $ this -> app -> path ( 'vendor/composer/autoload_static.php' ) ) ; file_put_contents ( $ staticPath = $ this -> app -> path ( 'vendor/composer/ComposerStaticInit.php' ) , str_replace ( 'ComposerStaticInit' . $ matches [ 1 ] , 'ComposerStaticInit' , $ staticContent ) ) ; $ this -> composerHash = $ matches [ 1 ] ; include $ staticPath ; return $ staticClass = '\\Composer\\Autoload\\ComposerStaticInit' ; } throw new InvalidArgumentException ( 'Composer autoload is invalid.' ) ; } 
protected function appNamespaces ( ) : array { $ path = $ this -> app -> path ( ) . '/composer.json' ; if ( ! is_file ( $ path ) ) { return [ ] ; } $ options = $ this -> getFileContent ( $ path ) ; $ appNamespaces = $ options [ 'autoload' ] [ 'psr-4' ] ?? [ ] ; if ( $ appNamespaces ) { $ appNamespaces = array_map ( function ( string $ value ) { return rtrim ( $ value , '\\' ) ; } , array_keys ( $ appNamespaces ) ) ; } $ extraNamespaces = $ options [ 'extra' ] [ 'leevel-console' ] [ 'autoload' ] [ 'namespaces' ] ?? [ ] ; return array_merge ( $ appNamespaces , $ extraNamespaces ) ; } 
protected function appHelpers ( ) : array { $ path = $ this -> app -> path ( ) . '/composer.json' ; if ( ! is_file ( $ path ) ) { return [ ] ; } $ options = $ this -> getFileContent ( $ path ) ; return $ options [ 'extra' ] [ 'leevel-console' ] [ 'autoload' ] [ 'files' ] ?? [ ] ; } 
public function handle ( IRouter $ router ) : void { 
protected function normalizeAction ( string $ action ) : string { if ( false !== strpos ( $ action , '-' ) ) { $ action = str_replace ( '-' , '_' , $ action ) ; } if ( false !== strpos ( $ action , '_' ) ) { $ action = '_' . str_replace ( '_' , ' ' , $ action ) ; $ action = ltrim ( str_replace ( ' ' , '' , ucwords ( $ action ) ) , '_' ) ; } return $ action ; } 
public function send ( array $ passed ) : IPipeline { foreach ( $ passed as $ item ) { $ this -> passed [ ] = $ item ; } return $ this ; } 
public function through ( array $ stage ) : IPipeline { foreach ( $ stage as $ item ) { $ this -> stage [ ] = $ item ; } return $ this ; } 
public function then ( Closure $ end = null ) { $ stage = $ this -> stage ; if ( $ end ) { $ stage [ ] = $ end ; } $ this -> generator = $ this -> stageGenerator ( $ stage ) ; return $ this -> traverseGenerator ( ... $ this -> passed ) ; } 
protected function traverseGenerator ( ... $ args ) { if ( ! $ this -> generator -> valid ( ) || $ this -> generator -> next ( ) || ! $ this -> generator -> valid ( ) ) { return ; } array_unshift ( $ args , function ( ... $ args ) { return $ this -> traverseGenerator ( ... $ args ) ; } ) ; $ current = $ this -> generator -> current ( ) ; 
protected function stageGenerator ( array $ stage ) : Generator { array_unshift ( $ stage , null ) ; foreach ( $ stage as $ item ) { yield $ this -> stageCallback ( $ item ) ; } } 
protected function stageCallback ( $ stages ) { if ( null === $ stages ) { return ; } if ( is_callable ( $ stages ) ) { return $ stages ; } list ( $ stage , $ params ) = $ this -> parse ( $ stages ) ; if ( false !== strpos ( $ stage , '@' ) ) { list ( $ stage , $ method ) = explode ( '@' , $ stage ) ; } else { $ method = 'handle' ; } if ( ! is_object ( $ stage = $ this -> container -> make ( $ stage ) ) ) { throw new InvalidArgumentException ( 'Stage is invalid.' ) ; } return [ $ stage , $ method , $ params ] ; } 
protected function parse ( string $ stage ) : array { list ( $ name , $ args ) = array_pad ( explode ( ':' , $ stage , 2 ) , 2 , [ ] ) ; if ( is_string ( $ args ) ) { $ args = explode ( ',' , $ args ) ; } $ args = array_map ( function ( string $ item ) { return ctype_digit ( $ item ) ? ( int ) $ item : $ item ; } , $ args ) ; return [ $ name , $ args ] ; } 
public function pdo ( $ master = false ) { if ( is_bool ( $ master ) ) { if ( false === $ master ) { return $ this -> readConnect ( ) ; } return $ this -> writeConnect ( ) ; } return $ this -> connects [ $ master ] ?? null ; } 
public function query ( string $ sql , array $ bindParams = [ ] , $ master = false , ? int $ fetchStyle = null , $ fetchArgument = null , array $ ctorArgs = [ ] ) { $ this -> initSelect ( ) ; $ this -> setLastSql ( $ sql , $ bindParams ) ; if ( ! in_array ( ( $ sqlType = $ this -> normalizeSqlType ( $ sql ) ) , [ 'select' , 'procedure' , ] , true ) ) { throw new InvalidArgumentException ( 'The query method only allows select and procedure SQL statements.' ) ; } $ this -> pdoStatement = $ this -> pdo ( $ master ) -> prepare ( $ sql ) ; $ this -> bindParams ( $ bindParams ) ; try { $ this -> pdoStatement -> execute ( ) ; $ this -> reconnectRetry = 0 ; } catch ( PDOException $ e ) { if ( $ this -> needReconnect ( $ e ) ) { $ this -> reconnectRetry ++ ; $ this -> close ( ) ; return self :: query ( $ sql , $ bindParams , $ master , $ fetchStyle , $ fetchArgument , $ ctorArgs ) ; } throw $ e ; } $ this -> numRows = $ this -> pdoStatement -> rowCount ( ) ; return $ this -> fetchResult ( $ fetchStyle , $ fetchArgument , $ ctorArgs , 'procedure' === $ sqlType ) ; } 
public function execute ( string $ sql , array $ bindParams = [ ] ) { $ this -> initSelect ( ) ; $ this -> setLastSql ( $ sql , $ bindParams ) ; if ( in_array ( ( $ sqlType = $ this -> normalizeSqlType ( $ sql ) ) , [ 'select' , 'procedure' , ] , true ) ) { throw new InvalidArgumentException ( 'The query method not allows select and procedure SQL statements.' ) ; } $ this -> pdoStatement = $ this -> pdo ( true ) -> prepare ( $ sql ) ; $ this -> bindParams ( $ bindParams ) ; try { $ this -> pdoStatement -> execute ( ) ; $ this -> reconnectRetry = 0 ; } catch ( PDOException $ e ) { if ( $ this -> needReconnect ( $ e ) ) { $ this -> reconnectRetry ++ ; $ this -> close ( ) ; return self :: execute ( $ sql , $ bindParams ) ; } $ this -> pdoException ( $ e ) ; } $ this -> numRows = $ this -> pdoStatement -> rowCount ( ) ; if ( in_array ( $ sqlType , [ 'insert' , 'replace' , ] , true ) ) { return $ this -> lastInsertId ( ) ; } return $ this -> numRows ; } 
public function transaction ( Closure $ action ) { $ this -> beginTransaction ( ) ; try { $ result = call_user_func_array ( $ action , [ $ this , ] ) ; $ this -> commit ( ) ; return $ result ; } catch ( Throwable $ e ) { $ this -> rollBack ( ) ; throw $ e ; } } 
public function beginTransaction ( ) : void { $ this -> transactionLevel ++ ; if ( 1 === $ this -> transactionLevel ) { try { 
public function commit ( ) : void { if ( 0 === $ this -> transactionLevel ) { throw new InvalidArgumentException ( 'There was no active transaction.' ) ; } if ( $ this -> isRollbackOnly ) { throw new InvalidArgumentException ( 'Commit failed for rollback only.' ) ; } if ( 1 === $ this -> transactionLevel ) { $ this -> pdo ( true ) -> commit ( ) ; } elseif ( $ this -> transactionLevel > 1 && $ this -> hasSavepoints ( ) ) { $ this -> releaseSavepoint ( $ this -> getSavepointName ( ) ) ; } $ this -> transactionLevel = max ( 0 , $ this -> transactionLevel - 1 ) ; } 
public function rollBack ( ) : void { if ( 0 === $ this -> transactionLevel ) { throw new InvalidArgumentException ( 'There was no active transaction.' ) ; } if ( 1 === $ this -> transactionLevel ) { $ this -> transactionLevel = 0 ; $ this -> pdo ( true ) -> rollBack ( ) ; $ this -> isRollbackOnly = false ; } elseif ( $ this -> transactionLevel > 1 && $ this -> hasSavepoints ( ) ) { $ this -> rollbackSavepoint ( $ this -> getSavepointName ( ) ) ; $ this -> transactionLevel -- ; } else { $ this -> isRollbackOnly = true ; $ this -> transactionLevel = max ( 0 , $ this -> transactionLevel - 1 ) ; } } 
public function normalizeExpression ( string $ sql , string $ tableName ) : string { preg_match_all ( '/\[[a-z][a-z0-9_\.]*\]|\[\*\]/i' , $ sql , $ matches , PREG_OFFSET_CAPTURE ) ; $ matches = reset ( $ matches ) ; $ out = '' ; $ offset = 0 ; foreach ( $ matches as $ value ) { $ length = strlen ( $ value [ 0 ] ) ; $ field = substr ( $ value [ 0 ] , 1 , $ length - 2 ) ; $ tmp = explode ( '.' , $ field ) ; switch ( count ( $ tmp ) ) { case 2 : $ field = $ tmp [ 1 ] ; $ table = $ tmp [ 0 ] ; break ; default : $ field = $ tmp [ 0 ] ; $ table = $ tableName ; } $ field = $ this -> normalizeTableOrColumn ( "{$table}.{$field}" ) ; $ out .= substr ( $ sql , $ offset , $ value [ 1 ] - $ offset ) . $ field ; $ offset = $ value [ 1 ] + $ length ; } $ out .= substr ( $ sql , $ offset ) ; return $ out ; } 
public function normalizeTableOrColumn ( string $ name , ? string $ alias = null , ? string $ as = null ) : string { $ name = str_replace ( '`' , '' , $ name ) ; if ( false === strpos ( $ name , '.' ) ) { $ name = $ this -> identifierColumn ( $ name ) ; } else { $ tmp = explode ( '.' , $ name ) ; foreach ( $ tmp as $ offset => $ name ) { if ( empty ( $ name ) ) { unset ( $ tmp [ $ offset ] ) ; } else { $ tmp [ $ offset ] = $ this -> identifierColumn ( $ name ) ; } } $ name = implode ( '.' , $ tmp ) ; } if ( $ alias ) { return "{$name} " . ( $ as ? $ as . ' ' : '' ) . $ this -> identifierColumn ( $ alias ) ; } return $ name ; } 
public function normalizeColumnValue ( $ value , bool $ quotationMark = true ) { if ( is_int ( $ value ) ) { return $ value ; } if ( is_bool ( $ value ) ) { return $ value ; } if ( null === $ value ) { return ; } $ value = trim ( $ value ) ; 
public function normalizeSqlType ( string $ sql ) : string { $ sql = trim ( $ sql ) ; foreach ( [ 'select' , 'show' , 'call' , 'exec' , 'delete' , 'insert' , 'replace' , 'update' , ] as $ value ) { if ( 0 === stripos ( $ sql , $ value ) ) { if ( 'show' === $ value ) { $ value = 'select' ; } elseif ( in_array ( $ value , [ 'call' , 'exec' ] , true ) ) { $ value = 'procedure' ; } return $ value ; } } return 'statement' ; } 
public function normalizeBindParamType ( $ value ) : int { switch ( true ) { case is_int ( $ value ) : return PDO :: PARAM_INT ; break ; case is_bool ( $ value ) : return PDO :: PARAM_BOOL ; break ; case null === $ value : return PDO :: PARAM_NULL ; break ; case is_string ( $ value ) : return PDO :: PARAM_STR ; break ; default : return PDO :: PARAM_STMT ; break ; } } 
protected function writeConnect ( ) : PDO { return $ this -> connect = $ this -> commonConnect ( $ this -> option [ 'master' ] , IConnect :: MASTER , true ) ; } 
protected function readConnect ( ) : PDO { if ( false === $ this -> option [ 'distributed' ] || empty ( $ this -> option [ 'slave' ] ) ) { return $ this -> writeConnect ( ) ; } if ( count ( $ this -> connects ) <= 1 ) { foreach ( $ this -> option [ 'slave' ] as $ read ) { $ this -> commonConnect ( $ read , null ) ; } if ( 0 === count ( $ this -> connects ) ) { return $ this -> writeConnect ( ) ; } } $ connects = $ this -> connects ; if ( true === $ this -> option [ 'separate' ] && isset ( $ connects [ IConnect :: MASTER ] ) ) { unset ( $ connects [ IConnect :: MASTER ] ) ; } if ( ! $ connects ) { return $ this -> writeConnect ( ) ; } $ connects = array_values ( $ connects ) ; if ( 1 === count ( $ connects ) ) { return $ connects [ 0 ] ; } return $ this -> connect = $ connects [ floor ( mt_rand ( 0 , count ( $ connects ) - 1 ) ) ] ; } 
protected function commonConnect ( array $ option = [ ] , ? int $ linkid = null , bool $ throwException = false ) { if ( null === $ linkid ) { $ linkid = count ( $ this -> connects ) ; } if ( ! empty ( $ this -> connects [ $ linkid ] ) ) { return $ this -> connects [ $ linkid ] ; } try { $ connect = $ this -> connects [ $ linkid ] = new PDO ( $ this -> parseDsn ( $ option ) , $ option [ 'user' ] , $ option [ 'password' ] , $ option [ 'options' ] ) ; $ connect -> setAttribute ( PDO :: ATTR_ERRMODE , PDO :: ERRMODE_EXCEPTION ) ; return $ connect ; } catch ( PDOException $ e ) { if ( false === $ throwException ) { return false ; } throw $ e ; } } 
protected function bindParams ( array $ bindParams = [ ] ) : void { foreach ( $ bindParams as $ key => $ val ) { $ key = is_numeric ( $ key ) ? $ key + 1 : ':' . $ key ; if ( is_array ( $ val ) ) { $ param = $ val [ 1 ] ; $ val = $ val [ 0 ] ; } else { $ param = PDO :: PARAM_STR ; } $ this -> pdoStatement -> bindValue ( $ key , $ val , $ param ) ; } } 
protected function fetchResult ( ? int $ fetchStyle = null , $ fetchArgument = null , array $ ctorArgs = [ ] , bool $ procedure = false ) : array { if ( $ procedure ) { return $ this -> fetchProcedureResult ( $ fetchStyle , $ fetchArgument , $ ctorArgs ) ; } if ( null === $ fetchStyle ) { $ fetchStyle = PDO :: FETCH_OBJ ; } $ args = [ $ fetchStyle ] ; if ( $ fetchArgument ) { $ args [ ] = $ fetchArgument ; if ( $ ctorArgs ) { $ args [ ] = $ ctorArgs ; } } return $ this -> pdoStatement -> fetchAll ( ... $ args ) ; } 
protected function fetchProcedureResult ( ? int $ fetchStyle = null , $ fetchArgument = null , array $ ctorArgs = [ ] ) : array { $ result = [ ] ; do { try { $ result [ ] = $ tim = $ this -> fetchResult ( $ fetchStyle , $ fetchArgument , $ ctorArgs ) ; } catch ( PDOException $ e ) { } } while ( $ this -> pdoStatement -> nextRowset ( ) ) ; return $ result ; } 
protected function setLastSql ( string $ sql , array $ bindParams = [ ] ) : void { $ this -> sql = $ sql ; $ this -> bindParams = $ bindParams ; $ this -> handleDispatch ( $ sql , $ bindParams ) ; } 
protected function handleDispatch ( string $ sql , array $ bindParams = [ ] ) : void { if ( $ this -> dispatch ) { $ this -> dispatch -> handle ( IConnect :: SQL_EVENT , $ sql , $ bindParams ) ; } } 
protected function createSavepoint ( string $ savepointName ) : void { $ this -> setLastSql ( $ sql = 'SAVEPOINT ' . $ savepointName ) ; $ this -> pdo ( true ) -> exec ( $ sql ) ; } 
protected function rollbackSavepoint ( string $ savepointName ) { $ this -> setLastSql ( $ sql = 'ROLLBACK TO SAVEPOINT ' . $ savepointName ) ; $ this -> pdo ( true ) -> exec ( $ sql ) ; } 
protected function needReconnect ( PDOException $ e ) : bool { 
protected function pdoException ( PDOException $ e ) : void { $ message = $ e -> getMessage ( ) ; 
public function encrypt ( string $ value , int $ expiry = 0 ) : string { $ iv = $ this -> createIv ( ) ; $ value = $ this -> packData ( $ value , $ expiry , $ iv ) ; return $ this -> encryptData ( $ value , $ iv ) ; } 
public function decrypt ( string $ value ) : string { if ( false === ( $ value = $ this -> decryptData ( $ value ) ) ) { return '' ; } list ( $ data , $ iv ) = $ value ; return $ this -> validateData ( $ data , $ iv ) ; } 
protected function packData ( string $ value , int $ expiry , string $ iv ) : string { $ data = [ $ this -> normalizeExpiry ( $ expiry ) , base64_encode ( $ value ) , base64_encode ( $ iv ) , $ this -> normalizeSign ( $ value ) , ] ; return implode ( "\t" , $ data ) ; } 
protected function unpackData ( string $ value ) { $ data = explode ( "\t" , $ value ) ; if ( 4 !== count ( $ data ) ) { return false ; } $ key = [ 'expiry' , 'value' , 'iv' , 'sign' ] ; return array_combine ( $ key , $ data ) ; } 
protected function encryptData ( string $ value , string $ iv ) : string { $ value = openssl_encrypt ( $ value , $ this -> cipher , $ this -> key , OPENSSL_RAW_DATA , $ iv ) ; if ( false === $ value ) { throw new InvalidArgumentException ( 'Encrypt the data failed.' ) ; 
protected function decryptData ( string $ value ) { if ( false === ( $ value = base64_decode ( $ value , true ) ) ) { return false ; } if ( false === ( $ value = $ this -> unpackDataWithIv ( $ value ) ) ) { return false ; } $ data = openssl_decrypt ( $ value [ 'value' ] , $ this -> cipher , $ this -> key , OPENSSL_RAW_DATA , $ value [ 'iv' ] ) ; if ( false === $ data ) { throw new InvalidArgumentException ( 'Decrypt the data failed.' ) ; } return [ $ data , base64_encode ( $ value [ 'iv' ] ) ] ; } 
protected function packDataWithIv ( string $ value , string $ iv ) : string { return base64_encode ( base64_encode ( $ value ) . "\t" . base64_encode ( $ iv ) ) ; } 
protected function unpackDataWithIv ( string $ value ) { $ data = explode ( "\t" , $ value ) ; if ( 2 !== count ( $ data ) ) { return false ; } $ key = [ 'value' , 'iv' ] ; $ data [ 0 ] = base64_decode ( $ data [ 0 ] , true ) ; $ data [ 1 ] = base64_decode ( $ data [ 1 ] , true ) ; return array_combine ( $ key , $ data ) ; } 
protected function normalizeSign ( string $ value ) : string { if ( ! $ this -> rsaPrivate ) { return '' ; } try { $ rsaPrivate = openssl_pkey_get_private ( $ this -> rsaPrivate ) ; if ( openssl_sign ( $ value , $ sign , $ rsaPrivate ) ) { return base64_encode ( $ sign ) ; } 
protected function validateCipher ( string $ cipher ) : void { if ( ! in_array ( $ cipher , openssl_get_cipher_methods ( ) , true ) ) { $ e = sprintf ( 'Encrypt cipher `%s` was not found.' , $ cipher ) ; throw new InvalidArgumentException ( $ e ) ; } } 
protected function validateData ( string $ data , string $ iv ) : string { if ( false === ( $ data = $ this -> unpackData ( $ data ) ) ) { return '' ; } if ( $ data [ 'iv' ] !== $ iv || ( '0000000000' !== $ data [ 'expiry' ] && time ( ) > $ data [ 'expiry' ] ) ) { return '' ; } $ result = base64_decode ( $ data [ 'value' ] , true ) ? : false ; if ( false === $ result ) { return '' ; } return $ this -> validateSign ( $ result , $ data [ 'sign' ] ) ; } 
protected function validateSign ( string $ value , string $ sign ) : string { if ( ! $ this -> rsaPublic ) { return $ value ; } try { $ rsaPublic = openssl_pkey_get_public ( $ this -> rsaPublic ) ; if ( 1 === openssl_verify ( $ value , base64_decode ( $ sign , true ) , $ rsaPublic ) ) { return $ value ; } 
protected function setRouterAndRequest ( IRouter $ router , IRequest $ request ) : void { $ this -> request = $ request ; $ this -> router = $ router ; } 
protected function matchePathInfo ( ) : string { $ pathInfo = $ this -> getPathInfo ( ) ; 
protected function matcheBasePaths ( string $ pathInfo ) : array { $ middlewares = [ ] ; foreach ( $ this -> router -> getBasePaths ( ) as $ item => $ option ) { if ( '*' === $ item ) { if ( isset ( $ option [ 'middlewares' ] ) ) { $ middlewares = $ option [ 'middlewares' ] ; } } elseif ( preg_match ( $ item , $ pathInfo , $ matches ) ) { if ( isset ( $ option [ 'middlewares' ] ) ) { $ middlewares = $ this -> mergeMiddlewares ( $ middlewares , $ option [ 'middlewares' ] ) ; } break ; } } return $ middlewares ; } 
protected function matcheGroupPaths ( string $ pathInfo , array $ middlewares ) : array { foreach ( $ this -> router -> getGroupPaths ( ) as $ item => $ option ) { if ( 0 === strpos ( $ pathInfo , $ item ) ) { $ pathInfo = substr ( $ pathInfo , strlen ( $ item ) ) ; if ( isset ( $ option [ 'middlewares' ] ) ) { $ middlewares = $ this -> mergeMiddlewares ( $ middlewares , $ option [ 'middlewares' ] ) ; } break ; } } return [ $ pathInfo , $ middlewares ] ; } 
public function dispatch ( IRequest $ request ) : IResponse { $ this -> request = $ request ; return $ this -> dispatchToRoute ( $ request ) ; } 
public function setPreRequestMatched ( IRequest $ request , array $ matchedData ) : void { $ this -> preRequestMatched [ spl_object_id ( $ request ) ] = $ matchedData ; } 
public function throughMiddleware ( IRequest $ passed , array $ passedExtend = [ ] ) : void { $ method = ! $ passedExtend ? 'handle' : 'terminate' ; $ middlewares = $ this -> matchedMiddlewares ( ) ; if ( empty ( $ middlewares [ $ method ] ) ) { return ; } ( new Pipeline ( $ this -> container ) ) -> send ( [ $ passed ] ) -> send ( $ passedExtend ) -> through ( $ middlewares [ $ method ] ) -> then ( ) ; } 
public function setControllerDir ( string $ controllerDir ) : void { $ controllerDir = str_replace ( '/' , '\\' , $ controllerDir ) ; $ this -> controllerDir = $ controllerDir ; } 
public function mergeMiddlewares ( array $ middlewares , array $ newMiddlewares ) : array { return [ 'handle' => array_unique ( array_merge ( $ middlewares [ 'handle' ] ?? [ ] , $ newMiddlewares [ 'handle' ] ?? [ ] ) ) , 'terminate' => array_unique ( array_merge ( $ middlewares [ 'terminate' ] ?? [ ] , $ newMiddlewares [ 'terminate' ] ?? [ ] ) ) , ] ; } 
protected function matchRouter ( ) { $ this -> initRequest ( ) ; $ this -> resolveMatchedData ( $ dataPathInfo = $ this -> normalizeMatchedData ( 'PathInfo' ) ) ; if ( false === ( $ bind = $ this -> normalizeRouterBind ( ) ) ) { $ bind = $ this -> annotationRouterBind ( $ dataPathInfo ) ; } return $ bind ; } 
protected function annotationRouterBind ( array $ dataPathInfo ) { $ data = $ this -> normalizeMatchedData ( 'Annotation' ) ; if ( ! $ data ) { $ data = $ dataPathInfo ; } else { $ this -> initRequest ( ) ; } $ this -> resolveMatchedData ( $ data ) ; return $ this -> findRouterBind ( ) ; } 
protected function resolveMatchedData ( array $ data ) : void { $ data = $ this -> mergeMatchedData ( $ data , $ this -> preRequestMatched [ spl_object_id ( $ this -> request ) ] ?? [ ] ) ; if ( ! $ data [ IRouter :: APP ] ) { $ data [ IRouter :: APP ] = self :: DEFAULT_APP ; } $ this -> matchedData = $ data ; } 
protected function mergeMatchedData ( array $ before , array $ after ) : array { $ result = [ ] ; foreach ( self :: MATCHED as $ key ) { if ( self :: MIDDLEWARES === $ key ) { $ result [ $ key ] = $ this -> mergeMiddlewares ( $ before [ $ key ] ?? [ ] , $ after [ $ key ] ?? [ ] ) ; } elseif ( in_array ( $ key , [ self :: PARAMS , self :: VARS ] , true ) ) { $ result [ $ key ] = array_merge ( $ before [ $ key ] ?? [ ] , $ after [ $ key ] ?? [ ] ) ; } else { $ result [ $ key ] = $ after [ $ key ] ?? $ before [ $ key ] ?? null ; } } return $ result ; } 
protected function normalizeMatchedData ( string $ matche ) : array { $ matche = __NAMESPACE__ . '\\Match\\' . $ matche ; return ( new $ matche ( ) ) -> matche ( $ this , $ this -> request ) ; } 
protected function runRoute ( IRequest $ request , callable $ bind ) : IResponse { $ this -> throughMiddleware ( $ this -> request ) ; $ response = $ this -> container -> call ( $ bind , $ this -> matchedVars ( ) ) ; if ( ! ( $ response instanceof IResponse ) ) { $ response = new Response ( $ response ) ; } return $ response ; } 
protected function makeRouterNode ( ) : string { if ( $ matchedBind = $ this -> matchedBind ( ) ) { return $ matchedBind ; } return $ this -> matchedApp ( ) . '\\' . $ this -> parseControllerDir ( ) . '\\' . $ this -> matchedController ( ) . '::' . $ this -> matchedAction ( ) . '()' ; } 
protected function parseControllerDir ( ) : string { $ result = $ this -> getControllerDir ( ) ; if ( $ this -> matchedPrefix ( ) ) { $ result .= '\\' . $ this -> matchedPrefix ( ) ; } return $ result ; } 
protected function completeRequest ( ) : void { $ this -> pathinfoRestful ( ) ; $ this -> container -> instance ( 'app_name' , $ this -> matchedApp ( ) ) ; $ this -> request -> params -> add ( $ this -> matchedParams ( ) ) ; } 
protected function pathinfoRestful ( ) : void { if ( ! empty ( $ this -> matchedData [ static :: ACTION ] ) ) { return ; } switch ( $ this -> request -> getMethod ( ) ) { 
protected function parseMatchedBind ( ) { if ( $ matchedBind = $ this -> matchedBind ( ) ) { if ( false !== strpos ( $ matchedBind , '@' ) ) { list ( $ bindClass , $ method ) = explode ( '@' , $ matchedBind ) ; if ( ! class_exists ( $ bindClass ) ) { return false ; } $ controller = $ this -> container -> make ( $ bindClass ) ; } else { if ( ! class_exists ( $ matchedBind ) ) { return false ; } $ controller = $ this -> container -> make ( $ matchedBind ) ; $ method = 'handle' ; } } else { $ matchedApp = $ this -> matchedApp ( ) ; $ matchedController = $ this -> matchedController ( ) ; $ matchedAction = $ this -> matchedAction ( ) ; 
protected function normalizeForSubdir ( string $ className , bool $ forAction = false ) : string { if ( false === strpos ( $ className , ':' ) ) { return $ className ; } $ className = preg_replace_callback ( '/:([a-zA-Z])/' , function ( array $ matches ) use ( $ forAction ) { return false === $ forAction ? '\\' . ucfirst ( $ matches [ 1 ] ) : ucfirst ( $ matches [ 1 ] ) ; } , $ className ) ; return str_replace ( '\\\\' , '\\' , $ className ) ; } 
protected function matchedPrefix ( ) : ? string { $ prefix = $ this -> matchedData [ static :: PREFIX ] ; if ( ! $ prefix || is_scalar ( $ prefix ) ) { return $ prefix ; } $ prefix = array_map ( function ( $ item ) { return $ this -> convertMatched ( ucfirst ( $ item ) ) ; } , $ prefix ) ; return $ this -> matchedData [ static :: PREFIX ] = implode ( '\\' , $ prefix ) ; } 
protected function convertMatched ( string $ matched ) : string { if ( false !== strpos ( $ matched , '-' ) ) { $ matched = str_replace ( '-' , '_' , $ matched ) ; } if ( false !== strpos ( $ matched , '_' ) ) { $ matched = '_' . str_replace ( '_' , ' ' , $ matched ) ; $ matched = ltrim ( str_replace ( ' ' , '' , ucwords ( $ matched ) ) , '_' ) ; } return $ matched ; } 
public function notify ( ... $ args ) { $ this -> notifyArgs = $ args ; foreach ( $ this -> observers as $ observer ) { $ observer -> update ( $ this ) ; } } 
public function register ( $ observer ) : void { if ( $ observer instanceof Closure ) { $ observer = new Observer ( $ observer ) ; } else { if ( is_string ( $ observer ) && is_string ( $ observer = $ this -> container -> make ( $ observer ) ) ) { throw new InvalidArgumentException ( sprintf ( 'Observer `%s` is invalid.' , $ observer ) ) ; } if ( ! ( $ observer instanceof SplObserver ) ) { if ( ! is_callable ( [ $ observer , 'handle' ] ) ) { throw new InvalidArgumentException ( sprintf ( 'Observer `%s` is invalid.' , get_class ( $ observer ) ) ) ; } $ observer = new Observer ( Closure :: fromCallable ( [ $ observer , 'handle' ] ) ) ; } } $ this -> attach ( $ observer ) ; } 
public function createResponse ( ResponseInterface $ psrResponse ) : IResponse { $ response = new Response ( $ psrResponse -> getBody ( ) -> __toString ( ) , $ psrResponse -> getStatusCode ( ) , $ psrResponse -> getHeaders ( ) ) ; $ response -> setProtocolVersion ( $ psrResponse -> getProtocolVersion ( ) ) ; foreach ( $ psrResponse -> getHeader ( 'Set-Cookie' ) as $ cookie ) { $ response -> setCookie ( ... $ this -> createCookie ( $ cookie ) ) ; } return $ response ; } 
protected function getFiles ( array $ uploadedFiles , string $ parent = '' ) : array { $ files = [ ] ; foreach ( $ uploadedFiles as $ key => $ value ) { $ key = ( $ parent ? $ parent . '\\' : '' ) . $ key ; if ( $ value instanceof UploadedFileInterface ) { $ files [ $ key ] = $ this -> createUploadedFile ( $ value ) ; } else { $ files = array_merge ( $ files , $ this -> getFiles ( $ value , $ key ) ) ; } } return $ files ; } 
protected function createUploadedFile ( UploadedFileInterface $ psrUploadedFile ) : UploadedFile { $ temporaryPath = '' ; $ clientFileName = '' ; if ( UPLOAD_ERR_NO_FILE !== $ psrUploadedFile -> getError ( ) ) { $ temporaryPath = $ this -> getTemporaryPath ( ) ; $ psrUploadedFile -> moveTo ( $ temporaryPath ) ; $ clientFileName = $ psrUploadedFile -> getClientFilename ( ) ; } return new UploadedFile ( $ temporaryPath , $ clientFileName ? : '' , $ psrUploadedFile -> getClientMediaType ( ) , $ psrUploadedFile -> getError ( ) ) ; } 
protected function createCookie ( string $ cookie ) : array { foreach ( explode ( ';' , $ cookie ) as $ part ) { $ part = trim ( $ part ) ; $ data = explode ( '=' , $ part , 2 ) ; $ name = $ data [ 0 ] ; $ value = isset ( $ data [ 1 ] ) ? trim ( $ data [ 1 ] , " \n\r\t\0\x0B\"" ) : null ; if ( ! isset ( $ cookieName ) ) { $ cookieName = $ name ; $ cookieValue = $ value ; continue ; } if ( 'expires' === strtolower ( $ name ) && null !== $ value ) { $ cookieExpire = new DateTime ( $ value ) ; continue ; } if ( 'path' === strtolower ( $ name ) && null !== $ value ) { $ cookiePath = $ value ; continue ; } if ( 'domain' === strtolower ( $ name ) && null !== $ value ) { $ cookieDomain = $ value ; continue ; } if ( 'secure' === strtolower ( $ name ) ) { $ cookieSecure = true ; continue ; } if ( 'httponly' === strtolower ( $ name ) ) { $ cookieHttpOnly = true ; continue ; } } if ( ! isset ( $ cookieName ) ) { throw new InvalidArgumentException ( 'The value of the Set-Cookie header is malformed.' ) ; } return [ $ cookieName , $ cookieValue , [ 'expire' => $ cookieExpire ?? 0 , 'path' => $ cookiePath ?? '/' , 'domain' => $ cookieDomain ?? null , 'secure' => isset ( $ cookieSecure ) , 'httponly' => isset ( $ cookieHttpOnly ) , ] , ] ; } 
public function handle ( Select $ select , IEntity $ entity ) : void { call_user_func ( $ this -> handle , $ select , $ entity ) ; } 
public function and ( ISpecification $ spec ) : ISpecification { return new self ( function ( IEntity $ entity ) use ( $ spec ) : bool { return $ this -> isSatisfiedBy ( $ entity ) && $ spec -> isSatisfiedBy ( $ entity ) ; } , function ( Select $ select , IEntity $ entity ) use ( $ spec ) { $ this -> handle ( $ select , $ entity ) ; $ spec -> handle ( $ select , $ entity ) ; } ) ; } 
public function not ( ) : ISpecification { return new self ( function ( IEntity $ entity ) : bool { return ! $ this -> isSatisfiedBy ( $ entity ) ; } , $ this -> handle ) ; } 
public static function create ( $ file = null , int $ status = 200 , array $ headers = [ ] , ? string $ contentDisposition = null , bool $ autoEtag = false , bool $ autoLastModified = true ) : IResponse { return new static ( $ file , $ status , $ headers , $ contentDisposition , $ autoEtag , $ autoLastModified ) ; } 
public function setFile ( $ file , ? string $ contentDisposition = null , bool $ autoEtag = false , bool $ autoLastModified = true ) : IResponse { if ( $ this -> checkFlowControl ( ) ) { return $ this ; } if ( ! $ file instanceof File ) { if ( $ file instanceof SplFileInfo || $ file instanceof SplFileObject ) { $ file = new File ( $ file -> getPathname ( ) ) ; } else { if ( ! is_readable ( $ file ) ) { throw new FileException ( 'File must be readable.' ) ; } $ file = new File ( ( string ) $ file ) ; } } if ( ! $ file -> isReadable ( ) ) { throw new FileException ( 'File must be readable.' ) ; } $ this -> file = $ file ; if ( $ autoEtag ) { $ this -> setAutoEtag ( ) ; } if ( $ autoLastModified ) { $ this -> setAutoLastModified ( ) ; } if ( $ contentDisposition ) { $ this -> setContentDisposition ( $ contentDisposition ) ; } return $ this ; } 
public function setAutoLastModified ( ) : IResponse { if ( $ this -> checkFlowControl ( ) ) { return $ this ; } $ this -> setLastModified ( DateTime :: createFromFormat ( 'U' , ( string ) $ this -> file -> getMTime ( ) ) ) ; return $ this ; } 
public function setAutoEtag ( ) : IResponse { if ( $ this -> checkFlowControl ( ) ) { return $ this ; } $ etag = base64_encode ( hash_file ( 'sha256' , $ this -> file -> getPathname ( ) , true ) ) ; $ this -> setEtag ( $ etag ) ; return $ this ; } 
public function setContent ( $ content ) : IResponse { if ( $ this -> checkFlowControl ( ) ) { return $ this ; } if ( null !== $ content ) { throw new LogicException ( 'The content cannot be set on a FileResponse instance.' ) ; } return $ this ; } 
public function setContentDisposition ( string $ disposition , string $ filename = '' ) : IResponse { if ( $ this -> checkFlowControl ( ) ) { return $ this ; } if ( '' === $ filename ) { $ filename = $ this -> file -> getFilename ( ) ; } if ( ! in_array ( $ disposition , [ ResponseHeaderBag :: DISPOSITION_ATTACHMENT , ResponseHeaderBag :: DISPOSITION_INLINE , ] , true ) ) { throw new InvalidArgumentException ( 'The disposition type is invalid.' ) ; } $ this -> headers -> set ( 'Content-Disposition' , sprintf ( '%s; filename="%s"' , $ disposition , str_replace ( '"' , '\\"' , basename ( $ filename ) ) ) ) ; return $ this ; } 
public function sendContent ( ) : IResponse { if ( $ this -> checkFlowControl ( ) ) { return $ this ; } if ( ! $ this -> isSuccessful ( ) ) { return parent :: sendContent ( ) ; } $ out = fopen ( 'php://output' , 'w' ) ; $ file = fopen ( $ this -> file -> getPathname ( ) , 'r' ) ; stream_copy_to_stream ( $ file , $ out ) ; fclose ( $ out ) ; fclose ( $ file ) ; return $ this ; } 
public function setEntity ( string $ entity ) : self { $ this -> entity = $ entity ; $ this -> message = sprintf ( 'Entity `%s` was not found.' , $ entity ) ; return $ this ; } 
public function handle ( Closure $ next , IRequest $ request ) : void { $ this -> startSession ( $ request ) ; $ next ( $ request ) ; } 
public function terminate ( Closure $ next , IRequest $ request , IResponse $ response ) : void { $ this -> setPrevUrl ( $ request ) ; $ this -> saveSession ( ) ; if ( ! $ this -> getSessionId ( $ request ) ) { $ response -> setCookie ( $ this -> manager -> getName ( ) , $ this -> manager -> getId ( ) , [ 'expire' => $ this -> getSessionExpire ( ) ] ) ; } $ next ( $ request , $ response ) ; } 
protected function startSession ( IRequest $ request ) : void { $ this -> manager -> start ( $ this -> getSessionId ( $ request ) ) ; } 
protected function getSessionId ( IRequest $ request ) : ? string { return $ request -> cookies -> get ( $ this -> manager -> getName ( ) , null ) ; } 
public function make ( array $ datas = [ ] , array $ rules = [ ] , array $ names = [ ] , array $ messages = [ ] ) : IValidator { $ validator = new Validator ( $ datas , $ rules , $ names , $ messages ) ; $ validator -> setContainer ( $ this -> container ) ; return $ validator ; } 
public static function initMessages ( ) : void { Validator :: initMessages ( [ 'required' => __ ( '{field} 不能为空'), 'number' => __ ( '{field} 必须是数字'), 'float' => __ ( '{field} 必须是浮点数'), 'double' => __ ( '{field} 必须是双精度浮点数'), 'boolean' => __ ( '{field} 必须是布尔值'), 'array' => __ ( '{field} 必须是数组'), 'accepted' => __ ( '{field} 必须是 yes、on、true 或者 1'), 'date' => __ ( '{field} 不是正确的日期格式'), 'date_format' => __ ( '{field} 必须使用日期格式 {rule}'), 'timezone' => __ ( '{field} 不是正确的时区'), 'alpha' => __ ( '{field} 只能是字母'), 'alpha_upper' => __ ( '{field} 只能是大写字母'), 'alpha_lower' => __ ( '{field} 只能是小写字母'), 'alpha_num' => __ ( '{field} 只能是字母和数字'), 'alpha_dash' => __ ( '{field} 只能是字母、数字、短横线和下划线'), 'chinese' => __ ( '{field} 只能是汉字'), 'chinese_alpha_num' => __ ( '{field} 只能是汉字、字母、数字'), 'chinese_alpha_dash' => __ ( '{field} 只能是汉字、字母、数字、短横线和下划线'), 'url' => __ ( '{field} 不是有效的 URL 地址'), 'active_url' => __ ( '{field} 不是有效的域名或者 IP'), 'ip' => __ ( '{field} 不是有效的 IP 地址'), 'ipv4' => __ ( '{field} 不是有效的 IPV4 地址'), 'ipv6' => __ ( '{field} 不是有效的 IPV6 地址'), 'in' => __ ( '{field} 必须在 {rule} 范围内'), 'not_in' => __ ( '{field} 不能在 {rule} 范围内'), 'between' => __ ( '{field} 只能在 {rule} 和 {rule1} 之间，不包含等于'), 'not_between' => __ ( '{field} 不在 {rule} 和 {rule1} 之间，不包含等于'), 'between_equal' => __ ( '{field} 只能在 {rule} 和 {rule1} 之间，包含等于'), 'not_between_equal' => __ ( '{field} 不在 {rule} 和 {rule1} 之间，包含等于'), 'greater_than' => __ ( '{field} 必须大于 {rule}'), 'equal_greater_than' => __ ( '{field} 必须大于等于 {rule}'), 'less_than' => __ ( '{field} 必须小于 {rule}'), 'equal_less_than' => __ ( '{field} 必须小于等于 {rule}'), 'equal' => __ ( '{field} 必须等于 {rule}'), 'not_equal' => __ ( '{field} 不能等于 {rule}'), 'equal_to' => __ ( '{field} 必须等于字段 {rule}'), 'different' => __ ( '{field} 不能等于字段 {rule}'), 'same' => __ ( '{field} 必须完全等于 {rule}'), 'not_same' => __ ( '{field} 不能完全等于 {rule}'), 'empty' => __ ( '{field} 必须为空'), 'not_empty' => __ ( '{field} 不能为空'), 'null' => __ ( '{field} 必须 null'), 'not_null' => __ ( '{field} 不能为 null'), 'strlen' => __ ( '{field} 长度不符合要求 {rule}'), 'max' => __ ( '{field} 长度不能超过 {rule}'), 'min' => __ ( '{field} 长度不能小于 {rule}'), 'digit' => __ ( '{field} 字符串中的字符必须都是数字'), 'type' => __ ( '{field} 类型不符合要求 {rule}'), 'lower' => __ ( '{field} 必须全部是小写'), 'upper' => __ ( '{field} 必须全部是大写'), 'min_length' => __ ( '{field} 不满足最小长度 {rule}'), 'max_length' => __ ( '{field} 不满足最大长度 {rule}'), 'id_card' => __ ( '{field} 必须是有效的中国大陆身份证'), 'zip_code' => __ ( '{field} 必须是有效的中国邮政编码'), 'qq' => __ ( '{field} 必须是有效的 QQ 号码'), 'phone' => __ ( '{field} 必须是有效的电话号码或者手机号'), 'mobile' => __ ( '{field} 必须是有效的手机号'), 'telephone' => __ ( '{field} 必须是有效的电话号码'), 'email' => __ ( '{field} 必须为正确的电子邮件格式'), 'luhn' => __ ( '{field} 必须为正确的符合 luhn 格式算法银行卡'), 'after' => __ ( '{field} 日期不能小于 {rule}'), 'before' => __ ( '{field} 日期不能超过 {rule}'), 'allowed_ip' => __ ( '{field} 不允许的 IP 访问 {rule}'), 'deny_ip' => __ ( '{field} 禁止的 IP 访问 {rule}'), 'json' => __ ( '{field} 不是有效的 JSON'), 'unique' => __ ( '{field} 不能出现重复值'), ] ) ; } 
public function matche ( IRouter $ router , IRequest $ request ) : array { $ this -> setRouterAndRequest ( $ router , $ request ) ; return $ this -> matchMain ( ) ; } 
protected function matchMain ( ) : array { 
protected function matcheApp ( array $ path ) : array { $ result = [ ] ; if ( $ path && $ this -> isFindApp ( $ path [ 0 ] ) ) { $ result [ IRouter :: APP ] = substr ( array_shift ( $ path ) , 1 ) ; } if ( $ restfulResult = $ this -> matcheRestful ( $ path ) ) { return [ array_merge ( $ result , $ restfulResult ) , [ ] ] ; } if ( ! $ path ) { $ result [ IRouter :: CONTROLLER ] = IRouter :: DEFAULT_CONTROLLER ; } return [ $ result , $ path ] ; } 
protected function matcheMvc ( array $ path ) : array { $ result = [ ] ; if ( 1 === count ( $ path ) ) { $ result [ IRouter :: CONTROLLER ] = array_pop ( $ path ) ; } else { if ( $ path ) { $ result [ IRouter :: ACTION ] = array_pop ( $ path ) ; } if ( $ path ) { $ result [ IRouter :: CONTROLLER ] = array_pop ( $ path ) ; } if ( $ path ) { $ result [ IRouter :: PREFIX ] = $ path ; } } return $ result ; } 
protected function matcheRestful ( array $ path ) : array { $ restfulPath = implode ( '/' , $ path ) ; $ regex = '/^(\S+)\/(' . IRouter :: RESTFUL_REGEX . ')(\/*\S*)$/' ; if ( preg_match ( $ regex , $ restfulPath , $ matches ) ) { $ result [ IRouter :: CONTROLLER ] = $ matches [ 1 ] ; $ result [ IRouter :: PARAMS ] [ IRouter :: RESTFUL_ID ] = $ matches [ 2 ] ; if ( '' !== $ matches [ 3 ] ) { $ result [ IRouter :: ACTION ] = substr ( $ matches [ 3 ] , 1 ) ; } return $ result ; } return [ ] ; } 
protected function throttler ( ) : void { $ this -> container -> singleton ( 'throttler' , function ( IContainer $ container ) { return ( new Throttler ( $ container [ 'caches' ] -> connect ( $ container [ 'option' ] [ 'throttler\\driver' ] ) ) ) -> setRequest ( $ container [ 'request' ] ) ; } ) ; } 
public function find ( int $ id , array $ column = [ '*' ] ) : IEntity { return $ this -> entity -> find ( $ id , $ column ) ; } 
public function findOrFail ( int $ id , array $ column = [ '*' ] ) : IEntity { return $ this -> entity -> findOrFail ( $ id , $ column ) ; } 
public function findAll ( $ condition = null ) : Collection { $ select = $ this -> entity -> selfDatabaseSelect ( ) ; if ( $ condition ) { $ this -> normalizeCondition ( $ condition , $ select ) ; } return $ select -> findAll ( ) ; } 
public function findList ( $ condition , $ fieldValue , ? string $ fieldKey = null ) : array { $ select = $ this -> entity -> selfDatabaseSelect ( ) ; if ( $ condition ) { $ this -> normalizeCondition ( $ condition , $ select ) ; } return $ select -> list ( $ fieldValue , $ fieldKey ) ; } 
public function findCount ( $ condition = null , string $ field = '*' ) : int { $ select = $ this -> entity -> selfDatabaseSelect ( ) ; if ( $ condition ) { $ this -> normalizeCondition ( $ condition , $ select ) ; } return $ select -> findCount ( $ field ) ; } 
public function findPage ( int $ currentPage , int $ perPage = 10 , $ condition = null , bool $ flag = false , bool $ withTotal = true , string $ column = '*' ) : array { $ select = $ this -> entity -> selfDatabaseSelect ( ) ; if ( $ condition ) { $ this -> normalizeCondition ( $ condition , $ select ) ; } return $ select -> page ( $ currentPage , $ perPage , $ flag , $ withTotal , $ column ) ; } 
public function findPageHtml ( int $ currentPage , int $ perPage = 10 , $ condition = null , bool $ flag = false , string $ column = '*' , array $ option = [ ] ) : array { $ select = $ this -> entity -> selfDatabaseSelect ( ) ; if ( $ condition ) { $ this -> normalizeCondition ( $ condition , $ select ) ; } return $ select -> pageHtml ( $ currentPage , $ perPage , $ flag , $ column , $ option ) ; } 
public function findPageMacro ( int $ currentPage , int $ perPage = 10 , $ condition = null , bool $ flag = false , array $ option = [ ] ) : array { $ select = $ this -> entity -> selfDatabaseSelect ( ) ; if ( $ condition ) { $ this -> normalizeCondition ( $ condition , $ select ) ; } return $ select -> pageMacro ( $ currentPage , $ perPage , $ flag , $ option ) ; } 
public function findPagePrevNext ( int $ currentPage , int $ perPage = 10 , $ condition = null , bool $ flag = false , array $ option = [ ] ) : array { $ select = $ this -> entity -> selfDatabaseSelect ( ) ; if ( $ condition ) { $ this -> normalizeCondition ( $ condition , $ select ) ; } return $ select -> pagePrevNext ( $ currentPage , $ perPage , $ flag , $ option ) ; } 
public function condition ( $ condition ) : Select { $ select = $ this -> entity -> selfDatabaseSelect ( ) ; $ this -> normalizeCondition ( $ condition , $ select ) ; return $ select ; } 
protected function normalizeCondition ( $ condition , Select $ select ) : void { if ( is_string ( $ condition ) ) { $ select -> scope ( $ condition ) ; } elseif ( is_object ( $ condition ) && $ condition instanceof ISpecification ) { $ this -> normalizeSpec ( $ select , $ condition ) ; } elseif ( is_object ( $ condition ) && $ condition instanceof Closure ) { $ condition ( $ select , $ this -> entity ) ; } elseif ( is_array ( $ condition ) && count ( $ condition ) >= 2 ) { $ tmpCondition = array_shift ( $ condition ) ; $ scope = $ condition ; $ this -> normalizeCondition ( $ tmpCondition , $ select ) ; $ select -> scope ( $ scope ) ; } else { throw new InvalidArgumentException ( 'Invalid condition type.' ) ; } } 
protected function normalizeSpec ( Select $ select , ISpecification $ spec ) : void { if ( $ spec instanceof ISpecification && $ spec -> isSatisfiedBy ( $ this -> entity ) ) { $ spec -> handle ( $ select , $ this -> entity ) ; } } 
public function read ( array $ filenames ) : array { $ translations = new Translations ( ) ; foreach ( $ filenames as $ val ) { $ translations -> addFromPoFile ( $ val ) ; } $ result = json_decode ( $ translations -> toJsonString ( ) , true ) ; $ result = $ result [ 'messages' ] [ '' ] ?? [ ] ; $ result = array_map ( function ( $ item ) { return $ item [ 0 ] ; } , $ result ) ; return $ result ; } 
public function display ( string $ file , array $ vars = [ ] , ? string $ ext = null , bool $ display = true ) { 
protected function debug ( ) : void { $ this -> container -> singleton ( 'debug' , function ( IContainer $ container ) { return new Debug ( $ container , $ container [ 'option' ] -> get ( 'debug\\' ) ) ; } ) ; } 
public function add ( array $ elements = [ ] ) : void { foreach ( $ elements as $ key => $ value ) { $ this -> set ( $ key , $ value ) ; } } 
public function addRelationCondition ( ) : void { if ( static :: $ relationCondition ) { $ this -> select -> join ( $ this -> middleEntity -> table ( ) , [ 'middle_' . $ this -> middleTargetKey => $ this -> middleTargetKey , 'middle_' . $ this -> middleSourceKey => $ this -> middleSourceKey , ] , [ $ this -> middleTargetKey => '{[' . $ this -> targetEntity -> table ( ) . '.' . $ this -> targetKey . ']}' , ] ) -> where ( $ this -> middleEntity -> table ( ) . '.' . $ this -> middleSourceKey , $ this -> getSourceValue ( ) ) -> asDefault ( ) -> asCollection ( false ) ; } } 
public function preLoadCondition ( array $ entitys ) : void { $ this -> select -> join ( $ this -> middleEntity -> table ( ) , [ 'middle_' . $ this -> middleTargetKey => $ this -> middleTargetKey , 'middle_' . $ this -> middleSourceKey => $ this -> middleSourceKey , ] , [ $ this -> middleTargetKey => '{[' . $ this -> targetEntity -> table ( ) . '.' . $ this -> targetKey . ']}' , ] ) -> whereIn ( $ this -> middleEntity -> table ( ) . '.' . $ this -> middleSourceKey , $ this -> getPreLoadSourceValue ( $ entitys ) ) -> asDefault ( ) -> asCollection ( false ) ; } 
public function matchPreLoad ( array $ entitys , collection $ result , string $ relation ) : array { $ maps = $ this -> buildMap ( $ result ) ; foreach ( $ entitys as $ entity ) { $ key = $ entity -> __get ( $ this -> sourceKey ) ; if ( isset ( $ maps [ $ key ] ) ) { $ entity -> withRelationProp ( $ relation , $ this -> targetEntity -> collection ( $ maps [ $ key ] ) ) ; } } return $ entitys ; } 
public function sourceQuery ( ) { $ tmps = $ this -> select -> findAll ( ) ; if ( ! $ tmps ) { return new Collection ( ) ; } $ result = [ ] ; $ middelClass = get_class ( $ this -> middleEntity ) ; $ targetClass = get_class ( $ this -> targetEntity ) ; foreach ( $ tmps as $ value ) { $ value = ( array ) $ value ; $ middleEnity = new $ middelClass ( [ $ this -> middleSourceKey => $ value [ 'middle_' . $ this -> middleSourceKey ] , $ this -> middleTargetKey => $ value [ 'middle_' . $ this -> middleTargetKey ] , ] ) ; unset ( $ value [ 'middle_' . $ this -> middleSourceKey ] , $ value [ 'middle_' . $ this -> middleTargetKey ] ) ; $ targetEntity = new $ targetClass ( $ value ) ; $ targetEntity -> withMiddle ( $ middleEnity ) ; $ result [ ] = $ targetEntity ; } return new Collection ( $ result , [ $ targetClass ] ) ; } 
protected function getPreLoadSourceValue ( array $ entitys ) : array { $ arr = [ ] ; foreach ( $ entitys as $ sourceEntity ) { $ arr [ ] = $ sourceEntity -> __get ( $ this -> sourceKey ) ; } return $ arr ; } 
protected function buildMap ( Collection $ result ) : array { $ maps = [ ] ; foreach ( $ result as $ entity ) { $ maps [ $ entity -> middle ( ) -> __get ( $ this -> middleSourceKey ) ] [ ] = $ entity ; } return $ maps ; } 
public function parseDsn ( array $ option ) : string { $ dsn = [ ] ; foreach ( [ 'Base' , 'Port' , 'Socket' , 'Charset' ] as $ method ) { $ dsn [ ] = $ this -> { 'parse' . $ method } ( $ option ) ; } return implode ( '' , $ dsn ) ; } 
public function tableNames ( string $ dbName , $ master = false ) : array { $ sql = 'SHOW TABLES FROM ' . $ this -> normalizeTableOrColumn ( $ dbName ) ; $ result = [ ] ; if ( ( $ tables = $ this -> query ( $ sql , [ ] , $ master , PDO :: FETCH_ASSOC ) ) ) { foreach ( $ tables as $ v ) { $ result [ ] = reset ( $ v ) ; } } unset ( $ tables , $ sql ) ; return $ result ; } 
public function tableColumns ( string $ tableName , $ master = false ) : array { $ sql = 'SHOW FULL COLUMNS FROM ' . $ this -> normalizeTableOrColumn ( $ tableName ) ; $ result = [ 'list' => [ ] , 'primary_key' => null , 'auto_increment' => null , ] ; if ( ( $ columns = $ this -> query ( $ sql , [ ] , $ master , PDO :: FETCH_ASSOC ) ) ) { foreach ( $ columns as $ column ) { $ tmp = [ ] ; $ tmp [ 'name' ] = $ column [ 'Field' ] ; if ( preg_match ( '/(.+)\((.+)\)/' , $ column [ 'Type' ] , $ matche ) ) { $ tmp [ 'type' ] = $ matche [ 1 ] ; $ tmp [ 'length' ] = $ matche [ 1 ] ; } else { $ tmp [ 'type' ] = $ column [ 'Type' ] ; $ tmp [ 'length' ] = null ; } $ tmp [ 'primary_key' ] = 'pri' === strtolower ( $ column [ 'Key' ] ) ; $ tmp [ 'auto_increment' ] = false !== strpos ( $ column [ 'Extra' ] , 'auto_increment' ) ; if ( null !== $ column [ 'Default' ] && 'null' !== strtolower ( $ column [ 'Default' ] ) ) { $ tmp [ 'default' ] = $ column [ 'Default' ] ; } else { $ tmp [ 'default' ] = null ; } $ tmp [ 'comment' ] = $ column [ 'Comment' ] ; $ result [ 'list' ] [ $ tmp [ 'name' ] ] = $ tmp ; if ( $ tmp [ 'auto_increment' ] ) { $ result [ 'auto_increment' ] = $ tmp [ 'name' ] ; } if ( $ tmp [ 'primary_key' ] ) { if ( ! is_array ( $ result [ 'primary_key' ] ) ) { $ result [ 'primary_key' ] = [ ] ; } $ result [ 'primary_key' ] [ ] = $ tmp [ 'name' ] ; } } } unset ( $ columns , $ sql ) ; return $ result ; } 
public function limitCount ( ? int $ limitCount = null , ? int $ limitOffset = null ) : string { if ( null !== $ limitOffset ) { $ sql = 'LIMIT ' . $ limitOffset ; if ( null !== $ limitCount ) { $ sql .= ',' . $ limitCount ; } else { $ sql .= ',999999999999' ; } return $ sql ; } if ( null !== $ limitCount ) { return 'LIMIT ' . $ limitCount ; } return '' ; } 
public function create ( ? string $ key = null , int $ limit = 60 , int $ time = 60 ) : IRateLimiter { $ key = $ this -> getRequestKey ( $ key ) ; if ( isset ( $ this -> rateLimiter [ $ key ] ) ) { return $ this -> rateLimiter [ $ key ] -> limit ( $ limit ) -> time ( $ time ) ; } return $ this -> rateLimiter [ $ key ] = new RateLimiter ( $ this -> cache , $ key , $ limit , $ time ) ; } 
public function getRequestKey ( ? string $ key = null ) : string { if ( ! $ key && ! $ this -> request ) { throw new RuntimeException ( 'Request is not set.' ) ; } return $ key ? : sha1 ( $ this -> request -> getClientIp ( ) . '@' . $ this -> request -> getRoot ( ) ) ; } 
public function handle ( IApp $ app ) : void { $ this -> app = $ app ; $ this -> line ( "<info>The QueryPHP server started:</info> <http://{$this->host()}:{$this->port()}>" ) ; $ this -> table ( [ 'key' , 'value' ] , [ [ 'php' , $ this -> php ( ) ] , [ 'server' , $ this -> server ( ) ] , ] ) ; passthru ( $ this -> normalizeCommand ( ) , $ status ) ; } 
protected function normalizeCommand ( ) : string { return sprintf ( '%s -S %s:%d -t %s' , escapeshellarg ( $ this -> php ( ) ) , $ this -> host ( ) , $ this -> port ( ) , escapeshellarg ( $ this -> server ( ) ) ) ; } 
protected function getOptions ( ) : array { return [ [ 'host' , null , Option :: VALUE_OPTIONAL , 'The host address to be listening on.' , '127.0.0.1' , ] , [ 'port' , null , Option :: VALUE_OPTIONAL , 'The port to be listening on.' , '9527' , ] , [ 'server' , null , Option :: VALUE_OPTIONAL , 'The server enter.' , null , ] , [ 'php' , null , Option :: VALUE_OPTIONAL , 'Where is php.' , ( new PhpExecutableFinder ( ) ) -> find ( false ) , ] , ] ; } 
public function call ( string $ call , array $ params = [ ] , array $ metas = [ ] ) : IResponse { $ transport = $ this -> makeTransport ( ) ; $ protocol = new TBinaryProtocol ( $ transport ) ; $ transport -> open ( ) ; $ response = $ this -> getResponseWithProtocol ( $ protocol , [ 'call' => $ call , 'params' => $ params , 'metas' => $ metas , ] ) ; $ transport -> close ( ) ; $ response = $ this -> normalizeResponse ( $ response ) ; return $ response ; } 
public function addMetas ( $ key , $ value = null ) { $ key = is_array ( $ key ) ? $ key : [ $ key => $ value , ] ; foreach ( $ key as $ k => $ v ) { $ this -> metas [ $ k ] = $ v ; } } 
protected function normalizeResponse ( Response $ response ) : IResponse { if ( $ this -> isJson ( $ response -> data ) ) { $ data = json_decode ( $ response -> data , true ) ; if ( isset ( $ data [ 'target_url' ] ) ) { return new RedirectResponse ( $ data [ 'target_url' ] , $ response -> status ) ; } return JsonResponse :: fromJsonString ( $ response -> data , $ response -> status ) ; } return new HttpResponse ( $ response -> data , $ response -> status ) ; } 
protected function getResponseWithProtocol ( TBinaryProtocol $ protocol , array $ data ) : Response { $ client = new ThriftClient ( $ protocol ) ; $ message = new Request ( $ data ) ; return $ client -> call ( $ message ) ; } 
public static function instance ( string $ table ) : IMeta { if ( ! isset ( static :: $ instances [ $ table ] ) ) { return static :: $ instances [ $ table ] = new static ( $ table ) ; } return static :: $ instances [ $ table ] ; } 
public static function resolveDatabase ( ) : DatabaseManager { if ( static :: $ resolveDatabase ) { return static :: $ resolveDatabase ; } if ( ! static :: $ databaseResolver && static :: lazyloadPlaceholder ( ) && ! static :: $ databaseResolver ) { throw new InvalidArgumentException ( 'Database resolver was not set.' ) ; } return static :: $ resolveDatabase = call_user_func ( static :: $ databaseResolver ) ; } 
public static function setDatabaseResolver ( ? Closure $ databaseResolver = null ) : void { static :: $ databaseResolver = $ databaseResolver ; if ( null === $ databaseResolver ) { static :: $ resolveDatabase = null ; } } 
public function setConnect ( $ connect = null ) : IMeta { $ this -> connect = self :: resolveDatabase ( ) -> connect ( $ connect ) ; return $ this ; } 
public function update ( array $ condition , array $ saveData ) : int { return $ this -> select ( ) -> where ( $ condition ) -> update ( $ saveData ) ; } 
protected function tokenPersistence ( array $ data , int $ loginTime = 0 ) : void { $ this -> setPersistence ( $ this -> getTokenName ( ) , json_encode ( $ data ) , $ loginTime ) ; } 
protected function tokenData ( ) : array { $ data = $ this -> getPersistence ( $ this -> getTokenName ( ) ) ; return $ data ? json_decode ( $ data , true ) : [ ] ; } 
public function handle ( IApp $ app ) : void { $ this -> app = $ app ; $ this -> extends = $ this -> extends ( ) ; $ this -> line ( 'Start to cache i18n.' ) ; list_directory ( $ app -> i18nPath ( ) , false , function ( $ item ) use ( $ app ) { if ( $ item -> isDir ( ) ) { $ i18n = $ item -> getFilename ( ) ; $ data = $ this -> data ( $ i18n ) ; $ cachePath = $ app -> i18nCachedPath ( $ i18n ) ; $ this -> writeCache ( $ cachePath , $ data ) ; $ this -> info ( sprintf ( 'I18n cache file %s cache successed.' , $ cachePath ) ) ; } } ) ; $ this -> info ( 'I18n cache files cache successed.' ) ; } 
protected function data ( string $ i18n ) : array { $ load = ( new Load ( [ $ this -> app -> i18nPath ( ) ] ) ) -> setI18n ( $ i18n ) -> addDir ( $ this -> extends ) ; return $ load -> loadData ( ) ; } 
protected function writeCache ( string $ cachePath , array $ data ) : void { $ content = '<?' . 'php /* ' . date ( 'Y-m-d H:i:s' ) . ' */ ?' . '>' . PHP_EOL . '<?' . 'php return ' . var_export ( $ data , true ) . '; ?' . '>' ; create_file ( $ cachePath , $ content ) ; } 
public function setOption ( string $ name , $ value ) : IRender { $ this -> option [ $ name ] = $ value ; return $ this ; } 
public function render ( array $ option = [ ] ) : string { if ( $ option ) { $ this -> option = array_merge ( $ this -> option , $ option ) ; $ this -> intOption ( ) ; } return preg_replace_callback ( '/{(.+?)}/' , function ( $ matches ) { return $ this -> { 'get' . ucwords ( $ matches [ 1 ] ) . 'Render' } ( ) ; } , $ this -> option [ 'template' ] ) ; } 
protected function getTotalRender ( ) : string { if ( ! $ this -> page -> canTotalRender ( ) ) { return '' ; } return sprintf ( '<span class="pagination-total">%s</span>' , __ ( '共 %d 条', $t h s ->pa ge ->ge tT otalRecord() ? : ) ) ; } 
protected function getMainRender ( ) : string { if ( ! $ this -> page -> canMainRender ( ) ) { return '' ; } $ result = '' ; for ( $ i = $ this -> page -> getPageStart ( ) ; $ i <= $ this -> page -> getPageEnd ( ) ; $ i ++ ) { $ active = $ this -> page -> getCurrentPage ( ) === $ i ; $ result .= sprintf ( '<li class="number%s"><a%s>%d</a></li>' , $ active ? ' active' : '' , $ active ? '' : sprintf ( ' href="%s"' , $ this -> replace ( $ i ) ) , $ i ) ; } return $ result ; } 
protected function getNextRender ( ) : string { if ( $ this -> page -> canNextRender ( ) ) { return sprintf ( '<button class="btn-next" ' . 'onclick="window.location.href=\'%s\';">&#8250;</button>' , $ this -> replace ( $ this -> page -> getCurrentPage ( ) + 1 ) ) ; } return '<button class="btn-next disabled">' . '&#8250;</button>' ; } 
protected function getLastRender ( ) : string { if ( $ this -> page -> isTotalMacro ( ) ) { return sprintf ( '<li class="btn-quicknext" ' . 'onclick="window.location.href=\'%s\';" ' . 'onmouseenter="this.innerHTML=\'&raquo;\';" ' . 'onmouseleave="this.innerHTML=\'...\';">...</li>' , $ this -> replace ( $ this -> page -> parseLastRenderNext ( ) ) ) ; } if ( $ this -> page -> canLastRender ( ) ) { return ( $ this -> page -> canLastRenderNext ( ) ? sprintf ( '<li class="btn-quicknext" ' . 'onclick="window.location.href=\'%s\';" ' . 'onmouseenter="this.innerHTML=\'&raquo;\';" ' . 'onmouseleave="this.innerHTML=\'...\';">...</li>' , $ this -> replace ( $ this -> page -> parseLastRenderNext ( ) ) ) : '' ) . sprintf ( '<li><a href="%s">%d</a></li>' , $ this -> replace ( $ this -> page -> getTotalPage ( ) ) , $ this -> page -> getTotalPage ( ) ) ; } return '' ; } 
public function start ( ? string $ sessionId = null ) : void { if ( $ this -> isStart ( ) ) { return ; } $ this -> setId ( $ sessionId ? : $ this -> option [ 'id' ] ) ; $ this -> loadData ( ) ; $ this -> started = true ; } 
public function save ( ) : void { if ( ! $ this -> isStart ( ) ) { throw new RuntimeException ( 'Session is not start yet.' ) ; } $ this -> unregisterFlash ( ) ; $ this -> connect -> write ( $ this -> getId ( ) , serialize ( $ this -> datas ) ) ; $ this -> started = false ; } 
public function set ( string $ name , $ value ) : void { $ name = $ this -> getNormalizeName ( $ name ) ; $ this -> datas [ $ name ] = $ value ; } 
public function put ( $ keys , $ value = null ) : void { if ( ! is_array ( $ keys ) ) { $ keys = [ $ keys => $ value , ] ; } foreach ( $ keys as $ item => $ value ) { $ this -> set ( $ item , $ value ) ; } } 
public function get ( string $ name , $ value = null ) { $ name = $ this -> getNormalizeName ( $ name ) ; return $ this -> datas [ $ name ] ?? $ value ; } 
public function delete ( string $ name ) : void { $ name = $ this -> getNormalizeName ( $ name ) ; if ( isset ( $ this -> datas [ $ name ] ) ) { unset ( $ this -> datas [ $ name ] ) ; } } 
public function has ( string $ name ) : bool { $ name = $ this -> getNormalizeName ( $ name ) ; return isset ( $ this -> datas [ $ name ] ) ; } 
public function flash ( string $ key , $ value ) : void { $ this -> set ( $ this -> flashDataKey ( $ key ) , $ value ) ; $ this -> mergeNewFlash ( [ $ key , ] ) ; $ this -> popOldFlash ( [ $ key , ] ) ; } 
public function flashs ( array $ flash ) : void { foreach ( $ flash as $ key => $ value ) { $ this -> flash ( $ key , $ value ) ; } } 
public function nowFlash ( string $ key , $ value ) : void { $ this -> set ( $ this -> flashDataKey ( $ key ) , $ value ) ; $ this -> mergeOldFlash ( [ $ key , ] ) ; } 
public function nowFlashs ( array $ flash ) : void { foreach ( $ flash as $ key => $ value ) { $ this -> nowFlash ( $ key , $ value ) ; } } 
public function rebuildFlash ( ) : void { $ this -> mergeNewFlash ( $ this -> get ( $ this -> flashOldKey ( ) , [ ] ) ) ; $ this -> set ( $ this -> flashOldKey ( ) , [ ] ) ; } 
public function getFlash ( string $ key , $ defaults = null ) { if ( false !== strpos ( $ key , '\\' ) ) { return $ this -> getPartData ( $ key , $ defaults , 'flash' ) ; } return $ this -> get ( $ this -> flashDataKey ( $ key ) , $ defaults ) ; } 
public function deleteFlash ( array $ keys ) : void { foreach ( $ keys as $ item ) { $ this -> delete ( $ this -> flashDataKey ( $ item ) ) ; } $ this -> mergeOldFlash ( $ keys ) ; $ this -> popNewFlash ( $ keys ) ; } 
public function unregisterFlash ( ) : void { $ arr = $ this -> get ( $ this -> flashNewKey ( ) , [ ] ) ; $ old = $ this -> get ( $ this -> flashOldKey ( ) , [ ] ) ; foreach ( $ old as $ item ) { $ this -> delete ( $ this -> flashDataKey ( $ item ) ) ; } $ this -> delete ( $ this -> flashNewKey ( ) ) ; $ this -> set ( $ this -> flashOldKey ( ) , $ arr ) ; unset ( $ arr , $ old ) ; } 
public function destroy ( ) : void { $ this -> clear ( ) ; $ this -> connect -> destroy ( $ this -> getId ( ) ) ; $ this -> id = null ; $ this -> started = false ; } 
public function setId ( ? string $ id = null ) : void { $ this -> id = $ id ? : $ this -> generateSessionId ( ) ; } 
protected function parseMicrotime ( ) : string { list ( $ usec , $ sec ) = explode ( ' ' , microtime ( ) ) ; return ( string ) ( ( float ) $ usec + ( float ) $ sec ) ; } 
protected function getPartData ( string $ key , $ defaults = null , ? string $ type = null ) { list ( $ key , $ name ) = explode ( '\\' , $ key ) ; if ( 'flash' === $ type ) { $ key = $ this -> flashDataKey ( $ key ) ; } $ value = $ this -> get ( $ key ) ; if ( is_array ( $ value ) ) { if ( ! strpos ( $ name , '.' ) ) { return array_key_exists ( $ name , $ value ) ? $ value [ $ name ] : $ defaults ; } $ parts = explode ( '.' , $ name ) ; foreach ( $ parts as $ part ) { if ( ! isset ( $ value [ $ part ] ) ) { return $ defaults ; } $ value = $ value [ $ part ] ; } return $ value ; } return $ defaults ; } 
protected function console ( array $ data ) : string { $ content = [ ] ; $ content [ ] = '<script type="text/javascript"> console.log( \'%cThe PHP Framework For Code Poem As Free As Wind %c(http: 
public function bootstrap ( ) : void { $ this -> setControllerDir ( ) ; $ this -> setMiddleware ( ) ; if ( $ this -> isRouterCached ( ) ) { $ this -> importCachedRouters ( ) ; } else { $ this -> loadRouters ( ) ; } } 
protected function setRoutersData ( array $ routers ) : void { $ this -> container [ 'router' ] -> setBasePaths ( $ routers [ 'base_paths' ] ) ; $ this -> container [ 'router' ] -> setGroupPaths ( $ routers [ 'group_paths' ] ) ; $ this -> container [ 'router' ] -> setGroups ( $ routers [ 'groups' ] ) ; $ this -> container [ 'router' ] -> setRouters ( $ routers [ 'routers' ] ) ; } 
protected function setControllerDir ( ) : void { if ( null !== $ this -> controllerDir ) { $ this -> container [ 'router' ] -> setControllerDir ( $ this -> controllerDir ) ; } } 
protected function setMiddleware ( ) : void { if ( null !== $ this -> middlewareGroups ) { $ this -> container [ 'router' ] -> setMiddlewareGroups ( $ this -> middlewareGroups ) ; } if ( null !== $ this -> middlewareAlias ) { $ this -> container [ 'router' ] -> setMiddlewareAlias ( $ this -> middlewareAlias ) ; } } 
public function handle ( IApp $ app ) : void { $ this -> app = $ app ; $ test = 2 === func_num_args ( ) ; if ( ! $ test ) { 
public function setErrorHandle ( int $ code , string $ description , ? string $ file = null , ? int $ line = null , $ context = null ) : void { 
public function registerShutdownFunction ( ) : void { if ( ( $ error = error_get_last ( ) ) && ! empty ( $ error [ 'type' ] ) ) { $ this -> setExceptionHandler ( $ this -> formatErrorException ( $ error ) ) ; } } 
public function setExceptionHandler ( Throwable $ e ) : void { if ( ! $ e instanceof Exception ) { $ e = new ErrorException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , E_ERROR , $ e -> getFile ( ) , $ e -> getLine ( ) , $ e -> getPrevious ( ) ) ; } try { $ this -> getRuntime ( ) -> report ( $ e ) ; 
protected function renderHttpResponse ( Exception $ e ) : void { $ this -> getRuntime ( ) -> render ( $ this -> app [ 'request' ] , $ e ) -> send ( ) ; } 
protected function formatErrorException ( array $ error ) : ErrorException { return new ErrorException ( ( string ) ( $ error [ 'message' ] ) , ( int ) ( $ error [ 'type' ] ) , 0 , ( string ) ( $ error [ 'file' ] ) , ( int ) ( $ error [ 'line' ] ) ) ; } 
protected function setPersistence ( string $ key , string $ value , int $ expire = 0 ) : void { $ this -> cache -> set ( $ key , $ value , [ 'expire' => $ expire ] ) ; } 
protected function getTokenNameFromRequest ( ) : string { $ token = $ this -> request -> query ( $ this -> option [ 'input_token' ] , '' ) ; if ( ! $ token ) { $ token = $ this -> request -> input ( $ this -> option [ 'input_token' ] , '' ) ; } return $ token ; } 
public function register ( ) : void { $ this -> httpServer ( ) ; $ this -> websocketServer ( ) ; $ this -> rpcServer ( ) ; $ this -> pool ( ) ; $ this -> rpc ( ) ; } 
protected function httpServer ( ) : void { $ this -> container -> singleton ( 'http.server' , function ( IContainer $ container ) { return new HttpServer ( $ container , array_merge ( $ container [ 'option' ] [ 'protocol\\server' ] , $ container [ 'option' ] [ 'protocol\\http' ] ) ) ; } ) ; } 
protected function websocketServer ( ) : void { $ this -> container -> singleton ( 'websocket.server' , function ( IContainer $ container ) { return new WebsocketServer ( $ container , array_merge ( $ container [ 'option' ] [ 'protocol\\server' ] , $ container [ 'option' ] [ 'protocol\\websocket' ] ) ) ; } ) ; } 
protected function rpcServer ( ) : void { $ this -> container -> singleton ( 'rpc.server' , function ( IContainer $ container ) { return new RpcServer ( $ container , array_merge ( $ container [ 'option' ] [ 'protocol\\server' ] , $ container [ 'option' ] [ 'protocol\\rpc' ] ) ) ; } ) ; } 
public function flush ( ) : void { $ this -> validateClosed ( ) ; if ( ! ( $ this -> entityCreates || $ this -> entityUpdates || $ this -> entityDeletes || $ this -> entityReplaces ) ) { return ; } $ this -> beginTransaction ( ) ; try { $ this -> handleRepository ( ) ; $ this -> commit ( ) ; } catch ( Throwable $ e ) { $ this -> close ( ) ; $ this -> rollBack ( ) ; throw $ e ; } } 
public function persistBefore ( IEntity $ entity , string $ method = 'save' ) : IUnitOfWork { return $ this -> persistEntity ( 'Before' , $ entity , $ method ) ; } 
public function persist ( IEntity $ entity , string $ method = 'save' ) : IUnitOfWork { return $ this -> persistEntity ( '' , $ entity , $ method ) ; } 
public function persisteAfter ( IEntity $ entity , string $ method = 'save' ) : IUnitOfWork { return $ this -> persistEntity ( 'After' , $ entity , $ method ) ; } 
public function removeBefore ( IEntity $ entity , int $ priority = 500 ) : IUnitOfWork { return $ this -> removeEntity ( 'Before' , $ entity , $ priority ) ; } 
public function remove ( IEntity $ entity , int $ priority = 500 ) : IUnitOfWork { return $ this -> removeEntity ( '' , $ entity , $ priority ) ; } 
public function removeAfter ( IEntity $ entity , int $ priority = 500 ) : IUnitOfWork { return $ this -> removeEntity ( 'After' , $ entity , $ priority ) ; } 
public function createBefore ( IEntity $ entity , int $ priority = 500 ) : IUnitOfWork { $ this -> createEntity ( $ entity ) ; $ id = spl_object_id ( $ entity ) ; $ this -> createsFlagBefore [ $ id ] = $ priority ; return $ this ; } 
public function create ( IEntity $ entity , int $ priority = 500 ) : IUnitOfWork { $ this -> createEntity ( $ entity ) ; $ id = spl_object_id ( $ entity ) ; $ this -> createsFlag [ $ id ] = $ priority ; return $ this ; } 
public function createAfter ( IEntity $ entity , int $ priority = 500 ) : IUnitOfWork { $ this -> createEntity ( $ entity ) ; $ id = spl_object_id ( $ entity ) ; $ this -> createsFlagAfter [ $ id ] = $ priority ; return $ this ; } 
public function created ( IEntity $ entity , int $ priority = 500 ) : bool { return isset ( $ this -> entityCreates [ spl_object_id ( $ entity ) ] ) ; } 
public function updateBefore ( IEntity $ entity , int $ priority = 500 ) : IUnitOfWork { $ this -> updateEntity ( $ entity ) ; $ id = spl_object_id ( $ entity ) ; $ this -> updatesFlagBefore [ $ id ] = $ priority ; return $ this ; } 
public function update ( IEntity $ entity , int $ priority = 500 ) : IUnitOfWork { $ this -> updateEntity ( $ entity ) ; $ id = spl_object_id ( $ entity ) ; $ this -> updatesFlag [ $ id ] = $ priority ; return $ this ; } 
public function updateAfter ( IEntity $ entity , int $ priority = 500 ) : IUnitOfWork { $ this -> updateEntity ( $ entity ) ; $ id = spl_object_id ( $ entity ) ; $ this -> updatesFlagAfter [ $ id ] = $ priority ; return $ this ; } 
public function replaceBefore ( IEntity $ entity , int $ priority = 500 ) : IUnitOfWork { $ this -> replaceEntity ( $ entity ) ; $ id = spl_object_id ( $ entity ) ; $ this -> replacesFlagBefore [ $ id ] = $ priority ; return $ this ; } 
public function replace ( IEntity $ entity , int $ priority = 500 ) : IUnitOfWork { $ this -> replaceEntity ( $ entity ) ; $ id = spl_object_id ( $ entity ) ; $ this -> replacesFlag [ $ id ] = $ priority ; return $ this ; } 
public function replaceAfter ( IEntity $ entity , int $ priority = 500 ) : IUnitOfWork { $ this -> replaceEntity ( $ entity ) ; $ id = spl_object_id ( $ entity ) ; $ this -> replacesFlagAfter [ $ id ] = $ priority ; return $ this ; } 
public function deleteBefore ( IEntity $ entity , int $ priority = 500 ) : IUnitOfWork { $ this -> deleteEntity ( $ entity ) ; $ id = spl_object_id ( $ entity ) ; $ this -> deletesFlagBefore [ $ id ] = $ priority ; return $ this ; } 
public function delete ( IEntity $ entity , int $ priority = 500 ) : IUnitOfWork { $ this -> deleteEntity ( $ entity ) ; $ id = spl_object_id ( $ entity ) ; $ this -> deletesFlag [ $ id ] = $ priority ; return $ this ; } 
public function deleteAfter ( IEntity $ entity , int $ priority = 500 ) : IUnitOfWork { $ this -> deleteEntity ( $ entity ) ; $ id = spl_object_id ( $ entity ) ; $ this -> deletesFlagAfter [ $ id ] = $ priority ; return $ this ; } 
public function registered ( IEntity $ entity ) : bool { $ id = spl_object_id ( $ entity ) ; return isset ( $ this -> entityCreates [ $ id ] ) || isset ( $ this -> entityUpdates [ $ id ] ) || isset ( $ this -> entityDeletes [ $ id ] ) || isset ( $ this -> entityReplaces [ $ id ] ) ; } 
public function refresh ( IEntity $ entity ) : IUnitOfWork { $ this -> validateClosed ( ) ; if ( self :: STATE_MANAGED !== $ this -> getEntityState ( $ entity ) ) { $ e = sprintf ( 'Entity `%s` was not managed.' , get_class ( $ entity ) ) ; throw new InvalidArgumentException ( $ e ) ; } $ this -> repository ( $ entity ) -> refresh ( $ entity ) ; return $ this ; } 
public function registerManaged ( IEntity $ entity ) : void { $ this -> entityStates [ spl_object_id ( $ entity ) ] = self :: STATE_MANAGED ; } 
public function transaction ( Closure $ action ) { $ this -> beginTransaction ( ) ; try { $ result = $ action ( $ this ) ; $ this -> flush ( ) ; $ this -> commit ( ) ; return $ result ; } catch ( Throwable $ e ) { $ this -> rollBack ( ) ; $ this -> close ( ) ; throw $ e ; } } 
public function clear ( ) : void { $ this -> entityCreates = [ ] ; $ this -> entityUpdates = [ ] ; $ this -> entityDeletes = [ ] ; $ this -> entityReplaces = [ ] ; $ this -> entityStates = [ ] ; $ this -> onCallbacks = [ ] ; $ this -> createsFlagBefore = [ ] ; $ this -> createsFlag = [ ] ; $ this -> createsFlagAfter = [ ] ; $ this -> replacesFlagBefore = [ ] ; $ this -> replacesFlag = [ ] ; $ this -> replacesFlagAfter = [ ] ; $ this -> updatesFlagBefore = [ ] ; $ this -> updatesFlag = [ ] ; $ this -> updatesFlagAfter = [ ] ; $ this -> deletesFlagBefore = [ ] ; $ this -> deletesFlag = [ ] ; $ this -> deletesFlagAfter = [ ] ; } 
public function on ( IEntity $ entity , Closure $ callbacks ) : void { $ this -> onCallbacks [ spl_object_id ( $ entity ) ] [ ] = $ callbacks ; } 
public function repository ( $ entity ) : IRepository { if ( is_string ( $ entity ) ) { $ entity = new $ entity ( ) ; } if ( defined ( get_class ( $ entity ) . '::REPOSITORY' ) ) { $ name = $ entity :: REPOSITORY ; $ repository = new $ name ( $ entity ) ; } else { $ repository = new Repository ( $ entity ) ; } return $ repository ; } 
public function getEntityState ( IEntity $ entity , ? int $ defaults = null ) : int { $ id = spl_object_id ( $ entity ) ; if ( isset ( $ this -> entityStates [ $ id ] ) ) { return $ this -> entityStates [ $ id ] ; } if ( null !== $ defaults ) { return $ defaults ; } if ( ! $ entity -> id ( ) ) { return self :: STATE_NEW ; } return self :: STATE_DETACHED ; } 
protected function persistEntity ( string $ position , IEntity $ entity , string $ method = 'save' ) : IUnitOfWork { $ this -> validateClosed ( ) ; $ id = spl_object_id ( $ entity ) ; $ entityState = $ this -> getEntityState ( $ entity , self :: STATE_NEW ) ; switch ( $ entityState ) { case self :: STATE_MANAGED : break ; case self :: STATE_NEW : $ this -> persistNewEntry ( $ position , $ method , $ entity ) ; break ; case self :: STATE_REMOVED : if ( isset ( $ this -> entityDeletes [ $ id ] ) ) { unset ( $ this -> entityDeletes [ $ id ] ) ; foreach ( [ 'deletesFlagBefore' , 'deletesFlag' , 'deletesFlagAfter' ] as $ flag ) { if ( isset ( $ this -> { $ flag } [ $ id ] ) ) { unset ( $ this -> { $ flag } [ $ id ] ) ; } } } $ this -> entityStates [ $ id ] = self :: STATE_MANAGED ; break ; case self :: STATE_DETACHED : default : $ e = sprintf ( 'Detached entity `%s` cannot be persist.' , get_class ( $ entity ) ) ; throw new InvalidArgumentException ( $ e ) ; } return $ this ; } 
protected function removeEntity ( string $ position , IEntity $ entity , int $ priority = 500 ) : IUnitOfWork { $ id = spl_object_id ( $ entity ) ; $ entityState = $ this -> getEntityState ( $ entity ) ; switch ( $ entityState ) { case self :: STATE_NEW : case self :: STATE_REMOVED : break ; case self :: STATE_MANAGED : $ this -> { 'delete' . $ position } ( $ entity , $ priority ) ; break ; case self :: STATE_DETACHED : default : $ e = sprintf ( 'Detached entity `%s` cannot be remove.' , get_class ( $ entity ) ) ; throw new InvalidArgumentException ( $ e ) ; } return $ this ; } 
protected function updateEntity ( IEntity $ entity ) : IUnitOfWork { $ this -> validateClosed ( ) ; $ id = spl_object_id ( $ entity ) ; if ( ! $ entity -> id ( ) ) { $ e = sprintf ( 'Entity `%s` has no identity for update.' , get_class ( $ entity ) ) ; throw new InvalidArgumentException ( $ e ) ; } if ( isset ( $ this -> entityDeletes [ $ id ] ) ) { $ e = sprintf ( 'Deleted entity `%s` cannot be added for update.' , get_class ( $ entity ) ) ; throw new InvalidArgumentException ( $ e ) ; } if ( isset ( $ this -> entityCreates [ $ id ] ) ) { $ e = sprintf ( 'Created entity `%s` cannot be added for update.' , get_class ( $ entity ) ) ; throw new InvalidArgumentException ( $ e ) ; } if ( isset ( $ this -> entityReplaces [ $ id ] ) ) { $ e = sprintf ( 'Replaced entity `%s` cannot be added for update.' , get_class ( $ entity ) ) ; throw new InvalidArgumentException ( $ e ) ; } if ( isset ( $ this -> entityUpdates [ $ id ] ) ) { $ e = sprintf ( 'Entity `%s` cannot be updated for twice.' , get_class ( $ entity ) ) ; throw new InvalidArgumentException ( $ e ) ; } $ this -> entityUpdates [ $ id ] = $ entity ; $ this -> entityStates [ $ id ] = self :: STATE_MANAGED ; return $ this ; } 
protected function deleteEntity ( IEntity $ entity ) : IUnitOfWork { $ this -> validateClosed ( ) ; $ id = spl_object_id ( $ entity ) ; if ( isset ( $ this -> entityCreates [ $ id ] ) ) { unset ( $ this -> entityCreates [ $ id ] , $ this -> entityStates [ $ id ] ) ; foreach ( [ 'createsFlagBefore' , 'createsFlag' , 'createsFlagAfter' ] as $ flag ) { if ( isset ( $ this -> { $ flag } [ $ id ] ) ) { unset ( $ this -> { $ flag } [ $ id ] ) ; } } return $ this ; } if ( isset ( $ this -> entityReplaces [ $ id ] ) ) { unset ( $ this -> entityReplaces [ $ id ] ) ; foreach ( [ 'replacesFlagBefore' , 'replacesFlag' , 'replacesFlagAfter' ] as $ flag ) { if ( isset ( $ this -> { $ flag } [ $ id ] ) ) { unset ( $ this -> { $ flag } [ $ id ] ) ; } } if ( ! $ entity -> id ( ) ) { return $ this ; } } if ( ! $ entity -> id ( ) ) { $ e = sprintf ( 'Entity `%s` has no identity for delete.' , get_class ( $ entity ) ) ; throw new InvalidArgumentException ( $ e ) ; } if ( isset ( $ this -> entityUpdates [ $ id ] ) ) { unset ( $ this -> entityUpdates [ $ id ] ) ; foreach ( [ 'updatesFlagBefore' , 'updatesFlag' , 'updatesFlagAfter' ] as $ flag ) { if ( isset ( $ this -> { $ flag } [ $ id ] ) ) { unset ( $ this -> { $ flag } [ $ id ] ) ; } } } if ( isset ( $ this -> entityDeletes [ $ id ] ) ) { $ e = sprintf ( 'Entity `%s` cannot be deleted for twice.' , get_class ( $ entity ) ) ; throw new InvalidArgumentException ( $ e ) ; } $ this -> entityDeletes [ $ id ] = $ entity ; $ this -> entityStates [ $ id ] = self :: STATE_REMOVED ; return $ this ; } 
protected function handleRepository ( ) : void { foreach ( [ 'Before' , '' , 'After' ] as $ position ) { foreach ( [ 'creates' , 'replaces' , 'updates' , 'deletes' ] as $ type ) { $ flag = $ type . 'Flag' . $ position ; if ( $ this -> { $ flag } ) { $ flags = $ this -> { $ flag } ; asort ( $ flags ) ; foreach ( $ flags as $ id => $ _ ) { $ entity = $ this -> { 'entity' . ucfirst ( $ type ) } [ $ id ] ; $ this -> repository ( $ entity ) -> { substr ( $ type , 0 , - 1 ) } ( $ entity ) ; if ( isset ( $ this -> onCallbacks [ $ id ] ) ) { foreach ( $ this -> onCallbacks [ $ id ] as $ c ) { $ c ( $ entity , $ this ) ; } } $ this -> entityStates [ $ id ] = self :: STATE_DETACHED ; } } } } $ oldStates = $ this -> entityStates ; $ this -> clear ( ) ; $ this -> entityStates = $ oldStates ; } 
protected function persistNewEntry ( string $ position , string $ method , IEntity $ entity ) : void { switch ( strtolower ( $ method ) ) { case 'create' : $ this -> { 'create' . $ position } ( $ entity ) ; break ; case 'update' : $ this -> { 'update' . $ position } ( $ entity ) ; break ; case 'replace' : $ this -> { 'replace' . $ position } ( $ entity ) ; break ; case 'save' : default : $ ids = $ entity -> id ( ) ; if ( is_array ( $ ids ) ) { $ this -> { 'replace' . $ position } ( $ entity ) ; } else { if ( empty ( $ ids ) ) { $ this -> { 'create' . $ position } ( $ entity ) ; } else { $ this -> { 'update' . $ position } ( $ entity ) ; } } break ; } } 
public function setOption ( string $ name , $ value ) : IPage { $ this -> option [ $ name ] = $ value ; return $ this ; } 
public function append ( string $ key , string $ value ) : IPage { return $ this -> addParameter ( $ key , $ value ) ; } 
public function appends ( array $ values ) : IPage { foreach ( $ values as $ key => $ value ) { $ this -> addParameter ( $ key , $ value ) ; } return $ this ; } 
public function addParameter ( string $ key , $ value ) : IPage { $ tmp = $ this -> option [ 'parameter' ] ; $ tmp [ $ key ] = $ value ; $ this -> setOption ( 'parameter' , $ tmp ) ; return $ this ; } 
public function renderOptions ( array $ option ) : IPage { foreach ( $ option as $ key => $ value ) { $ this -> renderOption ( $ key , $ value ) ; } return $ this ; } 
public function getPerPage ( ) : int { if ( null === $ this -> perPage ) { $ this -> perPage = static :: PER_PAGE ; } return $ this -> perPage ; } 
public function getToRecord ( ) : ? int { if ( ! $ this -> canTotalRender ( ) ) { return null ; } $ to = $ this -> getFromRecord ( ) + $ this -> getPerPage ( ) ; return $ to <= $ this -> getTotalRecord ( ) ? $ to : $ this -> getTotalRecord ( ) ; } 
public function getPageStart ( ) : int { if ( null !== $ this -> pageStart ) { return $ this -> pageStart ; } $ this -> pageStart = $ this -> getCurrentPage ( ) - $ this -> getRange ( ) ; if ( $ this -> pageStart < $ this -> getRange ( ) * 2 ) { $ this -> pageStart = 1 ; } return $ this -> pageStart ; } 
public function getPageEnd ( ) : int { if ( null !== $ this -> pageEnd ) { return $ this -> pageEnd ; } $ this -> pageEnd = $ this -> getCurrentPage ( ) + $ this -> getRange ( ) ; if ( 1 === $ this -> getPageStart ( ) ) { $ this -> pageEnd = $ this -> getRange ( ) * 2 + 2 ; } if ( $ this -> getTotalPage ( ) && $ this -> pageEnd > $ this -> getTotalPage ( ) ) { $ this -> pageEnd = $ this -> getTotalPage ( ) ; } return $ this -> pageEnd ; } 
public function getTotalPage ( ) : ? int { if ( null !== $ this -> totalPage || ! $ this -> getTotalRecord ( ) ) { return $ this -> totalPage ; } $ this -> totalPage = ( int ) ( ceil ( $ this -> getTotalRecord ( ) / $ this -> getPerPage ( ) ) ) ; return $ this -> totalPage ; } 
public function canNextRender ( ) : bool { return null === $ this -> getTotalPage ( ) || ( $ this -> getTotalPage ( ) > 1 && $ this -> getCurrentPage ( ) !== $ this -> getTotalPage ( ) ) ; } 
public function canLastRender ( ) : bool { return $ this -> getTotalPage ( ) > 1 && $ this -> getCurrentPage ( ) !== $ this -> getTotalPage ( ) && $ this -> getTotalPage ( ) > $ this -> getPageEnd ( ) ; } 
public function parseLastRenderNext ( ) : int { $ next = $ this -> getCurrentPage ( ) + $ this -> getRange ( ) * 2 + 1 ; if ( ! $ this -> isTotalMacro ( ) && $ next > $ this -> getTotalPage ( ) ) { $ next = $ this -> getTotalPage ( ) ; } return $ next ; } 
public function render ( $ render = null , array $ option = [ ] ) : string { $ option = array_merge ( $ this -> option [ 'render_option' ] , $ option ) ; if ( null === $ render || is_string ( $ render ) ) { $ render = $ render ? : $ this -> getRender ( ) ; $ render = __NAMESPACE__ . '\\' . ucfirst ( $ render ) ; $ render = new $ render ( $ this ) ; } elseif ( ! $ render instanceof IRender ) { throw new RuntimeException ( 'Unsupported render type.' ) ; } $ result = $ render -> render ( $ option ) ; $ this -> cachedUrl = null ; return $ result ; } 
public function toArray ( ) : array { return [ 'per_page' => $ this -> getPerPage ( ) , 'current_page' => $ this -> getCurrentPage ( ) , 'total_page' => $ this -> getTotalPage ( ) , 'total_record' => $ this -> getTotalRecord ( ) , 'total_macro' => $ this -> isTotalMacro ( ) , 'from' => $ this -> getFromRecord ( ) , 'to' => $ this -> getToRecord ( ) , ] ; } 
public function toJson ( $ option = null ) : string { if ( null === $ option ) { $ option = JSON_UNESCAPED_UNICODE ; } return json_encode ( $ this -> jsonSerialize ( ) , $ option ) ; } 
protected function getUrl ( ) : string { if ( null !== $ this -> cachedUrl ) { return $ this -> cachedUrl ; } $ url = ( string ) ( $ this -> option [ 'url' ] ) ; $ parameter = $ this -> option [ 'parameter' ] ; if ( isset ( $ parameter [ $ this -> option [ 'page' ] ] ) ) { unset ( $ parameter [ $ this -> option [ 'page' ] ] ) ; } if ( false === strpos ( $ url , '{page}' ) ) { $ parameter [ $ this -> option [ 'page' ] ] = '{page}' ; } $ this -> cachedUrl = $ url . ( false === strpos ( $ url , '?' ) ? '?' : '&' ) . http_build_query ( $ parameter , '' , '&' ) ; return $ this -> cachedUrl .= $ this -> buildFragment ( ) ; } 
protected function matchMain ( ) : array { if ( ! ( $ routers = $ this -> router -> getRouters ( ) ) ) { return [ ] ; } 
protected function matcheMethod ( array $ routers ) { $ method = strtolower ( $ this -> request -> getMethod ( ) ) ; return $ routers [ $ method ] ?? false ; } 
protected function matcheStatic ( array $ routers ) { $ pathInfo = $ this -> getPathInfo ( ) ; if ( isset ( $ routers [ 'static' ] , $ routers [ 'static' ] [ $ pathInfo ] ) ) { $ routers = $ routers [ 'static' ] [ $ pathInfo ] ; return $ this -> matcheSuccessed ( $ routers ) ; } return false ; } 
protected function matcheGroups ( string $ pathInfo , array $ routers ) : array { $ matchGroup = false ; foreach ( $ this -> router -> getGroups ( ) as $ group ) { if ( 0 === strpos ( $ pathInfo , $ group ) ) { $ routers = $ routers [ $ group ] ; $ matchGroup = true ; break ; } } if ( false === $ matchGroup ) { $ routers = $ routers [ '_' ] ?? [ ] ; } return $ routers ; } 
protected function matcheRegexGroups ( array $ routers ) { $ pathInfo = $ this -> getPathInfo ( ) ; foreach ( $ routers [ 'regex' ] as $ key => $ regex ) { if ( ! preg_match ( $ regex , $ pathInfo , $ matches ) ) { continue ; } $ matchedRouter = $ routers [ 'map' ] [ $ key ] [ count ( $ matches ) ] ; $ routers = $ routers [ $ matchedRouter ] ; $ matcheVars = $ this -> matcheVariable ( $ routers , $ matches ) ; return $ this -> matcheSuccessed ( $ routers , $ matcheVars ) ; } return false ; } 
protected function matcheSuccessed ( array $ routers , array $ matcheVars = [ ] ) : array { 
protected function matcheScheme ( string $ scheme ) : bool { if ( $ scheme && $ this -> request -> getScheme ( ) !== $ scheme ) { return false ; } return true ; } 
protected function matcheDomain ( array $ routers ) { $ domainVars = [ ] ; if ( ! empty ( $ routers [ 'domain' ] ) ) { 
protected function matcheVariable ( array $ routers , array $ matches ) : array { $ result = [ ] ; array_shift ( $ matches ) ; foreach ( $ routers [ 'var' ] as $ key => $ var ) { $ value = $ matches [ $ key ] ; $ result [ $ var ] = $ matches [ $ key ] ; $ this -> addVariable ( $ var , $ matches [ $ key ] ) ; } return $ result ; } 
public function eager ( array $ relation ) : self { $ this -> preLoads = array_merge ( $ this -> preLoads , $ this -> parseWithRelation ( $ relation ) ) ; return $ this ; } 
public function preLoadResult ( $ result ) { list ( $ result , $ type ) = $ this -> conversionToEntitys ( $ result ) ; if ( $ type ) { $ result = $ this -> preLoadRelation ( $ result ) ; if ( 'entity' === $ type ) { $ result = reset ( $ result ) ; } elseif ( 'collection' === $ type ) { $ result = new Collection ( $ result ) ; } } return $ result ; } 
public function find ( int $ id , array $ column = [ '*' ] ) : IEntity { return $ this -> select -> where ( $ this -> entity -> singlePrimaryKey ( ) , '=' , $ id ) -> setColumns ( $ column ) -> findOne ( ) ; } 
public function findMany ( array $ ids , array $ column = [ '*' ] ) : Collection { if ( empty ( $ ids ) ) { return $ this -> entity -> collection ( ) ; } return $ this -> select -> whereIn ( $ this -> entity -> singlePrimaryKey ( ) , $ ids ) -> setColumns ( $ column ) -> findAll ( ) ; } 
public function findOrFail ( int $ id , array $ column = [ '*' ] ) : IEntity { $ result = $ this -> find ( $ id , $ column ) ; if ( null !== $ result -> __get ( $ this -> entity -> singlePrimaryKey ( ) ) ) { return $ result ; } throw ( new EntityNotFoundException ( ) ) -> setEntity ( get_class ( $ this -> entity ) ) ; } 
public function softDelete ( ) : int { $ this -> entity -> __set ( $ this -> deleteAtColumn ( ) , $ time = date ( 'Y-m-d H:i:s' ) ) ; $ this -> entity -> handleEvent ( IEntity :: BEFORE_SOFT_DELETE_EVENT ) ; $ num = $ this -> entity -> update ( ) -> flush ( ) ; $ this -> entity -> handleEvent ( IEntity :: AFTER_SOFT_DELETE_EVENT ) ; return $ num ; } 
public function softDestroy ( array $ ids ) : int { $ count = 0 ; $ instance = $ this -> entity -> make ( ) ; $ entitys = $ instance -> whereIn ( $ instance -> singlePrimaryKey ( ) , $ ids ) -> findAll ( ) ; foreach ( $ entitys as $ value ) { if ( $ value -> softDelete ( ) ) { $ count ++ ; } } return $ count ; } 
public function softRestore ( ) : int { $ this -> entity -> handleEvent ( IEntity :: BEFORE_SOFT_RESTORE_EVENT ) ; $ this -> entity -> __set ( $ this -> deleteAtColumn ( ) , null ) ; $ num = $ this -> entity -> update ( ) -> flush ( ) ; $ this -> entity -> handleEvent ( IEntity :: AFTER_SOFT_RESTORE_EVENT ) ; return $ num ; } 
public function deleteAtColumn ( ) : string { if ( defined ( get_class ( $ this -> entity ) . '::DELETE_AT' ) ) { $ deleteAt = $ this -> entity :: DELETE_AT ; } else { $ deleteAt = 'delete_at' ; } if ( ! $ this -> entity -> hasField ( $ deleteAt ) ) { throw new InvalidArgumentException ( sprintf ( 'Entity `%s` soft delete field `%s` was not found.' , get_class ( $ this -> entity ) , $ deleteAt ) ) ; } return $ deleteAt ; } 
public function scope ( $ scope ) : IEntity { $ scopeSelect = $ this -> select ; $ args = func_get_args ( ) ; array_shift ( $ args ) ; array_unshift ( $ args , $ scopeSelect ) ; if ( $ scope instanceof Closure ) { $ scope ( ... $ args ) ; $ this -> entity -> withScopeSelect ( $ scopeSelect ) ; } else { foreach ( normalize ( $ scope ) as $ value ) { $ value = 'scope' . ucfirst ( $ value ) ; if ( method_exists ( $ this -> entity , $ value ) ) { $ this -> entity -> { $ value } ( ... $ args ) ; $ this -> entity -> withScopeSelect ( $ scopeSelect ) ; } } } return $ this -> entity ; } 
protected function preLoadRelation ( array $ entitys ) : array { foreach ( $ this -> preLoads as $ name => $ condition ) { if ( false === strpos ( $ name , '.' ) ) { $ entitys = $ this -> loadRelation ( $ entitys , $ name , $ condition ) ; } } return $ entitys ; } 
protected function getRelation ( string $ name ) : Relation { $ relation = Relation :: withoutRelationCondition ( function ( ) use ( $ name ) { return $ this -> entity -> { $ name } ( ) ; } ) ; $ nested = $ this -> nestedRelation ( $ name ) ; if ( count ( $ nested ) > 0 ) { $ relation -> getSelect ( ) -> eager ( $ nested ) ; } return $ relation ; } 
protected function nestedRelation ( string $ relation ) : array { $ nested = [ ] ; foreach ( $ this -> preLoads as $ name => $ condition ) { if ( $ this -> isNested ( $ name , $ relation ) ) { $ nested [ substr ( $ name , strlen ( $ relation . '.' ) ) ] = $ condition ; } } return $ nested ; } 
protected function isNested ( string $ name , string $ relation ) : bool { return contains ( $ name , '.' ) && starts_with ( $ name , $ relation . '.' ) ; } 
protected function parseWithRelation ( array $ relation ) : array { $ arr = [ ] ; foreach ( $ relation as $ name => $ condition ) { if ( is_numeric ( $ name ) ) { list ( $ name , $ condition ) = [ $ condition , function ( ) { } , ] ; } $ arr = $ this -> parseNestedWith ( $ name , $ arr ) ; $ arr [ $ name ] = $ condition ; } return $ arr ; } 
protected function parseNestedWith ( string $ name , array $ result ) : array { $ progress = [ ] ; foreach ( explode ( '.' , $ name ) as $ segment ) { $ progress [ ] = $ segment ; if ( ! isset ( $ result [ $ last = implode ( '.' , $ progress ) ] ) ) { $ result [ $ last ] = function ( ) { } ; } } return $ result ; } 
protected function conversionToEntitys ( $ result ) : array { $ type = '' ; if ( $ result instanceof Collection ) { $ arr = [ ] ; foreach ( $ result as $ entity ) { $ arr [ ] = $ entity ; } $ result = $ arr ; $ type = 'collection' ; } elseif ( is_object ( $ result ) && $ result instanceof IEntity ) { $ result = [ $ result ] ; $ type = 'entity' ; } return [ $ result , $ type ] ; } 
protected function loadRelation ( array $ entitys , string $ name , Closure $ condition ) : array { $ relation = $ this -> getRelation ( $ name ) ; $ relation -> preLoadCondition ( $ entitys ) ; call_user_func ( $ condition , $ relation ) ; return $ relation -> matchPreLoad ( $ entitys , $ relation -> getPreLoad ( ) , $ name ) ; } 
public function handle ( $ event , ... $ params ) : void { if ( is_object ( $ event ) ) { $ name = get_class ( $ event ) ; } else { $ name = $ event ; 
public function register ( $ event , $ listener , int $ priority = 500 ) : void { $ event = is_object ( $ event ) ? [ $ event ] : ( array ) $ event ; foreach ( $ event as $ item ) { $ item = $ this -> normalizeEvent ( $ item ) ; if ( false !== strpos ( $ item , '*' ) ) { $ this -> wildcards [ $ item ] [ $ priority ] [ ] = $ listener ; } else { $ this -> listeners [ $ item ] [ $ priority ] [ ] = $ listener ; } } } 
public function get ( $ event ) : array { $ listeners = [ ] ; $ event = $ this -> normalizeEvent ( $ event ) ; if ( isset ( $ this -> listeners [ $ event ] ) ) { $ listeners = $ this -> listeners [ $ event ] ; } foreach ( $ this -> wildcards as $ key => $ item ) { $ key = $ this -> prepareRegexForWildcard ( $ key ) ; if ( preg_match ( $ key , $ event , $ res ) ) { foreach ( $ item as $ priority => $ value ) { $ listeners [ $ priority ] = array_merge ( $ listeners [ $ priority ] ?? [ ] , $ value ) ; } } } return $ listeners ; } 
public function delete ( $ event ) : void { $ event = $ this -> normalizeEvent ( $ event ) ; if ( isset ( $ this -> listeners [ $ event ] ) ) { unset ( $ this -> listeners [ $ event ] ) ; } if ( isset ( $ this -> wildcards [ $ event ] ) ) { unset ( $ this -> wildcards [ $ event ] ) ; } } 
protected function makeSubject ( array $ listeners ) : Subject { $ subject = new Subject ( $ this -> container ) ; foreach ( $ listeners as $ item ) { $ subject -> register ( $ item ) ; } return $ subject ; } 
protected function prepareRegexForWildcard ( string $ regex ) : string { $ regex = preg_quote ( $ regex , '/' ) ; $ regex = '/^' . str_replace ( '\*' , '(\S*)' , $ regex ) . '$/' ; return $ regex ; } 
public function get ( string $ className , ... $ args ) { $ this -> valid ( $ className ) ; $ className = $ this -> normalize ( $ className ) ; $ pool = $ this -> pool ( $ className ) ; if ( $ pool -> count ( ) ) { $ obj = $ pool -> shift ( ) ; if ( is_callable ( [ $ obj , '__construct' ] ) ) { $ obj -> __construct ( ... $ args ) ; } if ( is_callable ( [ $ obj , 'construct' ] ) ) { $ obj -> construct ( ) ; } return $ obj ; } return $ this -> container -> make ( $ className , $ args ) ; } 
public function back ( $ obj ) : void { if ( method_exists ( $ obj , 'destruct' ) ) { $ obj -> destruct ( ) ; } $ className = $ this -> normalize ( get_class ( $ obj ) ) ; $ pool = $ this -> pool ( $ className ) ; $ pool -> push ( $ obj ) ; } 
public function pool ( string $ className ) : SplStack { $ this -> valid ( $ className ) ; $ className = $ this -> normalize ( $ className ) ; $ pool = $ this -> pools [ $ className ] ?? null ; if ( null !== $ pool ) { return $ pool ; } return $ this -> pools [ $ className ] = new SplStack ( ) ; } 
public function register ( ) : void { $ this -> viewViews ( ) ; $ this -> viewView ( ) ; $ this -> viewCompiler ( ) ; $ this -> viewParser ( ) ; } 
protected function viewParser ( ) : void { $ this -> container -> singleton ( 'view.parser' , function ( IContainer $ container ) { return ( new Parser ( $ container [ 'view.compiler' ] ) ) -> registerCompilers ( ) -> registerParsers ( ) ; } ) ; } 
public function handle ( Closure $ next , IRequest $ request , int $ limit = 60 , int $ time = 60 ) : void { $ rateLimiter = $ this -> throttler -> setRequest ( $ request ) -> create ( null , $ limit , $ time ) ; if ( $ rateLimiter -> attempt ( ) ) { $ e = new TooManyRequestsHttpException ( 'Too many attempts.' ) ; $ e -> setHeaders ( $ rateLimiter -> header ( ) ) ; throw $ e ; } $ next ( $ request ) ; } 
protected function createConnect ( object $ connect ) : object { return new Log ( $ connect , $ this -> getCommonOption ( ) , $ this -> container -> make ( IDispatch :: class ) ) ; } 
public function handle ( InputInterface $ input = null , OutputInterface $ output = null ) : int { $ this -> registerBaseService ( ) ; $ this -> bootstrap ( ) ; $ this -> setGlobalReplace ( ) ; $ this -> loadCommands ( ) ; return $ this -> getConsoleApplication ( ) -> run ( $ input , $ output ) ; } 
protected function getConsoleApplication ( ) : Application { if ( $ this -> consoleApplication ) { return $ this -> consoleApplication ; } return $ this -> consoleApplication = new Application ( $ this -> app , $ this -> app -> version ( ) ) ; } 
protected function loadCommands ( ) : void { $ commands = $ this -> normalizeCommands ( $ this -> getCommands ( ) ) ; $ this -> getConsoleApplication ( ) -> normalizeCommands ( $ commands ) ; } 
protected function normalizeCommands ( array $ commands ) : array { $ result = $ tmp = [ ] ; foreach ( $ commands as $ item ) { $ tmp [ class_exists ( $ item ) ? 'class' : 'namespace' ] [ ] = $ item ; } if ( isset ( $ tmp [ 'class' ] ) ) { $ result = $ tmp [ 'class' ] ; } if ( isset ( $ tmp [ 'namespace' ] ) ) { $ result = array_merge ( $ result , $ this -> getCommandsWithNamespace ( $ tmp [ 'namespace' ] ) ) ; } return $ result ; } 
protected function getCommandsWithNamespace ( array $ namespaces ) : array { $ data = [ ] ; foreach ( $ namespaces as $ item ) { $ data [ $ item ] = $ this -> app -> namespacePath ( $ item . '\\index' ) ; } return ( new Load ( ) ) -> addNamespace ( $ data ) -> loadData ( ) ; } 
public function getCompilers ( ) : array { $ methods = get_class_methods ( $ this ) ; $ compilers = [ ] ; foreach ( $ methods as $ method ) { if ( 'Compiler' !== substr ( $ method , - 8 ) ) { continue ; } $ method = substr ( $ method , 0 , - 8 ) ; if ( ! in_array ( $ method , [ 'global' , 'jsvar' , 'globalrevert' , 'revert' , ] , true ) ) { $ type = strtolower ( substr ( $ method , - 4 ) ) ; $ tag = substr ( $ method , 0 , - 4 ) ; if ( 'code' === $ type ) { $ name = $ this -> codeMap [ $ tag ] ?? $ tag ; } elseif ( 'node' === $ type ) { $ name = $ this -> nodeMap [ $ tag ] ?? $ tag ; } else { $ type = strtolower ( substr ( $ method , - 2 ) ) ; $ tag = substr ( $ method , 0 , - 2 ) ; $ name = $ this -> jsMap [ $ tag ] ?? $ tag ; } $ compilers [ ] = [ $ type , $ name , $ tag , ] ; } } unset ( $ methods ) ; return $ compilers ; } 
public function variableCodeCompiler ( array & $ theme ) : void { $ theme [ 'content' ] = ! empty ( $ theme [ 'content' ] ) ? $ this -> parseContent ( $ theme [ 'content' ] ) : null ; if ( null !== $ theme [ 'content' ] ) { $ theme [ 'content' ] = $ this -> withPhpTag ( 'echo ' . $ theme [ 'content' ] . ';' ) ; } $ theme [ 'content' ] = $ this -> encodeContent ( $ theme [ 'content' ] ) ; } 
public function ifCodeCompiler ( array & $ theme ) : void { $ theme [ 'content' ] = $ this -> parseContentIf ( $ theme [ 'content' ] , '' ) ; $ theme [ 'content' ] = $ this -> encodeContent ( $ this -> withPhpTag ( $ theme [ 'content' ] . ':' ) ) ; } 
public function elseifCodeCompiler ( array & $ theme ) : void { $ theme [ 'content' ] = $ this -> parseContentIf ( $ theme [ 'content' ] , 'else' ) ; $ theme [ 'content' ] = $ this -> encodeContent ( $ this -> withPhpTag ( $ theme [ 'content' ] . ':' ) ) ; } 
public function foreachCodeCompiler ( array & $ theme ) : void { $ theme [ 'content' ] = call_user_func ( function ( $ content ) { preg_match_all ( '/\\$([\S]+)/' , $ content , $ matches ) ; $ matches = $ matches [ 1 ] ; $ num = count ( $ matches ) ; if ( $ num > 0 ) { if ( 2 === $ num ) { $ result = "\${$matches[1]}" ; } elseif ( 3 === $ num ) { $ result = "\${$matches[1]} => \${$matches[2]}" ; } else { throw new InvalidArgumentException ( 'The parameter of code.foreach tag can be at most three.' ) ; } return "if (is_array(\${$matches[0]})): foreach(\${$matches[0]} as {$result})" ; } } , $ theme [ 'content' ] ) ; $ theme [ 'content' ] = $ this -> encodeContent ( $ this -> withPhpTag ( $ theme [ 'content' ] . ':' ) ) ; } 
public function endtagCodeCompiler ( array & $ theme ) : void { $ theme [ 'content' ] = substr ( $ theme [ 'source' ] , strpos ( $ theme [ 'source' ] , '/' ) , strripos ( $ theme [ 'source' ] , '}' ) - 1 ) ; $ theme [ 'content' ] = call_user_func ( function ( $ content ) { $ content = ltrim ( trim ( $ content ) , '/' ) ; switch ( $ content ) { case 'list' : $ content = $ this -> withPhpTag ( 'endforeach; endif;' ) ; break ; case 'for' : $ content = $ this -> withPhpTag ( 'endfor;' ) ; break ; case 'while' : $ content = $ this -> withPhpTag ( 'endwhile;' ) ; break ; case 'if' : $ content = $ this -> withPhpTag ( 'endif;' ) ; break ; case 'script' : $ content = '</script>' ; break ; case 'style' : $ content = '</style>' ; break ; } return $ content ; } , $ theme [ 'content' ] ) ; $ theme [ 'content' ] = $ this -> encodeContent ( $ theme [ 'content' ] ) ; } 
public function letJsCompiler ( array & $ theme ) : void { $ this -> checkNode ( $ theme , true ) ; $ attr = $ this -> getNodeAttribute ( $ theme ) ; $ name = array_shift ( $ attr ) ; $ equal = array_shift ( $ attr ) ; if ( '=' !== $ equal ) { array_unshift ( $ attr , $ equal ) ; } if ( ! $ attr ) { $ value = 'null' ; } else { $ value = $ this -> parseExpression ( implode ( ' ' , $ attr ) ) ; if ( '' === $ value ) { $ value = 'null' ; } } $ theme [ 'content' ] = $ this -> withPhpTag ( "\${$name} = " . $ value . ';' ) ; } 
public function ifJsCompiler ( array & $ theme ) : void { $ this -> checkNode ( $ theme , true ) ; $ attr = $ this -> getNodeAttribute ( $ theme ) ; $ attr = $ this -> parseExpression ( implode ( ' ' , $ attr ) ) ; $ theme [ 'content' ] = $ this -> withPhpTag ( "if ({$attr}):" ) ; $ theme [ 'content' ] .= $ this -> getNodeBody ( $ theme ) ; $ theme [ 'content' ] .= $ this -> withPhpTag ( 'endif;' ) ; } 
public function forJsCompiler ( array & $ theme ) : void { $ this -> checkNode ( $ theme , true ) ; $ attr = $ this -> getNodeAttribute ( $ theme ) ; $ attr = array_values ( $ attr ) ; if ( ! in_array ( 'in' , $ attr , true ) ) { throw new InvalidArgumentException ( 'For tag need “in“ separate.'); } $ key = 'key' ; $ value = array_shift ( $ attr ) ; if ( false !== strpos ( $ value , ',' ) ) { list ( $ key , $ value ) = explode ( ',' , $ value ) ; } $ next = array_shift ( $ attr ) ; if ( 'in' !== $ next ) { $ key = $ value ; $ value = $ next ; array_shift ( $ attr ) ; } $ attr = $ this -> parseExpression ( implode ( ' ' , $ attr ) ) ; $ theme [ 'content' ] = $ this -> withPhpTag ( "foreach ({$attr} as \${$key} => \${$value}):" ) ; $ theme [ 'content' ] .= $ this -> getNodeBody ( $ theme ) ; $ theme [ 'content' ] .= $ this -> withPhpTag ( 'endforeach;' ) ; } 
public function assignNodeCompiler ( array & $ theme ) : void { $ this -> checkNode ( $ theme ) ; $ attr = $ this -> getNodeAttribute ( $ theme ) ; $ attr [ 'name' ] = $ this -> parseContent ( $ attr [ 'name' ] , false ) ; if ( null === $ attr [ 'value' ] ) { $ attr [ 'value' ] = 'null' ; } else { if ( '$' === substr ( $ attr [ 'value' ] , 0 , 1 ) ) { $ attr [ 'value' ] = $ this -> parseContent ( substr ( $ attr [ 'value' ] , 1 ) ) ; } else { $ attr [ 'value' ] = '\'' . $ attr [ 'value' ] . '\'' ; } } 
public function ifNodeCompiler ( array & $ theme ) : void { $ this -> checkNode ( $ theme ) ; $ attr = $ this -> getNodeAttribute ( $ theme ) ; $ attr [ 'condition' ] = $ this -> parseContentIf ( $ attr [ 'condition' ] ) ; $ theme [ 'content' ] = $ this -> withPhpTag ( 'if (' . $ attr [ 'condition' ] . '):' ) . $ this -> getNodeBody ( $ theme ) . $ this -> withPhpTag ( 'endif;' ) ; } 
public function elseifNodeCompiler ( array & $ theme ) : void { $ this -> checkNode ( $ theme ) ; $ attr = $ this -> getNodeAttribute ( $ theme ) ; $ attr [ 'condition' ] = $ this -> parseContentIf ( $ attr [ 'condition' ] ) ; $ theme [ 'content' ] = $ this -> withPhpTag ( 'elseif (' . $ attr [ 'condition' ] . '):' ) ; } 
public function listNodeCompiler ( array & $ theme ) : void { $ this -> checkNode ( $ theme ) ; $ attr = $ this -> getNodeAttribute ( $ theme ) ; foreach ( [ 'key' , 'value' , 'index' , ] as $ key ) { null === $ attr [ $ key ] && $ attr [ $ key ] = '$' . $ key ; } foreach ( [ 'for' , 'key' , 'value' , 'index' , ] as $ key ) { if ( '$' . $ key === $ attr [ $ key ] ) { continue ; } $ attr [ $ key ] = $ this -> parseContent ( $ attr [ $ key ] ) ; } 
public function listsNodeCompiler ( array & $ theme ) : void { $ this -> checkNode ( $ theme ) ; $ attr = $ this -> getNodeAttribute ( $ theme ) ; null === $ attr [ 'index' ] && $ attr [ 'index' ] = 'index' ; null === $ attr [ 'key' ] && $ attr [ 'key' ] = 'key' ; null === $ attr [ 'id' ] && $ attr [ 'id' ] = 'id' ; null === $ attr [ 'mod' ] && $ attr [ 'mod' ] = 2 ; if ( preg_match ( '/[^\\d\-.,]/' , ( string ) ( $ attr [ 'mod' ] ) ) ) { $ attr [ 'mod' ] = '$' . $ attr [ 'mod' ] ; } null === $ attr [ 'empty' ] && $ attr [ 'empty' ] = '' ; null === $ attr [ 'length' ] && $ attr [ 'length' ] = '' ; null === $ attr [ 'offset' ] && $ attr [ 'offset' ] = '' ; $ attr [ 'name' ] = $ this -> parseContent ( $ attr [ 'name' ] ) ; $ compiled = [ ] ; $ tmp = 'if (is_array(' . $ attr [ 'name' ] . ')):' . PHP_EOL . ' $' . $ attr [ 'index' ] . ' = 0;' . PHP_EOL ; if ( '' !== $ attr [ 'length' ] ) { $ tmp .= ' $tmp = array_slice(' . $ attr [ 'name' ] . ', ' . $ attr [ 'offset' ] . ', ' . $ attr [ 'length' ] . ');' ; } elseif ( '' !== $ attr [ 'offset' ] ) { $ tmp .= ' $tmp = array_slice(' . $ attr [ 'name' ] . ', ' . $ attr [ 'offset' ] . ');' ; } else { $ tmp .= ' $tmp = ' . $ attr [ 'name' ] . ';' ; } $ tmp .= PHP_EOL . ' if (0 === count($tmp)):' . PHP_EOL . ' echo "' . $ attr [ 'empty' ] . '";' ; $ tmp .= PHP_EOL . ' else:' ; $ tmp .= PHP_EOL . ' foreach ($tmp as $' . $ attr [ 'key' ] . ' => $' . $ attr [ 'id' ] . '):' ; $ tmp .= PHP_EOL . ' ++$' . $ attr [ 'index' ] . ';' . PHP_EOL ; $ tmp .= ' ' . '$mod = $' . $ attr [ 'index' ] . ' % ' . $ attr [ 'mod' ] . ';' ; $ compiled [ ] = $ this -> withPhpTag ( $ tmp ) ; $ compiled [ ] = $ this -> getNodeBody ( $ theme ) ; $ compiled [ ] = ' ' . $ this -> withPhpTag ( 'endforeach;' . PHP_EOL . ' endif;' . PHP_EOL . 'else:' . PHP_EOL . ' echo "' . $ attr [ 'empty' ] . '";' . PHP_EOL . 'endif;' ) ; $ theme [ 'content' ] = implode ( '' , $ compiled ) ; } 
public function includeNodeCompiler ( array & $ theme ) : void { $ this -> checkNode ( $ theme ) ; $ attr = $ this -> getNodeAttribute ( $ theme ) ; if ( false === strpos ( $ attr [ 'file' ] , '(' ) ) { 
public function forNodeCompiler ( array & $ theme ) : void { $ this -> checkNode ( $ theme ) ; $ attr = $ this -> getNodeAttribute ( $ theme ) ; null === $ attr [ 'step' ] && $ attr [ 'step' ] = '1' ; null === $ attr [ 'start' ] && $ attr [ 'start' ] = '0' ; null === $ attr [ 'end' ] && $ attr [ 'end' ] = '0' ; null === $ attr [ 'var' ] && $ attr [ 'var' ] = 'var' ; $ attr [ 'var' ] = '$' . $ attr [ 'var' ] ; if ( '-' === $ attr [ 'type' ] ) { $ comparison = ' >= ' ; $ minusPlus = ' -= ' ; } else { $ comparison = ' <= ' ; $ minusPlus = ' += ' ; } $ compiled = [ ] ; $ compiled [ ] = $ this -> withPhpTag ( 'for (' . $ attr [ 'var' ] . ' = ' . $ attr [ 'start' ] . '; ' . $ attr [ 'var' ] . $ comparison . $ attr [ 'end' ] . '; ' . $ attr [ 'var' ] . $ minusPlus . $ attr [ 'step' ] . '):' ) ; $ compiled [ ] = $ this -> getNodeBody ( $ theme ) ; $ compiled [ ] = $ this -> withPhpTag ( 'endfor;' ) ; $ theme [ 'content' ] = implode ( '' , $ compiled ) ; } 
public function whileNodeCompiler ( array & $ theme ) : void { $ this -> checkNode ( $ theme ) ; $ attr = $ this -> getNodeAttribute ( $ theme ) ; $ theme [ 'content' ] = $ this -> withPhpTag ( 'while(' . $ attr [ 'condition' ] . '):' ) . $ this -> getNodeBody ( $ theme ) . $ this -> withPhpTag ( 'endwhile;' ) ; } 
public function phpNodeCompiler ( array & $ theme ) : void { $ this -> checkNode ( $ theme ) ; $ theme [ 'content' ] = $ this -> withPhpTag ( $ this -> getNodeBody ( $ theme ) ) ; } 
public function attributeNodeCompiler ( array & $ theme ) : void { $ source = trim ( $ theme [ 'content' ] ) ; $ source = $ this -> escapeRegexCharacter ( $ source ) ; if ( true === $ theme [ 'is_js' ] ) { $ tag = $ this -> jsTag ; } else { $ tag = $ this -> nodeTag ; } $ allowedAttr = $ tag [ $ theme [ 'parent_name' ] ] [ 'attr' ] ; 
protected function parseContentIf ( string $ content , ? string $ type = null ) : string { $ param = [ ] ; foreach ( explode ( ' ' , $ content ) as $ value ) { if ( strpos ( $ value , '.' ) > 0 ) { $ args = explode ( '.' , $ value ) ; $ param [ ] = $ args [ 0 ] . ( $ this -> arrayHandler ( $ args , true , 1 ) ) ; } else { $ param [ ] = $ value ; } } $ result = implode ( ' ' , $ param ) ; if ( null === $ type ) { return $ result ; } return $ type . "if ({$result})" ; } 
protected function parseJcontent ( string $ content ) : string { $ var = explode ( '|' , $ content ) ; $ content = array_shift ( $ var ) ; $ content = $ this -> parseExpression ( $ content ) ; if ( count ( $ var ) > 0 ) { return $ this -> parseJsFunction ( $ content , $ var ) ; } return $ content ; } 
protected function parseExpression ( string $ content ) : string { $ content = trim ( $ content ) ; $ logic = [ '+' , '-' , '.' , '(' , ')' , '/' , '%' , '*' , '?' , ':' , '<' , '>' , '=' , '|' , '&' , '~' , '!' , ] ; $ result = [ ] ; 
protected function parseContent ( string $ content , bool $ isFunc = true ) : string { 
protected function parseVarFunction ( string $ name , array $ var , bool $ isJavascript = false ) : string { $ len = count ( $ var ) ; for ( $ index = 0 ; $ index < $ len ; $ index ++ ) { if ( 0 === stripos ( $ var [ $ index ] , 'default=' ) ) { $ args = explode ( '=' , $ var [ $ index ] , 2 ) ; } else { $ args = explode ( '=' , $ var [ $ index ] ) ; } $ args [ 0 ] = trim ( $ args [ 0 ] ) ; if ( false === $ isJavascript && isset ( $ args [ 1 ] ) ) { $ args [ 1 ] = str_replace ( '->' , ':' , $ args [ 1 ] ) ; } switch ( strtolower ( $ args [ 0 ] ) ) { 
protected function arrayHandler ( array & $ vars , bool $ forObj = true , int $ start = 2 ) : string { $ len = count ( $ vars ) ; $ param = '' ; for ( $ index = $ start ; $ index < $ len ; $ index ++ ) { if ( true === $ forObj ) { 
protected function encodeContent ( string $ content , string $ type = '' ) : string { if ( 'global' === $ type ) { $ content = Parser :: globalEncode ( $ content ) ; } elseif ( in_array ( $ type , [ 'revert' , 'include' ] , true ) ) { $ content = base64_decode ( $ content , true ) ; } else { $ content = Parser :: revertEncode ( $ content ) ; } return $ content ; } 
protected function checkNode ( array $ theme , bool $ jsNode = false ) : bool { $ attribute = $ theme [ 'children' ] [ 0 ] ; 
protected function getNodeAttribute ( array $ theme ) : array { foreach ( $ theme [ 'children' ] as $ child ) { if ( isset ( $ child [ 'is_attribute' ] ) && true === $ child [ 'is_attribute' ] ) { return $ child [ 'attribute_list' ] ; } } return [ ] ; } 
protected function getNodeBody ( array $ theme ) { foreach ( $ theme [ 'children' ] as $ child ) { if ( isset ( $ child [ 'is_body' ] ) && true === $ child [ 'is_body' ] ) { return $ child [ 'content' ] ; } } } 
protected function escapeRegexCharacter ( string $ txt , bool $ esc = true ) : string { $ txt = $ this -> escapeCharacter ( $ txt , $ esc ) ; if ( ! $ esc ) { $ txt = str_replace ( [ ' band ' , ' bxor ' , ' bor ' , ' bnot ' , ' bleft ' , ' bright ' , ' and ' , ' or ' , ' not ' , ' dot ' , ' nheq ' , ' heq ' , ' neq ' , ' eq ' , ' egt ' , ' gt ' , ' elt ' , ' lt ' , ] , [ ' & ' , ' ^ ' , ' | ' , ' ~ ' , ' << ' , ' >> ' , ' && ' , ' || ' , ' != ' , '->' , ' !== ' , ' === ' , ' != ' , ' == ' , ' >= ' , ' > ' , ' <= ' , ' < ' , ] , $ txt ) ; } return $ txt ; } 
protected function escapeCharacter ( string $ txt , bool $ esc = true ) : string { if ( '""' === $ txt ) { $ txt = '' ; } if ( $ esc ) { 
public function setDefaultDriver ( string $ name ) : void { $ option = $ this -> getContainerOption ( 'default' ) ; $ this -> setContainerOption ( $ option . '_default' , $ name ) ; } 
protected function makeConnectSession ( array $ options = [ ] ) : Session { $ options = array_merge ( $ this -> normalizeConnectOption ( 'session' , $ options ) ) ; return new Session ( $ this -> container [ 'session' ] , $ options ) ; } 
protected function makeConnectToken ( array $ options = [ ] ) : Token { $ options = array_merge ( $ this -> normalizeConnectOption ( 'token' , $ options ) ) ; return new Token ( $ this -> container [ 'cache' ] , $ this -> container [ 'request' ] , $ options ) ; } 
public static function singletons ( ? string $ path = null ) : IApp { if ( null !== static :: $ app ) { return static :: $ app ; } return static :: $ app = new static ( $ path ) ; } 
public function make ( string $ name , array $ args = [ ] ) { $ name = $ this -> getAlias ( $ name ) ; if ( isset ( $ this -> deferredProviders [ $ name ] ) ) { $ this -> registerDeferredProvider ( $ name ) ; } return parent :: make ( $ name , $ args ) ; } 
public function appPath ( $ app = false , string $ path = '' ) : string { return ( $ this -> appPath ?? $ this -> path . \ DIRECTORY_SEPARATOR . 'application' ) . ( $ app ? \ DIRECTORY_SEPARATOR . $ this -> normalizeApp ( $ app ) : $ app ) . $ this -> normalizePath ( $ path ) ; } 
public function commonPath ( string $ path = '' ) : string { return ( $ this -> commonPath ?? $ this -> path . \ DIRECTORY_SEPARATOR . 'common' ) . $ this -> normalizePath ( $ path ) ; } 
public function runtimePath ( string $ path = '' ) : string { return ( $ this -> runtimePath ?? $ this -> path . \ DIRECTORY_SEPARATOR . 'runtime' ) . $ this -> normalizePath ( $ path ) ; } 
public function storagePath ( string $ path = '' ) : string { return ( $ this -> storagePath ?? $ this -> path . \ DIRECTORY_SEPARATOR . 'storage' ) . $ this -> normalizePath ( $ path ) ; } 
public function publicPath ( string $ path = '' ) : string { return ( $ this -> publicPath ?? $ this -> path . \ DIRECTORY_SEPARATOR . 'public' ) . $ this -> normalizePath ( $ path ) ; } 
public function themesPath ( string $ path = '' ) : string { return ( $ this -> themesPath ?? $ this -> path . \ DIRECTORY_SEPARATOR . 'themes' ) . $ this -> normalizePath ( $ path ) ; } 
public function optionPath ( string $ path = '' ) : string { return ( $ this -> optionPath ?? $ this -> path . \ DIRECTORY_SEPARATOR . 'option' ) . $ this -> normalizePath ( $ path ) ; } 
public function i18nPath ( ? string $ path = null ) : string { return ( $ this -> i18nPath ?? $ this -> path . \ DIRECTORY_SEPARATOR . 'i18n' ) . $ this -> normalizePath ( $ path ? : '' ) ; } 
public function i18nCachedPath ( string $ i18n ) : string { $ basePath = $ this -> i18nCachedPath ? : $ this -> path ( ) . '/bootstrap/i18n' ; return $ basePath . '/' . $ i18n . '.php' ; } 
public function optionCachedPath ( ) : string { $ basePath = $ this -> optionCachedPath ? : $ this -> path ( ) . '/bootstrap' ; $ cache = getenv ( 'RUNTIME_ENVIRONMENT' ) ? : 'option' ; return $ basePath . '/' . $ cache . '.php' ; } 
public function namespacePath ( string $ specificClass , bool $ throwException = true ) : string { if ( false === $ path = $ this -> composer ( ) -> findFile ( $ specificClass ) ) { if ( true === $ throwException ) { $ e = sprintf ( 'Specific class `%s` for finding namespaces was not found.' , $ specificClass ) ; throw new RuntimeException ( $ e ) ; } return '' ; } return dirname ( $ path ) ; } 
public function bootstrap ( array $ bootstraps ) : void { if ( $ this -> isBootstrap ) { return ; } foreach ( $ bootstraps as $ value ) { ( new $ value ( ) ) -> handle ( $ this ) ; } } 
public function registerProviders ( ) : void { if ( $ this -> isBootstrap ) { return ; } list ( $ this -> deferredProviders , $ deferredAlias ) = $ this -> make ( 'option' ) -> get ( '_deferred_providers' , [ [ ] , [ ] ] ) ; foreach ( $ deferredAlias as $ alias ) { $ this -> alias ( $ alias ) ; } $ providers = $ this -> make ( 'option' ) -> get ( '_composer.providers' , [ ] ) ; foreach ( $ providers as $ provider ) { $ provider = $ this -> register ( $ provider ) ; if ( method_exists ( $ provider , 'bootstrap' ) ) { $ this -> providerBootstraps [ ] = $ provider ; } } } 
public function bootstrapProviders ( ) : void { if ( $ this -> isBootstrap ) { return ; } foreach ( $ this -> providerBootstraps as $ item ) { $ this -> callProviderBootstrap ( $ item ) ; } $ this -> isBootstrap = true ; } 
public function register ( $ provider ) : Provider { if ( is_string ( $ provider ) ) { $ provider = $ this -> makeProvider ( $ provider ) ; } if ( method_exists ( $ provider , 'register' ) ) { $ provider -> register ( ) ; } if ( $ this -> isBootstrap ( ) ) { $ this -> callProviderBootstrap ( $ provider ) ; } return $ provider ; } 
protected function registerBaseProvider ( ) : void { $ this -> register ( new EventProvider ( $ this ) ) ; $ this -> register ( new LogProvider ( $ this ) ) ; $ this -> register ( new RouterProvider ( $ this ) ) ; } 
protected function registerDeferredProvider ( string $ provider ) : void { if ( ! isset ( $ this -> deferredProviders [ $ provider ] ) ) { return ; } $ providerInstance = $ this -> register ( $ this -> deferredProviders [ $ provider ] ) ; $ this -> callProviderBootstrap ( $ providerInstance ) ; unset ( $ this -> deferredProviders [ $ provider ] ) ; } 
public function validate ( $ value , array $ parameter , IValidator $ validator , string $ field ) : bool { if ( ! array_key_exists ( 0 , $ parameter ) ) { throw new InvalidArgumentException ( 'Missing the first element of parameter.' ) ; } if ( ! is_string ( $ parameter [ 0 ] ) && ! is_object ( $ parameter [ 0 ] ) ) { return false ; } $ select = $ this -> normalizeSelect ( $ value , $ parameter , $ field ) ; $ this -> parseExceptId ( $ select , $ parameter ) ; $ this -> parseAdditional ( $ select , $ parameter ) ; return 0 === $ select -> findCount ( ) ; } 
public static function rule ( string $ entity , ? string $ field = null , $ exceptId = null , ? string $ primaryKey = null , ... $ additional ) : string { if ( ! type_array ( $ additional , [ 'string' ] ) ) { $ e = 'Unique additional conditions must be string.' ; throw new InvalidArgumentException ( $ e ) ; } $ tmp = [ ] ; $ tmp [ ] = $ entity ; $ tmp [ ] = $ field ? : self :: PLACEHOLDER ; $ tmp [ ] = $ exceptId ? : self :: PLACEHOLDER ; $ tmp [ ] = $ primaryKey ? : self :: PLACEHOLDER ; $ tmp = array_merge ( $ tmp , $ additional ) ; return 'unique:' . implode ( ',' , $ tmp ) ; } 
protected function normalizeSelect ( $ value , array $ parameter , string $ field ) : Select { $ entity = $ this -> parseEntity ( $ parameter ) ; if ( isset ( $ parameter [ 1 ] ) && self :: PLACEHOLDER !== $ parameter [ 1 ] ) { $ field = $ parameter [ 1 ] ; } if ( false !== strpos ( $ field , self :: SEPARATE ) ) { $ select = $ entity -> selfDatabaseSelect ( ) ; foreach ( explode ( self :: SEPARATE , $ field ) as $ v ) { $ select -> where ( $ v , $ value ) ; } } else { $ select = $ entity -> where ( $ field , $ value ) ; } return $ select ; } 
protected function parseEntity ( array $ parameter ) : IEntity { $ connect = null ; if ( is_string ( $ parameter [ 0 ] ) ) { if ( false !== strpos ( $ parameter [ 0 ] , self :: SEPARATE ) ) { list ( $ connect , $ entityClass ) = explode ( self :: SEPARATE , $ parameter [ 0 ] ) ; } else { $ entityClass = $ parameter [ 0 ] ; } if ( ! class_exists ( $ entityClass ) ) { $ e = sprintf ( 'Validate entity `%s` was not found.' , $ entityClass ) ; throw new InvalidArgumentException ( $ e ) ; } $ entity = new $ entityClass ( ) ; } else { $ entity = $ parameter [ 0 ] ; } if ( ! ( $ entity instanceof IEntity ) ) { $ e = sprintf ( 'Validate entity `%s` must be an entity.' , get_class ( $ entity ) ) ; throw new InvalidArgumentException ( $ e ) ; } if ( $ connect ) { $ entity -> withConnect ( $ connect ) ; } return $ entity ; } 
protected function parseExceptId ( Select $ select , array $ parameter ) : void { if ( isset ( $ parameter [ 2 ] ) && self :: PLACEHOLDER !== $ parameter [ 2 ] ) { $ withoutPrimary = true ; if ( ! empty ( $ parameter [ 3 ] ) && self :: PLACEHOLDER !== $ parameter [ 3 ] ) { $ primaryKey = $ parameter [ 3 ] ; } else { if ( is_string ( $ _ = $ select -> entity ( ) -> primaryKey ( ) ) ) { $ primaryKey = $ _ ; } else { $ withoutPrimary = false ; } } if ( $ withoutPrimary ) { $ select -> where ( $ primaryKey , '<>' , $ parameter [ 2 ] ) ; } } } 
protected function parseAdditional ( Select $ select , array $ parameter ) : void { if ( ( $ num = count ( $ parameter ) ) >= 4 ) { for ( $ i = 4 ; $ i < $ num ; $ i += 2 ) { if ( ! isset ( $ parameter [ $ i + 1 ] ) ) { $ e = 'Unique additional conditions must be paired.' ; throw new InvalidArgumentException ( $ e ) ; } if ( false !== strpos ( $ parameter [ $ i ] , self :: SEPARATE ) ) { list ( $ field , $ operator ) = explode ( self :: SEPARATE , $ parameter [ $ i ] ) ; } else { $ field = $ parameter [ $ i ] ; $ operator = '=' ; } $ select -> where ( $ field , $ operator , $ parameter [ $ i + 1 ] ) ; } } } 
public function clear ( ) : void { foreach ( $ this -> pool -> getPools ( ) as $ className => & $ pool ) { while ( $ pool -> count ( ) ) { $ pool -> shift ( ) ; } } $ this -> log ( 'The object pool has cleared.' ) ; } 
public function reset ( array $ query = [ ] , array $ request = [ ] , array $ params = [ ] , array $ cookies = [ ] , array $ files = [ ] , array $ server = [ ] , $ content = null ) : void { $ this -> query = new Bag ( $ query ) ; $ this -> request = new Bag ( $ request ) ; $ this -> params = new Bag ( $ params ) ; $ this -> cookies = new Bag ( $ cookies ) ; $ this -> files = new FileBag ( $ files ) ; $ this -> server = new ServerBag ( $ server ) ; $ this -> headers = new HeaderBag ( $ this -> server -> getHeaders ( ) ) ; $ this -> content = $ content ; $ this -> baseUrl = null ; $ this -> requestUri = null ; $ this -> method = null ; $ this -> pathInfo = null ; $ this -> language = null ; } 
public static function createFromGlobals ( ) : IRequest { $ request = new static ( $ _GET , $ _POST , [ ] , $ _COOKIE , $ _FILES , $ _SERVER , null ) ; $ request = static :: normalizeRequestFromContent ( $ request ) ; return $ request ; } 
public static function normalizeRequestFromContent ( IRequest $ request ) : IRequest { $ contentType = $ request -> headers -> get ( 'CONTENT_TYPE' ) ; $ method = strtoupper ( $ request -> server -> get ( 'REQUEST_METHOD' , self :: METHOD_GET ) ) ; if ( $ contentType ) { if ( 0 === strpos ( $ contentType , 'application/x-www-form-urlencoded' ) && in_array ( $ method , [ static :: METHOD_PUT , static :: METHOD_DELETE , static :: METHOD_PATCH , ] , true ) ) { parse_str ( $ request -> getContent ( ) , $ data ) ; $ request -> request = new Bag ( $ data ) ; } elseif ( 0 === strpos ( $ contentType , 'application/json' ) && $ content = $ request -> getContent ( ) ) { $ request -> request = new Bag ( json_decode ( $ content , true ) ) ; } } return $ request ; } 
public function get ( string $ key , $ defaults = null ) { $ all = $ this -> all ( ) ; if ( array_key_exists ( $ key , $ all ) ) { return $ all [ $ key ] ; } return $ this -> params -> get ( $ key , $ defaults ) ; } 
public function exists ( array $ keys ) : bool { $ input = $ this -> all ( ) ; foreach ( $ keys as $ value ) { if ( ! array_key_exists ( $ value , $ input ) ) { return false ; } } return true ; } 
public function has ( array $ keys ) : bool { foreach ( $ keys as $ value ) { if ( $ this -> isEmptyString ( $ value ) ) { return false ; } } return true ; } 
public function only ( array $ keys ) : array { $ results = [ ] ; $ input = $ this -> all ( ) ; foreach ( $ keys as $ key ) { $ results [ $ key ] = $ input [ $ key ] ?? null ; } return $ results ; } 
public function except ( array $ keys ) : array { $ results = $ this -> all ( ) ; foreach ( $ keys as $ key ) { if ( array_key_exists ( $ key , $ results ) ) { unset ( $ results [ $ key ] ) ; } } return $ results ; } 
public function input ( ? string $ key = null , $ defaults = null ) { $ input = $ this -> getInputSource ( ) -> all ( ) + $ this -> query -> all ( ) ; if ( null === $ key ) { return $ input ; } return $ input [ $ key ] ?? $ defaults ; } 
public function query ( ? string $ key = null , $ defaults = null ) { return $ this -> getItem ( 'query' , $ key , $ defaults ) ; } 
public function cookie ( ? string $ key = null , $ defaults = null ) { return $ this -> getItem ( 'cookies' , $ key , $ defaults ) ; } 
public function file ( ? string $ key = null , $ defaults = null ) { if ( ! $ key || false === strpos ( $ key , '\\' ) ) { return $ this -> getItem ( 'files' , $ key , $ defaults ) ; } return $ this -> files -> getArr ( $ key , is_array ( $ defaults ) ? $ defaults : [ ] ) ; } 
public function header ( ? string $ key = null , $ defaults = null ) { return $ this -> getItem ( 'headers' , $ key , $ defaults ) ; } 
public function server ( ? string $ key = null , $ defaults = null ) { return $ this -> getItem ( 'server' , $ key , $ defaults ) ; } 
public function getItem ( string $ source , ? string $ key , $ defaults ) { if ( null === $ key ) { return $ this -> { $ source } -> all ( ) ; } return $ this -> { $ source } -> get ( $ key , $ defaults ) ; } 
public function isAjax ( ) : bool { $ field = static :: VAR_AJAX ; if ( $ this -> request -> has ( $ field ) || $ this -> query -> has ( $ field ) ) { return true ; } return $ this -> isRealAjax ( ) ; } 
public function isPjax ( ) : bool { $ field = static :: VAR_PJAX ; if ( $ this -> request -> has ( $ field ) || $ this -> query -> has ( $ field ) ) { return true ; } return $ this -> isRealPjax ( ) ; } 
public function isJson ( ) : bool { $ field = static :: VAR_JSON ; if ( $ this -> request -> has ( $ field ) || $ this -> query -> has ( $ field ) ) { return true ; } return $ this -> isRealJson ( ) ; } 
public function isRealJson ( ) : bool { $ contentType = $ this -> headers -> get ( 'CONTENT_TYPE' ) ; if ( ! $ contentType ) { return false ; } foreach ( [ '/json' , '+json' ] as $ item ) { if ( false !== strpos ( $ contentType , $ item ) ) { return true ; } } return false ; } 
public function isAcceptJson ( ) : bool { $ field = static :: VAR_ACCEPT_JSON ; if ( $ this -> request -> has ( $ field ) || $ this -> query -> has ( $ field ) ) { return true ; } if ( $ this -> isAjax ( ) && ! $ this -> isPjax ( ) && $ this -> isAcceptAny ( ) ) { return true ; } return $ this -> isRealAcceptJson ( ) ; } 
public function isRealAcceptJson ( ) : bool { $ accept = $ this -> headers -> get ( 'ACCEPT' ) ; if ( ! $ accept ) { return false ; } foreach ( [ '/json' , '+json' ] as $ item ) { if ( false !== strpos ( $ accept , $ item ) ) { return true ; } } return false ; } 
public function isAcceptAny ( ) : bool { $ accept = $ this -> headers -> get ( 'ACCEPT' ) ; if ( ! $ accept ) { return true ; } if ( false !== strpos ( $ accept , '*' ) ) { return true ; } return false ; } 
public function getMethod ( ) : string { if ( null !== $ this -> method ) { return $ this -> method ; } $ this -> method = strtoupper ( $ this -> server -> get ( 'REQUEST_METHOD' , 'GET' ) ) ; if ( 'POST' === $ this -> method ) { if ( $ method = $ this -> headers -> get ( 'X-HTTP-METHOD-OVERRIDE' ) ) { $ this -> method = strtoupper ( $ method ) ; } else { $ field = static :: VAR_METHOD ; $ this -> method = strtoupper ( $ this -> request -> get ( $ field , $ this -> query -> get ( $ field , 'POST' ) ) ) ; } } return $ this -> method ; } 
public function setMethod ( string $ method ) : IRequest { $ this -> method = null ; $ this -> server -> set ( 'REQUEST_METHOD' , $ method ) ; return $ this ; } 
public function getContent ( ) : string { $ resources = is_resource ( $ this -> content ) ; if ( $ resources ) { rewind ( $ this -> content ) ; return stream_get_contents ( $ this -> content ) ; } if ( null === $ this -> content ) { $ this -> content = file_get_contents ( 'php://input' ) ; } return $ this -> content ; } 
public function getEnter ( ) : string { if ( $ this -> isCli ( ) ) { return '' ; } $ scriptName = $ this -> getScriptName ( ) ; $ scriptName = dirname ( $ scriptName ) ; if ( '\\' === $ scriptName ) { $ scriptName = '/' ; } return $ scriptName ; } 
public function isSecure ( ) : bool { if ( in_array ( $ this -> server -> get ( 'HTTPS' ) , [ '1' , 'on' ] , true ) ) { return true ; } if ( '443' === $ this -> server -> get ( 'SERVER_PORT' ) ) { return true ; } return false ; } 
public function getHost ( ) : string { $ host = $ this -> headers -> get ( 'X_FORWARDED_HOST' , $ this -> headers -> get ( 'HOST' , '' ) ) ; if ( ! $ host ) { $ host = $ this -> server -> get ( 'SERVER_NAME' , $ this -> server -> get ( 'SERVER_ADDR' , '' ) ) ; } if ( false !== strpos ( $ host , ':' ) ) { list ( $ host ) = explode ( ':' , $ host ) ; } return $ host ; } 
public function getUri ( ) : string { if ( null !== $ queryString = $ this -> getQueryString ( ) ) { $ queryString = '?' . $ queryString ; } return $ this -> getSchemeAndHttpHost ( ) . rtrim ( $ this -> getBaseUrl ( ) , '/' ) . $ this -> getPathInfo ( ) . $ queryString ; } 
public function getPort ( ) : int { $ port = ( int ) $ this -> server -> get ( 'SERVER_PORT' ) ; if ( ! $ port ) { $ port = 'https' === $ this -> getScheme ( ) ? 443 : 80 ; } return $ port ; } 
public function getQueryString ( ) : ? string { $ queryString = $ this -> normalizeQueryString ( $ this -> server -> get ( 'QUERY_STRING' ) ) ; return '' === $ queryString && '0' !== $ queryString ? null : $ queryString ; } 
public function getPathInfo ( ) : string { if ( null !== $ this -> pathInfo ) { return $ this -> pathInfo ; } $ pathInfo = $ this -> server -> get ( 'PATH_INFO' ) ; if ( $ pathInfo ) { return $ this -> pathInfo = $ this -> parsePathInfo ( $ pathInfo ) ; } 
public function getBasePath ( ) : string { if ( null !== $ this -> basePath ) { return $ this -> basePath ; } $ baseUrl = $ this -> getBaseUrl ( ) ; if ( empty ( $ baseUrl ) ) { return '' ; } $ filename = basename ( $ this -> server -> get ( 'SCRIPT_FILENAME' , '' ) ) ; if ( basename ( $ baseUrl ) === $ filename ) { $ basePath = dirname ( $ baseUrl ) ; } else { $ basePath = $ baseUrl ; } if ( '\\' === \ DIRECTORY_SEPARATOR ) { $ basePath = str_replace ( '\\' , '/' , $ basePath ) ; } $ this -> basePath = rtrim ( $ basePath , '/' ) ; return $ this -> basePath ; } 
public function getBaseUrl ( ) : string { if ( null !== $ this -> baseUrl ) { return $ this -> baseUrl ; } 
public function getRequestUri ( ) : ? string { if ( null !== $ this -> requestUri ) { return $ this -> requestUri ; } $ requestUri = $ this -> headers -> get ( 'X_REWRITE_URL' , $ this -> server -> get ( 'REQUEST_URI' , '' ) ) ; if ( ! $ requestUri ) { $ requestUri = $ this -> server -> get ( 'ORIG_PATH_INFO' ) ; if ( $ this -> server -> get ( 'QUERY_STRING' ) ) { $ requestUri .= '?' . $ this -> server -> get ( 'QUERY_STRING' ) ; } } return $ this -> requestUri = $ requestUri ; } 
protected function parsePathInfo ( string $ pathInfo ) : string { if ( $ pathInfo ) { $ ext = pathinfo ( $ pathInfo , PATHINFO_EXTENSION ) ; if ( $ ext ) { $ pathInfo = substr ( $ pathInfo , 0 , - ( strlen ( $ ext ) + 1 ) ) ; } } $ pathInfo = empty ( $ pathInfo ) ? '/' : '/' . ltrim ( $ pathInfo , '/' ) ; return $ pathInfo ; } 
protected function normalizeQueryString ( ? string $ queryString ) : string { if ( ! $ queryString && '0' !== $ queryString ) { return '' ; } $ parts = [ ] ; foreach ( explode ( '&' , $ queryString ) as $ item ) { if ( '' === $ item && '0' !== $ item ) { continue ; } $ parts [ ] = $ item ; } return implode ( '&' , $ parts ) ; } 
protected function isEmptyString ( string $ key ) : bool { $ value = $ this -> input ( $ key ) ; return is_string ( $ value ) && '' === trim ( $ value ) && '0' !== $ value ; } 
protected function getUrlencodedPrefix ( string $ strings , string $ prefix ) { if ( 0 !== strpos ( rawurldecode ( $ strings ) , $ prefix ) ) { return false ; } $ len = strlen ( $ prefix ) ; if ( preg_match ( sprintf ( '#^(%%[[:xdigit:]]{2}|.){%d}#' , $ len ) , $ strings , $ matches ) ) { return $ matches [ 0 ] ; } return false ; } 
protected function close ( array $ option ) : void { $ pidFile = $ option [ 'pid_path' ] ; $ processName = $ option [ 'process_name' ] ; if ( ! file_exists ( $ pidFile ) ) { throw new InvalidArgumentException ( sprintf ( 'Pid path `%s` was not found.' , $ pidFile ) ) ; } $ pids = explode ( PHP_EOL , file_get_contents ( $ pidFile ) ) ; $ pid = ( int ) $ pids [ 0 ] ; if ( ! Process :: kill ( $ pid , 0 ) ) { throw new InvalidArgumentException ( sprintf ( 'Pid `%s` was not found.' , $ pid ) ) ; } Process :: kill ( $ pid , SIGKILL ) ; if ( is_file ( $ pidFile ) ) { unlink ( $ pidFile ) ; } $ this -> info ( sprintf ( 'Process %s:%d has stoped.' , $ processName , $ pid ) , true ) ; } 
public function ifs ( $ value = false ) : self { return $ this -> setFlowControl ( true , $ value ? true : false ) ; } 
public function elseIfs ( $ value = false ) : self { return $ this -> setFlowControl ( true , $ value ? true : false ) ; } 
public function setFlowControl ( bool $ inFlowControl , bool $ isFlowControlTrue ) : self { $ this -> inFlowControl = $ inFlowControl ; $ this -> isFlowControlTrue = $ isFlowControlTrue ; return $ this ; } 
public function setOption ( string $ name , $ value ) : IMail { $ this -> option [ $ name ] = $ value ; return $ this ; } 
public function globalFrom ( string $ address , ? string $ name = null ) : IMail { $ this -> setOption ( 'global_from' , compact ( 'address' , 'name' ) ) ; return $ this ; } 
public function view ( string $ file , array $ data = [ ] ) : IMail { $ this -> messageData [ 'html' ] [ ] = [ 'file' => $ file , 'data' => $ data , ] ; return $ this ; } 
public function viewPlain ( string $ file , array $ data = [ ] ) : IMail { $ this -> messageData [ 'plain' ] [ ] = [ 'file' => $ file , 'data' => $ data , ] ; return $ this ; } 
public function message ( Closure $ callbacks ) : IMail { $ this -> callbackMessage ( $ callbacks , $ this -> makeMessage ( ) ) ; return $ this ; } 
public function attach ( string $ file , Closure $ callbacks = null ) : IMail { $ this -> makeMessage ( ) ; return $ this -> callbackAttachment ( $ this -> createPathAttachment ( $ file ) , $ callbacks ) ; } 
public function attachData ( string $ data , string $ name , Closure $ callbacks = null ) : IMail { $ this -> makeMessage ( ) ; return $ this -> callbackAttachment ( $ this -> createDataAttachment ( $ data , $ name ) , $ callbacks ) ; } 
public function attachView ( string $ file ) : string { $ this -> makeMessage ( ) ; return $ this -> message -> embed ( Swift_Image :: fromPath ( $ file ) ) ; } 
public function attachDataView ( string $ data , string $ name , ? string $ contentType = null ) : string { $ this -> makeMessage ( ) ; return $ this -> message -> embed ( new Swift_Image ( $ data , $ name , $ contentType ) ) ; } 
public function attachChinese ( string $ file ) : string { $ ext = pathinfo ( $ file , PATHINFO_EXTENSION ) ; if ( $ ext ) { $ file = substr ( $ file , 0 , strrpos ( $ file , '.' . $ ext ) ) ; } return '=?UTF-8?B?' . base64_encode ( $ file ) . '?=' . ( $ ext ? '.' . $ ext : '' ) ; } 
public function send ( Closure $ callbacks = null , bool $ htmlPriority = true ) : int { $ this -> makeMessage ( ) ; $ this -> parseMailContent ( $ htmlPriority ) ; if ( $ callbacks ) { $ this -> message ( $ callbacks ) ; } if ( ! empty ( $ this -> option [ 'global_to' ] [ 'address' ] ) ) { $ this -> message -> addTo ( $ this -> option [ 'global_to' ] [ 'address' ] , $ this -> option [ 'global_to' ] [ 'name' ] ) ; } $ this -> handleDispatch ( $ this -> message ) ; return $ this -> sendMessage ( $ this -> message ) ; } 
protected function handleDispatch ( Swift_Message $ message ) : void { if ( $ this -> dispatch ) { $ this -> dispatch -> handle ( self :: MAIL_EVENT , $ message ) ; } } 
protected function getViewData ( string $ file , array $ data ) : string { return $ this -> view -> clearAssign ( ) -> assign ( 'mail' , $ this ) -> assign ( $ data ) -> display ( $ file , [ ] , null ) ; } 
protected function parseMailContent ( bool $ htmlPriority = true ) : void { $ findBody = false ; $ messageData = $ this -> messageData ; if ( ! empty ( $ messageData [ 'html' ] ) && ! empty ( $ messageData [ 'plain' ] ) ) { unset ( $ messageData [ true === $ htmlPriority ? 'plain' : 'html' ] ) ; } if ( ! empty ( $ messageData [ 'html' ] ) ) { foreach ( $ messageData [ 'html' ] as $ view ) { if ( false === $ findBody ) { $ method = 'setBody' ; $ findBody = true ; } else { $ method = 'addPart' ; } $ this -> message -> { $ method } ( is_array ( $ view ) ? $ this -> getViewData ( $ view [ 'file' ] , $ view [ 'data' ] ) : $ view , 'text/html' ) ; } } if ( ! empty ( $ messageData [ 'plain' ] ) ) { foreach ( $ messageData [ 'plain' ] as $ view ) { if ( false === $ findBody ) { $ method = 'setBody' ; $ findBody = true ; } else { $ method = 'addPart' ; } $ this -> message -> { $ method } ( is_array ( $ view ) ? $ this -> getViewData ( $ view [ 'file' ] , $ view [ 'data' ] ) : $ view , 'text/plain' ) ; } } } 
protected function sendMessage ( Swift_Message $ message ) : int { return $ this -> connect -> send ( $ message , $ this -> failedRecipients ) ; } 
protected function makeMessage ( ) : Swift_Message { if ( null !== $ this -> message ) { return $ this -> message ; } $ message = new Swift_Message ( ) ; if ( ! empty ( $ this -> option [ 'global_from' ] [ 'address' ] ) ) { $ message -> setFrom ( $ this -> option [ 'global_from' ] [ 'address' ] , $ this -> option [ 'global_from' ] [ 'name' ] ) ; } return $ this -> message = $ message ; } 
protected function callbackAttachment ( Swift_Attachment $ attachment , Closure $ callbacks = null ) : IMail { if ( $ callbacks ) { $ callbacks ( $ attachment , $ this ) ; } $ this -> message -> attach ( $ attachment ) ; return $ this ; } 
public function getCachePath ( string $ file ) : string { if ( ! $ this -> option [ 'cache_path' ] ) { throw new RuntimeException ( 'Theme cache path must be set.' ) ; } $ file = str_replace ( '//' , '/' , str_replace ( '\\' , '/' , $ file ) ) ; $ file = basename ( $ file , '.' . pathinfo ( $ file , PATHINFO_EXTENSION ) ) . '.' . md5 ( $ file ) . '.php' ; return $ this -> option [ 'cache_path' ] . '/' . $ file ; } 
protected function parser ( ) : IParser { if ( null !== $ this -> parser ) { return $ this -> parser ; } return $ this -> parser = $ this -> resolverParser ( ) ; } 
protected function isCacheExpired ( string $ file , string $ cachepath ) : bool { if ( ! is_file ( $ cachepath ) ) { return true ; } if ( filemtime ( $ file ) >= filemtime ( $ cachepath ) ) { return true ; } return false ; } 
public function call ( Request $ request ) : Response { $ httpRequest = $ this -> normalizeRequest ( $ request ) ; $ response = App :: make ( IKernel :: class ) -> handle ( $ httpRequest ) ; return $ this -> normalizeResponse ( $ response ) ; } 
protected function normalizeResponse ( IResponse $ response ) : Response { if ( $ response instanceof RedirectResponse ) { $ content = json_encode ( [ 'target_url' => $ response -> getTargetUrl ( ) ] ) ; } else { $ content = $ response -> getContent ( ) ; } return new Response ( [ 'status' => $ response -> getStatusCode ( ) , 'data' => $ content , ] ) ; } 
protected function normalizeRequest ( Request $ request ) : HttpRequest { if ( ! $ request -> call ) { throw new InvalidArgumentException ( 'Rpc call is not set.' ) ; } $ httpRequest = new HttpRequest ( ) ; 
protected function setPreRequestMatched ( IRequest $ request , array $ data ) : void { App :: make ( IRouter :: class ) -> setPreRequestMatched ( $ request , [ IRouter :: VARS => $ data ] ) ; } 
public function addScandir ( string $ dir ) : void { if ( ! is_dir ( $ dir ) ) { throw new InvalidArgumentException ( sprintf ( 'OpenApi scandir %s is exits.' , $ dir ) ) ; } $ this -> scandirs [ ] = $ dir ; } 
public function handle ( ) : array { $ openApi = $ this -> makeOpenApi ( ) ; $ this -> parseMainPath ( $ openApi ) ; $ routers = $ this -> normalizeFastRoute ( $ this -> parseMainRouters ( $ openApi ) ) ; return $ this -> packageRouters ( $ routers ) ; } 
protected function parseMainPath ( OpenApi $ openApi ) : void { list ( $ this -> basePaths , $ this -> groupPaths ) = $ this -> parsePaths ( $ openApi ) ; $ this -> groups = $ this -> parseGroups ( $ openApi ) ; } 
protected function parseMainRouters ( OpenApi $ openApi ) : array { $ routers = [ ] ; if ( $ openApi -> paths ) { foreach ( $ openApi -> paths as $ path ) { $ routers = $ this -> parseOpenApiPath ( $ path , $ routers ) ; } } return $ routers ; } 
protected function parseOpenApiPath ( PathItem $ path , array $ routers ) : array { foreach ( $ this -> methods as $ m ) { $ method = $ path -> { $ m } ; 
protected function isRouterIgnore ( $ method , string $ path ) : bool { if ( ! is_object ( $ method ) || true === $ method -> deprecated || ( property_exists ( $ method , 'leevelIgnore' ) && $ method -> leevelIgnore ) ) { return true ; } 
protected function parseRouterField ( $ method ) : array { $ result = [ ] ; foreach ( $ this -> routerField as $ f ) { $ field = 'leevel' . ucfirst ( $ f ) ; if ( property_exists ( $ method , $ field ) ) { $ result [ $ f ] = $ method -> { $ field } ; } } return $ result ; } 
protected function parseRouterBind ( $ method , array $ router ) : array { if ( empty ( $ router [ 'bind' ] ) ) { $ router [ 'bind' ] = $ this -> parseBindBySource ( $ method -> _context ) ; } if ( $ router [ 'bind' ] ) { $ router [ 'bind' ] = '\\' . trim ( $ router [ 'bind' ] , '\\' ) ; } return $ router ; } 
protected function parseRouterPath ( string $ path , array $ groupPaths , array $ groups ) : array { $ routerPath = $ this -> normalizePath ( $ path ) ; $ pathPrefix = '' ; if ( $ groupPaths ) { foreach ( $ groupPaths as $ key => $ item ) { if ( 0 === strpos ( $ routerPath , $ key ) ) { $ pathPrefix = $ key ; $ routerPath = substr ( $ routerPath , strlen ( $ key ) ) ; break ; } } } $ prefix = $ routerPath [ 1 ] ; $ groupPrefix = '_' ; foreach ( $ groups as $ g ) { if ( 0 === strpos ( $ routerPath , $ g ) ) { $ groupPrefix = $ g ; break ; } } $ routerPath = $ pathPrefix . $ routerPath ; return [ $ prefix , $ groupPrefix , $ routerPath ] ; } 
protected function parseRouterMiddlewares ( array $ router ) : array { if ( ! empty ( $ router [ 'middlewares' ] ) ) { $ router [ 'middlewares' ] = $ this -> middlewareParser -> handle ( normalize ( $ router [ 'middlewares' ] ) ) ; } return $ router ; } 
protected function parseRouterDomain ( array $ router ) : array { $ router [ 'domain' ] = $ this -> normalizeDomain ( $ router [ 'domain' ] ?? '' , $ this -> domain ? : '' ) ; if ( $ router [ 'domain' ] && false !== strpos ( $ router [ 'domain' ] , '{' ) ) { list ( $ router [ 'domain_regex' ] , $ router [ 'domain_var' ] ) = $ this -> ruleRegex ( $ router [ 'domain' ] , $ router , true ) ; } if ( ! $ router [ 'domain' ] ) { unset ( $ router [ 'domain' ] ) ; } return $ router ; } 
protected function parseRouterRegex ( string $ path , array $ router ) : array { list ( $ router [ 'regex' ] , $ router [ 'var' ] ) = $ this -> ruleRegex ( $ path , $ router ) ; return $ router ; } 
protected function normalizeFastRoute ( array $ routers ) : array { 
protected function parseToGroups ( array & $ routers ) : array { $ groups = [ ] ; $ groupIndex = 0 ; foreach ( $ routers as $ key => & $ item ) { $ groups [ ( int ) ( $ groupIndex / 10 ) ] [ $ key ] = $ item ; unset ( $ item [ 'regex' ] ) ; $ groupIndex ++ ; } return $ groups ; } 
protected function parseGroupRegex ( array $ routers ) : array { $ minCount = $ this -> computeMinCountVar ( $ routers ) ; $ regex = [ ] ; $ ruleMap = [ ] ; $ ruleKey = 0 ; $ regex [ ] = '~^(?' ; foreach ( $ routers as $ key => $ router ) { $ countVar = $ minCount + $ ruleKey ; $ emptyMatche = $ countVar - count ( $ router [ 'var' ] ) ; $ ruleMap [ $ countVar + 1 ] = $ key ; $ regex [ ] = '|' . $ router [ 'regex' ] . ( $ emptyMatche ? str_repeat ( '()' , $ emptyMatche ) : '' ) ; $ ruleKey ++ ; } $ regex [ ] = ')$~x' ; return [ implode ( '' , $ regex ) , $ ruleMap , ] ; } 
protected function computeMinCountVar ( array $ routers ) : int { $ minCount = 1 ; foreach ( $ routers as $ item ) { if ( ( $ curCount = count ( $ item [ 'var' ] ) ) > $ minCount ) { $ minCount = $ curCount ; } } return $ minCount ; } 
protected function parseBindBySource ( Context $ context ) : ? string { if ( ! $ context -> class || ! $ context -> method ) { return null ; } return $ context -> fullyQualifiedName ( $ context -> class ) . '@' . $ context -> method ; } 
protected function parseGroups ( OpenApi $ openApi ) : array { $ groups = [ ] ; if ( $ openApi -> tags ) { foreach ( $ openApi -> tags as $ tag ) { if ( property_exists ( $ tag , 'leevelGroup' ) ) { $ groups [ ] = '/' . $ tag -> leevelGroup ; } } } return $ groups ; } 
protected function ruleRegex ( string $ rule , array $ routers , bool $ forSingleRegex = false ) : array { $ routerVar = [ ] ; $ mapRegex = [ 'find' => [ ] , 'replace' => [ ] , ] ; $ rule = preg_replace_callback ( '/{(.+?)}/' , function ( $ matches ) use ( $ routers , & $ routerVar , & $ mapRegex ) { if ( false !== strpos ( $ matches [ 1 ] , ':' ) ) { list ( $ routerVar [ ] , $ regex ) = explode ( ':' , $ matches [ 1 ] ) ; } else { $ routerVar [ ] = $ matches [ 1 ] ; $ regex = IRouter :: DEFAULT_REGEX ; } $ regex = '(' . $ regex . ')' ; $ regexEncode = '`' . md5 ( $ regex ) . '`' ; $ mapRegex [ 'find' ] [ ] = $ regexEncode ; $ mapRegex [ 'replace' ] [ ] = $ regex ; return $ regexEncode ; } , $ rule ) ; if ( false === $ forSingleRegex ) { $ rule = preg_quote ( $ rule ) ; } else { $ rule = preg_quote ( $ rule , '/' ) ; } if ( $ mapRegex [ 'find' ] ) { $ rule = str_replace ( $ mapRegex [ 'find' ] , $ mapRegex [ 'replace' ] , $ rule ) ; } if ( true === $ forSingleRegex ) { $ rule = '/^' . $ rule . '$/' ; } return [ $ rule , $ routerVar ] ; } 
protected function normalizeDomain ( string $ domain , string $ topDomain ) : string { if ( ! $ domain || ! $ this -> domain ) { return $ domain ; } if ( $ topDomain !== substr ( $ domain , - strlen ( $ topDomain ) ) ) { $ domain .= '.' . $ topDomain ; } return $ domain ; } 
protected function parsePaths ( OpenApi $ openApi ) : array { if ( \ OpenApi \ UNDEFINED === $ openApi -> externalDocs ) { return [ [ ] , [ ] ] ; } $ externalDocs = $ openApi -> externalDocs ; if ( ! property_exists ( $ externalDocs , 'leevels' ) ) { return [ [ ] , [ ] ] ; } $ leevels = $ externalDocs -> leevels ; $ tmps = is_array ( $ leevels ) ? $ leevels : [ $ leevels ] ; $ basePaths = $ groupPaths = [ ] ; foreach ( $ tmps as $ key => $ value ) { 
protected function cacheLoad ( ) : void { $ this -> container -> singleton ( 'cache.load' , function ( IContainer $ container ) { return new Load ( $ container , $ container [ 'cache' ] ) ; } ) ; } 
public function handle ( IApp $ app ) : void { $ this -> line ( 'Start to cache option.' ) ; $ load = new Load ( $ app -> optionPath ( ) ) ; $ data = $ load -> loadData ( $ app ) ; $ cachePath = $ app -> optionCachedPath ( ) ; $ this -> basePath = $ app -> path ( ) ; $ this -> writeCache ( $ cachePath , $ data ) ; $ this -> info ( sprintf ( 'Option cache file %s cache successed.' , $ cachePath ) ) ; } 
protected function computeRelativePath ( string $ cachePath ) : int { if ( false === strpos ( $ cachePath , $ this -> basePath ) ) { return - 1 ; } $ relativePath = str_replace ( $ this -> basePath . '/' , '' , $ cachePath ) ; $ relativePath = dirname ( $ relativePath ) ; return count ( explode ( '/' , $ relativePath ) ) ; } 
protected function writeCache ( string $ cachePath , array $ data ) : void { $ relativePathLevel = $ this -> computeRelativePath ( $ cachePath ) ; $ isRelativePath = $ relativePathLevel > - 1 ; $ content = '<?' . 'php /* ' . date ( 'Y-m-d H:i:s' ) . ' */ ?' . '>' ; if ( $ isRelativePath ) { $ content .= PHP_EOL . '<?' . 'php $baseDir = dirname(__DIR__, ' . $ relativePathLevel . '); ?>' ; } $ content .= PHP_EOL . '<?' . 'php return ' . var_export ( $ data , true ) . '; ?' . '>' ; if ( $ isRelativePath ) { $ content = $ this -> replaceRelativePath ( $ content ) ; } create_file ( $ cachePath , $ content ) ; } 
protected function createConnect ( object $ connect ) : object { return new Mail ( $ connect , $ this -> container [ 'view' ] , $ this -> container [ 'event' ] , $ this -> getCommonOption ( ) ) ; } 
public function has ( string $ name = 'app\\' ) : bool { $ name = $ this -> parseNamespace ( $ name ) ; $ namespaces = $ name [ 0 ] ; $ name = $ name [ 1 ] ; if ( '*' === $ name ) { return isset ( $ this -> option [ $ namespaces ] ) ; } if ( ! strpos ( $ name , '.' ) ) { return array_key_exists ( $ name , $ this -> option [ $ namespaces ] ) ; } $ parts = explode ( '.' , $ name ) ; $ option = $ this -> option [ $ namespaces ] ; foreach ( $ parts as $ part ) { if ( ! isset ( $ option [ $ part ] ) ) { return false ; } $ option = $ option [ $ part ] ; } return true ; } 
public function get ( string $ name = 'app\\' , $ defaults = null ) { $ name = $ this -> parseNamespace ( $ name ) ; $ namespaces = $ name [ 0 ] ; $ name = $ name [ 1 ] ; if ( '*' === $ name ) { return $ this -> option [ $ namespaces ] ; } if ( ! strpos ( $ name , '.' ) ) { return array_key_exists ( $ name , $ this -> option [ $ namespaces ] ) ? $ this -> option [ $ namespaces ] [ $ name ] : $ defaults ; } $ parts = explode ( '.' , $ name ) ; $ option = $ this -> option [ $ namespaces ] ; foreach ( $ parts as $ part ) { if ( ! isset ( $ option [ $ part ] ) ) { return $ defaults ; } $ option = $ option [ $ part ] ; } return $ option ; } 
public function set ( $ name , $ value = null ) : void { if ( is_array ( $ name ) ) { foreach ( $ name as $ key => $ value ) { $ this -> set ( $ key , $ value ) ; } } else { $ name = $ this -> parseNamespace ( $ name ) ; $ namespaces = $ name [ 0 ] ; $ name = $ name [ 1 ] ; if ( '*' === $ name ) { $ this -> option [ $ namespaces ] = $ value ; return ; } if ( ! strpos ( $ name , '.' ) ) { $ this -> option [ $ namespaces ] [ $ name ] = $ value ; } else { $ parts = explode ( '.' , $ name ) ; $ max = count ( $ parts ) - 1 ; $ option = & $ this -> option [ $ namespaces ] ; for ( $ i = 0 ; $ i <= $ max ; $ i ++ ) { $ part = $ parts [ $ i ] ; if ( $ i < $ max ) { if ( ! isset ( $ option [ $ part ] ) ) { $ option [ $ part ] = [ ] ; } $ option = & $ option [ $ part ] ; } else { $ option [ $ part ] = $ value ; } } } } } 
public function delete ( string $ name ) : void { $ name = $ this -> parseNamespace ( $ name ) ; $ namespaces = $ name [ 0 ] ; $ name = $ name [ 1 ] ; if ( '*' === $ name ) { $ this -> option [ $ namespaces ] = [ ] ; return ; } if ( ! strpos ( $ name , '.' ) ) { if ( isset ( $ this -> option [ $ namespaces ] [ $ name ] ) ) { unset ( $ this -> option [ $ namespaces ] [ $ name ] ) ; } } else { $ parts = explode ( '.' , $ name ) ; $ max = count ( $ parts ) - 1 ; $ option = & $ this -> option [ $ namespaces ] ; for ( $ i = 0 ; $ i <= $ max ; $ i ++ ) { $ part = $ parts [ $ i ] ; if ( $ i < $ max ) { if ( ! isset ( $ option [ $ part ] ) ) { break ; } $ option = & $ option [ $ part ] ; } else { if ( isset ( $ option [ $ part ] ) ) { unset ( $ option [ $ part ] ) ; } } } } } 
public function reset ( $ namespaces = null ) : void { if ( is_array ( $ namespaces ) ) { $ this -> option = $ namespaces ; } elseif ( is_string ( $ namespaces ) ) { $ this -> option [ $ namespaces ] = [ ] ; } else { $ this -> option = [ ] ; } } 
protected function parseNamespace ( string $ name ) : array { if ( strpos ( $ name , '\\' ) ) { $ namespaces = explode ( '\\' , $ name ) ; if ( empty ( $ namespaces [ 1 ] ) ) { $ namespaces [ 1 ] = '*' ; } $ name = $ namespaces [ 1 ] ; $ namespaces = $ namespaces [ 0 ] ; } else { $ namespaces = static :: DEFAUTL_NAMESPACE ; } if ( ! isset ( $ this -> option [ $ namespaces ] ) ) { $ this -> option [ $ namespaces ] = [ ] ; } return [ $ namespaces , $ name , ] ; } 
public function get ( string $ name , $ defaults = false , array $ option = [ ] ) { $ option = $ this -> normalizeOptions ( $ option ) ; $ data = $ this -> handle -> get ( $ this -> getCacheName ( $ name ) ) ; if ( false === $ data ) { return $ defaults ; } if ( $ option [ 'serialize' ] && is_string ( $ data ) ) { $ data = unserialize ( $ data ) ; } return $ data ; } 
public function set ( string $ name , $ data , array $ option = [ ] ) : void { $ option = $ this -> normalizeOptions ( $ option ) ; if ( $ option [ 'serialize' ] ) { $ data = serialize ( $ data ) ; } $ option [ 'expire' ] = $ this -> cacheTime ( $ name , ( int ) $ option [ 'expire' ] ) ; $ this -> handle -> set ( $ this -> getCacheName ( $ name ) , $ data , $ option [ 'expire' ] ? ( int ) $ option [ 'expire' ] : null ) ; } 
public function delete ( string $ name ) : void { $ this -> handle -> delete ( $ this -> getCacheName ( $ name ) ) ; } 
public function add ( $ index , $ newval ) : void { $ this -> validate ( $ newval ) ; parent :: add ( $ index , $ newval ) ; } 
public function offsetSet ( $ index , $ newval ) : void { $ this -> validate ( $ newval ) ; parent :: offsetSet ( $ index , $ newval ) ; } 
public function validate ( $ value ) : void { if ( ! $ this -> checkType ( $ value ) ) { $ e = sprintf ( 'The linkedlist element type verification failed, and the allowed type is %s.' , implode ( ',' , $ this -> type ) ) ; throw new InvalidArgumentException ( $ e ) ; } } 
protected function checkType ( $ value ) : bool { if ( ! $ this -> type ) { return true ; } return type_these ( $ value , $ this -> type ) ; } 
protected function intOption ( ) : void { if ( $ this -> option [ 'large_size' ] ) { $ this -> setLargeSize ( ) ; } elseif ( $ this -> option [ 'small_size' ] ) { $ this -> setSmallSize ( ) ; } } 
protected function getFirstRender ( ) : string { if ( ! $ this -> page -> canFirstRender ( ) ) { return '' ; } return sprintf ( '<li class=""><a href="%s" >1</a></li>' . '<li><a href="%s">...</a></li>' , $ this -> replace ( 1 ) , $ this -> replace ( $ this -> page -> parseFirstRenderPrev ( ) ) ) ; } 
protected function getPrevRender ( ) : string { if ( $ this -> page -> canPrevRender ( ) ) { return sprintf ( '<li><a aria-label="Previous" href="%s">' . '<span aria-hidden="true">&laquo;</span></a></li>' , $ this -> replace ( $ this -> page -> parsePrevRenderPrev ( ) ) ) ; } return '<li class="disabled"><a aria-label="Previous">' . '<span aria-hidden="true">&laquo;</span></a></li>' ; } 
public function addDir ( array $ dirs ) : self { $ this -> dirs = array_unique ( array_merge ( $ this -> dirs , $ dirs ) ) ; return $ this ; } 
public function loadData ( ) : array { if ( null !== $ this -> loaded ) { return $ this -> loaded ; } $ files = $ this -> findMoFile ( $ this -> parseDir ( $ this -> dirs ) ) ; $ texts = $ this -> parseMoData ( $ files ) ; return $ this -> loaded = $ texts ; } 
protected function findMoFile ( array $ dirs ) : array { $ files = [ ] ; foreach ( $ dirs as $ dir ) { if ( ! is_dir ( $ dir ) ) { throw new RuntimeException ( sprintf ( 'I18n load dir %s is not exits.' , $ dir ) ) ; } $ files = array_merge ( $ files , $ this -> getMoFiles ( $ dir ) ) ; } return $ files ; } 
protected function parseDir ( array $ dirs ) : array { $ i18n = $ this -> i18n ; return array_map ( function ( $ dir ) use ( $ i18n ) { return $ dir . '/' . $ i18n ; } , $ dirs ) ; } 
public function insert ( $ data , array $ bind = [ ] , bool $ replace = false ) : array { 
public function insertAll ( array $ data , array $ bind = [ ] , bool $ replace = false ) : array { 
public function update ( $ data , array $ bind = [ ] ) : array { 
public function delete ( ? string $ data = null , array $ bind = [ ] ) : array { 
public function truncate ( ) : array { 
public function forPage ( int $ page , int $ perPage = 15 ) : self { return $ this -> limit ( ( $ page - 1 ) * $ perPage , $ perPage ) ; } 
public function time ( string $ type = 'date' ) : self { if ( $ this -> checkFlowControl ( ) ) { return $ this ; } if ( ! in_array ( $ type , [ 'date' , 'month' , 'day' , 'year' ] , true ) ) { throw new InvalidArgumentException ( sprintf ( 'Time type `%s` is invalid.' , $ type ) ) ; } $ this -> setInTimeCondition ( $ type ) ; return $ this ; } 
public function reset ( ? string $ option = null ) : self { if ( $ this -> checkFlowControl ( ) ) { return $ this ; } if ( null === $ option ) { $ this -> initOption ( ) ; } elseif ( array_key_exists ( $ option , static :: $ optionsDefault ) ) { $ this -> options [ $ option ] = static :: $ optionsDefault [ $ option ] ; } return $ this ; } 
public function prefix ( string $ prefix ) : self { if ( $ this -> checkFlowControl ( ) ) { return $ this ; } $ this -> options [ 'prefix' ] [ ] = $ prefix ; return $ this ; } 
public function table ( $ table , $ cols = '*' ) : self { if ( $ this -> checkFlowControl ( ) ) { return $ this ; } $ this -> setIsTable ( true ) ; $ this -> addJoin ( 'inner join' , $ table , $ cols ) ; $ this -> setIsTable ( false ) ; return $ this ; } 
public function columns ( $ cols = '*' , ? string $ table = null ) : self { if ( $ this -> checkFlowControl ( ) ) { return $ this ; } if ( null === $ table ) { $ table = $ this -> getTable ( ) ; } $ this -> addCols ( $ table , $ cols ) ; return $ this ; } 
public function setColumns ( $ cols = '*' , ? string $ table = null ) : self { if ( $ this -> checkFlowControl ( ) ) { return $ this ; } if ( null === $ table ) { $ table = $ this -> getTable ( ) ; } $ this -> options [ 'columns' ] = [ ] ; $ this -> addCols ( $ table , $ cols ) ; return $ this ; } 
public function where ( ... $ arr ) : self { if ( $ this -> checkFlowControl ( ) ) { return $ this ; } array_unshift ( $ arr , static :: LOGIC_AND ) ; array_unshift ( $ arr , 'where' ) ; return $ this -> aliatypeAndLogic ( ... $ arr ) ; } 
public function orWhere ( ... $ arr ) : self { if ( $ this -> checkFlowControl ( ) ) { return $ this ; } array_unshift ( $ arr , static :: LOGIC_OR ) ; array_unshift ( $ arr , 'where' ) ; return $ this -> aliatypeAndLogic ( ... $ arr ) ; } 
public function bind ( $ names , $ value = null , int $ type = PDO :: PARAM_STR ) : self { if ( $ this -> checkFlowControl ( ) ) { return $ this ; } if ( is_array ( $ names ) ) { foreach ( $ names as $ key => $ item ) { if ( ! is_array ( $ item ) ) { $ item = [ $ item , $ type , ] ; } $ this -> bindParams [ $ key ] = $ item ; } } else { if ( ! is_array ( $ value ) ) { $ value = [ $ value , $ type , ] ; } $ this -> bindParams [ $ names ] = $ value ; } return $ this ; } 
public function forceIndex ( $ indexs , $ type = 'FORCE' ) : self { if ( $ this -> checkFlowControl ( ) ) { return $ this ; } if ( ! isset ( static :: $ indexTypes [ $ type ] ) ) { throw new InvalidArgumentException ( sprintf ( 'Invalid Index type `%s`.' , $ type ) ) ; } $ type = strtoupper ( $ type ) ; $ indexs = normalize ( $ indexs ) ; foreach ( $ indexs as $ value ) { $ value = normalize ( $ value ) ; foreach ( $ value as $ tmp ) { $ this -> options [ 'index' ] [ $ type ] [ ] = $ tmp ; } } return $ this ; } 
public function join ( $ table , $ cols , $ cond ) : self { if ( $ this -> checkFlowControl ( ) ) { return $ this ; } $ args = func_get_args ( ) ; array_unshift ( $ args , 'inner join' ) ; return $ this -> addJoin ( ... $ args ) ; } 
public function union ( $ selects , string $ type = 'UNION' ) : self { if ( $ this -> checkFlowControl ( ) ) { return $ this ; } if ( ! isset ( static :: $ unionTypes [ $ type ] ) ) { throw new InvalidArgumentException ( sprintf ( 'Invalid UNION type `%s`.' , $ type ) ) ; } if ( ! is_array ( $ selects ) ) { $ selects = [ $ selects , ] ; } foreach ( $ selects as $ tmp ) { $ this -> options [ 'union' ] [ ] = [ $ tmp , $ type , ] ; } return $ this ; } 
public function groupBy ( $ expression ) : self { if ( $ this -> checkFlowControl ( ) ) { return $ this ; } if ( is_string ( $ expression ) && false !== strpos ( $ expression , ',' ) && false !== strpos ( $ expression , '{' ) && preg_match_all ( '/{(.+?)}/' , $ expression , $ matches ) ) { $ expression = str_replace ( $ matches [ 1 ] [ 0 ] , base64_encode ( $ matches [ 1 ] [ 0 ] ) , $ expression ) ; } $ expression = normalize ( $ expression ) ; 
public function having ( ... $ arr ) : self { if ( $ this -> checkFlowControl ( ) ) { return $ this ; } array_unshift ( $ arr , static :: LOGIC_AND ) ; array_unshift ( $ arr , 'having' ) ; return $ this -> aliatypeAndLogic ( ... $ arr ) ; } 
public function orHaving ( ... $ arr ) : self { if ( $ this -> checkFlowControl ( ) ) { return $ this ; } array_unshift ( $ arr , static :: LOGIC_OR ) ; array_unshift ( $ arr , 'having' ) ; return $ this -> aliatypeAndLogic ( ... $ arr ) ; } 
public function havingRaw ( string $ raw ) : self { if ( $ this -> checkFlowControl ( ) ) { return $ this ; } $ condition = [ ] ; array_unshift ( $ condition , static :: LOGIC_AND ) ; array_unshift ( $ condition , 'having' ) ; $ condition [ ] = [ ':stringSimple' => '{' . $ raw . '}' ] ; return $ this -> aliatypeAndLogic ( ... $ condition ) ; } 
public function orHavingRaw ( string $ raw ) : self { if ( $ this -> checkFlowControl ( ) ) { return $ this ; } $ condition = [ ] ; array_unshift ( $ condition , static :: LOGIC_OR ) ; array_unshift ( $ condition , 'having' ) ; $ condition [ ] = [ ':stringSimple' => '{' . $ raw . '}' ] ; return $ this -> aliatypeAndLogic ( ... $ condition ) ; } 
public function orderBy ( $ expression , string $ orderDefault = 'ASC' ) : self { if ( $ this -> checkFlowControl ( ) ) { return $ this ; } 
public function distinct ( bool $ flag = true ) : self { if ( $ this -> checkFlowControl ( ) ) { return $ this ; } $ this -> options [ 'distinct' ] = $ flag ; return $ this ; } 
public function count ( string $ field = '*' , string $ alias = 'row_count' ) : self { if ( $ this -> checkFlowControl ( ) ) { return $ this ; } return $ this -> addAggregate ( 'COUNT' , $ field , $ alias ) ; } 
public function avg ( string $ field , string $ alias = 'avg_value' ) : self { if ( $ this -> checkFlowControl ( ) ) { return $ this ; } return $ this -> addAggregate ( 'AVG' , $ field , $ alias ) ; } 
public function max ( string $ field , string $ alias = 'max_value' ) : self { if ( $ this -> checkFlowControl ( ) ) { return $ this ; } return $ this -> addAggregate ( 'MAX' , $ field , $ alias ) ; } 
public function min ( string $ field , string $ alias = 'min_value' ) : self { if ( $ this -> checkFlowControl ( ) ) { return $ this ; } return $ this -> addAggregate ( 'MIN' , $ field , $ alias ) ; } 
public function sum ( string $ field , string $ alias = 'sum_value' ) : self { if ( $ this -> checkFlowControl ( ) ) { return $ this ; } return $ this -> addAggregate ( 'SUM' , $ field , $ alias ) ; } 
public function one ( ) : self { if ( $ this -> checkFlowControl ( ) ) { return $ this ; } $ this -> options [ 'limitCount' ] = 1 ; $ this -> options [ 'limitOffset' ] = null ; $ this -> options [ 'limitQuery' ] = false ; return $ this ; } 
public function all ( ) : self { if ( $ this -> checkFlowControl ( ) ) { return $ this ; } if ( $ this -> options [ 'limitQuery' ] ) { return $ this ; } $ this -> options [ 'limitCount' ] = null ; $ this -> options [ 'limitOffset' ] = null ; $ this -> options [ 'limitQuery' ] = true ; return $ this ; } 
public function top ( int $ count = 30 ) : self { if ( $ this -> checkFlowControl ( ) ) { return $ this ; } return $ this -> limit ( 0 , $ count ) ; } 
public function limit ( int $ offset = 0 , int $ count = 0 ) : self { if ( $ this -> checkFlowControl ( ) ) { return $ this ; } if ( 0 === $ count ) { return $ this -> top ( $ offset ) ; } $ this -> options [ 'limitCount' ] = $ count ; $ this -> options [ 'limitOffset' ] = $ offset ; $ this -> options [ 'limitQuery' ] = true ; return $ this ; } 
public function forUpdate ( bool $ flag = true ) : self { if ( $ this -> checkFlowControl ( ) ) { return $ this ; } $ this -> options [ 'forUpdate' ] = $ flag ; return $ this ; } 
public function makeSql ( bool $ withLogicGroup = false ) : string { $ sql = [ 'SELECT' , ] ; foreach ( array_keys ( $ this -> options ) as $ option ) { if ( 'from' === $ option ) { $ sql [ 'from' ] = '' ; } elseif ( 'union' === $ option ) { continue ; } else { $ method = 'parse' . ucfirst ( $ option ) ; if ( method_exists ( $ this , $ method ) ) { $ sql [ $ option ] = $ this -> { $ method } ( ) ; } } } $ sql [ 'from' ] = $ this -> parseFrom ( ) ; 
public function setOption ( string $ name , $ value ) : self { $ this -> options [ $ name ] = $ value ; return $ this ; } 
protected function callWhereSugar ( string $ method , array $ args ) { if ( ! in_array ( $ method , [ 'whereNotBetween' , 'whereBetween' , 'whereNotNull' , 'whereNull' , 'whereNotIn' , 'whereIn' , 'whereNotLike' , 'whereLike' , 'whereDate' , 'whereDay' , 'whereMonth' , 'whereYear' , ] , true ) ) { return false ; } if ( $ this -> checkFlowControl ( ) ) { return $ this ; } if ( in_array ( $ method , [ 'whereDate' , 'whereDay' , 'whereMonth' , 'whereYear' ] , true ) ) { $ this -> setInTimeCondition ( strtolower ( substr ( $ method , 5 ) ) ) ; $ this -> where ( ... $ args ) ; $ this -> setInTimeCondition ( null ) ; return $ this ; } $ this -> setTypeAndLogic ( 'where' , static :: LOGIC_AND ) ; if ( 0 === strpos ( $ method , 'whereNot' ) ) { $ type = 'not ' . strtolower ( substr ( $ method , 8 ) ) ; } else { $ type = strtolower ( substr ( $ method , 5 ) ) ; } array_unshift ( $ args , $ type ) ; return $ this -> aliasCondition ( ... $ args ) ; } 
protected function callJoinSugar ( string $ method , array $ args ) { if ( ! in_array ( $ method , [ 'innerJoin' , 'leftJoin' , 'rightJoin' , 'fullJoin' , 'crossJoin' , 'naturalJoin' , ] , true ) ) { return false ; } if ( $ this -> checkFlowControl ( ) ) { return $ this ; } $ type = substr ( $ method , 0 , - 4 ) . ' join' ; array_unshift ( $ args , $ type ) ; return $ this -> addJoin ( ... $ args ) ; } 
protected function parseColumns ( ) : string { if ( empty ( $ this -> options [ 'columns' ] ) ) { return '' ; } $ columns = [ ] ; foreach ( $ this -> options [ 'columns' ] as $ item ) { list ( $ tableName , $ col , $ alias ) = $ item ; 
protected function parseAggregate ( ) : string { if ( empty ( $ this -> options [ 'aggregate' ] ) ) { return '' ; } $ columns = [ ] ; foreach ( $ this -> options [ 'aggregate' ] as $ item ) { list ( , $ field , $ alias ) = $ item ; $ columns [ ] = $ field . ' AS ' . $ alias ; } return $ columns ? implode ( ',' , $ columns ) : '' ; } 
protected function parseFrom ( ) : string { if ( empty ( $ this -> options [ 'from' ] ) ) { return '' ; } $ from = [ ] ; foreach ( $ this -> options [ 'from' ] as $ alias => $ value ) { $ tmp = '' ; 
protected function parseTable ( ) : string { foreach ( $ this -> options [ 'from' ] as $ alias => $ value ) { if ( $ alias === $ value [ 'table_name' ] ) { $ alias = $ this -> connect -> normalizeTableOrColumn ( "{$value['schema']}.{$value['table_name']}" ) ; } break ; } return $ alias ; } 
protected function parseIndex ( ) : string { $ index = '' ; foreach ( [ 'FORCE' , 'IGNORE' , ] as $ type ) { if ( empty ( $ this -> options [ 'index' ] [ $ type ] ) ) { continue ; } $ index .= ( $ index ? ' ' : '' ) . $ type . ' INDEX(' . implode ( ',' , $ this -> options [ 'index' ] [ $ type ] ) . ')' ; } return $ index ; } 
protected function parseWhere ( bool $ child = false ) : string { if ( empty ( $ this -> options [ 'where' ] ) ) { return '' ; } return $ this -> analyseCondition ( 'where' , $ child ) ; } 
protected function parseUnion ( ) : string { if ( empty ( $ this -> options [ 'union' ] ) ) { return '' ; } $ sql = '' ; if ( $ this -> options [ 'union' ] ) { $ options = count ( $ this -> options [ 'union' ] ) ; foreach ( $ this -> options [ 'union' ] as $ index => $ value ) { list ( $ union , $ type ) = $ value ; if ( $ union instanceof self || $ union instanceof Select ) { $ union = $ union -> makeSql ( ) ; } if ( $ index <= $ options - 1 ) { $ sql .= "\n" . $ type . ' ' . $ union ; } } } return $ sql ; } 
protected function parseLimitCount ( bool $ withoutOffset = false ) : string { if ( null === $ this -> options [ 'limitOffset' ] && null === $ this -> options [ 'limitCount' ] ) { return '' ; } return $ this -> connect -> limitCount ( $ this -> options [ 'limitCount' ] , $ withoutOffset ? null : $ this -> options [ 'limitOffset' ] ) ; } 
protected function analyseCondition ( string $ condType , bool $ child = false ) : string { $ sqlCond = [ ] ; $ table = $ this -> getTable ( ) ; foreach ( $ this -> options [ $ condType ] as $ key => $ cond ) { 
protected function aliasCondition ( string $ conditionType , $ cond ) : self { if ( ! is_array ( $ cond ) ) { $ args = func_get_args ( ) ; $ this -> addConditions ( $ args [ 1 ] , $ conditionType , $ args [ 2 ] ?? null ) ; } else { foreach ( $ cond as $ tmp ) { $ this -> addConditions ( $ tmp [ 0 ] , $ conditionType , $ tmp [ 1 ] ) ; } } return $ this ; } 
protected function aliatypeAndLogic ( string $ type , string $ logic , $ cond ) : self { $ this -> setTypeAndLogic ( $ type , $ logic ) ; if ( $ cond instanceof Closure ) { $ select = new static ( $ this -> connect ) ; $ select -> setTable ( $ this -> getTable ( ) ) ; call_user_func_array ( $ cond , [ $ select , ] ) ; $ tmp = $ select -> { 'parse' . ucwords ( $ type ) } ( true ) ; $ this -> setConditionItem ( static :: LOGIC_GROUP_LEFT . $ tmp . static :: LOGIC_GROUP_RIGHT , ':string' ) ; return $ this ; } $ args = func_get_args ( ) ; array_shift ( $ args ) ; array_shift ( $ args ) ; return $ this -> addConditions ( ... $ args ) ; } 
protected function addConditions ( ) : self { $ args = func_get_args ( ) ; $ table = $ this -> getTable ( ) ; 
protected function setConditionItem ( $ items , string $ type = '' ) : void { $ typeAndLogic = $ this -> getTypeAndLogic ( ) ; 
protected function setTypeAndLogic ( ? string $ type = null , ? string $ logic = null ) : void { if ( null !== $ type ) { $ this -> conditionType = $ type ; } if ( null !== $ logic ) { $ this -> conditionLogic = $ logic ; } } 
protected function normalizeColumn ( string $ field , string $ tableName ) : string { if ( false !== strpos ( $ field , '{' ) && preg_match ( '/^{(.+?)}$/' , $ field , $ matches ) ) { $ field = $ this -> connect -> normalizeExpression ( $ matches [ 1 ] , $ tableName ) ; } elseif ( ! preg_match ( '/\(.*\)/' , $ field ) ) { if ( preg_match ( '/(.+)\.(.+)/' , $ field , $ matches ) ) { $ currentTableName = $ matches [ 1 ] ; $ tmp = $ matches [ 2 ] ; } else { $ currentTableName = $ tableName ; } $ field = $ this -> connect -> normalizeTableOrColumn ( "{$currentTableName}.{$field}" ) ; } return $ field ; } 
protected function addJoin ( string $ joinType , $ names , $ cols , $ cond = null ) : self { 
protected function addCols ( string $ tableName , $ cols ) : void { 
protected function addAggregate ( string $ type , string $ field , string $ alias ) : self { $ this -> options [ 'columns' ] = [ ] ; $ tableName = $ this -> getTable ( ) ; 
protected function deleteBindParams ( $ names ) : void { if ( isset ( $ this -> bindParams [ $ names ] ) ) { unset ( $ this -> bindParams [ $ names ] ) ; } } 
protected function normalizeBindData ( array $ data , array $ bind = [ ] , int $ questionMark = 0 , int $ index = 0 ) : array { $ fields = $ values = [ ] ; $ tableName = $ this -> getTable ( ) ; foreach ( $ data as $ key => $ value ) { 
protected function parseTime ( string $ field , $ value , string $ type ) { $ field = str_replace ( '`' , '' , $ field ) ; $ table = $ this -> getTable ( ) ; if ( ! preg_match ( '/\(.*\)/' , $ field ) ) { if ( preg_match ( '/(.+)\.(.+)/' , $ field , $ matches ) ) { $ table = $ matches [ 1 ] ; $ field = $ matches [ 2 ] ; } } 
public function handle ( ) : void { $ this -> info ( $ this -> getLogo ( ) ) ; $ this -> warn ( $ this -> getVersion ( ) ) ; $ server = $ this -> createServer ( ) ; if ( true === $ this -> option ( 'daemonize' ) ) { $ server -> setOption ( 'daemonize' , '1' ) ; } $ this -> checkPort ( $ option = $ server -> getOption ( ) ) ; $ this -> checkService ( $ option ) ; $ this -> start ( $ option ) ; $ server -> startServer ( ) ; } 
protected function start ( array $ option ) : void { $ show = [ ] ; $ basePath = App :: path ( ) ; foreach ( $ option as $ key => $ val ) { if ( is_array ( $ val ) ) { continue ; } if ( in_array ( $ key , [ 'pid_path' , 'document_root' ] , true ) ) { $ val = str_replace ( $ basePath , '@path' , $ val ) ; } $ show [ ] = [ $ key , $ val ] ; } $ this -> table ( [ 'Item' , 'Value' ] , $ show ) ; } 
protected function checkPort ( array $ option ) : void { $ bind = $ this -> portBind ( ( int ) ( $ option [ 'port' ] ) ) ; if ( $ bind ) { foreach ( $ bind as $ k => $ val ) { if ( '*' === $ val [ 'ip' ] || $ val [ 'ip' ] === $ option [ 'host' ] ) { throw new InvalidArgumentException ( sprintf ( 'The port has been used %s:%s,the port process ID is %s' , $ val [ 'ip' ] , $ val [ 'port' ] , $ k ) ) ; } } } } 
protected function portBind ( int $ port ) : array { $ result = [ ] ; $ cmd = "lsof -i :{$port}|awk '$1 != \"COMMAND\" {print $1, $2, $9}'" ; exec ( $ cmd , $ out ) ; if ( ! empty ( $ out ) ) { foreach ( $ out as $ val ) { $ tmp = explode ( ' ' , $ val ) ; list ( $ ip , $ p ) = explode ( ':' , $ tmp [ 2 ] ) ; $ result [ $ tmp [ 1 ] ] = [ 'cmd' => $ tmp [ 0 ] , 'ip' => $ ip , 'port' => $ p , ] ; } } return $ result ; } 
protected function checkService ( array $ option ) : void { $ file = $ option [ 'pid_path' ] ; if ( ! is_file ( $ file ) ) { return ; } $ pid = explode ( PHP_EOL , file_get_contents ( $ file ) ) ; $ cmd = "ps ax | awk '{ print $1 }' | grep -e \"^{$pid[0]}$\"" ; exec ( $ cmd , $ out ) ; if ( ! empty ( $ out ) ) { throw new InvalidArgumentException ( sprintf ( 'Swoole pid file %s is already exists,pid is %d' , $ file , $ pid [ 0 ] ) ) ; } $ this -> warn ( sprintf ( 'Warning:swoole pid file is already exists.' , $ file ) . PHP_EOL . 'It is possible that the swoole service was last unusual exited.' . PHP_EOL . 'The non daemon mode ctrl+c termination is the most possible.' . PHP_EOL ) ; unlink ( $ file ) ; } 
public function addRelationCondition ( ) : void { if ( static :: $ relationCondition ) { $ this -> select -> where ( $ this -> targetKey , $ this -> getSourceValue ( ) ) ; $ this -> select -> whereNotNull ( $ this -> targetKey ) ; } } 
public function preLoadCondition ( array $ entitys ) : void { $ this -> select -> whereIn ( $ this -> targetKey , $ this -> getEntityKey ( $ entitys , $ this -> sourceKey ) ) ; } 
protected function matchPreLoadOneOrMany ( array $ entitys , Collection $ result , string $ relation , string $ type ) : array { $ maps = $ this -> buildMap ( $ result ) ; foreach ( $ entitys as & $ entity ) { $ key = $ entity -> __get ( $ this -> sourceKey ) ; if ( isset ( $ maps [ $ key ] ) ) { $ entity -> withRelationProp ( $ relation , $ this -> getRelationValue ( $ maps , $ key , $ type ) ) ; } } return $ entitys ; } 
protected function getRelationValue ( array $ maps , string $ key , string $ type ) { $ value = $ maps [ $ key ] ; return 'one' === $ type ? reset ( $ value ) : $ this -> targetEntity -> collection ( $ value ) ; } 
protected function buildMap ( Collection $ result ) : array { $ maps = [ ] ; foreach ( $ result as $ value ) { $ maps [ $ value -> __get ( $ this -> targetKey ) ] [ ] = $ value ; } return $ maps ; } 
public function handle ( ) : void { $ this -> line ( 'Start to create symbolic links.' ) ; $ this -> callApis ( ) ; $ this -> callPublic ( ) ; $ this -> callStorage ( ) ; $ this -> callDebugBar ( ) ; $ this -> line ( '' ) ; $ this -> info ( 'Links created successed.' ) ; } 
protected function makeSyslogHandler ( ) : LoggerInterface { $ handler = new SyslogHandler ( $ this -> option [ 'channel' ] , $ this -> option [ 'facility' ] , $ this -> normalizeMonologLevel ( $ this -> option [ 'level' ] ) ) ; return $ this -> monolog -> pushHandler ( $ this -> normalizeHandler ( $ handler ) ) ; } 
public function move ( string $ directory , ? string $ name = null ) : self { $ target = $ this -> getTargetFile ( $ directory , $ name ) ; $ this -> moveToTarget ( $ this -> getPathname ( ) , $ target ) ; return new self ( $ target ) ; } 
protected function getTargetFile ( string $ directory , ? string $ name = null ) : string { create_directory ( $ directory ) ; $ target = rtrim ( $ directory , '/\\' ) . \ DIRECTORY_SEPARATOR . ( $ name ?? $ this -> getBasename ( ) ) ; return $ target ; } 
protected function moveToTarget ( string $ sourcePath , string $ target , bool $ isUploaded = false ) : void { set_error_handler ( function ( $ type , $ msg ) { throw new FileException ( $ msg ) ; } ) ; $ method = $ isUploaded ? 'move_uploaded_file' : 'rename' ; $ method ( $ sourcePath , $ target ) ; restore_error_handler ( ) ; chmod ( $ target , 0666 & ~ umask ( ) ) ; } 
public function loadData ( ) : array { if ( null !== $ this -> loaded ) { return $ this -> loaded ; } $ data = [ ] ; foreach ( $ this -> getPackages ( ) as $ package ) { if ( $ option = $ this -> getLeevelOption ( $ package ) ) { $ data = $ data ? $ this -> mergeOption ( $ data , $ option ) : $ option ; } } $ appOption = $ this -> getAppComposerOption ( ) ; return $ this -> loaded = $ this -> mergeOption ( $ data , $ appOption ) ; } 
protected function getPackages ( ) : array { $ packages = [ ] ; $ installedJson = $ this -> path . '/vendor/composer/installed.json' ; if ( is_file ( $ installedJson ) ) { $ packages = $ this -> getFileContent ( $ installedJson ) ; } return $ packages ; } 
protected function mergeOption ( array $ olds , array $ options ) : array { $ result = [ ] ; foreach ( $ this -> supportedOptions as $ item ) { $ result [ $ item ] = array_merge ( $ olds [ $ item ] ?? [ ] , $ options [ $ item ] ?? [ ] ) ; } return $ result ; } 
protected function getLeevelOption ( array $ package ) : array { $ options = $ package [ 'extra' ] [ 'leevel' ] ?? [ ] ; if ( $ options ) { $ options = $ this -> normalizeOption ( $ options ) ; } return $ options ; } 
protected function normalizeOption ( array $ options ) : array { $ result = [ ] ; foreach ( $ this -> supportedOptions as $ item ) { $ tmp = $ options [ $ item ] ?? [ ] ; if ( ! is_array ( $ tmp ) ) { $ tmp = [ $ tmp ] ; } $ result [ $ item ] = $ tmp ; } return $ result ; } 
protected function getAppComposerOption ( ) : array { $ path = $ this -> path . '/composer.json' ; if ( ! is_file ( $ path ) ) { return [ ] ; } return $ this -> getLeevelOption ( $ this -> getFileContent ( $ path ) ) ; } 
public function replace ( array $ elements = [ ] ) : void { $ this -> elements = [ ] ; $ elements = $ this -> normalizeArray ( $ elements ) ; $ this -> add ( $ elements ) ; } 
public function set ( string $ key , $ value ) : void { if ( ! is_array ( $ value ) && ! $ value instanceof UploadedFile ) { $ e = 'An uploaded file must be an array or an instance of UploadedFile.' ; throw new InvalidArgumentException ( $ e ) ; } parent :: set ( $ key , $ this -> convertFile ( $ value ) ) ; } 
public function add ( array $ files = [ ] ) : void { foreach ( $ files as $ key => $ file ) { $ this -> set ( $ key , $ file ) ; } } 
public function getArr ( string $ key , array $ defaults = [ ] ) { $ files = [ ] ; foreach ( $ this -> elements as $ k => $ value ) { if ( 0 === strpos ( $ k , $ key ) && null !== $ value ) { $ files [ ] = $ value ; } } return $ files ? : $ defaults ; } 
protected function convertFile ( $ file ) : ? UploadedFile { if ( $ file instanceof UploadedFile ) { return $ file ; } $ file = $ this -> normalizeFile ( $ file ) ; if ( UPLOAD_ERR_NO_FILE === $ file [ 'error' ] ) { $ file = null ; } else { $ file = new UploadedFile ( $ file [ 'tmp_name' ] , $ file [ 'name' ] , $ file [ 'type' ] , $ file [ 'error' ] ) ; } return $ file ; } 
protected function normalizeFile ( array $ data ) : array { $ result = [ ] ; foreach ( $ data as $ key => $ value ) { if ( in_array ( $ key , static :: $ fileKeys , true ) ) { $ result [ $ key ] = $ value ; } } $ keys = $ this -> normalizeKey ( $ result ) ; if ( $ keys !== static :: $ fileKeys ) { $ e = sprintf ( 'An array uploaded file must be contain keys %s.' , implode ( ',' , static :: $ fileKeys ) ) ; throw new InvalidArgumentException ( $ e ) ; } return $ result ; } 
protected function normalizeArray ( array $ elements ) : array { $ result = [ ] ; foreach ( $ elements as $ key => $ value ) { if ( is_array ( $ value ) ) { if ( false === array_key_exists ( 'name' , $ value ) ) { $ e = 'An uploaded file must be contain key name.' ; throw new InvalidArgumentException ( $ e ) ; } if ( isset ( $ value [ 'name' ] ) && is_array ( $ value [ 'name' ] ) ) { foreach ( $ value [ 'name' ] as $ index => $ item ) { $ element = [ ] ; foreach ( static :: $ fileKeys as $ fileKey ) { if ( ! array_key_exists ( $ fileKey , $ value ) ) { $ e = sprintf ( 'An uploaded file must be contain key %s.' , $ fileKey ) ; throw new InvalidArgumentException ( $ e ) ; } if ( ! array_key_exists ( $ index , $ value [ $ fileKey ] ) ) { $ e = sprintf ( 'An uploaded file must be contain %s in key %s.' , $ index , $ fileKey ) ; throw new InvalidArgumentException ( $ e ) ; } $ element [ $ fileKey ] = $ value [ $ fileKey ] [ $ index ] ?? '' ; } $ result [ $ key . '\\' . $ index ] = $ element ; $ result = $ this -> normalizeArray ( $ result ) ; } } else { $ result [ $ key ] = $ value ; } } else { $ result [ $ key ] = $ value ; } } return $ result ; } 
public function validateDate ( $ value , array $ parameter , IValidator $ validator , string $ field , bool $ before = false ) : bool { if ( ! is_string ( $ value ) ) { return false ; } if ( ! array_key_exists ( 0 , $ parameter ) ) { throw new InvalidArgumentException ( 'Missing the first element of parameter.' ) ; } $ this -> validator = $ validator ; if ( $ format = $ this -> getDateFormat ( $ field ) ) { return $ this -> doWithFormat ( $ format , $ value , $ parameter , $ before ) ; } if ( ! ( $ time = strtotime ( $ parameter [ 0 ] ) ) ) { if ( null === ( $ _ = $ validator -> getFieldValue ( $ parameter [ 0 ] ) ) ) { return false ; } return $ this -> compareTime ( strtotime ( $ value ) , strtotime ( $ _ ) , $ before ) ; } return $ this -> compareTime ( strtotime ( $ value ) , $ time , $ before ) ; } 
protected function compareTime ( int $ left , int $ right , bool $ before = false ) : bool { if ( true === $ before ) { return $ left < $ right ; } return $ left > $ right ; } 
protected function doWithFormat ( string $ format , $ value , array $ parameter , bool $ before = false ) : bool { $ parameter [ 0 ] = $ this -> validator -> getFieldValue ( $ parameter [ 0 ] ) ? : $ parameter [ 0 ] ; if ( true === $ before ) { list ( $ parameter [ 0 ] , $ value ) = [ $ value , $ parameter [ 0 ] ] ; } return $ this -> doCheckDate ( $ format , $ parameter [ 0 ] , $ value ) ; } 
protected function doCheckDate ( string $ format , string $ first , string $ second ) : bool { $ before = $ this -> makeDateTimeFormat ( $ format , $ first ) ; $ after = $ this -> makeDateTimeFormat ( $ format , $ second ) ; return $ before && $ after && $ before < $ after ; } 
protected function makeDateTimeFormat ( string $ format , string $ value ) { $ date = DateTime :: createFromFormat ( $ format , $ value ) ; if ( $ date ) { return $ date ; } try { return new DateTime ( $ value ) ; } catch ( Exception $ e ) { } } 
protected function makeConnectRedis ( array $ options = [ ] ) : Redis { $ options = $ this -> normalizeConnectOption ( 'redis' , $ options ) ; return new Redis ( new PhpRedis ( $ options ) , $ options ) ; } 
public function registerCompilers ( ) : IParser { foreach ( $ this -> compiler -> getCompilers ( ) as $ compiler ) { foreach ( ( array ) $ compiler [ 1 ] as $ name ) { $ this -> registerCompiler ( $ compiler [ 0 ] , $ name , $ compiler [ 2 ] ) ; } } return $ this ; } 
public function registerParsers ( ) : IParser { foreach ( $ this -> tags as $ key => $ value ) { $ this -> registerParser ( $ key ) ; } return $ this ; } 
public function doCompile ( string $ file , ? string $ cachePath = null , bool $ isContent = false ) { 
protected function globalParse ( string & $ compiled ) : void { $ tag = $ this -> getTag ( 'global' ) ; if ( preg_match_all ( "/{$tag['left']}tagself{$tag['right']}(.+?){$tag['left']}\\/tagself{$tag['right']}/isx" , $ compiled , $ res ) ) { $ startPos = 0 ; foreach ( $ res [ 1 ] as $ index => $ encode ) { $ source = trim ( $ res [ 0 ] [ $ index ] ) ; $ content = trim ( $ res [ 1 ] [ $ index ] ) ; $ theme = [ 'source' => $ source , 'content' => $ content , 'compiler' => 'global' , 
protected function codeParse ( string & $ compiled ) : void { foreach ( $ this -> compilers [ 'code' ] as $ compilers => $ tag ) { 
protected function jsParse ( string & $ compiled ) : void { $ this -> jsNode = true ; $ this -> normalizeNodeParse ( $ compiled ) ; } 
protected function nodeParse ( string & $ compiled ) : void { $ this -> jsNode = false ; $ this -> normalizeNodeParse ( $ compiled ) ; } 
protected function normalizeNodeParse ( string & $ compiled ) : void { 
protected function revertParse ( string & $ compiled ) : void { if ( preg_match_all ( '/__##revert##START##\d+@(.+?)##END##revert##__/' , $ compiled , $ res ) ) { $ startPos = 0 ; foreach ( $ res [ 1 ] as $ index => $ encode ) { $ source = $ res [ 0 ] [ $ index ] ; $ theme = [ 'source' => $ source , 'content' => $ encode , 'compiler' => 'revert' , 
protected function findNodeTag ( string & $ compiled ) : void { 
protected function packNode ( string & $ compiled ) : void { if ( true === $ this -> jsNode ) { $ nodeTag = $ this -> compiler -> getJsTagHelp ( ) ; $ compiler = 'Js' ; } else { $ nodeTag = $ this -> compiler -> getNodeTagHelp ( ) ; $ compiler = 'Node' ; } 
protected function registerCompiler ( string $ type , string $ name , string $ tag ) : void { $ this -> compilers [ $ type ] [ $ name ] = $ tag ; } 
protected function compileThemeTree ( ) : string { $ cache = '' ; foreach ( $ this -> themeTree as $ theme ) { $ this -> compileTheme ( $ theme ) ; $ cache .= $ theme [ 'content' ] ; } return $ cache ; } 
protected function compileTheme ( array & $ theme ) : void { foreach ( $ theme [ 'children' ] as $ key => $ value ) { $ source = $ value [ 'source' ] ; 
protected function makeCacheFile ( string $ cachePath , string & $ compiled ) : void { $ content = '<?' . 'php /* ' . date ( 'Y-m-d H:i:s' ) . ' */ ?' . '>' . PHP_EOL . $ compiled ; create_file ( $ cachePath , $ content ) ; } 
protected function addTheme ( array $ theme ) : void { $ top = & $ this -> themeTree [ 0 ] ; $ top = $ this -> addThemeTree ( $ top , $ theme ) ; } 
protected function addThemeTree ( array $ top , array $ new ) : array { $ result = [ ] ; foreach ( $ top [ 'children' ] as $ child ) { if ( $ new ) { $ relative = $ this -> positionRelative ( $ new [ 'position' ] , $ child [ 'position' ] ) ; switch ( $ relative ) { case 'front' : $ result [ ] = $ new ; $ result [ ] = $ child ; $ new = null ; break ; case 'behind' : $ result [ ] = $ child ; break ; case 'in' : $ child = $ this -> addThemeTree ( $ child , $ new ) ; $ result [ ] = $ child ; $ new = null ; break ; case 'out' : $ new = $ this -> addThemeTree ( $ new , $ child ) ; break ; } } else { $ result [ ] = $ child ; } } if ( $ new ) { $ result [ ] = $ new ; } $ top [ 'children' ] = $ result ; return $ top ; } 
protected function getPosition ( string $ content , string $ find , int $ start ) : array { $ data = [ ] ; * 匹配模块范围圈（在这个字节里面的都是它的子模快） * 找到开始和结束的地方就确定了这个模块所在区域范围. */ 
protected function positionRelative ( array $ value , array $ beyond ) : string { if ( $ value [ 'end' ] <= $ beyond [ 'start' ] ) { return 'front' ; } if ( $ value [ 'start' ] >= $ beyond [ 'end' ] ) { return 'behind' ; } if ( $ value [ 'start' ] >= $ beyond [ 'start' ] && $ value [ 'end' ] <= $ beyond [ 'end' ] ) { return 'in' ; } if ( $ value [ 'start' ] <= $ beyond [ 'start' ] && $ value [ 'end' ] >= $ beyond [ 'end' ] ) { return 'out' ; } 
protected function getLocation ( array $ position ) : string { return sprintf ( 'Line:%s; column:%s; file:%s.' , $ position [ 'start_line' ] , $ position [ 'start_in' ] , $ this -> sourceFile ? : null ) . ( $ this -> sourceFile ? $ this -> getLocationSource ( $ position ) : null ) ; } 
protected function getLocationSource ( array $ position ) : string { $ line = explode ( PHP_EOL , htmlentities ( substr ( file_get_contents ( $ this -> sourceFile ) , $ position [ 'start' ] , $ position [ 'end' ] ) ) ) ; $ line [ ] = '<div class="template-key">' . array_pop ( $ line ) . '</div>' ; return '<pre><code>' . implode ( PHP_EOL , $ line ) . '</code></pre>' ; } 
public function terminate ( Closure $ next , IRequest $ request , IResponse $ response ) : void { $ this -> saveLog ( ) ; $ next ( $ request , $ response ) ; } 
public function makeConnect ( ) { if ( empty ( $ this -> option [ 'path' ] ) ) { throw new InvalidArgumentException ( 'The zip requires path option.' ) ; } if ( ! class_exists ( 'League\Flysystem\ZipArchive\ZipArchiveAdapter' ) ) { throw new InvalidArgumentException ( 'Please run composer require league/flysystem-ziparchive.' ) ; } return new ZipArchiveAdapter ( $ this -> option [ 'path' ] ) ; } 
public function switchView ( IViews $ theme ) : IView { $ assign = $ this -> getAssign ( ) ; $ this -> theme = $ theme ; $ this -> assign ( $ assign ) ; return $ this ; } 
public function assign ( $ name , $ value = null ) : IView { $ this -> theme -> setVar ( $ name , $ value ) ; return $ this ; } 
public function display ( string $ file , array $ vars = [ ] , ? string $ ext = null ) : string { return $ this -> theme -> display ( $ file , $ vars , $ ext , false ) ; } 
public static function create ( $ data = null , int $ status = 200 , array $ headers = [ ] ) : IResponse { return new static ( $ data , $ status , $ headers ) ; } 
public static function fromJsonString ( ? string $ data = null , $ status = 200 , $ headers = [ ] ) : IResponse { return new static ( $ data , $ status , $ headers , true ) ; } 
public function setCallback ( ? string $ callback = null ) : IResponse { if ( $ this -> checkFlowControl ( ) ) { return $ this ; } $ this -> callback = $ callback ; return $ this -> updateContent ( ) ; } 
public function setJson ( $ json ) : IResponse { if ( $ this -> checkFlowControl ( ) ) { return $ this ; } if ( ! $ this -> isJsonData ( $ json ) ) { throw new InvalidArgumentException ( 'The method setJson need a json data.' ) ; } $ this -> data = $ json ; return $ this -> updateContent ( ) ; } 
public function getData ( bool $ assoc = true , int $ depth = 512 ) { return json_decode ( $ this -> data , $ assoc , $ depth ) ; } 
public function setEncodingOptions ( int $ encodingOptions ) : IResponse { if ( $ this -> checkFlowControl ( ) ) { return $ this ; } $ this -> encodingOptions = ( int ) $ encodingOptions ; return $ this -> setData ( $ this -> getData ( ) ) ; } 
protected function isJsonData ( $ data ) : bool { if ( ! is_scalar ( $ data ) && ! method_exists ( $ data , '__toString' ) ) { return false ; } json_decode ( ( string ) ( $ data ) ) ; return JSON_ERROR_NONE === json_last_error ( ) ; } 
protected function updateContent ( ) : IResponse { if ( null !== $ this -> callback ) { $ this -> headers -> set ( 'Content-Type' , 'text/javascript' ) ; return $ this -> setContent ( sprintf ( ';%s(%s);' , $ this -> callback , $ this -> data ) ) ; } if ( ! $ this -> headers -> has ( 'Content-Type' ) || 'text/javascript' === $ this -> headers -> get ( 'Content-Type' ) ) { $ this -> headers -> set ( 'Content-Type' , 'application/json' ) ; } return $ this -> setContent ( $ this -> data ) ; } 
protected function create ( ) : void { 
protected function replaceTemplateSource ( ) : void { 
protected function saveTemplateResult ( ) : void { $ saveFilePath = $ this -> getSaveFilePath ( ) ; if ( is_file ( $ saveFilePath ) ) { $ e = 'File is already exits.' . PHP_EOL . $ this -> formatFile ( $ saveFilePath ) ; throw new RuntimeException ( $ e ) ; } create_file ( $ saveFilePath , $ this -> getTemplateResult ( ) ) ; } 
protected function parseTemplateSource ( ) : void { $ templateSource = $ this -> getTemplatePath ( ) ; if ( ! is_file ( $ templateSource ) ) { throw new RuntimeException ( 'Stub not found.' . PHP_EOL . $ this -> formatFile ( $ templateSource ) ) ; } $ this -> templateSource = file_get_contents ( $ templateSource ) ; } 
protected function parseSourceAndReplace ( ) : array { $ replaceKeyValue = array_merge ( static :: $ globalReplace , $ this -> getDefaultReplaceKeyValue ( ) ) ; $ sourceKey = array_map ( function ( $ item ) { return '{{' . $ item . '}}' ; } , array_keys ( $ replaceKeyValue ) ) ; $ replace = array_values ( $ replaceKeyValue ) ; return [ $ sourceKey , $ replace ] ; } 
protected function getNamespacePath ( ) : string { $ namespacePath = $ this -> getContainer ( ) -> namespacePath ( $ this -> getNamespace ( ) . '\\index' , true ) . '/' ; return $ namespacePath ; } 
protected function setCustomReplaceKeyValue ( $ key , $ value = null ) { if ( is_array ( $ key ) ) { $ this -> customReplaceKeyValue = array_merge ( $ this -> customReplaceKeyValue , $ key ) ; } else { $ this -> customReplaceKeyValue [ $ key ] = $ value ; } } 
public function context ( string $ className ) : bool { if ( ! class_exists ( $ className ) ) { return false ; } if ( method_exists ( $ className , 'coroutineContext' ) && true === $ className :: coroutineContext ( ) ) { return true ; } return false ; } 
public function setOption ( string $ name , $ value ) : self { $ this -> option [ $ name ] = $ value ; return $ this ; } 
public function handle ( IRequest $ request , IResponse $ response ) : void { if ( ! $ this -> enabled ) { return ; } if ( $ request -> isJson ( ) || $ response instanceof ApiResponse || $ response instanceof JsonResponse || $ response -> isJson ( ) ) { if ( $ this -> option [ 'json' ] && is_array ( $ data = $ response -> getData ( ) ) ) { $ jsonRenderer = $ this -> getJsonRenderer ( ) ; if ( array_values ( $ data ) !== $ data ) { $ data [ ':trace' ] = $ jsonRenderer -> render ( ) ; } else { $ data [ ] = [ ':trace' => $ jsonRenderer -> render ( ) ] ; } $ response -> setData ( $ data ) ; } } elseif ( ! ( $ response instanceof RedirectResponse ) ) { if ( $ this -> option [ 'javascript' ] ) { $ javascriptRenderer = $ this -> getJavascriptRenderer ( '/debugbar' ) ; $ response -> appendContent ( $ javascriptRenderer -> renderHead ( ) . $ javascriptRenderer -> render ( ) ) ; } if ( $ this -> option [ 'console' ] ) { $ consoleRenderer = $ this -> getConsoleRenderer ( ) ; $ response -> appendContent ( $ consoleRenderer -> render ( ) ) ; } } } 
public function message ( $ message , string $ label = 'info' ) : void { $ this -> getCollector ( 'messages' ) -> addMessage ( $ message , $ label ) ; } 
public function time ( string $ name , ? string $ label = null ) : void { $ this -> getCollector ( 'time' ) -> startMeasure ( $ name , $ label ) ; } 
public function end ( string $ name ) : void { try { $ this -> getCollector ( 'time' ) -> stopMeasure ( $ name ) ; } catch ( Exception $ e ) { } } 
public function addTime ( string $ label , float $ start , float $ end ) : void { $ this -> getCollector ( 'time' ) -> addMeasure ( $ label , $ start , $ end ) ; } 
public function closureTime ( string $ label , Closure $ closure ) : void { $ this -> getCollector ( 'time' ) -> measure ( $ label , $ closure ) ; } 
public function getJavascriptRenderer ( $ baseUrl = null , $ basePath = null ) : JavascriptRenderer { return new JavascriptRenderer ( $ this , $ baseUrl , $ basePath ) ; } 
public function bootstrap ( ) : void { if ( $ this -> isBootstrap ) { return ; } $ this -> addCollector ( new PhpInfoCollector ( ) ) ; $ this -> addCollector ( new MessagesCollector ( ) ) ; $ this -> addCollector ( new RequestDataCollector ( ) ) ; $ this -> addCollector ( new TimeDataCollector ( ) ) ; $ this -> addCollector ( new MemoryCollector ( ) ) ; $ this -> addCollector ( new ExceptionsCollector ( ) ) ; $ this -> addCollector ( new ConfigCollector ( ) ) ; $ this -> addCollector ( new LeevelCollector ( $ this -> app ) ) ; $ this -> addCollector ( new SessionCollector ( $ this -> app -> make ( 'session' ) ) ) ; $ this -> addCollector ( new FilesCollector ( $ this -> app ) ) ; $ this -> addCollector ( new LogsCollector ( ) ) ; $ this -> initData ( ) ; $ this -> databaseEventDispatch ( ) ; $ this -> logEventDispatch ( ) ; $ this -> isBootstrap = true ; } 
protected function initData ( ) : void { $ this -> message ( 'Starts from this moment with QueryPHP.' , '' ) ; $ this -> getCollector ( 'config' ) -> setData ( $ this -> app -> make ( 'option' ) -> all ( ) ) ; } 
protected function databaseEventDispatch ( ) : void { $ this -> getEventDispatch ( ) -> register ( IConnect :: SQL_EVENT , function ( string $ event , string $ sql , array $ bindParams = [ ] ) { $ this -> getCollector ( 'logs' ) -> addMessage ( $ sql . ': ' . json_encode ( $ bindParams , JSON_UNESCAPED_UNICODE ) , 'sql' ) ; } ) ; } 
protected function logEventDispatch ( ) : void { $ this -> getEventDispatch ( ) -> register ( ILog :: LOG_EVENT , function ( string $ event , string $ level , string $ message , array $ context = [ ] ) { $ this -> getCollector ( 'logs' ) -> addMessage ( File :: formatMessage ( $ level , $ message , $ context ) , $ level ) ; } ) ; } 
public function handle ( IApp $ app ) : void { $ this -> line ( 'Start to clear cache log.' ) ; delete_directory ( $ cachePath = $ app -> runtimePath ( 'log' ) , true ) ; $ this -> info ( sprintf ( 'Log files in path %s cache clear successed.' , $ cachePath ) ) ; } 
public function handle ( ) : void { $ this -> includeBootstrapFile ( ) ; if ( ! ( $ files = $ this -> parseFiles ( ) ) ) { throw new InvalidArgumentException ( 'Files was not found.' ) ; } $ this -> utilsDoc = new UtilsDoc ( $ this -> outputDir ( ) ) ; $ this -> classParser = new ClassParser ( ) ; $ succeedCount = 0 ; foreach ( $ files as $ file ) { if ( true === $ this -> convertMarkdown ( $ file ) ) { $ succeedCount ++ ; } } $ this -> info ( sprintf ( 'A total of <comment>%d</comment> files generate succeed.' , $ succeedCount ) ) ; } 
protected function convertMarkdown ( string $ file ) : bool { $ className = $ this -> classParser -> handle ( $ file ) ; if ( ! class_exists ( $ className ) ) { return false ; } $ result = $ this -> utilsDoc -> handleAndSave ( $ className ) ; if ( true === $ result ) { $ this -> line ( sprintf ( 'Class <info>%s</info> was generate succeed.' , $ className ) ) ; } return $ result ; } 
protected function parseFiles ( ) : array { $ fileOrDir = dirname ( $ this -> testsDir ( ) ) . '/' . $ this -> path ( ) ; $ result = [ ] ; if ( is_file ( $ fileOrDir ) ) { $ result [ ] = $ fileOrDir ; } elseif ( is_dir ( $ fileOrDir ) ) { list_directory ( $ fileOrDir , true , function ( DirectoryIterator $ file ) use ( & $ result ) { if ( $ file -> isFile ( ) ) { $ result [ ] = $ file -> getPathname ( ) ; } } ) ; } return $ result ; } 
public function handle ( Manager $ database ) : void { $ this -> database = $ database ; 
protected function getReplace ( ) : array { $ columns = $ this -> getColumns ( ) ; return [ 'file_name' => ucfirst ( camelize ( $ this -> argument ( 'name' ) ) ) , 'table_name' => $ this -> getTableName ( ) , 'primary_key' => $ this -> getPrimaryKey ( $ columns ) , 'primary_key_type' => $ this -> getPrimaryKeyType ( $ columns ) , 'auto_increment' => $ this -> getAutoIncrement ( $ columns ) , 'struct' => $ this -> getStruct ( $ columns ) , 'props' => $ this -> getProps ( $ columns ) , ] ; } 
protected function getPrimaryKey ( array $ columns ) : string { if ( ! $ columns [ 'primary_key' ] ) { return 'null' ; } if ( count ( $ columns [ 'primary_key' ] ) > 1 ) { return '[' . implode ( ', ' , array_map ( function ( $ item ) { return "'{$item}'" ; } , $ columns [ 'primary_key' ] ) ) . ']' ; } return "'{$columns['primary_key'][0]}'" ; } 
protected function getStruct ( array $ columns ) : string { $ struct = [ '[' ] ; foreach ( $ columns [ 'list' ] as $ val ) { if ( $ val [ 'primary_key' ] ) { $ struct [ ] = " '{$val['name']}' => [ 'readonly' => true, ]," ; } else { $ struct [ ] = " '{$val['name']}' => []," ; } } $ struct [ ] = ' ]' ; return implode ( PHP_EOL , $ struct ) ; } 
protected function getProps ( array $ columns ) : string { $ props = [ ] ; foreach ( $ columns [ 'list' ] as $ val ) { $ comment = $ val [ 'comment' ] ? : $ val [ 'name' ] ; $ propName = camelize ( $ val [ 'name' ] ) ; $ type = in_array ( $ val [ 'type' ] , [ 'tinyint' , 'smallint' , 'mediumint' , 'int' , 'integer' , 'bigint' ] , true ) ? 'int' : 'string' ; $ tmpProp = " /** * {$comment}. * * @var {$type} */ private \${$propName}; " ; $ props [ ] = $ tmpProp ; } return implode ( '' , $ props ) ; } 
public function bind ( $ name , $ service = null , bool $ share = false ) : IContainer { if ( is_array ( $ name ) ) { list ( $ name , $ alias ) = $ this -> parseAlias ( $ name ) ; $ this -> alias ( $ name , $ alias ) ; } if ( null === $ service ) { $ service = $ name ; } $ this -> services [ $ name ] = $ service ; if ( $ share ) { $ this -> singletons [ ] = $ name ; } return $ this ; } 
public function instance ( $ name , $ service = null ) : IContainer { if ( is_array ( $ name ) ) { list ( $ name , $ alias ) = $ this -> parseAlias ( $ name ) ; $ this -> alias ( $ name , $ alias ) ; } if ( null === $ service ) { $ service = $ name ; } if ( $ this -> coroutineContext ( $ service ) ) { $ this -> coroutineInstances [ $ this -> coroutineUid ( ) ] [ $ name ] = $ service ; } else { $ this -> instances [ $ name ] = $ service ; } return $ this ; } 
public function singleton ( $ name , $ service = null ) : IContainer { return $ this -> bind ( $ name , $ service , true ) ; } 
public function alias ( $ alias , $ value = null ) : IContainer { if ( is_array ( $ alias ) ) { foreach ( $ alias as $ key => $ item ) { if ( is_int ( $ key ) ) { continue ; } $ this -> alias ( $ key , $ item ) ; } } else { $ value = ( array ) $ value ; foreach ( $ value as $ item ) { $ this -> alias [ $ item ] = $ alias ; } } return $ this ; } 
public function make ( string $ name , array $ args = [ ] ) { 
public function call ( $ callback , array $ args = [ ] ) { $ isStatic = false ; if ( is_string ( $ callback ) ) { if ( false !== strpos ( $ callback , '@' ) ) { $ callback = explode ( '@' , $ callback ) ; } elseif ( false !== strpos ( $ callback , '::' ) ) { $ callback = explode ( '::' , $ callback ) ; $ isStatic = true ; } } if ( false === $ isStatic && is_array ( $ callback ) ) { if ( ! is_object ( $ callback [ 0 ] ) ) { if ( ! is_string ( $ callback [ 0 ] ) ) { throw new InvalidArgumentException ( 'The classname must be string.' ) ; } $ callback [ 0 ] = $ this -> getInjectionObject ( $ callback [ 0 ] ) ; } if ( empty ( $ callback [ 1 ] ) ) { $ callback [ 1 ] = 'handle' ; } } $ args = $ this -> normalizeInjectionArgs ( $ callback , $ args ) ; return call_user_func_array ( $ callback , $ args ) ; } 
public function remove ( string $ name ) : void { $ name = $ this -> normalize ( $ name ) ; $ prop = [ 'services' , 'instances' , 'singletons' , ] ; foreach ( $ prop as $ item ) { if ( isset ( $ this -> { $ item } [ $ name ] ) ) { unset ( $ this -> { $ item } [ $ name ] ) ; } } if ( $ this -> existsCoroutine ( $ name ) ) { unset ( $ this -> coroutineInstances [ $ this -> coroutineUid ( ) ] [ $ name ] ) ; } } 
public function removeCoroutine ( ? string $ name = null ) : void { if ( ! $ this -> coroutine ) { return ; } if ( null === $ name ) { if ( isset ( $ this -> coroutineInstances [ $ this -> coroutineUid ( ) ] ) ) { unset ( $ this -> coroutineInstances [ $ this -> coroutineUid ( ) ] ) ; } } else { $ name = $ this -> normalize ( $ name ) ; if ( $ this -> existsCoroutine ( $ name ) ) { unset ( $ this -> coroutineInstances [ $ this -> coroutineUid ( ) ] [ $ name ] ) ; } } } 
public function exists ( string $ name ) : bool { $ name = $ this -> normalize ( $ name ) ; $ name = $ this -> getAlias ( $ name ) ; return isset ( $ this -> services [ $ name ] ) || isset ( $ this -> instances [ $ name ] ) || $ this -> existsCoroutine ( $ name ) ; } 
public function clear ( ) : void { $ prop = [ 'services' , 'instances' , 'singletons' , 'coroutineInstances' , ] ; foreach ( $ prop as $ item ) { $ this -> { $ item } = [ ] ; } $ this -> alias = [ ] ; } 
public function existsCoroutine ( string $ name ) : bool { return false !== $ this -> coroutineUid ( ) && isset ( $ this -> coroutineInstances [ $ this -> coroutineUid ( ) ] , $ this -> coroutineInstances [ $ this -> coroutineUid ( ) ] [ $ name ] ) ; } 
protected function coroutineContext ( $ instance ) : bool { if ( ! $ this -> coroutine ) { return false ; } if ( is_object ( $ instance ) ) { $ instance = get_class ( $ instance ) ; } return $ this -> coroutine -> context ( $ instance ) ; } 
protected function getInjectionObject ( string $ classname , array $ args = [ ] ) { if ( interface_exists ( $ classname ) ) { $ e = sprintf ( 'Interface %s cannot be normalize because not binded.' , $ classname ) ; throw new ContainerInvalidArgumentException ( $ e ) ; } if ( ! class_exists ( $ classname ) ) { return $ classname ; } $ args = $ this -> normalizeInjectionArgs ( $ classname , $ args ) ; return $ this -> newInstanceArgs ( $ classname , $ args ) ; } 
protected function normalizeInjectionArgs ( $ value , array $ args ) : array { list ( $ args , $ required , $ validArgs ) = $ this -> parseInjection ( $ value , $ args ) ; if ( $ validArgs < $ required ) { $ e = sprintf ( 'There are %d required args,but %d gived.' , $ required , $ validArgs ) ; throw new ContainerInvalidArgumentException ( $ e ) ; } return $ args ; } 
protected function parseInjection ( $ injection , array $ args = [ ] ) : array { $ result = [ ] ; $ required = 0 ; $ param = $ this -> parseReflection ( $ injection ) ; $ validArgs = count ( $ param ) ; foreach ( $ param as $ key => $ item ) { try { switch ( true ) { case $ argsclass = $ this -> parseParameterClass ( $ item ) : if ( isset ( $ args [ 0 ] ) && is_object ( $ args [ 0 ] ) && $ args [ 0 ] instanceof $ argsclass ) { $ data = array_shift ( $ args ) ; } elseif ( array_key_exists ( $ argsclass , $ args ) ) { $ data = $ args [ $ argsclass ] ; } elseif ( $ item -> isDefaultValueAvailable ( ) ) { $ data = $ item -> getDefaultValue ( ) ; } else { $ data = $ this -> parseClassFromContainer ( $ argsclass ) ; } $ required ++ ; $ validArgs ++ ; break ; case $ item -> isDefaultValueAvailable ( ) : $ data = array_key_exists ( $ item -> name , $ args ) ? $ args [ $ item -> name ] : $ item -> getDefaultValue ( ) ; break ; default : $ required ++ ; if ( array_key_exists ( $ item -> name , $ args ) ) { $ data = $ args [ $ item -> name ] ; $ validArgs ++ ; } else { if ( isset ( $ args [ 0 ] ) ) { $ data = array_shift ( $ args ) ; } else { $ validArgs -- ; $ data = null ; } } break ; } $ result [ $ item -> name ] = $ data ; } catch ( ReflectionException $ e ) { throw new InvalidArgumentException ( $ e -> getMessage ( ) ) ; } } if ( $ args ) { $ result = array_values ( $ result ) ; 
protected function parseParameterClass ( ReflectionParameter $ param ) { $ classObject = $ param -> getClass ( ) ; if ( ! $ classObject || ! ( $ classObject instanceof ReflectionClass ) ) { return false ; } return $ classObject -> getName ( ) ; } 
protected function parseClassFromContainer ( string $ argsclass ) { $ itemMake = $ this -> make ( $ argsclass ) ; 
protected function parseReflection ( $ injection ) : array { switch ( true ) { case $ injection instanceof Closure : return $ this -> parseClosureReflection ( $ injection ) ; case ! is_string ( $ injection ) && is_callable ( $ injection ) : return $ this -> parseMethodReflection ( $ injection ) ; case is_string ( $ injection ) : return $ this -> parseClassReflection ( $ injection ) ; default : throw new InvalidArgumentException ( 'Unsupported callback types.' ) ; } } 
protected function parseClosureReflection ( Closure $ injection ) : array { $ reflection = new ReflectionFunction ( $ injection ) ; if ( ! ( $ param = $ reflection -> getParameters ( ) ) ) { $ param = [ ] ; } return $ param ; } 
protected function parseMethodReflection ( callable $ injection ) : array { $ reflection = new ReflectionMethod ( $ injection [ 0 ] , $ injection [ 1 ] ) ; if ( ! ( $ param = $ reflection -> getParameters ( ) ) ) { $ param = [ ] ; } return $ param ; } 
protected function parseClassReflection ( string $ injection ) : array { $ reflection = new ReflectionClass ( $ injection ) ; if ( ! $ reflection -> isInstantiable ( ) ) { $ e = sprintf ( 'Class %s is not instantiable.' , $ injection ) ; throw new InvalidArgumentException ( $ e ) ; } $ param = [ ] ; if ( ( $ constructor = $ reflection -> getConstructor ( ) ) ) { $ param = $ constructor -> getParameters ( ) ; } return $ param ; } 
protected function newInstanceArgs ( string $ classname , array $ args ) { try { 
public function setOption ( string $ name , $ value ) : IConnect { $ this -> option [ $ name ] = $ value ; return $ this ; } 
public function flush ( array $ data ) : void { foreach ( $ data as $ value ) { $ method = $ this -> normalizeLevel ( array_shift ( $ value ) ) ; $ this -> monolog -> { $ method } ( ... $ value ) ; } } 
protected function normalizeLevel ( string $ level ) : string { if ( ! in_array ( $ level , array_keys ( $ this -> supportLevel ) , true ) ) { return ILog :: DEBUG ; } return $ level ; } 
protected function normalizeMonologLevel ( string $ level ) : int { if ( isset ( $ this -> supportLevel [ $ level ] ) ) { return $ this -> supportLevel [ $ level ] ; } return $ this -> supportLevel [ ILog :: DEBUG ] ; } 
public function report ( Exception $ e ) { if ( method_exists ( $ e , 'report' ) ) { return $ e -> report ( ) ; } 
public function render ( IRequest $ request , Exception $ e ) : IResponse { if ( method_exists ( $ e , 'render' ) && $ response = $ e -> render ( $ request , $ e ) ) { if ( ! ( $ response instanceof IResponse ) ) { $ response = new Response ( $ response , $ this -> normalizeStatusCode ( $ e ) , $ this -> normalizeHeaders ( $ e ) ) ; } return $ response ; } $ e = $ this -> prepareException ( $ e ) ; if ( $ request -> isAcceptJson ( ) ) { return $ this -> makeJsonResponse ( $ e ) ; } return $ this -> makeHttpResponse ( $ e ) ; } 
public function renderForConsole ( OutputInterface $ output , Exception $ e ) : void { $ handler = ( new CollisionProvider ( ) ) -> register ( ) -> getHandler ( ) -> setOutput ( $ output ) ; $ handler -> setInspector ( new Inspector ( $ e ) ) ; $ handler -> handle ( ) ; } 
public function rendorWithHttpExceptionView ( Exception $ e ) : IResponse { $ filepath = $ this -> getHttpExceptionView ( $ e ) ; if ( file_exists ( $ filepath ) ) { $ vars = $ this -> getExceptionVars ( $ e ) ; $ content = $ this -> renderWithFile ( $ filepath , $ vars ) ; return new Response ( $ content , $ e -> getStatusCode ( ) , $ e -> getHeaders ( ) ) ; } return $ this -> convertExceptionToResponse ( $ e ) ; } 
protected function makeHttpResponse ( Exception $ e ) : IResponse { if ( $ this -> container -> debug ( ) ) { return $ this -> convertExceptionToResponse ( $ e ) ; } if ( ! $ this -> isHttpException ( $ e ) ) { $ e = new HttpException ( 500 , $ e -> getMessage ( ) ) ; } return $ this -> rendorWithHttpExceptionView ( $ e ) ; } 
protected function makeJsonResponse ( Exception $ e ) : IResponse { $ whoops = $ this -> makeWhoops ( ) ; $ whoops -> pushHandler ( $ this -> makeJsonResponseHandler ( ) ) ; 
protected function convertExceptionToResponse ( Exception $ e ) : IResponse { return new Response ( $ this -> renderExceptionContent ( $ e ) , $ this -> normalizeStatusCode ( $ e ) , $ this -> normalizeHeaders ( $ e ) ) ; } 
protected function renderExceptionContent ( Exception $ e ) : string { if ( $ this -> container -> debug ( ) ) { return $ this -> renderExceptionWithWhoops ( $ e ) ; } return $ this -> renderExceptionWithDefault ( $ e ) ; } 
protected function renderExceptionWithDefault ( Exception $ e ) : string { $ vars = $ this -> getExceptionVars ( $ e ) ; return $ this -> renderWithFile ( $ this -> getDefaultHttpExceptionView ( ) , $ vars ) ; } 
protected function renderExceptionWithWhoops ( Exception $ e ) : string { $ whoops = $ this -> makeWhoops ( ) ; $ prettyPage = new PrettyPageHandler ( ) ; $ prettyPage -> handleUnconditionally ( true ) ; $ whoops -> pushHandler ( $ prettyPage ) ; return $ whoops -> handleException ( $ e ) ; } 
protected function getExceptionVars ( Exception $ e ) : array { return [ 'e' => $ e , 'code' => $ this -> normalizeStatusCode ( $ e ) , 'message' => $ e -> getMessage ( ) , 'type' => get_class ( $ e ) , 'file' => $ this -> filterPhysicalPath ( $ e -> getFile ( ) ) , 'line' => $ e -> getLine ( ) , ] ; } 
protected function makeWhoops ( ) : Run { $ whoops = new Run ( ) ; $ whoops -> writeToOutput ( false ) ; $ whoops -> allowQuit ( false ) ; return $ whoops ; } 
protected function prepareException ( Exception $ e ) : Exception { if ( $ e instanceof EntityNotFoundException ) { $ e = new NotFoundHttpException ( $ e -> getMessage ( ) , $ e -> getCode ( ) ) ; } return $ e ; } 
protected function renderWithFile ( string $ filepath , array $ vars = [ ] ) : string { if ( ! is_file ( $ filepath ) ) { throw new Exception ( sprintf ( 'Exception file %s is not extis.' , $ filepath ) ) ; } extract ( $ vars ) ; ob_start ( ) ; require $ filepath ; $ content = ob_get_contents ( ) ; ob_end_clean ( ) ; return $ content ; } 
public function validate ( $ value , array $ parameter , IValidator $ validator , string $ field ) : bool { return $ this -> validateDate ( $ value , $ parameter , $ validator , $ field ) ; } 
public function flush ( array $ datas ) : void { $ level = $ datas [ 0 ] [ 0 ] ; $ this -> checkSize ( $ filepath = $ this -> normalizePath ( $ level ) ) ; foreach ( $ datas as $ value ) { error_log ( self :: formatMessage ( ... $ value ) , 3 , $ filepath ) ; } } 
public static function formatMessage ( string $ level , string $ message , array $ context = [ ] ) : string { return sprintf ( '[%s] %s %s: %s' . PHP_EOL , date ( 'Y-m-d H:i:s' ) , $ message , $ level , json_encode ( $ context , JSON_UNESCAPED_UNICODE ) ) ; } 
protected function checkSize ( string $ filePath ) : void { $ dirname = dirname ( $ filePath ) ; if ( ! is_file ( $ filePath ) ) { create_directory ( $ dirname ) ; } 
protected function normalizePath ( string $ level ) : string { if ( ! $ this -> option [ 'path' ] ) { throw new InvalidArgumentException ( 'Path for log has not set.' ) ; } return $ this -> option [ 'path' ] . '/' . $ this -> option [ 'channel' ] . '.' . ( $ level ? $ level . '/' : '' ) . date ( $ this -> option [ 'name' ] ) . '.log' ; } 
public function make ( string $ url , array $ params = [ ] , string $ subdomain = 'www' , $ suffix = null ) : string { $ url = $ this -> makeUrl ( $ url , $ params , null !== $ suffix ? $ suffix : $ this -> option [ 'with_suffix' ] ) ; $ url = $ this -> withEnter ( $ url ) ; $ url = $ this -> WithDomain ( $ url , $ subdomain ) ; return $ url ; } 
public function setOption ( string $ name , $ value ) : IUrl { $ this -> option [ $ name ] = $ value ; return $ this ; } 
protected function makeUrl ( string $ url , array $ params , $ suffix ) : string { $ this -> params = $ params ; if ( '/' !== substr ( $ url , 0 , 1 ) ) { $ url = '/' . $ url ; } if ( false !== strpos ( $ url , '{' ) ) { $ url = preg_replace_callback ( '/{(.+?)}/' , function ( $ matches ) { if ( isset ( $ this -> params [ $ matches [ 1 ] ] ) ) { $ value = $ this -> params [ $ matches [ 1 ] ] ; unset ( $ this -> params [ $ matches [ 1 ] ] ) ; } else { $ value = $ matches [ 0 ] ; } return $ value ; } , $ url ) ; } if ( $ this -> params ) { $ queryUrl = http_build_query ( $ this -> params ) ; $ url .= ( false !== strpos ( $ url , '?' ) ? '&' : '?' ) . $ queryUrl ; } $ url = $ this -> withSuffix ( $ url , $ suffix ) ; return $ url ; } 
protected function withDomain ( string $ url , string $ domain ) : string { if ( ! $ this -> option [ 'domain' ] || ! $ domain ) { return $ url ; } return ( $ this -> isSecure ( ) ? 'https://' : 'http://' ) . ( $ domain && '*' !== $ domain ? $ domain . '.' : '' ) . $ this -> option [ 'domain' ] . $ url ; } 
protected function withSuffix ( string $ url , $ suffix ) : string { if ( '/' === $ url || 0 === strpos ( $ url , '/?' ) ) { return $ url ; } $ suffix = true === $ suffix ? $ this -> option [ 'suffix' ] : $ suffix ; if ( false !== strpos ( $ url , '?' ) ) { $ url = str_replace ( '?' , $ suffix . '?' , $ url ) ; } else { $ url .= $ suffix ; } return $ url ; } 
protected function withEnter ( string $ url ) : string { $ enter = $ this -> request -> getEnter ( ) ; $ enter = '/' !== $ enter ? $ enter : '' ; return $ enter . $ url ; } 
public function getHeaders ( ) : array { $ result = [ ] ; $ contentHeaders = [ 'CONTENT_LENGTH' , 'CONTENT_MD5' , 'CONTENT_TYPE' , ] ; foreach ( $ this -> elements as $ key => $ value ) { if ( 0 === strpos ( $ key , 'HTTP_' ) ) { $ result [ substr ( $ key , 5 ) ] = $ value ; } elseif ( in_array ( $ key , $ contentHeaders , true ) ) { $ result [ $ key ] = $ value ; } } return $ result ; } 
public function add ( SymfonyCommand $ command ) { if ( $ command instanceof Command ) { $ command -> setContainer ( $ this -> container ) ; } return parent :: add ( $ command ) ; } 
public function normalizeCommand ( string $ command ) : SymfonyCommand { return $ this -> add ( $ this -> container -> make ( $ command ) ) ; } 
public function and ( ISpecification $ spec ) : ISpecification { $ old = $ this -> spec ; $ oldHandle = $ this -> handle ; $ this -> spec = function ( IEntity $ entity ) use ( $ old , $ spec ) : bool { return $ old ( $ entity ) && $ spec -> isSatisfiedBy ( $ entity ) ; } ; $ this -> handle = function ( Select $ select , IEntity $ entity ) use ( $ spec , $ oldHandle ) { $ oldHandle ( $ select , $ entity ) ; $ spec -> handle ( $ select , $ entity ) ; } ; return $ this ; } 
public function not ( ) : ISpecification { $ old = $ this -> spec ; $ this -> spec = function ( IEntity $ entity ) use ( $ old ) : bool { return ! $ old ( $ entity ) ; } ; return $ this ; } 
public function update ( SplSubject $ subject ) : void { if ( method_exists ( $ this , 'handle' ) ) { $ handle = [ $ this , 'handle' ] ; } elseif ( $ this -> handle ) { $ handle = [ $ this , '__invoke' ] ; } else { $ handle = null ; } if ( ! is_callable ( $ handle ) ) { throw new InvalidArgumentException ( sprintf ( 'Observer %s must has handle method.' , get_class ( $ this ) ) ) ; } $ subject -> container -> call ( $ handle , $ subject -> notifyArgs ) ; } 
public function get ( string $ key , $ defaults = null ) { $ key = $ this -> normalize ( $ key ) ; return $ this -> filter ( $ key , $ defaults ) ; } 
public function set ( string $ key , $ value ) : void { $ key = $ this -> normalize ( $ key ) ; $ this -> elements [ $ key ] = $ value ; } 
public function has ( string $ key ) : bool { $ key = $ this -> normalize ( $ key ) ; return array_key_exists ( $ key , $ this -> elements ) ; } 
public function remove ( string $ key ) : void { $ key = $ this -> normalize ( $ key ) ; if ( $ this -> has ( $ key ) ) { unset ( $ this -> elements [ $ key ] ) ; } } 
public function filter ( string $ key , $ defaults = null , $ filter = null , array $ options = [ ] ) { $ key = $ this -> normalize ( $ key ) ; $ filter = $ this -> parseFilter ( $ filter ) ; list ( $ key , $ filter ) = $ this -> parseKeyFilter ( $ key , $ filter ) ; $ part = '' ; if ( false !== strpos ( $ key , '\\' ) ) { list ( $ key , $ part ) = explode ( '\\' , $ key ) ; } $ result = array_key_exists ( $ key , $ this -> elements ) ? $ this -> elements [ $ key ] : $ defaults ; if ( $ part ) { $ result = $ this -> getPartData ( $ part , $ result , $ defaults ) ; } if ( $ filter ) { $ result = $ this -> filterValue ( $ result , $ defaults , $ filter , $ options ) ; } return $ result ; } 
protected function parseKeyFilter ( string $ key , array $ filter ) : array { if ( false !== strpos ( $ key , '|' ) ) { $ temp = explode ( '|' , $ key ) ; $ key = array_shift ( $ temp ) ; $ filter = array_merge ( $ temp , $ filter ) ; } return [ $ key , $ filter ] ; } 
protected function filterValue ( $ value , $ defaults , array $ filters , array $ options = [ ] ) { foreach ( $ filters as $ item ) { if ( is_string ( $ item ) && false !== strpos ( $ item , '=' ) ) { $ value = $ this -> filterValueWithFunc ( $ value , $ item ) ; } elseif ( is_callable ( $ item ) ) { $ value = $ this -> filterValueWithCallable ( $ value , $ item ) ; } elseif ( is_scalar ( $ value ) && ! empty ( $ item ) ) { $ value = $ this -> filterValueWithFilterVar ( $ value , $ item , $ options ) ; if ( false === $ value ) { $ value = $ defaults ; break ; } } } return $ value ; } 
protected function filterValueWithFunc ( $ value , string $ filter ) { list ( $ filter , $ extend ) = explode ( '=' , $ filter ) ; if ( 'default' === $ filter ) { if ( ! is_numeric ( $ extend ) && ! preg_match ( '/^[A-Z\_]+$/' , $ extend ) ) { $ extend = "'" . $ extend . "'" ; } $ evals = "\$value = '" . ( $ value ? '1' : '' ) . "' ?: " . $ extend . ';' ; } elseif ( $ extend ) { if ( false !== strpos ( $ extend , ',' ) ) { $ tmp = explode ( ',' , $ extend ) ; $ result = [ ] ; foreach ( $ tmp as $ v ) { $ v = trim ( $ v ) ; if ( '**' === $ v || is_numeric ( $ v ) || preg_match ( '/^[A-Z\_]+$/' , $ v ) ) { $ result [ ] = $ v ; } else { $ result [ ] = "'" . $ v . "'" ; } } $ extend = implode ( ',' , $ result ) ; } if ( strstr ( $ extend , '**' ) ) { $ extend = str_replace ( '**' , '$value' , $ extend ) ; $ evals = "\$value = {$filter}({$extend});" ; } else { $ evals = "\$value = {$filter}(\$value, {$extend});" ; } } eval ( $ evals ) ; return $ value ; } 
protected function filterValueWithFilterVar ( $ value , $ filter , array $ options ) { $ value = filter_var ( $ value , $ this -> parseFilterId ( $ filter ) , $ options ) ; return $ value ; } 
protected function parseFilterId ( $ filter ) : int { $ filter = $ this -> isInt ( $ filter ) ? $ filter : filter_id ( $ filter ) ; return $ filter ; } 
protected function getPartData ( string $ key , $ value , $ defaults = null ) { if ( ! is_array ( $ value ) ) { return $ value ; } $ parts = explode ( '.' , $ key ) ; foreach ( $ parts as $ item ) { if ( ! is_array ( $ value ) || ! isset ( $ value [ $ item ] ) ) { return $ defaults ; } $ value = $ value [ $ item ] ; } return $ value ; } 
public function get ( string $ name , $ defaults = false , array $ option = [ ] ) { $ option = $ this -> normalizeOptions ( $ option ) ; $ cachePath = $ this -> getCachePath ( $ name ) ; 
public function set ( string $ name , $ data , array $ option = [ ] ) : void { $ option = $ this -> normalizeOptions ( $ option ) ; if ( $ option [ 'serialize' ] ) { $ data = serialize ( $ data ) ; } $ data = sprintf ( static :: HEADER , '/* ' . date ( 'Y-m-d H:i:s' ) . ' */' ) . $ data ; $ cachePath = $ this -> getCachePath ( $ name ) ; $ this -> writeData ( $ cachePath , $ data ) ; } 
public function delete ( string $ name ) : void { $ cachePath = $ this -> getCachePath ( $ name ) ; if ( $ this -> exist ( $ name ) ) { unlink ( $ cachePath ) ; } } 
protected function isExpired ( string $ name , array $ option ) : bool { $ filePath = $ this -> getCachePath ( $ name ) ; $ option [ 'expire' ] = $ this -> cacheTime ( $ name , ( int ) $ option [ 'expire' ] ) ; if ( $ option [ 'expire' ] <= 0 ) { return true ; } return filemtime ( $ filePath ) + ( int ) $ option [ 'expire' ] < time ( ) ; } 
protected function getCachePath ( string $ name ) : string { if ( ! $ this -> option [ 'path' ] ) { throw new InvalidArgumentException ( 'Cache path is not allowed empty.' ) ; } return $ this -> option [ 'path' ] . '/' . $ this -> getCacheName ( $ name ) . '.php' ; } 
protected function writeData ( string $ fileName , string $ data ) : void { create_file ( $ fileName ) ; file_put_contents ( $ fileName , $ data , LOCK_EX ) ; } 
public function handle ( IApp $ app ) : void { $ this -> checkRuntimeEnv ( $ app ) ; if ( $ app -> isCachedOption ( ) ) { $ data = ( array ) include $ app -> optionCachedPath ( ) ; $ this -> setEnvs ( $ data [ 'app' ] [ '_env' ] ) ; } else { $ load = new Load ( $ app -> optionPath ( ) ) ; $ data = $ load -> loadData ( $ app ) ; } $ app -> instance ( 'option' , $ option = new Option ( $ data ) ) ; $ test = 2 === func_num_args ( ) ; if ( ! $ test ) { 
protected function checkRuntimeEnv ( IApp $ app ) : void { if ( ! getenv ( 'RUNTIME_ENVIRONMENT' ) ) { return ; } $ file = '.' . getenv ( 'RUNTIME_ENVIRONMENT' ) ; 
protected function setEnvs ( array $ env ) : void { foreach ( $ env as $ name => $ value ) { $ this -> setEnvVar ( $ name , $ value ) ; } } 
protected function setEnvVar ( string $ name , $ value = null ) : void { if ( is_bool ( $ value ) ) { putenv ( $ name . '=' . ( $ value ? '(true)' : '(false)' ) ) ; } elseif ( null === $ value ) { putenv ( $ name . '(null)' ) ; } else { putenv ( $ name . '=' . $ value ) ; } $ _ENV [ $ name ] = $ value ; $ _SERVER [ $ name ] = $ value ; } 
protected function initialization ( Option $ option ) : void { mb_internal_encoding ( 'UTF-8' ) ; if ( function_exists ( 'date_default_timezone_set' ) ) { date_default_timezone_set ( $ option -> get ( 'time_zone' , 'UTC' ) ) ; } if ( \ PHP_SAPI === 'cli' ) { return ; } if ( function_exists ( 'gz_handler' ) && $ option -> get ( 'start_gzip' ) ) { ob_start ( 'gz_handler' ) ; } else { ob_start ( ) ; } } 
public function handle ( string $ className ) : string { $ this -> lines = $ this -> parseFileContnet ( $ reflection = new ReflectionClass ( $ className ) ) ; if ( ! ( $ markdown = $ this -> parseClassContent ( $ reflection ) ) ) { return '' ; } $ markdown .= $ this -> parseMethodContents ( $ reflection ) ; return $ markdown ; } 
public function handleAndSave ( string $ className , ? string $ path = null ) : bool { $ this -> setSavePath ( $ path ) ; $ markdown = trim ( $ this -> handle ( $ className ) ) ; if ( ! $ markdown || ! $ this -> savePath ) { return false ; } $ this -> writeCache ( $ this -> savePath , $ markdown ) ; return true ; } 
public static function getMethodBody ( string $ className , string $ method , bool $ isDoc = false ) : string { $ doc = new static ( '' ) ; $ lines = $ doc -> parseFileContnet ( new ReflectionClass ( $ className ) ) ; $ method = new ReflectionMethod ( $ className , $ method ) ; return $ doc -> parseMethodBody ( $ lines , $ method , $ isDoc ) ; } 
public static function getClassBody ( string $ className ) : string { $ doc = new static ( '' ) ; $ lines = $ doc -> parseFileContnet ( $ reflectionClass = new ReflectionClass ( $ className ) ) ; $ startLine = $ reflectionClass -> getStartLine ( ) - 1 ; $ endLine = $ reflectionClass -> getEndLine ( ) ; $ hasUse = false ; $ result = [ ] ; $ result [ ] = 'namespace ' . $ reflectionClass -> getNamespaceName ( ) . ';' ; $ result [ ] = '' ; foreach ( $ lines as $ k => $ v ) { if ( $ k < $ startLine || $ k >= $ endLine ) { 
protected function setSavePath ( ? string $ path = null ) : void { if ( null === $ path ) { $ this -> savePath = null ; } else { $ this -> savePath = $ this -> basePath . '/' . $ path . '.md' ; } } 
protected function isMethodNeedParsed ( ReflectionMethod $ method ) : bool { $ name = $ method -> getName ( ) ; return 0 === strpos ( $ name , 'test' ) || 0 === strpos ( $ name , 'doc' ) ; } 
protected function parseClassContent ( ReflectionClass $ reflection ) : string { if ( ! ( $ comment = $ reflection -> getDocComment ( ) ) || ! ( $ info = $ this -> parseComment ( $ comment ) ) ) { return '' ; } $ data = [ ] ; $ data [ ] = $ this -> formatTitle ( $ info [ 'title' ] ?? '' , true ) ; $ data [ ] = $ this -> formatDescription ( $ info [ 'description' ] ?? '' ) ; $ data [ ] = $ this -> formatUsers ( $ reflection ) ; 
protected function parseMethodContents ( ReflectionClass $ reflection ) : string { $ markdown = '' ; foreach ( $ reflection -> getMethods ( ) as $ method ) { if ( ! $ this -> isMethodNeedParsed ( $ method ) ) { continue ; } $ markdown .= $ this -> parseMethodContent ( $ method ) ; } return $ markdown ; } 
protected function parseMethodContent ( ReflectionMethod $ method ) : string { if ( ! ( $ comment = $ method -> getDocComment ( ) ) || ! ( $ info = $ this -> parseComment ( $ comment ) ) ) { return '' ; } $ data = [ ] ; $ data [ ] = $ this -> formatTitle ( $ info [ 'title' ] ?? '' ) ; $ data [ ] = $ this -> formatDescription ( $ info [ 'description' ] ?? '' ) ; $ data [ ] = $ this -> formatBody ( $ method , $ info [ 'lang' ] ?? 'php' ) ; $ data [ ] = $ this -> formatNote ( $ info [ 'note' ] ?? '' ) ; return implode ( PHP_EOL , $ data ) . PHP_EOL ; } 
protected function formatTitle ( string $ title , bool $ isHeader = false ) : string { if ( $ title ) { $ title = ( $ isHeader ? '#' : '##' ) . " {$title}" . PHP_EOL ; } return $ title ; } 
protected function formatUsers ( ReflectionClass $ reflection ) : string { $ uses = $ this -> parseUseDefined ( $ this -> lines , $ reflection ) ; if ( $ uses ) { $ uses = <<<eot **引入相关类** {$uses} eot ; } return $ uses ; } 
protected function formatBody ( ReflectionMethod $ method , string $ lang ) : string { $ body = $ this -> parseMethodBody ( $ this -> lines , $ method , 0 === strpos ( $ method -> getName ( ) , 'doc' ) ) ; if ( $ body ) { $ body = <<<eot ``` {$lang} {$body} ``` eot ; } return $ body ; } 
protected function parseUseDefined ( array $ lines , ReflectionClass $ classRef ) : string { $ startLine = $ classRef -> getStartLine ( ) - 1 ; $ result = [ ] ; foreach ( $ lines as $ k => $ v ) { $ v = trim ( $ v ) ; if ( $ k >= $ startLine ) { break ; } if ( 0 === strpos ( $ v , 'use ' ) && ! in_array ( $ v , [ 'use Tests\TestCase;' ] , true ) && false === strpos ( $ v , '\\Fixtures\\' ) ) { $ result [ ] = ' * ' . $ v ; } } return implode ( PHP_EOL , $ result ) ; } 
protected function parseMethodBody ( array $ lines , ReflectionMethod $ method , bool $ isDoc = false ) : string { $ startLine = $ method -> getStartLine ( ) - 1 ; $ endLine = $ method -> getEndLine ( ) ; $ offsetLength = 4 ; $ findEot = false ; $ result = [ ] ; 
protected function parseComment ( string $ comment ) : array { $ comments = explode ( PHP_EOL , $ comment ) ; $ findApi = false ; $ result = [ ] ; $ code = [ '$result = [' ] ; foreach ( $ comments as $ v ) { $ v = trim ( $ v , '* ' ) ; $ v = trim ( $ v , '_' ) ; 
public static function make ( array $ datas = [ ] , array $ rules = [ ] , array $ names = [ ] , array $ messages = [ ] ) : IValidator { return new static ( $ datas , $ rules , $ names , $ messages ) ; } 
public function success ( ) : bool { $ skipRule = $ this -> getSkipRule ( ) ; $ this -> failedRules = $ this -> errorMessages = [ ] ; foreach ( $ this -> rules as $ field => $ rules ) { foreach ( $ rules as $ rule ) { if ( in_array ( $ rule , $ skipRule , true ) ) { continue ; } if ( false === $ this -> doValidateItem ( $ field , $ rule ) ) { 
public function data ( array $ datas ) : IValidator { if ( $ this -> checkFlowControl ( ) ) { return $ this ; } $ this -> datas = $ datas ; return $ this ; } 
public function addData ( array $ datas ) : IValidator { if ( $ this -> checkFlowControl ( ) ) { return $ this ; } $ this -> datas = array_merge ( $ this -> datas , $ datas ) ; return $ this ; } 
public function rule ( array $ rules , Closure $ callbacks = null ) : IValidator { if ( $ this -> checkFlowControl ( ) ) { return $ this ; } if ( null === $ callbacks || $ this -> isCallbackValid ( $ callbacks ) ) { $ this -> rules = $ this -> arrayRule ( $ rules ) ; } return $ this ; } 
public function addRule ( array $ rules , Closure $ callbacks = null ) : IValidator { if ( $ this -> checkFlowControl ( ) ) { return $ this ; } if ( null === $ callbacks || $ this -> isCallbackValid ( $ callbacks ) ) { $ this -> rules = array_merge ( $ this -> rules , $ this -> arrayRule ( $ rules ) ) ; } return $ this ; } 
public function message ( array $ messages ) : IValidator { if ( $ this -> checkFlowControl ( ) ) { return $ this ; } $ this -> messages = $ this -> arrayMessage ( $ messages ) ; return $ this ; } 
public function addMessage ( array $ messages ) : IValidator { if ( $ this -> checkFlowControl ( ) ) { return $ this ; } $ this -> messages = array_merge ( $ this -> messages , $ this -> arrayMessage ( $ messages ) ) ; return $ this ; } 
public function name ( array $ names ) : IValidator { if ( $ this -> checkFlowControl ( ) ) { return $ this ; } $ this -> names = $ names ; return $ this ; } 
public function addName ( array $ names ) : IValidator { if ( $ this -> checkFlowControl ( ) ) { return $ this ; } $ this -> names = array_merge ( $ this -> names , $ names ) ; return $ this ; } 
public function alias ( string $ name , string $ alias ) : IValidator { if ( in_array ( $ name , $ this -> getSkipRule ( ) , true ) ) { $ e = sprintf ( 'You cannot set alias for skip rule %s.' , $ name ) ; throw new InvalidArgumentException ( $ e ) ; } $ this -> alias [ $ alias ] = $ name ; return $ this ; } 
public function aliasMany ( array $ alias ) : IValidator { foreach ( $ alias as $ alias => $ value ) { $ this -> alias ( $ alias , $ value ) ; } return $ this ; } 
public function after ( Closure $ callbacks ) : IValidator { $ this -> afters [ ] = function ( ) use ( $ callbacks ) { return $ callbacks ( $ this ) ; } ; return $ this ; } 
public function getParseRule ( string $ field , $ rules ) : array { $ rules = ( array ) $ rules ; foreach ( $ this -> rules [ $ field ] as $ rule ) { list ( $ rule , $ parameter ) = $ this -> parseRule ( $ rule ) ; if ( in_array ( $ rule , $ rules , true ) ) { return [ $ rule , $ parameter ] ; } } return [ ] ; } 
public function getFieldValue ( string $ rule ) { if ( false === strpos ( $ rule , '.' ) ) { if ( isset ( $ this -> datas [ $ rule ] ) ) { return $ this -> datas [ $ rule ] ; } } else { $ parts = explode ( '.' , $ rule ) ; $ datas = $ this -> datas ; foreach ( $ parts as $ part ) { if ( ! isset ( $ datas [ $ part ] ) ) { return ; } $ datas = $ datas [ $ part ] ; } return $ datas ; } } 
protected function arrayMessage ( array $ messages ) : array { $ result = [ ] ; foreach ( $ messages as $ field => $ message ) { 
protected function wildcardMessageItem ( string $ field , $ message ) : array { $ field = $ this -> prepareRegexForWildcard ( $ field ) ; $ messages = [ ] ; foreach ( $ this -> parseDataKey ( ) as $ key ) { if ( preg_match ( $ field , $ key , $ matche ) ) { $ messages = array_merge ( $ messages , $ this -> arrayMessageItem ( $ key , $ message ) ) ; } } return $ messages ; } 
protected function prepareRegexForWildcard ( string $ regex , bool $ strict = true ) : string { $ regex = preg_quote ( $ regex , '/' ) ; $ regex = '/^' . str_replace ( '\*' , '(\S+)' , $ regex ) . ( $ strict ? '$' : '' ) . '/' ; return $ regex ; } 
protected function arrayMessageItem ( string $ field , $ message ) : array { $ result = [ ] ; if ( is_array ( $ message ) ) { foreach ( $ message as $ key => $ message ) { $ result [ $ field . '.' . $ key ] = $ message ; } } else { foreach ( $ this -> getFieldRuleWithoutSkip ( $ field ) as $ rule ) { $ result [ $ field . '.' . $ rule ] = $ message ; } } return $ result ; } 
protected function getFieldRule ( string $ field ) : array { if ( isset ( $ this -> rules [ $ field ] ) ) { return $ this -> rules [ $ field ] ; } return [ ] ; } 
protected function parseRule ( string $ rule ) : array { $ parameter = [ ] ; if ( false !== strpos ( $ rule , ':' ) ) { list ( $ rule , $ parameter ) = explode ( ':' , $ rule , 2 ) ; if ( isset ( $ this -> alias [ $ rule ] ) ) { $ rule = $ this -> alias [ $ rule ] ; } $ parameter = $ this -> parseParameters ( $ rule , $ parameter ) ; } return [ trim ( $ rule ) , $ parameter ] ; } 
protected function arrayRule ( array $ rules ) : array { $ result = [ ] ; foreach ( $ rules as $ field => $ rules ) { if ( false === strpos ( $ field , '*' ) ) { $ result [ $ field ] = $ this -> arrayRuleItem ( $ rules ) ; } else { $ result = array_merge ( $ result , $ this -> wildcardRuleItem ( $ field , $ rules ) ) ; } } return $ result ; } 
protected function wildcardRuleItem ( string $ field , $ rules ) : array { $ field = $ this -> prepareRegexForWildcard ( $ field ) ; $ result = [ ] ; foreach ( $ this -> parseDataKey ( ) as $ key ) { if ( preg_match ( $ field , $ key , $ matche ) ) { $ result [ $ key ] = $ this -> arrayRuleItem ( $ rules ) ; } } return $ result ; } 
protected function parseDataKeyRecursion ( array $ datas , string $ parentKey = '' ) : array { $ dataKeys = [ ] ; foreach ( $ datas as $ key => $ datas ) { $ first = ( $ parentKey ? $ parentKey . '.' : '' ) . $ key ; if ( is_array ( $ datas ) ) { $ dataKeys = array_merge ( $ dataKeys , $ this -> parseDataKeyRecursion ( $ datas , $ first ) ) ; } else { $ dataKeys [ ] = $ first ; } } return $ dataKeys ; } 
protected function hasFieldRuleWithoutParameter ( string $ field , string $ rule ) { $ result = $ this -> hasFieldRuleWithoutParameterReal ( $ field , $ rule ) ; if ( ! $ result && $ rule === static :: DEFAULT_CONDITION ) { return ! $ this -> hasFieldRuleWithoutParameterReal ( $ field , [ static :: CONDITION_MUST , static :: CONDITION_VALUE , ] ) ; } return $ result ; } 
protected function hasFieldRuleWithoutParameterReal ( string $ field , $ rules ) : bool { if ( ! isset ( $ this -> rules [ $ field ] ) ) { return false ; } $ rules = ( array ) $ rules ; foreach ( $ rules as $ rule ) { if ( in_array ( $ rule , $ this -> rules [ $ field ] , true ) ) { return true ; } } return false ; } 
protected function parseParameters ( string $ rule , string $ parameter ) : array { if ( 'regex' === strtolower ( $ rule ) ) { return [ $ parameter ] ; } return explode ( ',' , $ parameter ) ; } 
protected function doValidateItem ( string $ field , string $ rule ) { list ( $ rule , $ parameter ) = $ this -> parseRule ( $ rule ) ; if ( '' === $ rule ) { return ; } $ fieldValue = $ this -> getFieldValue ( $ field ) ; 
protected function addFailure ( string $ field , string $ rule , array $ parameter ) : void { $ this -> addError ( $ field , $ rule , $ parameter ) ; $ this -> failedRules [ $ field ] [ $ rule ] = $ parameter ; } 
protected function addError ( string $ field , string $ rule , array $ parameter ) : void { $ message = $ this -> getFieldRuleMessage ( $ field , $ rule ) ; $ replace = [ 'field' => $ this -> parseFieldName ( $ field ) , ] ; if ( ! $ this -> isImplodeRuleParameter ( $ rule ) ) { foreach ( $ parameter as $ key => $ parameter ) { $ replace [ 'rule' . ( $ key ? : '' ) ] = $ parameter ; } } else { $ replace [ 'rule' ] = implode ( ',' , $ parameter ) ; } $ message = preg_replace_callback ( '/{(.+?)}/' , function ( $ matche ) use ( $ replace ) { return $ replace [ $ matche [ 1 ] ] ?? $ matche [ 0 ] ; } , $ message ) ; $ this -> errorMessages [ $ field ] [ ] = $ message ; unset ( $ replace , $ message ) ; } 
protected function getFieldRuleMessage ( string $ field , string $ rule ) : string { return $ this -> messages [ $ field . '.' . $ rule ] ?? $ this -> messages [ $ rule ] ?? static :: $ defaultMessages [ $ rule ] ?? '' ; } 
protected function callClassExtend ( string $ extend , array $ parameter ) : bool { if ( ! $ this -> container ) { throw new InvalidArgumentException ( 'Container was not set.' ) ; } if ( false === strpos ( $ extend , '@' ) ) { $ className = $ extend ; $ method = 'handle' ; } else { list ( $ className , $ method ) = explode ( '@' , $ extend ) ; } if ( ! is_object ( $ extend = $ this -> container -> make ( $ className ) ) ) { $ e = sprintf ( 'Extend class %s is not valid.' , $ className ) ; throw new InvalidArgumentException ( $ e ) ; } $ parameter [ ] = $ this ; return $ extend -> { $ method } ( ... $ parameter ) ; } 
protected function callExtend ( string $ rule , array $ parameter ) : bool { $ extends = $ this -> extends [ $ rule ] ; if ( is_callable ( $ extends ) ) { $ parameter [ ] = $ this ; return $ extends ( ... $ parameter ) ; } if ( is_string ( $ extends ) ) { return $ this -> callClassExtend ( $ extends , $ parameter ) ; } $ e = sprintf ( 'Extend in rule %s is not valid.' , $ rule ) ; throw new InvalidArgumentException ( $ e ) ; } 
public function onReceive ( SwooleServer $ server , int $ fd , int $ reactorId , string $ data ) : void { parent :: onReceive ( $ server , $ fd , $ reactorId , $ data ) ; $ this -> thriftServer -> receive ( $ server , $ fd , $ reactorId , $ data ) ; } 
protected function makeThriftServer ( ) : ThriftServer { $ service = new ThriftHandler ( ) ; $ processor = new ThriftProcessor ( $ service ) ; $ socketTranport = new TServerSocket ( $ this -> option [ 'host' ] , ( int ) ( $ this -> option [ 'port' ] ) ) ; $ outFactory = $ inFactory = new TFramedTransportFactory ( ) ; $ outProtocol = $ inProtocol = new TBinaryProtocolFactory ( ) ; $ server = new ThriftServer ( $ processor , $ socketTranport , $ inFactory , $ outFactory , $ inProtocol , $ outProtocol ) ; return $ server ; } 
public function gettext ( string $ text , ... $ arr ) : string { $ value = $ this -> text [ $ this -> i18n ] [ $ text ] ?? $ text ; if ( $ arr ) { return sprintf ( $ value , ... $ arr ) ; } return $ value ; } 
public function addtext ( string $ i18n , array $ data = [ ] ) : void { if ( array_key_exists ( $ i18n , $ this -> text ) ) { $ this -> text [ $ i18n ] = array_merge ( $ this -> text [ $ i18n ] , $ data ) ; } else { $ this -> text [ $ i18n ] = $ data ; } } 
public function setVar ( $ name , $ value = null ) : void { if ( is_array ( $ name ) ) { $ this -> vars = array_merge ( $ this -> vars , $ name ) ; } else { $ this -> vars [ $ name ] = $ value ; } } 
public function deleteVar ( array $ name ) : void { foreach ( $ name as $ item ) { if ( isset ( $ this -> vars [ $ item ] ) ) { unset ( $ this -> vars [ $ item ] ) ; } } } 
protected function parseDisplayFile ( ? string $ file = null , ? string $ ext = '' ) : string { if ( ! is_file ( $ file ) ) { $ file = $ this -> parseFile ( $ file , $ ext ) ; } if ( ! is_file ( $ file ) ) { throw new RuntimeException ( sprintf ( 'Template file %s does not exist.' , $ file ) ) ; } return $ file ; } 
protected function parseFile ( ? string $ tpl = null , ? string $ ext = '' ) : string { $ tpl = trim ( str_replace ( '->' , '.' , $ tpl ) ) ; 
public function setCookie ( string $ name , string $ value = '' , array $ option = [ ] ) : void { $ this -> cookie -> set ( $ name , $ value , $ option ) ; } 
public function withCookies ( array $ cookies , array $ option = [ ] ) : void { foreach ( $ cookies as $ key => $ value ) { $ this -> setCookie ( $ key , $ value , $ option ) ; } } 
public function setNode ( $ id , $ parent , $ value , bool $ priority = false ) : void { $ this -> data [ $ id ] = $ value ; if ( $ priority ) { $ tmp = [ $ id => $ parent , ] ; foreach ( $ this -> map as $ key => $ value ) { $ tmp [ $ key ] = $ value ; } $ this -> map = $ tmp ; unset ( $ tmp ) ; } else { $ this -> map [ $ id ] = $ parent ; } } 
public function getChild ( $ id ) : array { $ data = [ ] ; foreach ( $ this -> map as $ key => $ parent ) { if ( ( string ) $ parent === ( string ) $ id ) { $ data [ $ key ] = $ key ; } } return $ data ; } 
public function getChildren ( $ id = 0 ) : array { $ data = [ ] ; foreach ( $ this -> getChild ( $ id ) as $ key ) { $ data [ ] = $ key ; $ data = array_merge ( $ data , $ this -> getChildren ( $ key ) ) ; } return $ data ; } 
public function hasChildren ( $ id , array $ validateChildren , bool $ strict = true ) : bool { if ( empty ( $ validateChildren ) ) { return false ; } $ children = $ this -> getChildren ( $ id ) ; if ( true === $ strict && array_diff ( $ validateChildren , $ children ) ) { return false ; } if ( false === $ strict && array_intersect ( $ validateChildren , $ children ) ) { return true ; } return false ; } 
public function getParent ( $ id , bool $ withItSelf = false ) : array { if ( ! array_key_exists ( $ id , $ this -> map ) ) { return [ ] ; } $ data = [ ] ; if ( array_key_exists ( $ this -> map [ $ id ] , $ this -> map ) ) { $ data [ ] = $ this -> map [ $ id ] ; } if ( true === $ withItSelf ) { $ data [ ] = $ id ; } return $ data ; } 
public function getParents ( $ id , bool $ withItSelf = false ) : array { $ data = $ this -> getParentsReal ( $ id ) ; sort ( $ data ) ; if ( true === $ withItSelf ) { $ data [ ] = $ id ; } return $ data ; } 
public function setData ( $ id , $ value ) : void { if ( isset ( $ this -> data [ $ id ] ) ) { $ this -> data [ $ id ] = $ value ; } } 
public function normalize ( Closure $ callables = null , array $ key = [ ] , $ id = 0 ) : array { $ data = [ ] ; foreach ( $ this -> getChild ( $ id ) as $ value ) { $ item = [ $ key [ 'value' ] ?? 'value' => $ value , $ key [ 'data' ] ?? 'data' => $ this -> data [ $ value ] , ] ; if ( $ callables ) { $ result = $ callables ( $ item , $ this ) ; if ( null !== $ result ) { $ item = $ result ; } } if ( $ children = $ this -> normalize ( $ callables , $ key , $ value ) ) { $ item [ $ key [ 'children' ] ?? 'children' ] = $ children ; } $ data [ ] = $ item ; } return $ data ; } 
public function toJson ( $ option = null ) : string { if ( null === $ option ) { $ option = JSON_UNESCAPED_UNICODE ; } $ args = func_get_args ( ) ; array_shift ( $ args ) ; return json_encode ( $ this -> toArray ( ... $ args ) , $ option ) ; } 
protected function getParentsReal ( $ id ) : array { if ( ! array_key_exists ( $ id , $ this -> map ) ) { return [ ] ; } $ data = [ ] ; if ( array_key_exists ( $ this -> map [ $ id ] , $ this -> map ) ) { $ data [ ] = $ this -> map [ $ id ] ; $ data = array_merge ( $ data , $ this -> getParentsReal ( $ this -> map [ $ id ] ) ) ; } return $ data ; } 
protected function cacheTime ( string $ id , int $ defaultTime = 0 ) : int { if ( ! $ this -> option [ 'time_preset' ] ) { return $ defaultTime ; } if ( isset ( $ this -> option [ 'time_preset' ] [ $ id ] ) ) { return $ this -> option [ 'time_preset' ] [ $ id ] ; } foreach ( $ this -> option [ 'time_preset' ] as $ key => $ value ) { if ( preg_match ( $ this -> prepareRegexForWildcard ( $ key ) , $ id , $ res ) ) { return $ this -> option [ 'time_preset' ] [ $ key ] ; } } return $ defaultTime ; } 
public function handle ( IApp $ app ) : void { if ( file_exists ( $ link = $ app -> path ( 'www/public' ) ) ) { $ this -> error ( sprintf ( 'The `%s` directory already exists.' , $ link ) ) ; return ; } link ( $ path = $ app -> publicPath ( ) , $ link ) ; $ this -> info ( sprintf ( 'Linked `%s` directory to `%s` successed.' , $ path , $ link ) ) ; } 
public function connect ( $ options = null ) : object { list ( $ options , $ unique ) = $ this -> parseOptionAndUnique ( $ options ) ; if ( isset ( $ this -> connects [ $ unique ] ) ) { return $ this -> connects [ $ unique ] ; } $ driver = $ options [ 'driver' ] ?? $ this -> getDefaultDriver ( ) ; return $ this -> connects [ $ unique ] = $ this -> makeConnect ( $ driver , $ options ) ; } 
public function disconnect ( $ options = [ ] ) : void { list ( $ options , $ unique ) = $ this -> parseOptionAndUnique ( $ options ) ; if ( isset ( $ this -> connects [ $ unique ] ) ) { unset ( $ this -> connects [ $ unique ] ) ; } } 
public function getContainerOption ( ? string $ name = null ) { $ name = $ this -> normalizeOptionName ( $ name ) ; return $ this -> container [ 'option' ] [ $ name ] ; } 
public function setContainerOption ( string $ name , $ value ) : void { $ name = $ this -> normalizeOptionName ( $ name ) ; $ this -> container [ 'option' ] [ $ name ] = $ value ; } 
protected function makeConnect ( string $ connect , array $ options = [ ] ) : object { if ( null === $ this -> getContainerOption ( 'connect.' . $ connect ) ) { $ e = sprintf ( 'Connect driver %s not exits.' , $ connect ) ; throw new Exception ( $ e ) ; } return $ this -> createConnect ( $ this -> createConnectCommon ( $ connect , $ options ) ) ; } 
protected function parseOptionParameter ( $ options = [ ] ) : array { if ( null === $ options ) { return [ ] ; } if ( is_string ( $ options ) ) { $ options = $ this -> getContainerOption ( 'connect.' . $ options ) ; if ( ! is_array ( $ options ) ) { return [ ] ; } } return $ options ; } 
protected function normalizeConnectOption ( string $ connect , array $ extendOption = [ ] ) : array { return array_merge ( $ this -> getConnectOption ( $ connect ) , $ this -> getCommonOption ( ) , $ extendOption ) ; } 
protected function filterCommonOption ( array $ options ) : array { foreach ( $ this -> defaultCommonOption ( ) as $ item ) { if ( isset ( $ options [ $ item ] ) ) { unset ( $ options [ $ item ] ) ; } } return $ options ; } 
public function loadData ( IApp $ app ) : array { if ( $ this -> loaded ) { return $ this -> loaded ; } $ env = $ this -> loadEnvData ( $ app ) ; $ composer = $ this -> loadComposerOption ( $ app -> path ( ) ) ; $ data = $ this -> loadOptionData ( ) ; 
protected function loadEnvData ( IApp $ app ) : array { $ oldEnv = $ _ENV ; $ _ENV = [ ] ; try { ( new Dotenv ( $ app -> envPath ( ) , $ app -> envFile ( ) ) ) -> overload ( ) ; } catch ( InvalidPathException $ e ) { throw new RuntimeException ( $ e -> getMessage ( ) ) ; } catch ( InvalidFileException $ e ) { throw new RuntimeException ( $ e -> getMessage ( ) ) ; } $ result = $ _ENV ; $ _ENV = array_merge ( $ oldEnv , $ _ENV ) ; return $ result ; } 
protected function loadDeferredProviderData ( array & $ providers ) : array { $ deferredProviders = $ deferredAlias = [ ] ; foreach ( $ providers as $ k => $ provider ) { if ( ! class_exists ( $ provider ) ) { unset ( $ providers [ $ k ] ) ; continue ; } if ( $ provider :: isDeferred ( ) ) { $ providerAlias = $ provider :: providers ( ) ; foreach ( $ providerAlias as $ key => $ alias ) { if ( is_int ( $ key ) ) { $ key = $ alias ; } $ deferredProviders [ $ key ] = $ provider ; } $ deferredAlias [ $ provider ] = $ providerAlias ; unset ( $ providers [ $ k ] ) ; } } $ providers = array_values ( $ providers ) ; return [ $ deferredProviders , $ deferredAlias , ] ; } 
protected function loadOptionData ( ) : array { $ data = [ ] ; $ files = glob ( $ this -> dir . '/*.php' ) ; $ findApp = false ; foreach ( $ files as $ file ) { $ type = substr ( basename ( $ file ) , 0 , - 4 ) ; if ( 'app' === $ type ) { $ findApp = true ; } $ data [ $ type ] = ( array ) include $ file ; } if ( false === $ findApp ) { throw new RuntimeException ( 'Unable to load the app option file.' ) ; } return $ data ; } 
protected function mergeComposerOption ( array $ options , IApp $ app , array $ optionFiles ) : array { $ data = [ ] ; $ path = $ app -> path ( ) ; foreach ( $ optionFiles as $ key => $ files ) { if ( ! is_array ( $ files ) ) { $ files = [ $ files ] ; } $ optionData = [ ] ; foreach ( $ files as $ item ) { if ( ! is_file ( $ item ) ) { $ item = $ path . '/' . $ item ; } if ( ! is_file ( $ item ) ) { $ e = sprintf ( 'Option file %s is not exist.' , $ item ) ; throw new RuntimeException ( $ e ) ; } $ optionData = array_merge ( $ optionData , include $ item ) ; } if ( array_key_exists ( $ key , $ options ) ) { $ options [ $ key ] = array_merge ( $ options [ $ key ] , $ optionData ) ; } else { $ options [ $ key ] = $ optionData ; } } return $ options ; } 
public function handle ( IApp $ app ) : void { ini_set ( 'display_errors' , 'stderr' ) ; $ kernel = $ app -> make ( IKernel :: class ) ; list ( $ psr7 , $ psr2Leevel , $ leevel2Psr ) = $ this -> getPsrBridge ( ) ; while ( $ req = $ psr7 -> acceptRequest ( ) ) { try { $ request = $ psr2Leevel -> createRequest ( $ req ) ; $ response = $ kernel -> handle ( $ request ) ; $ psr7 -> respond ( $ leevel2Psr -> createResponse ( $ response ) ) ; $ kernel -> terminate ( $ request , $ response ) ; } catch ( Throwable $ e ) { $ psr7 -> getWorker ( ) -> error ( ( string ) $ e ) ; } } } 
public function handle ( IApp $ app ) : void { $ this -> line ( 'Start to clear cache autoload.' ) ; $ cachePath = $ app -> runtimePath ( 'autoload.php' ) ; $ this -> clearCache ( $ cachePath ) ; $ this -> info ( sprintf ( 'Autoload file %s cache clear successed.' , $ cachePath ) ) ; } 
protected function clearCache ( string $ cachePath ) : void { if ( ! is_file ( $ cachePath ) ) { $ this -> warn ( 'Autoload cache files have been cleaned up.' ) ; return ; } unlink ( $ cachePath ) ; } 
public function handle ( string $ pathToFile ) : string { 
public function call ( $ command , array $ arguments = [ ] ) : int { $ arguments [ 'command' ] = $ command ; return $ this -> getApplication ( ) -> find ( $ command ) -> run ( new ArrayInput ( $ arguments ) , $ this -> output ) ; } 
public function confirm ( $ question , $ defaults = false ) : bool { return $ this -> output -> confirm ( $ question , $ defaults ) ; } 
public function ask ( $ question , $ defaults = null ) : string { return $ this -> output -> ask ( $ question , $ defaults ) ; } 
public function table ( array $ headers , array $ rows , $ style = 'default' ) : void { ( new Table ( $ this -> output ) ) -> setHeaders ( $ headers ) -> setRows ( $ rows ) -> setStyle ( $ style ) -> render ( ) ; } 
public function choice ( $ question , array $ choices , $ defaults = null , $ attempts = null , $ multiple = null ) : string { $ question = new ChoiceQuestion ( $ question , $ choices , $ defaults ) ; $ question -> setMaxAttempts ( $ attempts ) -> setMultiselect ( $ multiple ) ; return $ this -> output -> askQuestion ( $ question ) ; } 
public function warn ( $ message , $ verbosity = null ) : void { if ( ! $ this -> output -> getFormatter ( ) -> hasStyle ( 'warning' ) ) { $ this -> output -> getFormatter ( ) -> setStyle ( 'warning' , new OutputFormatterStyle ( 'yellow' ) ) ; } $ this -> line ( $ message , 'warning' , $ verbosity ) ; } 
public function line ( $ message , $ style = null , $ verbosity = null ) : void { $ message = $ style ? "<{$style}>{$message}</{$style}>" : $ message ; $ this -> output -> writeln ( $ message , $ this -> parseVerbosity ( $ verbosity ) ) ; } 
protected function specifyParameters ( ) : void { foreach ( $ this -> getArguments ( ) as $ argument ) { $ this -> addArgument ( ... $ argument ) ; } foreach ( $ this -> getOptions ( ) as $ option ) { $ this -> addOption ( ... $ option ) ; } } 
protected function parseVerbosity ( $ level = null ) : int { return static :: $ verbosityMap [ $ level ] ?? ( ! is_int ( $ level ) ? static :: DEFAULT_VERBOSITY : $ level ) ; } 
public function handle ( array $ middlewares ) : array { $ middlewareGroups = $ this -> router -> getMiddlewareGroups ( ) ; $ middlewareAlias = $ this -> router -> getMiddlewareAlias ( ) ; $ result = [ ] ; foreach ( $ middlewares as $ m ) { if ( ! is_string ( $ m ) ) { throw new InvalidArgumentException ( 'Middleware only allowed string.' ) ; } list ( $ m , $ params ) = $ this -> parseMiddleware ( $ m ) ; if ( isset ( $ middlewareGroups [ $ m ] ) ) { $ temp = is_array ( $ middlewareGroups [ $ m ] ) ? $ middlewareGroups [ $ m ] : [ $ middlewareGroups [ $ m ] ] ; foreach ( $ temp as $ item ) { list ( $ item , $ params ) = $ this -> parseMiddleware ( $ item ) ; $ result [ ] = $ this -> middlewareName ( $ middlewareAlias [ $ item ] ?? $ item , $ params ) ; } } else { $ result [ ] = $ this -> middlewareName ( $ middlewareAlias [ $ m ] ?? $ m , $ params ) ; } } $ result = [ 'handle' => $ this -> normalizeMiddleware ( $ result , 'handle' ) , 'terminate' => $ this -> normalizeMiddleware ( $ result , 'terminate' ) , ] ; if ( empty ( $ result [ 'handle' ] ) && empty ( $ result [ 'terminate' ] ) ) { return [ ] ; } return $ result ; } 
protected function normalizeMiddleware ( array $ middlewares , string $ method ) : array { $ middlewares = array_map ( function ( $ item ) use ( $ method ) { if ( false === strpos ( $ item , ':' ) ) { $ realClass = $ item ; } else { list ( $ realClass ) = explode ( ':' , $ item ) ; } 
protected function parseMiddleware ( string $ middleware ) : array { $ params = '' ; if ( false !== strpos ( $ middleware , ':' ) ) { list ( $ middleware , $ params ) = explode ( ':' , $ middleware ) ; } return [ $ middleware , $ params , ] ; } 
public function withProps ( array $ data ) : IEntity { foreach ( $ data as $ prop => $ value ) { $ this -> offsetSet ( $ prop , $ value ) ; } return $ this ; } 
public function save ( array $ data = [ ] , array $ fill = null ) : IEntity { $ this -> saveEntry ( 'save' , $ data , $ fill ) ; return $ this ; } 
public function create ( array $ data = [ ] , array $ fill = null ) : IEntity { $ this -> saveEntry ( 'create' , $ data , $ fill ) ; return $ this ; } 
public function update ( array $ data = [ ] , array $ fill = null ) : IEntity { $ this -> saveEntry ( 'update' , $ data , $ fill ) ; return $ this ; } 
public function replace ( array $ data = [ ] , array $ fill = null ) : IEntity { $ this -> saveEntry ( 'replace' , $ data , $ fill ) ; return $ this ; } 
public static function destroys ( array $ ids ) : int { $ count = 0 ; $ instance = new static ( ) ; foreach ( $ instance -> whereIn ( $ instance -> singlePrimaryKey ( ) , $ ids ) -> findAll ( ) as $ entity ) { if ( $ entity -> destroy ( ) -> flush ( ) ) { $ count ++ ; } } return $ count ; } 
public function destroy ( ) : IEntity { if ( null === $ this -> primaryKey ( ) ) { $ e = sprintf ( 'Entity %s has no primary key.' , static :: class ) ; throw new InvalidArgumentException ( $ e ) ; } $ this -> leevelFlushed = false ; $ this -> leevelFlush = function ( $ condition ) { $ this -> handleEvent ( static :: BEFORE_DELETE_EVENT , $ condition ) ; $ num = $ this -> metaConnect ( ) -> delete ( $ condition ) ; $ this -> handleEvent ( static :: AFTER_DELETE_EVENT ) ; return $ num ; } ; $ this -> leevelFlushData = [ $ this -> idCondition ( ) ] ; return $ this ; } 
public function flush ( ) { if ( ! $ this -> leevelFlush || true === $ this -> leevelFlushed ) { return ; } try { $ result = call_user_func_array ( $ this -> leevelFlush , $ this -> leevelFlushData ) ; } catch ( ReplaceException $ e ) { if ( false === $ this -> leevelReplace ) { throw $ e ; } $ this -> leevelFlush = null ; $ this -> leevelFlushData = null ; $ this -> updateReal ( $ this -> leevelReplace ) ; $ this -> leevelReplace = false ; return $ this -> flush ( ) ; } $ this -> leevelFlush = null ; $ this -> leevelFlushData = null ; $ this -> leevelFlushed = true ; $ this -> handleEvent ( static :: AFTER_SAVE_EVENT ) ; return $ result ; } 
public function id ( ) { $ result = [ ] ; foreach ( ( $ keys = $ this -> primaryKeys ( ) ) as $ value ) { if ( ! ( $ tmp = $ this -> __get ( $ value ) ) ) { continue ; } $ result [ $ value ] = $ tmp ; } if ( ! $ result ) { return ; } 
public function refresh ( ) : void { $ key = $ this -> primaryKey ( ) ; if ( null === $ key ) { $ e = sprintf ( 'Entity %s do not have primary key.' , static :: class ) ; throw new InvalidArgumentException ( $ e ) ; } if ( is_array ( $ key ) ) { $ map = $ this -> id ( ) ; } else { $ map = [ $ this -> singlePrimaryKey ( ) , $ this -> id ( ) ] ; } $ data = $ this -> metaConnect ( ) -> select ( ) -> where ( $ map ) -> findOne ( ) ; foreach ( $ data as $ k => $ v ) { $ this -> withPropValue ( $ k , $ v , false ) ; } } 
public function loadRelationProp ( string $ prop ) { if ( $ result = $ this -> relationProp ( $ prop ) ) { return $ result ; } return $ this -> loadDataFromRelation ( $ prop ) ; } 
public function isRelation ( string $ prop ) : bool { $ prop = $ this -> normalize ( $ prop ) ; $ this -> validate ( $ prop ) ; $ struct = static :: STRUCT [ $ prop ] ; if ( isset ( $ struct [ self :: BELONGS_TO ] ) || isset ( $ struct [ self :: HAS_MANY ] ) || isset ( $ struct [ self :: HAS_ONE ] ) || isset ( $ struct [ self :: MANY_MANY ] ) ) { return true ; } return false ; } 
public function loadRelation ( string $ prop ) : Relation { $ prop = $ this -> normalize ( $ prop ) ; $ this -> validate ( $ prop ) ; $ defined = static :: STRUCT [ $ prop ] ; if ( isset ( $ defined [ self :: BELONGS_TO ] ) ) { $ this -> validateRelationDefined ( $ defined , [ 'source_key' , 'target_key' ] ) ; $ relation = $ this -> belongsTo ( $ defined [ self :: BELONGS_TO ] , $ defined [ 'target_key' ] , $ defined [ 'source_key' ] ) ; } elseif ( isset ( $ defined [ self :: HAS_MANY ] ) ) { $ this -> validateRelationDefined ( $ defined , [ 'source_key' , 'target_key' ] ) ; $ relation = $ this -> hasMany ( $ defined [ self :: HAS_MANY ] , $ defined [ 'target_key' ] , $ defined [ 'source_key' ] ) ; } elseif ( isset ( $ defined [ self :: HAS_ONE ] ) ) { $ this -> validateRelationDefined ( $ defined , [ 'source_key' , 'target_key' ] ) ; $ relation = $ this -> hasOne ( $ defined [ self :: HAS_ONE ] , $ defined [ 'target_key' ] , $ defined [ 'source_key' ] ) ; } elseif ( isset ( $ defined [ self :: MANY_MANY ] ) ) { $ this -> validateRelationDefined ( $ defined , [ 'middle_entity' , 'source_key' , 'target_key' , 'middle_target_key' , 'middle_source_key' , ] ) ; $ relation = $ this -> ManyMany ( $ defined [ self :: MANY_MANY ] , $ defined [ 'middle_entity' ] , $ defined [ 'target_key' ] , $ defined [ 'source_key' ] , $ defined [ 'middle_target_key' ] , $ defined [ 'middle_source_key' ] ) ; } if ( isset ( $ defined [ self :: SCOPE ] ) ) { call_user_func ( [ $ this , 'scope' . ucfirst ( $ defined [ self :: SCOPE ] ) ] , $ relation ) ; } return $ relation ; } 
public function withRelationProp ( string $ prop , $ value ) : void { $ this -> validate ( $ prop ) ; $ this -> propSetter ( $ prop , $ value ) ; } 
public function hasOne ( string $ relatedEntityClass , string $ targetKey , string $ sourceKey ) : HasOne { $ entity = new $ relatedEntityClass ( ) ; $ this -> validateRelationField ( $ entity , $ targetKey ) ; $ this -> validateRelationField ( $ this , $ sourceKey ) ; return new HasOne ( $ entity , $ this , $ targetKey , $ sourceKey ) ; } 
public function belongsTo ( string $ relatedEntityClass , string $ targetKey , string $ sourceKey ) : BelongsTo { $ entity = new $ relatedEntityClass ( ) ; $ this -> validateRelationField ( $ entity , $ targetKey ) ; $ this -> validateRelationField ( $ this , $ sourceKey ) ; return new BelongsTo ( $ entity , $ this , $ targetKey , $ sourceKey ) ; } 
public function hasMany ( string $ relatedEntityClass , string $ targetKey , string $ sourceKey ) : HasMany { $ entity = new $ relatedEntityClass ( ) ; $ this -> validateRelationField ( $ entity , $ targetKey ) ; $ this -> validateRelationField ( $ this , $ sourceKey ) ; return new HasMany ( $ entity , $ this , $ targetKey , $ sourceKey ) ; } 
public function manyMany ( string $ relatedEntityClass , string $ middleEntityClass , string $ targetKey , string $ sourceKey , string $ middleTargetKey , string $ middleSourceKey ) : ManyMany { $ entity = new $ relatedEntityClass ( ) ; $ middleEntity = new $ middleEntityClass ( ) ; $ this -> validateRelationField ( $ entity , $ targetKey ) ; $ this -> validateRelationField ( $ middleEntity , $ middleTargetKey ) ; $ this -> validateRelationField ( $ this , $ sourceKey ) ; $ this -> validateRelationField ( $ middleEntity , $ middleSourceKey ) ; return new ManyMany ( $ entity , $ this , $ middleEntity , $ targetKey , $ sourceKey , $ middleTargetKey , $ middleSourceKey ) ; } 
public static function event ( string $ event , $ listener ) : void { if ( null === static :: $ leevelDispatch && static :: lazyloadPlaceholder ( ) && null === static :: $ leevelDispatch ) { return ; } static :: isSupportEvent ( $ event ) ; static :: $ leevelDispatch -> register ( "entity.{$event}:" . static :: class , $ listener ) ; } 
public function handleEvent ( string $ event , ... $ args ) : void { if ( null === static :: $ leevelDispatch ) { return ; } $ this -> isSupportEvent ( $ event ) ; array_unshift ( $ args , $ this ) ; array_unshift ( $ args , "entity.{$event}:" . get_class ( $ this ) ) ; static :: $ leevelDispatch -> handle ( ... $ args ) ; } 
public static function isSupportEvent ( string $ event ) : void { if ( ! in_array ( $ event , static :: supportEvent ( ) , true ) ) { $ e = sprintf ( 'Event `%s` do not support.' ) ; throw new InvalidArgumentException ( $ e ) ; } } 
public static function supportEvent ( ) : array { return [ static :: BEFORE_SELECT_EVENT , static :: AFTER_SELECT_EVENT , static :: BEFORE_FIND_EVENT , static :: AFTER_FIND_EVENT , static :: BEFORE_SAVE_EVENT , static :: AFTER_SAVE_EVENT , static :: BEFORE_CREATE_EVENT , static :: AFTER_CREATE_EVENT , static :: BEFORE_UPDATE_EVENT , static :: AFTER_UPDATE_EVENT , static :: BEFORE_DELETE_EVENT , static :: AFTER_DELETE_EVENT , static :: BEFORE_SOFT_DELETE_EVENT , static :: AFTER_SOFT_DELETE_EVENT , static :: BEFORE_SOFT_RESTORE_EVENT , static :: AFTER_SOFT_RESTORE_EVENT , ] ; } 
public function addChanged ( array $ props ) : IEntity { foreach ( $ props as $ prop ) { if ( ! in_array ( $ prop , $ this -> leevelChangedProp , true ) ) { continue ; } $ this -> leevelChangedProp [ ] = $ prop ; } return $ this ; } 
public function deleteChanged ( array $ props ) : IEntity { $ this -> leevelChangedProp = array_values ( array_diff ( $ this -> leevelChangedProp , $ props ) ) ; return $ this ; } 
public static function singlePrimaryKey ( ) : string { $ key = static :: primaryKey ( ) ; if ( ! is_string ( $ key ) ) { $ e = sprintf ( 'Entity %s do not have primary key or composite id not supported.' , static :: class ) ; throw new InvalidArgumentException ( $ e ) ; } return $ key ; } 
public static function enum ( string $ prop , $ enum = null , string $ separate = ',' ) { $ prop = static :: normalize ( $ prop ) ; $ enumDefined = static :: class . '::' . strtoupper ( $ prop ) . '_ENUM' ; if ( ! defined ( $ enumDefined ) ) { return false ; } if ( ! isset ( static :: $ leevelEnums [ static :: class ] ) || ! isset ( static :: $ leevelEnums [ static :: class ] [ $ prop ] ) ) { $ enums = constant ( $ enumDefined ) ; $ enums = array_values ( $ enums ) ; foreach ( $ enums as & $ e ) { if ( ! isset ( $ e [ 1 ] ) ) { $ e = sprintf ( 'Invalid enum in the field `%s` of entity `%s`.' , $ prop , static :: class ) ; throw new InvalidArgumentException ( $ e ) ; } $ e [ 1 ] = __ ( $ e [ 1 ] ) ; } static :: $ leevelEnums [ static :: class ] [ $ prop ] = $ enums ; } else { $ enums = static :: $ leevelEnums [ static :: class ] [ $ prop ] ; } if ( null === $ enum ) { return $ enums ; } $ enums = array_column ( $ enums , 1 , 0 ) ; $ enumSep = explode ( ',' , ( string ) $ enum ) ; foreach ( $ enumSep as $ v ) { if ( ! isset ( $ enums [ $ v ] ) && ! isset ( $ enums [ ( int ) $ v ] ) ) { $ e = sprintf ( 'Value not a enum in the field `%s` of entity `%s`.' , $ prop , static :: class ) ; throw new InvalidArgumentException ( $ e ) ; } $ result [ ] = isset ( $ enums [ $ v ] ) ? $ enums [ $ v ] : $ enums [ ( int ) $ v ] ; } return implode ( $ separate , $ result ) ; } 
public function toJson ( $ option = null ) : string { if ( null === $ option ) { $ option = JSON_UNESCAPED_UNICODE ; } return json_encode ( $ this -> toArray ( ) , $ option ) ; } 
public function idCondition ( ) : array { if ( null === ( ( $ ids = $ this -> id ( ) ) ) ) { $ e = sprintf ( 'Entity %s has no primary key data.' , static :: class ) ; throw new InvalidArgumentException ( $ e ) ; } if ( ! is_array ( $ ids ) ) { $ ids = [ $ this -> singlePrimaryKey ( ) => $ ids ] ; } return $ ids ; } 
public function databaseSelect ( ) : DatabaseSelect { if ( $ this -> leevelScopeSelect ) { return $ this -> leevelScopeSelect ; } return $ this -> metaConnect ( ) -> select ( ) -> asClass ( static :: class , [ true ] ) -> asCollection ( ) ; } 
protected function saveEntry ( string $ method , array $ data , ? array $ fill = null ) : IEntity { foreach ( $ data as $ k => $ v ) { $ this -> withPropValue ( $ k , $ v ) ; } $ this -> handleEvent ( static :: BEFORE_SAVE_EVENT ) ; 
protected function createReal ( ? array $ fill = null ) : IEntity { $ this -> leevelFlushed = false ; $ this -> parseAutoFill ( 'create' , $ fill ) ; $ propKey = $ this -> normalizeWhiteAndBlack ( array_flip ( $ this -> leevelChangedProp ) , 'create_prop' ) ; $ saveData = [ ] ; foreach ( $ this -> leevelChangedProp as $ prop ) { if ( ! array_key_exists ( $ prop , $ propKey ) ) { continue ; } $ saveData [ $ prop ] = $ this -> __get ( $ prop ) ; } if ( ! $ saveData ) { if ( null === ( ( $ primaryKey = $ this -> primaryKeys ( ) ) ) ) { $ e = sprintf ( 'Entity %s has no primary key.' , static :: class ) ; throw new InvalidArgumentException ( $ e ) ; } foreach ( $ primaryKey as $ value ) { $ saveData [ $ value ] = null ; } } $ this -> leevelFlush = function ( $ saveData ) { $ this -> handleEvent ( static :: BEFORE_CREATE_EVENT , $ saveData ) ; $ lastInsertId = $ this -> metaConnect ( ) -> insert ( $ saveData ) ; if ( $ auto = $ this -> autoIncrement ( ) ) { $ this -> withPropValue ( $ auto , $ lastInsertId , false , true ) ; } $ this -> leevelNewed = false ; $ this -> clearChanged ( ) ; $ this -> handleEvent ( static :: AFTER_CREATE_EVENT , $ saveData ) ; return $ lastInsertId ; } ; $ this -> leevelFlushData = [ $ saveData ] ; return $ this ; } 
protected function updateReal ( ? array $ fill = null ) : IEntity { $ this -> leevelFlushed = false ; $ this -> parseAutoFill ( 'update' , $ fill ) ; $ propKey = $ this -> normalizeWhiteAndBlack ( array_flip ( $ this -> leevelChangedProp ) , 'update_prop' ) ; $ saveData = [ ] ; foreach ( $ this -> leevelChangedProp as $ prop ) { if ( ! array_key_exists ( $ prop , $ propKey ) ) { continue ; } $ saveData [ $ prop ] = $ this -> __get ( $ prop ) ; } if ( ! $ saveData ) { return $ this ; } $ condition = [ ] ; foreach ( $ this -> primaryKeys ( ) as $ field ) { if ( isset ( $ saveData [ $ field ] ) ) { unset ( $ saveData [ $ field ] ) ; } if ( $ value = $ this -> __get ( $ field ) ) { $ condition [ $ field ] = $ value ; } } if ( empty ( $ condition ) || empty ( $ saveData ) ) { return $ this ; } $ this -> leevelFlush = function ( $ condition , $ saveData ) { $ this -> handleEvent ( static :: BEFORE_UPDATE_EVENT , $ saveData , $ condition ) ; $ num = $ this -> metaConnect ( ) -> update ( $ condition , $ saveData ) ; $ this -> handleEvent ( static :: BEFORE_UPDATE_EVENT , null , null ) ; $ this -> clearChanged ( ) ; $ this -> handleEvent ( static :: AFTER_UPDATE_EVENT ) ; return $ num ; } ; $ this -> leevelFlushData = [ $ condition , $ saveData ] ; return $ this ; } 
protected function replaceReal ( ? array $ fill = null ) : void { $ this -> leevelReplace = $ fill ; $ this -> createReal ( $ fill ) ; } 
protected function withPropValue ( string $ prop , $ value , bool $ force = true , bool $ ignoreReadonly = false ) : void { $ prop = $ this -> normalize ( $ prop ) ; $ this -> validate ( $ prop ) ; if ( $ this -> isRelation ( $ prop ) ) { $ e = sprintf ( 'Cannot set a relation prop `%s` on entity `%s`.' , $ prop , static :: class ) ; throw new InvalidArgumentException ( $ e ) ; } $ this -> propSetter ( $ prop , $ value ) ; if ( ! $ force ) { return ; } if ( false === $ ignoreReadonly && isset ( static :: STRUCT [ $ prop ] [ 'readonly' ] ) && true === static :: STRUCT [ $ prop ] [ 'readonly' ] ) { $ e = sprintf ( 'Cannot set a read-only prop `%s` on entity `%s`.' , $ prop , static :: class ) ; throw new InvalidArgumentException ( $ e ) ; } if ( in_array ( $ prop , $ this -> leevelChangedProp , true ) ) { return ; } $ this -> leevelChangedProp [ ] = $ prop ; } 
protected function propValue ( string $ prop ) { $ prop = $ this -> normalize ( $ prop ) ; $ this -> validate ( $ prop ) ; if ( ! $ this -> isRelation ( $ prop ) ) { return $ this -> propGetter ( $ prop ) ; } return $ this -> loadRelationProp ( $ prop ) ; } 
protected function hasProp ( string $ prop ) : bool { $ prop = $ this -> normalize ( $ prop ) ; if ( ! $ this -> hasField ( $ prop ) ) { return false ; } $ prop = $ this -> asProp ( $ prop ) ; if ( ! property_exists ( $ this , $ prop ) ) { $ e = sprintf ( 'Prop `%s` of entity `%s` was not defined.' , $ prop , get_class ( $ this ) ) ; throw new InvalidArgumentException ( $ e ) ; } return true ; } 
protected function propSetter ( string $ prop , $ value ) : void { $ this -> { 'setter' . ucfirst ( $ this -> asProp ( $ prop ) ) } ( $ value ) ; } 
protected function parseAutoFill ( string $ type , ? array $ fill = null ) : void { if ( null === $ fill ) { return ; } foreach ( static :: STRUCT as $ prop => $ value ) { if ( $ fill && ! in_array ( $ prop , $ fill , true ) ) { continue ; } if ( array_key_exists ( $ type . '_fill' , $ value ) ) { $ this -> normalizeFill ( $ prop , $ value [ $ type . '_fill' ] ) ; } } } 
protected function normalizeFill ( string $ prop , $ value ) : void { if ( null === $ value ) { $ camelizeClass = 'fill' . ucfirst ( $ this -> asProp ( $ prop ) ) ; if ( method_exists ( $ this , $ camelizeClass ) ) { $ value = $ this -> { $ camelizeClass } ( $ this -> propValue ( $ prop ) ) ; } } $ this -> withPropValue ( $ prop , $ value ) ; } 
protected function loadDataFromRelation ( string $ prop ) { $ relation = $ this -> loadRelation ( $ prop ) ; $ result = $ relation -> sourceQuery ( ) ; $ this -> withRelationProp ( $ prop , $ result ) ; return $ result ; } 
protected function prop ( string $ prop ) : string { $ this -> validate ( $ prop ) ; return $ this -> asProp ( $ prop ) ; } 
protected function validate ( string $ prop ) : void { $ prop = $ this -> normalize ( $ prop ) ; if ( ! $ this -> hasProp ( $ prop ) ) { $ e = sprintf ( 'Entity `%s` prop or field of struct `%s` was not defined.' , get_class ( $ this ) , $ prop ) ; throw new InvalidArgumentException ( $ e ) ; } } 
protected function validateRelationDefined ( array $ defined , array $ field ) : void { foreach ( $ field as $ v ) { if ( ! isset ( $ defined [ $ v ] ) ) { $ e = sprintf ( 'Relation `%s` field was not defined.' , $ v ) ; throw new InvalidArgumentException ( $ e ) ; } } } 
protected function validateRelationField ( IEntity $ entity , string $ field ) : void { if ( ! $ entity -> hasField ( $ field ) ) { $ e = sprintf ( 'The field `%s`.`%s` of entity `%s` was not defined.' , $ entity -> table ( ) , $ field , get_class ( $ entity ) ) ; throw new InvalidArgumentException ( $ e ) ; } } 
protected function normalizeWhiteAndBlack ( array $ key , string $ type ) : array { return $ this -> whiteAndBlack ( $ key , $ this -> leevelBlackWhites [ $ type ] [ 'white' ] , $ this -> leevelBlackWhites [ $ type ] [ 'black' ] ) ; } 
protected function toArraySource ( array $ white = [ ] , array $ black = [ ] , string $ separate = ',' ) : array { if ( $ white || $ black ) { $ prop = $ this -> whiteAndBlack ( $ this -> fields ( ) , $ white , $ black ) ; } else { $ prop = $ this -> normalizeWhiteAndBlack ( $ this -> fields ( ) , 'show_prop' ) ; } $ result = [ ] ; foreach ( $ prop as $ k => $ value ) { if ( $ this -> isRelation ( $ k ) ) { continue ; } $ value = $ this -> propValue ( $ k ) ; $ result [ $ k ] = $ value ; $ result = static :: prepareEnum ( $ k , $ result , $ separate ) ; } return $ result ; } 
protected static function prepareEnum ( string $ prop , array $ data , string $ separate = ',' ) : array { if ( ! isset ( $ data [ $ prop ] ) ) { return $ data ; } if ( false === ( $ enum = static :: enum ( $ prop , $ data [ $ prop ] , $ separate ) ) ) { return $ data ; } $ data [ $ prop . '_' . self :: ENUM ] = $ enum ; return $ data ; } 
protected function whiteAndBlack ( array $ key , array $ white , array $ black ) : array { if ( $ white ) { $ key = array_intersect_key ( $ key , array_flip ( $ white ) ) ; } elseif ( $ black ) { $ key = array_diff_key ( $ key , array_flip ( $ black ) ) ; } return $ key ; } 
protected static function normalize ( string $ prop ) : string { if ( isset ( static :: $ leevelUnCamelize [ $ prop ] ) ) { return static :: $ leevelUnCamelize [ $ prop ] ; } return static :: $ leevelUnCamelize [ $ prop ] = un_camelize ( $ prop ) ; } 
protected function asProp ( string $ prop ) : string { if ( isset ( static :: $ leevelCamelize [ $ prop ] ) ) { return static :: $ leevelCamelize [ $ prop ] ; } return static :: $ leevelCamelize [ $ prop ] = camelize ( $ prop ) ; } 
public function onRequest ( SwooleHttpRequest $ swooleRequest , SwooleHttpResponse $ swooleResponse ) : void { 
public function onHttpClose ( SwooleHttpServer $ server , int $ fd , int $ reactorId ) : void { $ this -> log ( sprintf ( 'Server close, fd %d, reactorId %d.' , $ fd , $ reactorId ) ) ; } 
protected function dispatchRouter ( IRequest $ request ) : IResponse { $ kernel = $ this -> container -> make ( IKernel :: class ) ; $ response = $ kernel -> handle ( $ request ) ; $ kernel -> terminate ( $ request , $ response ) ; $ this -> removeCoroutine ( ) ; return $ response ; } 
protected function normalizeResponse ( IResponse $ response , SwooleHttpResponse $ swooleResponse ) : SwooleHttpResponse { foreach ( $ response -> getCookies ( ) as $ item ) { call_user_func_array ( [ $ swooleResponse , 'cookie' ] , $ item ) ; } if ( $ response instanceof RedirectResponse && method_exists ( $ swooleResponse , 'redirect' ) ) { $ swooleResponse -> redirect ( $ response -> getTargetUrl ( ) ) ; } foreach ( $ response -> headers -> all ( ) as $ key => $ value ) { $ swooleResponse -> header ( $ key , $ value ) ; } $ swooleResponse -> status ( $ response -> getStatusCode ( ) ) ; $ swooleResponse -> write ( $ response -> getContent ( ) ? : ' ' ) ; return $ swooleResponse ; } 
protected function normalizeRequest ( SwooleHttpRequest $ swooleRequest ) : IRequest { $ request = new Request ( ) ; $ datas = [ 'header' => 'headers' , 'server' => 'server' , 'cookie' => 'cookies' , 'get' => 'query' , 'files' => 'files' , 'post' => 'request' , ] ; $ servers = [ ] ; if ( $ swooleRequest -> header ) { $ tmp = $ tmpHeader = [ ] ; foreach ( $ swooleRequest -> header as $ key => $ value ) { $ key = strtoupper ( str_replace ( '-' , '_' , $ key ) ) ; $ tmpHeader [ $ key ] = $ value ; $ key = 'HTTP_' . $ key ; $ tmp [ $ key ] = $ value ; } $ servers = $ tmp ; $ swooleRequest -> header = $ tmpHeader ; } if ( $ swooleRequest -> server ) { $ swooleRequest -> server = array_change_key_case ( $ swooleRequest -> server , CASE_UPPER ) ; $ servers = array_merge ( $ servers , $ swooleRequest -> server ) ; $ swooleRequest -> server = $ servers ; } else { $ swooleRequest -> server = $ servers ? : null ; } foreach ( $ datas as $ key => $ item ) { if ( $ swooleRequest -> { $ key } ) { $ request -> { $ item } -> replace ( $ swooleRequest -> { $ key } ) ; } } return $ request ; } 
protected function createServer ( ) : void { unset ( $ this -> option [ 'task_worker_num' ] ) ; $ this -> server = new SwooleHttpServer ( $ this -> option [ 'host' ] , ( int ) ( $ this -> option [ 'port' ] ) ) ; $ this -> initServer ( ) ; 
public function addNamespace ( array $ namespaces ) : self { $ this -> namespaces = array_merge ( $ this -> namespaces , $ namespaces ) ; return $ this ; } 
public function loadData ( ) : array { if ( null !== $ this -> loaded ) { return $ this -> loaded ; } $ files = $ this -> findConsoleFile ( $ this -> namespaces ) ; return $ this -> loaded = $ files ; } 
public function findConsoleFile ( array $ namespaces ) : array { $ files = [ ] ; foreach ( $ namespaces as $ key => $ dir ) { if ( ! is_dir ( $ dir ) ) { throw new RuntimeException ( sprintf ( 'Console load dir %s is not exits.' , $ dir ) ) ; } $ currentFiles = glob ( $ dir . '/*.php' ) ; $ currentFiles = array_map ( function ( $ item ) use ( $ key ) { return $ key . '\\' . basename ( $ item , '.php' ) ; } , $ currentFiles ) ; 
public function send ( Swift_Mime_SimpleMessage $ message , & $ failedRecipients = null ) { return $ this -> getSwiftMailer ( ) -> send ( $ message , $ failedRecipients ) ; } 
public function setOption ( string $ name , $ value ) : IServer { $ this -> option [ $ name ] = $ value ; return $ this ; } 
public function process ( string $ process ) : void { $ newProgress = new Process ( function ( Process $ worker ) use ( $ process ) { $ newProgress = $ this -> container -> make ( $ process ) ; if ( ! is_object ( $ newProgress ) || ( $ newProgress instanceof ProtocolProcess ) ) { throw new InvalidArgumentException ( sprintf ( 'Process `%s` was invalid.' , $ process ) ) ; } if ( ! is_callable ( [ $ newProgress , 'handle' ] ) ) { throw new InvalidArgumentException ( sprintf ( 'The `handle` of process `%s` was not found.' , $ process ) ) ; } $ worker -> name ( $ this -> option [ 'process_name' ] . '.' . $ newProgress -> getName ( ) ) ; $ newProgress -> handle ( $ this , $ worker ) ; } ) ; $ this -> server -> addProcess ( $ newProgress ) ; } 
public function startServer ( ) : void { $ this -> checkPidPath ( ) ; $ this -> createServer ( ) ; $ this -> eventServer ( ) ; $ this -> startSwooleServer ( ) ; } 
public function onStart ( SwooleServer $ server ) : void { $ this -> log ( sprintf ( 'Server is started at %s:%d' , $ this -> option [ 'host' ] , $ this -> option [ 'port' ] ) , true , '' ) ; $ this -> log ( 'Server master worker start' , true ) ; $ this -> setProcessName ( $ this -> option [ 'process_name' ] . '.master' ) ; $ pid = $ server -> master_pid . "\n" . $ server -> manager_pid ; $ dirname = dirname ( $ this -> option [ 'pid_path' ] ) ; if ( ! is_writable ( $ dirname ) || ! file_put_contents ( $ this -> option [ 'pid_path' ] , $ pid ) ) { throw new InvalidArgumentException ( sprintf ( 'Dir %s is not writeable.' , $ dirname ) ) ; } chmod ( $ this -> option [ 'pid_path' ] , 0666 & ~ umask ( ) ) ; 
public function onConnect ( SwooleServer $ server , int $ fd , int $ reactorId ) : void { $ this -> log ( sprintf ( 'Server connect, fd %d, reactorId %d.' , $ fd , $ reactorId ) ) ; } 
public function onWorkerStart ( SwooleServer $ server , int $ workeId ) : void { if ( $ workeId >= $ this -> option [ 'worker_num' ] ) { $ this -> setProcessName ( $ this -> option [ 'process_name' ] . '.task' ) ; } else { $ this -> setProcessName ( $ this -> option [ 'process_name' ] . '.worker' ) ; } 
public function onManagerStart ( SwooleServer $ server ) : void { $ this -> log ( 'Server manager worker start' , true ) ; $ this -> setProcessName ( $ this -> option [ 'process_name' ] . '.manager' ) ; } 
public function onWorkerStop ( SwooleServer $ server , int $ workerId ) : void { $ this -> log ( sprintf ( 'Server %s worker %d shutdown' , $ server -> setting [ 'process_name' ] , $ workerId ) ) ; } 
public function onReceive ( SwooleServer $ server , int $ fd , int $ reactorId , string $ data ) : void { } 
public function onFinish ( SwooleServer $ server , int $ taskId , string $ data ) : void { $ this -> log ( sprintf ( 'Task %d finish, the result is %s' , $ taskId , $ data ) ) ; } 
public function onTask ( SwooleServer $ server , int $ taskId , int $ fromId , string $ data ) : void { $ this -> log ( sprintf ( 'Task %d form workder %d, the result is %s' , $ taskId , $ fromId , $ data ) ) ; $ server -> finish ( $ data ) ; } 
public function onShutdown ( SwooleServer $ server ) : void { if ( is_file ( $ this -> option [ 'pid_path' ] ) ) { unlink ( $ this -> option [ 'pid_path' ] ) ; } $ this -> log ( 'Server shutdown' ) ; } 
protected function createServer ( ) : void { $ this -> server = new SwooleServer ( $ this -> option [ 'host' ] , ( int ) ( $ this -> option [ 'port' ] ) ) ; $ this -> initServer ( ) ; } 
protected function initServer ( ) : void { $ this -> server -> set ( $ this -> option ) ; foreach ( $ this -> option [ 'processes' ] as $ process ) { $ this -> process ( $ process ) ; } } 
protected function eventServer ( ) : void { $ type = get_class ( $ this ) ; $ type = substr ( $ type , strrpos ( $ type , '\\' ) + 1 ) ; $ type = str_replace ( 'Server' , '' , $ type ) ; foreach ( $ this -> serverEvent as $ event ) { if ( ! method_exists ( $ this , $ onEvent = 'on' . $ type . ucfirst ( $ event ) ) ) { $ onEvent = 'on' . ucfirst ( $ event ) ; } $ this -> server -> on ( $ event , [ $ this , $ onEvent ] ) ; } } 
protected function setProcessName ( string $ name ) : void { if ( function_exists ( 'cli_set_process_title' ) ) { cli_set_process_title ( $ name ) ; } else { if ( function_exists ( 'swoole_set_process_name' ) ) { swoole_set_process_name ( $ name ) ; } else { throw new InvalidArgumentException ( 'Require cli_set_process_title or swoole_set_process_name.' ) ; } } } 
protected function log ( string $ message , bool $ force = false , string $ formatTime = 'H:i:s' ) : void { if ( ! $ force && ! $ this -> daemonize ( ) ) { return ; } fwrite ( STDOUT , $ this -> messageTime ( $ message , $ formatTime ) . PHP_EOL ) ; } 
protected function messageTime ( string $ message , string $ formatTime = '' ) : string { return ( $ formatTime ? sprintf ( '[%s]' , date ( $ formatTime ) ) : '' ) . $ message ; } 
public static function lazy ( $ value , ? string $ message = null , bool $ all = true ) : self { return new static ( $ value , $ message , true , $ all ) ; } 
public function flush ( Closure $ format = null ) : bool { if ( $ this -> error ) { if ( ! $ format ) { $ format = 'json_encode' ; } $ e = $ format ( $ this -> error ) ; throw new AssertException ( $ e ) ; } return true ; } 
protected static function validateAssert ( string $ method , array $ args ) : bool { if ( ! array_key_exists ( 0 , $ args ) ) { throw new InvalidArgumentException ( 'Missing the first argument.' ) ; } 
protected static function normalizeMessage ( array $ args , ? string $ message = null ) : string { if ( count ( $ args ) >= 2 && is_string ( $ args [ array_key_last ( $ args ) ] ) ) { $ message = array_pop ( $ args ) ; } else { $ message = $ message ?? 'No exception messsage specified.' ; } return $ message ; } 
protected static function matchOptional ( string $ method , array $ args ) { if ( 0 !== strpos ( $ method , 'optional' ) ) { return [ $ method , false ] ; } if ( null === $ args [ 0 ] ) { self :: countPhpUnit ( ) ; return true ; } $ method = substr ( $ method , 8 ) ; return [ $ method , true ] ; } 
protected static function matchMulti ( string $ method , array $ args , bool $ optional ) { if ( 0 !== stripos ( $ method , 'multi' ) ) { return [ $ method , [ $ args ] ] ; } if ( ! is_array ( $ args [ 0 ] ) && ! $ args instanceof Traversable ) { $ e = sprintf ( 'Invalid first argument for multi assert.' ) ; throw new InvalidArgumentException ( $ e ) ; } $ multi = [ ] ; $ argsSource = $ args ; foreach ( $ args [ 0 ] as $ v ) { if ( null === $ v && true === $ optional ) { continue ; } $ argsSource [ 0 ] = $ v ; $ multi [ ] = $ argsSource ; } if ( ! $ multi ) { self :: countPhpUnit ( ) ; return true ; } $ method = substr ( $ method , 5 ) ; return [ $ method , $ multi ] ; } 
protected static function validateRule ( string $ method , array $ multi ) : bool { try { $ fn = __NAMESPACE__ . '\\Helper\\validate_' . un_camelize ( $ method ) ; foreach ( $ multi as $ m ) { if ( ! function_exists ( $ fn ) ) { class_exists ( $ fn ) ; } if ( false === $ fn ( ... $ m ) ) { return false ; } self :: countPhpUnit ( ) ; } } catch ( FunctionNotFoundException $ th ) { $ e = sprintf ( 'Method `%s` is not exits.' , $ method ) ; throw new BadMethodCallException ( $ e ) ; } return true ; } 
public function register ( ) : void { $ this -> databases ( ) ; $ this -> database ( ) ; $ this -> work ( ) ; $ this -> databaseLazyload ( ) ; } 
public function handle ( IApp $ app ) : void { $ i18nDefault = $ app [ 'option' ] [ 'i18n\\default' ] ; if ( $ app -> isCachedI18n ( $ i18nDefault ) ) { $ data = ( array ) include $ app -> i18nCachedPath ( $ i18nDefault ) ; } else { $ load = ( new Load ( [ $ app -> i18nPath ( ) ] ) ) -> setI18n ( $ i18nDefault ) -> addDir ( $ this -> getExtend ( $ app ) ) ; $ data = $ load -> loadData ( ) ; } $ app -> instance ( 'i18n' , $ i18n = new I18n ( $ i18nDefault ) ) ; $ i18n -> addtext ( $ i18nDefault , $ data ) ; } 
public function getExtend ( IApp $ app ) : array { $ extend = $ app [ 'option' ] -> get ( '_composer.i18ns' , [ ] ) ; $ path = $ app -> path ( ) ; $ extend = array_map ( function ( string $ item ) use ( $ path ) { if ( ! is_file ( $ item ) ) { $ item = $ path . '/' . $ item ; } if ( ! is_dir ( $ item ) ) { throw new Exception ( sprintf ( 'I18n dir %s is not exist.' , $ item ) ) ; } return $ item ; } , $ extend ) ; return $ extend ; } 
public function setOption ( string $ name , $ value ) : ISeccode { $ this -> option [ $ name ] = $ value ; return $ this ; } 
public function display ( $ code = null , ? string $ outPath = null , bool $ autoCode = true , string $ autoType = self :: ALPHA_UPPERCASE ) : void { if ( is_int ( $ code ) && $ autoCode ) { $ this -> autoCode ( $ code , $ autoType ) ; } else { $ code && $ this -> code ( $ code ) ; } $ resImage = imagecreatefromstring ( $ this -> makeBackground ( ) ) ; if ( $ this -> option [ 'adulterate' ] ) { $ this -> makeAdulterate ( $ resImage ) ; } $ this -> makeTtfFont ( $ resImage ) ; if ( $ outPath ) { create_directory ( dirname ( $ outPath ) ) ; imagepng ( $ resImage , $ outPath , 9 ) ; } else { 
protected function normalizeWidth ( ) : int { if ( $ this -> option [ 'width' ] < static :: MIN_WIDTH ) { return static :: MIN_WIDTH ; } if ( $ this -> option [ 'width' ] > static :: MAX_WIDTH ) { return static :: MAX_WIDTH ; } return $ this -> option [ 'width' ] ; } 
protected function normalizeHeight ( ) : int { if ( $ this -> option [ 'height' ] < static :: MIN_HEIGHT ) { return static :: MIN_HEIGHT ; } if ( $ this -> option [ 'height' ] > static :: MAX_HEIGHT ) { return static :: MAX_HEIGHT ; } return $ this -> option [ 'height' ] ; } 
protected function makeBackground ( ) : string { $ resImage = imagecreatetruecolor ( $ this -> normalizeWidth ( ) , $ this -> normalizeHeight ( ) ) ; $ resColor = imagecolorallocate ( $ resImage , 255 , 255 , 255 ) ; if ( false === $ this -> makeBackgroundWithImage ( $ resImage ) ) { $ this -> makeBackgroundDefault ( $ resImage ) ; } ob_start ( ) ; imagepng ( $ resImage ) ; imagedestroy ( $ resImage ) ; $ background = ob_get_contents ( ) ; ob_end_clean ( ) ; return $ background ; } 
protected function makeAdulterate ( & $ resImage ) : void { $ width = $ this -> normalizeWidth ( ) ; $ height = $ this -> normalizeHeight ( ) ; $ lineNum = $ height / 10 ; for ( $ i = 0 ; $ i <= $ lineNum ; $ i ++ ) { $ resColor = $ this -> option [ 'color' ] ? imagecolorallocate ( $ resImage , $ this -> mtRand ( 0 , 255 ) , $ this -> mtRand ( 0 , 255 ) , $ this -> mtRand ( 0 , 255 ) ) : imagecolorallocate ( $ resImage , $ this -> fontColor [ 0 ] , $ this -> fontColor [ 1 ] , $ this -> fontColor [ 2 ] ) ; $ x = $ this -> mtRand ( 0 , $ width ) ; $ y = $ this -> mtRand ( 0 , $ height ) ; if ( mt_rand ( 0 , 1 ) ) { imagearc ( $ resImage , $ x , $ y , $ this -> mtRand ( 0 , $ width ) , $ this -> mtRand ( 0 , $ height ) , $ this -> mtRand ( 0 , 360 ) , $ this -> mtRand ( 0 , 360 ) , $ resColor ) ; } else { imageline ( $ resImage , $ x , $ y , 0 + $ this -> mtRand ( 0 , 0 ) , 0 + $ this -> mtRand ( 0 , $ this -> mtRand ( $ height , $ width ) ) , $ resColor ) ; } } } 
protected function makeTtfFont ( & $ resImage ) : void { if ( ! function_exists ( 'imagettftext' ) ) { 
protected function getFontOption ( ) : array { $ code = $ this -> getCode ( ) ; $ ttf = $ this -> getTtf ( ) ; if ( $ this -> isChinese ( $ code ) ) { $ code = str_split ( $ code , 3 ) ; $ codeLength = count ( $ code ) ; } else { $ codeLength = strlen ( $ code ) ; } $ font = [ ] ; $ widthTotal = 0 ; $ width = $ this -> normalizeWidth ( ) ; for ( $ i = 0 ; $ i < $ codeLength ; $ i ++ ) { if ( ! isset ( $ font [ $ i ] ) ) { $ font [ $ i ] = [ ] ; } $ font [ $ i ] [ 'font' ] = $ ttf [ array_rand ( $ ttf ) ] ; $ font [ $ i ] [ 'tilt' ] = $ this -> option [ 'tilt' ] ? $ this -> mtRand ( - 30 , 30 ) : 0 ; $ font [ $ i ] [ 'size' ] = $ width / 6 ; $ this -> option [ 'size' ] && $ font [ $ i ] [ 'size' ] = $ this -> mtRand ( $ font [ $ i ] [ 'size' ] - $ width / 40 , $ font [ $ i ] [ 'size' ] + $ width / 20 ) ; $ resBox = imagettfbbox ( $ font [ $ i ] [ 'size' ] , 0 , $ font [ $ i ] [ 'font' ] , $ code [ $ i ] ) ; $ font [ $ i ] [ 'zheight' ] = max ( $ resBox [ 1 ] , $ resBox [ 3 ] ) - min ( $ resBox [ 5 ] , $ resBox [ 7 ] ) ; $ resBox = imagettfbbox ( $ font [ $ i ] [ 'size' ] , $ font [ $ i ] [ 'tilt' ] , $ font [ $ i ] [ 'font' ] , $ code [ $ i ] ) ; $ font [ $ i ] [ 'height' ] = max ( $ resBox [ 1 ] , $ resBox [ 3 ] ) - min ( $ resBox [ 5 ] , $ resBox [ 7 ] ) ; $ font [ $ i ] [ 'hd' ] = $ font [ $ i ] [ 'height' ] - $ font [ $ i ] [ 'zheight' ] ; $ font [ $ i ] [ 'width' ] = ( max ( $ resBox [ 2 ] , $ resBox [ 4 ] ) - min ( $ resBox [ 0 ] , $ resBox [ 6 ] ) ) + $ this -> mtRand ( 0 , ( int ) ( $ width / 8 ) ) ; $ font [ $ i ] [ 'width' ] = $ font [ $ i ] [ 'width' ] > $ width / $ codeLength ? $ width / $ codeLength : $ font [ $ i ] [ 'width' ] ; $ widthTotal += $ font [ $ i ] [ 'width' ] ; } return [ $ font , $ code , $ widthTotal , ] ; } 
protected function makeBackgroundWithImage ( & $ resImage ) : bool { $ findBackground = false ; $ backgroundPath = $ this -> option [ 'background_path' ] ; $ width = $ this -> normalizeWidth ( ) ; $ height = $ this -> normalizeHeight ( ) ; if ( $ this -> option [ 'background' ] && function_exists ( 'imagecreatefromjpeg' ) && function_exists ( 'imagecolorat' ) && function_exists ( 'imagecopymerge' ) && function_exists ( 'imagesetpixel' ) && function_exists ( 'imageSX' ) && function_exists ( 'imageSY' ) ) { if ( ! is_dir ( $ backgroundPath ) ) { $ e = sprintf ( 'Background path %s is not exists.' , $ backgroundPath ) ; throw new InvalidArgumentException ( $ e ) ; } $ background = glob ( $ backgroundPath . '/*.*' ) ; if ( $ background ) { $ resBackground = imagecreatefromjpeg ( $ background [ array_rand ( $ background ) ] ) ; $ resColorIndex = imagecolorat ( $ resBackground , 0 , 0 ) ; $ color = imagecolorsforindex ( $ resBackground , $ resColorIndex ) ; $ resColorIndex = imagecolorat ( $ resBackground , 1 , 0 ) ; imagesetpixel ( $ resBackground , 0 , 0 , $ resColorIndex ) ; $ color [ 0 ] = ( int ) ( $ color [ 'red' ] ) ; $ color [ 1 ] = ( int ) ( $ color [ 'green' ] ) ; $ color [ 2 ] = ( int ) ( $ color [ 'blue' ] ) ; imagecopymerge ( $ resImage , $ resBackground , 0 , 0 , $ this -> mtRand ( 0 , 200 - $ width ) , $ this -> mtRand ( 0 , 80 - $ height ) , imagesx ( $ resBackground ) , imagesy ( $ resBackground ) , 100 ) ; imagedestroy ( $ resBackground ) ; $ findBackground = true ; $ this -> fontColor = $ color ; } } return $ findBackground ; } 
protected function makeBackgroundDefault ( & $ resImage ) : void { $ width = $ this -> normalizeWidth ( ) ; $ height = $ this -> normalizeHeight ( ) ; for ( $ i = 0 ; $ i < 3 ; $ i ++ ) { $ start [ $ i ] = $ this -> mtRand ( 200 , 255 ) ; $ end [ $ i ] = $ this -> mtRand ( 100 , 150 ) ; $ step [ $ i ] = ( $ end [ $ i ] - $ start [ $ i ] ) / $ width ; $ color [ $ i ] = $ start [ $ i ] ; } for ( $ i = 0 ; $ i < $ width ; $ i ++ ) { $ resColor = imagecolorallocate ( $ resImage , ( int ) ( $ color [ 0 ] ) , ( int ) ( $ color [ 1 ] ) , ( int ) ( $ color [ 2 ] ) ) ; imageline ( $ resImage , $ i , 0 , $ i - ( $ this -> option [ 'tilt' ] ? $ this -> mtRand ( - 30 , 30 ) : 0 ) , $ height , $ resColor ) ; $ color [ 0 ] += $ step [ 0 ] ; $ color [ 1 ] += $ step [ 1 ] ; $ color [ 2 ] += $ step [ 2 ] ; } $ color [ 0 ] -= 20 ; $ color [ 1 ] -= 20 ; $ color [ 2 ] -= 20 ; $ color [ 0 ] = ( int ) ( $ color [ 0 ] ) ; $ color [ 1 ] = ( int ) ( $ color [ 1 ] ) ; $ color [ 2 ] = ( int ) ( $ color [ 2 ] ) ; $ this -> fontColor = $ color ; unset ( $ color ) ; } 
protected function getTtf ( ) : array { $ fontPath = $ this -> isChinese ( $ this -> getCode ( ) ) ? $ this -> option [ 'chinese_font_path' ] : $ this -> option [ 'font_path' ] ; if ( ! is_dir ( $ fontPath ) ) { $ e = sprintf ( 'Font path %s is not exits.' , $ fontPath ) ; throw new InvalidArgumentException ( $ e ) ; } $ ttf = glob ( $ fontPath . '/*.*' ) ; if ( empty ( $ ttf ) ) { throw new InvalidArgumentException ( 'Font files not found.' ) ; } return $ ttf ; } 
protected function autoCode ( int $ size , string $ autoType = self :: ALPHA_UPPERCASE ) : void { if ( $ size < 1 ) { $ e = sprintf ( 'Code must be greater than %d.' , 0 ) ; throw new InvalidArgumentException ( $ e ) ; } if ( ! in_array ( $ autoType , $ this -> getAllowedAutoType ( ) , true ) ) { $ e = sprintf ( 'Code type must be these %s.' , implode ( ',' , $ this -> getAllowedAutoType ( ) ) ) ; throw new InvalidArgumentException ( $ e ) ; } $ randMethod = 'Leevel\\Support\\Str\\rand_' . $ autoType ; $ this -> code ( fn ( $ randMethod , $ size ) ) ; } 
protected function mtRand ( $ numFirst , $ numSecond ) : int { $ numFirst = ( int ) ( $ numFirst ) ; $ numSecond = ( int ) ( $ numSecond ) ; if ( $ numFirst > $ numSecond ) { list ( $ numSecond , $ numFirst ) = [ $ numFirst , $ numSecond ] ; } return ( int ) ( mt_rand ( $ numFirst , $ numSecond ) ) ; } 
protected function makeConnectHtml ( array $ options = [ ] ) : Html { $ options = $ this -> normalizeConnectOption ( 'html' , $ options ) ; $ options = array_merge ( $ options , $ this -> viewOptionCommon ( ) ) ; $ container = $ this -> container ; $ html = new Html ( $ options ) ; $ html -> setParseResolver ( function ( ) use ( $ container ) { return $ container [ 'view.parser' ] ; } ) ; return $ html ; } 
protected function makeConnectPhpui ( array $ options = [ ] ) : Phpui { $ options = $ this -> normalizeConnectOption ( 'phpui' , $ options ) ; $ options = array_merge ( $ options , $ this -> viewOptionCommon ( ) ) ; return new Phpui ( $ options ) ; } 
public function fetchArgs ( int $ fetchStyle , $ fetchArgument = null , array $ ctorArgs = [ ] ) : self { $ this -> queryParams [ 'fetch_args' ] [ 'fetch_style' ] = $ fetchStyle ; if ( $ fetchArgument ) { $ this -> queryParams [ 'fetch_args' ] [ 'fetch_argument' ] = $ fetchArgument ; } $ this -> queryParams [ 'fetch_args' ] [ 'ctor_args' ] = $ ctorArgs ; return $ this ; } 
public function asClass ( string $ className , array $ args = [ ] ) : self { $ this -> queryParams [ 'as_class' ] = $ className ; $ this -> queryParams [ 'class_args' ] = $ args ; $ this -> queryParams [ 'as_default' ] = false ; return $ this ; } 
public function select ( $ data = null , array $ bind = [ ] , bool $ flag = false ) { 
public function insert ( $ data , array $ bind = [ ] , bool $ replace = false , bool $ flag = false ) { return $ this -> safeSql ( $ flag ) -> runNativeSql ( ... $ this -> condition -> insert ( $ data , $ bind , $ replace ) ) ; } 
public function update ( $ data , array $ bind = [ ] , bool $ flag = false ) { return $ this -> safeSql ( $ flag ) -> runNativeSql ( ... $ this -> condition -> update ( $ data , $ bind ) ) ; } 
public function updateColumn ( string $ column , $ value , array $ bind = [ ] , bool $ flag = false ) { return $ this -> update ( [ $ column => $ value ] , $ bind , $ flag ) ; } 
public function updateIncrease ( string $ column , int $ step = 1 , array $ bind = [ ] , bool $ flag = false ) { return $ this -> updateColumn ( $ column , '{[' . $ column . ']+' . $ step . '}' , $ bind , $ flag ) ; } 
public function delete ( ? string $ data = null , array $ bind = [ ] , bool $ flag = false ) { return $ this -> safeSql ( $ flag ) -> runNativeSql ( ... $ this -> condition -> delete ( $ data , $ bind ) ) ; } 
public function truncate ( bool $ flag = false ) { return $ this -> safeSql ( $ flag ) -> runNativeSql ( ... $ this -> condition -> truncate ( ) ) ; } 
public function findOne ( bool $ flag = false ) { $ this -> condition -> one ( ) ; return $ this -> safeSql ( $ flag ) -> query ( ) ; } 
public function findAll ( bool $ flag = false ) { $ this -> condition -> all ( ) ; return $ this -> safeSql ( $ flag ) -> query ( ) ; } 
public function find ( ? int $ num = null , bool $ flag = false ) { if ( null !== $ num ) { $ this -> condition -> top ( $ num ) ; } return $ this -> safeSql ( $ flag ) -> query ( ) ; } 
public function value ( string $ field , bool $ flag = false ) { $ this -> condition -> setColumns ( $ field ) -> one ( ) ; $ result = ( array ) $ this -> safeSql ( $ flag ) -> asDefault ( ) -> query ( ) ; if ( true === $ this -> onlyMakeSql ) { return $ result ; } return $ result [ $ field ] ?? null ; } 
public function pull ( string $ field , bool $ flag = false ) { return $ this -> value ( $ field , $ flag ) ; } 
public function list ( $ fieldValue , ? string $ fieldKey = null , bool $ flag = false ) : array { 
public function chunk ( int $ count , Closure $ chunk ) : void { $ result = $ this -> forPage ( $ page = 1 , $ count ) -> findAll ( ) ; while ( count ( $ result ) > 0 ) { if ( false === $ chunk ( $ result , $ page ) ) { break ; } $ page ++ ; $ result = $ this -> forPage ( $ page , $ count ) -> findAll ( ) ; } } 
public function each ( int $ count , Closure $ each ) : void { $ this -> chunk ( $ count , function ( $ result , $ page ) use ( $ each ) { foreach ( $ result as $ key => $ value ) { if ( false === $ each ( $ value , $ key , $ page ) ) { return false ; } } } ) ; } 
public function findCount ( string $ field = '*' , string $ alias = 'row_count' , bool $ flag = false ) { $ result = $ this -> findAggregateResult ( 'count' , $ field , $ alias , $ flag ) ; if ( ! is_array ( $ result ) ) { $ result = ( int ) $ result ; } return $ result ; } 
public function findSum ( string $ field , string $ alias = 'sum_value' , bool $ flag = false ) { return $ this -> findAggregateResult ( 'sum' , $ field , $ alias , $ flag ) ; } 
public function page ( int $ currentPage , int $ perPage = 10 , bool $ flag = false , bool $ withTotal = true , string $ column = '*' ) : array { $ from = ( $ currentPage - 1 ) * $ perPage ; return [ [ 'per_page' => $ perPage , 'current_page' => $ currentPage , 'total_record' => $ withTotal ? $ this -> pageCount ( $ column ) : null , 'from' => $ from , ] , $ this -> limit ( $ from , $ perPage ) -> findAll ( $ flag ) , self :: PAGE => true , ] ; } 
public function pageHtml ( int $ currentPage , int $ perPage = 10 , bool $ flag = false , string $ column = '*' , array $ option = [ ] ) : array { $ page = new Page ( $ currentPage , $ perPage , $ this -> pageCount ( $ column ) , $ option ) ; return [ $ page , $ this -> limit ( $ page -> getFromRecord ( ) , $ perPage ) -> findAll ( $ flag ) , self :: PAGE => true , ] ; } 
public function pageMacro ( int $ currentPage , int $ perPage = 10 , bool $ flag = false , array $ option = [ ] ) : array { $ page = new Page ( $ currentPage , $ perPage , IPage :: MACRO , $ option ) ; return [ $ page , $ this -> limit ( $ page -> getFromRecord ( ) , $ perPage ) -> findAll ( $ flag ) , self :: PAGE => true , ] ; } 
public function pagePrevNext ( int $ currentPage , int $ perPage = 10 , bool $ flag = false , array $ option = [ ] ) : array { $ page = new Page ( $ currentPage , $ perPage , null , $ option ) ; return [ $ page , $ this -> limit ( $ page -> getFromRecord ( ) , $ perPage ) -> findAll ( $ flag ) , self :: PAGE => true , ] ; } 
public function pageCount ( string $ cols = '*' ) : int { $ this -> backupPageArgs ( ) ; $ count = $ this -> findCount ( $ cols ) ; $ this -> restorePageArgs ( ) ; return $ count ; } 
protected function safeSql ( bool $ flag = true ) : self { if ( true === $ this -> onlyMakeSql ) { return $ this ; } $ this -> onlyMakeSql = $ flag ; return $ this ; } 
protected function query ( ) { $ sql = $ this -> makeSql ( ) ; $ args = [ $ sql , $ this -> condition -> getBindParams ( ) , $ this -> queryParams [ 'master' ] , $ this -> queryParams [ 'fetch_args' ] [ 'fetch_style' ] , $ this -> queryParams [ 'fetch_args' ] [ 'fetch_argument' ] , $ this -> queryParams [ 'fetch_args' ] [ 'ctor_args' ] , ] ; 
protected function queryDefault ( array $ data ) { if ( ! $ this -> condition -> getOption ( ) [ 'limitQuery' ] ) { return reset ( $ data ) ? : [ ] ; } return $ this -> queryParams [ 'as_collection' ] ? new Collection ( $ data ) : $ data ; } 
protected function queryClass ( array $ data ) { $ className = $ this -> queryParams [ 'as_class' ] ; if ( ! class_exists ( $ className ) ) { $ e = sprintf ( 'The class of query `%s` was not found.' , $ className ) ; throw new InvalidArgumentException ( $ e ) ; } foreach ( $ data as $ key => $ tmp ) { $ data [ $ key ] = new $ className ( ( array ) $ tmp , ... $ this -> queryParams [ 'class_args' ] ) ; } if ( ! $ this -> condition -> getOption ( ) [ 'limitQuery' ] ) { $ data = reset ( $ data ) ? : new $ className ( [ ] , ... $ this -> queryParams [ 'class_args' ] ) ; } elseif ( $ this -> queryParams [ 'as_collection' ] ) { $ data = new Collection ( $ data , [ $ className ] ) ; } return $ data ; } 
protected function findAggregateResult ( string $ method , string $ field , string $ alias , bool $ flag = false ) { $ this -> condition -> { $ method } ( $ field , $ alias ) ; $ result = $ this -> safeSql ( $ flag ) -> asDefault ( ) -> query ( ) ; if ( true === $ this -> onlyMakeSql ) { return $ result ; } return is_object ( $ result ) ? $ result -> { $ alias } : $ result [ $ alias ] ; } 
protected function runNativeSql ( string $ nativeType , string $ data , array $ bindParams = [ ] ) { $ sqlType = $ this -> connect -> normalizeSqlType ( $ data ) ; if ( 'procedure' === $ sqlType ) { $ sqlType = 'select' ; } if ( $ sqlType !== $ nativeType ) { $ e = sprintf ( 'The SQL type `%s` must be consistent with the provided `%s`.' , $ sqlType , $ nativeType ) ; throw new InvalidArgumentException ( $ e ) ; } $ args = [ $ data , $ bindParams ] ; 
protected function backupPageArgs ( ) : void { $ this -> backupPage = [ ] ; $ this -> backupPage [ 'query_params' ] = $ this -> queryParams ; $ this -> backupPage [ 'aggregate' ] = $ this -> condition -> getOption ( ) [ 'aggregate' ] ; $ this -> backupPage [ 'columns' ] = $ this -> condition -> getOption ( ) [ 'columns' ] ; } 
protected function restorePageArgs ( ) : void { $ this -> queryParams = $ this -> backupPage [ 'query_params' ] ; $ this -> condition -> setOption ( 'aggregate' , $ this -> backupPage [ 'aggregate' ] ) ; $ this -> condition -> setOption ( 'columns' , $ this -> backupPage [ 'columns' ] ) ; } 
protected function unCamelize ( string $ value , string $ separator = '_' ) : string { return strtolower ( preg_replace ( '/([a-z])([A-Z])/' , '$1' . $ separator . '$2' , $ value ) ) ; } 
public function read ( $ sessionid ) : string { return serialize ( $ this -> cache -> get ( $ this -> getSessionName ( $ sessionid ) , [ ] ) ? : [ ] ) ; } 
public function write ( $ sessionid , $ sessiondata ) : bool { $ this -> cache -> set ( $ this -> getSessionName ( $ sessionid ) , unserialize ( $ sessiondata ) ) ; return true ; } 
public function destroy ( $ sessionid ) : bool { $ this -> cache -> delete ( $ this -> getSessionName ( $ sessionid ) ) ; return true ; } 
public function isValid ( ) : bool { return UPLOAD_ERR_OK === $ this -> error && ( $ this -> test ? true : is_uploaded_file ( $ this -> getPathname ( ) ) ) ; } 
public function move ( string $ directory , ? string $ name = null ) : File { if ( $ this -> isValid ( ) ) { if ( $ this -> test ) { return parent :: move ( $ directory , $ name ) ; } $ target = $ this -> getTargetFile ( $ directory , $ name ) ; $ this -> moveToTarget ( $ this -> getPathname ( ) , $ target , true ) ; return new File ( $ target ) ; } throw new FileException ( $ this -> getErrorMessage ( ) ) ; } 
public function getErrorMessage ( ) : string { $ errorCode = $ this -> error ; $ maxFilesize = UPLOAD_ERR_INI_SIZE === $ errorCode ? self :: getMaxFilesize ( ) / 1024 : 0 ; $ message = isset ( self :: $ errors [ $ errorCode ] ) ? self :: $ errors [ $ errorCode ] : 'The file %s was not uploaded due to an unknown error.' ; $ message = sprintf ( $ message , $ this -> getOriginalName ( ) , $ maxFilesize ) ; return $ message ; } 
public function withInput ( ? array $ input = null ) : IResponse { if ( $ this -> checkFlowControl ( ) ) { return $ this ; } $ input = $ input ? : $ this -> request -> input ( ) ; $ inputs = array_merge ( $ this -> session -> getFlash ( 'inputs' , [ ] ) , $ input ) ; $ this -> session -> flash ( 'inputs' , $ inputs ) ; return $ this ; } 
public function onlyInput ( ... $ args ) : IResponse { if ( ! $ args ) { throw new InvalidArgumentException ( 'Method onlyInput need an args.' ) ; } return $ this -> withInput ( $ this -> request -> only ( $ args ) ) ; } 
public function exceptInput ( ... $ args ) : IResponse { if ( ! $ args ) { throw new InvalidArgumentException ( 'Method exceptInput need an args.' ) ; } return $ this -> withInput ( $ this -> request -> except ( $ args ) ) ; } 
public function withErrors ( $ value , string $ key = 'default' ) : IResponse { if ( $ this -> checkFlowControl ( ) ) { return $ this ; } $ errors = $ this -> session -> getFlash ( 'errors' , [ ] ) ; $ errors [ $ key ] = $ value ; $ this -> session -> flash ( 'errors' , $ errors ) ; return $ this ; } 
public function set ( string $ name , $ value = null , array $ option = [ ] ) : void { $ option = $ this -> normalizeOptions ( $ option ) ; if ( is_array ( $ value ) ) { $ value = json_encode ( $ value ) ; } elseif ( ! is_string ( $ value ) && null !== $ value ) { throw new Exception ( 'Cookie value must be string,array or null.' ) ; } $ option [ 'expire' ] = ( int ) ( $ option [ 'expire' ] ) ; if ( $ option [ 'expire' ] < 0 ) { throw new Exception ( 'Cookie expire date must greater than or equal 0.' ) ; } if ( $ option [ 'expire' ] > 0 ) { $ option [ 'expire' ] = time ( ) + $ option [ 'expire' ] ; } 
public function put ( $ keys , $ value = null , array $ option = [ ] ) : void { if ( ! is_array ( $ keys ) ) { $ keys = [ $ keys => $ value , ] ; } foreach ( $ keys as $ key => $ value ) { $ this -> set ( $ key , $ value , $ option ) ; } } 
public function merge ( string $ key , array $ value , array $ option = [ ] ) : void { $ this -> set ( $ key , array_merge ( $ this -> get ( $ key , [ ] , $ option ) , $ value ) , $ option ) ; } 
public function pop ( string $ key , array $ value , array $ option = [ ] ) : void { $ this -> set ( $ key , array_diff ( $ this -> get ( $ key , [ ] , $ option ) , $ value ) , $ option ) ; } 
public function arr ( string $ key , $ keys , $ value = null , array $ option = [ ] ) : void { $ arr = $ this -> get ( $ key , [ ] , $ option ) ; if ( is_string ( $ keys ) ) { $ arr [ $ keys ] = $ value ; } elseif ( is_array ( $ keys ) ) { $ arr = array_merge ( $ arr , $ keys ) ; } $ this -> set ( $ key , $ arr , $ option ) ; } 
public function arrDelete ( string $ key , $ keys , array $ option = [ ] ) : void { $ arr = $ this -> get ( $ key , [ ] , $ option ) ; if ( ! is_array ( $ keys ) ) { $ keys = [ $ keys , ] ; } foreach ( $ keys as $ tmp ) { if ( isset ( $ arr [ $ tmp ] ) ) { unset ( $ arr [ $ tmp ] ) ; } } $ this -> set ( $ key , $ arr , $ option ) ; } 
public function get ( string $ name , $ defaults = null , array $ option = [ ] ) { $ option = $ this -> normalizeOptions ( $ option ) ; if ( isset ( $ this -> cookies [ $ name ] ) ) { if ( $ this -> isJson ( $ this -> cookies [ $ name ] [ 1 ] ) ) { return json_decode ( $ this -> cookies [ $ name ] [ 1 ] , true ) ; } return $ this -> cookies [ $ name ] [ 1 ] ; } return $ defaults ; } 
public function delete ( string $ name , array $ option = [ ] ) : void { $ this -> set ( $ name , null , $ option ) ; } 
public function clear ( array $ option = [ ] ) : void { $ option = $ this -> normalizeOptions ( $ option ) ; foreach ( $ this -> cookies as $ key => $ val ) { $ this -> delete ( $ key , $ option ) ; } } 
public static function format ( array $ cookie ) : string { if ( 7 !== count ( $ cookie ) ) { throw new Exception ( 'Invalid cookie data.' ) ; } $ str = $ cookie [ 0 ] . '=' ; if ( '' === ( string ) $ cookie [ 1 ] ) { $ str .= 'deleted; expires=' . gmdate ( 'D, d-M-Y H:i:s T' , time ( ) - 31536001 ) . '; Max-Age=0' ; } else { $ str .= $ cookie [ 1 ] ; if ( 0 !== $ cookie [ 2 ] ) { $ str .= '; expires=' . gmdate ( 'D, d-M-Y H:i:s T' , $ cookie [ 2 ] ) . '; Max-Age=' . ( $ cookie [ 2 ] - time ( ) ? : 0 ) ; } } if ( $ cookie [ 3 ] ) { $ str .= '; path=' . $ cookie [ 3 ] ; } if ( $ cookie [ 4 ] ) { $ str .= '; domain=' . $ cookie [ 4 ] ; } if ( true === $ cookie [ 5 ] ) { $ str .= '; secure' ; } if ( true === $ cookie [ 6 ] ) { $ str .= '; httponly' ; } return $ str ; } 
protected function makeConnectMysql ( array $ option = [ ] ) : Mysql { return new Mysql ( $ this -> normalizeConnectOption ( 'mysql' , $ option ) , $ this -> container -> make ( IDispatch :: class ) ) ; } 
protected function normalizeConnectOption ( string $ connect , array $ extendOption = [ ] ) : array { return $ this -> parseDatabaseOption ( parent :: normalizeConnectOption ( $ connect , $ extendOption ) ) ; } 
protected function parseDatabaseOption ( array $ option ) : array { $ temp = $ option ; $ type = [ 'distributed' , 'separate' , 'driver' , 'master' , 'slave' ] ; foreach ( array_keys ( $ option ) as $ t ) { if ( in_array ( $ t , $ type , true ) ) { if ( isset ( $ temp [ $ t ] ) ) { unset ( $ temp [ $ t ] ) ; } } elseif ( isset ( $ option [ $ t ] ) ) { unset ( $ option [ $ t ] ) ; } } foreach ( [ 'master' , 'slave' ] as $ t ) { if ( ! is_array ( $ option [ $ t ] ) ) { $ e = sprintf ( 'Database option `%s` must be an array.' , $ t ) ; throw new InvalidArgumentException ( $ e ) ; } } $ option [ 'master' ] = array_merge ( $ option [ 'master' ] , $ temp ) ; if ( ! $ option [ 'distributed' ] ) { $ option [ 'slave' ] = [ ] ; } elseif ( $ option [ 'slave' ] ) { if ( count ( $ option [ 'slave' ] ) === count ( $ option [ 'slave' ] , COUNT_RECURSIVE ) ) { $ option [ 'slave' ] = [ $ option [ 'slave' ] ] ; } foreach ( $ option [ 'slave' ] as & $ slave ) { $ slave = array_merge ( $ slave , $ temp ) ; } } return $ option ; } 
protected function getPrevRender ( ) : string { if ( $ this -> page -> canPrevRender ( ) ) { return sprintf ( '<li class="%s"><a aria-label="Previous" href="%s">' . '<span aria-hidden="true">%s</span></a></li>' , 'justify' === $ this -> option [ 'align' ] ? 'previous' : '' , $ this -> replace ( $ this -> page -> parsePrevRenderPrev ( ) ) , __ ( '上一页') ) ; } return sprintf ( '<li class="disabled%s"><a aria-label="Previous">' . '<span aria-hidden="true">%s</span></a></li>' , 'justify' === $ this -> option [ 'align' ] ? ' previous' : '' , __ ( '上一页') ) ; } 
protected function getNextRender ( ) : string { if ( $ this -> page -> canNextRender ( ) ) { return sprintf ( '<li class="%s"><a aria-label="Next" href="%s">' . '<span aria-hidden="true">%s</span></a></li>' , 'justify' === $ this -> option [ 'align' ] ? 'next' : '' , $ this -> replace ( $ this -> page -> getCurrentPage ( ) + 1 ) , __ ( '下一页') ) ; } return sprintf ( '<li class="disabled%s"><a aria-label="Next">' . '<span aria-hidden="true">%s</span></a></li>' , 'justify' === $ this -> option [ 'align' ] ? ' next' : '' , __ ( '下一页') ) ; } 
public function next ( ) : void { $ next = next ( $ this -> elements ) ; $ this -> valid = false !== $ next ; } 
public function offsetSet ( $ index , $ newval ) : void { $ this -> checkType ( $ newval ) ; $ this -> elements [ $ index ] = $ newval ; } 
public function offsetUnset ( $ index ) : void { if ( isset ( $ this -> elements [ $ index ] ) ) { unset ( $ this -> elements [ $ index ] ) ; } } 
public function toArray ( ) : array { $ args = func_get_args ( ) ; return array_map ( function ( $ value ) use ( $ args ) { return $ value instanceof IArray ? $ value -> toArray ( ... $ args ) : $ value ; } , $ this -> elements ) ; } 
public function jsonSerialize ( ) : array { return array_map ( function ( $ value ) { if ( $ value instanceof JsonSerializable ) { return $ value -> jsonSerialize ( ) ; } if ( $ value instanceof IJson ) { return json_decode ( $ value -> toJson ( ) , true ) ; } if ( $ value instanceof IArray ) { return $ value -> toArray ( ) ; } return $ value ; } , $ this -> elements ) ; } 
public function each ( Closure $ callback ) : void { foreach ( $ this -> elements as $ key => $ item ) { if ( false === $ callback ( $ item , $ key ) ) { break ; } } } 
protected function getArrayElements ( $ elements ) : array { if ( is_array ( $ elements ) ) { return $ elements ; } if ( $ elements instanceof self ) { return $ elements -> all ( ) ; } if ( $ elements instanceof IArray ) { return $ elements -> toArray ( ) ; } if ( $ elements instanceof IJson ) { return json_decode ( $ elements -> toJson ( ) , true ) ; } if ( $ elements instanceof JsonSerializable ) { return $ elements -> jsonSerialize ( ) ; } if ( $ elements instanceof stdClass ) { return json_decode ( json_encode ( $ elements ) , true ) ; } return [ $ elements ] ; } 
public function view ( string $ file , array $ vars = [ ] , ? string $ ext = null , int $ status = 200 , array $ headers = [ ] ) : Response { return $ this -> make ( $ this -> view -> display ( $ file , $ vars , $ ext ) , $ status , $ headers ) ; } 
public function viewSuccess ( string $ message , string $ url = '' , int $ time = 1 , int $ status = 200 , array $ headers = [ ] ) : Response { $ vars = [ 'message' => $ message , 'url' => $ url , 'time' => $ time , ] ; return $ this -> view ( $ this -> viewSuccessTemplate , $ vars , null , $ status , $ headers ) ; } 
public function viewFail ( string $ message , string $ url = '' , int $ time = 3 , int $ status = 404 , array $ headers = [ ] ) : Response { $ vars = [ 'message' => $ message , 'url' => $ url , 'time' => $ time , ] ; return $ this -> view ( $ this -> viewFailTemplate , $ vars , null , $ status , $ headers ) ; } 
public function jsonp ( string $ callback , $ data = null , int $ status = 200 , array $ headers = [ ] , bool $ json = false ) : JsonResponse { return $ this -> json ( $ data , $ status , $ headers , $ json ) -> setCallback ( $ callback ) ; } 
public function download ( $ file , string $ name = null , int $ status = 200 , array $ headers = [ ] , bool $ autoEtag = false , bool $ autoLastModified = true ) : FileResponse { $ response = new FileResponse ( $ file , $ status , $ headers , ResponseHeaderBag :: DISPOSITION_ATTACHMENT , $ autoEtag , $ autoLastModified ) ; if ( null !== $ name ) { return $ response -> setContentDisposition ( ResponseHeaderBag :: DISPOSITION_ATTACHMENT , $ name ) ; } return $ response ; } 
public function file ( $ file , int $ status = 200 , array $ headers = [ ] , bool $ autoEtag = false , bool $ autoLastModified = true ) : FileResponse { return new FileResponse ( $ file , $ status , $ headers , ResponseHeaderBag :: DISPOSITION_INLINE , $ autoEtag , $ autoLastModified ) ; } 
public function redirect ( string $ url , array $ params = [ ] , string $ subdomain = 'www' , $ suffix = null , int $ status = 302 , array $ headers = [ ] ) : RedirectResponse { return $ this -> redirector -> url ( $ url , $ params , $ subdomain , $ suffix , $ status , $ headers ) ; } 
public function redirectRaw ( string $ url , int $ status = 302 , array $ headers = [ ] ) : RedirectResponse { return $ this -> redirector -> raw ( $ url , $ status , $ headers ) ; } 
public function apiOk ( $ content = '' , ? string $ text = null ) : ApiResponse { return $ this -> createApiResponse ( ) -> ok ( $ content , $ text ) ; } 
public function apiCreated ( ? string $ location = null , $ content = '' ) : ApiResponse { return $ this -> createApiResponse ( ) -> created ( $ location , $ content ) ; } 
public function apiAccepted ( ? string $ location = null , $ content = '' ) : ApiResponse { return $ this -> createApiResponse ( ) -> accepted ( $ location , $ content ) ; } 
public function apiError ( string $ message , int $ statusCode , ? string $ text = null ) : ApiResponse { return $ this -> createApiResponse ( ) -> error ( $ message , $ statusCode , $ text ) ; } 
public function apiBadRequest ( ? string $ message = null , ? string $ text = null ) : ApiResponse { return $ this -> createApiResponse ( ) -> badRequest ( $ message , $ text ) ; } 
public function apiUnauthorized ( ? string $ message = null , ? string $ text = null ) : ApiResponse { return $ this -> createApiResponse ( ) -> unauthorized ( $ message , $ text ) ; } 
public function apiForbidden ( ? string $ message = null , ? string $ text = null ) : ApiResponse { return $ this -> createApiResponse ( ) -> forbidden ( $ message , $ text ) ; } 
public function apiNotFound ( ? string $ message = null , ? string $ text = null ) : ApiResponse { return $ this -> createApiResponse ( ) -> notFound ( $ message , $ text ) ; } 
public function apiMethodNotAllowed ( ? string $ message = null , ? string $ text = null ) : ApiResponse { return $ this -> createApiResponse ( ) -> methodNotAllowed ( $ message , $ text ) ; } 
public function apiUnprocessableEntity ( ? array $ errors = null , ? string $ message = null , ? string $ text = null ) : ApiResponse { return $ this -> createApiResponse ( ) -> unprocessableEntity ( $ errors , $ message , $ text ) ; } 
public function apiTooManyRequests ( ? string $ message = null , ? string $ text = null ) : ApiResponse { return $ this -> createApiResponse ( ) -> tooManyRequests ( $ message , $ text ) ; } 
public function apiInternalServerError ( ? string $ message = null , ? string $ text = null ) : ApiResponse { return $ this -> createApiResponse ( ) -> internalServerError ( $ message , $ text ) ; } 
public function createRequest ( IRequest $ leevelRequest ) : ServerRequestInterface { $ server = normalizeServer ( $ leevelRequest -> server -> all ( ) ) ; $ headers = $ leevelRequest -> headers -> all ( ) ; $ body = new DiactorosStream ( $ this -> normalizeContent ( $ leevelRequest -> getContent ( ) ) ) ; $ request = new ServerRequest ( $ server , normalizeUploadedFiles ( $ this -> getFiles ( $ leevelRequest -> files -> all ( ) ) ) , $ leevelRequest -> getSchemeAndHttpHost ( ) . $ leevelRequest -> getRequestUri ( ) , $ leevelRequest -> getMethod ( ) , $ body , $ headers ) ; $ request = $ request -> withCookieParams ( $ leevelRequest -> cookies -> all ( ) ) -> withQueryParams ( $ leevelRequest -> query -> all ( ) ) -> withParsedBody ( $ leevelRequest -> request -> all ( ) ) -> withRequestTarget ( $ leevelRequest -> getRequestUri ( ) ) ; foreach ( $ leevelRequest -> params -> all ( ) as $ key => $ value ) { $ request = $ request -> withAttribute ( $ key , $ value ) ; } return $ request ; } 
public function createResponse ( Response $ leevelResponse ) : ResponseInterface { $ stream = new DiactorosStream ( 'php://temp' , 'wb+' ) ; $ stream -> write ( $ leevelResponse -> getContent ( ) ) ; $ headers = $ leevelResponse -> headers -> all ( ) ; if ( ! isset ( $ headers [ 'Set-Cookie' ] ) && ! isset ( $ headers [ 'set-sookie' ] ) && $ cookies = $ leevelResponse -> getCookies ( ) ) { foreach ( $ cookies as $ item ) { $ headers [ 'Set-Cookie' ] [ ] = Cookie :: format ( $ item ) ; } } $ response = new DiactorosResponse ( $ stream , $ leevelResponse -> getStatusCode ( ) , $ headers ) ; $ protocolVersion = $ leevelResponse -> getProtocolVersion ( ) ; if ( '1.1' !== $ protocolVersion ) { $ response = $ response -> withProtocolVersion ( $ protocolVersion ) ; } return $ response ; } 
protected function normalizeContent ( string $ content ) { $ resource = fopen ( 'php://temp' , 'r+' ) ; fwrite ( $ resource , $ content ) ; rewind ( $ resource ) ; return $ resource ; } 
protected function createUploadedFile ( UploadedFile $ leevelUploadedFile ) : UploadedFileInterface { return new DiactorosUploadedFile ( $ leevelUploadedFile -> getRealPath ( ) , ( int ) $ leevelUploadedFile -> getSize ( ) , $ leevelUploadedFile -> getError ( ) , $ leevelUploadedFile -> getOriginalName ( ) , $ leevelUploadedFile -> getMimeType ( ) ) ; } 
public function handle ( IApp $ app , RouterProvider $ routerProvider ) : void { $ this -> line ( 'Start to cache router.' ) ; $ data = $ routerProvider -> getRouters ( ) ; $ cachePath = $ app -> routerCachedPath ( ) ; $ this -> writeCache ( $ cachePath , $ data ) ; $ this -> info ( sprintf ( 'Router cache file %s cache successed.' , $ cachePath ) ) ; } 
public function handle ( IServer $ server ) : void { while ( true ) { sleep ( 1 ) ; $ newMd5 = $ this -> md5 ( ) ; $ this -> count ++ ; if ( $ this -> md5 && $ newMd5 !== $ this -> md5 ) { $ this -> log ( 'The Swoole server will reload.' ) ; $ this -> count = 0 ; $ this -> reloading = true ; } if ( true === $ this -> reloading && $ this -> count > $ this -> after ) { $ this -> reload ( $ server ) ; } $ this -> md5 = $ newMd5 ; } } 
protected function md5 ( ) : string { $ md5File = [ ] ; foreach ( $ this -> files ( ) as $ file ) { $ md5File [ $ file ] = md5_file ( $ file ) ; } ksort ( $ md5File ) ; return md5 ( json_encode ( $ md5File ) ) ; } 
protected function files ( ) : array { $ files = [ ] ; foreach ( ( array ) $ this -> option -> get ( 'swoole\\hotoverload_watch' ) as $ dir ) { if ( ! is_dir ( $ dir ) ) { continue ; } list_directory ( $ dir , true , function ( $ file ) use ( & $ files ) { if ( $ file -> isFile ( ) ) { if ( in_array ( $ file -> getExtension ( ) , [ 'php' ] , true ) ) { $ files [ ] = $ file -> getPath ( ) . '/' . $ file -> getFilename ( ) ; } } } ) ; } return $ files ; } 
protected function reload ( IServer $ server ) : void { $ this -> reloading = false ; $ this -> log ( 'The Swoole server is start reloading.' ) ; $ server -> getServer ( ) -> reload ( ) ; $ this -> log ( 'The Swoole server has reloaded.' ) ; } 
public function remember ( string $ name , $ data , array $ option = [ ] ) { if ( false !== ( $ result = $ this -> connect -> get ( $ name , false , $ option ) ) ) { return $ result ; } if ( is_object ( $ data ) && $ data instanceof Closure ) { $ data = $ data ( $ name ) ; } $ this -> connect -> set ( $ name , $ data , $ option ) ; return $ data ; } 
protected function status ( array $ option ) : void { $ processName = $ option [ 'process_name' ] ; if ( $ this -> option ( 'all' ) ) { $ item = '$1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11' ; $ nikename = [ 
public function url ( string $ url , array $ params = [ ] , string $ subdomain = 'www' , $ suffix = null , int $ status = 302 , array $ headers = [ ] ) : RedirectResponse { $ url = $ this -> url -> make ( $ url , $ params , $ subdomain , $ suffix ) ; return $ this -> createRedirectResponse ( $ url , $ status , $ headers ) ; } 
public function raw ( string $ url , int $ status = 302 , array $ headers = [ ] ) : RedirectResponse { return $ this -> createRedirectResponse ( $ url , $ status , $ headers ) ; } 
protected function createRedirectResponse ( string $ url , int $ status = 302 , array $ headers = [ ] ) : RedirectResponse { $ redirect = new RedirectResponse ( $ url , $ status , $ headers ) ; if ( isset ( $ this -> session ) ) { $ redirect -> setSession ( $ this -> session ) ; } $ redirect -> setRequest ( $ this -> url -> getRequest ( ) ) ; return $ redirect ; } 
public function handle ( Closure $ next , IRequest $ request ) : void { if ( ! $ this -> manager -> isLogin ( ) ) { throw new AuthException ( 'User authorization failed.' ) ; } $ next ( $ request ) ; } 
public function password ( string $ password , array $ option = [ ] ) : string { $ algo = $ option [ self :: ALGO ] ?? PASSWORD_BCRYPT ; return password_hash ( $ password , ( int ) $ algo , $ option ) ; } 
public function handle ( Closure $ next , IRequest $ request ) : void { if ( ! $ this -> app -> debug ( ) ) { $ next ( $ request ) ; return ; } $ this -> debug -> bootstrap ( ) ; $ next ( $ request ) ; } 
public function terminate ( Closure $ next , IRequest $ request , IResponse $ response ) : void { if ( ! $ this -> app -> debug ( ) ) { $ next ( $ request , $ response ) ; return ; } $ this -> debug -> handle ( $ request , $ response ) ; $ next ( $ request , $ response ) ; } 
public function handle ( ) : void { $ this -> line ( 'Start to optimize you app.' ) ; $ this -> callRouter ( ) ; $ this -> callOption ( ) ; $ this -> callI18n ( ) ; $ this -> callView ( ) ; $ this -> callAutoload ( ) ; $ this -> line ( '' ) ; $ this -> info ( 'Optimize successed.' ) ; } 
public function register ( ) : void { $ this -> router ( ) ; $ this -> url ( ) ; $ this -> redirect ( ) ; $ this -> response ( ) ; $ this -> view ( ) ; } 
protected function url ( ) : void { $ this -> container -> singleton ( 'url' , function ( IContainer $ container ) { $ option = $ container [ 'option' ] ; $ router = $ container [ 'router' ] ; $ options = [ ] ; foreach ( [ 'with_suffix' , 'suffix' , 'domain' , ] as $ item ) { $ options [ $ item ] = $ option -> get ( $ item ) ; } return new Url ( $ container [ 'request' ] , $ options ) ; } ) ; } 
protected function redirect ( ) : void { $ this -> container -> singleton ( 'redirect' , function ( IContainer $ container ) { $ redirect = new Redirect ( $ container [ 'url' ] ) ; if ( isset ( $ container [ 'session' ] ) ) { $ redirect -> setSession ( $ container [ 'session' ] ) ; } return $ redirect ; } ) ; } 
protected function response ( ) : void { $ this -> container -> singleton ( 'response' , function ( IContainer $ container ) { $ option = $ container [ 'option' ] ; return ( new ResponseFactory ( $ container [ 'view' ] , $ container [ 'redirect' ] ) ) -> setViewSuccessTemplate ( $ option -> get ( 'view\\success' ) ) -> setViewFailTemplate ( $ option -> get ( 'view\\fail' ) ) ; } ) ; } 
public function handle ( IRequest $ request ) : IResponse { try { $ this -> registerBaseService ( $ request ) ; $ this -> bootstrap ( ) ; $ response = $ this -> getResponseWithRequest ( $ request ) ; $ this -> middlewareTerminate ( $ request , $ response ) ; } catch ( Exception $ e ) { $ this -> reportException ( $ e ) ; $ response = $ this -> renderException ( $ request , $ e ) ; } catch ( Throwable $ e ) { $ e = new ErrorException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , E_ERROR , $ e -> getFile ( ) , $ e -> getLine ( ) , $ e -> getPrevious ( ) ) ; $ this -> reportException ( $ e ) ; $ response = $ this -> renderException ( $ request , $ e ) ; } return $ response ; } 
protected function renderException ( IRequest $ request , Exception $ e ) : IResponse { return $ this -> getRuntime ( ) -> render ( $ request , $ e ) ; } 
protected function middlewareTerminate ( IRequest $ request , IResponse $ response ) : void { $ this -> router -> throughMiddleware ( $ request , [ $ response , ] ) ; } 
public function setOption ( string $ name , $ value ) : ILog { $ this -> option [ $ name ] = $ value ; return $ this ; } 
public function log ( string $ level , string $ message , array $ context = [ ] ) : void { if ( ! in_array ( $ level , $ this -> option [ 'levels' ] , true ) ) { return ; } $ data = [ $ level , $ message , $ context ] ; $ this -> handleDispatch ( $ data ) ; $ this -> count ++ ; $ this -> logs [ $ level ] [ ] = $ data ; if ( false === $ this -> option [ 'buffer' ] || ( $ this -> option [ 'buffer_size' ] && $ this -> count >= $ this -> option [ 'buffer_size' ] ) ) { $ this -> flush ( ) ; } } 
public function flush ( ) : void { foreach ( $ this -> logs as $ data ) { $ this -> saveStore ( $ data ) ; } $ this -> clear ( ) ; } 
public function clear ( ? string $ level = null ) : void { if ( null === $ level ) { $ this -> count = 0 ; $ this -> logs = [ ] ; } if ( isset ( $ this -> logs [ $ level ] ) ) { $ this -> count -= count ( $ this -> logs [ $ level ] ) ; $ this -> logs [ $ level ] = [ ] ; } } 
public function all ( ? string $ level = null ) : array { if ( null === $ level ) { return $ this -> logs ; } if ( isset ( $ this -> logs [ $ level ] ) ) { return $ this -> logs [ $ level ] ; } return [ ] ; } 
public function count ( ? string $ level = null ) : int { if ( null === $ level ) { return $ this -> count ; } return count ( $ this -> all ( $ level ) ) ; } 
protected function handleDispatch ( array $ data ) : void { if ( $ this -> dispatch ) { $ this -> dispatch -> handle ( self :: LOG_EVENT , ... $ data ) ; } } 
public function bootstrap ( IDispatch $ dispatch ) : void { foreach ( $ this -> get ( ) as $ event => $ listeners ) { foreach ( $ listeners as $ key => $ item ) { if ( is_int ( $ item ) ) { $ dispatch -> register ( $ event , $ key , $ item ) ; } else { $ dispatch -> register ( $ event , $ item ) ; } } } } 
public function data ( $ names , array $ option = [ ] , bool $ force = false ) : array { $ names = is_array ( $ names ) ? $ names : [ $ names , ] ; foreach ( $ names as $ name ) { if ( ! isset ( $ this -> cacheLoaded [ $ name ] ) || $ force ) { $ this -> cacheLoaded [ $ name ] = $ this -> cache ( $ name , $ option , $ force ) ; } } $ result = [ ] ; foreach ( $ names as $ name ) { $ result [ $ name ] = $ this -> cacheLoaded [ $ name ] ; } return count ( $ result ) > 1 ? $ result : reset ( $ result ) ; } 
public function refresh ( $ names ) : void { $ tmp = is_array ( $ names ) ? $ names : [ $ names , ] ; foreach ( $ tmp as $ name ) { $ this -> delete ( $ name ) ; } } 
public function dataLoaded ( $ names , array $ option = [ ] , bool $ force = false ) { $ result = [ ] ; $ names = is_array ( $ names ) ? $ names : [ $ names , ] ; foreach ( $ names as $ name ) { $ result [ $ name ] = array_key_exists ( $ name , $ this -> cacheLoaded ) ? $ this -> cacheLoaded [ $ name ] : false ; } return count ( $ result ) > 1 ? $ result : reset ( $ result ) ; } 
protected function cache ( string $ name , array $ option = [ ] , bool $ force = false ) { if ( false === $ force ) { $ data = $ this -> getPersistence ( $ name , false , $ option ) ; } else { $ data = false ; } if ( false === $ data ) { $ data = $ this -> update ( $ name , $ option ) ; } return $ data ; } 
protected function update ( string $ name , array $ option = [ ] ) { $ sourceName = $ name ; list ( $ name , $ params ) = $ this -> parse ( $ name ) ; if ( false !== strpos ( $ name , '@' ) ) { list ( $ name , $ method ) = explode ( '@' , $ name ) ; } else { $ method = 'handle' ; } if ( ! is_object ( $ cache = $ this -> container -> make ( $ name ) ) ) { throw new InvalidArgumentException ( sprintf ( 'Cache %s is not valid.' , $ name ) ) ; } if ( ! is_callable ( [ $ cache , $ method ] ) ) { throw new InvalidArgumentException ( sprintf ( 'Cache %s is not a callable.' , $ name . '@' . $ method ) ) ; } $ sourceData = $ cache -> { $ method } ( ... $ params ) ; $ this -> setPersistence ( $ sourceName , $ sourceData , $ option ) ; return $ sourceData ; } 
protected function getPersistence ( string $ name , $ defaults = false , array $ option = [ ] ) { return $ this -> cache -> get ( $ name , $ defaults , $ option ) ; } 
protected function setPersistence ( string $ name , $ data , array $ option = [ ] ) : void { $ this -> cache -> set ( $ name , $ data , $ option ) ; } 
public static function withoutRelationCondition ( Closure $ returnRelation ) : self { $ old = static :: $ relationCondition ; static :: $ relationCondition = false ; $ relation = call_user_func ( $ returnRelation ) ; static :: $ relationCondition = $ old ; return $ relation ; } 
protected function getEntityKey ( array $ entitys , ? string $ key = null ) : array { return array_unique ( array_values ( array_map ( function ( $ entity ) use ( $ key ) { return $ key ? $ entity -> __get ( $ key ) : $ entity -> singleId ( ) ; } , $ entitys ) ) ) ; } 
public function register ( ) : void { $ this -> container -> singleton ( 'encryption' , function ( IContainer $ container ) { $ option = $ container [ 'option' ] ; return new Encryption ( $ option [ 'auth_key' ] , $ option [ 'auth_cipher' ] , $ option [ 'auth_rsa_private' ] , $ option [ 'auth_rsa_public' ] ) ; } ) ; } 
public function sendHeaders ( ) : IResponse { if ( headers_sent ( ) ) { return $ this ; } 
public function setContent ( $ content ) : IResponse { if ( $ this -> checkFlowControl ( ) ) { return $ this ; } $ this -> original = $ content ; if ( $ this -> contentShouldJson ( $ content ) ) { $ this -> setHeader ( 'Content-Type' , 'application/json' ) ; $ this -> isJson = true ; $ content = $ this -> contentToJson ( $ content ) ; } if ( null !== $ content && ! is_scalar ( $ content ) && ! is_callable ( [ $ content , '__toString' ] ) ) { $ e = sprintf ( 'The Response content must be a scalar or object implementing __toString(), %s given.' , gettype ( $ content ) ) ; throw new UnexpectedValueException ( $ e ) ; } $ this -> content = ( string ) $ content ; return $ this ; } 
public function appendContent ( string $ content = null ) : IResponse { if ( $ this -> checkFlowControl ( ) ) { return $ this ; } $ this -> content = $ this -> getContent ( ) . $ content ; return $ this ; } 
public function setHeader ( string $ key , string $ value , bool $ replace = true ) : IResponse { if ( $ this -> checkFlowControl ( ) ) { return $ this ; } if ( true === $ replace || ! $ this -> headers -> has ( $ key ) ) { $ this -> headers -> set ( $ key , $ value ) ; } return $ this ; } 
public function withHeaders ( array $ headers ) : IResponse { if ( $ this -> checkFlowControl ( ) ) { return $ this ; } foreach ( $ headers as $ key => $ value ) { $ this -> headers -> set ( $ key , $ value ) ; } return $ this ; } 
public function cookie ( string $ name , string $ value = '' , array $ option = [ ] ) : IResponse { return $ this -> setCookie ( $ name , $ value , $ option ) ; } 
public function setCookie ( string $ name , string $ value = '' , array $ option = [ ] ) : IResponse { if ( $ this -> checkFlowControl ( ) ) { return $ this ; } $ this -> headers -> setCookie ( $ name , $ value , $ option ) ; return $ this ; } 
public function withCookies ( array $ cookies , array $ option = [ ] ) : IResponse { if ( $ this -> checkFlowControl ( ) ) { return $ this ; } foreach ( $ cookies as $ key => $ value ) { $ this -> setCookie ( $ key , $ value , $ option ) ; } return $ this ; } 
public function getData ( bool $ assoc = true , int $ depth = 512 ) { if ( $ this -> isJson ) { return json_decode ( $ this -> content , $ assoc , $ depth ) ; } return $ this -> content ; } 
public function setData ( $ data = [ ] , ? int $ encodingOptions = null ) : IResponse { if ( $ this -> checkFlowControl ( ) ) { return $ this ; } $ this -> original = $ data ; if ( null === $ encodingOptions ) { $ encodingOptions = 256 ; } if ( $ data instanceof IArray ) { $ data = json_encode ( $ data -> toArray ( ) , $ encodingOptions ) ; } elseif ( is_object ( $ data ) && $ data instanceof IJson ) { $ data = $ data -> toJson ( $ encodingOptions ) ; } elseif ( is_object ( $ data ) && $ data instanceof JsonSerializable ) { $ data = json_encode ( $ data -> jsonSerialize ( ) , $ encodingOptions ) ; } else { $ data = json_encode ( $ data , $ encodingOptions ) ; } if ( JSON_ERROR_NONE !== json_last_error ( ) ) { throw new InvalidArgumentException ( json_last_error_msg ( ) ) ; } $ this -> content = ( string ) $ data ; return $ this ; } 
public function setProtocolVersion ( string $ protocolVersion ) : IResponse { if ( $ this -> checkFlowControl ( ) ) { return $ this ; } $ this -> protocolVersion = $ protocolVersion ; return $ this ; } 
public function setStatusCode ( int $ code , ? string $ text = null ) : IResponse { if ( $ this -> checkFlowControl ( ) ) { return $ this ; } $ this -> statusCode = $ code ; if ( $ this -> isInvalid ( ) ) { $ e = sprintf ( 'The HTTP status code %s is not valid.' , $ code ) ; throw new InvalidArgumentException ( $ e ) ; } if ( null === $ text ) { $ this -> statusText = self :: $ statusTexts [ $ code ] ?? 'unknown status' ; return $ this ; } $ this -> statusText = $ text ; return $ this ; } 
public function charset ( string $ charset ) : IResponse { if ( $ this -> checkFlowControl ( ) ) { return $ this ; } $ this -> charset = $ charset ; return $ this ; } 
public function setLastModified ( DateTime $ datetime = null ) : IResponse { if ( $ this -> checkFlowControl ( ) ) { return $ this ; } if ( null === $ datetime ) { $ this -> headers -> remove ( 'Last-Modified' ) ; return $ this ; } $ this -> setHeader ( 'Last-Modified' , $ this -> normalizeDateTime ( $ datetime ) ) ; return $ this ; } 
public function setCache ( int $ minutes ) : IResponse { if ( $ this -> checkFlowControl ( ) ) { return $ this ; } $ date = new DateTime ( ) ; $ date -> modify ( '+' . $ minutes . 'minutes' ) ; $ this -> setExpires ( $ date ) ; $ this -> setHeader ( 'Cache-Control' , 'max-age=' . ( $ minutes * 60 ) ) ; return $ this ; } 
public function setNotModified ( ) : IResponse { if ( $ this -> checkFlowControl ( ) ) { return $ this ; } $ this -> setStatusCode ( 304 , self :: $ statusTexts [ 304 ] ) ; return $ this ; } 
public function setContentType ( string $ contentType , ? string $ charset = null ) : IResponse { if ( $ this -> checkFlowControl ( ) ) { return $ this ; } if ( null === $ charset ) { $ charset = $ this -> getCharset ( ) ; } if ( null === $ charset ) { $ this -> setHeader ( 'Content-Type' , $ contentType ) ; } else { $ this -> setHeader ( 'Content-Type' , $ contentType . '; charset=' . $ charset ) ; } return $ this ; } 
public function setContentLength ( int $ contentLength ) : IResponse { if ( $ this -> checkFlowControl ( ) ) { return $ this ; } $ this -> setHeader ( 'Content-Length' , ( string ) $ contentLength ) ; return $ this ; } 
public function setEtag ( string $ etag ) : IResponse { if ( $ this -> checkFlowControl ( ) ) { return $ this ; } $ this -> setHeader ( 'Etag' , $ etag ) ; return $ this ; } 
protected function normalizeDateTime ( DateTime $ datetime ) : string { $ date = clone $ datetime ; $ date -> setTimezone ( new DateTimeZone ( 'UTC' ) ) ; return $ date -> format ( 'D, d M Y H:i:s' ) . ' GMT' ; } 
protected function contentToJson ( $ content ) : string { if ( $ content instanceof IJson ) { return $ content -> toJson ( ) ; } if ( $ content instanceof IArray ) { $ content = $ content -> toArray ( ) ; } return json_encode ( $ content , JSON_UNESCAPED_UNICODE ) ; } 
protected function contentShouldJson ( $ content ) : bool { return $ content instanceof IJson || $ content instanceof IArray || $ content instanceof ArrayObject || $ content instanceof JsonSerializable || is_array ( $ content ) ; } 
public function addRelationCondition ( ) : void { if ( static :: $ relationCondition ) { $ this -> select -> where ( $ this -> targetKey , $ this -> getSourceValue ( ) ) ; } } 
public function matchPreLoad ( array $ entitys , Collection $ result , string $ relation ) : array { $ maps = $ this -> buildMap ( $ result ) ; foreach ( $ entitys as $ value ) { $ key = $ value -> __get ( $ this -> sourceKey ) ; if ( isset ( $ maps [ $ key ] ) ) { $ value -> withRelationProp ( $ relation , $ maps [ $ key ] ) ; } } return $ entitys ; } 
public function preLoadCondition ( array $ entitys ) : void { $ this -> select -> whereIn ( $ this -> targetKey , $ this -> getPreLoadEntityValue ( $ entitys ) ) ; } 
protected function buildMap ( Collection $ result ) : array { $ maps = [ ] ; foreach ( $ result as $ entity ) { $ maps [ $ entity -> __get ( $ this -> targetKey ) ] = $ entity ; } return $ maps ; } 
protected function getPreLoadEntityValue ( array $ entitys ) : array { $ arr = [ ] ; foreach ( $ entitys as $ value ) { if ( null !== ( $ tmp = $ value -> __get ( $ this -> sourceKey ) ) ) { $ arr [ ] = $ tmp ; } } if ( 0 === count ( $ arr ) ) { return [ 0 ] ; } return array_values ( array_unique ( $ arr ) ) ; } 
public function handle ( ) : void { $ this -> warn ( $ this -> getVersion ( ) ) ; $ server = $ this -> createServer ( ) ; $ this -> reload ( $ server -> getOption ( ) ) ; } 
protected function reload ( array $ option ) : void { $ pidFile = $ option [ 'pid_path' ] ; $ processName = $ option [ 'process_name' ] ; if ( ! file_exists ( $ pidFile ) ) { throw new InvalidArgumentException ( sprintf ( 'Pid path `%s` was not found.' , $ pidFile ) ) ; } $ pids = explode ( PHP_EOL , file_get_contents ( $ pidFile ) ) ; $ pid = ( int ) $ pids [ 0 ] ; if ( ! Process :: kill ( $ pid , 0 ) ) { throw new InvalidArgumentException ( sprintf ( 'Pid `%s` was not found.' , $ pid ) ) ; } Process :: kill ( $ pid , $ this -> option ( 'all' ) ? SIGUSR1 : SIGUSR2 ) ; 
public function ok ( $ content = '' , ? string $ text = null ) : IResponse { if ( $ this -> checkFlowControl ( ) ) { return $ this ; } $ this -> setStatusCode ( static :: HTTP_OK , $ text ) ; return $ this -> setData ( $ content ) ; } 
public function created ( ? string $ location = null , $ content = '' ) : IResponse { if ( $ this -> checkFlowControl ( ) ) { return $ this ; } $ this -> setData ( $ content ) ; $ this -> setStatusCode ( static :: HTTP_CREATED ) ; if ( null !== $ location ) { $ this -> setHeader ( 'Location' , $ location ) ; } return $ this ; } 
public function accepted ( ? string $ location = null , $ content = '' ) : IResponse { if ( $ this -> checkFlowControl ( ) ) { return $ this ; } $ this -> setData ( $ content ) ; $ this -> setStatusCode ( static :: HTTP_ACCEPTED ) ; if ( null !== $ location ) { $ this -> setHeader ( 'Location' , $ location ) ; } return $ this ; } 
public function unprocessableEntity ( ? array $ errors = null , ? string $ message = null , ? string $ text = null ) : IResponse { if ( $ this -> checkFlowControl ( ) ) { return $ this ; } $ this -> setStatusCode ( static :: HTTP_UNPROCESSABLE_ENTITY , $ text ) ; $ this -> setData ( [ 'message' => $ this -> parseErrorMessage ( $ message ) , 'errors' => $ errors ? : [ ] , ] ) ; return $ this ; } 
public function error ( ? string $ message , int $ statusCode , ? string $ text = null ) : IResponse { if ( $ this -> checkFlowControl ( ) ) { return $ this ; } $ this -> setStatusCode ( $ statusCode , $ text ) ; return $ this -> normalizeErrorMessage ( $ message ) ; } 
public function badRequest ( ? string $ message = null , ? string $ text = null ) : IResponse { return $ this -> error ( $ message , static :: HTTP_BAD_REQUEST , $ text ) ; } 
public function unauthorized ( ? string $ message = null , ? string $ text = null ) : IResponse { return $ this -> error ( $ message , static :: HTTP_UNAUTHORIZED , $ text ) ; } 
public function forbidden ( ? string $ message = null , ? string $ text = null ) : IResponse { return $ this -> error ( $ message , static :: HTTP_FORBIDDEN , $ text ) ; } 
public function notFound ( ? string $ message = null , ? string $ text = null ) : IResponse { return $ this -> error ( $ message , static :: HTTP_NOT_FOUND , $ text ) ; } 
public function methodNotAllowed ( ? string $ message = null , ? string $ text = null ) : IResponse { return $ this -> error ( $ message , static :: HTTP_METHOD_NOT_ALLOWED , $ text ) ; } 
public function tooManyRequests ( ? string $ message = null , ? string $ text = null ) : IResponse { return $ this -> error ( $ message , static :: HTTP_TOO_MANY_REQUESTS , $ text ) ; } 
public function internalServerError ( ? string $ message = null , ? string $ text = null ) : IResponse { return $ this -> error ( $ message , static :: HTTP_INTERNAL_SERVER_ERROR , $ text ) ; } 
protected function normalizeErrorMessage ( ? string $ message = null , ? string $ text = null ) : IResponse { return $ this -> setData ( [ 'message' => $ this -> parseErrorMessage ( $ message ) , ] ) ; } 
public function verifyResponseContent ( $ responseContent ) { 
public function getTranslation ( ) { if ( sizeof ( $ this -> responseContent -> translations ) === 0 ) { return null ; } $ translatedText = '' ; $ lineBreaks = $ this -> lineBreaks ; 
public function getTranslationAlternatives ( ) { if ( sizeof ( $ this -> responseContent -> translations ) === 0 ) { return [ ] ; } if ( sizeof ( $ this -> responseContent -> translations ) > 1 ) { throw new \ LogicException ( 'This method does not operate on more than one source text' , 290 ) ; } $ beams = $ this -> responseContent -> translations [ 0 ] -> beams ; $ translationAlternatives = [ ] ; foreach ( $ beams as $ beam ) { $ translationAlternatives [ ] = $ beam -> postprocessed_sentence ; } return $ translationAlternatives ; } 
public function getTranslatedSentences ( ) { $ translatedTexts = [ ] ; foreach ( $ this -> responseContent -> translations as $ translation ) { 
public function callApi ( $ url , array $ payload , $ method ) { if ( ! is_string ( $ url ) ) { throw new \ InvalidArgumentException ( '$url has to be a string' ) ; } if ( ! is_string ( $ method ) ) { throw new \ InvalidArgumentException ( '$method has to be a string' ) ; } $ jsonData = $ this -> protocol -> createRequestData ( $ payload , $ method ) ; $ options = [ 'body' => $ jsonData ] ; try { $ guzzleResponse = $ this -> guzzle -> post ( $ url , $ options ) ; } catch ( GuzzleException $ exception ) { $ callException = new CallException ( 'cURL error during DeepLy API call: ' . $ exception -> getMessage ( ) ) ; throw $ callException ; } $ code = $ guzzleResponse -> getStatusCode ( ) ; if ( $ code !== 200 ) { 
public function ping ( $ url ) { if ( ! is_string ( $ url ) ) { throw new \ InvalidArgumentException ( '$url has to be a string' ) ; } try { $ startedAt = microtime ( true ) ; $ this -> guzzle -> get ( $ url ) ; $ duration = microtime ( true ) - $ startedAt ; } catch ( GuzzleException $ exception ) { throw new CallException ( 'Did not get a valid response. API seems to be unreachable.' ) ; } return $ duration ; } 
public function createRequestData ( array $ payload , $ method ) { if ( ! is_string ( $ method ) ) { throw new \ InvalidArgumentException ( 'The $method argument has to be null or of type string' ) ; } 
public function processResponseData ( $ rawResponseData ) { if ( ! is_string ( $ rawResponseData ) ) { throw new \ InvalidArgumentException ( 'The $rawResponseData argument has to be a string' ) ; } $ responseData = json_decode ( $ rawResponseData ) ; $ this -> validateResponseData ( $ responseData ) ; 
protected function validateResponseData ( $ responseData ) { if ( ! $ responseData instanceof \ stdClass ) { throw new ProtocolException ( 'DeepLy API call did not return JSON that describes a \stdClass object' ) ; } if ( ! property_exists ( $ responseData , 'jsonrpc' ) ) { throw new ProtocolException ( ' The given response data does not seem to be come from a JSON RPC request - it has no "jsonrpc" property' ) ; } if ( $ responseData -> jsonrpc !== self :: PROTOCOL_VERSION ) { throw new ProtocolException ( 'The version of the JSON RPC response does not match the expected version ' . self :: PROTOCOL_VERSION ) ; } if ( property_exists ( $ responseData , 'error' ) ) { if ( $ responseData -> error instanceof \ stdClass and property_exists ( $ responseData -> error , 'message' ) ) { $ message = 'DeepLy API call resulted in this error: ' . $ responseData -> error -> message ; 
public function callApi ( $ url , array $ payload , $ method ) { if ( ! is_string ( $ url ) ) { throw new \ InvalidArgumentException ( '$url has to be a string' ) ; } if ( ! is_string ( $ method ) ) { throw new \ InvalidArgumentException ( '$method has to be a string' ) ; } $ jsonData = $ this -> protocol -> createRequestData ( $ payload , $ method ) ; $ curl = curl_init ( $ url ) ; curl_setopt ( $ curl , CURLOPT_CUSTOMREQUEST , 'POST' ) ; curl_setopt ( $ curl , CURLOPT_POSTFIELDS , $ jsonData ) ; curl_setopt ( $ curl , CURLOPT_RETURNTRANSFER , true ) ; curl_setopt ( $ curl , CURLOPT_SSL_VERIFYPEER , $ this -> sslVerifyPeer ) ; 
protected function getTextFromHtml ( $ htmlCode ) { $ document = new \ DOMDocument ( ) ; $ okay = $ document -> loadHTML ( $ htmlCode ) ; 
public function ping ( $ url ) { if ( ! is_string ( $ url ) ) { throw new \ InvalidArgumentException ( '$url has to be a string' ) ; } $ curl = curl_init ( $ url ) ; 
public function verifyResponseContent ( $ responseContent ) { 
public function getAllSentences ( ) { $ splitTexts = $ this -> responseContent -> splitted_texts ; $ sentences = [ ] ; foreach ( $ splitTexts as $ splitText ) { foreach ( $ splitText as $ sentence ) { $ sentences [ ] = $ sentence ; } } return $ sentences ; } 
public function requestSplitText ( $ text , $ from = self :: LANG_AUTO ) { if ( ! is_string ( $ text ) and ! is_array ( $ text ) ) { throw new \ InvalidArgumentException ( 'The $text argument has to be a string or an array of strings' ) ; } if ( is_array ( $ text ) ) { foreach ( $ text as $ index => $ part ) { if ( ! is_string ( $ part ) ) { throw new \ InvalidArgumentException ( 'If the $text argument is an array it ha to be an array of strings, but the ' . ( $ index + 1 ) . '. item is not a string' ) ; } } } else { $ text = [ $ text ] ; } $ params = [ 'texts' => $ text , 'lang' => [ 'lang_user_selected' => $ from ] ] ; $ rawResponseData = $ this -> httpClient -> callApi ( self :: API_BASE_URL , $ params , self :: METHOD_SPLIT ) ; $ responseContent = $ this -> protocol -> processResponseData ( $ rawResponseData ) ; $ splitTextBag = new SentencesBag ( $ responseContent ) ; return $ splitTextBag ; } 
public function splitText ( $ text , $ from = self :: LANG_AUTO ) { $ splitTextBag = $ this -> requestSplitText ( $ text , $ from ) ; $ sentences = $ splitTextBag -> getAllSentences ( ) ; return $ sentences ; } 
public function detectLanguage ( $ text ) { 
protected function requestTranslation ( $ text , $ to = self :: LANG_EN , $ from = self :: LANG_AUTO ) { $ this -> translationBag = null ; if ( ! is_string ( $ text ) and ! is_array ( $ text ) ) { throw new \ InvalidArgumentException ( 'The $text argument has to be a string or an array' ) ; } if ( is_array ( $ text ) ) { foreach ( $ text as $ index => $ sentence ) { if ( ! is_string ( $ sentence ) ) { throw new \ InvalidArgumentException ( 'The $text argument has to be a string or an array of strings. ' . 'The ' . ( ++ $ index ) . '. item of the array is not a string.' ) ; } 
public function translate ( $ text , $ to = self :: LANG_EN , $ from = self :: LANG_AUTO ) { $ translationBag = $ this -> requestTranslation ( $ text , $ to , $ from ) ; return $ translationBag -> getTranslation ( ) ; } 
public function proposeTranslations ( $ text , $ to = self :: LANG_EN , $ from = self :: LANG_AUTO ) { $ translationBag = $ this -> requestTranslation ( $ text , $ to , $ from ) ; return $ translationBag -> getTranslationAlternatives ( ) ; } 
public function translateSentences ( array $ sentences , $ to = self :: LANG_EN , $ from = self :: LANG_AUTO , $ join = false ) { $ translationBag = $ this -> requestTranslation ( $ sentences , $ to , $ from ) ; $ translatedSentences = $ translationBag -> getTranslatedSentences ( ) ; if ( $ join ) { return implode ( ' ' , $ translatedSentences ) ; } return $ translatedSentences ; } 
public function translateFile ( $ filename , $ to = self :: LANG_EN , $ from = self :: LANG_AUTO ) { if ( ! is_string ( $ filename ) ) { throw new \ InvalidArgumentException ( 'The $filename argument has to be a string' ) ; } if ( ! is_readable ( $ filename ) ) { throw new \ InvalidArgumentException ( 'Could not read file with the given filename' ) ; } $ text = file_get_contents ( $ filename ) ; if ( $ text === false ) { throw new \ RuntimeException ( 'Could not read file with the given filename. Does this file exist and do we have read permission?' ) ; } return $ this -> translate ( $ text , $ to , $ from ) ; } 
public function supportsLangCode ( $ langCode , $ allowAuto = false ) { if ( ! is_string ( $ langCode ) ) { throw new \ InvalidArgumentException ( 'The $langCode argument has to be a string' ) ; } $ supported = in_array ( $ langCode , $ this -> getLangCodes ( $ allowAuto ) ) ; return $ supported ; } 
public function getLangCodes ( $ withAuto = true ) { if ( ! is_bool ( $ withAuto ) ) { throw new \ InvalidArgumentException ( 'The $withAuto argument has to be boolean' ) ; } if ( $ withAuto ) { return self :: LANG_CODES ; } 
public function getLangName ( $ langCode ) { if ( ! in_array ( $ langCode , self :: LANG_CODES ) ) { throw new \ InvalidArgumentException ( 'The language code is unknown' ) ; } return self :: LANG_NAMES [ $ langCode ] ; } 
public function getLangCodeByName ( $ langName ) { if ( ! in_array ( $ langName , self :: LANG_NAMES ) ) { throw new \ InvalidArgumentException ( 'The language name is unknown' ) ; } return array_search ( $ langName , self :: LANG_NAMES ) ; } 
public function verifyResponseContent ( $ responseContent ) { if ( ! $ responseContent instanceof \ stdClass ) { throw new BagException ( 'DeepLy API call did not return JSON that describes a \stdClass object' , 10 ) ; } if ( property_exists ( $ responseContent , 'error' ) ) { if ( $ responseContent -> error instanceof \ stdClass and property_exists ( $ responseContent -> error , 'message' ) ) { throw new BagException ( 'DeepLy API call resulted in this error: ' . $ responseContent -> error -> message , 20 ) ; } else { throw new BagException ( 'DeepLy API call resulted in an unknown error' , 21 ) ; } } } 
public function getDefaults ( array $ overrides = null ) : array { if ( empty ( $ overrides ) ) { return $ this -> defaults ; } $ diff = array_diff_key ( $ overrides , $ this -> fields ) ; if ( ! empty ( $ diff ) ) { throw new SimpleCrudException ( sprintf ( 'The field %s does not exist in the table %s' , implode ( array_keys ( $ diff ) ) , $ this ) ) ; } return $ overrides + $ this -> defaults ; } 
public function cache ( Row $ row ) : Row { if ( $ row -> id ) { $ this -> cache [ $ row -> id ] = $ row ; } return $ row ; } 
public function getCached ( $ id ) : ? Row { if ( ! $ this -> isCached ( $ id ) ) { return null ; } $ row = $ this -> cache [ $ id ] ; if ( $ row && ! $ row -> id ) { return $ this -> cache [ $ id ] = null ; } return $ row ; } 
public function offsetExists ( $ offset ) : bool { if ( $ this -> isCached ( $ offset ) ) { return $ this -> getCached ( $ offset ) !== null ; } return $ this -> selectAggregate ( 'COUNT' ) -> where ( 'id = ' , $ offset ) -> limit ( 1 ) -> run ( ) === 1 ; } 
public function offsetGet ( $ offset ) : ? Row { if ( $ this -> isCached ( $ offset ) ) { return $ this -> getCached ( $ offset ) ; } return $ this -> cache [ $ offset ] = $ this -> select ( ) -> one ( ) -> where ( 'id = ' , $ offset ) -> run ( ) ; } 
public function offsetSet ( $ offset , $ value ) : Row { 
public function offsetUnset ( $ offset ) { $ this -> cache [ $ offset ] = null ; $ this -> delete ( ) -> where ( 'id = ' , $ offset ) -> run ( ) ; } 
public function getJoinField ( Table $ table ) : ? Field { $ field = $ table -> getForeignKey ( ) ; return $ this -> fields [ $ field ] ?? null ; } 
public function delete ( ) : self { $ ids = array_values ( $ this -> id ) ; if ( count ( $ ids ) ) { $ this -> table -> delete ( ) -> where ( 'id IN ' , $ ids ) -> run ( ) ; $ this -> id = null ; } return $ this ; } 
public function get ( Table $ table , array $ info ) : Field { $ className = $ this -> getClassName ( $ info [ 'name' ] , $ info [ 'type' ] ) ; if ( class_exists ( $ className ) ) { $ field = new $ className ( $ table , $ info ) ; $ config = $ this -> fields [ $ className ] [ 'config' ] ?? [ ] ; foreach ( $ config as $ name => $ value ) { $ field -> setConfig ( $ name , $ value ) ; } return $ field ; } throw new SimpleCrudException ( "No field class found for '{$className}'" ) ; } 
private function getClassName ( string $ name , string $ type ) : ? string { foreach ( $ this -> fields as $ className => $ definition ) { foreach ( $ definition [ 'names' ] as $ defName ) { if ( $ defName === $ name || ( $ defName [ 0 ] === '/' && preg_match ( $ defName , $ name ) ) ) { return $ className ; } } if ( in_array ( $ type , $ definition [ 'types' ] ) ) { return $ className ; } } return $ this -> defaultType ; } 
public function setConfig ( string $ name , $ value ) : self { $ this -> config [ $ name ] = $ value ; return $ this ; } 
public function getFieldFactory ( ) : FieldFactory { if ( $ this -> fieldFactory === null ) { return $ this -> fieldFactory = new FieldFactory ( ) ; } return $ this -> fieldFactory ; } 
public function execute ( string $ query , array $ marks = null ) : PDOStatement { $ statement = $ this -> connection -> prepare ( $ query ) ; $ statement -> execute ( $ marks ) ; return $ statement ; } 
public function executeTransaction ( callable $ callable ) { try { $ transaction = $ this -> beginTransaction ( ) ; $ return = $ callable ( $ this ) ; if ( $ transaction ) { $ this -> commit ( ) ; } } catch ( Exception $ exception ) { if ( $ transaction ) { $ this -> rollBack ( ) ; } throw $ exception ; } return $ return ; } 
public function beginTransaction ( ) : bool { if ( ! $ this -> inTransaction ( ) ) { $ this -> connection -> beginTransaction ( ) ; return $ this -> inTransaction = true ; } return false ; } 
private static function isValid ( $ data ) : bool { if ( ! is_array ( $ data ) ) { return false ; } if ( ! isset ( $ data [ 0 ] ) || ! isset ( $ data [ 1 ] ) || count ( $ data ) > 2 ) { return false ; } return is_numeric ( $ data [ 0 ] ) && is_numeric ( $ data [ 1 ] ) ; } 
public function & __get ( string $ name ) { if ( $ name === 'id' ) { return $ this -> values [ 'id' ] ; } 
public function __isset ( string $ name ) : bool { $ valueName = $ this -> getValueName ( $ name ) ; return ( isset ( $ valueName ) && ! is_null ( $ this -> getValue ( $ valueName ) ) ) || isset ( $ this -> data [ $ name ] ) ; } 
public function edit ( array $ values ) : self { foreach ( $ values as $ name => $ value ) { $ this -> __set ( $ name , $ value ) ; } return $ this ; } 
public function save ( ) : self { if ( ! empty ( $ this -> changes ) ) { $ eventDispatcher = $ this -> table -> getEventDispatcher ( ) ; if ( $ eventDispatcher ) { $ eventDispatcher -> dispatch ( new BeforeSaveRow ( $ this ) ) ; } if ( empty ( $ this -> id ) ) { $ this -> id = $ this -> table -> insert ( $ this -> changes ) -> run ( ) ; } else { $ this -> table -> update ( $ this -> changes ) -> where ( 'id = ' , $ this -> id ) -> run ( ) ; } $ this -> values = $ this -> toArray ( ) ; $ this -> changes = [ ] ; $ this -> table -> cache ( $ this ) ; } return $ this ; } 
public function delete ( ) : self { $ id = $ this -> id ; if ( ! empty ( $ id ) ) { $ this -> table -> delete ( ) -> where ( 'id = ' , $ id ) -> run ( ) ; $ this -> values [ 'id' ] = null ; } return $ this ; } 
public function relate ( Row ... $ rows ) : self { $ table1 = $ this -> table ; foreach ( $ rows as $ row ) { $ table2 = $ row -> getTable ( ) ; 
public function unrelate ( Row ... $ rows ) : self { $ table1 = $ this -> table ; foreach ( $ rows as $ row ) { $ table2 = $ row -> getTable ( ) ; 
public function unrelateAll ( Table ... $ tables ) : self { $ table1 = $ this -> table ; foreach ( $ tables as $ table2 ) { 
public function select ( Table $ table ) : Select { 
private function getValueName ( string $ name ) : ? string { if ( array_key_exists ( $ name , $ this -> values ) ) { return $ name ; } 
public function setLimits ( $ var ) { $ arr = GPBUtil :: checkRepeatedField ( $ var , \ Google \ Protobuf \ Internal \ GPBType :: MESSAGE , \ Google \ Api \ QuotaLimit :: class ) ; $ this -> limits = $ arr ; return $ this ; } 
public function setMetricRules ( $ var ) { $ arr = GPBUtil :: checkRepeatedField ( $ var , \ Google \ Protobuf \ Internal \ GPBType :: MESSAGE , \ Google \ Api \ MetricRule :: class ) ; $ this -> metric_rules = $ arr ; return $ this ; } 
public function setProducerDestinations ( $ var ) { $ arr = GPBUtil :: checkRepeatedField ( $ var , \ Google \ Protobuf \ Internal \ GPBType :: MESSAGE , \ Google \ Api \ Logging \ LoggingDestination :: class ) ; $ this -> producer_destinations = $ arr ; return $ this ; } 
public function setConsumerDestinations ( $ var ) { $ arr = GPBUtil :: checkRepeatedField ( $ var , \ Google \ Protobuf \ Internal \ GPBType :: MESSAGE , \ Google \ Api \ Logging \ LoggingDestination :: class ) ; $ this -> consumer_destinations = $ arr ; return $ this ; } 
public function setAdvices ( $ var ) { $ arr = GPBUtil :: checkRepeatedField ( $ var , \ Google \ Protobuf \ Internal \ GPBType :: MESSAGE , \ Google \ Api \ Advice :: class ) ; $ this -> advices = $ arr ; return $ this ; } 
public function setAttachments ( $ var ) { $ arr = GPBUtil :: checkRepeatedField ( $ var , \ Google \ Protobuf \ Internal \ GPBType :: MESSAGE , \ Google \ Protobuf \ Any :: class ) ; $ this -> attachments = $ arr ; return $ this ; } 
public function setApis ( $ var ) { $ arr = GPBUtil :: checkRepeatedField ( $ var , \ Google \ Protobuf \ Internal \ GPBType :: MESSAGE , \ Google \ Protobuf \ Api :: class ) ; $ this -> apis = $ arr ; return $ this ; } 
public function setTypes ( $ var ) { $ arr = GPBUtil :: checkRepeatedField ( $ var , \ Google \ Protobuf \ Internal \ GPBType :: MESSAGE , \ Google \ Protobuf \ Type :: class ) ; $ this -> types = $ arr ; return $ this ; } 
public function setEnums ( $ var ) { $ arr = GPBUtil :: checkRepeatedField ( $ var , \ Google \ Protobuf \ Internal \ GPBType :: MESSAGE , \ Google \ Protobuf \ Enum :: class ) ; $ this -> enums = $ arr ; return $ this ; } 
public function setEndpoints ( $ var ) { $ arr = GPBUtil :: checkRepeatedField ( $ var , \ Google \ Protobuf \ Internal \ GPBType :: MESSAGE , \ Google \ Api \ Endpoint :: class ) ; $ this -> endpoints = $ arr ; return $ this ; } 
public function setLogs ( $ var ) { $ arr = GPBUtil :: checkRepeatedField ( $ var , \ Google \ Protobuf \ Internal \ GPBType :: MESSAGE , \ Google \ Api \ LogDescriptor :: class ) ; $ this -> logs = $ arr ; return $ this ; } 
public function setMetrics ( $ var ) { $ arr = GPBUtil :: checkRepeatedField ( $ var , \ Google \ Protobuf \ Internal \ GPBType :: MESSAGE , \ Google \ Api \ MetricDescriptor :: class ) ; $ this -> metrics = $ arr ; return $ this ; } 
public function setMonitoredResources ( $ var ) { $ arr = GPBUtil :: checkRepeatedField ( $ var , \ Google \ Protobuf \ Internal \ GPBType :: MESSAGE , \ Google \ Api \ MonitoredResourceDescriptor :: class ) ; $ this -> monitored_resources = $ arr ; return $ this ; } 
public function setFieldViolations ( $ var ) { $ arr = GPBUtil :: checkRepeatedField ( $ var , \ Google \ Protobuf \ Internal \ GPBType :: MESSAGE , \ Google \ Rpc \ BadRequest \ FieldViolation :: class ) ; $ this -> field_violations = $ arr ; return $ this ; } 
public function setOperations ( $ var ) { $ arr = GPBUtil :: checkRepeatedField ( $ var , \ Google \ Protobuf \ Internal \ GPBType :: MESSAGE , \ Google \ LongRunning \ Operation :: class ) ; $ this -> operations = $ arr ; return $ this ; } 
public function setView ( $ var ) { GPBUtil :: checkEnum ( $ var , \ Google \ Iam \ Admin \ V1 \ RoleView :: class ) ; $ this -> view = $ var ; return $ this ; } 
public function setIncludedPermissions ( $ var ) { $ arr = GPBUtil :: checkRepeatedField ( $ var , \ Google \ Protobuf \ Internal \ GPBType :: STRING ) ; $ this -> included_permissions = $ arr ; return $ this ; } 
public function setStage ( $ var ) { GPBUtil :: checkEnum ( $ var , \ Google \ Iam \ Admin \ V1 \ Role_RoleLaunchStage :: class ) ; $ this -> stage = $ var ; return $ this ; } 
public function setConsumerDestinations ( $ var ) { $ arr = GPBUtil :: checkRepeatedField ( $ var , \ Google \ Protobuf \ Internal \ GPBType :: MESSAGE , \ Google \ Api \ Billing \ BillingDestination :: class ) ; $ this -> consumer_destinations = $ arr ; return $ this ; } 
public function setExtensions ( $ var ) { $ arr = GPBUtil :: checkRepeatedField ( $ var , \ Google \ Protobuf \ Internal \ GPBType :: MESSAGE , \ Google \ Protobuf \ Any :: class ) ; $ this -> extensions = $ arr ; return $ this ; } 
public function setProviders ( $ var ) { $ arr = GPBUtil :: checkRepeatedField ( $ var , \ Google \ Protobuf \ Internal \ GPBType :: MESSAGE , \ Google \ Api \ AuthProvider :: class ) ; $ this -> providers = $ arr ; return $ this ; } 
public function setRequested ( $ var ) { $ arr = GPBUtil :: checkRepeatedField ( $ var , \ Google \ Protobuf \ Internal \ GPBType :: STRING ) ; $ this -> requested = $ arr ; return $ this ; } 
public function setProvided ( $ var ) { $ arr = GPBUtil :: checkRepeatedField ( $ var , \ Google \ Protobuf \ Internal \ GPBType :: STRING ) ; $ this -> provided = $ arr ; return $ this ; } 
public function setBounds ( $ var ) { $ arr = GPBUtil :: checkRepeatedField ( $ var , \ Google \ Protobuf \ Internal \ GPBType :: DOUBLE ) ; $ this -> bounds = $ arr ; return $ this ; } 
public function setRole ( $ var ) { GPBUtil :: checkMessage ( $ var , \ Google \ Iam \ Admin \ V1 \ Role :: class ) ; $ this -> role = $ var ; return $ this ; } 
public function setSubpages ( $ var ) { $ arr = GPBUtil :: checkRepeatedField ( $ var , \ Google \ Protobuf \ Internal \ GPBType :: MESSAGE , \ Google \ Api \ Page :: class ) ; $ this -> subpages = $ arr ; return $ this ; } 
public function setKeyTypes ( $ var ) { $ arr = GPBUtil :: checkRepeatedField ( $ var , \ Google \ Protobuf \ Internal \ GPBType :: ENUM , \ Google \ Iam \ Admin \ V1 \ ListServiceAccountKeysRequest \ KeyType :: class ) ; $ this -> key_types = $ arr ; return $ this ; } 
public function setAddressLines ( $ var ) { $ arr = GPBUtil :: checkRepeatedField ( $ var , \ Google \ Protobuf \ Internal \ GPBType :: STRING ) ; $ this -> address_lines = $ arr ; return $ this ; } 
public function setRecipients ( $ var ) { $ arr = GPBUtil :: checkRepeatedField ( $ var , \ Google \ Protobuf \ Internal \ GPBType :: STRING ) ; $ this -> recipients = $ arr ; return $ this ; } 
public function setLogs ( $ var ) { $ arr = GPBUtil :: checkRepeatedField ( $ var , \ Google \ Protobuf \ Internal \ GPBType :: STRING ) ; $ this -> logs = $ arr ; return $ this ; } 
public function setRequirements ( $ var ) { $ arr = GPBUtil :: checkRepeatedField ( $ var , \ Google \ Protobuf \ Internal \ GPBType :: STRING ) ; $ this -> requirements = $ arr ; return $ this ; } 
public function setStackEntries ( $ var ) { $ arr = GPBUtil :: checkRepeatedField ( $ var , \ Google \ Protobuf \ Internal \ GPBType :: STRING ) ; $ this -> stack_entries = $ arr ; return $ this ; } 
public function setMembers ( $ var ) { $ arr = GPBUtil :: checkRepeatedField ( $ var , \ Google \ Protobuf \ Internal \ GPBType :: STRING ) ; $ this -> members = $ arr ; return $ this ; } 
public function setProducerDestinations ( $ var ) { $ arr = GPBUtil :: checkRepeatedField ( $ var , \ Google \ Protobuf \ Internal \ GPBType :: MESSAGE , \ Google \ Api \ Monitoring \ MonitoringDestination :: class ) ; $ this -> producer_destinations = $ arr ; return $ this ; } 
public function setConsumerDestinations ( $ var ) { $ arr = GPBUtil :: checkRepeatedField ( $ var , \ Google \ Protobuf \ Internal \ GPBType :: MESSAGE , \ Google \ Api \ Monitoring \ MonitoringDestination :: class ) ; $ this -> consumer_destinations = $ arr ; return $ this ; } 
public function setAdditionalBindings ( $ var ) { $ arr = GPBUtil :: checkRepeatedField ( $ var , \ Google \ Protobuf \ Internal \ GPBType :: MESSAGE , \ Google \ Api \ HttpRule :: class ) ; $ this -> additional_bindings = $ arr ; return $ this ; } 
public function setRequirements ( $ var ) { $ arr = GPBUtil :: checkRepeatedField ( $ var , \ Google \ Protobuf \ Internal \ GPBType :: MESSAGE , \ Google \ Api \ AuthRequirement :: class ) ; $ this -> requirements = $ arr ; return $ this ; } 
public function setBindings ( $ var ) { $ arr = GPBUtil :: checkRepeatedField ( $ var , \ Google \ Protobuf \ Internal \ GPBType :: MESSAGE , \ Google \ Cloud \ Iam \ V1 \ Binding :: class ) ; $ this -> bindings = $ arr ; return $ this ; } 
public function setMetricCosts ( $ var ) { $ arr = GPBUtil :: checkMapField ( $ var , \ Google \ Protobuf \ Internal \ GPBType :: STRING , \ Google \ Protobuf \ Internal \ GPBType :: INT64 ) ; $ this -> metric_costs = $ arr ; return $ this ; } 
public function setPages ( $ var ) { $ arr = GPBUtil :: checkRepeatedField ( $ var , \ Google \ Protobuf \ Internal \ GPBType :: MESSAGE , \ Google \ Api \ Page :: class ) ; $ this -> pages = $ arr ; return $ this ; } 
public function setRules ( $ var ) { $ arr = GPBUtil :: checkRepeatedField ( $ var , \ Google \ Protobuf \ Internal \ GPBType :: MESSAGE , \ Google \ Api \ DocumentationRule :: class ) ; $ this -> rules = $ arr ; return $ this ; } 
public function setAction ( $ var ) { GPBUtil :: checkEnum ( $ var , \ Google \ Cloud \ Iam \ V1 \ BindingDelta_Action :: class ) ; $ this -> action = $ var ; return $ this ; } 
public function setSourceFiles ( $ var ) { $ arr = GPBUtil :: checkRepeatedField ( $ var , \ Google \ Protobuf \ Internal \ GPBType :: MESSAGE , \ Google \ Protobuf \ Any :: class ) ; $ this -> source_files = $ arr ; return $ this ; } 
public function setKeys ( $ var ) { $ arr = GPBUtil :: checkRepeatedField ( $ var , \ Google \ Protobuf \ Internal \ GPBType :: MESSAGE , \ Google \ Iam \ Admin \ V1 \ ServiceAccountKey :: class ) ; $ this -> keys = $ arr ; return $ this ; } 
public function setAccounts ( $ var ) { $ arr = GPBUtil :: checkRepeatedField ( $ var , \ Google \ Protobuf \ Internal \ GPBType :: MESSAGE , \ Google \ Iam \ Admin \ V1 \ ServiceAccount :: class ) ; $ this -> accounts = $ arr ; return $ this ; } 
public function setCustomRolesSupportLevel ( $ var ) { GPBUtil :: checkEnum ( $ var , \ Google \ Iam \ Admin \ V1 \ Permission_CustomRolesSupportLevel :: class ) ; $ this -> custom_roles_support_level = $ var ; return $ this ; } 
public function setPolicyDelta ( $ var ) { GPBUtil :: checkMessage ( $ var , \ Google \ Cloud \ Iam \ V1 \ PolicyDelta :: class ) ; $ this -> policy_delta = $ var ; return $ this ; } 
public function setBucketCounts ( $ var ) { $ arr = GPBUtil :: checkRepeatedField ( $ var , \ Google \ Protobuf \ Internal \ GPBType :: INT64 ) ; $ this -> bucket_counts = $ arr ; return $ this ; } 
public function setExemplars ( $ var ) { $ arr = GPBUtil :: checkRepeatedField ( $ var , \ Google \ Protobuf \ Internal \ GPBType :: MESSAGE , \ Google \ Api \ Distribution \ Exemplar :: class ) ; $ this -> exemplars = $ arr ; return $ this ; } 
public function setMetrics ( $ var ) { $ arr = GPBUtil :: checkRepeatedField ( $ var , \ Google \ Protobuf \ Internal \ GPBType :: STRING ) ; $ this -> metrics = $ arr ; return $ this ; } 
public function setLinks ( $ var ) { $ arr = GPBUtil :: checkRepeatedField ( $ var , \ Google \ Protobuf \ Internal \ GPBType :: MESSAGE , \ Google \ Rpc \ Help \ Link :: class ) ; $ this -> links = $ arr ; return $ this ; } 
public function setAliases ( $ var ) { $ arr = GPBUtil :: checkRepeatedField ( $ var , \ Google \ Protobuf \ Internal \ GPBType :: STRING ) ; $ this -> aliases = $ arr ; return $ this ; } 
public function setFeatures ( $ var ) { $ arr = GPBUtil :: checkRepeatedField ( $ var , \ Google \ Protobuf \ Internal \ GPBType :: STRING ) ; $ this -> features = $ arr ; return $ this ; } 
public function setValues ( $ var ) { $ arr = GPBUtil :: checkMapField ( $ var , \ Google \ Protobuf \ Internal \ GPBType :: STRING , \ Google \ Protobuf \ Internal \ GPBType :: INT64 ) ; $ this -> values = $ arr ; return $ this ; } 
public function setServiceAccount ( $ var ) { GPBUtil :: checkMessage ( $ var , \ Google \ Iam \ Admin \ V1 \ ServiceAccount :: class ) ; $ this -> service_account = $ var ; return $ this ; } 
public function setProperties ( $ var ) { $ arr = GPBUtil :: checkRepeatedField ( $ var , \ Google \ Protobuf \ Internal \ GPBType :: MESSAGE , \ Google \ Api \ Property :: class ) ; $ this -> properties = $ arr ; return $ this ; } 
public function setViolations ( $ var ) { $ arr = GPBUtil :: checkRepeatedField ( $ var , \ Google \ Protobuf \ Internal \ GPBType :: MESSAGE , \ Google \ Rpc \ QuotaFailure \ Violation :: class ) ; $ this -> violations = $ arr ; return $ this ; } 
public function setPrivateKeyType ( $ var ) { GPBUtil :: checkEnum ( $ var , \ Google \ Iam \ Admin \ V1 \ ServiceAccountPrivateKeyType :: class ) ; $ this -> private_key_type = $ var ; return $ this ; } 
public function setKeyAlgorithm ( $ var ) { GPBUtil :: checkEnum ( $ var , \ Google \ Iam \ Admin \ V1 \ ServiceAccountKeyAlgorithm :: class ) ; $ this -> key_algorithm = $ var ; return $ this ; } 
public function setDetails ( $ var ) { $ arr = GPBUtil :: checkRepeatedField ( $ var , \ Google \ Protobuf \ Internal \ GPBType :: MESSAGE , \ Google \ Protobuf \ Any :: class ) ; $ this -> details = $ arr ; return $ this ; } 
public function setBindingDeltas ( $ var ) { $ arr = GPBUtil :: checkRepeatedField ( $ var , \ Google \ Protobuf \ Internal \ GPBType :: MESSAGE , \ Google \ Cloud \ Iam \ V1 \ BindingDelta :: class ) ; $ this -> binding_deltas = $ arr ; return $ this ; } 
public function setPublicKeyType ( $ var ) { GPBUtil :: checkEnum ( $ var , \ Google \ Iam \ Admin \ V1 \ ServiceAccountPublicKeyType :: class ) ; $ this -> public_key_type = $ var ; return $ this ; } 
public function setPolicy ( $ var ) { GPBUtil :: checkMessage ( $ var , \ Google \ Cloud \ Iam \ V1 \ Policy :: class ) ; $ this -> policy = $ var ; return $ this ; } 
public function setRoles ( $ var ) { $ arr = GPBUtil :: checkRepeatedField ( $ var , \ Google \ Protobuf \ Internal \ GPBType :: MESSAGE , \ Google \ Iam \ Admin \ V1 \ Role :: class ) ; $ this -> roles = $ arr ; return $ this ; } 
public function setParameters ( $ var ) { $ arr = GPBUtil :: checkRepeatedField ( $ var , \ Google \ Protobuf \ Internal \ GPBType :: MESSAGE , \ Google \ Api \ SystemParameter :: class ) ; $ this -> parameters = $ arr ; return $ this ; } 
public function getCacheFile ( $ filename , $ actual = false , $ mkdir = false ) { $ path = array ( ) ; 
protected function checkConditions ( $ cacheFile , array $ conditions = array ( ) ) { 
public function exists ( $ filename , array $ conditions = array ( ) ) { $ cacheFile = $ this -> getCacheFile ( $ filename , true ) ; return $ this -> checkConditions ( $ cacheFile , $ conditions ) ; } 
public function set ( $ filename , $ contents = '' ) { $ cacheFile = $ this -> getCacheFile ( $ filename , true , true ) ; file_put_contents ( $ cacheFile , $ contents , \ LOCK_EX ) ; return $ this ; } 
public function get ( $ filename , array $ conditions = array ( ) ) { if ( $ this -> exists ( $ filename , $ conditions ) ) { return file_get_contents ( $ this -> getCacheFile ( $ filename , true ) ) ; } else { return null ; } } 
public function getOrCreate ( $ filename , array $ conditions = array ( ) , $ function , $ file = false , $ actual = false ) { if ( ! is_callable ( $ function ) ) { throw new \ InvalidArgumentException ( 'The argument $function should be callable' ) ; } $ cacheFile = $ this -> getCacheFile ( $ filename , true , true ) ; $ data = null ; if ( ! $ this -> check ( $ filename , $ conditions ) ) { if ( file_exists ( $ cacheFile ) ) { unlink ( $ cacheFile ) ; } $ data = call_user_func ( $ function , $ cacheFile ) ; 
public function getOrCreateFile ( $ filename , array $ conditions = array ( ) , $ function , $ actual = false ) { return $ this -> getOrCreate ( $ filename , $ conditions , $ function , true , $ actual ) ; } 
public function download ( $ args , $ assoc_args ) { $ download_dir = ! empty ( $ assoc_args [ 'path' ] ) ? ( rtrim ( $ assoc_args [ 'path' ] , '/\\' ) . '/' ) : ABSPATH ; $ wordpress_present = is_readable ( $ download_dir . 'wp-load.php' ) ; if ( $ wordpress_present && ! Utils \ get_flag_value ( $ assoc_args , 'force' ) ) { WP_CLI :: error ( 'WordPress files seem to already be present here.' ) ; } if ( ! is_dir ( $ download_dir ) ) { if ( ! is_writable ( dirname ( $ download_dir ) ) ) { WP_CLI :: error ( "Insufficient permission to create directory '{$download_dir}'." ) ; } WP_CLI :: log ( "Creating directory '{$download_dir}'." ) ; if ( ! @ mkdir ( $ download_dir , 0777 , true ) ) { $ error = error_get_last ( ) ; WP_CLI :: error ( "Failed to create directory '{$download_dir}': {$error['message']}." ) ; } } if ( ! is_writable ( $ download_dir ) ) { WP_CLI :: error ( "'{$download_dir}' is not writable by current user." ) ; } $ locale = Utils \ get_flag_value ( $ assoc_args , 'locale' , 'en_US' ) ; $ skip_content = Utils \ get_flag_value ( $ assoc_args , 'skip-content' ) ; if ( isset ( $ assoc_args [ 'version' ] ) && 'latest' !== $ assoc_args [ 'version' ] ) { $ version = $ assoc_args [ 'version' ] ; if ( in_array ( strtolower ( $ version ) , [ 'trunk' , 'nightly' ] , true ) ) { $ version = 'nightly' ; } 
public function is_installed ( $ args , $ assoc_args ) { if ( is_blog_installed ( ) && ( ! Utils \ get_flag_value ( $ assoc_args , 'network' ) || is_multisite ( ) ) ) { WP_CLI :: halt ( 0 ) ; } WP_CLI :: halt ( 1 ) ; } 
public function install ( $ args , $ assoc_args ) { if ( $ this -> do_install ( $ assoc_args ) ) { WP_CLI :: success ( 'WordPress installed successfully.' ) ; } else { WP_CLI :: log ( 'WordPress is already installed.' ) ; } } 
public function multisite_convert ( $ args , $ assoc_args ) { if ( is_multisite ( ) ) { WP_CLI :: error ( 'This already is a multisite install.' ) ; } $ assoc_args = self :: set_multisite_defaults ( $ assoc_args ) ; if ( ! isset ( $ assoc_args [ 'title' ] ) ) { 
public function multisite_install ( $ args , $ assoc_args ) { if ( $ this -> do_install ( $ assoc_args ) ) { WP_CLI :: log ( 'Created single site database tables.' ) ; } else { WP_CLI :: log ( 'Single site database tables already present.' ) ; } $ assoc_args = self :: set_multisite_defaults ( $ assoc_args ) ; 
private static function create_initial_blog ( $ network_id , $ blog_id , $ domain , $ path , $ subdomain_install , $ site_user ) { global $ wpdb , $ current_site , $ wp_rewrite ; 
private static function add_site_admins ( $ site_user ) { $ site_admins = [ $ site_user -> user_login ] ; $ users = get_users ( [ 'fields' => [ 'ID' , 'user_login' ] ] ) ; if ( $ users ) { foreach ( $ users as $ user ) { if ( is_super_admin ( $ user -> ID ) && ! in_array ( $ user -> user_login , $ site_admins , true ) ) { $ site_admins [ ] = $ user -> user_login ; } } } update_site_option ( 'site_admins' , $ site_admins ) ; } 
public function version ( $ args = [ ] , $ assoc_args = [ ] ) { $ details = self :: get_wp_details ( ) ; if ( ! Utils \ get_flag_value ( $ assoc_args , 'extra' ) ) { WP_CLI :: line ( $ details [ 'wp_version' ] ) ; return ; } $ match = [ ] ; $ found_version = preg_match ( '/(\d)(\d+)-/' , $ details [ 'tinymce_version' ] , $ match ) ; $ human_readable_tiny_mce = $ found_version ? "{$match[1]}.{$match[2]}" : '' ; echo Utils \ mustache_render ( self :: get_template_path ( 'versions.mustache' ) , [ 'wp-version' => $ details [ 'wp_version' ] , 'db-version' => $ details [ 'wp_db_version' ] , 'local-package' => empty ( $ details [ 'wp_local_package' ] ) ? 'en_US' : $ details [ 'wp_local_package' ] , 'mce-version' => $ human_readable_tiny_mce ? "{$human_readable_tiny_mce} ({$details['tinymce_version']})" : $ details [ 'tinymce_version' ] , ] ) ; } 
private static function get_wp_details ( $ abspath = ABSPATH ) { $ versions_path = $ abspath . 'wp-includes/version.php' ; if ( ! is_readable ( $ versions_path ) ) { WP_CLI :: error ( "This does not seem to be a WordPress install.\n" . 'Pass --path=`path/to/wordpress` or run `wp core download`.' ) ; } $ version_content = file_get_contents ( $ versions_path , null , null , 6 , 2048 ) ; $ vars = [ 'wp_version' , 'wp_db_version' , 'tinymce_version' , 'wp_local_package' ] ; $ result = [ ] ; foreach ( $ vars as $ var_name ) { $ result [ $ var_name ] = self :: find_var ( $ var_name , $ version_content ) ; } return $ result ; } 
private static function find_var ( $ var_name , $ code ) { $ start = strpos ( $ code , '$' . $ var_name . ' = ' ) ; if ( ! $ start ) { return null ; } $ start = $ start + strlen ( $ var_name ) + 3 ; $ end = strpos ( $ code , ';' , $ start ) ; $ value = substr ( $ code , $ start , $ end - $ start ) ; return trim ( $ value , " '" ) ; } 
private static function get_core_checksums ( $ version , $ locale ) { $ query = http_build_query ( compact ( 'version' , 'locale' ) , null , '&' ) ; $ url = "https://api.wordpress.org/core/checksums/1.0/?{$query}" ; $ options = [ 'timeout' => 30 ] ; $ headers = [ 'Accept' => 'application/json' ] ; $ response = Utils \ http_request ( 'GET' , $ url , null , $ headers , $ options ) ; if ( ! $ response -> success || 200 !== ( int ) $ response -> status_code ) { return "Checksum request '{$url}' failed (HTTP {$response->status_code})." ; } $ body = trim ( $ response -> body ) ; $ body = json_decode ( $ body , true ) ; if ( ! is_array ( $ body ) || ! isset ( $ body [ 'checksums' ] ) || ! is_array ( $ body [ 'checksums' ] ) ) { return "Checksums not available for WordPress {$version}/{$locale}." ; } return $ body [ 'checksums' ] ; } 
public function update ( $ args , $ assoc_args ) { global $ wp_version ; $ update = null ; $ from_api = null ; $ upgrader = 'WP_CLI\\Core\\CoreUpgrader' ; if ( 'trunk' === Utils \ get_flag_value ( $ assoc_args , 'version' ) ) { $ assoc_args [ 'version' ] = 'nightly' ; } if ( ! empty ( $ args [ 0 ] ) ) { 
public function update_db ( $ args , $ assoc_args ) { global $ wpdb , $ wp_db_version , $ wp_current_db_version ; $ network = Utils \ get_flag_value ( $ assoc_args , 'network' ) ; if ( $ network && ! is_multisite ( ) ) { WP_CLI :: error ( 'This is not a multisite installation.' ) ; } $ dry_run = Utils \ get_flag_value ( $ assoc_args , 'dry-run' ) ; if ( $ dry_run ) { WP_CLI :: log ( 'Performing a dry run, with no database modification.' ) ; } if ( $ network ) { $ iterator_args = [ 'table' => $ wpdb -> blogs , 'where' => [ 'spam' => 0 , 'deleted' => 0 , 'archived' => 0 , ] , ] ; $ it = new TableIterator ( $ iterator_args ) ; $ success = 0 ; $ total = 0 ; $ site_ids = [ ] ; foreach ( $ it as $ blog ) { $ total ++ ; $ site_ids [ ] = $ blog -> site_id ; $ url = $ blog -> domain . $ blog -> path ; $ cmd = "--url={$url} core update-db" ; if ( $ dry_run ) { $ cmd .= ' --dry-run' ; } $ process = WP_CLI :: runcommand ( $ cmd , [ 'return' => 'all' ] ) ; if ( 0 === ( int ) $ process -> return_code ) { 
private function get_download_url ( $ version , $ locale = 'en_US' , $ file_type = 'zip' ) { if ( 'nightly' === $ version ) { if ( 'zip' === $ file_type ) { return 'https://wordpress.org/nightly-builds/wordpress-latest.zip' ; } else { WP_CLI :: error ( 'Nightly builds are only available in .zip format.' ) ; } } $ locale_subdomain = 'en_US' === $ locale ? '' : substr ( $ locale , 0 , 2 ) . '.' ; $ locale_suffix = 'en_US' === $ locale ? '' : "-{$locale}" ; return "https://{$locale_subdomain}wordpress.org/wordpress-{$version}{$locale_suffix}.{$file_type}" ; } 
private function get_updates ( $ assoc_args ) { wp_version_check ( ) ; $ from_api = get_site_transient ( 'update_core' ) ; if ( ! $ from_api ) { return [ ] ; } $ compare_version = str_replace ( '-src' , '' , $ GLOBALS [ 'wp_version' ] ) ; $ updates = [ 'major' => false , 'minor' => false , ] ; foreach ( $ from_api -> updates as $ offer ) { $ update_type = Utils \ get_named_sem_ver ( $ offer -> version , $ compare_version ) ; if ( ! $ update_type ) { continue ; } 
public function download_package ( $ package , $ check_signatures = true ) { $ reply = apply_filters ( * Download to a temporary file because piping from cURL to tar is flaky * on MinGW (and probably in other environments too). */ $ headers = [ 'Accept' => 'application/json' ] ; $ options = [ 'timeout' => 600 , 
public function upgrade ( $ current , $ args = [ ] ) { set_error_handler ( [ __CLASS__ , 'error_handler' ] , E_USER_WARNING | E_USER_NOTICE ) ; $ result = parent :: upgrade ( $ current , $ args ) ; restore_error_handler ( ) ; return $ result ; } 
protected function build_table ( array $ arr , $ child = false ) { $ html = '<div class="papi-property-table"><table class="papi-table">' ; $ allow_html = $ this -> get_setting ( 'allow_html' ) ; if ( $ child ) { $ html .= '<thead>' ; foreach ( $ arr [ 0 ] as $ key => $ value ) { if ( $ allow_html ) { $ key = html_entity_decode ( $ key ) ; } $ html .= sprintf ( '<th>%s</th>' , $ key ) ; } $ html .= '</thead>' ; } foreach ( $ arr as $ key => $ value ) { $ html .= '<tr>' ; foreach ( $ value as $ key2 => $ value2 ) { if ( is_array ( $ value2 ) ) { $ value2 = $ this -> build_table ( $ value2 , true ) ; } $ value2 = papi_convert_to_string ( $ value2 ) ; if ( $ allow_html ) { $ value2 = html_entity_decode ( $ value2 ) ; } $ html .= sprintf ( '<td>%s</td>' , $ value2 ) ; } $ html .= '</tr>' ; } return $ html . '</table></div>' ; } 
public function html ( ) { $ value = $ this -> get_value ( ) ; $ data = $ this -> get_setting ( 'items' ) ; if ( ! is_array ( $ data ) ) { return ; } 
public function admin_head ( ) { if ( ! $ this -> box -> frame ) { echo sprintf ( '<style type="text/css">label[for="%s-hide"],#%s>h2,#%s>button{display:none !important}</style>' , esc_attr ( $ this -> box -> id ) , esc_attr ( $ this -> box -> id ) , esc_attr ( $ this -> box -> id ) ) ; } } 
public function move_meta_box_after_title ( ) { global $ post , $ wp_meta_boxes ; do_meta_boxes ( get_current_screen ( ) , $ this -> box -> context , $ post ) ; unset ( $ wp_meta_boxes [ get_post_type ( $ post ) ] [ $ this -> box -> context ] ) ; } 
protected function get_post_type ( ) { if ( papi_get_meta_type ( ) === 'post' ) { if ( $ post_id = papi_get_post_id ( ) ) { return get_post_type ( $ post_id ) ; } if ( $ post_type = papi_get_post_type ( ) ) { return $ post_type ; } } return $ this -> box -> id ; } 
protected function get_title ( ) { $ title = $ this -> box -> title ; if ( $ this -> box -> get_option ( 'required' ) ) { $ title .= papi_property_required_html ( $ this -> box -> properties [ 0 ] , true ) ; } return $ title ; } 
public function render_meta_box ( $ post , array $ args ) { if ( ! isset ( $ args [ 'args' ] ) ) { return ; } 
protected function setup_actions ( ) { if ( post_type_exists ( $ this -> get_post_type ( ) ) && papi_get_meta_type ( ) === 'post' ) { add_action ( 'add_meta_boxes' , [ $ this , 'setup_meta_box' ] ) ; if ( $ this -> box -> context === 'after_title' ) { add_action ( 'edit_form_after_title' , [ $ this , 'move_meta_box_after_title' ] ) ; } } else { $ this -> setup_meta_box ( ) ; } 
public function setup_meta_box ( ) { $ properties = $ this -> box -> properties ; 
protected function get_meta ( ) { $ method = 'meta' ; if ( ! method_exists ( $ this , $ method ) ) { return [ ] ; } $ child_meta = call_user_func ( [ $ this , $ method ] ) ; $ child_meta = is_array ( $ child_meta ) ? $ child_meta : [ ] ; $ parent_class = get_parent_class ( $ this ) ; $ parent_exists = method_exists ( $ parent_class , $ method ) ; $ parent_meta = [ ] ; while ( $ parent_exists ) { $ rc = new ReflectionClass ( $ parent_class ) ; 
protected function setup_file ( $ file_path ) { $ this -> _file_path = $ file_path ; $ this -> _class_name = papi_get_class_name ( $ this -> _file_path ) ; } 
protected function setup_meta_data ( ) { foreach ( $ this -> get_meta ( ) as $ key => $ value ) { if ( substr ( $ key , 0 , 1 ) === '_' ) { continue ; } $ this -> $ key = papi_esc_html ( $ value ) ; } if ( $ this -> sort_order === 1000 ) { $ this -> sort_order = papi_filter_settings_sort_order ( ) ; } } 
public function disabled ( ) { 
public static function factory ( ) { if ( count ( func_get_args ( ) ) === 0 ) { return new static ; } else { $ type = func_get_arg ( 0 ) ; } if ( is_array ( $ type ) ) { $ type = ( object ) $ type ; } if ( ! is_string ( $ type ) && ! is_object ( $ type ) ) { return ; } if ( is_object ( $ type ) && ! isset ( $ type -> type ) ) { $ property = new static ; $ property -> set_options ( $ type ) ; return $ property ; } if ( is_subclass_of ( $ type , __CLASS__ ) ) { return $ type ; } $ options = null ; if ( is_object ( $ type ) ) { if ( ! isset ( $ type -> type ) || ! is_string ( $ type -> type ) ) { return ; } $ options = $ type ; $ type = $ type -> type ; } 
public function format_value ( $ value , $ slug , $ post_id ) { $ value = maybe_unserialize ( $ value ) ; return papi_maybe_json_decode ( $ value , $ this -> convert_type === 'array' ) ; } 
public function get_child_property ( $ slug , array $ items = [ ] ) { $ items = empty ( $ items ) ? $ this -> get_child_properties ( ) : $ items ; foreach ( $ items as $ property ) { if ( is_array ( $ property ) && isset ( $ property [ 'items' ] ) ) { $ property = $ this -> get_child_property ( $ slug , $ property [ 'items' ] ) ; } $ property = papi_get_property_type ( $ property ) ; if ( papi_is_property ( $ property ) && $ property -> match_slug ( $ slug ) ) { return $ property ; } } } 
public function get_option ( $ key , $ default = null ) { $ value = $ default ; if ( isset ( $ this -> options -> $ key ) ) { $ value = $ this -> options -> $ key ; } if ( papi_is_empty ( $ value ) && isset ( $ this -> default_options [ $ key ] ) ) { $ value = $ this -> default_options [ $ key ] ; } if ( $ key === 'settings' && is_array ( $ value ) ) { $ value = ( object ) $ value ; } return $ value ; } 
public function get_post_id ( ) { if ( ! papi_is_empty ( $ this -> post_id ) ) { return $ this -> post_id ; } if ( $ this -> store instanceof Papi_Core_Meta_Store ) { return $ this -> store -> id ; } return papi_get_post_id ( ) ; } 
public function get_setting ( $ key , $ default = null ) { if ( ! is_string ( $ key ) ) { return $ default ; } $ settings = $ this -> get_settings ( ) ; if ( isset ( $ settings -> $ key ) ) { return $ settings -> $ key ; } return $ default ; } 
public function html_id ( $ suffix = '' , $ row = null ) { if ( is_array ( $ suffix ) || is_object ( $ suffix ) ) { return papi_f ( $ this -> html_name ( $ suffix , $ row ) ) ; } else { $ suffix = empty ( $ suffix ) || ! is_string ( $ suffix ) ? '' : '_' . $ suffix ; $ suffix = papi_underscorify ( papi_slugify ( $ suffix ) ) ; } $ name = $ this -> html_name ( ) ; $ len = strlen ( $ name ) ; if ( isset ( $ name [ $ len - 1 ] ) && $ name [ $ len - 1 ] === ']' ) { return papi_f ( sprintf ( '%s%s]' , substr ( $ name , 0 , $ len - 1 ) , $ suffix ) ) ; } return papi_f ( sprintf ( '%s%s' , $ this -> html_name ( ) , $ suffix ) ) ; } 
public function html_name ( $ sub_property = null , $ row = null ) { $ base_slug = $ this -> slug ; if ( is_null ( $ sub_property ) ) { return $ base_slug ; } if ( is_numeric ( $ row ) ) { $ base_slug = sprintf ( '%s[%d]' , $ base_slug , intval ( $ row ) ) ; } if ( ! papi_is_property ( $ sub_property ) ) { if ( is_array ( $ sub_property ) || is_object ( $ sub_property ) ) { $ sub_property = self :: factory ( $ sub_property ) ; } else { return $ base_slug ; } } return sprintf ( '%s[%s]' , $ base_slug , unpapify ( $ sub_property -> get_slug ( ) ) ) ; } 
public function load_value ( $ value , $ slug , $ post_id ) { $ value = maybe_unserialize ( $ value ) ; return papi_maybe_json_decode ( $ value , $ this -> convert_type === 'array' ) ; } 
public function match_slug ( $ slug ) { if ( ! is_string ( $ slug ) ) { return false ; } return $ this -> get_slug ( ! preg_match ( '/^papi\_/' , $ slug ) ) === $ slug ; } 
protected function prepare_value ( $ value ) { if ( papi_is_empty ( $ value ) ) { return ; } $ value = papi_santize_data ( $ value ) ; if ( is_array ( $ value ) ) { $ value = array_filter ( $ value , function ( $ val ) { return ! papi_is_empty ( $ val ) ; } ) ; if ( ! count ( array_filter ( array_keys ( $ value ) , 'is_string' ) ) ) { $ value = array_values ( $ value ) ; } } return $ value ; } 
public function register ( $ type = 'post' ) { if ( version_compare ( get_bloginfo ( 'version' ) , '4.6' , '<' ) ) { return false ; } $ type = papi_get_meta_type ( $ type ) ; 
public function render_is_allowed_by_rules ( array $ rules = [ ] ) { if ( empty ( $ rules ) ) { $ rules = $ this -> get_rules ( ) ; } return $ this -> conditional -> display ( $ rules , $ this ) ; } 
public function set_option ( $ key , $ value ) { if ( ! is_object ( $ this -> options ) ) { $ this -> options = ( object ) $ this -> default_options ; } $ this -> options -> $ key = $ value ; } 
public function set_setting ( $ key , $ value ) { if ( isset ( $ this -> options -> settings , $ this -> options -> settings -> $ key ) ) { $ this -> options -> settings -> $ key = $ value ; } } 
protected function setup_properties ( ) { $ this -> conditional = new Papi_Core_Conditional ( ) ; if ( $ this -> default_options [ 'sort_order' ] === - 1 ) { $ this -> default_options [ 'sort_order' ] = papi_filter_settings_sort_order ( ) ; } if ( papi_is_empty ( $ this -> default_options [ 'post_type' ] ) ) { $ this -> default_options [ 'post_type' ] = papi_get_post_type ( ) ; } } 
protected function setup_options ( $ options = [ ] ) { 
protected function setup_options_slug ( $ options ) { $ slug = $ options -> slug ; 
protected function setup_options_settings ( $ options ) { $ property_class = self :: factory ( $ options -> type ) ; if ( papi_is_property ( $ property_class ) ) { $ options -> settings = array_merge ( ( array ) $ property_class -> get_default_settings ( ) , ( array ) $ options -> settings ) ; } return ( object ) $ options -> settings ; } 
public function update_value ( $ value , $ slug , $ post_id ) { if ( ! ( $ value = $ this -> prepare_value ( $ value ) ) ) { return ; } return papi_maybe_json_encode ( $ value ) ; } 
public function edit_attachment ( $ form_fields , $ post ) { foreach ( $ this -> get_boxes ( ) as $ box ) { if ( ! empty ( $ box -> title ) ) { $ form_fields [ 'papi-media-title-' . uniqid ( ) ] = [ 'label' => '' , 'input' => 'html' , 'html' => '<h4 class="papi-media-title">' . $ box -> title . '</h4>' ] ; } foreach ( $ box -> properties as $ prop ) { 
public function save_attachment ( $ post ) { update_post_meta ( $ post [ 'ID' ] , papi_get_page_type_key ( ) , $ this -> get_id ( ) ) ; $ handler = new Papi_Admin_Meta_Handler ( ) ; $ handler -> save_meta_boxes ( $ post [ 'ID' ] , $ post ) ; return $ post ; } 
public function singleton ( ) { $ key = sprintf ( 'entry_type_id.post_type.%s' , $ this -> get_post_type ( ) ) ; if ( papi ( ) -> exists ( $ key ) ) { return true ; } papi ( ) -> singleton ( $ key , $ this -> get_id ( ) ) ; return false ; } 
public function get_property_meta_value ( $ slug ) { $ slug = strtolower ( $ slug ) ; if ( isset ( $ this -> meta_values [ $ slug ] ) ) { return $ this -> meta_values [ $ slug ] ; } return papi_data_get ( $ this -> id , $ slug , $ this -> get_type ( ) ) ; } 
public function get_value ( $ id = null , $ slug = null , $ default = null , $ type = 'post' ) { if ( ! is_numeric ( $ id ) && is_string ( $ id ) ) { $ type = empty ( $ default ) ? $ type : $ default ; $ default = $ slug ; $ slug = $ id ; $ id = null ; } $ slug = strtolower ( $ slug ) ; 
public function format_value ( $ slug , $ value ) { $ slug = strtolower ( unpapify ( $ slug ) ) ; $ property = $ this -> property ( $ slug ) ; 
protected function property ( $ slug = '' ) { if ( isset ( $ this -> properties [ $ slug ] ) && papi_is_property ( $ this -> properties [ $ slug ] ) ) { $ property = $ this -> properties [ $ slug ] ; } else { $ property = $ this -> properties [ $ slug ] = $ this -> get_property ( $ slug ) ; } return apply_filters ( 'papi/get_property' , $ property ) ; } 
public function load_value ( $ slug ) { $ slug = strtolower ( unpapify ( $ slug ) ) ; $ property = $ this -> property ( $ slug ) ; 
public static function factory ( $ post_id , $ type = 'post' ) { $ type = papi_get_meta_type ( $ type ) ; $ class_suffix = '_' . ucfirst ( $ type ) . '_Store' ; $ class_name = 'Papi' . $ class_suffix ; if ( ! class_exists ( $ class_name ) ) { return ; } $ post_id = papi_get_post_id ( $ post_id ) ; $ page = new $ class_name ( $ post_id ) ; if ( ! $ page -> valid ( ) ) { return ; } return $ page ; } 
public function get_property_option ( $ slug , $ option , $ default = null ) { $ slug = unpapify ( $ slug ) ; $ property = $ this -> property ( $ slug ) ; 
public function html ( ) { $ options = $ this -> get_options ( ) ; $ title = '' ; $ text = '' ; if ( ! papi_is_empty ( $ options -> title ) ) { $ title = sprintf ( '<h3><span>%s</span></h3>' , esc_html ( $ options -> title ) ) ; } if ( ! papi_is_empty ( $ options -> description ) ) { $ text = sprintf ( '<p>%s</p>' , $ options -> description ) ; } papi_render_html_tag ( 'div' , [ 'class' => 'papi-property-divider' , 'data-papi-rule' => esc_attr ( $ this -> html_name ( ) ) , sprintf ( '%s%s' , $ title , $ text ) ] ) ; } 
public function get_value ( ) { $ value = $ this -> get_option ( 'value' ) ; if ( papi_is_empty ( $ value ) ) { $ type = papi_get_meta_type ( ) ; $ slug = $ this -> get_slug ( true ) ; $ value = papi_get_field ( $ slug , null , $ type ) ; $ post_status = get_post_status ( $ this -> get_post_id ( ) ) ; if ( papi_is_empty ( $ value ) && ( $ post_status === false || $ post_status === 'auto-draft' ) ) { $ value = $ this -> get_option ( 'default' ) ; } } if ( papi_is_empty ( $ value ) ) { return $ this -> default_value ; } if ( $ this -> convert_type === 'string' ) { $ value = papi_convert_to_string ( $ value ) ; } return papi_santize_data ( $ value ) ; } 
public function can_render ( ) { 
public function render ( ) { 
protected function render_hidden_html ( ) { $ slug = $ this -> get_option ( 'slug' ) ; if ( substr ( $ slug , - 1 ) === ']' ) { $ slug = substr ( $ slug , 0 , - 1 ) ; $ slug = papi_get_property_type_key ( $ slug ) ; $ slug .= ']' ; } else { $ slug = papi_get_property_type_key ( $ slug ) ; } $ slug = papify ( $ slug ) ; $ options = $ this -> get_options ( ) ; $ property_json = base64_encode ( papi_maybe_json_encode ( $ options ) ) ; papi_render_html_tag ( 'input' , [ 'data-property' => strtolower ( $ this -> get_option ( 'type' ) ) , 'name' => $ slug , 'type' => 'hidden' , 'value' => $ property_json ] ) ; } 
protected function render_label_html ( ) { $ title = $ this -> get_option ( 'title' ) ; papi_render_html_tag ( 'label' , [ 'for' => $ this -> html_id ( ) , 'title' => trim ( $ title . ' ' . papi_property_require_text ( $ this -> get_options ( ) ) ) , $ title , papi_property_required_html ( $ this ) ] ) ; } 
protected function render_property_html ( ) { papi_render_html_tag ( 'div' , [ 'class' => 'papi-before-html ' . $ this -> get_option ( 'before_class' ) , 'data-property' => $ this -> get_option ( 'type' ) , papi_maybe_get_callable_value ( $ this -> get_option ( 'before_html' ) ) ] ) ; $ this -> html ( ) ; papi_render_html_tag ( 'div' , [ 'class' => 'papi-after-html ' . $ this -> get_option ( 'after_class' ) , 'data-property' => $ this -> get_option ( 'type' ) , papi_maybe_get_callable_value ( $ this -> get_option ( 'after_html' ) ) ] ) ; } 
protected function render_row_html ( ) { $ display_class = $ this -> display ( ) ? '' : ' papi-hide' ; $ rules_class = papi_is_empty ( $ this -> get_rules ( ) ) ? '' : ' papi-rules-exists' ; $ css_class = trim ( $ display_class . $ rules_class ) ; $ css_class .= sprintf ( ' papi-layout-%s' , $ this -> get_option ( 'layout' ) ) ; if ( $ this -> get_option ( 'raw' ) ) { echo sprintf ( '<div class="%s">' , esc_attr ( $ css_class ) ) ; $ this -> render_property_html ( ) ; $ this -> render_hidden_html ( ) ; $ this -> render_rules_json ( ) ; echo '</div>' ; } else { ?> <tr class="<?php echo esc_attr ( $ css_class ) ; ?>"> <?php if ( $ this -> get_option ( 'sidebar' ) && $ this -> get_option ( 'layout' ) === 'horizontal' ) : ?> <td class="papi-table-sidebar"> <?php $ this -> render_label_html ( ) ; $ this -> render_description_html ( ) ; ?> </td> <?php endif ; ?> <td <?php echo $ this -> get_option ( 'sidebar' ) && $ this -> get_option ( 'layout' ) === 'horizontal' ? '' : 'colspan="2"' ; ?>> <?php </td> </tr> <?php } } 
protected function render_rules_json ( ) { $ rules = $ this -> get_rules ( ) ; if ( empty ( $ rules ) ) { return ; } $ rules = $ this -> conditional -> prepare_rules ( $ rules , $ this ) ; papi_render_html_tag ( 'script' , [ 'data-papi-rule-source-slug' => $ this -> html_name ( ) , 'data-papi-rules' => 'true' , 'type' => 'application/json' , papi_maybe_json_encode ( $ rules ) ] ) ; } 
public function format_value ( $ value , $ slug , $ post_id ) { if ( ! $ this -> get_setting ( 'allow_html' ) && $ this -> input_type === 'text' ) { $ value = papi_maybe_json_decode ( maybe_unserialize ( $ value ) ) ; if ( ! is_string ( $ value ) ) { $ value = '' ; } $ value = wp_strip_all_tags ( $ value ) ; } return $ value ; } 
public function get_value ( ) { $ value = $ this -> format_value ( parent :: get_value ( ) , $ this -> get_slug ( ) , papi_get_post_id ( ) ) ; return $ this -> get_setting ( 'allow_html' ) ? $ value : esc_html ( $ value ) ; } 
public function html ( ) { papi_render_html_tag ( 'input' , [ 'id' => esc_attr ( $ this -> html_id ( ) ) , 'name' => esc_attr ( $ this -> html_name ( ) ) , 'type' => esc_attr ( $ this -> input_type ) , 'value' => $ this -> get_value ( ) , 'placeholder' => esc_attr ( $ this -> get_setting ( 'placeholder' ) ) ] ) ; } 
protected function decode_property ( $ key , $ value ) { if ( papi_is_property_type_key ( $ key ) && is_string ( $ value ) ) { $ value = base64_decode ( $ value ) ; $ value = papi_maybe_json_decode ( $ value ) ; } return $ value ; } 
protected function get_post_data ( $ pattern = '/^papi\_.*/' ) { $ data = [ ] ; $ keys = preg_grep ( $ pattern , array_keys ( $ _POST ) ) ; foreach ( $ keys as $ key ) { 
protected function get_pre_deep_keys_value ( array $ arr ) { $ keys = [ ] ; $ value = null ; foreach ( $ arr as $ key => $ v ) { if ( is_array ( $ v ) ) { $ keys [ ] = $ key ; list ( $ ks , $ val ) = $ this -> get_pre_deep_keys_value ( $ v ) ; $ keys = array_merge ( $ keys , $ ks ) ; $ value = $ val ; } else { $ keys [ ] = $ key ; $ value = $ v ; } } return [ $ keys , $ value ] ; } 
protected function prepare_post_data ( $ data ) { if ( ! is_array ( $ data ) ) { return $ data ; } foreach ( $ data as $ key => $ value ) { if ( is_array ( $ value ) ) { $ data [ $ key ] = $ this -> prepare_post_data ( $ value ) ; } else { $ data [ $ key ] = $ this -> decode_property ( $ key , $ value ) ; } } return $ data ; } 
protected function prepare_properties_data ( array $ data = [ ] , $ post_id = 0 ) { 
protected function santize_data ( $ value ) { if ( is_array ( $ value ) ) { foreach ( $ value as $ k => $ v ) { if ( is_string ( $ v ) ) { $ value [ $ k ] = $ this -> santize_data ( $ v ) ; } } } else if ( is_string ( $ value ) ) { $ value = wp_unslash ( $ value ) ; } return $ value ; } 
public function delete ( $ id , $ slug ) { $ fn = $ this -> get_function ( 'delete' ) ; 
public function get_function ( $ context = 'get' ) { switch ( $ this -> type ) { case 'option' : return sprintf ( '%s_option' , $ context ) ; case 'site' : case 'network' : return sprintf ( '%s_site_option' , $ context ) ; case 'post' : case 'term' : return sprintf ( '%s_metadata' , $ context ) ; default : break ; } } 
public function get ( $ id , $ slug ) { $ fn = $ this -> get_function ( 'get' ) ; if ( ! is_callable ( $ fn ) ) { return ; } if ( $ this -> id ) { $ value = call_user_func_array ( $ fn , [ $ this -> type , $ id , unpapify ( $ slug ) , true ] ) ; } else { $ value = call_user_func_array ( $ fn , [ unpapify ( $ slug ) , null ] ) ; } if ( papi_is_empty ( $ value ) ) { return ; } return $ value ; } 
public function update ( $ id , $ slug , $ value ) { $ save_value = true ; 
public function update_clear_cache ( $ id , $ value ) { $ value = is_array ( $ value ) ? $ value : [ ] ; foreach ( $ value as $ child_key => $ child_value ) { papi_cache_delete ( $ child_key , $ id , $ this -> type ) ; if ( is_array ( $ child_value ) ) { $ this -> update_clear_cache ( $ id , $ child_value ) ; } } } 
public function get_revision_ui_diff ( $ return , $ compare_from , $ compare_to ) { $ meta = get_post_meta ( $ compare_from -> ID ) ; $ meta = is_array ( $ meta ) ? $ meta : [ ] ; foreach ( $ meta as $ key => $ value ) { if ( $ key [ 0 ] === '_' && $ key !== papi_get_page_type_key ( ) ) { continue ; } $ content_from = papi_data_get ( $ compare_from -> ID , $ key ) ; $ content_to = papi_data_get ( $ compare_to -> ID , $ key ) ; $ diff = wp_text_diff ( $ content_from , $ content_to , [ 'show_split_view' => true ] ) ; if ( $ diff ) { $ return [ ] = [ 'id' => $ key , 'name' => $ key , 'diff' => $ diff , ] ; } } return $ return ; } 
public function hidden_meta_boxes ( ) { global $ _wp_post_type_features ; if ( isset ( $ _wp_post_type_features [ $ this -> post_type ] [ 'editor' ] ) ) { return ; } add_meta_box ( 'papi-hidden-editor' , 'Papi hidden editor' , [ $ this , 'hidden_meta_box_editor' ] , $ this -> post_type ) ; } 
public function load_post_new ( ) { $ request_uri = $ _SERVER [ 'REQUEST_URI' ] ; $ post_types = papi_get_post_types ( ) ; if ( in_array ( $ this -> post_type , $ post_types , true ) && strpos ( $ request_uri , 'page_type=' ) === false ) { $ parsed_url = parse_url ( $ request_uri ) ; $ only_page_type = papi_filter_settings_only_page_type ( $ this -> post_type ) ; $ page_types = papi_get_all_page_types ( $ this -> post_type ) ; $ show_standard = false ; if ( count ( $ page_types ) === 1 && empty ( $ only_page_type ) ) { $ show_standard = $ page_types [ 0 ] -> standard_type ; $ show_standard = $ show_standard ? papi_filter_settings_show_standard_page_type ( $ this -> post_type ) : $ show_standard ; $ only_page_type = $ show_standard ? '' : $ page_types [ 0 ] -> get_id ( ) ; } 
public function redirect_post_location ( $ location ) { if ( ! isset ( $ _SERVER [ 'HTTP_REFERER' ] ) ) { return $ location ; } $ referer = $ _SERVER [ 'HTTP_REFERER' ] ; $ referer = strtolower ( $ referer ) ; if ( strpos ( $ referer , 'papi-iframe-mode' ) === false ) { return $ location ; } return sprintf ( '%s&papi_css[]=papi-iframe-mode' , $ location ) ; } 
public function setup ( ) { 
public function rename ( $ args , $ assoc_args ) { $ type = $ args [ 0 ] ; $ old_key = $ args [ 1 ] ; $ new_key = $ args [ 2 ] ; $ posts = ( new Papi_Query ( [ 'entry_type' => $ type , 'fields' => 'ids' ] ) ) -> get_result ( ) ; if ( empty ( $ posts ) ) { WP_CLI :: error ( 'No posts found' ) ; } foreach ( $ posts as $ post ) { $ meta = get_post_meta ( $ post , $ old_key , true ) ; if ( papi_is_empty ( $ meta ) ) { continue ; } if ( delete_post_meta ( $ post , $ old_key ) === false ) { WP_CLI :: error ( 'Could not delete post meta with key: ' . $ old_key ) ; } if ( update_post_meta ( $ post , $ new_key , $ meta ) === false ) { WP_CLI :: error ( 'Could not update post meta with key: ' . $ new_key ) ; } } WP_CLI :: success ( 'Done' ) ; } 
public function get_field_slug ( ) { if ( preg_match ( '/\[|\]/' , $ this -> slug ) ) { $ slug = preg_replace ( '/\[|\]/' , '.' , $ this -> slug ) ; $ slug = str_replace ( '..' , '.' , $ slug ) ; return substr ( $ slug , 0 , - 1 ) ; } return $ this -> slug ; } 
public function get_source ( ) { if ( is_callable ( $ this -> source ) ) { return call_user_func_array ( $ this -> source , [ $ this -> slug ] ) ; } if ( is_string ( $ this -> source ) && strpos ( $ this -> source , '#' ) !== false ) { $ source = explode ( '#' , $ this -> source ) ; if ( empty ( $ source [ 0 ] ) || empty ( $ source [ 1 ] ) ) { return $ this -> source ; } $ source [ 0 ] = new $ source [ 0 ] ( ) ; if ( method_exists ( $ source [ 0 ] , $ source [ 1 ] ) ) { return call_user_func_array ( $ source , [ $ this -> slug ] ) ; } return ; } return $ this -> source ; } 
public function setup_source ( $ value ) { if ( is_array ( $ value ) && count ( $ value ) === 2 && is_object ( $ value [ 0 ] ) && is_string ( $ value [ 1 ] ) ) { return sprintf ( '%s#%s' , get_class ( $ value [ 0 ] ) , $ value [ 1 ] ) ; } if ( is_string ( $ value ) && is_callable ( $ value ) ) { return $ value ; } 
protected function setup ( array $ rule ) { foreach ( $ rule as $ key => $ value ) { if ( $ key === 'operator' ) { $ value = strtoupper ( $ value ) ; $ value = html_entity_decode ( $ value ) ; } else if ( $ key === 'slug' ) { $ value = papify ( $ value ) ; } else if ( $ key === 'source' ) { $ value = $ this -> setup_source ( $ value ) ; } $ this -> $ key = $ value ; } } 
public function admin_init ( ) { $ meta_type = papi_get_meta_type ( ) ; $ meta_type = ucfirst ( $ meta_type ) ; $ class_name = 'Papi_Admin_Entry_' . $ meta_type ; 
public function admin_body_class ( $ classes ) { if ( $ entry_type = $ this -> get_entry_type ( ) ) { $ classes .= sprintf ( ' papi-body papi-meta-type-%s' , papi_get_meta_type ( ) ) ; 
public function edit_form_after_title ( ) { wp_nonce_field ( 'papi_save_data' , 'papi_meta_nonce' ) ; if ( $ value = esc_attr ( papi_get_entry_type_id ( ) ) ) { papi_render_html_tag ( 'input' , [ 'data-papi-page-type-key' => true , 'name' => esc_attr ( papi_get_page_type_key ( ) ) , 'type' => 'hidden' , 'value' => $ value ] ) ; } } 
protected function get_entry_type ( ) { if ( $ this -> entry_type instanceof Papi_Entry_Type ) { return $ this -> entry_type ; } $ entry_type_id = papi_get_entry_type_id ( ) ; 
public function plugin_row_meta ( array $ links , $ file ) { if ( $ file === PAPI_PLUGIN_BASENAME ) { return array_merge ( $ links , [ 'docs' => '<a href="' . esc_url ( 'https://wp-papi.github.io/docs/' ) . '" title="' . esc_attr ( __ ( 'View Papi Documentation' , 'papi' ) ) . '">' . __ ( 'Docs' , 'papi' ) . '</a>' , ] ) ; } return $ links ; } 
protected function setup_actions ( ) { add_action ( 'admin_init' , [ $ this , 'admin_init' ] ) ; add_action ( 'edit_form_after_title' , [ $ this , 'edit_form_after_title' ] ) ; if ( $ taxonomy = papi_get_taxonomy ( ) ) { add_action ( $ taxonomy . '_add_form' , [ $ this , 'edit_form_after_title' ] ) ; add_action ( $ taxonomy . '_edit_form' , [ $ this , 'edit_form_after_title' ] ) ; } } 
protected function setup_filters ( ) { add_filter ( 'admin_body_class' , [ $ this , 'admin_body_class' ] ) ; add_filter ( 'plugin_row_meta' , [ $ this , 'plugin_row_meta' ] , 10 , 2 ) ; add_filter ( 'wp_link_query' , [ $ this , 'wp_link_query' ] ) ; add_filter ( 'wp_refresh_nonces' , [ $ this , 'wp_refresh_nonces' ] , 11 ) ; add_filter ( 'pre_update_option' , [ $ this , 'update_front_page' ] , 10 , 2 ) ; } 
public function update_front_page ( $ value , $ option ) { if ( $ option !== 'page_on_front' ) { return $ value ; } $ front_pages = papi_get_all_entry_types ( [ 'types' => [ 'front-page' ] , ] ) ; if ( count ( $ front_pages ) === 0 ) { return $ value ; } $ old_page_type_id = papi_get_page_type_id ( $ value ) ; $ new_page_type_id = $ front_pages [ 0 ] -> get_id ( ) ; 
public function wp_link_query ( array $ results ) { foreach ( $ results as $ index => $ value ) { $ post_type = papi_get_post_type ( $ value [ 'ID' ] ) ; $ name = papi_get_page_type_name ( $ value [ 'ID' ] ) ; if ( empty ( $ name ) ) { $ name = papi_filter_settings_standard_page_type_name ( $ post_type ) ; } $ results [ $ index ] [ 'info' ] = esc_html ( $ name ) ; } return $ results ; } 
public function format_value ( $ value , $ slug , $ post_id ) { if ( is_numeric ( $ value ) && intval ( $ value ) !== 0 ) { $ value = [ 'module' => get_post ( $ value ) , 'template' => papi_data_get ( $ post_id , sprintf ( '%s_template' , unpapify ( $ this -> html_name ( ) ) ) ) ] ; if ( papi_is_admin ( ) ) { return ( object ) $ value ; } 
protected function get_posts ( $ post_type = null ) { $ query = $ this -> get_setting ( 'query' ) ; 
protected function get_templates ( $ id ) { if ( empty ( $ id ) && ! is_numeric ( $ id ) ) { return [ ] ; } if ( $ data = papi_get_entry_type_by_meta_id ( $ id ) ) { $ templates = papi_to_array ( $ data -> template ) ; ksort ( $ templates ) ; return $ templates ; } return [ ] ; } 
public function html ( ) { $ layout = $ this -> get_setting ( 'layout' ) ; $ post_type = $ this -> get_post_type ( ) ; $ settings = $ this -> get_settings ( ) ; $ value = $ this -> get_value ( ) ; $ posts = $ this -> get_posts ( $ post_type ) ; $ selected_post_id = is_object ( $ value ) ? $ value -> module : 0 ; $ selected_post_id = is_object ( $ selected_post_id ) ? $ selected_post_id -> ID : 0 ; $ templates = $ this -> get_templates ( $ selected_post_id ) ; $ selected_template = is_object ( $ value ) ? intval ( $ value -> template ) : null ; $ classes = '' ; if ( $ settings -> select2 ) { $ classes .= ' papi-component-select2' ; } ?> <div class="papi-property-module papi-property-post advanced"> <table class="papi-table"> <tr> <td> <label for="<?php echo esc_attr ( $ this -> html_id ( ) ) ; ?>_modules"> <?php echo esc_html ( $ settings -> labels [ 'select_module' ] ) ; ?> </label> </td> <td> <?php $ placeholder = ! is_null ( $ settings -> placeholder ) ? $ settings -> placeholder : '' ; ?> <select class="<?php echo esc_attr ( $ classes ) ; ?> papi-property-module-right" id="<?php echo esc_attr ( $ this -> html_id ( ) ) ; ?>_modules" name="<?php echo esc_attr ( $ this -> html_name ( ) ) ; ?>" data-allow-clear="<?php echo empty ( $ settings -> placeholder ) ? 'false' : 'true' ; ?>" data-select-item="<?php echo esc_attr ( $ settings -> labels [ 'select_module' ] ) ; ?>" data-placeholder="<?php echo esc_attr ( $ settings -> placeholder ) ; ?>" data-width="100%" > <?php if ( ! empty ( $ settings -> placeholder ) ) : ?> <?php if ( $ settings -> new_url ) : ?> <option data-placeholder data-new-url="<?php echo esc_attr ( admin_url ( 'post-new.php?post_type=' . $ post_type ) ) ; ?>"></option> <?php else : ?> <option></option> <?php endif ; ?> <?php endif ; ?> <?php foreach ( $ posts as $ post ) { if ( papi_is_empty ( $ post -> post_title ) ) { continue ; } papi_render_html_tag ( 'option' , [ 'data-entry-type' => get_post_meta ( $ post -> ID , papi_get_page_type_key ( ) , true ) , 'data-edit-url' => get_edit_post_link ( $ value ) , 'data-new-url' => $ settings -> new_url ? admin_url ( 'post-new.php?post_type=' . $ post -> post_type ) : '' , 'selected' => $ selected_post_id === $ post -> ID , 'value' => $ post -> ID , $ post -> post_title ] ) ; } ?> </select> </td> </tr> <tr> <td> <label for="<?php echo esc_attr ( $ this -> html_id ( ) ) ; ?>_template"> <?php echo esc_html ( $ settings -> labels [ 'select_template' ] ) ; ?> </label> </td> <td> <select id="<?php echo esc_attr ( $ this -> html_id ( ) ) ; ?>_template" name="<?php echo esc_attr ( $ this -> html_name ( ) ) ; ?>_template" class="<?php echo esc_attr ( $ classes ) ; ?> papi-property-module-left" data-post-query='<?php echo esc_attr ( papi_maybe_json_encode ( $ settings -> query ) ) ; ?>' data-width="100%" > <?php foreach ( $ templates as $ index => $ item ) { </select> </td> </tr> </table> </div> <?php } 
public function render_option_template ( ) { $ settings = $ this -> get_settings ( ) ; $ post_type = $ this -> get_post_type ( ) ; ?> <script type="text/template" id="tmpl-papi-property-module-option"> <option data-allow-clear="<?php echo esc_attr ( $ settings -> allow_clear ) ; ?>" value="<%= value %>" > <%= title %> </option> </script> <script type="text/template" id="tmpl-papi-property-module-option-placeholder"> <option data-placeholder <?php if ( $ settings -> new_url ) : ?> data-new-url="<?php echo esc_attr ( admin_url ( 'post-new.php?post_type=' . $ post_type ) ) ; ?>" <?php endif ; ?> > </option> </script> <?php } 
public function html ( ) { $ settings = $ this -> get_settings ( ) ; $ html = papi_maybe_get_callable_value ( $ settings -> html ) ; if ( $ settings -> save ) { $ value = $ this -> get_value ( ) ; if ( ! empty ( $ value ) && is_string ( $ value ) ) { $ html = $ value ; } papi_render_html_tag ( 'input' , [ 'name' => esc_attr ( $ this -> html_name ( ) ) , 'type' => 'hidden' , 'value' => $ html ] ) ; } papi_render_html_tag ( 'div' , [ 'data-papi-rule' => esc_attr ( $ this -> html_name ( ) ) , 'class' => 'property-html' , $ html ] ) ; } 
protected function setup_args ( array $ args ) { foreach ( $ args as $ key => $ value ) { if ( isset ( $ this -> $ key ) ) { $ this -> $ key = papi_esc_html ( $ value ) ; } } if ( empty ( $ this -> id ) ) { $ this -> id = strtolower ( papi_f ( papi_underscorify ( papify ( $ this -> title ) ) ) ) ; } } 
public function format_value ( $ value , $ slug , $ post_id ) { if ( ! $ this -> get_setting ( 'allow_html' ) ) { $ value = maybe_unserialize ( $ value ) ; if ( ! is_string ( $ value ) ) { $ value = '' ; } $ value = wp_strip_all_tags ( $ value ) ; if ( ! papi_is_admin ( ) ) { $ value = $ this -> get_setting ( 'nl2br' ) ? nl2br ( $ value ) : $ value ; } } return $ value ; } 
public function html ( ) { papi_render_html_tag ( 'textarea' , [ 'class' => 'papi-property-text' , 'id' => esc_attr ( $ this -> html_id ( ) ) , 'name' => esc_attr ( $ this -> html_name ( ) ) , $ this -> get_value ( ) ] ) ; } 
public function get_property ( $ slug , $ child_slug = '' ) { $ page_type_id = papi_get_page_type_id ( $ this -> id ) ; $ page_type = papi_get_entry_type_by_id ( $ page_type_id ) ; if ( $ page_type instanceof Papi_Page_Type === false ) { return ; } if ( $ property = $ page_type -> get_property ( $ slug , $ child_slug ) ) { return $ this -> prepare_property ( $ property ) ; } } 
protected function prepare_load_value ( Papi_Core_Property $ property , $ value ) { if ( $ property -> overwrite ) { 
public function save_properties ( ) { if ( $ _SERVER [ 'REQUEST_METHOD' ] !== 'POST' || papi_get_meta_type ( ) !== 'option' ) { return ; } * Fire `save_properties` action when all is done. * * @param int $id * @param string $meta_type */ do_action ( 'papi/save_properties' , 0 , 'option' ) ; } 
public function metabox ( ) { $ post_type = papi_get_post_type ( ) ; $ page_type = papi_get_entry_type_by_id ( papi_get_page_type_id ( ) ) ; $ page_type_key = papi_get_page_type_key ( 'switch' ) ; $ page_types = papi_get_all_page_types ( $ post_type ) ; $ show_standard = papi_filter_settings_show_standard_page_type ( $ post_type ) ; if ( $ show_standard ) { $ standard_page_type = papi_get_standard_page_type ( $ post_type ) ; $ page_types [ ] = $ standard_page_type ; if ( empty ( $ page_type ) ) { $ page_type = $ standard_page_type ; } } usort ( $ page_types , function ( $ a , $ b ) { return strcmp ( $ a -> name , $ b -> name ) ; } ) ; $ page_types = papi_sort_order ( array_reverse ( $ page_types ) ) ; <div class="misc-pub-section misc-pub-section-last papi-page-type-switcher"> <label for="<?php echo esc_attr ( $ page_type_key ) ; ?>"><?php esc_html_e ( 'Page Type:' , 'papi' ) ; ?></label> <span><?php echo esc_html ( $ page_type -> name ) ; ?></span> <?php if ( papi_current_user_is_allowed ( $ page_type -> capabilities ) && $ page_type -> switcher ) : ?> <a href="#" id="papi-page-type-switcher-edit" class="hide-if-no-js"><?php esc_html_e ( 'Edit' , 'papi' ) ; ?></a> <div> <select name="<?php echo esc_attr ( $ page_type_key ) ; ?>" id="<?php echo esc_attr ( $ page_type_key ) ; ?>"> <?php foreach ( $ page_types as $ pt ) { if ( ! papi_current_user_is_allowed ( $ pt -> capabilities ) ) { continue ; } papi_render_html_tag ( 'option' , [ 'selected' => $ page_type -> match_id ( $ pt -> get_id ( ) ) , 'value' => esc_attr ( $ pt -> get_id ( ) ) , esc_html ( $ pt -> name ) ] ) ; } ?> </select> <a href="#" id="papi-page-type-switcher-save" class="hide-if-no-js button"><?php esc_html_e ( 'OK' , 'papi' ) ; ?></a> <a href="#" id="papi-page-type-switcher-cancel" class="hide-if-no-js"><?php esc_html_e ( 'Cancel' , 'papi' ) ; ?></a> </div> <?php endif ; ?> </div> <?php } 
public function save_post ( $ post_id , $ post ) { 
protected function overwrite_post_data ( $ post_id ) { global $ wpdb ; if ( empty ( $ post_id ) || empty ( $ this -> overwrite ) ) { return ; } $ wpdb -> update ( $ wpdb -> posts , $ this -> overwrite , [ 'ID' => $ post_id ] ) ; 
protected function pre_save ( $ id ) { if ( empty ( $ id ) ) { return ; } $ data = $ this -> get_pre_data ( ) ; foreach ( $ data as $ key => $ value ) { if ( empty ( $ value ) ) { continue ; } if ( is_array ( $ value ) ) { list ( $ keys , $ value ) = $ this -> get_pre_deep_keys_value ( $ value ) ; $ key = sprintf ( '%s_%s' , $ key , implode ( '_' , $ keys ) ) ; } update_metadata ( $ this -> get_meta_type ( ) , $ id , $ key , $ value ) ; } } 
public function save_meta_boxes ( $ id , $ post = null ) { 
public function save_revision ( $ revision_id ) { 
public function save_properties ( $ id ) { * Fire `save_properties` action when all is done. * * @param int $id * @param string $meta_type */ do_action ( 'papi/save_properties' , $ id , $ meta_type ) ; } 
public function restore_post_revision ( $ post_id , $ revision_id ) { if ( papi_is_empty ( papi_get_entry_type_by_meta_id ( $ post_id , 'post' ) ) ) { return ; } $ meta = get_post_meta ( $ revision_id ) ; foreach ( $ meta as $ key => $ value ) { if ( $ key [ 0 ] === '_' && $ key !== papi_get_page_type_key ( ) ) { continue ; } papi_data_update ( $ post_id , $ key , array_shift ( $ value ) ) ; } } 
protected function setup_actions ( ) { add_action ( '_wp_put_post_revision' , [ $ this , 'save_revision' ] ) ; add_action ( 'save_post' , [ $ this , 'save_meta_boxes' ] , 1 , 2 ) ; add_action ( 'created_term' , [ $ this , 'save_meta_boxes' ] , 1 ) ; add_action ( 'edit_term' , [ $ this , 'save_meta_boxes' ] , 1 ) ; add_action ( 'wp_restore_post_revision' , [ $ this , 'restore_post_revision' ] , 10 , 2 ) ; } 
protected function valid_post_id ( $ post_id ) { $ key = papi_get_sanitized_post ( 'action' ) === 'save-attachment-compat' ? 'id' : 'post_ID' ; $ val = papi_get_sanitized_post ( $ key ) ; 
public function display ( array $ rules , $ property = null ) { if ( empty ( $ rules ) ) { return true ; } $ rules = $ this -> prepare_rules ( $ rules , $ property ) ; if ( in_array ( $ rules [ 'relation' ] , $ this -> relations , true ) ) { return $ this -> display_by_relation ( $ rules ) ; } return true ; } 
protected function display_by_relation ( array $ rules ) { if ( $ rules [ 'relation' ] === 'AND' ) { $ display = true ; foreach ( $ rules as $ rule ) { if ( ! $ display ) { break ; } if ( papi_is_rule ( $ rule ) ) { $ display = apply_filters ( 'papi/conditional/rule_allowed' , papi_filter_conditional_rule_allowed ( $ rule ) , $ rule ) ; } } return $ display ; } $ empty = array_filter ( $ rules , function ( $ rule ) { return papi_is_rule ( $ rule ) ? true : null ; } ) ; if ( empty ( $ empty ) ) { return true ; } $ result = [ ] ; foreach ( $ rules as $ rule ) { if ( papi_is_rule ( $ rule ) ) { $ result [ ] = apply_filters ( 'papi/conditional/rule_allowed' , papi_filter_conditional_rule_allowed ( $ rule ) , $ rule ) ; } } $ result = array_filter ( $ result , function ( $ res ) { return $ res === true ? true : null ; } ) ; return ! empty ( $ result ) ; } 
protected function get_rule_slug ( $ rule , $ property ) { $ arr_reg = '/\[\d+\](\[\w+\])$/' ; $ slug = $ property -> get_slug ( ) ; $ page_type = papi_get_entry_type_by_meta_id ( ) ; if ( $ page_type instanceof Papi_Page_Type === false ) { return $ rule -> slug ; } if ( preg_match ( $ arr_reg , $ slug , $ out ) ) { $ slug = str_replace ( $ out [ 1 ] , '[' . unpapify ( $ rule -> slug ) . ']' , $ slug ) ; $ property = $ page_type -> get_property ( $ slug ) ; if ( papi_is_property ( $ property ) ) { return $ slug ; } } return $ rule -> slug ; } 
public function prepare_rules ( array $ rules , $ property = null ) { if ( ! isset ( $ rules [ 'relation' ] ) ) { $ rules [ 'relation' ] = 'OR' ; } else { $ rules [ 'relation' ] = strtoupper ( $ rules [ 'relation' ] ) ; } foreach ( $ rules as $ index => $ value ) { if ( is_string ( $ index ) ) { continue ; } if ( is_array ( $ value ) ) { $ rules [ $ index ] = new Papi_Core_Conditional_Rule ( $ value ) ; if ( strpos ( $ rules [ $ index ] -> slug , '.' ) === false && papi_is_property ( $ property ) ) { $ rules [ $ index ] -> slug = $ this -> get_rule_slug ( $ rules [ $ index ] , $ property ) ; } } } return $ rules ; } 
public function allowed ( ) { $ args = func_get_args ( ) ; if ( empty ( $ args ) ) { return parent :: allowed ( ) ; } return papi_current_user_is_allowed ( $ this -> capabilities ) && isset ( $ args [ 0 ] ) && in_array ( $ args [ 0 ] , $ this -> post_type , true ) ; } 
public function get_body_classes ( ) { $ classes = parent :: get_body_classes ( ) ; if ( ! $ this -> show_permalink ) { $ classes [ ] = 'papi-hide-edit-slug-box' ; } if ( ! $ this -> show_page_attributes ) { $ classes [ ] = 'papi-hide-pageparentdiv' ; } return $ classes ; } 
public function get_child_types ( ) { $ child_types = [ ] ; foreach ( papi_to_array ( $ this -> child_types ) as $ id ) { $ child_type = papi_get_entry_type_by_id ( $ id ) ; if ( $ child_type instanceof Papi_Page_Type ) { $ child_types [ ] = $ child_type ; } } return $ child_types ; } 
public function get_labels ( ) { if ( ! $ this -> fill_labels ) { return $ this -> labels ; } return array_merge ( $ this -> labels , [ 'add_new_item' => sprintf ( '%s %s' , __ ( 'Add New' , 'papi' ) , $ this -> name ) , 'edit_item' => sprintf ( '%s %s' , __ ( 'Edit' , 'papi' ) , $ this -> name ) , 'view_item' => sprintf ( '%s %s' , __ ( 'View' , 'papi' ) , $ this -> name ) ] ) ; } 
protected function get_post_type_supports ( ) { $ supports = [ 'custom-fields' ] ; if ( method_exists ( $ this , 'remove' ) ) { $ output = $ this -> remove ( ) ; $ output = is_string ( $ output ) ? [ $ output ] : $ output ; $ output = is_array ( $ output ) ? $ output : [ ] ; $ output = array_filter ( $ output , 'is_string' ) ; $ supports = array_merge ( $ supports , $ output ) ; } $ parent_class = get_parent_class ( $ this ) ; $ parent_remove = method_exists ( $ parent_class , 'remove' ) ; while ( $ parent_remove ) { $ parent = new $ parent_class ( ) ; $ output = $ parent -> remove ( ) ; $ output = is_string ( $ output ) ? [ $ output ] : $ output ; $ output = is_array ( $ output ) ? $ output : [ ] ; $ output = array_filter ( $ output , 'is_string' ) ; $ supports = array_merge ( $ supports , $ output ) ; $ parent_class = get_parent_class ( $ parent_class ) ; $ parent_remove = method_exists ( $ parent_class , 'remove' ) ; } return $ supports ; } 
public function remove_post_type_support ( ) { global $ _wp_post_type_features ; $ post_type = $ this -> get_post_type ( ) ; if ( empty ( $ post_type ) ) { return ; } $ post_type_supports = $ this -> get_post_type_supports ( ) ; foreach ( $ post_type_supports as $ key => $ value ) { if ( is_numeric ( $ key ) ) { $ key = $ value ; $ value = '' ; } if ( isset ( $ _wp_post_type_features [ $ post_type ] , $ _wp_post_type_features [ $ post_type ] [ $ key ] ) ) { unset ( $ _wp_post_type_features [ $ post_type ] [ $ key ] ) ; continue ; } if ( in_array ( strtolower ( $ key ) , [ 'all' , 'normal' , 'side' , 'advanced' ] , true ) ) { $ value = strtolower ( $ key ) ; } else if ( empty ( $ value ) ) { $ value = 'normal' ; } $ this -> remove_meta_boxes [ ] = [ $ key , $ value ] ; } add_action ( 'add_meta_boxes' , [ $ this , 'remove_meta_boxes' ] , 999 ) ; } 
public function remove_meta_boxes ( ) { global $ wp_meta_boxes ; $ post_type = $ this -> get_post_type ( ) ; $ context = [ ] ; foreach ( $ this -> remove_meta_boxes as $ item ) { if ( $ item [ 0 ] !== $ item [ 1 ] ) { remove_meta_box ( $ item [ 0 ] , $ post_type , $ item [ 1 ] ) ; continue ; } $ context = $ item [ 0 ] ; 
public function setup ( ) { parent :: setup ( ) ; 
protected function setup_post_types ( ) { $ this -> post_type = papi_to_array ( $ this -> post_type ) ; 
protected function setup_page_templates ( ) { if ( ! is_array ( $ this -> template ) || ! $ this -> has_post_type ( papi_get_post_type ( ) ) ) { return ; } $ this -> show_page_template = true ; foreach ( $ this -> post_type as $ post_type ) { 
protected function add_mce_buttons ( ) { for ( $ i = 0 ; $ i < 4 ; $ i ++ ) { $ num = $ i === 0 ? '' : '_' . ( $ i + 1 ) ; add_filter ( 'mce_buttons' . $ num , [ $ this , 'mce_buttons' ] ) ; } } 
public function html ( ) { $ value = $ this -> get_value ( ) ; $ value = html_entity_decode ( $ value ) ; $ id = str_replace ( '[' , '' , str_replace ( ']' , '' , $ this -> html_name ( ) ) ) . '-' . uniqid ( ) ; 
protected function reove_mce_buttons ( ) { for ( $ i = 0 ; $ i < 4 ; $ i ++ ) { $ num = $ i === 0 ? '' : '_' . ( $ i + 1 ) ; remove_filter ( 'mce_buttons' . $ num , [ $ this , 'mce_buttons' ] ) ; } } 
public function delete_value ( $ slug , $ post_id , $ type ) { $ rows = intval ( papi_data_get ( $ post_id , $ slug , $ type ) ) ; $ value = $ this -> load_value ( $ rows , $ slug , $ post_id ) ; $ value = papi_property_to_array_slugs ( $ value , $ slug ) ; $ result = true ; foreach ( array_keys ( $ value ) as $ key ) { $ out = papi_data_delete ( $ post_id , $ key , $ type ) ; $ result = $ out ? $ result : $ out ; } return $ result ; } 
public function format_value ( $ values , $ repeater_slug , $ post_id ) { if ( ! is_array ( $ values ) ) { return [ ] ; } $ top_property = new Papi_Core_Property ; foreach ( $ values as $ index => $ row ) { if ( ! is_array ( $ row ) ) { continue ; } $ top_property -> slug = $ repeater_slug . '_' . $ index ; foreach ( $ row as $ slug => $ value ) { if ( papi_is_property_type_key ( $ slug ) ) { continue ; } 
protected function get_results ( $ value , $ repeater_slug , $ post_id ) { global $ wpdb ; if ( $ this -> get_meta_type ( ) === 'option' ) { $ table = $ wpdb -> prefix . 'options' ; 
protected function get_row_results ( $ dbresults ) { $ results = [ ] ; $ is_option = $ this -> get_meta_type ( ) === 'option' ; foreach ( $ dbresults as $ meta ) { if ( $ is_option ) { preg_match ( '/^[^\d]*(\d+)/' , $ meta -> option_name , $ matches ) ; } else { preg_match ( '/^[^\d]*(\d+)/' , $ meta -> meta_key , $ matches ) ; } if ( count ( $ matches ) < 2 ) { continue ; } $ i = intval ( $ matches [ 1 ] ) ; if ( ! isset ( $ results [ $ i ] ) ) { $ results [ $ i ] = [ ] ; } if ( $ is_option ) { $ results [ $ i ] [ $ meta -> option_name ] = ( object ) [ 'meta_key' => $ meta -> option_name , 'meta_value' => $ meta -> option_value ] ; } else { $ results [ $ i ] [ $ meta -> meta_key ] = $ meta ; } } return $ results ; } 
protected function get_settings_properties ( ) { $ settings = $ this -> get_settings ( ) ; if ( is_null ( $ settings ) ) { return [ ] ; } return $ this -> prepare_properties ( papi_to_array ( $ settings -> items ) ) ; } 
public function html ( ) { $ options = $ this -> get_options ( ) ; 
public function load_value ( $ value , $ repeater_slug , $ post_id ) { if ( is_array ( $ value ) ) { return $ value ; } list ( $ results , $ trash ) = $ this -> get_results ( $ value , $ repeater_slug , $ post_id ) ; 
protected function load_child_properties ( array $ results , $ property = null ) { foreach ( $ results as $ index => $ row ) { foreach ( $ row as $ slug => $ value ) { if ( is_array ( $ value ) && isset ( $ value [ $ slug ] ) ) { $ child_property = $ this -> get_store ( ) -> get_property ( $ this -> get_slug ( true ) , $ slug ) ; if ( papi_is_property ( $ child_property ) && ! empty ( $ child_property -> get_child_properties ( ) ) ) { $ value = papi_from_property_array_slugs ( $ value , unpapify ( $ slug ) ) ; $ results [ $ index ] [ $ slug ] = $ this -> load_child_properties ( $ value , $ child_property ) ; } } $ type_key = papi_get_property_type_key_f ( $ slug ) ; if ( $ property -> match_slug ( $ slug ) ) { $ results [ $ index ] [ $ type_key ] = $ property ; } else { $ results [ $ index ] [ $ type_key ] = $ property -> get_child_property ( $ slug ) ; } } } return $ results ; } 
protected function prepare_properties ( $ items ) { $ key = isset ( $ this -> layout_key ) && $ this -> layout_key === '_layout' ? 'flexible' : 'repeater' ; $ items = array_map ( 'papi_property' , $ items ) ; $ exclude_properties = $ this -> exclude_properties ; $ exclude_properties = array_merge ( $ exclude_properties , apply_filters ( 'papi/property/' . $ key . '/exclude' , [ ] ) ) ; return array_filter ( $ items , function ( $ item ) use ( $ exclude_properties ) { if ( ! is_object ( $ item ) ) { return false ; } if ( empty ( $ item -> type ) ) { return false ; } return ! in_array ( $ item -> type , $ exclude_properties , true ) ; } ) ; } 
protected function prepare_property_for_json ( $ property ) { 
protected function remove_repeater_rows ( $ post_id , $ repeater_slug ) { global $ wpdb ; $ is_option = $ this -> get_meta_type ( ) === 'option' ; $ repeater_slug = $ repeater_slug . '_%' ; if ( $ is_option ) { $ table = $ wpdb -> prefix . 'options' ; 
public function render_ajax_request ( ) { $ items = $ this -> get_settings_properties ( ) ; if ( papi_doing_ajax ( ) ) { $ counter = papi_get_qs ( 'counter' ) ; $ this -> counter = intval ( $ counter ) ; } $ this -> render_properties ( $ items , false ) ; } 
protected function render_json_template ( $ slug ) { $ options = $ this -> get_options ( ) ; $ options -> settings -> items = papi_to_array ( $ options -> settings -> items ) ; foreach ( $ options -> settings -> items as $ key => $ value ) { $ property = $ this -> prepare_property_for_json ( papi_property ( $ value ) ) ; if ( $ property === false ) { unset ( $ options -> settings -> items [ $ key ] ) ; continue ; } $ options -> settings -> items [ $ key ] = $ property ; } papi_render_html_tag ( 'script' , [ 'data-papi-json' => esc_attr ( sprintf ( '%s_repeater_json' , $ slug ) ) , 'type' => 'application/json' , papi_maybe_json_encode ( [ $ options ] ) ] ) ; } 
protected function render_properties ( $ row , $ value ) { $ layout = $ this -> get_setting ( 'layout' ) ; if ( $ layout === 'row' ) : ?> <td class="repeater-layout-row"> <div class="repeater-content-open"> <table class="papi-table"> <tbody> <?php endif ; $ has_value = $ value !== false ; foreach ( $ row as $ property ) { </tbody> </table> </div> </td> <?php endif ; } 
protected function render_repeater ( $ options ) { ?> <div class="papi-property-repeater papi-property-repeater-top" data-limit="<?php echo esc_attr ( $ this -> get_setting ( 'limit' ) ) ; ?>"> <table class="papi-table"> <?php $ this -> render_repeater_head ( ) ; ?> <tbody class="repeater-tbody"> <?php $ this -> render_repeater_rows ( ) ; ?> </tbody> </table> <div class="bottom"> <?php papi_render_html_tag ( 'button' , [ 'class' => 'button button-primary' , 'data-papi-json' => sprintf ( '%s_repeater_json' , $ options -> slug ) , 'type' => 'button' , esc_html ( $ this -> get_setting ( 'add_new_label' ) ) ] ) ; ?> </div> <?php ?> <input type="hidden" data-papi-rule="<?php echo esc_attr ( $ options -> slug ) ; ?>" name="<?php echo esc_attr ( $ options -> slug ) ; ?>[]" /> </div> <?php } 
protected function render_repeater_head ( ) { $ properties = $ this -> get_settings_properties ( ) ; ?> <thead> <?php if ( ! $ this -> layout ( 'row' ) ) : ?> <tr> <th></th> <?php foreach ( $ properties as $ property ) : <th class="repeater-column <?php echo $ property -> display ( ) ? '' : 'papi-hide' ; ?>"> <?php echo esc_html ( $ property -> title ) ; ?> </th> <?php endforeach ; ?> <th class="last"></th> </tr> <?php endif ; ?> </thead> <?php } 
protected function render_repeater_rows ( ) { $ items = $ this -> get_settings_properties ( ) ; $ values = $ this -> get_value ( ) ; $ values = is_array ( $ values ) ? $ values : [ ] ; $ slugs = wp_list_pluck ( $ items , 'slug' ) ; <tr <?php echo $ closed_rows ? 'class="closed"' : '' ; ?>> <td class="handle"> <span class="toggle"></span> <span class="count"><?php echo esc_html ( $ this -> counter + 1 ) ; ?></span> </td> <?php $ this -> render_properties ( $ items , $ row ) ; $ this -> counter ++ ; ?> <td class="last"> <span> <a title="<?php esc_attr_e ( 'Remove' , 'papi' ) ; ?>" href="#" class="repeater-remove-item">x</a> </span> </td> </tr> <?php endforeach ; } 
public function update_value ( $ values , $ repeater_slug , $ post_id ) { $ rows = intval ( papi_data_get ( $ post_id , $ repeater_slug , $ this -> get_meta_type ( ) ) ) ; if ( ! is_array ( $ values ) ) { $ values = [ ] ; } list ( $ results , $ trash ) = $ this -> get_results ( $ rows , $ repeater_slug , $ post_id ) ; 
public function register ( ) { 
public function get_setting ( $ key , $ value ) { $ property = null ; foreach ( ( array ) $ this -> entries as $ entry ) { if ( $ property = $ entry -> get_property ( $ key ) ) { break ; } } if ( is_null ( $ property ) ) { return $ value ; } $ value = papi_get_option ( $ key ) ; return $ property -> rest_prepare_value ( $ value ) ; } 
public function prepare_response ( $ response ) { $ response = ( array ) $ response ; foreach ( $ response as $ key => $ value ) { $ setting = $ this -> get_setting ( $ key , $ value ) ; if ( $ setting !== $ value ) { $ response [ $ key ] = $ setting ; } } return $ response ; } 
public function format_value ( $ value , $ slug , $ post_id ) { if ( is_object ( $ value ) && isset ( $ value -> ID ) ) { $ value = $ value -> ID ; } if ( is_numeric ( $ value ) ) { return $ value === 0 ? null : new WP_User ( $ value ) ; } return $ value ; } 
public function get_value ( ) { $ user = parent :: get_value ( ) ; if ( is_object ( $ user ) && isset ( $ user -> ID ) ) { return $ user -> ID ; } return 0 ; } 
public function get_items ( ) { $ capabilities = papi_to_array ( $ this -> get_setting ( 'capabilities' ) ) ; $ users = get_users ( ) ; $ items = [ ] ; foreach ( $ users as $ user ) { $ allcaps = $ user -> allcaps ; if ( count ( array_diff ( $ capabilities , array_keys ( $ allcaps ) ) ) === 0 ) { $ items [ $ user -> display_name ] = $ user -> ID ; } } ksort ( $ items ) ; return $ items ; } 
public function update_value ( $ value , $ slug , $ post_id ) { if ( $ value instanceof WP_User ) { $ value = $ value -> ID ; } return ( int ) $ value ; } 
protected function constants ( ) { 
protected function init ( ) { 
protected function load_textdomain ( ) { $ locale = function_exists ( 'get_user_local' ) ? get_user_local ( ) : get_locale ( ) ; $ locale = apply_filters ( 'plugin_locale' , $ locale , 'papi' ) ; load_textdomain ( 'papi' , WP_LANG_DIR . '/papi/papi-' . $ locale . '.mo' ) ; load_textdomain ( 'papi' , PAPI_PLUGIN_DIR . '../languages/papi-' . $ locale . '.mo' ) ; } 
protected function require_files ( ) { 
public static function deactivate ( ) { 
public function format_value ( $ value , $ slug , $ post_id ) { if ( ! $ this -> get_setting ( 'multiple' ) ) { return $ this -> is_string_items ( ) ? $ value : papi_cast_string_value ( $ value ) ; } $ value = is_array ( $ value ) ? $ value : [ ] ; if ( ! $ this -> is_string_items ( ) ) { $ value = array_map ( 'papi_cast_string_value' , $ value ) ; } return $ value ; } 
public function is_string_items ( ) { $ items = $ this -> get_items ( ) ; if ( empty ( $ items ) ) { return false ; } $ items = array_values ( $ items ) ; return is_string ( $ items [ 0 ] ) ; } 
public function html ( ) { 
public function load_value ( $ value , $ slug , $ post_id ) { $ value = maybe_unserialize ( $ value ) ; return papi_maybe_json_decode ( $ value , $ this -> get_setting ( 'multiple' ) ) ; } 
public function format_value ( $ value , $ slug , $ post_id ) { if ( ! is_array ( $ value ) ) { return [ ] ; } 
protected function get_settings_properties ( ) { $ settings = $ this -> get_settings ( ) ; if ( is_null ( $ settings ) ) { return [ ] ; } return array_filter ( array_map ( 'papi_property' , papi_to_array ( $ settings -> items ) ) , 'papi_is_property' ) ; } 
public function html ( ) { $ properties = $ this -> get_settings_properties ( ) ; $ properties = $ this -> prepare_properties ( $ properties ) ; 
protected function prepare_properties ( $ properties ) { $ result = [ ] ; $ value = $ this -> get_value ( ) ; $ value = is_array ( $ value ) ? $ value : [ ] ; foreach ( $ properties as $ property ) { $ render_property = clone $ property -> get_options ( ) ; $ value_slug = $ property -> get_slug ( true ) ; if ( array_key_exists ( $ value_slug , $ value ) ) { $ render_property -> value = $ value [ $ value_slug ] ; } else { $ render_property -> value = null ; } $ render_property -> slug = $ this -> html_name ( $ property ) ; $ result [ ] = $ render_property ; } return $ result ; } 
public function update_value ( $ values , $ slug , $ post_id ) { if ( ! isset ( $ values [ 0 ] ) && ! empty ( $ values ) ) { $ values = [ $ values ] ; } return parent :: update_value ( $ values , $ slug , $ post_id ) ; } 
public function format_value ( $ value , $ slug , $ post_id ) { if ( ! is_array ( $ value ) ) { $ value = $ this -> get_file ( $ value ) ; } 
public function get_file ( $ value ) { $ meta_key = $ this -> get_setting ( 'meta_key' ) ; if ( empty ( $ meta_key ) ) { if ( is_numeric ( $ value ) && intval ( $ value ) !== 0 ) { $ post = get_post ( $ value ) ; } } else if ( ! empty ( $ value ) ) { $ args = [ 'fields' => 'ids' , 'meta_key' => $ meta_key , 'meta_value' => $ value , 'posts_per_page' => 1 , 'post_type' => 'attachment' , 'post_status' => 'any' ] ; $ query = new WP_Query ( $ args ) ; if ( ! empty ( $ query -> posts ) ) { $ post = get_post ( $ query -> posts [ 0 ] ) ; } } if ( empty ( $ post ) ) { return $ value ; } return $ post -> ID ; } 
protected function get_file_value ( $ value ) { $ meta_key = $ this -> get_setting ( 'meta_key' ) ; if ( ! is_object ( $ value ) ) { return 0 ; } if ( empty ( $ meta_key ) ) { return $ value -> id ; } if ( $ value = get_post_meta ( $ value -> id , $ meta_key , true ) ) { return $ value ; } return 0 ; } 
public function html ( ) { $ css_classes = '' ; $ labels = $ this -> get_labels ( ) ; $ settings = $ this -> get_settings ( ) ; $ slug = $ this -> html_name ( ) ; $ value = papi_to_array ( $ this -> get_value ( ) ) ; <div class="papi-property-file <?php echo esc_attr ( $ css_classes ) ; ?>" data-file-type="<?php echo esc_attr ( $ this -> file_type ) ; ?>"> <p class="papi-file-select <?php echo $ show_button ? '' : 'papi-hide' ; ?>"> <?php if ( ! $ settings -> multiple ) { echo esc_html ( $ labels [ 'no_file' ] ) . '&nbsp;' ; } papi_render_html_tag ( 'input' , [ 'name' => esc_attr ( $ slug ) , 'type' => 'hidden' , 'value' => '' ] ) ; papi_render_html_tag ( 'button' , [ 'data-slug' => esc_attr ( $ slug ) , 'class' => 'button' , 'type' => 'button' , esc_html ( $ labels [ 'add' ] ) ] ) ; ?> </p> <div class="attachments"> <?php if ( is_array ( $ value ) ) : foreach ( $ value as $ file ) : if ( ! is_object ( $ file ) ) { continue ; } $ url = wp_get_attachment_thumb_url ( $ file -> id ) ; if ( empty ( $ url ) ) { $ url = wp_mime_type_icon ( $ file -> id ) ; } ?> <div class="attachment"> <a class="check" href="#">&times;</a> <div class="attachment-preview"> <div class="thumbnail"> <div class="centered"> <?php papi_render_html_tag ( 'img' , [ 'alt' => esc_attr ( $ file -> alt ) , 'src' => esc_attr ( $ url ) ] ) ; papi_render_html_tag ( 'input' , [ 'name' => esc_attr ( $ slug ) , 'type' => 'hidden' , 'value' => $ file -> id ] ) ; if ( ! isset ( $ file -> file ) && isset ( $ file -> url ) ) { $ file -> file = $ file -> url ; } ?> </div> <?php if ( $ this -> file_type === 'file' ) : ?> <div class="filename"> <div><?php echo esc_html ( basename ( $ file -> file ) ) ; ?></div> </div> <?php endif ; ?> </div> </div> </div> <?php endforeach ; endif ; ?> </div> <div class="clear"></div> </div> <?php } 
public function update_value ( $ values , $ slug , $ post_id ) { if ( ! is_array ( $ values ) ) { $ values = $ this -> get_file_value ( ( object ) [ 'id' => $ values ] ) ; if ( empty ( $ values ) ) { return ; } return $ values ; } foreach ( $ values as $ index => $ value ) { if ( ! is_numeric ( $ value ) ) { continue ; } $ values [ $ index ] = $ this -> get_file_value ( ( object ) [ 'id' => $ value ] ) ; } return array_filter ( $ values ) ; } 
public function bind ( $ id , $ value = null , $ singleton = false ) { if ( is_string ( $ id ) && $ this -> is_singleton ( $ id ) ) { throw new Exception ( sprintf ( 'Identifier `%s` is a singleton and cannot be rebind' , $ id ) ) ; } if ( is_object ( $ id ) && get_class ( $ id ) !== false ) { $ value = $ id ; $ id = $ this -> get_class_prefix ( get_class ( $ id ) , false ) ; $ this -> classes [ $ id ] = true ; } if ( $ value instanceof Closure ) { $ closure = $ value ; } else { $ closure = $ this -> get_closure ( $ value , $ singleton ) ; } $ this -> values [ $ id ] = compact ( 'closure' , 'singleton' ) ; $ this -> keys [ $ id ] = true ; return $ value ; } 
protected function call_closure ( $ closure , array $ parameters = [ ] ) { if ( $ closure instanceof Closure ) { $ rc = new ReflectionFunction ( $ closure ) ; $ args = $ rc -> getParameters ( ) ; $ params = $ parameters ; $ classes = [ $ this -> get_class_prefix ( get_class ( $ this ) ) , get_class ( $ this ) , get_parent_class ( $ this ) ] ; foreach ( $ args as $ index => $ arg ) { if ( $ arg -> getClass ( ) === null ) { continue ; } if ( in_array ( $ arg -> getClass ( ) -> name , $ classes , true ) ) { $ parameters [ $ index ] = $ this ; } else if ( $ this -> exists ( $ arg -> getClass ( ) -> name ) ) { $ parameters [ $ index ] = $ this -> make ( $ arg -> getClass ( ) -> name ) ; } } if ( ! empty ( $ args ) && empty ( $ parameters ) ) { $ parameters [ 0 ] = $ this ; } if ( count ( $ args ) > count ( $ parameters ) ) { $ parameters = array_merge ( $ parameters , $ params ) ; } return $ this -> call_closure ( call_user_func_array ( $ closure , $ parameters ) , $ parameters ) ; } return $ closure ; } 
protected function get_class_prefix ( $ id , $ check = true ) { if ( strpos ( $ id , '\\' ) !== false && $ id [ 0 ] !== '\\' ) { $ class = '\\' . $ id ; if ( $ check ) { return isset ( $ this -> classes [ $ class ] ) ? $ class : $ id ; } return $ class ; } return $ id ; } 
public function is_singleton ( $ id ) { if ( ! is_string ( $ id ) ) { throw new InvalidArgumentException ( 'Invalid argument. Must be string.' ) ; } if ( ! $ this -> exists ( $ id ) ) { return false ; } $ id = $ this -> get_class_prefix ( $ id ) ; return $ this -> values [ $ id ] [ 'singleton' ] === true ; } 
public function make ( $ id , array $ parameters = [ ] ) { if ( ! $ this -> exists ( $ id ) ) { throw new Exception ( sprintf ( 'Identifier `%s` is not defined' , $ id ) ) ; } $ id = $ this -> get_class_prefix ( $ id ) ; $ value = $ this -> values [ $ id ] ; $ closure = $ value [ 'closure' ] ; return $ this -> call_closure ( $ closure , $ parameters ) ; } 
public function once ( $ key , $ callback ) { if ( ! is_string ( $ key ) && ! is_callable ( $ callback ) ) { return ; } if ( ! $ this -> exists ( $ key ) ) { $ result = $ callback ( ) ; $ this -> singleton ( $ key , $ result ) ; } return $ this -> make ( $ key ) ; } 
public function remove ( $ id ) { $ id = $ this -> get_class_prefix ( $ id ) ; unset ( $ this -> keys [ $ id ] , $ this -> values [ $ id ] ) ; } 
protected function override_labels ( Papi_Entry_Type $ entry_type ) { global $ wp_post_types , $ wp_taxonomies ; if ( $ entry_type -> get_type ( ) === 'taxonomy' ) { $ meta_type_value = papi_get_taxonomy ( ) ; } else { $ meta_type_value = papi_get_post_type ( ) ; } if ( empty ( $ meta_type_value ) || ( ! isset ( $ wp_post_types [ $ meta_type_value ] ) && ! isset ( $ wp_taxonomies [ $ meta_type_value ] ) ) ) { return ; } foreach ( $ entry_type -> get_labels ( ) as $ key => $ value ) { if ( empty ( $ value ) ) { continue ; } if ( $ entry_type -> get_type ( ) === 'taxonomy' && isset ( $ wp_taxonomies [ $ meta_type_value ] -> labels -> $ key ) ) { $ wp_taxonomies [ $ meta_type_value ] -> labels -> $ key = $ value ; } else if ( isset ( $ wp_post_types [ $ meta_type_value ] -> labels -> $ key ) ) { $ wp_post_types [ $ meta_type_value ] -> labels -> $ key = $ value ; } } } 
public function page_items_menu ( ) { $ entry_types = papi_get_all_entry_types ( [ 'mode' => 'exclude' , 'types' => 'page' ] ) ; foreach ( $ entry_types as $ entry_type ) { if ( empty ( $ entry_type -> get_menu ( ) ) || empty ( $ entry_type -> name ) ) { continue ; } $ slug = sprintf ( 'papi/%s/%s' , $ entry_type -> get_type ( ) , $ entry_type -> get_id ( ) ) ; add_submenu_page ( $ entry_type -> get_menu ( ) , $ entry_type -> name , $ entry_type -> name , $ entry_type -> capability , $ slug , [ $ entry_type , 'render' ] ) ; } } 
public function post_types_menu ( ) { global $ submenu ; $ post_types = papi_get_post_types ( ) ; foreach ( $ post_types as $ post_type ) { if ( ! post_type_exists ( $ post_type ) ) { continue ; } if ( $ post_type === 'post' ) { $ edit_url = 'edit.php' ; } else { $ edit_url = 'edit.php?post_type=' . $ post_type ; } if ( ! isset ( $ submenu [ $ edit_url ] , $ submenu [ $ edit_url ] [ 10 ] , $ submenu [ $ edit_url ] [ 10 ] [ 2 ] ) ) { $ post_type_object = get_post_type_object ( $ post_type ) ; if ( $ post_type_object -> show_in_menu !== true ) { $ submenu [ $ edit_url ] = [ 10 => [ __ ( 'Add New' , 'papi' ) , 'edit_posts' , 'post-new.php' ] ] ; } else { continue ; } } $ only_page_type = papi_filter_settings_only_page_type ( $ post_type ) ; $ page_types = papi_get_all_page_types ( $ post_type ) ; $ show_standard = false ; 
public function render_view ( ) { if ( strpos ( papi_get_qs ( 'page' ) , 'papi' ) !== false ) { $ page = str_replace ( 'papi-' , '' , papi_get_qs ( 'page' ) ) ; $ res = preg_replace ( '/\,.*/' , '' , $ page ) ; if ( is_string ( $ res ) ) { $ page_view = $ res ; } } if ( ! isset ( $ page_view ) ) { $ page_view = null ; } if ( ! is_null ( $ page_view ) ) { $ view = new Papi_Admin_View ; $ view -> render ( $ page_view ) ; } else { echo '<h2>Papi - 404</h2>' ; } } 
protected function setup_actions ( ) { if ( papi_is_admin ( ) ) { add_action ( 'admin_init' , [ $ this , 'admin_bar_menu' ] ) ; add_action ( 'admin_menu' , [ $ this , 'page_items_menu' ] ) ; add_action ( 'admin_menu' , [ $ this , 'post_types_menu' ] ) ; } else { add_action ( 'admin_bar_menu' , [ $ this , 'admin_bar_menu' ] ) ; } } 
public function autoload ( $ class ) { $ class = strtolower ( $ class ) ; $ file = 'class-' . str_replace ( '_' , '-' , strtolower ( $ class ) ) . '.php' ; $ path = PAPI_PLUGIN_DIR ; if ( strpos ( $ class , 'papi_admin' ) === 0 ) { $ path .= 'admin/' ; } else if ( strpos ( $ class , 'papi_core_' ) === 0 ) { $ path .= 'core/' ; } else if ( strpos ( $ class , 'papi_cli_' ) === 0 ) { $ path .= 'cli/' ; } else if ( preg_match ( '/^papi\_\w+\_store$/' , $ class ) ) { $ path .= 'stores/' ; } else if ( strpos ( $ class , 'papi_property' ) === 0 ) { $ path .= 'properties/' ; } else if ( strpos ( $ class , 'papi_query' ) === 0 ) { $ path .= 'query/' ; } else if ( preg_match ( '/^papi\_\w+\_type/' , $ class ) ) { $ path .= 'types/' ; } if ( is_readable ( $ path . $ file ) ) { require_once $ path . $ file ; } } 
public function get_property ( $ slug , $ child_slug = '' ) { $ taxonomy_type_id = papi_get_taxonomy_type_id ( $ this -> id , 'term' ) ; $ taxonomy_type = papi_get_entry_type_by_id ( $ taxonomy_type_id ) ; if ( $ taxonomy_type instanceof Papi_Taxonomy_Type === false ) { return ; } if ( $ property = $ taxonomy_type -> get_property ( $ slug , $ child_slug ) ) { return $ this -> prepare_property ( $ property ) ; } } 
public function format_value ( $ value , $ slug , $ post_id ) { if ( is_admin ( ) || ! $ this -> settings -> render ) { return $ value ; } ob_start ( ) ; if ( is_active_sidebar ( $ value ) ) { dynamic_sidebar ( $ value ) ; } return ob_get_clean ( ) ; } 
public function get_items ( ) { global $ wp_registered_sidebars ; $ items = [ ] ; foreach ( $ wp_registered_sidebars as $ item ) { $ items [ $ item [ 'name' ] ] = $ item [ 'id' ] ; } ksort ( $ items ) ; return $ items ; } 
public function html ( ) { $ settings = $ this -> get_settings ( ) ; papi_render_html_tag ( 'input' , [ 'class' => $ settings -> mediauploader ? 'papi-url-media-input' : null , 'id' => esc_attr ( $ this -> html_id ( ) ) , 'name' => esc_attr ( $ this -> html_name ( ) ) , 'type' => 'url' , 'value' => $ this -> get_value ( ) ] ) ; if ( $ settings -> mediauploader ) { echo '&nbsp;' ; papi_render_html_tag ( 'input' , [ 'class' => 'button papi-url-media-button' , 'data-papi-action' => 'mediauploader' , 'id' => esc_attr ( $ this -> html_id ( ) ) , 'name' => esc_attr ( $ this -> html_name ( ) . '_button' ) , 'type' => 'button' , 'value' => esc_attr__ ( 'Select file' , 'papi' ) ] ) ; } } 
public function format_value ( $ value , $ slug , $ post_id ) { $ meta_key = $ this -> get_setting ( 'meta_key' ) ; if ( ! empty ( $ meta_key ) ) { $ args = [ 'fields' => 'ids' , 'meta_key' => $ meta_key , 'meta_value' => $ value , 'posts_per_page' => 1 , 'post_type' => $ this -> get_setting ( 'post_type' ) , ] ; $ query = new WP_Query ( $ args ) ; if ( ! empty ( $ query -> posts ) ) { $ value = $ query -> posts [ 0 ] ; } } $ post = $ this -> default_value ; 
protected function get_labels ( ) { $ results = [ ] ; foreach ( $ this -> get_post_types ( ) as $ post_type ) { if ( post_type_exists ( $ post_type ) ) { $ post_type_object = get_post_type_object ( $ post_type ) ; $ results [ $ post_type ] = $ post_type_object -> labels -> menu_name ; } } return $ results ; } 
protected function get_posts ( $ post_type = '' ) { $ query = $ this -> get_setting ( 'query' ) ; $ layout = $ this -> get_setting ( 'layout' ) ; 
protected function get_post_value ( $ post ) { $ meta_key = $ this -> get_setting ( 'meta_key' ) ; if ( is_numeric ( $ post ) ) { $ post_id = $ post ; } else if ( ! empty ( $ post ) ) { $ post = get_post ( $ post ) ; if ( $ post instanceof WP_Post === false ) { return 0 ; } $ post_id = $ post -> ID ; } if ( empty ( $ post_id ) ) { return 0 ; } if ( ! empty ( $ meta_key ) ) { $ value = get_post_meta ( $ post_id , $ meta_key , true ) ; } else { $ value = $ post_id ; } return $ value ; } 
public function html ( ) { $ settings = $ this -> get_settings ( ) ; $ layout = $ settings -> layout ; $ labels = $ this -> get_labels ( ) ; $ post_types = $ this -> get_post_types ( ) ; $ render_label = count ( $ post_types ) > 1 ; $ advanced = $ render_label && $ layout === 'advanced' ; $ single = $ render_label && $ layout !== 'advanced' ; $ classes = count ( $ post_types ) > 1 ? '' : 'papi-fullwidth' ; $ value = $ this -> get_value ( ) ; $ value = $ this -> get_post_value ( $ value ) ; $ selected_label = is_array ( $ labels ) && ! empty ( $ labels ) ? array_values ( $ labels ) [ 0 ] : '' ; $ selected_post_type = empty ( $ value ) ? '' : get_post_type ( $ value ) ; $ selected_post_type = empty ( $ selected_post_type ) ? '' : $ selected_post_type ; $ posts = $ this -> get_posts ( $ selected_post_type ) ; if ( $ settings -> select2 ) { $ classes .= ' papi-component-select2' ; } <div class="papi-property-post <?php echo $ advanced ? 'advanced' : '' ; ?>"> <?php if ( $ advanced ) : ?> <table class="papi-table"> <tr> <td> <label for="<?php echo esc_attr ( $ this -> html_id ( ) ) ; ?>_post_type"> <?php echo esc_html ( $ settings -> labels [ 'select_post_type' ] ) ; ?> </label> </td> <td> <select id="<?php echo esc_attr ( $ this -> html_id ( ) ) ; ?>_post_type" class="<?php echo esc_attr ( $ classes ) ; ?> papi-property-post-left" data-select-item="<?php echo esc_attr ( $ settings -> labels [ 'select_item' ] ) ; ?>" data-post-query='<?php echo esc_attr ( papi_maybe_json_encode ( $ settings -> query ) ) ; ?>' data-width="100%" > <?php foreach ( $ labels as $ post_type => $ label ) { $ selected = $ post_type === $ selected_post_type ; papi_render_html_tag ( 'option' , [ 'value' => $ post_type , 'selected' => $ selected , $ label ] ) ; if ( $ selected ) { $ selected_label = $ label ; } } ?> </select> </td> </tr> <tr> <td> <label for="<?php echo esc_attr ( $ this -> html_id ( ) ) ; ?>_posts"> <?php echo esc_html ( sprintf ( $ settings -> labels [ 'select_item' ] , $ selected_label ) ) ; ?> </label> </td> <td> <?php endif ; ?> <?php $ placeholder = ! is_null ( $ settings -> placeholder ) ? $ settings -> placeholder : '' ; ?> <select class="<?php echo esc_attr ( $ classes ) ; ?> papi-property-post-right" id="<?php echo esc_attr ( $ this -> html_id ( ) ) ; ?>_posts" name="<?php echo esc_attr ( $ this -> html_name ( ) ) ; ?>" data-allow-clear="<?php echo is_null ( $ settings -> placeholder ) ? 'false' : 'true' ; ?>" data-placeholder="<?php echo esc_attr ( $ placeholder ) ; ?>" data-width="100%" > <?php if ( ! empty ( $ settings -> placeholder ) ) : ?> <?php if ( $ settings -> new_url ) : ?> <option data-placeholder data-new-url="<?php echo esc_attr ( admin_url ( 'post-new.php?post_type=' . $ post_types [ 0 ] ) ) ; ?>"></option> <?php else : ?> <option></option> <?php endif ; ?> <?php endif ; ?> <?php foreach ( $ posts as $ label => $ items ) : ?> <?php if ( $ single ) : ?> <optgroup label="<?php echo esc_attr ( $ label ) ; ?>"> <?php endif ; ?> <?php foreach ( $ items as $ post ) { if ( papi_is_empty ( $ post -> post_title ) ) { continue ; } papi_render_html_tag ( 'option' , [ 'data-allow-clear' => $ settings -> allow_clear , 'data-edit-url' => $ settings -> edit_url ? get_edit_post_link ( $ post ) : '' , 'data-new-url' => $ settings -> new_url ? admin_url ( 'post-new.php?post_type=' . $ post -> post_type ) : '' , 'selected' => $ value === $ this -> get_post_value ( $ post ) , 'value' => $ this -> get_post_value ( $ post ) , $ post -> post_title ] ) ; } ?> <?php if ( $ single ) : ?> </optgroup> <?php endif ; ?> <?php endforeach ; ?> </select> <?php if ( $ advanced ) : ?> </td> </tr> </table> <?php endif ; ?> </div> <?php } 
public function render_option_template ( ) { $ settings = $ this -> get_settings ( ) ; $ post_types = $ this -> get_post_types ( ) ; ?> <script type="text/template" id="tmpl-papi-property-post-option"> <option data-allow-clear="<?php echo esc_attr ( $ settings -> allow_clear ) ; ?>" <?php if ( $ settings -> edit_url ) : ?> data-edit-url="<?php echo esc_attr ( admin_url ( 'post.php' ) ) ; ?>?post=<%= id %>&action=edit" <?php endif ; ?> <?php if ( $ settings -> new_url ) : ?> data-new-url="<?php echo esc_attr ( admin_url ( 'post-new.php?post_type=' ) ) ; ?><%= typeof type !== 'undefined' ? type : '<?php echo esc_attr ( $ post_types [ 0 ] ) ; ?>' %>" <?php endif ; ?> value="<%= id %>" > <%= title %> </option> </script> <script type="text/template" id="tmpl-papi-property-post-option-placeholder"> <option data-placeholder <?php if ( $ settings -> new_url ) : ?> data-new-url="<?php echo esc_attr ( admin_url ( 'post-new.php?post_type=' ) ) ; ?><%= typeof type !== 'undefined' ? type : '<?php echo esc_attr ( $ post_types [ 0 ] ) ; ?>' %>" <?php endif ; ?> > </option> </script> <?php } 
public function parse_args ( array $ args ) { $ args = array_merge ( $ this -> default_args , $ args ) ; 
protected function parse_post_args ( array $ args ) { if ( isset ( $ args [ 'page_type' ] ) ) { $ args [ 'entry_type' ] = $ args [ 'page_type' ] ; unset ( $ args [ 'page_type' ] ) ; } $ entry_type = papi_get_entry_type_by_id ( $ args [ 'entry_type' ] ) ; if ( $ entry_type instanceof Papi_Page_Type ) { $ args [ 'post_type' ] = papi_to_array ( $ entry_type -> post_type ) ; } else { $ args [ 'post_type' ] = isset ( $ args [ 'post_type' ] ) ? $ args [ 'post_type' ] : '' ; } return $ args ; } 
protected function parse_term_args ( array $ args ) { if ( isset ( $ args [ 'taxonomy_type' ] ) ) { $ args [ 'entry_type' ] = $ args [ 'taxonomy_type' ] ; unset ( $ args [ 'taxonomy_type' ] ) ; } $ entry_type = papi_get_entry_type_by_id ( $ args [ 'entry_type' ] ) ; if ( $ entry_type instanceof Papi_Taxonomy_Type ) { $ args [ 'taxonomy' ] = papi_to_array ( $ entry_type -> taxonomy ) ; } else { $ args [ 'taxonomy' ] = isset ( $ args [ 'taxonomy' ] ) ? $ args [ 'taxonomy' ] : '' ; } return $ args ; } 
public function get_query_args ( ) { $ args = $ this -> args ; if ( empty ( $ args [ 'meta_query' ] ) ) { 
public function get_result ( ) { if ( ! method_exists ( $ this -> query , 'query' ) ) { return [ ] ; } $ this -> parse_args ( $ this -> args ) ; return $ this -> query -> query ( $ this -> get_query_args ( ) ) ; } 
public function html ( ) { $ settings = $ this -> get_settings ( ) ; $ value = $ this -> get_value ( ) ; papi_render_html_tag ( 'div' , [ 'class' => 'papi-property-color-picker' , papi_html_tag ( 'input' , [ 'data-settings' => $ settings , 'id' => $ this -> html_id ( ) , 'name' => $ this -> html_name ( ) , 'type' => $ settings -> show_input === true ? 'text' : 'hidden' , 'value' => $ value , ] ) ] ) ; } 
public function format_value ( $ value , $ slug , $ post_id ) { if ( is_string ( $ value ) && ! papi_is_empty ( $ value ) ) { return [ papi_cast_string_value ( $ value ) ] ; } if ( ! is_array ( $ value ) ) { return $ this -> default_value ; } return array_map ( 'papi_cast_string_value' , $ value ) ; } 
public function html ( ) { $ settings = $ this -> get_settings ( ) ; $ value = papi_cast_string_value ( $ this -> get_value ( ) ) ; 
public function get_property ( $ slug , $ child_slug = '' ) { $ entry_type_id = papi_get_qs ( 'page' ) ; if ( empty ( $ entry_type_id ) ) { $ property = null ; $ entry_types = papi_get_all_entry_types ( [ 'types' => 'option' ] ) ; foreach ( $ entry_types as $ entry_type ) { if ( $ property = $ entry_type -> get_property ( $ slug , $ child_slug ) ) { break ; } } if ( is_null ( $ property ) ) { return ; } return $ property ; } $ entry_type = papi_get_entry_type_by_id ( $ entry_type_id ) ; if ( $ entry_type instanceof Papi_Option_Type === false ) { return ; } if ( $ property = $ entry_type -> get_property ( $ slug , $ child_slug ) ) { return $ this -> prepare_property ( $ property ) ; } } 
public function html ( ) { $ settings = $ this -> get_settings ( ) ; $ value = $ this -> get_value ( ) ; $ settings_json = [ 'i18n' => [ 'previousMonth' => __ ( 'Previous Month' , 'papi' ) , 'nextMonth' => __ ( 'Next Month' , 'papi' ) , 'midnight' => __ ( 'Midnight' , 'papi' ) , 'months' => [ __ ( 'January' , 'papi' ) , __ ( 'February' , 'papi' ) , __ ( 'March' , 'papi' ) , __ ( 'April' , 'papi' ) , __ ( 'May' , 'papi' ) , __ ( 'June' , 'papi' ) , __ ( 'July' , 'papi' ) , __ ( 'August' , 'papi' ) , __ ( 'September' , 'papi' ) , __ ( 'October' , 'papi' ) , __ ( 'November' , 'papi' ) , __ ( 'December' , 'papi' ) ] , 'noon' => __ ( 'Noon' , 'papi' ) , 'weekdays' => [ __ ( 'Sunday' , 'papi' ) , __ ( 'Monday' , 'papi' ) , __ ( 'Tuesday' , 'papi' ) , __ ( 'Wednesday' , 'papi' ) , __ ( 'Thursday' , 'papi' ) , __ ( 'Friday' , 'papi' ) , __ ( 'Saturday' , 'papi' ) ] , 'weekdaysShort' => [ __ ( 'Sun' , 'papi' ) , __ ( 'Mon' , 'papi' ) , __ ( 'Tue' , 'papi' ) , __ ( 'Wed' , 'papi' ) , __ ( 'Thu' , 'papi' ) , __ ( 'Fri' , 'papi' ) , __ ( 'Sat' , 'papi' ) ] ] ] ; 
public function add_help_tabs ( ) { $ help = $ this -> help ( ) ; $ screen = get_current_screen ( ) ; 
protected function box ( $ file_or_options = [ ] , $ properties = [ ] ) { if ( ! is_string ( $ file_or_options ) && ! is_array ( $ file_or_options ) && ! is_object ( $ file_or_options ) ) { return ; } list ( $ options , $ properties ) = papi_get_options_and_properties ( $ file_or_options , $ properties , true ) ; 
protected function call_parent_register ( ) { $ parent_class = get_parent_class ( $ this ) ; if ( ! method_exists ( $ parent_class , 'register' ) ) { return ; } $ rc = new ReflectionClass ( $ parent_class ) ; 
protected function convert_properties ( $ properties ) { if ( is_array ( $ properties ) ) { if ( isset ( $ properties [ 'type' ] ) ) { $ properties = [ $ properties ] ; } else if ( isset ( $ properties [ 0 ] ) && $ properties [ 0 ] instanceof Papi_Core_Tab ) { foreach ( $ properties as $ items ) { $ items -> properties = array_map ( 'papi_get_property_type' , $ items -> properties ) ; } return $ properties ; } } if ( is_object ( $ properties ) ) { $ properties = papi_get_property_type ( $ properties ) ; } if ( papi_is_property ( $ properties ) ) { $ properties = [ $ properties ] ; } $ properties = is_array ( $ properties ) ? $ properties : [ ] ; $ properties = array_map ( 'papi_get_property_type' , $ properties ) ; return array_filter ( $ properties , 'papi_is_property' ) ; } 
public function get_body_classes ( ) { $ arr = $ this -> body_classes ( ) ; $ arr = is_string ( $ arr ) ? [ $ arr ] : $ arr ; $ arr = is_array ( $ arr ) ? $ arr : [ ] ; return array_merge ( $ arr , [ ] ) ; } 
public function get_boxes ( ) { if ( empty ( $ this -> boxes ) && $ this -> load_boxes === false ) { if ( ! method_exists ( $ this , 'register' ) ) { return [ ] ; } $ this -> load_boxes = true ; $ this -> call_parent_register ( ) ; $ this -> register ( ) ; } * Modify boxes array. * * @param array $boxes * @param string $id */ $ this -> boxes = apply_filters ( 'papi/get_boxes' , $ this -> boxes , $ this -> get_id ( ) ) ; $ this -> boxes = is_array ( $ this -> boxes ) ? $ this -> boxes : [ ] ; 
public function get_property ( $ slug , $ child_slug = '' ) { $ boxes = $ this -> get_boxes ( ) ; $ parts = preg_match ( '/\[\d+\]/' , $ slug ) ? preg_split ( '/\[\d+\]/' , $ slug ) : explode ( '[' , $ slug ) ; $ parts = array_map ( function ( $ part ) { return preg_replace ( '/(\[|\])/' , '' , $ part ) ; } , $ parts ) ; if ( count ( $ parts ) > 1 ) { $ property = null ; for ( $ i = 0 , $ l = count ( $ parts ) ; $ i < $ l ; $ i ++ ) { $ child = isset ( $ parts [ $ i + 1 ] ) ? $ parts [ $ i + 1 ] : '' ; $ property = $ this -> get_property ( $ parts [ $ i ] , $ child ) ; if ( isset ( $ parts [ $ i + 1 ] ) ) { $ i ++ ; } } return apply_filters ( 'papi/get_property' , $ property ) ; } foreach ( $ boxes as $ box ) { foreach ( $ box -> properties as $ property ) { $ property = papi_get_property_type ( $ property ) ; if ( papi_is_property ( $ property ) && $ property -> match_slug ( $ slug ) ) { if ( empty ( $ child_slug ) ) { return apply_filters ( 'papi/get_property' , $ property ) ; } $ property = $ property -> get_child_property ( $ child_slug ) ; if ( papi_is_property ( $ property ) ) { return apply_filters ( 'papi/get_property' , $ property ) ; } } } } } 
public function get_properties ( ) { $ boxes = $ this -> get_boxes ( ) ; $ list = [ ] ; foreach ( $ boxes as $ box ) { foreach ( $ box -> properties as $ property ) { $ list [ ] = $ property ; } } return $ list ; } 
protected function merge_boxes ( array $ boxes ) { $ result = [ ] ; foreach ( $ boxes as $ box ) { if ( ! isset ( $ result [ $ box -> id ] ) ) { $ result [ $ box -> id ] = $ box ; continue ; } foreach ( $ box -> properties as $ property ) { $ result [ $ box -> id ] -> properties [ ] = $ property ; } $ result [ $ box -> id ] -> properties = array_unique ( $ result [ $ box -> id ] -> properties ) ; } return array_values ( $ result ) ; } 
public function setup ( ) { add_action ( 'in_admin_header' , [ $ this , 'add_help_tabs' ] ) ; add_filter ( 'screen_options_show_screen' , function ( ) { return $ this -> show_screen_options ; } ) ; 
protected function tab ( $ file_or_options = [ ] , $ properties = [ ] ) { if ( ! is_string ( $ file_or_options ) && ! is_array ( $ file_or_options ) ) { return ; } return papi_tab ( $ file_or_options , $ properties ) ; } 
public function format_value ( $ value , $ slug , $ post_id ) { $ value = is_string ( $ value ) && is_numeric ( $ value ) ? $ value + 0 : $ value ; if ( is_float ( $ value ) ) { return floatval ( $ value ) ; } else { return intval ( $ value ) ; } } 
public function html ( ) { $ settings = $ this -> get_settings ( ) ; $ value = $ this -> get_value ( ) ; 
public function delete_value ( $ slug , $ post_id , $ type ) { $ values = $ this -> load_value ( null , $ slug , $ post_id ) ; $ values = is_object ( $ values ) ? ( array ) $ values : $ values ; $ result = true ; foreach ( array_keys ( $ values ) as $ key ) { $ out = papi_data_delete ( $ post_id , $ slug . '_' . $ key ) ; $ result = $ out ? $ result : $ out ; } if ( $ result ) { $ result = papi_data_delete ( $ post_id , $ slug ) ; } return $ result ; } 
public function load_value ( $ value , $ slug , $ post_id ) { if ( is_array ( $ value ) || is_object ( $ value ) ) { $ values = $ value ; } else { $ values = $ this -> link_fields ; foreach ( $ values as $ index => $ key ) { $ values [ $ key ] = papi_data_get ( $ post_id , sprintf ( '%s_%s' , $ slug , $ key ) , $ this -> get_meta_type ( ) ) ; unset ( $ values [ $ index ] ) ; } } return ( object ) $ this -> prepare_link_array ( $ values , $ slug ) ; } 
public function html ( ) { $ value = $ this -> get_value ( ) ; $ value = is_array ( $ value ) || is_object ( $ value ) ? $ value : [ ] ; $ value = ( object ) $ value ; $ exists = ! empty ( $ value -> url ) ; ?> <div class="papi-property-link" data-replace-slug="true" data-slug="<?php echo esc_attr ( $ this -> html_name ( ) ) ; ?>"> <input type="hidden" name="<?php echo esc_attr ( $ this -> html_name ( ) ) ; ?>" value="<?php echo $ exists ? 1 : '' ; ?>"> <?php if ( $ exists ) : ?> <table class="papi-table link-table"> <tbody> <tr> <td><?php esc_html_e ( 'URL' , 'papi' ) ; ?></td> <td> <a href="<?php echo esc_attr ( $ value -> url ) ; ?>" target="_blank"><?php echo esc_attr ( $ value -> url ) ; ?></a> <input type="hidden" value="<?php echo esc_attr ( $ value -> title . ' - ' . $ value -> url ) ; ?>" data-papi-rule="<?php echo esc_attr ( $ this -> html_name ( ) ) ; ?>"> <input class="wp-link-url" type="hidden" value="<?php echo esc_attr ( $ value -> url ) ; ?>" name="<?php echo esc_attr ( $ this -> html_name ( ) ) ; ?>[url]"> </td> </tr> <tr> <td><?php esc_html_e ( 'Title' , 'papi' ) ; ?></td> <td> <?php echo esc_html ( $ value -> title ) ; ?> <input class="wp-link-text" type="hidden" value="<?php echo esc_attr ( $ value -> title ) ; ?>" name="<?php echo esc_attr ( $ this -> html_name ( ) ) ; ?>[title]"> </td> </tr> <tr> <td><?php esc_html_e ( 'Target' , 'papi' ) ; ?></td> <td> <?php echo $ value -> target === '_blank' ? esc_html_e ( 'New window' , 'papi' ) : esc_html_e ( 'Same window' , 'papi' ) ; ?> <input class="wp-link-target" type="hidden" value="<?php echo esc_attr ( $ value -> target ) ; ?>" name="<?php echo esc_attr ( $ this -> html_name ( ) ) ; ?>[target]"> </td> </tr> </tbody> </table> <?php endif ; ?> <p class="papi-file-select"> <span class="<?php echo empty ( $ value -> url ) ? '' : 'papi-hide' ; ?>"> <?php esc_html_e ( 'No link selected' , 'papi' ) ; ?> <button class="button" data-link-action="add"><?php esc_html_e ( 'Add link' , 'papi' ) ; ?></button> </span> <span class="<?php echo empty ( $ value -> url ) ? 'papi-hide' : '' ; ?>"> <button class="button" data-link-action="edit"><?php esc_html_e ( 'Edit link' , 'papi' ) ; ?></button> <button class="button" data-link-action="remove"><?php esc_html_e ( 'Remove link' , 'papi' ) ; ?></button> </span> </p> </div> <?php } 
protected function prepare_link_array ( $ link , $ slug ) { $ array = is_array ( $ link ) ; $ values = ( array ) $ link ; foreach ( $ values as $ key => $ val ) { unset ( $ values [ $ key ] ) ; $ key = preg_replace ( '/^' . $ slug . '\_/' , '' , $ key ) ; $ values [ $ key ] = $ val ; } $ link = ( object ) $ values ; 
public function update_value ( $ values , $ slug , $ post_id ) { if ( is_object ( $ values ) ) { $ values = ( array ) $ values ; } if ( ! isset ( $ values [ 'url' ] ) ) { $ values = $ this -> link_fields ; foreach ( $ values as $ index => $ key ) { $ values [ sprintf ( '%s_%s' , $ slug , $ key ) ] = '' ; unset ( $ values [ $ index ] ) ; } 
public function allowed ( ) { $ args = func_get_args ( ) ; if ( empty ( $ args ) ) { return parent :: allowed ( ) ; } return isset ( $ args [ 0 ] ) && in_array ( $ args [ 0 ] , $ this -> taxonomy , true ) ; } 
protected function setup_actions ( ) { foreach ( papi_to_array ( $ this -> taxonomy ) as $ taxonomy ) { if ( is_string ( $ taxonomy ) && taxonomy_exists ( $ taxonomy ) ) { add_action ( $ taxonomy . '_edit_form' , [ $ this , 'edit_form' ] ) ; } } } 
public function edit_form ( ) { ?> <div id="papi-hidden-editor" class="hide-if-js"> <?php wp_editor ( '' , 'papiHiddenEditor' ) ; ?> </div> <div id="poststuff"> <div id="post-body"> <?php foreach ( $ this -> boxes as $ box ) { do_meta_boxes ( $ box -> id , 'normal' , null ) ; } ?> </div> </div> <?php } 
public function get_post ( WP_Post $ post ) { if ( ! ( $ page_type = papi_get_entry_type_by_meta_id ( $ post -> ID ) ) ) { return $ post ; } 
public function prepare_response ( $ response ) { if ( ! isset ( $ response -> data [ 'meta' ] ) ) { return $ response ; } foreach ( $ response -> data [ 'meta' ] as $ key => $ value ) { $ response -> data [ 'meta' ] [ $ key ] = papi_get_field ( $ key , $ value , 'post' ) ; } return $ response ; } 
public function setup_fields ( ) { if ( ! function_exists ( 'register_rest_field' ) ) { return ; } $ post_types = papi_get_post_types ( ) ; foreach ( $ post_types as $ post_type ) { register_rest_field ( $ post_type , 'page_type' , [ 'get_callback' => [ $ this , 'get_page_type' ] ] ) ; } } 
protected function get_format_args ( $ assoc_args ) { $ format_args = [ 'fields' => $ this -> get_default_format_fields ( ) , 'field' => null , 'format' => 'table' , ] ; if ( isset ( $ assoc_args [ 'fields' ] ) ) { $ format_args [ 'fields' ] = $ assoc_args [ 'fields' ] ; } if ( isset ( $ assoc_args [ 'field' ] ) ) { $ format_args [ 'field' ] = $ assoc_args [ 'field' ] ; } if ( ! empty ( $ assoc_args [ 'format' ] ) && in_array ( $ assoc_args [ 'format' ] , [ 'count' , 'ids' , 'table' , 'csv' , 'json' ] , true ) ) { $ format_args [ 'format' ] = $ assoc_args [ 'format' ] ; } return $ format_args ; } 
public function render ( $ file ) { if ( ! empty ( $ file ) && $ this -> exists ( $ file ) ) { require $ this -> file ( $ file ) ; } } 
public function get_option ( $ key ) { return isset ( $ this -> options [ $ key ] ) ? $ this -> options [ $ key ] : null ; } 
protected function setup_args ( array $ args ) { $ excluded_keys = [ 'options' , 'properties' ] ; foreach ( $ args as $ key => $ value ) { if ( isset ( $ this -> $ key ) && ! in_array ( $ key , $ excluded_keys , true ) ) { $ this -> $ key = papi_esc_html ( $ value ) ; } } if ( empty ( $ this -> id ) ) { $ this -> id = papi_slugify ( strtolower ( papi_f ( papi_underscorify ( papify ( $ this -> title ) ) ) ) ) ; $ this -> id = sanitize_text_field ( $ this -> id ) ; } } 
protected function convert_prop ( $ value , Papi_Core_Conditional_Rule $ rule ) { $ meta_id = papi_get_meta_id ( ) ; $ meta_type = papi_get_meta_type ( ) ; $ entry_type = papi_get_entry_type_by_meta_id ( $ meta_id , $ meta_type ) ; if ( ! papi_is_empty ( $ value ) && $ entry_type instanceof Papi_Entry_Type !== false ) { $ property = $ entry_type -> get_property ( $ rule -> slug ) ; if ( papi_is_property ( $ property ) ) { $ prop_value = $ property -> format_value ( $ value , $ property -> slug , $ meta_id ) ; $ prop_value = papi_filter_format_value ( $ property -> type , $ prop_value , $ property -> slug , $ meta_id , $ meta_type ) ; $ prop_value = $ this -> get_deep_value ( $ rule -> slug , $ prop_value ) ; if ( gettype ( $ prop_value ) === gettype ( $ rule -> value ) ) { return $ prop_value ; } } return $ value ; } return $ value ; } 
protected function get_converted_value ( Papi_Core_Conditional_Rule $ rule ) { $ value = $ this -> get_value ( $ rule ) ; 
protected function get_deep_value ( $ slug , $ value ) { $ slugs = explode ( '.' , $ slug ) ; array_shift ( $ slugs ) ; return papi_field_value ( $ slugs , $ value , $ value ) ; } 
protected function get_value ( Papi_Core_Conditional_Rule $ rule ) { if ( papi_doing_ajax ( ) ) { $ source = $ rule -> get_source ( ) ; $ meta_id = papi_get_meta_id ( ) ; $ entry_type = papi_get_entry_type_by_meta_id ( $ meta_id ) ; if ( ! papi_is_empty ( $ source ) && $ entry_type instanceof Papi_Entry_Type !== false ) { if ( papi_is_property ( $ entry_type -> get_property ( $ rule -> slug ) ) ) { return $ this -> get_deep_value ( $ rule -> slug , $ source ) ; } } } if ( ! papi_is_empty ( $ rule -> get_source ( ) ) ) { return $ this -> get_deep_value ( $ rule -> slug , $ rule -> get_source ( ) ) ; } $ slug = $ rule -> get_field_slug ( ) ; $ type = papi_get_meta_type ( ) ; $ value = papi_get_field ( $ slug , null , $ type ) ; return $ this -> get_deep_value ( $ slug , $ value ) ; } 
public function rule_equal ( Papi_Core_Conditional_Rule $ rule ) { list ( $ value , $ rule_value ) = $ this -> get_converted_value ( $ rule ) ; return $ value === $ rule_value ; } 
public function rule_not_equal ( Papi_Core_Conditional_Rule $ rule ) { list ( $ value , $ rule_value ) = $ this -> get_converted_value ( $ rule ) ; return $ value !== $ rule_value ; } 
public function rule_greater_then ( Papi_Core_Conditional_Rule $ rule ) { $ value = $ this -> get_value ( $ rule ) ; if ( is_array ( $ value ) ) { $ value = count ( $ value ) ; } if ( ! is_numeric ( $ value ) || ! is_numeric ( $ rule -> value ) ) { return false ; } return $ this -> convert_number ( $ value ) > $ this -> convert_number ( $ rule -> value ) ; } 
public function rule_not_in ( Papi_Core_Conditional_Rule $ rule ) { list ( $ value , $ rule_value ) = $ this -> get_converted_value ( $ rule ) ; if ( ! is_array ( $ rule_value ) ) { return false ; } return ! in_array ( $ value , $ rule_value , true ) ; } 
public function rule_like ( Papi_Core_Conditional_Rule $ rule ) { $ value = $ this -> get_value ( $ rule ) ; if ( ! is_string ( $ value ) ) { $ value = papi_convert_to_string ( $ value ) ; } if ( papi_is_empty ( $ value ) ) { return false ; } return strpos ( strtolower ( $ value ) , strtolower ( $ rule -> value ) ) !== false ; } 
protected function get_between_values ( Papi_Core_Conditional_Rule $ rule ) { $ value = $ this -> get_value ( $ rule ) ; if ( ! is_array ( $ rule -> value ) ) { return [ $ rule , false ] ; } foreach ( $ rule -> value as $ index => $ v ) { $ v = $ this -> convert_number ( $ v ) ; if ( is_numeric ( $ v ) ) { $ rule -> value [ $ index ] = $ v ; } else { unset ( $ rule -> value [ $ index ] ) ; } } if ( ! is_numeric ( $ value ) || count ( $ rule -> value ) !== 2 ) { return [ $ rule , false ] ; } return [ $ rule , $ this -> convert_number ( $ value ) ] ; } 
public function rule_between ( Papi_Core_Conditional_Rule $ rule ) { list ( $ rule , $ value ) = $ this -> get_between_values ( $ rule ) ; if ( $ value === false ) { return false ; } return $ rule -> value [ 0 ] <= $ value && $ value <= $ rule -> value [ 1 ] ; } 
public function rule_not_between ( Papi_Core_Conditional_Rule $ rule ) { list ( $ rule , $ value ) = $ this -> get_between_values ( $ rule ) ; if ( $ value === false ) { return false ; } return ! ( $ rule -> value [ 0 ] <= $ value && $ value <= $ rule -> value [ 1 ] ) ; } 
public function setup_filters ( ) { add_filter ( 'papi/conditional/rule/=' , [ $ this , 'rule_equal' ] ) ; add_filter ( 'papi/conditional/rule/!=' , [ $ this , 'rule_not_equal' ] ) ; add_filter ( 'papi/conditional/rule/>' , [ $ this , 'rule_greater_then' ] ) ; add_filter ( 'papi/conditional/rule/>=' , [ $ this , 'rule_greater_then_or_equal' ] ) ; add_filter ( 'papi/conditional/rule/<' , [ $ this , 'rule_less_then' ] ) ; add_filter ( 'papi/conditional/rule/<=' , [ $ this , 'rule_less_then_or_equal' ] ) ; add_filter ( 'papi/conditional/rule/IN' , [ $ this , 'rule_in' ] ) ; add_filter ( 'papi/conditional/rule/NOT IN' , [ $ this , 'rule_not_in' ] ) ; add_filter ( 'papi/conditional/rule/LIKE' , [ $ this , 'rule_like' ] ) ; add_filter ( 'papi/conditional/rule/BETWEEN' , [ $ this , 'rule_between' ] ) ; add_filter ( 'papi/conditional/rule/NOT BETWEEN' , [ $ this , 'rule_not_between' ] ) ; add_filter ( 'papi/conditional/rule/EXISTS' , [ $ this , 'rule_exists' ] ) ; add_filter ( 'papi/conditional/rule/NOT EXISTS' , [ $ this , 'rule_not_exists' ] ) ; add_filter ( 'papi/conditional/rule/EMPTY' , [ $ this , 'rule_empty' ] ) ; add_filter ( 'papi/conditional/rule/NOT EMPTY' , [ $ this , 'rule_not_empty' ] ) ; } 
public function format_value ( $ values , $ slug , $ post_id ) { if ( is_array ( $ values ) || is_object ( $ values ) ) { $ items = $ this -> get_setting ( 'items' ) ; $ result = [ ] ; foreach ( $ values as $ id ) { 
public function get_sort_option ( $ post_id ) { $ slug = $ this -> html_id ( 'sort_option' ) ; $ slug = str_replace ( '][' , '_' , $ slug ) ; $ slug = str_replace ( '[' , '_' , $ slug ) ; $ slug = str_replace ( ']' , '' , $ slug ) ; return papi_data_get ( $ post_id , $ slug , $ this -> get_meta_type ( ) ) ; } 
public static function get_sort_options ( ) { $ sort_options = [ ] ; $ sort_options [ __ ( 'Select' , 'papi' ) ] = null ; $ sort_options [ __ ( 'Name (alphabetically)' , 'papi' ) ] = function ( $ a , $ b ) { 
protected function get_items ( $ settings ) { if ( is_array ( $ settings -> items ) && ! empty ( $ settings -> items ) ) { $ mapping = function ( $ item ) { return is_array ( $ item ) ? isset ( $ item [ 'id' ] , $ item [ 'title' ] ) : isset ( $ item -> id , $ item -> title ) ; } ; return array_map ( 'papi_maybe_convert_to_object' , array_filter ( $ settings -> items , $ mapping ) ) ; } 
protected function get_post_value ( $ value ) { $ meta_key = $ this -> get_setting ( 'meta_key' ) ; if ( $ value instanceof WP_Post === false ) { return 0 ; } if ( empty ( $ meta_key ) ) { return $ value -> ID ; } if ( $ value = get_post_meta ( $ value -> ID , $ meta_key , true ) ) { return $ value ; } return 0 ; } 
public function html ( ) { $ post_id = papi_get_post_id ( ) ; $ slug = $ this -> html_name ( ) ; $ settings = $ this -> get_settings ( ) ; $ settings_json = [ ] ; $ sort_option = $ this -> get_sort_option ( $ post_id ) ; $ sort_options = static :: get_sort_options ( ) ; $ values = papi_get_only_objects ( $ this -> get_value ( ) ) ; $ items = $ this -> get_items ( $ settings ) ; if ( papi_is_empty ( $ settings -> items ) ) { $ values = array_map ( [ $ this , 'convert_post_to_item' ] , $ values ) ; } else { foreach ( array_keys ( $ sort_options ) as $ key ) { if ( strpos ( $ key , 'Post' ) === 0 ) { unset ( $ sort_options [ $ key ] ) ; } } } <div class="papi-property-relationship" data-settings='<?php echo esc_attr ( papi_maybe_json_encode ( $ settings_json ) ) ; ?>'> <input type="hidden" name="<?php echo esc_attr ( $ slug ) ; ?>[]" data-papi-rule="<?php echo esc_attr ( $ slug ) ; ?>" /> <div class="relationship-inner"> <div class="relationship-top-left"> <label for="<?php echo esc_attr ( $ this -> html_id ( 'search' ) ) ; ?>"><?php esc_html_e ( 'Search' , 'papi' ) ; ?></label> <input id="<?php echo esc_attr ( $ this -> html_id ( 'search' ) ) ; ?>" type="search" /> </div> <div class="relationship-top-right"> <?php if ( $ settings -> show_sort_by ) : ?> <label for="<?php echo esc_attr ( $ this -> html_id ( 'sort_option' ) ) ; ?>"><?php esc_html_e ( 'Sort by' , 'papi' ) ; ?></label> <select id="<?php echo esc_attr ( $ this -> html_id ( 'sort_option' ) ) ; ?>" name="<?php echo esc_attr ( $ this -> html_id ( 'sort_option' ) ) ; ?>"> <?php foreach ( array_keys ( $ sort_options ) as $ key ) : ?> <option value="<?php echo esc_attr ( $ key ) ; ?>" <?php echo $ key === $ sort_option ? 'selected="selected"' : '' ; ?>><?php echo esc_html ( $ key ) ; ?></option> <?php endforeach ; ?> </select> <?php endif ; ?> </div> <div class="papi-clear"></div> </div> <div class="relationship-inner"> <div class="relationship-left"> <ul> <?php foreach ( $ items as $ item ) : if ( ! empty ( $ item -> title ) ) : ?> <li> <input type="hidden" data-name="<?php echo esc_attr ( $ slug ) ; ?>[]" value="<?php echo esc_attr ( $ item -> id ) ; ?>"/> <a href="#" title="<?php echo esc_attr ( $ item -> title ) ; ?>"><?php echo esc_html ( $ item -> title ) ; ?></a> <span class="icon plus"></span> </li> <?php endif ; endforeach ; ?> </ul> </div> <div class="relationship-right"> <ul> <?php foreach ( $ values as $ item ) : ?> <li> <input type="hidden" name="<?php echo esc_attr ( $ slug ) ; ?>[]" value="<?php echo esc_attr ( $ item -> id ) ; ?>"/> <a href="#"><?php echo esc_attr ( $ item -> title ) ; ?></a> <span class="icon minus"></span> </li> <?php endforeach ; ?> </ul> </div> <div class="papi-clear"></div> </div> </div> <?php } 
public function load_value ( $ values , $ slug , $ post_id ) { $ values = ( array ) papi_maybe_json_decode ( maybe_unserialize ( $ values ) , true ) ; return array_map ( 'papi_maybe_convert_to_object' , $ values ) ; } 
public function sort_value ( $ values , $ slug , $ post_id ) { $ sort_option = $ this -> get_sort_option ( $ post_id ) ; $ sort_options = static :: get_sort_options ( ) ; if ( empty ( $ sort_option ) || ! isset ( $ sort_options [ $ sort_option ] ) || is_null ( $ sort_options [ $ sort_option ] ) ) { return $ values ; } usort ( $ values , $ sort_options [ $ sort_option ] ) ; return $ values ; } 
public function update_value ( $ values , $ slug , $ post_id ) { $ values = $ this -> format_value ( $ values , $ slug , $ post_id ) ; $ values = array_map ( function ( $ item ) { if ( $ item instanceof WP_Post ) { $ item = $ this -> convert_post_to_item ( $ item ) ; } if ( isset ( $ item -> title ) ) { unset ( $ item -> title ) ; } return $ item ; } , $ values ) ; return papi_maybe_json_decode ( $ values ) ; } 
protected function get_meta_type_value ( $ entry_type ) { if ( in_array ( $ entry_type -> get_type ( ) , [ 'attachment' ] , true ) ) { return $ entry_type -> get_type ( ) ; } switch ( papi_get_meta_type ( $ entry_type -> get_type ( ) ) ) { case 'post' : return implode ( ', ' , $ entry_type -> post_type ) ; case 'term' : return implode ( ', ' , $ entry_type -> taxonomy ) ; default : return 'n/a' ; } } 
public function list_ ( $ args , $ assoc_args ) { 
protected function html ( ) { ?> <div class="papi-tabs-wrapper"> <div class="papi-tabs-table-back"></div> <div class="papi-tabs-back"></div> <ul class="papi-tabs"> <?php foreach ( $ this -> tabs as $ tab ) : $ css_classes = $ this -> tabs [ 0 ] === $ tab ? 'active ' : '' ; if ( empty ( $ tab -> background ) ) { <li class="<?php echo esc_attr ( $ css_classes ) ; ?>"> <a href="#" data-papi-tab="<?php echo esc_attr ( $ tab -> id ) ; ?>"> <?php if ( ! empty ( $ tab -> icon ) ) : ?> <img src="<?php echo esc_attr ( $ tab -> icon ) ; ?>" alt="<?php echo esc_attr ( $ tab -> title ) ; ?>" /> <?php endif ; echo esc_html ( $ tab -> title ) ; ?> </a> </li> <?php endforeach ; ?> </ul> <div class="papi-tabs-content"> <?php foreach ( $ this -> tabs as $ tab ) : ?> <div class="<?php echo $ this -> tabs [ 0 ] === $ tab ? 'active' : '' ; ?>" data-papi-tab="<?php echo esc_attr ( $ tab -> id ) ; ?>"> <?php papi_render_properties ( $ tab -> properties ) ; ?> </div> <?php endforeach ; ?> </div> </div> <div class="papi-clear"></div> <?php } 
public function format_value ( $ values , $ repeater_slug , $ post_id ) { if ( ! is_array ( $ values ) ) { return [ ] ; } foreach ( $ values as $ index => $ layout ) { foreach ( $ layout as $ slug => $ value ) { if ( is_string ( $ value ) && preg_match ( $ this -> layout_value_regex , $ value ) ) { if ( isset ( $ values [ $ index ] [ $ this -> layout_key ] ) ) { unset ( $ values [ $ index ] [ $ slug ] ) ; continue ; } $ values [ $ index ] [ $ this -> layout_key ] = $ value ; unset ( $ values [ $ index ] [ $ slug ] ) ; continue ; } if ( papi_is_property_type_key ( $ slug ) ) { continue ; } $ property_type_slug = papi_get_property_type_key_f ( $ slug ) ; if ( ! isset ( $ values [ $ index ] [ $ property_type_slug ] ) ) { continue ; } $ property_type_value = $ values [ $ index ] [ $ property_type_slug ] ; $ property_type = papi_get_property_type ( $ property_type_value ) ; if ( ! is_object ( $ property_type ) ) { continue ; } 
protected function get_json_id ( $ key , $ extra = '' ) { return $ this -> get_slug ( ) . '_' . papi_slugify ( $ key ) . ( empty ( $ extra ) ? '' : '_' . $ extra ) ; } 
protected function get_layout ( $ slug ) { $ layouts = $ this -> get_settings_layouts ( ) ; foreach ( $ layouts as $ layout ) { if ( $ layout [ 'slug' ] === $ slug ) { return $ layout ; } } return [ ] ; } 
protected function get_results ( $ value , $ repeater_slug , $ post_id ) { global $ wpdb ; if ( $ this -> get_meta_type ( ) === 'option' ) { $ table = $ wpdb -> prefix . 'options' ; 
public function load_value ( $ value , $ repeater_slug , $ post_id ) { if ( is_array ( $ value ) ) { return $ value ; } list ( $ results , $ trash ) = $ this -> get_results ( $ value , $ repeater_slug , $ post_id ) ; 
protected function load_child_properties ( array $ results , $ property = null ) { $ layout_key = substr ( $ this -> layout_key , 1 ) ; foreach ( $ results as $ index => $ row ) { foreach ( $ row as $ slug => $ value ) { $ children = [ ] ; if ( $ layout_key === $ slug ) { continue ; } if ( isset ( $ results [ $ index ] [ $ layout_key ] ) ) { $ layout = $ results [ $ index ] [ $ layout_key ] ; $ layout = $ this -> get_layout ( $ layout ) ; if ( ! empty ( $ layout ) && isset ( $ layout [ 'items' ] ) ) { $ children = $ layout [ 'items' ] ; } } $ child_property = null ; foreach ( $ children as $ child ) { if ( $ child -> match_slug ( $ slug ) ) { $ child_property = $ child ; } } if ( empty ( $ child_property ) ) { $ child_property = $ this -> get_store ( ) -> get_property ( $ this -> get_slug ( true ) , $ slug ) ; } if ( is_array ( $ value ) && papi_is_property ( $ child_property ) && ! empty ( $ child_property -> get_child_properties ( ) ) ) { $ new_value = papi_from_property_array_slugs ( $ value , unpapify ( $ slug ) ) ; if ( empty ( $ new_value ) ) { $ results [ $ index ] [ $ slug ] = $ value ; } else { $ results [ $ index ] [ $ slug ] = $ this -> load_child_properties ( $ new_value , $ child_property ) ; } } $ type_key = papi_get_property_type_key_f ( $ slug ) ; if ( $ property -> match_slug ( $ slug ) ) { $ results [ $ index ] [ $ type_key ] = $ property ; } else { $ results [ $ index ] [ $ type_key ] = $ property -> get_child_property ( $ slug , $ children ) ; } } } return $ results ; } 
protected function prepare_properties ( $ layouts ) { $ layouts = array_map ( function ( $ layout ) { return ( array ) $ layout ; } , $ layouts ) ; foreach ( $ layouts as $ index => $ layout ) { if ( ! $ this -> valid_layout ( $ layout ) ) { if ( is_array ( $ layout ) ) { unset ( $ layout [ $ index ] ) ; } else { unset ( $ layouts [ $ index ] ) ; } continue ; } if ( ! isset ( $ layout [ 'slug' ] ) ) { $ layout [ 'slug' ] = $ layout [ 'title' ] ; } if ( ! isset ( $ layout [ 'row_label' ] ) ) { $ layout [ 'row_label' ] = $ layout [ 'title' ] ; } if ( ! isset ( $ layout [ 'show_label' ] ) ) { $ layout [ 'show_label' ] = true ; } $ layouts [ $ index ] = array_merge ( $ layouts [ $ index ] , $ layout ) ; $ layouts [ $ index ] [ 'slug' ] = papi_slugify ( $ layout [ 'slug' ] ) ; $ layouts [ $ index ] [ 'slug' ] = $ this -> get_layout_value ( $ layouts [ $ index ] [ 'slug' ] ) ; $ layouts [ $ index ] [ 'items' ] = parent :: prepare_properties ( $ layout [ 'items' ] ) ; } return array_filter ( $ layouts ) ; } 
public function render_ajax_request ( ) { $ items = null ; $ layouts = $ this -> get_settings_layouts ( ) ; if ( defined ( 'DOING_PAPI_AJAX' ) && DOING_PAPI_AJAX ) { $ counter = papi_get_qs ( 'counter' ) ; $ this -> counter = intval ( $ counter ) ; $ flexible_layout = papi_get_qs ( 'flexible_layout' ) ; foreach ( $ layouts as $ layout ) { if ( $ layout [ 'slug' ] === $ flexible_layout ) { $ items = $ layout ; break ; } } } if ( ! empty ( $ items ) ) { $ this -> render_properties ( $ items , false ) ; } } 
protected function render_layout_input ( $ value ) { $ slug = sprintf ( '%s[%d][%s]' , $ this -> get_slug ( ) , $ this -> counter , $ this -> layout_key ) ; ?> <input type="hidden" name="<?php echo esc_attr ( $ slug ) ; ?>" value="<?php echo esc_attr ( $ value ) ; ?>" /> <?php } 
protected function render_properties ( $ row , $ value ) { $ has_value = $ value !== false ; $ render_layout = $ this -> get_setting ( 'layout' ) ; $ layout_slug = isset ( $ row [ 'slug' ] ) ? $ row [ 'slug' ] : false ; $ layout_slug = empty ( $ layout_slug ) && isset ( $ value [ '_layout' ] ) ? $ value [ '_layout' ] : $ layout_slug ; $ layout_slug = empty ( $ layout_slug ) && isset ( $ value [ $ this -> layout_key ] ) ? $ value [ $ this -> layout_key ] : $ layout_slug ; $ row = isset ( $ row [ 'items' ] ) ? $ row [ 'items' ] : $ row ; $ layout = $ this -> get_layout ( $ layout_slug ) ; <td class="repeater-column flexible-column <?php echo $ render_layout === 'table' ? 'flexible-layout-table' : 'flexible-layout-row' ; ?>"> <div class="repeater-content-open"> <?php <label class="flexible-row-label"><?php echo esc_html ( $ layout [ 'row_label' ] ) ; ?></label> <?php endif ; ?> <table class="<?php echo $ render_layout === 'table' ? 'flexible-table' : 'papi-table' ; ?>"> <?php if ( $ render_layout === 'table' ) : echo '<thead>' ; for ( $ i = 0 , $ l = count ( $ row ) ; $ i < $ l ; $ i ++ ) { </table> </div> <div class="repeater-content-closed"> <?php if ( ! empty ( $ layout [ 'title' ] ) ) { echo esc_html ( $ layout [ 'title' ] ) ; } ?> </div> </td> <?php } 
protected function render_repeater ( $ options ) { $ layouts = $ this -> get_settings_layouts ( ) ; ?> <div class="papi-property-flexible papi-property-repeater-top" data-limit="<?php echo esc_attr ( $ this -> get_setting ( 'limit' ) ) ; ?>"> <table class="papi-table"> <tbody class="repeater-tbody flexible-tbody"> <?php $ this -> render_repeater_row ( ) ; ?> </tbody> </table> <div class="bottom"> <div class="flexible-layouts-btn-wrap"> <div class="flexible-layouts flexible-layouts-hidden"> <div class="flexible-layouts-arrow"></div> <ul> <?php foreach ( $ layouts as $ layout ) { papi_render_html_tag ( 'li' , [ papi_html_tag ( 'a' , [ 'data-layout' => esc_html ( $ layout [ 'slug' ] ) , 'data-papi-json' => sprintf ( '%s_repeater_json' , $ options -> slug ) , 'href' => '#' , 'role' => 'button' , 'tabindex' => 0 , esc_html ( $ layout [ 'title' ] ) ] ) ] ) ; } ?> </ul> </div> <?php papi_render_html_tag ( 'button' , [ 'class' => 'button button-primary' , 'type' => 'button' , esc_html ( $ this -> get_setting ( 'add_new_label' ) ) ] ) ; ?> </div> </div> <?php ?> <input type="hidden" data-papi-rule="<?php echo esc_attr ( $ options -> slug ) ; ?>" name="<?php echo esc_attr ( $ this -> get_slug ( ) ) ; ?>[]" /> </div> <?php } 
protected function render_repeater_row ( ) { $ layouts = $ this -> get_settings_layouts ( ) ; $ values = $ this -> get_value ( ) ; <tr <?php echo $ closed_rows ? 'class="closed"' : '' ; ?>> <td class="handle"> <span class="toggle"></span> <span class="count"><?php echo esc_html ( $ this -> counter + 1 ) ; ?></span> </td> <?php foreach ( $ layouts as $ layout ) { <td class="last"> <span> <a title="<?php esc_html_e ( 'Remove' , 'papi' ) ; ?>" href="#" class="repeater-remove-item">x</a> </span> </td> </tr> <?php endforeach ; } 
public function add_form_fields ( ) { $ html_name = esc_attr ( papi_get_page_type_key ( ) ) ; $ taxonomy = papi_get_qs ( 'taxonomy' ) ; $ taxonomy_object = get_taxonomy ( $ taxonomy ) ; <div class="form-field"> <label for="<?php echo esc_attr ( $ html_name ) ; ?>"> <?php echo esc_html ( sprintf ( __ ( '%s type' , 'papi' ) , $ taxonomy_object -> labels -> singular_name ) ) ; ?> </label> <select name="<?php echo esc_attr ( $ html_name ) ; ?>" id="<?php echo esc_attr ( $ html_name ) ; ?>" data-papi-page-type-key="true"> <?php foreach ( $ taxonomy_types as $ taxonomy_type ) { papi_render_html_tag ( 'option' , [ 'data-redirect' => $ taxonomy_type -> redirect_after_create , 'value' => esc_attr ( $ taxonomy_type -> get_id ( ) ) , esc_html ( $ taxonomy_type -> name ) ] ) ; } ?> </select> </div> <?php else : papi_render_html_tag ( 'input' , [ 'data-redirect' => $ taxonomy_types [ 0 ] -> redirect_after_create , 'data-papi-page-type-key' => true , 'name' => esc_attr ( $ html_name ) , 'type' => 'hidden' , 'value' => esc_attr ( $ taxonomy_types [ 0 ] -> get_id ( ) ) ] ) ; endif ; } 
protected function prepare_taxonomy_types ( array $ taxonomy_types ) { $ taxonomy = papi_get_qs ( 'taxonomy' ) ; if ( papi_filter_settings_show_standard_taxonomy_type ( $ taxonomy ) ) { $ id = sprintf ( 'papi-standard-%s-type' , $ taxonomy ) ; $ taxonomy_type = new Papi_Taxonomy_Type ( $ id ) ; $ taxonomy_type -> id = $ id ; $ taxonomy_type -> name = papi_filter_settings_standard_taxonomy_type_name ( $ taxonomy ) ; $ taxonomy_type -> taxonomy = [ $ taxonomy ] ; $ taxonomy_types [ ] = $ taxonomy_type ; } usort ( $ taxonomy_types , function ( $ a , $ b ) { return strcmp ( $ a -> name , $ b -> name ) ; } ) ; return papi_sort_order ( array_reverse ( $ taxonomy_types ) ) ; } 
public function setup_taxonomies_hooks ( ) { $ this -> taxonomy_types = papi_get_all_entry_types ( [ 'types' => 'taxonomy' ] ) ; $ taxonomies = array_reduce ( $ this -> taxonomy_types , function ( $ taxonomies , $ taxonomy_type ) { return array_merge ( $ taxonomies , $ taxonomy_type -> taxonomy ) ; } , [ ] ) ; $ taxonomies = array_unique ( $ taxonomies ) ; foreach ( $ taxonomies as $ taxonomy ) { if ( is_string ( $ taxonomy ) && taxonomy_exists ( $ taxonomy ) ) { add_action ( $ taxonomy . '_add_form_fields' , [ $ this , 'add_form_fields' ] ) ; } } } 
public function ajax_url ( ) { if ( empty ( $ this -> structure ) ) { $ url = esc_url ( home_url ( 'index.php' , is_ssl ( ) ? 'https' : 'http' ) ) ; } else { $ url = esc_url ( home_url ( '/papi-ajax/' , is_ssl ( ) ? 'https' : 'http' ) ) ; } ?> <script type="text/javascript"> var papi = papi || {}; papi.ajaxUrl = '<?php echo esc_html ( $ url ) ; ?>'; </script> <?php } 
public function handle_papi_ajax ( ) { if ( defined ( 'DOING_AJAX' ) && DOING_AJAX ) { return ; } $ ajax_action = '' ; if ( ! empty ( $ _GET [ 'action' ] ) ) { $ ajax_action = sanitize_text_field ( $ _GET [ 'action' ] ) ; } if ( is_user_logged_in ( ) && has_action ( $ this -> action_prefix . $ ajax_action ) !== false ) { if ( ! defined ( 'DOING_AJAX' ) ) { define ( 'DOING_AJAX' , true ) ; } if ( ! defined ( 'DOING_PAPI_AJAX' ) ) { define ( 'DOING_PAPI_AJAX' , true ) ; } status_header ( 200 ) ; do_action ( $ this -> action_prefix . $ ajax_action ) ; wp_die ( ) ; } } 
public function get_entry_type ( ) { $ entry_type_id = papi_get_qs ( 'entry_type' ) ; $ entry_type = papi_get_entry_type_by_id ( $ entry_type_id ) ; if ( empty ( $ entry_type ) ) { $ this -> render_error ( 'No entry type found' ) ; return ; } wp_send_json ( $ entry_type ) ; } 
public function get_posts ( ) { $ args = papi_get_qs ( 'query' ) ? : [ ] ; $ args = is_array ( $ args ) ? $ args : [ ] ; $ fields = papi_get_qs ( 'fields' ) ? : [ ] ; $ fields = is_array ( $ fields ) ? $ fields : [ ] ; $ posts = ( new WP_Query ( array_merge ( [ 'posts_per_page' => - 1 , 'post_status' => 'any' , 'post_type' => [ 'post' ] , 'no_found_rows' => true , 'update_post_meta_cache' => false , 'update_post_term_cache' => false ] , $ args ) ) ) -> posts ; $ posts = array_filter ( $ posts , function ( $ post ) { return ! empty ( $ post -> post_title ) ; } ) ; usort ( $ posts , function ( $ a , $ b ) { return strcmp ( strtolower ( $ a -> post_title ) , strtolower ( $ b -> post_title ) ) ; } ) ; if ( ! empty ( $ fields ) ) { foreach ( $ posts as $ index => $ post ) { $ item = [ ] ; foreach ( $ fields as $ field ) { $ item [ $ field ] = $ post -> $ field ; } $ posts [ $ index ] = $ item ; } } wp_send_json ( $ posts ) ; } 
public function get_property ( ) { $ default_options = Papi_Core_Property :: factory ( ) -> get_options ( ) ; $ keys = array_keys ( get_object_vars ( $ default_options ) ) ; $ options = papi_get_qs ( $ keys , true ) ; if ( $ property = papi_property ( $ options ) ) { ob_start ( ) ; $ property -> render_ajax_request ( ) ; $ html = ob_get_clean ( ) ; wp_send_json ( [ 'html' => utf8_encode ( $ html ) ] ) ; return ; } $ this -> render_error ( 'No property found' ) ; } 
public function get_properties ( ) { if ( ! papi_get_sanitized_post ( 'properties' ) ) { $ this -> render_error ( 'No properties found' ) ; return ; } $ items = json_decode ( stripslashes ( $ _POST [ 'properties' ] ) , true ) ; if ( empty ( $ items ) || ! is_array ( $ items ) ) { $ this -> render_error ( 'No properties found' ) ; return ; } foreach ( $ items as $ key => $ item ) { $ property = papi_property ( ( array ) $ item ) ; if ( ! papi_is_property ( $ property ) ) { unset ( $ items [ $ key ] ) ; continue ; } ob_start ( ) ; $ property -> render_ajax_request ( ) ; $ items [ $ key ] = trim ( ob_get_clean ( ) ) ; } $ items = array_filter ( $ items ) ; if ( empty ( $ items ) ) { $ this -> render_error ( 'No properties found' ) ; return ; } wp_send_json ( [ 'html' => $ items ] ) ; } 
public function get_rules_result ( ) { if ( ! papi_get_sanitized_post ( 'data' ) ) { $ this -> render_error ( 'No rule found' ) ; return ; } $ data = json_decode ( stripslashes ( papi_get_sanitized_post ( 'data' ) ) , true ) ; if ( empty ( $ data ) || ! is_array ( $ data ) || ! isset ( $ data [ 'slug' ] ) ) { $ this -> render_error ( 'No rule found' ) ; return ; } $ entry_type = papi_get_entry_type_by_meta_id ( ) ; if ( empty ( $ entry_type ) ) { $ entry_type_id = papi_get_qs ( 'entry_type' ) ; $ entry_type = papi_get_entry_type_by_id ( $ entry_type_id ) ; } if ( $ entry_type instanceof Papi_Entry_Type === false ) { $ this -> render_error ( 'No rule found' ) ; return ; } if ( preg_match ( '/\[\]$/' , $ data [ 'slug' ] ) ) { $ data [ 'slug' ] = preg_replace ( '/\[\]$/' , '' , $ data [ 'slug' ] ) ; } if ( $ property = $ entry_type -> get_property ( $ data [ 'slug' ] ) ) { wp_send_json ( [ 'render' => $ property -> render_is_allowed_by_rules ( $ data [ 'rules' ] ) ] ) ; return ; } $ this -> render_error ( 'No rule found' ) ; } 
public function get_shortcode ( ) { $ shortcode = papi_get_qs ( 'shortcode' ) ? : '' ; $ shortcode = html_entity_decode ( $ shortcode ) ; $ shortcode = wp_unslash ( $ shortcode ) ; wp_send_json ( [ 'html' => do_shortcode ( $ shortcode ) ] ) ; } 
public function get_terms ( ) { $ query = papi_get_qs ( 'query' ) ? : [ ] ; $ query = is_array ( $ query ) ? $ query : [ ] ; $ taxonomy = papi_get_qs ( 'taxonomy' ) ? : '' ; $ args = array_merge ( $ query , [ 'fields' => 'id=>name' ] ) ; $ terms = [ ] ; if ( taxonomy_exists ( $ taxonomy ) ) { $ terms = get_terms ( $ taxonomy , $ args ) ; } wp_send_json ( $ terms ) ; } 
protected function setup_actions ( ) { add_action ( 'init' , [ $ this , 'add_endpoint' ] ) ; add_action ( 'parse_request' , [ $ this , 'handle_papi_ajax' ] ) ; add_action ( 'admin_enqueue_scripts' , [ $ this , 'ajax_url' ] , 10 ) ; 
public function get ( $ args , $ assoc_args ) { try { 
public function rename ( $ args , $ assoc_args ) { $ type = $ args [ 0 ] ; $ old_key = $ args [ 1 ] ; $ new_key = $ args [ 2 ] ; $ terms = ( new Papi_Query ( [ 'entry_type' => $ type , 'fields' => 'ids' ] ) ) -> get_result ( ) ; if ( empty ( $ terms ) ) { WP_CLI :: error ( 'No terms found' ) ; } foreach ( $ terms as $ term ) { $ meta = get_term_meta ( $ term , $ old_key , true ) ; if ( papi_is_empty ( $ meta ) ) { continue ; } if ( delete_term_meta ( $ term , $ old_key ) === false ) { WP_CLI :: error ( 'Could not delete term meta with key: ' . $ old_key ) ; } if ( update_term_meta ( $ term , $ new_key , $ meta ) === false ) { WP_CLI :: error ( 'Could not update term meta with key: ' . $ new_key ) ; } } WP_CLI :: success ( 'Done' ) ; } 
public function manage_page_type_posts_columns ( array $ defaults = [ ] ) { if ( ! in_array ( $ this -> post_type , papi_get_post_types ( ) , true ) && ! in_array ( $ this -> taxonomy , papi_get_taxonomies ( ) , true ) ) { return $ defaults ; } if ( apply_filters ( 'papi/settings/column_hide_' . $ this -> get_meta_type_value ( ) , false ) ) { return $ defaults ; } $ defaults [ 'entry_type' ] = apply_filters ( 'papi/settings/column_title_' . $ this -> get_meta_type_value ( ) , esc_html__ ( 'Type' , 'papi' ) ) ; return $ defaults ; } 
public function manage_page_type_posts_custom_column ( $ column_name , $ post_id , $ term_id = null ) { if ( ! in_array ( $ this -> post_type , papi_get_post_types ( ) , true ) && ! in_array ( $ this -> taxonomy , papi_get_taxonomies ( ) , true ) ) { return ; } if ( apply_filters ( 'papi/settings/column_hide_' . $ this -> get_meta_type_value ( ) , false ) ) { return ; } 
public function manage_page_type_sortable_columns ( $ columns ) { if ( in_array ( $ this -> post_type , papi_get_post_types ( ) , true ) || in_array ( $ this -> taxonomy , papi_get_taxonomies ( ) , true ) ) { $ columns [ 'entry_type' ] = 'entry_type' ; } return $ columns ; } 
public function pre_get_posts ( WP_Query $ query ) { global $ pagenow ; if ( $ pagenow === 'edit.php' && ! is_null ( papi_get_qs ( 'page_type' ) ) ) { if ( papi_get_qs ( 'page_type' ) === 'papi-standard-page' ) { $ query -> set ( 'meta_query' , [ [ 'key' => papi_get_page_type_key ( ) , 'compare' => 'NOT EXISTS' ] ] ) ; } else { $ query -> set ( 'meta_key' , papi_get_page_type_key ( ) ) ; $ query -> set ( 'meta_value' , papi_get_qs ( 'page_type' ) ) ; } } 
public function restrict_page_types ( ) { $ post_types = papi_get_post_types ( ) ; if ( in_array ( $ this -> post_type , $ post_types , true ) ) { $ page_types = papi_get_all_page_types ( $ this -> post_type ) ; $ page_types = array_map ( function ( $ page_type ) { return [ 'name' => $ page_type -> name , 'value' => $ page_type -> get_id ( ) ] ; } , $ page_types ) ; <select name="page_type" class="postform"> <option value="0" selected><?php esc_html_e ( 'All types' , 'papi' ) ; ?></option> <?php foreach ( $ page_types as $ page_type ) { printf ( '<option value="%s" %s>%s</option>' , esc_attr ( $ page_type [ 'value' ] ) , papi_get_qs ( 'page_type' ) === $ page_type [ 'value' ] ? ' selected' : '' , esc_html ( $ page_type [ 'name' ] ) ) ; } ?> </select> <?php } } 
protected function setup_actions ( ) { 
protected function setup_filters ( ) { 
public function format_value ( $ value , $ slug , $ term_id ) { $ meta_key = $ this -> get_setting ( 'meta_key' ) ; if ( empty ( $ meta_key ) ) { if ( is_numeric ( $ value ) && intval ( $ value ) !== 0 ) { $ term_id = $ value ; } } else { $ args = [ 'fields' => 'ids' , 'meta_key' => $ meta_key , 'meta_value' => $ value , 'hide_empty' => false , 'taxonomy' => $ this -> get_setting ( 'taxonomy' ) , 'number' => 1 ] ; $ terms = get_terms ( $ args ) ; if ( ! empty ( $ terms ) && ! is_wp_error ( $ terms ) ) { $ term_id = $ terms [ 0 ] ; } } 
protected function get_labels ( ) { $ results = [ ] ; foreach ( $ this -> get_taxonomies ( ) as $ taxonomy ) { if ( taxonomy_exists ( $ taxonomy ) ) { $ taxonomy_object = get_taxonomy ( $ taxonomy ) ; $ results [ $ taxonomy ] = $ taxonomy_object -> labels -> name ; } } return $ results ; } 
protected function get_terms ( $ taxonomy ) { 
protected function get_term_value ( $ term ) { $ meta_key = $ this -> get_setting ( 'meta_key' ) ; if ( is_numeric ( $ term ) ) { $ term_id = $ term ; } else { $ term = get_term ( $ term ) ; if ( $ term instanceof WP_Term === false ) { return 0 ; } $ term_id = $ term -> term_id ; } if ( ! empty ( $ meta_key ) ) { $ value = get_term_meta ( $ term_id , $ meta_key , true ) ; } else { $ value = $ term_id ; } return $ value ; } 
public function html ( ) { $ settings = $ this -> get_settings ( ) ; $ layout = $ settings -> layout ; $ labels = $ this -> get_labels ( ) ; $ taxonomies = $ this -> get_taxonomies ( ) ; $ render_label = count ( $ taxonomies ) > 1 ; $ advanced = $ render_label && $ layout === 'advanced' ; $ single = $ render_label && $ layout !== 'advanced' ; $ classes = count ( $ taxonomies ) > 1 ? '' : 'papi-fullwidth' ; $ value = $ this -> get_value ( ) ; $ selected_term = get_term ( $ value ) ; $ selected_term = is_wp_error ( $ selected_term ) || empty ( $ selected_term ) ? '' : $ selected_term ; $ selected_taxonomy = empty ( $ selected_term ) ? reset ( $ taxonomies ) : $ selected_term -> taxonomy ; $ value = $ this -> get_term_value ( $ value ) ; $ selected_label = reset ( $ labels ) ; if ( $ settings -> select2 ) { $ classes = ' papi-component-select2' ; } ?> <div class="papi-property-term <?php echo $ advanced ? 'advanced' : '' ; ?>"> <?php if ( $ advanced ) : ?> <table class="papi-table"> <tr> <td> <label for="<?php echo esc_attr ( $ this -> html_id ( ) ) ; ?>_taxonomy"> <?php echo esc_html ( $ settings -> labels [ 'select_taxonomy' ] ) ; ?> </label> </td> <td> <select id="<?php echo esc_attr ( $ this -> html_id ( ) ) ; ?>_taxonomy" class="<?php echo esc_attr ( $ classes ) ; ?> papi-property-term-left" data-select-item="<?php echo esc_attr ( $ settings -> labels [ 'select_item' ] ) ; ?>" data-term-query='<?php echo esc_attr ( papi_maybe_json_encode ( $ settings -> query ) ) ; ?>' data-width="100%" > <?php foreach ( $ labels as $ taxonomy => $ label ) { papi_render_html_tag ( 'option' , [ 'value' => $ taxonomy , 'selected' => $ taxonomy === $ selected_taxonomy , $ label ] ) ; if ( $ selected ) { $ selected_label = $ label ; } } ?> </select> </td> </tr> <tr> <td> <label for="<?php echo esc_attr ( $ this -> html_id ( ) ) ; ?>_terms"> <?php echo esc_html ( sprintf ( $ settings -> labels [ 'select_item' ] , $ selected_label ) ) ; ?> </label> </td> <td> <?php endif ; ?> <?php $ placeholder = ! is_null ( $ settings -> placeholder ) ? $ settings -> placeholder : '' ; $ placeholder = papi_is_empty ( $ placeholder ) ? '&nbsp;' : $ placeholder ; ?> <select class="<?php echo esc_attr ( $ classes ) ; ?> papi-property-term-right" id="<?php echo esc_attr ( $ this -> html_id ( ) ) ; ?>_terms" name="<?php echo esc_attr ( $ this -> html_name ( ) ) ; ?>" class="<?php echo esc_attr ( $ classes ) ; ?>" data-allow-clear="<?php echo is_null ( $ settings -> placeholder ) ? 'false' : 'true' ; ?>" data-placeholder="<?php echo esc_attr ( $ placeholder ) ; ?>" data-width="100%"> <?php if ( ! is_null ( $ settings -> placeholder ) ) : ?> <option value="<?php echo esc_attr ( $ this -> get_option ( 'default' , ' ' ) ) ; ?>"><?php echo esc_html ( $ placeholder ) ; ?></option> <?php endif ; ?> <?php foreach ( $ taxonomies as $ taxonomy ) : ?> <?php if ( $ advanced && $ taxonomy !== $ selected_taxonomy ) { continue ; } $ terms = $ this -> get_terms ( $ taxonomy ) ; if ( empty ( $ terms ) ) { continue ; } ?> <?php if ( $ single ) : ?> <optgroup label="<?php echo esc_attr ( $ labels [ $ taxonomy ] ) ; ?>"> <?php endif ; ?> <?php foreach ( $ terms as $ term_id => $ term_name ) { if ( papi_is_empty ( $ term_name ) ) { continue ; } papi_render_html_tag ( 'option' , [ 'data-allow-clear' => $ settings -> allow_clear , 'value' => $ this -> get_term_value ( $ term_id ) , 'selected' => $ value === $ this -> get_term_value ( $ term_id ) , esc_html ( $ term_name ) ] ) ; } ?> <?php if ( $ single ) : ?> </optgroup> <?php endif ; ?> <?php endforeach ; ?> </select> <?php if ( $ advanced ) : ?> </td> </tr> </table> <?php endif ; ?> </div> <?php } 
public function format_value ( $ value , $ slug , $ post_id ) { if ( is_string ( $ value ) && $ value === 'false' || $ value === false ) { return false ; } return is_string ( $ value ) && ( $ value === 'true' || $ value === 'on' ) || $ value === true ; } 
public function html ( ) { $ value = $ this -> get_value ( ) ; papi_render_html_tag ( 'input' , [ 'type' => 'hidden' , 'name' => esc_attr ( $ this -> html_name ( ) ) , 'value' => false ] ) ; papi_render_html_tag ( 'input' , [ 'checked' => ! empty ( $ value ) , 'id' => esc_attr ( $ this -> html_id ( ) ) , 'name' => esc_attr ( $ this -> html_name ( ) ) , 'type' => 'checkbox' ] ) ; } 
protected function prepare_value ( $ value ) { if ( is_string ( $ value ) && ( $ value === 'true' || $ value === 'on' ) || $ value === true ) { return true ; } return null ; } 
public function html ( ) { $ post_id = papi_get_post_id ( ) ; $ settings = $ this -> get_settings ( ) ; <ul class="papi-property-reference" data-papi-rule="<?php echo esc_attr ( $ this -> html_name ( ) ) ; ?>"> <?php if ( empty ( $ values ) ) : ?> <p> <?php esc_html_e ( 'No references exists' , 'papi' ) ; ?> </p> <?php endif ; ksort ( $ values ) ; foreach ( $ values as $ title => $ val ) : $ post_type = get_post_type_object ( $ title ) ; ?> <li> <h3><?php echo esc_html ( $ post_type -> labels -> name ) ; ?></h3> <div class="handlediv" title="Click to toggle"><br></div> </li> <li> <div class="page-types"> <ul> <?php ksort ( $ val ) ; foreach ( $ val as $ name => $ posts ) : ?> <li class="heading-border"> <h4><?php echo esc_html ( $ name ) ; ?></h4> <div class="handlediv" title="Click to toggle"><br></div> </li> <li> <div class="box"> <?php $ i = 0 ; foreach ( $ posts as $ post ) : ?> <a href="<?php echo esc_attr ( get_edit_post_link ( $ post -> ID ) ) ; ?>"><?php echo esc_html ( $ post -> post_title ) ; ?></a> <?php $ i ++ ; endforeach ; ?> <div class="clear"></div> </div> </li> <?php endforeach ; ?> </ul> <div class="clear"></div> </div> </li> <?php endforeach ; ?> </ul> <?php } 
public function search ( $ searchTerm ) { $ url = 'https://finance.yahoo.com/_finance_doubledown/api/resource/searchassist;gossipConfig=%7B%22queryKey%22:%22query%22,%22resultAccessor%22:%22ResultSet.Result%22,%22suggestionTitleAccessor%22:%22symbol%22,%22suggestionMeta%22:[%22symbol%22],%22url%22:%7B%22query%22:%7B%22region%22:%22US%22,%22lang%22:%22en-US%22%7D%7D%7D;searchTerm=' . urlencode ( $ searchTerm ) . '?bkt=[%22findd-ctrl%22,%22fin-strm-test1%22,%22fndmtest%22,%22finnossl%22]&device=desktop&feature=canvassOffnet,finGrayNav,newContentAttribution,relatedVideoFeature,videoNativePlaylist,livecoverage&intl=us&lang=en-US&partner=none&prid=eo2okrhcni00f&region=US&site=finance&tz=UTC&ver=0.102.432&returnMeta=true' ; $ responseBody = ( string ) $ this -> client -> request ( 'GET' , $ url ) -> getBody ( ) ; return $ this -> resultDecoder -> transformSearchResult ( $ responseBody ) ; } 
public function getHistoricalData ( $ symbol , $ interval , \ DateTime $ startDate , \ DateTime $ endDate ) { $ allowedIntervals = [ self :: INTERVAL_1_DAY , self :: INTERVAL_1_WEEK , self :: INTERVAL_1_MONTH ] ; if ( ! in_array ( $ interval , $ allowedIntervals ) ) { throw new \ InvalidArgumentException ( 'Interval must be one of: ' . implode ( ', ' , $ allowedIntervals ) ) ; } if ( $ startDate > $ endDate ) { throw new \ InvalidArgumentException ( 'Start date must be before end date' ) ; } $ cookieJar = new CookieJar ( ) ; $ initialUrl = 'https://finance.yahoo.com/quote/' . urlencode ( $ symbol ) . '/history?p=' . urlencode ( $ symbol ) ; $ responseBody = ( string ) $ this -> client -> request ( 'GET' , $ initialUrl , [ 'cookies' => $ cookieJar ] ) -> getBody ( ) ; $ crumb = $ this -> resultDecoder -> extractCrumb ( $ responseBody ) ; $ dataUrl = 'https://query1.finance.yahoo.com/v7/finance/download/' . urlencode ( $ symbol ) . '?period1=' . $ startDate -> getTimestamp ( ) . '&period2=' . $ endDate -> getTimestamp ( ) . '&interval=' . $ interval . '&events=history&crumb=' . urlencode ( $ crumb ) ; $ responseBody = ( string ) $ this -> client -> request ( 'GET' , $ dataUrl , [ 'cookies' => $ cookieJar ] ) -> getBody ( ) ; return $ this -> resultDecoder -> transformHistoricalDataResult ( $ responseBody ) ; } 
public function getQuote ( $ symbol ) { $ list = $ this -> fetchQuotes ( [ $ symbol ] ) ; return isset ( $ list [ 0 ] ) ? $ list [ 0 ] : null ; } 
public function getExchangeRate ( $ currency1 , $ currency2 ) { $ list = $ this -> getExchangeRates ( [ [ $ currency1 , $ currency2 ] ] ) ; return isset ( $ list [ 0 ] ) ? $ list [ 0 ] : null ; } 
public function getExchangeRates ( array $ currencyPairs ) { $ currencySymbols = array_map ( function ( array $ currencies ) { return implode ( $ currencies ) . self :: CURRENCY_SYMBOL_SUFFIX ; 
private function fetchQuotes ( array $ symbols ) { $ url = 'https://query1.finance.yahoo.com/v7/finance/quote?symbols=' . urlencode ( implode ( ',' , $ symbols ) ) ; $ responseBody = ( string ) $ this -> client -> request ( 'GET' , $ url ) -> getBody ( ) ; return $ this -> resultDecoder -> transformQuotes ( $ responseBody ) ; } 
public static function createApiClient ( ClientInterface $ guzzleClient = null ) { $ guzzleClient = $ guzzleClient ? $ guzzleClient : new Client ( ) ; $ resultDecoder = new ResultDecoder ( ) ; return new ApiClient ( $ guzzleClient , $ resultDecoder ) ; } 
public function fire ( ) { if ( $ this -> option ( 'new' ) ) { $ this -> createNewAdministrator ( ) ; return ; } if ( $ this -> option ( 'delete' ) ) { $ this -> deleteAdministrator ( ) ; return ; } if ( $ this -> option ( 'password' ) ) { $ this -> changePassword ( ) ; return ; } $ this -> listAdministrators ( ) ; } 
protected function getAttributesForHeader ( ) { $ attributes = [ ] ; if ( ! $ this -> isSortable ( ) ) { $ attributes [ 'data-sortable' ] = 'false' ; } if ( $ this -> isSortableDefault ( ) ) { $ attributes [ 'data-sortable-default' ] = $ this -> sortableDest ; } $ attributes [ 'style' ] = 'width:10px;' ; return $ attributes ; } 
public function render ( $ instance , $ totalCount , $ content = null ) { if ( is_null ( $ content ) ) { $ content = $ this -> valueFromInstance ( $ instance , $ this -> name ) ; } $ content = $ this -> renderAppends ( $ instance , $ totalCount , $ content ) ; return $ this -> htmlBuilder -> tag ( 'td' , $ this -> getAttributesForCell ( $ instance ) , $ content ) ; } 
protected function renderAppends ( $ instance , $ totalCount , $ content ) { $ appends = [ $ content ] ; foreach ( $ this -> appends as $ append ) { $ appends [ ] = $ append -> render ( $ instance , $ totalCount ) ; } return implode ( ' ' , $ appends ) ; } 
public function valueFromInstance ( $ instance , $ name ) { $ result = $ instance ; $ parts = explode ( '.' , $ name ) ; foreach ( $ parts as $ part ) { if ( $ result instanceof Collection ) { $ result = $ result -> lists ( $ part ) ; } elseif ( is_null ( $ result ) ) { $ result = null ; } else { $ result = $ result -> $ part ; } } if ( is_string ( $ result ) ) { $ result = e ( $ result ) ; } return $ result ; } 
public function getAll ( ) { $ files = $ this -> getAllFiles ( ) ; $ result = [ ] ; foreach ( $ files as $ file ) { $ result [ ] = $ this -> createImageObject ( $ file ) ; } return $ result ; } 
public function postUpload ( ) { $ imageDirectory = Config :: get ( 'admin.imagesUploadDirectory' ) ; $ upload_dir = Config :: get ( 'admin.imagesDirectory' ) . '/' . $ imageDirectory ; $ allowedExtensions = [ 'bmp' , 'gif' , 'jpg' , 'jpeg' , 'png' ] ; $ maxsize = 2000 ; $ maxwidth = 9000 ; $ maxheight = 8000 ; $ minwidth = 10 ; $ minheight = 10 ; $ file = Input :: file ( 'upload' ) ; $ errors = [ ] ; $ extension = null ; $ width = 0 ; $ height = 0 ; try { if ( is_null ( $ file ) ) { $ errors [ ] = Lang :: get ( 'admin::lang.ckeditor.upload.error.common' ) ; throw new Exception ; } $ extension = $ file -> guessClientExtension ( ) ; if ( ! in_array ( $ extension , $ allowedExtensions ) ) { $ errors [ ] = Lang :: get ( 'admin::lang.ckeditor.upload.error.wrong_extension' , [ 'file' => $ file -> getClientOriginalName ( ) ] ) ; throw new Exception ; } if ( $ file -> getSize ( ) > $ maxsize * 1000 ) { $ errors [ ] = Lang :: get ( 'admin::lang.ckeditor.upload.error.filesize_limit' , [ 'size' => $ maxsize ] ) ; } $ image = App :: make ( 'image' ) -> make ( $ file ) ; $ width = $ image -> width ( ) ; $ height = $ image -> height ( ) ; if ( $ width > $ maxwidth || $ height > $ maxheight ) { $ errors [ ] = Lang :: get ( 'admin::lang.ckeditor.upload.error.imagesize_max_limit' , [ 'width' => $ width , 'height' => $ height , 'maxwidth' => $ maxwidth , 'maxheight' => $ maxheight ] ) ; } if ( $ width < $ minwidth || $ height < $ minheight ) { $ errors [ ] = Lang :: get ( 'admin::lang.ckeditor.upload.error.imagesize_min_limit' , [ 'width' => $ width , 'height' => $ height , 'minwidth' => $ minwidth , 'minheight' => $ minheight ] ) ; } } catch ( Exception $ e ) { } if ( ! empty ( $ errors ) ) { return '<script>alert("' . implode ( '\\n' , $ errors ) . '");</script>' ; } $ finalFilename = RandomFilenamer :: get ( $ upload_dir , $ extension ) ; $ file = $ file -> move ( $ upload_dir , $ finalFilename ) ; $ CKEditorFuncNum = Input :: get ( 'CKEditorFuncNum' ) ; $ url = URL :: route ( 'imagecache' , [ 'original' , $ imageDirectory . '/' . $ finalFilename ] ) ; $ message = Lang :: get ( 'admin::lang.ckeditor.upload.success' , [ 'size' => number_format ( $ file -> getSize ( ) / 1024 , 3 , '.' , '' ) , 'width' => $ width , 'height' => $ height ] ) ; $ result = "window.parent.CKEDITOR.tools.callFunction($CKEditorFuncNum, '$url', '$message')" ; return '<script>' . $ result . ';</script>' ; } 
public function register ( ) { $ this -> registerCommands ( ) ; $ this -> app -> register ( '\Intervention\Image\ImageServiceProvider' ) ; $ this -> app -> register ( '\SleepingOwl\AdminAuth\AdminAuthServiceProvider' ) ; $ this -> registerFormBuilder ( ) ; $ this -> app -> bind ( 'SleepingOwl\Admin\Repositories\Interfaces\ModelRepositoryInterface' , 'SleepingOwl\Admin\Repositories\ModelRepository' ) ; $ this -> app -> bindShared ( 'SleepingOwl\Admin\Admin' , function ( $ app ) { return Admin :: instance ( ) ; } ) ; $ this -> app -> singleton ( 'admin' , 'SleepingOwl\Admin\Admin' ) ; $ this -> app -> bind ( 'admin.router' , function ( ) { return Admin :: instance ( ) -> router ; } ) ; $ this -> registerValidateExceptionHandler ( ) ; } 
public function fire ( ) { $ title = $ this -> option ( 'title' ) ; $ this -> call ( 'vendor:publish' , [ '--provider' => 'Intervention\Image\ImageServiceProviderLaravel5' ] ) ; $ this -> call ( 'vendor:publish' , [ '--provider' => 'SleepingOwl\Admin\AdminServiceProvider' ] ) ; $ this -> publishDB ( ) ; $ this -> publishImagecacheConfig ( ) ; $ this -> publishSelfConfig ( $ title ) ; $ this -> createBootstrapDirectory ( ) ; $ this -> createMenuFile ( ) ; $ this -> createBootstrapFile ( ) ; $ this -> createDummyUserFile ( ) ; $ this -> createPublicDefaultStructure ( ) ; } 
public function with ( $ params = null ) { if ( ! is_array ( $ params ) ) { $ params = func_get_args ( ) ; } $ this -> with = $ params ; return $ this ; } 
public function setDefaults ( ) { foreach ( $ this -> items as $ item ) { $ name = $ item -> getName ( ) ; if ( ! is_null ( $ name ) && ! isset ( $ this -> instance -> $ name ) ) { $ this -> instance -> $ name = $ item -> getDefault ( ) ; } } } 
public static function get ( $ path , $ extension ) { if ( ! Str :: endsWith ( $ path , '/' ) ) { $ path .= '/' ; } do { $ name = Str :: random ( 10 ) . '.' . $ extension ; } while ( file_exists ( $ path . $ name ) ) ; return $ name ; } 
public function filter ( Builder $ query , $ parameters ) { $ parameter = $ this -> getParameter ( $ parameters ) ; if ( is_null ( $ parameter ) ) return null ; if ( ! $ this -> applyScope ( $ query , $ parameter ) && $ this -> name ) { $ query -> where ( $ this -> name , '=' , $ parameter ) ; } return $ this -> title -> get ( $ parameter ) ; } 
protected function applyScope ( Builder $ query , $ parameter ) { if ( $ this -> scope ) { $ query -> { $ this -> scope } ( $ parameter ) ; return true ; } return false ; } 
public function fire ( ) { $ compiler = new ModelCompiler ( $ this , $ this -> getModelClass ( ) , $ this -> option ( 'title' ) ) ; $ compiler -> parseColumns ( $ this -> option ( 'columns' ) ) ; $ compiler -> generateForm ( ) ; $ template = $ this -> getTemplate ( ) ; $ replacement = $ compiler -> getReplacements ( ) ; $ template = $ this -> makeReplacements ( $ template , $ replacement ) ; $ this -> saveResult ( $ compiler -> getModelClass ( ) , $ template ) ; } 
public function from ( $ modelClass , $ field = null ) { $ this -> from = $ modelClass ; $ this -> field = $ field ? : static :: DEFAULT_FIELD ; return $ this ; } 
public function get ( $ parameter ) { if ( ! is_null ( $ this -> staticTitle ) ) return $ this -> staticTitle ; if ( is_null ( $ this -> from ) ) { throw new TitleNotFormattedException ; } $ from = $ this -> from ; $ property = $ this -> field ; $ model = new $ this -> from ; $ model = $ this -> getInstance ( $ parameter , $ model ) ; if ( isset ( $ model -> $ property ) ) { return $ model -> $ property ; } throw new ModelAttributeNotFoundException ( $ from , $ property ) ; } 
protected function makeGroup ( $ name , $ label , $ formElement ) { $ content = '' ; $ content .= $ this -> label ( $ name , $ label ) ; $ content .= $ formElement ; return $ this -> wrapContent ( $ name , $ content ) ; } 
protected function wrapContent ( $ name , $ content ) { $ content .= $ this -> errors -> first ( $ name , $ this -> getErrorTemplate ( ) ) ; $ class = $ this -> getErrorClass ( $ name ) ; return $ this -> wrapGroup ( $ content , compact ( 'class' ) ) ; } 
protected function wrapGroup ( $ content , array $ options = [ ] ) { $ options = $ this -> addClassToOptions ( $ this -> getFormGroupClass ( ) , $ options ) ; return $ this -> html -> tag ( 'div' , $ options , $ content ) ; } 
protected function addClassToOptions ( $ classToAdd , array $ options = [ ] ) { $ class = array_get ( $ options , 'class' , '' ) ; if ( is_array ( $ class ) ) { $ class [ ] = $ classToAdd ; } elseif ( ! empty ( $ class ) ) { $ class .= ' ' . $ classToAdd ; } else { $ class = $ classToAdd ; } array_set ( $ options , 'class' , $ class ) ; return $ options ; } 
public function registerRoutes ( ) { $ this -> registerAssetsRoutes ( ) ; $ this -> registerAuthRoutes ( ) ; $ this -> registerImageCacheRoute ( ) ; $ models = Admin :: instance ( ) -> models -> getAllAliases ( ) ; $ this -> laravelRouter -> group ( [ 'prefix' => $ this -> prefix , 'before' => $ this -> getBeforeFilters ( ) , 'namespace' => 'SleepingOwl\Admin\Controllers' , ] , function ( ) use ( $ models ) { if ( empty ( $ models ) ) $ models = [ '__empty_models__' ] ; $ this -> laravelRouter -> group ( [ 'where' => [ 'model' => implode ( '|' , $ models ) ] ] , function ( ) { foreach ( static :: $ modelRoutes as $ route ) { $ url = $ route [ 'url' ] ; $ action = $ route [ 'action' ] ; $ method = $ route [ 'method' ] ; $ controller = isset ( $ route [ 'controller' ] ) ? $ route [ 'controller' ] : 'AdminController' ; $ this -> laravelRouter -> $ method ( $ url , [ 'as' => $ this -> routePrefix . '.table.' . $ action , 'uses' => $ controller . '@' . $ action ] ) ; } } ) ; $ wildcardRoute = $ this -> laravelRouter -> any ( '{wildcard?}' , [ 'as' => $ this -> routePrefix . '.wildcard' , 'uses' => 'AdminController@getWildcard' ] ) -> where ( 'wildcard' , '.*' ) ; $ this -> setRoutePriority ( $ wildcardRoute , 0 ) ; } ) ; } 
protected function registerAssetsRoutes ( ) { # CKEditor file listing and upload $ this -> laravelRouter -> group ( [ 'before' => $ this -> getBeforeFilters ( ) , 'prefix' => 'images' , 'namespace' => 'SleepingOwl\Admin\Controllers' ] , function ( ) { $ this -> laravelRouter -> get ( 'all' , 'ImagesController@getAll' ) ; $ this -> laravelRouter -> post ( 'upload' , 'ImagesController@postUpload' ) ; } ) ; $ this -> laravelRouter -> get ( 'js/{locale}/lang.js' , [ 'prefix' => $ this -> prefix , 'as' => $ this -> routePrefix . '.lang' , 'uses' => 'SleepingOwl\Admin\Controllers\LangController@getAll' ] ) ; } 
protected function registerAuthRoutes ( ) { $ this -> laravelRouter -> group ( [ 'prefix' => $ this -> prefix , 'namespace' => 'SleepingOwl\Admin\Controllers' ] , function ( ) { $ this -> laravelRouter -> get ( 'login' , [ 'as' => $ this -> routePrefix . '.login' , 'uses' => 'AuthController@getLogin' ] ) ; $ this -> laravelRouter -> post ( 'login' , [ 'as' => $ this -> routePrefix . '.login.post' , 'uses' => 'AuthController@postLogin' ] ) -> before ( 'csrf' ) ; $ this -> laravelRouter -> get ( 'logout' , [ 'as' => $ this -> routePrefix . '.logout' , 'uses' => 'AuthController@getLogout' ] ) ; } ) ; } 
public function add ( ProcessWrapper $ processWrapper ) : void { $ className = $ processWrapper -> getClassName ( ) ; if ( isset ( $ this -> processes [ $ className ] ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Testcase with name "%s" was already added, make sure you don\'t have duplicate class names.' , $ className ) ) ; } $ this -> processes [ $ className ] = $ processWrapper ; $ this -> graph -> createVertex ( $ className ) ; if ( $ this -> publisher ) { $ this -> publisher -> publishResults ( $ className , ProcessWrapper :: PROCESS_STATUS_QUEUED , null ) ; } } 
public function get ( string $ status ) : array { Assertion :: choice ( $ status , ProcessWrapper :: PROCESS_STATUSES ) ; $ return = [ ] ; foreach ( $ this -> processes as $ className => $ processWrapper ) { if ( $ processWrapper -> getStatus ( ) === $ status ) { $ return [ $ className ] = $ processWrapper ; } } return $ return ; } 
public function buildTree ( ) : OutTree { if ( $ this -> tree === null ) { $ root = $ this -> graph -> createVertex ( 0 ) ; 
public function optimizeOrder ( OptimizeOrderInterface $ optimizeStrategy ) : void { $ optimizedOrder = $ optimizeStrategy -> optimize ( $ this -> buildTree ( ) ) ; 
public function countStatuses ( ) : array { $ statusesCount = [ ] ; foreach ( ProcessWrapper :: PROCESS_STATUSES as $ status ) { $ statusesCount [ $ status ] = count ( $ this -> get ( $ status ) ) ; } return $ statusesCount ; } 
public function countResults ( ) : array { $ done = $ this -> get ( ProcessWrapper :: PROCESS_STATUS_DONE ) ; $ doneClasses = [ ] ; $ resultsCount = [ ProcessWrapper :: PROCESS_RESULT_PASSED => 0 , ProcessWrapper :: PROCESS_RESULT_FAILED => 0 , ProcessWrapper :: PROCESS_RESULT_FATAL => 0 , ] ; 
public function failDependants ( string $ className ) : array { $ descendantProcesses = $ this -> getDependencyTree ( $ className ) ; $ failedProcesses = [ ] ; foreach ( $ descendantProcesses as $ processClassName => $ processWrapper ) { $ failedProcesses [ $ processClassName ] = $ processWrapper ; $ processWrapper -> setStatus ( ProcessWrapper :: PROCESS_STATUS_DONE ) ; } return $ failedProcesses ; } 
protected function getDependencyTree ( string $ className ) : array { Assertion :: notEmpty ( $ this -> tree , 'Cannot get dependency tree - the tree was not yet build using buildTree()' ) ; $ descendants = $ this -> tree -> getVerticesDescendant ( $ this -> graph -> getVertex ( $ className ) ) ; $ descendantProcesses = [ ] ; foreach ( $ descendants as $ descendant ) { $ descendantProcesses [ $ descendant -> getId ( ) ] = $ this -> processes [ $ descendant -> getId ( ) ] ; } return $ descendantProcesses ; } 
public function output ( string $ output , string $ identifier ) : void { if ( empty ( $ output ) ) { return ; } $ lines = explode ( "\n" , $ output ) ; foreach ( $ lines as $ line ) { 
public function errorOutput ( string $ output , string $ identifier ) : void { $ output = rtrim ( $ output ) ; if ( empty ( $ output ) ) { return ; } $ lines = explode ( "\n" , $ output ) ; foreach ( $ lines as $ line ) { $ this -> write ( '<error>' . $ identifier . ' ERR> ' ) ; $ this -> writeln ( $ line . '</>' ) ; } } 
protected function configure ( ) : void { $ this -> setName ( 'run' ) -> setDescription ( 'Run tests planner and execute tests' ) -> addArgument ( self :: ARGUMENT_ENVIRONMENT , InputArgument :: REQUIRED , 'Environment name (must be specified to avoid unintentional run against production)' ) -> addArgument ( self :: ARGUMENT_BROWSER , InputArgument :: REQUIRED , 'Browser in which tests should be run' ) -> addOption ( self :: OPTION_SERVER_URL , null , InputOption :: VALUE_REQUIRED , 'Selenium server (hub) URL ' , 'http://localhost:4444/wd/hub' ) -> addOption ( self :: OPTION_CAPABILITY , null , InputOption :: VALUE_IS_ARRAY | InputOption :: VALUE_REQUIRED , 'Extra DesiredCapabilities to be passed to WebDriver, use format capabilityName:value' ) -> addOption ( self :: OPTION_TESTS_DIR , null , InputOption :: VALUE_REQUIRED , 'Path to directory with tests' , STEWARD_BASE_DIR . DIRECTORY_SEPARATOR . 'tests' ) -> addOption ( self :: OPTION_LOGS_DIR , null , InputOption :: VALUE_REQUIRED , 'Path to directory with logs' , STEWARD_BASE_DIR . DIRECTORY_SEPARATOR . 'logs' ) -> addOption ( self :: OPTION_PATTERN , null , InputOption :: VALUE_REQUIRED , 'Pattern for test files to be run' , '*Test.php' ) -> addOption ( self :: OPTION_GROUP , null , InputOption :: VALUE_REQUIRED | InputOption :: VALUE_IS_ARRAY , 'Only run testcases with specified @group of this name' ) -> addOption ( self :: OPTION_EXCLUDE_GROUP , null , InputOption :: VALUE_REQUIRED | InputOption :: VALUE_IS_ARRAY , 'Exclude testcases with specified @group from being run' ) -> addOption ( self :: OPTION_FILTER , null , InputOption :: VALUE_REQUIRED , 'Run only testcases/tests with name matching this filter' ) -> addOption ( self :: OPTION_NO_EXIT , null , InputOption :: VALUE_NONE , 'Always exit with code 0 <comment>(by default any failed test causes the command to return 1)</comment>' ) -> addOption ( self :: OPTION_IGNORE_DELAYS , 'i' , InputOption :: VALUE_NONE , 'Ignore delays defined between testcases' ) -> addOption ( self :: OPTION_PARALLEL_LIMIT , 'l' , InputOption :: VALUE_REQUIRED , 'Number of maximum testcases being executed in a parallel' , 50 ) ; $ this -> addUsage ( 'staging firefox' ) ; $ this -> addUsage ( '--group=foo --group=bar --exclude-group=baz -vvv development phantomjs' ) ; $ this -> getDispatcher ( ) -> dispatch ( CommandEvents :: CONFIGURE , new BasicConsoleEvent ( $ this ) ) ; } 
protected function initialize ( InputInterface $ input , OutputInterface $ output ) : void { parent :: initialize ( $ input , $ output ) ; $ output -> writeln ( sprintf ( '<info>Steward</info> <comment>%s</comment> is running the tests...%s' , $ this -> getApplication ( ) -> getVersion ( ) , ( ! ( new CiDetector ( ) ) -> isCiDetected ( ) ? ' Just for you <fg=red><3</fg=red>!' : '' ) ) ) ; 
public function onCommandConfigure ( BasicConsoleEvent $ event ) : void { if ( $ event -> getCommand ( ) -> getName ( ) !== 'run' ) { return ; } $ event -> getCommand ( ) -> addOption ( self :: OPTION_NO_CLEAN , null , InputOption :: VALUE_NONE , 'Do not clean content of logs directory on startup' ) ; } 
public function getVersion ( ) : ? string { if ( ! $ this -> version ) { $ this -> version = self :: getLatestVersion ( ) ; } return $ this -> version ; } 
public function getFileUrl ( ) : string { $ version = $ this -> getVersion ( ) ; Assert :: that ( $ version , 'Invalid version (expected format is X.Y.Z)' ) -> notEmpty ( ) -> regex ( '/^\d+\.\d+\.[\da-z\-]+$/i' ) ; $ versionParts = explode ( '.' , $ version ) ; $ devVersion = '' ; if ( preg_match ( '/(\d+)-([[:alnum:]]+)/' , $ versionParts [ 2 ] , $ matches ) ) { $ devVersion = $ matches [ 2 ] ; } $ fileUrl = self :: $ storageUrl . '/' . $ versionParts [ 0 ] . '.' . $ versionParts [ 1 ] . ( ! empty ( $ devVersion ) ? '-' . $ devVersion : '' ) . '/' . $ this -> getFileName ( ) ; return $ fileUrl ; } 
public function download ( ) : int { $ targetPath = $ this -> getFilePath ( ) ; if ( ! is_dir ( dirname ( $ targetPath ) ) ) { mkdir ( dirname ( $ targetPath ) , 0777 , true ) ; } $ fileUrl = $ this -> getFileUrl ( ) ; $ fp = @ fopen ( $ fileUrl , 'rb' ) ; $ responseHeaders = get_headers ( $ fileUrl ) ; if ( mb_strpos ( $ responseHeaders [ 0 ] , '200 OK' ) === false ) { throw new \ RuntimeException ( sprintf ( 'Error downloading file "%s" (%s)' , $ fileUrl , $ responseHeaders [ 0 ] ) ) ; } $ downloadedSize = file_put_contents ( $ targetPath , $ fp ) ; 
public function getFirstSelectedOption ( ) : WebDriverElement { if ( ! $ this -> isMultiple ( ) ) { return $ this -> findByCss ( $ this -> select2Selector . ' ' . self :: SIMPLESELECT_SELECTED_OPTION_SELECTOR ) ; } $ selected = $ this -> findMultipleByCss ( $ this -> select2Selector . ' ' . self :: MULTISELECT_SELECTED_OPTIONS_SELECTOR ) ; if ( count ( $ selected ) === 0 ) { throw new NoSuchElementException ( 'No options are selected' ) ; } return reset ( $ selected ) ; } 
public function selectByVisiblePartialText ( $ text ) : void { $ this -> openDropdownOptions ( ) ; $ this -> log ( 'Sending keys to select2: %s' , $ text ) ; $ inputSelector = WebDriverBy :: cssSelector ( $ this -> isMultiple ( ) ? $ this -> select2Selector . ' input' : '#select2-drop input' ) ; 
protected function configure ( ) : void { $ this -> setName ( 'install' ) -> setDescription ( 'Download latest Selenium standalone server jar file' ) -> addArgument ( 'version' , InputArgument :: OPTIONAL , 'Specific Selenium version to install' ) ; $ this -> getDispatcher ( ) -> dispatch ( CommandEvents :: CONFIGURE , new BasicConsoleEvent ( $ this ) ) ; } 
protected function execute ( InputInterface $ input , OutputInterface $ output ) : int { $ verboseOutput = false ; if ( $ input -> isInteractive ( ) || $ output -> isVerbose ( ) ) { $ verboseOutput = true ; } $ version = $ input -> getArgument ( 'version' ) ; 
protected function configure ( ) : void { $ this -> setName ( 'generate-timeline' ) -> setDescription ( 'Generates HTML file with timeline visualisation of test run' ) -> addOption ( self :: OPTION_RESULTS_FILE , null , InputOption :: VALUE_REQUIRED , 'Path to test results xml file' , STEWARD_BASE_DIR . DIRECTORY_SEPARATOR . 'logs' . DIRECTORY_SEPARATOR . XmlPublisher :: FILE_NAME ) -> addOption ( self :: OPTION_OUTPUT_FILE , null , InputOption :: VALUE_REQUIRED , 'Path to output html file' , STEWARD_BASE_DIR . DIRECTORY_SEPARATOR . 'logs' . DIRECTORY_SEPARATOR . self :: DEFAULT_OUTPUT_FILENAME ) ; $ this -> getDispatcher ( ) -> dispatch ( CommandEvents :: CONFIGURE , new BasicConsoleEvent ( $ this ) ) ; } 
protected function getLegacyName ( string $ type ) : string { $ name = $ this -> testClassName ; if ( ! preg_match ( '/Phase\d/' , $ name ) ) { throw new LegacyException ( "Cannot generate Legacy name from class without 'Phase' followed by number in name " . $ name ) ; } $ name = preg_replace ( '/Phase\d/' , '' , $ name ) ; 
public function saveWithName ( $ data , string $ legacyName ) : void { $ filename = $ this -> getLegacyFullPath ( $ legacyName ) ; $ this -> log ( 'Saving data as Legacy "%s" to file "%s"' , $ legacyName , $ filename ) ; $ this -> debug ( 'Legacy data: %s' , $ this -> getPrintableValue ( $ data ) ) ; if ( @ file_put_contents ( $ filename , serialize ( $ data ) ) === false ) { throw new LegacyException ( 'Cannot save Legacy to file ' . $ filename ) ; } } 
public function save ( $ data , string $ type = self :: LEGACY_TYPE_CASE ) : void { $ this -> saveWithName ( $ data , $ this -> getLegacyName ( $ type ) ) ; } 
public function load ( string $ type = self :: LEGACY_TYPE_CASE ) { return $ this -> loadWithName ( $ this -> getLegacyName ( $ type ) ) ; } 
public function loadWithName ( string $ legacyName ) { $ filename = $ this -> getLegacyFullPath ( $ legacyName ) ; $ this -> log ( 'Reading Legacy "%s" from file "%s"' , $ legacyName , $ filename ) ; $ data = @ file_get_contents ( $ filename ) ; if ( $ data === false ) { throw new LegacyException ( 'Cannot read Legacy file ' . $ filename ) ; } $ legacy = unserialize ( $ data ) ; if ( $ legacy === false ) { throw new LegacyException ( 'Cannot parse Legacy from file ' . $ filename ) ; } $ this -> debug ( 'Legacy data: %s' , $ this -> getPrintableValue ( $ legacy ) ) ; return $ legacy ; } 
private function getPrintableValue ( $ object ) : string { if ( is_object ( $ object ) && method_exists ( $ object , '__toString' ) ) { return ( string ) $ object ; } return print_r ( $ object , true ) ; } 
public function isAccessible ( ) : bool { 
public function isSeleniumServer ( ) : bool { 
public function getCloudService ( ) : string { 
public function getSessionExecutor ( string $ sessionId ) : string { $ context = stream_context_create ( [ 'http' => [ 'ignore_errors' => true , 'timeout' => 1 ] ] ) ; 
protected function guessPort ( string $ host , string $ scheme ) : int { if ( $ scheme === 'https' ) { return self :: DEFAULT_PORT_CLOUD_SERVICE_HTTPS ; } foreach ( [ 'saucelabs.com' , 'browserstack.com' , 'testingbot.com' ] as $ knownCloudHost ) { if ( mb_strpos ( $ host , $ knownCloudHost ) !== false ) { return self :: DEFAULT_PORT_CLOUD_SERVICE ; } } return self :: DEFAULT_PORT ; } 
private function detectCloudServiceByStatus ( $ responseData ) : string { if ( isset ( $ responseData -> value , $ responseData -> value -> build , $ responseData -> value -> build -> version ) ) { if ( $ responseData -> value -> build -> version === 'Sauce Labs' ) { return self :: CLOUD_SERVICE_SAUCELABS ; } elseif ( $ responseData -> value -> build -> version === 'TestingBot' ) { return self :: CLOUD_SERVICE_TESTINGBOT ; } elseif ( ! isset ( $ responseData -> class ) && ! isset ( $ responseData -> value -> ready ) ) { return self :: CLOUD_SERVICE_BROWSERSTACK ; } } return '' ; } 
public function createFromFiles ( Finder $ files , array $ groups , array $ excludeGroups , string $ filter = null , bool $ ignoreDelays = false ) : ProcessSet { $ files -> sortByName ( ) ; $ processSet = $ this -> getProcessSet ( ) ; if ( $ this -> output -> isVeryVerbose ( ) ) { if ( ! empty ( $ groups ) || ! empty ( $ excludeGroups ) || ! empty ( $ filter ) ) { $ this -> output -> writeln ( 'Filtering testcases:' ) ; } if ( ! empty ( $ groups ) ) { $ this -> output -> writeln ( sprintf ( ' - by group(s): %s' , implode ( ', ' , $ groups ) ) ) ; } if ( ! empty ( $ excludeGroups ) ) { $ this -> output -> writeln ( sprintf ( ' - excluding group(s): %s' , implode ( ', ' , $ excludeGroups ) ) ) ; } if ( ! empty ( $ filter ) ) { $ this -> output -> writeln ( sprintf ( ' - by testcase/test name: %s' , $ filter ) ) ; } } $ testCasesNum = 0 ; foreach ( $ files as $ file ) { $ fileName = $ file -> getRealPath ( ) ; $ className = $ this -> getClassNameFromFile ( $ fileName ) ; $ annotations = $ this -> getClassAnnotations ( $ className , $ fileName ) ; if ( $ excludingGroups = $ this -> getExcludingGroups ( $ excludeGroups , $ annotations ) ) { $ this -> output -> writeln ( sprintf ( 'Excluding testcase file %s with group %s' , $ fileName , implode ( ', ' , $ excludingGroups ) ) , OutputInterface :: VERBOSITY_DEBUG ) ; continue ; } 
protected function buildProcess ( string $ fileName , array $ phpunitArgs = [ ] ) : Process { $ capabilities = ( new KeyValueCapabilityOptionsParser ( ) ) -> parse ( $ this -> input -> getOption ( RunCommand :: OPTION_CAPABILITY ) ) ; $ env = [ 'BROWSER_NAME' => $ this -> input -> getArgument ( RunCommand :: ARGUMENT_BROWSER ) , 'ENV' => mb_strtolower ( $ this -> input -> getArgument ( RunCommand :: ARGUMENT_ENVIRONMENT ) ) , 'CAPABILITY' => json_encode ( $ capabilities ) , 'CAPABILITIES_RESOLVER' => $ this -> config [ ConfigOptions :: CAPABILITIES_RESOLVER ] , 'SERVER_URL' => $ this -> input -> getOption ( RunCommand :: OPTION_SERVER_URL ) , 'LOGS_DIR' => $ this -> config [ ConfigOptions :: LOGS_DIR ] , 'DEBUG' => $ this -> output -> isDebug ( ) ? '1' : '0' , ] ; $ dispatcher = $ this -> command -> getDispatcher ( ) ; $ dispatcher -> dispatch ( CommandEvents :: RUN_TESTS_PROCESS , $ processEvent = new RunTestsProcessEvent ( $ this -> command , $ this -> input , $ this -> output , $ env , $ phpunitArgs ) ) ; $ phpunitExecutable = realpath ( __DIR__ . '/../../bin/phpunit-steward' ) ; $ commandLine = array_merge ( [ PHP_BINARY , $ phpunitExecutable ] , $ processEvent -> getArgs ( ) , [ $ fileName ] ) ; return new Process ( $ commandLine , STEWARD_BASE_DIR , $ processEvent -> getEnvironmentVars ( ) , null , 3600 ) ; } 
private function getExcludingGroups ( array $ excludeGroups , array $ annotations ) : array { $ excludingGroups = [ ] ; if ( ! empty ( $ excludeGroups ) && array_key_exists ( 'group' , $ annotations ) ) { if ( ! empty ( array_intersect ( $ excludeGroups , $ annotations [ 'group' ] ) ) ) { $ excludingGroups = array_intersect ( $ excludeGroups , $ annotations [ 'group' ] ) ; } } return $ excludingGroups ; } 
private function getClassAnnotations ( string $ className , string $ fileName ) : array { try { return AnnotationsParser :: getAll ( new \ ReflectionClass ( $ className ) ) ; } catch ( \ ReflectionException $ e ) { throw new \ RuntimeException ( sprintf ( 'Error loading class "%s" from file "%s". Make sure the class name and namespace matches ' . 'the file path.' , $ className , $ fileName ) ) ; } } 
protected function takeSnapshot ( AbstractTestCase $ test ) : void { if ( ! $ test -> wd instanceof RemoteWebDriver ) { $ test -> appendTestLog ( '[WARN] WebDriver instance not found, cannot take snapshot.' ) ; return ; } $ savePath = ConfigProvider :: getInstance ( ) -> logsDir . DIRECTORY_SEPARATOR ; $ testIdentifier = $ this -> assembleTestIdentifier ( $ test ) ; ob_start ( ) ; $ outputBufferClosed = false ; try { $ currentUrl = $ test -> wd -> getCurrentURL ( ) ; 
protected function getSnapshotUrl ( string $ path ) : string { if ( getenv ( 'JENKINS_URL' ) && getenv ( 'BUILD_URL' ) && getenv ( 'WORKSPACE' ) ) { $ realPath = realpath ( $ path ) ; if ( $ realPath ) { 
public function onCommandConfigure ( BasicConsoleEvent $ event ) : void { if ( $ event -> getCommand ( ) -> getName ( ) !== 'run' ) { return ; } $ event -> getCommand ( ) -> addOption ( self :: OPTION_XDEBUG , null , InputOption :: VALUE_OPTIONAL , 'Start Xdebug debugger on tests. Pass custom IDE key if needed for your IDE settings.' , '' ) ; } 
protected function getIdeKeyFromInputOption ( InputInterface $ input ) : ? string { $ optionValue = $ input -> getOption ( self :: OPTION_XDEBUG ) ; if ( $ optionValue === null ) { 
public function instantiate ( EventDispatcher $ dispatcher , string $ dirToSearchForListeners ) : void { $ listeners = $ this -> searchListeners ( $ dirToSearchForListeners ) ; foreach ( $ listeners as $ listener ) { $ r = new \ ReflectionClass ( $ listener ) ; if ( $ r -> implementsInterface ( 'Symfony\\Component\\EventDispatcher\\EventSubscriberInterface' ) && ! $ r -> isAbstract ( ) ) { $ listenerInstance = $ r -> newInstanceWithoutConstructor ( ) ; $ dispatcher -> addSubscriber ( $ listenerInstance ) ; } } } 
protected function configure ( ) : void { $ this -> setName ( 'clean' ) -> setDescription ( 'Clean logs directory' ) -> addOption ( RunCommand :: OPTION_LOGS_DIR , null , InputOption :: VALUE_REQUIRED , 'Path to directory with logs' , STEWARD_BASE_DIR . DIRECTORY_SEPARATOR . 'logs' ) ; $ this -> getDispatcher ( ) -> dispatch ( CommandEvents :: CONFIGURE , new BasicConsoleEvent ( $ this ) ) ; } 
public function getFilePath ( ) : string { if ( ! $ this -> fileDir ) { $ this -> fileDir = ConfigProvider :: getInstance ( ) -> logsDir ; } return $ this -> fileDir . '/' . $ this -> fileName ; } 
protected function quoteXpathAttribute ( string $ input ) : string { if ( mb_strpos ( $ input , '\'' ) === false ) { // Selector does not contain single quotes return "'$input'" ; // Encapsulate with double quotes } if ( mb_strpos ( $ input , '"' ) === false ) { // Selector contain single quotes but not double quotes return "\"$input\"" ; // Encapsulate with single quotes } // When both single and double quotes are contained, escape each part individually and concat() all parts return "concat('" . strtr ( $ input , [ '\'' => '\', "\'", \'' ] ) . "')" ; } 
public function optimize ( OutTree $ tree ) : array { 
private function castToGuessedDataType ( string $ value ) { $ stringValueWithoutQuotes = $ this -> removeEncapsulatingQuotes ( $ value ) ; if ( $ stringValueWithoutQuotes !== null ) { return $ stringValueWithoutQuotes ; } $ intValue = filter_var ( $ value , FILTER_VALIDATE_INT , [ ] ) ; if ( $ intValue !== false ) { return $ intValue ; } $ floatValue = filter_var ( $ value , FILTER_VALIDATE_FLOAT , [ ] ) ; if ( $ floatValue !== false ) { return $ floatValue ; } $ boolValue = filter_var ( $ value , FILTER_VALIDATE_BOOLEAN , [ 'flags' => FILTER_NULL_ON_FAILURE ] ) ; if ( $ boolValue !== null ) { return $ boolValue ; } return $ value ; } 
public function checkProcessTimeout ( ) : ? string { try { $ this -> getProcess ( ) -> checkTimeout ( ) ; } catch ( ProcessTimedOutException $ e ) { $ this -> setStatus ( self :: PROCESS_STATUS_DONE ) ; return sprintf ( 'Process for class "%s" exceeded the timeout of %d seconds and was killed.' , $ this -> getClassName ( ) , $ e -> getExceededTimeout ( ) ) ; } return '' ; } 
private function resolveResult ( ) : string { $ exitCode = $ this -> getProcess ( ) -> getExitCode ( ) ; 
private function getExecutors ( ) : array { $ testElements = $ this -> xml -> xpath ( '//testcase/test[@status="done"]' ) ; $ hasTestWithoutExecutor = false ; $ executors = [ ] ; foreach ( $ testElements as $ testElement ) { $ executorValue = ( string ) $ testElement [ 'executor' ] ; if ( ! empty ( $ executorValue ) ) { $ executors [ ] = $ executorValue ; } else { $ hasTestWithoutExecutor = true ; } } $ executors = array_unique ( $ executors ) ; 
protected function setupCiCapabilities ( DesiredCapabilities $ capabilities , AbstractTestCase $ test ) : DesiredCapabilities { $ ci = $ this -> ciDetector -> detect ( ) ; $ capabilities -> setCapability ( 'build' , $ this -> config -> env . '-' . $ ci -> getBuildNumber ( ) ) ; $ capabilities -> setCapability ( 'tags' , [ $ this -> config -> env , $ ci -> getCiName ( ) , get_class ( $ test ) ] ) ; return $ capabilities ; } 
public function setCustomConfigurationOptions ( array $ customConfigurationOptions ) : void { if ( $ this -> config !== null ) { throw new \ RuntimeException ( 'Custom configuration options can be set only before initialization of configuration' ) ; } $ this -> customConfigurationOptions = $ customConfigurationOptions ; } 
private function retrieveConfigurationValues ( array $ options ) : array { $ outputValues = [ ] ; foreach ( $ options as $ option ) { $ value = getenv ( $ option ) ; 
protected function dequeueProcessesWithoutDelay ( ) : void { $ queuedProcesses = $ this -> processSet -> get ( ProcessWrapper :: PROCESS_STATUS_QUEUED ) ; foreach ( $ queuedProcesses as $ className => $ processWrapper ) { if ( $ processWrapper -> isDelayed ( ) ) { $ this -> io -> writeln ( sprintf ( 'Testcase "%s" is queued to be run %01.1f minutes after testcase "%s" is finished' , $ className , $ processWrapper -> getDelayMinutes ( ) , $ processWrapper -> getDelayAfter ( ) ) , OutputInterface :: VERBOSITY_DEBUG ) ; } elseif ( $ this -> parallelLimitReached ( ) ) { $ this -> io -> writeln ( sprintf ( 'Max parallel limit reached, testcase "%s" is queued' , $ className ) , OutputInterface :: VERBOSITY_QUIET ) ; } else { $ this -> io -> writeln ( sprintf ( 'Testcase "%s" is prepared to be run' , $ className ) , OutputInterface :: VERBOSITY_DEBUG ) ; $ processWrapper -> setStatus ( ProcessWrapper :: PROCESS_STATUS_PREPARED ) ; } } } 
protected function flushProcessOutput ( ProcessWrapper $ processWrapper ) : void { $ this -> io -> output ( $ processWrapper -> getProcess ( ) -> getIncrementalOutput ( ) , $ processWrapper -> getClassName ( ) ) ; $ this -> io -> errorOutput ( $ processWrapper -> getProcess ( ) -> getIncrementalErrorOutput ( ) , $ processWrapper -> getClassName ( ) ) ; } 
protected function createWebDriver ( AbstractTestCase $ test , string $ remoteServerUrl , DesiredCapabilities $ desiredCapabilities , DesiredCapabilities $ requiredCapabilities , int $ connectTimeoutMs , int $ requestTimeoutMs ) : void { $ browserName = ConfigProvider :: getInstance ( ) -> browserName ; for ( $ startAttempts = 0 ; $ startAttempts < 4 ; $ startAttempts ++ ) { try { $ test -> wd = RemoteWebDriver :: create ( $ remoteServerUrl , $ desiredCapabilities , $ connectTimeoutMs , $ requestTimeoutMs , null , null , $ requiredCapabilities ) ; return ; } catch ( UnknownServerException $ e ) { if ( $ this -> cannotBindToFirefoxLockingPort ( $ browserName , $ e -> getMessage ( ) ) ) { 
public function favorite ( $ class ) { return $ this -> favorites ( ) -> where ( 'favoriteable_type' , $ class ) -> with ( 'favoriteable' ) -> get ( ) -> mapWithKeys ( function ( $ item ) { return [ $ item [ 'favoriteable' ] -> id => $ item [ 'favoriteable' ] ] ; } ) ; } 
private function countSummary ( $ dstFile ) { $ tests = ( new \ DOMXPath ( $ dstFile ) ) -> query ( "//table/tr[contains(@class,'scenarioRow')]" ) ; foreach ( $ tests as $ test ) { $ class = str_replace ( 'scenarioRow ' , '' , $ test -> getAttribute ( 'class' ) ) ; switch ( $ class ) { case 'scenarioSuccess' : $ this -> countSuccess += 0.5 ; break ; case 'scenarioFailed' : $ this -> countFailed += 0.5 ; break ; case 'scenarioSkipped' : $ this -> countSkipped += 0.5 ; break ; case 'scenarioIncomplete' : $ this -> countIncomplete += 0.5 ; break ; } } } 
private function updateSummaryTable ( $ dstFile ) { $ dstFile = new \ DOMXPath ( $ dstFile ) ; $ pathFor = function ( $ type ) { return "//div[@id='stepContainerSummary']//td[@class='$type']" ; } ; $ dstFile -> query ( $ pathFor ( 'scenarioSuccessValue' ) ) -> item ( 0 ) -> nodeValue = $ this -> countSuccess ; $ dstFile -> query ( $ pathFor ( 'scenarioFailedValue' ) ) -> item ( 0 ) -> nodeValue = $ this -> countFailed ; $ dstFile -> query ( $ pathFor ( 'scenarioSkippedValue' ) ) -> item ( 0 ) -> nodeValue = $ this -> countSkipped ; $ dstFile -> query ( $ pathFor ( 'scenarioIncompleteValue' ) ) -> item ( 0 ) -> nodeValue = $ this -> countIncomplete ; } 
private function moveSummaryTable ( $ dstFile , $ node ) { $ summaryTable = ( new \ DOMXPath ( $ dstFile ) ) -> query ( "//div[@id='stepContainerSummary']" ) -> item ( 0 ) -> parentNode -> parentNode ; $ node -> appendChild ( $ dstFile -> importNode ( $ summaryTable , true ) ) ; } 
private function updateToolbarTable ( $ dstFile ) { $ dstFile = new \ DOMXPath ( $ dstFile ) ; $ pathFor = function ( $ type ) { return "//ul[@id='toolbar-filter']//a[@title='$type']" ; } ; $ dstFile -> query ( $ pathFor ( 'Successful' ) ) -> item ( 0 ) -> nodeValue = '✔ '.$ t h is-> co untSuccess; $ dstFile -> query ( $ pathFor ( 'Failed' ) ) -> item ( 0 ) -> nodeValue = '✗ '.$ t h is-> co untFailed; $ dstFile -> query ( $ pathFor ( 'Skipped' ) ) -> item ( 0 ) -> nodeValue = 'S ' . $ this -> countSkipped ; $ dstFile -> query ( $ pathFor ( 'Incomplete' ) ) -> item ( 0 ) -> nodeValue = 'I ' . $ this -> countIncomplete ; } 
private function updateButtons ( $ dstFile ) { $ nodes = ( new \ DOMXPath ( $ dstFile ) ) -> query ( "//div[@class='layout']/table/tr[contains(@class, 'scenarioRow')]" ) ; for ( $ i = 2 ; $ i < $ nodes -> length ; $ i += 2 ) { $ n = $ i / 2 + 1 ; $ p = $ nodes -> item ( $ i ) -> childNodes -> item ( 1 ) -> childNodes -> item ( 1 ) ; $ table = $ nodes -> item ( $ i + 1 ) -> childNodes -> item ( 1 ) -> childNodes -> item ( 1 ) ; $ p -> setAttribute ( 'onclick' , "showHide('$n', this)" ) ; $ table -> setAttribute ( 'id' , "stepContainer" . $ n ) ; } } 
public function addFavorite ( $ user_id = null ) { $ favorite = new Favorite ( [ 'user_id' => ( $ user_id ) ? $ user_id : Auth :: id ( ) ] ) ; $ this -> favorites ( ) -> save ( $ favorite ) ; } 
public function removeFavorite ( $ user_id = null ) { $ this -> favorites ( ) -> where ( 'user_id' , ( $ user_id ) ? $ user_id : Auth :: id ( ) ) -> delete ( ) ; } 
public function toggleFavorite ( $ user_id = null ) { $ this -> isFavorited ( $ user_id ) ? $ this -> removeFavorite ( $ user_id ) : $ this -> addFavorite ( $ user_id ) ; } 
public function isFavorited ( $ user_id = null ) { return $ this -> favorites ( ) -> where ( 'user_id' , ( $ user_id ) ? $ user_id : Auth :: id ( ) ) -> exists ( ) ; } 
public function favoritedBy ( ) { return $ this -> favorites ( ) -> with ( 'user' ) -> get ( ) -> mapWithKeys ( function ( $ item ) { return [ $ item [ 'user' ] -> id => $ item [ 'user' ] ] ; } ) ; } 
public function load ( array $ configs , ContainerBuilder $ container ) { $ configuration = new Configuration ( ) ; $ config = $ this -> processConfiguration ( $ configuration , $ configs ) ; $ loader = new XmlFileLoader ( $ container , new FileLocator ( __DIR__ . '/../Resources/config' ) ) ; $ loader -> load ( 'services.xml' ) ; $ container -> setParameter ( 'overblog_graphiql.endpoint_resolver' , $ config [ 'endpoint_resolver' ] ) ; $ graphiQLViewConfigJSLibraries = $ container -> getDefinition ( 'overblog_graphiql.view.config.javascript_libraries' ) ; $ graphiQLViewConfigJSLibraries -> setArguments ( [ $ config [ 'javascript_libraries' ] [ 'graphiql' ] , $ config [ 'javascript_libraries' ] [ 'react' ] , $ config [ 'javascript_libraries' ] [ 'fetch' ] , ] ) ; $ graphiQLViewConfig = $ container -> getDefinition ( 'overblog_graphiql.view.config' ) ; $ graphiQLViewConfig -> setArguments ( [ new Reference ( 'overblog_graphiql.view.config.javascript_libraries' ) , $ config [ 'template' ] , ] ) ; } 
public function initialize ( $ input ) { 
public function getPermissions ( ) { $ permissions = [ $ this -> manage_permission ] ; if ( $ this -> create ) { $ permissions [ ] = $ this -> create_permission ; $ permissions [ ] = $ this -> store_permission ; } if ( $ this -> edit ) { $ permissions [ ] = $ this -> edit_permission ; $ permissions [ ] = $ this -> update_permission ; } if ( $ this -> delete ) { $ permissions [ ] = $ this -> delete_permission ; } return $ permissions ; } 
public function insertToLanguageFiles ( ) { 
public function createViewFiles ( ) { 
public function createMigration ( ) { $ table = $ this -> table ; if ( Schema :: hasTable ( $ table ) ) { return 'Table Already Exists!' ; } else { 
public function createEvents ( ) { if ( ! empty ( $ this -> events ) ) { $ base_path = $ this -> event_namespace ; foreach ( $ this -> events as $ event ) { $ path = escapeSlashes ( $ base_path . DIRECTORY_SEPARATOR . $ event ) ; $ model = str_replace ( DIRECTORY_SEPARATOR , '\\' , $ path ) ; Artisan :: call ( 'make:event' , [ 'name' => $ model , ] ) ; Artisan :: call ( 'make:listener' , [ 'name' => $ model . 'Listener' , '--event' => $ model , ] ) ; } } } 
public function generateFile ( $ stub_name , $ replacements , $ file , $ contents = null ) { if ( $ stub_name ) { 
public function getStubPath ( ) { $ path = resource_path ( 'views' . DIRECTORY_SEPARATOR . 'vendor' . DIRECTORY_SEPARATOR . 'generator' . DIRECTORY_SEPARATOR . 'Stubs' . DIRECTORY_SEPARATOR ) ; $ package_stubs_path = base_path ( 'vendor' . DIRECTORY_SEPARATOR . 'bvipul' . DIRECTORY_SEPARATOR . 'generator' . DIRECTORY_SEPARATOR . 'src' . DIRECTORY_SEPARATOR . 'views' . DIRECTORY_SEPARATOR . 'Stubs' . DIRECTORY_SEPARATOR ) ; if ( $ this -> files -> exists ( $ path ) ) return $ path ; else return $ package_stubs_path ; } 
public function getBasePath ( $ namespace , $ status = false ) { if ( $ status ) { return base_path ( escapeSlashes ( $ this -> removeFileNameFromEndOfNamespace ( $ namespace , $ status ) ) ) ; } return base_path ( lcfirst ( escapeSlashes ( $ namespace ) ) ) ; } 
public function delete_all_between ( $ beginning , $ end , $ string ) { $ beginningPos = strpos ( $ string , $ beginning ) ; $ endPos = strpos ( $ string , $ end ) ; if ( $ beginningPos === false || $ endPos === false ) { return $ string ; } $ textToDelete = substr ( $ string , $ beginningPos , ( $ endPos + strlen ( $ end ) ) - $ beginningPos ) ; return str_replace ( $ textToDelete , '' , $ string ) ; } 
public function create ( array $ input , array $ permissions ) { $ module = Module :: where ( 'name' , $ input [ 'name' ] ) -> first ( ) ; if ( ! $ module ) { $ name = $ input [ 'model_name' ] ; $ model = strtolower ( $ name ) ; foreach ( $ permissions as $ permission ) { $ perm = [ 'name' => $ permission , 'display_name' => title_case ( str_replace ( '-' , ' ' , $ permission ) ) . ' Permission' , ] ; 
public function boot ( ) { $ this -> loadViewsFrom ( __DIR__ . '/../views' , 'generator' ) ; $ this -> loadMigrationsFrom ( __DIR__ . '/../migrations' ) ; $ this -> loadTranslationsFrom ( __DIR__ . '/../lang' , 'generator' ) ; $ this -> mergeConfigFrom ( __DIR__ . '/../config/generator.php' , 'generator' ) ; $ this -> publishes ( [ __DIR__ . '/../config/generator.php' => config_path ( 'generator.php' ) , ] , 'generator' ) ; $ this -> publishes ( [ __DIR__ . '/../views' => base_path ( 'resources/views/vendor/generator' ) , ] , 'generator_views' ) ; 
public function register ( ) { include __DIR__ . '/../routes.php' ; require_once ( __DIR__ . '/../helpers.php' ) ; $ this -> app -> make ( 'Bvipul\Generator\Module' ) ; $ this -> app -> make ( 'Bvipul\Generator\Controllers\Generator' ) ; $ this -> app -> make ( 'Bvipul\Generator\Controllers\ModuleController' ) ; $ this -> app -> make ( 'Bvipul\Generator\Repositories\ModuleRepository' ) ; $ this -> app -> make ( 'Bvipul\Generator\Controllers\ModuleTableController' ) ; } 
public function create ( Request $ request ) { return view ( 'generator::create' ) -> with ( 'model_namespace' , $ this -> generator -> getModelNamespace ( ) ) -> with ( 'request_namespace' , $ this -> generator -> getRequestNamespace ( ) ) -> with ( 'controller_namespace' , $ this -> generator -> getControllerNamespace ( ) ) -> with ( 'event_namespace' , $ this -> event_namespace ) -> with ( 'repo_namespace' , $ this -> generator -> getRepoNamespace ( ) ) -> with ( 'route_path' , $ this -> generator -> getRoutePath ( ) ) -> with ( 'view_path' , $ this -> generator -> getViewPath ( ) ) ; } 
public function store ( Request $ request ) { $ this -> generator -> initialize ( $ request -> all ( ) ) ; $ this -> generator -> createMigration ( ) ; $ this -> generator -> createModel ( ) ; $ this -> generator -> createRequests ( ) ; $ this -> generator -> createResponses ( ) ; $ this -> generator -> createRepository ( ) ; $ this -> generator -> createController ( ) ; $ this -> generator -> createTableController ( ) ; $ this -> generator -> createRouteFiles ( ) ; $ this -> generator -> insertToLanguageFiles ( ) ; $ this -> generator -> createViewFiles ( ) ; $ this -> generator -> createEvents ( ) ; 
public function checkNamespace ( Request $ request ) { if ( isset ( $ request -> path ) ) { $ path = $ this -> parseModel ( $ request -> path ) ; $ path = base_path ( trim ( str_replace ( '\\' , '/' , $ request -> path ) ) , '\\' ) ; $ path = str_replace ( 'App' , 'app' , $ path ) ; if ( file_exists ( $ path . '.php' ) ) { return response ( ) -> json ( ( object ) [ 'type' => 'error' , 'message' => 'File exists Already' , ] ) ; } else { return response ( ) -> json ( ( object ) [ 'type' => 'success' , 'message' => 'File can be generated at this location' , ] ) ; } } else { return response ( ) -> json ( ( object ) [ 'type' => 'error' , 'message' => 'Please provide some value' , ] ) ; } } 
public function checkTable ( Request $ request ) { if ( $ request -> table ) { if ( Schema :: hasTable ( $ request -> table ) ) { return response ( ) -> json ( ( object ) [ 'type' => 'error' , 'message' => 'Table exists Already' , ] ) ; } else { return response ( ) -> json ( ( object ) [ 'type' => 'success' , 'message' => 'Table Name Available' , ] ) ; } } else { return response ( ) -> json ( ( object ) [ 'type' => 'error' , 'message' => 'Please provide some value' , ] ) ; } } 
public function parseModel ( $ model ) { if ( preg_match ( '([^A-Za-z0-9_/\\\\])' , $ model ) ) { throw new InvalidArgumentException ( 'Name contains invalid characters.' ) ; } $ model = trim ( str_replace ( '/' , '\\' , $ model ) , '\\' ) ; return $ model ; } 
public function onOneRandomServer ( ) { $ keys = array_keys ( $ this -> getServerConfig ( ) ) ; do { $ randServerRank = array_rand ( $ keys ) ; if ( $ redis = $ this -> getRedisFromServerConfig ( $ keys [ $ randServerRank ] ) ) { $ this -> selectedRedis = array ( $ keys [ $ randServerRank ] => $ redis ) ; } else { unset ( $ keys [ $ randServerRank ] ) ; } } while ( ! empty ( $ keys ) && empty ( $ this -> selectedRedis ) ) ; if ( empty ( $ this -> selectedRedis ) ) { throw new Exception ( "Can't connect to a random redis server" ) ; } $ this -> multiRedis = false ; return $ this ; } 
public function onAllServer ( $ strict = true ) { foreach ( $ this -> getServerConfig ( ) as $ idServer => $ config ) { if ( $ redis = $ this -> getRedisFromServerConfig ( $ idServer ) ) { $ this -> selectedRedis [ $ idServer ] = $ redis ; } else { if ( $ strict ) { throw new Exception ( 'cant connect to redis ' . $ idServer ) ; } } } $ this -> multiRedis = true ; return $ this ; } 
public function onOneServer ( $ idServer , $ strict = true ) { $ redisList = $ this -> getServerConfig ( ) ; 
public function onOneKeyServer ( $ key ) { $ this -> selectedRedis [ ] = $ this -> getRedis ( $ key ) ; $ this -> multiRedis = false ; return $ this ; } 
protected function callRedisCommand ( PredisProxy $ redis , $ name , $ arguments ) { $ start = microtime ( true ) ; try { $ return = call_user_func_array ( array ( $ redis , $ name ) , $ arguments ) ; $ this -> notifyEvent ( $ name , $ arguments , microtime ( true ) - $ start ) ; } catch ( Predis \ PredisException $ e ) { throw new Exception ( "Error calling the method " . $ name . " : " . $ e -> getMessage ( ) ) ; } return $ return ; } 
public function setCurrentDb ( $ v ) { if ( ! is_int ( $ v ) ) { throw new Exception ( "please describe the db as an integer ^^" ) ; } if ( $ v == Cache :: CACHE ) { throw new Exception ( "cant use " . Cache :: CACHE . " in class " . __CLASS__ ) ; } $ this -> currentDb = $ v ; return $ this ; } 
public function setEventDispatcher ( $ eventDispatcher , $ eventClass ) { if ( ! is_object ( $ eventDispatcher ) || ! method_exists ( $ eventDispatcher , 'dispatch' ) ) { throw new Exception ( "The EventDispatcher must be an object and implement a dispatch method" ) ; } if ( ! class_exists ( $ eventClass ) || ! method_exists ( $ eventClass , 'setCommand' ) || ! method_exists ( $ eventClass , 'setArguments' ) || ! method_exists ( $ eventClass , 'setExecutionTime' ) ) { $ msg = "The Event class : " . $ eventClass . " must implement the setCommand, " ; $ msg .= "setExecutionTime and the setArguments method" ; throw new Exception ( $ msg ) ; } $ this -> eventDispatcher = $ eventDispatcher ; $ this -> eventClass = $ eventClass ; return $ this ; } 
protected function init ( $ params ) { 
protected function checkServerConfig ( $ servers ) { if ( ! is_array ( $ servers ) ) { return false ; } foreach ( $ servers as $ serverId => $ server ) { if ( ! is_string ( $ serverId ) ) { return false ; } if ( ! isset ( $ server [ 'ip' ] ) or ! isset ( $ server [ 'port' ] ) ) { return false ; } } return true ; } 
public function getServerConfig ( $ servername = null ) { if ( is_null ( $ servername ) ) { return $ this -> serverConfig ; } else { return $ this -> serverConfig [ $ servername ] ; } } 
protected function setServerConfig ( $ servers , $ check = true ) { if ( $ check and ( ! self :: checkServerConfig ( $ servers ) ) ) { throw new Exception ( "Le parametre serverConfig est mal formé") ; } 
protected function getServerId ( $ key , $ servers = null ) { if ( is_null ( $ servers ) ) { $ servers = $ this -> getServerConfig ( ) ; } $ serverKeys = array_keys ( $ servers ) ; return $ serverKeys [ ( int ) ( crc32 ( $ key ) % count ( $ serverKeys ) ) ] ; } 
protected function getRedis ( $ key , $ servers = null ) { if ( is_null ( $ servers ) ) { $ servers = $ this -> getServerConfig ( ) ; 
public function getRedisFromServerConfig ( $ idServer ) { 
protected function connectServer ( PredisProxy $ redis , $ server ) { try { $ redis -> callRedisConstructor ( array ( 'host' => $ server [ 'ip' ] , 'port' => ( int ) $ server [ 'port' ] , 'timeout' => $ this -> getTimeout ( ) , 'read_write_timeout' => $ this -> getReadWriteTimeout ( ) ) ) ; 
public function get ( $ key ) { $ redis = $ this -> getRedis ( $ key ) ; $ start = microtime ( true ) ; $ ret = $ redis -> get ( $ this -> getPatternKey ( ) . $ key ) ; 
public function del ( $ keys ) { if ( ! is_array ( $ keys ) ) { $ keys = array ( $ keys ) ; } $ funcs = array ( ) ; 
public function set ( $ key , $ value , $ ttl = null ) { if ( $ this -> getCompress ( ) ) { $ value = self :: compress ( $ value ) ; } $ keyP = $ this -> getPatternKey ( ) . $ key ; if ( is_null ( $ ttl ) ) { $ func = function ( $ redis ) use ( $ keyP , $ value ) { $ start = microtime ( true ) ; $ redis -> set ( $ keyP , $ value ) ; $ this -> notifyEvent ( 'set' , array ( $ keyP , $ value ) , microtime ( true ) - $ start ) ; return $ redis ; } ; } else { $ func = function ( $ redis ) use ( $ keyP , $ value , $ ttl ) { $ start = microtime ( true ) ; $ redis -> setex ( $ keyP , $ ttl , $ value ) ; $ this -> notifyEvent ( 'setex' , array ( $ keyP , $ ttl , $ value ) , microtime ( true ) - $ start ) ; return $ redis ; } ; } if ( true === $ this -> multi ) { $ this -> addToExecList ( $ key , $ func ) ; } else { $ func ( $ this -> getRedis ( $ key ) ) ; 
public function exists ( $ key ) { $ start = microtime ( true ) ; $ ret = $ this -> getRedis ( $ key ) -> exists ( $ this -> getPatternKey ( ) . $ key ) ; $ this -> notifyEvent ( 'exists' , array ( $ this -> getPatternKey ( ) . $ key ) , microtime ( true ) - $ start ) ; return ( boolean ) $ ret ; } 
public function type ( $ key ) { $ start = microtime ( true ) ; $ ret = ( string ) $ this -> getRedis ( $ key ) -> type ( $ this -> getPatternKey ( ) . $ key ) ; $ this -> notifyEvent ( 'type' , array ( $ this -> getPatternKey ( ) . $ key ) , microtime ( true ) - $ start ) ; return $ ret ; } 
public function ttl ( $ key ) { $ start = microtime ( true ) ; $ ret = $ this -> getRedis ( $ key ) -> ttl ( $ this -> getPatternKey ( ) . $ key ) ; $ this -> notifyEvent ( 'ttl' , array ( $ this -> getPatternKey ( ) . $ key ) , microtime ( true ) - $ start ) ; return $ ret ; } 
public function incr ( $ key , $ incr = 1 ) { $ keyP = $ this -> getPatternKey ( ) . $ key ; $ func = function ( $ redis ) use ( $ keyP , $ incr ) { try { $ start = microtime ( true ) ; $ ret = $ redis -> incrby ( $ keyP , $ incr ) ; $ this -> notifyEvent ( 'incrby' , array ( $ keyP , $ incr ) , microtime ( true ) - $ start ) ; return $ ret ; } catch ( Predis \ ServerException $ e ) { return null ; } } ; if ( true === $ this -> multi ) { $ this -> addToExecList ( $ key , $ func ) ; return $ this ; } else { if ( is_null ( $ ret = $ func ( $ this -> getRedis ( $ key ) ) ) ) { throw new Exception ( "Cant increment key " . $ key . ", not an integer ?" ) ; } return $ ret ; } } 
public function expire ( $ key , $ ttl ) { if ( $ ttl <= 0 ) { throw new Exception ( 'ttl arg cant be negative' ) ; } $ keyP = $ this -> getPatternKey ( ) . $ key ; $ func = function ( $ redis ) use ( $ keyP , $ ttl ) { try { $ start = microtime ( true ) ; $ ret = $ redis -> expire ( $ keyP , $ ttl ) ; $ this -> notifyEvent ( 'expire' , array ( $ keyP , $ ttl ) , microtime ( true ) - $ start ) ; return $ ret ; } catch ( Predis \ ServerException $ e ) { return null ; } } ; 
public function flush ( ) { $ pattern = $ this -> getPatternKey ( ) ; $ arrReturn = $ this -> runOnAllRedisServer ( function ( $ redis ) use ( $ pattern ) { $ wasDeleted = 0 ; $ allKeys = $ redis -> keys ( $ pattern . '*' ) ; 
public function watch ( $ key ) { $ redis = $ this -> getRedis ( $ key ) ; $ this -> notifyEvent ( 'watch' , array ( $ this -> getPatternKey ( ) . $ key ) ) ; $ redis -> watch ( $ this -> getPatternKey ( ) . $ key ) ; } 
public function exec ( ) { if ( true === $ this -> multi ) { $ ret = array ( ) ; $ this -> multi = false ; 
public function keys ( $ pattern ) { $ pattern = $ this -> getPatternKey ( ) . $ pattern ; return $ this -> runOnAllRedisServer ( function ( $ redis ) use ( $ pattern ) { $ this -> notifyEvent ( 'keys' , array ( $ pattern ) ) ; return $ redis -> keys ( $ pattern ) ; } ) ; } 
protected function runOnAllRedisServer ( \ Closure $ func ) { $ ret = array ( ) ; 
public function dbSize ( $ idServer = null ) { if ( is_null ( $ idServer ) ) { $ servers = $ this -> getServerConfig ( ) ; $ dbsize = array ( ) ; foreach ( array_keys ( $ servers ) as $ idServer ) { $ redis = $ this -> getRedisFromServerConfig ( $ idServer ) ; $ dbsize [ $ idServer ] = $ redis -> dbsize ( ) ; } } else { $ redis = $ this -> getRedisFromServerConfig ( $ idServer ) ; $ dbsize = $ redis -> dbsize ( ) ; } return $ dbsize ; } 
public function info ( $ idServer = null ) { if ( is_null ( $ idServer ) ) { $ servers = $ this -> getServerConfig ( ) ; $ info = array ( ) ; foreach ( array_keys ( $ servers ) as $ idServer ) { $ redis = $ this -> getRedisFromServerConfig ( $ idServer ) ; $ info [ $ idServer ] = $ redis -> info ( ) ; } } else { $ redis = $ this -> getRedisFromServerConfig ( $ idServer ) ; $ info = $ redis -> info ( ) ; } return $ info ; } 
protected function addToExecList ( $ key , \ Closure $ func ) { $ redis = $ this -> getRedis ( $ key ) ; $ this -> execList [ md5 ( serialize ( $ redis ) ) ] [ ] = array ( 'key' => $ key , 'function' => $ func , 'redis' => $ redis ) ; } 
public function getRedisObject ( $ serverRank = 0 ) { $ serverConfig = $ this -> getServerConfig ( ) ; $ keys = array_keys ( $ serverConfig ) ; if ( isset ( $ keys [ $ serverRank ] ) ) { return $ this -> getRedisFromServerConfig ( $ keys [ $ serverRank ] ) ; } else { throw new Exception ( "No server found at rank " . $ serverRank ) ; } } 
public function load ( array $ configs , ContainerBuilder $ container ) { $ configuration = new Configuration ( ) ; $ config = $ this -> processConfiguration ( $ configuration , $ configs ) ; $ servers = isset ( $ config [ 'servers' ] ) ? $ config [ 'servers' ] : [ ] ; $ clients = isset ( $ config [ 'clients' ] ) ? $ config [ 'clients' ] : [ ] ; $ loader = new Loader \ YamlFileLoader ( $ container , new FileLocator ( __DIR__ . '/../Resources/config' ) ) ; $ loader -> load ( 'services.yml' ) ; $ clientServiceNames = [ ] ; foreach ( $ clients as $ alias => $ clientConfig ) { 
protected function loadClient ( $ container , $ alias , array $ config , array $ servers , $ baseEvents ) { $ usedServers = [ ] ; $ events = $ config [ 'events' ] ; $ matchedServers = [ ] ; if ( $ config [ 'servers' ] [ 0 ] == 'all' ) { 
public function getConfigTreeBuilder ( ) { $ treeBuilder = new TreeBuilder ( ) ; $ rootNode = $ treeBuilder -> root ( 'm6_statsd' ) ; $ this -> addServersSection ( $ rootNode ) ; $ this -> addClientsSection ( $ rootNode ) ; $ this -> addDefaultEventSection ( $ rootNode ) ; return $ treeBuilder ; } 
private function addDefaultEventSection ( $ rootNode ) { $ rootNode -> children ( ) -> booleanNode ( 'base_collectors' ) -> defaultFalse ( ) -> end ( ) -> booleanNode ( 'console_events' ) -> defaultFalse ( ) -> end ( ) ; } 
public function validate ( $ value , Constraint $ constraint ) { if ( ! is_scalar ( $ value ) && ! ( is_object ( $ value ) && method_exists ( $ value , '__toString' ) ) ) { $ this -> context -> addViolation ( 'node is not given or wrong datatype' ) ; return ; } if ( empty ( $ value ) ) { $ this -> context -> addViolation ( 'the node is empty and isn\'t suitable for graphite' ) ; return ; } if ( ! self :: validatePattern ( $ value ) ) { $ this -> context -> addViolation ( 'the node : ' . $ value . ' isn\'t suitable for graphite' ) ; return ; } } 
protected function dispatch ( $ eventName , BaseConsoleEvent $ e ) { if ( ! is_null ( $ this -> eventDispatcher ) ) { $ class = str_replace ( 'Symfony\Component\Console\Event' , 'M6Web\Bundle\StatsdBundle\Event' , get_class ( $ e ) ) ; $ finaleEvent = $ class :: createFromConsoleEvent ( $ e , $ this -> startTime , ! is_null ( $ this -> startTime ) ? microtime ( true ) - $ this -> startTime : null ) ; return $ this -> eventDispatcher -> dispatch ( $ eventName , $ finaleEvent ) ; } else { return false ; } } 
public function handleEvent ( $ event , $ name = null ) { 
private function getEventValue ( $ event , $ method ) { if ( ! method_exists ( $ event , $ method ) ) { throw new Exception ( "The event class " . get_class ( $ event ) . " must have a " . $ method . " method in order to mesure value" ) ; } return call_user_func ( array ( $ event , $ method ) ) ; } 
private function addTiming ( $ event , $ timingMethod , $ node , $ tags = [ ] ) { $ timing = $ this -> getEventValue ( $ event , $ timingMethod ) ; if ( $ timing > 0 ) { $ this -> timing ( $ node , $ timing , 1 , $ tags ) ; } } 
private function replaceConfigPlaceholder ( $ event , $ eventName , $ string ) { 
private function mergeTags ( $ event , $ config ) { $ configTags = isset ( $ config [ 'tags' ] ) ? $ config [ 'tags' ] : [ ] ; if ( $ event instanceof MonitorableEventInterface ) { return array_merge ( $ configTags , $ event -> getTags ( ) ) ; } return $ configTags ; } 
public function onKernelException ( GetResponseForExceptionEvent $ event ) { $ exception = $ event -> getException ( ) ; if ( $ exception instanceof HttpExceptionInterface ) { $ code = $ event -> getException ( ) -> getStatusCode ( ) ; } else { $ code = 'unknown' ; } $ this -> eventDispatcher -> dispatch ( 'statsd.exception' , new StatsdEvent ( $ code ) ) ; } 
private function dispatchMemory ( ) { $ memory = memory_get_peak_usage ( true ) ; $ memory = ( $ memory > 1024 ? intval ( $ memory / 1024 ) : 0 ) ; $ this -> eventDispatcher -> dispatch ( 'statsd.memory_usage' , new StatsdEvent ( $ memory ) ) ; } 
private function dispatchRequestTime ( PostResponseEvent $ event ) { $ request = $ event -> getRequest ( ) ; $ startTime = $ request -> server -> get ( 'REQUEST_TIME_FLOAT' , $ request -> server -> get ( 'REQUEST_TIME' ) ) ; $ time = microtime ( true ) - $ startTime ; $ time = round ( $ time * 1000 ) ; $ this -> eventDispatcher -> dispatch ( 'statsd.time' , new StatsdEvent ( $ time ) ) ; } 
public static function createFromConsoleEvent ( BaseConsoleEvent $ e , $ startTime = null , $ executionTime = null ) { if ( static :: support ( $ e ) ) { return new static ( $ e , $ startTime , $ executionTime ) ; } else { throw \ InvalidArgumentException ( 'Invalid event type.' ) ; } } 
public function onKernelResponse ( $ event ) { if ( HttpKernelInterface :: MASTER_REQUEST == $ event -> getRequestType ( ) ) { foreach ( $ this -> statsdClients as $ clientName => $ client ) { $ clientInfo = [ 'name' => $ clientName , 'operations' => [ ] ] ; foreach ( $ client -> getToSend ( ) as $ operation ) { if ( $ operation ) { $ this -> data [ 'operations' ] ++ ; $ message = $ operation [ 'message' ] ; $ clientInfo [ 'operations' ] [ ] = [ 'server' => $ operation [ 'server' ] , 'node' => $ message -> getNode ( ) , 'value' => $ message -> getValue ( ) , 'sample' => $ message -> getSampleRate ( ) , 'unit' => $ message -> getUnit ( ) ] ; } } $ this -> data [ 'clients' ] [ ] = $ clientInfo ; } } } 
protected function getType ( & $ value ) { if ( is_numeric ( $ value ) ) { $ value += 0 ; if ( is_int ( $ value ) ) { return self :: T_INTEGER ; } return self :: T_FLOAT ; } if ( ctype_alpha ( $ value ) ) { $ name = __CLASS__ . '::T_' . strtoupper ( $ value ) ; if ( defined ( $ name ) ) { return constant ( $ name ) ; } return self :: T_STRING ; } switch ( $ value ) { case ',' : return self :: T_COMMA ; case '(' : return self :: T_OPEN_PARENTHESIS ; case ')' : return self :: T_CLOSE_PARENTHESIS ; case '=' : return self :: T_EQUALS ; case ';' : return self :: T_SEMICOLON ; default : return self :: T_NONE ; } } 
public function parse ( $ input = null ) { if ( null !== $ input ) { $ this -> input = $ input ; } $ this -> lexer -> setInput ( $ this -> input ) ; $ this -> lexer -> moveNext ( ) ; $ this -> srid = null ; $ this -> dimension = null ; if ( $ this -> lexer -> isNextToken ( Lexer :: T_SRID ) ) { $ this -> srid = $ this -> srid ( ) ; } $ geometry = $ this -> geometry ( ) ; $ geometry [ 'srid' ] = $ this -> srid ; $ geometry [ 'dimension' ] = '' === $ this -> dimension ? null : $ this -> dimension ; return $ geometry ; } 
protected function srid ( ) { $ this -> match ( Lexer :: T_SRID ) ; $ this -> match ( Lexer :: T_EQUALS ) ; $ this -> match ( Lexer :: T_INTEGER ) ; $ srid = $ this -> lexer -> value ( ) ; $ this -> match ( Lexer :: T_SEMICOLON ) ; return $ srid ; } 
protected function geometry ( ) { $ type = $ this -> type ( ) ; $ this -> type = $ type ; if ( $ this -> lexer -> isNextTokenAny ( array ( Lexer :: T_Z , Lexer :: T_M , Lexer :: T_ZM ) ) ) { $ this -> match ( $ this -> lexer -> lookahead [ 'type' ] ) ; $ this -> dimension = $ this -> lexer -> value ( ) ; } $ this -> match ( Lexer :: T_OPEN_PARENTHESIS ) ; $ value = $ this -> $ type ( ) ; $ this -> match ( Lexer :: T_CLOSE_PARENTHESIS ) ; return array ( 'type' => $ type , 'value' => $ value ) ; } 
protected function point ( ) { if ( null !== $ this -> dimension ) { return $ this -> coordinates ( 2 + strlen ( $ this -> dimension ) ) ; } $ values = $ this -> coordinates ( 2 ) ; for ( $ i = 3 ; $ i <= 4 && $ this -> lexer -> isNextTokenAny ( array ( Lexer :: T_FLOAT , Lexer :: T_INTEGER ) ) ; $ i ++ ) { $ values [ ] = $ this -> coordinate ( ) ; } switch ( count ( $ values ) ) { case 2 : $ this -> dimension = '' ; break ; case 3 : $ this -> dimension = 'Z' ; break ; case 4 : $ this -> dimension = 'ZM' ; break ; } return $ values ; } 
protected function coordinates ( $ count ) { $ values = array ( ) ; for ( $ i = 1 ; $ i <= $ count ; $ i ++ ) { $ values [ ] = $ this -> coordinate ( ) ; } return $ values ; } 
protected function coordinate ( ) { $ this -> match ( ( $ this -> lexer -> isNextToken ( Lexer :: T_FLOAT ) ? Lexer :: T_FLOAT : Lexer :: T_INTEGER ) ) ; return $ this -> lexer -> value ( ) ; } 
protected function pointList ( ) { $ points = array ( $ this -> point ( ) ) ; while ( $ this -> lexer -> isNextToken ( Lexer :: T_COMMA ) ) { $ this -> match ( Lexer :: T_COMMA ) ; $ points [ ] = $ this -> point ( ) ; } return $ points ; } 
protected function pointLists ( ) { $ this -> match ( Lexer :: T_OPEN_PARENTHESIS ) ; $ pointLists = array ( $ this -> pointList ( ) ) ; $ this -> match ( Lexer :: T_CLOSE_PARENTHESIS ) ; while ( $ this -> lexer -> isNextToken ( Lexer :: T_COMMA ) ) { $ this -> match ( Lexer :: T_COMMA ) ; $ this -> match ( Lexer :: T_OPEN_PARENTHESIS ) ; $ pointLists [ ] = $ this -> pointList ( ) ; $ this -> match ( Lexer :: T_CLOSE_PARENTHESIS ) ; } return $ pointLists ; } 
protected function multiPolygon ( ) { $ this -> match ( Lexer :: T_OPEN_PARENTHESIS ) ; $ polygons = array ( $ this -> polygon ( ) ) ; $ this -> match ( Lexer :: T_CLOSE_PARENTHESIS ) ; while ( $ this -> lexer -> isNextToken ( Lexer :: T_COMMA ) ) { $ this -> match ( Lexer :: T_COMMA ) ; $ this -> match ( Lexer :: T_OPEN_PARENTHESIS ) ; $ polygons [ ] = $ this -> polygon ( ) ; $ this -> match ( Lexer :: T_CLOSE_PARENTHESIS ) ; } return $ polygons ; } 
protected function geometryCollection ( ) { $ collection = array ( $ this -> geometry ( ) ) ; while ( $ this -> lexer -> isNextToken ( Lexer :: T_COMMA ) ) { $ this -> match ( Lexer :: T_COMMA ) ; $ collection [ ] = $ this -> geometry ( ) ; } return $ collection ; } 
protected function match ( $ token ) { $ lookaheadType = $ this -> lexer -> lookahead [ 'type' ] ; if ( $ lookaheadType !== $ token && ( $ token !== Lexer :: T_TYPE || $ lookaheadType <= Lexer :: T_TYPE ) ) { throw $ this -> syntaxError ( $ this -> lexer -> getLiteral ( $ token ) ) ; } $ this -> lexer -> moveNext ( ) ; } 
private function syntaxError ( $ expected ) { $ expected = sprintf ( 'Expected %s, got' , $ expected ) ; $ token = $ this -> lexer -> lookahead ; $ found = null === $ this -> lexer -> lookahead ? 'end of string.' : sprintf ( '"%s"' , $ token [ 'value' ] ) ; $ message = sprintf ( '[Syntax Error] line 0, col %d: Error: %s %s in value "%s"' , isset ( $ token [ 'position' ] ) ? $ token [ 'position' ] : '-1' , $ expected , $ found , $ this -> input ) ; return new UnexpectedValueException ( $ message ) ; } 
protected function createResponseParts ( $ responseParts ) { if ( $ responseParts === null ) { return array ( ) ; } $ responses = array ( ) ; foreach ( $ responseParts as $ responsePart ) { $ responses [ ] = new Response ( $ responsePart ) ; } return $ responses ; } 
public function getTime ( ) { if ( isset ( $ this -> data [ 'time' ] ) ) { $ requestTime = new \ DateTime ( ) ; 
protected function createApiClient ( ) { 
public function command ( ) { try { $ args = func_get_args ( ) ; $ commandName = $ args [ 0 ] ; array_shift ( $ args ) ; $ messageToSend = json_encode ( array ( 'name' => $ commandName , 'args' => $ args ) ) ; $ commandResponse = $ this -> getApiClient ( ) -> post ( "/api" , array ( "body" => $ messageToSend ) ) ; $ jsonResponse = json_decode ( $ commandResponse -> getBody ( ) , TRUE ) ; } catch ( ServerException $ e ) { $ jsonResponse = json_decode ( $ e -> getResponse ( ) -> getBody ( ) -> getContents ( ) , true ) ; } catch ( ConnectException $ e ) { throw new DeadClient ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } catch ( \ Exception $ e ) { throw $ e ; } if ( isset ( $ jsonResponse [ 'error' ] ) ) { throw $ this -> getErrorClass ( $ jsonResponse ) ; } return $ jsonResponse [ 'response' ] ; } 
public function sendKeys ( $ pageId , $ elementId , $ keys ) { return $ this -> command ( 'send_keys' , $ pageId , $ elementId , $ this -> normalizeKeys ( $ keys ) ) ; } 
public function getRedirectUrl ( ) { if ( isset ( $ this -> data [ 'redirectUrl' ] ) && ! empty ( $ this -> data [ 'redirectUrl' ] ) ) { return $ this -> data [ 'redirectUrl' ] ; } return null ; } 
protected function checkRenderOptions ( $ options ) { 
public function render ( $ path , $ options = array ( ) ) { $ fixedOptions = $ this -> checkRenderOptions ( $ options ) ; return $ this -> command ( 'render' , $ path , $ fixedOptions [ "full" ] , $ fixedOptions [ "selector" ] ) ; } 
public function renderBase64 ( $ imageFormat , $ options = array ( ) ) { $ fixedOptions = $ this -> checkRenderOptions ( $ options ) ; return $ this -> command ( 'render_base64' , $ imageFormat , $ fixedOptions [ "full" ] , $ fixedOptions [ "selector" ] ) ; } 
public function find ( $ method , $ selector ) { $ result = $ this -> command ( 'find' , $ method , $ selector ) ; $ found [ "page_id" ] = $ result [ "page_id" ] ; foreach ( $ result [ "ids" ] as $ id ) { $ found [ "ids" ] [ ] = $ id ; } return $ found ; } 
public function findWithin ( $ pageId , $ elementId , $ method , $ selector ) { return $ this -> command ( 'find_within' , $ pageId , $ elementId , $ method , $ selector ) ; } 
public function setAttribute ( $ pageId , $ elementId , $ name , $ value ) { return $ this -> command ( 'set_attribute' , $ pageId , $ elementId , $ name , $ value ) ; } 
public function keyEvent ( $ pageId , $ elementId , $ keyEvent , $ key , $ modifier ) { return $ this -> command ( "key_event" , $ pageId , $ elementId , $ keyEvent , $ key , $ modifier ) ; } 
public function selectOption ( $ pageId , $ elementId , $ value , $ multiple = false ) { return $ this -> command ( "select_option" , $ pageId , $ elementId , $ value , $ multiple ) ; } 
public function debug ( $ enable = false ) { $ this -> debug = $ enable ; return $ this -> command ( 'set_debug' , $ this -> debug ) ; } 
public function setProxy ( $ proxy ) { $ args = array ( 'set_proxy' ) ; if ( $ proxy !== false ) { if ( preg_match ( '~^(http|socks5)://(?:([^:@/]*?):([^:@/]*?)@)?([^:@/]+):(\d+)$~' , $ proxy , $ components ) ) { array_push ( $ args , $ components [ 4 ] , intval ( $ components [ 5 ] , 10 ) , $ components [ 1 ] ) ; if ( strlen ( $ components [ 2 ] ) || strlen ( $ components [ 3 ] ) ) { array_push ( $ args , urldecode ( $ components [ 2 ] ) , urldecode ( $ components [ 3 ] ) ) ; } } else { throw new \ UnexpectedValueException ( 'Invalid proxy url ' . $ proxy ) ; } } return call_user_func_array ( array ( $ this , 'command' ) , $ args ) ; } 
public function networkTraffic ( ) { $ networkTraffic = $ this -> command ( 'network_traffic' ) ; $ requestTraffic = array ( ) ; if ( count ( $ networkTraffic ) === 0 ) { return null ; } foreach ( $ networkTraffic as $ traffic ) { $ requestTraffic [ ] = new Request ( $ traffic [ "request" ] , $ traffic [ "responseParts" ] ) ; } return $ requestTraffic ; } 
public function cookies ( ) { $ cookies = $ this -> command ( 'cookies' ) ; $ objCookies = array ( ) ; foreach ( $ cookies as $ cookie ) { $ objCookies [ $ cookie [ "name" ] ] = new Cookie ( $ cookie ) ; } return $ objCookies ; } 
public function setCookie ( $ cookie ) { 
public function javascriptErrors ( ) { $ jsErrors = array ( ) ; $ errors = $ this -> response [ "error" ] [ "args" ] [ 0 ] ; foreach ( $ errors as $ error ) { $ jsErrors [ ] = new JSErrorItem ( $ error [ "message" ] , $ error [ "stack" ] ) ; } return $ jsErrors ; } 
public function message ( ) { $ error = "One or more errors were raised in the Javascript code on the page. If you don't care about these errors, you can ignore them by setting js_errors: false in your Poltergeist configuration (see documentation for details)." ; 
private function compileNode ( bool $ isCompilingHostTrie , TrieNode $ currTrieNode , AstNode $ ast , Route $ route , ? TrieNode $ hostTrie ) : void { $ astChildren = $ ast -> children ; $ numAstChildren = \ count ( $ astChildren ) ; $ isEndpoint = false ; $ segmentContainsVariable = false ; $ segmentBuffer = [ ] ; foreach ( $ isCompilingHostTrie ? \ array_reverse ( $ astChildren ) : $ astChildren as $ i => $ childAstNode ) { $ isEndpoint = $ isEndpoint || ( ( $ isCompilingHostTrie || $ hostTrie === null ) && ( $ i === $ numAstChildren - 1 || $ childAstNode -> type === AstNodeTypes :: OPTIONAL_ROUTE_PART || ( $ astChildren [ $ i + 1 ] -> type === AstNodeTypes :: OPTIONAL_ROUTE_PART ) ) ) ; switch ( $ childAstNode -> type ) { case AstNodeTypes :: SEGMENT_DELIMITER : 
private function compileVariableNode ( AstNode $ astNode ) : RouteVariable { $ rules = [ ] ; foreach ( $ astNode -> children as $ childAstNode ) { if ( $ childAstNode -> type !== AstNodeTypes :: VARIABLE_RULE ) { throw new InvalidArgumentException ( "Unexpected node type {$childAstNode->type}" ) ; } $ ruleParams = $ childAstNode -> hasChildren ( ) ? $ childAstNode -> children [ 0 ] -> value : [ ] ; $ rules [ ] = $ this -> ruleFactory -> createRule ( $ childAstNode -> value , $ ruleParams ) ; } return new RouteVariable ( $ astNode -> value , $ rules ) ; } 
private static function createTrieNode ( array & $ segmentBuffer , bool & $ segmentContainsVariable , bool $ isEndpoint , Route $ route , ? TrieNode $ hostTrie ) : TrieNode { $ routes = $ isEndpoint ? $ route : [ ] ; if ( $ segmentContainsVariable ) { $ node = new VariableTrieNode ( $ segmentBuffer , [ ] , $ routes , $ hostTrie ) ; } else { $ node = new LiteralTrieNode ( \ implode ( '' , $ segmentBuffer ) , [ ] , $ routes , $ hostTrie ) ; } 
private static function flushTextBuffer ( string & $ textBuffer , array & $ tokens ) : void { if ( $ textBuffer !== '' ) { $ tokens [ ] = new Token ( TokenTypes :: T_TEXT , $ textBuffer ) ; $ textBuffer = '' ; } } 
private static function lexNumber ( string $ number , array & $ tokens , int & $ cursor ) : void { $ floatVal = ( float ) $ number ; $ intVal = ( int ) $ number ; 
private static function lexPunctuation ( string $ punctuation , array & $ tokens , int & $ cursor ) : void { $ tokens [ ] = new Token ( TokenTypes :: T_PUNCTUATION , $ punctuation ) ; $ cursor ++ ; } 
private static function lexQuotedString ( string $ quotedString , array & $ tokens , int & $ cursor ) : void { $ tokens [ ] = new Token ( TokenTypes :: T_QUOTED_STRING , \ stripcslashes ( \ substr ( \ trim ( $ quotedString ) , 1 , - 1 ) ) ) ; $ cursor += \ mb_strlen ( $ quotedString ) ; } 
private static function lexTextChar ( string $ char , string & $ textBuffer , int & $ cursor ) : void { $ textBuffer .= $ char ; $ cursor ++ ; } 
private static function lexVariableName ( string $ variableName , array & $ tokens , int & $ cursor ) : void { 
public function add ( Route $ route ) : void { $ this -> routes [ ] = $ route ; if ( $ route -> name !== null ) { $ this -> namedRoutes [ $ route -> name ] = & $ route ; } } 
public function getNamedRoute ( string $ name ) : ? Route { if ( ! isset ( $ this -> namedRoutes [ $ name ] ) ) { return null ; } return $ this -> namedRoutes [ $ name ] ; } 
public function createTrie ( ) : TrieNode { if ( $ this -> trieCache !== null && ( $ trie = $ this -> trieCache -> get ( ) ) !== null ) { return $ trie ; } 
public function parseHeaders ( array $ server ) : array { $ headers = [ ] ; foreach ( $ server as $ key => $ value ) { $ uppercasedKey = \ strtoupper ( $ key ) ; if ( isset ( self :: $ specialCaseHeaders [ $ uppercasedKey ] ) || \ strpos ( $ uppercasedKey , 'HTTP_' ) === 0 ) { $ value = ( array ) $ value ; $ headers [ self :: normalizeName ( $ key ) ] = $ value ; } } return $ headers ; } 
private static function normalizeName ( $ name ) : string { $ dashedName = \ str_replace ( '_' , '-' , $ name ) ; if ( \ stripos ( $ dashedName , 'HTTP-' ) === 0 ) { $ dashedName = \ substr ( $ dashedName , 5 ) ; } return $ dashedName ; } 
public function expect ( string $ type , $ value = null , string $ message = null ) : void { if ( $ this -> test ( $ type , $ value ) ) { return ; } $ currentToken = $ this -> getCurrent ( ) ; if ( $ message === null ) { 
public function getCurrent ( ) : ? Token { return \ count ( $ this -> tokens ) > $ this -> cursor ? $ this -> tokens [ $ this -> cursor ] : null ; } 
public function next ( ) : ? Token { return \ count ( $ this -> tokens ) > ++ $ this -> cursor ? $ this -> tokens [ $ this -> cursor ] : null ; } 
public function nextIfType ( string $ type , $ value = null ) : bool { $ currentToken = $ this -> getCurrent ( ) ; $ typeMatches = $ currentToken !== null && $ currentToken -> type === $ type ; if ( $ typeMatches && ( $ value === null || $ currentToken -> value === $ value ) ) { $ this -> next ( ) ; return true ; } return false ; } 
public function peek ( int $ lookahead = 1 ) : ? Token { if ( $ this -> cursor + $ lookahead >= \ count ( $ this -> tokens ) ) { return null ; } return $ this -> tokens [ $ this -> cursor + $ lookahead ] ; } 
public function addChild ( AstNode $ node ) : AstNode { $ node -> parent = $ this ; $ this -> children [ ] = $ node ; return $ this ; } 
public function addChild ( TrieNode $ childNode ) : self { if ( $ childNode instanceof LiteralTrieNode ) { $ this -> addLiteralChildNode ( $ childNode ) ; } elseif ( $ childNode instanceof VariableTrieNode ) { $ this -> addVariableChildNode ( $ childNode ) ; } else { throw new InvalidArgumentException ( 'Unexpected trie node type ' . \ get_class ( $ childNode ) ) ; } return $ this ; } 
public function getAllChildren ( ) : array { $ children = [ ] ; foreach ( $ this -> literalChildrenByValue as $ childNode ) { $ children [ ] = $ childNode ; } foreach ( $ this -> variableChildren as $ childNode ) { $ children [ ] = $ childNode ; } return $ children ; } 
private function addLiteralChildNode ( LiteralTrieNode $ childNode ) : void { 
private function addVariableChildNode ( VariableTrieNode $ childNode ) : void { 
public function buildAll ( ) : array { $ builtRoutes = [ ] ; foreach ( $ this -> routeBuilders as $ routeBuilder ) { $ builtRoutes [ ] = $ routeBuilder -> build ( ) ; } return $ builtRoutes ; } 
public function group ( RouteGroupOptions $ groupOptions , Closure $ callback ) : void { $ this -> groupOptionsStack [ ] = $ groupOptions ; $ callback ( $ this ) ; \ array_pop ( $ this -> groupOptionsStack ) ; } 
public function map ( $ httpMethods , string $ pathTemplate , string $ hostTemplate = null , bool $ isHttpsOnly = false ) : RouteBuilder { $ this -> applyGroupRouteTemplates ( $ pathTemplate , $ hostTemplate , $ isHttpsOnly ) ; $ routeBuilder = new RouteBuilder ( ( array ) $ httpMethods , new UriTemplate ( $ pathTemplate , $ hostTemplate , $ isHttpsOnly ) ) ; $ this -> applyGroupConstraints ( $ routeBuilder ) ; $ this -> applyGroupMiddleware ( $ routeBuilder ) ; $ this -> applyGroupAttributes ( $ routeBuilder ) ; $ this -> routeBuilders [ ] = $ routeBuilder ; return $ routeBuilder ; } 
private function applyGroupAttributes ( RouteBuilder $ routeBuilder ) : void { $ groupAttributes = [ ] ; foreach ( $ this -> groupOptionsStack as $ groupOptions ) { $ groupAttributes = \ array_merge ( $ groupAttributes , $ groupOptions -> attributes ) ; } $ routeBuilder -> withManyAttributes ( $ groupAttributes ) ; } 
private function applyGroupConstraints ( RouteBuilder $ routeBuilder ) : void { $ groupConstraintBindings = [ ] ; foreach ( $ this -> groupOptionsStack as $ groupOptions ) { $ groupConstraintBindings = \ array_merge ( $ groupConstraintBindings , $ groupOptions -> constraints ) ; } $ routeBuilder -> withManyConstraints ( $ groupConstraintBindings ) ; } 
private function applyGroupMiddleware ( RouteBuilder $ routeBuilder ) : void { $ groupMiddlewareBindings = [ ] ; foreach ( $ this -> groupOptionsStack as $ groupOptions ) { $ groupMiddlewareBindings = \ array_merge ( $ groupMiddlewareBindings , $ groupOptions -> middlewareBindings ) ; } $ routeBuilder -> withManyMiddleware ( $ groupMiddlewareBindings ) ; } 
private function applyGroupRouteTemplates ( string & $ pathTemplate , string & $ hostTemplate = null , bool & $ isHttpsOnly = false ) : void { $ groupPathTemplate = '' ; $ groupHostTemplate = '' ; $ groupIsHttpsOnly = false ; foreach ( $ this -> groupOptionsStack as $ groupOptions ) { $ groupPathTemplate .= $ groupOptions -> pathTemplate ; $ groupHostTemplate = $ groupOptions -> hostTemplate . $ groupHostTemplate ; $ groupIsHttpsOnly = $ groupIsHttpsOnly || $ groupOptions -> isHttpsOnly ; } $ pathTemplate = $ groupPathTemplate . $ pathTemplate ; $ hostTemplate = ( $ hostTemplate ?? '' ) . $ groupHostTemplate ; $ isHttpsOnly = $ isHttpsOnly || $ groupIsHttpsOnly ; } 
public function registerRuleFactories ( IRuleFactory $ ruleFactory ) : IRuleFactory { $ ruleFactory -> registerRuleFactory ( AlphaRule :: getSlug ( ) , function ( ) { return new AlphaRule ( ) ; } ) ; $ ruleFactory -> registerRuleFactory ( AlphanumericRule :: getSlug ( ) , function ( ) { return new AlphanumericRule ( ) ; } ) ; $ ruleFactory -> registerRuleFactory ( BetweenRule :: getSlug ( ) , function ( $ min , $ max , bool $ isInclusive = true ) { return new BetweenRule ( $ min , $ max , $ isInclusive ) ; } ) ; $ ruleFactory -> registerRuleFactory ( DateRule :: getSlug ( ) , function ( $ formats ) { return new DateRule ( $ formats ) ; } ) ; $ ruleFactory -> registerRuleFactory ( InRule :: getSlug ( ) , function ( array $ acceptableValues ) { return new InRule ( $ acceptableValues ) ; } ) ; $ ruleFactory -> registerRuleFactory ( IntegerRule :: getSlug ( ) , function ( ) { return new IntegerRule ( ) ; } ) ; $ ruleFactory -> registerRuleFactory ( NotInRule :: getSlug ( ) , function ( array $ unacceptableValues ) { return new NotInRule ( $ unacceptableValues ) ; } ) ; $ ruleFactory -> registerRuleFactory ( NumericRule :: getSlug ( ) , function ( ) { return new NumericRule ( ) ; } ) ; $ ruleFactory -> registerRuleFactory ( RegexRule :: getSlug ( ) , function ( string $ regex ) { return new RegexRule ( $ regex ) ; } ) ; $ ruleFactory -> registerRuleFactory ( UuidV4Rule :: getSlug ( ) , function ( ) { return new UuidV4Rule ( ) ; } ) ; return $ ruleFactory ; } 
private static function getMatchCandidates ( TrieNode $ node , array $ segments , int $ segmentIter , array $ hostSegments , array & $ routeVars ) : iterable { 
public function build ( ) : Route { if ( $ this -> action === null ) { throw new LogicException ( 'No controller specified for route' ) ; } return new Route ( $ this -> uriTemplate , $ this -> action , $ this -> constraints , $ this -> middlewareBindings , $ this -> name , $ this -> attributes ) ; } 
public function toMethod ( string $ controllerClassName , string $ controllerMethodName ) : self { $ this -> action = new MethodRouteAction ( $ controllerClassName , $ controllerMethodName ) ; return $ this ; } 
public function withAttribute ( string $ name , $ value ) : self { $ this -> attributes [ $ name ] = $ value ; return $ this ; } 
public function withManyAttributes ( array $ attributes ) : self { $ this -> attributes = \ array_merge ( $ this -> attributes , $ attributes ) ; return $ this ; } 
public function withManyConstraints ( array $ constraints ) : self { $ this -> constraints = \ array_merge ( $ this -> constraints , $ constraints ) ; return $ this ; } 
public function withManyMiddleware ( array $ middlewareBindings ) : self { foreach ( $ middlewareBindings as $ middlewareBinding ) { if ( \ is_string ( $ middlewareBinding ) ) { $ this -> middlewareBindings [ ] = new MiddlewareBinding ( $ middlewareBinding ) ; } elseif ( $ middlewareBinding instanceof MiddlewareBinding ) { $ this -> middlewareBindings [ ] = $ middlewareBinding ; } else { throw new InvalidArgumentException ( 'Middleware binding must either be a string or an instance of ' . MiddlewareBinding :: class ) ; } } return $ this ; } 
public function withMiddleware ( string $ middlewareClassName , array $ middlewareProperties = [ ] ) : self { $ this -> middlewareBindings [ ] = new MiddlewareBinding ( $ middlewareClassName , $ middlewareProperties ) ; return $ this ; } 
private function parsePunctuation ( TokenStream $ tokens , AstNode & $ currNode , bool $ parsingPath ) : void { if ( ( $ token = $ tokens -> getCurrent ( ) ) === null ) { return ; } switch ( $ token -> value ) { case '/' : if ( ! $ parsingPath ) { throw new InvalidArgumentException ( "Unexpected {$token->type} \"{$token->value}\" in host" ) ; } $ currNode -> addChild ( new AstNode ( AstNodeTypes :: SEGMENT_DELIMITER , $ token -> value ) ) ; $ tokens -> next ( ) ; break ; case '.' : * Optional parts in hosts must end with '.', eg [foo.[bar.]]example.com * So, make sure that the previous non-optional route part ends with '.' */ $ isValid = false ; for ( $ i = \ count ( $ currNode -> children ) - 1 ; $ i >= 0 ; $ i -- ) { $ childNode = $ currNode -> children [ $ i ] ; if ( $ childNode -> type !== AstNodeTypes :: OPTIONAL_ROUTE_PART ) { if ( $ childNode -> type === AstNodeTypes :: SEGMENT_DELIMITER ) { $ isValid = true ; } break ; } } if ( ! $ isValid ) { throw new InvalidArgumentException ( 'Expected optional host part to end with \'.\'' ) ; } } 
private function parseText ( TokenStream $ tokens , AstNode $ currNode ) : void { if ( ( $ token = $ tokens -> getCurrent ( ) ) === null ) { return ; } $ currNode -> addChild ( new AstNode ( AstNodeTypes :: TEXT , $ token -> value ) ) ; $ tokens -> next ( ) ; } 
private function parseTokens ( TokenStream $ tokens , AstNode $ ast ) : void { $ parsingPath = $ ast -> type === AstNodeTypes :: PATH ; $ currNode = $ ast ; while ( ( $ token = $ tokens -> getCurrent ( ) ) !== null ) { switch ( $ token -> type ) { case TokenTypes :: T_TEXT : $ this -> parseText ( $ tokens , $ currNode ) ; break ; case TokenTypes :: T_NUMBER : 
private function parseVariable ( TokenStream $ tokens , AstNode & $ currNode ) : void { if ( ( $ token = $ tokens -> getCurrent ( ) ) === null ) { return ; } $ variableNode = new AstNode ( AstNodeTypes :: VARIABLE , $ token -> value ) ; $ currNode -> addChild ( $ variableNode ) ; $ currNode = $ variableNode ; $ tokens -> next ( ) ; 
private function parseVariableRule ( TokenStream $ tokens , AstNode $ currNode ) : void { 
public function isMatch ( string $ segmentValue , array & $ routeVariables ) : bool { if ( $ this -> onlyContainsVariable ) { foreach ( $ this -> parts [ 0 ] -> rules as $ rule ) { if ( ! $ rule -> passes ( $ segmentValue ) ) { return false ; } } $ routeVariables [ $ this -> parts [ 0 ] -> name ] = $ segmentValue ; return true ; } $ matches = [ ] ; if ( \ preg_match ( $ this -> regex , $ segmentValue , $ matches , PREG_UNMATCHED_AS_NULL ) !== 1 ) { return false ; } 
protected function decodeResponse ( $ action , $ data ) { if ( ! array_key_exists ( $ action , $ this -> decodeSettings [ static :: DECODE_ACTION ] ) ) { throw new DeCaptchaErrors ( 'нет action'); } $ decodeSetting = $ this -> decodeSettings [ static :: DECODE_ACTION ] [ $ action ] ; $ decodeFormat = array_key_exists ( static :: DECODE_FORMAT , $ decodeSetting ) ? $ decodeSetting [ static :: DECODE_FORMAT ] : $ this -> decodeSettings [ static :: DECODE_FORMAT ] ; $ values = [ ] ; switch ( $ decodeFormat ) { case static :: RESPONSE_TYPE_STRING : foreach ( explode ( $ decodeSetting [ static :: DECODE_SEPARATOR ] , $ data ) as $ key => $ value ) { foreach ( $ decodeSetting [ static :: DECODE_PARAMS ] as $ param => $ paramSetting ) { if ( $ key === $ paramSetting [ static :: DECODE_PARAM_SETTING_MARKER ] ) { $ values [ $ param ] = $ value ; } } } break ; case static :: RESPONSE_TYPE_JSON : foreach ( json_decode ( $ data , true ) as $ key => $ value ) { foreach ( $ decodeSetting [ static :: DECODE_PARAMS ] as $ param => $ paramSetting ) { if ( count ( explode ( '.' , $ paramSetting [ static :: DECODE_PARAM_SETTING_MARKER ] ) ) > 1 ) { if ( $ key === explode ( '.' , $ paramSetting [ static :: DECODE_PARAM_SETTING_MARKER ] ) [ 0 ] ) { if ( array_key_exists ( explode ( '.' , $ paramSetting [ static :: DECODE_PARAM_SETTING_MARKER ] ) [ 1 ] , $ value ) ) { $ values [ $ param ] = $ value [ explode ( '.' , $ paramSetting [ static :: DECODE_PARAM_SETTING_MARKER ] ) [ 1 ] ] ; } } } if ( $ key === $ paramSetting [ static :: DECODE_PARAM_SETTING_MARKER ] ) { $ values [ $ param ] = $ value ; } } } break ; } return $ values ; } 
protected function getFilePath ( $ fileName ) { if ( strpos ( $ fileName , 'http://' ) !== false || strpos ( $ fileName , 'https://' ) !== false ) { try { $ current = file_get_contents ( $ fileName ) ; } catch ( \ Exception $ e ) { throw new DeCaptchaErrors ( DeCaptchaErrors :: ERROR_FILE_IS_NOT_LOADED , $ fileName , $ this -> errorLang ) ; } $ path = tempnam ( sys_get_temp_dir ( ) , 'captcha' ) ; file_put_contents ( $ path , $ current ) ; return $ path ; } if ( file_exists ( $ fileName ) ) { return $ fileName ; } throw new DeCaptchaErrors ( DeCaptchaErrors :: ERROR_FILE_NOT_FOUND , $ fileName , $ this -> errorLang ) ; } 
public function getParamSpec ( $ param , $ spec = null , $ coding = null ) { if ( is_null ( $ spec ) ) { $ spec = $ param ; } if ( ! array_key_exists ( $ param , $ this -> params ) || is_null ( $ this -> params [ $ param ] ) ) { if ( ! array_key_exists ( $ spec , $ this -> params ) || is_null ( $ this -> params [ $ spec ] ) ) { return null ; } $ param = $ spec ; } switch ( $ spec ) { case static :: PARAM_SPEC_FILE : switch ( $ coding ) { case static :: PARAM_SLUG_CODING_BASE64 : return base64_encode ( file_get_contents ( $ this -> params [ $ param ] ) ) ; } return ( version_compare ( PHP_VERSION , '5.5.0' ) >= 0 ) ? new \ CURLFile ( $ this -> getFilePath ( $ this -> params [ $ param ] ) ) : '@' . $ this -> getFilePath ( $ this -> params [ $ param ] ) ; case static :: PARAM_SPEC_API_KEY : return is_callable ( $ this -> params [ $ param ] ) ? $ this -> params [ $ param ] ( ) : $ this -> params [ $ param ] ; case static :: PARAM_SPEC_CAPTCHA : return ( int ) $ this -> params [ $ param ] ; case static :: PARAM_SPEC_CODE : return ( string ) $ this -> params [ $ param ] ; } return null ; } 
protected function getParams ( $ action , $ field = null ) { if ( empty ( $ this -> actions [ $ action ] ) ) { return [ ] ; } $ fields = $ this -> actions [ $ action ] [ static :: ACTION_FIELDS ] ; if ( ! is_null ( $ field ) ) { $ fields = $ fields [ $ field ] [ static :: ACTION_FIELDS ] ; } $ params = [ ] ; foreach ( $ fields as $ field => $ settings ) { $ value = null ; if ( array_key_exists ( self :: PARAM_SLUG_DEFAULT , $ settings ) ) { $ value = $ settings [ self :: PARAM_SLUG_DEFAULT ] ; } if ( array_key_exists ( $ field , $ this -> params ) && ( ! array_key_exists ( self :: PARAM_SLUG_VARIABLE , $ settings ) ^ ( array_key_exists ( self :: PARAM_SLUG_VARIABLE , $ settings ) && $ settings [ self :: PARAM_SLUG_VARIABLE ] === false ) ) ) { $ value = $ this -> params [ $ field ] ; } if ( array_key_exists ( self :: PARAM_SLUG_SPEC , $ settings ) ) { $ value = $ this -> getParamSpec ( $ field , $ settings [ self :: PARAM_SLUG_SPEC ] , array_key_exists ( self :: PARAM_SLUG_CODING , $ settings ) ? $ settings [ self :: PARAM_SLUG_CODING ] : null ) ; } if ( is_null ( $ value ) ) { if ( array_key_exists ( self :: PARAM_SLUG_REQUIRE , $ settings ) && $ settings [ self :: PARAM_SLUG_REQUIRE ] === true ) { throw new DeCaptchaErrors ( DeCaptchaErrors :: ERROR_PARAM_REQUIRE , array_key_exists ( $ field , $ this -> paramsNames ) ? $ this -> paramsNames [ $ field ] : $ field , $ this -> errorLang ) ; } continue ; } if ( array_key_exists ( $ field , $ this -> paramsNames ) ) { switch ( $ settings [ self :: PARAM_SLUG_TYPE ] ) { case self :: PARAM_FIELD_TYPE_FLOAT : $ value = ( float ) $ value ; break ; case self :: PARAM_FIELD_TYPE_INTEGER : $ value = ( int ) $ value ; break ; case self :: PARAM_FIELD_TYPE_STRING : $ value = ( string ) $ value ; break ; case self :: PARAM_FIELD_TYPE_BOOLEAN : $ value = ( bool ) $ value ; break ; case self :: PARAM_FIELD_TYPE_OBJECT : $ value = $ this -> getParams ( $ action , $ field ) ; break ; } if ( array_key_exists ( self :: PARAM_SLUG_ENUM , $ settings ) && ! in_array ( $ value , $ settings [ static :: PARAM_SLUG_ENUM ] ) ) { throw new DeCaptchaErrors ( DeCaptchaErrors :: ERROR_PARAM_ENUM , ( array_key_exists ( $ field , $ this -> paramsNames ) ? $ this -> paramsNames [ $ field ] : $ field ) . ' = ' . $ value , $ this -> errorLang ) ; } $ params [ $ this -> paramsNames [ $ field ] ] = $ value ; } } return $ params ; } 
protected function getResponse ( $ action ) { return $ this -> curlResponse ( $ this -> getActionUrl ( $ action ) , $ this -> getParams ( $ action ) , array_key_exists ( static :: ACTION_METHOD , $ this -> actions [ $ action ] ) && $ this -> actions [ $ action ] [ static :: ACTION_METHOD ] === static :: ACTION_METHOD_POST , array_key_exists ( static :: ACTION_JSON , $ this -> actions [ $ action ] ) && $ this -> actions [ $ action ] [ static :: ACTION_JSON ] === true ) ; } 
protected function executionDelayed ( $ delay = 0 , $ callback = null ) { $ time = microtime ( true ) ; $ timePassed = $ time - $ this -> lastRunTime ; if ( $ timePassed < $ delay ) { usleep ( ( $ delay - $ timePassed ) * 1000000 ) ; } $ this -> lastRunTime = microtime ( true ) ; return $ callback instanceof \ Closure ? $ callback ( $ this ) : $ callback ; } 
protected function curlResponse ( $ url , $ data , $ isPost = true , $ isJson = false ) { $ curl = curl_init ( ) ; if ( $ isJson ) { $ data = json_encode ( $ data ) ; } elseif ( ! $ isPost ) { $ uri = [ ] ; foreach ( $ data as $ key => $ value ) { $ uri [ ] = "$key=$value" ; } $ url .= '?' . implode ( '&' , $ uri ) ; } curl_setopt ( $ curl , CURLOPT_URL , $ url ) ; if ( ! $ isJson && version_compare ( PHP_VERSION , '5.5.0' ) >= 0 && version_compare ( PHP_VERSION , '7.0' ) < 0 && defined ( 'CURLOPT_SAFE_UPLOAD' ) ) { curl_setopt ( $ curl , CURLOPT_SAFE_UPLOAD , false ) ; } curl_setopt ( $ curl , CURLOPT_RETURNTRANSFER , true ) ; curl_setopt ( $ curl , CURLOPT_ENCODING , 'gzip,deflate' ) ; curl_setopt ( $ curl , CURLOPT_TIMEOUT , 30 ) ; curl_setopt ( $ curl , CURLOPT_CONNECTTIMEOUT , 30 ) ; curl_setopt ( $ curl , CURLOPT_POST , $ isPost ) ; if ( $ isPost ) { curl_setopt ( $ curl , CURLOPT_POSTFIELDS , $ data ) ; } if ( $ isJson ) { curl_setopt ( $ curl , CURLOPT_HTTPHEADER , [ 'Content-Type: application/json; charset=utf-8' , 'Accept: application/json' , 'Content-Length: ' . strlen ( $ data ) , ] ) ; } $ result = curl_exec ( $ curl ) ; if ( curl_errno ( $ curl ) ) { throw new DeCaptchaErrors ( DeCaptchaErrors :: ERROR_CURL , curl_error ( $ curl ) , $ this -> errorLang ) ; } curl_close ( $ curl ) ; return $ result ; } 
public function recognize ( $ filePath , $ additionally = [ ] ) { try { $ this -> resetLimits ( ) ; if ( $ filePath ) { $ additionally [ static :: ACTION_FIELD_FILE ] = $ filePath ; } $ this -> setParams ( $ additionally ) ; return $ this -> requestRecognize ( ) && $ this -> requestCode ( ) ; } catch ( DeCaptchaErrors $ e ) { if ( $ this -> causeAnError ) { throw $ e ; } $ this -> errorObject = $ e ; return false ; } } 
protected function requestRepeat ( $ action , $ decodeAction , $ setParam , $ decodeSerParam , $ ok , $ sleep , $ repeat , $ error = null ) { if ( is_null ( $ error ) ) { $ error = static :: DECODE_PARAM_RESPONSE ; } while ( $ this -> limitHasNotYetEnded ( $ action ) ) { $ this -> executionDelayed ( $ sleep ) ; $ response = $ this -> getResponse ( $ action ) ; $ dataRecognize = $ this -> decodeResponse ( $ decodeAction , $ response ) ; if ( $ dataRecognize [ static :: DECODE_PARAM_RESPONSE ] === $ ok && ! empty ( $ dataRecognize [ $ decodeSerParam ] ) ) { $ this -> setParam ( $ setParam , $ dataRecognize [ $ decodeSerParam ] ) ; $ this -> executionDelayed ( static :: SLEEP_BETWEEN ) ; return true ; } elseif ( $ dataRecognize [ static :: DECODE_PARAM_RESPONSE ] === $ repeat ) { continue ; } throw new DeCaptchaErrors ( $ dataRecognize [ $ error ] , null , $ this -> errorLang ) ; } throw new DeCaptchaErrors ( DeCaptchaErrors :: ERROR_LIMIT , null , $ this -> errorLang ) ; } 
protected function requestUniversal ( $ action ) { $ this -> setParam ( static :: ACTION_FIELD_ACTION , $ action ) ; $ response = $ this -> getResponse ( static :: ACTION_UNIVERSAL ) ; return $ this -> decodeResponse ( static :: DECODE_ACTION_UNIVERSAL , $ response ) ; } 
protected function requestRecognize ( ) { return $ this -> requestRepeat ( static :: ACTION_RECOGNIZE , static :: DECODE_ACTION_RECOGNIZE , static :: PARAM_SPEC_CAPTCHA , static :: DECODE_PARAM_CAPTCHA , static :: RESPONSE_RECOGNIZE_OK , static :: SLEEP_RECOGNIZE , static :: RESPONSE_RECOGNIZE_REPEAT , static :: DECODE_PARAM_ERROR ) ; } 
protected function requestCode ( ) { return $ this -> requestRepeat ( static :: ACTION_UNIVERSAL_WITH_CAPTCHA , static :: DECODE_ACTION_GET , static :: PARAM_SPEC_CODE , static :: DECODE_PARAM_CODE , static :: RESPONSE_GET_OK , static :: SLEEP_GET , static :: RESPONSE_GET_REPEAT , static :: DECODE_PARAM_ERROR ) ; } 
public function getBalance ( ) { $ this -> setParam ( static :: ACTION_FIELD_ACTION , static :: ACTION_BALANCE ) ; $ response = $ this -> getResponse ( static :: ACTION_BALANCE ) ; $ result = $ this -> decodeResponse ( static :: DECODE_ACTION_BALANCE , $ response ) ; if ( $ result [ static :: DECODE_PARAM_RESPONSE ] != 0 ) { return 0 ; } return ( float ) $ result [ static :: DECODE_PARAM_BALANCE ] ; } 
public function getText ( $ name , $ separator = '; ' ) { $ getResult = function ( $ name , $ texts ) { if ( is_array ( $ name ) ) { $ name = implode ( '_' , $ name ) ; } if ( ! isset ( $ texts [ $ name ] ) ) { return null ; } if ( is_array ( $ texts [ $ name ] ) ) { if ( isset ( $ texts [ $ name ] [ $ this -> lang ] ) ) { return $ texts [ $ name ] [ $ this -> lang ] ; } return array_values ( $ texts [ $ name ] ) [ 0 ] ; } return $ texts [ $ name ] ; } ; $ result = $ getResult ( $ name , $ this -> texts ) ; if ( is_array ( $ result ) ) { if ( $ separator ) { $ result = implode ( $ separator , $ result ) ; } } return $ result ; } 
public function isThereSuch ( $ name ) { if ( is_string ( $ name ) && defined ( "static::$name" ) ) { return constant ( "static::$name" ) ; } if ( is_int ( $ name ) ) { return $ name ; } return null ; } 
public function _getCreateTableSQL ( $ tableName , array $ columns , array $ options = [ ] ) { $ queryFields = $ this -> platform -> getColumnDeclarationListSQL ( $ columns ) ; if ( isset ( $ options [ 'primary' ] ) && ! empty ( $ options [ 'primary' ] ) ) { $ keyColumns = array_unique ( array_values ( $ options [ 'primary' ] ) ) ; $ queryFields .= ', PRIMARY KEY(' . implode ( ', ' , $ keyColumns ) . ')' ; } $ query = 'CREATE TABLE ' . $ tableName . ' (' . $ queryFields . ')' ; $ sql [ ] = $ query ; if ( isset ( $ options [ 'indexes' ] ) && ! empty ( $ options [ 'indexes' ] ) ) { foreach ( $ options [ 'indexes' ] as $ index ) { $ sql [ ] = $ this -> platform -> getCreateIndexSQL ( $ index , $ tableName ) ; } } if ( isset ( $ options [ 'foreignKeys' ] ) ) { foreach ( ( array ) $ options [ 'foreignKeys' ] as $ definition ) { $ sql [ ] = $ this -> platform -> getCreateForeignKeySQL ( $ definition , $ tableName ) ; } } return $ sql ; } 
protected function getColumnComment ( Column $ column ) { $ comment = $ column -> getComment ( ) ; if ( $ this -> platform -> isCommentedDoctrineType ( $ column -> getType ( ) ) ) { $ comment .= $ this -> platform -> getDoctrineTypeComment ( $ column -> getType ( ) ) ; } return $ comment ; } 
public function group ( array $ attributes , Closure $ routes ) : Router { 
public function map ( ? string $ method , string $ route , $ controller , $ middleware = [ ] , string $ domain = null , string $ name = null ) : Router { $ name = $ name ? : $ this -> currentName ; $ uri = $ this -> currentPrefix . $ route ; $ middleware = is_array ( $ middleware ) ? $ middleware : [ $ middleware ] ; if ( is_string ( $ controller ) && is_callable ( $ controller ) == false ) { $ controller = $ this -> currentNamespace . "\\" . $ controller ; } $ route = new Route ( $ name , $ uri , $ method , $ controller , array_merge ( $ this -> currentMiddleware , $ middleware ) , $ domain ? : $ this -> currentDomain ) ; $ this -> routes [ ] = $ route ; if ( $ name ) { $ this -> names [ $ name ] = $ route ; $ this -> currentName = null ; } return $ this ; } 
public function dispatch ( ) : Router { $ this -> prepare ( ) ; $ method = $ this -> request -> getMethod ( ) ; $ scheme = $ this -> request -> getUri ( ) -> getScheme ( ) ; $ domain = substr ( $ this -> request -> getUri ( ) -> getHost ( ) , strlen ( $ scheme . '://' ) ) ; $ uri = $ this -> request -> getUri ( ) -> getPath ( ) ; sort ( $ this -> routes , SORT_DESC ) ; foreach ( $ this -> routes as $ route ) { $ parameters = [ ] ; if ( $ this -> compareMethod ( $ route -> getMethod ( ) , $ method ) && $ this -> compareDomain ( $ route -> getDomain ( ) , $ domain ) && $ this -> compareUri ( $ route -> getUri ( ) , $ uri , $ parameters ) ) { $ this -> currentRoute = $ route ; $ this -> publisher -> publish ( $ this -> run ( $ route , $ parameters ) ) ; return $ this ; } } throw new RouteNotFoundException ( ) ; } 
private function compareMethod ( ? string $ routeMethod , string $ requestMethod ) : bool { return $ routeMethod == null || $ routeMethod == $ requestMethod ; } 
private function compareDomain ( ? string $ routeDomain , string $ requestDomain ) : bool { return $ routeDomain == null || preg_match ( '@^' . $ routeDomain . '$@' , $ requestDomain ) ; } 
private function compareUri ( string $ routeUri , string $ requestUri , array & $ parameters ) : bool { $ pattern = '@^' . $ this -> regexUri ( $ routeUri ) . '$@' ; return preg_match ( $ pattern , $ requestUri , $ parameters ) ; } 
private function run ( Route $ route , array $ parameters ) { $ controller = $ route -> getController ( ) ; if ( count ( $ middleware = $ route -> getMiddleware ( ) ) > 0 ) { $ controllerRunner = function ( ServerRequest $ request ) use ( $ controller , $ parameters ) { return $ this -> runController ( $ controller , $ parameters , $ request ) ; } ; return $ this -> runControllerThroughMiddleware ( $ middleware , $ this -> request , $ controllerRunner ) ; } else { return $ this -> runController ( $ controller , $ parameters , $ this -> request ) ; } } 
private function runControllerThroughMiddleware ( array $ middleware , ServerRequestInterface $ request , Closure $ controllerRunner , $ i = 0 ) { if ( isset ( $ middleware [ $ i + 1 ] ) ) { $ next = function ( ServerRequestInterface $ request ) use ( $ middleware , $ controllerRunner , $ i ) { return $ this -> runControllerThroughMiddleware ( $ middleware , $ request , $ controllerRunner , $ i + 1 ) ; } ; } else { $ next = $ controllerRunner ; } if ( is_callable ( $ middleware [ $ i ] ) ) { return $ middleware [ $ i ] ( $ request , $ next ) ; } if ( is_subclass_of ( $ middleware [ $ i ] , Middleware :: class ) ) { if ( is_string ( $ middleware [ $ i ] ) ) { $ middleware [ $ i ] = new $ middleware [ $ i ] ; } return $ middleware [ $ i ] -> handle ( $ request , $ next ) ; } throw new InvalidMiddlewareException ( 'Invalid middleware for route: ' . $ this -> currentRoute ) ; } 
private function runController ( $ controller , array $ parameters , ServerRequestInterface $ request ) { try { if ( is_string ( $ controller ) && strpos ( $ controller , '@' ) ) { list ( $ className , $ methodName ) = explode ( '@' , $ controller ) ; if ( class_exists ( $ className ) == false ) { throw new InvalidControllerException ( "Controller class `$controller` not found." ) ; } $ classObject = new $ className ( ) ; if ( method_exists ( $ classObject , $ methodName ) == false ) { throw new InvalidControllerException ( "Controller method `$methodName` not found." ) ; } $ parameters = $ this -> arrangeMethodParameters ( $ className , $ methodName , $ parameters , $ request ) ; $ controller = [ $ classObject , $ methodName ] ; } elseif ( is_callable ( $ controller ) ) { $ parameters = $ this -> arrangeFunctionParameters ( $ controller , $ parameters , $ request ) ; } else { throw new InvalidControllerException ( 'Invalid controller: ' . $ controller ) ; } return call_user_func_array ( $ controller , $ parameters ) ; } catch ( ReflectionException $ e ) { throw new InvalidControllerException ( '' , 0 , $ e ) ; } } 
private function arrangeMethodParameters ( string $ class , string $ method , array $ parameters , ServerRequestInterface $ request ) { return $ this -> arrangeParameters ( new ReflectionMethod ( $ class , $ method ) , $ parameters , $ request ) ; } 
private function arrangeParameters ( ReflectionFunctionAbstract $ reflection , array $ parameters , ServerRequestInterface $ request ) { return array_map ( function ( ReflectionParameter $ parameter ) use ( $ parameters , $ request ) { if ( isset ( $ parameters [ $ parameter -> getName ( ) ] ) ) { return $ parameters [ $ parameter -> getName ( ) ] ; } if ( ( $ parameter -> getType ( ) && $ parameter -> getType ( ) -> getName ( ) == ServerRequestInterface :: class ) || ( $ parameter -> getType ( ) && $ parameter -> getType ( ) -> getName ( ) == ServerRequest :: class ) || ( $ parameter -> getName ( ) == 'request' ) ) { return $ request ; } if ( ( $ parameter -> getType ( ) && $ parameter -> getType ( ) -> getName ( ) == Router :: class ) || ( $ parameter -> getName ( ) == 'router' ) ) { return $ this ; } if ( $ parameter -> isOptional ( ) ) { return $ parameter -> getDefaultValue ( ) ; } return null ; } , $ reflection -> getParameters ( ) ) ; } 
private function regexUri ( string $ route ) : string { return preg_replace_callback ( '@{([^}]+)}@' , function ( array $ match ) { return $ this -> regexParameter ( $ match [ 1 ] ) ; } , $ route ) ; } 
private function regexParameter ( string $ name ) : string { if ( $ name [ - 1 ] == '?' ) { $ name = substr ( $ name , 0 , - 1 ) ; $ suffix = '?' ; } else { $ suffix = '' ; } $ pattern = $ this -> parameters [ $ name ] ?? '[^/]+' ; return '(?<' . $ name . '>' . $ pattern . ')' . $ suffix ; } 
public function any ( string $ route , $ controller , $ middleware = [ ] , string $ domain = null , string $ name = null ) : Router { return $ this -> map ( null , $ route , $ controller , $ middleware , $ domain , $ name ) ; } 
public function define ( string $ name , string $ pattern ) : Router { $ this -> parameters [ $ name ] = $ pattern ; return $ this ; } 
public function url ( string $ routeName , array $ parameters = [ ] ) : ? string { if ( isset ( $ this -> names [ $ routeName ] ) == false ) { return null ; } $ uri = $ this -> names [ $ routeName ] -> getUri ( ) ; foreach ( $ parameters as $ name => $ value ) { $ uri = preg_replace ( '/\??\{' . $ name . '\??\}/' , $ value , $ uri ) ; } $ uri = preg_replace ( '/{[^\}]+\?\}/' , '' , $ uri ) ; $ uri = str_replace ( '/?' , '' , $ uri ) ; return $ uri ; } 
private function prepare ( ) : void { if ( $ this -> request == null ) { $ this -> request = ServerRequestFactory :: fromGlobals ( ) ; } if ( $ this -> publisher == null ) { $ this -> publisher = new Publisher ( ) ; } } 
public function getAccessToken ( ) { $ client = new Client ( array ( 'base_uri' => 'https://api-ssl.bitly.com/oauth/access_token' , ) ) ; $ response = $ client -> post ( null , array ( 'auth' => array ( $ this -> username , $ this -> password , ) , ) ) ; return $ response -> getBody ( ) -> getContents ( ) ; } 
public function shorten ( LinkInterface $ link ) { $ client = $ this -> createClient ( ) ; $ response = $ client -> post ( $ this -> getUri ( ) , array_merge ( array ( 'json' => array ( 'longUrl' => $ link -> getLongUrl ( ) , ) , ) , $ this -> options ) ) ; $ response = $ this -> validate ( $ response -> getBody ( ) -> getContents ( ) ) ; $ link -> setShortUrl ( $ response -> id ) ; } 
public function expand ( LinkInterface $ link ) { $ client = $ this -> createClient ( ) ; $ response = $ client -> get ( $ this -> getUri ( array ( 'shortUrl' => $ link -> getShortUrl ( ) , ) ) , $ this -> options ) ; $ response = $ this -> validate ( $ response -> getBody ( ) -> getContents ( ) , true ) ; $ link -> setLongUrl ( $ response -> longUrl ) ; } 
private function getUri ( array $ parameters = array ( ) ) { if ( $ this -> apiKey ) { $ parameters = array_merge ( $ parameters , array ( 'key' => $ this -> apiKey ) ) ; } if ( 0 === count ( $ parameters ) ) { return ; } return sprintf ( '?%s' , http_build_query ( $ parameters ) ) ; } 
private function validate ( $ apiRawResponse , $ checkStatus = false ) { $ response = json_decode ( $ apiRawResponse ) ; if ( null === $ response ) { throw new InvalidApiResponseException ( 'Google response is probably mal-formed because cannot be json-decoded.' ) ; } if ( property_exists ( $ response , 'error' ) ) { throw new InvalidApiResponseException ( sprintf ( 'Google returned status code "%s" with message "%s".' , property_exists ( $ response -> error , 'code' ) ? $ response -> error -> code : '' , property_exists ( $ response -> error , 'message' ) ? $ response -> error -> message : '' ) ) ; } if ( ! property_exists ( $ response , 'id' ) ) { throw new InvalidApiResponseException ( 'Property "id" does not exist within Google response.' ) ; } if ( ! property_exists ( $ response , 'longUrl' ) ) { throw new InvalidApiResponseException ( 'Property "longUrl" does not exist within Google response.' ) ; } if ( ! $ checkStatus ) { return $ response ; } if ( ! property_exists ( $ response , 'status' ) ) { throw new InvalidApiResponseException ( 'Property "status" does not exist within Google response.' ) ; } if ( 'OK' !== $ response -> status ) { throw new InvalidApiResponseException ( sprintf ( 'Google returned status code "%s".' , $ response -> status ) ) ; } return $ response ; } 
public function getAccessToken ( ) { $ client = new Client ( array ( 'base_uri' => 'https://api.weixin.qq.com' , ) ) ; $ apiRawResponse = $ client -> get ( '/cgi-bin/token' , array ( 'query' => array ( 'grant_type' => 'client_credential' , 'appid' => $ this -> appid , 'secret' => $ this -> appsecret , ) , ) ) ; $ response = json_decode ( $ apiRawResponse -> getBody ( ) -> getContents ( ) ) ; if ( null === $ response ) { throw new InvalidApiResponseException ( 'Wechat response is probably mal-formed because cannot be json-decoded.' ) ; } if ( property_exists ( $ response , 'errcode' ) ) { throw new InvalidApiResponseException ( sprintf ( 'Wecaht returned status code "%s" with message "%s".' , property_exists ( $ response , 'errcode' ) ? $ response -> errcode : '' , property_exists ( $ response , 'errmsg' ) ? $ response -> errmsg : '' ) ) ; } return $ response -> access_token ; } 
public function shorten ( LinkInterface $ link ) { $ client = $ this -> createClient ( ) ; $ response = $ client -> post ( '/admin/create' , array_merge ( array ( 'json' => array ( 'url' => $ link -> getLongUrl ( ) , ) , ) , $ this -> options ) ) ; $ response = $ this -> validate ( $ response -> getBody ( ) -> getContents ( ) , true ) ; $ link -> setShortUrl ( $ response -> ShortUrl ) ; } 
public function expand ( LinkInterface $ link ) { $ client = $ this -> createClient ( ) ; $ response = $ client -> post ( '/admin/query' , array_merge ( array ( 'json' => array ( 'shortUrl' => $ link -> getShortUrl ( ) , ) , ) , $ this -> options ) ) ; $ response = $ this -> validate ( $ response -> getBody ( ) -> getContents ( ) , true ) ; $ link -> setLongUrl ( $ response -> LongUrl ) ; } 
private function validate ( $ apiRawResponse , $ checkStatus = false ) { $ response = json_decode ( $ apiRawResponse ) ; if ( null === $ response ) { throw new InvalidApiResponseException ( 'Baidu response is probably mal-formed because cannot be json-decoded.' ) ; } if ( ! $ checkStatus ) { return $ response ; } if ( ! property_exists ( $ response , 'Code' ) ) { throw new InvalidApiResponseException ( 'Property "Code" does not exist within Baidu response.' ) ; } if ( 0 !== $ response -> Code ) { throw new InvalidApiResponseException ( sprintf ( 'Baidu returned code error message "%s: %s".' , $ response -> Code , $ response -> ErrMsg ) ) ; } return $ response ; } 
public function shorten ( LinkInterface $ link ) { $ client = $ this -> createClient ( ) ; $ response = $ client -> post ( sprintf ( '/cgi-bin/shorturl?access_token=%s' , $ this -> auth -> getAccessToken ( ) ) , array_merge ( array ( 'json' => array ( 'action' => 'long2short' , 'long_url' => $ link -> getLongUrl ( ) , ) , ) , $ this -> options ) ) ; $ response = $ this -> validate ( $ response -> getBody ( ) -> getContents ( ) ) ; $ link -> setShortUrl ( $ response -> short_url ) ; } 
private function validate ( $ apiRawResponse ) { $ response = json_decode ( $ apiRawResponse ) ; if ( null === $ response ) { throw new InvalidApiResponseException ( 'Wechat response is probably mal-formed because cannot be json-decoded.' ) ; } if ( ! property_exists ( $ response , 'errcode' ) ) { throw new InvalidApiResponseException ( 'Property "errcode" does not exist within Wechat response.' ) ; } if ( 0 !== $ response -> errcode ) { throw new InvalidApiResponseException ( sprintf ( 'Wechat returned status code "%s" with message "%s"' , $ response -> errcode , property_exists ( $ response , 'errmsg' ) ? $ response -> errmsg : '' ) ) ; } return $ response ; } 
protected function execute ( InputInterface $ input , OutputInterface $ output ) { $ link = new Link ( ) ; $ link -> setLongUrl ( $ input -> getArgument ( 'long-url' ) ) ; $ options = $ input -> getOption ( 'options' ) ? json_decode ( $ input -> getOption ( 'options' ) , true ) : array ( ) ; $ provider = new BaiduProvider ( $ options ) ; try { $ provider -> shorten ( $ link ) ; $ output -> writeln ( sprintf ( '<info>Success:</info> %s' , $ link -> getShortUrl ( ) ) ) ; } catch ( \ Exception $ e ) { $ output -> writeln ( sprintf ( '<error>Failure:</error> %s' , $ e -> getMessage ( ) ) ) ; } } 
public function shorten ( LinkInterface $ link , $ domain = null ) { $ client = $ this -> createClient ( ) ; $ response = $ client -> get ( sprintf ( '/v3/shorten?access_token=%s&longUrl=%s&domain=%s' , $ this -> auth -> getAccessToken ( ) , urlencode ( $ link -> getLongUrl ( ) ) , $ domain ) , $ this -> options ) ; $ response = $ this -> validate ( $ response -> getBody ( ) -> getContents ( ) ) ; $ link -> setShortUrl ( $ response -> data -> url ) ; } 
public function expand ( LinkInterface $ link , $ hash = null ) { $ client = $ this -> createClient ( ) ; $ response = $ client -> get ( sprintf ( '/v3/expand?access_token=%s&shortUrl=%s&hash=%s' , $ this -> auth -> getAccessToken ( ) , urlencode ( $ link -> getShortUrl ( ) ) , $ hash ) , $ this -> options ) ; $ response = $ this -> validate ( $ response -> getBody ( ) -> getContents ( ) ) ; $ link -> setLongUrl ( $ response -> data -> expand [ 0 ] -> long_url ) ; } 
private function validate ( $ apiRawResponse ) { $ response = json_decode ( $ apiRawResponse ) ; if ( null === $ response ) { throw new InvalidApiResponseException ( 'Bit.ly response is probably mal-formed because cannot be json-decoded.' ) ; } if ( ! property_exists ( $ response , 'status_code' ) ) { throw new InvalidApiResponseException ( 'Property "status_code" does not exist within Bit.ly response.' ) ; } if ( 200 !== $ response -> status_code ) { throw new InvalidApiResponseException ( sprintf ( 'Bit.ly returned status code "%s" with message "%s"' , $ response -> status_code , property_exists ( $ response , 'status_txt' ) ? $ response -> status_txt : '' ) ) ; } return $ response ; } 
public function findOneByProviderAndShortUrl ( $ providerName , $ shortUrl ) { $ provider = $ this -> chainProvider -> getProvider ( $ providerName ) ; $ link = $ this -> create ( ) ; $ link -> setProviderName ( $ provider -> getName ( ) ) ; $ link -> setShortUrl ( $ shortUrl ) ; $ provider -> expand ( $ link ) ; return $ link ; } 
public function findOneByProviderAndLongUrl ( $ providerName , $ longUrl ) { $ provider = $ this -> chainProvider -> getProvider ( $ providerName ) ; $ link = $ this -> create ( ) ; $ link -> setProviderName ( $ provider -> getName ( ) ) ; $ link -> setLongUrl ( $ longUrl ) ; $ provider -> shorten ( $ link ) ; return $ link ; } 
public function shorten ( LinkInterface $ link ) { $ client = $ this -> createClient ( ) ; $ response = $ client -> get ( 'shorten.json' , array_merge ( array ( 'query' => array ( 'source' => $ this -> apiKey , 'url_long' => $ link -> getLongUrl ( ) , ) , ) , $ this -> options ) ) ; $ response = $ this -> validate ( $ response -> getBody ( ) -> getContents ( ) ) ; $ link -> setShortUrl ( $ response -> urls [ 0 ] -> url_short ) ; } 
public function expand ( LinkInterface $ link ) { $ client = $ this -> createClient ( ) ; $ response = $ client -> get ( 'expand.json' , array_merge ( array ( 'query' => array ( 'source' => $ this -> apiKey , 'url_short' => $ link -> getShortUrl ( ) , ) , ) , $ this -> options ) ) ; $ response = $ this -> validate ( $ response -> getBody ( ) -> getContents ( ) ) ; $ link -> setLongUrl ( $ response -> urls [ 0 ] -> url_long ) ; } 
private function validate ( $ apiRawResponse ) { $ response = json_decode ( $ apiRawResponse ) ; if ( null === $ response ) { throw new InvalidApiResponseException ( 'Sina response is probably mal-formed because cannot be json-decoded.' ) ; } if ( property_exists ( $ response , 'error' ) ) { throw new InvalidApiResponseException ( sprintf ( 'Sina returned status code "%s" with message "%s".' , property_exists ( $ response , 'error_code' ) ? $ response -> error_code : '' , property_exists ( $ response , 'error' ) ? $ response -> error : '' ) ) ; } if ( property_exists ( $ response , 'urls' ) ) { if ( empty ( $ response -> urls [ 0 ] -> url_long ) ) { throw new InvalidApiResponseException ( 'Property "longUrl" does not exist within Sina response.' ) ; } } return $ response ; } 
protected function execute ( InputInterface $ input , OutputInterface $ output ) { $ link = new Link ( ) ; $ link -> setShortUrl ( $ input -> getArgument ( 'short-url' ) ) ; $ options = $ input -> getOption ( 'options' ) ? json_decode ( $ input -> getOption ( 'options' ) , true ) : array ( ) ; $ provider = new BitlyProvider ( new OAuthClient ( $ input -> getArgument ( 'username' ) , $ input -> getArgument ( 'password' ) ) , $ options ) ; try { $ provider -> expand ( $ link ) ; $ output -> writeln ( sprintf ( '<info>Success:</info> %s' , $ link -> getLongUrl ( ) ) ) ; } catch ( \ Exception $ e ) { $ output -> writeln ( sprintf ( '<error>Failure:</error> %s' , $ e -> getMessage ( ) ) ) ; } } 
public function getProvider ( $ name ) { if ( ! $ this -> hasProvider ( $ name ) ) { throw new \ RuntimeException ( sprintf ( 'Unable to retrieve the provider named: "%s"' , $ name ) ) ; } return $ this -> providers [ $ name ] ; } 
public function getConfigTreeBuilder ( ) { $ builder = new TreeBuilder ( 'sb_json_request' ) ; if ( \ method_exists ( $ builder , 'getRootNode' ) ) { $ rootNode = $ builder -> getRootNode ( ) ; } else { 
public function onKernelRequest ( GetResponseEvent $ event ) { $ request = $ event -> getRequest ( ) ; if ( false === $ this -> isAvailable ( $ request ) ) { return ; } if ( false === $ this -> transform ( $ request ) ) { $ response = Response :: create ( 'Unable to parse request.' , 400 ) ; $ event -> setResponse ( $ response ) ; } } 
private function transform ( Request $ request ) { $ data = json_decode ( $ request -> getContent ( ) , true ) ; if ( json_last_error ( ) !== JSON_ERROR_NONE ) { return false ; } if ( is_array ( $ data ) ) { $ request -> request -> replace ( $ data ) ; } return true ; } 
protected function loadInternal ( array $ configs , ContainerBuilder $ container ) { $ listener = new Definition ( $ configs [ 'listener' ] [ 'request_transformer' ] ) ; $ listener -> addTag ( 'kernel.event_listener' , [ 'event' => 'kernel.request' , 'method' => 'onKernelRequest' , 'priority' => $ configs [ 'listener' ] [ 'priority' ] , ] ) ; $ container -> setDefinition ( 'sb_json_request.request_transformer' , $ listener ) ; } 
public function handle ( Request $ request , Closure $ next ) { 
public function getDetails ( $ ip_address = null ) { $ response_details = $ this -> getRequestDetails ( ( string ) $ ip_address ) ; return $ this -> formatDetailsObject ( $ response_details ) ; } 
public function formatDetailsObject ( $ details = [ ] ) { $ country = $ details [ 'country' ] ?? null ; $ details [ 'country_name' ] = $ this -> countries [ $ country ] ?? null ; if ( array_key_exists ( 'loc' , $ details ) ) { $ coords = explode ( ',' , $ details [ 'loc' ] ) ; $ details [ 'latitude' ] = $ coords [ 0 ] ; $ details [ 'longitude' ] = $ coords [ 1 ] ; } else { $ details [ 'latitude' ] = null ; $ details [ 'longitude' ] = null ; } return new Details ( $ details ) ; } 
public function getRequestDetails ( string $ ip_address ) { if ( ! $ this -> cache -> has ( $ ip_address ) ) { $ url = self :: API_URL ; if ( $ ip_address ) { $ url .= "/$ip_address" ; } try { $ response = $ this -> http_client -> request ( self :: REQUEST_TYPE_GET , $ url , $ this -> buildHeaders ( ) ) ; } catch ( GuzzleException $ e ) { throw new IPinfoException ( $ e -> getMessage ( ) ) ; } catch ( Exception $ e ) { throw new IPinfoException ( $ e -> getMessage ( ) ) ; } if ( $ response -> getStatusCode ( ) == self :: STATUS_CODE_QUOTA_EXCEEDED ) { throw new IPinfoException ( 'IPinfo request quota exceeded.' ) ; } elseif ( $ response -> getStatusCode ( ) >= 400 ) { throw new IPinfoException ( 'Exception: ' . json_encode ( [ 'status' => $ response -> getStatusCode ( ) , 'reason' => $ response -> getReasonPhrase ( ) , ] ) ) ; } $ raw_details = json_decode ( $ response -> getBody ( ) , true ) ; $ this -> cache -> set ( $ ip_address , $ raw_details ) ; } return $ this -> cache -> get ( $ ip_address ) ; } 
public function set ( string $ name , $ value ) { if ( ! $ this -> cache -> has ( $ name ) ) { $ this -> element_queue [ ] = $ name ; } $ this -> cache -> set ( $ name , $ value , $ this -> ttl ) ; $ this -> manageSize ( ) ; } 
private function manageSize ( ) { $ overflow = count ( $ this -> element_queue ) - $ this -> maxsize ; if ( $ overflow > 0 ) { foreach ( array_slice ( $ this -> element_queue , 0 , $ overflow ) as $ name ) { if ( $ this -> cache -> has ( $ name ) ) { $ this -> cache -> delete ( $ name ) ; } } $ this -> element_queue = array_slice ( $ this -> element_queue , $ overflow ) ; } } 
public function _getPublicData ( ) { $ response = $ this -> getPropertiesFromResponse ( ) ; $ result = array ( ) ; if ( isset ( $ response [ 'type' ] ) && $ response [ 'type' ] == 'Error' ) { $ result = array ( 'success' => 0 , 'error' => array ( 'message' => $ response [ 'error' ] , 'code' => $ response [ 'code' ] ) ) ; } elseif ( ! empty ( $ response [ 'secure' ] ) ) { $ result = array ( 'success' => 0 , 'secure' => $ response [ 'secure' ] ) ; } elseif ( $ this -> isSuccessful ( ) ) { $ result [ 'success' ] = 1 ; } else { $ result = array ( 'success' => 0 , 'error' => array ( 'message' => 'Internal error' ) ) ; } return $ result ; } 
public function post ( $ params = array ( ) , $ headers = array ( ) ) { if ( empty ( $ params ) ) { return null ; } $ this -> httpAction -> setApiParams ( $ params ) ; $ this -> httpAction -> setApiHeaders ( array_merge ( array ( $ this -> getApiBaseHeader ( ) ) , $ headers ) ) ; return ( array ) $ this -> preparePropertiesFromResponse ( $ this -> httpAction -> post ( $ this -> getApiUrl ( ) ) ) ; } 
public function offsetSet ( $ offset , $ value ) { $ txKey = isset ( $ this -> attributeMap [ $ offset ] ) ? $ this -> attributeMap [ $ offset ] : null ; if ( is_array ( $ txKey ) ) { $ checkedValue = ( $ value ) ? ( string ) $ value : '' ; $ isHex = $ this -> util -> isHex ( $ checkedValue ) ; $ checkedValue = $ this -> util -> stripZero ( $ checkedValue ) ; if ( ! isset ( $ txKey [ 'allowLess' ] ) || ( isset ( $ txKey [ 'allowLess' ] ) && $ txKey [ 'allowLess' ] === false ) ) { // check length if ( isset ( $ txKey [ 'length' ] ) ) { if ( $ isHex ) { if ( strlen ( $ checkedValue ) > $ txKey [ 'length' ] * 2 ) { throw new InvalidArgumentException ( $ offset . ' exceeds the length limit.' ) ; } } else { if ( strlen ( $ checkedValue ) > $ txKey [ 'length' ] ) { throw new InvalidArgumentException ( $ offset . ' exceeds the length limit.' ) ; } } } } if ( ! isset ( $ txKey [ 'allowZero' ] ) || ( isset ( $ txKey [ 'allowZero' ] ) && $ txKey [ 'allowZero' ] === false ) ) { // check zero if ( preg_match ( '/^0*$/' , $ checkedValue ) === 1 ) { // set value to empty string $ value = '' ; } } $ this -> txData [ $ txKey [ 'key' ] ] = $ value ; } } 
public function offsetExists ( $ offset ) { $ txKey = isset ( $ this -> attributeMap [ $ offset ] ) ? $ this -> attributeMap [ $ offset ] : null ; if ( is_array ( $ txKey ) ) { return isset ( $ this -> txData [ $ txKey [ 'key' ] ] ) ; } return false ; } 
public function offsetGet ( $ offset ) { $ txKey = isset ( $ this -> attributeMap [ $ offset ] ) ? $ this -> attributeMap [ $ offset ] : null ; if ( is_array ( $ txKey ) && isset ( $ this -> txData [ $ txKey [ 'key' ] ] ) ) { return $ this -> txData [ $ txKey [ 'key' ] ] ; } return null ; } 
public function serialize ( ) { $ chainId = $ this -> offsetGet ( 'chainId' ) ; // sort tx data if ( ksort ( $ this -> txData ) !== true ) { throw new RuntimeException ( 'Cannot sort tx data by keys.' ) ; } if ( $ chainId && $ chainId > 0 ) { $ txData = array_fill ( 0 , 9 , '' ) ; } else { $ txData = array_fill ( 0 , 6 , '' ) ; } foreach ( $ this -> txData as $ key => $ data ) { if ( $ key >= 0 ) { $ txData [ $ key ] = $ data ; } } return $ this -> rlp -> encode ( $ txData ) ; } 
public function sign ( string $ privateKey ) { $ txHash = $ this -> hash ( false ) ; $ privateKey = $ this -> secp256k1 -> keyFromPrivate ( $ privateKey , 'hex' ) ; $ signature = $ privateKey -> sign ( $ txHash , [ 'canonical' => true ] ) ; $ r = $ signature -> r ; $ s = $ signature -> s ; $ v = $ signature -> recoveryParam + 35 ; $ chainId = $ this -> offsetGet ( 'chainId' ) ; if ( $ chainId && $ chainId > 0 ) { $ v += ( int ) $ chainId * 2 ; } $ this -> offsetSet ( 'r' , '0x' . $ r -> toString ( 16 ) ) ; $ this -> offsetSet ( 's' , '0x' . $ s -> toString ( 16 ) ) ; $ this -> offsetSet ( 'v' , $ v ) ; $ this -> privateKey = $ privateKey ; return $ this -> serialize ( ) -> toString ( 'hex' ) ; } 
public function hash ( $ includeSignature = false ) { $ chainId = $ this -> offsetGet ( 'chainId' ) ; // sort tx data if ( ksort ( $ this -> txData ) !== true ) { throw new RuntimeException ( 'Cannot sort tx data by keys.' ) ; } if ( $ includeSignature ) { $ txData = $ this -> txData ; } else { $ rawTxData = $ this -> txData ; if ( $ chainId && $ chainId > 0 ) { $ v = ( int ) $ chainId ; $ this -> offsetSet ( 'r' , '' ) ; $ this -> offsetSet ( 's' , '' ) ; $ this -> offsetSet ( 'v' , $ v ) ; $ txData = array_fill ( 0 , 9 , '' ) ; } else { $ txData = array_fill ( 0 , 6 , '' ) ; } foreach ( $ this -> txData as $ key => $ data ) { if ( $ key >= 0 ) { $ txData [ $ key ] = $ data ; } } $ this -> txData = $ rawTxData ; } $ serializedTx = $ this -> rlp -> encode ( $ txData ) -> toString ( 'utf8' ) ; return $ this -> util -> sha3 ( $ serializedTx ) ; } 
public function getFromAddress ( ) { $ from = $ this -> offsetGet ( 'from' ) ; if ( $ from ) { return $ from ; } if ( ! isset ( $ this -> privateKey ) || ! ( $ this -> privateKey instanceof KeyPair ) ) { // recover from hash $ r = $ this -> offsetGet ( 'r' ) ; $ s = $ this -> offsetGet ( 's' ) ; $ v = $ this -> offsetGet ( 'v' ) ; $ chainId = $ this -> offsetGet ( 'chainId' ) ; if ( ! $ r || ! $ s ) { throw new RuntimeException ( 'Invalid signature r and s.' ) ; } $ txHash = $ this -> hash ( false ) ; if ( $ chainId && $ chainId > 0 ) { $ v -= ( $ chainId * 2 ) ; } $ v -= 35 ; $ publicKey = $ this -> secp256k1 -> recoverPubKey ( $ txHash , [ 'r' => $ r , 's' => $ s ] , $ v ) ; $ publicKey = $ publicKey -> encode ( 'hex' ) ; } else { $ publicKey = $ this -> privateKey -> getPublic ( false , 'hex' ) ; } $ from = '0x' . substr ( $ this -> util -> sha3 ( substr ( hex2bin ( $ publicKey ) , 1 ) ) , 24 ) ; $ this -> offsetSet ( 'from' , $ from ) ; return $ from ; } 
public static function errorHtml ( $ e , $ header , $ debug = TRUE ) { $ pattern = [ '/\{\{title\}\}/' , '/\{\{header\}\}/' , '/\{\{exception\}\}/' , ] ; $ title = $ header ; $ exception = $ debug ? $ e : 'something error...' ; $ replacement = [ $ title , $ header , $ exception ] ; return preg_replace ( $ pattern , $ replacement , self :: $ _html_blade ) ; } 
public static function run ( array $ middlewares , Requests $ request ) { 
public static function __callstatic ( $ method , $ params ) { 
public static function group ( array $ filter , Closure $ routes ) { 
protected static function _pathParse ( $ path ) { 
protected static function _isVariableRoute ( $ path ) { $ matched = [ ] ; preg_match_all ( self :: $ _variable_regexp , $ path , $ matched ) ; if ( empty ( $ matched [ 0 ] ) ) { return FALSE ; } return TRUE ; } 
protected static function _variablePathParse ( $ path , $ method ) { 
protected static function _variableRouteCacheControl ( $ value ) { 
protected static function _setMapTree ( $ method , $ path , $ content ) { $ path = self :: _pathParse ( self :: $ _filter [ 'prefix' ] . $ path ) ; $ callback = is_string ( $ content ) ? self :: _namespaceParse ( '\\' . self :: $ _filter [ 'namespace' ] . $ content ) : $ content ; if ( self :: _isVariableRoute ( $ path ) ) { 
protected static function _getRedirectUrl ( $ path , $ param ) { $ base_url = rtrim ( Config :: get ( 'app.base_url' ) , '/' ) ; $ path = self :: _pathParse ( $ path ) ; $ url = $ base_url . $ path . '?' . http_build_query ( $ param ) ; return $ url ; } 
protected static function _checkMiddleware ( Requests $ request , $ middleware_symbols ) { 
protected static function _runDispatch ( Requests $ request , $ callback , $ middleware_symbols , $ params = [ ] ) { 
public static function dispatch ( Requests $ request ) { 
public static function redirect ( $ path , $ param = [ ] ) { $ url = self :: _getRedirectUrl ( $ path , $ param ) ; return Response :: redirect ( $ url ) ; } 
public static function init ( array $ db_confs ) { 
protected function _connect ( ) { extract ( $ this -> _config , EXTR_SKIP ) ; $ dsn = isset ( $ unix_socket ) ? 'mysql:unix_socket=' . $ unix_socket . ';dbname=' . $ dbname : 'mysql:dbname=' . $ dbname . ';host=' . $ host . ( isset ( $ port ) ? ';port=' . $ port : '' ) ; $ options = isset ( $ options ) ? $ options + $ this -> _options : $ this -> _options ; try { $ this -> _pdo = new PDO ( $ dsn , $ user , $ password , $ options ) ; 
public static function dotGet ( $ array , $ key , $ default = NULL ) { if ( is_null ( $ key ) ) { return $ array ; } if ( isset ( $ array [ $ key ] ) ) { return $ array [ $ key ] ; } foreach ( explode ( '.' , $ key ) as $ segment ) { if ( ! is_array ( $ array ) || ! array_key_exists ( $ segment , $ array ) ) { return $ default ; } $ array = $ array [ $ segment ] ; } return $ array ; } 
public static function dotHas ( $ array , $ key ) { if ( empty ( $ array ) || is_null ( $ key ) ) { return FALSE ; } if ( array_key_exists ( $ key , $ array ) ) { return TRUE ; } foreach ( explode ( '.' , $ key ) as $ segment ) { if ( ! is_array ( $ array ) || ! array_key_exists ( $ segment , $ array ) ) { return FALSE ; } $ array = $ array [ $ segment ] ; } return TRUE ; } 
public static function header ( $ headers ) { if ( is_array ( $ headers ) ) { 
public static function getHeader ( $ key ) { if ( ! array_key_exists ( $ key , HttpCache :: $ header ) ) { return NULL ; } return HttpCache :: $ header [ $ key ] ; } 
protected function _connect ( ) { extract ( $ this -> _config , EXTR_SKIP ) ; $ dsn = 'pgsql:dbname=' . $ dbname . ( isset ( $ host ) ? ';host=' . $ host : '' ) . ( isset ( $ port ) ? ';port=' . $ port : '' ) . ( isset ( $ sslmode ) ? ';sslmode=' . $ sslmode : '' ) ; $ options = isset ( $ options ) ? $ options + $ this -> _options : $ this -> _options ; try { $ this -> _pdo = new PDO ( $ dsn , $ user , $ password , $ options ) ; 
public function insertGetLastId ( array $ data ) { 
protected function _connect ( ) { extract ( $ this -> _config , EXTR_SKIP ) ; if ( $ dbname == ':memory:' ) { $ dsn = 'sqlite::memory:' ; } else { $ path = realpath ( $ dbname ) ; if ( $ path === FALSE ) { throw new \ InvalidArgumentException ( "Database $dbname does not exist." ) ; } $ dsn = 'sqlite:' . $ path ; } $ options = isset ( $ options ) ? $ options + $ this -> _options : $ this -> _options ; try { $ this -> _pdo = new PDO ( $ dsn , '' , '' , $ options ) ; } catch ( PDOException $ e ) { throw $ e ; } } 
protected static function _getDiParams ( array $ params ) { $ di_params = [ ] ; foreach ( $ params as $ param ) { $ class = $ param -> getClass ( ) ; if ( $ class ) { 
public static function singleton ( $ instance , $ name = NULL ) { if ( ! is_object ( $ instance ) ) { throw new \ InvalidArgumentException ( "Object need!" ) ; } $ class_name = $ name == NULL ? get_class ( $ instance ) : $ name ; 
public static function getSingleton ( $ class_name ) { return array_key_exists ( $ class_name , self :: $ _singleton ) ? self :: $ _singleton [ $ class_name ] : NULL ; } 
public static function register ( $ abstract , $ concrete = NULL ) { if ( $ concrete == NULL ) { $ instance = self :: getInstance ( $ abstract ) ; self :: singleton ( $ instance ) ; } else { $ instance = self :: getInstance ( $ concrete ) ; self :: singleton ( $ instance , $ abstract ) ; } } 
public static function getInstance ( $ class_name ) { 
public static function getInstanceWithSingleton ( $ class_name ) { 
public static function run ( $ class_name , $ method , $ params = [ ] ) { 
public static function run ( TcpConnection $ con ) { try { 
public static function init ( ) { try { 
public static function register ( ) { 
public function pipe ( $ pipe ) { if ( FALSE === is_callable ( $ pipe ) ) { throw new InvalidArgumentException ( 'pipe should be callable.' ) ; } $ this -> _pipes [ ] = $ pipe ; return $ this ; } 
public function flow ( $ payload ) { foreach ( $ this -> _pipes as $ pipe ) { 
public static function init ( array $ rd_confs ) { 
public static function subscribe ( $ channels , Closure $ callback , $ connection = 'default' , $ method = 'subscribe' ) { $ loop = self :: $ _clients [ $ connection ] -> pubSubLoop ( ) ; call_user_func_array ( [ $ loop , $ method ] , ( array ) $ channels ) ; 
public static function psubscribe ( $ channels , Closure $ callback , $ connection = 'default' ) { return self :: subscribe ( $ channels , $ callback , $ connection , 'psubscribe' ) ; } 
protected function _connect ( ) { extract ( $ this -> _config , EXTR_SKIP ) ; $ dsn = 'mysql:dbname=' . $ dbname . ';host=' . $ host . ';port=' . $ port ; $ options = isset ( $ options ) ? $ options + $ this -> _options : $ this -> _options ; try { $ this -> _pdo = new PDO ( $ dsn , $ user , $ password , $ options ) ; } catch ( PDOException $ e ) { throw $ e ; } } 
protected function _reset ( ) { $ this -> _table = '' ; $ this -> _prepare_sql = '' ; $ this -> _cols_str = ' * ' ; $ this -> _where_str = '' ; $ this -> _orderby_str = '' ; $ this -> _groupby_str = '' ; $ this -> _having_str = '' ; $ this -> _join_str = '' ; $ this -> _limit_str = '' ; $ this -> _insert_str = '' ; $ this -> _update_str = '' ; $ this -> _bind_params = [ ] ; } 
protected function _resetBuildAttr ( ) { $ this -> _table = '' ; $ this -> _prepare_sql = '' ; $ this -> _cols_str = ' * ' ; $ this -> _where_str = '' ; $ this -> _orderby_str = '' ; $ this -> _groupby_str = '' ; $ this -> _having_str = '' ; $ this -> _join_str = '' ; $ this -> _limit_str = '' ; } 
protected function _wrapPrepareSql ( ) { 
protected function _execute ( ) { try { $ this -> _wrapPrepareSql ( ) ; $ this -> _pdoSt = $ this -> _pdo -> prepare ( $ this -> _prepare_sql ) ; $ this -> _bindParams ( ) ; $ this -> _pdoSt -> execute ( ) ; $ this -> _reset ( ) ; 
protected function _bindParams ( ) { if ( is_array ( $ this -> _bind_params ) ) { foreach ( $ this -> _bind_params as $ plh => $ param ) { $ data_type = PDO :: PARAM_STR ; if ( is_numeric ( $ param ) ) { $ data_type = PDO :: PARAM_INT ; } if ( is_null ( $ param ) ) { $ data_type = PDO :: PARAM_NULL ; } if ( is_bool ( $ param ) ) { $ data_type = PDO :: PARAM_BOOL ; } $ this -> _pdoSt -> bindValue ( $ plh , $ param , $ data_type ) ; } } } 
protected function _wrapTable ( $ table ) { $ prefix = array_key_exists ( 'prefix' , $ this -> _config ) ? $ this -> _config [ 'prefix' ] : '' ; return $ prefix . $ table ; } 
protected static function _wrapRow ( $ str ) { 
protected function _condition_constructor ( $ args_num , $ params , & $ construct_str ) { 
protected function _storeBuildAttr ( ) { 
protected function _reStoreBuildAttr ( array $ data ) { foreach ( $ this -> _buildAttrs as $ buildAttr ) { $ this -> $ buildAttr = $ data [ $ buildAttr ] ; } } 
protected function _subBuilder ( Closure $ callback ) { 
public function table ( $ table ) { $ this -> _table = self :: _wrapRow ( $ this -> _wrapTable ( $ table ) ) ; return $ this ; } 
public function select ( ) { $ cols = func_get_args ( ) ; if ( ! func_num_args ( ) || in_array ( '*' , $ cols ) ) { $ this -> _cols_str = ' * ' ; } else { 
public function where ( ) { $ operator = 'AND' ; 
public function orWhere ( ) { $ operator = 'OR' ; 
public function whereIn ( $ field , array $ data , $ condition = 'IN' , $ operator = 'AND' ) { if ( ! in_array ( $ condition , [ 'IN' , 'NOT IN' ] ) || ! in_array ( $ operator , [ 'AND' , 'OR' ] ) ) { throw new \ InvalidArgumentException ( "Error whereIn mode" ) ; } 
public function whereBetween ( $ field , $ start , $ end , $ operator = 'AND' ) { if ( ! in_array ( $ operator , [ 'AND' , 'OR' ] ) ) { throw new \ InvalidArgumentException ( "Logical operator" ) ; } 
public function whereNull ( $ field , $ condition = 'NULL' , $ operator = 'AND' ) { if ( ! in_array ( $ condition , [ 'NULL' , 'NOT NULL' ] ) || ! in_array ( $ operator , [ 'AND' , 'OR' ] ) ) { throw new \ InvalidArgumentException ( "Logical operator" ) ; } 
public function whereBrackets ( Closure $ callback , $ operator = 'AND' ) { if ( ! in_array ( $ operator , [ 'AND' , 'OR' ] ) ) { throw new \ InvalidArgumentException ( "Logical operator" ) ; } 
public function whereExists ( Closure $ callback , $ condition = 'EXISTS' , $ operator = 'AND' ) { if ( ! in_array ( $ condition , [ 'EXISTS' , 'NOT EXISTS' ] ) || ! in_array ( $ operator , [ 'AND' , 'OR' ] ) ) { throw new \ InvalidArgumentException ( "Error whereExists mode" ) ; } 
public function whereInSub ( $ field , Closure $ callback , $ condition = 'IN' , $ operator = 'AND' ) { if ( ! in_array ( $ condition , [ 'IN' , 'NOT IN' ] ) || ! in_array ( $ operator , [ 'AND' , 'OR' ] ) ) { throw new \ InvalidArgumentException ( "Error whereIn mode" ) ; } 
public function groupBy ( $ field ) { 
public function having ( ) { $ operator = 'AND' ; 
public function orHaving ( ) { $ operator = 'OR' ; 
public function orderBy ( $ field , $ mode = 'ASC' ) { $ mode = strtoupper ( $ mode ) ; if ( ! in_array ( $ mode , [ 'ASC' , 'DESC' ] ) ) { throw new \ InvalidArgumentException ( "Error order by mode" ) ; } 
public function join ( $ table , $ one , $ two , $ type = 'INNER' ) { if ( ! in_array ( $ type , [ 'INNER' , 'LEFT' , 'RIGHT' ] ) ) { throw new \ InvalidArgumentException ( "Error join mode" ) ; } 
public function fromSub ( Closure $ callback ) { $ sub_attr = $ this -> _subBuilder ( $ callback ) ; $ this -> _table .= ' ( ' . $ sub_attr [ '_prepare_sql' ] . ' ) AS tb_' . uniqid ( ) . ' ' ; return $ this ; } 
public function paginate ( $ step , $ page = NULL ) { 
public function get ( ) { $ this -> _buildQuery ( ) ; $ this -> _execute ( ) ; return $ this -> _pdoSt -> fetchAll ( PDO :: FETCH_ASSOC ) ; } 
public function row ( ) { $ this -> _buildQuery ( ) ; $ this -> _execute ( ) ; return $ this -> _pdoSt -> fetch ( PDO :: FETCH_ASSOC ) ; } 
public function getList ( $ field ) { $ this -> _cols_str = ' ' . self :: _quote ( $ field ) . ' ' ; $ this -> _buildQuery ( ) ; $ this -> _execute ( ) ; return $ this -> _pdoSt -> fetchAll ( PDO :: FETCH_COLUMN , 0 ) ; } 
public function count ( $ field = '*' ) { if ( trim ( $ field ) != '*' ) { $ field = self :: _quote ( $ field ) ; } $ this -> _cols_str = ' COUNT(' . $ field . ') AS count_num ' ; return $ this -> row ( ) [ 'count_num' ] ; } 
public function insert ( array $ data ) { 
public function update ( array $ data ) { 
public function delete ( ) { 
public function query ( $ sql ) { try { return $ this -> _pdo -> query ( $ sql ) ; } catch ( PDOException $ e ) { 
public function prepare ( $ sql , array $ driver_options = [ ] ) { try { return $ this -> _pdo -> prepare ( $ sql , $ driver_options ) ; } catch ( PDOException $ e ) { 
public function beginTrans ( ) { try { return $ this -> _pdo -> beginTransaction ( ) ; } catch ( PDOException $ e ) { 
public function handle ( \ Exception $ e ) { $ httpCode = 500 ; 
public function generateId ( $ size = 0 , $ mode = self :: MODE_NORMAL ) { $ size = $ size > 0 ? $ size : $ this -> size ; switch ( $ mode ) { case self :: MODE_DYNAMIC : return $ this -> core -> random ( $ this -> generator , $ size ) ; default : return $ this -> normalRandom ( $ size ) ; } } 
public function formatedId ( $ alphabet , $ size , GeneratorInterface $ generator = null ) { $ generator = $ generator ? : $ this -> generator ; $ alphabet = $ alphabet ? : CoreInterface :: SAFE_SYMBOLS ; return $ this -> core -> random ( $ generator , $ size , $ alphabet ) ; } 
private function normalRandom ( $ size ) { $ id = '' ; while ( 1 <= $ size -- ) { $ rand = mt_rand ( ) / ( mt_getrandmax ( ) + 1 ) ; $ id .= $ this -> alphbet [ $ rand * 64 | 0 ] ; } return $ id ; } 
public function loadConfiguration ( ) : void { $ builder = $ this -> getContainerBuilder ( ) ; $ config = $ this -> validateConfig ( $ this -> defaults ) ; 
public function beforeCompile ( ) : void { $ builder = $ this -> getContainerBuilder ( ) ; $ config = $ this -> validateConfig ( $ this -> defaults ) ; 
public static function normalizeDSN ( $ dsn , $ user = null , $ pass = null ) { 
public static function connect ( $ dsn , $ user = null , $ password = null , $ args = [ ] ) { 
public function dsql ( $ properties = [ ] ) { $ c = $ this -> query_class ; $ q = new $ c ( $ properties ) ; $ q -> connection = $ this ; return $ q ; } 
public function execute ( Expression $ expr ) { 
public function beginTransaction ( ) { 
public function commit ( ) { 
public function rollBack ( ) { 
public function iterate ( $ ret ) { foreach ( $ ret as $ key => $ row ) { $ this -> rows ++ ; yield $ key => $ row ; } } 
public function execute ( Expression $ expr ) { if ( $ expr instanceof Query ) { $ this -> queries ++ ; if ( $ expr -> mode === 'select' || $ expr -> mode === null ) { $ this -> selects ++ ; } } else { $ this -> expressions ++ ; } try { $ ret = parent :: execute ( $ expr ) ; } catch ( \ Exception $ e ) { if ( $ this -> callback && is_callable ( $ this -> callback ) ) { call_user_func ( $ this -> callback , $ this -> queries , $ this -> selects , $ this -> rows , $ this -> expressions , true ) ; } else { printf ( "[ERROR] Queries: %3d, Selects: %3d, Rows fetched: %4d, Expressions %3d\n" , $ this -> queries , $ this -> selects , $ this -> rows , $ this -> expressions ) ; } throw $ e ; } return $ this -> iterate ( $ ret ) ; } 
public function lastInsertID ( $ m = null ) { if ( $ m instanceof \ atk4 \ data \ Model ) { 
public function execute ( Expression $ expr ) { $ this -> start_time = microtime ( true ) ; try { $ ret = parent :: execute ( $ expr ) ; $ took = microtime ( true ) - $ this -> start_time ; if ( $ this -> callback && is_callable ( $ this -> callback ) ) { call_user_func ( $ this -> callback , $ expr , $ took , false ) ; } else { printf ( "[%02.6f] %s\n" , $ took , $ expr -> getDebugQuery ( ) ) ; } } catch ( \ Exception $ e ) { $ took = microtime ( true ) - $ this -> start_time ; if ( $ this -> callback && is_callable ( $ this -> callback ) ) { call_user_func ( $ this -> callback , $ expr , $ took , true ) ; } else { printf ( "[ERROR %02.6f] %s\n" , $ took , $ expr -> getDebugQuery ( ) ) ; } throw $ e ; } return $ ret ; } 
public function _render_limit ( ) { if ( isset ( $ this -> args [ 'limit' ] ) ) { $ cnt = ( int ) $ this -> args [ 'limit' ] [ 'cnt' ] ; $ shift = ( int ) $ this -> args [ 'limit' ] [ 'shift' ] ; return ' ' . trim ( ( $ shift ? 'OFFSET ' . $ shift . ' ROWS' : '' ) . ' ' . 
public function expr ( $ properties = [ ] , $ arguments = null ) { 
public function reset ( $ tag = null ) { 
protected function _consume ( $ sql_code , $ escape_mode = 'param' ) { if ( ! is_object ( $ sql_code ) ) { switch ( $ escape_mode ) { case 'param' : return $ this -> _param ( $ sql_code ) ; case 'escape' : return $ this -> _escape ( $ sql_code ) ; case 'soft-escape' : return $ this -> _escapeSoft ( $ sql_code ) ; case 'none' : return $ sql_code ; } throw new Exception ( [ '$escape_mode value is incorrect' , 'escape_mode' => $ escape_mode , ] ) ; } 
protected function isUnescapablePattern ( $ value ) { return is_object ( $ value ) || $ value === '*' || strpos ( $ value , '(' ) !== false || strpos ( $ value , $ this -> escape_char ) !== false ; } 
protected function _escapeSoft ( $ value ) { 
protected function _escape ( $ value ) { 
protected function _param ( $ value ) { 
public function render ( ) { $ nameless_count = 0 ; if ( ! isset ( $ this -> _paramBase ) ) { $ this -> _paramBase = $ this -> paramBase ; } if ( $ this -> template === null ) { throw new Exception ( 'Template is not defined for Expression' ) ; } $ res = preg_replace_callback ( '/\[[a-z0-9_]*\]|{[a-z0-9_]*}/i' , function ( $ matches ) use ( & $ nameless_count ) { $ identifier = substr ( $ matches [ 0 ] , 1 , - 1 ) ; $ escaping = ( $ matches [ 0 ] [ 0 ] == '[' ) ? 'param' : 'escape' ; 
public function getDebugQuery ( $ html = null ) { $ d = $ this -> render ( ) ; $ pp = [ ] ; foreach ( array_reverse ( $ this -> params ) as $ key => $ val ) { if ( is_numeric ( $ val ) ) { $ d = preg_replace ( '/' . $ key . '([^_]|$)/' , $ val . '\1' , $ d ) ; } elseif ( is_string ( $ val ) ) { $ d = preg_replace ( '/' . $ key . '([^_]|$)/' , "'" . addslashes ( $ val ) . "'\\1" , $ d ) ; } elseif ( $ val === null ) { $ d = preg_replace ( '/' . $ key . '([^_]|$)/' , 'NULL\1' , $ d ) ; } else { $ d = preg_replace ( '/' . $ key . '([^_]|$)/' , $ val . '\\1' , $ d ) ; } $ pp [ ] = $ key ; } if ( class_exists ( 'SqlFormatter' ) ) { if ( $ html ) { $ result = \ SqlFormatter :: format ( $ d ) ; } else { $ result = \ SqlFormatter :: format ( $ d , false ) ; } } else { $ result = $ d ; 
public function execute ( $ connection = null ) { if ( $ connection === null ) { $ connection = $ this -> connection ; } 
public function get ( ) { $ stmt = $ this -> execute ( ) ; if ( $ stmt instanceof \ Generator ) { return iterator_to_array ( $ stmt ) ; } return $ stmt -> fetchAll ( ) ; } 
public function getOne ( ) { $ data = $ this -> getRow ( ) ; if ( ! $ data ) { throw new Exception ( [ 'Unable to fetch single cell of data for getOne from this query' , 'result' => $ data , 'query' => $ this -> getDebugQuery ( ) , ] ) ; } $ one = array_shift ( $ data ) ; return $ one ; } 
public function getRow ( ) { $ stmt = $ this -> execute ( ) ; if ( $ stmt instanceof \ Generator ) { return $ stmt -> current ( ) ; } return $ stmt -> fetch ( ) ; } 
public function _render_limit ( ) { if ( isset ( $ this -> args [ 'limit' ] ) ) { return ' limit ' . ( int ) $ this -> args [ 'limit' ] [ 'cnt' ] . ' offset ' . ( int ) $ this -> args [ 'limit' ] [ 'shift' ] ; } } 
public function field ( $ field , $ alias = null ) { 
protected function _render_field ( $ add_alias = true ) { 
public function table ( $ table , $ alias = null ) { 
protected function _render_table ( $ add_alias = true ) { 
public function join ( $ foreign_table , $ master_field = null , $ join_kind = null , $ _foreign_alias = null ) { 
public function _render_join ( ) { if ( ! isset ( $ this -> args [ 'join' ] ) ) { return '' ; } $ joins = [ ] ; foreach ( $ this -> args [ 'join' ] as $ j ) { $ jj = '' ; $ jj .= $ j [ 't' ] . ' join ' ; $ jj .= $ this -> _escape ( $ j [ 'f1' ] ) ; if ( $ j [ 'fa' ] !== null ) { $ jj .= ' as ' . $ this -> _escape ( $ j [ 'fa' ] ) ; } $ jj .= ' on ' ; if ( isset ( $ j [ 'expr' ] ) ) { $ jj .= $ this -> _consume ( $ j [ 'expr' ] ) ; } else { $ jj .= $ this -> _escape ( $ j [ 'fa' ] ? : $ j [ 'f1' ] ) . '.' . $ this -> _escape ( $ j [ 'f2' ] ) . ' = ' . ( $ j [ 'm1' ] === null ? '' : $ this -> _escape ( $ j [ 'm1' ] ) . '.' ) . $ this -> _escape ( $ j [ 'm2' ] ) ; } $ joins [ ] = $ jj ; } return ' ' . implode ( ' ' , $ joins ) ; } 
public function where ( $ field , $ cond = null , $ value = null , $ kind = 'where' , $ num_args = null ) { 
public function having ( $ field , $ cond = null , $ value = null ) { $ num_args = func_num_args ( ) ; return $ this -> where ( $ field , $ cond , $ value , 'having' , $ num_args ) ; } 
protected function __render_where ( $ kind ) { 
protected function __render_condition ( $ row ) { if ( count ( $ row ) === 3 ) { list ( $ field , $ cond , $ value ) = $ row ; } elseif ( count ( $ row ) === 2 ) { list ( $ field , $ cond ) = $ row ; } elseif ( count ( $ row ) === 1 ) { list ( $ field ) = $ row ; } $ field = $ this -> _consume ( $ field , 'soft-escape' ) ; if ( count ( $ row ) == 1 ) { 
public function group ( $ group ) { 
protected function _render_group ( ) { if ( ! isset ( $ this -> args [ 'group' ] ) ) { return '' ; } $ g = array_map ( function ( $ a ) { return $ this -> _consume ( $ a , 'soft-escape' ) ; } , $ this -> args [ 'group' ] ) ; return ' group by ' . implode ( ', ' , $ g ) ; } 
public function set ( $ field , $ value = null ) { if ( $ value === false ) { throw new Exception ( [ 'Value "false" is not supported by SQL' , 'field' => $ field , 'value' => $ value , ] ) ; } if ( is_array ( $ value ) ) { throw new Exception ( [ 'Array values are not supported by SQL' , 'field' => $ field , 'value' => $ value , ] ) ; } if ( is_array ( $ field ) ) { foreach ( $ field as $ key => $ value ) { $ this -> set ( $ key , $ value ) ; } return $ this ; } if ( is_string ( $ field ) || $ field instanceof Expression || $ field instanceof Expressionable ) { $ this -> args [ 'set' ] [ ] = [ $ field , $ value ] ; } else { throw new Exception ( [ 'Field name should be string or Expressionable' , 'field' => $ field , ] ) ; } return $ this ; } 
protected function _render_set ( ) { 
protected function _render_set_fields ( ) { 
protected function _render_set_values ( ) { 
public function option ( $ option , $ mode = 'select' ) { 
protected function _render_option ( ) { if ( ! isset ( $ this -> args [ 'option' ] [ $ this -> mode ] ) ) { return '' ; } return ' ' . implode ( ' ' , $ this -> args [ 'option' ] [ $ this -> mode ] ) ; } 
public function order ( $ order , $ desc = null ) { 
public function _render_order ( ) { if ( ! isset ( $ this -> args [ 'order' ] ) ) { return '' ; } $ x = [ ] ; foreach ( $ this -> args [ 'order' ] as $ tmp ) { list ( $ arg , $ desc ) = $ tmp ; $ x [ ] = $ this -> _consume ( $ arg , 'soft-escape' ) . ( $ desc ? ( ' ' . $ desc ) : '' ) ; } return ' order by ' . implode ( ', ' , array_reverse ( $ x ) ) ; } 
public function mode ( $ mode ) { $ prop = 'template_' . $ mode ; if ( isset ( $ this -> { $ prop } ) ) { $ this -> mode = $ mode ; $ this -> template = $ this -> { $ prop } ; } else { throw new Exception ( [ 'Query does not have this mode' , 'mode' => $ mode , ] ) ; } return $ this ; } 
public function expr ( $ properties = [ ] , $ arguments = null ) { $ c = $ this -> expression_class ; $ e = new $ c ( $ properties , $ arguments ) ; $ e -> connection = $ this -> connection ; return $ e ; } 
public function caseExpr ( $ operand = null ) { $ q = $ this -> dsql ( [ 'template' => '[case]' ] ) ; if ( $ operand !== null ) { $ q -> args [ 'case_operand' ] = $ operand ; } return $ q ; } 
protected function _render_case ( ) { if ( ! isset ( $ this -> args [ 'case_when' ] ) ) { return ; } $ ret = '' ; 
public function limit ( $ cnt , $ shift = null ) { 
public function parse ( $ value ) { $ value = trim ( $ value ) ; if ( $ this -> parser -> string_helper -> startsWith ( '#' , $ value ) ) { return null ; } return $ this -> parseValue ( $ value ) ; } 
private function parseValue ( $ value ) { foreach ( self :: $ value_types as $ type ) { $ parsed_value = $ value ; if ( $ type !== 'string' ) { $ parsed_value = $ this -> parser -> string_helper -> stripComments ( $ value ) ; } list ( $ is_function , $ parse_function ) = $ this -> fetchFunctionNames ( $ type ) ; if ( $ this -> parser -> string_helper -> $ is_function ( $ parsed_value ) ) { return $ this -> $ parse_function ( $ parsed_value ) ; } } return ( isset ( $ parsed_value ) ) ? $ this -> parseUnquotedString ( $ parsed_value ) : $ value ; } 
private function parseString ( $ value ) { $ single = false ; $ regex = self :: REGEX_QUOTE_DOUBLE_STRING ; $ symbol = '"' ; if ( $ this -> parser -> string_helper -> startsWith ( '\'' , $ value ) ) { $ single = true ; $ regex = self :: REGEX_QUOTE_SINGLE_STRING ; $ symbol = "'" ; } $ matches = $ this -> fetchStringMatches ( $ value , $ regex , $ symbol ) ; $ value = trim ( $ matches [ 0 ] , $ symbol ) ; $ value = strtr ( $ value , self :: $ character_map ) ; return ( $ single ) ? $ value : $ this -> variable_parser -> parse ( $ value , true ) ; } 
private function fetchStringMatches ( $ value , $ regex , $ symbol ) { if ( ! preg_match ( '/' . $ regex . '/' , $ value , $ matches ) ) { throw new ParseException ( sprintf ( 'Missing end %s quote' , $ symbol ) , $ value , $ this -> parser -> line_num ) ; } return $ matches ; } 
private function createMessage ( $ message , $ line , $ line_num ) { if ( ! is_null ( $ line ) ) { $ message .= sprintf ( " near %s" , $ line ) ; } if ( ! is_null ( $ line_num ) ) { $ message .= sprintf ( " at line %d" , $ line_num ) ; } return $ message ; } 
public function startsWith ( $ string , $ line ) { return $ string === "" || strrpos ( $ line , $ string , - strlen ( $ line ) ) !== false ; } 
public function parse ( $ value , $ quoted_string = false ) { $ matches = $ this -> fetchVariableMatches ( $ value ) ; if ( is_array ( $ matches ) ) { if ( $ this -> parser -> string_helper -> isVariableClone ( $ value , $ matches , $ quoted_string ) ) { return $ this -> fetchVariable ( $ value , $ matches [ 1 ] [ 0 ] , $ matches , $ quoted_string ) ; } $ value = $ this -> doReplacements ( $ value , $ matches , $ quoted_string ) ; } return $ value ; } 
private function fetchVariableMatches ( $ value ) { preg_match_all ( '/' . self :: REGEX_ENV_VARIABLE . '/' , $ value , $ matches ) ; if ( ! is_array ( $ matches ) || ! isset ( $ matches [ 0 ] ) || empty ( $ matches [ 0 ] ) ) { return false ; } return $ matches ; } 
private function fetchVariable ( $ value , $ variable_name , $ matches , $ quoted_string ) { if ( $ this -> hasParameterExpansion ( $ variable_name ) ) { $ replacement = $ this -> fetchParameterExpansion ( $ variable_name ) ; } elseif ( $ this -> hasVariable ( $ variable_name ) ) { $ replacement = $ this -> getVariable ( $ variable_name ) ; } else { throw new ParseException ( sprintf ( 'Variable has not been defined: %s' , $ variable_name ) , $ value , $ this -> parser -> line_num ) ; } if ( $ this -> parser -> string_helper -> isBoolInString ( $ replacement , $ quoted_string , count ( $ matches [ 0 ] ) ) ) { $ replacement = ( $ replacement ) ? 'true' : 'false' ; } return $ replacement ; } 
private function hasParameterExpansion ( $ variable ) { if ( ( strpos ( $ variable , self :: SYMBOL_DEFAULT_VALUE ) !== false ) || ( strpos ( $ variable , self :: SYMBOL_ASSIGN_DEFAULT_VALUE ) !== false ) ) { return true ; } return false ; } 
private function fetchParameterExpansion ( $ variable_name ) { $ parameter_type = $ this -> fetchParameterExpansionType ( $ variable_name ) ; list ( $ parameter_symbol , $ empty_flag ) = $ this -> fetchParameterExpansionSymbol ( $ variable_name , $ parameter_type ) ; list ( $ variable , $ default ) = $ this -> splitVariableDefault ( $ variable_name , $ parameter_symbol ) ; $ value = $ this -> getVariable ( $ variable ) ; return $ this -> parseVariableParameter ( $ variable , $ default , $ this -> hasVariable ( $ variable ) , $ empty_flag && empty ( $ value ) , $ parameter_type ) ; } 
private function fetchParameterExpansionSymbol ( $ variable_name , $ type ) { $ class = new \ ReflectionClass ( $ this ) ; $ symbol = $ class -> getConstant ( 'SYMBOL_' . strtoupper ( $ type ) ) ; $ pos = strpos ( $ variable_name , $ symbol ) ; $ check_empty = substr ( $ variable_name , ( $ pos - 1 ) , 1 ) === ":" ; if ( $ check_empty ) { $ symbol = sprintf ( ":%s" , $ symbol ) ; } return array ( $ symbol , $ check_empty ) ; } 
private function splitVariableDefault ( $ variable_name , $ parameter_symbol ) { $ variable_default = explode ( $ parameter_symbol , $ variable_name , 2 ) ; if ( count ( $ variable_default ) !== 2 || empty ( $ variable_default [ 1 ] ) ) { throw new ParseException ( 'You must have valid parameter expansion syntax, eg. ${parameter:=word}' , $ variable_name , $ this -> parser -> line_num ) ; } return array ( trim ( $ variable_default [ 0 ] ) , trim ( $ variable_default [ 1 ] ) ) ; } 
private function parseVariableParameter ( $ variable , $ default , $ exists , $ empty , $ type ) { if ( $ exists && ! $ empty ) { return $ this -> getVariable ( $ variable ) ; } return $ this -> assignVariableParameterDefault ( $ variable , $ default , $ empty , $ type ) ; } 
private function assignVariableParameterDefault ( $ variable , $ default , $ empty , $ type ) { $ default = $ this -> parser -> value_parser -> parse ( $ default ) ; if ( $ type === "assign_default_value" && $ empty ) { $ this -> parser -> lines [ $ variable ] = $ default ; } return $ default ; } 
private function hasVariable ( $ variable ) { if ( array_key_exists ( $ variable , $ this -> parser -> lines ) ) { return true ; } if ( array_key_exists ( $ variable , $ this -> context ) ) { return true ; } return false ; } 
private function getVariable ( $ variable ) { if ( array_key_exists ( $ variable , $ this -> parser -> lines ) ) { return $ this -> parser -> lines [ $ variable ] ; } if ( array_key_exists ( $ variable , $ this -> context ) ) { return $ this -> context [ $ variable ] ; } return null ; } 
public function parse ( $ key ) { $ key = trim ( $ key ) ; if ( $ this -> parser -> string_helper -> startsWith ( '#' , $ key ) ) { return false ; } if ( ! ctype_alnum ( str_replace ( '_' , '' , $ key ) ) || $ this -> parser -> string_helper -> startsWithNumber ( $ key ) ) { throw new ParseException ( sprintf ( 'Key can only contain alphanumeric and underscores and can not start with a number: %s' , $ key ) , $ key , $ this -> parser -> line_num ) ; } return $ key ; } 
protected function doParse ( $ content ) { $ raw_lines = array_filter ( $ this -> makeLines ( $ content ) , 'strlen' ) ; if ( empty ( $ raw_lines ) ) { return ; } return $ this -> parseContent ( $ raw_lines ) ; } 
private function parseContent ( array $ raw_lines ) { $ this -> lines = array ( ) ; $ this -> line_num = 0 ; foreach ( $ raw_lines as $ raw_line ) { $ this -> line_num ++ ; if ( $ this -> string_helper -> startsWith ( '#' , $ raw_line ) || ! $ raw_line ) { continue ; } $ this -> parseLine ( $ raw_line ) ; } return $ this -> lines ; } 
private function parseLine ( $ raw_line ) { $ raw_line = $ this -> parseExport ( $ raw_line ) ; list ( $ key , $ value ) = $ this -> parseKeyValue ( $ raw_line ) ; $ key = $ this -> key_parser -> parse ( $ key ) ; if ( ! is_string ( $ key ) ) { return ; } $ this -> lines [ $ key ] = $ this -> value_parser -> parse ( $ value ) ; } 
private function parseExport ( $ raw_line ) { $ line = trim ( $ raw_line ) ; if ( $ this -> string_helper -> startsWith ( "export" , $ line ) ) { $ export_line = explode ( "export" , $ raw_line , 2 ) ; if ( count ( $ export_line ) !== 2 || empty ( $ export_line [ 1 ] ) ) { throw new ParseException ( 'You must have a export key = value' , $ raw_line , $ this -> line_num ) ; } $ line = trim ( $ export_line [ 1 ] ) ; } return $ line ; } 
private function parseKeyValue ( $ raw_line ) { $ key_value = explode ( "=" , $ raw_line , 2 ) ; if ( count ( $ key_value ) !== 2 ) { throw new ParseException ( 'You must have a key = value' , $ raw_line , $ this -> line_num ) ; } return $ key_value ; } 
public function getContent ( $ keyName = null ) { if ( ! is_null ( $ keyName ) ) { return ( array_key_exists ( $ keyName , $ this -> lines ) ) ? $ this -> lines [ $ keyName ] : null ; } return $ this -> lines ; } 
public function getWorkerUrl ( $ ressources = '' , $ params = [ ] ) { if ( is_array ( $ params ) ) { return $ this -> getWorkerUrlV2 ( $ ressources , $ params ) ; } $ url = ( getenv ( 'ZENATON_WORKER_URL' ) ? : self :: ZENATON_WORKER_URL ) . ':' . ( getenv ( 'ZENATON_WORKER_PORT' ) ? : self :: DEFAULT_WORKER_PORT ) . '/api/' . self :: WORKER_API_VERSION . '/' . $ ressources . '?' ; return $ this -> addAppEnv ( $ url , $ params ) ; } 
public function getWebsiteUrl ( $ ressources = '' , $ params = [ ] ) { if ( is_array ( $ params ) ) { return $ this -> getWebsiteUrlV2 ( $ ressources , $ params ) ; } $ url = ( getenv ( 'ZENATON_API_URL' ) ? : self :: ZENATON_API_URL ) . '/' . $ ressources . '?' . self :: API_TOKEN . '=' . $ this -> apiToken . '&' ; return $ this -> addAppEnv ( $ url , $ params ) ; } 
public function startTask ( TaskInterface $ task ) { $ response = $ this -> http -> post ( $ this -> getTaskWorkerUrl ( ) , [ self :: ATTR_PROG => self :: PROG , self :: ATTR_NAME => get_class ( $ task ) , self :: ATTR_DATA => $ this -> serializer -> encode ( $ this -> properties -> getPropertiesFromObject ( $ task ) ) , self :: ATTR_MAX_PROCESSING_TIME => method_exists ( $ task , 'getMaxProcessingTime' ) ? $ task -> getMaxProcessingTime ( ) : null , ] ) ; if ( $ response -> hasErrors ( ) ) { if ( strpos ( $ response -> body -> error , 'Your worker does not listen' ) !== false ) { throw new AgentNotListeningException ( $ this -> appId , $ this -> appEnv ) ; } if ( strpos ( $ response -> body -> error , 'Unknown version' ) !== false ) { throw new AgentUpdateRequiredException ( '>=0.6.0' ) ; } throw new AgentException ( $ response -> body -> error ) ; } } 
public function startWorkflow ( WorkflowInterface $ flow ) { $ canonical = null ; 
public function findWorkflow ( $ workflowName , $ customId ) { $ params = [ static :: ATTR_ID => $ customId , static :: ATTR_NAME => $ workflowName , static :: ATTR_PROG => static :: PROG , ] ; $ response = $ this -> http -> get ( $ this -> getInstanceWebsiteUrl ( $ params ) ) ; if ( $ response -> code === 404 ) { return null ; } if ( $ response -> hasErrors ( ) ) { throw ApiException :: unexpectedStatusCode ( $ response -> code ) ; } return $ this -> properties -> getObjectFromNameAndProperties ( $ response -> body -> data -> name , $ this -> serializer -> decode ( $ response -> body -> data -> properties ) ) ; } 
public function sendEvent ( $ workflowName , $ customId , EventInterface $ event ) { $ url = $ this -> getSendEventURL ( ) ; $ body = [ self :: ATTR_PROG => self :: PROG , self :: ATTR_NAME => $ workflowName , self :: ATTR_ID => $ customId , self :: EVENT_NAME => get_class ( $ event ) , self :: EVENT_INPUT => $ this -> serializer -> encode ( $ this -> properties -> getPropertiesFromObject ( $ event ) ) , ] ; $ this -> http -> post ( $ url , $ body ) ; } 
protected function addAppEnv ( $ url , $ params = '' ) { static $ triggeredDeprecation = false ; if ( ! $ triggeredDeprecation ) { trigger_error ( 'You are running a Zenaton agent version <= 0.4.5 which is using deprecated code. Please consider upgrading your agent.' , E_USER_DEPRECATED ) ; } $ triggeredDeprecation = true ; 
public static function timezone ( $ timezone ) { if ( ! in_array ( $ timezone , DateTimeZone :: listIdentifiers ( ) ) ) { throw new ExternalZenatonException ( 'Unknown timezone' ) ; } self :: $ _timezone = $ timezone ; } 
public function _getTimestampOrDuration ( ) { if ( null === $ this -> _buffer ) { return [ null , null ] ; } list ( $ now , $ then ) = $ this -> _initNowThen ( ) ; $ this -> _mode = null ; 
protected function sameMonthDayLater ( $ now , $ day ) { return $ this -> sameMonthDay ( $ now , $ day ) && $ this -> later ( $ now ) ; } 
protected function sameWeekDayLater ( $ now , $ day ) { return $ this -> sameWeekDay ( $ now , $ day ) && $ this -> later ( $ now ) ; } 
protected function later ( $ now ) { 
private function getClassProperties ( $ argument , $ filter = null ) { if ( null === $ filter ) { $ filter = \ ReflectionProperty :: IS_STATIC | \ ReflectionProperty :: IS_PUBLIC | \ ReflectionProperty :: IS_PROTECTED | \ ReflectionProperty :: IS_PRIVATE ; } $ reflectionClass = new \ ReflectionClass ( $ argument ) ; if ( $ parentClass = $ reflectionClass -> getParentClass ( ) ) { return array_merge ( $ this -> getClassProperties ( $ parentClass -> getName ( ) , $ filter ) , $ reflectionClass -> getProperties ( $ filter ) ) ; } return $ reflectionClass -> getProperties ( $ filter ) ; } 
public function send ( EventInterface $ event ) { $ this -> client -> sendEvent ( $ this -> class , $ this -> id , $ event ) ; return $ this ; } 
public function load ( array $ configs , ContainerBuilder $ container ) { $ configuration = new Configuration ( ) ; $ config = $ this -> processConfiguration ( $ configuration , $ configs ) ; $ config = $ this -> fixConfiguration ( $ config ) ; $ bundles = $ container -> getParameter ( 'kernel.bundles' ) ; $ loader = new Loader \ XmlFileLoader ( $ container , new FileLocator ( __DIR__ . '/../Resources/config' ) ) ; if ( isset ( $ bundles [ 'SonataBlockBundle' ] , $ bundles [ 'KnpMenuBundle' ] ) ) { $ loader -> load ( 'blocks.xml' ) ; } $ loader -> load ( 'event.xml' ) ; $ loader -> load ( 'services.xml' ) ; $ loader -> load ( 'commands.xml' ) ; $ this -> configureSeoPage ( $ config [ 'page' ] , $ container ) ; $ this -> configureSitemap ( $ config [ 'sitemap' ] , $ container ) ; $ container -> getDefinition ( 'sonata.seo.twig.extension' ) -> replaceArgument ( 1 , $ config [ 'encoding' ] ) ; } 
protected function configureSitemap ( array $ config , ContainerBuilder $ container ) { $ source = $ container -> getDefinition ( 'sonata.seo.sitemap.manager' ) ; if ( method_exists ( $ source , 'setShared' ) ) { 
protected function fixConfiguration ( array $ config ) { foreach ( $ config [ 'sitemap' ] [ 'doctrine_orm' ] as $ pos => $ sitemap ) { $ sitemap [ 'group' ] = $ sitemap [ 'group' ] ?? false ; $ sitemap [ 'types' ] = $ sitemap [ 'types' ] ?? [ ] ; $ sitemap [ 'connection' ] = $ sitemap [ 'connection' ] ?? 'doctrine.dbal.default_connection' ; $ sitemap [ 'route' ] = $ sitemap [ 'route' ] ?? false ; $ sitemap [ 'parameters' ] = $ sitemap [ 'parameters' ] ?? false ; $ sitemap [ 'query' ] = $ sitemap [ 'query' ] ?? false ; if ( false === $ sitemap [ 'route' ] ) { throw new \ RuntimeException ( 'Route cannot be empty, please review the sonata_seo.sitemap configuration' ) ; } if ( false === $ sitemap [ 'query' ] ) { throw new \ RuntimeException ( 'Query cannot be empty, please review the sonata_seo.sitemap configuration' ) ; } if ( false === $ sitemap [ 'parameters' ] ) { throw new \ RuntimeException ( 'Route\'s parameters cannot be empty, please review the sonata_seo.sitemap configuration' ) ; } $ config [ 'sitemap' ] [ 'doctrine_orm' ] [ $ pos ] = $ sitemap ; } foreach ( $ config [ 'sitemap' ] [ 'services' ] as $ pos => $ sitemap ) { if ( ! \ is_array ( $ sitemap ) ) { $ sitemap = [ 'group' => false , 'types' => [ ] , 'id' => $ sitemap , ] ; } else { $ sitemap [ 'group' ] = $ sitemap [ 'group' ] ?? false ; $ sitemap [ 'types' ] = $ sitemap [ 'types' ] ?? [ ] ; if ( ! isset ( $ sitemap [ 'id' ] ) ) { throw new \ RuntimeException ( 'Service id must to be defined, please review the sonata_seo.sitemap configuration' ) ; } } $ config [ 'sitemap' ] [ 'services' ] [ $ pos ] = $ sitemap ; } return $ config ; } 
public function configureSettings ( OptionsResolver $ resolver ) { $ resolver -> setDefaults ( [ 'template' => '@SonataSeo/Block/block_facebook_send_button.html.twig' , 'url' => null , 'width' => null , 'height' => null , 'colorscheme' => $ this -> colorschemeList [ 'light' ] , ] ) ; } 
public function buildEditForm ( FormMapper $ formMapper , BlockInterface $ block ) { $ formMapper -> add ( 'settings' , ImmutableArrayType :: class , [ 'keys' => [ [ 'url' , UrlType :: class , [ 'required' => false , 'label' => 'form.label_url' , ] ] , [ 'width' , IntegerType :: class , [ 'required' => false , 'label' => 'form.label_width' , ] ] , [ 'height' , IntegerType :: class , [ 'required' => false , 'label' => 'form.label_height' , ] ] , [ 'colorscheme' , ChoiceType :: class , [ 'required' => true , 'choices' => $ this -> colorschemeList , 'label' => 'form.label_colorscheme' , ] ] , ] , 'translation_domain' => 'SonataSeoBundle' , ] ) ; } 
public function addSource ( $ group , SourceIteratorInterface $ source , array $ types = [ ] ) { if ( ! isset ( $ this -> sources [ $ group ] ) ) { $ this -> sources [ $ group ] = new \ stdClass ( ) ; $ this -> sources [ $ group ] -> sources = new ChainSourceIterator ( ) ; $ this -> sources [ $ group ] -> types = [ ] ; } $ this -> sources [ $ group ] -> sources -> addSource ( $ source ) ; if ( $ types ) { $ this -> sources [ $ group ] -> types += array_diff ( $ types , $ this -> sources [ $ group ] -> types ) ; } } 
public function configureSettings ( OptionsResolver $ resolver ) { $ resolver -> setDefaults ( [ 'template' => '@SonataSeo/Block/block_facebook_like_button.html.twig' , 'url' => null , 'width' => null , 'show_faces' => true , 'share' => true , 'layout' => $ this -> layoutList [ 'standard' ] , 'colorscheme' => $ this -> colorschemeList [ 'light' ] , 'action' => $ this -> actionTypes [ 'like' ] , ] ) ; } 
public function buildEditForm ( FormMapper $ formMapper , BlockInterface $ block ) { $ formMapper -> add ( 'settings' , ImmutableArrayType :: class , [ 'keys' => [ [ 'url' , UrlType :: class , [ 'required' => false , 'label' => 'form.label_url' , ] ] , [ 'width' , IntegerType :: class , [ 'required' => false , 'label' => 'form.label_width' , ] ] , [ 'show_faces' , CheckboxType :: class , [ 'required' => false , 'label' => 'form.label_show_faces' , ] ] , [ 'share' , CheckboxType :: class , [ 'required' => false , 'label' => 'form.label_share' , ] ] , [ 'layout' , ChoiceType :: class , [ 'required' => true , 'choices' => $ this -> layoutList , 'label' => 'form.label_layout' , ] ] , [ 'colorscheme' , ChoiceType :: class , [ 'required' => true , 'choices' => $ this -> colorschemeList , 'label' => 'form.label_colorscheme' , ] ] , [ 'action' , ChoiceType :: class , [ 'required' => true , 'choices' => $ this -> actionTypes , 'label' => 'form.label_action' , ] ] , ] , 'translation_domain' => 'SonataSeoBundle' , ] ) ; } 
public function onBlock ( BlockEvent $ event ) { $ context = $ event -> getSetting ( 'context' , null ) ; if ( null === $ context ) { return ; } foreach ( $ this -> blockServices as $ type => $ blockService ) { if ( $ blockService -> handleContext ( $ context ) ) { $ block = new Block ( ) ; $ block -> setId ( uniqid ( ) ) ; $ block -> setSettings ( $ event -> getSettings ( ) ) ; $ block -> setType ( $ type ) ; $ event -> addBlock ( $ block ) ; return ; } } } 
public function configureSettings ( OptionsResolver $ resolver ) { parent :: configureSettings ( $ resolver ) ; $ resolver -> setDefaults ( [ 'menu_template' => '@SonataSeo/Block/breadcrumb.html.twig' , 'include_homepage_link' => true , 'context' => false , ] ) ; } 
protected function getRootMenu ( BlockContextInterface $ blockContext ) { $ settings = $ blockContext -> getSettings ( ) ; $ menu = $ this -> factory -> createItem ( 'breadcrumb' ) ; $ menu -> setChildrenAttribute ( 'class' , 'breadcrumb' ) ; if ( method_exists ( $ menu , 'setCurrentUri' ) ) { $ menu -> setCurrentUri ( $ settings [ 'current_uri' ] ) ; } if ( method_exists ( $ menu , 'setCurrent' ) ) { $ menu -> setCurrent ( $ settings [ 'current_uri' ] ) ; } if ( $ settings [ 'include_homepage_link' ] ) { $ menu -> addChild ( 'sonata_seo_homepage_breadcrumb' , [ 'uri' => '/' ] ) ; } return $ menu ; } 
public function addTitle ( $ title ) { $ this -> title = $ title . $ this -> separator . $ this -> title ; return $ this ; } 
public function addMeta ( $ type , $ name , $ content , array $ extras = [ ] ) { if ( ! \ is_string ( $ content ) ) { @ trigger_error ( sprintf ( 'Passing meta content of type %s in %s is deprecated since version 2.x and will be unsupported in version 3. Please cast the value to a string first.' , \ gettype ( $ content ) , __METHOD__ ) , E_USER_DEPRECATED ) ; } if ( ! isset ( $ this -> metas [ $ type ] ) ) { $ this -> metas [ $ type ] = [ ] ; } $ this -> metas [ $ type ] [ $ name ] = [ $ content , $ extras ] ; return $ this ; } 
public function setMetas ( array $ metadatas ) { $ this -> metas = [ ] ; foreach ( $ metadatas as $ type => $ metas ) { if ( ! \ is_array ( $ metas ) ) { throw new \ RuntimeException ( '$metas must be an array' ) ; } foreach ( $ metas as $ name => $ meta ) { list ( $ content , $ extras ) = $ this -> normalize ( $ meta ) ; $ this -> addMeta ( $ type , $ name , $ content , $ extras ) ; } } return $ this ; } 
public function configureSettings ( OptionsResolver $ resolver ) { $ resolver -> setDefaults ( [ 'template' => '@SonataSeo/Block/block_facebook_like_box.html.twig' , 'url' => null , 'width' => null , 'height' => null , 'colorscheme' => $ this -> colorschemeList [ 'light' ] , 'show_faces' => true , 'show_header' => true , 'show_posts' => false , 'show_border' => true , ] ) ; } 
public function buildEditForm ( FormMapper $ formMapper , BlockInterface $ block ) { $ formMapper -> add ( 'settings' , ImmutableArrayType :: class , [ 'keys' => [ [ 'url' , UrlType :: class , [ 'required' => false , 'label' => 'form.label_url' , ] ] , [ 'width' , IntegerType :: class , [ 'required' => false , 'label' => 'form.label_width' , ] ] , [ 'height' , IntegerType :: class , [ 'required' => false , 'label' => 'form.label_height' , ] ] , [ 'colorscheme' , ChoiceType :: class , [ 'required' => true , 'choices' => $ this -> colorschemeList , 'label' => 'form.label_colorscheme' , ] ] , [ 'show_faces' , CheckboxType :: class , [ 'required' => false , 'label' => 'form.label_show_faces' , ] ] , [ 'show_header' , CheckboxType :: class , [ 'required' => false , 'label' => 'form.label_show_header' , ] ] , [ 'show_posts' , CheckboxType :: class , [ 'required' => false , 'label' => 'form.label_show_posts' , ] ] , [ 'show_border' , CheckboxType :: class , [ 'required' => false , 'label' => 'form.label_show_border' , ] ] , ] , 'translation_domain' => 'SonataSeoBundle' , ] ) ; } 
public function execute ( InputInterface $ input , OutputInterface $ output ) { $ this -> getContainer ( ) -> get ( 'router' ) -> getContext ( ) -> setHost ( $ input -> getArgument ( 'host' ) ) ; $ this -> getContainer ( ) -> get ( 'router' ) -> getContext ( ) -> setScheme ( $ input -> getOption ( 'scheme' ) ) ; $ this -> getContainer ( ) -> get ( 'router' ) -> getContext ( ) -> setBaseUrl ( $ input -> getOption ( 'baseurl' ) ) ; $ tempFolder = sys_get_temp_dir ( ) . '/sonata_sitemap_' . md5 ( __DIR__ ) ; $ fs = new Filesystem ( ) ; 
public function configureSettings ( OptionsResolver $ resolver ) { $ resolver -> setDefaults ( [ 'template' => '@SonataSeo/Block/block_twitter_mention_button.html.twig' , 'user' => null , 'text' => null , 'recommend' => null , 'large_button' => false , 'opt_out' => false , 'language' => $ this -> languageList [ 'en' ] , ] ) ; } 
public function buildEditForm ( FormMapper $ formMapper , BlockInterface $ block ) { $ formMapper -> add ( 'settings' , ImmutableArrayType :: class , [ 'keys' => [ [ 'user' , TextType :: class , [ 'required' => true , 'label' => 'form.label_user' , ] ] , [ 'text' , TextType :: class , [ 'required' => false , 'label' => 'form.label_text' , ] ] , [ 'recommend' , TextType :: class , [ 'required' => false , 'label' => 'form.label_recommend' , ] ] , [ 'large_button' , CheckboxType :: class , [ 'required' => false , 'label' => 'form.label_large_button' , ] ] , [ 'opt_out' , CheckboxType :: class , [ 'required' => false , 'label' => 'form.label_opt_out' , ] ] , [ 'language' , ChoiceType :: class , [ 'required' => true , 'choices' => $ this -> languageList , 'label' => 'form.label_language' , ] ] , ] , 'translation_domain' => 'SonataSeoBundle' , ] ) ; } 
public function execute ( BlockContextInterface $ blockContext , Response $ response = null ) { $ tweet = $ blockContext -> getSetting ( 'tweet' ) ; if ( ( $ uriMatched = preg_match ( self :: TWEET_URL_PATTERN , $ tweet ) ) || preg_match ( self :: TWEET_ID_PATTERN , $ tweet ) ) { 
public function buildEditForm ( FormMapper $ form , BlockInterface $ block ) { $ form -> add ( 'settings' , ImmutableArrayType :: class , [ 'keys' => [ [ 'tweet' , TextareaType :: class , [ 'required' => true , 'label' => 'form.label_tweet' , 'sonata_help' => 'form.help_tweet' , ] ] , [ 'maxwidth' , IntegerType :: class , [ 'required' => false , 'label' => 'form.label_maxwidth' , 'sonata_help' => 'form.help_maxwidth' , ] ] , [ 'hide_media' , CheckboxType :: class , [ 'required' => false , 'label' => 'form.label_hide_media' , 'sonata_help' => 'form.help_hide_media' , ] ] , [ 'hide_thread' , CheckboxType :: class , [ 'required' => false , 'label' => 'form.label_hide_thread' , 'sonata_help' => 'form.help_hide_thread' , ] ] , [ 'omit_script' , CheckboxType :: class , [ 'required' => false , 'label' => 'form.label_omit_script' , 'sonata_help' => 'form.help_omit_script' , ] ] , [ 'align' , ChoiceType :: class , [ 'required' => false , 'choices' => [ 'left' => 'form.label_align_left' , 'right' => 'form.label_align_right' , 'center' => 'form.label_align_center' , 'none' => 'form.label_align_none' , ] , 'label' => 'form.label_align' , ] ] , [ 'related' , TextType :: class , [ 'required' => false , 'label' => 'form.label_related' , 'sonata_help' => 'form.help_related' , ] ] , [ 'lang' , ChoiceType :: class , [ 'required' => true , 'choices' => $ this -> languageList , 'label' => 'form.label_lang' , ] ] , ] , 'translation_domain' => 'SonataSeoBundle' , ] ) ; } 
protected function buildUri ( $ uriMatched , array $ settings ) { $ apiParams = $ settings ; $ supportedParams = $ this -> getSupportedApiParams ( ) ; if ( $ uriMatched ) { 
public function build ( ContainerBuilder $ container ) { parent :: build ( $ container ) ; $ container -> addCompilerPass ( new BreadcrumbBlockServicesCompilerPass ( ) ) ; $ container -> addCompilerPass ( new ServiceCompilerPass ( ) ) ; } 
public function getConfigTreeBuilder ( ) { $ treeBuilder = new TreeBuilder ( 'sonata_seo' ) ; 
private function getFonts ( ) { if ( empty ( $ this -> fonts ) ) { $ files = FileHelper :: findFiles ( Craft :: getAlias ( self :: FONT_DIR ) , [ 'only' => self :: FONT_EXT ] ) ; $ filenames = [ ] ; $ fonts = [ ] ; foreach ( $ files as $ file ) { $ pathInfo = pathinfo ( $ file ) ; $ safename = in_array ( $ pathInfo [ 'filename' ] , $ filenames ) ? $ pathInfo [ 'basename' ] : $ pathInfo [ 'filename' ] ; $ safename = $ this -> safeName ( $ safename ) ; $ fonts [ $ safename ] = ArrayHelper :: merge ( [ 'path' => $ file , 'safename' => $ safename ] , $ pathInfo ) ; $ filenames [ ] = $ pathInfo [ 'filename' ] ; } $ this -> fonts = $ fonts ; } return $ this -> fonts ; } 
private function getIcons ( ) { if ( ! empty ( $ this -> iconFont ) ) { $ fonts = $ this -> getFonts ( ) ; if ( ! empty ( $ fonts ) && isset ( $ fonts [ $ this -> iconFont ] ) ) { $ font = Font :: load ( $ fonts [ $ this -> iconFont ] [ 'path' ] ) ; $ font -> parse ( ) ; if ( $ font !== null ) { return $ font -> getUnicodeCharMap ( ) ; } } } return null ; } 
public function getFontCss ( ) { $ sharedAsset = new sharedAsset ( ) ; $ scss = "" ; foreach ( $ this -> getFonts ( ) as $ safeName => $ pathInfo ) { $ fontFile = $ pathInfo [ 'path' ] ; $ font = Font :: load ( $ fontFile ) ; $ font -> parse ( ) ; if ( ! empty ( $ font ) ) { $ iconFontName = $ safeName ; if ( ! empty ( $ iconFontName ) ) { $ scss .= " @font-face { font-family: 'dq-iconpicker-" . $ iconFontName . "'; src: url('../fonts/" . $ pathInfo [ 'basename' ] . "'); font-weight: 100; font-style: normal; }\n\n" ; $ scss .= ' [class*="dq-icon-' . $ iconFontName . '"] { /* use !important to prevent issues with browser extensions that change fonts */ font-family: dq-iconpicker-' . $ iconFontName . ' !important; speak: none; font-style: normal; font-weight: normal; font-variant: normal; text-transform: none; line-height: 1; display: inline-block; vertical-align: baseline; /* Better Font Rendering =========== */ -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; }' . "\n\n" ; } } } file_put_contents ( Craft :: getAlias ( $ sharedAsset -> sourcePath . '/css/fonts.css' ) , $ scss ) ; 
public static function hashAndEncrypt ( string $ password , Key $ aesKey ) : string { $ hash = \ password_hash ( Base64 :: encode ( \ hash ( 'sha384' , $ password , true ) ) , PASSWORD_DEFAULT ) ; if ( ! \ is_string ( $ hash ) ) { throw new \ Exception ( "Unknown hashing error." ) ; } return Crypto :: encrypt ( $ hash , $ aesKey ) ; } 
public static function decryptAndVerifyLegacy ( string $ password , string $ ciphertext , string $ aesKey ) : bool { if ( Binary :: safeStrlen ( $ aesKey ) !== 16 ) { throw new \ Exception ( "Encryption keys must be 16 bytes long" ) ; } $ hash = Crypto :: legacyDecrypt ( $ ciphertext , $ aesKey ) ; if ( ! \ is_string ( $ hash ) ) { throw new \ Exception ( "Unknown hashing error." ) ; } return \ password_verify ( Base64 :: encode ( \ hash ( 'sha256' , $ password , true ) ) , $ hash ) ; } 
public static function decryptAndVerify ( string $ password , string $ ciphertext , Key $ aesKey ) : bool { $ hash = Crypto :: decrypt ( $ ciphertext , $ aesKey ) ; if ( ! \ is_string ( $ hash ) ) { throw new \ Exception ( "Unknown hashing error." ) ; } return \ password_verify ( Base64 :: encode ( \ hash ( 'sha384' , $ password , true ) ) , $ hash ) ; } 
public static function rotateKey ( string $ ciphertext , Key $ oldKey , Key $ newKey ) : string { $ plaintext = Crypto :: decrypt ( $ ciphertext , $ oldKey ) ; return Crypto :: encrypt ( $ plaintext , $ newKey ) ; } 
public static function upgradeFromVersion1 ( string $ password , string $ ciphertext , string $ oldKey , Key $ newKey ) : string { if ( ! self :: decryptAndVerifyLegacy ( $ password , $ ciphertext , $ oldKey ) ) { throw new \ Exception ( 'The correct password is necessary for legacy migration.' ) ; } $ plaintext = Crypto :: legacyDecrypt ( $ ciphertext , $ oldKey ) ; return self :: hashAndEncrypt ( $ plaintext , $ newKey ) ; } 
public static function excludeEverythingNotInBreadcrumbPath ( ArrayNode $ node , $ breadcrumbPath ) { if ( $ breadcrumbPath === null ) { return ; } $ path = explode ( '.' , $ breadcrumbPath ) ; self :: excludeEverythingNotInPath ( $ node , $ path ) ; } 
private static function childNode ( ArrayNode $ node , $ childNodeName ) { if ( $ node instanceof PrototypedArrayNode && '*' === $ childNodeName ) { return self :: nodePrototypeProperty ( ) -> getValue ( $ node ) ; } $ children = self :: nodeChildrenProperty ( ) -> getValue ( $ node ) ; if ( ! isset ( $ children [ $ childNodeName ] ) ) { throw new UndefinedChildNode ( $ node , $ childNodeName ) ; } return $ children [ $ childNodeName ] ; } 
private function createRequest ( Uri $ uri ) { $ headers = [ 'Accept-Encoding' => 'gzip' , 'Connection' => 'keep-alive' ] ; if ( $ uri -> getSessionIdentifier ( ) ) { $ session = $ this -> sessionContainer -> getSession ( $ uri -> getSessionIdentifier ( ) ) ; foreach ( $ session -> getCookies ( ) as $ key => $ value ) { $ uri -> addCookie ( $ key , $ value ) ; } } $ request = RequestFactory :: getRequest ( $ uri , 'GET' , 'php://memory' , $ headers ) ; return $ request ; } 
protected function execute ( InputInterface $ input , OutputInterface $ output ) { $ this -> init ( $ input , $ output ) ; $ config = $ this -> initConfiguration ( $ input -> getOption ( 'config_file' ) ) ; $ rules = $ config -> getRules ( ) ; foreach ( $ rules as $ name => $ rule ) { $ info = Init :: getInitInformationByClass ( get_class ( $ rule ) ) ; $ output -> writeln ( ' ' . $ name . ':' ) ; $ output -> writeln ( ' class: ' . get_class ( $ rule ) ) ; $ output -> writeln ( ' description: ' . str_replace ( "\n" , "\n " , $ info [ 'documentation' ] ) ) ; if ( count ( $ info [ 'parameters' ] ) > 0 ) { $ output -> writeln ( ' parameter:' ) ; foreach ( $ info [ 'parameters' ] as $ parameter ) { $ output -> writeln ( ' ' . $ parameter [ 'name' ] . ': ' . $ parameter [ 'description' ] . ' (default: ' . $ parameter [ 'default' ] . ')' ) ; } } $ output -> writeln ( '' ) ; } } 
private function initConfiguration ( $ configFile ) { $ configArray = $ this -> getConfigArray ( $ configFile ) ; $ config = new Configuration ( new Uri ( '' ) , $ this -> eventDispatcher , $ configArray ) ; return $ config ; } 
public function process ( $ results , UriAwareResponse $ response ) { foreach ( $ results as $ result ) { if ( $ result -> getStatus ( ) == CheckResult :: STATUS_FAILURE ) { $ this -> memory [ ] = ( string ) $ response -> getUri ( ) ; } } } 
private function initConfiguration ( $ num_urls , $ run_level , Uri $ uri , Dispatcher $ dispatcher ) { $ configArray = $ this -> getConfigArray ( __DIR__ . '/../../settings/' . self :: CONFIG_FILE ) ; $ config = new Configuration ( $ uri , $ dispatcher , $ configArray ) ; $ crawler = $ config -> getExtension ( '_ResponseRetriever' ) -> getRetriever ( ) ; $ crawler -> setStartPage ( $ uri ) ; $ config -> getExtension ( '_SmokeStop' ) -> getStrategy ( '_CountStop' ) -> init ( $ num_urls ) ; $ config -> getExtension ( '_ProgressBar' ) -> setMax ( $ num_urls ) ; $ config -> getExtension ( '_SmokeRunLevel' ) -> setRunLevel ( $ run_level ) ; $ this -> config = $ config ; } 
private function getRuleKeys ( ) { $ keys = array ( ) ; foreach ( $ this -> config -> getRules ( ) as $ key => $ rule ) { $ keys [ ] = $ key ; } return $ keys ; } 
protected function writeSmokeCredentials ( $ url = null ) { if ( defined ( 'SMOKE_CREDENTIALS' ) ) { $ this -> output -> writeln ( "\n " . SMOKE_CREDENTIALS . "\n" ) ; } else { $ this -> output -> writeln ( "\n Smoke " . SMOKE_VERSION . " by Nils Langner\n" ) ; } if ( $ url ) { $ this -> output -> writeln ( ' <info>Scanning ' . $ url . "</info>\n" ) ; } } 
protected function getConfigArray ( $ configFile , $ mandatory = false ) { $ configArray = array ( ) ; if ( $ configFile ) { if ( strpos ( $ configFile , 'http://' ) === 0 || strpos ( $ configFile , 'https://' ) === 0 ) { $ curlClient = new Client ( ) ; $ fileContent = ( string ) $ curlClient -> get ( $ configFile ) -> getBody ( ) ; } else { if ( file_exists ( $ configFile ) ) { $ fileContent = file_get_contents ( $ configFile ) ; } else { throw new \ RuntimeException ( "Config file was not found ('" . $ configFile . "')." ) ; } } $ configArray = EnvAwareYaml :: parse ( $ fileContent ) ; } else { if ( $ mandatory ) { throw new \ RuntimeException ( 'Config file was not defined.' ) ; } } return $ configArray ; } 
private function checkRelation ( $ relation , $ expected , $ current ) { switch ( $ relation ) { case 'equals' : if ( $ expected !== $ current ) { return false ; } break ; case 'less than' : if ( $ expected <= $ current ) { return false ; } break ; case 'greater than' : if ( $ expected >= $ current ) { return false ; } break ; } return true ; } 
public function isFiltered ( UriInterface $ currentUri , UriInterface $ startUri ) { $ startDomainElements = explode ( '.' , $ startUri -> getHost ( ) ) ; $ currentDomainElements = explode ( '.' , $ currentUri -> getHost ( ) ) ; $ startDomainLength = count ( $ startDomainElements ) ; $ currentDomainLength = count ( $ currentDomainElements ) ; if ( $ currentDomainLength < $ startDomainLength ) { return true ; } return $ currentUri -> getHost ( $ startDomainLength ) !== $ startUri -> getHost ( $ startDomainLength ) ; } 
protected function configureCommand ( $ description , $ help , $ name ) { $ this -> setDefinition ( [ new InputOption ( 'config_file' , 'c' , InputOption :: VALUE_REQUIRED , 'config file' ) , new InputOption ( 'bootstrap' , 'b' , InputOption :: VALUE_OPTIONAL , 'bootstrap file' ) , ] ) -> setDescription ( $ description ) -> setHelp ( $ help ) -> setName ( $ name ) ; } 
protected function doValidation ( ResponseInterface $ response ) { $ document = new Document ( ( string ) $ response -> getBody ( ) , false ) ; $ urls = $ document -> getDependencies ( $ response -> getUri ( ) ) ; $ invalidUrls = array ( ) ; foreach ( $ urls as $ url ) { if ( function_exists ( 'idn_to_ascii' ) ) { $ idnUrl = $ url -> getScheme ( ) . '://' . idn_to_ascii ( $ url -> getHost ( ) ) . $ url -> getPath ( ) ; } else { $ idnUrl = $ url -> getScheme ( ) . '://' . $ url -> getHost ( ) . $ url -> getPath ( ) ; } if ( ! filter_var ( $ idnUrl , FILTER_VALIDATE_URL ) ) { $ invalidUrls [ ] = ( string ) $ url ; } } $ this -> assert ( count ( $ invalidUrls ) === 0 , 'Invalid urls found (' . implode ( ', ' , $ invalidUrls ) . ').' ) ; } 
public function doRun ( InputInterface $ input , OutputInterface $ output ) { $ this -> registerCommands ( ) ; return parent :: doRun ( $ input , $ output ) ; } 
private function registerCommands ( ) { $ this -> add ( new ScanCommand ( ) ) ; $ this -> add ( new ExplainCommand ( ) ) ; $ this -> add ( new WarmUpCommand ( ) ) ; $ this -> add ( new CustomCommand ( ) ) ; } 
public function getSection ( $ section ) { if ( $ this -> hasSection ( $ section ) ) { return $ this -> configArray [ $ section ] ; } else { throw new \ RuntimeException ( 'The section (' . $ section . ') you are trying to access does not exist.' ) ; } } 
public function process ( $ results , ResponseInterface $ response ) { foreach ( $ this -> reporters as $ reporter ) { $ reporter -> processResults ( $ results , $ response ) ; } } 
protected function execute ( InputInterface $ input , OutputInterface $ output ) { $ this -> init ( $ input , $ output , $ input -> getArgument ( 'url' ) ) ; $ this -> initConfiguration ( new Uri ( $ input -> getArgument ( 'url' ) ) , $ this -> eventDispatcher ) ; $ timeStrategy = $ this -> config -> getExtension ( '_SmokeStop' ) -> getStrategy ( '_TimeStop' ) ; $ timeStrategy -> init ( $ input -> getOption ( 'duration' ) ) ; return $ this -> scan ( ) ; } 
private function initConfiguration ( Uri $ uri , Dispatcher $ dispatcher ) { $ configArray = $ this -> getConfigArray ( __DIR__ . '/../../settings/warmup.yml' ) ; $ config = new Configuration ( $ uri , $ dispatcher , $ configArray ) ; $ crawler = $ config -> getExtension ( '_ResponseRetriever' ) -> getRetriever ( ) ; $ crawler -> setStartPage ( $ uri ) ; $ this -> config = $ config ; } 
protected function execute ( InputInterface $ input , OutputInterface $ output ) { $ this -> init ( $ input , $ output ) ; $ this -> initConfiguration ( $ input -> getOption ( 'config_file' ) , $ this -> eventDispatcher ) ; if ( $ input -> getOption ( 'bootstrap' ) ) { include $ input -> getOption ( 'bootstrap' ) ; } return $ this -> scan ( ) ; } 
private function initConfiguration ( $ configFile , Dispatcher $ dispatcher ) { $ configArray = $ this -> getConfigArray ( $ configFile , true ) ; if ( is_string ( $ configArray ) ) { throw new \ RuntimeException ( 'Unable to load config file. Please check ' . $ configFile ) ; } $ this -> config = new Configuration ( new Uri ( 'http://www.example.com' ) , $ dispatcher , $ configArray ) ; } 
public static function getSubscribedEvents ( ) { return [ Events :: POST_COMMENTED => 'onPostCommented' , Events :: POST_VOTED => 'onPostVoted' , Events :: COMMENT_VOTED => 'onCommentVoted' , Events :: USER_MENTIONED_COMMENT => 'onUserMentioned' , Events :: CATEGORY_FOLLOWED => 'onCategoryFollowed' ] ; } 
public function onPostCommented ( PostCommentedEvent $ event ) { if ( $ event -> getPost ( ) -> getUser ( ) === $ event -> getComment ( ) -> getUser ( ) ) { return ; } $ notification = $ this -> notificationHelper -> createCommentPostNotification ( $ event -> getPost ( ) , $ event -> getComment ( ) ) ; $ this -> notificationHelper -> sendNotification ( $ event -> getPost ( ) -> getUser ( ) , $ notification ) ; } 
public function onPostVoted ( VotePostEvent $ event ) { if ( $ event -> getPost ( ) -> getUser ( ) === $ event -> getVoter ( ) ) { return ; } $ this -> notificationHelper -> createVotePostNotification ( $ event -> getPost ( ) , $ event -> getVoter ( ) ) ; } 
public function onCommentVoted ( VoteCommentEvent $ event ) { 
public function onUserMentioned ( CommentMentionUserEvent $ event ) { foreach ( $ event -> getMentionedUsers ( ) as $ user ) { if ( $ event -> getComment ( ) -> getUser ( ) === $ user || $ event -> getComment ( ) -> getPost ( ) -> getUser ( ) === $ user ) { continue ; } $ this -> notificationHelper -> createMentionUserInPostNotification ( $ event -> getComment ( ) ) ; } } 
public function onCategoryFollowed ( CategoryFollowedEvent $ event ) { if ( $ event -> getCategory ( ) -> getCreator ( ) === $ event -> getFollower ( ) ) { return ; } $ this -> notificationHelper -> createFollowCategoryNotification ( $ event -> getCategory ( ) , $ event -> getFollower ( ) ) ; } 
public function inboxAction ( Request $ request ) { $ threads = $ this -> provider -> getInboxThreadsPager ( $ request -> query -> get ( 'page' , 1 ) ) ; return $ this -> render ( $ this -> configuration -> getTemplate ( 'Chat:inbox.html.twig' ) , [ 'threads' => $ threads ] ) ; } 
public function sentAction ( Request $ request ) { $ threads = $ this -> provider -> getSentThreadsPager ( $ request -> query -> get ( 'page' , 1 ) ) ; return $ this -> render ( $ this -> configuration -> getTemplate ( 'Chat:sent.html.twig' ) , [ 'threads' => $ threads ] ) ; } 
public function createAction ( Request $ request ) { $ this -> denyAccessUnlessGranted ( 'IS_AUTHENTICATED_REMEMBERED' ) ; $ username = $ request -> query -> get ( 'mail_to' ) ; $ user = $ this -> getUserManager ( ) -> findUserByName ( $ username ) ; if ( is_null ( $ user ) ) { throw $ this -> createNotFoundException ( ) ; } $ form = $ this -> createForm ( NewChatType :: class , $ this -> createBlankThreadMessage ( $ user ) ) ; $ formHandler = $ this -> get ( 'fos_message.new_thread_form.handler' ) ; if ( $ message = $ formHandler -> process ( $ form ) ) { return new RedirectResponse ( $ this -> get ( 'router' ) -> generate ( 'fos_message_thread_view' , [ 'threadId' => $ message -> getThread ( ) -> getId ( ) , ] ) ) ; } return $ this -> render ( $ this -> configuration -> getTemplate ( 'Chat:new_chat.html.twig' ) , array ( 'form' => $ form -> createView ( ) , 'recipient' => $ user , 'data' => $ form -> getData ( ) , ) ) ; } 
public function getConfigTreeBuilder ( ) { $ treeBuilder = new TreeBuilder ( ) ; $ rootNode = $ treeBuilder -> root ( 'phpdish_chat' ) ; $ rootNode -> children ( ) -> arrayNode ( 'resources' ) -> children ( ) -> arrayNode ( 'message' ) -> children ( ) -> scalarNode ( 'interface' ) -> defaultValue ( \ FOS \ MessageBundle \ Model \ Message :: class ) -> cannotBeEmpty ( ) -> end ( ) -> scalarNode ( 'model' ) -> defaultValue ( Message :: class ) -> cannotBeEmpty ( ) -> end ( ) -> end ( ) -> end ( ) -> arrayNode ( 'message_metadata' ) -> children ( ) -> scalarNode ( 'interface' ) -> defaultValue ( \ FOS \ MessageBundle \ Model \ MessageMetadata :: class ) -> cannotBeEmpty ( ) -> end ( ) -> scalarNode ( 'model' ) -> defaultValue ( MessageMetadata :: class ) -> cannotBeEmpty ( ) -> end ( ) -> end ( ) -> end ( ) -> arrayNode ( 'message_thread' ) -> children ( ) -> scalarNode ( 'interface' ) -> defaultValue ( \ FOS \ MessageBundle \ Model \ ThreadInterface :: class ) -> cannotBeEmpty ( ) -> end ( ) -> scalarNode ( 'model' ) -> defaultValue ( Thread :: class ) -> cannotBeEmpty ( ) -> end ( ) -> end ( ) -> end ( ) -> arrayNode ( 'message_thread_metadata' ) -> children ( ) -> scalarNode ( 'interface' ) -> defaultValue ( \ FOS \ MessageBundle \ Model \ ThreadMetadata :: class ) -> cannotBeEmpty ( ) -> end ( ) -> scalarNode ( 'model' ) -> defaultValue ( ThreadMetadata :: class ) -> cannotBeEmpty ( ) -> end ( ) -> end ( ) -> end ( ) -> end ( ) -> end ( ) -> end ( ) ; $ this -> addTemplatesSection ( $ rootNode ) ; return $ treeBuilder ; } 
public function execute ( InputInterface $ input , OutputInterface $ output ) { $ this -> rawCommand = $ this -> getApplication ( ) -> get ( 'sylius:theme:assets:install' ) ; $ this -> setHelp ( $ this -> rawCommand -> getHelp ( ) ) ; $ arguments = array ( 'command' => 'sylius:theme:assets:install' , 'target' => $ input -> getArgument ( 'target' ) , '--symlink' => $ input -> getOption ( 'symlink' ) , '--relative' => $ input -> getOption ( 'relative' ) , ) ; $ greetInput = new ArrayInput ( $ arguments ) ; $ this -> rawCommand -> run ( $ greetInput , $ output ) ; } 
public function translateWalletHistoryType ( $ history ) { switch ( $ history -> getType ( ) ) { case PaymentInterface :: TYPE_BUY_BOOK : $ text = $ this -> translator -> trans ( 'payment.type.buy_book' ) ; break ; case PaymentInterface :: TYPE_FOLLOW_CATEGORY : $ text = $ this -> translator -> trans ( 'payment.type.subscribe_category' ) ; break ; case PaymentInterface :: TYPE_CATEGORY_INCOME : $ text = $ this -> translator -> trans ( 'payment.type.category_income' ) ; break ; case PaymentInterface :: TYPE_BOOK_INCOME : $ text = $ this -> translator -> trans ( 'payment.type.book_income' ) ; break ; case PaymentInterface :: TYPE_WITHDRAW : $ text = $ this -> translator -> trans ( 'payment.type.withdraw' ) ; break ; default : $ text = $ this -> translator -> trans ( 'payment.type.unknown' ) ; } return $ text ; } 
public function translateWalletHistoryStatus ( WalletHistoryInterface $ history ) { switch ( $ history -> getStatus ( ) ) { case PaymentInterface :: STATUS_OK : if ( $ history -> isIncome ( ) ) { $ text = $ this -> translator -> trans ( 'payment.status.have_received' ) ; } elseif ( $ history -> getType ( ) === PaymentInterface :: TYPE_WITHDRAW ) { $ text = $ this -> translator -> trans ( 'payment.status.have_tansfer' ) ; } else { $ text = $ this -> translator -> trans ( 'payment.status.paid' ) ; } break ; case PaymentInterface :: STATUS_WAITING : if ( $ history -> getType ( ) === PaymentInterface :: TYPE_WITHDRAW ) { $ text = $ this -> translator -> trans ( 'payment.status.processing' ) ; } else { $ text = $ this -> translator -> trans ( 'payment.status.unpaid' ) ; } break ; case PaymentInterface :: STATUS_CLOSED : $ text = $ this -> translator -> trans ( 'payment.status.closed' ) ; break ; default : $ text = $ this -> translator -> trans ( 'payment.status.unknown' ) ; } return $ text ; } 
public function load ( ObjectManager $ manager ) { $ title = '基于 PHP 的内网穿透工具 “Spike”'; $ body = <<<EOT Spike [ https: 之前由于要与一个同事远程协作开发一款app需要用到内网穿透服务，在网上找到了frp与ngrok；后来我在想能不能用php也写出来一个这样的服务软件？大家都知道php多进程多线程不够友好，在window上还不支持；写服务确实很吃力；不过幸运的是有[ReactPHP](https: 基于ReactPHP的IO多路复用，使得Spike并没有比Frp性能差太多；下面是我简单做的一个benchmark，基于apache ab检验http隧道的服务性能；客户端与服务端都搭在本地，代理同事电脑上的http服务。不是特别符合应用场景，大家简单看一下。 Spike: ``` Concurrency Level: 10 Time taken for tests: 37.727 seconds Complete requests: 100 Failed requests: 0 Total transferred: 2569900 bytes HTML transferred: 2514600 bytes Requests per second: 2.65 [#/sec] (mean) Time per request: 3772.747 [ms] (mean) Time per request: 377.275 [ms] (mean, across all concurrent requests) Transfer rate: 66.52 [Kbytes/sec] received Connection Times (ms) min mean[+/-sd] median max Connect: 0 0 0.4 0 3 Processing: 533 3602 591.9 3714 4096 Waiting: 516 3587 592.3 3701 4076 Total: 534 3602 591.9 3715 4097 Percentage of the requests served within a certain time (ms) 50% 3715 66% 3791 75% 3822 80% 3844 90% 3970 95% 4015 98% 4053 99% 4097 100% 4097 (longest request) ``` Frp: ``` Concurrency Level: 10 Time taken for tests: 38.230 seconds Complete requests: 100 Failed requests: 0 Total transferred: 2569900 bytes HTML transferred: 2514600 bytes Requests per second: 2.62 [#/sec] (mean) Time per request: 3823.045 [ms] (mean) Time per request: 382.304 [ms] (mean, across all concurrent requests) Transfer rate: 65.65 [Kbytes/sec] received Connection Times (ms) min mean[+/-sd] median max Connect: 0 0 0.2 0 1 Processing: 379 3650 644.4 3809 4140 Waiting: 360 3633 645.5 3789 4124 Total: 380 3650 644.4 3809 4140 Percentage of the requests served within a certain time (ms) 50% 3809 66% 3847 75% 3909 80% 3923 90% 4026 95% 4053 98% 4129 99% 4140 100% 4140 (longest request) ``` 从上面可以看出Spike性能要稍微好点，不过这个地方有点不公平，我在做spike的测试时只开启了服务端的日志，客户端的日志是关闭的；而FRP的两端日志都是开启的；我不知道怎么关frp的日志； 在这里简单提一点由于Spike的日志IO是同步的所以日志的读写会耗掉部分性能，提升日志等级减少日志写入可以提升不少的性能； 最后再次附上项目地址： [https: EOT ; $ this -> createTopic ( $ title , $ body ) ; $ title = 'Composer 的源管理工具 Composer Registry Manager'; $ body = <<<EOT 惯例先附上项目地址： [https: 之前使用的是简称，由于crm容易与常说的crm系统混淆，所以这次改成全称并重新在packagist发布了； 如果以前安装的同学请先使用下面命令卸载 ```bash $ composer global remove slince/crm ``` 使用下面命令安装 ```bash $ composer global require slince/composer-registry-manager ^1.2 ``` 此次在1.2版本中做了个不小的重构，API没有做任何改变，主要改善了下以前的一些写法，重写了部分单元测试；除此之外将源管理配置从库文件的位置移出： Windows下移至 `C:\Users\用户名下\AppData\Roaming\ComposerRegistryManager\crm.json` Linux下移至`~/.config/composer-registry-manager/crm.json` 从而修复了因版本升级导致原先做的配置丢失的问题； 上一张GIF图: ![screenshot](https: 感谢[NRM](http: 再次附上地址； 欢迎star，欢迎fork；[https: EOT ; $ this -> createTopic ( $ title , $ body ) ; } 
protected function createTopic ( $ title , $ body ) { $ manager = $ this -> getTopicManager ( ) ; $ topic = $ manager -> createTopic ( $ this -> getReference ( 'general-user' ) ) ; $ topic -> setUpdatedAt ( Carbon :: now ( ) ) -> setTitle ( $ title ) -> setOriginalBody ( $ body ) -> setThreads ( [ $ this -> getReference ( 'thread-share' ) ] ) -> setEnabled ( true ) ; $ manager -> saveTopic ( $ topic ) ; } 
public function onKernelRequest ( GetResponseEvent $ event ) { $ request = $ event -> getRequest ( ) ; $ locale = null ; if ( ! $ request -> hasPreviousSession ( ) ) { $ locale = $ this -> getClientPreferredLocale ( $ request ) ; } elseif ( ! $ request -> attributes -> get ( '_locale' ) ) { $ locale = $ request -> getSession ( ) -> get ( '_locale' , $ this -> getClientPreferredLocale ( $ request ) ) ; } if ( $ locale !== null ) { $ request -> setLocale ( $ locale ) ; } } 
public function getConfigTreeBuilder ( ) { $ treeBuilder = new TreeBuilder ( ) ; $ rootNode = $ treeBuilder -> root ( 'phpdish_user' ) ; $ rootNode -> children ( ) -> scalarNode ( 'avatar_downloader' ) -> isRequired ( ) -> cannotBeEmpty ( ) -> end ( ) -> arrayNode ( 'resources' ) -> children ( ) -> arrayNode ( 'user' ) -> children ( ) -> scalarNode ( 'interface' ) -> defaultValue ( UserInterface :: class ) -> cannotBeEmpty ( ) -> end ( ) -> scalarNode ( 'model' ) -> defaultValue ( User :: class ) -> cannotBeEmpty ( ) -> end ( ) -> end ( ) -> end ( ) -> arrayNode ( 'profile' ) -> children ( ) -> scalarNode ( 'interface' ) -> defaultValue ( ProfileInterface :: class ) -> cannotBeEmpty ( ) -> end ( ) -> scalarNode ( 'model' ) -> defaultValue ( Profile :: class ) -> cannotBeEmpty ( ) -> end ( ) -> end ( ) -> end ( ) -> arrayNode ( 'point_history' ) -> children ( ) -> scalarNode ( 'interface' ) -> defaultValue ( PointHistoryInterface :: class ) -> cannotBeEmpty ( ) -> end ( ) -> scalarNode ( 'model' ) -> defaultValue ( PointHistory :: class ) -> cannotBeEmpty ( ) -> end ( ) -> end ( ) -> end ( ) -> end ( ) -> end ( ) -> end ( ) ; $ this -> addTemplatesSection ( $ rootNode ) ; return $ treeBuilder ; } 
protected function execute ( InputInterface $ input , OutputInterface $ output ) { $ outputStyle = new SymfonyStyle ( $ input , $ output ) ; $ outputStyle -> writeln ( '<info>Installing PHPDish...</info>' ) ; $ outputStyle -> writeln ( static :: PHPDISH_LOGO ) ; $ this -> ensureDirectoryWritableAndExists ( $ this -> getContainer ( ) -> getParameter ( 'kernel.cache_dir' ) , $ output ) ; $ this -> ensureDirectoryWritableAndExists ( $ this -> getContainer ( ) -> getParameter ( 'app.dir.media' ) , $ output ) ; $ this -> ensureDirectoryWritableAndExists ( $ this -> getContainer ( ) -> getParameter ( 'app.dir.uploads' ) , $ output ) ; $ this -> ensureDirectoryWritableAndExists ( $ this -> getContainer ( ) -> getParameter ( 'app.dir.avatar' ) , $ output ) ; $ this -> getApplication ( ) -> setAutoExit ( false ) ; foreach ( $ this -> commands as $ index => $ command ) { $ outputStyle -> newLine ( ) ; $ outputStyle -> section ( sprintf ( 'Step %d of %d. <info>%s</info>' , $ index + 1 , count ( $ this -> commands ) , $ command [ 'message' ] ) ) ; $ this -> executeCommand ( $ command [ 'command' ] , $ output , isset ( $ command [ 'options' ] ) ? $ command [ 'options' ] : [ ] ) ; } $ output -> writeln ( 'PHPDish has been successfully installed.' ) ; } 
public function get ( $ sourceClass ) { if ( isset ( $ this -> factories [ $ sourceClass ] ) ) { $ factory = $ this -> factory [ $ sourceClass ] ; $ grid = $ factory -> getGrid ( ) ; } else { $ reflection = new \ ReflectionClass ( $ sourceClass ) ; if ( ! $ reflection -> isInstantiable ( ) ) { throw new \ InvalidArgumentException ( sprintf ( 'The "%s" cannot be instantiated' ) ) ; } $ grid = $ this -> factory -> createGrid ( $ sourceClass ) ; } 
public function onUserFollowed ( UserFollowedEvent $ event ) { if ( $ event -> getUser ( ) === $ event -> getFollower ( ) ) { return ; } $ notification = $ this -> notificationHelper -> createFollowUserNotification ( $ event -> getFollower ( ) ) ; $ this -> notificationHelper -> sendNotification ( $ event -> getUser ( ) , $ notification ) ; } 
public function indexAction ( Request $ request ) { $ manager = $ this -> getTopicManager ( ) ; $ criteria = Criteria :: create ( ) ; $ criteria -> orderBy ( [ 'isTop' => 'desc' , 'lastCommentAt' => 'desc' ] ) -> where ( Criteria :: expr ( ) -> eq ( 'enabled' , true ) ) ; $ tab = $ request -> query -> get ( 'tab' ) ; if ( $ tab === 'following' ) { $ this -> denyAccessUnlessGranted ( 'IS_AUTHENTICATED_REMEMBERED' ) ; 
public function createAction ( Request $ request ) { $ this -> denyAccessUnlessGranted ( 'IS_AUTHENTICATED_REMEMBERED' ) ; $ manager = $ this -> getTopicManager ( ) ; $ topic = $ manager -> createTopic ( $ this -> getUser ( ) ) ; $ form = $ this -> createForm ( TopicType :: class , $ topic ) ; $ form -> handleRequest ( $ request ) ; if ( $ form -> isSubmitted ( ) && $ form -> isValid ( ) ) { $ manager -> saveTopic ( $ topic ) ; 
public function viewAction ( $ id , Request $ request ) { $ topic = $ this -> getTopicManager ( ) -> findTopicById ( $ id ) ; if ( ! $ topic || ! $ topic -> isEnabled ( ) ) { throw $ this -> createNotFoundException ( ) ; } $ replies = $ this -> getReplyManager ( ) -> findTopicReplies ( $ topic , $ request -> query -> getInt ( 'page' , 1 ) ) ; $ reply = $ this -> getReplyManager ( ) -> createReply ( $ topic , $ this -> getUser ( ) ) ; $ form = $ this -> createForm ( TopicReplyType :: class , $ reply ) ; 
public function editAction ( $ id , Request $ request ) { $ topic = $ this -> getTopicManager ( ) -> findTopicById ( $ id ) ; if ( ! $ topic ) { throw $ this -> createNotFoundException ( ) ; } $ this -> denyAccessUnlessGranted ( 'edit' , $ topic ) ; $ form = $ this -> createForm ( TopicType :: class , $ topic ) ; $ form -> handleRequest ( $ request ) ; if ( $ form -> isSubmitted ( ) && $ form -> isValid ( ) ) { $ this -> getTopicManager ( ) -> saveTopic ( $ topic ) ; return $ this -> redirectToRoute ( 'topic_view' , [ 'id' => $ topic -> getId ( ) , ] ) ; } return $ this -> render ( $ this -> configuration -> getTemplate ( 'Topic:create.html.twig' ) , [ 'form' => $ form -> createView ( ) , 'topic' => $ topic , 'threads' => $ this -> getThreadManager ( ) -> findEnabledThreads ( 10 ) ] ) ; } 
public function deleteAction ( $ id ) { $ topic = $ this -> getTopicManager ( ) -> findTopicById ( $ id ) ; if ( ! $ topic || ! $ topic -> isEnabled ( ) ) { throw $ this -> createNotFoundException ( ) ; } $ this -> denyAccessUnlessGranted ( 'edit' , $ topic ) ; $ this -> getTopicManager ( ) -> blockTopic ( $ topic ) ; return $ this -> handleView ( $ this -> view ( [ 'result' => true , ] ) ) ; } 
public function replyTopicAction ( $ id , Request $ request ) { $ this -> denyAccessUnlessGranted ( 'IS_AUTHENTICATED_REMEMBERED' ) ; $ topic = $ this -> getTopicManager ( ) -> findTopicById ( $ id ) ; $ reply = $ this -> getReplyManager ( ) -> createReply ( $ topic , $ this -> getUser ( ) ) ; $ form = $ this -> createForm ( TopicReplyType :: class , $ reply ) ; $ form -> handleRequest ( $ request ) ; $ view = $ this -> view ( ) -> setFormat ( 'json' ) ; if ( $ form -> isSubmitted ( ) && $ form -> isValid ( ) ) { $ this -> getReplyManager ( ) -> saveReply ( $ reply ) ; 
public function toggleRecommendAction ( $ id ) { $ topic = $ this -> getTopicManager ( ) -> findTopicById ( $ id ) ; if ( ! $ topic || ! $ topic -> isEnabled ( ) ) { throw $ this -> createNotFoundException ( ) ; } $ this -> denyAccessUnlessGranted ( 'ROLE_ADMIN' , $ topic ) ; $ topic -> setRecommended ( ! $ topic -> isRecommended ( ) ) ; $ manager = $ this -> getDoctrine ( ) -> getManager ( ) ; $ manager -> persist ( $ topic ) ; $ manager -> flush ( ) ; return $ this -> handleView ( $ this -> view ( [ 'is_recommended' => $ topic -> isRecommended ( ) , ] ) ) ; } 
public function toggleTopAction ( $ id ) { $ topic = $ this -> getTopicManager ( ) -> findTopicById ( $ id ) ; if ( ! $ topic || ! $ topic -> isEnabled ( ) ) { throw $ this -> createNotFoundException ( ) ; } $ this -> denyAccessUnlessGranted ( 'ROLE_ADMIN' , $ topic ) ; $ topic -> setTop ( ! $ topic -> isTop ( ) ) ; $ manager = $ this -> getDoctrine ( ) -> getManager ( ) ; $ manager -> persist ( $ topic ) ; $ manager -> flush ( ) ; return $ this -> handleView ( $ this -> view ( [ 'is_top' => $ topic -> isTop ( ) , ] ) ) ; } 
public function toggleVoterAction ( $ id ) { $ this -> denyAccessUnlessGranted ( 'IS_AUTHENTICATED_REMEMBERED' ) ; $ topic = $ this -> getTopicManager ( ) -> findTopicById ( $ id ) ; if ( ! $ topic ) { throw new \ InvalidArgumentException ( $ this -> get ( 'translator' ) -> trans ( 'topic.not_exists' ) ) ; } if ( $ isVoted = $ topic -> isVotedBy ( $ this -> getUser ( ) ) ) { $ this -> getTopicManager ( ) -> removeVoter ( $ topic , $ this -> getUser ( ) ) ; } else { $ this -> getTopicManager ( ) -> addVoter ( $ topic , $ this -> getUser ( ) ) ; } return $ this -> json ( [ 'vote_count' => $ topic -> getVoteCount ( ) , 'is_voted' => ! $ isVoted ] ) ; } 
public function getUserTopicsAction ( $ username , Request $ request ) { $ user = $ this -> getUserManager ( ) -> findUserByName ( $ username ) ; $ topics = $ this -> getTopicManager ( ) -> findUserTopics ( $ user , $ request -> query -> getInt ( 'page' , 1 ) ) ; return $ this -> render ( $ this -> configuration -> getTemplate ( 'Topic:user_topics.html.twig' ) , [ 'user' => $ user , 'topics' => $ topics , ] ) ; } 
public function todayHotTopicsAction ( $ limit = null ) { $ date = Carbon :: today ( ) -> modify ( '-100 days' ) ; $ topics = $ this -> getTopicManager ( ) -> findHotTopics ( $ date , $ limit ? : 10 ) ; return $ this -> render ( $ this -> configuration -> getTemplate ( 'Topic:_today_hot.html.twig' ) , [ 'topics' => $ topics , ] ) ; } 
public function push ( $ title , $ route = null , $ routeParameters = [ ] ) { $ this -> crumbs [ ] = [ 'title' => $ title , 'route' => $ route , 'routeParameters' => $ routeParameters ] ; } 
public function unshift ( $ title , $ route = null , $ routeParameters = [ ] ) { array_unshift ( $ this -> crumbs , [ 'title' => $ title , 'route' => $ route , 'routeParameters' => $ routeParameters ] ) ; } 
public function remove ( $ title ) { $ this -> crumbs = array_filter ( $ this -> crumbs , function ( $ crumb ) use ( $ title ) { return $ crumb [ 'title' ] !== $ title ; } ) ; } 
public function load ( ObjectManager $ manager ) { $ manager = $ this -> getCategoryManager ( ) ; $ category = $ manager -> createCategory ( $ this -> getReference ( 'general-user' ) ) ; $ category -> setName ( '小风的PHP研究所') -> setDescription ( '小风的PHP研究所') -> setSlug ( 'php-labs' ) ; $ manager -> saveCategory ( $ category ) ; $ this -> addReference ( 'general-category' , $ category ) ; } 
public function generate ( $ idString , $ width = 256 ) { $ avatar = new MDAvatars ( $ idString , $ width ) ; $ tmpFile = sys_get_temp_dir ( ) . '/' . md5 ( uniqid ( 'avatar' ) ) ; $ avatar -> Save ( $ tmpFile , $ width ) ; $ content = new Stream ( fopen ( $ tmpFile , 'r+' ) ) ; $ file = new File ( $ this -> namer -> transformWithExtension ( 'png' ) , $ content ) ; $ this -> fileManager -> upload ( $ file ) ; @ unlink ( $ tmpFile ) ; return $ file ; } 
public function withdrawAction ( $ id ) { $ form = $ this -> createForm ( WithdrawType :: class ) ; $ history = $ this -> admin -> getSubject ( ) ; $ request = $ this -> getRequest ( ) ; $ form -> handleRequest ( $ request ) ; if ( $ form -> isSubmitted ( ) && $ form -> isValid ( ) ) { $ translator = $ this -> get ( 'translator' ) ; $ walletManager = $ this -> getWalletManager ( ) ; $ action = $ form -> getData ( ) [ 'action' ] ; $ note = $ form -> getData ( ) [ 'note' ] ; if ( $ action === 'approve' ) { $ walletManager -> approveWithdraw ( $ history , $ note ) ; $ this -> addFlash ( 'sonata_flash_success' , $ translator -> trans ( 'payment.withdraw_approve' ) ) ; } else { $ walletManager -> refuseWithdraw ( $ history , $ note ) ; $ this -> addFlash ( 'sonata_flash_success' , $ translator -> trans ( 'payment.withdraw_declined' ) ) ; } return $ this -> redirect ( $ this -> admin -> generateUrl ( 'list' , [ 'filter' => $ this -> admin -> getFilterParameters ( ) ] ) ) ; } $ formView = $ form -> createView ( ) ; return $ this -> renderWithExtraParams ( 'PHPDishAdminBundle:Payment:handle_withdraw.html.twig' , [ 'action' => 'withdraw' , 'form' => $ formView , 'history' => $ history ] , null ) ; } 
public function loadSource ( $ columns , $ page = 1 , $ limit = GridInterface :: MAX_RESULTS_NUM ) { $ this -> initialize ( ) ; $ qb = $ this -> createQueryBuilder ( ) ; 
public function getFunctions ( ) : array { return [ new \ Twig_SimpleFunction ( 'get_category' , [ $ this -> categoryManager , 'findCategoryById' ] ) , new \ Twig_SimpleFunction ( 'get_category_by_slug' , [ $ this -> categoryManager , 'findCategoryBySlug' ] ) , new \ Twig_SimpleFunction ( 'get_categories' , [ $ this , 'getCategories' ] ) , new \ Twig_SimpleFunction ( 'get_categories_pager' , [ $ this -> categoryManager , 'findCategoriesPager' ] ) , new \ Twig_SimpleFunction ( 'get_post' , [ $ this -> postManager , 'findPostById' ] ) , new \ Twig_SimpleFunction ( 'get_posts' , [ $ this , 'getPosts' ] ) , new \ Twig_SimpleFunction ( 'get_posts_pager' , [ $ this -> postManager , 'findPostsPager' ] ) , new \ Twig_SimpleFunction ( 'get_comment' , [ $ this -> commentManager , 'findCommentById' ] ) , new \ Twig_SimpleFunction ( 'get_comments' , [ $ this , 'getComments' ] ) , new \ Twig_SimpleFunction ( 'get_comments_pager' , [ $ this -> commentManager , 'findCommentsPager' ] ) , ] ; } 
public function getCategories ( $ criteria , array $ orderBy = [ ] , ? int $ limit = null ) { if ( $ criteria instanceof Criteria ) { return $ this -> categoryManager -> findCategories ( $ criteria ) ; } else { return $ this -> categoryManager -> getCategoryRepository ( ) -> findBy ( $ criteria , $ orderBy , $ limit ) ; } } 
public function getPosts ( $ criteria , array $ orderBy = [ ] , ? int $ limit = null ) { if ( $ criteria instanceof Criteria ) { return $ this -> postManager -> findPosts ( $ criteria ) ; } else { return $ this -> postManager -> getPostRepository ( ) -> findBy ( $ criteria , $ orderBy , $ limit ) ; } } 
public function getComments ( $ criteria , array $ orderBy = [ ] , ? int $ limit = null ) { if ( $ criteria instanceof Criteria ) { return $ this -> commentManager -> findComments ( $ criteria ) ; } else { return $ this -> commentManager -> getCommentRepository ( ) -> findBy ( $ criteria , $ orderBy , $ limit ) ; } } 
public function upload ( FileInterface $ file , $ overwrite = true ) { $ body = $ file -> getContent ( ) ; if ( $ body instanceof StreamInterface ) { 
public function download ( FileInterface $ file , $ streaming = true ) { if ( $ streaming ) { $ this -> assertStreamingSupport ( ) ; 
public function has ( $ file ) { $ key = $ file instanceof FileInterface ? $ file -> getKey ( ) : $ file ; return $ this -> filesystem -> has ( $ key ) ; } 
public function removeLocale ( $ locale ) { if ( ( $ key = array_search ( $ this -> enabledLocales , $ locale ) ) !== false ) { unset ( $ this -> enabledLocales [ $ key ] ) ; } } 
public function load ( array $ configs , ContainerBuilder $ container ) { $ configuration = new Configuration ( ) ; $ config = $ this -> processConfiguration ( $ configuration , $ configs ) ; if ( $ config [ 'templates_namespace' ] ) { $ container -> setParameter ( 'phpdish.templates_namespace' , $ config [ 'templates_namespace' ] ) ; } 
protected function addTemplatesSection ( ArrayNodeDefinition $ rootNode ) { $ rootNode -> children ( ) -> scalarNode ( 'templates_namespace' ) -> defaultNull ( ) -> end ( ) -> arrayNode ( 'templates' ) -> scalarPrototype ( ) -> end ( ) -> end ( ) -> end ( ) ; } 
public function createPost ( UserInterface $ user ) { $ post = new $ this -> postEntity ; $ post -> setUser ( $ user ) ; return $ post ; } 
public function savePost ( PostInterface $ post ) { if ( ! $ post -> getId ( ) ) { $ post -> getCategory ( ) -> setPostCount ( $ post -> getCategory ( ) -> getPostCount ( ) + 1 ) ; } 
public function findPosts ( Criteria $ criteria ) { return $ this -> getPostRepository ( ) -> createQueryBuilder ( 'p' ) -> addCriteria ( $ criteria ) -> getQuery ( ) -> getResult ( ) ; } 
public function findPostsPager ( Criteria $ criteria , $ page = 1 , $ limit = null ) { $ query = $ this -> getPostRepository ( ) -> createQueryBuilder ( 'p' ) -> addCriteria ( $ criteria ) -> getQuery ( ) ; return $ this -> createPaginator ( $ query , $ page , $ limit ) ; } 
public function findCategoryPosts ( CategoryInterface $ category , $ page = 1 , $ limit = null ) { $ qb = $ this -> getPostRepository ( ) -> createQueryBuilder ( 'p' ) -> join ( 'p.user' , 'pu' ) -> addSelect ( 'pu' ) -> where ( 'p.category = :category' ) -> setParameter ( 'category' , $ category ) -> andWhere ( 'p.enabled = :enabled' ) -> setParameter ( 'enabled' , true ) -> orderBy ( 'p.createdAt' , 'desc' ) ; return $ this -> createPaginator ( $ qb -> getQuery ( ) , $ page , $ limit ) ; } 
public function blockPost ( PostInterface $ post ) { $ post -> disable ( ) ; $ this -> entityManager -> persist ( $ post ) ; $ this -> entityManager -> flush ( ) ; } 
public function increasePostViews ( PostInterface $ post , $ views = 1 ) { $ post -> addViewCount ( $ views ) ; $ this -> entityManager -> persist ( $ post ) ; $ this -> entityManager -> flush ( ) ; } 
public function getUserPostCount ( UserInterface $ user , $ ignoreEmptyPost = true ) { $ qb = $ this -> getPostRepository ( ) -> createQueryBuilder ( 'p' ) ; $ qb -> select ( $ qb -> expr ( ) -> count ( 'p' ) ) -> where ( 'p.enabled = :enabled' ) -> setParameter ( 'enabled' , true ) -> andWhere ( 'p.user = :user' ) -> setParameter ( 'user' , $ user ) ; if ( $ ignoreEmptyPost ) { $ qb -> andWhere ( 'p.originalBody is not null' ) ; } return $ qb -> getQuery ( ) -> getSingleScalarResult ( ) ; } 
public function addVoter ( PostInterface $ post , UserInterface $ user ) { $ post -> addVoter ( $ user ) -> addVoteCount ( ) ; $ this -> entityManager -> persist ( $ post ) ; $ this -> entityManager -> flush ( ) ; 
public function removeVoter ( PostInterface $ post , UserInterface $ user ) { $ post -> removeVoter ( $ user ) -> addVoteCount ( - 1 ) ; $ this -> entityManager -> persist ( $ post ) ; $ this -> entityManager -> flush ( ) ; } 
public function findTemplate ( $ template , $ throw = true ) { 
public function safeChunk ( string $ html , float $ percent ) : string { return $ this -> htmlChunker -> chunk ( $ html , $ percent ) ; } 
public function loadUserByOAuthUserResponse ( UserResponseInterface $ response ) { 
protected function createNewUser ( UserResponseInterface $ response ) { $ user = $ this -> userManager -> createUser ( ) -> setEnabled ( true ) -> setUsername ( $ this -> generateUsername ( $ response ) ) -> setPassword ( '' ) -> setEmail ( $ response -> getEmail ( ) ? : '' ) -> setCreatedAt ( $ now = Carbon :: now ( ) ) -> setUpdatedAt ( $ now ) ; try { $ avatar = $ this -> fileDownloader -> download ( $ response -> getProfilePicture ( ) ) ; $ user -> setAvatar ( $ avatar -> getKey ( ) ) ; } catch ( \ Exception $ exception ) { $ user -> setAvatar ( '' ) ; } return $ user ; } 
protected function generateUsername ( UserResponseInterface $ response ) { $ username = $ response -> getNickname ( ) ; return $ this -> userManager -> findUserByUsername ( $ username ) ? $ username . $ response -> getUsername ( ) : $ username ; } 
protected function getAuthenticatedUser ( ) { return ( $ token = $ this -> tokenStorage -> getToken ( ) ) ? ( $ token -> getUser ( ) instanceof UserInterface ? $ token -> getUser ( ) : null ) : null ; } 
public function process ( ContainerBuilder $ container ) { if ( $ algoliaClient = $ container -> findDefinition ( 'algolia_client' ) ) { $ algoliaClient -> setArguments ( [ '%algolia.application_id%' , '%algolia.api_key%' , ] ) ; } 
public function getCurrentTheme ( ) { if ( $ this -> theme === null ) { $ this -> theme = $ this -> themeContext -> getTheme ( ) ; } return $ this -> theme ; } 
public function getThemes ( ) { if ( $ this -> themes === null ) { $ this -> themes = $ this -> themeFinder -> find ( ) ; } return $ this -> themes ; } 
public function getFilterByOperator ( $ operator ) { 
protected function createPagerfanta ( $ keyword , $ entity , $ options ) { $ page = $ options [ 'page' ] ?? 1 ; $ length = $ options [ 'length' ] ?? 10 ; unset ( $ options [ 'page' ] ) ; unset ( $ options [ 'length' ] ) ; 
private function resolveStatusCode ( \ Exception $ exception ) { if ( $ exception instanceof HttpExceptionInterface ) { $ statusCode = $ exception -> getStatusCode ( ) ; } else { if ( in_array ( $ exception -> getCode ( ) , array_keys ( Response :: $ statusTexts ) ) ) { $ statusCode = $ exception -> getCode ( ) ; } else { $ statusCode = static :: DEFAULT_STATUS_CODE ; } } return $ statusCode ; } 
private function createForbiddenResponseForAPI ( ) { if ( $ this -> authorizationChecker -> isGranted ( 'IS_AUTHENTICATED_REMEMBERED' ) ) { $ response = new JsonResponse ( [ 'error' => '访问拒绝', ] , Response :: HTTP_FORBIDDEN ) ; } else { $ response = new JsonResponse ( [ 'error' => '请先登录', 'redirect' => $ this -> router -> generate ( 'login' ) , ] , Response :: HTTP_FORBIDDEN ) ; } return $ response ; } 
public function processBodyImage ( $ body ) { return preg_replace_callback ( '#<img src="(.*)"#' , function ( $ matches ) { if ( strpos ( 'http' , $ matches [ 1 ] ) === 0 ) { return $ matches [ 0 ] ; } return str_replace ( $ matches [ 1 ] , $ this -> baseUrl . $ matches [ 1 ] , $ matches [ 0 ] ) ; } , $ body ) ; } 
public function buildMediaUrl ( $ key , $ alias = null ) { $ serviceId = $ alias ? 'phpdish.media.url_builder.' . $ alias : 'phpdish.media.url_builder' ; try { $ urlBuilder = $ this -> container -> get ( $ serviceId ) ; } catch ( ServiceNotFoundException $ exception ) { throw new \ InvalidArgumentException ( sprintf ( 'Invalid Media Service Alias "%s"' , $ alias ) ) ; } return $ urlBuilder -> build ( $ key ) ; } 
public function parse ( $ name ) : TemplateReferenceInterface { if ( $ name instanceof TemplateReferenceInterface ) { return $ name ; } if ( isset ( $ this -> cache [ $ name ] ) ) { return $ this -> cache [ $ name ] ; } 
public function build ( ContainerBuilder $ container ) { parent :: build ( $ container ) ; $ container -> addCompilerPass ( new AlgoliaPass ( ) ) ; $ container -> addCompilerPass ( new RegisterPluginPass ( ) ) ; $ container -> addCompilerPass ( new InjectAssetsPass ( ) ) ; } 
public function deleteAction ( $ id ) { $ manager = $ this -> getReplyManager ( ) ; $ reply = $ manager -> findReplyById ( $ id ) ; if ( ! $ reply ) { throw $ this -> createNotFoundException ( ) ; } $ this -> denyAccessUnlessGranted ( 'edit' , $ reply ) ; $ manager -> blockReply ( $ reply ) ; return $ this -> handleView ( $ this -> view ( [ 'result' => true , ] ) ) ; } 
public function getUserRepliesAction ( $ username , Request $ request ) { $ user = $ this -> getUserManager ( ) -> findUserByName ( $ username ) ; $ replies = $ this -> getReplyManager ( ) -> findUserReplies ( $ user , $ request -> query -> getInt ( 'page' , 1 ) ) ; return $ this -> render ( $ this -> configuration -> getTemplate ( 'Topic:user_replies.html.twig' ) , [ 'user' => $ user , 'replies' => $ replies , ] ) ; } 
public function toggleVoterAction ( $ id ) { $ this -> denyAccessUnlessGranted ( 'IS_AUTHENTICATED_REMEMBERED' ) ; $ reply = $ this -> getReplyManager ( ) -> findReplyById ( $ id ) ; if ( ! $ reply ) { throw new \ InvalidArgumentException ( $ this -> get ( 'translator' ) -> trans ( 'reply.not_exists' ) ) ; } if ( $ isVoted = $ reply -> isVotedBy ( $ this -> getUser ( ) ) ) { $ this -> getReplyManager ( ) -> removeVoter ( $ reply , $ this -> getUser ( ) ) ; } else { $ this -> getReplyManager ( ) -> addVoter ( $ reply , $ this -> getUser ( ) ) ; } return $ this -> json ( [ 'vote_count' => $ reply -> getVoteCount ( ) , 'is_voted' => ! $ isVoted ] ) ; } 
protected function getTemplates ( Twig_Environment $ environment ) { if ( $ this -> templates ) { return $ this -> templates ; } $ this -> templates [ ] = $ environment -> load ( $ this -> defaultTemplate ) ; if ( $ this -> theme ) { if ( ! $ this -> theme instanceof \ Twig_Template && ! $ this -> theme instanceof \ Twig_TemplateWrapper ) { $ template = $ environment -> load ( $ this -> theme ) ; } else { $ template = $ this -> theme ; } $ this -> templates [ ] = $ template ; } return $ this -> templates ; } 
public function check ( ) { $ this -> ensureExists ( $ this -> directory ) ; $ this -> ensureIsWritable ( $ this -> directory ) ; return true ; } 
public function ensureIsWritable ( $ directory ) { if ( is_writable ( $ directory ) ) { return ; } try { $ this -> filesystem -> chmod ( $ directory , 0755 ) ; $ this -> output -> writeln ( sprintf ( '<comment>Changed "%s" permissions to 0755.</comment>' , realpath ( $ directory ) ) ) ; } catch ( IOException $ exception ) { $ this -> output -> writeln ( '' ) ; $ this -> output -> writeln ( '<error>Cannot run command due to bad directory permissions (tried to change permissions to 0755).</error>' ) ; $ this -> output -> writeln ( '' ) ; throw new \ RuntimeException ( sprintf ( 'Set "%s" writable and run command "<comment>%s</comment>"' , realpath ( dirname ( $ directory ) ) , $ this -> name ) ) ; } } 
public function ensureExists ( $ directory ) { if ( is_dir ( $ directory ) ) { return ; } try { $ this -> filesystem -> mkdir ( $ directory , 0755 ) ; $ this -> output -> writeln ( sprintf ( '<comment>Created "%s" directory.</comment>' , realpath ( $ directory ) ) ) ; } catch ( IOException $ exception ) { $ this -> output -> writeln ( '' ) ; $ this -> output -> writeln ( '<error>Cannot run command due to unexisting directory (tried to create it automatically, failed).</error>' ) ; $ this -> output -> writeln ( '' ) ; throw new \ RuntimeException ( sprintf ( 'Create directory "%s" and run command "<comment>%s</comment>"' , realpath ( $ directory ) , $ this -> name ) ) ; } } 
public function factory ( ) { $ source = new Entity ( self :: getSourceClass ( ) ) ; $ gridBuilder = $ this -> gridFactory -> createBuilder ( 'grid' , $ source , [ 'persistence' => true , 'route' => 'admin_user_index' , 'filterable' => true , 'sortable' => true , 'max_per_page' => 20 , ] ) ; $ this -> addColumns ( $ gridBuilder ) ; $ this -> addFilters ( $ gridBuilder ) ; return $ gridBuilder -> getGrid ( ) ; } 
public function onPaymentPaid ( PaymentEvent $ event ) { $ payment = $ event -> getPayment ( ) ; 
public function findThreads ( Criteria $ criteria ) { return $ this -> getThreadRepository ( ) -> createQueryBuilder ( 't' ) -> addCriteria ( $ criteria ) -> getQuery ( ) -> getResult ( ) ; } 
public function findThreadsPager ( Criteria $ criteria , $ page , $ limit = null ) { $ qb = $ this -> getThreadRepository ( ) -> createQueryBuilder ( 't' ) -> addCriteria ( $ criteria ) ; return $ this -> createPaginator ( $ qb -> getQuery ( ) , $ page , $ limit ) ; } 
public function findUserFollowingThreads ( UserInterface $ user , $ page , $ limit = null , Criteria $ criteria = null ) { $ qb = $ this -> getThreadRepository ( ) -> createQueryBuilder ( 't' ) -> leftJoin ( 't.followers' , 'f' ) -> where ( 'f.id = :userId' ) -> setParameter ( 'userId' , $ user ) ; $ criteria && $ qb -> addCriteria ( $ criteria ) ; return $ this -> createPaginator ( $ qb -> getQuery ( ) , $ page , $ limit ) ; } 
public function findThreadsByNames ( $ names ) { $ qb = $ this -> getThreadRepository ( ) -> createQueryBuilder ( 't' ) ; return $ qb -> where ( $ qb -> expr ( ) -> in ( 't.name' , $ names ) ) -> getQuery ( ) -> getResult ( ) ; } 
public function saveThread ( ThreadInterface $ thread ) { $ this -> entityManager -> persist ( $ thread ) ; $ this -> entityManager -> flush ( ) ; } 
public function createThreadsByNames ( $ names ) { $ threads = [ ] ; foreach ( $ names as $ name ) { $ thread = $ this -> createThread ( ) ; $ thread -> setName ( $ name ) -> setSlug ( $ this -> pinyin -> permalink ( $ name ) ) -> setDescription ( $ name ) ; $ threads [ ] = $ thread ; } return $ threads ; } 
public function searchThreads ( $ term ) { $ qb = $ this -> getThreadRepository ( ) -> createQueryBuilder ( 't' ) ; return $ qb -> where ( $ qb -> expr ( ) -> like ( 't.name' , ':term' ) ) -> orWhere ( $ qb -> expr ( ) -> like ( 't.description' , ':term' ) ) -> setParameter ( 'term' , "%{$term}%" ) -> setMaxResults ( 10 ) -> getQuery ( ) -> getResult ( ) ; } 
public function followThread ( ThreadInterface $ thread , UserInterface $ user ) { $ thread -> addFollower ( $ user ) ; $ thread -> setFollowerCount ( $ thread -> getFollowerCount ( ) + 1 ) ; $ this -> saveThread ( $ thread ) ; } 
public function unFollowThread ( ThreadInterface $ thread , UserInterface $ user ) { $ thread -> removeFollower ( $ user ) ; $ thread -> setFollowerCount ( $ thread -> getFollowerCount ( ) - 1 ? : 0 ) ; $ this -> saveThread ( $ thread ) ; } 
public function check ( ) { $ table = new Table ( $ this -> output ) ; $ fulfilled = true ; foreach ( $ this -> requirements as $ requirement ) { $ row = [ $ requirement -> getLabel ( ) ] ; if ( $ requirement -> isFulfilled ( ) ) { $ row [ ] = '<info>Yes</info>' ; $ fulfilled = $ fulfilled && true ; } elseif ( $ requirement -> isRequired ( ) ) { $ row [ ] = '<error>Error</error>' ; $ fulfilled = $ fulfilled && false ; } else { $ row [ ] = '<comment>Warning</comment>' ; $ fulfilled = $ fulfilled && true ; } $ table -> addRow ( $ row ) ; } $ table -> render ( ) ; return $ fulfilled ; } 
private function getInterfacesMapping ( array $ resources ) : array { $ interfaces = [ ] ; foreach ( $ resources as $ alias => $ resource ) { foreach ( $ resource as $ resourceItem ) { $ interfaces [ $ resourceItem [ 'interface' ] ] = $ resourceItem [ 'model' ] ; } } return $ interfaces ; } 
public function createPayment ( UserInterface $ user = null ) { $ payment = new $ this -> paymentEntity ; $ now = Carbon :: now ( ) ; $ payment -> setUser ( $ user ) -> setStatus ( PaymentInterface :: STATUS_WAITING ) -> setCreatedAt ( $ now ) -> setUpdatedAt ( $ now ) ; return $ payment ; } 
public function savePayment ( PaymentInterface $ payment ) { 
public function charge ( PaymentInterface $ payment ) { $ qrCode = $ this -> youzanPay -> charge ( [ 'name' => strip_tags ( $ payment -> getDescription ( ) ) , 'price' => $ payment -> getAmount ( ) , 'source' => $ payment -> getSerialNo ( ) ] ) ; $ payment -> setQrId ( $ qrCode -> getId ( ) ) ; $ this -> savePayment ( $ payment ) ; return $ qrCode ; } 
public function notifyPayment ( $ qrId ) { $ payment = $ this -> findPaymentByQrId ( $ qrId ) ; if ( ! $ payment ) { return null ; } 
public function locate ( $ file , $ currentPath = null , $ first = true ) { if ( $ this -> currentTheme && $ file [ 0 ] === '@' ) { $ bundleName = substr ( $ file , 1 ) ; if ( false !== strpos ( $ bundleName , '/' ) ) { list ( $ bundleName , $ path ) = explode ( '/' , $ bundleName , 2 ) ; } if ( in_array ( $ bundleName , $ this -> themeManager -> getNamespaces ( ) ) ) { try { $ filePath = $ this -> _kernel -> locateResource ( $ file , $ this -> currentTheme -> getPath ( ) , $ first ) ; return $ filePath ; } catch ( \ Exception $ exception ) { 
public function findAll ( ) { if ( ! file_exists ( $ this -> installedJson ) ) { return [ ] ; } $ installed = \ GuzzleHttp \ json_decode ( file_get_contents ( $ this -> installedJson ) , true ) ; foreach ( $ installed as $ package ) { if ( ! isset ( $ package [ 'type' ] ) || $ package [ 'type' ] !== 'phpdish-plugin' || ! isset ( $ package [ 'extra' ] [ 'phpdish' ] [ 'class' ] ) || ! class_exists ( $ package [ 'extra' ] [ 'phpdish' ] [ 'class' ] ) ) { continue ; } $ pluginClass = $ package [ 'extra' ] [ 'phpdish' ] [ 'class' ] ; $ this -> plugins [ ] = $ this -> initializePlugin ( $ pluginClass ) ; } return $ this -> plugins ; } 
public function load ( ObjectManager $ manager ) { $ job = new Thread ( ) ; $ job -> setCreatedAt ( Carbon :: now ( ) ) -> setUpdatedAt ( Carbon :: now ( ) ) -> setEnabled ( true ) -> setName ( '招聘') -> setSlug ( 'job' ) -> setDescription ( '招聘节点'); $ question = new Thread ( ) ; $ question -> setCreatedAt ( Carbon :: now ( ) ) -> setUpdatedAt ( Carbon :: now ( ) ) -> setEnabled ( true ) -> setName ( '问答') -> setSlug ( 'question' ) -> setDescription ( '问答节点'); $ share = new Thread ( ) ; $ share -> setCreatedAt ( Carbon :: now ( ) ) -> setUpdatedAt ( Carbon :: now ( ) ) -> setEnabled ( true ) -> setName ( '创造与分享') -> setSlug ( 'creation-share' ) -> setDescription ( '创造与分享'); $ manager -> persist ( $ job ) ; $ manager -> persist ( $ question ) ; $ manager -> persist ( $ share ) ; $ manager -> flush ( ) ; $ this -> addReference ( 'thread-share' , $ share ) ; } 
public function upload ( Request $ request ) { $ uploadedFile = $ request -> files -> get ( static :: UPLOAD_FIELD_NAME ) ; if ( is_null ( $ uploadedFile ) ) { throw new \ InvalidArgumentException ( 'Bad arguments' ) ; } list ( $ uploader , $ urlBuilder ) = $ this -> getUploaderAndBuilder ( $ request ) ; $ file = $ uploader -> upload ( $ uploadedFile ) ; $ response = [ 'key' => $ file -> getKey ( ) , 'path' => $ urlBuilder -> build ( $ file ) ] ; if ( $ file instanceof Image ) { $ response [ 'thumb' ] = $ urlBuilder -> buildImageResizeUrl ( $ file , 'middle_square' ) ; } $ file -> getContent ( ) -> close ( ) ; return $ this -> json ( $ response ) ; } 
protected function getUploaderAndBuilder ( Request $ request ) { if ( $ configKey = $ request -> headers -> get ( 'media_mapping' ) ) { $ uploader = $ this -> get ( 'phpdish_media.file_uploader.' . $ configKey ) ; $ urlBuilder = $ this -> get ( 'phpdish_media.url_builder.' . $ configKey ) ; } else { $ uploader = $ this -> get ( 'phpdish_media.file_uploader' ) ; $ urlBuilder = $ this -> get ( 'phpdish_media.url_builder' ) ; } return [ $ uploader , $ urlBuilder ] ; } 
public function format ( $ money ) { if ( ! $ money instanceof Money ) { $ money = new Money ( $ money , new Currency ( 'RMB' ) ) ; } return $ this -> formatter -> format ( $ money ) ; } 
public function process ( ContainerBuilder $ container ) { $ listenerRegistry = $ container -> getParameter ( 'phpdish.plugin.listener_registry' ) ; $ eventDispatcherDefinition = $ container -> findDefinition ( 'event_dispatcher' ) ; foreach ( $ listenerRegistry as $ index => $ listener ) { if ( is_array ( $ listener ) ) { list ( $ eventName , $ listener , $ priority ) = $ listener ; if ( is_array ( $ listener ) ) { list ( $ class , $ method ) = $ listener ; } else { $ class = $ listener ; $ method = '__invoke' ; } $ id = 'phpdish.plugin.listener_' . $ index ; $ listenerDefinition = new Definition ( $ class ) ; $ listenerDefinition -> setAutowired ( true ) ; $ container -> setDefinition ( $ id , $ listenerDefinition ) ; $ eventDispatcherDefinition -> addMethodCall ( 'addListener' , [ $ eventName , [ new ServiceClosureArgument ( new Reference ( $ id ) ) , $ method ] , $ priority ] ) ; } else { $ id = 'phpdish.plugin.subscriber_' . $ index ; $ listenerDefinition = new Definition ( $ listener ) ; $ listenerDefinition -> setAutowired ( true ) ; $ container -> setDefinition ( $ id , $ listenerDefinition ) ; $ eventDispatcherDefinition -> addMethodCall ( 'addSubscriber' , [ new Reference ( $ id ) ] ) ; } } $ container -> getParameterBag ( ) -> remove ( 'phpdish.plugin.listener_registry' ) ; } 
public function get ( $ sourceClass ) { if ( isset ( $ this -> factory [ $ sourceClass ] ) ) { $ factory = $ this -> factory [ $ sourceClass ] ; $ grid = $ factory -> factory ( ) ; } else { $ reflection = new \ ReflectionClass ( $ sourceClass ) ; if ( ! $ reflection -> isInstantiable ( ) ) { throw new \ InvalidArgumentException ( sprintf ( 'The "%s" cannot be instantiated' ) ) ; } $ source = new Entity ( $ sourceClass ) ; $ this -> grid -> setSource ( $ source ) ; $ grid = $ this -> grid ; } 
public function load ( array $ configs , ContainerBuilder $ container ) { 
public function load ( ObjectManager $ manager ) { $ friendLink = new FriendLink ( ) ; $ friendLink -> setName ( 'PHPDish' ) -> setUrl ( 'https://www.phpdish.com' ) ; $ this -> getFriendLinkManager ( ) -> saveFriendLink ( $ friendLink ) ; } 
public function findAllTemplates ( ) { if ( null !== $ this -> templates ) { return $ this -> templates ; } 
private function findTemplatesInBundle ( BundleInterface $ bundle ) { $ name = $ bundle -> getName ( ) ; $ templates = array_merge ( $ this -> findTemplatesInFolder ( $ bundle -> getPath ( ) . '/Resources/views' ) , $ this -> findTemplatesInFolder ( $ this -> rootDir . '/' . $ name . '/views' ) ) ; 
public function load ( array $ configs , ContainerBuilder $ container ) { $ configuration = new Configuration ( ) ; $ config = $ this -> processConfiguration ( $ configuration , $ configs ) ; $ loader = new Loader \ YamlFileLoader ( $ container , new FileLocator ( __DIR__ . '/../Resources/config' ) ) ; $ loader -> load ( 'services.yml' ) ; if ( isset ( $ config [ 'youzan' ] ) ) { $ container -> setDefinition ( 'phpdish.payment_gateway.youzan.api_context' , new Definition ( ApiContext :: class , [ $ config [ 'youzan' ] [ 'client_id' ] , $ config [ 'youzan' ] [ 'client_secret' ] , $ config [ 'youzan' ] [ 'kdt_id' ] ] ) ) ; if ( $ container -> hasDefinition ( 'phpdish.payment_gateway.youzan' ) ) { $ youzanPayDef = $ container -> getDefinition ( 'phpdish.payment_gateway.youzan' ) ; $ youzanPayDef -> replaceArgument ( 0 , new Reference ( 'phpdish.payment_gateway.youzan.api_context' ) ) ; } } 
public function onCategoryPersist ( CategoryPersistEvent $ event ) { $ category = $ event -> getCategory ( ) ; $ cover = $ category -> getCover ( ) ; if ( ! $ cover || $ cover === '/avatar/user1.jpg' ) { $ avatar = $ this -> avatarGenerator -> generate ( $ category -> getName ( ) ) ; $ category -> setCover ( $ avatar -> getKey ( ) ) ; } } 
public function createUserLink ( $ user ) { return sprintf ( '<a href="%s" target="_blank" data-username="%s">@%s</a> ' , $ this -> router -> generate ( 'user_view' , [ 'username' => $ user -> getUsername ( ) , ] ) , $ user -> getUsername ( ) , $ user -> getUsername ( ) ) ; } 
public function createAction ( Request $ request ) { $ this -> denyAccessUnlessGranted ( 'IS_AUTHENTICATED_REMEMBERED' ) ; $ manager = $ this -> getPaymentManager ( ) ; $ payment = $ manager -> createPayment ( $ this -> getUser ( ) ) ; $ form = $ this -> createForm ( PaymentType :: class , $ payment ) ; $ form -> handleRequest ( $ request ) ; if ( $ form -> isValid ( ) && $ form -> isSubmitted ( ) ) { $ manager -> savePayment ( $ payment ) ; $ qrCode = $ manager -> charge ( $ payment ) ; return $ this -> json ( [ 'payment' => $ payment , 'qrcode' => $ qrCode ] ) ; } throw new \ InvalidArgumentException ( 'Invalid request' ) ; } 
public function getPaymentResultAction ( Request $ request ) { $ qrId = $ request -> query -> get ( 'qr_id' ) ; if ( ! $ qrId ) { throw new \ InvalidArgumentException ( "Bad Request" ) ; } $ result = $ this -> get ( 'phpdish.payment_gateway.youzan' ) -> checkQRStatus ( $ qrId ) ; if ( $ result ) { 
public function notifyAction ( Request $ request ) { $ youZanPay = $ this -> get ( 'phpdish.payment_gateway.youzan' ) ; try { $ result = $ youZanPay -> verifyWebhook ( $ request ) ; $ trade = $ youZanPay -> getTrade ( $ result [ 'id' ] ) ; if ( $ trade ) { 
public function withdrawAction ( Request $ request ) { $ this -> denyAccessUnlessGranted ( 'IS_AUTHENTICATED_REMEMBERED' ) ; $ walletManager = $ this -> getWalletManager ( ) ; $ wallet = $ walletManager -> getUserWallet ( $ this -> getUser ( ) ) ; $ history = $ walletManager -> withdraw ( $ wallet , $ request -> request -> get ( 'amount' ) , $ request -> request -> get ( 'alipay_account' ) ) ; $ view = $ this -> view ( [ 'history' => $ history ] ) -> setContext ( ( new Context ( ) ) -> setGroups ( [ 'Default' ] ) ) ; return $ this -> handleView ( $ view ) ; } 
public function getWalletAction ( Request $ request ) { $ this -> denyAccessUnlessGranted ( 'IS_AUTHENTICATED_REMEMBERED' ) ; $ wallet = $ this -> getWalletManager ( ) -> getUserWallet ( $ this -> getUser ( ) ) ; $ histories = $ this -> getWalletManager ( ) -> findUserWalletHistories ( $ wallet , $ request -> query -> getInt ( 'page' , 1 ) ) ; return $ this -> render ( $ this -> configuration -> getTemplate ( 'Wallet:index.html.twig' ) , [ 'wallet' => $ wallet , 'histories' => $ histories ] ) ; } 
public function getSummary ( ) { return $ this -> getPosts ( ) -> matching ( Criteria :: create ( ) -> where ( Criteria :: expr ( ) -> isNull ( 'parent' ) ) -> andWhere ( Criteria :: expr ( ) -> eq ( 'enabled' , true ) ) ) ; } 
public function createAction ( Request $ request ) { $ this -> denyAccessUnlessGranted ( 'IS_AUTHENTICATED_REMEMBERED' ) ; $ manager = $ this -> getCategoryManager ( ) ; $ category = $ manager -> createCategory ( $ this -> getUser ( ) ) ; $ form = $ this -> createForm ( CategoryType :: class , $ category ) ; $ form -> handleRequest ( $ request ) ; $ translator = $ this -> get ( 'translator' ) ; if ( ( $ number = $ manager -> getUserCategoriesNumber ( $ this -> getUser ( ) ) ) >= 2 ) { $ this -> addFlash ( 'danger' , $ translator -> trans ( 'category.more_than_2_categories' , [ '%count%' => $ number ] ) ) ; } if ( $ form -> isSubmitted ( ) && $ form -> isValid ( ) ) { 
public function viewAction ( $ slug , Request $ request ) { $ category = $ this -> getCategoryManager ( ) -> findCategoryBySlug ( $ slug ) ; $ criteria = Criteria :: create ( ) -> where ( Criteria :: expr ( ) -> eq ( 'category' , $ category -> getId ( ) ) ) -> andWhere ( Criteria :: expr ( ) -> eq ( 'enabled' , true ) ) ; if ( $ request -> query -> get ( 'orderby' ) === 'hot' ) { $ criteria -> orderBy ( [ 'viewCount' => 'desc' , 'createdAt' => 'desc' , ] ) ; } else { $ criteria -> orderBy ( [ 'createdAt' => 'desc' , ] ) ; } $ posts = $ this -> getPostManager ( ) -> findPostsPager ( $ criteria , $ request -> query -> getInt ( 'page' , 1 ) ) ; return $ this -> render ( $ this -> configuration -> getTemplate ( 'Category:view.html.twig' ) , [ 'category' => $ category , 'posts' => $ posts , ] ) ; } 
public function editAction ( $ slug , Request $ request ) { $ manager = $ this -> getCategoryManager ( ) ; $ category = $ manager -> findCategoryBySlug ( $ slug ) ; if ( ! $ category ) { throw $ this -> createNotFoundException ( ) ; } $ this -> denyAccessUnlessGranted ( 'edit' , $ category ) ; $ form = $ this -> createForm ( CategoryType :: class , $ category ) ; $ form -> handleRequest ( $ request ) ; if ( $ form -> isValid ( ) && $ form -> isSubmitted ( ) ) { $ manager -> saveCategory ( $ category ) ; $ this -> addFlash ( 'success' , $ this -> get ( 'translator' ) -> trans ( 'category.edit_success' ) ) ; return $ this -> redirectToRoute ( 'category_view' , [ 'slug' => $ category -> getSlug ( ) , ] ) ; } return $ this -> render ( $ this -> configuration -> getTemplate ( 'Category:create.html.twig' ) , [ 'form' => $ form -> createView ( ) , 'category' => $ category , 'hasManyCategories' => false , 'isBook' => false ] ) ; } 
public function getFollowersAction ( $ slug , Request $ request ) { $ category = $ this -> getCategoryManager ( ) -> findCategoryBySlug ( $ slug ) ; $ users = $ this -> getUserManager ( ) -> findCategoryFollowers ( $ category , $ request -> query -> getInt ( 'page' , 1 ) ) ; return $ this -> render ( $ this -> configuration -> getTemplate ( 'Category:followers.html.twig' ) , [ 'category' => $ category , 'users' => $ users , ] ) ; } 
public function followAction ( $ slug ) { $ this -> denyAccessUnlessGranted ( 'IS_AUTHENTICATED_REMEMBERED' ) ; $ category = $ this -> getCategoryManager ( ) -> findCategoryBySlug ( $ slug ) ; if ( $ category -> isCharging ( ) && ! $ category -> isBelongsTo ( $ this -> getUser ( ) ) ) { 
public function unFollowAction ( $ slug ) { $ this -> denyAccessUnlessGranted ( 'IS_AUTHENTICATED_REMEMBERED' ) ; $ category = $ this -> getCategoryManager ( ) -> findCategoryBySlug ( $ slug ) ; $ this -> getCategoryManager ( ) -> unFollowCategory ( $ category , $ this -> getUser ( ) ) ; $ view = $ this -> view ( [ 'follower_count' => $ category -> getFollowerCount ( ) , ] ) ; return $ this -> handleView ( $ view ) ; } 
public function userCategoriesAction ( UserInterface $ user ) { $ categories = $ this -> getCategoryManager ( ) -> findUserCategories ( $ user ) ; return $ this -> render ( $ this -> configuration -> getTemplate ( 'Category:user_categories.html.twig' ) , [ 'categories' => $ categories , 'user' => $ user , ] ) ; } 
public function onTopicReplied ( ReplyTopicEvent $ event ) { if ( $ event -> getTopic ( ) -> getUser ( ) === $ event -> getReply ( ) -> getUser ( ) ) { return ; } $ notification = $ this -> notificationHelper -> createReplyTopicNotification ( $ event -> getTopic ( ) , $ event -> getReply ( ) ) ; $ this -> notificationHelper -> sendNotification ( $ event -> getTopic ( ) -> getUser ( ) , $ notification ) ; } 
public function onTopicVoted ( VoteTopicEvent $ event ) { 
public function onReplyVoted ( VoteReplyEvent $ event ) { 
public function onUserMentioned ( ReplyMentionUserEvent $ event ) { 
public function getTheme ( ) { if ( $ this -> currentThemeName ) { foreach ( $ this -> themeFinder -> find ( ) as $ theme ) { if ( $ theme -> getName ( ) === $ this -> currentThemeName ) { return $ theme ; } } throw new \ InvalidArgumentException ( sprintf ( 'The theme "%s" is not found' , $ this -> currentThemeName ) ) ; } return null ; } 
public function load ( array $ configs , ContainerBuilder $ container ) { $ configuration = new Configuration ( ) ; $ config = $ this -> processConfiguration ( $ configuration , $ configs ) ; 
public function addPostCount ( $ count = 1 ) { $ this -> postCount += $ count ; $ this -> postCount = max ( $ this -> postCount , 0 ) ; return $ this ; } 
public function createAction ( Request $ request ) { $ this -> denyAccessUnlessGranted ( 'IS_AUTHENTICATED_REMEMBERED' ) ; $ manager = $ this -> getBookManager ( ) ; $ book = $ manager -> createBook ( $ this -> getUser ( ) ) ; $ form = $ this -> createForm ( BookType :: class , $ book ) ; $ form -> handleRequest ( $ request ) ; $ translator = $ this -> get ( 'translator' ) ; if ( ( $ number = $ manager -> getUserBookNumber ( $ this -> getUser ( ) ) ) >= 5 ) { $ this -> addFlash ( 'danger' , $ translator -> trans ( 'book.more_than_5_books' , [ '%count%' => $ number ] ) ) ; } if ( $ form -> isSubmitted ( ) && $ form -> isValid ( ) ) { $ manager -> saveBook ( $ book ) ; $ this -> addFlash ( 'success' , $ translator -> trans ( 'book.add_success' ) ) ; return $ this -> redirectToRoute ( 'book_view' , [ 'slug' => $ book -> getSlug ( ) , ] ) ; } return $ this -> render ( $ this -> configuration -> getTemplate ( 'Category:create.html.twig' ) , [ 'form' => $ form -> createView ( ) , 'hasManyCategories' => $ number >= 5 , 'isBook' => true ] ) ; } 
public function viewAction ( $ slug , Request $ request ) { $ book = $ this -> getBookManager ( ) -> findBook ( $ slug ) ; return $ this -> render ( $ this -> configuration -> getTemplate ( 'Book:view.html.twig' ) , [ 'book' => $ book , ] ) ; } 
public function editAction ( $ slug , Request $ request ) { $ manager = $ this -> getBookManager ( ) ; $ book = $ manager -> findBook ( $ slug ) ; if ( ! $ book ) { throw $ this -> createNotFoundException ( ) ; } $ this -> denyAccessUnlessGranted ( 'edit' , $ book ) ; $ form = $ this -> createForm ( BookType :: class , $ book ) ; $ form -> handleRequest ( $ request ) ; if ( $ form -> isValid ( ) && $ form -> isSubmitted ( ) ) { $ manager -> saveBook ( $ book ) ; $ this -> addFlash ( 'success' , $ this -> get ( 'translator' ) -> trans ( 'book.edit_success' ) ) ; return $ this -> redirectToRoute ( 'book_view' , [ 'slug' => $ book -> getSlug ( ) , ] ) ; } return $ this -> render ( $ this -> configuration -> getTemplate ( 'Category:create.html.twig' ) , [ 'form' => $ form -> createView ( ) , 'category' => $ book , 'hasManyCategories' => false , 'isBook' => true ] ) ; } 
public function getSummaryAction ( $ slug ) { $ book = $ this -> getBookManager ( ) -> findBook ( $ slug ) ; $ chaptersTree = $ this -> getBookManager ( ) -> findBookChaptersTree ( $ book ) ; return $ this -> render ( $ this -> configuration -> getTemplate ( 'Book:summary.html.twig' ) , [ 'book' => $ book , 'chaptersTree' => $ chaptersTree ] ) ; } 
public function getFollowersAction ( $ slug , Request $ request ) { $ book = $ this -> getBookManager ( ) -> findBook ( $ slug ) ; $ users = $ this -> getUserManager ( ) -> findCategoryFollowers ( $ book , $ request -> query -> getInt ( 'page' , 1 ) ) ; return $ this -> render ( $ this -> configuration -> getTemplate ( 'Book:followers.html.twig' ) , [ 'book' => $ book , 'users' => $ users , ] ) ; } 
public function viewChapterAction ( $ slug , $ chapterId , Request $ request ) { $ book = $ this -> getBookManager ( ) -> findBook ( $ slug ) ; $ chapter = $ this -> getBookManager ( ) -> findChapter ( $ chapterId ) ; $ chaptersTree = $ this -> getBookManager ( ) -> findBookChaptersTree ( $ book ) ; 
public function getUserBooksAction ( $ username , Request $ request ) { $ user = $ this -> getUserManager ( ) -> findUserByName ( $ username ) ; $ books = $ this -> getBookManager ( ) -> findUserBooks ( $ user ) ; return $ this -> render ( $ this -> configuration -> getTemplate ( 'Book:user_books.html.twig' ) , [ 'user' => $ user , 'books' => $ books ] ) ; } 
public function addSummaryAction ( $ slug , Request $ request ) { $ book = $ this -> getBookManager ( ) -> findBook ( $ slug ) ; $ this -> denyAccessUnlessGranted ( 'edit' , $ book ) ; $ chapter = $ this -> getBookManager ( ) -> addBookChapter ( $ book , $ request -> request -> get ( 'title' ) ) ; return $ this -> handleView ( $ this -> view ( [ 'chapter' => $ chapter ] ) -> setContext ( ( new Context ( ) ) -> setGroups ( [ 'Default' ] ) ) ) ; } 
public function editSummaryAction ( $ slug , $ id , Request $ request ) { $ book = $ this -> getBookManager ( ) -> findBook ( $ slug ) ; $ this -> denyAccessUnlessGranted ( 'edit' , $ book ) ; $ chapter = $ this -> getBookManager ( ) -> findChapter ( $ id ) ; $ chapter -> setTitle ( $ request -> request -> get ( 'title' ) ) ; $ this -> getPostManager ( ) -> savePost ( $ chapter ) ; return $ this -> handleView ( $ this -> view ( [ 'chapter' => $ chapter ] ) -> setContext ( ( new Context ( ) ) -> setGroups ( [ 'Default' ] ) ) ) ; } 
public function addChapterAction ( $ slug , Request $ request ) { $ book = $ this -> getBookManager ( ) -> findBook ( $ slug ) ; $ this -> denyAccessUnlessGranted ( 'edit' , $ book ) ; 
public function editChapterAction ( $ slug , $ id , Request $ request ) { $ book = $ this -> getBookManager ( ) -> findBook ( $ slug ) ; $ this -> denyAccessUnlessGranted ( 'edit' , $ book ) ; 
public function moveChapterAction ( $ slug , $ id , Request $ request ) { $ book = $ this -> getBookManager ( ) -> findBook ( $ slug ) ; $ this -> denyAccessUnlessGranted ( 'edit' , $ book ) ; $ chapter = $ this -> getBookManager ( ) -> findChapter ( $ id ) ; $ this -> getBookManager ( ) -> moveBookChapter ( $ book , $ chapter , $ request -> request -> get ( 'direction' ) , $ request -> request -> get ( 'step' ) ) ; return $ this -> handleView ( $ this -> view ( [ 'chapter' => $ chapter ] ) -> setContext ( ( new Context ( ) ) -> setGroups ( [ 'Default' ] ) ) ) ; } 
public function process ( ContainerBuilder $ container ) { if ( ! $ container -> hasParameter ( 'phpdish.resources' ) || ! $ container -> hasDefinition ( 'phpdish_resource.resource_registry' ) ) { return ; } $ resourceRegistry = $ container -> findDefinition ( 'phpdish_resource.resource_registry' ) ; $ resourceRegistry -> setArgument ( 0 , $ container -> getParameter ( 'phpdish.resources' ) ) ; } 
public function getComparison ( ) { $ this -> assertComparable ( ) ; return new Comparison ( $ this -> column -> getName ( ) , $ this -> operator , $ this -> value ) ; } 
public function initialize ( $ data ) { $ this -> value = $ data [ 'value' ] ; 
public function getTemplate ( $ key ) { if ( isset ( $ this -> templates [ $ key ] ) ) { return $ this -> templates [ $ key ] ; } return $ this -> defaultTemplateNamespace . ':' . $ key ; } 
public function createMenu ( array $ options = [ ] ) { $ menu = $ this -> factory -> createItem ( 'root' ) ; $ menu -> setChildrenAttribute ( 'class' , 'nav navbar-nav' ) ; $ menu -> addChild ( 'homepage' , [ 'label' => 'menu.homepage' , 'route' => 'homepage' , ] ) ; $ menu -> addChild ( 'Category' , [ 'label' => 'menu.category' , 'route' => 'post' , ] ) ; $ menu -> addChild ( 'Topic' , [ 'label' => 'menu.ask_question' , 'route' => 'thread_view' , 'routeParameters' => [ 'slug' => 'question' , ] , ] ) ; $ menu -> addChild ( 'job' , [ 'label' => 'menu.job' , 'route' => 'thread_view' , 'routeParameters' => [ 'slug' => 'job' , ] , ] ) ; $ github = $ menu -> addChild ( 'GitHub' , [ 'label' => 'GitHub' , 'uri' => 'https://github.com/slince/phpdish' ] ) ; $ github -> setLinkAttribute ( 'target' , '_blank' ) ; $ this -> eventDispatcher -> dispatch ( Events :: NAV_MENU_BUILT , new FilterMenuEvent ( $ menu ) ) ; return $ menu ; } 
public function saveFriendLink ( FriendLink $ friendLink ) { $ this -> entityManager -> persist ( $ friendLink ) ; $ this -> entityManager -> flush ( ) ; } 
public function addColumn ( $ column , $ type , $ options = [ ] ) { if ( ! $ column instanceof ColumnInterface ) { $ column = $ this -> factory -> createColumn ( $ column , $ type , $ options ) ; } $ this -> columns [ $ column -> getName ( ) ] = $ column ; } 
protected function loadEntities ( ) { if ( $ this -> request ) { if ( $ filters = $ this -> request -> get ( 'filters' ) ) { $ this -> applyFilters ( $ filters ) ; } } $ this -> entities = $ this -> source -> loadSource ( $ this -> columns ) ; } 
protected function applyFilters ( array $ filterItems ) { foreach ( $ filterItems as $ columnName => $ filterItem ) { if ( is_numeric ( $ columnName ) ) { if ( ! is_array ( $ filterItem ) ) { 
public function transform ( $ value ) { if ( null === $ value ) { return '' ; } $ threadNames = [ ] ; foreach ( $ value as $ thread ) { if ( ! $ thread instanceof ThreadInterface ) { throw new UnexpectedTypeException ( $ thread , ThreadInterface :: class ) ; } $ threadNames [ ] = $ thread -> getName ( ) ; } return implode ( ',' , $ threadNames ) ; } 
public function reverseTransform ( $ value ) { if ( null === $ value || '' === $ value ) { return null ; } $ threadNames = array_unique ( array_filter ( array_map ( 'trim' , explode ( ',' , $ value ) ) ) ) ; if ( count ( $ threadNames ) === 0 ) { return null ; } $ threads = $ this -> threadManager -> findThreadsByNames ( $ threadNames ) ; $ existingThreadNames = array_map ( function ( ThreadInterface $ thread ) { return $ thread -> getName ( ) ; } , $ threads ) ; 
public function process ( ContainerBuilder $ container ) { $ this -> container = $ container ; $ this -> routingLoaderDefinition = $ container -> findDefinition ( 'phpdish.plugin.route_loader' ) ; $ this -> translatorDefinition = $ container -> findDefinition ( 'translator' ) ; 
public function install ( $ pluginMetadata ) { 
public function createNotification ( $ subject , $ message = null ) { $ notification = new $ this -> notificationEntity ( ) ; $ notification -> setSubject ( $ subject ) ; $ message && $ notification -> setMessage ( $ message ) ; return $ notification ; } 
public function sendNotification ( $ participants , NotificationInterface $ notification , $ send = false ) { foreach ( $ participants as $ participant ) { $ metadata = new $ this -> metadataEntity ( ) ; $ metadata -> setParticipant ( $ participant ) ; $ notification -> addMetadata ( $ metadata ) ; } $ this -> entityManager -> persist ( $ notification ) ; $ send && $ this -> entityManager -> flush ( ) ; } 
public function findNotificationsPager ( UserInterface $ participant , $ seen = null , $ page , $ limit = null ) { $ qb = $ this -> getNotificationQb ( $ participant , $ seen ) ; return $ this -> createPaginator ( $ qb -> getQuery ( ) , $ page , $ limit ) ; } 
public function findNotificationMetadataPager ( UserInterface $ participant , $ seen , $ page , $ limit = null ) { $ qb = $ this -> getParticipantMetadataQb ( $ participant , $ seen ) ; $ qb -> innerJoin ( 'm.notification' , 'mn' ) -> addSelect ( [ 'mn' ] ) ; return $ this -> createPaginator ( $ qb -> getQuery ( ) , $ page , $ limit ) ; } 
public function getNotificationCount ( UserInterface $ participant , $ seen = null ) { $ qb = $ this -> getParticipantMetadataQb ( $ participant , $ seen ) ; $ qb -> select ( $ qb -> expr ( ) -> count ( 'm' ) ) ; return $ qb -> getQuery ( ) -> getSingleScalarResult ( ) ; } 
protected function getParticipantMetadataQb ( UserInterface $ participant , $ seen ) { $ qb = $ this -> getMetadataRepository ( ) -> createQueryBuilder ( 'm' ) -> where ( 'm.participant = :participant' ) -> setParameter ( 'participant' , $ participant ) ; if ( $ seen !== null ) { $ qb -> andWhere ( 'm.seen =:seen' ) -> setParameter ( 'seen' , ( boolean ) $ seen ) ; } return $ qb ; } 
public function markAllAsSeen ( UserInterface $ participant ) { $ notifications = $ this -> findNotificationMetadata ( $ participant , false ) ; foreach ( $ notifications as $ notification ) { $ notification -> setSeen ( true ) ; } $ this -> entityManager -> flush ( ) ; } 
public function markAsSeen ( $ notificationMeta ) { foreach ( $ notificationMeta as $ notificationMetadata ) { $ notificationMetadata -> setSeen ( true ) ; } $ this -> entityManager -> flush ( ) ; } 
protected function ensureDirectoryWritableAndExists ( $ directory , $ output ) { $ checker = $ this -> getContainer ( ) -> get ( 'phpdish.installer.directory_checker' ) ; $ checker -> setOutput ( $ output ) ; $ checker -> setDirectory ( $ directory ) ; $ checker -> check ( ) ; } 
protected function executeCommand ( $ command , OutputInterface $ output = null , array $ options = [ ] ) { if ( is_null ( $ output ) ) { $ output = new NullOutput ( ) ; } $ options = array_merge ( $ options , [ 'command' => $ command , ] ) ; $ this -> getApplication ( ) -> run ( new ArrayInput ( $ options ) , $ output ) ; return $ this ; } 
protected function bulkRunCommands ( array $ commands , OutputInterface $ output , $ renderProgressbar = false ) { if ( $ renderProgressbar ) { $ progressbar = new ProgressBar ( $ output , count ( $ commands ) ) ; } foreach ( $ commands as $ commandItem ) { if ( is_string ( $ commandItem ) ) { $ command = $ commandItem ; $ options = [ ] ; } else { $ command = $ commandItem [ 'command' ] ; $ options = $ commandItem [ 'options' ] ; } $ this -> executeCommand ( $ command , null , $ options ) ; $ renderProgressbar && $ progressbar -> advance ( 1 ) ; } $ renderProgressbar && $ progressbar -> finish ( ) ; } 
public function addResourcesSection ( ArrayNodeDefinition $ rootNode ) { $ rootNode -> children ( ) -> arrayNode ( 'resources' ) -> children ( ) -> arrayNode ( 'post' ) -> children ( ) -> scalarNode ( 'interface' ) -> defaultValue ( PostInterface :: class ) -> cannotBeEmpty ( ) -> end ( ) -> scalarNode ( 'model' ) -> defaultValue ( Post :: class ) -> cannotBeEmpty ( ) -> end ( ) -> end ( ) -> end ( ) -> arrayNode ( 'comment' ) -> children ( ) -> scalarNode ( 'interface' ) -> defaultValue ( CommentInterface :: class ) -> cannotBeEmpty ( ) -> end ( ) -> scalarNode ( 'model' ) -> defaultValue ( Comment :: class ) -> cannotBeEmpty ( ) -> end ( ) -> end ( ) -> end ( ) -> arrayNode ( 'category' ) -> children ( ) -> scalarNode ( 'interface' ) -> defaultValue ( CategoryInterface :: class ) -> cannotBeEmpty ( ) -> end ( ) -> scalarNode ( 'model' ) -> defaultValue ( Category :: class ) -> cannotBeEmpty ( ) -> end ( ) -> end ( ) -> end ( ) -> end ( ) -> end ( ) -> end ( ) ; } 
public function onKernelResponse ( FilterResponseEvent $ event ) { if ( ! $ this -> pjaxHelper -> isPjaxRequest ( $ event -> getRequest ( ) ) ) { return ; } $ this -> filterResponse ( $ event -> getRequest ( ) , $ event -> getResponse ( ) ) ; } 
protected function filterResponse ( Request $ request , Response $ response ) { $ crawler = new Crawler ( $ response -> getContent ( ) ) ; $ body = $ this -> fetchBody ( $ crawler , $ this -> pjaxHelper -> getContainer ( $ request ) ) ; $ response -> setContent ( $ this -> makeTitle ( $ crawler ) . $ body ) ; } 
protected function fetchBody ( Crawler $ crawler , $ container ) { $ content = $ crawler -> filter ( $ container ) ; if ( $ content -> count ( ) == 0 ) { return '' ; } return $ content -> html ( ) ; } 
public function buildImageResizeUrl ( ImageInterface $ image , $ filter , $ runtimeConfig = [ ] ) { return $ this -> imagineCacheManager -> getBrowserPath ( $ image -> getKey ( ) , $ filter , $ runtimeConfig ) ; } 
public function editProfileAction ( Request $ request ) { $ this -> denyAccessUnlessGranted ( 'IS_AUTHENTICATED_REMEMBERED' ) ; $ user = $ this -> getUser ( ) ; $ form = $ this -> createForm ( ChangeUserProfileType :: class , $ user ) ; $ form -> handleRequest ( $ request ) ; if ( $ form -> isSubmitted ( ) && $ form -> isValid ( ) ) { $ this -> getUserManager ( ) -> saveUser ( $ user ) ; $ translator = $ this -> get ( 'translator' ) ; $ this -> addFlash ( 'success' , $ translator -> trans ( 'profile.edit.success' ) ) ; return $ this -> redirectToRoute ( 'setting_profile' ) ; } return $ this -> render ( $ this -> configuration -> getTemplate ( 'Setting:profile.html.twig' ) , [ 'form' => $ form -> createView ( ) , ] ) ; } 
public function bindSocialSiteAction ( Request $ request ) { $ this -> denyAccessUnlessGranted ( 'IS_AUTHENTICATED_REMEMBERED' ) ; return $ this -> render ( $ this -> configuration -> getTemplate ( 'Setting:bind_social.html.twig' ) ) ; } 
public function mergeResources ( $ alias , $ resources ) { $ this -> resources = array_merge ( $ this -> resources , [ $ alias => $ resources ] ) ; } 
public function getResourceItemByModel ( $ model ) { foreach ( $ this -> resources as $ alias => $ resource ) { foreach ( $ resource as $ resourceItem ) { if ( $ resourceItem [ 'model' ] === $ model ) { return $ resourceItem ; } } } return null ; } 
public function grid ( GridInterface $ grid , $ theme = null ) { $ this -> initializeTemplate ( $ theme ) ; $ grid -> initialize ( ) ; return $ this -> renderBlock ( 'grid' , [ 'grid' => $ grid ] ) ; } 
protected function hasBlock ( $ name ) { foreach ( $ this -> templates as $ template ) { if ( $ template -> hasBlock ( $ name ) ) { return true ; } } return false ; } 
public function find ( ) { $ finder = new Finder ( ) ; $ finder -> in ( $ this -> directory ) -> name ( $ this -> filename ) -> ignoreUnreadableDirs ( ) ; $ themes = [ ] ; foreach ( $ finder as $ file ) { $ theme = $ this -> hydrateTheme ( $ file ) ; if ( $ theme === false ) { continue ; } $ themes [ ] = $ theme ; } return $ themes ; } 
private function convertAuthorsArraysToAuthorsObjects ( array $ authorsArrays ) : array { return array_map ( function ( array $ authorArray ) { $ author = new ThemeAuthor ( ) ; $ author -> setName ( $ authorArray [ 'name' ] ?? null ) ; $ author -> setEmail ( $ authorArray [ 'email' ] ?? null ) ; $ author -> setHomepage ( $ authorArray [ 'homepage' ] ?? null ) ; $ author -> setRole ( $ authorArray [ 'role' ] ?? null ) ; return $ author ; } , $ authorsArrays ) ; } 
private function convertScreenshotsArraysToScreenshotsObjects ( array $ screenshotsArrays ) : array { return array_map ( function ( array $ screenshotArray ) { if ( ! array_key_exists ( 'path' , $ screenshotArray ) ) { throw new \ InvalidArgumentException ( 'Screenshot path is required.' ) ; } $ themeScreenshot = new ThemeScreenshot ( $ screenshotArray [ 'path' ] ) ; $ themeScreenshot -> setTitle ( $ screenshotArray [ 'title' ] ?? null ) ; $ themeScreenshot -> setDescription ( $ screenshotArray [ 'description' ] ?? null ) ; return $ themeScreenshot ; } , $ screenshotsArrays ) ; } 
public function indexAction ( Request $ request ) { $ posts = $ this -> getPostManager ( ) -> findLatestEnabledPosts ( $ request -> query -> getInt ( 'page' , 1 ) ) ; return $ this -> render ( $ this -> configuration -> getTemplate ( 'Post:index.html.twig' ) , [ 'posts' => $ posts , ] ) ; } 
public function createAction ( Request $ request ) { $ this -> denyAccessUnlessGranted ( 'IS_AUTHENTICATED_REMEMBERED' ) ; $ translator = $ this -> get ( 'translator' ) ; 
public function viewAction ( $ id , Request $ request ) { $ post = $ this -> getPostManager ( ) -> findPostById ( $ id ) ; if ( ! $ post -> isEnabled ( ) ) { throw $ this -> createNotFoundException ( ) ; } 
public function editAction ( $ id , Request $ request ) { $ post = $ this -> getPostManager ( ) -> findPostById ( $ id ) ; if ( ! $ post ) { throw $ this -> createNotFoundException ( ) ; } $ this -> denyAccessUnlessGranted ( 'edit' , $ post ) ; $ form = $ this -> createForm ( PostType :: class , $ post , [ 'user' => $ this -> getUser ( ) , ] ) ; $ form -> handleRequest ( $ request ) ; if ( $ form -> isValid ( ) && $ form -> isSubmitted ( ) ) { $ this -> getPostManager ( ) -> savePost ( $ post ) ; return $ this -> redirectToRoute ( 'post_view' , [ 'id' => $ post -> getId ( ) , ] ) ; } return $ this -> render ( $ this -> configuration -> getTemplate ( 'Post:create.html.twig' ) , [ 'form' => $ form -> createView ( ) , 'post' => $ post , ] ) ; } 
public function deleteAction ( $ id ) { $ manager = $ this -> getPostManager ( ) ; $ post = $ manager -> findPostById ( $ id ) ; if ( ! $ post ) { throw $ this -> createNotFoundException ( ) ; } $ this -> denyAccessUnlessGranted ( 'edit' , $ post ) ; $ manager -> blockPost ( $ post ) ; return $ this -> handleView ( $ this -> view ( [ 'result' => true , ] ) ) ; } 
public function getUserPostsAction ( $ username , Request $ request ) { $ user = $ this -> getUserManager ( ) -> findUserByName ( $ username ) ; $ posts = $ this -> getPostManager ( ) -> findUserEnabledPosts ( $ user , $ request -> query -> getInt ( 'page' , 1 ) ) ; return $ this -> render ( $ this -> configuration -> getTemplate ( 'Post:user_posts.html.twig' ) , [ 'user' => $ user , 'posts' => $ posts , ] ) ; } 
public function recommendPostsAction ( $ limit ) { $ criteria = Criteria :: create ( ) -> orderBy ( [ 'isRecommended' => 'desc' , 'createdAt' => 'desc' ] ) -> andWhere ( Criteria :: expr ( ) -> gte ( 'createdAt' , Carbon :: parse ( '-100 days' ) ) ) -> setMaxResults ( $ limit ) ; $ posts = $ this -> getPostManager ( ) -> findPosts ( $ criteria ) ; return $ this -> render ( $ this -> configuration -> getTemplate ( 'Post:recommend_posts.html.twig' ) , [ 'posts' => $ posts , ] ) ; } 
public function toggleVoterAction ( $ id ) { $ this -> denyAccessUnlessGranted ( 'IS_AUTHENTICATED_REMEMBERED' ) ; $ post = $ this -> getPostManager ( ) -> findPostById ( $ id ) ; if ( ! $ post ) { throw new \ InvalidArgumentException ( $ this -> get ( 'translator' ) -> trans ( 'post.not_exists' ) ) ; } if ( $ isVoted = $ post -> isVotedBy ( $ this -> getUser ( ) ) ) { $ this -> getPostManager ( ) -> removeVoter ( $ post , $ this -> getUser ( ) ) ; } else { $ this -> getPostManager ( ) -> addVoter ( $ post , $ this -> getUser ( ) ) ; } return $ this -> json ( [ 'vote_count' => $ post -> getVoteCount ( ) , 'is_voted' => ! $ isVoted ] ) ; } 
public function registerBundles ( ) { $ bundles = [ new \ Symfony \ Bundle \ FrameworkBundle \ FrameworkBundle ( ) , new \ Symfony \ Bundle \ SecurityBundle \ SecurityBundle ( ) , new \ Symfony \ Bundle \ TwigBundle \ TwigBundle ( ) , new \ Symfony \ Bundle \ MonologBundle \ MonologBundle ( ) , new \ Symfony \ Bundle \ SwiftmailerBundle \ SwiftmailerBundle ( ) , new \ Doctrine \ Bundle \ DoctrineBundle \ DoctrineBundle ( ) , new \ Sensio \ Bundle \ FrameworkExtraBundle \ SensioFrameworkExtraBundle ( ) , new \ Symfony \ Bundle \ AsseticBundle \ AsseticBundle ( ) , new \ Doctrine \ Bundle \ MigrationsBundle \ DoctrineMigrationsBundle ( ) , new \ Doctrine \ Bundle \ FixturesBundle \ DoctrineFixturesBundle ( ) , new \ Stof \ DoctrineExtensionsBundle \ StofDoctrineExtensionsBundle ( ) , new \ JMS \ SerializerBundle \ JMSSerializerBundle ( ) , new \ FOS \ UserBundle \ FOSUserBundle ( ) , new \ FOS \ RestBundle \ FOSRestBundle ( ) , new \ FOS \ MessageBundle \ FOSMessageBundle ( ) , new \ Knp \ Bundle \ PaginatorBundle \ KnpPaginatorBundle ( ) , new \ Knp \ Bundle \ MarkdownBundle \ KnpMarkdownBundle ( ) , new \ Knp \ Bundle \ GaufretteBundle \ KnpGaufretteBundle ( ) , new \ Knp \ Bundle \ MenuBundle \ KnpMenuBundle ( ) , new \ WhiteOctober \ PagerfantaBundle \ WhiteOctoberPagerfantaBundle ( ) , new \ Liip \ ImagineBundle \ LiipImagineBundle ( ) , new \ Http \ HttplugBundle \ HttplugBundle ( ) , new \ HWI \ Bundle \ OAuthBundle \ HWIOAuthBundle ( ) , new \ Algolia \ SearchBundle \ AlgoliaSearchBundle ( ) , new \ Exercise \ HTMLPurifierBundle \ ExerciseHTMLPurifierBundle ( ) , 
protected function getKernelParameters ( ) { $ simplePlugins = [ ] ; $ simplePluginMetas = [ ] ; foreach ( $ this -> simplePlugins as $ simplePlugin ) { $ simplePlugins [ $ simplePlugin -> getName ( ) ] = get_class ( $ simplePlugin ) ; $ simplePluginMetas [ $ simplePlugin -> getName ( ) ] = [ 'path' => $ simplePlugin -> getPath ( ) , 'routerSource' => $ simplePlugin -> getRouterResource ( ) , 'servicesSource' => $ simplePlugin -> getServicesSource ( ) , ] ; } return array_merge ( parent :: getKernelParameters ( ) , [ 'kernel.simple_plugins' => $ simplePlugins , 'kernel.simple_plugins_metadata' => $ simplePluginMetas ] ) ; } 
protected function findSimplePlugins ( ) { $ finder = new CachedPluginFinder ( $ this -> getCacheDir ( ) . '/phpdish_plugins.php' , new PluginFinder ( $ this -> getProjectDir ( ) ) ) ; return $ finder -> findAll ( ) ; } 
public function initialize ( $ data ) { isset ( $ data [ 'from' ] ) && $ this -> from = $ data [ 'from' ] ; isset ( $ data [ 'to' ] ) && $ this -> from = $ data [ 'to' ] ; } 
protected function isResource ( ClassMetadata $ metadata ) : bool { if ( ! $ reflectionClass = $ metadata -> getReflectionClass ( ) ) { return false ; } return $ reflectionClass -> implementsInterface ( IdentifiableInterface :: class ) ; } 
public function download ( $ mediaUrl ) { try { $ response = $ this -> httpClient -> get ( $ mediaUrl ) ; } catch ( \ Exception $ exception ) { throw new \ RuntimeException ( sprintf ( 'Fail to donwload the resource "%s"' , $ mediaUrl ) ) ; } 
public function buildForm ( FormBuilderInterface $ builder , array $ options ) { $ supportLocales = $ this -> localeManager -> all ( ) ; $ builder -> add ( 'username' , TextType :: class , [ 'label' => 'form.user.username' , ] ) -> add ( 'gender' , ChoiceType :: class , [ 'choices' => [ 'form.user.gender.male' => User :: GENDER_MEN , 'form.user.gender.female' => User :: GENDER_WOMEN , ] , 'placeholder' => 'form.user.gender.placeholder' , 'label' => 'form.user.gender.gender' , ] ) -> add ( 'email' , TextType :: class , [ 'label' => 'form.user.email' , ] ) -> add ( 'description' , TextareaType :: class , [ 'label' => 'form.user.description' , ] ) -> add ( 'profile' , ProfileType :: class ) -> add ( 'avatar' , HiddenType :: class , [ 'label' => 'form.user.avatar' , ] ) -> add ( 'locale' , ChoiceType :: class , [ 'choices' => $ this -> wrapLocaleChoices ( ) , 'label' => 'form.user.locale.locale' , ] ) ; } 
public function addViewCount ( $ viewCount ) { $ this -> viewCount += $ viewCount ; $ this -> viewCount < 0 && $ this -> viewCount = 0 ; return $ this ; } 
public function getImages ( ) { if ( ! is_null ( $ this -> images ) ) { return $ this -> images ; } return $ this -> images = MarkdownHelper :: extractImages ( $ this -> getOriginalBody ( ) ) ; } 
public function getInboxThreadsPager ( $ page , $ limit = null ) { $ participant = $ this -> getAuthenticatedParticipant ( ) ; $ query = $ this -> threadManager -> getParticipantInboxThreadsQueryBuilder ( $ participant ) -> getQuery ( ) ; return $ this -> createPaginator ( $ query , $ page , $ limit ) ; } 
public function getSentThreadsPager ( $ page , $ limit = null ) { $ participant = $ this -> getAuthenticatedParticipant ( ) ; $ query = $ this -> threadManager -> getParticipantSentThreadsQueryBuilder ( $ participant ) -> getQuery ( ) ; return $ this -> createPaginator ( $ query , $ page , $ limit ) ; } 
public function getFunctions ( ) : array { return [ new \ Twig_SimpleFunction ( 'get_thread' , [ $ this -> threadManager , 'findThreadById' ] ) , new \ Twig_SimpleFunction ( 'get_thread_by_slug' , [ $ this -> threadManager , 'findThreadBySlug' ] ) , new \ Twig_SimpleFunction ( 'get_threads' , [ $ this , 'getThreads' ] ) , new \ Twig_SimpleFunction ( 'get_threads_pager' , [ $ this -> threadManager , 'findThreadsPager' ] ) , new \ Twig_SimpleFunction ( 'get_topic' , [ $ this -> topicManager , 'findTopicById' ] ) , new \ Twig_SimpleFunction ( 'get_topics' , [ $ this , 'getTopics' ] ) , new \ Twig_SimpleFunction ( 'get_topics_pager' , [ $ this -> topicManager , 'findTopicsPager' ] ) , new \ Twig_SimpleFunction ( 'get_topics_pager_by_thread' , [ $ this -> topicManager , 'findThreadTopics' ] ) , new \ Twig_SimpleFunction ( 'get_reply' , [ $ this -> replyManager , 'findReplyById' ] ) , new \ Twig_SimpleFunction ( 'get_replies' , [ $ this , 'getReplies' ] ) , new \ Twig_SimpleFunction ( 'get_replies_pager' , [ $ this -> replyManager , 'findRepliesPager' ] ) , ] ; } 
public function getThreads ( $ criteria , array $ orderBy = [ ] , ? int $ limit = null ) { if ( $ criteria instanceof Criteria ) { return $ this -> threadManager -> findThreads ( $ criteria ) ; } else { return $ this -> threadManager -> getThreadRepository ( ) -> findBy ( $ criteria , $ orderBy , $ limit ) ; } } 
public function getTopics ( $ criteria , array $ orderBy = [ ] , ? int $ limit = null ) { if ( $ criteria instanceof Criteria ) { return $ this -> topicManager -> findTopics ( $ criteria ) ; } else { return $ this -> topicManager -> getTopicRepository ( ) -> findBy ( $ criteria , $ orderBy , $ limit ) ; } } 
public function getReplies ( $ criteria , array $ orderBy = [ ] , ? int $ limit = null ) { if ( $ criteria instanceof Criteria ) { return $ this -> replyManager -> findReplies ( $ criteria ) ; } else { return $ this -> replyManager -> getReplyRepository ( ) -> findBy ( $ criteria , $ orderBy , $ limit ) ; } } 
public function upload ( UploadedFile $ uploadedFile ) { $ file = $ this -> fileFactory -> createFileFromUploadedFile ( $ uploadedFile ) ; $ this -> fileManager -> upload ( $ file , true ) ; return $ file ; } 
public function findCommentsPager ( Criteria $ criteria , $ page = 1 , $ limit = null ) { $ query = $ this -> getCommentRepository ( ) -> createQueryBuilder ( 'c' ) -> join ( 'c.user' , 'cu' ) -> addSelect ( 'cu' ) -> addCriteria ( $ criteria ) -> getQuery ( ) ; return $ this -> createPaginator ( $ query , $ page , $ limit ) ; } 
public function findComments ( Criteria $ criteria ) { return $ this -> getCommentRepository ( ) -> createQueryBuilder ( 'c' ) -> join ( 'c.user' , 'cu' ) -> addSelect ( 'cu' ) -> addCriteria ( $ criteria ) -> getQuery ( ) -> getResult ( ) ; } 
public function createComment ( PostInterface $ post , UserInterface $ user ) { $ comment = new $ this -> commentEntity ; $ comment -> setPost ( $ post ) -> setUser ( $ user ) ; $ post -> addCommentCount ( ) ; return $ comment ; } 
public function saveComment ( CommentInterface $ comment ) { $ new = ! $ comment -> getId ( ) ; $ parsedBody = $ this -> bodyProcessor -> process ( $ comment -> getOriginalBody ( ) ) ; $ comment -> setUpdatedAt ( Carbon :: now ( ) ) -> setBody ( $ parsedBody ) ; 
public function addVoter ( CommentInterface $ comment , UserInterface $ user ) { $ comment -> addVoter ( $ user ) -> addVoteCount ( ) ; $ this -> entityManager -> persist ( $ comment ) ; $ this -> entityManager -> flush ( ) ; 
public function removeVoter ( CommentInterface $ comment , UserInterface $ user ) { $ comment -> removeVoter ( $ user ) -> addVoteCount ( - 1 ) ; $ this -> entityManager -> persist ( $ comment ) ; $ this -> entityManager -> flush ( ) ; } 
public function getCommentRepository ( ) { if ( $ this -> commentRepository ) { return $ this -> commentRepository ; } return $ this -> entityManager -> getRepository ( $ this -> commentEntity ) ; } 
public function load ( $ resource , $ type = null ) { $ routes = new RouteCollection ( ) ; foreach ( $ this -> routerResources as $ resource ) { $ type = pathinfo ( $ resource , PATHINFO_EXTENSION ) ; if ( $ type === 'yml' ) { $ type = 'yaml' ; } $ importedRoutes = $ this -> import ( $ resource , $ type ) ; $ routes -> addCollection ( $ importedRoutes ) ; } return $ routes ; } 
public function indexAction ( Request $ request ) { $ postManager = $ this -> getPostManager ( ) ; $ posts = $ postManager -> findLatestPosts ( $ request -> query -> getInt ( 'page' , 1 ) ) ; $ topics = $ this -> getTopicManager ( ) -> findHotTopics ( Carbon :: now ( ) -> addDays ( - 10 ) , 15 ) ; return $ this -> render ( 'PHPDishWebBundle:Default:index.html.twig' , [ 'posts' => $ posts , 'topics' => $ topics , ] ) ; } 
public function countNotificationAction ( ) { $ this -> denyAccessUnlessGranted ( 'IS_AUTHENTICATED_REMEMBERED' ) ; $ count = $ this -> get ( 'phpdish_notification.manager.notification' ) -> getNotificationCount ( $ this -> getUser ( ) , false ) ; $ nbMessageCount = $ this -> get ( 'fos_message.provider' ) -> getNbUnreadMessages ( ) ; return $ this -> json ( [ 'count' => $ count + $ nbMessageCount , ] ) ; } 
public function getNbResults ( ) { return $ this -> indexManager -> count ( $ this -> query , $ this -> entityClass , $ this -> options ) ; } 
public function getSlice ( $ offset , $ length ) { return array_filter ( $ this -> indexManager -> search ( $ this -> query , $ this -> entityClass , $ this -> entityManager , $ offset / $ length + 1 , $ length , $ this -> options ) ) ; } 
public function autoCompleteAction ( Request $ request ) { $ query = $ request -> query -> get ( 'query' ) ; $ threads = $ this -> getThreadManager ( ) -> searchThreads ( $ query ) ; return $ this -> json ( [ 'threads' => $ threads ] ) ; } 
public function hotThreadsAction ( ) { $ threads = $ this -> getThreadManager ( ) -> findEnabledThreads ( 15 ) ; return $ this -> render ( $ this -> configuration -> getTemplate ( 'Thread:_hot_threads.html.twig' ) , [ 'threads' => $ threads ] ) ; } 
public function indexAction ( Request $ request ) { $ criteria = Criteria :: create ( ) -> where ( Criteria :: expr ( ) -> eq ( 'enabled' , true ) ) -> orderBy ( [ 'followerCount' => 'desc' , 'createdAt' => 'desc' , ] ) ; if ( $ request -> query -> get ( 'tab' ) === 'following' ) { $ threads = $ this -> getThreadManager ( ) -> findUserFollowingThreads ( $ this -> getUser ( ) , $ request -> query -> getInt ( 'page' , 1 ) , null , $ criteria ) ; } else { $ threads = $ this -> getThreadManager ( ) -> findThreadsPager ( $ criteria , $ request -> query -> getInt ( 'page' , 1 ) ) ; } $ translator = $ this -> get ( 'translator' ) ; $ seoPage = $ this -> get ( 'sonata.seo.page' ) ; $ seoPage -> setTitle ( $ translator -> trans ( 'thread.explore' ) ) -> removeMeta ( 'name' , 'keywords' ) -> addMeta ( 'name' , 'description' , $ translator -> trans ( 'thread.explore' ) ) -> addMeta ( 'property' , 'og:title' , $ translator -> trans ( 'thread.explore' ) ) -> addMeta ( 'property' , 'og:url' , $ this -> generateUrl ( 'threads' , [ ] , UrlGeneratorInterface :: ABSOLUTE_URL ) ) -> addMeta ( 'property' , 'og:description' , $ translator -> trans ( 'thread.explore' ) ) ; return $ this -> render ( $ this -> configuration -> getTemplate ( 'Thread:index.html.twig' ) , [ 'threads' => $ threads ] ) ; } 
public function viewAction ( $ slug , Request $ request ) { $ thread = $ this -> getThreadManager ( ) -> findThreadBySlug ( $ slug ) ; if ( ! $ thread ) { throw $ this -> createNotFoundException ( ) ; } $ criteria = Criteria :: create ( ) ; $ criteria -> orderBy ( [ 'lastCommentAt' => 'desc' ] ) -> where ( Criteria :: expr ( ) -> eq ( 'enabled' , true ) ) ; $ tab = $ request -> query -> get ( 'tab' ) ; if ( $ tab && $ tab === 'recommend' ) { $ criteria -> andWhere ( Criteria :: expr ( ) -> eq ( 'recommended' , true ) ) ; } $ topics = $ this -> getTopicManager ( ) -> findThreadTopics ( $ thread , $ request -> query -> getInt ( 'page' , 1 ) , null , $ criteria ) ; 
public function editAction ( $ slug , Request $ request ) { $ thread = $ this -> getThreadManager ( ) -> findThreadBySlug ( $ slug ) ; if ( ! $ thread ) { throw $ this -> createNotFoundException ( ) ; } $ this -> denyAccessUnlessGranted ( 'edit' , $ thread ) ; $ form = $ this -> createForm ( ThreadType :: class , $ thread ) ; $ form -> handleRequest ( $ request ) ; if ( $ form -> isValid ( ) && $ form -> isSubmitted ( ) ) { $ this -> getThreadManager ( ) -> saveThread ( $ thread ) ; $ this -> addFlash ( 'success' , $ this -> get ( 'translator' ) -> trans ( 'thread.edit_success' ) ) ; return $ this -> redirectToRoute ( 'thread_view' , [ 'slug' => $ thread -> getSlug ( ) , ] ) ; } return $ this -> render ( $ this -> configuration -> getTemplate ( 'Thread:create.html.twig' ) , [ 'thread' => $ thread , 'form' => $ form -> createView ( ) ] ) ; } 
public function followAction ( $ slug ) { $ this -> denyAccessUnlessGranted ( 'IS_AUTHENTICATED_REMEMBERED' ) ; $ thread = $ this -> getThreadManager ( ) -> findThreadBySlug ( $ slug ) ; $ this -> getThreadManager ( ) -> followThread ( $ thread , $ this -> getUser ( ) ) ; return $ this -> json ( [ 'follower_count' => $ thread -> getFollowerCount ( ) , ] ) ; } 
public function unFollowAction ( $ slug ) { $ this -> denyAccessUnlessGranted ( 'IS_AUTHENTICATED_REMEMBERED' ) ; $ thread = $ this -> getThreadManager ( ) -> findThreadBySlug ( $ slug ) ; $ this -> getThreadManager ( ) -> unFollowThread ( $ thread , $ this -> getUser ( ) ) ; return $ this -> json ( [ 'follower_count' => $ thread -> getFollowerCount ( ) , ] ) ; } 
public function getConfigTreeBuilder ( ) { $ treeBuilder = new TreeBuilder ( ) ; $ rootNode = $ treeBuilder -> root ( 'phpdish_permission' ) ; $ rootNode -> children ( ) -> arrayNode ( 'resources' ) -> children ( ) -> arrayNode ( 'privileger' ) -> children ( ) -> scalarNode ( 'interface' ) -> defaultValue ( PrivilegerInterface :: class ) -> cannotBeEmpty ( ) -> end ( ) -> scalarNode ( 'model' ) -> cannotBeEmpty ( ) -> end ( ) -> end ( ) -> end ( ) -> arrayNode ( 'role' ) -> children ( ) -> scalarNode ( 'interface' ) -> defaultValue ( RoleInterface :: class ) -> cannotBeEmpty ( ) -> end ( ) -> scalarNode ( 'model' ) -> defaultValue ( Role :: class ) -> cannotBeEmpty ( ) -> end ( ) -> end ( ) -> end ( ) -> arrayNode ( 'permission' ) -> children ( ) -> scalarNode ( 'interface' ) -> defaultValue ( PermissionInterface :: class ) -> cannotBeEmpty ( ) -> end ( ) -> scalarNode ( 'model' ) -> defaultValue ( Permission :: class ) -> cannotBeEmpty ( ) -> end ( ) -> end ( ) -> end ( ) -> end ( ) -> end ( ) -> end ( ) ; return $ treeBuilder ; } 
public function process ( ContainerBuilder $ container ) { if ( $ changePassword = $ container -> findDefinition ( 'fos_user.resetting.controller' ) ) { $ changePassword -> setClass ( ResettingController :: class ) -> addMethodCall ( 'setResourceConfiguration' , [ new Reference ( 'phpdish_resource.configuration.phpdish_user' ) ] ) ; } } 
public function findCategories ( Criteria $ criteria ) { return $ this -> getCategoryRepository ( ) -> createQueryBuilder ( 'c' ) -> addCriteria ( $ criteria ) -> getQuery ( ) -> getResult ( ) ; } 
public function findCategoriesPager ( Criteria $ criteria , $ page , $ limit = null ) { $ query = $ this -> getCategoryRepository ( ) -> createQueryBuilder ( 'c' ) -> addCriteria ( $ criteria ) -> getQuery ( ) ; return $ this -> createPaginator ( $ query , $ page , $ limit ) ; } 
public function findAllEnabledCategories ( ) { $ criteria = Criteria :: create ( ) -> where ( Criteria :: expr ( ) -> eq ( 'enabled' , true ) ) ; return $ this -> findCategories ( $ criteria ) ; } 
public function findUserCategories ( UserInterface $ user ) { return $ this -> createGetUserCategoriesQueryBuilder ( $ user ) -> andWhere ( 'c.isBook = :isBook' ) -> setParameter ( 'isBook' , false ) -> getQuery ( ) -> getResult ( ) ; } 
public function getUserCategoriesNumber ( UserInterface $ user ) { $ qb = $ this -> createGetUserCategoriesQueryBuilder ( $ user ) -> andWhere ( 'c.isBook = :isBook' ) -> setParameter ( 'isBook' , false ) ; return ( int ) $ qb -> select ( $ qb -> expr ( ) -> count ( 'c' ) ) -> getQuery ( ) -> getSingleScalarResult ( ) ; } 
public function createGetUserCategoriesQueryBuilder ( UserInterface $ user ) { return $ this -> getCategoryRepository ( ) -> createQueryBuilder ( 'c' ) -> where ( 'c.creator = :userId' ) -> setParameter ( 'userId' , $ user -> getId ( ) ) -> orderBy ( 'c.createdAt' , 'desc' ) ; } 
public function addManagerForCategory ( CategoryInterface $ category , UserInterface $ user ) { $ category -> addManager ( $ user ) ; return $ this -> saveCategory ( $ category ) ; } 
public function addCategoryIncome ( UserInterface $ user , CategoryInterface $ category , UserInterface $ follower , $ amount = null ) { $ wallet = $ this -> walletManager -> getUserWallet ( $ user ) ; $ history = $ this -> walletManager -> createHistory ( ) ; if ( $ category -> isBook ( ) ) { $ description = $ this -> translator -> trans ( 'payment.buy_your_book' , [ '%username%' => sprintf ( '<a href="%s">%s</a>' , $ this -> router -> generate ( 'user_view' , [ 'username' => $ follower -> getUsername ( ) ] ) , $ follower -> getUsername ( ) ) , '%book%' => sprintf ( '<a href="%s">《%s》</a>', $ this -> router -> generate ( 'book_view' , [ 'slug' => $ category -> getSlug ( ) ] ) , $ category -> getName ( ) ) , ] ) ; } else { $ description = $ this -> translator -> trans ( 'payment.subscribe_your_category' , [ '%username%' => sprintf ( '<a href="%s">%s</a>' , $ this -> router -> generate ( 'user_view' , [ 'username' => $ follower -> getUsername ( ) ] ) , $ follower -> getUsername ( ) ) , '%category%' => sprintf ( '<a href="%s">《%s》</a>', $ this -> router -> generate ( 'category_view' , [ 'slug' => $ category -> getSlug ( ) ] ) , $ category -> getName ( ) ) , ] ) ; } 
public function payForCategory ( CategoryInterface $ category , UserInterface $ user ) { if ( $ category -> isCharging ( ) ) { 
public function followCategory ( CategoryInterface $ category , UserInterface $ user ) { $ category -> addFollower ( $ user ) ; $ category -> setFollowerCount ( $ category -> getFollowerCount ( ) + 1 ) ; $ result = $ this -> saveCategory ( $ category ) ; 
public function unFollowCategory ( CategoryInterface $ category , UserInterface $ user ) { $ category -> removeFollower ( $ user ) ; $ category -> setFollowerCount ( $ category -> getFollowerCount ( ) - 1 ? : 0 ) ; return $ this -> saveCategory ( $ category ) ; } 
public function createCategory ( UserInterface $ user ) { $ category = new $ this -> categoryEntity ; $ category -> setCreator ( $ user ) -> setCreatedAt ( Carbon :: now ( ) ) ; return $ category ; } 
public function saveCategory ( CategoryInterface $ category ) { $ event = new CategoryPersistEvent ( $ category ) ; $ this -> eventDispatcher -> dispatch ( Events :: CATEGORY_PRE_PERSIST , $ event ) ; if ( $ event -> isPersistenceAborted ( ) ) { return false ; } $ category -> setUpdatedAt ( Carbon :: now ( ) ) ; $ this -> entityManager -> persist ( $ category ) ; $ this -> entityManager -> flush ( ) ; return true ; } 
public function createTopic ( UserInterface $ user ) { $ topic = new $ this -> topicEntity ; $ now = Carbon :: now ( ) ; $ topic -> setUser ( $ user ) -> setLastCommentAt ( $ now ) -> setCreatedAt ( $ now ) -> setLastCommentUser ( $ user ) ; return $ topic ; } 
public function saveTopic ( TopicInterface $ topic ) { $ parsedBody = $ this -> bodyProcessor -> process ( $ topic -> getOriginalBody ( ) ) ; $ topic -> setUpdatedAt ( Carbon :: now ( ) ) -> setBody ( $ parsedBody ) ; 
public function blockTopic ( TopicInterface $ topic ) { $ topic -> disable ( ) ; $ this -> entityManager -> persist ( $ topic ) ; $ this -> entityManager -> flush ( ) ; } 
public function findThreadTopics ( ThreadInterface $ thread , $ page , $ limit = null , Criteria $ criteria = null ) { $ qb = $ this -> getTopicRepository ( ) -> createQueryBuilder ( 't' ) -> innerJoin ( 't.threads' , 'th' ) -> where ( 'th.id = :threadId' ) -> setParameter ( 'threadId' , $ thread ) ; $ criteria && $ qb -> addCriteria ( $ criteria ) ; return $ this -> createPaginator ( $ qb -> getQuery ( ) , $ page , $ limit ) ; } 
public function findUserTopics ( UserInterface $ user , $ page , $ limit = null ) { $ criteria = Criteria :: create ( ) -> where ( Criteria :: expr ( ) -> eq ( 'user' , $ user -> getId ( ) ) ) -> orderBy ( [ 'createdAt' => 'DESC' , ] ) ; return $ this -> findTopicsPager ( $ criteria , $ page , $ limit ) ; } 
public function findTopicsPager ( Criteria $ criteria , $ page , $ limit = null ) { $ query = $ this -> getTopicRepository ( ) -> createQueryBuilder ( 't' ) -> addCriteria ( $ criteria ) -> getQuery ( ) ; return $ this -> createPaginator ( $ query , $ page , $ limit ) ; } 
public function findTopics ( Criteria $ criteria ) { return $ this -> getTopicRepository ( ) -> createQueryBuilder ( 't' ) -> addCriteria ( $ criteria ) -> getQuery ( ) -> getResult ( ) ; } 
public function findHotTopics ( \ DateTime $ date , $ limit ) { $ criteria = Criteria :: create ( ) -> where ( Criteria :: expr ( ) -> gt ( 'createdAt' , $ date ) ) -> andWhere ( Criteria :: expr ( ) -> eq ( 'enabled' , true ) ) -> orderBy ( [ 'commentCount' => 'desc' , 'createdAt' => 'desc' ] ) -> setMaxResults ( $ limit ) ; return $ this -> findTopics ( $ criteria ) ; } 
public function findFollowingThreadsTopicsQuery ( UserInterface $ user , Criteria $ criteria = null ) { $ qb = $ this -> getTopicRepository ( ) -> createQueryBuilder ( 't' ) -> leftJoin ( 't.threads' , 'tt' ) -> leftJoin ( 'tt.followers' , 'f' ) -> where ( 'f.id = :userId' ) -> setParameter ( 'userId' , $ user ) -> orderBy ( 't.createdAt' , 'desc' ) ; if ( $ criteria ) { $ qb -> addCriteria ( $ criteria ) ; } return $ qb -> getQuery ( ) ; } 
public function findFollowingThreadsTopics ( UserInterface $ user , $ page , $ limit = null ) { $ query = $ this -> findFollowingThreadsTopicsQuery ( $ user , Criteria :: create ( ) -> where ( Criteria :: expr ( ) -> eq ( 'enabled' , true ) ) ) ; return $ this -> createPaginator ( $ query , $ page , $ limit ) ; } 
public function getUserTopicCount ( UserInterface $ user ) { $ qb = $ this -> getTopicRepository ( ) -> createQueryBuilder ( 'p' ) ; $ qb -> select ( $ qb -> expr ( ) -> count ( 'p' ) ) -> where ( 'p.enabled = :enabled' ) -> setParameter ( 'enabled' , true ) -> andWhere ( 'p.user = :user' ) -> setParameter ( 'user' , $ user ) ; return $ qb -> getQuery ( ) -> getSingleScalarResult ( ) ; } 
public function addVoter ( TopicInterface $ topic , UserInterface $ user ) { $ topic -> addVoter ( $ user ) -> addVoteCount ( ) ; $ this -> saveTopic ( $ topic ) ; $ event = new VoteTopicEvent ( $ topic , $ user ) ; $ this -> eventDispatcher -> dispatch ( Events :: TOPIC_VOTED , $ event ) ; } 
public function removeVoter ( TopicInterface $ topic , UserInterface $ user ) { $ topic -> removeVoter ( $ user ) -> addVoteCount ( - 1 ) ; $ this -> saveTopic ( $ topic ) ; } 
public function postPersist ( PostInterface $ post , LifecycleEventArgs $ event ) { $ user = $ post -> getUser ( ) ; $ this -> handleUserPostCount ( $ user ) ; } 
protected function handleUserPostCount ( UserInterface $ user ) { $ count = $ this -> postManager -> getUserPostCount ( $ user ) ; $ user -> setPostCount ( $ count ) ; $ this -> userManager -> saveUser ( $ user ) ; } 
public function requestAction ( ) { $ form = $ this -> createForm ( ResettingRequestType :: class , null , [ 'action' => $ this -> generateUrl ( 'fos_user_resetting_send_email' ) ] ) ; return $ this -> render ( $ this -> configuration -> getTemplate ( 'Resetting:request.html.twig' ) , [ 'form' => $ form -> createView ( ) , 'lastUsername' => $ this -> get ( 'session' ) -> get ( static :: LAST_USERNAME_SESSION_KEY ) ? : '' ] ) ; } 
public function sendEmailAction ( Request $ request ) { $ form = $ this -> createForm ( ResettingRequestType :: class ) ; $ form -> handleRequest ( $ request ) ; if ( $ form -> isSubmitted ( ) && $ form -> isValid ( ) ) { $ this -> getEventDispatcher ( ) -> addListener ( FOSUserEvents :: RESETTING_SEND_EMAIL_INITIALIZE , [ $ this , 'onSendEmailInitialize' ] ) ; return parent :: sendEmailAction ( $ request ) ; } 
public function onSendEmailInitialize ( GetResponseNullableUserEvent $ event ) { $ response = $ this -> redirectToRoute ( 'fos_user_resetting_request' ) ; $ translator = $ this -> get ( 'translator' ) ; if ( $ event -> getUser ( ) === null ) { $ this -> addFlash ( 'danger' , $ translator -> trans ( 'resetting.username_or_email_not_exists' ) ) ; $ event -> setResponse ( $ response ) ; } elseif ( ! $ event -> getUser ( ) -> getEmail ( ) ) { $ this -> addFlash ( 'warning' , $ translator -> trans ( 'resetting.user_missing_email' ) ) ; $ event -> setResponse ( $ response ) ; } } 
public function getConfigTreeBuilder ( ) { $ treeBuilder = new TreeBuilder ( ) ; $ rootNode = $ treeBuilder -> root ( 'phpdish_notification' ) ; $ rootNode -> children ( ) -> arrayNode ( 'resources' ) -> children ( ) -> arrayNode ( 'notification' ) -> children ( ) -> scalarNode ( 'interface' ) -> defaultValue ( NotificationInterface :: class ) -> cannotBeEmpty ( ) -> end ( ) -> scalarNode ( 'model' ) -> defaultValue ( Notification :: class ) -> cannotBeEmpty ( ) -> end ( ) -> end ( ) -> end ( ) -> arrayNode ( 'notification_metadata' ) -> children ( ) -> scalarNode ( 'interface' ) -> defaultValue ( NotificationMetadataInterface :: class ) -> cannotBeEmpty ( ) -> end ( ) -> scalarNode ( 'model' ) -> defaultValue ( NotificationMetadata :: class ) -> cannotBeEmpty ( ) -> end ( ) -> end ( ) -> end ( ) -> end ( ) -> end ( ) -> end ( ) ; $ this -> addTemplatesSection ( $ rootNode ) ; return $ treeBuilder ; } 
public function parse ( $ body ) { $ this -> parsedBody = $ body ; $ this -> mentionedNames = static :: extractUserNames ( $ body ) ; if ( $ this -> mentionedNames ) { $ this -> mentionedUsers = $ this -> adapter -> findUsers ( $ this -> mentionedNames ) ; foreach ( $ this -> mentionedUsers as $ user ) { $ search = '@' . $ user -> getUsername ( ) ; $ replace = $ this -> adapter -> createUserLink ( $ user ) ; $ this -> parsedBody = str_replace ( $ search , $ replace , $ this -> parsedBody ) ; } } return $ this ; } 
public function getConfigTreeBuilder ( ) { $ treeBuilder = new TreeBuilder ( ) ; $ rootNode = $ treeBuilder -> root ( 'phpdish_forum' ) ; $ rootNode -> children ( ) -> arrayNode ( 'resources' ) -> children ( ) -> arrayNode ( 'topic' ) -> children ( ) -> scalarNode ( 'interface' ) -> defaultValue ( TopicInterface :: class ) -> cannotBeEmpty ( ) -> end ( ) -> scalarNode ( 'model' ) -> defaultValue ( Topic :: class ) -> cannotBeEmpty ( ) -> end ( ) -> end ( ) -> end ( ) -> arrayNode ( 'reply' ) -> children ( ) -> scalarNode ( 'interface' ) -> defaultValue ( ReplyInterface :: class ) -> cannotBeEmpty ( ) -> end ( ) -> scalarNode ( 'model' ) -> defaultValue ( Reply :: class ) -> cannotBeEmpty ( ) -> end ( ) -> end ( ) -> end ( ) -> arrayNode ( 'thread' ) -> children ( ) -> scalarNode ( 'interface' ) -> defaultValue ( ThreadInterface :: class ) -> cannotBeEmpty ( ) -> end ( ) -> scalarNode ( 'model' ) -> defaultValue ( Thread :: class ) -> cannotBeEmpty ( ) -> end ( ) -> end ( ) -> end ( ) -> end ( ) -> end ( ) -> end ( ) ; $ this -> addTemplatesSection ( $ rootNode ) ; return $ treeBuilder ; } 
public function createFollowUserNotification ( UserInterface $ follower ) { $ notification = $ this -> notificationManager -> createNotification ( $ this -> translator -> trans ( 'notification.follow_user.subject' , [ '%username%' => $ follower -> getUsername ( ) , '%url%' => $ this -> router -> generate ( 'user_view' , [ 'username' => $ follower -> getUsername ( ) ] ) ] ) ) ; $ notification -> addParameters ( [ 'subject' => Notification :: SUBJECT_FOLLOW_USER , 'follower_id' => $ follower -> getId ( ) , 'follower_username' => $ follower -> getUsername ( ) , ] ) ; return $ notification ; } 
public function createReplyTopicNotification ( TopicInterface $ topic , ReplyInterface $ reply ) { $ notification = $ this -> notificationManager -> createNotification ( $ this -> translator -> trans ( 'notification.reply_topic.subject' , [ '%userUrl%' => $ this -> router -> generate ( 'user_view' , [ 'username' => $ reply -> getUser ( ) -> getUsername ( ) ] ) , '%username%' => $ reply -> getUser ( ) -> getUsername ( ) , '%topicUrl%' => $ this -> router -> generate ( 'topic_view' , [ 'id' => $ topic -> getId ( ) ] ) , '%topicTitle%' => $ topic -> getTitle ( ) ] ) , $ reply -> getBody ( ) ) ; $ notification -> addParameters ( [ 'subject' => Notification :: SUBJECT_REPLY_TOPIC , 'topic_id' => $ topic -> getId ( ) , 'reply_id' => $ reply -> getId ( ) , 'reply_user_id' => $ reply -> getUser ( ) -> getId ( ) , 'reply_user_username' => $ reply -> getUser ( ) -> getUsername ( ) , ] ) ; return $ notification ; } 
public function createCommentPostNotification ( PostInterface $ post , CommentInterface $ comment ) { $ notification = $ this -> notificationManager -> createNotification ( $ this -> translator -> trans ( 'notification.comment_post.subject' , [ '%userUrl%' => $ this -> router -> generate ( 'user_view' , [ 'username' => $ comment -> getUser ( ) -> getUsername ( ) ] ) , '%username%' => $ comment -> getUser ( ) -> getUsername ( ) , '%postUrl%' => $ this -> router -> generate ( 'post_view' , [ 'id' => $ post -> getId ( ) ] ) , '%postTitle%' => $ post -> getTitle ( ) ] ) , $ comment -> getBody ( ) ) ; $ notification -> addParameters ( [ 'subject' => Notification :: SUBJECT_COMMENT_POST , 'post_id' => $ post -> getId ( ) , 'comment_id' => $ comment -> getId ( ) , 'comment_user_id' => $ comment -> getUser ( ) -> getId ( ) , 'comment_user_username' => $ comment -> getUser ( ) -> getUsername ( ) , ] ) ; return $ notification ; } 
public function createMentionUserInPostNotification ( CommentInterface $ comment ) { $ notification = $ this -> notificationManager -> createNotification ( $ this -> translator -> trans ( 'notification.mention_user_post.subject' , [ '%userUrl%' => $ this -> router -> generate ( 'user_view' , [ 'username' => $ comment -> getUser ( ) -> getUsername ( ) ] ) , '%username%' => $ comment -> getUser ( ) -> getUsername ( ) , '%postUrl%' => $ this -> router -> generate ( 'post_view' , [ 'id' => $ comment -> getPost ( ) -> getId ( ) ] ) , '%postTitle%' => $ comment -> getPost ( ) -> getTitle ( ) ] ) ) ; $ notification -> addParameters ( [ 'subject' => Notification :: SUBJECT_MENTION_USER_IN_POST , 'post_id' => $ comment -> getPost ( ) -> getId ( ) , 'comment_id' => $ comment -> getId ( ) , 'comment_user_id' => $ comment -> getUser ( ) -> getId ( ) , 'comment_user_username' => $ comment -> getUser ( ) -> getUsername ( ) , ] ) ; return $ notification ; } 
public function createMentionUserInTopicNotification ( ReplyInterface $ reply ) { $ notification = $ this -> notificationManager -> createNotification ( $ this -> translator -> trans ( 'notification.mention_user_topic.subject' , [ '%userUrl%' => $ this -> router -> generate ( 'user_view' , [ 'username' => $ reply -> getUser ( ) -> getUsername ( ) ] ) , '%username%' => $ reply -> getUser ( ) -> getUsername ( ) , '%topicUrl%' => $ this -> router -> generate ( 'post_view' , [ 'id' => $ reply -> getTopic ( ) -> getId ( ) ] ) , '%topicTitle%' => $ reply -> getTopic ( ) -> getTitle ( ) ] ) ) ; $ notification -> addParameters ( [ 'subject' => Notification :: SUBJECT_MENTION_USER_IN_TOPIC , 'topic_id' => $ reply -> getTopic ( ) -> getId ( ) , 'reply_id' => $ reply -> getId ( ) , 'reply_user_id' => $ reply -> getUser ( ) -> getId ( ) , 'reply_user_username' => $ reply -> getUser ( ) -> getUsername ( ) , ] ) ; return $ notification ; } 
public function createFollowCategoryNotification ( CategoryInterface $ category , UserInterface $ follower ) { if ( $ category -> isBook ( ) ) { $ notification = $ this -> notificationManager -> createNotification ( $ this -> translator -> trans ( 'notification.follow_book.subject' , [ '%userUrl%' => $ this -> router -> generate ( 'user_view' , [ 'username' => $ follower -> getUsername ( ) ] ) , '%username%' => $ follower -> getUsername ( ) , '%bookUrl%' => $ this -> router -> generate ( 'book_view' , [ 'slug' => $ category -> getSlug ( ) ] ) , '%bookTitle%' => $ category -> getName ( ) ] ) ) ; } else { $ notification = $ this -> notificationManager -> createNotification ( $ this -> translator -> trans ( 'notification.follow_category.subject' , [ '%userUrl%' => $ this -> router -> generate ( 'user_view' , [ 'username' => $ follower -> getUsername ( ) ] ) , '%username%' => $ follower -> getUsername ( ) , '%categoryUrl%' => $ this -> router -> generate ( 'category_view' , [ 'slug' => $ category -> getSlug ( ) ] ) , '%categoryTitle%' => $ category -> getName ( ) ] ) ) ; } $ notification -> addParameters ( [ 'subject' => Notification :: SUBJECT_FOLLOW_CATEGORY , 'category_id' => $ category -> getId ( ) , 'follower_id' => $ follower -> getId ( ) , 'follower_username' => $ follower -> getUsername ( ) , ] ) ; return $ notification ; } 
public function createWithdrawNotification ( PaymentInterface $ payment ) { $ message = $ payment -> getStatus ( ) === PaymentInterface :: STATUS_OK ? $ this -> translator -> trans ( 'notification.withdraw.subject.your_withdraw_was_approved' , [ '%payment%' => $ payment -> getDescription ( ) ] ) : $ this -> translator -> trans ( 'notification.withdraw.subject.your_withdraw_was_declined' , [ '%payment%' => $ payment -> getDescription ( ) ] ) ; $ notification = $ this -> notificationManager -> createNotification ( $ this -> translator -> trans ( 'notification.withdraw.subject' ) , $ message ) ; $ notification -> addParameters ( [ 'subject' => Notification :: SUBJECT_HANDLE_WITHDRAW , 'payment_id' => $ payment -> getId ( ) , 'payment_serial_no' => $ payment -> getSerialNo ( ) , ] ) ; return $ notification ; } 
public function createVoteTopicNotification ( TopicInterface $ topic , UserInterface $ user ) { $ notification = $ this -> notificationManager -> createNotification ( $ this -> translator -> trans ( 'notification.vote_topic.subject' , [ '%userUrl%' => $ this -> router -> generate ( 'user_view' , [ 'username' => $ user -> getUsername ( ) ] ) , '%username%' => $ user -> getUsername ( ) , '%topicUrl%' => $ this -> router -> generate ( 'topic_view' , [ 'id' => $ topic -> getId ( ) ] ) , '%topicTitle%' => $ topic -> getTitle ( ) ] ) ) ; $ notification -> addParameters ( [ 'subject' => Notification :: SUBJECT_VOTE_TOPIC , 'topic_id' => $ topic -> getId ( ) , 'voter_id' => $ user -> getId ( ) , 'voter_username' => $ user -> getUsername ( ) , ] ) ; return $ notification ; } 
public function createVoteReplyNotification ( TopicInterface $ topic , ReplyInterface $ reply , UserInterface $ user ) { $ notification = $ this -> notificationManager -> createNotification ( $ this -> translator -> trans ( 'notification.vote_reply.subject' , [ '%userUrl%' => $ this -> router -> generate ( 'user_view' , [ 'username' => $ user -> getUsername ( ) ] ) , '%username%' => $ user -> getUsername ( ) , '%topicUrl%' => $ this -> router -> generate ( 'topic_view' , [ 'id' => $ topic -> getId ( ) ] ) , '%topicTitle%' => $ topic -> getTitle ( ) ] ) ) ; $ notification -> addParameters ( [ 'subject' => Notification :: SUBJECT_VOTE_REPLY , 'topic_id' => $ topic -> getId ( ) , 'reply_id' => $ reply -> getId ( ) , 'voter_id' => $ user -> getId ( ) , 'voter_username' => $ user -> getUsername ( ) , ] ) ; return $ notification ; } 
public function createVotePostNotification ( PostInterface $ post , UserInterface $ user ) { $ notification = $ this -> notificationManager -> createNotification ( $ this -> translator -> trans ( 'notification.vote_post.subject' , [ '%userUrl%' => $ this -> router -> generate ( 'user_view' , [ 'username' => $ user -> getUsername ( ) ] ) , '%username%' => $ user -> getUsername ( ) , '%postUrl%' => $ this -> router -> generate ( 'post_view' , [ 'id' => $ post -> getId ( ) ] ) , '%postTitle%' => $ post -> getTitle ( ) ] ) ) ; $ notification -> addParameters ( [ 'subject' => Notification :: SUBJECT_VOTE_POST , 'post_id' => $ post -> getId ( ) , 'voter_id' => $ user -> getId ( ) , 'voter_username' => $ user -> getUsername ( ) , ] ) ; return $ notification ; } 
public function createVoteCommentNotification ( PostInterface $ post , CommentInterface $ comment , UserInterface $ user ) { $ notification = $ this -> notificationManager -> createNotification ( $ this -> translator -> trans ( 'notification.vote_comment.subject' , [ '%userUrl%' => $ this -> router -> generate ( 'user_view' , [ 'username' => $ user -> getUsername ( ) ] ) , '%username%' => $ user -> getUsername ( ) , '%postUrl%' => $ this -> router -> generate ( 'post_view' , [ 'id' => $ post -> getId ( ) ] ) , '%postTitle%' => $ post -> getTitle ( ) ] ) ) ; $ notification -> addParameters ( [ 'subject' => Notification :: SUBJECT_VOTE_COMMENT , 'post_id' => $ post -> getId ( ) , 'comment_id' => $ comment -> getId ( ) , 'voter_id' => $ user -> getId ( ) , 'voter_username' => $ user -> getUsername ( ) , ] ) ; return $ notification ; } 
public function sendNotification ( $ participant , $ notification ) { $ participants = is_array ( $ participant ) ? $ participant : [ $ participant ] ; $ this -> notificationManager -> sendNotification ( $ participants , $ notification , true ) ; } 
public function userFollowingAction ( UserInterface $ user ) { $ following = $ this -> getUserManager ( ) -> findUserFollowing ( $ user , 1 ) ; return $ this -> render ( $ this -> configuration -> getTemplate ( 'User:user_grid.html.twig' ) , [ 'users' => $ following , ] ) ; } 
public function userFollowersAction ( UserInterface $ user ) { $ following = $ this -> getUserManager ( ) -> findUserFollowers ( $ user , 1 ) ; return $ this -> render ( $ this -> configuration -> getTemplate ( 'User:user_grid.html.twig' ) , [ 'users' => $ following , ] ) ; } 
public function getUserFollowingAction ( $ username , Request $ request ) { $ manager = $ this -> getUserManager ( ) ; $ user = $ manager -> findUserByName ( $ username ) ; $ following = $ manager -> findUserFollowing ( $ user , $ request -> query -> getInt ( 'page' , 1 ) ) ; return $ this -> render ( $ this -> configuration -> getTemplate ( 'User:user_following.html.twig' ) , [ 'user' => $ user , 'users' => $ following , ] ) ; } 
public function getUserFollowersAction ( $ username , Request $ request ) { $ manager = $ this -> getUserManager ( ) ; $ user = $ manager -> findUserByName ( $ username ) ; $ followers = $ manager -> findUserFollowers ( $ user , $ request -> query -> getInt ( 'page' , 1 ) ) ; $ view = $ this -> view ( [ 'user' => $ user , 'followers' => $ followers , ] ) -> setTemplate ( $ this -> configuration -> getTemplate ( 'User:user_followers.html.twig' ) ) ; return $ this -> handleView ( $ view ) ; } 
public function followAction ( $ username ) { $ this -> denyAccessUnlessGranted ( 'IS_AUTHENTICATED_REMEMBERED' ) ; $ manager = $ this -> getUserManager ( ) ; $ user = $ manager -> findUserByName ( $ username ) ; $ view = $ this -> view ( ) ; try { $ manager -> followUser ( $ user , $ this -> getUser ( ) ) ; $ view -> setStatusCode ( static :: HTTP_CREATED ) -> setData ( [ 'follower_count' => $ user -> getFollowerCount ( ) , ] ) ; } catch ( \ Exception $ exception ) { $ view -> setStatusCode ( static :: HTTP_BAD_REQUEST ) -> setData ( [ 'error' => $ exception -> getMessage ( ) , ] ) ; } return $ this -> handleView ( $ view ) ; } 
public function unFollowAction ( $ username ) { $ this -> denyAccessUnlessGranted ( 'IS_AUTHENTICATED_REMEMBERED' ) ; $ manager = $ this -> getUserManager ( ) ; $ user = $ manager -> findUserByName ( $ username ) ; $ view = $ this -> view ( ) ; $ manager -> unFollowUser ( $ user , $ this -> getUser ( ) ) ; $ view -> setStatusCode ( static :: HTTP_OK ) -> setData ( [ 'follower_count' => $ user -> getFollowerCount ( ) , ] ) ; return $ this -> handleView ( $ view ) ; } 
public function pointAction ( $ username , Request $ request ) { $ this -> denyAccessUnlessGranted ( 'IS_AUTHENTICATED_REMEMBERED' ) ; $ manager = $ this -> getUserManager ( ) ; $ user = $ manager -> findUserByName ( $ username ) ; $ histories = $ this -> getPointManager ( ) -> findPointHistories ( $ user , $ request -> get ( 'page' , 1 ) ) ; return $ this -> render ( $ this -> configuration -> getTemplate ( 'User:point_history.html.twig' ) , [ 'histories' => $ histories , 'user' => $ user , ] ) ; } 
public function process ( ContainerBuilder $ container ) { 
public function onRegisterSuccess ( FormEvent $ event ) { $ user = $ event -> getForm ( ) -> getData ( ) ; $ response = new RedirectResponse ( $ this -> router -> generate ( 'user_view' , [ 'username' => $ user -> getUsername ( ) , ] ) ) ; $ event -> setResponse ( $ response ) ; } 
public function onResettingResetSuccess ( FormEvent $ event ) { $ response = new RedirectResponse ( $ this -> router -> generate ( 'setting_profile' ) ) ; $ event -> setResponse ( $ response ) ; } 
public function postPersist ( $ user , LifecycleEventArgs $ event ) { $ now = Carbon :: now ( ) ; $ user -> setCreatedAt ( $ now ) -> setUpdatedAt ( $ now ) ; $ user -> setAvatar ( $ this -> avatarGenerator -> generate ( $ user -> getUsername ( ) ) -> getKey ( ) ) ; 
public function process ( $ body ) { $ body = $ this -> markdownParser -> transformMarkdown ( $ body ) ; $ body = $ this -> htmlPurifier -> purify ( $ body ) ; 
public function createWallet ( UserInterface $ user ) { $ wallet = new $ this -> walletEntity ; $ now = Carbon :: now ( ) ; $ wallet -> setUser ( $ user ) -> setCreatedAt ( $ now ) -> setUpdatedAt ( $ now ) ; return $ wallet ; } 
public function saveWallet ( WalletInterface $ wallet ) { $ this -> entityManager -> persist ( $ wallet ) ; $ this -> entityManager -> flush ( ) ; } 
public function addHistory ( WalletInterface $ wallet , WalletHistoryInterface $ history ) { $ wallet -> addHistory ( $ history ) ; 
public function createHistory ( ) { $ history = new $ this -> paymentEntity ; $ now = Carbon :: now ( ) ; $ history -> setUpdatedAt ( $ now ) -> setCreatedAt ( $ now ) ; return $ history ; } 
public function getUserWallet ( UserInterface $ user ) { $ wallet = $ this -> getWalletRepository ( ) -> findOneBy ( [ 'user' => $ user ] ) ; if ( ! $ wallet ) { $ wallet = $ this -> createWallet ( $ user ) ; $ this -> saveWallet ( $ wallet ) ; } $ wallet -> setUser ( $ user ) ; return $ wallet ; } 
public function findUserWalletHistories ( WalletInterface $ wallet , $ page , $ limit = null ) { $ query = $ this -> getHistoryRepository ( ) -> createQueryBuilder ( 'wh' ) -> where ( 'wh.wallet = :wallet' ) -> setParameter ( 'wallet' , $ wallet ) -> orderBy ( 'wh.updatedAt' , 'desc' ) -> getQuery ( ) ; return $ this -> createPaginator ( $ query , $ page , $ limit ) ; } 
public function withdraw ( WalletInterface $ wallet , $ amount , $ alipay ) { $ amount = intval ( $ amount ) ; if ( $ amount < PaymentInterface :: WITHDRAW_MAX_AMOUNT ) { throw new \ LogicException ( $ this -> translator -> trans ( 'withdraw.amount_should_greater_than' , PaymentInterface :: WITHDRAW_MAX_AMOUNT ) ) ; } if ( $ wallet -> getAmount ( ) < $ amount ) { throw new \ LogicException ( $ this -> translator -> trans ( 'withdraw.not_encough_balance' ) ) ; } if ( ! $ alipay ) { throw new \ LogicException ( $ this -> translator -> trans ( 'withdraw.need_provide_alipay' ) ) ; } $ history = $ this -> createHistory ( ) ; $ history -> setType ( PaymentInterface :: TYPE_WITHDRAW ) -> setAmount ( $ amount ) -> setDescription ( '' ) -> setStatus ( PaymentInterface :: STATUS_WAITING ) -> setDescription ( $ this -> translator -> trans ( 'withdraw.to' , [ '%alipay%' => $ alipay ] ) ) -> setUser ( $ wallet -> getUser ( ) ) ; 
public function refuseWithdraw ( WalletHistoryInterface $ history , $ reason = null ) { $ history -> getWallet ( ) -> release ( $ history -> getAmount ( ) ) ; 
public function approveWithdraw ( WalletHistoryInterface $ history , $ reason = null ) { $ wallet = $ history -> getWallet ( ) ; $ wallet -> setFreezeAmount ( $ wallet -> getFreezeAmount ( ) - $ history -> getAmount ( ) ) ; 
protected function execute ( InputInterface $ input , OutputInterface $ output ) { $ outputStyle = new SymfonyStyle ( $ input , $ output ) ; $ outputStyle -> writeln ( 'Creating PHPDish database.' ) ; 
protected function createSchemaWithProgressbar ( OutputInterface $ output ) { ksort ( $ this -> commands ) ; $ this -> bulkRunCommands ( $ this -> commands , $ output , true ) ; } 
protected function isDatabasePresent ( ) { $ connection = $ this -> getContainer ( ) -> get ( 'doctrine.dbal.default_connection' ) ; $ databaseName = $ connection -> getDatabase ( ) ; try { return in_array ( $ databaseName , $ connection -> getSchemaManager ( ) -> listDatabases ( ) ) ; } catch ( \ Exception $ exception ) { $ message = $ exception -> getMessage ( ) ; $ mysqlDatabaseError = false !== strpos ( $ message , sprintf ( "Unknown database '%s'" , $ databaseName ) ) ; $ postgresDatabaseError = false !== strpos ( $ message , sprintf ( 'database "%s" does not exist' , $ databaseName ) ) ; if ( $ mysqlDatabaseError || $ postgresDatabaseError ) { return false ; } throw $ exception ; } } 
public function getRootDir ( ) { if ( null === $ this -> rootDir ) { $ r = new \ ReflectionObject ( $ this ) ; $ dir = $ rootDir = dirname ( $ r -> getFileName ( ) ) ; while ( ! file_exists ( $ dir . '/composer.json' ) ) { if ( $ dir === dirname ( $ dir ) ) { return $ this -> rootDir = $ rootDir ; } $ dir = dirname ( $ dir ) ; } $ this -> rootDir = $ dir ; } return $ this -> rootDir ; } 
public function createReply ( TopicInterface $ topic , UserInterface $ user = null ) { $ reply = new $ this -> replyEntity ; $ reply -> setTopic ( $ topic ) -> setCreatedAt ( Carbon :: now ( ) ) ; $ user && $ reply -> setUser ( $ user ) ; return $ reply ; } 
public function saveReply ( ReplyInterface $ reply ) { $ parsedBody = $ this -> bodyProcessor -> process ( $ reply -> getOriginalBody ( ) ) ; $ reply -> setUpdatedAt ( Carbon :: now ( ) ) -> setBody ( $ parsedBody ) ; if ( $ new = ! $ reply -> getId ( ) ) { $ reply -> getTopic ( ) -> addCommentCount ( 1 ) -> setLastCommentAt ( Carbon :: now ( ) ) -> setLastCommentUser ( $ reply -> getUser ( ) ) ; } $ this -> entityManager -> persist ( $ reply ) ; $ this -> entityManager -> flush ( ) ; 
public function findRepliesPager ( Criteria $ criteria , $ page , $ limit = null ) { $ qb = $ this -> getRepliesQb ( ) -> addCriteria ( $ criteria ) ; return $ this -> createPaginator ( $ qb -> getQuery ( ) , $ page , $ limit ) ; } 
public function findTopicReplies ( TopicInterface $ topic , $ page , $ limit = null , Criteria $ criteria = null ) { $ qb = $ this -> getRepliesQb ( ) -> where ( 'r.topic = :topic' ) -> setParameter ( 'topic' , $ topic ) -> andWhere ( 'r.enabled = :enabled' ) -> setParameter ( 'enabled' , true ) ; if ( $ criteria ) { $ qb -> addCriteria ( $ criteria ) ; } return $ this -> createPaginator ( $ qb -> getQuery ( ) , $ page , $ limit ) ; } 
public function findUserReplies ( UserInterface $ user , $ page , $ limit = null , Criteria $ criteria = null ) { $ qb = $ this -> getReplyRepository ( ) -> createQueryBuilder ( 'r' ) -> addSelect ( 'rt' ) -> join ( 'r.topic' , 'rt' ) -> where ( 'r.user = :user' ) -> setParameter ( 'user' , $ user ) -> andWhere ( 'r.enabled = :enabled' ) -> setParameter ( 'enabled' , true ) -> orderBy ( 'r.createdAt' , 'desc' ) ; if ( $ criteria ) { $ qb -> addCriteria ( $ criteria ) ; } return $ this -> createPaginator ( $ qb -> getQuery ( ) , $ page , $ limit ) ; } 
public function blockReply ( ReplyInterface $ reply ) { $ reply -> disable ( ) ; $ topic = $ reply -> getTopic ( ) ; $ topic -> addCommentCount ( - 1 ) ; $ this -> entityManager -> persist ( $ reply ) ; $ this -> entityManager -> flush ( ) ; return true ; } 
public function replyTopic ( UserInterface $ user , TopicInterface $ topic , $ body ) { $ reply = $ this -> createReply ( $ topic , $ user ) ; $ reply -> setOriginalBody ( $ body ) ; $ this -> saveReply ( $ reply ) ; return $ reply ; } 
public function addVoter ( ReplyInterface $ reply , UserInterface $ user ) { $ reply -> addVoter ( $ user ) -> addVoteCount ( ) ; $ this -> entityManager -> persist ( $ reply ) ; $ this -> entityManager -> flush ( ) ; 
public function removeVoter ( ReplyInterface $ reply , UserInterface $ user ) { $ reply -> removeVoter ( $ user ) -> addVoteCount ( - 1 ) ; $ this -> entityManager -> persist ( $ reply ) ; $ this -> entityManager -> flush ( ) ; } 
public function searchAction ( Request $ request ) { $ keyword = $ request -> query -> get ( 'q' ) ; $ type = $ request -> query -> get ( 'type' , static :: TYPE_TOPIC ) ; $ searchResult = $ this -> searcFrom ( $ keyword , $ type , [ 'length' => 10 , 'page' => $ request -> query -> getInt ( 'page' , 1 ) ] ) ; return $ this -> render ( 'PHPDishWebBundle:Search:result.html.twig' , [ 'searchResult' => $ searchResult , 'keyword' => $ keyword ] ) ; } 
protected function searcFrom ( $ keyword , $ type , $ options ) { $ searchService = $ this -> get ( 'phpdish.searcher' ) ; if ( $ type === static :: TYPE_TOPIC ) { $ searchResult = $ searchService -> queryTopics ( $ keyword , $ options ) ; } elseif ( $ type === static :: TYPE_USER ) { $ searchResult = $ searchService -> queryUsers ( $ keyword , $ options ) ; } else { $ searchResult = $ searchService -> queryPosts ( $ keyword , $ options ) ; } return $ searchResult ; } 
public function transformFromUrl ( $ url ) { $ extension = ExtensionFinder :: find ( $ url ) ; return $ this -> transformWithExtension ( strrchr ( $ url , $ extension ) ) ; } 
public function transformWithExtension ( $ extension ) { $ baseDir = Carbon :: now ( ) -> format ( 'Y/md' ) ; do { $ path = "{$baseDir}/{$this->generateKey()}." . $ extension ; } while ( $ this -> filesystem -> has ( $ path ) ) ; return $ path ; } 
public function getConfigTreeBuilder ( ) { $ treeBuilder = new TreeBuilder ( ) ; $ rootNode = $ treeBuilder -> root ( 'phpdish_payment' ) ; $ rootNode -> children ( ) -> arrayNode ( 'youzan' ) -> children ( ) -> scalarNode ( 'client_id' ) -> cannotBeEmpty ( ) -> end ( ) -> scalarNode ( 'client_secret' ) -> cannotBeEmpty ( ) -> end ( ) -> scalarNode ( 'kdt_id' ) -> cannotBeEmpty ( ) -> end ( ) -> end ( ) -> end ( ) ; $ this -> addResourcesSection ( $ rootNode ) ; $ this -> addTemplatesSection ( $ rootNode ) ; return $ treeBuilder ; } 
public function chunk ( $ html , $ percent ) { $ totalLength = mb_strlen ( $ html ) ; $ reservedLength = intval ( $ totalLength * $ percent ) ; $ chunkHtml = mb_substr ( $ html , 0 , $ reservedLength , 'utf-8' ) ; $ junkTagPattern = '#<img[^>]+$#' ; 
public function addAction ( $ id , Request $ request ) { $ this -> denyAccessUnlessGranted ( 'IS_AUTHENTICATED_REMEMBERED' ) ; $ post = $ this -> getPostManager ( ) -> findPostById ( $ id ) ; $ comment = $ this -> getPostCommentManager ( ) -> createComment ( $ post , $ this -> getUser ( ) ) ; $ form = $ this -> createForm ( CommentType :: class , $ comment ) ; $ form -> handleRequest ( $ request ) ; $ view = $ this -> view ( ) ; if ( $ form -> isSubmitted ( ) && $ form -> isValid ( ) ) { $ this -> getPostCommentManager ( ) -> saveComment ( $ comment ) ; 
public function deleteAction ( $ id ) { $ manager = $ this -> getPostCommentManager ( ) ; $ comment = $ manager -> findCommentById ( $ id ) ; if ( ! $ comment ) { throw $ this -> createNotFoundException ( ) ; } $ this -> denyAccessUnlessGranted ( 'edit' , $ comment ) ; $ manager -> blockComment ( $ comment ) ; return $ this -> handleView ( $ this -> view ( [ 'result' => true , ] ) ) ; } 
public function toggleVoterAction ( $ id ) { $ this -> denyAccessUnlessGranted ( 'IS_AUTHENTICATED_REMEMBERED' ) ; $ comment = $ this -> getPostCommentManager ( ) -> findCommentById ( $ id ) ; if ( ! $ comment ) { throw new \ InvalidArgumentException ( $ this -> get ( 'translator' ) -> trans ( 'comment.not_exists' ) ) ; } if ( $ isVoted = $ comment -> isVotedBy ( $ this -> getUser ( ) ) ) { $ this -> getPostCommentManager ( ) -> removeVoter ( $ comment , $ this -> getUser ( ) ) ; } else { $ this -> getPostCommentManager ( ) -> addVoter ( $ comment , $ this -> getUser ( ) ) ; } return $ this -> json ( [ 'vote_count' => $ comment -> getVoteCount ( ) , 'is_voted' => ! $ isVoted ] ) ; } 
public function createColumn ( $ name , $ type , $ options = [ ] ) { $ column = new Column ( $ name , $ type , $ options [ 'sortable' ] ?? true ) ; if ( $ options [ 'filterable' ] ) { 
public function createGrid ( $ source , $ alias = null ) { $ source = $ this -> createSource ( $ source , $ alias ) ; $ grid = new Grid ( $ source ) ; $ grid -> setFactory ( $ this ) ; return $ grid ; } 
public function getFunctions ( ) { return [ new \ Twig_SimpleFunction ( 'get_user' , [ $ this -> userManager , 'findUserById' ] ) , new \ Twig_SimpleFunction ( 'get_user_by_username' , [ $ this -> userManager , 'findUserByUsername' ] ) , new \ Twig_SimpleFunction ( 'get_user_by_email' , [ $ this -> userManager , 'findUserByEmail' ] ) , new \ Twig_SimpleFunction ( 'get_user_by_username_or_email' , [ $ this -> userManager , 'findUserByUsernameOrEmail' ] ) , new \ Twig_SimpleFunction ( 'get_users' , [ $ this , 'getUsers' ] ) , new \ Twig_SimpleFunction ( 'get_users_pager' , [ $ this -> userManager , 'findUsersPager' ] ) , new \ Twig_SimpleFunction ( 'get_category_authors' , [ $ this , 'getCategoryAuthors' ] ) , ] ; } 
public function getCategoryAuthors ( $ limit = 10 ) { $ qb = $ this -> userManager -> getUserRepository ( ) -> createQueryBuilder ( 'u' ) ; return $ qb -> select ( 'distinct u' ) -> innerJoin ( 'u.categories' , 'c' ) -> where ( 'c.postCount > :postCount' ) -> setParameter ( 'postCount' , 0 ) -> setMaxResults ( $ limit ) -> orderBy ( 'u.updatedAt' , 'desc' ) -> getQuery ( ) -> getResult ( ) ; } 
public function getUsers ( $ criteria , array $ orderBy = [ ] , ? int $ limit = null ) { if ( $ criteria instanceof Criteria ) { return $ this -> userManager -> findUsersByCriteria ( $ criteria ) ; } else { return $ this -> userManager -> getUserRepository ( ) -> findBy ( $ criteria , $ orderBy , $ limit ) ; } } 
public function getPointHistoryLabel ( PointHistoryInterface $ history ) { static $ labels = [ PointHistory :: TYPE_SIGN_IN => 'point.history.type.sign_in' , PointHistory :: TYPE_CHECK_IN => 'point.history.type.check_in' , 
public function load ( ObjectManager $ manager ) { $ user1 = $ this -> getUserManipulator ( ) -> create ( '优雅的风', '12345 6 , 'user1 @ hpdish.com', true, f lse) ; $ user2 = $ this -> getUserManipulator ( ) -> create ( '风中的少年', '123456' , 'user2@p h dish.com', true, fa l e); $ avatarGenerator = $ this -> getAvatarGenerator ( ) ; $ user1 -> setAvatar ( $ avatarGenerator -> generate ( '优雅的风')->getKe y () ); $ user2 -> setAvatar ( $ avatarGenerator -> generate ( '风中的少年')->getKey( ) ); $ userManager = $ this -> getUserManager ( ) ; $ userManager -> updateUser ( $ user1 ) ; $ userManager -> updateUser ( $ user2 ) ; $ this -> addReference ( 'general-user' , $ user1 ) ; } 
protected function createPaginator ( Query $ query , $ page , $ limit = null ) { $ paginator = new Pagerfanta ( new DoctrineORMAdapter ( $ query ) ) ; $ paginator -> setCurrentPage ( $ page ) ; $ paginator -> setMaxPerPage ( $ limit ? : $ this -> getMaxPerPage ( ) ) ; return $ paginator ; } 
protected function execute ( InputInterface $ input , OutputInterface $ output ) { $ checker = $ this -> getContainer ( ) -> get ( 'phpdish.installer.requirements_checker' ) ; $ checker -> setOutput ( $ output ) ; $ fulfilled = $ checker -> check ( $ output ) ; if ( ! $ fulfilled ) { throw new RuntimeException ( 'Some system requirements are not fulfilled. Please check output messages and fix them.' ) ; } $ output -> writeln ( '<info>Success! Your system can run PHPDish properly.</info>' ) ; } 
public function createFileFromUploadedFile ( UploadedFile $ uploadedFile ) { $ file = $ this -> isImage ( $ uploadedFile ) ? new Image ( ) : new File ( ) ; $ file -> setExtension ( $ uploadedFile -> guessExtension ( ) ) -> setSize ( $ uploadedFile -> getSize ( ) ) -> setContentType ( $ uploadedFile -> getMimeType ( ) ) -> setContent ( stream_for ( fopen ( $ uploadedFile -> getRealPath ( ) , 'r' ) ) ) -> setKey ( $ this -> namer -> transform ( $ uploadedFile ) ) ; return $ file ; } 
public function createFileWithExtension ( $ extension ) { $ key = $ this -> namer -> transformWithExtension ( $ extension ) ; return $ this -> createFileByKey ( $ key ) ; } 
public function freeze ( $ amount ) { if ( $ this -> amount < $ amount ) { throw new \ LogicException ( 'Not enough balance' ) ; } $ this -> amount -= $ amount ; $ this -> freezeAmount += $ amount ; return $ this ; } 
public function release ( $ amount ) { if ( $ this -> freezeAmount < $ amount ) { throw new \ LogicException ( 'Not enough frozen balance' ) ; } $ this -> amount += $ amount ; $ this -> freezeAmount -= $ amount ; return $ this ; } 
public function warmUp ( $ cacheDir ) { $ allTemplates = $ this -> finder -> findAllTemplates ( ) ; $ filesystem = new Filesystem ( ) ; $ templates = array ( ) ; 
public function execute ( InputInterface $ input , OutputInterface $ output ) { $ this -> rawCommand = $ this -> getApplication ( ) -> get ( 'sylius:theme:list' ) ; $ arguments = array ( 'command' => 'sylius:theme:list' , ) ; $ greetInput = new ArrayInput ( $ arguments ) ; $ this -> rawCommand -> run ( $ greetInput , $ output ) ; } 
public function createPointHistory ( UserInterface $ user , $ amount , $ type = null ) { $ history = new $ this -> pointHistoryEntity ; $ history -> setUser ( $ user ) -> setAmount ( $ amount ) -> setType ( $ type ) ; return $ history ; } 
public function savePointHistory ( PointHistoryInterface $ history ) { $ this -> entityManager -> persist ( $ history ) ; $ this -> entityManager -> flush ( ) ; } 
public function findPointHistories ( UserInterface $ user , $ page , $ limit = null ) { $ query = $ this -> getPointHistoryRepository ( ) -> createQueryBuilder ( 'p' ) -> where ( 'p.user = :user' ) -> setParameter ( 'user' , $ user ) -> getQuery ( ) ; return $ this -> createPaginator ( $ query , $ page , $ limit ) ; } 
public function registerBundles ( ) { $ bundles = [ new EasyCorp \ Bundle \ EasyAdminBundle \ EasyAdminBundle ( ) , 
public function getTheme ( ) : ? ThemeInterface { return $ this -> currentThemeName ? $ this -> themeRepository -> findOneByName ( $ this -> currentThemeName ) : null ; } 
public function buildForm ( FormBuilderInterface $ builder , array $ options ) { $ builder -> add ( 'title' , TextType :: class , [ 'label' => 'form.post.title' , ] ) -> add ( 'category' , EntityType :: class , [ 'class' => 'PHPDishPostBundle:Category' , 'choice_label' => 'name' , 'choices' => $ this -> getCurrentUserCategories ( $ options ) , ] ) -> add ( 'originalBody' , TextareaType :: class , [ 'label' => 'form.post.body' , ] ) ; } 
public function findAll ( ) { if ( $ this -> plugins ) { return $ this -> plugins ; } if ( $ this -> cached ) { foreach ( $ this -> cache as $ pluginItem ) { if ( class_exists ( $ pluginItem [ 'class' ] ) ) { $ this -> plugins [ ] = new $ pluginItem [ 'class' ] ; } } } else { $ this -> plugins = $ this -> decoratedFinder -> findAll ( ) ; } return $ this -> plugins ; } 
public function process ( ContainerBuilder $ container ) { 
public function index ( Request $ request ) { $ this -> denyAccessUnlessGranted ( 'IS_AUTHENTICATED_REMEMBERED' ) ; $ meta = $ this -> notificationManager -> findNotificationMetadataPager ( $ this -> getUser ( ) , null , $ request -> query -> getInt ( 'page' , 1 ) ) ; 
public function getChildren ( ) { return $ this -> children -> matching ( Criteria :: create ( ) -> where ( Criteria :: expr ( ) -> eq ( 'enabled' , true ) ) ) ; } 
public function getConfigTreeBuilder ( ) { $ treeBuilder = new TreeBuilder ( ) ; $ rootNode = $ treeBuilder -> root ( 'phpdish_core' ) ; $ this -> addAssetsSection ( $ rootNode ) ; return $ treeBuilder ; } 
public function build ( ContainerBuilder $ container ) { parent :: build ( $ container ) ; $ container -> addCompilerPass ( new DoctrineTargetEntitiesResolverPass ( ) , PassConfig :: TYPE_BEFORE_OPTIMIZATION , 1 ) ; $ container -> addCompilerPass ( new RegisterResourcePass ( ) ) ; $ container -> addCompilerPass ( new InjectResourceConfigurationPass ( ) ) ; $ container -> addCompilerPass ( new InjectServiceManager ( ) ) ; } 
public function encodePassword ( $ raw , $ salt ) { if ( $ this -> difficulty === static :: DIFFICULTY_SIMPLE ) { $ salt = null ; } return $ this -> messageDigestPasswordEncoder -> encodePassword ( $ raw , $ salt ) ; } 
public function isPasswordValid ( $ encoded , $ raw , $ salt ) { if ( $ this -> difficulty === static :: DIFFICULTY_SIMPLE ) { $ salt = null ; } return $ this -> messageDigestPasswordEncoder -> isPasswordValid ( $ encoded , $ raw , $ salt ) ; } 
public function load ( ObjectManager $ manager ) { $ manager = $ this -> getCategoryManager ( ) ; $ post = $ manager -> createPost ( $ this -> getReference ( 'general-user' ) ) ; $ body = <<<EOT 此次基准测试只是简单测算一下node与php在冒泡排序方面的时间损耗情况，基本思想是使用冒泡排序各自运算100次之后求出平均值；冒泡排序算法摘自网上，测试代码如下： ## 代码 JavaScript: ```javascript function sort(arr){ var n=arr.length; var temp=null; for(var i=0; i<n-1; i++){ for(var j=0; j<n-1-i; j++){ if(arr[j]>arr[j+1]){ temp=arr[j]; arr[j]=arr[j+1]; arr[j+1]=temp; } } } return arr; } const array = [49, 38, 65, 97, 76, 13, 27,49, 38, 65, 97, 76, 13, 27]; const startTime = new Date(); for (let i = 0; i <= 99; i++) { const arr = sort(array); } console.log((new Date() - startTime) / 1000 / 100); ``` PHP: ```php function bubble_sort(\$array) { \$count = count(\$array); if (\$count <= 0) return false; for (\$i = 0; \$i < \$count; \$i++) { for (\$j = \$count - 1; \$j > \$i; \$j--) { if (\$array[\$j] < \$array[\$j - 1]) { \$tmp = \$array[\$j]; \$array[\$j] = \$array[\$j - 1]; \$array[\$j - 1] = \$tmp; } } } return \$array; } \$array = [49, 38, 65, 97, 76, 13, 27,49, 38, 65, 97, 76, 13, 27]; \$startTime = microtime(true); for (\$i = 0; \$i <= 99; \$i++) { \$arr = bubble_sort(\$array); } echo number_format((microtime(true) - \$startTime) / 100, 10); ``` 注意：为了测试php5并没有采用php7的强调语法类型 ## 测试结果 如图： PHP5.6 ![clipboard.png](https: Node7.9: ![clipboard.png](https: PHP7.1 ![clipboard.png](https: ## 结论 三次测算的结果分别是： | 环境 | 时间(s)| | --- | --- | |php5.6 | 0.0000207901| |node7.9 | 0.0005099999999999999| |php7.1 | 0.0000101209| 测试机器 ![clipboard.png](https: 从本次测试的结果来看在执行速度上 PHP7.1 > PHP5.6 > Node7.9; EOT ; $ post -> setCategory ( $ this -> getReference ( 'general-category' ) ) -> setTitle ( '一个简单的NodeJs与PHP的benchmark') -> setOriginalBody ( $ body ) ; $ manager -> savePost ( $ post ) ; } 
public function postPersist ( TopicInterface $ topic , LifecycleEventArgs $ event ) { $ user = $ topic -> getUser ( ) ; $ this -> handleUserTopicCount ( $ user ) ; } 
protected function handleUserTopicCount ( UserInterface $ user ) { $ count = $ this -> topicManager -> getUserTopicCount ( $ user ) ; $ user -> setTopicCount ( $ count ) ; $ this -> userManager -> saveUser ( $ user ) ; } 
public function findBook ( $ slug ) { $ category = $ this -> categoryManager -> findCategoryBySlug ( $ slug ) ; if ( ! $ category || ! $ category -> isBook ( ) ) { throw new \ InvalidArgumentException ( 'The book is not exists' ) ; } return $ category ; } 
public function findBookChaptersTree ( BookInterface $ book ) { $ repo = $ this -> postManager -> getPostRepository ( ) ; return $ repo -> createQueryBuilder ( 'p' ) -> where ( 'p.category = :book' ) -> andWhere ( 'p.enabled = :enabled' ) -> setParameter ( 'enabled' , true ) -> setParameter ( 'book' , $ book ) -> orderBy ( 'p.level, p.left' , 'ASC' ) -> getQuery ( ) -> setHint ( \ Doctrine \ ORM \ Query :: HINT_INCLUDE_META_COLUMNS , true ) -> getResult ( 'tree' ) ; } 
public function findUserBooks ( UserInterface $ user ) { $ qb = $ this -> createGetUserBooksQueryBuilder ( $ user ) ; return $ qb -> getQuery ( ) -> getResult ( ) ; } 
public function getUserBookNumber ( UserInterface $ user ) { $ qb = $ this -> createGetUserBooksQueryBuilder ( $ user ) ; return ( int ) $ qb -> select ( $ qb -> expr ( ) -> count ( 'c' ) ) -> getQuery ( ) -> getSingleScalarResult ( ) ; } 
public function createBook ( UserInterface $ user ) { $ book = $ this -> categoryManager -> createCategory ( $ user ) ; $ book -> asBook ( ) ; return $ book ; } 
public function addBookChapter ( BookInterface $ book , $ chapter ) { if ( is_string ( $ chapter ) ) { $ title = $ chapter ; $ chapter = $ this -> postManager -> createPost ( $ book -> getCreator ( ) ) ; $ chapter -> setTitle ( $ title ) ; } $ chapter -> setUpdatedAt ( Carbon :: now ( ) ) -> setCategory ( $ book ) ; $ this -> postManager -> savePost ( $ chapter ) ; return $ chapter ; } 
public function moveBookChapter ( BookInterface $ book , ChapterInterface $ chapter , $ direction , $ step ) { $ func = $ direction === static :: MOVE_DIRECTION_UP ? 'moveUp' : 'moveDown' ; $ this -> postManager -> getPostRepository ( ) -> $ func ( $ chapter , $ step ) ; 
public function createMenu ( array $ options = [ ] ) { $ menu = $ this -> factory -> createItem ( 'root' ) ; $ menu -> setChildrenAttribute ( 'class' , 'list-group vertical-menu' ) ; $ menu -> addChild ( 'Profile' , [ 'label' => 'menu.profile' , 'route' => 'setting_profile' , ] ) -> setAttribute ( 'class' , 'list-group-item if i-envelope-o' ) ; $ menu -> addChild ( 'Change Password' , [ 'label' => 'menu.change_password' , 'route' => 'setting_change_password' , ] ) -> setAttribute ( 'class' , 'list-group-item if i-password' ) ; $ menu -> addChild ( 'Social Binding' , [ 'label' => 'menu.social_binding' , 'route' => 'setting_social_binding' , ] ) -> setAttribute ( 'class' , 'list-group-item if i-sync' ) ; 
public function warmUp ( $ cacheDir ) { $ plugins = $ this -> pluginFinder -> findAll ( ) ; $ processed = [ ] ; foreach ( $ plugins as $ plugin ) { $ processed [ ] = [ 'class' => get_class ( $ plugin ) , 'path' => $ plugin -> getRootDir ( ) ] ; } $ var = var_export ( $ processed , true ) ; $ export = <<<EOT <?php return $var; EOT ; $ this -> writeCacheFile ( $ cacheDir . '/phpdish_plugins.php' , $ export ) ; } 
public function setProfile ( ProfileInterface $ profile ) { $ this -> profile -> clear ( ) ; $ profile -> setUser ( $ this ) ; $ this -> profile [ ] = $ profile ; return $ this ; } 
public function indexAction ( ) { $ this -> breadcrumb -> push ( 'admin.user.index' ) ; $ grid = $ this -> gridFactory -> get ( User :: class ) ; return $ this -> render ( 'PHPDishAdminBundle:User:index.html.twig' , [ 'grid' => $ grid ] ) ; } 
public function saveUser ( UserInterface $ user ) { $ user -> setUpdatedAt ( Carbon :: now ( ) ) ; $ this -> objectManager -> persist ( $ user ) ; $ this -> objectManager -> flush ( ) ; return true ; } 
public function findUsersByNames ( $ userNames ) { $ qb = $ this -> getRepository ( ) -> createQueryBuilder ( 'u' ) ; return $ qb -> where ( $ qb -> expr ( ) -> in ( 'u.username' , $ userNames ) ) -> getQuery ( ) -> getResult ( ) ; } 
public function findUserFollowing ( UserInterface $ user , $ page , $ limit = null ) { $ query = $ this -> getRepository ( ) -> createQueryBuilder ( 'u' ) -> innerJoin ( 'u.followers' , 'f' ) -> where ( 'f.id = :userId' ) -> setParameter ( 'userId' , $ user -> getId ( ) ) -> getQuery ( ) ; return $ this -> createPaginator ( $ query , $ page , $ limit ) ; } 
public function findCategoryFollowers ( CategoryInterface $ category , $ page , $ limit = null ) { $ query = $ this -> getRepository ( ) -> createQueryBuilder ( 'u' ) -> innerJoin ( 'u.followingCategories' , 'f' ) -> where ( 'f.id = :categoryId' ) -> setParameter ( 'categoryId' , $ category -> getId ( ) ) -> getQuery ( ) ; return $ this -> createPaginator ( $ query , $ page , $ limit ) ; } 
public function findTopicVoters ( TopicInterface $ topic , $ page , $ limit = null ) { $ query = $ this -> getRepository ( ) -> createQueryBuilder ( 'u' ) -> innerJoin ( 'u.votedTopics' , 'vt' ) -> where ( 'vt.id = :topicId' ) -> setParameter ( 'topicId' , $ topic -> getId ( ) ) -> getQuery ( ) ; return $ this -> createPaginator ( $ query , $ page , $ limit ) ; } 
public function findTopicReplyVoters ( ReplyInterface $ reply , $ page , $ limit = null ) { $ query = $ this -> getRepository ( ) -> createQueryBuilder ( 'u' ) -> innerJoin ( 'u.votedReplies' , 'vr' ) -> where ( 'vr.id = :replyId' ) -> setParameter ( 'replyId' , $ reply -> getId ( ) ) -> getQuery ( ) ; return $ this -> createPaginator ( $ query , $ page , $ limit ) ; } 
public function findPostVoters ( PostInterface $ post , $ page , $ limit = null ) { $ query = $ this -> getRepository ( ) -> createQueryBuilder ( 'u' ) -> innerJoin ( 'u.votedPosts' , 'vp' ) -> where ( 'vp.id = :postId' ) -> setParameter ( 'postId' , $ post -> getId ( ) ) -> getQuery ( ) ; return $ this -> createPaginator ( $ query , $ page , $ limit ) ; } 
public function findCommentVoters ( CommentInterface $ comment , $ page , $ limit = null ) { $ query = $ this -> getRepository ( ) -> createQueryBuilder ( 'u' ) -> innerJoin ( 'u.votedComments' , 'vc' ) -> where ( 'vc.id = :commentId' ) -> setParameter ( 'commentId' , $ comment -> getId ( ) ) -> getQuery ( ) ; return $ this -> createPaginator ( $ query , $ page , $ limit ) ; } 
public function followUser ( UserInterface $ user , UserInterface $ follower ) { if ( $ user -> getId ( ) == $ follower -> getId ( ) ) { throw new \ LogicException ( $ this -> translator -> trans ( 'follow.cannot_follow_yourself' ) ) ; } $ user -> addFollower ( $ follower ) ; $ user -> setFollowerCount ( $ user -> getFollowerCount ( ) + 1 ) ; $ follower -> setFollowingCount ( $ follower -> getFollowingCount ( ) + 1 ) ; $ this -> objectManager -> persist ( $ user ) ; $ this -> objectManager -> persist ( $ follower ) ; $ this -> objectManager -> flush ( ) ; 
public function unFollowUser ( UserInterface $ user , UserInterface $ follower ) { $ user -> removeFollower ( $ follower ) ; $ user -> setFollowerCount ( $ user -> getFollowerCount ( ) - 1 ) ; $ follower -> setFollowingCount ( $ follower -> getFollowingCount ( ) - 1 ) ; $ this -> objectManager -> persist ( $ user ) ; $ this -> objectManager -> persist ( $ follower ) ; $ this -> objectManager -> flush ( ) ; return true ; } 
public function findUsersByCriteria ( Criteria $ criteria ) { return $ this -> getRepository ( ) -> createQueryBuilder ( 'u' ) -> addCriteria ( $ criteria ) -> getQuery ( ) -> getResult ( ) ; } 
public function findUsersPager ( Criteria $ criteria , $ page , $ limit = null ) { $ query = $ this -> getRepository ( ) -> createQueryBuilder ( 'u' ) -> addCriteria ( $ criteria ) -> getQuery ( ) ; return $ this -> createPaginator ( $ query , $ page , $ limit ) ; } 
protected function supports ( $ attribute , $ subject ) { $ entityClass = $ this -> getResourceClass ( ) ; return in_array ( $ attribute , $ this -> actions ) && $ subject instanceof $ entityClass ; } 
protected function voteOnAttribute ( $ attribute , $ subject , TokenInterface $ token ) { $ user = $ token -> getUser ( ) ; $ this -> hasAuthenticatedUser = $ user instanceof UserInterface ; 
protected function canView ( $ entity , UserInterface $ user ) { return $ this -> canEdit ( $ entity , $ user ) || $ entity -> isEnabled ( ) ; } 
public function build ( ContainerBuilder $ container ) { $ container -> addCompilerPass ( DoctrineOrmMappingsPass :: createXmlMappingDriver ( [ $ this -> getConfigFilesPath ( ) => $ this -> getModelNamespace ( ) ] , [ sprintf ( '%s.object_manager' , $ this -> getBundlePrefix ( ) ) ] ) ) ; } 
public function isValid ( $ record ) : bool { $ record = ( $ record instanceof Record ? $ record : new Record ( $ record ) ) ; foreach ( $ this -> filters as $ value ) { [ $ index , $ filter ] = $ value ; $ value = $ record -> __get ( $ index ) ; if ( $ filter -> isValid ( $ value ) ) { continue ; } return false ; } return true ; } 
public function convert ( Traversable $ traversable ) { $ result = [ ] ; foreach ( $ traversable as $ key => $ value ) { if ( $ this -> recursive && $ value instanceof Traversable ) { $ value = $ this -> convert ( $ value ) ; } $ result [ $ key ] = $ value ; } return $ result ; } 
public function isValid ( $ input ) : bool { foreach ( $ this -> getFilters ( ) as $ filter ) { if ( ! $ filter -> isValid ( $ input ) ) { continue ; } return true ; } return false ; } 
public function convert ( Traversable $ traversable ) { $ name = $ this -> getNodeName ( $ traversable ) ; $ childNode = $ this -> document -> createElement ( $ name ) ; $ this -> document -> appendChild ( $ childNode ) ; $ this -> parseNode ( $ traversable , $ childNode ) ; return $ this -> document -> saveXml ( ) ; } 
public function convert ( Traversable $ traversable ) { return json_encode ( ( new Arr ( true ) ) -> convert ( $ traversable ) , $ this -> jsonEncodeFlags ) ; } 
protected function cast ( $ input ) { if ( $ input instanceof $ this -> precision ) { return $ input ; } if ( class_exists ( $ this -> precision ) ) { return new $ this -> precision ( $ input ) ; } settype ( $ input , $ this -> precision ) ; return $ input ; } 
public function isValid ( $ actual ) : bool { if ( $ this -> precision == self :: NORMAL ) { return $ this -> expected == $ actual ; } if ( $ this -> precision == self :: IDENTICAL ) { return $ this -> expected === $ actual ; } return $ this -> cast ( $ this -> expected ) == $ this -> cast ( $ actual ) ; } 
public static function reconstituteFromEvents ( AggregateRootId $ aggregateRootId , Generator $ events ) : AggregateRoot { $ aggregateRoot = new static ( $ aggregateRootId ) ; foreach ( $ events as $ event ) { $ aggregateRoot -> apply ( $ event ) ; } return $ aggregateRoot ; } 
private function dumpCommands ( array $ commands ) : string { $ code = [ ] ; foreach ( $ commands as $ command ) { $ code [ ] = <<<EOF final class {$command->name()} { {$this->dumpFields($command)}{$this->dumpConstructor($command)}{$this->dumpMethods($command)}} EOF ; } return rtrim ( implode ( '' , $ code ) ) ; } 
private function fieldsFromDefinition ( DefinitionWithFields $ definition ) : array { $ fields = $ this -> fieldsFrom ( $ definition -> fieldsFrom ( ) ) ; foreach ( $ definition -> fields ( ) as $ field ) { array_push ( $ fields , $ field ) ; } return $ fields ; } 
public function call ( $ string , $ method , $ args ) { if ( $ this -> methodUsesStringAsFirstArgument ( $ method ) ) { array_unshift ( $ args , ( string ) $ string ) ; } $ underscoreResult = call_user_func_array ( [ 'Underscore\Types\Strings' , $ method ] , $ args ) ; if ( $ this -> methodReturnsAString ( $ method ) ) { return new Str ( $ underscoreResult ) ; } return $ underscoreResult ; } 
public function between ( $ start , $ end ) { if ( $ start == '' && $ end == '' ) { return $ this ; } if ( $ start != '' && strpos ( $ this -> string , $ start ) === false ) { return new static ( ) ; } if ( $ end != '' && strpos ( $ this -> string , $ end ) === false ) { return new static ( ) ; } if ( $ start == '' ) { return new static ( substr ( $ this -> string , 0 , strpos ( $ this -> string , $ end ) ) ) ; } if ( $ end == '' ) { return new static ( substr ( $ this -> string , strpos ( $ this -> string , $ start ) + strlen ( $ start ) ) ) ; } $ stringWithoutStart = explode ( $ start , $ this -> string ) [ 1 ] ; $ middle = explode ( $ end , $ stringWithoutStart ) [ 0 ] ; return new static ( $ middle ) ; } 
public function tease ( $ length = 200 , $ moreTextIndicator = '...' ) { $ sanitizedString = $ this -> sanitizeForTease ( $ this -> string ) ; if ( strlen ( $ sanitizedString ) == 0 ) { return new static ( ) ; } if ( strlen ( $ sanitizedString ) <= $ length ) { return new static ( $ sanitizedString ) ; } $ ww = wordwrap ( $ sanitizedString , $ length , "\n" ) ; $ shortenedString = substr ( $ ww , 0 , strpos ( $ ww , "\n" ) ) . $ moreTextIndicator ; return new static ( $ shortenedString ) ; } 
private function sanitizeForTease ( $ string ) { $ string = trim ( $ string ) ; 
public function replaceFirst ( $ search , $ replace ) { if ( $ search == '' ) { return $ this ; } $ position = strpos ( $ this -> string , $ search ) ; if ( $ position === false ) { return $ this ; } $ resultString = substr_replace ( $ this -> string , $ replace , $ position , strlen ( $ search ) ) ; return new static ( $ resultString ) ; } 
public function replaceLast ( $ search , $ replace ) { if ( $ search == '' ) { return $ this ; } $ position = strrpos ( $ this -> string , $ search ) ; if ( $ position === false ) { return $ this ; } $ resultString = substr_replace ( $ this -> string , $ replace , $ position , strlen ( $ search ) ) ; return new static ( $ resultString ) ; } 
public function possessive ( ) { if ( $ this -> string == '' ) { return new static ( ) ; } $ noApostropheEdgeCases = [ 'it' ] ; if ( in_array ( $ this -> string , $ noApostropheEdgeCases ) ) { return new static ( $ this -> string . 's' ) ; } return new static ( $ this -> string . '\'' . ( $ this -> string [ strlen ( $ this -> string ) - 1 ] != 's' ? 's' : '' ) ) ; } 
public function segment ( $ delimiter , $ index ) { $ segments = explode ( $ delimiter , $ this -> string ) ; if ( $ index < 0 ) { $ segments = array_reverse ( $ segments ) ; $ index = abs ( $ index ) - 1 ; } $ segment = isset ( $ segments [ $ index ] ) ? $ segments [ $ index ] : '' ; return new static ( $ segment ) ; } 
public function contains ( $ needle , $ caseSensitive = false , $ absolute = false ) { return $ this -> find ( $ needle , $ caseSensitive , $ absolute ) ; } 
public function response ( $ request ) { $ response = $ request -> all ( ) ; $ rcvd_checksum = $ request -> checksum ; $ rcvd_data = $ this -> getAllResponseParams ( $ response ) ; $ checksum_check = $ this -> verifyChecksum ( $ rcvd_checksum , $ rcvd_data , $ this -> secret ) ; if ( ! $ checksum_check ) { return "Recieved Checksum Mismatch." ; } $ this -> response = $ response ; return $ this -> response ; } 
public function response ( $ request ) { $ payment_request_id = Request :: input ( 'payment_request_id' ) ; $ payment_id = Request :: input ( 'payment_id' ) ; $ client = new \ GuzzleHttp \ Client ( ) ; $ response = $ client -> get ( $ this -> getEndPoint ( 'payment-requests/' . $ payment_request_id . '/' . $ payment_id . '/' ) , [ 'headers' => array ( 'X-Api-Key' => $ this -> api_key , 'X-Auth-Token' => $ this -> auth_token , ) , ] ) -> getBody ( ) -> getContents ( ) ; $ response = json_decode ( $ response ) ; if ( $ response -> success ) { return $ response ; } return false ; } 
protected function encrypt ( ) { $ this -> hash = '' ; $ hashSequence = "key|txnid|amount|productinfo|firstname|email|udf1|udf2|udf3|udf4|udf5|udf6|udf7|udf8|udf9|udf10" ; $ hashVarsSeq = explode ( '|' , $ hashSequence ) ; $ hash_string = '' ; foreach ( $ hashVarsSeq as $ hash_var ) { $ hash_string .= isset ( $ this -> parameters [ $ hash_var ] ) ? $ this -> parameters [ $ hash_var ] : '' ; $ hash_string .= '|' ; } $ hash_string .= $ this -> salt ; $ this -> hash = strtolower ( hash ( 'sha512' , $ hash_string ) ) ; } 
protected function decrypt ( $ response ) { $ hashSequence = "status||||||udf5|udf4|udf3|udf2|udf1|email|firstname|productinfo|amount|txnid|key" ; $ hashVarsSeq = explode ( '|' , $ hashSequence ) ; $ hash_string = $ this -> salt . "|" ; foreach ( $ hashVarsSeq as $ hash_var ) { $ hash_string .= isset ( $ response [ $ hash_var ] ) ? $ response [ $ hash_var ] : '' ; $ hash_string .= '|' ; } $ hash_string = trim ( $ hash_string , '|' ) ; return strtolower ( hash ( 'sha512' , $ hash_string ) ) ; } 
public function register ( ) { $ gateway = Config :: get ( 'indipay.gateway' ) ; $ this -> app -> bind ( 'indipay' , 'Softon\Indipay\Indipay' ) ; $ this -> app -> bind ( 'Softon\Indipay\Gateways\PaymentGatewayInterface' , 'Softon\Indipay\Gateways\\' . $ gateway . 'Gateway' ) ; } 
public function response ( $ request ) { $ encResponse = $ request -> encResp ; $ rcvdString = $ this -> decrypt ( $ encResponse , $ this -> workingKey ) ; parse_str ( $ rcvdString , $ decResponse ) ; return $ decResponse ; } 
protected function encrypt ( $ plainText , $ key ) { $ secretKey = $ this -> hextobin ( md5 ( $ key ) ) ; $ initVector = pack ( "C*" , 0x00 , 0x01 , 0x02 , 0x03 , 0x04 , 0x05 , 0x06 , 0x07 , 0x08 , 0x09 , 0x0a , 0x0b , 0x0c , 0x0d , 0x0e , 0x0f ) ; $ openMode = @ mcrypt_module_open ( MCRYPT_RIJNDAEL_128 , '' , 'cbc' , '' ) ; $ blockSize = @ mcrypt_get_block_size ( MCRYPT_RIJNDAEL_128 , 'cbc' ) ; $ plainPad = $ this -> pkcs5_pad ( $ plainText , $ blockSize ) ; if ( @ mcrypt_generic_init ( $ openMode , $ secretKey , $ initVector ) != - 1 ) { $ encryptedText = @ mcrypt_generic ( $ openMode , $ plainPad ) ; @ mcrypt_generic_deinit ( $ openMode ) ; } return bin2hex ( $ encryptedText ) ; } 
protected function decrypt ( $ encryptedText , $ key ) { $ secretKey = $ this -> hextobin ( md5 ( $ key ) ) ; $ initVector = pack ( "C*" , 0x00 , 0x01 , 0x02 , 0x03 , 0x04 , 0x05 , 0x06 , 0x07 , 0x08 , 0x09 , 0x0a , 0x0b , 0x0c , 0x0d , 0x0e , 0x0f ) ; $ encryptedText = $ this -> hextobin ( $ encryptedText ) ; $ openMode = @ mcrypt_module_open ( MCRYPT_RIJNDAEL_128 , '' , 'cbc' , '' ) ; @ mcrypt_generic_init ( $ openMode , $ secretKey , $ initVector ) ; $ decryptedText = @ mdecrypt_generic ( $ openMode , $ encryptedText ) ; $ decryptedText = rtrim ( $ decryptedText , "\0" ) ; @ mcrypt_generic_deinit ( $ openMode ) ; return $ decryptedText ; } 
public function response ( $ request ) { $ response = $ request -> all ( ) ; $ response_hash = $ this -> decrypt ( $ response ) ; if ( $ response_hash != $ response [ 'signature' ] ) { return 'Hash Mismatch Error' ; } return $ response ; } 
protected function encrypt ( ) { $ hash_string = $ this -> vanityUrl . $ this -> parameters [ 'orderAmount' ] . $ this -> parameters [ 'merchantTxnId' ] . $ this -> parameters [ 'currency' ] ; $ this -> hash = hash_hmac ( 'sha1' , $ hash_string , $ this -> secretKey ) ; } 
protected function decrypt ( $ response ) { $ hash_string = '' ; $ hash_string .= $ response [ 'TxId' ] ; $ hash_string .= $ response [ 'TxStatus' ] ; $ hash_string .= $ response [ 'amount' ] ; $ hash_string .= $ response [ 'pgTxnNo' ] ; $ hash_string .= $ response [ 'issuerRefNo' ] ; $ hash_string .= $ response [ 'authIdCode' ] ; $ hash_string .= $ response [ 'firstName' ] ; $ hash_string .= $ response [ 'lastName' ] ; $ hash_string .= $ response [ 'pgRespCode' ] ; $ hash_string .= $ response [ 'addressZip' ] ; return hash_hmac ( 'sha1' , $ hash_string , $ this -> secretKey ) ; } 
protected function encrypt ( ) { $ this -> hash = '' ; $ hash_string = $ this -> secretKey . "|" . urlencode ( $ this -> parameters [ 'account_id' ] ) . "|" . urlencode ( $ this -> parameters [ 'amount' ] ) . "|" . urlencode ( $ this -> parameters [ 'reference_no' ] ) . "|" . $ this -> parameters [ 'return_url' ] . "|" . urlencode ( $ this -> parameters [ 'mode' ] ) ; $ this -> hash = md5 ( $ hash_string ) ; } 
private function parseScenario ( $ scenarioString ) { $ parsedScenario = array ( ) ; $ scenarios = explode ( $ this -> methodDelimiter , $ scenarioString ) ; foreach ( $ scenarios as $ scenario ) { $ arguments = null ; $ scenarioElement = explode ( $ this -> argumentDelimiter , $ scenario ) ; if ( isset ( $ scenarioElement [ 1 ] ) ) { $ arguments = $ scenarioElement [ 1 ] ; } $ parsedScenario [ ] = new Expression ( $ this -> methodParser -> parse ( $ scenarioElement [ 0 ] ) , $ arguments ) ; } return $ parsedScenario ; } 
private function runScenario ( $ parsedScenario ) { foreach ( $ parsedScenario as $ expression ) { call_user_func_array ( array ( $ this , $ expression -> getName ( ) ) , array ( $ expression -> getArguments ( ) ) ) ; } return $ this ; } 
public function replace ( $ source , $ value ) { 
public function range ( ) { $ args = func_get_args ( ) ; $ arg_num = count ( $ args ) ; if ( $ arg_num % 2 != 0 ) { throw new \ InvalidArgumentException ( 'Number of args must be even' , 1 ) ; } $ value = '[' ; for ( $ i = 0 ; $ i < $ arg_num ; ) { $ value .= self :: sanitize ( $ args [ $ i ++ ] ) . '-' . self :: sanitize ( $ args [ $ i ++ ] ) ; } $ value .= ']' ; return $ this -> add ( $ value ) ; } 
public function addModifier ( $ modifier ) { if ( strpos ( $ this -> modifiers , $ modifier ) === false ) { $ this -> modifiers .= $ modifier ; } return $ this ; } 
public function clean ( array $ options = array ( ) ) { $ options = array_merge ( array ( 'prefixes' => '' , 'source' => '' , 'suffixes' => '' , 'modifiers' => 'gm' , 'replaceLimit' => '1' ) , $ options ) ; $ this -> prefixes = $ options [ 'prefixes' ] ; $ this -> source = $ options [ 'source' ] ; $ this -> suffixes = $ options [ 'suffixes' ] ; $ this -> modifiers = $ options [ 'modifiers' ] ; 
public function addRange ( int $ start , int $ end ) : void { $ this -> pages = array_merge ( $ this -> pages , range ( $ start , $ end ) ) ; } 
public function addRaw ( string $ content , PagesInterface $ pages = null ) : void { $ this -> sources [ ] = new RawSource ( $ content , $ pages ) ; } 
public function addFile ( string $ filename , PagesInterface $ pages = null ) : void { $ this -> sources [ ] = new FileSource ( $ filename , $ pages ) ; } 
public function addIterator ( iterable $ iterator , PagesInterface $ pages = null ) : void { foreach ( $ iterator as $ filename ) { $ this -> addFile ( $ filename , $ pages ) ; } } 
protected static function jsonUnserializeFromProperties ( $ properties ) { if ( ! is_array ( $ properties ) && ! is_object ( $ properties ) ) { throw UnserializationException :: invalidProperty ( 'Linked CRS' , 'properties' , $ properties , 'array or object' ) ; } $ properties = new \ ArrayObject ( $ properties ) ; if ( ! $ properties -> offsetExists ( 'href' ) ) { throw UnserializationException :: missingProperty ( 'Linked CRS' , 'properties.href' , 'string' ) ; } $ href = ( string ) $ properties [ 'href' ] ; $ type = isset ( $ properties [ 'type' ] ) ? ( string ) $ properties [ 'type' ] : null ; return new self ( $ href , $ type ) ; } 
protected function setOptionalConstructorArgs ( array $ args ) { foreach ( $ args as $ arg ) { if ( $ arg instanceof CoordinateReferenceSystem ) { $ this -> crs = $ arg ; } if ( $ arg instanceof BoundingBox ) { $ this -> boundingBox = $ arg ; } } } 
public static function invalidValue ( $ context , $ value , $ expectedType ) { return new self ( sprintf ( '%s expected value of type %s, %s given' , $ context , $ expectedType , is_object ( $ value ) ? get_class ( $ value ) : gettype ( $ value ) ) ) ; } 
public static function invalidProperty ( $ context , $ property , $ value , $ expectedType ) { return new self ( sprintf ( '%s expected "%s" property of type %s, %s given' , $ context , $ property , $ expectedType , is_object ( $ value ) ? get_class ( $ value ) : gettype ( $ value ) ) ) ; } 
protected static function jsonUnserializeFromProperties ( $ properties ) { if ( ! is_array ( $ properties ) && ! is_object ( $ properties ) ) { throw UnserializationException :: invalidProperty ( 'Named CRS' , 'properties' , $ properties , 'array or object' ) ; } $ properties = new \ ArrayObject ( $ properties ) ; if ( ! $ properties -> offsetExists ( 'name' ) ) { throw UnserializationException :: missingProperty ( 'Named CRS' , 'properties.name' , 'string' ) ; } $ name = ( string ) $ properties [ 'name' ] ; return new self ( $ name ) ; } 
protected function getBaseInstallationPath ( ) { if ( ! $ this -> composer || ! $ this -> composer -> getPackage ( ) ) { return self :: DEFAULT_ROOT ; } $ extra = $ this -> composer -> getPackage ( ) -> getExtra ( ) ; if ( ! $ extra || empty ( $ extra [ 'module-dir' ] ) ) { return self :: DEFAULT_ROOT ; } return $ extra [ 'module-dir' ] ; } 
protected function getModuleName ( PackageInterface $ package ) { $ name = $ package -> getPrettyName ( ) ; $ split = explode ( "/" , $ name ) ; if ( count ( $ split ) !== 2 ) { throw new \ Exception ( $ this -> usage ( ) ) ; } $ splitNameToUse = explode ( "-" , $ split [ 1 ] ) ; if ( count ( $ splitNameToUse ) < 2 ) { throw new \ Exception ( $ this -> usage ( ) ) ; } if ( array_pop ( $ splitNameToUse ) !== 'module' ) { throw new \ Exception ( $ this -> usage ( ) ) ; } return implode ( '' , array_map ( 'ucfirst' , $ splitNameToUse ) ) ; } 
public function registerContainerConfiguration ( LoaderInterface $ loader ) { $ loader -> load ( function ( ContainerBuilder $ container ) use ( $ loader ) { $ container -> loadFromExtension ( 'framework' , [ 'router' => [ 'resource' => 'kernel:loadRoutes' , 'type' => 'service' , ] , ] ) ; $ this -> configFiles = array_unique ( $ this -> configFiles ) ; foreach ( $ this -> configFiles as $ path ) { $ loader -> load ( $ path ) ; } $ container -> addObjectResource ( $ this ) ; } ) ; } 
public function loadRoutes ( LoaderInterface $ loader ) { $ routes = new RouteCollectionBuilder ( $ loader ) ; $ routes -> import ( __DIR__ . '/config/routing.yml' ) ; return $ routes -> build ( ) ; } 
protected function buildContainer ( ) { $ container = parent :: buildContainer ( ) ; foreach ( $ this -> compilerPasses as $ pass ) { $ container -> addCompilerPass ( $ pass ) ; } return $ container ; } 
public function organiseArguments ( ReflectionFunctionAbstract $ function , array $ arguments ) : array { $ organisedArguments = $ this -> decoratedArgumentOrganiser -> organiseArguments ( $ function , $ arguments ) ; if ( $ function -> isVariadic ( ) ) { $ organisedArguments += array_diff ( $ arguments , $ organisedArguments ) ; } return $ organisedArguments ; } 
public function load ( ContainerBuilder $ container , array $ config ) : void { $ definition = new Definition ( VariadicArgumentOrganiser :: class , [ new Reference ( 'fob_variadic.argument.mixed_organiser.inner' ) , ] ) ; $ definition -> setDecoratedService ( ArgumentExtension :: MIXED_ARGUMENT_ORGANISER_ID ) ; $ container -> setDefinition ( 'fob_variadic.argument.mixed_organiser' , $ definition ) ; } 
public function configPath ( $ path = '' ) { return $ this -> basePath . DIRECTORY_SEPARATOR . 'vendor' . DIRECTORY_SEPARATOR . 'matthewbdaly' . DIRECTORY_SEPARATOR . 'artisan-standalone' . DIRECTORY_SEPARATOR . 'config' . ( $ path ? DIRECTORY_SEPARATOR . $ path : $ path ) ; } 
public function getNamespace ( ) { if ( ! is_null ( $ this -> namespace ) ) { return $ this -> namespace ; } $ path = $ this -> basePath ; $ composer = json_decode ( file_get_contents ( $ path . DIRECTORY_SEPARATOR . 'composer.json' ) , true ) ; foreach ( ( array ) data_get ( $ composer , 'autoload.psr-4' ) as $ namespace => $ path ) { return $ this -> namespace = $ namespace ; } throw new RuntimeException ( 'Unable to detect application namespace.' ) ; } 
public function getAdapter ( array $ config ) { $ client = new \ Redis ( ) ; $ dsn = $ this -> getDsn ( ) ; if ( empty ( $ dsn ) ) { if ( false === $ client -> connect ( $ config [ 'host' ] , $ config [ 'port' ] ) ) { throw new ConnectException ( sprintf ( 'Could not connect to Redis database on "%s:%s".' , $ config [ 'host' ] , $ config [ 'port' ] ) ) ; } } else { if ( false === $ client -> connect ( $ dsn -> getFirstHost ( ) , $ dsn -> getFirstPort ( ) ) ) { throw new ConnectException ( sprintf ( 'Could not connect to Redis database on "%s:%s".' , $ dsn -> getFirstHost ( ) , $ dsn -> getFirstPort ( ) ) ) ; } if ( ! empty ( $ dsn -> getPassword ( ) ) ) { if ( false === $ client -> auth ( $ dsn -> getPassword ( ) ) ) { throw new ConnectException ( 'Could not connect authenticate connection to Redis database.' ) ; } } $ config [ 'database' ] = $ dsn -> getDatabase ( ) ; } if ( null !== $ config [ 'database' ] && false === $ client -> select ( $ config [ 'database' ] ) ) { throw new ConnectException ( sprintf ( 'Could not select Redis database with index "%s".' , $ config [ 'database' ] ) ) ; } $ pool = new RedisCachePool ( $ client ) ; if ( null !== $ config [ 'pool_namespace' ] ) { $ pool = new NamespacedCachePool ( $ pool , $ config [ 'pool_namespace' ] ) ; } return $ pool ; } 
public function getAdapter ( array $ config ) { $ redis = new \ Redis ( ) ; $ redis -> connect ( $ config [ 'host' ] , $ config [ 'port' ] ) ; $ client = new RedisCache ( ) ; $ client -> setRedis ( $ redis ) ; return new DoctrineCachePool ( $ client ) ; } 
protected function parseParameters ( $ params ) { $ parameters = explode ( '&' , $ params ) ; foreach ( $ parameters as $ parameter ) { $ kv = explode ( '=' , $ parameter , 2 ) ; $ this -> parameters [ $ kv [ 0 ] ] = isset ( $ kv [ 1 ] ) ? $ kv [ 1 ] : null ; } return '' ; } 
public function getAdapter ( array $ config ) { $ memcache = new Memcache ( ) ; $ memcache -> connect ( $ config [ 'host' ] , $ config [ 'port' ] ) ; $ client = new MemcacheCache ( ) ; $ client -> setMemcache ( $ memcache ) ; return new DoctrineCachePool ( $ client ) ; } 
public function getAdapter ( array $ config ) { $ couchbase = new Couchbase ( $ config [ 'host' ] , $ config [ 'user' ] , $ config [ 'password' ] , $ config [ 'bucket' ] ) ; $ client = new CouchbaseCache ( ) ; $ client -> setCouchbase ( $ couchbase ) ; return new DoctrineCachePool ( $ client ) ; } 
public function load ( array $ configs , ContainerBuilder $ container ) { $ configuration = new Configuration ( ) ; $ config = $ this -> processConfiguration ( $ configuration , $ configs ) ; $ loader = new Loader \ YamlFileLoader ( $ container , new FileLocator ( __DIR__ . '/../Resources/config' ) ) ; $ loader -> load ( 'services.yml' ) ; 
private function findReferences ( array $ options ) { foreach ( $ options as $ key => $ value ) { if ( is_array ( $ value ) ) { $ options [ $ key ] = $ this -> findReferences ( $ value ) ; } elseif ( '_service' === substr ( $ key , - 8 ) || 0 === strpos ( $ value , '@' ) || 'service' === $ key ) { $ options [ $ key ] = new Reference ( ltrim ( $ value , '@' ) ) ; } } return $ options ; } 
public function getAdapter ( array $ config ) { $ client = new Client ( [ 'scheme' => $ config [ 'scheme' ] , 'host' => $ config [ 'host' ] , 'port' => $ config [ 'port' ] , ] ) ; return new DoctrineCachePool ( new PredisCache ( $ client ) ) ; } 
public static function validate ( array $ options , $ adapterName ) { parent :: validate ( $ options , $ adapterName ) ; if ( empty ( $ options [ 'dsn' ] ) ) { return ; } $ dsn = new DSN ( $ options [ 'dsn' ] ) ; if ( ! $ dsn -> isValid ( ) ) { throw new \ InvalidArgumentException ( 'Invalid DSN: ' . $ options [ 'dsn' ] ) ; } } 
public function createAdapter ( array $ options = [ ] ) { if ( ! empty ( $ options [ 'dsn' ] ) ) { $ dsn = new DSN ( $ options [ 'dsn' ] ) ; if ( ! $ dsn -> isValid ( ) ) { throw new \ InvalidArgumentException ( 'Invalid DSN: ' . $ options [ 'dsn' ] ) ; } $ this -> DSN = $ dsn ; } return parent :: createAdapter ( $ options ) ; } 
public function getAdapter ( array $ config ) { $ client = new Memcache ( ) ; $ client -> connect ( $ config [ 'host' ] , $ config [ 'port' ] ) ; foreach ( $ config [ 'redundant_servers' ] as $ server ) { if ( ! isset ( $ server [ 'host' ] ) ) { continue ; } $ port = $ config [ 'port' ] ; if ( isset ( $ server [ 'port' ] ) ) { $ port = $ server [ 'port' ] ; } $ client -> addserver ( $ server [ 'host' ] , $ port ) ; } return new MemcacheCachePool ( $ client ) ; } 
public function getAdapter ( array $ config ) { $ dsn = $ this -> getDsn ( ) ; if ( empty ( $ dsn ) ) { $ manager = new Manager ( sprintf ( 'mongodb://%s:%s' , $ config [ 'host' ] , $ config [ 'port' ] ) ) ; } else { $ manager = new Manager ( $ dsn -> getDsn ( ) ) ; } $ collection = MongoDBCachePool :: createCollection ( $ manager , $ config [ 'namespace' ] ) ; return new MongoDBCachePool ( $ collection ) ; } 
public function getConfigTreeBuilder ( ) { $ treeBuilder = new TreeBuilder ( 'cache_adapter' ) ; if ( method_exists ( $ treeBuilder , 'getRootNode' ) ) { $ rootNode = $ treeBuilder -> getRootNode ( ) ; } else { $ rootNode = $ treeBuilder -> root ( 'cache_adapter' ) ; } $ rootNode -> children ( ) -> append ( $ this -> getClustersNode ( ) ) -> end ( ) ; return $ treeBuilder ; } 
public function createAdapter ( array $ options = [ ] ) { $ this -> verifyDependencies ( ) ; $ resolver = new OptionsResolver ( ) ; static :: configureOptionResolver ( $ resolver ) ; $ config = $ resolver -> resolve ( $ options ) ; return $ this -> getAdapter ( $ config ) ; } 
public static function validate ( array $ options , $ adapterName ) { static :: verifyDependencies ( ) ; $ resolver = new OptionsResolver ( ) ; static :: configureOptionResolver ( $ resolver ) ; try { $ resolver -> resolve ( $ options ) ; } catch ( \ Exception $ e ) { $ message = sprintf ( 'Error while configure adapter %s. Verify your configuration at "cache_adapter.providers.%s.options". %s' , $ adapterName , $ adapterName , $ e -> getMessage ( ) ) ; throw new ConfigurationException ( $ message , $ e -> getCode ( ) , $ e ) ; } } 
protected static function configureOptionResolver ( OptionsResolver $ resolver ) { parent :: configureOptionResolver ( $ resolver ) ; $ resolver -> setRequired ( [ 'namespace' , 'service' ] ) ; $ resolver -> setAllowedTypes ( 'namespace' , [ 'string' ] ) ; } 
protected static function configureOptionResolver ( OptionsResolver $ resolver ) { parent :: configureOptionResolver ( $ resolver ) ; $ resolver -> setRequired ( 'services' ) ; $ resolver -> setAllowedTypes ( 'services' , [ 'array' ] ) ; $ resolver -> setDefault ( 'skip_on_failure' , false ) ; } 
public function getAdapter ( array $ config ) { $ client = new FilesystemCache ( $ config [ 'directory' ] , $ config [ 'extension' ] , ( int ) $ config [ 'umask' ] ) ; return new DoctrineCachePool ( $ client ) ; } 
protected static function configureOptionResolver ( OptionsResolver $ resolver ) { $ resolver -> setDefaults ( [ 'extension' => FilesystemCache :: EXTENSION , 'umask' => '0002' , ] ) ; $ resolver -> setRequired ( [ 'directory' ] ) ; $ resolver -> setAllowedTypes ( 'directory' , [ 'string' ] ) ; $ resolver -> setAllowedTypes ( 'extension' , [ 'string' ] ) ; $ resolver -> setAllowedTypes ( 'umask' , [ 'string' , 'int' ] ) ; } 
public function getAdapter ( array $ config ) { $ connection = new Connection ( $ config [ 'host' ] , $ config [ 'port' ] ) ; $ bucket = new Bucket ( $ connection , $ config [ 'type' ] ) ; return new DoctrineCachePool ( new RiakCache ( $ bucket ) ) ; } 
public function getAdapter ( array $ config ) { $ client = new Memcached ( $ config [ 'persistent_id' ] ) ; $ client -> addServer ( $ config [ 'host' ] , $ config [ 'port' ] ) ; foreach ( $ config [ 'redundant_servers' ] as $ server ) { if ( ! isset ( $ server [ 'host' ] ) ) { continue ; } $ port = $ config [ 'port' ] ; if ( isset ( $ server [ 'port' ] ) ) { $ port = $ server [ 'port' ] ; } $ client -> addServer ( $ server [ 'host' ] , $ port ) ; } foreach ( $ config [ 'driver_options' ] as $ constant => $ value ) { $ client -> setOption ( constant ( $ constant ) , $ value ) ; } $ pool = new MemcachedCachePool ( $ client ) ; if ( null !== $ config [ 'pool_namespace' ] ) { $ pool = new NamespacedCachePool ( $ pool , $ config [ 'pool_namespace' ] ) ; } return $ pool ; } 
public function getAdapter ( array $ config ) { $ dsn = $ this -> getDsn ( ) ; if ( empty ( $ dsn ) ) { $ client = new Client ( [ 'scheme' => $ config [ 'scheme' ] , 'host' => $ config [ 'host' ] , 'port' => $ config [ 'port' ] , 'persistent' => $ config [ 'persistent' ] , ] ) ; } else { $ client = new Client ( $ dsn -> getDsn ( ) ) ; } $ pool = new PredisCachePool ( $ client ) ; if ( null !== $ config [ 'pool_namespace' ] ) { $ pool = new NamespacedCachePool ( $ pool , $ config [ 'pool_namespace' ] ) ; } return $ pool ; } 
public function addServer ( $ host , $ port , $ weight = 0 ) { $ serverList = $ this -> getServerList ( ) ; foreach ( $ serverList as $ server ) { if ( $ server [ 'host' ] === $ host && $ server [ 'port' ] === $ port ) { return false ; } } return parent :: addServer ( $ host , $ port , $ weight ) ; } 
public function getAdapter ( array $ config ) { $ memcached = new Memcached ( ) ; $ memcached -> addServer ( $ config [ 'host' ] , $ config [ 'port' ] ) ; $ client = new MemcachedCache ( ) ; $ client -> setMemcached ( $ memcached ) ; return new DoctrineCachePool ( $ client ) ; } 
public function process ( ContainerBuilder $ container ) { $ serviceIds = array_keys ( $ container -> findTaggedServiceIds ( 'cache.provider' ) ) ; foreach ( $ serviceIds as $ serviceId ) { $ instance = $ container -> get ( $ serviceId ) ; $ class = get_class ( $ instance ) ; $ container -> setAlias ( $ class , $ serviceId ) ; } } 
public function getAdapter ( array $ config ) { $ mongo = new MongoClient ( ) ; $ collection = $ mongo -> selectCollection ( $ config [ 'host' ] , $ config [ 'collection' ] ) ; return new DoctrineCachePool ( new MongoDBCache ( $ collection ) ) ; } 
public function getAdapter ( array $ config ) { $ pool = new ArrayCachePool ( ) ; if ( null !== $ config [ 'pool_namespace' ] ) { $ pool = new NamespacedCachePool ( $ pool , $ config [ 'pool_namespace' ] ) ; } return $ pool ; } 
public function syncFile ( $ relativeUrl , $ forceDownload = false , $ allowMissing = false ) { $ fs = new Filesystem ( ) ; 
public static function fromXdr ( XdrBuffer $ xdr ) { $ model = new ChangeTrustResult ( ) ; $ rawErrorCode = $ xdr -> readInteger ( ) ; $ errorCodeMap = [ '0' => 'success' , '-1' => static :: MALFORMED , '-2' => static :: NO_ISSUER , '-3' => static :: INVALID_LIMIT , '-4' => static :: LOW_RESERVE , '-5' => static :: SELF_NOT_ALLOWED , ] ; if ( ! isset ( $ errorCodeMap [ $ rawErrorCode ] ) ) { throw new \ ErrorException ( sprintf ( 'Unknown error code %s' , $ rawErrorCode ) ) ; } 
public static function newMasterNode ( $ entropy ) { $ hmac = hash_hmac ( 'sha512' , $ entropy , 'ed25519 seed' , true ) ; return new HdNode ( substr ( $ hmac , 0 , 32 ) , substr ( $ hmac , 32 , 32 ) ) ; } 
public function derivePath ( $ path ) { $ pathParts = $ this -> parseDerivationPath ( $ path ) ; $ derived = $ this ; foreach ( $ pathParts as $ index ) { $ derived = $ derived -> derive ( $ index ) ; } return $ derived ; } 
protected function parseDerivationPath ( $ path ) { $ parsed = [ ] ; $ parts = explode ( '/' , $ path ) ; if ( strtolower ( $ parts [ 0 ] ) != 'm' ) throw new \ InvalidArgumentException ( 'Path must start with "m"' ) ; 
public static function fromXdr ( XdrBuffer $ xdr ) { $ model = new InflationResult ( ) ; $ rawErrorCode = $ xdr -> readInteger ( ) ; $ errorCodeMap = [ '0' => 'success' , '-1' => static :: NOT_TIME , ] ; if ( ! isset ( $ errorCodeMap [ $ rawErrorCode ] ) ) { throw new \ ErrorException ( sprintf ( 'Unknown error code %s' , $ rawErrorCode ) ) ; } 
public static function fromXdr ( XdrBuffer $ xdr ) { $ opResultCode = $ xdr -> readInteger ( ) ; 
public static function isValidAccount ( $ accountId ) { 
public function getNativeBalance ( ) { MathSafety :: require64Bit ( ) ; foreach ( $ this -> getBalances ( ) as $ balance ) { if ( $ balance -> isNativeAsset ( ) ) return $ balance -> getBalance ( ) ; } return 0 ; } 
public function getNativeBalanceStroops ( ) { MathSafety :: require64Bit ( ) ; foreach ( $ this -> getBalances ( ) as $ balance ) { if ( $ balance -> isNativeAsset ( ) ) return $ balance -> getUnscaledBalance ( ) ; } return "0" ; } 
public function getCustomAssetBalanceValue ( Asset $ asset ) { foreach ( $ this -> getBalances ( ) as $ balance ) { if ( $ balance -> getAssetCode ( ) !== $ asset -> getAssetCode ( ) ) continue ; if ( $ balance -> getAssetIssuerAccountId ( ) != $ asset -> getIssuer ( ) -> getAccountIdString ( ) ) continue ; return $ balance -> getBalance ( ) ; } return null ; } 
public function getCustomAssetBalance ( Asset $ asset ) { foreach ( $ this -> getBalances ( ) as $ balance ) { if ( $ balance -> getAssetCode ( ) !== $ asset -> getAssetCode ( ) ) continue ; if ( $ balance -> getAssetIssuerAccountId ( ) != $ asset -> getIssuer ( ) -> getAccountIdString ( ) ) continue ; return $ balance ; } return null ; } 
public function getCustomAssetBalanceStroops ( Asset $ asset ) { MathSafety :: require64Bit ( ) ; foreach ( $ this -> getBalances ( ) as $ balance ) { if ( $ balance -> getAssetCode ( ) !== $ asset -> getAssetCode ( ) ) continue ; if ( $ balance -> getAssetIssuerAccountId ( ) != $ asset -> getIssuer ( ) -> getAccountIdString ( ) ) continue ; return $ balance -> getUnscaledBalance ( ) ; } return null ; } 
public static function getEntropyChecksumHex ( $ entropyBytes ) { $ checksumLengthBits = ( strlen ( $ entropyBytes ) * 8 ) / 32 ; $ hashBytes = hash ( 'sha256' , $ entropyBytes , true ) ; 
public static function bitstringToHex ( $ bitstring ) { $ chunkSizeBits = 8 ; 
public function mnemonicToEntropy ( $ mnenomic ) { $ bitstring = $ this -> parseMnemonic ( $ mnenomic ) ; 
public function mnemonicToSeedBytesWithErrorChecking ( $ mnemonic , $ passphrase = '' ) { 
protected function parseMnemonic ( $ mnemonic ) { $ words = explode ( ' ' , $ mnemonic ) ; if ( count ( $ words ) % 3 !== 0 ) throw new \ InvalidArgumentException ( 'Invalid mnemonic (number of words must be a multiple of 3)' ) ; $ wordBitstrings = [ ] ; foreach ( $ words as $ word ) { $ wordIdx = $ this -> getWordIndex ( $ word ) ; 
public function signWith ( SigningInterface $ signer ) { $ decoratedSignature = $ signer -> signTransaction ( $ this ) ; $ this -> signatures [ ] = $ decoratedSignature ; return $ decoratedSignature ; } 
public function authorizeTrustline ( Asset $ asset , $ trustorId , $ sourceAccountId = null ) { if ( $ trustorId instanceof Keypair ) { $ trustorId = $ trustorId -> getPublicKey ( ) ; } $ op = new AllowTrustOp ( $ asset , new AccountId ( $ trustorId ) , $ sourceAccountId ) ; $ op -> setIsAuthorized ( true ) ; return $ this -> addOperation ( $ op ) ; } 
public function revokeTrustline ( Asset $ asset , $ trustorId , $ sourceAccountId = null ) { if ( $ trustorId instanceof Keypair ) { $ trustorId = $ trustorId -> getPublicKey ( ) ; } $ op = new AllowTrustOp ( $ asset , new AccountId ( $ trustorId ) , $ sourceAccountId ) ; $ op -> setIsAuthorized ( false ) ; return $ this -> addOperation ( $ op ) ; } 
public function addMergeOperation ( $ destinationAccountId , $ sourceAccountId = null ) { if ( $ destinationAccountId instanceof Keypair ) { $ destinationAccountId = $ destinationAccountId -> getPublicKey ( ) ; } return $ this -> addOperation ( new AccountMergeOp ( $ destinationAccountId , $ sourceAccountId ) ) ; } 
public static function fromXdr ( XdrBuffer $ xdr ) { $ model = new CreateAccountResult ( ) ; $ rawErrorCode = $ xdr -> readInteger ( ) ; $ errorCodeMap = [ '0' => 'success' , '-1' => static :: MALFORMED , '-2' => static :: UNDERFUNDED , '-3' => static :: LOW_RESERVE , '-4' => static :: ALREADY_EXIST , ] ; if ( ! isset ( $ errorCodeMap [ $ rawErrorCode ] ) ) { throw new \ ErrorException ( sprintf ( 'Unknown error code %s' , $ rawErrorCode ) ) ; } 
public static function fromXdr ( XdrBuffer $ xdr ) { $ model = new AllowTrustResult ( ) ; $ rawErrorCode = $ xdr -> readInteger ( ) ; $ errorCodeMap = [ '0' => 'success' , '-1' => static :: MALFORMED , '-2' => static :: NO_TRUST_LINE , '-3' => static :: TRUST_NOT_REQUIRED , '-4' => static :: CANT_REVOKE , '-5' => static :: SELF_NOT_ALLOWED , ] ; if ( ! isset ( $ errorCodeMap [ $ rawErrorCode ] ) ) { throw new \ ErrorException ( sprintf ( 'Unknown error code %s' , $ rawErrorCode ) ) ; } 
public function toXdr ( ) { $ bytes = '' ; 
public static function opaqueVariable ( $ value ) { $ maxLength = pow ( 2 , 32 ) - 1 ; if ( strlen ( $ value ) > $ maxLength ) throw new \ InvalidArgumentException ( sprintf ( 'Value of length %s is greater than the maximum allowed length of %s' , strlen ( $ value ) , $ maxLength ) ) ; $ bytes = '' ; $ bytes .= self :: unsignedInteger ( strlen ( $ value ) ) ; $ bytes .= self :: applyPadding ( $ value ) ; return $ bytes ; } 
public static function signedBigInteger64 ( BigInteger $ value ) { $ xdrBytes = '' ; $ bigIntBytes = $ value -> toBytes ( true ) ; $ bigIntBits = $ value -> toBits ( true ) ; 
public static function unsignedBigInteger64 ( BigInteger $ value ) { $ xdrBytes = '' ; $ bigIntBytes = $ value -> toBytes ( true ) ; 
public static function optional ( XdrEncodableInterface $ value = null ) { $ bytes = '' ; if ( $ value !== null ) { $ bytes .= self :: boolean ( true ) ; $ bytes .= $ value -> toXdr ( ) ; } else { $ bytes .= self :: boolean ( false ) ; } return $ bytes ; } 
private static function applyPadding ( $ value , $ targetLength = 4 , $ rightPadding = true ) { 
public static function fromXdr ( XdrBuffer $ xdr ) { $ model = new ManageOfferResult ( ) ; $ rawErrorCode = $ xdr -> readInteger ( ) ; $ errorCodeMap = [ '0' => 'success' , '-1' => static :: MALFORMED , '-2' => static :: SELL_NO_TRUST , '-3' => static :: BUY_NO_TRUST , '-4' => static :: SELL_NOT_AUTHORIZED , '-5' => static :: BUY_NOT_AUTHORIZED , '-6' => static :: LINE_FULL , '-7' => static :: UNDERFUNDED , '-8' => static :: CROSS_SELF , '-9' => static :: SELL_NO_ISSUER , '-10' => static :: BUY_NO_ISSUER , '-11' => static :: NOT_FOUND , '-12' => static :: LOW_RESERVE , ] ; if ( ! isset ( $ errorCodeMap [ $ rawErrorCode ] ) ) { throw new \ ErrorException ( sprintf ( 'Unknown error code %s' , $ rawErrorCode ) ) ; } 
public function getUniqueBucketHashes ( ) { $ hashes = [ ] ; if ( $ this -> curr != self :: HASH_EMPTY ) $ hashes [ ] = $ this -> curr ; if ( $ this -> snap != self :: HASH_EMPTY ) $ hashes [ ] = $ this -> snap ; return array_values ( array_unique ( $ hashes ) ) ; } 
public static function fromXdr ( XdrBuffer $ xdr ) { $ model = new SetOptionsResult ( ) ; $ rawErrorCode = $ xdr -> readInteger ( ) ; $ errorCodeMap = [ '0' => 'success' , '-1' => static :: LOW_RESERVE , '-2' => static :: TOO_MANY_SIGNERS , '-3' => static :: BAD_FLAGS , '-4' => static :: INVALID_INFLATION , '-5' => static :: CANT_CHANGE , '-6' => static :: UNKNOWN_FLAG , '-7' => static :: THRESHOLD_OUT_OF_RANGE , '-8' => static :: BAD_SIGNER , '-9' => static :: INVALID_HOME_DOMAIN , ] ; if ( ! isset ( $ errorCodeMap [ $ rawErrorCode ] ) ) { throw new \ ErrorException ( sprintf ( 'Unknown error code %s' , $ rawErrorCode ) ) ; } 
public static function hexDump ( $ data , $ newline = "\n" ) { $ output = '' ; static $ from = '' ; static $ to = '' ; static $ width = 16 ; # number of bytes per line static $ pad = '.' ; # padding for non-visible characters if ( $ from === '' ) { for ( $ i = 0 ; $ i <= 0xFF ; $ i ++ ) { $ from .= chr ( $ i ) ; $ to .= ( $ i >= 0x20 && $ i <= 0x7E ) ? chr ( $ i ) : $ pad ; } } $ hex = str_split ( bin2hex ( $ data ) , $ width * 2 ) ; $ chars = str_split ( strtr ( $ data , $ from , $ to ) , $ width ) ; $ offset = 0 ; foreach ( $ hex as $ i => $ line ) { $ output .= sprintf ( '%6X' , $ offset ) . ' : ' . implode ( ' ' , str_split ( $ line , 2 ) ) . ' [' . $ chars [ $ i ] . ']' . $ newline ; $ offset += $ width ; } return $ output ; } 
public static function fromXdr ( XdrBuffer $ xdr ) { $ destination = AccountId :: fromXdr ( $ xdr ) ; return new AccountMergeOp ( $ destination -> getAccountIdString ( ) ) ; } 
public function getField ( $ fieldName ) { if ( ! isset ( $ this -> rawData [ $ fieldName ] ) ) return null ; return $ this -> rawData [ $ fieldName ] ; } 
public function mustGetField ( $ fieldName ) { if ( ! isset ( $ this -> rawData [ $ fieldName ] ) ) throw new \ InvalidArgumentException ( sprintf ( "Field '%s' not present in response" , $ fieldName ) ) ; return $ this -> rawData [ $ fieldName ] ; } 
public function getAccount ( $ accountId ) { 
public function accountExists ( $ accountId ) { 
public function setAuthRequired ( $ isRequired ) { if ( $ isRequired ) { $ this -> setFlags = $ this -> setFlags | static :: FLAG_AUTH_REQUIRED ; $ this -> clearFlags = $ this -> clearFlags & ~ ( static :: FLAG_AUTH_REQUIRED ) ; } else { $ this -> setFlags = $ this -> setFlags & ~ ( static :: FLAG_AUTH_REQUIRED ) ; $ this -> clearFlags = $ this -> clearFlags | static :: FLAG_AUTH_REQUIRED ; } return $ this ; } 
public function setAuthRevocable ( $ isRevocable ) { if ( $ isRevocable ) { $ this -> setFlags = $ this -> setFlags | static :: FLAG_AUTH_REVOCABLE ; $ this -> clearFlags = $ this -> clearFlags & ~ ( static :: FLAG_AUTH_REVOCABLE ) ; } else { $ this -> setFlags = $ this -> setFlags & ~ ( static :: FLAG_AUTH_REVOCABLE ) ; $ this -> clearFlags = $ this -> clearFlags | static :: FLAG_AUTH_REVOCABLE ; } return $ this ; } 
public static function fromHashX ( $ x ) { $ signerKey = new SignerKey ( static :: TYPE_HASH_X ) ; $ signerKey -> key = hash ( 'sha256' , $ x , true ) ; return $ signerKey ; } 
public static function fromRawResponse ( $ requestedUrl , $ httpMethod , $ raw , ClientException $ clientException = null ) { $ title = isset ( $ raw [ 'title' ] ) ? $ raw [ 'title' ] : 'Unknown Exception' ; $ exception = new HorizonException ( $ title , $ clientException ) ; $ exception -> title = $ title ; $ exception -> requestedUrl = $ requestedUrl ; $ exception -> httpMethod = $ httpMethod ; if ( isset ( $ raw [ 'type' ] ) ) $ exception -> type = $ raw [ 'type' ] ; if ( isset ( $ raw [ 'status' ] ) ) $ exception -> httpStatusCode = $ raw [ 'status' ] ; if ( isset ( $ raw [ 'detail' ] ) ) $ exception -> detail = $ raw [ 'detail' ] ; if ( ! empty ( $ raw [ 'extras' ] [ 'result_codes' ] [ 'operations' ] ) ) { $ exception -> operationResultCodes = $ raw [ 'extras' ] [ 'result_codes' ] [ 'operations' ] ; } if ( ! empty ( $ raw [ 'extras' ] [ 'result_codes' ] [ 'transaction' ] ) ) { $ exception -> transactionResultCode = $ raw [ 'extras' ] [ 'result_codes' ] [ 'transaction' ] ; } 
public static function newFromMnemonic ( $ mnemonic , $ passphrase = '' , $ index = 0 ) { $ bip39 = new Bip39 ( ) ; $ seedBytes = $ bip39 -> mnemonicToSeedBytesWithErrorChecking ( $ mnemonic , $ passphrase ) ; $ masterNode = HdNode :: newMasterNode ( $ seedBytes ) ; $ accountNode = $ masterNode -> derivePath ( sprintf ( "m/44'/148'/%s'" , $ index ) ) ; return static :: newFromRawSeed ( $ accountNode -> getPrivateKeyBytes ( ) ) ; } 
public function getPublicKeyChecksum ( ) { $ checksumBytes = substr ( $ this -> getPublicKeyBytes ( ) , - 2 ) ; $ unpacked = unpack ( 'v' , $ checksumBytes ) ; return array_shift ( $ unpacked ) ; } 
protected static function crc16 ( $ binaryString ) { $ crc = 0x0000 ; $ polynomial = 0x1021 ; foreach ( str_split ( $ binaryString ) as $ byte ) { $ byte = ord ( $ byte ) ; for ( $ i = 0 ; $ i < 8 ; $ i ++ ) { $ bit = ( ( $ byte >> ( 7 - $ i ) & 1 ) == 1 ) ; $ c15 = ( ( $ crc >> 15 & 1 ) == 1 ) ; $ crc <<= 1 ; if ( $ c15 ^ $ bit ) $ crc ^= $ polynomial ; } } return $ crc & 0xffff ; } 
public static function fromXdr ( XdrBuffer $ xdr ) { $ model = new AccountMergeResult ( ) ; $ rawErrorCode = $ xdr -> readInteger ( ) ; $ errorCodeMap = [ '0' => 'success' , '-1' => static :: MALFORMED , '-2' => static :: NO_ACCOUNT , '-3' => static :: IMMUTABLE_SET , '-4' => static :: HAS_SUB_ENTRIES , ] ; if ( ! isset ( $ errorCodeMap [ $ rawErrorCode ] ) ) { throw new \ ErrorException ( sprintf ( 'Unknown error code %s' , $ rawErrorCode ) ) ; } 
public static function opaqueFixedString ( $ xdr , $ length ) { $ bytes = static :: opaqueFixed ( $ xdr , $ length ) ; 
public static function addressFromRawBytes ( $ rawBytes ) { $ version = pack ( 'C' , self :: VERSION_BYTE_ACCOUNT_ID ) ; $ payload = $ rawBytes ; $ checksum = Checksum :: generate ( $ version . $ payload ) ; return Base32 :: encode ( $ version . $ payload . $ checksum ) ; } 
public static function fromXdr ( XdrBuffer $ xdr ) { $ model = new BumpSequenceResult ( ) ; $ rawErrorCode = $ xdr -> readInteger ( ) ; $ errorCodeMap = [ '0' => 'success' , '-1' => static :: BAD_SEQ , ] ; if ( ! isset ( $ errorCodeMap [ $ rawErrorCode ] ) ) { throw new \ ErrorException ( sprintf ( 'Unknown error code %s' , $ rawErrorCode ) ) ; } 
public static function fromXdr ( XdrBuffer $ xdr ) { $ model = new ManageDataResult ( ) ; $ rawErrorCode = $ xdr -> readInteger ( ) ; $ errorCodeMap = [ '0' => 'success' , '-1' => static :: NOT_SUPPORTED_YET , '-2' => static :: NAME_NOT_FOUND , '-3' => static :: LOW_RESERVE , '-4' => static :: INVALID_NAME , ] ; if ( ! isset ( $ errorCodeMap [ $ rawErrorCode ] ) ) { throw new \ ErrorException ( sprintf ( 'Unknown error code %s' , $ rawErrorCode ) ) ; } 
public static function fromXdr ( XdrBuffer $ xdr ) { $ model = new PaymentResult ( ) ; $ rawErrorCode = $ xdr -> readInteger ( ) ; $ errorCodeMap = [ '0' => 'success' , '-1' => static :: MALFORMED , '-2' => static :: UNDERFUNDED , '-3' => static :: SRC_NO_TRUST , '-4' => static :: SRC_NOT_AUTHORIZED , '-5' => static :: NO_DESTINATION , '-6' => static :: NO_TRUST , '-7' => static :: NOT_AUTHORIZED , '-8' => static :: LINE_FULL , '-9' => static :: NO_ISSUER , ] ; if ( ! isset ( $ errorCodeMap [ $ rawErrorCode ] ) ) { throw new \ ErrorException ( sprintf ( 'Unknown error code %s' , $ rawErrorCode ) ) ; } 
public static function fromXdr ( XdrBuffer $ xdr ) { $ model = new PathPaymentResult ( ) ; $ rawErrorCode = $ xdr -> readInteger ( ) ; $ errorCodeMap = [ '0' => 'success' , '-1' => static :: MALFORMED , '-2' => static :: UNDERFUNDED , '-3' => static :: SRC_NO_TRUST , '-4' => static :: SRC_NOT_AUTHORIZED , '-5' => static :: NO_DESTINATION , '-6' => static :: NO_TRUST , '-7' => static :: NOT_AUTHORIZED , '-8' => static :: LINE_FULL , '-9' => static :: NO_ISSUER , '-10' => static :: TOO_FEW_OFFERS , '-11' => static :: OFFER_CROSS_SELF , '-12' => static :: OVER_SENDMAX , ] ; if ( ! isset ( $ errorCodeMap [ $ rawErrorCode ] ) ) { throw new \ ErrorException ( sprintf ( 'Unknown error code %s' , $ rawErrorCode ) ) ; } 
protected function parseRawData ( $ rawData ) { if ( ! $ rawData ) return ; if ( ! empty ( $ rawData [ 'result_xdr' ] ) ) { $ xdr = new XdrBuffer ( base64_decode ( $ rawData [ 'result_xdr' ] ) ) ; $ this -> result = TransactionResult :: fromXdr ( $ xdr ) ; } } 
public function sign ( $ keypairsOrsecretKeyStrings , Server $ server = null ) { if ( ! is_array ( $ keypairsOrsecretKeyStrings ) ) $ keypairsOrsecretKeyStrings = [ $ keypairsOrsecretKeyStrings ] ; $ transactionHash = null ; if ( $ server ) { $ transactionHash = $ server -> getApiClient ( ) -> hash ( $ this -> transactionBuilder ) ; } else { $ transactionHash = $ this -> transactionBuilder -> hash ( ) ; } foreach ( $ keypairsOrsecretKeyStrings as $ keypairOrSecretKeyString ) { if ( is_string ( $ keypairOrSecretKeyString ) ) { $ keypairOrSecretKeyString = Keypair :: newFromSeed ( $ keypairOrSecretKeyString ) ; } $ decorated = $ keypairOrSecretKeyString -> signDecorated ( $ transactionHash ) ; $ this -> signatures -> append ( $ decorated ) ; } return $ this ; } 
public function submitTransaction ( TransactionBuilder $ transactionBuilder , $ signingAccountSeedString ) { $ transactionEnvelope = $ transactionBuilder -> sign ( $ signingAccountSeedString ) ; return $ this -> submitB64Transaction ( base64_encode ( $ transactionEnvelope -> toXdr ( ) ) ) ; } 
public function streamEffects ( $ sinceCursor = 'now' , callable $ callback = null ) { $ url = sprintf ( '/effects' ) ; $ params = [ ] ; if ( $ sinceCursor ) $ params [ 'cursor' ] = $ sinceCursor ; if ( $ params ) { $ url .= '?' . http_build_query ( $ params ) ; } $ this -> getAndStream ( $ url , function ( $ rawData ) use ( $ callback ) { $ parsedObject = Effect :: fromRawResponseData ( $ rawData ) ; $ parsedObject -> setApiClient ( $ this ) ; $ callback ( $ parsedObject ) ; } ) ; } 
public function streamLedgers ( $ sinceCursor = 'now' , callable $ callback = null ) { $ url = sprintf ( '/ledgers' ) ; $ params = [ ] ; if ( $ sinceCursor ) $ params [ 'cursor' ] = $ sinceCursor ; if ( $ params ) { $ url .= '?' . http_build_query ( $ params ) ; } $ this -> getAndStream ( $ url , function ( $ rawData ) use ( $ callback ) { $ parsedObject = Ledger :: fromRawResponseData ( $ rawData ) ; $ parsedObject -> setApiClient ( $ this ) ; $ callback ( $ parsedObject ) ; } ) ; } 
public function streamOperations ( $ sinceCursor = 'now' , callable $ callback = null ) { $ url = sprintf ( '/operations' ) ; $ params = [ ] ; if ( $ sinceCursor ) $ params [ 'cursor' ] = $ sinceCursor ; if ( $ params ) { $ url .= '?' . http_build_query ( $ params ) ; } $ this -> getAndStream ( $ url , function ( $ rawData ) use ( $ callback ) { $ parsedObject = Operation :: fromRawResponseData ( $ rawData ) ; $ parsedObject -> setApiClient ( $ this ) ; $ callback ( $ parsedObject ) ; } ) ; } 
public function streamPayments ( $ sinceCursor = 'now' , callable $ callback = null ) { $ url = sprintf ( '/payments' ) ; $ params = [ ] ; if ( $ sinceCursor ) $ params [ 'cursor' ] = $ sinceCursor ; if ( $ params ) { $ url .= '?' . http_build_query ( $ params ) ; } $ this -> getAndStream ( $ url , function ( $ rawData ) use ( $ callback ) { switch ( $ rawData [ 'type' ] ) { case 'create_account' : $ parsedObject = CreateAccountOperation :: fromRawResponseData ( $ rawData ) ; break ; case 'payment' : $ parsedObject = Payment :: fromRawResponseData ( $ rawData ) ; break ; case 'account_merge' : $ parsedObject = AccountMergeOperation :: fromRawResponseData ( $ rawData ) ; break ; case 'path_payment' : $ parsedObject = PathPayment :: fromRawResponseData ( $ rawData ) ; break ; } $ parsedObject -> setApiClient ( $ this ) ; $ callback ( $ parsedObject ) ; } ) ; } 
public function streamTransactions ( $ sinceCursor = 'now' , callable $ callback = null ) { $ url = sprintf ( '/transactions' ) ; $ params = [ ] ; if ( $ sinceCursor ) $ params [ 'cursor' ] = $ sinceCursor ; if ( $ params ) { $ url .= '?' . http_build_query ( $ params ) ; } $ this -> getAndStream ( $ url , function ( $ rawData ) use ( $ callback ) { $ parsedObject = Transaction :: fromRawResponseData ( $ rawData ) ; $ parsedObject -> setApiClient ( $ this ) ; $ callback ( $ parsedObject ) ; } ) ; } 
protected function postTransaction ( $ relativeUrl , $ parameters = array ( ) ) { $ apiResponse = null ; try { $ apiResponse = $ this -> httpClient -> post ( $ relativeUrl , [ 'form_params' => $ parameters ] ) ; } catch ( ClientException $ e ) { 
public function fromText ( $ patchText ) { $ patches = array ( ) ; if ( ! $ patchText ) { return $ patches ; } $ lines = explode ( "\n" , $ patchText ) ; while ( count ( $ lines ) ) { $ line = $ lines [ 0 ] ; if ( ! preg_match ( "/^@@ -(\d+),?(\d*) \+(\d+),?(\d*) @@$/" , $ line , $ m ) ) { throw new \ InvalidArgumentException ( "Invalid patch string: " . $ line ) ; } $ patch = new PatchObject ( ) ; $ patch -> setStart1 ( $ m [ 1 ] ) ; if ( $ m [ 2 ] == '' ) { $ patch -> setStart1 ( $ patch -> getStart1 ( ) - 1 ) ; $ patch -> setLength1 ( 1 ) ; } elseif ( $ m [ 2 ] == '0' ) { $ patch -> setLength1 ( 0 ) ; } else { $ patch -> setStart1 ( $ patch -> getStart1 ( ) - 1 ) ; $ patch -> setLength1 ( $ m [ 2 ] ) ; } $ patch -> setStart2 ( $ m [ 3 ] ) ; if ( $ m [ 4 ] == '' ) { $ patch -> setStart2 ( $ patch -> getStart2 ( ) - 1 ) ; $ patch -> setLength2 ( 1 ) ; } elseif ( $ m [ 4 ] == '0' ) { $ patch -> setLength2 ( 0 ) ; } else { $ patch -> setStart2 ( $ patch -> getStart2 ( ) - 1 ) ; $ patch -> setLength2 ( $ m [ 4 ] ) ; } $ patches [ ] = $ patch ; array_shift ( $ lines ) ; while ( count ( $ lines ) ) { $ line = $ lines [ 0 ] ; if ( $ line ) { $ sign = mb_substr ( $ line , 0 , 1 ) ; } else { $ sign = '' ; } $ text = Utils :: unescapeString ( mb_substr ( $ line , 1 ) ) ; switch ( $ sign ) { case '+' : 
public function toText ( $ patches ) { $ text = '' ; foreach ( $ patches as $ patch ) { $ text .= ( string ) $ patch ; } return $ text ; } 
public function addContext ( PatchObject $ patch , $ text ) { if ( ! mb_strlen ( $ text ) ) { return ; } $ padding = 0 ; $ pattern = mb_substr ( $ text , $ patch -> getStart1 ( ) , $ patch -> getLength1 ( ) ) ; 
public function make ( $ a , $ b = null , $ c = null ) { $ diff = $ this -> getDiff ( ) ; if ( is_string ( $ a ) && is_string ( $ b ) && is_null ( $ c ) ) { 
public function splitMax ( & $ patches ) { $ patchSize = $ this -> getMatch ( ) -> getMaxBits ( ) ; if ( $ patchSize == 0 ) { 
public function addPadding ( & $ patches ) { $ paddingLength = $ this -> getMargin ( ) ; $ nullPadding = '' ; for ( $ i = 1 ; $ i <= $ paddingLength ; $ i ++ ) { $ nullPadding .= chr ( $ i ) ; } 
public function apply ( $ patches , $ text ) { if ( empty ( $ patches ) ) { return array ( $ text , array ( ) ) ; } 
protected function deepCopy ( $ patches ) { $ patchesCopy = array ( ) ; foreach ( $ patches as $ patch ) { $ patchCopy = clone $ patch ; $ patchesCopy [ ] = $ patchCopy ; } return $ patchesCopy ; } 
public function main ( $ text , $ pattern , $ loc = 0 ) { 
public function bitap ( $ text , $ pattern , $ loc ) { if ( $ this -> getMaxBits ( ) != 0 && $ this -> getMaxBits ( ) < mb_strlen ( $ pattern ) ) { throw new \ RangeException ( 'Pattern too long for this application.' ) ; } 
protected function bitapScore ( $ errors , $ matchLoc , $ patternLen , $ searchLoc ) { $ accuracy = $ errors / $ patternLen ; $ proximity = abs ( $ searchLoc - $ matchLoc ) ; if ( ! $ this -> getDistance ( ) ) { 
public function alphabet ( $ pattern ) { $ s = array ( ) ; foreach ( preg_split ( "//u" , $ pattern , - 1 , PREG_SPLIT_NO_EMPTY ) as $ char ) { $ s [ $ char ] = 0 ; } for ( $ i = 0 ; $ i < mb_strlen ( $ pattern ) ; $ i ++ ) { $ s [ mb_substr ( $ pattern , $ i , 1 ) ] |= 1 << ( mb_strlen ( $ pattern ) - $ i - 1 ) ; } return $ s ; } 
public function cleanupMerge ( ) { $ diffs = $ this -> getChanges ( ) ; $ diffs [ ] = array ( self :: EQUAL , '' , ) ; $ pointer = 0 ; $ count_delete = 0 ; $ count_insert = 0 ; $ text_delete = '' ; $ text_insert = '' ; while ( $ pointer < count ( $ diffs ) ) { if ( $ diffs [ $ pointer ] [ 0 ] == self :: INSERT ) { $ count_insert ++ ; $ text_insert .= $ diffs [ $ pointer ] [ 1 ] ; $ pointer ++ ; } elseif ( $ diffs [ $ pointer ] [ 0 ] == self :: DELETE ) { $ count_delete ++ ; $ text_delete .= $ diffs [ $ pointer ] [ 1 ] ; $ pointer ++ ; } elseif ( $ diffs [ $ pointer ] [ 0 ] == self :: EQUAL ) { 
public function cleanupSemanticLossless ( ) { $ diffs = $ this -> getChanges ( ) ; $ pointer = 1 ; 
protected function cleanupSemanticScore ( $ one , $ two ) { if ( $ one == '' || $ two == '' ) { 
public function cleanupSemantic ( ) { $ diffs = $ this -> getChanges ( ) ; $ changes = false ; 
public function cleanupEfficiency ( ) { $ diffs = $ this -> getChanges ( ) ; $ changes = false ; 
public function prettyHtml ( ) { $ diffs = $ this -> getChanges ( ) ; $ html = '' ; foreach ( $ diffs as $ change ) { $ op = $ change [ 0 ] ; $ data = $ change [ 1 ] ; $ text = str_replace ( array ( '&' , '<' , '>' , "\n" , ) , array ( '&amp;' , '&lt;' , '&gt;' , '&para;<br>' , ) , $ data ) ; if ( $ op == self :: INSERT ) { $ html .= '<ins style="background:#e6ffe6;">' . $ text . '</ins>' ; } elseif ( $ op == self :: DELETE ) { $ html .= '<del style="background:#ffe6e6;">' . $ text . '</del>' ; } else { $ html .= '<span>' . $ text . '</span>' ; } } return $ html ; } 
public function text1 ( ) { $ diffs = $ this -> getChanges ( ) ; $ text = '' ; foreach ( $ diffs as $ change ) { $ op = $ change [ 0 ] ; $ data = $ change [ 1 ] ; if ( $ op != self :: INSERT ) { $ text .= $ data ; } } return $ text ; } 
public function text2 ( ) { $ diffs = $ this -> getChanges ( ) ; $ text = '' ; foreach ( $ diffs as $ change ) { $ op = $ change [ 0 ] ; $ data = $ change [ 1 ] ; if ( $ op != self :: DELETE ) { $ text .= $ data ; } } return $ text ; } 
public function toDelta ( ) { $ diffs = $ this -> getChanges ( ) ; $ text = array ( ) ; foreach ( $ diffs as $ change ) { $ op = $ change [ 0 ] ; $ data = $ change [ 1 ] ; if ( $ op == self :: INSERT ) { $ text [ ] = '+' . Utils :: escapeString ( $ data ) ; } elseif ( $ op == self :: DELETE ) { $ text [ ] = '-' . mb_strlen ( $ data ) ; } else { $ text [ ] = '=' . mb_strlen ( $ data ) ; } } return implode ( "\t" , $ text ) ; } 
public function fromDelta ( $ text1 , $ delta ) { $ diffs = array ( ) ; 
public function xIndex ( $ loc ) { $ diffs = $ this -> getChanges ( ) ; $ chars1 = 0 ; $ chars2 = 0 ; $ last_chars1 = 0 ; $ last_chars2 = 0 ; $ i = 0 ; foreach ( $ diffs as $ change ) { $ op = $ change [ 0 ] ; $ text = $ change [ 1 ] ; 
public function levenshtein ( ) { $ diffs = $ this -> getChanges ( ) ; $ levenshtein = 0 ; $ insertions = 0 ; $ deletions = 0 ; foreach ( $ diffs as $ change ) { $ op = $ change [ 0 ] ; $ text = $ change [ 1 ] ; switch ( $ op ) { case self :: INSERT : $ insertions += mb_strlen ( $ text ) ; break ; case self :: DELETE : $ deletions += mb_strlen ( $ text ) ; break ; case self :: EQUAL : 
public function main ( $ text1 , $ text2 , $ checklines = true , $ deadline = null ) { 
protected function compute ( $ text1 , $ text2 , $ checklines , $ deadline ) { if ( $ text1 == '' ) { 
protected function lineMode ( $ text1 , $ text2 , $ deadline ) { 
protected function bisect ( $ text1 , $ text2 , $ deadline ) { 
protected function bisectSplit ( $ text1 , $ text2 , $ x , $ y , $ deadline ) { $ text1A = mb_substr ( $ text1 , 0 , $ x ) ; $ text2A = mb_substr ( $ text2 , 0 , $ y ) ; $ text1B = mb_substr ( $ text1 , $ x ) ; $ text2B = mb_substr ( $ text2 , $ y ) ; 
public function commonPrefix ( $ text1 , $ text2 ) { 
public function commonSuffix ( $ text1 , $ text2 ) { 
public function commontOverlap ( $ text1 , $ text2 ) { 
public function halfMatch ( $ text1 , $ text2 ) { if ( mb_strlen ( $ text1 ) > mb_strlen ( $ text2 ) ) { $ longtext = $ text1 ; $ shorttext = $ text2 ; } else { $ shorttext = $ text1 ; $ longtext = $ text2 ; } if ( mb_strlen ( $ longtext ) < 4 || mb_strlen ( $ shorttext ) * 2 < mb_strlen ( mb_strlen ( $ longtext ) ) ) { 
protected function halfMatchI ( $ longtext , $ shorttext , $ i ) { $ seed = mb_substr ( $ longtext , $ i , ( int ) ( mb_strlen ( $ longtext ) / 4 ) ) ; $ best_common = $ best_longtext_a = $ best_longtext_b = $ best_shorttext_a = $ best_shorttext_b = '' ; $ j = mb_strpos ( $ shorttext , $ seed ) ; while ( $ j !== false ) { $ prefixLegth = $ this -> commonPrefix ( mb_substr ( $ longtext , $ i ) , mb_substr ( $ shorttext , $ j ) ) ; $ suffixLegth = $ this -> commonSuffix ( mb_substr ( $ longtext , 0 , $ i ) , mb_substr ( $ shorttext , 0 , $ j ) ) ; if ( mb_strlen ( $ best_common ) < $ suffixLegth + $ prefixLegth ) { $ best_common = mb_substr ( $ shorttext , $ j - $ suffixLegth , $ suffixLegth ) . mb_substr ( $ shorttext , $ j , $ prefixLegth ) ; $ best_longtext_a = mb_substr ( $ longtext , 0 , $ i - $ suffixLegth ) ; $ best_longtext_b = mb_substr ( $ longtext , $ i + $ prefixLegth ) ; $ best_shorttext_a = mb_substr ( $ shorttext , 0 , $ j - $ suffixLegth ) ; $ best_shorttext_b = mb_substr ( $ shorttext , $ j + $ prefixLegth ) ; } $ j = mb_strpos ( $ shorttext , $ seed , $ j + 1 ) ; } if ( mb_strlen ( $ best_common ) * 2 >= mb_strlen ( $ longtext ) ) { return array ( $ best_longtext_a , $ best_longtext_b , $ best_shorttext_a , $ best_shorttext_b , $ best_common ) ; } else { return null ; } } 
public function linesToChars ( $ text1 , $ text2 ) { 
protected function linesToCharsMunge ( $ text , array & $ lineArray , array & $ lineHash ) { 
public function charsToLines ( & $ diffs , $ lineArray ) { foreach ( $ diffs as & $ diff ) { $ text = '' ; for ( $ i = 0 ; $ i < mb_strlen ( $ diff [ 1 ] ) ; $ i ++ ) { $ char = mb_substr ( $ diff [ 1 ] , $ i , 1 ) ; $ text .= $ lineArray [ Utils :: unicodeOrd ( $ char ) ] ; } $ diff [ 1 ] = $ text ; } unset ( $ diff ) ; } 
public function diff_main ( $ text1 , $ text2 , $ checklines = true ) { return $ this -> diff -> main ( $ text1 , $ text2 , $ checklines ) -> getChanges ( ) ; } 
public function diff_cleanupSemantic ( & $ diffs ) { $ this -> diff -> setChanges ( $ diffs ) ; $ this -> diff -> cleanupSemantic ( ) ; $ diffs = $ this -> diff -> getChanges ( ) ; } 
public function diff_cleanupEfficiency ( & $ diffs ) { $ this -> diff -> setChanges ( $ diffs ) ; $ this -> diff -> cleanupEfficiency ( ) ; $ diffs = $ this -> diff -> getChanges ( ) ; } 
public function match_main ( $ text , $ pattern , $ loc = 0 ) { return $ this -> match -> main ( $ text , $ pattern , $ loc ) ; } 
public function patch_make ( $ a , $ b = null , $ c = null ) { return $ this -> patch -> make ( $ a , $ b , $ c ) ; } 
public static function unicodeChr ( $ code ) { 
public static function unicodeOrd ( $ char ) { if ( mb_internal_encoding ( ) != 'UCS-2LE' ) { $ char = iconv ( mb_internal_encoding ( ) , 'UCS-2LE' , $ char ) ; } $ code = 0 ; for ( $ i = 0 ; $ i < strlen ( $ char ) ; $ i ++ ) { $ code += ord ( $ char [ $ i ] ) * pow ( 256 , $ i ) ; } return $ code ; } 
public function send ( $ notifiable , Notification $ notification ) { if ( ! ( $ to = $ this -> getRecipients ( $ notifiable , $ notification ) ) ) { return ; } $ message = $ notification -> { 'toSmscRu' } ( $ notifiable ) ; if ( \ is_string ( $ message ) ) { $ message = new SmscRuMessage ( $ message ) ; } $ this -> sendMessage ( $ to , $ message ) ; } 
protected function getRecipients ( $ notifiable , Notification $ notification ) { $ to = $ notifiable -> routeNotificationFor ( 'smscru' , $ notification ) ; if ( $ to === null || $ to === false || $ to === '' ) { return [ ] ; } return \ is_array ( $ to ) ? $ to : [ $ to ] ; } 
public function version ( ) { $ app = $ this -> app ; $ tab = explode ( 'Laravel Components ' , $ app -> version ( ) ) ; return intval ( empty ( $ tab [ 1 ] ) ? $ app :: VERSION : $ tab [ 1 ] ) ; } 
public function register ( ) { 
public function boot ( ) { 
public function registerPugCompiler ( $ subExtension = '' ) { 
public function getConfig ( ) { $ key = $ this -> version ( ) >= 5 ? 'laravel-pug' : 'laravel-pug::config' ; return array_merge ( array ( 'allow_composite_extensions' => true , ) , $ this -> app -> make ( 'config' ) -> get ( $ key ) ) ; } 
public function construct ( array $ pugTarget , Filesystem $ files , array $ config , $ defaultCachePath = null ) { $ this -> pugTarget = $ pugTarget ; $ cachePath = null ; foreach ( array ( 'cache_dir' , 'cache' , 'defaultCache' ) as $ name ) { if ( isset ( $ config [ $ name ] ) ) { $ cachePath = $ config [ $ name ] ; break ; } } if ( ! $ cachePath ) { $ cachePath = $ defaultCachePath ? : $ this -> getCachePath ( ) ; } parent :: __construct ( $ files , $ cachePath ) ; } 
public function getPug ( ) { if ( ! $ this -> pug ) { $ this -> pug = $ this -> pugTarget [ 0 ] [ $ this -> pugTarget [ 1 ] ] ; } return $ this -> pug ; } 
public function getCachePath ( ) { if ( $ this -> cachePath ) { return $ this -> cachePath ; } $ cachePath = $ this -> getOption ( 'cache' ) ; return is_string ( $ cachePath ) ? $ cachePath : $ this -> getOption ( 'defaultCache' ) ; } 
public function getOption ( $ name , $ default = null ) { $ pug = $ this -> getPug ( ) ; try { if ( method_exists ( $ pug , 'hasOption' ) && ! $ pug -> hasOption ( $ name ) ) { throw new \ InvalidArgumentException ( 'invalid option' ) ; } return $ pug -> getOption ( $ name ) ; } catch ( \ InvalidArgumentException $ exception ) { return $ default ; } } 
private function hasExpiredImport ( $ path ) { $ compiled = $ this -> getCompiledPath ( $ path ) ; $ importsMap = $ compiled . '.imports.serialize.txt' ; $ files = $ this -> files ; if ( ! $ files -> exists ( $ importsMap ) ) { return true ; } $ importPaths = unserialize ( $ files -> get ( $ importsMap ) ) ; $ time = $ files -> lastModified ( $ compiled ) ; foreach ( $ importPaths as $ importPath ) { if ( ! $ files -> exists ( $ importPath ) || $ files -> lastModified ( $ importPath ) >= $ time ) { return true ; } } return false ; } 
public function isExpired ( $ path ) { if ( ! $ this -> cachePath || parent :: isExpired ( $ path ) ) { return true ; } return is_subclass_of ( '\Pug\Pug' , '\Phug\Renderer' ) && $ this -> hasExpiredImport ( $ path ) ; } 
public function extractPath ( $ path ) { if ( $ path && method_exists ( $ this , 'setPath' ) ) { $ this -> setPath ( $ path ) ; } if ( ! $ path && method_exists ( $ this , 'getPath' ) ) { $ path = $ this -> getPath ( ) ; } if ( ! $ path ) { throw new InvalidArgumentException ( 'Missing path argument.' ) ; } return $ path ; } 
public function getCompiler ( ) { $ pug = $ this -> getPug ( ) ; if ( $ pug instanceof \ Phug \ Renderer ) { $ pug = clone $ pug -> getCompiler ( ) ; } return $ pug ; } 
public function compileWith ( $ path , callable $ callback = null ) { $ path = $ this -> extractPath ( $ path ) ; if ( $ this -> cachePath ) { $ pug = $ this -> getCompiler ( ) ; $ compiled = $ this -> getCompiledPath ( $ path ) ; $ contents = $ pug -> compile ( $ this -> files -> get ( $ path ) , $ path ) ; if ( $ callback ) { $ contents = call_user_func ( $ callback , $ contents ) ; } if ( $ pug instanceof \ Phug \ Compiler ) { $ this -> files -> put ( $ compiled . '.imports.serialize.txt' , serialize ( $ pug -> getCurrentImportPaths ( ) ) ) ; } $ this -> files -> put ( $ compiled , $ contents ) ; } } 
public function compile ( $ path = null ) { $ app = Blade :: getFacadeApplication ( ) ; if ( isset ( $ app [ 'view' ] ) ) { $ this -> enableBladeDirectives ( ) ; } $ this -> footer = array ( ) ; $ this -> compileWith ( $ path , array ( $ this , 'compileString' ) ) ; } 
public function register ( ) { $ this -> app -> singleton ( 'amocrm' , function ( Container $ app ) { $ config = $ app [ 'config' ] ; return new AmoCrmManager ( $ config ) ; } ) ; $ this -> app -> singleton ( 'amocrm.fields' , function ( Container $ app ) { $ manager = $ app [ 'amocrm' ] ; return $ manager -> getFields ( ) ; } ) ; $ this -> app -> singleton ( 'amocrm.b2bfamily' , function ( Container $ app ) { $ manager = $ app [ 'amocrm' ] ; return $ manager -> getB2BFamily ( ) ; } ) ; } 
public function getClient ( ) { if ( ! $ this -> client instanceof Client ) { $ this -> client = new Client ( $ this -> config -> get ( 'amocrm.domain' ) , $ this -> config -> get ( 'amocrm.login' ) , $ this -> config -> get ( 'amocrm.hash' ) ) ; } return $ this -> client ; } 
public function getB2BFamily ( ) { $ client = $ this -> getClient ( ) ; return new B2BFamily ( $ client , $ this -> config -> get ( 'amocrm.b2bfamily.appkey' ) , $ this -> config -> get ( 'amocrm.b2bfamily.secret' ) , $ this -> config -> get ( 'amocrm.b2bfamily.email' ) , $ this -> config -> get ( 'amocrm.b2bfamily.password' ) ) ; } 
private function hashPrint ( $ input ) { 
private function hasExpiredImport ( $ sourcePath , $ cachePath ) { $ importsMap = $ cachePath . '.imports.serialize.txt' ; if ( ! file_exists ( $ importsMap ) ) { return true ; } $ importPaths = unserialize ( file_get_contents ( $ importsMap ) ) ? : [ ] ; $ importPaths [ ] = $ sourcePath ; $ time = filemtime ( $ cachePath ) ; foreach ( $ importPaths as $ importPath ) { if ( ! file_exists ( $ importPath ) || filemtime ( $ importPath ) >= $ time ) { 
public function resolve ( $ file ) { return $ this -> locator -> locate ( $ file , $ this -> paths , isset ( $ this -> options [ 'extensions' ] ) ? $ this -> options [ 'extensions' ] : [ '' , '.pug' , '.jade' ] ) ; } 
public function isExpired ( $ file , & $ cachePath = null ) { if ( isset ( $ this -> options [ 'up_to_date_check' ] ) && ! $ this -> options [ 'up_to_date_check' ] ) { return false ; } if ( ! $ this -> cacheDirectory ) { return true ; } $ sourcePath = $ this -> resolve ( $ file ) ; $ cachePath = rtrim ( $ this -> cacheDirectory , '\\/' ) . DIRECTORY_SEPARATOR . $ this -> hashPrint ( $ sourcePath ) . '.php' ; if ( ! file_exists ( $ cachePath ) ) { return true ; } return $ this -> hasExpiredImport ( $ sourcePath , $ cachePath ) ; } 
public function displayFile ( $ __pug_file , array $ __pug_parameters = [ ] ) { if ( $ this -> isExpired ( $ __pug_file , $ __pug_cache_file ) ) { if ( isset ( $ this -> options [ 'render' ] ) ) { call_user_func ( $ this -> options [ 'render' ] , $ __pug_file , $ __pug_parameters , $ this -> options ) ; return ; } if ( isset ( $ this -> options [ 'renderer' ] ) ) { $ this -> options [ 'renderer' ] -> displayFile ( $ __pug_file , $ __pug_parameters ) ; return ; } if ( isset ( $ this -> options [ 'renderer_class_name' ] ) ) { $ className = $ this -> options [ 'renderer_class_name' ] ; $ renderer = new $ className ( $ this -> options ) ; $ renderer -> displayFile ( $ __pug_file , $ __pug_parameters ) ; return ; } $ facade = isset ( $ this -> options [ 'facade' ] ) ? $ this -> options [ 'facade' ] : static :: FACADE ; if ( is_callable ( [ $ facade , 'displayFile' ] ) ) { $ facade :: displayFile ( $ __pug_file , $ __pug_parameters , $ this -> options ) ; return ; } throw new \ RuntimeException ( 'No valid render method, renderer engine, renderer class or facade provided.' ) ; } if ( isset ( $ this -> options [ 'shared_variables' ] ) ) { $ __pug_parameters = array_merge ( $ this -> options [ 'shared_variables' ] , $ __pug_parameters ) ; } if ( isset ( $ this -> options [ 'globals' ] ) ) { $ __pug_parameters = array_merge ( $ this -> options [ 'globals' ] , $ __pug_parameters ) ; } if ( isset ( $ this -> options [ 'self' ] ) && $ this -> options [ 'self' ] ) { $ self = $ this -> options [ 'self' ] === true ? 'self' : strval ( $ this -> options [ 'self' ] ) ; $ __pug_parameters = [ $ self => $ __pug_parameters ] ; } extract ( $ __pug_parameters ) ; include $ __pug_cache_file ; } 
public static function getExtensionsOptions ( array $ extensions , array $ options = [ ] ) { $ methods = static :: getExtensionsGetters ( ) ; foreach ( $ extensions as $ extensionClassName ) { if ( is_a ( $ extensionClassName , ModuleInterface :: class , true ) ) { if ( ! isset ( $ options [ 'modules' ] ) ) { $ options [ 'modules' ] = [ ] ; } $ options [ 'modules' ] [ ] = $ extensionClassName ; continue ; } static :: extractExtensionOptions ( $ options , $ extensionClassName , $ methods ) ; } return $ options ; } 
public static function addExtension ( $ extensionClassName ) { if ( ! class_exists ( $ extensionClassName ) ) { throw new PhugException ( 'Invalid ' . $ extensionClassName . ' extension given: ' . 'it must be a class name.' ) ; } if ( ! static :: hasExtension ( $ extensionClassName ) ) { self :: $ extensions [ ] = $ extensionClassName ; if ( $ renderer = self :: $ renderer ) { $ renderer -> setOptionsRecursive ( static :: getOptions ( ) ) ; } } } 
public static function removeExtension ( $ extensionClassName ) { if ( static :: hasExtension ( $ extensionClassName ) ) { if ( self :: $ renderer ) { self :: removeExtensionFromCurrentRenderer ( $ extensionClassName ) ; self :: $ renderer -> initCompiler ( ) ; } self :: $ extensions = array_diff ( self :: $ extensions , [ $ extensionClassName ] ) ; } } 
public static function removeOptions ( $ path , $ options ) { if ( self :: $ renderer && ( empty ( $ path ) || self :: $ renderer -> hasOption ( $ path ) ) ) { if ( is_array ( $ options ) ) { foreach ( $ options as $ key => $ value ) { if ( is_int ( $ key ) ) { $ callbacks = self :: $ renderer -> getOption ( $ path ) ; if ( ! is_array ( $ callbacks ) || is_callable ( $ callbacks ) ) { $ callbacks = [ $ callbacks ] ; } self :: $ renderer -> setOption ( $ path , array_filter ( $ callbacks , function ( $ item ) use ( $ value ) { return $ item !== $ value ; } ) ) ; continue ; } static :: removeOptions ( array_merge ( $ path , [ $ key ] ) , $ value ) ; } return ; } self :: $ renderer -> unsetOption ( $ path ) ; } } 
public static function reset ( ) { static :: resetFacadeOptions ( ) ; self :: $ renderer = null ; self :: $ extensions = [ ] ; self :: $ filters = [ ] ; self :: $ keywords = [ ] ; } 
public static function getRenderer ( array $ options = [ ] ) { $ options = static :: getOptions ( $ options ) ; if ( ! self :: $ renderer ) { $ rendererClassName = self :: getRendererClassName ( ) ; self :: $ renderer = new $ rendererClassName ( $ options ) ; } elseif ( ! empty ( $ options ) ) { self :: $ renderer -> reInitOptions ( $ options ) ; self :: $ renderer -> getCompiler ( ) -> getFormatter ( ) -> initFormats ( ) ; } return self :: $ renderer ; } 
public static function setFilter ( $ name , $ filter ) { if ( ! ( is_callable ( $ filter ) || class_exists ( $ filter ) || method_exists ( $ filter , 'parse' ) ) ) { throw new PhugException ( 'Invalid ' . $ name . ' filter given: ' . 'it must be a callable or a class name.' ) ; } self :: $ filters [ self :: normalizeFilterName ( $ name ) ] = $ filter ; if ( self :: $ renderer ) { self :: $ renderer -> setOptionsRecursive ( static :: getOptions ( ) ) ; } } 
public static function addFilter ( $ name , $ filter ) { $ key = self :: normalizeFilterName ( $ name ) ; if ( isset ( self :: $ filters [ $ key ] ) ) { throw new PhugException ( 'Filter ' . $ name . ' is already set.' ) ; } self :: setFilter ( $ name , $ filter ) ; } 
public static function removeFilter ( $ name ) { $ key = self :: normalizeFilterName ( $ name ) ; if ( isset ( self :: $ filters [ $ key ] ) ) { unset ( self :: $ filters [ $ key ] ) ; if ( self :: $ renderer ) { self :: $ renderer -> unsetOption ( [ 'filters' , $ key ] ) ; } } } 
public static function setKeyword ( $ name , $ keyword ) { if ( ! is_callable ( $ keyword ) ) { throw new PhugException ( 'Invalid ' . $ name . ' keyword given: ' . 'it must be a callable or a class name.' ) ; } self :: $ keywords [ self :: normalizeKeywordName ( $ name ) ] = $ keyword ; if ( self :: $ renderer ) { self :: $ renderer -> setOptionsRecursive ( static :: getOptions ( ) ) ; } } 
public static function addKeyword ( $ name , $ keyword ) { $ key = self :: normalizeKeywordName ( $ name ) ; if ( isset ( self :: $ keywords [ $ key ] ) ) { throw new PhugException ( 'Keyword ' . $ name . ' is already set.' ) ; } self :: setKeyword ( $ name , $ keyword ) ; } 
public static function removeKeyword ( $ name ) { $ key = self :: normalizeKeywordName ( $ name ) ; if ( isset ( self :: $ keywords [ $ key ] ) ) { unset ( self :: $ keywords [ $ key ] ) ; if ( self :: $ renderer ) { self :: $ renderer -> unsetOption ( [ 'keywords' , $ key ] ) ; } } } 
public static function cacheDirectory ( $ source , $ destination = null , $ options = null ) { if ( $ destination && ! is_array ( $ destination ) ) { $ destination = [ 'cache_dir' => $ destination , ] ; } return static :: getRenderer ( array_merge ( $ options ? : [ ] , 
public static function textualCacheDirectory ( $ source , $ destination = null , $ options = null ) { list ( $ success , $ errors , $ errorDetails ) = static :: cacheDirectory ( $ source , $ destination , $ options ) ; return "$success templates cached.\n" . "$errors templates failed to be cached.\n" . implode ( '' , array_map ( function ( $ detail ) { return $ detail [ 'inputFile' ] . "\n" . $ detail [ 'error' ] -> getMessage ( ) . "\n" . $ detail [ 'error' ] -> getTraceAsString ( ) ; } , $ errorDetails ) ) ; } 
public function run ( $ arguments ) { $ outputFile = $ this -> getNamedArgument ( $ arguments , [ '--output-file' , '-o' ] ) ; $ bootstrapFile = $ this -> getNamedArgument ( $ arguments , [ '--bootstrap' , '-b' ] ) ; if ( $ bootstrapFile ) { include $ bootstrapFile ; } elseif ( file_exists ( 'phugBootstrap.php' ) ) { include 'phugBootstrap.php' ; } list ( , $ action ) = array_pad ( $ arguments , 2 , null ) ; $ arguments = array_slice ( $ arguments , 2 ) ; $ facade = $ this -> facade ; $ method = $ this -> convertToCamelCase ( $ action ) ; $ customMethods = $ this -> getCustomMethods ( ) ; if ( ! $ action ) { echo "You must provide a method.\n" ; $ this -> listAvailableMethods ( $ customMethods ) ; return false ; } if ( ! in_array ( $ method , iterator_to_array ( $ this -> getAvailableMethods ( $ customMethods ) ) ) ) { echo "The method $action is not available as CLI command in the $facade facade.\n" ; $ this -> listAvailableMethods ( $ customMethods ) ; return false ; } return $ this -> execute ( $ facade , $ method , $ arguments , $ outputFile ) ; } 
public function getAvailableMethods ( $ customMethods = null ) { foreach ( [ $ this -> methods , $ customMethods ? : $ this -> getCustomMethods ( ) ] as $ methods ) { foreach ( $ methods as $ method => $ action ) { $ method = is_int ( $ method ) ? $ action : $ method ; if ( substr ( $ method , 0 , 2 ) !== '__' ) { yield $ method ; } } } } 
public function listAvailableMethods ( $ customMethods = null ) { echo "Available methods are:\n" ; foreach ( $ this -> getAvailableMethods ( $ customMethods ? : $ this -> getCustomMethods ( ) ) as $ method ) { $ action = $ this -> convertToKebabCase ( $ method ) ; $ target = isset ( $ this -> methods [ $ method ] ) ? $ this -> methods [ $ method ] : $ method ; $ key = array_search ( $ target , $ this -> methods ) ; if ( is_int ( $ key ) ) { $ key = $ this -> methods [ $ key ] ; } echo ' - ' . $ action . ( $ key && $ key !== $ method ? ' (' . $ this -> convertToKebabCase ( $ key ) . ' alias)' : '' ) . "\n" ; } } 
public function getColumnAttributes ( $ gridField , $ record , $ columnName ) { $ errors = $ this -> getErrors ( $ record ) ; return [ 'class' => count ( $ errors ) ? 'seo-editor-error ' . implode ( ' ' , $ errors ) : 'seo-editor-valid' , ] ; } 
public function getColumnContent ( $ gridField , $ record , $ columnName ) { $ field = new TextareaField ( 'MetaDescription' ) ; $ value = $ gridField -> getDataFieldValue ( $ record , $ columnName ) ; $ value = $ this -> formatValue ( $ gridField , $ record , $ columnName , $ value ) ; $ field -> setName ( $ this -> getFieldName ( $ field -> getName ( ) , $ gridField , $ record ) ) ; $ field -> setValue ( $ value ) ; $ field -> setAttribute ( 'data-name' , 'MetaDescription' ) ; return $ field -> Field ( ) . $ this -> getErrorMessages ( ) ; } 
public function getErrors ( DataObject $ record ) { $ errors = [ ] ; if ( strlen ( $ record -> MetaDescription ) < 10 ) { $ errors [ ] = 'seo-editor-error-too-short' ; } if ( strlen ( $ record -> MetaDescription ) > 160 ) { $ errors [ ] = 'seo-editor-error-too-long' ; } if ( strlen ( SiteTree :: get ( ) -> filter ( 'MetaDescription' , $ record -> MetaDescription ) -> count ( ) > 1 ) ) { $ errors [ ] = 'seo-editor-error-duplicate' ; } return $ errors ; } 
public function getList ( ) { $ list = parent :: getList ( ) ; $ params = $ this -> request -> requestVar ( 'q' ) ; if ( isset ( $ params [ 'RemoveEmptyMetaTitles' ] ) && $ params [ 'RemoveEmptyMetaTitles' ] ) { $ list = $ this -> removeEmptyAttributes ( $ list , 'MetaTitle' ) ; } if ( isset ( $ params [ 'RemoveEmptyMetaDescriptions' ] ) && $ params [ 'RemoveEmptyMetaDescriptions' ] ) { $ list = $ this -> removeEmptyAttributes ( $ list , 'MetaDescription' ) ; } $ list = $ this -> markDuplicates ( $ list ) ; if ( isset ( $ params [ 'DuplicatesOnly' ] ) && $ params [ 'DuplicatesOnly' ] ) { $ list = $ list -> filter ( 'IsDuplicate' , true ) ; } $ list = $ list -> sort ( 'ID' ) ; return $ list ; } 
private function markDuplicates ( $ list ) { $ duplicates = $ this -> findDuplicates ( $ list , 'MetaTitle' ) -> map ( 'ID' , 'ID' ) -> toArray ( ) ; $ duplicateList = new ArrayList ( ) ; foreach ( $ list as $ item ) { if ( in_array ( $ item -> ID , $ duplicates ) ) { $ item -> IsDuplicate = true ; $ duplicateList -> push ( $ item ) ; } } $ duplicates = $ this -> findDuplicates ( $ list , 'MetaDescription' ) -> map ( 'ID' , 'ID' ) -> toArray ( ) ; foreach ( $ list as $ item ) { if ( in_array ( $ item -> ID , $ duplicates ) ) { $ item -> IsDuplicate = true ; if ( ! $ list -> byID ( $ item -> ID ) ) { $ duplicateList -> push ( $ item ) ; } } } $ duplicateList -> merge ( $ list ) ; $ duplicateList -> removeDuplicates ( ) ; return $ duplicateList ; } 
private function findDuplicates ( SS_List $ list , $ type ) { $ pageAttributes = $ list -> map ( 'ID' , $ type ) -> toArray ( ) ; $ potentialDuplicateAttributes = array_unique ( array_diff_assoc ( $ pageAttributes , array_unique ( $ pageAttributes ) ) ) ; $ duplicateAttributes = array_filter ( $ pageAttributes , function ( $ value ) use ( $ potentialDuplicateAttributes ) { return in_array ( $ value , $ potentialDuplicateAttributes ) ; } ) ; if ( ! count ( $ duplicateAttributes ) ) { return $ list ; } return $ list -> filter ( [ 'ID' => array_keys ( $ duplicateAttributes ) , ] ) ; } 
private function removeEmptyAttributes ( SS_List $ list , $ type ) { $ pageAttributes = $ list -> map ( 'ID' , $ type ) -> toArray ( ) ; $ emptyAttributess = array_map ( function ( $ value ) { return $ value == '' ; } , $ pageAttributes ) ; if ( ! count ( $ emptyAttributess ) ) { return $ list ; } return $ list -> filter ( [ 'ID:not' => array_keys ( array_filter ( $ emptyAttributess , function ( $ value ) { return $ value == 1 ; } ) ) ] ) ; } 
public function processRecord ( $ record , $ columnMap , & $ results , $ preview = false ) { $ page = $ this -> findExistingObject ( $ record , $ columnMap ) ; if ( ! $ page || ! $ page -> exists ( ) ) { return false ; } foreach ( $ record as $ fieldName => $ val ) { if ( $ fieldName == 'MetaTitle' || $ fieldName == 'MetaDescription' ) { $ sqlValue = Convert :: raw2sql ( $ val ) ; DB :: query ( "UPDATE SiteTree SET {$fieldName} = '{$sqlValue}' WHERE ID = {$page->ID}" ) ; if ( $ page -> isPublished ( ) ) { DB :: query ( "UPDATE SiteTree_Live SET {$fieldName} = '{$sqlValue}' WHERE ID = {$page->ID}" ) ; } } } return $ page -> ID ; } 
public function handle ( $ request , $ next ) { return resolve ( AllReleases :: class ) -> authorize ( $ request ) ? $ next ( $ request ) : abort ( 403 ) ; } 
public function create ( $ key , $ position , $ referenceValue , $ value ) { return $ this -> _create ( $ key , $ position , $ referenceValue , $ value ) ; } 
public function create ( $ key , $ member ) { $ connection = $ this -> _rediska -> getConnectionByKeyName ( $ key ) ; $ member = $ this -> _rediska -> getSerializer ( ) -> serialize ( $ member ) ; $ command = array ( 'ZREM' , $ this -> _rediska -> getOption ( 'namespace' ) . $ key , $ member ) ; return new Rediska_Connection_Exec ( $ connection , $ command ) ; } 
public function setOption ( $ name , $ value ) { if ( method_exists ( $ this , "set$name" ) ) { return call_user_func ( array ( $ this , "set$name" ) , $ value ) ; } else if ( array_key_exists ( $ name , $ this -> _options ) ) { $ this -> _options [ $ name ] = $ value ; return $ this ; } else { throw new $ this -> _optionsException ( "Unknown option '$name'" ) ; } } 
public function getOption ( $ name ) { if ( method_exists ( $ this , "get$name" ) ) { return call_user_func ( array ( $ this , "get$name" ) ) ; } else if ( array_key_exists ( $ name , $ this -> _options ) ) { return $ this -> _options [ $ name ] ; } else { throw new $ this -> _optionsException ( "Unknown option '$name'" ) ; } } 
public function create ( $ keyOrKeys ) { if ( is_array ( $ keyOrKeys ) ) { $ keys = $ keyOrKeys ; if ( empty ( $ keys ) ) { throw new Rediska_Command_Exception ( 'Not present keys for delete' ) ; } $ connections = array ( ) ; $ keysByConnections = array ( ) ; foreach ( $ keys as $ key ) { $ connection = $ this -> _rediska -> getConnectionByKeyName ( $ key ) ; $ connectionAlias = $ connection -> getAlias ( ) ; if ( ! array_key_exists ( $ connectionAlias , $ connections ) ) { $ connections [ $ connectionAlias ] = $ connection ; $ keysByConnections [ $ connectionAlias ] = array ( ) ; } $ keysByConnections [ $ connectionAlias ] [ ] = $ key ; } $ commands = array ( ) ; foreach ( $ keysByConnections as $ connectionAlias => $ keys ) { $ command = array ( 'DEL' ) ; foreach ( $ keys as $ key ) { $ command [ ] = $ this -> _rediska -> getOption ( 'namespace' ) . $ key ; } $ commands [ ] = new Rediska_Connection_Exec ( $ connections [ $ connectionAlias ] , $ command ) ; } return $ commands ; } else { $ key = $ keyOrKeys ; $ connection = $ this -> _rediska -> getConnectionByKeyName ( $ key ) ; $ command = array ( 'DEL' , $ this -> _rediska -> getOption ( 'namespace' ) . $ key ) ; return new Rediska_Connection_Exec ( $ connection , $ command ) ; } } 
public function create ( ) { $ connections = $ this -> _rediska -> getConnections ( ) ; $ index = rand ( 0 , count ( $ connections ) - 1 ) ; $ connection = $ connections [ $ index ] ; $ command = array ( 'RANDOMKEY' ) ; return new Rediska_Connection_Exec ( $ connection , $ command ) ; } 
public function parseResponse ( $ response ) { if ( $ response == '' ) { return null ; } else { if ( $ this -> _rediska -> getOption ( 'namespace' ) != '' && strpos ( $ response , $ this -> _rediska -> getOption ( 'namespace' ) ) === 0 ) { $ response = substr ( $ response , strlen ( $ this -> _rediska -> getOption ( 'namespace' ) ) ) ; } return $ response ; } } 
public function create ( $ channelOrChannels , $ message ) { $ channels = array ( ) ; if ( ! is_array ( $ channelOrChannels ) ) { $ channels = array ( $ channelOrChannels ) ; } else { $ channels = $ channelOrChannels ; } 
public function create ( $ pattern ) { $ commands = array ( ) ; $ command = array ( 'KEYS' , $ this -> _rediska -> getOption ( 'namespace' ) . $ pattern ) ; foreach ( $ this -> _rediska -> getConnections ( ) as $ connection ) { $ commands [ ] = new Rediska_Connection_Exec ( $ connection , $ command ) ; } return $ commands ; } 
public function parseResponses ( $ responses ) { $ keys = array ( ) ; foreach ( $ responses as $ response ) { if ( ! empty ( $ response ) ) { $ keys = array_merge ( $ keys , is_array ( $ response ) ? $ response : explode ( ' ' , $ response ) ) ; } } $ keys = array_unique ( $ keys ) ; if ( $ this -> _rediska -> getOption ( 'namespace' ) != '' ) { $ namespaceLength = strlen ( $ this -> _rediska -> getOption ( 'namespace' ) ) ; foreach ( $ keys as & $ key ) { if ( strpos ( $ key , $ this -> _rediska -> getOption ( 'namespace' ) ) === 0 ) { $ key = substr ( $ key , $ namespaceLength ) ; } } } return $ keys ; } 
public function start ( ) { $ this -> _startTime = microtime ( true ) ; $ this -> _profiler -> startCallback ( $ this ) ; return $ this -> _startTime ; } 
public function stop ( ) { $ this -> _stopTime = microtime ( true ) ; $ this -> _profiler -> stopCallBack ( $ this ) ; return $ this -> getElapsedTime ( ) ; } 
public function getElapsedTime ( $ decimals = null ) { if ( ! $ this -> hasStopped ( ) ) { return false ; } $ elapsedTime = $ this -> _stopTime - $ this -> _startTime ; if ( $ decimals ) { return number_format ( $ elapsedTime , $ decimals ) ; } else { return $ elapsedTime ; } } 
public function initialize ( ) { if ( $ this -> _execs === null ) { $ this -> _execs = call_user_func_array ( array ( $ this , 'create' ) , $ this -> _arguments ) ; if ( ! is_array ( $ this -> _execs ) ) { $ this -> _execs = array ( $ this -> _execs ) ; } return true ; } return false ; } 
public function write ( ) { $ this -> initialize ( ) ; foreach ( $ this -> _execs as $ exec ) { $ exec -> write ( ) ; } $ this -> _isWritten = true ; return true ; } 
public function read ( ) { $ responses = array ( ) ; if ( ! $ this -> _isWritten ) { throw new Rediska_Command_Exception ( 'You need write before' ) ; } foreach ( $ this -> _execs as $ exec ) { $ responses [ ] = $ exec -> read ( ) ; } if ( isset ( $ responses [ 0 ] ) && $ responses [ 0 ] === self :: QUEUED ) { $ this -> _isQueued = true ; return true ; } else { $ this -> _isWritten = false ; return $ this -> parseResponses ( $ responses ) ; } } 
public function parseResponses ( $ responses ) { foreach ( $ responses as & $ response ) { $ response = $ this -> parseResponse ( $ response ) ; } if ( sizeof ( $ responses ) == 1 ) { return $ responses [ 0 ] ; } } 
protected function _argumentsToString ( $ arguments ) { $ strings = array ( ) ; foreach ( $ arguments as $ name => $ value ) { $ key = ! is_integer ( $ name ) ? "'$name' => " : '' ; if ( is_object ( $ value ) ) { $ argument = get_class ( $ value ) . ' $' . $ name ; } else if ( is_numeric ( $ value ) ) { $ argument = $ value ; } else if ( is_string ( $ value ) ) { $ argument = "'$value'" ; } else if ( is_array ( $ value ) ) { $ argument = 'array(' . $ this -> _argumentsToString ( $ value ) . ')' ; } else if ( is_null ( $ value ) ) { $ argument = 'null' ; } else if ( $ value === true ) { $ argument = 'true' ; } else if ( $ value === false ) { $ argument = 'false' ; } $ strings [ ] = $ key . $ argument ; } return implode ( ', ' , $ strings ) ; } 
protected function _getAndValidateArguments ( $ arguments ) { $ className = get_class ( $ this ) ; if ( ! isset ( self :: $ _argumentNames [ $ className ] ) ) { $ reflection = new ReflectionMethod ( $ this , 'create' ) ; self :: $ _argumentNames [ $ className ] = array ( ) ; foreach ( $ reflection -> getParameters ( ) as $ parameter ) { self :: $ _argumentNames [ $ className ] [ ] = $ parameter ; } } $ count = 0 ; $ argumentNamesAndValues = array ( ) ; foreach ( self :: $ _argumentNames [ $ className ] as $ parameter ) { if ( array_key_exists ( $ count , $ arguments ) ) { $ value = $ arguments [ $ count ] ; } else if ( $ parameter -> isOptional ( ) ) { $ value = $ parameter -> getDefaultValue ( ) ; } else { throw new Rediska_Command_Exception ( "Argument '{$parameter->getName()}' not present for command '$this->_name'" ) ; } $ argumentNamesAndValues [ $ parameter -> getName ( ) ] = $ value ; $ count ++ ; } return $ argumentNamesAndValues ; } 
protected function _throwExceptionIfNotSupported ( $ version = null ) { if ( null === $ version ) { $ version = $ this -> _version ; } $ redisVersion = $ this -> _rediska -> getOption ( 'redisVersion' ) ; if ( version_compare ( $ version , $ redisVersion ) == 1 ) { throw new Rediska_Command_Exception ( "Command '{$this->_name}' requires {$version}+ version of Redis server. Current version is {$redisVersion}. To change it specify 'redisVersion' option." ) ; } } 
protected function _executeCommand ( $ name , $ args = array ( ) ) { $ command = Rediska_Commands :: get ( $ this -> _rediska , $ name , $ args ) ; $ response = $ command -> execute ( ) ; unset ( $ command ) ; return $ response ; } 
public static function register ( $ prepend = false ) { if ( self :: isRegistered ( ) ) { return false ; } if ( ! is_bool ( $ prepend ) ) { $ prepend = ( bool ) $ prepend ; } if ( version_compare ( PHP_VERSION , '5.3.0' , '<' ) ) { self :: $ _isRegistered = spl_autoload_register ( self :: $ _callback ) ; } else { self :: $ _isRegistered = spl_autoload_register ( self :: $ _callback , true , $ prepend ) ; } return self :: $ _isRegistered ; } 
public static function unregister ( ) { if ( ! self :: isRegistered ( ) ) { return false ; } self :: $ _isRegistered = ! spl_autoload_unregister ( self :: $ _callback ) ; return self :: $ _isRegistered ; } 
public static function load ( $ className ) { if ( 0 !== strpos ( $ className , 'Rediska' ) ) { return false ; } $ path = self :: getRediskaPath ( ) . '/' . str_replace ( '_' , '/' , $ className ) . '.php' ; return include $ path ; } 
public static function getRediskaPath ( ) { if ( ! self :: $ _rediskaPath ) { self :: $ _rediskaPath = realpath ( dirname ( __FILE__ ) . '/..' ) ; } return self :: $ _rediskaPath ; } 
public function addConnection ( $ connectionString , $ weight = Rediska_Connection :: DEFAULT_WEIGHT ) { if ( isset ( $ this -> _backends [ $ connectionString ] ) ) { throw new Rediska_KeyDistributor_Exception ( "Connection '$connectionString' already exists." ) ; } $ this -> _backends [ $ connectionString ] = $ weight ; $ this -> _backendsCount ++ ; $ this -> _hashringIsInitialized = false ; return $ this ; } 
public function removeConnection ( $ connectionString ) { if ( ! isset ( $ this -> _backends [ $ connectionString ] ) ) { throw new Rediska_KeyDistributor_Exception ( "Connection '$connectionString' not exist." ) ; } unset ( $ this -> _backends [ $ connectionString ] ) ; $ this -> _backendsCount -- ; $ this -> _hashringIsInitialized = false ; return $ this ; } 
public function getConnectionByKeyName ( $ name ) { $ connections = $ this -> getConnectionsByKeyName ( $ name , 1 ) ; if ( empty ( $ connections ) ) { throw new Rediska_KeyDistributor_Exception ( 'No connections exist' ) ; } return $ connections [ 0 ] ; } 
public function getConnectionsByKeyName ( $ name , $ count ) { 
public function addChannel ( $ channel ) { $ connection = $ this -> getConnectionByChannelName ( $ channel ) ; if ( ! array_key_exists ( $ connection -> getAlias ( ) , $ this -> _channelsByConnections ) ) { $ this -> _channelsByConnections [ $ connection -> getAlias ( ) ] = array ( ) ; $ this -> _connections [ $ connection -> getAlias ( ) ] = $ connection ; } if ( ! in_array ( $ channel , $ this -> _channelsByConnections [ $ connection -> getAlias ( ) ] ) ) { $ this -> _channelsByConnections [ $ connection -> getAlias ( ) ] [ ] = $ channel ; } return $ connection ; } 
public function hasChannel ( $ channel ) { $ connection = $ this -> getConnectionByChannelName ( $ channel ) ; return isset ( $ this -> _channelsByConnections [ $ connection -> getAlias ( ) ] ) && in_array ( $ channel , $ this -> _channelsByConnections [ $ connection -> getAlias ( ) ] ) ; } 
public function removeChannel ( $ channel ) { $ connection = $ this -> getConnectionByChannelName ( $ channel ) ; $ key = array_search ( $ channel , $ this -> _channelsByConnections [ $ connection -> getAlias ( ) ] ) ; unset ( $ this -> _channelsByConnections [ $ connection -> getAlias ( ) ] [ $ key ] ) ; if ( empty ( $ this -> _channelsByConnections [ $ connection -> getAlias ( ) ] ) ) { unset ( $ this -> _channelsByConnections [ $ connection -> getAlias ( ) ] ) ; unset ( $ this -> _connections [ $ connection -> getAlias ( ) ] ) ; 
public function getConnectionByChannelName ( $ name ) { 
public function getConnectionByAlias ( $ alias ) { if ( ! isset ( $ this -> _connections [ $ alias ] ) ) { throw new Rediska_PubSub_Exception ( "Can't find connection '$alias'" ) ; } return $ this -> _connections [ $ alias ] ; } 
public function getChannelsByConnection ( Rediska_Connection $ connection ) { if ( ! isset ( $ this -> _channelsByConnections [ $ connection -> getAlias ( ) ] ) ) { throw new Rediska_PubSub_Exception ( "Channels by this connection not present" ) ; } return $ this -> _channelsByConnections [ $ connection -> getAlias ( ) ] ; } 
public function get ( $ nameOrPattern ) { $ configGet = new Rediska_Connection_Exec ( $ this -> _connection , array ( 'CONFIG' , 'GET' , $ nameOrPattern ) ) ; $ valuesAfterNames = $ configGet -> execute ( ) ; if ( preg_match ( '/\W/i' , $ nameOrPattern ) ) { 
public function set ( $ name , $ value ) { $ exec = new Rediska_Connection_Exec ( $ this -> _connection , array ( 'CONFIG' , 'SET' , $ name , $ value ) ) ; $ exec -> execute ( ) ; return $ this ; } 
public function count ( ) { $ exec = new Rediska_Connection_Exec ( $ this -> _connection , array ( 'CONFIG' , 'GET' , '*' ) ) ; $ namesAndValues = $ exec -> execute ( ) ; return count ( $ namesAndValues ) / 2 ; } 
protected function _sanitizeValue ( $ value ) { $ value = trim ( $ value ) ; 
protected function _throwIfNotSupported ( ) { $ version = '2.0' ; $ redisVersion = $ this -> _rediska -> getOption ( 'redisVersion' ) ; if ( version_compare ( $ version , $ this -> _rediska -> getOption ( 'redisVersion' ) ) == 1 ) { throw new Rediska_Transaction_Exception ( "Transaction requires {$version}+ version of Redis server. Current version is {$redisVersion}. To change it specify 'redisVersion' option." ) ; } } 
public function create ( $ name , $ timeout = null ) { $ this -> _queues -> add ( $ name ) ; $ this -> _queueObjects [ $ name ] = new Rediska_Key_List ( $ this -> _getKeyName ( "queue_$name" ) , array ( 'rediska' => $ this -> _rediska ) ) ; return true ; } 
public function delete ( $ name ) { if ( $ this -> _queues -> remove ( $ name ) ) { if ( isset ( $ this -> _queueObjects [ $ name ] ) ) { unset ( $ this -> _queueObjects [ $ name ] ) ; } return $ this -> _rediska -> delete ( $ this -> _getKeyName ( "queue_$name" ) ) ; } } 
public function count ( Zend_Queue $ queue = null ) { if ( $ queue === null ) { $ queue = $ this -> _queue ; } $ queueName = $ queue -> getName ( ) ; if ( ! $ this -> isExists ( $ queueName ) ) { require_once 'Zend/Queue/Exception.php' ; throw new Zend_Queue_Exception ( 'Queue does not exist:' . $ queueName ) ; } if ( ! isset ( $ this -> _queueObjects [ $ queueName ] ) ) { $ this -> _queueObjects [ $ queueName ] = new Rediska_Key_List ( $ this -> _getKeyName ( "queue_$queueName" ) , array ( 'rediska' => $ this -> _rediska ) ) ; } return count ( $ this -> _queueObjects [ $ queueName ] ) ; } 
public function send ( $ message , Zend_Queue $ queue = null ) { if ( $ queue === null ) { $ queue = $ this -> _queue ; } $ queueName = $ queue -> getName ( ) ; if ( ! $ this -> isExists ( $ queueName ) ) { require_once 'Zend/Queue/Exception.php' ; throw new Zend_Queue_Exception ( 'Queue does not exist:' . $ queueName ) ; } if ( ! isset ( $ this -> _queueObjects [ $ queueName ] ) ) { $ this -> _queueObjects [ $ queueName ] = new Rediska_Key_List ( $ this -> _getKeyName ( "queue_$queueName" ) , array ( 'rediska' => $ this -> _rediska ) ) ; } $ result = $ this -> _queueObjects [ $ queueName ] -> prepend ( $ message ) ; if ( $ result === false ) { require_once 'Zend/Queue/Exception.php' ; throw new Zend_Queue_Exception ( 'Failed to insert message into queue:' . $ queueName ) ; } $ options = array ( 'queue' => $ queue , 'data' => array ( 'body' => $ message ) , ) ; $ classname = $ queue -> getMessageClass ( ) ; if ( ! class_exists ( $ classname ) ) { require_once 'Zend/Loader.php' ; Zend_Loader :: loadClass ( $ classname ) ; } return new $ classname ( $ options ) ; } 
public function receive ( $ maxMessages = null , $ timeout = null , Zend_Queue $ queue = null ) { if ( $ maxMessages === null ) { $ maxMessages = 1 ; } if ( $ queue === null ) { $ queue = $ this -> _queue ; } $ queueName = $ queue -> getName ( ) ; if ( ! $ this -> isExists ( $ queueName ) ) { require_once 'Zend/Queue/Exception.php' ; throw new Zend_Queue_Exception ( 'Queue does not exist:' . $ queueName ) ; } if ( ! isset ( $ this -> _queueObjects [ $ queueName ] ) ) { $ this -> _queueObjects [ $ queueName ] = new Rediska_Key_List ( $ this -> _getKeyName ( "queue_$queueName" ) , array ( 'rediska' => $ this -> _rediska ) ) ; } $ messages = array ( ) ; for ( $ i = 0 ; $ i < $ maxMessages ; $ i ++ ) { $ message = $ this -> _queueObjects [ $ queueName ] -> pop ( ) ; if ( ! is_null ( $ message ) ) { $ messages [ ] = array ( 'body' => $ message ) ; } } $ options = array ( 'queue' => $ queue , 'data' => $ messages , 'messageClass' => $ queue -> getMessageClass ( ) , ) ; $ classname = $ queue -> getMessageSetClass ( ) ; if ( ! class_exists ( $ classname ) ) { require_once 'Zend/Loader.php' ; Zend_Loader :: loadClass ( $ classname ) ; } return new $ classname ( $ options ) ; } 
public function deleteMessage ( Zend_Queue_Message $ message ) { $ queueName = $ this -> _queue -> getName ( ) ; if ( ! isset ( $ this -> _queueObjects [ $ queueName ] ) ) { $ this -> _queueObjects [ $ queueName ] = new Rediska_Key_List ( $ this -> _getKeyName ( "queue_$queueName" ) , array ( 'rediska' => $ this -> _rediska ) ) ; } return ( boolean ) $ this -> _queueObjects [ $ queueName ] -> remove ( $ message -> body ) ; } 
public function create ( $ oldKey , $ newKey , $ overwrite = true ) { $ oldKeyConnection = $ this -> _rediska -> getConnectionByKeyName ( $ oldKey ) ; $ newKeyConnection = $ this -> _rediska -> getConnectionByKeyName ( $ newKey ) ; $ command = '' ; if ( $ oldKeyConnection === $ newKeyConnection ) { if ( $ overwrite ) { $ command = array ( ) ; } else { $ command = "" ; } $ command = array ( $ overwrite ? 'RENAME' : 'RENAMENX' , $ this -> _rediska -> getOption ( 'namespace' ) . $ oldKey , $ this -> _rediska -> getOption ( 'namespace' ) . $ newKey ) ; } else { $ this -> setAtomic ( false ) ; $ command = array ( 'GET' , $ this -> _rediska -> getOption ( 'namespace' ) . $ oldKey ) ; } return new Rediska_Connection_Exec ( $ oldKeyConnection , $ command ) ; } 
public function parseResponses ( $ responses ) { if ( ! $ this -> isAtomic ( ) ) { $ oldValue = $ this -> _rediska -> getSerializer ( ) -> unserialize ( $ responses [ 0 ] ) ; if ( ! is_null ( $ oldValue ) ) { $ reply = $ this -> _rediska -> set ( $ this -> newKey , $ oldValue , $ this -> overwrite ) ; if ( $ reply ) { $ this -> _rediska -> delete ( $ this -> oldKey ) ; } return $ reply ; } else { throw new Rediska_Command_Exception ( 'No such key' ) ; } } else { return ( boolean ) $ responses [ 0 ] ; } } 
public function start ( $ context ) { $ profile = new Rediska_Profiler_Profile ( $ this , $ context ) ; $ profile -> start ( ) ; $ this -> _profiles [ ] = $ profile ; return $ profile ; } 
public function stop ( ) { $ hasUnstopped = false ; foreach ( array_reverse ( $ this -> _profiles ) as $ profile ) { if ( ! $ profile -> hasStopped ( ) ) { $ hasUnstopped = true ; break ; } } if ( $ hasUnstopped ) { $ profile -> stop ( ) ; } else { throw new Rediska_Profiler_Exception ( 'You need start profiler before stop it' ) ; } return $ profile ; } 
public function getTotalElapsedTime ( $ decimals = null ) { $ totalElapsedTime = 0 ; foreach ( $ this -> getProfiles ( ) as $ profile ) { if ( $ profile -> hasStopped ( ) ) { $ totalElapsedTime += $ profile -> getElapsedTime ( ) ; } } if ( $ decimals ) { return number_format ( $ totalElapsedTime , $ decimals ) ; } else { return $ totalElapsedTime ; } } 
public function addConnection ( $ connectionString , $ weight = Rediska_Connection :: DEFAULT_WEIGHT ) { if ( in_array ( $ connectionString , $ this -> _connections ) ) { throw new Rediska_KeyDistributor_Exception ( "Connection '$connectionString' already exists." ) ; } $ this -> _connections [ ] = $ connectionString ; $ this -> _connectionCount ++ ; 
public function removeConnection ( $ connectionString ) { if ( ! in_array ( $ connectionString , $ this -> _connections ) ) { throw new Rediska_KeyDistributor_Exception ( "Connection '$connectionString' does not exist." ) ; } $ index = array_search ( $ connectionString , $ this -> _connections ) ; unset ( $ this -> _connections [ $ index ] ) ; $ this -> _connectionCount -- ; 
public function getConnectionByKeyName ( $ name ) { if ( empty ( $ this -> _connections ) ) { throw new Rediska_KeyDistributor_Exception ( "No connection exists." ) ; } if ( $ this -> _connectionCount == 1 ) { return $ this -> _connections [ 0 ] ; } $ index = abs ( crc32 ( $ name ) % $ this -> _connectionPositionCount ) ; return $ this -> _connectionPositions [ $ index ] ; } 
public function set ( $ fieldOrData , $ value = null , $ overwrite = true ) { $ result = $ this -> _getRediskaOn ( ) -> setToHash ( $ this -> getName ( ) , $ fieldOrData , $ value , $ overwrite ) ; if ( ! is_null ( $ this -> getExpire ( ) ) && ( ( ! $ overwrite && $ result ) || ( $ overwrite ) ) ) { $ this -> expire ( $ this -> getExpire ( ) , $ this -> isExpireTimestamp ( ) ) ; } return $ result ; } 
public function offsetSet ( $ field , $ value ) { if ( is_null ( $ field ) ) { throw new Rediska_Key_Exception ( 'Field must be present' ) ; } $ this -> set ( $ field , $ value ) ; return $ value ; } 
public function increment ( $ field , $ amount = 1 ) { $ result = $ this -> _getRediskaOn ( ) -> incrementInHash ( $ this -> getName ( ) , $ field , $ amount ) ; if ( ! is_null ( $ this -> getExpire ( ) ) && $ result ) { $ this -> expire ( $ this -> getExpire ( ) , $ this -> isExpireTimestamp ( ) ) ; } return $ result ; } 
public function remove ( $ field ) { $ result = $ this -> _getRediskaOn ( ) -> deleteFromHash ( $ this -> getName ( ) , $ field ) ; if ( ! is_null ( $ this -> getExpire ( ) ) && $ result ) { $ this -> expire ( $ this -> getExpire ( ) , $ this -> isExpireTimestamp ( ) ) ; } return $ result ; } 
public function authenticate ( ) { $ identity = $ this -> getIdentity ( ) ; $ userIdKey = str_replace ( '*' , $ identity , $ this -> getOption ( 'userIdKey' ) ) ; $ userId = $ this -> getRediska ( ) -> get ( $ userIdKey ) ; if ( is_null ( $ userId ) ) { $ code = Zend_Auth_Result :: FAILURE_IDENTITY_NOT_FOUND ; $ message = 'User with the supplied identity could not be found.' ; } else { $ userDataKey = str_replace ( '*' , $ userId , $ this -> getOption ( 'userDataKey' ) ) ; $ userData = $ this -> getRediska ( ) -> get ( $ userDataKey ) ; if ( is_null ( $ userData ) ) { throw new Zend_Auth_Adapter_Exception ( "User data key '$userDataKey' not found" ) ; } $ credentialAttributeName = $ this -> getOption ( 'credentialAttributeName' ) ; if ( $ this -> getOption ( 'userDataIsArray' ) ) { if ( ! array_key_exists ( $ credentialAttributeName , $ userData ) ) { throw new Zend_Auth_Adapter_Exception ( "Credential key with name '$credentialAttributeName' not found in user data" ) ; } $ credential = $ userData [ $ credentialAttributeName ] ; } else { if ( ! isset ( $ userData -> $ credentialAttributeName ) ) { throw new Zend_Auth_Adapter_Exception ( "Credential attribute with name '$credentialAttributeName' not found in user data" ) ; } $ credential = $ userData -> $ credentialAttributeName ; } if ( $ this -> getCredential ( ) == $ credential ) { $ code = Zend_Auth_Result :: SUCCESS ; $ message = 'Authentication successful.' ; $ this -> _userData = $ userData ; } else { $ code = Zend_Auth_Result :: FAILURE_CREDENTIAL_INVALID ; $ message = 'Supplied credential is invalid.' ; } } return new Zend_Auth_Result ( $ code , $ identity , array ( $ message ) ) ; } 
public function create ( $ key , array $ options = array ( ) ) { $ connection = $ this -> _rediska -> getConnectionByKeyName ( $ key ) ; $ command = array ( 'SORT' , $ this -> _rediska -> getOption ( 'namespace' ) . $ key ) ; foreach ( $ options as $ name => $ value ) { if ( ! array_key_exists ( $ name , $ this -> _options ) ) { throw new Rediska_Command_Exception ( "Unknown option '$name'" ) ; } $ this -> _options [ $ name ] = $ value ; } 
public function write ( $ id , $ data ) { try { $ timestamp = time ( ) ; $ this -> _set [ $ timestamp ] = $ id ; } catch ( Rediska_Connection_Exec_Exception $ e ) { $ this -> _deleteSetOrThrowException ( $ e ) ; } return $ this -> getRediska ( ) -> setAndExpire ( $ this -> _getKeyName ( $ id ) , $ data , $ this -> getOption ( 'lifetime' ) ) ; } 
public function destroy ( $ id ) { try { $ this -> _set -> remove ( $ id ) ; } catch ( Rediska_Connection_Exec_Exception $ e ) { $ this -> _deleteSetOrThrowException ( $ e ) ; } return $ this -> getRediska ( ) -> delete ( $ this -> _getKeyName ( $ id ) ) ; } 
public function gc ( $ maxlifetime ) { try { return $ this -> _set -> removeByScore ( 0 , time ( ) - $ this -> getOption ( 'lifetime' ) ) ; } catch ( Rediska_Connection_Exec_Exception $ e ) { $ this -> _deleteSetOrThrowException ( $ e ) ; } } 
public function subscribe ( $ channelOrChannels ) { if ( ! is_array ( $ channelOrChannels ) ) { $ channels = array ( $ channelOrChannels ) ; } else { $ channels = $ channelOrChannels ; } $ this -> _execCommand ( self :: SUBSCRIBE , $ channels ) ; return $ this ; } 
public function unsubscribe ( $ channelOrChannels = null ) { if ( is_null ( $ channelOrChannels ) ) { $ channels = $ this -> _subscriptions ; } elseif ( ! is_array ( $ channelOrChannels ) ) { $ channels = array ( $ channelOrChannels ) ; } else { $ channels = $ channelOrChannels ; } $ this -> _execCommand ( self :: UNSUBSCRIBE , $ channels ) ; return $ this ; } 
public function publish ( $ message ) { $ rediska = $ this -> getRediska ( ) ; if ( $ this -> getServerAlias ( ) !== null ) { $ rediska = $ rediska -> on ( $ this -> getServerAlias ( ) ) ; } return $ rediska -> publish ( $ this -> _subscriptions , $ message ) ; } 
public function getMessage ( $ timeout = null ) { 
public function offsetSet ( $ offset , $ value ) { if ( ! is_null ( $ offset ) ) { throw new Rediska_PubSub_Exception ( 'Offset is not allowed in Rediska_PubSub_Channel' ) ; } $ this -> publish ( $ value ) ; return $ value ; } 
protected function _execCommand ( $ command , $ channels ) { 
protected function _addMessageToBuffer ( Rediska_PubSub_Response_Message $ message ) { $ key = "{$message->getConnection()->getAlias()}-{$message->getChannel()}" ; if ( ! isset ( self :: $ _messages [ $ key ] ) ) { self :: $ _messages [ $ key ] = array ( ) ; } self :: $ _messages [ $ key ] [ ] = $ message ; } 
protected function _getResponseFromConnection ( Rediska_Connection $ connection ) { $ response = Rediska_Connection_Exec :: readResponseFromConnection ( $ connection ) ; if ( $ response === null || $ response === true ) { return null ; } list ( $ type , $ channel , $ body ) = $ response ; if ( $ this -> getRediska ( ) -> getOption ( 'namespace' ) !== '' && strpos ( $ channel , $ this -> getRediska ( ) -> getOption ( 'namespace' ) ) === 0 ) { $ channel = substr ( $ channel , strlen ( $ this -> getRediska ( ) -> getOption ( 'namespace' ) ) ) ; } switch ( $ type ) { case self :: SUBSCRIBE : return new Rediska_PubSub_Response_Subscribe ( $ connection , $ channel ) ; case self :: UNSUBSCRIBE : return new Rediska_PubSub_Response_Unsubscribe ( $ connection , $ channel ) ; case self :: MESSAGE : $ message = $ this -> getRediska ( ) -> getSerializer ( ) -> unserialize ( $ body ) ; return new Rediska_PubSub_Response_Message ( $ connection , $ channel , $ message ) ; default : throw new Rediska_PubSub_Response_Exception ( 'Unknown reponse type: ' . $ type ) ; } } 
protected function _throwIfNotSupported ( ) { $ version = '1.3.8' ; $ redisVersion = $ this -> getRediska ( ) -> getOption ( 'redisVersion' ) ; if ( version_compare ( $ version , $ this -> getRediska ( ) -> getOption ( 'redisVersion' ) ) == 1 ) { throw new Rediska_PubSub_Exception ( "Publish/Subscribe requires {$version}+ version of Redis server. Current version is {$redisVersion}. To change it specify 'redisVersion' option." ) ; } } 
public function create ( $ key , $ value , $ seconds ) { $ connection = $ this -> getRediska ( ) -> getConnectionByKeyName ( $ key ) ; $ command = array ( 'SETEX' , $ this -> getRediska ( ) -> getOption ( 'namespace' ) . $ key , $ seconds , $ this -> getRediska ( ) -> getSerializer ( ) -> serialize ( $ value ) ) ; return new Rediska_Connection_Exec ( $ connection , $ command ) ; } 
public function create ( $ key , $ min , $ max , $ withScores = false , $ limit = null , $ offset = null , $ revert = false ) { if ( $ revert ) { $ this -> _throwExceptionIfNotSupported ( '2.1.6' ) ; } $ connection = $ this -> _rediska -> getConnectionByKeyName ( $ key ) ; $ command = array ( $ revert ? 'ZREVRANGEBYSCORE' : 'ZRANGEBYSCORE' , $ this -> _rediska -> getOption ( 'namespace' ) . $ key , $ revert ? $ max : $ min , $ revert ? $ min : $ max ) ; if ( ! is_null ( $ limit ) ) { if ( is_null ( $ offset ) ) { $ offset = 0 ; } $ command [ ] = 'LIMIT' ; $ command [ ] = $ offset ; $ command [ ] = $ limit ; } if ( $ withScores ) { $ this -> _throwExceptionIfNotSupported ( '1.3.4' ) ; $ command [ ] = 'WITHSCORES' ; } return new Rediska_Connection_Exec ( $ connection , $ command ) ; } 
public function parseResponse ( $ response ) { $ values = $ response ; if ( $ this -> withScores ) { $ values = Rediska_Command_Response_ValueAndScore :: combine ( $ this -> _rediska , $ values ) ; } else { $ values = array_map ( array ( $ this -> _rediska -> getSerializer ( ) , 'unserialize' ) , $ values ) ; } return $ values ; } 
public function unserialize ( $ value ) { set_error_handler ( array ( $ this , 'catchUnserializeNotice' ) ) ; $ unserializedValue = @ unserialize ( $ value ) ; restore_error_handler ( ) ; if ( ! $ this -> _unserialized ) { $ this -> _unserialized = true ; throw new Rediska_Serializer_Adapter_Exception ( "Can't unserialize value" ) ; } return $ unserializedValue ; } 
public function catchUnserializeNotice ( $ errno , $ errstr , $ errfile , $ errline , $ errcontext ) { if ( ! error_reporting ( ) && strpos ( $ errstr , 'unserialize()' ) !== false ) { $ this -> _unserialized = false ; return true ; } else { return false ; } } 
public function create ( $ key , $ pushToKey = null ) { $ connection = $ this -> _rediska -> getConnectionByKeyName ( $ key ) ; if ( is_null ( $ pushToKey ) ) { $ command = array ( 'RPOP' , $ this -> _rediska -> getOption ( 'namespace' ) . $ key ) ; } else { $ toConnection = $ this -> _rediska -> getConnectionByKeyName ( $ pushToKey ) ; if ( $ connection -> getAlias ( ) == $ toConnection -> getAlias ( ) ) { $ this -> _throwExceptionIfNotSupported ( '1.1' ) ; $ command = array ( 'RPOPLPUSH' , $ this -> _rediska -> getOption ( 'namespace' ) . $ key , $ this -> _rediska -> getOption ( 'namespace' ) . $ pushToKey ) ; } else { $ this -> setAtomic ( false ) ; $ command = array ( 'RPOP' , $ this -> _rediska -> getOption ( 'namespace' ) . $ key ) ; } } return new Rediska_Connection_Exec ( $ connection , $ command ) ; } 
public function parseResponse ( $ response ) { if ( ! $ this -> isAtomic ( ) ) { $ value = $ this -> _rediska -> getSerializer ( ) -> unserialize ( $ response ) ; $ this -> _rediska -> prependToList ( $ this -> pushToKey , $ value ) ; return $ value ; } else { return $ this -> _rediska -> getSerializer ( ) -> unserialize ( $ response ) ; } } 
public function create ( array $ keys , $ storeKey = null ) { if ( empty ( $ keys ) ) { throw new Rediska_Command_Exception ( 'You must specify sets' ) ; } $ connections = array ( ) ; $ keysByConnections = array ( ) ; foreach ( $ keys as $ key ) { $ connection = $ this -> _rediska -> getConnectionByKeyName ( $ key ) ; $ connectionAlias = $ connection -> getAlias ( ) ; if ( ! array_key_exists ( $ connectionAlias , $ connections ) ) { $ connections [ $ connectionAlias ] = $ connection ; $ keysByConnections [ $ connectionAlias ] = array ( ) ; } $ keysByConnections [ $ connectionAlias ] [ ] = $ key ; } if ( count ( $ connections ) == 1 ) { $ connectionValues = array_values ( $ connections ) ; $ connection = $ connectionValues [ 0 ] ; if ( ! is_null ( $ storeKey ) ) { $ storeConnection = $ this -> _rediska -> getConnectionByKeyName ( $ storeKey ) ; if ( $ storeConnection === $ connection ) { $ command = array ( $ this -> _storeCommand , $ this -> _rediska -> getOption ( 'namespace' ) . $ storeKey ) ; } else { $ this -> setAtomic ( false ) ; $ this -> _storeConnection = $ storeConnection ; $ command = array ( $ this -> _command ) ; } } else { $ command = array ( $ this -> _command ) ; } $ connectionKeys = array_keys ( $ connections ) ; $ connectionAlias = $ connectionKeys [ 0 ] ; foreach ( $ keysByConnections [ $ connectionAlias ] as $ key ) { $ command [ ] = $ this -> _rediska -> getOption ( 'namespace' ) . $ key ; } return new Rediska_Connection_Exec ( $ connection , $ command ) ; } else { $ this -> setAtomic ( false ) ; $ commands = array ( ) ; foreach ( $ keysByConnections as $ connectionAlias => $ keys ) { foreach ( $ keys as $ key ) { $ command = array ( 'SMEMBERS' , $ this -> _rediska -> getOption ( 'namespace' ) . $ key ) ; $ commands [ ] = new Rediska_Connection_Exec ( $ connections [ $ connectionAlias ] , $ command ) ; } } return $ commands ; } } 
public function parseResponses ( $ responses ) { if ( ! $ this -> isAtomic ( ) ) { if ( $ this -> _storeConnection ) { $ values = $ responses [ 0 ] ; } else { $ values = array_values ( $ this -> _compareSets ( $ responses ) ) ; } $ unserializedValues = array_map ( array ( $ this -> _rediska -> getSerializer ( ) , 'unserialize' ) , $ values ) ; if ( is_null ( $ this -> storeKey ) ) { return $ unserializedValues ; } else { $ this -> _rediska -> delete ( $ this -> storeKey ) ; foreach ( $ unserializedValues as $ value ) { $ this -> _rediska -> addToSet ( $ this -> storeKey , $ value ) ; } return true ; } } else { $ reply = $ responses [ 0 ] ; if ( is_null ( $ this -> storeKey ) ) { $ reply = array_map ( array ( $ this -> _rediska -> getSerializer ( ) , 'unserialize' ) , $ reply ) ; } else { $ reply = ( boolean ) $ reply ; } return $ reply ; } } 
public function serialize ( $ value ) { $ options = 0 ; if ( $ this -> _options [ 'encodeasobject' ] ) { $ options = $ options | JSON_FORCE_OBJECT ; } if ( $ this -> _options [ 'encodehexquote' ] ) { $ options = $ options | JSON_HEX_QUOT ; } if ( $ this -> _options [ 'encodehextag' ] ) { $ options = $ options | JSON_HEX_TAG ; } if ( $ this -> _options [ 'encodehexamp' ] ) { $ options = $ options | JSON_HEX_AMP ; } if ( $ this -> _options [ 'encodehexapos' ] ) { $ options = $ options | JSON_HEX_APOS ; } $ serializedValue = json_encode ( $ value ) ; if ( json_last_error ( ) != JSON_ERROR_NONE ) { throw new Rediska_Serializer_Adapter_Exception ( "Can't serialize value" ) ; } return $ serializedValue ; } 
public function unserialize ( $ value ) { $ decodedValue = json_decode ( $ value ) ; if ( $ decodedValue === null && $ value !== 'null' ) { throw new Rediska_Serializer_Adapter_Exception ( "Can't unserialize value" ) ; } return $ decodedValue ; } 
public function add ( $ name ) { $ result = $ this -> _queuesSet -> add ( $ name ) ; if ( $ result ) { $ queuesCache = $ this -> _getQueuesCache ( ) ; $ queuesCache [ ] = $ name ; $ this -> _setQueuesCache ( $ queuesCache ) ; } return $ result ; } 
public function remove ( $ name ) { $ result = $ this -> _queuesSet -> remove ( $ name ) ; if ( $ result ) { $ queuesCache = $ this -> _getQueuesCache ( ) ; $ key = array_search ( $ name , $ queuesCache ) ; unset ( $ queuesCache [ $ key ] ) ; $ this -> _setQueuesCache ( $ queuesCache ) ; } return $ result ; } 
protected function _getQueuesCache ( ) { if ( $ this -> _queuesCache === null ) { $ this -> _queuesCache = $ this -> _queuesSet -> toArray ( ) ; } return $ this -> _queuesCache ; } 
public function watch ( $ keyOrKeys ) { $ this -> _throwIfNotSupported ( 'Watch' , '2.1' ) ; $ command = array ( 'WATCH' ) ; if ( ! is_array ( $ keyOrKeys ) ) { $ keys = array ( $ keyOrKeys ) ; } else { $ keys = $ keyOrKeys ; } foreach ( $ keys as $ key ) { $ command [ ] = $ this -> _rediska -> getOption ( 'namespace' ) . $ key ; } $ exec = new Rediska_Connection_Exec ( $ this -> _connection , $ command ) ; $ exec -> execute ( ) ; $ this -> _isWatched = true ; return $ this ; } 
public function unwatch ( ) { $ this -> _throwIfNotSupported ( 'Unwatch' , '2.1' ) ; $ command = 'UNWATCH' ; $ exec = new Rediska_Connection_Exec ( $ this -> _connection , $ command ) ; $ exec -> execute ( ) ; $ this -> _isWatched = false ; return $ this ; } 
public function execute ( ) { $ results = array ( ) ; $ this -> _rediska -> getProfiler ( ) -> start ( $ this ) ; $ multi = new Rediska_Connection_Exec ( $ this -> _connection , 'MULTI' ) ; $ multi -> execute ( ) ; foreach ( $ this -> _commands as $ command ) { $ command -> execute ( ) ; } $ exec = new Rediska_Connection_Exec ( $ this -> _connection , 'EXEC' ) ; $ responses = $ exec -> execute ( ) ; $ this -> _rediska -> getProfiler ( ) -> stop ( ) ; if ( ! $ responses ) { throw new Rediska_Transaction_AbortedException ( 'Transaction has been aborted by server' ) ; } foreach ( $ this -> _commands as $ i => $ command ) { $ results [ ] = $ command -> parseResponses ( array ( $ responses [ $ i ] ) ) ; } $ this -> _reset ( ) ; return $ results ; } 
protected function _addCommand ( $ name , $ args = array ( ) ) { $ this -> _specifiedConnection -> setConnection ( $ this -> _connection ) ; $ command = Rediska_Commands :: get ( $ this -> _rediska , $ name , $ args ) ; $ command -> initialize ( ) ; if ( ! $ command -> isAtomic ( ) ) { throw new Rediska_Exception ( "Command '$name' doesn't work properly (not atomic) in transaction on multiple servers" ) ; } $ this -> _commands [ ] = $ command ; $ this -> _specifiedConnection -> resetConnection ( ) ; return $ this ; } 
public function create ( array $ keys , $ storeKey , $ aggregation = self :: SUM ) { if ( empty ( $ keys ) ) { throw new Rediska_Command_Exception ( 'You must specify sorted sets' ) ; } 
public function parseResponses ( $ responses ) { if ( $ this -> isAtomic ( ) ) { return $ responses [ 0 ] ; } else { $ sets = array ( ) ; $ valuesWithScores = array ( ) ; foreach ( $ this -> _keys as $ key ) { $ sets [ $ key ] = array ( ) ; $ response = current ( $ responses ) ; next ( $ responses ) ; $ isValue = true ; foreach ( $ response as $ valueOrScore ) { if ( $ isValue ) { $ value = $ valueOrScore ; $ sets [ $ key ] [ ] = $ value ; if ( ! isset ( $ valuesWithScores [ $ value ] ) ) { $ valuesWithScores [ $ value ] = array ( ) ; } } else { $ score = $ valueOrScore ; $ valuesWithScores [ $ value ] [ ] = $ score * $ this -> _weights [ $ key ] ; } $ isValue = ! $ isValue ; } } $ aggregation = strtolower ( $ this -> aggregation ) ; $ pipeline = $ this -> _rediska -> pipeline ( ) ; $ count = 0 ; foreach ( $ this -> _compareSets ( $ sets ) as $ value ) { $ scores = $ valuesWithScores [ $ value ] ; switch ( $ aggregation ) { case self :: SUM : $ score = array_sum ( $ scores ) ; break ; case self :: MIN : $ score = min ( $ scores ) ; break ; case self :: MAX : $ score = max ( $ scores ) ; break ; default : throw new Rediska_Command_Exception ( 'Unknown aggregation method ' . $ this -> aggregation ) ; } $ value = $ this -> _rediska -> getSerializer ( ) -> unserialize ( $ value ) ; $ pipeline -> addToSortedSet ( $ this -> storeKey , $ value , $ score ) ; $ count ++ ; } $ pipeline -> execute ( ) ; return $ count ; } } 
public function newAction ( ) { $ currentUser = Zend_Auth :: getInstance ( ) -> getStorage ( ) -> read ( ) ; $ form = new Form_Post ; if ( $ this -> getRequest ( ) -> isPost ( ) && $ form -> isValid ( $ this -> getRequest ( ) -> getPost ( ) ) ) { $ postData = $ form -> getValues ( ) ; $ postData [ 'id' ] = Post :: fetchNextId ( ) ; $ postData [ 'userId' ] = $ currentUser [ 'id' ] ; 
public function indexAction ( ) { $ currentUser = Zend_Auth :: getInstance ( ) -> getStorage ( ) -> read ( ) ; $ feed = new Feed ( $ currentUser [ 'id' ] ) ; $ this -> view -> posts = array ( ) ; 
public function create ( $ keyOrKeys ) { if ( is_array ( $ keyOrKeys ) ) { $ this -> _multi = true ; $ keys = $ keyOrKeys ; if ( empty ( $ keys ) ) { throw new Rediska_Command_Exception ( 'Not present keys for get' ) ; } $ sortedResult = array ( ) ; $ this -> _keys = $ keys ; $ connections = array ( ) ; $ keysByConnections = array ( ) ; foreach ( $ keys as $ key ) { $ connection = $ this -> _rediska -> getConnectionByKeyName ( $ key ) ; $ connectionAlias = $ connection -> getAlias ( ) ; if ( ! array_key_exists ( $ connectionAlias , $ connections ) ) { $ connections [ $ connectionAlias ] = $ connection ; $ keysByConnections [ $ connectionAlias ] = array ( ) ; } $ keysByConnections [ $ connectionAlias ] [ ] = $ key ; } $ result = array ( ) ; $ commands = array ( ) ; foreach ( $ keysByConnections as $ connectionAlias => $ keys ) { $ command = array ( 'MGET' ) ; foreach ( $ keys as $ key ) { $ command [ ] = $ this -> _rediska -> getOption ( 'namespace' ) . $ key ; $ this -> _keysByConnections [ ] = $ key ; } $ commands [ ] = new Rediska_Connection_Exec ( $ connections [ $ connectionAlias ] , $ command ) ; } return $ commands ; } else { $ key = $ keyOrKeys ; $ connection = $ this -> _rediska -> getConnectionByKeyName ( $ key ) ; $ command = array ( 'GET' , $ this -> _rediska -> getOption ( 'namespace' ) . $ key ) ; return new Rediska_Connection_Exec ( $ connection , $ command ) ; } } 
public function parseResponses ( $ responses ) { if ( is_array ( $ this -> keyOrKeys ) ) { $ result = array ( ) ; if ( ! empty ( $ responses ) ) { $ mergedResponses = array ( ) ; foreach ( $ responses as $ response ) { $ mergedResponses = array_merge ( $ mergedResponses , $ response ) ; } $ unsortedResult = array ( ) ; foreach ( $ this -> _keysByConnections as $ i => $ key ) { $ unsortedResult [ $ key ] = $ mergedResponses [ $ i ] ; } foreach ( $ this -> _keys as $ key ) { if ( isset ( $ unsortedResult [ $ key ] ) ) { $ result [ $ key ] = $ this -> _rediska -> getSerializer ( ) -> unserialize ( $ unsortedResult [ $ key ] ) ; } } } return $ result ; } else { return $ this -> _rediska -> getSerializer ( ) -> unserialize ( $ responses [ 0 ] ) ; } } 
static public function factory ( $ config ) { $ config = self :: _parseConfig ( $ config ) ; if ( ! isset ( $ config [ 'keyName' ] ) ) { throw new Zend_Log_Exception ( 'keyName not present' ) ; } if ( ! isset ( $ config [ 'rediska' ] ) ) { $ config [ 'rediska' ] = Rediska :: DEFAULT_NAME ; } return new self ( $ config [ 'keyName' ] , $ config [ 'rediska' ] ) ; } 
public function add ( $ value , $ score ) { $ result = $ this -> _getRediskaOn ( ) -> addToSortedSet ( $ this -> getName ( ) , $ value , $ score ) ; if ( ! is_null ( $ this -> getExpire ( ) ) && $ result ) { $ this -> expire ( $ this -> getExpire ( ) , $ this -> isExpireTimestamp ( ) ) ; } return $ result ; } 
public function getLengthByScore ( $ min , $ max ) { return $ this -> _getRediskaOn ( ) -> getSortedSetLengthByScore ( $ this -> getName ( ) , $ min , $ max ) ; } 
public function getByScore ( $ min , $ max , $ withScores = false , $ limit = null , $ offset = null , $ revert = false ) { return $ this -> _getRediskaOn ( ) -> getFromSortedSetByScore ( $ this -> getName ( ) , $ min , $ max , $ withScores , $ limit , $ offset , $ revert ) ; } 
public function removeByScore ( $ min , $ max ) { return $ this -> _getRediskaOn ( ) -> DeleteFromSortedSetByScore ( $ this -> getName ( ) , $ min , $ max ) ; } 
public function incrementScore ( $ value , $ score ) { return $ this -> _getRediskaOn ( ) -> incrementScoreInSortedSet ( $ this -> getName ( ) , $ value , $ score ) ; } 
public function getByRank ( $ withScores = false , $ start = 0 , $ end = - 1 , $ revert = false , $ responseIterator = false ) { return $ this -> _getRediskaOn ( ) -> getSortedSet ( $ this -> getName ( ) , $ withScores , $ start , $ end , $ revert , $ responseIterator ) ; } 
public function removeByRank ( $ start , $ end ) { return $ this -> _getRediskaOn ( ) -> deleteFromSortedSetByRank ( $ this -> getName ( ) , $ start , $ end ) ; } 
public function getRank ( $ value , $ revert = false ) { return $ this -> _getRediskaOn ( ) -> getRankFromSortedSet ( $ this -> getName ( ) , $ value , $ revert ) ; } 
public function union ( $ setOrSets , $ storeKeyName , $ aggregation = 'sum' ) { $ sets = $ this -> _prepareSetsForComapre ( $ setOrSets ) ; return $ this -> _getRediskaOn ( ) -> unionSortedSets ( $ sets , $ storeKeyName , $ aggregation ) ; } 
public function intersect ( $ setOrSets , $ storeKeyName , $ aggregation = 'sum' ) { $ sets = $ this -> _prepareSetsForComapre ( $ setOrSets ) ; return $ this -> _getRediskaOn ( ) -> intersectSortedSets ( $ sets , $ storeKeyName , $ aggregation ) ; } 
public function toArray ( $ withScores = false , $ start = 0 , $ end = - 1 , $ revert = false , $ responseIterator = false ) { return $ this -> getByRank ( $ withScores , $ start , $ end , $ revert , $ responseIterator ) ; } 
public function fromArray ( array $ array ) { $ pipeline = $ this -> _getRediskaOn ( ) -> pipeline ( ) ; foreach ( $ array as $ score => $ value ) { $ pipeline -> addToSortedSet ( $ this -> getName ( ) , $ value , $ score ) ; } if ( ! is_null ( $ this -> getExpire ( ) ) ) { $ pipeline -> expire ( $ this -> getName ( ) , $ this -> getExpire ( ) , $ this -> isExpireTimestamp ( ) ) ; } $ pipeline -> execute ( ) ; return true ; } 
public function create ( $ key , $ start = 0 , $ end = - 1 , $ responseIterator = false ) { $ connection = $ this -> _rediska -> getConnectionByKeyName ( $ key ) ; $ command = array ( 'LRANGE' , $ this -> _rediska -> getOption ( 'namespace' ) . $ key , $ start , $ end ) ; $ exec = new Rediska_Connection_Exec ( $ connection , $ command ) ; if ( $ responseIterator ) { $ exec -> setResponseIterator ( true ) ; $ exec -> setResponseCallback ( array ( $ this -> getRediska ( ) -> getSerializer ( ) , 'unserialize' ) ) ; } return $ exec ; } 
public function setName ( $ name ) { $ this -> _options [ 'name' ] = $ name ; if ( $ this -> _options [ 'addToManager' ] ) { Rediska_Manager :: add ( $ this ) ; } return $ this ; } 
public function setServers ( array $ servers ) { $ this -> _connections = array ( ) ; foreach ( $ servers as $ alias => $ serverOptions ) { if ( ! isset ( $ serverOptions [ 'alias' ] ) && is_string ( $ alias ) ) { $ serverOptions [ 'alias' ] = $ alias ; } $ this -> addServer ( isset ( $ serverOptions [ 'host' ] ) ? $ serverOptions [ 'host' ] : Rediska_Connection :: DEFAULT_HOST , isset ( $ serverOptions [ 'port' ] ) ? $ serverOptions [ 'port' ] : Rediska_Connection :: DEFAULT_PORT , $ serverOptions ) ; } return $ this ; } 
public function addServer ( $ host , $ port = Rediska_Connection :: DEFAULT_PORT , array $ options = array ( ) ) { if ( ! isset ( $ options [ 'alias' ] ) ) { $ connectionString = "$host:$port" ; } else { $ connectionString = $ options [ 'alias' ] ; } if ( array_key_exists ( $ connectionString , $ this -> _connections ) ) { throw new Rediska_Exception ( "Server '$connectionString' already added." ) ; } $ options [ 'host' ] = $ host ; $ options [ 'port' ] = $ port ; if ( isset ( $ options [ 'useSocket' ] ) ) { if ( $ options [ 'useSocket' ] == true ) { $ connectionClass = static :: CONNECTION_SOCKET_CLASS ; } unset ( $ options [ 'useSocket' ] ) ; } else { $ connectionClass = static :: CONNECTION_CLASS ; } $ this -> _connections [ $ connectionString ] = new $ connectionClass ( $ options ) ; if ( $ this -> _keyDistributor ) { $ this -> _keyDistributor -> addConnection ( $ connectionString , isset ( $ options [ 'weight' ] ) ? $ options [ 'weight' ] : Rediska_Connection :: DEFAULT_WEIGHT ) ; } return $ this ; } 
public function removeServer ( $ aliasOrConnection ) { if ( $ aliasOrConnection instanceof Rediska_Connection ) { $ alias = $ aliasOrConnection -> getAlias ( ) ; } if ( ! isset ( $ this -> _connections [ $ alias ] ) ) { throw new Rediska_Exception ( "Can't find connection '$alias'" ) ; } unset ( $ this -> _connections [ $ alias ] ) ; if ( $ this -> _keyDistributor ) { $ this -> _keyDistributor -> removeConnection ( $ alias ) ; } return $ this ; } 
public function getConnectionByKeyName ( $ name ) { if ( $ this -> _specifiedConnection -> getConnection ( ) ) { $ connection = $ this -> _specifiedConnection -> getConnection ( ) ; } elseif ( count ( $ this -> _connections ) == 1 ) { $ connections = array_values ( $ this -> _connections ) ; $ connection = $ connections [ 0 ] ; } else { $ alias = $ this -> _keyDistributor -> getConnectionByKeyName ( $ name ) ; $ connection = $ this -> _connections [ $ alias ] ; } return $ connection ; } 
public function getConnectionByAlias ( $ alias ) { if ( ! isset ( $ this -> _connections [ $ alias ] ) ) { throw new Rediska_Exception ( "Can't find connection '$alias'" ) ; } return $ this -> _connections [ $ alias ] ; } 
public function getConnections ( ) { if ( $ this -> _specifiedConnection -> getConnection ( ) ) { return array ( $ this -> _specifiedConnection -> getConnection ( ) ) ; } else { return array_values ( $ this -> _connections ) ; } } 
public function on ( $ aliasOrConnection ) { if ( $ aliasOrConnection instanceof Rediska_Connection ) { $ connection = $ aliasOrConnection ; } else { $ alias = $ aliasOrConnection ; $ connection = $ this -> getConnectionByAlias ( $ alias ) ; } $ this -> _specifiedConnection -> setConnection ( $ connection ) ; return $ this -> _specifiedConnection ; } 
public function transaction ( $ aliasOrConnection = null ) { if ( $ aliasOrConnection instanceof Rediska_Connection ) { $ connection = $ aliasOrConnection ; } elseif ( $ aliasOrConnection !== null ) { $ connection = $ this -> getConnectionByAlias ( $ aliasOrConnection ) ; } elseif ( $ this -> _specifiedConnection -> getConnection ( ) ) { $ connection = $ this -> _specifiedConnection -> getConnection ( ) ; } else { $ connections = $ this -> getConnections ( ) ; if ( count ( $ connections ) == 1 ) { $ connection = $ connections [ 0 ] ; } else { throw new Rediska_Transaction_Exception ( 'You must specify connection by $aliasOrConnection argument!' ) ; } } return new Rediska_Transaction ( $ this , $ this -> _specifiedConnection , $ connection ) ; } 
public function subscribe ( $ channelOrChannels , $ timeout = null ) { return new Rediska_PubSub_Channel ( $ channelOrChannels , array ( 'rediska' => $ this , 'timeout' => $ timeout , 'serverAlias' => $ this -> _specifiedConnection -> getConnection ( ) ) ) ; } 
public function config ( $ aliasOrConnection = null ) { if ( $ aliasOrConnection instanceof Rediska_Connection ) { $ connection = $ aliasOrConnection ; } elseif ( $ aliasOrConnection !== null ) { $ connection = $ this -> getConnectionByAlias ( $ aliasOrConnection ) ; } elseif ( $ this -> _specifiedConnection -> getConnection ( ) ) { $ connection = $ this -> _specifiedConnection -> getConnection ( ) ; } else { $ connections = $ this -> getConnections ( ) ; if ( count ( $ connections ) == 1 ) { $ connection = $ connections [ 0 ] ; } else { throw new Rediska_Transaction_Exception ( 'You must specify connection by $aliasOrConnection argument!' ) ; } } return new Rediska_Config ( $ this , $ connection ) ; } 
public function setKeyDistributor ( $ name ) { $ this -> _options [ 'keyDistributor' ] = $ name ; if ( is_object ( $ name ) ) { $ this -> _keyDistributor = $ name ; } else if ( in_array ( $ name , array ( 'crc32' , 'consistentHashing' ) ) ) { $ name = ucfirst ( $ name ) ; $ className = "Rediska_KeyDistributor_$name" ; $ this -> _keyDistributor = new $ className ; } else { if ( ! @ class_exists ( $ name ) ) { throw new Rediska_Exception ( "Key distributor '$name' not found. You need include it before or setup autoload." ) ; } $ this -> _keyDistributor = new $ name ; } if ( ! $ this -> _keyDistributor instanceof Rediska_KeyDistributor_Interface ) { throw new Rediska_Exception ( "'$name' must implement Rediska_KeyDistributor_Interface" ) ; } 
public function getSerializer ( ) { if ( $ this -> _serializer === null ) { $ this -> _serializer = new Rediska_Serializer ( $ this -> _options [ 'serializerAdapter' ] ) ; } return $ this -> _serializer ; } 
public function getProfiler ( ) { if ( ! $ this -> _profiler ) { if ( is_string ( $ this -> _options [ 'profiler' ] ) ) { $ this -> _options [ 'profiler' ] = array ( 'name' => $ this -> _options [ 'profiler' ] ) ; } if ( $ this -> _options [ 'profiler' ] === false ) { $ this -> _profiler = new Rediska_Profiler_Null ( ) ; } else if ( $ this -> _options [ 'profiler' ] === true ) { $ this -> _profiler = new Rediska_Profiler ( ) ; } else if ( is_array ( $ this -> _options [ 'profiler' ] ) ) { if ( ! isset ( $ this -> _options [ 'profiler' ] [ 'name' ] ) ) { throw new Rediska_Exception ( "You must specify profiler 'name'." ) ; } else if ( in_array ( $ this -> _options [ 'profiler' ] [ 'name' ] , array ( 'stream' ) ) ) { $ name = ucfirst ( $ this -> _options [ 'profiler' ] [ 'name' ] ) ; $ className = "Rediska_Profiler_$name" ; $ options = $ this -> _options [ 'profiler' ] ; unset ( $ options [ 'name' ] ) ; $ this -> _profiler = new $ className ( $ options ) ; } else if ( @ class_exists ( $ this -> _options [ 'profiler' ] [ 'name' ] ) ) { $ className = $ this -> _options [ 'profiler' ] [ 'name' ] ; $ options = $ this -> _options [ 'profiler' ] ; unset ( $ options [ 'name' ] ) ; $ this -> _profiler = new $ className ( $ options ) ; } else { throw new Rediska_Exception ( "Profiler '{$this->_options['profiler']['name']}' not found. You need include it before or setup autoload." ) ; } } elseif ( is_object ( $ this -> _options [ 'profiler' ] ) ) { $ this -> _profiler = $ this -> _options [ 'profiler' ] ; } else { throw new Rediska_Exception ( "Profiler option must be a boolean, object or array of options" ) ; } if ( ! $ this -> _profiler instanceof Rediska_Profiler_Interface ) { $ profilerClass = get_class ( $ this -> _profiler ) ; throw new Rediska_Serializer_Exception ( "Profiler '$profilerClass' must implement Rediska_Profiler_Interface" ) ; } } return $ this -> _profiler ; } 
protected function _executeCommand ( $ name , $ args = array ( ) ) { $ this -> _specifiedConnection -> resetConnection ( ) ; $ command = Rediska_Commands :: get ( $ this , $ name , $ args ) ; $ this -> getProfiler ( ) -> start ( $ command ) ; $ response = $ command -> execute ( ) ; $ this -> getProfiler ( ) -> stop ( ) ; unset ( $ command ) ; return $ response ; } 
public function create ( $ key , $ fieldOrFields ) { if ( is_array ( $ fieldOrFields ) ) { $ this -> _fields = array_values ( $ fieldOrFields ) ; if ( empty ( $ this -> _fields ) ) { throw new Rediska_Command_Exception ( 'Not present fields' ) ; } $ command = array_merge ( array ( 'HMGET' , $ this -> _rediska -> getOption ( 'namespace' ) . $ key ) , $ this -> _fields ) ; } else { $ field = $ fieldOrFields ; $ command = array ( 'HGET' , $ this -> _rediska -> getOption ( 'namespace' ) . $ key , $ field ) ; } $ connection = $ this -> _rediska -> getConnectionByKeyName ( $ key ) ; return new Rediska_Connection_Exec ( $ connection , $ command ) ; } 
public function parseResponse ( $ response ) { if ( ! empty ( $ this -> _fields ) ) { $ result = array ( ) ; $ fieldsCount = count ( $ this -> _fields ) ; for ( $ i = 0 ; $ i < $ fieldsCount ; $ i ++ ) { $ result [ $ this -> _fields [ $ i ] ] = $ this -> _rediska -> getSerializer ( ) -> unserialize ( $ response [ $ i ] ) ; } return $ result ; } else { return $ this -> _rediska -> getSerializer ( ) -> unserialize ( $ response ) ; } } 
public static function add ( $ name , $ className ) { if ( ! class_exists ( $ className ) ) { throw new Rediska_Exception ( "Class '$className' not found. You must include before or setup autoload" ) ; } $ classReflection = new ReflectionClass ( $ className ) ; if ( ! in_array ( 'Rediska_Command_Interface' , $ classReflection -> getInterfaceNames ( ) ) ) { throw new Rediska_Exception ( "Class '$className' must implement Rediska_Command_Interface interface" ) ; } $ lowerName = strtolower ( $ name ) ; self :: $ _commands [ $ lowerName ] = $ className ; return true ; } 
public static function remove ( $ name ) { $ lowerName = self :: _getCommandLowerNameAndThrowIfNotPresent ( $ name ) ; unset ( self :: $ _commands [ $ lowerName ] ) ; return true ; } 
public static function get ( Rediska $ rediska , $ name , $ arguments ) { $ lowerName = self :: _getCommandLowerNameAndThrowIfNotPresent ( $ name ) ; return new self :: $ _commands [ $ lowerName ] ( $ rediska , $ name , $ arguments ) ; } 
protected static function _getCommandLowerNameAndThrowIfNotPresent ( $ name ) { $ lowerName = strtolower ( $ name ) ; if ( ! isset ( self :: $ _commands [ $ lowerName ] ) ) { throw new Rediska_Exception ( "Command '$name' not found" ) ; } return $ lowerName ; } 
public function execute ( ) { $ results = array ( ) ; if ( ! empty ( $ this -> _commands ) ) { $ this -> _rediska -> getProfiler ( ) -> start ( $ this ) ; foreach ( $ this -> _commands as $ command ) { $ command -> write ( ) ; } foreach ( $ this -> _commands as $ command ) { $ results [ ] = $ command -> read ( ) ; } $ this -> _rediska -> getProfiler ( ) -> stop ( ) ; } return $ results ; } 
protected function _addCommand ( $ name , $ args = array ( ) ) { if ( $ this -> _oneTimeConnection ) { $ connection = $ this -> _oneTimeConnection ; $ this -> _oneTimeConnection = null ; } else { $ connection = $ this -> _defaultConnection ; } if ( $ connection !== null ) { $ this -> _specifiedConnection -> setConnection ( $ connection ) ; } else { $ this -> _specifiedConnection -> resetConnection ( ) ; } $ command = Rediska_Commands :: get ( $ this -> _rediska , $ name , $ args ) ; $ command -> initialize ( ) ; if ( ! $ command -> isAtomic ( ) ) { throw new Rediska_Exception ( "Command '$name' doesn't work properly (not atomic) in pipeline on multiple servers" ) ; } $ this -> _commands [ ] = $ command ; $ this -> _specifiedConnection -> resetConnection ( ) ; return $ this ; } 
public function create ( $ fromKey , $ toKey , $ member ) { $ fromKeyConnection = $ this -> _rediska -> getConnectionByKeyName ( $ fromKey ) ; $ toKeyConnection = $ this -> _rediska -> getConnectionByKeyName ( $ toKey ) ; $ member = $ this -> _rediska -> getSerializer ( ) -> serialize ( $ member ) ; if ( $ fromKeyConnection === $ toKeyConnection ) { $ command = array ( 'SMOVE' , $ this -> _rediska -> getOption ( 'namespace' ) . $ fromKey , $ this -> _rediska -> getOption ( 'namespace' ) . $ toKey , $ member ) ; } else { $ this -> setAtomic ( false ) ; $ command = array ( 'SISMEMBER' , $ this -> _rediska -> getOption ( 'namespace' ) . $ fromKey , $ member ) ; } return new Rediska_Connection_Exec ( $ fromKeyConnection , $ command ) ; } 
public function parseResponses ( $ responses ) { if ( ! $ this -> isAtomic ( ) ) { if ( $ responses [ 0 ] ) { $ this -> _rediska -> deleteFromSet ( $ this -> fromKey , $ this -> member ) ; return $ this -> _rediska -> addToSet ( $ this -> toKey , $ this -> member ) ; } else { return false ; } } else { return ( boolean ) $ responses [ 0 ] ; } } 
public function getCommand ( $ timeout = null ) { if ( ! $ timeout && $ this -> getTimeout ( ) ) { $ timeout = $ this -> getTimeout ( ) ; } 
protected function _getResponseFromConnection ( Rediska_Connection $ connection ) { $ response = Rediska_Connection_Exec :: readResponseFromConnection ( $ connection ) ; if ( $ response === null || $ response === true ) { return null ; } $ timestampAndCommand = explode ( ' ' , $ response , 2 ) ; $ command = $ timestampAndCommand [ 1 ] ; if ( $ command == '"MONITOR"' ) { return null ; } return $ timestampAndCommand ; } 
public function create ( ) { $ command = array ( 'LASTSAVE' ) ; $ commands = array ( ) ; foreach ( $ this -> _rediska -> getConnections ( ) as $ connection ) { $ this -> _connections [ ] = $ connection -> getAlias ( ) ; $ commands [ ] = new Rediska_Connection_Exec ( $ connection , $ command ) ; } return $ commands ; } 
public function parseResponses ( $ responses ) { $ timestamps = array ( ) ; $ count = 0 ; foreach ( $ this -> _connections as $ connection ) { $ timestamps [ $ connection ] = $ responses [ $ count ] ; $ count ++ ; } if ( count ( $ timestamps ) == 1 ) { $ timestamps = array_values ( $ timestamps ) ; $ timestamps = $ timestamps [ 0 ] ; } return $ timestamps ; } 
public function write ( ) { $ result = $ this -> getConnection ( ) -> write ( $ this -> getCommand ( ) ) ; $ this -> _isWritten = true ; return $ result ; } 
public function read ( ) { if ( ! $ this -> isWritten ( ) ) { throw new Rediska_Connection_Exec_Exception ( 'You must write command before read' ) ; } $ this -> _isWritten = false ; if ( $ this -> getResponseIterator ( ) !== null ) { if ( $ this -> getResponseIterator ( ) === true ) { $ className = 'Rediska_Connection_Exec_MultiBulkIterator' ; } else { $ className = $ this -> getResponseIterator ( ) ; } $ response = new $ className ( $ this -> getConnection ( ) , $ this -> getResponseCallback ( ) ) ; } else { $ response = self :: readResponseFromConnection ( $ this -> getConnection ( ) ) ; if ( $ this -> _responseCallback !== null ) { $ response = call_user_func ( $ this -> getResponseCallback ( ) , $ response ) ; } } return $ response ; } 
public function getConnection ( ) { if ( $ this -> _responseIterator === null ) { return $ this -> _connection ; } else { if ( $ this -> _connectionClone === null ) { $ this -> _connectionClone = clone $ this -> _connection ; } return $ this -> _connectionClone ; } return $ this -> _connection ; } 
public function setResponseCallback ( $ callback ) { if ( $ callback !== null && ! is_callable ( $ callback ) ) { throw new Rediska_Connection_Exec_Exception ( 'Bad callback' ) ; } $ this -> _responseCallback = $ callback ; return $ this ; } 
public static function transformMultiBulkCommand ( array $ command ) { $ commandString = self :: REPLY_MULTY_BULK . count ( $ command ) . Rediska :: EOL ; foreach ( $ command as $ argument ) { $ commandString .= self :: REPLY_BULK . strlen ( $ argument ) . Rediska :: EOL . $ argument . Rediska :: EOL ; } return $ commandString ; } 
public static function readResponseFromConnection ( Rediska_Connection $ connection ) { $ reply = $ connection -> readLine ( ) ; if ( $ reply === null ) { return $ reply ; } $ type = substr ( $ reply , 0 , 1 ) ; $ data = substr ( $ reply , 1 ) ; switch ( $ type ) { case self :: REPLY_STATUS : if ( $ data == 'OK' ) { return true ; } else { return $ data ; } case self :: REPLY_ERROR : throw new Rediska_Connection_Exec_Exception ( $ data ) ; case self :: REPLY_INTEGER : if ( strpos ( $ data , '.' ) !== false ) { $ number = ( integer ) $ data ; } else { $ number = ( float ) $ data ; } return $ number ; case self :: REPLY_BULK : if ( $ data == '-1' ) { return null ; } else { $ length = ( integer ) $ data ; return $ connection -> read ( $ length ) ; } case self :: REPLY_MULTY_BULK : $ count = ( integer ) $ data ; $ replies = array ( ) ; for ( $ i = 0 ; $ i < $ count ; $ i ++ ) { $ replies [ ] = self :: readResponseFromConnection ( $ connection ) ; } return $ replies ; default : throw new Rediska_Connection_Exec_Exception ( "Invalid reply type: '$type'" ) ; } } 
public function stopCallback ( Rediska_Profiler_Profile $ profile ) { $ commandString = $ profile -> getContext ( ) -> __toString ( ) ; $ matches = array ( ) ; preg_match ( '/^(.+)\((.*)\)$/s' , $ commandString , $ matches ) ; $ row = array ( ( double ) $ profile -> getElapsedTime ( 4 ) ) ; if ( isset ( $ matches [ 1 ] ) ) { $ row [ ] = $ matches [ 1 ] ; $ row [ ] = $ matches [ 2 ] ; } else { $ row [ ] = $ commandString ; } $ this -> getMessage ( ) -> addRow ( $ row ) ; $ placeHolders = array ( '%rediskaName%' => $ profile -> getContext ( ) -> getRediska ( ) -> getName ( ) , '%count%' => $ this -> count ( ) , '%totalElapsedTime%' => $ this -> getTotalElapsedTime ( 4 ) , ) ; $ label = str_replace ( array_keys ( $ placeHolders ) , array_values ( $ placeHolders ) , $ this -> getLabel ( ) ) ; $ this -> getMessage ( ) -> setLabel ( $ label ) ; } 
public function append ( $ value , $ createIfNotExists = true ) { $ result = $ this -> _getRediskaOn ( ) -> appendToList ( $ this -> getName ( ) , $ value , $ createIfNotExists ) ; if ( ! is_null ( $ this -> getExpire ( ) ) && $ result ) { $ this -> expire ( $ this -> getExpire ( ) , $ this -> isExpireTimestamp ( ) ) ; } return $ result ; } 
public function prepend ( $ value , $ createIfNotExists = true ) { $ result = $ this -> _getRediskaOn ( ) -> prependToList ( $ this -> getName ( ) , $ value , $ createIfNotExists ) ; if ( ! is_null ( $ this -> getExpire ( ) ) && $ result ) { $ this -> expire ( $ this -> getExpire ( ) , $ this -> isExpireTimestamp ( ) ) ; } return $ result ; } 
public function truncate ( $ start , $ end ) { $ result = $ this -> _getRediskaOn ( ) -> truncateList ( $ this -> getName ( ) , $ start , $ end ) ; if ( ! is_null ( $ this -> getExpire ( ) ) && $ result ) { $ this -> expire ( $ this -> getExpire ( ) , $ this -> isExpireTimestamp ( ) ) ; } return $ result ; } 
public function set ( $ index , $ value ) { $ result = $ this -> _getRediskaOn ( ) -> setToList ( $ this -> getName ( ) , $ index , $ value ) ; if ( ! is_null ( $ this -> getExpire ( ) ) && $ result ) { $ this -> expire ( $ this -> getExpire ( ) , $ this -> isExpireTimestamp ( ) ) ; } return $ result ; } 
public function insertAfter ( $ referenceValue , $ value ) { return $ this -> _getRediskaOn ( ) -> insertToListAfter ( $ this -> getName ( ) , $ referenceValue , $ value ) ; } 
public function insertBefore ( $ referenceValue , $ value ) { return $ this -> _getRediskaOn ( ) -> insertToListBefore ( $ this -> getName ( ) , $ referenceValue , $ value ) ; } 
public function insert ( $ position , $ referenceValue , $ value ) { return $ this -> _getRediskaOn ( ) -> insertToList ( $ this -> getName ( ) , $ position , $ referenceValue , $ value ) ; } 
public function remove ( $ value , $ count = 0 ) { $ result = $ this -> _getRediskaOn ( ) -> deleteFromList ( $ this -> getName ( ) , $ value , $ count ) ; if ( ! is_null ( $ this -> getExpire ( ) ) && $ result ) { $ this -> expire ( $ this -> getExpire ( ) , $ this -> isExpireTimestamp ( ) ) ; } return $ result ; } 
public function shift ( ) { $ result = $ this -> _getRediskaOn ( ) -> shiftFromList ( $ this -> getName ( ) ) ; if ( ! is_null ( $ this -> getExpire ( ) ) && $ result ) { $ this -> expire ( $ this -> getExpire ( ) , $ this -> isExpireTimestamp ( ) ) ; } return $ result ; } 
public function shiftBlocking ( $ timeout = 0 ) { $ result = $ this -> _getRediskaOn ( ) -> shiftFromListBlocking ( $ this -> getName ( ) , $ timeout ) ; if ( ! is_null ( $ this -> getExpire ( ) ) && $ result ) { $ this -> expire ( $ this -> getExpire ( ) , $ this -> isExpireTimestamp ( ) ) ; } return $ result ; } 
public function pop ( $ pushTo = null ) { if ( $ pushTo instanceof Rediska_Key_List ) { $ pushTo = $ pushTo -> getName ( ) ; } $ result = $ this -> _getRediskaOn ( ) -> popFromList ( $ this -> getName ( ) , $ pushTo ) ; if ( ! is_null ( $ this -> getExpire ( ) ) && $ result ) { $ this -> expire ( $ this -> getExpire ( ) , $ this -> isExpireTimestamp ( ) ) ; } return $ result ; } 
public function popBlocking ( $ timeout = 0 , $ pushToKey = null ) { $ result = $ this -> _getRediskaOn ( ) -> popFromListBlocking ( $ this -> getName ( ) , $ timeout , $ pushToKey ) ; if ( ! is_null ( $ this -> getExpire ( ) ) && $ result ) { $ this -> expire ( $ this -> getExpire ( ) , $ this -> isExpireTimestamp ( ) ) ; } return $ result ; } 
public function getValues ( $ start = 0 , $ end = - 1 , $ responseIterator = false ) { return $ this -> _getRediskaOn ( ) -> getList ( $ this -> getName ( ) , $ start , $ end , $ responseIterator ) ; } 
public function toArray ( $ start = 0 , $ end = - 1 , $ responseIterator = false ) { return $ this -> getValues ( $ start , $ end , $ responseIterator ) ; } 
public function fromArray ( array $ array ) { $ pipeline = $ this -> _getRediskaOn ( ) -> pipeline ( ) ; foreach ( $ array as $ item ) { $ pipeline -> appendToList ( $ this -> getName ( ) , $ item ) ; } if ( ! is_null ( $ this -> getExpire ( ) ) ) { $ pipeline -> expire ( $ this -> getName ( ) , $ this -> getExpire ( ) , $ this -> isExpireTimestamp ( ) ) ; } $ pipeline -> execute ( ) ; return true ; } 
public function create ( $ key , $ withScores = false , $ start = 0 , $ end = - 1 , $ revert = false , $ responseIterator = false ) { $ connection = $ this -> _rediska -> getConnectionByKeyName ( $ key ) ; $ command = array ( $ revert ? 'ZREVRANGE' : 'ZRANGE' , $ this -> _rediska -> getOption ( 'namespace' ) . $ key , $ start , $ end ) ; if ( $ withScores ) { $ command [ ] = 'WITHSCORES' ; } $ exec = new Rediska_Connection_Exec ( $ connection , $ command ) ; if ( $ responseIterator ) { if ( $ withScores ) { $ responseIterator = 'Rediska_Command_GetSortedSet_WithScoresIterator' ; } $ exec -> setResponseIterator ( $ responseIterator ) ; $ exec -> setResponseCallback ( array ( $ this , 'parseIteratorResponse' ) ) ; } return $ exec ; } 
public function load ( $ id , $ doNotTestCacheValidity = false ) { $ id = ( array ) $ id ; foreach ( $ id as $ key ) { $ key = $ this -> _options [ 'storage' ] [ 'prefix_key' ] . $ key ; $ this -> _getTransactionByKey ( $ key ) -> getFromHash ( $ key , self :: FIELD_DATA ) ; } $ oldSerializaerAdapter = $ this -> getRediska ( ) -> getSerializer ( ) -> getAdapter ( ) ; $ this -> getRediska ( ) -> setSerializerAdapter ( 'toString' ) ; $ result = $ this -> _execTransactions ( ) ; $ this -> getRediska ( ) -> getSerializer ( ) -> setAdapter ( $ oldSerializaerAdapter ) ; if ( count ( $ result ) == 1 ) { if ( null === ( $ result = array_shift ( $ result ) ) ) { return false ; } else { return $ result ; } } else { return $ result ; } } 
public function save ( $ data , $ id , $ tags = array ( ) , $ specificLifetime = false ) { if ( ! is_array ( $ tags ) ) $ tags = array ( $ tags ) ; $ lifetime = $ this -> getLifetime ( $ specificLifetime ) ; $ oldTags = explode ( ',' , $ this -> getRediska ( ) -> getFromHash ( $ this -> _options [ 'storage' ] [ 'prefix_key' ] . $ id , self :: FIELD_TAGS ) ) ; $ this -> _getTransactionByKey ( $ this -> _options [ 'storage' ] [ 'prefix_key' ] . $ id ) -> setToHash ( $ this -> _options [ 'storage' ] [ 'prefix_key' ] . $ id , array ( self :: FIELD_DATA => $ data , self :: FIELD_TAGS => implode ( ',' , $ tags ) , self :: FIELD_MTIME => time ( ) , self :: FIELD_INF => $ lifetime ? 0 : 1 ) ) ; $ this -> _getTransactionByKey ( $ this -> _options [ 'storage' ] [ 'prefix_key' ] . $ id ) -> expire ( $ this -> _options [ 'storage' ] [ 'prefix_key' ] . $ id , $ lifetime ? $ lifetime : self :: MAX_LIFETIME ) ; if ( $ addTags = ( $ oldTags ? array_diff ( $ tags , $ oldTags ) : $ tags ) ) { foreach ( $ addTags as $ add ) { $ this -> _getTransactionByKey ( $ this -> _options [ 'storage' ] [ 'set_tags' ] ) -> addToSet ( $ this -> _options [ 'storage' ] [ 'set_tags' ] , $ add ) ; } foreach ( $ addTags as $ tag ) { $ this -> _getTransactionByKey ( $ this -> _options [ 'storage' ] [ 'prefix_tag_ids' ] . $ tag ) -> addToSet ( $ this -> _options [ 'storage' ] [ 'prefix_tag_ids' ] . $ tag , $ id ) ; } } if ( $ remTags = ( $ oldTags ? array_diff ( $ oldTags , $ tags ) : false ) ) { foreach ( $ remTags as $ tag ) { $ this -> _getTransactionByKey ( $ this -> _options [ 'storage' ] [ 'prefix_tag_ids' ] . $ tag ) -> deleteFromSet ( $ this -> _options [ 'storage' ] [ 'prefix_tag_ids' ] . $ tag , $ id ) ; } } $ this -> _getTransactionByKey ( $ this -> _options [ 'storage' ] [ 'set_ids' ] ) -> addToSet ( $ this -> _options [ 'storage' ] [ 'set_ids' ] , $ id ) ; try { $ this -> _execTransactions ( ) ; return true ; } catch ( Rediska_Transaction_Exception $ e ) { $ this -> _log ( $ e -> getMessage ( ) , Zend_Log :: ERR ) ; return false ; } } 
public function remove ( $ id ) { $ tags = explode ( ',' , $ this -> getRediska ( ) -> getFromHash ( $ this -> _options [ 'storage' ] [ 'prefix_key' ] . $ id , self :: FIELD_TAGS ) ) ; $ this -> _getTransactionByKey ( $ this -> _options [ 'storage' ] [ 'prefix_key' ] . $ id ) -> delete ( $ this -> _options [ 'storage' ] [ 'prefix_key' ] . $ id ) ; $ this -> _getTransactionByKey ( $ this -> _options [ 'storage' ] [ 'set_ids' ] , $ id ) -> deleteFromSet ( $ this -> _options [ 'storage' ] [ 'set_ids' ] , $ id ) ; foreach ( $ tags as $ tag ) { $ this -> _getTransactionByKey ( $ this -> _options [ 'storage' ] [ 'prefix_tag_ids' ] . $ tag ) -> deleteFromSet ( $ this -> _options [ 'storage' ] [ 'prefix_tag_ids' ] . $ tag , $ id ) ; } $ result = $ this -> _execTransactions ( ) ; if ( count ( $ result ) ) { return array_shift ( $ result ) ; } else { return false ; } } 
public function clean ( $ mode = Zend_Cache :: CLEANING_MODE_ALL , $ tags = array ( ) ) { if ( $ tags && ! is_array ( $ tags ) ) { $ tags = array ( $ tags ) ; } $ result = true ; switch ( $ mode ) { case Zend_Cache :: CLEANING_MODE_ALL : $ this -> _removeIds ( $ this -> getIds ( ) ) ; break ; case Zend_Cache :: CLEANING_MODE_OLD : break ; case Zend_Cache :: CLEANING_MODE_MATCHING_TAG : $ this -> _removeIdsByMatchingTags ( $ tags ) ; break ; case Zend_Cache :: CLEANING_MODE_NOT_MATCHING_TAG : $ this -> _removeIdsByNotMatchingTags ( $ tags ) ; break ; case Zend_Cache :: CLEANING_MODE_MATCHING_ANY_TAG : $ this -> _removeIdsByMatchingAnyTags ( $ tags ) ; break ; default : Zend_Cache :: throwException ( 'Invalid mode for clean() method: ' . $ mode ) ; } return $ this -> _collectGarbage ( ) ; } 
public function setDirectives ( $ directives ) { parent :: setDirectives ( $ directives ) ; $ lifetime = $ this -> getLifetime ( false ) ; if ( $ lifetime > self :: MAX_LIFETIME ) { $ this -> _log ( 'redis backend has a limit of 30 days (' . self :: MAX_LIFETIME . ' seconds) for the lifetime' ) ; } } 
public function getIdsNotMatchingTags ( $ tags = array ( ) ) { $ sets = $ this -> _preprocessTagIds ( $ tags ) ; array_unshift ( $ sets , $ this -> _options [ 'storage' ] [ 'set_ids' ] ) ; $ data = $ this -> getRediska ( ) -> diffSets ( $ sets ) ; return $ data ; } 
public function getMetadatas ( $ id ) { $ metaData = $ this -> getRediska ( ) -> getFromHash ( $ this -> _options [ 'storage' ] [ 'prefix_key' ] . $ id , array ( self :: FIELD_DATA , self :: FIELD_TAGS , self :: FIELD_MTIME , self :: FIELD_INF ) ) ; if ( ! $ metaData [ self :: FIELD_MTIME ] ) { return false ; } $ lifetime = $ this -> getRediska ( ) -> getLifetime ( $ this -> _options [ 'storage' ] [ 'prefix_key' ] . $ id ) ; $ tags = explode ( ',' , $ metaData [ self :: FIELD_TAGS ] ) ; $ expire = $ metaData [ self :: FIELD_INF ] === '1' ? false : time ( ) + $ lifetime ; return array ( 'expire' => $ expire , 'tags' => $ tags , 'mtime' => $ metaData [ self :: FIELD_MTIME ] , ) ; } 
public function touch ( $ id , $ extraLifetime ) { $ data = $ this -> getRediska ( ) -> getFromHash ( $ this -> _options [ 'storage' ] [ 'prefix_key' ] . $ id , array ( self :: FIELD_INF ) ) ; $ lifetime = $ this -> getRediska ( ) -> getLifetime ( $ this -> _options [ 'storage' ] [ 'prefix_key' ] . $ id ) ; if ( $ data [ self :: FIELD_INF ] === 0 ) { $ expireAt = time ( ) + $ lifetime + $ extraLifetime ; return ( bool ) $ this -> getRediska ( ) -> expire ( $ this -> _options [ 'storage' ] [ 'prefix_key' ] . $ id , $ expireAt , true ) ; } return false ; } 
protected function _collectGarbage ( ) { $ exists = array ( ) ; $ tags = $ this -> getTags ( ) ; foreach ( $ tags as $ tag ) { $ prefix_tag_ids = $ this -> _options [ 'storage' ] [ 'prefix_tag_ids' ] . $ tag ; $ tagMembers = $ this -> getRediska ( ) -> getSet ( $ prefix_tag_ids ) ; $ this -> _getTransactionByKey ( $ prefix_tag_ids ) -> watch ( $ prefix_tag_ids ) ; $ expired = array ( ) ; if ( count ( $ tagMembers ) ) { foreach ( $ tagMembers as $ id ) { if ( ! isset ( $ exists [ $ id ] ) ) { $ exists [ $ id ] = $ this -> getRediska ( ) -> exists ( $ this -> _options [ 'storage' ] [ 'prefix_key' ] . $ id ) ; } if ( ! $ exists [ $ id ] ) { $ expired [ ] = $ id ; } } if ( ! count ( $ expired ) ) continue ; } if ( ! count ( $ tagMembers ) || count ( $ expired ) == count ( $ tagMembers ) ) { $ this -> _getTransactionByKey ( $ this -> _options [ 'storage' ] [ 'set_tags' ] ) -> deleteFromSet ( $ this -> _options [ 'storage' ] [ 'set_tags' ] , $ tag ) ; $ this -> _getTransactionByKey ( $ this -> _options [ 'storage' ] [ 'prefix_tag_ids' ] . $ tag ) -> delete ( $ this -> _options [ 'storage' ] [ 'prefix_tag_ids' ] . $ tag ) ; } else { $ this -> _getTransactionByKey ( $ this -> _options [ 'storage' ] [ 'prefix_tag_ids' ] . $ tag ) -> deleteFromSet ( $ this -> _options [ 'storage' ] [ 'prefix_tag_ids' ] . $ tag , $ expired ) ; } $ this -> _getTransactionByKey ( $ this -> _options [ 'storage' ] [ 'set_ids' ] ) -> deleteFromSet ( $ this -> _options [ 'storage' ] [ 'set_ids' ] , $ expired ) ; } try { return ( bool ) $ this -> _execTransactions ( ) ; } catch ( Rediska_Transaction_AbortedException $ e ) { $ this -> _log ( $ e -> getMessage ( ) , Zend_Log :: ERR ) ; return false ; } } 
protected function _getTransactionByKey ( $ key ) { $ connection = $ this -> getRediska ( ) -> getConnectionByKeyName ( $ key ) ; if ( ! $ this -> _transaction [ $ connection -> getAlias ( ) ] ) { $ this -> _transaction [ $ connection -> getAlias ( ) ] = $ this -> getRediska ( ) -> transaction ( $ connection ) ; } return $ this -> _transaction [ $ connection -> getAlias ( ) ] ; } 
public function create ( $ keyOrData , $ valueOrOverwrite = null , $ overwrite = true ) { if ( is_array ( $ keyOrData ) ) { $ this -> _throwExceptionIfNotSupported ( '1.1' ) ; $ this -> _multiple = true ; $ data = $ keyOrData ; $ overwrite = ( $ valueOrOverwrite === null || $ valueOrOverwrite ) ; if ( empty ( $ data ) ) { throw new Rediska_Command_Exception ( 'Not present keys and values for set' ) ; } $ connections = array ( ) ; $ keysByConnections = array ( ) ; foreach ( $ data as $ key => $ value ) { $ connection = $ this -> _rediska -> getConnectionByKeyName ( $ key ) ; $ connectionAlias = $ connection -> getAlias ( ) ; if ( ! array_key_exists ( $ connectionAlias , $ connections ) ) { $ connections [ $ connectionAlias ] = $ connection ; $ keysByConnections [ $ connectionAlias ] = array ( ) ; } $ keysByConnections [ $ connectionAlias ] [ $ key ] = $ value ; } $ commands = array ( ) ; $ namespace = $ this -> _rediska -> getOption ( 'namespace' ) ; foreach ( $ keysByConnections as $ connectionAlias => $ data ) { $ command = array ( $ overwrite ? 'MSET' : 'MSETNX' ) ; foreach ( $ data as $ key => $ value ) { $ command [ ] = $ namespace . $ key ; $ command [ ] = $ this -> _rediska -> getSerializer ( ) -> serialize ( $ value ) ; } $ commands [ ] = new Rediska_Connection_Exec ( $ connections [ $ connectionAlias ] , $ command ) ; } return $ commands ; } else { $ key = $ keyOrData ; $ value = $ valueOrOverwrite ; $ connection = $ this -> _rediska -> getConnectionByKeyName ( $ key ) ; $ value = $ this -> _rediska -> getSerializer ( ) -> serialize ( $ value ) ; $ command = array ( $ overwrite ? 'SET' : 'SETNX' , $ this -> _rediska -> getOption ( 'namespace' ) . $ key , $ value ) ; return new Rediska_Connection_Exec ( $ connection , $ command ) ; } } 
public function parseResponses ( $ responses ) { if ( $ this -> _multiple ) { if ( ! empty ( $ responses ) ) { foreach ( $ responses as $ response ) { if ( ! $ response ) { return false ; } } return true ; } else { return false ; } } else { return ( boolean ) $ responses [ 0 ] ; } } 
public function create ( $ keyOrKeys , $ timeout = 0 ) { if ( ! is_array ( $ keyOrKeys ) ) { $ keys = array ( $ keyOrKeys ) ; } elseif ( ! empty ( $ keyOrKeys ) ) { $ keys = $ keyOrKeys ; } else { throw new Rediska_Command_Exception ( 'Not present keys for shift' ) ; } $ connections = array ( ) ; $ keysByConnections = array ( ) ; foreach ( $ keys as $ key ) { $ connection = $ this -> _rediska -> getConnectionByKeyName ( $ key ) ; $ connectionAlias = $ connection -> getAlias ( ) ; if ( ! array_key_exists ( $ connectionAlias , $ connections ) ) { $ connections [ $ connectionAlias ] = $ connection ; $ keysByConnections [ $ connectionAlias ] = array ( ) ; } $ keysByConnections [ $ connectionAlias ] [ ] = $ key ; } 
public function parseResponse ( $ response ) { if ( ! is_array ( $ this -> keyOrKeys ) && ! empty ( $ response ) ) { $ result = $ this -> _rediska -> getSerializer ( ) -> unserialize ( $ response [ 1 ] ) ; } else { $ result = Rediska_Command_Response_ListNameAndValue :: factory ( $ this -> _rediska , $ response ) ; } return $ result ; } 
public function create ( $ all = false ) { if ( $ all ) { $ command = array ( 'FLUSHALL' ) ; } else { $ command = array ( 'FLUSHDB' ) ; } $ commands = array ( ) ; foreach ( $ this -> _rediska -> getConnections ( ) as $ connection ) { $ commands [ ] = new Rediska_Connection_Exec ( $ connection , $ command ) ; } return $ commands ; } 
public function add ( $ value ) { $ result = $ this -> _getRediskaOn ( ) -> addToSet ( $ this -> getName ( ) , $ value ) ; if ( ! is_null ( $ this -> getExpire ( ) ) && $ result ) { $ this -> expire ( $ this -> getExpire ( ) , $ this -> isExpireTimestamp ( ) ) ; } return $ result ; } 
public function remove ( $ value ) { $ result = $ this -> _getRediskaOn ( ) -> deleteFromSet ( $ this -> getName ( ) , $ value ) ; if ( ! is_null ( $ this -> getExpire ( ) ) && $ result ) { $ this -> expire ( $ this -> getExpire ( ) , $ this -> isExpireTimestamp ( ) ) ; } return $ result ; } 
public function move ( $ set , $ value ) { if ( $ set instanceof Rediska_Key_Set ) { $ set = $ set -> getName ( ) ; } return $ this -> _getRediskaOn ( ) -> moveToSet ( $ this -> getName ( ) , $ set , $ value ) ; } 
public function intersect ( $ setOrSets , $ storeKeyName = null ) { $ sets = $ this -> _prepareSetsForCompare ( $ setOrSets ) ; return $ this -> _getRediskaOn ( ) -> intersectSets ( $ sets , $ storeKeyName ) ; } 
public function union ( $ setOrSets , $ storeKeyName = null ) { $ sets = $ this -> _prepareSetsForCompare ( $ setOrSets ) ; return $ this -> _getRediskaOn ( ) -> unionSets ( $ sets , $ storeKeyName ) ; } 
public function diff ( $ setOrSets , $ storeKeyName = null ) { $ sets = $ this -> _prepareSetsForCompare ( $ setOrSets ) ; return $ this -> _getRediskaOn ( ) -> diffSets ( $ sets , $ storeKeyName ) ; } 
public function getRediska ( ) { if ( ! is_object ( $ this -> _rediska ) ) { $ this -> _rediska = self :: getRediskaInstance ( $ this -> _rediska , $ this -> _optionsException , $ this -> _rediskaOptionName ) ; } return $ this -> _rediska ; } 
public function setValue ( $ value ) { if ( $ this -> getExpire ( ) !== null && ! $ this -> isExpireTimestamp ( ) ) { $ reply = $ this -> setAndExpire ( $ value , $ this -> getExpire ( ) ) ; } else { $ reply = $ this -> _getRediskaOn ( ) -> set ( $ this -> getName ( ) , $ value ) ; if ( $ reply && ! is_null ( $ this -> getExpire ( ) ) ) { $ this -> expire ( $ this -> getExpire ( ) , $ this -> isExpireTimestamp ( ) ) ; } } return $ reply ; } 
public function setAndExpire ( $ value , $ seconds ) { return $ this -> _getRediskaOn ( ) -> setAndExpire ( $ this -> getName ( ) , $ value , $ seconds ) ; } 
public function setBit ( $ offset , $ bit ) { return $ this -> _getRediskaOn ( ) -> setBit ( $ this -> getName ( ) , $ offset , $ bit ) ; } 
public function setRange ( $ offset , $ value ) { return $ this -> _getRediskaOn ( ) -> setRange ( $ this -> getName ( ) , $ offset , $ value ) ; } 
public function getRange ( $ start , $ end = - 1 ) { return $ this -> _getRediskaOn ( ) -> getRange ( $ this -> getName ( ) , $ start , $ end ) ; } 
public function substring ( $ start , $ end = - 1 ) { return $ this -> _getRediskaOn ( ) -> substring ( $ this -> getName ( ) , $ start , $ end ) ; } 
public function getOrSetValue ( $ object = null , $ expire = null , $ expireIsTimestamp = false ) { return new Rediska_Key_GetOrSetValue ( $ this , $ object , $ expire , $ expireIsTimestamp ) ; } 
public function signupAction ( ) { $ form = new Form_User ; if ( $ this -> getRequest ( ) -> isPost ( ) && $ form -> isValid ( $ this -> getRequest ( ) -> getPost ( ) ) ) { $ userData = $ form -> getValues ( ) ; $ userData [ 'id' ] = User :: fetchNextId ( ) ; 
public function loginAction ( ) { $ form = new Form_UserLogin ; if ( $ this -> getRequest ( ) -> isPost ( ) && $ form -> isValid ( $ this -> getRequest ( ) -> getPost ( ) ) ) { $ auth = Zend_Auth :: getInstance ( ) ; $ options = array ( 'userIdKey' => 'userIdKey:*' , 'userDataKey' => 'users:*' , 'userDataIsArray' => true ) ; $ adapter = new Rediska_Zend_Auth_Adapter_Redis ( $ options ) ; 
public function followersAction ( ) { $ userId = $ this -> _getParam ( 'userId' ) ; $ user = new User ( $ userId ) ; $ this -> view -> user = $ user -> getValue ( ) ; $ followers = new Followers ( $ userId ) ; $ this -> view -> users = User :: getMultiple ( $ followers -> toArray ( ) ) ; $ this -> _setUsersIFollow ( ) ; } 
public function followingAction ( ) { $ userId = $ this -> _getParam ( 'userId' ) ; $ following = new Following ( $ userId ) ; $ this -> view -> users = User :: getMultiple ( $ following -> toArray ( ) ) ; $ this -> _setUsersIFollow ( ) ; } 
public function followAction ( ) { $ auth = Zend_Auth :: getInstance ( ) ; if ( ! $ auth -> hasIdentity ( ) ) { throw new Zend_Auth_Exception ( "You're not authorized to see this page" ) ; } $ userId = $ this -> _getParam ( 'userId' ) ; $ follower = $ auth -> getStorage ( ) -> read ( ) ; if ( $ userId != $ follower [ 'id' ] ) { $ followers = new Followers ( $ userId ) ; $ followers [ ] = $ follower [ 'id' ] ; $ following = new Following ( $ follower [ 'id' ] ) ; $ following [ ] = $ userId ; } $ this -> _redirect ( '/user/followers/userId/' . $ userId ) ; } 
public function create ( $ key , $ secondsOrTimestamp , $ isTimestamp = false ) { $ connection = $ this -> _rediska -> getConnectionByKeyName ( $ key ) ; if ( $ isTimestamp ) { $ this -> _throwExceptionIfNotSupported ( '1.1' ) ; $ command = 'EXPIREAT' ; } else { $ command = 'EXPIRE' ; } $ command = array ( $ command , $ this -> _rediska -> getOption ( 'namespace' ) . $ key , $ secondsOrTimestamp ) ; return new Rediska_Connection_Exec ( $ connection , $ command ) ; } 
public function rename ( $ newName , $ overwrite = true ) { try { $ this -> _getRediskaOn ( ) -> rename ( $ this -> getName ( ) , $ newName , $ overwrite ) ; } catch ( Rediska_Exception $ e ) { return false ; } $ this -> setName ( $ newName ) ; if ( ! is_null ( $ this -> getExpire ( ) ) ) { $ this -> expire ( $ this -> getExpire ( ) , $ this -> isExpireTimestamp ( ) ) ; } return true ; } 
public function expire ( $ secondsOrTimestamp , $ isTimestamp = false ) { return $ this -> _getRediskaOn ( ) -> expire ( $ this -> getName ( ) , $ secondsOrTimestamp , $ isTimestamp ) ; } 
public function moveToDb ( $ dbIndex ) { $ result = $ this -> _getRediskaOn ( ) -> moveToDb ( $ this -> getName ( ) , $ dbIndex ) ; if ( ! is_null ( $ this -> getExpire ( ) ) && $ result ) { $ this -> expire ( $ this -> getExpire ( ) , $ this -> isExpireTimestamp ( ) ) ; } return $ result ; } 
public function setExpire ( $ secondsOrTimestamp , $ isTimestamp = false ) { if ( $ secondsOrTimestamp !== null ) { trigger_error ( 'Expire option is deprecated, because expire behaviour was changed in Redis 2.2. Use expire method instead.' , E_USER_WARNING ) ; } $ this -> _options [ 'expire' ] = $ secondsOrTimestamp ; $ this -> _options [ 'expireIsTimestamp' ] = $ isTimestamp ; return $ this ; } 
protected function _getRediskaOn ( ) { $ rediska = $ this -> getRediska ( ) ; if ( ! is_null ( $ this -> getServerAlias ( ) ) ) { $ rediska = $ rediska -> on ( $ this -> getServerAlias ( ) ) ; } return $ rediska ; } 
public function setAdapter ( $ adapter ) { if ( is_object ( $ adapter ) ) { $ this -> _adapter = $ adapter ; } else if ( in_array ( $ adapter , array ( 'phpSerialize' , 'json' , 'toString' ) ) ) { $ adapter = ucfirst ( $ adapter ) ; $ className = "Rediska_Serializer_Adapter_$adapter" ; $ this -> _adapter = new $ className ; } else { if ( ! @ class_exists ( $ adapter ) ) { throw new Rediska_Serializer_Exception ( "Serializer adapter '$adapter' not found. You need include it before or setup autoload." ) ; } $ this -> _adapter = new $ adapter ; } if ( ! $ this -> _adapter instanceof Rediska_Serializer_Adapter_Interface ) { throw new Rediska_Serializer_Exception ( "'$adapter' must implement Rediska_Serializer_Adapter_Interface" ) ; } return $ this ; } 
public function serialize ( $ value ) { if ( is_numeric ( $ value ) || is_string ( $ value ) ) { return ( string ) $ value ; } else { return $ this -> _adapter -> serialize ( $ value ) ; } } 
public function unserialize ( $ value ) { if ( is_null ( $ value ) ) { return null ; } else if ( is_numeric ( $ value ) ) { if ( strpos ( $ value , '.' ) === false ) { $ unserializedValue = ( integer ) $ value ; } else { $ unserializedValue = ( float ) $ value ; } if ( ( string ) $ unserializedValue !== $ value ) { $ unserializedValue = $ value ; } } else { try { $ unserializedValue = $ this -> _adapter -> unserialize ( $ value ) ; } catch ( Rediska_Serializer_Adapter_Exception $ e ) { $ unserializedValue = $ value ; } } return $ unserializedValue ; } 
public function getStream ( ) { if ( ! is_resource ( $ this -> _stream ) ) { $ stream = $ this -> _stream ; if ( is_array ( $ stream ) && isset ( $ stream [ 'stream' ] ) ) { $ stream = $ stream [ 'stream' ] ; } if ( ! $ this -> _stream = @ fopen ( $ stream , $ this -> getMode ( ) , false ) ) { throw new Rediska_Profiler_Exception ( "'$stream' cannot be opened with mode '{$this->getMode()}'" ) ; } } return $ this -> _stream ; } 
public function setMode ( $ mode ) { if ( is_resource ( $ this -> _stream ) && $ this -> _mode != $ mode ) { $ meta = stream_get_meta_data ( $ this -> _stream ) ; $ this -> setStream ( $ meta [ 'uri' ] ) ; } $ this -> _mode = $ mode ; return $ this ; } 
public function stopCallback ( Rediska_Profiler_Profile $ profile ) { $ placeHolders = array ( '%timestamp%' => date ( 'Y-m-d H:i:s' ) , '%profile%' => $ profile -> getContext ( ) , '%elapsedTime%' => $ profile -> getElapsedTime ( 4 ) ) ; $ data = str_replace ( array_keys ( $ placeHolders ) , array_values ( $ placeHolders ) , $ this -> _format . Rediska :: EOL ) ; $ this -> _write ( $ data ) ; } 
public function reset ( ) { parent :: reset ( ) ; $ prevMode = $ this -> getMode ( ) ; $ this -> setMode ( 'w' ) ; $ this -> _write ( '' ) ; $ this -> setMode ( $ prevMode ) ; return $ this ; } 
public static function add ( $ rediska ) { if ( $ rediska instanceof Rediska ) { if ( ! self :: has ( $ rediska -> getName ( ) ) ) { foreach ( self :: $ _instances as $ name => $ instance ) { if ( $ instance === $ rediska && $ name != $ rediska -> getName ( ) ) { unset ( self :: $ _instances [ $ name ] ) ; break ; } } } $ name = $ rediska -> getName ( ) ; } else if ( is_array ( $ rediska ) ) { if ( isset ( $ rediska [ 'name' ] ) ) { $ name = $ rediska [ 'name' ] ; } else { $ name = Rediska :: DEFAULT_NAME ; } } else { throw new Rediska_Exception ( 'Rediska must be a instance or options' ) ; } if ( self :: has ( $ name ) ) { $ result = false ; } else { $ result = true ; } self :: $ _instances [ $ name ] = $ rediska ; return $ result ; } 
public static function get ( $ name = Rediska :: DEFAULT_NAME ) { if ( ! self :: has ( $ name ) ) { throw new Rediska_Exception ( "Rediska instance '$name' not present" ) ; } self :: _instanceFromOptions ( $ name ) ; return self :: $ _instances [ $ name ] ; } 
public static function getAll ( ) { foreach ( self :: $ _instances as $ name => $ instanceOrOptions ) { self :: _instanceFromOptions ( $ name ) ; } return self :: $ _instances ; } 
public static function remove ( $ rediska ) { if ( $ rediska instanceof Rediska ) { $ name = $ rediska -> getName ( ) ; } else if ( is_string ( $ rediska ) ) { $ name = $ rediska ; } else { throw new Rediska_Exception ( 'Rediska must be a instance or name' ) ; } if ( ! isset ( self :: $ _instances [ $ name ] ) ) { throw new Rediska_Exception ( "Rediska instance '$name' not present" ) ; } unset ( self :: $ _instances [ $ name ] ) ; return true ; } 
protected static function _instanceFromOptions ( $ name ) { if ( ! is_object ( self :: $ _instances [ $ name ] ) ) { $ options = self :: $ _instances [ $ name ] ; self :: $ _instances [ $ name ] = new Rediska ( $ options ) ; } } 
public function parseResponses ( $ responses ) { $ info = array ( ) ; $ count = 0 ; foreach ( $ this -> _connections as $ connection ) { $ info [ $ connection ] = array ( ) ; foreach ( explode ( Rediska :: EOL , $ responses [ $ count ] ) as $ param ) { if ( ! $ param || ! strpos ( $ param , ':' ) !== false ) { continue ; } list ( $ name , $ stringValue ) = explode ( ':' , $ param , 2 ) ; if ( strpos ( $ stringValue , '.' ) !== false ) { $ value = ( float ) $ stringValue ; } else { $ value = ( integer ) $ stringValue ; } if ( ( string ) $ value != $ stringValue ) { $ value = $ stringValue ; } $ info [ $ connection ] [ $ name ] = $ value ; } $ info [ $ connection ] = new Rediska_Info ( $ info [ $ connection ] ) ; $ count ++ ; } if ( count ( $ info ) == 1 ) { $ info = array_shift ( $ info ) ; } return $ info ; } 
public function increment ( $ subject ) { $ bucket = $ this -> _getBucketName ( ) ; $ transaction = $ this -> _getTransaction ( ) ; $ this -> _setMultiIncrementTransactionPart ( $ transaction , $ subject , $ bucket ) ; $ transaction -> execute ( ) ; } 
public function getRateByInterval ( $ subject , $ interval ) { $ bucket = $ this -> _getBucketName ( ) ; $ count = ( int ) floor ( $ interval / $ this -> bucketInterval ) ; $ transaction = $ this -> _getTransaction ( ) ; $ this -> _setMulitExecGetCountPart ( $ transaction , $ subject , $ bucket , $ count ) ; return array_sum ( $ transaction -> execute ( ) ) ; } 
public function incrementAndGetCountByInterval ( $ subject , $ interval ) { $ bucket = $ this -> _getBucketName ( ) ; $ count = ( int ) floor ( $ interval / $ this -> _bucketInterval ) ; $ transaction = $ this -> _getTransaction ( ) ; $ this -> _setMultiIncrementTransactionPart ( $ transaction , $ subject , $ bucket ) ; $ this -> _setMulitExecGetCountPart ( $ transaction , $ subject , $ bucket , $ count ) ; return array_sum ( array_slice ( $ transaction -> execute ( ) , 4 ) ) ; } 
public function reset ( $ subject ) { $ keyName = $ this -> _getKeyName ( $ subject ) ; return ( bool ) $ this -> _rediska -> delete ( $ keyName ) ; } 
protected function _getBucketName ( $ time = null ) { $ time = $ time ? : time ( ) ; return ( int ) floor ( ( $ time % $ this -> _bucketSpan ) / $ this -> _bucketInterval ) ; } 
protected function _setMultiIncrementTransactionPart ( Rediska_Transaction $ transaction , $ subject , $ bucket ) { $ keyName = $ this -> _getKeyName ( $ subject ) ; $ transaction -> incrementinhash ( $ keyName , $ bucket , 1 ) -> deletefromhash ( $ keyName , ( $ bucket + 1 ) % $ this -> _bucketCount ) -> deletefromhash ( $ keyName , ( $ bucket + 2 ) % $ this -> _bucketCount ) -> expire ( $ keyName , $ this -> _subjectExpire ) ; } 
protected function _setMulitExecGetCountPart ( Rediska_Transaction $ transaction , $ subject , $ bucket , $ count ) { $ keyName = $ this -> _getKeyName ( $ subject ) ; 
public function create ( $ key , $ amount = 1 ) { $ connection = $ this -> _rediska -> getConnectionByKeyName ( $ key ) ; if ( $ amount == 1 ) { $ command = array ( 'DECR' , $ this -> _rediska -> getOption ( 'namespace' ) . $ key ) ; } else { $ command = array ( 'DECRBY' , $ this -> _rediska -> getOption ( 'namespace' ) . $ key , $ amount ) ; } return new Rediska_Connection_Exec ( $ connection , $ command ) ; } 
public function create ( $ key , $ referenceValue , $ value ) { return $ this -> _create ( $ key , self :: BEFORE , $ referenceValue , $ value ) ; } 
public function create ( $ key , $ fieldOrData , $ value = null , $ overwrite = true ) { if ( is_array ( $ fieldOrData ) ) { $ data = $ fieldOrData ; if ( empty ( $ data ) ) { throw new Rediska_Command_Exception ( 'Not present fields and values for set' ) ; } $ command = array ( 'HMSET' , $ this -> _rediska -> getOption ( 'namespace' ) . $ key ) ; foreach ( $ data as $ field => $ value ) { $ command [ ] = $ field ; $ command [ ] = $ this -> _rediska -> getSerializer ( ) -> serialize ( $ value ) ; } } else { $ field = $ fieldOrData ; $ value = $ this -> _rediska -> getSerializer ( ) -> serialize ( $ value ) ; $ command = array ( $ overwrite ? 'HSET' : 'HSETNX' , $ this -> _rediska -> getOption ( 'namespace' ) . $ key , $ field , $ value ) ; } $ connection = $ this -> _rediska -> getConnectionByKeyName ( $ key ) ; return new Rediska_Connection_Exec ( $ connection , $ command ) ; } 
public function create ( $ key ) { $ connection = $ this -> _rediska -> getConnectionByKeyName ( $ key ) ; $ command = array ( 'HGETALL' , $ this -> _rediska -> getOption ( 'namespace' ) . $ key ) ; return new Rediska_Connection_Exec ( $ connection , $ command ) ; } 
public function parseResponse ( $ response ) { $ isField = true ; $ result = array ( ) ; foreach ( $ response as $ fieldOrValue ) { if ( $ isField ) { $ field = $ fieldOrValue ; } else { $ result [ $ field ] = $ this -> _rediska -> getSerializer ( ) -> unserialize ( $ fieldOrValue ) ; } $ isField = ! $ isField ; } return $ result ; } 
public function connect ( ) { if ( $ this -> isConnected ( ) ) { return false ; } $ this -> _socket = $ this -> _createSocketConnection ( ) ; 
public function disconnect ( ) { if ( ! $ this -> isConnected ( ) ) { return false ; } @ socket_close ( $ this -> _socket ) ; $ this -> _socket = null ; $ this -> _readBuffer = null ; return true ; } 
public function write ( $ string ) { if ( $ string == '' ) { return false ; } $ this -> connect ( ) ; $ string = ( string ) $ string . Rediska :: EOL ; $ offset = 0 ; $ length = strlen ( $ string ) ; while ( true ) { $ sent = @ socket_write ( $ this -> getSocket ( ) , substr ( $ string , $ offset , $ length ) , $ length ) ; if ( $ sent === false ) { $ errorCode = socket_last_error ( ) ; $ errorMessage = socket_strerror ( $ errorCode ) ; 
protected function _createSocketConnection ( ) { $ socket = socket_create ( AF_INET , SOCK_STREAM , getprotobyname ( 'tcp' ) ) ; socket_set_option ( $ socket , SOL_SOCKET , TCP_NODELAY , 1 ) ; @ socket_set_nonblock ( $ socket ) ; $ result = @ socket_connect ( $ socket , $ this -> getHost ( ) , $ this -> getPort ( ) ) ; if ( $ result === false ) { $ errorCode = socket_last_error ( $ socket ) ; if ( $ errorCode !== SOCKET_EINPROGRESS ) { return null ; } } else { 
protected function _getReadBuffer ( ) { if ( $ this -> _readBuffer === null ) { $ this -> _readBuffer = new Rediska_Connection_Socket_ReadBuffer ( $ this ) ; } return $ this -> _readBuffer ; } 
public function create ( $ aliasOrConnection ) { if ( $ aliasOrConnection === false ) { $ host = 'no' ; $ port = 'one' ; } else { if ( $ aliasOrConnection instanceof Rediska_Connection ) { $ connection = $ aliasOrConnection ; } else { $ alias = $ aliasOrConnection ; $ connection = $ this -> _rediska -> getConnectionByAlias ( $ alias ) ; } $ host = $ connection -> getHost ( ) ; $ port = $ connection -> getPort ( ) ; } $ command = array ( 'SLAVEOF' , $ host , $ port ) ; $ commands = array ( ) ; foreach ( $ this -> _rediska -> getConnections ( ) as $ connection ) { $ commands [ ] = new Rediska_Connection_Exec ( $ connection , $ command ) ; } return $ commands ; } 
public function connect ( ) { if ( ! $ this -> isConnected ( ) ) { $ socketAddress = 'tcp://' . $ this -> getHost ( ) . ':' . $ this -> getPort ( ) ; if ( $ this -> _options [ 'persistent' ] ) { $ flag = STREAM_CLIENT_PERSISTENT | STREAM_CLIENT_CONNECT ; } else { $ flag = STREAM_CLIENT_CONNECT ; } $ socketParams = array ( $ socketAddress , & $ errno , & $ errmsg , $ this -> getTimeout ( ) , $ flag ) ; $ streamContext = $ this -> getStreamContext ( ) ; if ( $ streamContext ) { $ socketParams [ ] = $ streamContext ; } $ this -> _socket = call_user_func_array ( 'stream_socket_client' , $ socketParams ) ; 
public function write ( $ string ) { if ( $ string !== '' ) { $ needToWrite = ( string ) $ string . Rediska :: EOL ; $ this -> connect ( ) ; while ( $ needToWrite ) { $ bytes = @ fwrite ( $ this -> _socket , $ needToWrite ) ; if ( $ bytes === false ) { $ this -> disconnect ( ) ; throw new Rediska_Connection_Exception ( "Can't write to socket." ) ; } if ( $ bytes == 0 ) { return true ; } $ needToWrite = substr ( $ needToWrite , $ bytes ) ; } return true ; } else { return false ; } } 
public function read ( $ length ) { if ( ! $ this -> isConnected ( ) ) { throw new Rediska_Connection_Exception ( "Can't read without connection to Redis server. Do connect or write first." ) ; } if ( $ length > 0 ) { $ data = $ this -> _readAndThrowException ( $ length ) ; } else { $ data = null ; } if ( $ length !== - 1 ) { $ this -> _readAndThrowException ( 2 ) ; } return $ data ; } 
public function readLine ( ) { if ( ! $ this -> isConnected ( ) ) { throw new Rediska_Connection_Exception ( "Can't read without connection to Redis server. Do connect or write first." ) ; } $ reply = @ fgets ( $ this -> _socket ) ; if ( $ reply === false || $ reply === '' ) { $ metaData = stream_get_meta_data ( $ this -> _socket ) ; if ( $ metaData [ 'timed_out' ] ) { throw new Rediska_Connection_TimeoutException ( "Connection read timed out." ) ; } if ( $ this -> _options [ 'blockingMode' ] && ! $ metaData [ 'eof' ] ) { $ this -> disconnect ( ) ; throw new Rediska_Connection_Exception ( "Can't read from socket." ) ; } $ reply = null ; } else { $ reply = trim ( $ reply ) ; } return $ reply ; } 
public function setReadTimeout ( $ timeout ) { $ this -> _options [ 'readTimeout' ] = $ timeout ; if ( $ this -> isConnected ( ) ) { $ seconds = floor ( $ this -> _options [ 'readTimeout' ] ) ; $ microseconds = ( $ this -> _options [ 'readTimeout' ] - $ seconds ) * 1000000 ; stream_set_timeout ( $ this -> _socket , $ seconds , $ microseconds ) ; } return $ this ; } 
public function setBlockingMode ( $ flag = true ) { $ this -> _options [ 'blockingMode' ] = $ flag ; if ( $ this -> isConnected ( ) ) { stream_set_blocking ( $ this -> _socket , $ this -> _options [ 'blockingMode' ] ) ; } return $ this ; } 
public function getStreamContext ( ) { if ( $ this -> _options [ 'streamContext' ] !== null ) { if ( is_resource ( $ this -> _options [ 'streamContext' ] ) ) { return $ this -> _options [ 'streamContext' ] ; } if ( is_array ( $ this -> _options [ 'streamContext' ] ) ) { return stream_context_create ( $ this -> _options [ 'streamContext' ] ) ; } } return null ; } 
protected function _readAndThrowException ( $ length ) { $ data = @ stream_get_contents ( $ this -> _socket , $ length ) ; $ info = stream_get_meta_data ( $ this -> _socket ) ; if ( $ info [ 'timed_out' ] ) { throw new Rediska_Connection_TimeoutException ( "Connection read timed out." ) ; } if ( $ data === false ) { $ this -> disconnect ( ) ; throw new Rediska_Connection_Exception ( "Can't read from socket." ) ; } return $ data ; } 
public function create ( $ key , $ start , $ end = - 1 ) { if ( $ this -> getName ( ) == 'substring' ) { trigger_error ( 'Substring is deprecated. Use getRange command instead' , E_USER_WARNING ) ; } $ redisVersion = $ this -> getRediska ( ) -> getOption ( 'redisVersion' ) ; $ isVersionLessThen2 = version_compare ( '2.0.4' , $ redisVersion ) >= 0 ; $ command = array ( $ isVersionLessThen2 ? 'SUBSTR' : 'GETRANGE' , $ this -> _rediska -> getOption ( 'namespace' ) . $ key , $ start , $ end ) ; $ connection = $ this -> _rediska -> getConnectionByKeyName ( $ key ) ; return new Rediska_Connection_Exec ( $ connection , $ command ) ; } 
public function create ( ) { $ command = array ( 'QUIT' ) ; $ this -> _affectedConnections = $ this -> _rediska -> getConnections ( ) ; $ commands = array ( ) ; foreach ( $ this -> _affectedConnections as $ connection ) { $ commands [ ] = new Rediska_Connection_Exec ( $ connection , $ command ) ; } return $ commands ; } 
public function create ( $ key , $ referenceValue , $ value ) { return $ this -> _create ( $ key , self :: AFTER , $ referenceValue , $ value ) ; } 
public function create ( $ keyOrKeys , $ timeout = 0 , $ pushToKey = null ) { 
public function parseResponse ( $ response ) { if ( $ this -> pushToKey !== null ) { if ( empty ( $ response ) ) { return null ; } if ( ! $ this -> isAtomic ( ) ) { $ command = array ( 'LPUSH' , $ this -> _rediska -> getOption ( 'namespace' ) . $ this -> pushToKey , $ response [ 1 ] ) ; $ exec = new Rediska_Connection_Exec ( $ this -> _storeConnection , $ command ) ; $ exec -> execute ( ) ; $ value = $ response [ 1 ] ; } else { $ value = $ response ; } return $ this -> _rediska -> getSerializer ( ) -> unserialize ( $ value ) ; } else { if ( ! is_array ( $ this -> keyOrKeys ) && ! empty ( $ response ) ) { $ result = $ this -> _rediska -> getSerializer ( ) -> unserialize ( $ response [ 1 ] ) ; } else { $ result = Rediska_Command_Response_ListNameAndValue :: factory ( $ this -> _rediska , $ response ) ; } return $ result ; } } 
public function reportMessage ( $ message ) { foreach ( $ this -> reporters as $ reporter ) { $ reporter -> reportMessage ( $ message ) ; } foreach ( $ this -> callbacks as $ callback ) { call_user_func ( $ callback , $ message ) ; } } 
public function validate ( NonceContextInterface $ context = null ) { $ context or $ context = new RequestGlobalsContext ( ) ; $ value = $ context -> offsetExists ( $ this -> action ) ? $ context [ $ this -> action ] : '' ; if ( ! $ value || ! is_string ( $ value ) ) { return false ; } $ lifeFilter = $ this -> lifeFilter ( ) ; add_filter ( 'nonce_life' , $ lifeFilter ) ; $ valid = wp_verify_nonce ( $ value , $ this -> hashedAction ( ) ) ; remove_filter ( 'nonce_life' , $ lifeFilter ) ; return ( bool ) $ valid ; } 
public function publish ( $ data , $ routingKey = '' , array $ headers = [ ] ) { $ this -> driver -> publish ( $ this -> exchangeName , new Message ( $ data , $ routingKey , $ headers ) ) ; return null ; } 
public function publish ( $ data , $ routingKey = '' , array $ headers = [ ] ) { $ response = null ; $ correlationId = uniqid ( '' , false ) ; $ replyTo = $ this -> driver -> declareSimpleQueue ( '' , Driver :: QUEUE_EXCLUSIVE ) ; $ this -> driver -> publish ( $ this -> exchangeName , new Message ( $ data , $ routingKey , $ headers , $ correlationId , $ replyTo ) ) ; $ this -> driver -> consume ( $ replyTo , function ( Message $ message ) use ( $ correlationId , & $ response ) { if ( $ message -> getCorrelationId ( ) == $ correlationId ) { $ response = $ message -> getBody ( ) ; return QueueHandler :: STOP_CONSUMING ; } return QueueHandler :: CONTINUE_CONSUMING ; } , $ this -> timeout ) ; return $ response ; } 
protected function execute ( InputInterface $ input , OutputInterface $ output ) { $ exchange = $ input -> getArgument ( 'exchange' ) ; $ queue = $ input -> getArgument ( 'queue' ) ; $ routingKey = ( $ input -> getOption ( 'routingKey' ) !== null ) ? $ input -> getOption ( 'routingKey' ) : '' ; $ this -> driver -> bindQueue ( $ input -> getArgument ( 'exchange' ) , $ input -> getArgument ( 'queue' ) , $ routingKey ) ; $ output -> writeln ( sprintf ( '<info>Bind exchange <comment>%s</comment> to queue <comment>%s</comment> [<comment>%s</comment>]</info>' , $ exchange , $ queue , $ routingKey ) ) ; } 
public function publish ( $ data , $ routingKey = '' , array $ headers = [ ] ) { $ returnValue = $ this -> publisher -> publish ( $ this -> serializer -> serialize ( $ data ) , $ routingKey , $ headers ) ; return $ this -> serializer -> deserialize ( $ returnValue ) ; } 
public function handle ( Message $ message ) { try { $ this -> handler -> handle ( $ message ) ; return self :: CONTINUE_CONSUMING ; } catch ( \ Exception $ e ) { $ this -> logger -> error ( $ e ) ; return self :: STOP_CONSUMING ; } } 
public function handle ( EventInterface $ event ) { if ( ! ( $ event instanceof DaemonStarted ) ) { throw ListenerException :: badEventGiven ( $ event ) ; } $ this -> metricService -> increment ( 'daemon.started' ) ; } 
public function declareSimpleQueue ( $ queueName = '' , $ type = self :: QUEUE_DURABLE ) { $ flag = AMQP_DURABLE ; if ( $ type === self :: QUEUE_EXCLUSIVE ) { $ flag = AMQP_EXCLUSIVE ; } $ queue = $ this -> getQueue ( $ queueName ) ; $ queue -> setFlags ( $ flag ) ; $ queue -> declareQueue ( ) ; return $ queue -> getName ( ) ; } 
public function declareExchange ( $ exchangeName = '' , $ type = self :: EXCHANGE_TYPE_FANOUT ) { $ exchange = $ this -> getExchange ( $ exchangeName ) ; $ exchange -> setType ( $ type ) ; $ exchange -> setFlags ( AMQP_DURABLE ) ; $ exchange -> declareExchange ( ) ; return $ exchange -> getName ( ) ; } 
public function bindQueue ( $ exchange , $ queueName , $ routingKey = '' ) { $ queue = $ this -> getQueue ( $ queueName ) ; $ queue -> bind ( $ exchange , $ routingKey ) ; } 
public function declareAndBindQueue ( $ exchange , $ queueName , $ routingKey = '' ) { $ this -> declareSimpleQueue ( $ queueName ) ; $ this -> bindQueue ( $ exchange , $ queueName , $ routingKey ) ; } 
public function publish ( $ exchangeName , Message $ message ) { $ exchange = $ this -> getExchange ( $ exchangeName ) ; $ exchange -> publish ( $ message -> getBody ( ) , $ message -> getRoutingKey ( ) , AMQP_NOPARAM , self :: getMessageProperties ( $ message ) ) ; } 
public function consume ( $ queueName , callable $ callback , $ timeout = 0 , $ autoAck = true ) { $ this -> connection -> setReadTimeout ( $ timeout ) ; $ this -> getChannel ( ) -> setPrefetchCount ( 1 ) ; $ queue = $ this -> getQueue ( $ queueName ) ; $ flags = $ autoAck ? AMQP_AUTOACK : AMQP_NOPARAM ; try { $ queue -> consume ( function ( \ AMQPEnvelope $ message ) use ( $ callback , $ queueName ) { $ burrowMessage = new Message ( $ message -> getBody ( ) , $ message -> getRoutingKey ( ) , $ message -> getHeaders ( ) , $ message -> getCorrelationId ( ) , $ message -> getReplyTo ( ) ) ; $ burrowMessage -> setDeliveryTag ( $ message -> getDeliveryTag ( ) ) ; $ burrowMessage -> setQueue ( $ queueName ) ; return $ callback ( $ burrowMessage ) ; } , $ flags ) ; } catch ( \ AMQPQueueException $ e ) { if ( $ e -> getMessage ( ) === 'Consumer timeout exceed' ) { throw TimeoutException :: build ( $ e , $ timeout ) ; } throw ConsumerException :: build ( $ e ) ; } } 
public function ack ( Message $ message ) { $ queue = $ this -> getQueue ( $ message -> getQueue ( ) ) ; $ queue -> ack ( $ message -> getDeliveryTag ( ) ) ; } 
public function nack ( Message $ message , $ requeue = true ) { $ queue = $ this -> getQueue ( $ message -> getQueue ( ) ) ; $ queue -> nack ( $ message -> getDeliveryTag ( ) , $ requeue ? AMQP_REQUEUE : AMQP_NOPARAM ) ; } 
private function getChannel ( ) { if ( null === $ this -> channel ) { $ this -> connection -> connect ( ) ; $ this -> channel = new \ AMQPChannel ( $ this -> connection ) ; } return $ this -> channel ; } 
private function getQueue ( $ queueName ) { $ queue = new \ AMQPQueue ( $ this -> getChannel ( ) ) ; if ( $ queueName ) { $ queue -> setName ( $ queueName ) ; } return $ queue ; } 
private function getExchange ( $ exchangeName ) { $ exchange = new \ AMQPExchange ( $ this -> getChannel ( ) ) ; if ( $ exchangeName ) { $ exchange -> setName ( $ exchangeName ) ; } return $ exchange ; } 
private static function getMessageProperties ( Message $ message ) { $ properties = [ self :: DELIVERY_MODE => 2 , self :: CONTENT_TYPE => 'text/plain' , self :: APPLICATION_HEADERS => $ message -> getHeaders ( ) ] ; if ( $ message -> getCorrelationId ( ) !== null ) { $ properties [ self :: CORRELATION_ID ] = $ message -> getCorrelationId ( ) ; } if ( $ message -> getReplyTo ( ) !== null ) { $ properties [ self :: REPLY_TO ] = $ message -> getReplyTo ( ) ; } return $ properties ; } 
public function start ( ) { $ this -> eventEmitter -> emit ( new DaemonStarted ( ) ) ; $ this -> logger -> info ( 'Starting daemon...' ) ; $ options = $ this -> handler -> options ( new ConsumeOptions ( ) ) ; $ this -> driver -> consume ( $ this -> queueName , function ( Message $ message ) { $ this -> eventEmitter -> emit ( new MessageReceived ( ) ) ; $ this -> monitor -> monitor ( $ this , $ message ) ; $ result = $ this -> handler -> handle ( $ message ) ; $ this -> eventEmitter -> emit ( new MessageConsumed ( ) ) ; pcntl_signal_dispatch ( ) ; return $ result ; } , $ options -> getTimeout ( ) , $ options -> isAutoAck ( ) ) ; $ this -> stop ( ) ; } 
public function stop ( ) { $ this -> logger -> info ( 'Closing daemon...' ) ; $ this -> driver -> close ( ) ; $ this -> eventEmitter -> emit ( new DaemonStopped ( ) ) ; } 
public function provideListeners ( ListenerAcceptorInterface $ listenerAcceptor ) { $ listenerAcceptor -> addListener ( DaemonStarted :: NAME , new SendMetricOnDaemonStarted ( $ this -> metricService ) ) ; $ listenerAcceptor -> addListener ( DaemonStopped :: NAME , new SendMetricOnDaemonStopped ( $ this -> metricService ) ) ; $ listenerAcceptor -> addListener ( MessageReceived :: NAME , new SendMetricOnMessageReceived ( $ this -> metricService ) ) ; $ sendMetricOnMessageConsumed = new SendMetricOnMessageConsumed ( $ this -> metricService ) ; $ listenerAcceptor -> addListener ( MessageReceived :: NAME , $ sendMetricOnMessageConsumed ) ; $ listenerAcceptor -> addListener ( MessageConsumed :: NAME , $ sendMetricOnMessageConsumed ) ; } 
protected function execute ( InputInterface $ input , OutputInterface $ output ) { $ name = $ input -> getArgument ( 'name' ) ; $ type = $ input -> getArgument ( 'type' ) ; Assertion :: choice ( $ type , [ Driver :: EXCHANGE_TYPE_DIRECT , Driver :: EXCHANGE_TYPE_TOPIC , Driver :: EXCHANGE_TYPE_FANOUT , Driver :: EXCHANGE_TYPE_HEADERS ] , 'The type of the exchange must be one of the four valid values.' ) ; $ this -> driver -> declareExchange ( $ name , $ type ) ; $ output -> writeln ( sprintf ( '<info>Declare exchange <comment>%s</comment> [<comment>%s</comment>]</info>' , $ name , $ type ) ) ; } 
public function deserialize ( $ message ) { if ( $ message === null ) { return null ; } Assertion :: string ( $ message , 'The message to deserialize must be a valid string' ) ; return json_decode ( $ message ) ; } 
public function handle ( Message $ message ) { try { $ result = $ this -> handler -> handle ( $ message ) ; $ this -> driver -> ack ( $ message ) ; return $ result ; } catch ( \ Exception $ e ) { $ this -> driver -> nack ( $ message , $ this -> requeueOnFailure ) ; throw $ e ; } } 
public static function build ( \ Exception $ e , $ timeout ) { return new self ( sprintf ( 'The connection timed out after %d sec while awaiting incoming data' , $ timeout ) , $ e -> getCode ( ) , $ e ) ; } 
public static function create ( $ type , $ options = [ ] , $ contextualTags = [ ] ) { $ collector = Factory :: create ( $ type , $ options ) ; switch ( $ type ) { case 'dogstatsd' : return new DogStatsDMetricService ( $ collector , $ contextualTags ) ; case 'statsd' : return new StatsDMetricService ( $ collector ) ; } throw new \ Exception ( sprintf ( 'MetricService for %s is not implemented' , $ type ) ) ; } 
protected function execute ( InputInterface $ input , OutputInterface $ output ) { $ configuration = $ this -> getConfiguration ( $ input ) ; $ this -> declareQueues ( $ configuration , $ output ) ; $ this -> bind ( $ configuration , $ output ) ; } 
protected function getConfiguration ( InputInterface $ input ) { $ file = $ input -> getArgument ( 'file' ) ; Assertion :: file ( $ file , 'You must provide a valid file name' ) ; $ configurationString = file_get_contents ( $ file ) ; Assertion :: isJsonString ( $ configurationString , 'The file must be a valid JSON' ) ; $ configuration = @ json_decode ( $ configurationString , true ) ; if ( json_last_error ( ) !== JSON_ERROR_NONE ) { throw new \ InvalidArgumentException ( 'Invalid json : ' . json_last_error_msg ( ) ) ; } self :: checkConfiguration ( $ configuration ) ; return $ configuration ; } 
private static function checkQueuesConfiguration ( array $ configuration ) { Assertion :: keyIsset ( $ configuration , 'queues' , 'You must provide a `queues` configuration' ) ; $ queues = $ configuration [ 'queues' ] ; Assertion :: isArray ( $ queues , 'The `queues` configuration must be an array' ) ; foreach ( $ queues as $ queueInformation ) { if ( is_string ( $ queueInformation ) ) { continue ; } Assertion :: keyIsset ( $ queueInformation , 'name' , 'You must provide a name for the queue' ) ; } } 
private static function checkExchangesConfiguration ( array $ configuration ) { Assertion :: keyIsset ( $ configuration , 'exchanges' , 'You must provide an `exchanges` configuration' ) ; $ exchanges = $ configuration [ 'exchanges' ] ; Assertion :: isArray ( $ exchanges , 'The `exchanges` configuration must be an array' ) ; foreach ( $ exchanges as $ exchangeInformation ) { self :: checkExchangeConfiguration ( $ exchangeInformation ) ; } } 
private static function checkExchangeConfiguration ( array $ exchangeInformation ) { Assertion :: keyIsset ( $ exchangeInformation , 'name' , 'You must provide a name for the exchange' ) ; Assertion :: keyIsset ( $ exchangeInformation , 'type' , 'You must provide a type for the exchange' ) ; self :: checkQueuesConfiguration ( $ exchangeInformation ) ; } 
public function handle ( EventInterface $ event ) { if ( $ event instanceof MessageReceived ) { $ this -> messageReceivedAt = $ this -> clock -> timestampInMs ( ) ; return ; } if ( ! ( $ event instanceof MessageConsumed ) ) { throw ListenerException :: badEventGiven ( $ event ) ; } $ this -> metricService -> increment ( 'daemon.message_consumed' ) ; $ this -> metricService -> timing ( 'daemon.message_processing_time' , $ this -> clock -> timestampInMs ( ) - $ this -> messageReceivedAt ) ; } 
public function handle ( Message $ message ) { 
public function build ( QueueConsumer $ consumer ) { Assertion :: notNull ( $ this -> sync , 'You must specify if the handler must be sync or async' ) ; 
public function handle ( Message $ message ) { $ returnValue = $ this -> consumer -> consume ( $ message -> getBody ( ) , $ message -> getHeaders ( ) ) ; $ this -> handleSyncMessage ( $ message , $ returnValue ) ; return self :: CONTINUE_CONSUMING ; } 
private function handleSyncMessage ( Message $ message , $ returnValue ) { self :: checkMessageIsSync ( $ message ) ; $ this -> logger -> debug ( 'Send return value back!' , [ 'returnValue' => $ returnValue , 'correlationId' => $ message -> getCorrelationId ( ) , 'replyTo' => $ message -> getReplyTo ( ) ] ) ; $ this -> driver -> publish ( '' , new Message ( $ returnValue , $ message -> getReplyTo ( ) , $ message -> getHeaders ( ) , $ message -> getCorrelationId ( ) ) ) ; } 
public function deserialize ( $ message ) { if ( $ message === null ) { return null ; } Assertion :: string ( $ message , 'The message to deserialize must be a valid string' ) ; return unserialize ( $ message ) ; } 
protected function execute ( InputInterface $ input , OutputInterface $ output ) { $ queue = $ input -> getArgument ( 'name' ) ; $ this -> driver -> declareSimpleQueue ( $ queue ) ; $ output -> writeln ( sprintf ( '<info>Declare queue <comment>%s</comment></info>' , $ queue ) ) ; } 
public static function getDriver ( $ connection ) { if ( is_array ( $ connection ) && isset ( $ connection [ 'host' ] , $ connection [ 'port' ] , $ connection [ 'user' ] , $ connection [ 'pwd' ] ) ) { $ connection = self :: getConnectionFromArray ( $ connection ) ; } if ( $ connection instanceof AbstractConnection ) { return new PhpAmqpLibDriver ( $ connection ) ; } if ( $ connection instanceof \ AMQPConnection ) { return new PeclAmqpDriver ( $ connection ) ; } throw new \ InvalidArgumentException ( 'You provided an unsupported connection' ) ; } 
protected static function getPeclConnection ( array $ connection ) { $ amqpConnection = new \ AMQPConnection ( ) ; $ amqpConnection -> setHost ( $ connection [ 'host' ] ) ; $ amqpConnection -> setPort ( $ connection [ 'port' ] ) ; $ amqpConnection -> setLogin ( $ connection [ 'user' ] ) ; $ amqpConnection -> setPassword ( $ connection [ 'pwd' ] ) ; return $ amqpConnection ; } 
protected function execute ( InputInterface $ input , OutputInterface $ output ) { $ name = $ input -> getArgument ( 'name' ) ; $ this -> driver -> deleteExchange ( $ name ) ; $ output -> writeln ( sprintf ( '<info>Delete exchange <comment>%s</comment></info>' , $ name ) ) ; } 
private function checkHeaders ( array $ headers ) { foreach ( $ headers as $ key => $ value ) { Assertion :: string ( $ key , 'Header key must be a string' ) ; Assertion :: notBlank ( $ key , 'Header key must be a non empty string' ) ; Assertion :: notNull ( $ value , 'Value cannot be null' ) ; if ( ! is_string ( $ value ) && ! is_numeric ( $ value ) && ! is_bool ( $ value ) ) { throw new \ InvalidArgumentException ( 'Value must be a string, a number or a boolean.' ) ; } } } 
public function declareSimpleQueue ( $ queueName = '' , $ type = self :: QUEUE_DURABLE ) { $ durable = ( $ type === self :: QUEUE_DURABLE ) ; $ exclusive = ( $ type === self :: QUEUE_EXCLUSIVE ) ; list ( $ name , , ) = $ this -> getChannel ( ) -> queue_declare ( $ queueName , false , $ durable , $ exclusive , false ) ; return $ name ; } 
public function declareExchange ( $ exchangeName = '' , $ type = self :: EXCHANGE_TYPE_FANOUT ) { list ( $ name , , ) = $ this -> getChannel ( ) -> exchange_declare ( $ exchangeName , $ type , false , true , false ) ; return $ name ; } 
public function bindQueue ( $ exchange , $ queueName , $ routingKey = '' ) { $ this -> getChannel ( ) -> queue_bind ( $ queueName , $ exchange , $ routingKey ) ; } 
public function publish ( $ exchangeName , Message $ message ) { $ this -> getChannel ( ) -> basic_publish ( new AMQPMessage ( $ message -> getBody ( ) , self :: getMessageProperties ( $ message ) ) , $ exchangeName , $ message -> getRoutingKey ( ) ) ; } 
public function consume ( $ queueName , callable $ callback , $ timeout = 0 , $ autoAck = true ) { $ this -> stop = false ; $ this -> getChannel ( ) -> basic_qos ( null , 1 , null ) ; $ this -> getChannel ( ) -> basic_consume ( $ queueName , '' , false , $ autoAck , false , false , function ( AMQPMessage $ message ) use ( $ callback , $ queueName ) { $ burrowMessage = new Message ( $ message -> getBody ( ) , '' , 
public function nack ( Message $ message , $ requeue = true ) { $ this -> getChannel ( ) -> basic_reject ( $ message -> getDeliveryTag ( ) , $ requeue ) ; } 
public function close ( ) { $ this -> stop = true ; $ this -> getChannel ( ) -> close ( ) ; $ this -> connection -> close ( ) ; } 
private function wait ( $ timeout ) { while ( count ( $ this -> getChannel ( ) -> callbacks ) && ! $ this -> stop ) { try { $ this -> getChannel ( ) -> wait ( null , false , $ timeout ) ; } catch ( AMQPTimeoutException $ e ) { throw TimeoutException :: build ( $ e , $ timeout ) ; } catch ( \ Exception $ e ) { if ( $ e instanceof AMQPExceptionInterface ) { throw ConsumerException :: build ( $ e ) ; } throw $ e ; } } } 
private static function getHeaders ( AMQPMessage $ message ) { return $ message -> has ( self :: APPLICATION_HEADERS ) ? $ message -> get ( self :: APPLICATION_HEADERS ) -> getNativeData ( ) : [ ] ; } 
private static function getCorrelationId ( AMQPMessage $ message ) { return $ message -> has ( self :: CORRELATION_ID ) ? $ message -> get ( self :: CORRELATION_ID ) : '' ; } 
private static function getReplyTo ( AMQPMessage $ message ) { return $ message -> has ( self :: REPLY_TO ) ? $ message -> get ( self :: REPLY_TO ) : '' ; } 
public function consume ( $ message , array $ headers = [ ] ) { return $ this -> serializer -> serialize ( $ this -> consumer -> consume ( $ this -> serializer -> deserialize ( $ message ) , $ headers ) ) ; } 
protected function buildClass ( $ name ) { $ stub = parent :: buildClass ( $ name ) ; return $ this -> replaceModelImport ( $ stub ) -> replaceModel ( $ stub ) ; } 
protected function replaceModel ( & $ stub ) { $ model = explode ( '\\' , $ this -> getModel ( ) ) ; $ model = array_pop ( $ model ) ; $ stub = str_replace ( 'ModelName' , $ model , $ stub ) ; return $ stub ; } 
protected function qualifyClass ( $ name ) { $ rootNamespace = $ this -> laravel -> getNamespace ( ) ; if ( Str :: startsWith ( $ name , $ rootNamespace ) ) { return $ name ; } if ( Str :: contains ( $ name , '/' ) ) { $ name = str_replace ( '/' , '\\' , $ name ) ; } if ( ! Str :: contains ( Str :: lower ( $ name ) , 'datatable' ) ) { $ name .= $ this -> type ; } return $ this -> getDefaultNamespace ( trim ( $ rootNamespace , '\\' ) ) . '\\' . $ name ; } 
public function process ( Request $ request ) { $ action = $ request -> get ( 'action' ) ; if ( ! in_array ( $ action , $ this -> actions ) ) { throw new DataTablesEditorException ( 'Requested action not supported!' ) ; } return $ this -> { $ action } ( $ request ) ; } 
public function create ( Request $ request ) { $ instance = $ this -> resolveModel ( ) ; $ connection = $ instance -> getConnection ( ) ; $ affected = [ ] ; $ errors = [ ] ; $ connection -> beginTransaction ( ) ; foreach ( $ request -> get ( 'data' ) as $ data ) { $ validator = $ this -> getValidationFactory ( ) -> make ( $ data , $ this -> createRules ( ) , $ this -> createMessages ( ) , $ this -> attributes ( ) ) ; if ( $ validator -> fails ( ) ) { foreach ( $ this -> formatErrors ( $ validator ) as $ error ) { $ errors [ ] = $ error ; } continue ; } if ( method_exists ( $ this , 'creating' ) ) { $ data = $ this -> creating ( $ instance , $ data ) ; } if ( method_exists ( $ this , 'saving' ) ) { $ data = $ this -> saving ( $ instance , $ data ) ; } $ model = $ instance -> newQuery ( ) -> create ( $ data ) ; $ model -> setAttribute ( 'DT_RowId' , $ model -> getKey ( ) ) ; if ( method_exists ( $ this , 'created' ) ) { $ this -> created ( $ model , $ data ) ; } if ( method_exists ( $ this , 'saved' ) ) { $ this -> saved ( $ model , $ data ) ; } $ affected [ ] = $ model ; } if ( ! $ errors ) { $ connection -> commit ( ) ; } else { $ connection -> rollBack ( ) ; } return $ this -> toJson ( $ affected , $ errors ) ; } 
protected function toJson ( array $ data , array $ errors = [ ] ) { $ response = [ 'data' => $ data ] ; if ( $ errors ) { $ response [ 'fieldErrors' ] = $ errors ; } return new JsonResponse ( $ response , 200 ) ; } 
public function edit ( Request $ request ) { $ instance = $ this -> resolveModel ( ) ; $ connection = $ instance -> getConnection ( ) ; $ affected = [ ] ; $ errors = [ ] ; $ connection -> beginTransaction ( ) ; foreach ( $ request -> get ( 'data' ) as $ key => $ data ) { $ model = $ instance -> newQuery ( ) -> find ( $ key ) ; $ validator = $ this -> getValidationFactory ( ) -> make ( $ data , $ this -> editRules ( $ model ) , $ this -> editMessages ( ) , $ this -> attributes ( ) ) ; if ( $ validator -> fails ( ) ) { foreach ( $ this -> formatErrors ( $ validator ) as $ error ) { $ errors [ ] = $ error ; } continue ; } if ( method_exists ( $ this , 'updating' ) ) { $ data = $ this -> updating ( $ model , $ data ) ; } if ( method_exists ( $ this , 'saving' ) ) { $ data = $ this -> saving ( $ model , $ data ) ; } $ model -> update ( $ data ) ; if ( method_exists ( $ this , 'updated' ) ) { $ this -> updated ( $ model , $ data ) ; } if ( method_exists ( $ this , 'saved' ) ) { $ this -> saved ( $ model , $ data ) ; } $ model -> setAttribute ( 'DT_RowId' , $ model -> getKey ( ) ) ; $ affected [ ] = $ model ; } if ( ! $ errors ) { $ connection -> commit ( ) ; } else { $ connection -> rollBack ( ) ; } return $ this -> toJson ( $ affected , $ errors ) ; } 
public function remove ( Request $ request ) { $ instance = $ this -> resolveModel ( ) ; $ connection = $ instance -> getConnection ( ) ; $ affected = [ ] ; $ errors = [ ] ; $ connection -> beginTransaction ( ) ; foreach ( $ request -> get ( 'data' ) as $ key => $ data ) { $ model = $ instance -> newQuery ( ) -> find ( $ key ) ; $ validator = $ this -> getValidationFactory ( ) -> make ( $ data , $ this -> removeRules ( $ model ) , $ this -> removeMessages ( ) , $ this -> attributes ( ) ) ; if ( $ validator -> fails ( ) ) { foreach ( $ this -> formatErrors ( $ validator ) as $ error ) { $ errors [ ] = $ error [ 'status' ] ; } continue ; } try { if ( method_exists ( $ this , 'deleting' ) ) { $ this -> deleting ( $ model , $ data ) ; } $ model -> delete ( ) ; if ( method_exists ( $ this , 'deleted' ) ) { $ this -> deleted ( $ model , $ data ) ; } } catch ( QueryException $ exception ) { $ error = config ( 'app.debug' ) ? $ exception -> errorInfo [ 2 ] : $ this -> removeExceptionMessage ( $ exception , $ model ) ; $ errors [ ] = $ error ; } $ affected [ ] = $ model ; } if ( ! $ errors ) { $ connection -> commit ( ) ; } else { $ connection -> rollBack ( ) ; } $ response = [ 'data' => $ affected ] ; if ( $ errors ) { $ response [ 'error' ] = implode ( "\n" , $ errors ) ; } return new JsonResponse ( $ response , 200 ) ; } 
protected function voteOnAttribute ( $ attribute , $ subject , TokenInterface $ token ) { return $ this -> isLoggedInUser ( $ token ) || ! $ this -> inList ( $ subject -> getName ( ) ) ; } 
public function explorerAction ( ) { $ response = $ this -> render ( '@GraphQLBundle/Feature/explorer.html.twig' , [ 'graphQLUrl' => $ this -> generateUrl ( 'youshido_graphql_graphql_default' ) , 'tokenHeader' => 'access-token' ] ) ; $ date = \ DateTime :: createFromFormat ( 'U' , strtotime ( 'tomorrow' ) , new \ DateTimeZone ( 'UTC' ) ) ; $ response -> setExpires ( $ date ) ; $ response -> setPublic ( ) ; return $ response ; } 
public function isSecurityEnabledFor ( $ attribute ) { if ( SecurityManagerInterface :: RESOLVE_FIELD_ATTRIBUTE == $ attribute ) { return $ this -> fieldSecurityEnabled ; } else if ( SecurityManagerInterface :: RESOLVE_ROOT_OPERATION_ATTRIBUTE == $ attribute ) { return $ this -> rootOperationSecurityEnabled ; } return false ; } 
public function load ( array $ configs , ContainerBuilder $ container ) { $ configuration = new Configuration ( ) ; $ this -> config = $ this -> processConfiguration ( $ configuration , $ configs ) ; $ preparedHeaders = [ ] ; $ headers = $ this -> config [ 'response' ] [ 'headers' ] ? $ this -> config [ 'response' ] [ 'headers' ] : $ this -> getDefaultHeaders ( ) ; foreach ( $ headers as $ header ) { $ preparedHeaders [ $ header [ 'name' ] ] = $ header [ 'value' ] ; } $ container -> setParameter ( 'graphql.response.headers' , $ preparedHeaders ) ; $ container -> setParameter ( 'graphql.schema_class' , $ this -> config [ 'schema_class' ] ) ; $ container -> setParameter ( 'graphql.schema_service' , $ this -> config [ 'schema_service' ] ) ; $ container -> setParameter ( 'graphql.logger' , $ this -> config [ 'logger' ] ) ; $ container -> setParameter ( 'graphql.max_complexity' , $ this -> config [ 'max_complexity' ] ) ; $ container -> setParameter ( 'graphql.response.json_pretty' , $ this -> config [ 'response' ] [ 'json_pretty' ] ) ; $ container -> setParameter ( 'graphql.security.guard_config' , [ 'field' => $ this -> config [ 'security' ] [ 'guard' ] [ 'field' ] , 'operation' => $ this -> config [ 'security' ] [ 'guard' ] [ 'operation' ] ] ) ; $ container -> setParameter ( 'graphql.security.black_list' , $ this -> config [ 'security' ] [ 'black_list' ] ) ; $ container -> setParameter ( 'graphql.security.white_list' , $ this -> config [ 'security' ] [ 'white_list' ] ) ; $ loader = new Loader \ XmlFileLoader ( $ container , new FileLocator ( __DIR__ . '/../Resources/config' ) ) ; $ loader -> load ( 'services.xml' ) ; } 
public function getConfigTreeBuilder ( ) { $ treeBuilder = new TreeBuilder ( ) ; $ rootNode = $ treeBuilder -> root ( 'graphql' ) ; $ rootNode -> children ( ) -> scalarNode ( 'schema_class' ) -> defaultValue ( null ) -> end ( ) -> scalarNode ( 'schema_service' ) -> defaultValue ( null ) -> end ( ) -> integerNode ( 'max_complexity' ) -> defaultValue ( null ) -> end ( ) -> scalarNode ( 'logger' ) -> defaultValue ( null ) -> end ( ) -> arrayNode ( 'security' ) -> addDefaultsIfNotSet ( ) -> canBeUnset ( ) -> children ( ) -> arrayNode ( 'guard' ) -> addDefaultsIfNotSet ( ) -> canBeUnset ( ) -> children ( ) -> booleanNode ( 'operation' ) -> defaultFalse ( ) -> end ( ) -> booleanNode ( 'field' ) -> defaultFalse ( ) -> end ( ) -> end ( ) -> end ( ) -> arrayNode ( 'white_list' ) -> canBeUnset ( ) -> defaultValue ( [ ] ) -> prototype ( 'scalar' ) -> end ( ) -> end ( ) -> arrayNode ( 'black_list' ) -> canBeUnset ( ) -> defaultValue ( [ ] ) -> prototype ( 'scalar' ) -> end ( ) -> end ( ) -> end ( ) -> end ( ) -> arrayNode ( 'response' ) -> addDefaultsIfNotSet ( ) -> canBeUnset ( ) -> children ( ) -> booleanNode ( 'json_pretty' ) -> defaultTrue ( ) -> end ( ) -> arrayNode ( 'headers' ) -> prototype ( 'array' ) -> children ( ) -> scalarNode ( 'name' ) -> end ( ) -> scalarNode ( 'value' ) -> defaultValue ( null ) -> end ( ) -> end ( ) -> end ( ) -> end ( ) -> end ( ) -> end ( ) -> end ( ) ; return $ treeBuilder ; } 
public function defaultAction ( ) { try { $ this -> initializeSchemaService ( ) ; } catch ( UnableToInitializeSchemaServiceException $ e ) { return new JsonResponse ( [ [ 'message' => 'Schema class ' . $ this -> getSchemaClass ( ) . ' does not exist' ] ] , 200 , $ this -> getResponseHeaders ( ) ) ; } if ( $ this -> get ( 'request_stack' ) -> getCurrentRequest ( ) -> getMethod ( ) == 'OPTIONS' ) { return $ this -> createEmptyResponse ( ) ; } list ( $ queries , $ isMultiQueryRequest ) = $ this -> getPayload ( ) ; $ queryResponses = array_map ( function ( $ queryData ) { return $ this -> executeQuery ( $ queryData [ 'query' ] , $ queryData [ 'variables' ] ) ; } , $ queries ) ; $ response = new JsonResponse ( $ isMultiQueryRequest ? $ queryResponses : $ queryResponses [ 0 ] , 200 , $ this -> getParameter ( 'graphql.response.headers' ) ) ; if ( $ this -> getParameter ( 'graphql.response.json_pretty' ) ) { $ response -> setEncodingOptions ( $ response -> getEncodingOptions ( ) | JSON_PRETTY_PRINT ) ; } return $ response ; } 
private function getPayload ( ) { $ request = $ this -> get ( 'request_stack' ) -> getCurrentRequest ( ) ; $ query = $ request -> get ( 'query' , null ) ; $ variables = $ request -> get ( 'variables' , [ ] ) ; $ isMultiQueryRequest = false ; $ queries = [ ] ; $ variables = is_string ( $ variables ) ? json_decode ( $ variables , true ) ? : [ ] : [ ] ; $ content = $ request -> getContent ( ) ; if ( ! empty ( $ content ) ) { if ( $ request -> headers -> has ( 'Content-Type' ) && 'application/graphql' == $ request -> headers -> get ( 'Content-Type' ) ) { $ queries [ ] = [ 'query' => $ content , 'variables' => [ ] , ] ; } else { $ params = json_decode ( $ content , true ) ; if ( $ params ) { 
private function makeSchemaService ( ) { if ( $ this -> container -> has ( $ this -> getSchemaService ( ) ) ) { return $ this -> container -> get ( $ this -> getSchemaService ( ) ) ; } $ schemaClass = $ this -> getSchemaClass ( ) ; if ( ! $ schemaClass || ! class_exists ( $ schemaClass ) ) { throw new UnableToInitializeSchemaServiceException ( ) ; } if ( $ this -> container -> has ( $ schemaClass ) ) { return $ this -> container -> get ( $ schemaClass ) ; } $ schema = new $ schemaClass ( ) ; if ( $ schema instanceof ContainerAwareInterface ) { $ schema -> setContainer ( $ this -> container ) ; } return $ schema ; } 
protected function execute ( InputInterface $ input , OutputInterface $ output ) { $ isComposerCall = $ input -> getOption ( 'composer' ) ; $ container = $ this -> getContainer ( ) ; $ rootDir = $ container -> getParameter ( 'kernel.root_dir' ) ; $ configFile = $ rootDir . DIRECTORY_SEPARATOR . '..' . DIRECTORY_SEPARATOR . 'config/packages/graphql.yml' ; $ className = 'Schema' ; $ schemaNamespace = self :: PROJECT_NAMESPACE . '\\GraphQL' ; $ graphqlPath = rtrim ( $ rootDir , DIRECTORY_SEPARATOR ) . DIRECTORY_SEPARATOR . 'GraphQL' ; $ classPath = $ graphqlPath . DIRECTORY_SEPARATOR . $ className . '.php' ; $ inputHelper = $ this -> getHelper ( 'question' ) ; if ( file_exists ( $ classPath ) ) { if ( ! $ isComposerCall ) { $ output -> writeln ( sprintf ( 'Schema class %s was found.' , $ schemaNamespace . '\\' . $ className ) ) ; } } else { $ question = new ConfirmationQuestion ( sprintf ( 'Confirm creating class at %s ? [Y/n]' , $ schemaNamespace . '\\' . $ className ) , true ) ; if ( ! $ inputHelper -> ask ( $ input , $ output , $ question ) ) { return ; } if ( ! is_dir ( $ graphqlPath ) ) { mkdir ( $ graphqlPath , 0777 , true ) ; } file_put_contents ( $ classPath , $ this -> getSchemaClassTemplate ( $ schemaNamespace , $ className ) ) ; $ output -> writeln ( 'Schema file has been created at' ) ; $ output -> writeln ( $ classPath . "\n" ) ; if ( ! file_exists ( $ configFile ) ) { $ question = new ConfirmationQuestion ( sprintf ( 'Config file not found (look at %s). Create it? [Y/n]' , $ configFile ) , true ) ; if ( ! $ inputHelper -> ask ( $ input , $ output , $ question ) ) { return ; } touch ( $ configFile ) ; } $ originalConfigData = file_get_contents ( $ configFile ) ; if ( strpos ( $ originalConfigData , 'graphql' ) === false ) { $ projectNameSpace = self :: PROJECT_NAMESPACE ; $ configData = <<<CONFIG graphql: schema_class: "{$projectNameSpace}\\\\GraphQL\\\\{$className}" CONFIG ; file_put_contents ( $ configFile , $ configData . $ originalConfigData ) ; } } if ( ! $ this -> graphQLRouteExists ( ) ) { $ question = new ConfirmationQuestion ( 'Confirm adding GraphQL route? [Y/n]' , true ) ; $ resource = $ this -> getMainRouteConfig ( ) ; if ( $ resource && $ inputHelper -> ask ( $ input , $ output , $ question ) ) { $ routeConfigData = <<<CONFIG graphql: resource: "@GraphQLBundle/Controller/" CONFIG ; file_put_contents ( $ resource , $ routeConfigData , FILE_APPEND ) ; $ output -> writeln ( 'Config was added to ' . $ resource ) ; } } else { if ( ! $ isComposerCall ) { $ output -> writeln ( 'GraphQL default route was found.' ) ; } } } 
protected function getMainRouteConfig ( ) { $ routerResources = $ this -> getContainer ( ) -> get ( 'router' ) -> getRouteCollection ( ) -> getResources ( ) ; foreach ( $ routerResources as $ resource ) { if ( method_exists ( $ resource , 'getResource' ) && substr ( $ resource -> getResource ( ) , - 11 ) == 'routes.yaml' ) { return $ resource -> getResource ( ) ; } } return null ; } 
public function process ( ContainerBuilder $ container ) { if ( $ loggerAlias = $ container -> getParameter ( 'graphql.logger' ) ) { if ( strpos ( $ loggerAlias , '@' ) === 0 ) { $ loggerAlias = substr ( $ loggerAlias , 1 ) ; } if ( ! $ container -> has ( $ loggerAlias ) ) { throw new \ RuntimeException ( sprintf ( 'Logger "%s" not found' , $ loggerAlias ) ) ; } $ container -> getDefinition ( 'graphql.processor' ) -> addMethodCall ( 'setLogger' , [ new Reference ( $ loggerAlias ) ] ) ; } if ( $ maxComplexity = $ container -> getParameter ( 'graphql.max_complexity' ) ) { $ container -> getDefinition ( 'graphql.processor' ) -> addMethodCall ( 'setMaxComplexity' , [ $ maxComplexity ] ) ; } $ this -> processSecurityGuard ( $ container ) ; } 
private function processSecurityGuard ( ContainerBuilder $ container ) { $ guardConfig = $ container -> getParameter ( 'graphql.security.guard_config' ) ; $ whiteList = $ container -> getParameter ( 'graphql.security.white_list' ) ; $ blackList = $ container -> getParameter ( 'graphql.security.black_list' ) ; if ( ( ! $ guardConfig [ 'field' ] && ! $ guardConfig [ 'operation' ] ) && ( $ whiteList || $ blackList ) ) { if ( $ whiteList && $ blackList ) { throw new \ RuntimeException ( 'Configuration error: Only one white or black list allowed' ) ; } $ this -> addListVoter ( $ container , BlacklistVoter :: class , $ blackList ) ; $ this -> addListVoter ( $ container , WhitelistVoter :: class , $ whiteList ) ; } } 
private function addListVoter ( ContainerBuilder $ container , $ voterClass , array $ list ) { if ( $ list ) { $ container -> getDefinition ( 'graphql.security.voter' ) -> setClass ( $ voterClass ) -> addMethodCall ( 'setEnabled' , [ true ] ) -> addMethodCall ( 'setList' , [ $ list ] ) ; $ container -> setParameter ( 'graphql.security.guard_config' , [ 'operation' => true , 'field' => false , ] ) ; } } 
public function getHashSign ( $ xml ) { $ doc = new \ DOMDocument ( ) ; @ $ doc -> loadXML ( $ xml ) ; return $ this -> getHashSignFromDoc ( $ doc ) ; } 
public function getHashSignFromFile ( $ filename ) { $ doc = new \ DOMDocument ( ) ; @ $ doc -> load ( $ filename ) ; return $ this -> getHashSignFromDoc ( $ doc ) ; } 
public function getHashSignFromDoc ( \ DOMDocument $ document ) { $ xpt = $ this -> getXpath ( $ document ) ; $ exts = $ xpt -> query ( 'ext:UBLExtensions/ext:UBLExtension' , $ document -> documentElement ) ; if ( $ exts -> length == 0 ) { return '' ; } return $ this -> getHash ( $ exts , $ xpt ) ; } 
private function getXpath ( \ DOMDocument $ document ) { $ xpt = new \ DOMXPath ( $ document ) ; $ xpt -> registerNamespace ( 'ext' , self :: EXT_NAMESPACE ) ; $ xpt -> registerNamespace ( 'ds' , self :: DS_NAMESPACE ) ; return $ xpt ; } 
public function getImage ( $ sale ) { $ client = $ sale -> getClient ( ) ; $ params = [ $ sale -> getCompany ( ) -> getRuc ( ) , $ sale -> getTipoDoc ( ) , $ sale -> getSerie ( ) , $ sale -> getCorrelativo ( ) , number_format ( $ sale -> getMtoIGV ( ) , 2 , '.' , '' ) , number_format ( $ sale -> getMtoImpVenta ( ) , 2 , '.' , '' ) , $ sale -> getFechaEmision ( ) -> format ( 'Y-m-d' ) , $ client -> getTipoDoc ( ) , $ client -> getNumDoc ( ) , ] ; $ content = implode ( '|' , $ params ) . '|' ; return $ this -> getQrImage ( $ content ) ; } 
public function getTemplate ( $ document ) { $ className = get_class ( $ document ) ; switch ( $ className ) { case \ Greenter \ Model \ Sale \ Invoice :: class : case \ Greenter \ Model \ Sale \ Note :: class : $ name = 'invoice' ; break ; case \ Greenter \ Model \ Retention \ Retention :: class : $ name = 'retention' ; break ; case \ Greenter \ Model \ Perception \ Perception :: class : $ name = 'perception' ; break ; case \ Greenter \ Model \ Despatch \ Despatch :: class : $ name = 'despatch' ; break ; case \ Greenter \ Model \ Summary \ Summary :: class : $ name = 'summary' ; break ; case \ Greenter \ Model \ Voided \ Voided :: class : case \ Greenter \ Model \ Voided \ Reversion :: class : $ name = 'voided' ; break ; default : throw new \ Exception ( 'Not found template for ' . $ className ) ; } return $ name . '.html.twig' ; } 
public function getValueLegend ( $ legends , $ code ) { foreach ( $ legends as $ legend ) { if ( $ legend -> getCode ( ) == $ code ) { return $ legend -> getValue ( ) ; } } return '' ; } 
public function render ( DocumentInterface $ document , $ parameters = [ ] ) { $ html = $ this -> twig -> render ( $ this -> template , [ 'doc' => $ document , 'params' => $ parameters , ] ) ; return $ html ; } 
private function buildTwig ( $ directory , $ options ) { $ dirs = $ this -> getDirectories ( $ directory ) ; $ loader = new \ Twig_Loader_Filesystem ( $ dirs ) ; $ twig = new \ Twig_Environment ( $ loader , $ options ) ; $ twig -> addRuntimeLoader ( new RuntimeLoader ( ) ) ; $ twig -> addExtension ( new ReportTwigExtension ( ) ) ; return $ twig ; } 
public function get ( $ length = null ) { if ( $ length === null ) { $ length = $ this -> limit - $ this -> position ; } elseif ( $ length > $ this -> remaining ( ) ) { throw new BufferUnderFlowException ( ) ; } $ data = substr ( $ this -> byteArray , $ this -> position , $ length ) ; $ this -> position += $ length ; return $ data ; } 
public function getString ( ) { $ zeroByteIndex = strpos ( $ this -> byteArray , "\0" , $ this -> position ) ; if ( $ zeroByteIndex === false ) { return '' ; } else { $ dataString = $ this -> get ( $ zeroByteIndex - $ this -> position ) ; $ this -> position ++ ; return $ dataString ; } } 
public function limit ( $ newLimit = null ) { if ( $ newLimit == null ) { return $ this -> limit ; } else { $ this -> limit = $ newLimit ; return null ; } } 
public function put ( $ sourceByteArray ) { $ newPosition = min ( $ this -> remaining ( ) , strlen ( $ sourceByteArray ) ) ; $ this -> byteArray = substr_replace ( $ this -> byteArray , $ sourceByteArray , $ this -> position , $ newPosition ) ; $ this -> position = $ newPosition ; return $ this ; } 
public static function getPacketFromData ( $ rawData ) { $ header = ord ( $ rawData [ 0 ] ) ; $ data = substr ( $ rawData , 1 ) ; switch ( $ header ) { case SteamPacket :: S2A_INFO_DETAILED_HEADER : return new S2AINFODETAILEDPacket ( $ data ) ; case SteamPacket :: S2A_INFO2_HEADER : return new S2AINFO2Packet ( $ data ) ; case SteamPacket :: S2A_PLAYER_HEADER : return new S2APLAYERPacket ( $ data ) ; case SteamPacket :: S2A_RULES_HEADER : return new S2ARULESPacket ( $ data ) ; case SteamPacket :: S2C_CHALLENGE_HEADER : return new S2CCHALLENGEPacket ( $ data ) ; case SteamPacket :: M2A_SERVER_BATCH_HEADER : return new M2ASERVERBATCHPacket ( $ data ) ; case SteamPacket :: RCON_GOLDSRC_CHALLENGE_HEADER : case SteamPacket :: RCON_GOLDSRC_NO_CHALLENGE_HEADER : case SteamPacket :: RCON_GOLDSRC_RESPONSE_HEADER : return new RCONGoldSrcResponse ( $ data ) ; default : throw new PacketFormatException ( 'Unknown packet with header 0x' . dechex ( $ header ) . ' received.' ) ; } } 
public static function reassemblePacket ( $ splitPackets , $ isCompressed = false , $ packetChecksum = 0 ) { $ packetData = join ( '' , $ splitPackets ) ; if ( $ isCompressed ) { $ packetData = bzdecompress ( $ packetData ) ; if ( crc32 ( $ packetData ) != $ packetChecksum ) { throw new PacketFormatException ( 'CRC32 checksum mismatch of uncompressed packet data.' ) ; } } $ packetData = substr ( $ packetData , 4 ) ; return self :: getPacketFromData ( $ packetData ) ; } 
public static function getGlobalPercentages ( $ appId ) { $ params = [ 'gameid' => $ appId ] ; $ data = WebApi :: getJSONObject ( 'ISteamUserStats' , 'GetGlobalAchievementPercentagesForApp' , 2 , $ params ) ; $ percentages = [ ] ; foreach ( $ data -> achievementpercentages -> achievements as $ achievementData ) { $ percentages [ $ achievementData -> name ] = ( float ) $ achievementData -> percent ; } return $ percentages ; } 
public function close ( ) { if ( ! empty ( $ this -> socket ) && $ this -> socket -> isOpen ( ) ) { $ this -> socket -> close ( ) ; } } 
public function receivePacket ( $ bufferLength = 0 ) { if ( ! $ this -> socket -> select ( self :: $ timeout ) ) { throw new TimeoutException ( ) ; } if ( $ bufferLength == 0 ) { $ this -> buffer -> clear ( ) ; } else { $ this -> buffer = ByteBuffer :: allocate ( $ bufferLength ) ; } try { $ data = $ this -> socket -> recv ( $ this -> buffer -> remaining ( ) ) ; $ this -> buffer -> put ( $ data ) ; } catch ( ConnectionResetException $ e ) { $ this -> socket -> close ( ) ; throw $ e ; } $ bytesRead = $ this -> buffer -> position ( ) ; $ this -> buffer -> rewind ( ) ; $ this -> buffer -> limit ( $ bytesRead ) ; return $ bytesRead ; } 
public function send ( SteamPacket $ dataPacket ) { $ this -> logger -> debug ( "Sending packet of type \"" . get_class ( $ dataPacket ) . "\"..." ) ; $ this -> socket -> send ( $ dataPacket -> __toString ( ) ) ; } 
public function getReply ( ) { $ this -> receivePacket ( 1400 ) ; $ isCompressed = false ; if ( $ this -> buffer -> getLong ( ) == - 2 ) { do { $ requestId = $ this -> buffer -> getLong ( ) ; $ isCompressed = ( ( $ requestId & 0x80000000 ) != 0 ) ; $ packetCount = $ this -> buffer -> getByte ( ) ; $ packetNumber = $ this -> buffer -> getByte ( ) + 1 ; if ( $ isCompressed ) { $ splitSize = $ this -> buffer -> getLong ( ) ; $ packetChecksum = $ this -> buffer -> getUnsignedLong ( ) ; } else { $ splitSize = $ this -> buffer -> getShort ( ) ; } $ splitPackets [ $ packetNumber ] = $ this -> buffer -> get ( ) ; $ this -> logger -> debug ( "Received packet $packetNumber of $packetCount for request #$requestId" ) ; if ( sizeof ( $ splitPackets ) < $ packetCount ) { try { $ bytesRead = $ this -> receivePacket ( ) ; } catch ( TimeoutException $ e ) { $ bytesRead = 0 ; } } else { $ bytesRead = 0 ; } } while ( $ bytesRead > 0 && $ this -> buffer -> getLong ( ) == - 2 ) ; if ( $ isCompressed ) { $ packet = SteamPacketFactory :: reassemblePacket ( $ splitPackets , true , $ packetChecksum ) ; } else { $ packet = SteamPacketFactory :: reassemblePacket ( $ splitPackets ) ; } } else { $ packet = SteamPacketFactory :: getPacketFromData ( $ this -> buffer -> get ( ) ) ; } if ( $ isCompressed ) { $ this -> logger -> debug ( "Received compressed reply of type \"" . get_class ( $ packet ) . "\"" ) ; } else { $ this -> logger -> debug ( "Received reply of type \"" . get_class ( $ packet ) . "\"" ) ; } return $ packet ; } 
public function getReply ( ) { $ this -> receivePacket ( 1500 ) ; if ( $ this -> buffer -> getLong ( ) != - 1 ) { throw new PacketFormatException ( "Master query response has wrong packet header." ) ; } $ packet = SteamPacketFactory :: getPacketFromData ( $ this -> buffer -> get ( ) ) ; $ this -> logger -> debug ( "Received reply of type \"" . get_class ( $ packet ) . "\"" ) ; return $ packet ; } 
public static function createInventory ( $ steamId , $ fetchNow = true , $ bypassCache = false ) { return parent :: create ( self :: APP_ID , $ steamId , $ fetchNow , $ bypassCache ) ; } 
public function getReply ( ) { $ bytesRead = $ this -> receivePacket ( 1400 ) ; if ( $ this -> buffer -> getLong ( ) == - 2 ) { do { $ requestId = $ this -> buffer -> getLong ( ) ; $ packetCountAndNumber = $ this -> buffer -> getByte ( ) ; $ packetCount = $ packetCountAndNumber & 0xF ; $ packetNumber = ( $ packetCountAndNumber >> 4 ) + 1 ; $ splitPackets [ $ packetNumber - 1 ] = $ this -> buffer -> get ( ) ; $ this -> logger -> debug ( "Received packet $packetNumber of $packetCount for request #$requestId" ) ; if ( sizeof ( $ splitPackets ) < $ packetCount ) { try { $ bytesRead = $ this -> receivePacket ( ) ; } catch ( \ SteamCondenser \ Exceptions \ TimeoutException $ e ) { $ bytesRead = 0 ; } } else { $ bytesRead = 0 ; } } while ( $ bytesRead > 0 && $ this -> buffer -> getLong ( ) == - 2 ) ; $ packet = SteamPacketFactory :: reassemblePacket ( $ splitPackets ) ; } else { $ packet = SteamPacketFactory :: getPacketFromData ( $ this -> buffer -> get ( ) ) ; } $ this -> logger -> debug ( "Received packet of type \"" . get_class ( $ packet ) . "\"" ) ; return $ packet ; } 
public function rconExec ( $ password , $ command ) { if ( $ this -> rconChallenge == - 1 || $ this -> isHLTV ) { $ this -> rconGetChallenge ( ) ; } $ this -> rconSend ( "rcon {$this->rconChallenge} $password $command" ) ; if ( $ this -> isHLTV ) { try { $ response = $ this -> getReply ( ) -> getResponse ( ) ; } catch ( \ SteamCondenser \ Exceptions \ TimeoutException $ e ) { $ response = '' ; } } else { $ response = $ this -> getReply ( ) -> getResponse ( ) ; } if ( trim ( $ response ) == 'Bad rcon_password.' ) { throw new \ SteamCondenser \ Exceptions \ RCONNoAuthException ( ) ; } elseif ( trim ( $ response ) == 'You have been banned from this server.' ) { throw new \ SteamCondenser \ Exceptions \ RCONBanException ( ) ; } $ this -> rconSend ( "rcon {$this->rconChallenge} $password" ) ; do { $ responsePart = $ this -> getReply ( ) -> getResponse ( ) ; $ response .= $ responsePart ; } while ( strlen ( $ responsePart ) > 0 ) ; return $ response ; } 
public function rconGetChallenge ( ) { $ this -> rconSend ( 'challenge rcon' ) ; $ response = trim ( $ this -> getReply ( ) -> getResponse ( ) ) ; if ( $ response == 'You have been banned from this server.' ) { throw new RCONBanException ( ) ; } $ this -> rconChallenge = floatval ( substr ( $ response , 14 ) ) ; } 
public function rconSend ( $ command ) { $ this -> send ( new \ SteamCondenser \ Servers \ Packets \ RCON \ RCONGoldSrcRequest ( $ command ) ) ; } 
public function connect ( $ ipAddress , $ portNumber , $ timeout ) { $ this -> ipAddress = $ ipAddress ; $ this -> portNumber = $ portNumber ; if ( $ this -> socketsEnabled ) { if ( ! $ this -> socket = socket_create ( AF_INET , SOCK_STREAM , SOL_TCP ) ) { throw new SocketException ( socket_last_error ( $ this -> socket ) ) ; } socket_set_nonblock ( $ this -> socket ) ; socket_connect ( $ this -> socket , $ ipAddress , $ portNumber ) ; $ write = [ $ this -> socket ] ; $ read = $ except = null ; $ sec = floor ( $ timeout / 1000 ) ; $ usec = $ timeout % 1000 ; if ( ! socket_select ( $ read , $ write , $ except , $ sec , $ usec ) ) { $ errorCode = socket_last_error ( $ this -> socket ) ; } else { $ errorCode = socket_get_option ( $ this -> socket , SOL_SOCKET , SO_ERROR ) ; } if ( $ errorCode ) { throw new SocketException ( $ errorCode ) ; } socket_set_block ( $ this -> socket ) ; } else { if ( ! $ this -> socket = fsockopen ( "tcp://$ipAddress" , $ portNumber , $ socketErrno , $ socketErrstr , $ timeout / 1000 ) ) { throw new SocketException ( $ socketErrstr ) ; } stream_set_blocking ( $ this -> socket , true ) ; } } 
public function getServers ( $ regionCode = MasterServer :: REGION_ALL , $ filter = '' , $ force = false ) { $ failCount = 0 ; $ finished = false ; $ portNumber = 0 ; $ hostName = '0.0.0.0' ; $ serverArray = [ ] ; while ( true ) { $ failCount = 0 ; try { do { $ this -> socket -> send ( new A2MGETSERVERSBATCH2Packet ( $ regionCode , "$hostName:$portNumber" , $ filter ) ) ; try { $ serverStringArray = $ this -> socket -> getReply ( ) -> getServers ( ) ; foreach ( $ serverStringArray as $ serverString ) { $ serverString = explode ( ':' , $ serverString ) ; $ hostName = $ serverString [ 0 ] ; $ portNumber = $ serverString [ 1 ] ; if ( $ hostName != '0.0.0.0' && $ portNumber != 0 ) { $ serverArray [ ] = [ $ hostName , $ portNumber ] ; } else { $ finished = true ; } } $ failCount = 0 ; } catch ( TimeoutException $ e ) { $ failCount ++ ; if ( $ failCount == self :: $ retries ) { throw $ e ; } $ this -> logger -> info ( "Request to master server {$this->ipAddress} timed out, retrying..." ) ; } } while ( ! $ finished ) ; break ; } catch ( TimeoutException $ e ) { if ( $ this -> rotateIp ( ) ) { if ( $ force ) { break ; } throw $ e ; } $ this -> logger -> info ( "Request to master server failed, retrying {$this->ipAddress}..." ) ; } } return array_unique ( $ serverArray , SORT_REGULAR ) ; } 
public function internalFetch ( ) { $ params = [ 'language' => $ this -> language ] ; $ data = WebApi :: getJSONData ( "IEconItems_{$this->appId}" , 'GetSchema' , 1 , $ params ) ; $ this -> attributes = [ ] ; foreach ( $ data -> attributes as $ attribute ) { $ this -> attributes [ $ attribute -> defindex ] = $ attribute ; $ this -> attributes [ $ attribute -> name ] = $ attribute ; } $ this -> effects = [ ] ; foreach ( $ data -> attribute_controlled_attached_particles as $ effect ) { $ this -> effects [ $ effect -> id ] = $ effect ; } $ this -> items = [ ] ; $ this -> itemNames = [ ] ; foreach ( $ data -> items as $ item ) { $ this -> items [ $ item -> defindex ] = $ item ; $ this -> itemNames [ $ item -> name ] = $ item -> defindex ; } if ( ! empty ( $ data -> levels ) ) { $ this -> itemLevels = [ ] ; foreach ( $ data -> item_levels as $ itemLevelType ) { $ itemLevels = [ ] ; foreach ( $ itemLevelType -> levels as $ itemLevel ) { $ itemLevels [ $ itemLevel -> level ] = $ itemLevel -> name ; } $ this -> itemLevels [ $ itemLevelType -> name ] = $ itemLevels ; } } $ this -> itemSets = [ ] ; foreach ( $ data -> item_sets as $ itemSet ) { $ this -> itemSets [ $ itemSet -> item_set ] = $ itemSet ; } $ this -> origins = [ ] ; foreach ( $ data -> originNames as $ origin ) { $ this -> origins [ $ origin -> origin ] = $ origin -> name ; } $ this -> qualities = [ ] ; $ index = - 1 ; foreach ( $ data -> qualities as $ key => $ value ) { $ index ++ ; if ( property_exists ( $ data -> qualityNames , $ key ) ) { $ qualityName = $ data -> qualityNames -> $ key ; } if ( empty ( $ qualityName ) ) { $ qualityName = ucwords ( $ key ) ; } $ this -> qualities [ $ index ] = $ qualityName ; } } 
public static function convertCommunityIdToSteamId ( $ communityId ) { $ steamId1 = bcmod ( $ communityId , 2 ) ; $ steamId2 = bcsub ( $ communityId , 76561197960265728 ) ; if ( $ steamId2 <= 0 ) { throw new SteamCondenserException ( "SteamID $communityId is too small." ) ; } $ steamId2 = ( $ steamId2 - $ steamId1 ) / 2 ; return "STEAM_0:$steamId1:$steamId2" ; } 
public static function convertSteamIdToCommunityId ( $ steamId ) { if ( $ steamId == 'STEAM_ID_LAN' || $ steamId == 'BOT' ) { throw new SteamCondenserException ( "Cannot convert SteamID \"$steamId\" to a community ID." ) ; } if ( preg_match ( '/^STEAM_[0-1]:[0-1]:[0-9]+$/' , $ steamId ) ) { $ steamId = explode ( ':' , substr ( $ steamId , 8 ) ) ; return bcadd ( $ steamId [ 0 ] + $ steamId [ 1 ] * 2 , 76561197960265728 ) ; } elseif ( preg_match ( '/^\[U:[0-1]:[0-9]+\]$/' , $ steamId ) ) { $ steamId = explode ( ':' , substr ( $ steamId , 3 , strlen ( $ steamId ) - 1 ) ) ; return bcadd ( $ steamId [ 0 ] + $ steamId [ 1 ] , 76561197960265727 ) ; } else { throw new SteamCondenserException ( "SteamID \"$steamId\" doesn't have the correct format." ) ; } } 
public static function resolveVanityUrl ( $ vanityUrl ) { $ params = [ 'vanityurl' => $ vanityUrl ] ; $ result = WebApi :: getJSONObject ( 'ISteamUser' , 'ResolveVanityURL' , 1 , $ params ) ; $ result = $ result -> response ; if ( $ result -> success != 1 ) { return null ; } return $ result -> steamid ; } 
public function fetchFriends ( ) { $ friendsData = $ this -> getData ( $ this -> getBaseUrl ( ) . '/friends?xml=1' ) ; $ this -> friends = [ ] ; foreach ( $ friendsData -> friends -> friend as $ friend ) { $ this -> friends [ ] = self :: create ( ( string ) $ friend , false ) ; } return $ this -> friends ; } 
public function fetchGames ( ) { $ params = [ 'steamid' => $ this -> getSteamId64 ( ) , 'include_appinfo' => 1 , 'include_played_free_games' => 1 ] ; $ gamesData = WebApi :: getJSONObject ( 'IPlayerService' , 'GetOwnedGames' , 1 , $ params ) ; foreach ( $ gamesData -> response -> games as $ gameData ) { $ game = SteamGame :: create ( $ gameData ) ; $ this -> games [ $ game -> getAppId ( ) ] = $ game ; if ( property_exists ( $ gameData , 'playtime_2weeks' ) ) { $ recent = $ gameData -> playtime_2weeks ; } else { $ recent = 0 ; } $ total = $ gameData -> playtime_forever ; $ this -> playtimes [ $ game -> getAppId ( ) ] = [ $ recent , $ total ] ; } return $ this -> games ; } 
public function fetchGroups ( ) { $ params = [ 'steamid' => $ this -> getSteamId64 ( ) ] ; $ result = WebApi :: getJSONObject ( 'ISteamUser' , 'GetUserGroupList' , 1 , $ params ) ; $ this -> groups = [ ] ; foreach ( $ result -> response -> groups as $ groupData ) { $ this -> groups [ ] = SteamGroup :: create ( $ groupData -> gid , false ) ; } return $ this -> groups ; } 
public function getSteamId64 ( ) { if ( empty ( $ this -> steamId64 ) ) { $ this -> steamId64 = self :: resolveVanityUrl ( $ this -> customUrl ) ; } return $ this -> steamId64 ; } 
public function getRecentPlaytime ( $ appId ) { if ( empty ( $ this -> playtimes ) ) { $ this -> fetchGames ( ) ; } return $ this -> playtimes [ $ appId ] [ 0 ] ; } 
public function getTotalPlaytime ( $ appId ) { if ( empty ( $ this -> playtimes ) ) { $ this -> fetchGames ( ) ; } return $ this -> playtimes [ $ appId ] [ 1 ] ; } 
protected function internalFetch ( ) { $ profile = $ this -> getData ( $ this -> getBaseUrl ( ) . '?xml=1' ) ; if ( ! empty ( $ profile -> error ) ) { throw new SteamCondenserException ( ( string ) $ profile -> error ) ; } if ( ! empty ( $ profile -> privacyMessage ) ) { throw new SteamCondenserException ( ( string ) $ profile -> privacyMessage ) ; } $ this -> nickname = htmlspecialchars_decode ( ( string ) $ profile -> steamID ) ; $ this -> steamId64 = ( string ) $ profile -> steamID64 ; $ this -> limited = ( bool ) ( int ) $ profile -> isLimitedAccount ; $ this -> tradeBanState = ( string ) $ profile -> tradeBanState ; $ this -> vacBanned = ( bool ) ( int ) $ profile -> vacBanned ; $ this -> imageUrl = substr ( ( string ) $ profile -> avatarIcon , 0 , - 4 ) ; $ this -> onlineState = ( string ) $ profile -> onlineState ; $ this -> privacyState = ( string ) $ profile -> privacyState ; $ this -> stateMessage = ( string ) $ profile -> stateMessage ; $ this -> visibilityState = ( int ) $ profile -> visibilityState ; if ( $ this -> isPublic ( ) ) { $ this -> customUrl = strtolower ( ( string ) $ profile -> customURL ) ; $ this -> hoursPlayed = ( float ) $ profile -> hoursPlayed2Wk ; $ this -> location = ( string ) $ profile -> location ; $ this -> memberSince = ( string ) $ profile -> memberSince ; $ this -> realName = htmlspecialchars_decode ( ( string ) $ profile -> realname ) ; $ this -> summary = htmlspecialchars_decode ( ( string ) $ profile -> summary ) ; } } 
public function rotateIp ( ) { if ( sizeof ( $ this -> ipAddresses ) == 1 ) { return true ; } $ this -> ipIndex = ( $ this -> ipIndex + 1 ) % sizeof ( $ this -> ipAddresses ) ; $ this -> ipAddress = $ this -> ipAddresses [ $ this -> ipIndex ] ; $ this -> initSocket ( ) ; return $ this -> ipIndex == 0 ; } 
public function initSocket ( ) { $ this -> rconSocket = new Sockets \ RCONSocket ( $ this -> ipAddress , $ this -> port ) ; $ this -> socket = new Sockets \ SourceSocket ( $ this -> ipAddress , $ this -> port ) ; } 
public function rconAuth ( $ password ) { $ this -> rconRequestId = $ this -> generateRconRequestId ( ) ; $ this -> rconSocket -> send ( new Packets \ RCON \ RCONAuthRequest ( $ this -> rconRequestId , $ password ) ) ; $ reply = $ this -> rconSocket -> getReply ( ) ; if ( $ reply == null ) { throw new RCONBanException ( ) ; } $ reply = $ this -> rconSocket -> getReply ( ) ; $ this -> rconAuthenticated = $ reply -> getRequestId ( ) == $ this -> rconRequestId ; return $ this -> rconAuthenticated ; } 
public function rconExec ( $ command ) { if ( ! $ this -> rconAuthenticated ) { throw new RCONNoAuthException ( ) ; } $ this -> rconSocket -> send ( new Packets \ RCON \ RCONExecRequest ( $ this -> rconRequestId , $ command ) ) ; $ isMulti = false ; $ response = [ ] ; do { $ responsePacket = $ this -> rconSocket -> getReply ( ) ; if ( $ responsePacket == null || $ responsePacket instanceof Packets \ RCON \ RCONAuthResponse ) { $ this -> rconAuthenticated = false ; throw new RCONNoAuthException ( ) ; } if ( ! $ isMulti && strlen ( $ responsePacket -> getResponse ( ) ) > 0 ) { $ isMulti = true ; $ this -> rconSocket -> send ( new Packets \ RCON \ RCONTerminator ( $ this -> rconRequestId ) ) ; } $ response [ ] = $ responsePacket -> getResponse ( ) ; } while ( $ isMulti && ! ( empty ( $ response [ sizeof ( $ response ) - 2 ] ) && empty ( $ response [ sizeof ( $ response ) - 1 ] ) ) ) ; return trim ( join ( '' , $ response ) ) ; } 
public function connect ( $ ipAddress , $ portNumber , $ timeout ) { $ this -> ipAddress = $ ipAddress ; $ this -> portNumber = $ portNumber ; if ( $ this -> socketsEnabled ) { if ( ! $ this -> socket = socket_create ( AF_INET , SOCK_DGRAM , SOL_UDP ) ) { throw new SocketException ( socket_last_error ( $ this -> socket ) ) ; } if ( ! socket_connect ( $ this -> socket , $ ipAddress , $ portNumber ) ) { throw new SocketException ( socket_last_error ( $ this -> socket ) ) ; } socket_set_block ( $ this -> socket ) ; } else { if ( ! $ this -> socket = fsockopen ( "udp://$ipAddress" , $ portNumber , $ socketErrno , $ socketErrstr ) ) { throw new SocketException ( $ socketErrstr ) ; } stream_set_blocking ( $ this -> socket , true ) ; } } 
public static function create ( ) { $ args = func_get_args ( ) ; $ className = empty ( self :: $ className ) ? get_class ( ) : self :: $ className ; $ class = new \ ReflectionClass ( $ className ) ; $ constructor = $ class -> getConstructor ( ) ; $ arity = $ constructor -> getNumberOfParameters ( ) ; if ( sizeof ( $ args ) < $ arity ) { array_fill ( 0 , $ arity , null ) ; } $ bypassCache = ( sizeof ( $ args ) > $ arity + 1 ) ? array_pop ( $ args ) : false ; $ fetch = ( sizeof ( $ args ) > $ arity ) ? array_pop ( $ args ) : true ; $ object = $ class -> newInstanceWithoutConstructor ( ) ; $ constructor -> setAccessible ( true ) ; $ constructor -> invokeArgs ( $ object , $ args ) ; $ cachedObject = $ object -> cachedInstance ( ) ; if ( $ cachedObject != null && ! $ bypassCache ) { $ object = $ cachedObject ; } if ( $ fetch && ( $ bypassCache || ! $ object -> isFetched ( ) ) ) { $ object -> fetch ( ) ; $ object -> cache ( ) ; } return $ object ; } 
protected function cachedInstance ( ) { $ findInstance = function ( $ id , $ cache ) use ( & $ findInstance ) { self :: selectIds ( $ id , $ ids ) ; if ( array_key_exists ( $ id , $ cache ) ) { return ( empty ( $ ids ) ) ? $ cache [ $ id ] : $ findInstance ( $ id , $ cache [ $ id ] ) ; } return null ; } ; foreach ( $ this -> cacheIds ( ) as $ id ) { $ instance = $ findInstance ( $ id , self :: $ cache ) ; if ( $ instance != null ) { return $ instance ; } } return null ; } 
public static function isCached ( $ id ) { $ findId = function ( $ id , $ cache ) use ( & $ findId ) { self :: selectIds ( $ id , $ ids ) ; if ( array_key_exists ( $ id , $ cache ) ) { return ( is_array ( $ ids ) ) ? $ findId ( $ id , $ cache [ $ id ] ) : true ; } return false ; } ; return $ findId ( $ id , self :: $ cache ) ; } 
protected function cache ( ) { $ cacheInstance = function ( $ id , & $ cache ) use ( & $ cacheInstance ) { self :: selectIds ( $ id , $ ids ) ; if ( empty ( $ ids ) ) { $ cache [ $ id ] = $ this ; } else { $ cacheInstance ( $ ids , $ cache [ $ id ] ) ; } } ; foreach ( $ this -> cacheIds ( ) as $ cacheId ) { $ cacheInstance ( $ cacheId , self :: $ cache ) ; } } 
protected function cacheIds ( ) { $ values = function ( $ id ) use ( & $ values ) { return is_array ( $ id ) ? array_map ( $ values , $ id ) : $ this -> { $ id } ; } ; return array_map ( $ values , self :: $ cacheIds ) ; } 
public static function getPacketFromData ( $ rawData ) { $ byteBuffer = new ByteBuffer ( $ rawData ) ; $ requestId = $ byteBuffer -> getLong ( ) ; $ header = $ byteBuffer -> getLong ( ) ; $ data = $ byteBuffer -> getString ( ) ; switch ( $ header ) { case RCONPacket :: SERVERDATA_AUTH_RESPONSE : return new RCONAuthResponse ( $ requestId ) ; case RCONPacket :: SERVERDATA_RESPONSE_VALUE : return new RCONExecResponse ( $ requestId , $ data ) ; default : throw new PacketFormatException ( 'Unknown packet with header ' . dechex ( $ header ) . ' received.' ) ; } } 
public function initSocket ( ) { $ this -> socket = new Sockets \ GoldSrcSocket ( $ this -> ipAddress , $ this -> port , $ this -> isHLTV ) ; } 
public function rconAuth ( $ password ) { $ this -> rconPassword = $ password ; try { $ this -> rconAuthenticated = true ; $ this -> rconExec ( '' ) ; } catch ( RCONNoAuthException $ e ) { $ this -> rconAuthenticated = false ; $ this -> rconPassword = null ; } return $ this -> rconAuthenticated ; } 
public function rconExec ( $ command ) { if ( ! $ this -> rconAuthenticated ) { throw new RCONNoAuthException ( ) ; } try { return trim ( $ this -> socket -> rconExec ( $ this -> rconPassword , $ command ) ) ; } catch ( RCONNoAuthException $ e ) { $ this -> rconAuthenticated = false ; throw $ e ; } } 
public function close ( ) { if ( ! empty ( $ this -> socket ) ) { if ( $ this -> socketsEnabled ) { socket_close ( $ this -> socket ) ; } else { fclose ( $ this -> socket ) ; } $ this -> socket = null ; } } 
public function recv ( $ length = 128 ) { if ( $ this -> socketsEnabled ) { $ data = socket_read ( $ this -> socket , $ length ) ; if ( $ data === false ) { $ errorCode = socket_last_error ( $ this -> socket ) ; if ( defined ( 'SOCKET_ECONNRESET' ) && $ errorCode == SOCKET_ECONNRESET ) { throw new ConnectionResetException ( ) ; } throw new SocketException ( $ errorCode ) ; } } else { $ data = fread ( $ this -> socket , $ length ) ; if ( $ data === false ) { throw new SocketException ( 'Could not read from socket.' ) ; } } return $ data ; } 
public function select ( $ timeout = 0 ) { $ read = [ $ this -> socket ] ; $ write = null ; $ except = null ; $ sec = floor ( $ timeout / 1000 ) ; $ usec = $ timeout % 1000 ; if ( $ this -> socketsEnabled ) { $ select = socket_select ( $ read , $ write , $ except , $ sec , $ usec ) ; } else { $ select = stream_select ( $ read , $ write , $ except , $ sec , $ usec ) ; } return $ select > 0 ; } 
public function send ( $ data ) { if ( $ this -> socketsEnabled ) { $ sendResult = socket_send ( $ this -> socket , $ data , strlen ( $ data ) , 0 ) ; if ( $ sendResult === false ) { throw new SocketException ( socket_last_error ( $ this -> socket ) ) ; } } else { $ sendResult = fwrite ( $ this -> socket , $ data , strlen ( $ data ) ) ; if ( $ sendResult === false ) { throw new SocketException ( 'Could not send data.' ) ; } } } 
public static function getNewsForApp ( $ appId , $ count = 5 , $ maxLength = null ) { $ params = [ 'appid' => $ appId , 'count' => $ count , 'maxlength' => $ maxLength ] ; $ data = WebApi :: getJSONObject ( 'ISteamNews' , 'GetNewsForApp' , 2 , $ params ) ; $ newsItems = [ ] ; foreach ( $ data -> appnews -> newsitems as $ newsData ) { $ newsItems [ ] = new AppNews ( $ appId , $ newsData ) ; } return $ newsItems ; } 
protected function getData ( $ url ) { if ( ! $ xml = file_get_contents ( $ url ) ) { preg_match ( '/^.* (\d{3}) (.*)$/' , $ http_response_header [ 0 ] , $ http_status ) ; $ errorMessage = "Failed to retrieve XML data because of an HTTP error: {$http_status[1]} (status code: {$http_status[0]})" ; throw new SteamCondenserException ( $ errorMessage , 0 ) ; } try { return new \ SimpleXMLElement ( $ xml ) ; } catch ( \ Exception $ e ) { $ errorMessage = "XML could not be parsed: " . $ e -> getMessage ( ) ; throw new SteamCondenserException ( $ errorMessage , 0 , $ e ) ; } } 
public function getClassesEquipped ( ) { $ classesEquipped = [ ] ; foreach ( $ this -> equipped as $ classId => $ equipped ) { if ( $ equipped ) { $ classesEquipped [ ] = $ classId ; } } return $ classesEquipped ; } 
public function getMemberCount ( ) { if ( empty ( $ this -> memberCount ) ) { $ totalPages = $ this -> fetchPage ( 1 ) ; if ( $ totalPages == 1 ) { $ this -> fetchTime = time ( ) ; } } return $ this -> memberCount ; } 
public function getMembers ( ) { if ( sizeof ( $ this -> members ) != $ this -> memberCount ) { $ this -> fetch ( ) ; } return $ this -> members ; } 
private function fetchPage ( $ page ) { $ url = "{$this->getBaseUrl()}/memberslistxml?p=$page" ; $ memberData = $ this -> getData ( $ url ) ; if ( $ page == 1 ) { preg_match ( '/\/([0-9a-f]+)\.jpg$/' , ( string ) $ memberData -> groupDetails -> avatarIcon , $ matches ) ; $ this -> avatarHash = $ matches [ 1 ] ; $ this -> customUrl = ( string ) $ memberData -> groupDetails -> groupURL ; $ this -> groupId64 = ( string ) $ memberData -> groupID64 ; $ this -> name = ( string ) $ memberData -> groupDetails -> groupName ; $ this -> headline = ( string ) $ memberData -> groupDetails -> headline ; $ this -> summary = ( string ) $ memberData -> groupDetails -> summary ; } $ this -> memberCount = ( int ) $ memberData -> memberCount ; $ totalPages = ( int ) $ memberData -> totalPages ; foreach ( $ memberData -> members -> steamID64 as $ member ) { array_push ( $ this -> members , SteamId :: create ( ( string ) $ member , false ) ) ; } return $ totalPages ; } 
protected function internalFetch ( ) { if ( empty ( $ this -> memberCount ) || sizeof ( $ this -> members ) == $ this -> memberCount ) { $ page = 0 ; } else { $ page = 1 ; } do { $ totalPages = $ this -> fetchPage ( ++ $ page ) ; } while ( $ page < $ totalPages ) ; $ this -> fetchTime = time ( ) ; } 
public static function create ( $ appId , $ steamId , $ fetchNow = true , $ bypassCache = false ) { if ( is_numeric ( $ steamId ) ) { $ steamId64 = $ steamId ; } else { $ steamId64 = SteamId :: resolveVanityUrl ( $ steamId ) ; } switch ( $ appId ) { case DotA2BetaInventory :: APP_ID : $ inventoryClass = 'Dota2\\Dota2BetaInventory' ; break ; case DotA2Inventory :: APP_ID : $ inventoryClass = 'Dota2\\Dota2Inventory' ; break ; case Portal2Inventory :: APP_ID : $ inventoryClass = 'Portal2\\Portal2Inventory' ; break ; case TF2BetaInventory :: APP_ID : $ inventoryClass = 'TF2\\TF2BetaInventory' ; break ; case TF2Inventory :: APP_ID : $ inventoryClass = 'TF2\\TF2Inventory' ; break ; default : $ inventoryClass = 'GameInventory' ; } self :: overwriteClass ( "\\SteamCondenser\\Community\\$inventoryClass" ) ; return self :: createCacheable ( $ appId , $ steamId64 , $ fetchNow , $ bypassCache ) ; } 
public function getItemSchema ( ) { if ( $ this -> itemSchema == null ) { $ this -> itemSchema = GameItemSchema :: create ( $ this -> appId , self :: $ schemaLanguage ) ; } return $ this -> itemSchema ; } 
protected function internalFetch ( ) { $ params = [ 'SteamID' => $ this -> steamId64 ] ; $ result = WebApi :: getJSONData ( "IEconItems_{$this->getAppId()}" , 'GetPlayerItems' , 1 , $ params ) ; $ this -> items = [ ] ; $ this -> preliminaryItems = [ ] ; foreach ( $ result -> items as $ itemData ) { if ( $ itemData != null ) { $ inventoryClass = get_called_class ( ) ; $ itemClass = $ inventoryClass :: ITEM_CLASS ; $ item = new $ itemClass ( $ this , $ itemData ) ; if ( $ item -> isPreliminary ( ) ) { $ this -> preliminaryItems [ ] = $ item ; } else { $ this -> items [ $ item -> getBackpackPosition ( ) - 1 ] = $ item ; } } } } 
public function getBotsEquipped ( ) { $ botsEquipped = [ ] ; foreach ( $ this -> equipped as $ botId => $ equipped ) { if ( $ equipped ) { $ botsEquipped [ ] = $ botId ; } } return $ botsEquipped ; } 
public static function getGoldenWrenches ( ) { if ( self :: $ goldenWrenches == null ) { self :: $ goldenWrenches = [ ] ; $ data = WebApi :: getJSONObject ( 'ITFItems_440' , 'GetGoldenWrenches' , 2 ) ; foreach ( $ data -> results -> wrenches as $ wrenchData ) { self :: $ goldenWrenches [ ] = new TF2GoldenWrench ( $ wrenchData ) ; } } return self :: $ goldenWrenches ; } 
public static function getJSON ( $ interface , $ method , $ version = 1 , $ params = null ) { return self :: load ( 'json' , $ interface , $ method , $ version , $ params ) ; } 
public static function getJSONData ( $ interface , $ method , $ version = 1 , $ params = null ) { $ result = self :: getJSONObject ( $ interface , $ method , $ version , $ params ) -> result ; if ( $ result -> status != 1 ) { throw new WebApiException ( WebApiException :: STATUS_BAD , $ result -> status , $ result -> statusDetail ) ; } return $ result ; } 
public static function getJSONObject ( $ interface , $ method , $ version = 1 , $ params = null ) { return json_decode ( self :: getJSON ( $ interface , $ method , $ version , $ params ) ) ; } 
public static function load ( $ format , $ interface , $ method , $ version = 1 , $ params = null ) { return self :: instance ( ) -> _load ( $ format , $ interface , $ method , $ version , $ params ) ; } 
private static function instance ( ) { if ( self :: $ instance == null ) { self :: $ instance = new WebApi ( ) ; self :: $ instance -> setLogger ( \ SteamCondenser \ getLogger ( get_class ( ) ) ) ; } return self :: $ instance ; } 
public static function setApiKey ( $ apiKey ) { if ( $ apiKey != null && ! preg_match ( '/^[0-9A-F]{32}$/' , $ apiKey ) ) { throw new WebApiException ( WebApiException :: INVALID_KEY ) ; } self :: $ apiKey = $ apiKey ; } 
protected function _load ( $ format , $ interface , $ method , $ version = 1 , $ params = null ) { $ protocol = ( self :: $ secure ) ? 'https' : 'http' ; $ url = "$protocol://api.steampowered.com/$interface/$method/v$version/" ; $ params [ 'format' ] = $ format ; if ( self :: $ apiKey != null ) { $ params [ 'key' ] = self :: $ apiKey ; } if ( $ params != null && ! empty ( $ params ) ) { $ url .= '?' ; $ url_params = [ ] ; foreach ( $ params as $ k => $ v ) { $ url_params [ ] = "$k=$v" ; } $ url .= join ( '&' , $ url_params ) ; } return $ this -> request ( $ url ) ; } 
protected function request ( $ url ) { $ this -> logger -> debug ( "Querying Steam Web API: " . str_replace ( self :: $ apiKey , 'SECRET' , $ url ) ) ; $ data = file_get_contents ( $ url ) ; if ( empty ( $ data ) ) { preg_match ( '/^.* (\d{3}) (.*)$/' , $ http_response_header [ 0 ] , $ http_status ) ; if ( $ http_status [ 1 ] == 401 ) { throw new WebApiException ( WebApiException :: UNAUTHORIZED ) ; } throw new WebApiException ( WebApiException :: HTTP_ERROR , $ http_status [ 1 ] , $ http_status [ 2 ] ) ; } return $ data ; } 
public function send ( SteamPacket $ dataPacket ) { if ( empty ( $ this -> socket ) || ! $ this -> socket -> isOpen ( ) ) { $ this -> socket = new TCPSocket ( ) ; $ this -> socket -> connect ( $ this -> ipAddress , $ this -> portNumber , SteamSocket :: $ timeout ) ; } parent :: send ( $ dataPacket ) ; } 
public function getReply ( ) { try { if ( $ this -> receivePacket ( 4 ) == 0 ) { $ this -> socket -> close ( ) ; return null ; } } catch ( ConnectionResetException $ e ) { $ this -> socket -> close ( ) ; return null ; } $ packetSize = $ this -> buffer -> getLong ( ) ; $ remainingBytes = $ packetSize ; $ packetData = '' ; do { $ receivedBytes = $ this -> receivePacket ( $ remainingBytes ) ; $ remainingBytes -= $ receivedBytes ; $ packetData .= $ this -> buffer -> get ( ) ; } while ( $ remainingBytes > 0 ) ; $ packet = RCONPacketFactory :: getPacketFromData ( $ packetData ) ; $ this -> logger -> debug ( 'Received packet of type ' . get_class ( $ packet ) ) ; return $ packet ; } 
protected function getPlayerStatusAttributes ( $ statusHeader ) { $ statusAttributes = [ ] ; foreach ( preg_split ( "/\s+/" , $ statusHeader ) as $ attribute ) { if ( $ attribute == 'connected' ) { $ statusAttributes [ ] = 'time' ; } else if ( $ attribute == 'frag' ) { $ statusAttributes [ ] = 'score' ; } else { $ statusAttributes [ ] = $ attribute ; } } return $ statusAttributes ; } 
protected function splitPlayerStatus ( $ attributes , $ playerStatus ) { if ( $ attributes [ 0 ] != 'userid' ) { $ playerStatus = preg_replace ( '/^\d+ +/' , '' , $ playerStatus ) ; } $ firstQuote = strpos ( $ playerStatus , '"' ) ; $ lastQuote = strrpos ( $ playerStatus , '"' ) ; $ data = [ substr ( $ playerStatus , 0 , $ firstQuote ) , substr ( $ playerStatus , $ firstQuote + 1 , $ lastQuote - 1 - $ firstQuote ) , substr ( $ playerStatus , $ lastQuote + 1 ) ] ; $ data = array_merge ( array_filter ( preg_split ( "/\s+/" , trim ( $ data [ 0 ] ) ) ) , [ $ data [ 1 ] ] , preg_split ( "/\s+/" , trim ( $ data [ 2 ] ) ) ) ; $ data = array_values ( $ data ) ; if ( sizeof ( $ attributes ) > sizeof ( $ data ) && in_array ( 'state' , $ attributes ) ) { array_splice ( $ data , 3 , 0 , [ null , null , null ] ) ; } elseif ( sizeof ( $ attributes ) < sizeof ( $ data ) ) { unset ( $ data [ 1 ] ) ; $ data = array_values ( $ data ) ; } $ playerData = [ ] ; for ( $ i = 0 ; $ i < sizeof ( $ data ) ; $ i ++ ) { $ playerData [ $ attributes [ $ i ] ] = $ data [ $ i ] ; } return $ playerData ; } 
public function getPlayers ( $ rconPassword = null ) { if ( $ this -> playerHash == null ) { $ this -> updatePlayers ( $ rconPassword ) ; } return $ this -> playerHash ; } 
protected function handleResponseForRequest ( $ requestType , $ repeatOnFailure = true ) { switch ( $ requestType ) { case self :: REQUEST_CHALLENGE : $ expectedResponse = '\SteamCondenser\Servers\Packets\S2CCHALLENGEPacket' ; $ requestPacket = new A2SPLAYERPacket ( ) ; break ; case self :: REQUEST_INFO : $ expectedResponse = '\SteamCondenser\Servers\Packets\S2AINFOBasePacket' ; $ requestPacket = new A2SINFOPacket ( ) ; break ; case self :: REQUEST_PLAYER : $ expectedResponse = '\SteamCondenser\Servers\Packets\S2APLAYERPacket' ; $ requestPacket = new A2SPLAYERPacket ( $ this -> challengeNumber ) ; break ; case self :: REQUEST_RULES : $ expectedResponse = '\SteamCondenser\Servers\Packets\S2ARULESPacket' ; $ requestPacket = new A2SRULESPacket ( $ this -> challengeNumber ) ; break ; default : throw new SteamCondenserException ( 'Called with wrong request type.' ) ; } $ this -> socket -> send ( $ requestPacket ) ; $ responsePacket = $ this -> socket -> getReply ( ) ; if ( $ responsePacket instanceof S2AINFOBasePacket ) { $ this -> infoHash = $ responsePacket -> getInfo ( ) ; } elseif ( $ responsePacket instanceof S2APLAYERPacket ) { $ this -> playerHash = $ responsePacket -> getPlayerHash ( ) ; } elseif ( $ responsePacket instanceof S2ARULESPacket ) { $ this -> rulesHash = $ responsePacket -> getRulesArray ( ) ; } elseif ( $ responsePacket instanceof S2CCHALLENGEPacket ) { $ this -> challengeNumber = $ responsePacket -> getChallengeNumber ( ) ; } else { throw new SteamCondenserException ( 'Response of type ' . get_class ( $ responsePacket ) . ' cannot be handled by this method.' ) ; } if ( ! ( $ responsePacket instanceof $ expectedResponse ) ) { $ this -> logger -> info ( "Expected {$expectedResponse}, got " . get_class ( $ responsePacket ) . '.' ) ; if ( $ repeatOnFailure ) { $ this -> handleResponseForRequest ( $ requestType , false ) ; } } } 
public function updatePing ( ) { $ this -> socket -> send ( new A2SINFOPacket ( ) ) ; $ startTime = microtime ( true ) ; $ this -> socket -> getReply ( ) ; $ endTime = microtime ( true ) ; $ this -> ping = intval ( round ( ( $ endTime - $ startTime ) * 1000 ) ) ; return $ this -> ping ; } 
public function updatePlayers ( $ rconPassword = null ) { $ this -> handleResponseForRequest ( self :: REQUEST_PLAYER ) ; if ( ! $ this -> rconAuthenticated ) { if ( $ rconPassword == null ) { return ; } $ this -> rconAuth ( $ rconPassword ) ; } $ players = [ ] ; foreach ( explode ( "\n" , $ this -> rconExec ( 'status' ) ) as $ line ) { if ( strpos ( $ line , '#' ) === 0 && $ line != '#end' ) { $ players [ ] = trim ( substr ( $ line , 1 ) ) ; } } $ attributes = $ this -> getPlayerStatusAttributes ( array_shift ( $ players ) ) ; foreach ( $ players as $ player ) { $ playerData = $ this -> splitPlayerStatus ( $ attributes , $ player ) ; if ( array_key_exists ( $ playerData [ 'name' ] , $ this -> playerHash ) ) { $ this -> playerHash [ $ playerData [ 'name' ] ] -> addInformation ( $ playerData ) ; } } } 
public function addInformation ( $ playerData ) { if ( $ playerData [ 'name' ] != $ this -> name ) { throw new SteamCondenserException ( 'Information to add belongs to a different player.' ) ; } $ this -> extended = true ; $ this -> connectionId = intval ( $ playerData [ 'userid' ] ) ; if ( array_key_exists ( 'state' , $ playerData ) ) { $ this -> state = $ playerData [ 'state' ] ; } $ this -> steamId = $ playerData [ 'uniqueid' ] ; if ( ! $ this -> isBot ( ) ) { $ this -> loss = intval ( $ playerData [ 'loss' ] ) ; $ this -> ping = intval ( $ playerData [ 'ping' ] ) ; if ( array_key_exists ( 'adr' , $ playerData ) ) { $ address = explode ( ':' , $ playerData [ 'adr' ] ) ; $ this -> ipAddress = $ address [ 0 ] ; $ this -> clientPort = intval ( $ address [ 1 ] ) ; } if ( array_key_exists ( 'rate' , $ playerData ) ) { $ this -> rate = $ playerData [ 'rate' ] ; } } } 
public static function getLeaderboard ( $ gameName , $ id ) { $ leaderboards = self :: getLeaderboards ( $ gameName ) ; if ( is_int ( $ id ) ) { if ( array_key_exists ( $ id , $ leaderboards ) ) { return $ leaderboards [ $ id ] ; } else { return null ; } } else { foreach ( array_values ( $ leaderboards ) as $ board ) { if ( $ board -> getName ( ) == $ id ) { return $ board ; } } } } 
public static function getLeaderboards ( $ gameName ) { if ( ! array_key_exists ( $ gameName , self :: $ leaderboards ) ) { self :: loadLeaderboards ( $ gameName ) ; } return self :: $ leaderboards [ $ gameName ] ; } 
private static function loadLeaderboards ( $ gameName ) { $ url = "http://steamcommunity.com/stats/$gameName/leaderboards/?xml=1" ; $ boardsData = new \ SimpleXMLElement ( file_get_contents ( $ url ) ) ; if ( ! empty ( $ boardsData -> error ) ) { throw new SteamCondenserException ( ( string ) $ boardsData -> error ) ; } self :: $ leaderboards [ $ gameName ] = [ ] ; foreach ( $ boardsData -> leaderboard as $ boardData ) { $ leaderboard = new GameLeaderboard ( $ boardData ) ; self :: $ leaderboards [ $ gameName ] [ $ leaderboard -> getId ( ) ] = $ leaderboard ; } } 
public function getEntryForSteamId ( $ steamId ) { if ( is_object ( $ steamId ) ) { $ id = $ steamId -> getSteamId64 ( ) ; } else { $ id = $ steamId ; } $ xml = $ this -> loadDataForSteamId ( $ id ) ; foreach ( $ xml -> entries -> entry as $ entryData ) { if ( $ entryData -> steamid == $ id ) { return new GameLeaderboardEntry ( $ entryData , $ this ) ; } } return null ; } 
public function getEntryRange ( $ first , $ last ) { if ( $ last < $ first ) { throw new SteamCondenserException ( 'First entry must be prior to last entry for leaderboard entry lookup.' ) ; } if ( ( $ last - $ first ) > 5000 ) { throw new SteamCondenserException ( 'Leaderboard entry lookup is currently limited to a maximum of 5001 entries per request.' ) ; } $ xml = $ this -> loadData ( [ 'start' => $ first , 'end' => $ last ] ) ; return $ this -> parseEntries ( $ xml ) ; } 
protected function loadData ( array $ params ) { $ url = $ this -> url ; if ( ! empty ( $ params ) ) { $ url_params = [ ] ; foreach ( $ params as $ k => $ v ) { $ url_params [ ] = "$k=$v" ; } $ url .= '&' . join ( '&' , $ url_params ) ; } $ xml = new \ SimpleXMLElement ( file_get_contents ( $ url ) ) ; if ( ! empty ( $ xml -> error ) ) { throw new SteamCondenserException ( ( string ) $ xml -> error ) ; } return $ xml ; } 
protected function loadDataForSteamId ( $ steamId ) { if ( is_object ( $ steamId ) ) { $ id = $ steamId -> getSteamId64 ( ) ; } else { $ id = $ steamId ; } return $ this -> loadData ( [ 'steamid' => $ id ] ) ; } 
protected function parseEntries ( \ SimpleXMLElement $ xml ) { $ entries = [ ] ; foreach ( $ xml -> entries -> entry as $ entryData ) { $ rank = ( int ) $ entryData -> rank ; $ entries [ $ rank ] = new GameLeaderboardEntry ( $ entryData , $ this ) ; } return $ entries ; } 
public static function create ( \ stdClass $ gameData ) { if ( array_key_exists ( $ gameData -> appid , self :: $ games ) ) { return self :: $ games [ $ gameData -> appid ] ; } else { return new SteamGame ( $ gameData ) ; } } 
public static function checkSteamInf ( $ path ) { $ steamInf = file_get_contents ( $ path ) ; preg_match ( '/^\s*appID=(\d+)\s*$/im' , $ steamInf , $ appId ) ; preg_match ( '/^\s*PatchVersion=([\d\.]+)\s*$/im' , $ steamInf , $ version ) ; if ( $ appId == null || $ version == null ) { throw new SteamCondenserException ( "The steam.inf file at \"$path\" is invalid." ) ; } $ appId = ( int ) $ appId [ 1 ] ; $ version = ( int ) str_replace ( '.' , '' , $ version [ 1 ] ) ; return self :: checkUpToDate ( $ appId , $ version ) ; } 
public static function checkUpToDate ( $ appId , $ version ) { $ params = [ 'appid' => $ appId , 'version' => $ version ] ; $ result = WebApi :: getJSONObject ( 'ISteamApps' , 'UpToDateCheck' , 1 , $ params ) ; $ result = $ result -> response ; if ( ! $ result -> success ) { throw new SteamCondenserException ( $ result -> error ) ; } return $ result -> up_to_date ; } 
public function getPlayerCount ( ) { $ params = [ 'appid' => $ this -> appId ] ; $ result = WebApi :: getJSONObject ( 'ISteamUserStats' , 'GetNumberOfCurrentPlayers' , 1 , $ params ) ; return $ result -> response -> player_count ; } 
public function getUserStats ( $ steamId ) { if ( ! $ this -> hasStats ( ) ) { return null ; } return GameStats :: create ( $ steamId , $ this -> appId ) ; } 
public function index ( $ workOrderId ) { $ workOrder = $ this -> workOrder -> findOrFail ( $ workOrderId ) ; $ parts = $ this -> presenter -> table ( $ workOrder ) ; $ inventory = $ this -> presenter -> tableInventory ( $ workOrder , $ this -> inventory ) ; $ navbarParts = $ this -> presenter -> navbarParts ( $ workOrder ) ; $ navbarInventory = $ this -> presenter -> navbarInventory ( ) ; return view ( 'work-orders.parts.index' , compact ( 'parts' , 'inventory' , 'workOrder' , 'navbarParts' , 'navbarInventory' ) ) ; } 
public function store ( Request $ request ) { $ event = $ this -> event -> create ( $ request ) ; if ( $ event ) { $ message = 'Successfully created event.' ; return redirect ( ) -> route ( 'maintenance.events.index' ) -> withSuccess ( $ message ) ; } else { $ message = 'There was an issue creating an event. Please try again.' ; return redirect ( ) -> route ( 'maintenance.events.create' ) -> withErrors ( $ message ) ; } } 
public function show ( $ id ) { $ event = $ this -> event -> find ( $ id ) ; $ apiObject = $ this -> event -> findApiObject ( $ event -> api_id ) ; if ( $ apiObject ) { return view ( 'events.show' , compact ( 'event' , 'apiObject' ) ) ; } abort ( 404 ) ; } 
public function update ( Request $ request , $ id ) { $ event = $ this -> event -> update ( $ request , $ id ) ; if ( $ event ) { $ message = 'Successfully updated event.' ; return redirect ( ) -> route ( 'maintenance.events.show' , [ $ event -> id ] ) -> withSuccess ( $ message ) ; } else { $ message = 'There was an issue updating this event. Please try again.' ; return redirect ( ) -> route ( 'maintenance.events.create' ) -> withErrors ( $ message ) ; } } 
public function destroy ( $ id ) { if ( $ this -> event -> delete ( $ id ) ) { $ message = 'Successfully deleted event' ; return redirect ( ) -> route ( 'maintenance.events.index' ) -> withSuccess ( $ message ) ; } else { $ message = 'There was an error trying to delete this event. Please try again.' ; return redirect ( ) -> route ( 'maintenance.events.show' , [ $ id ] ) -> withErrors ( $ message ) ; } } 
public function store ( WorkOrderRequest $ request ) { $ workOrder = $ this -> workOrder -> newInstance ( ) ; return $ this -> dispatch ( new Store ( $ request , $ workOrder ) ) ; } 
public function show ( $ id ) { $ workOrder = $ this -> workOrder -> findOrFail ( $ id ) ; $ sessions = $ this -> presenter -> tableSessions ( $ workOrder ) ; $ history = $ this -> presenter -> tableHistory ( 'work-orders' , $ workOrder -> revisions ( ) ) ; $ navbar = $ this -> presenter -> navbarShow ( $ workOrder ) ; $ formComment = $ this -> presenter -> formComment ( $ workOrder , $ workOrder -> comments ( ) -> getRelated ( ) ) ; return view ( 'work-orders.show' , compact ( 'workOrder' , 'sessions' , 'history' , 'navbar' , 'formComment' ) ) ; } 
public function edit ( $ id ) { $ workOrder = $ this -> workOrder -> findOrFail ( $ id ) ; $ form = $ this -> presenter -> form ( $ workOrder ) ; return view ( 'work-orders.edit' , compact ( 'form' ) ) ; } 
public function update ( WorkOrderRequest $ request , $ id ) { $ workOrder = $ this -> workOrder -> findOrFail ( $ id ) ; return $ this -> dispatch ( new Update ( $ request , $ workOrder ) ) ; } 
public function getTake ( $ workOrderId , $ itemId , $ stockId ) { return $ this -> processor -> getTake ( $ workOrderId , $ itemId , $ stockId ) ; } 
public function postTake ( PartTakeRequest $ request , $ workOrderId , $ itemId , $ stockId ) { try { if ( $ this -> processor -> postTake ( $ request , $ workOrderId , $ itemId , $ stockId ) ) { flash ( ) -> success ( 'Success!' , 'Successfully added parts to work order.' ) ; return redirect ( ) -> route ( 'maintenance.work-orders.parts.index' , [ $ workOrderId ] ) ; } else { flash ( ) -> error ( 'Error!' , 'There was an issue adding parts to this work order. Please try again.' ) ; return redirect ( ) -> route ( 'maintenance.work-orders.parts.stocks.take' , [ $ workOrderId , $ itemId , $ stockId ] ) ; } } catch ( NotEnoughStockException $ e ) { flash ( ) -> error ( 'Not Enough Stock' , "There isn't enough stock available to take the requested quantity." ) ; return redirect ( ) -> route ( 'maintenance.work-orders.parts.stocks.take' , [ $ workOrderId , $ itemId , $ stockId ] ) ; } } 
public function getPut ( $ workOrderId , $ inventoryId , $ stockId ) { return $ this -> processor -> getPut ( $ workOrderId , $ inventoryId , $ stockId ) ; } 
public function postPut ( PartReturnRequest $ request , $ workOrderId , $ inventoryId , $ stockId ) { if ( $ this -> processor -> postPut ( $ request , $ workOrderId , $ inventoryId , $ stockId ) ) { flash ( ) -> success ( 'Success!' , 'Successfully returned parts to the inventory.' ) ; return redirect ( ) -> route ( 'maintenance.work-orders.parts.index' , [ $ workOrderId ] ) ; } else { flash ( ) -> error ( 'Error!' , 'There was an issue returning parts into the inventory. Please try again.' ) ; return redirect ( ) -> route ( 'maintenance.work-orders.parts.stocks.put' , [ $ workOrderId ] ) ; } } 
public function store ( WorkRequest $ request ) { $ workRequest = $ this -> workRequest -> create ( $ request ) ; if ( $ workRequest ) { $ message = 'Successfully created work request. You will receive a response shortly.' ; return redirect ( ) -> route ( 'maintenance.client.work-requests.index' ) -> withSuccess ( $ message ) ; } else { $ message = 'There was an issue creating a work request. Please try again.' ; return redirect ( ) -> route ( 'maintenance.client.work-requests.create' ) -> withErrors ( $ message ) ; } } 
public function show ( $ id ) { $ workRequest = $ this -> workRequest -> model ( ) -> findOrFail ( $ id ) ; return view ( 'client.work-requests.show' , compact ( 'workRequest' ) ) ; } 
public function edit ( $ id ) { $ workRequest = $ this -> workRequest -> model ( ) -> findOrFail ( $ id ) ; return view ( 'client.work-requests.edit' , compact ( 'workRequest' ) ) ; } 
public function update ( WorkRequest $ request , $ id ) { $ workRequest = $ this -> workRequest -> update ( $ request , $ id ) ; if ( $ workRequest ) { $ message = 'Successfully updated work request.' ; return redirect ( ) -> route ( 'maintenance.client.work-requests.show' , [ $ workRequest -> id ] ) -> withSuccess ( $ message ) ; } else { $ message = 'There was an issue updating your work request. Please try again.' ; return redirect ( ) -> route ( 'maintenance.client.work-requests.edit' , [ $ id ] ) -> withErrors ( $ message ) ; } } 
public function destroy ( $ id ) { $ workRequest = $ this -> workRequest -> model ( ) -> findOrFail ( $ id ) ; if ( $ workRequest -> delete ( ) ) { $ message = 'Successfully deleted work request.' ; return redirect ( ) -> route ( 'maintenance.client.work-requests.index' ) -> withSuccess ( $ message ) ; } else { $ message = 'There was an issue deleting this work request. Please try again.' ; return redirect ( ) -> route ( 'maintenance.client.work-requests.show' , [ $ id ] ) -> withErrors ( $ message ) ; } } 
public function getRevisedLocationAttribute ( $ id ) { if ( $ id ) { $ location = $ this -> location ( ) -> find ( $ id ) ; if ( $ location instanceof Location ) { return $ location -> trail ; } } return ; } 
public function scopeLocation ( $ query , $ locationId = null ) { if ( ! is_null ( $ locationId ) ) { 
public function store ( ReportRequest $ request , $ eventId ) { $ report = $ this -> event -> createReport ( $ request , $ eventId ) ; if ( $ report ) { $ message = 'Successfully created event report.' ; return redirect ( ) -> route ( 'maintenance.events.show' , [ $ eventId , '#tab-report' ] ) -> withSuccess ( $ message ) ; } else { $ message = 'There was an issue creating a report for this event. Please try again.' ; return redirect ( ) -> route ( 'maintenance.events.show' , [ $ eventId , '#tab-report' ] ) -> withErrors ( $ message ) ; } } 
public function handle ( ) { $ this -> report -> user_id = auth ( ) -> id ( ) ; $ this -> report -> work_order_id = $ this -> workOrder -> getKey ( ) ; $ this -> report -> description = $ this -> request -> clean ( $ this -> request -> input ( 'description' ) ) ; if ( $ this -> report -> save ( ) ) { $ this -> workOrder -> complete ( $ this -> request -> input ( 'status' ) ) ; return true ; } return false ; } 
public function create ( $ workOrderId ) { $ workOrder = $ this -> workOrder -> findOrFail ( $ workOrderId ) ; $ form = $ this -> presenter -> form ( $ workOrder , $ workOrder -> attachments ( ) -> getRelated ( ) ) ; return view ( 'work-orders.attachments.create' , compact ( 'form' ) ) ; } 
public function store ( AttachmentRequest $ request , $ workOrderId ) { $ workOrder = $ this -> workOrder -> findOrFail ( $ workOrderId ) ; return $ this -> dispatch ( new Store ( $ request , $ workOrder -> attachments ( ) ) ) ; } 
public function show ( $ workOrderId , $ attachmentId ) { $ workOrder = $ this -> workOrder -> findOrFail ( $ workOrderId ) ; $ attachment = $ workOrder -> attachments ( ) -> findOrFail ( $ attachmentId ) ; return view ( 'work-orders.attachments.show' , compact ( 'workOrder' , 'attachment' ) ) ; } 
public function edit ( $ workOrderId , $ attachmentId ) { $ workOrder = $ this -> workOrder -> findOrFail ( $ workOrderId ) ; $ attachment = $ workOrder -> attachments ( ) -> findOrFail ( $ attachmentId ) ; $ form = $ this -> presenter -> form ( $ workOrder , $ attachment ) ; return view ( 'work-orders.attachments.edit' , compact ( 'form' ) ) ; } 
public function update ( AttachmentUpdateRequest $ request , $ workOrderId , $ attachmentId ) { $ workOrder = $ this -> workOrder -> findOrFail ( $ workOrderId ) ; $ attachment = $ workOrder -> attachments ( ) -> findOrFail ( $ attachmentId ) ; return $ this -> dispatch ( new Update ( $ request , $ attachment ) ) ; } 
public function destroy ( $ workOrderId , $ attachmentId ) { $ workOrder = $ this -> workOrder -> findOrFail ( $ workOrderId ) ; $ attachment = $ workOrder -> attachments ( ) -> findOrFail ( $ attachmentId ) ; return $ this -> dispatch ( new Destroy ( $ attachment ) ) ; } 
public function download ( $ workOrderId , $ attachmentId ) { $ workOrder = $ this -> workOrder -> findOrFail ( $ workOrderId ) ; $ attachment = $ workOrder -> attachments ( ) -> findOrFail ( $ attachmentId ) ; return response ( ) -> download ( $ attachment -> download_path ) ; } 
public function form ( WorkOrder $ workOrder , WorkOrderReport $ report ) { return $ this -> form -> of ( 'work-orders.report' , function ( FormGrid $ form ) use ( $ workOrder , $ report ) { if ( $ report -> exists ) { $ method = 'PATCH' ; $ url = route ( 'maintenance.work-orders.report.update' , [ $ workOrder -> getKey ( ) , $ report -> getKey ( ) ] ) ; $ form -> submit = 'Save' ; } else { $ method = 'POST' ; $ url = route ( 'maintenance.work-orders.report.store' , [ $ workOrder -> getKey ( ) ] ) ; $ form -> submit = 'Create' ; } $ form -> attributes ( compact ( 'method' , 'url' ) ) ; $ form -> with ( $ report ) ; $ form -> fieldset ( function ( Fieldset $ fieldset ) use ( $ workOrder ) { $ fieldset -> control ( 'select' , 'status' ) -> options ( function ( ) { $ statuses = Status :: all ( ) -> pluck ( 'name' , 'id' ) ; $ statuses [ 0 ] = 'None' ; return $ statuses ; } ) -> value ( function ( ) use ( $ workOrder ) { if ( $ workOrder -> status instanceof Status ) { return $ workOrder -> status -> getKey ( ) ; } } ) -> attributes ( [ 'class' => 'select2' , ] ) ; $ fieldset -> control ( 'input:textarea' , 'description' ) ; } ) ; } ) ; } 
public function getIconAttribute ( ) { $ class = $ this -> attributes [ 'notifiable_type' ] ; $ config = App :: make ( ConfigService :: class ) ; * Looks like the notification icon could not be * found, we'll return the default notification icon */ $ defaultIcon = $ config -> setPrefix ( 'maintenance' ) -> get ( 'notifications.icons.default' ) ; return $ defaultIcon ; } return ; } 
public function handle ( ) { $ this -> stock -> location_id = $ this -> request -> input ( 'location' , $ this -> stock -> location_id ) ; $ this -> stock -> quantity = $ this -> request -> input ( 'quantity' , $ this -> stock -> quantity ) ; $ this -> stock -> cost = $ this -> request -> input ( 'cost' ) ; $ this -> stock -> reason = $ this -> request -> input ( 'reason' ) ; return $ this -> stock -> save ( ) ; } 
public function index ( $ inventory_id , $ stock_id ) { $ item = $ this -> inventory -> find ( $ inventory_id ) ; $ stock = $ this -> inventoryStock -> find ( $ stock_id ) ; $ data = $ this -> inputAll ( ) ; $ data [ 'stock_id' ] = $ stock -> id ; $ movements = $ this -> inventoryStockMovement -> setInput ( $ data ) -> getByPageWithFilter ( ) ; return view ( 'inventory.stocks.movements.index' , [ 'title' => "Viewing Stock Movements for Item: $item->name in Location: " . renderNode ( $ stock -> location ) , 'item' => $ item , 'stock' => $ stock , 'movements' => $ movements , ] ) ; } 
public function show ( $ inventory_id , $ stock_id , $ movement_id ) { $ item = $ this -> inventory -> find ( $ inventory_id ) ; $ stock = $ this -> inventoryStock -> find ( $ stock_id ) ; $ movement = $ this -> inventoryStockMovement -> find ( $ movement_id ) ; return view ( 'inventory.stocks.movements.show' , [ 'title' => 'Viewing Movement: ' . $ movement -> id , 'item' => $ item , 'stock' => $ stock , 'movement' => $ movement , ] ) ; } 
public function rollback ( $ inventory_id , $ stock_id , $ movement_id ) { $ item = $ this -> inventory -> find ( $ inventory_id ) ; $ stock = $ this -> inventoryStock -> find ( $ stock_id ) ; $ movement = $ this -> inventoryStockMovement -> find ( $ movement_id ) ; if ( $ stock -> rollback ( $ movement ) ) { $ this -> message = 'Successfully rolled back movement' ; $ this -> messageType = 'success' ; $ this -> redirect = routeBack ( 'maintenance.inventory.stock.movements.index' , [ $ item -> id , $ stock -> id , ] ) ; } else { $ this -> message = 'There was an error trying to roll back this movement. Please try again.' ; $ this -> messageType = 'success' ; $ this -> redirect = routeBack ( 'maintenance.inventory.stock.movements.index' , [ $ item -> id , $ stock -> id , ] ) ; } return $ this -> response ( ) ; } 
public function getRevisedStatusAttribute ( $ id ) { if ( $ id ) { $ status = $ this -> status ( ) -> find ( $ id ) ; if ( $ status instanceof Status ) { return $ status -> getLabel ( ) ; } } return ; } 
public function getRevisedPriorityAttribute ( $ id ) { if ( $ id ) { $ priority = $ this -> priority ( ) -> find ( $ id ) ; if ( $ priority instanceof Priority ) { return $ priority -> getLabel ( ) ; } } return ; } 
public function closeSessions ( ) { $ closed = [ ] ; foreach ( $ this -> sessions as $ session ) { if ( $ session instanceof WorkOrderSession && is_null ( $ session -> out ) ) { $ session -> out = $ this -> freshTimestamp ( ) ; if ( $ session -> save ( ) ) { $ closed [ ] = $ session ; } } } return $ closed ; } 
public function userCheckedIn ( ) { $ session = $ this -> getCurrentSession ( ) ; if ( $ session instanceof WorkOrderSession ) { return $ session -> in && is_null ( $ session -> out ) ; } return false ; } 
public function getStartedAtLabel ( ) { if ( $ this -> started_at ) { $ class = 'label label-success' ; $ icon = 'fa fa-check' ; $ message = $ this -> started_at ; } else { $ class = 'label label-danger' ; $ icon = 'fa fa-times' ; $ message = 'Has not been started.' ; } $ icon = HTML :: create ( 'i' , '' , [ 'class' => $ icon ] ) ; return HTML :: raw ( "<span class='$class'>$icon $message</span>" ) ; } 
public function getCompletedAtLabel ( ) { if ( $ this -> isComplete ( ) ) { $ class = 'label label-success' ; $ icon = 'fa fa-check' ; $ message = $ this -> completed_at ; } else { $ class = 'label label-danger' ; $ icon = 'fa fa-times' ; $ message = 'No report has been created.' ; } $ icon = HTML :: create ( 'i' , '' , [ 'class' => $ icon ] ) ; return HTML :: raw ( "<span class='$class'>$icon $message</span>" ) ; } 
public function complete ( $ statusId ) { if ( is_null ( $ this -> started_at ) ) { $ this -> started_at = $ this -> freshTimestamp ( ) ; } $ this -> completed_at = $ this -> freshTimestamp ( ) ; $ this -> status_id = $ statusId ; return $ this -> save ( ) ; } 
public function table ( Status $ status ) { return $ this -> table -> of ( 'work-orders.statuses' , function ( TableGrid $ table ) use ( $ status ) { $ table -> with ( $ status ) -> paginate ( $ this -> perPage ) ; $ table -> column ( 'Status' , function ( Column $ column ) { $ column -> value = function ( Status $ status ) { return link_to_route ( 'maintenance.work-orders.statuses.edit' , $ status -> getLabel ( ) , [ $ status -> getKey ( ) ] ) ; } ; } ) ; $ table -> column ( 'created_at' ) ; $ table -> column ( 'created_by' , function ( Column $ column ) { $ column -> value = function ( Status $ status ) { if ( $ status -> user instanceof User ) { return $ status -> user -> getRecipientName ( ) ; } else { return HTML :: create ( 'em' , 'None' ) ; } } ; } ) ; } ) ; } 
public function form ( Status $ status ) { return $ this -> form -> of ( 'work-orders.statuses' , function ( FormGrid $ form ) use ( $ status ) { if ( $ status -> exists ) { $ method = 'PATCH' ; $ url = route ( 'maintenance.work-orders.statuses.update' , [ $ status -> getKey ( ) ] ) ; $ form -> submit = 'Save' ; } else { $ method = 'POST' ; $ url = route ( 'maintenance.work-orders.statuses.store' , [ $ status -> getKey ( ) ] ) ; $ form -> submit = 'Create' ; } $ colors = config ( 'maintenance.colors' , [ ] ) ; $ form -> with ( $ status ) ; $ form -> attributes ( compact ( 'method' , 'url' ) ) ; $ form -> fieldset ( function ( Fieldset $ fieldset ) use ( $ colors ) { $ fieldset -> control ( 'input:text' , 'name' ) -> attributes ( [ 'placeholder' => 'ex. Awaiting Parts / Supplies' , ] ) ; $ fieldset -> control ( 'select' , 'color' ) -> options ( $ colors ) -> value ( function ( Status $ status ) { return $ status -> color ; } ) -> attributes ( [ 'class' => 'select2-color' , ] ) ; } ) ; } ) ; } 
public function handle ( ) { $ quantity = $ this -> request -> input ( 'quantity' ) ; $ reason = link_to_route ( 'maintenance.work-orders.show' , 'Used for Work Order' , [ $ this -> workOrder -> getKey ( ) ] ) ; $ this -> stock -> take ( $ quantity , $ reason ) ; 
public function index ( ) { $ priorities = $ this -> presenter -> table ( $ this -> priority ) ; $ navbar = $ this -> presenter -> navbar ( ) ; return view ( 'work-orders.priorities.index' , compact ( 'priorities' , 'navbar' ) ) ; } 
public function store ( PriorityRequest $ request ) { $ priority = $ this -> priority -> newInstance ( ) ; return $ this -> dispatch ( new Store ( $ request , $ priority ) ) ; } 
public function edit ( $ id ) { $ priority = $ this -> priority -> findOrFail ( $ id ) ; $ form = $ this -> presenter -> form ( $ priority ) ; return view ( 'work-orders.priorities.edit' , compact ( 'form' ) ) ; } 
public function update ( PriorityRequest $ request , $ id ) { $ priority = $ this -> priority -> findOrFail ( $ id ) ; return $ this -> dispatch ( new Update ( $ request , $ priority ) ) ; } 
public function handle ( ) { $ this -> metric -> name = $ this -> request -> input ( 'name' , $ this -> metric -> name ) ; $ this -> metric -> symbol = $ this -> request -> input ( 'symbol' , $ this -> metric -> symbol ) ; return $ this -> metric -> save ( ) ; } 
public function scopeStock ( $ query , $ operator = null , $ stock = null ) { if ( $ operator && $ stock ) { return $ query -> whereHas ( 'stocks' , function ( $ query ) use ( $ operator , $ stock ) { if ( $ output = $ this -> getOperator ( $ operator ) ) { return $ query -> where ( 'quantity' , $ output [ 0 ] , $ stock ) ; } else { return $ query ; } } ) ; } return $ query ; } 
public function scopeSku ( $ query , $ sku = null ) { if ( $ sku ) { return $ query -> whereHas ( 'sku' , function ( $ query ) use ( $ sku ) { return $ query -> where ( 'code' , 'LIKE' , '%' . $ sku . '%' ) ; } ) ; } return $ query ; } 
public function getCurrentStockAttribute ( ) { $ stock = $ this -> getTotalStock ( ) ; if ( $ this -> hasMetric ( ) ) { return sprintf ( '%s %s' , $ stock , $ this -> getMetricSymbol ( ) ) ; } return $ stock ; } 
public function getRevisedMetricAttribute ( $ id ) { if ( $ id ) { $ metric = $ this -> metric ( ) -> find ( $ id ) ; if ( $ metric ) { return $ metric -> name ; } } return ; } 
protected function getOperator ( $ string ) { $ allowed_operators = [ '>' , '<' , '=' , '>=' , '<=' ] ; $ output = preg_split ( "/[\[\]]/" , $ string ) ; if ( is_array ( $ output ) ) { if ( array_key_exists ( '1' , $ output ) && array_key_exists ( '2' , $ output ) ) { if ( in_array ( $ output [ 1 ] , $ allowed_operators ) ) { return [ $ output [ 1 ] , $ output [ 2 ] ] ; } } else { return $ output ; } } return false ; } 
public function scopeSort ( $ query , $ field = null , $ sort = null ) { if ( $ field && $ sort ) { $ columns = Schema :: getColumnListing ( $ this -> getTable ( ) ) ; if ( in_array ( $ field , $ columns ) ) { if ( $ sort === 'asc' || $ sort === 'desc' ) { return $ query -> orderBy ( $ field , $ sort ) ; } } } return $ query -> latest ( ) ; } 
public function store ( WorkOrderRequest $ request ) { if ( $ this -> processor -> store ( $ request ) ) { flash ( ) -> success ( 'Success!' , 'Successfully created work order.' ) ; return redirect ( ) -> route ( 'maintenance.work-orders.index' ) ; } else { flash ( ) -> error ( 'Error!' , 'There was an issue creating this work order. Please try again.' ) ; return redirect ( ) -> route ( 'maintenance.work-orders.create' ) ; } } 
public function getFullPathAttribute ( ) { $ config = sprintf ( 'filesystems.%s.root' , $ this -> getDisk ( ) ) ; $ default = storage_path ( 'app' ) ; $ basePath = config ( $ config , $ default ) ; return $ basePath . DIRECTORY_SEPARATOR . $ this -> file_path ; } 
public function index ( ) { $ statuses = $ this -> presenter -> table ( $ this -> status ) ; $ navbar = $ this -> presenter -> navbar ( ) ; return view ( 'work-orders.statuses.index' , compact ( 'statuses' , 'navbar' ) ) ; } 
public function store ( StatusRequest $ request ) { $ status = $ this -> status -> newInstance ( ) ; return $ this -> dispatch ( new Store ( $ request , $ status ) ) ; } 
public function edit ( $ id ) { $ status = $ this -> status -> findOrFail ( $ id ) ; $ form = $ this -> presenter -> form ( $ status ) ; return view ( 'work-orders.statuses.edit' , compact ( 'form' ) ) ; } 
public function update ( StatusRequest $ request , $ id ) { $ status = $ this -> status -> findOrFail ( $ id ) ; return $ this -> dispatch ( new Update ( $ request , $ status ) ) ; } 
public function up ( ) { Schema :: create ( 'inventories' , function ( Blueprint $ table ) { $ table -> increments ( 'id' ) ; $ table -> timestamps ( ) ; $ table -> softDeletes ( ) ; $ table -> integer ( 'category_id' ) -> unsigned ( ) -> nullable ( ) ; $ table -> integer ( 'user_id' ) -> unsigned ( ) -> nullable ( ) ; $ table -> integer ( 'metric_id' ) -> unsigned ( ) ; $ table -> string ( 'name' ) ; $ table -> text ( 'description' ) -> nullable ( ) ; $ table -> foreign ( 'category_id' ) -> references ( 'id' ) -> on ( 'categories' ) -> onUpdate ( 'restrict' ) -> onDelete ( 'set null' ) ; $ table -> foreign ( 'user_id' ) -> references ( 'id' ) -> on ( 'users' ) -> onUpdate ( 'restrict' ) -> onDelete ( 'set null' ) ; $ table -> foreign ( 'metric_id' ) -> references ( 'id' ) -> on ( 'metrics' ) -> onUpdate ( 'restrict' ) -> onDelete ( 'cascade' ) ; } ) ; Schema :: create ( 'inventory_stocks' , function ( Blueprint $ table ) { $ table -> increments ( 'id' ) ; $ table -> timestamps ( ) ; $ table -> softDeletes ( ) ; $ table -> integer ( 'user_id' ) -> unsigned ( ) -> nullable ( ) ; $ table -> integer ( 'inventory_id' ) -> unsigned ( ) ; $ table -> integer ( 'location_id' ) -> unsigned ( ) ; $ table -> decimal ( 'quantity' , 8 , 2 ) -> default ( 0 ) ; $ table -> string ( 'aisle' ) -> nullable ( ) ; $ table -> string ( 'row' ) -> nullable ( ) ; $ table -> string ( 'bin' ) -> nullable ( ) ; $ table -> unique ( [ 'inventory_id' , 'location_id' ] ) ; $ table -> foreign ( 'user_id' ) -> references ( 'id' ) -> on ( 'users' ) -> onUpdate ( 'restrict' ) -> onDelete ( 'set null' ) ; $ table -> foreign ( 'inventory_id' ) -> references ( 'id' ) -> on ( 'inventories' ) -> onUpdate ( 'restrict' ) -> onDelete ( 'cascade' ) ; $ table -> foreign ( 'location_id' ) -> references ( 'id' ) -> on ( 'locations' ) -> onUpdate ( 'restrict' ) -> onDelete ( 'cascade' ) ; } ) ; Schema :: create ( 'inventory_stock_movements' , function ( Blueprint $ table ) { $ table -> increments ( 'id' ) ; $ table -> timestamps ( ) ; $ table -> softDeletes ( ) ; $ table -> integer ( 'stock_id' ) -> unsigned ( ) ; $ table -> integer ( 'user_id' ) -> unsigned ( ) -> nullable ( ) ; $ table -> decimal ( 'before' , 8 , 2 ) -> default ( 0 ) ; $ table -> decimal ( 'after' , 8 , 2 ) -> default ( 0 ) ; $ table -> decimal ( 'cost' , 8 , 2 ) -> default ( 0 ) -> nullable ( ) ; $ table -> string ( 'reason' ) -> nullable ( ) ; $ table -> foreign ( 'stock_id' ) -> references ( 'id' ) -> on ( 'inventory_stocks' ) -> onUpdate ( 'restrict' ) -> onDelete ( 'cascade' ) ; $ table -> foreign ( 'user_id' ) -> references ( 'id' ) -> on ( 'users' ) -> onUpdate ( 'restrict' ) -> onDelete ( 'set null' ) ; } ) ; } 
public function create ( $ itemId ) { $ item = $ this -> inventory -> findOrFail ( $ itemId ) ; $ form = $ this -> presenter -> form ( $ item , $ variant = true ) ; return view ( 'inventory.variants.create' , compact ( 'form' ) ) ; } 
public function store ( InventoryRequest $ request , $ itemId ) { $ item = $ this -> inventory -> findOrFail ( $ itemId ) ; $ variant = $ item -> newVariant ( ) ; $ variant -> name = $ request -> input ( 'name' , $ item -> name ) ; $ variant -> category_id = $ request -> input ( 'category' , $ item -> category_id ) ; $ variant -> metric_id = $ request -> input ( 'metric' , $ item -> metric_id ) ; return $ variant -> save ( ) ; } 
public function create ( $ workOrderId ) { $ workOrder = $ this -> workOrder -> findOrFail ( $ workOrderId ) ; if ( $ workOrder -> isComplete ( ) ) { throw new ReportExistsException ( ) ; } $ form = $ this -> presenter -> form ( $ workOrder , $ this -> report ) ; return view ( 'work-orders.report.create' , compact ( 'form' ) ) ; } 
public function store ( ReportRequest $ request , $ workOrderId ) { $ workOrder = $ this -> workOrder -> findOrFail ( $ workOrderId ) ; $ report = $ this -> report -> newInstance ( ) ; return $ this -> dispatch ( new Store ( $ request , $ workOrder , $ report ) ) ; } 
public function table ( $ workOrder ) { return $ this -> table -> of ( 'work-orders' , function ( TableGrid $ table ) use ( $ workOrder ) { $ table -> with ( $ workOrder ) -> paginate ( $ this -> perPage ) ; $ table -> attributes ( [ 'class' => 'table table-hover table-striped' , ] ) ; $ table -> column ( 'ID' , 'id' ) ; $ table -> column ( 'subject' , function ( Column $ column ) { $ column -> value = function ( WorkOrder $ workOrder ) { return link_to_route ( 'maintenance.work-orders.show' , $ workOrder -> subject , [ $ workOrder -> getKey ( ) ] ) ; } ; } ) ; $ table -> column ( 'Created At' , 'created_at' ) ; $ table -> column ( 'created_by' , function ( Column $ column ) { $ column -> value = function ( WorkOrder $ workOrder ) { return $ workOrder -> user -> fullname ; } ; } ) ; $ table -> column ( 'priority' , function ( Column $ column ) { $ column -> value = function ( WorkOrder $ workOrder ) { if ( $ workOrder -> priority instanceof Priority ) { return $ workOrder -> priority -> getLabel ( ) ; } return HTML :: create ( 'em' , 'None' ) ; } ; } ) ; $ table -> column ( 'status' , function ( Column $ column ) { $ column -> value = function ( WorkOrder $ workOrder ) { if ( $ workOrder -> status instanceof Status ) { return $ workOrder -> status -> getLabel ( ) ; } return HTML :: create ( 'em' , 'None' ) ; } ; } ) ; } ) ; } 
public function tableAssigned ( $ workOrder ) { $ workOrder = $ workOrder -> whereHas ( 'assignments' , function ( Builder $ query ) { $ query -> where ( 'to_user_id' , auth ( ) -> id ( ) ) ; } ) ; return $ this -> table ( $ workOrder ) ; } 
public function tableSessions ( WorkOrder $ workOrder ) { $ presenter = new WorkOrderSessionPresenter ( $ this -> form , $ this -> table ) ; return $ presenter -> tablePerWorker ( $ workOrder ) ; } 
public function form ( WorkOrder $ workOrder ) { return $ this -> form -> of ( 'work-orders' , function ( FormGrid $ form ) use ( $ workOrder ) { if ( $ workOrder -> exists ) { $ method = 'PATCH' ; $ url = route ( 'maintenance.work-orders.update' , [ $ workOrder -> getKey ( ) ] ) ; $ form -> submit = 'Save' ; } else { $ method = 'POST' ; $ url = route ( 'maintenance.work-orders.store' ) ; $ form -> submit = 'Create' ; } $ form -> with ( $ workOrder ) ; $ form -> attributes ( compact ( 'method' , 'url' ) ) ; $ form -> fieldset ( function ( Fieldset $ fieldset ) { $ fieldset -> control ( 'select' , 'category' ) -> value ( function ( WorkOrder $ workOrder ) { return $ workOrder -> category_id ; } ) -> options ( function ( ) { return Category :: getSelectHierarchy ( 'work-orders' ) ; } ) ; $ fieldset -> control ( 'select' , 'location' ) -> value ( function ( WorkOrder $ workOrder ) { return $ workOrder -> location_id ; } ) -> options ( function ( ) { return Location :: getSelectHierarchy ( ) ; } ) ; $ fieldset -> control ( 'select' , 'status' ) -> options ( function ( ) { $ statuses = Status :: all ( ) -> pluck ( 'name' , 'id' ) ; $ statuses [ 0 ] = 'None' ; return $ statuses ; } ) ; $ fieldset -> control ( 'select' , 'priority' ) -> value ( function ( WorkOrder $ workOrder ) { return $ workOrder -> priority_id ; } ) -> options ( function ( ) { $ priorities = Priority :: all ( ) -> pluck ( 'name' , 'id' ) ; $ priorities [ 0 ] = 'None' ; return $ priorities ; } ) ; $ fieldset -> control ( 'select' , 'assets[]' ) -> label ( 'Assets' ) -> options ( function ( ) { return Asset :: all ( ) -> pluck ( 'name' , 'id' ) ; } ) -> attributes ( [ 'class' => 'select2' , 'multiple' => true , ] ) ; $ fieldset -> control ( 'input:text' , 'subject' ) -> attributes ( [ 'placeholder' => 'ex. Worked on HVAC' , ] ) ; $ fieldset -> control ( 'input:textarea' , 'description' ) ; } ) ; } ) ; } 
public function formComment ( WorkOrder $ workOrder , Comment $ comment ) { $ presenter = new WorkOrderCommentPresenter ( $ this -> form , $ this -> table ) ; return $ presenter -> form ( $ workOrder , $ comment ) ; } 
public function handle ( Filesystem $ filesystem ) { $ files = $ this -> request -> file ( 'files' ) ; if ( is_array ( $ files ) ) { $ uploaded = [ ] ; foreach ( $ files as $ file ) { 
public function table ( Asset $ asset ) { return $ this -> table -> of ( 'assets' , function ( TableGrid $ table ) use ( $ asset ) { $ table -> with ( $ asset ) -> paginate ( $ this -> perPage ) ; $ table -> attributes ( [ 'class' => 'table table-hover table-striped' , ] ) ; $ table -> column ( 'tag' ) ; $ table -> column ( 'name' , function ( Column $ column ) { $ column -> value = function ( Asset $ asset ) { return link_to_route ( 'maintenance.assets.show' , $ asset -> name , [ $ asset -> getKey ( ) ] ) ; } ; } ) ; $ table -> column ( 'category' , function ( Column $ column ) { $ column -> value = function ( Asset $ asset ) { return $ asset -> category -> trail ; } ; } ) ; $ table -> column ( 'location' , function ( Column $ column ) { $ column -> value = function ( Asset $ asset ) { return $ asset -> location -> trail ; } ; } ) ; $ table -> column ( 'created_at' ) ; } ) ; } 
public function form ( Asset $ asset ) { return $ this -> form -> of ( 'assets' , function ( FormGrid $ form ) use ( $ asset ) { if ( $ asset -> exists ) { $ method = 'PATCH' ; $ route = route ( 'maintenance.assets.update' , [ $ asset -> getKey ( ) ] ) ; $ form -> submit = 'Save' ; } else { $ method = 'POST' ; $ route = route ( 'maintenance.assets.store' ) ; $ form -> submit = 'Create' ; } $ categories = Category :: getSelectHierarchy ( 'assets' ) ; $ locations = Location :: getSelectHierarchy ( ) ; $ form -> resource ( $ this , $ route , $ asset , compact ( 'method' ) ) ; $ form -> fieldset ( function ( Fieldset $ fieldset ) use ( $ categories , $ locations ) { $ fieldset -> control ( 'input:text' , 'tag' ) -> attributes ( [ 'placeholder' => 'ex. 100010' , ] ) ; $ fieldset -> control ( 'input:text' , 'name' ) -> attributes ( [ 'placeholder' => 'ex. Ford F150' , ] ) ; $ fieldset -> control ( 'select' , 'category' ) -> options ( $ categories ) -> value ( function ( Asset $ asset ) { return $ asset -> category_id ; } ) ; $ fieldset -> control ( 'select' , 'location' ) -> options ( $ locations ) -> value ( function ( Asset $ asset ) { return $ asset -> location_id ; } ) ; $ fieldset -> control ( 'input:textarea' , 'description' ) ; $ fieldset -> control ( 'select' , 'condition' ) -> options ( trans ( 'assets.conditions' ) ) -> value ( function ( Asset $ asset ) { return $ asset -> condition_number ; } ) ; $ fieldset -> control ( 'input:text' , 'vendor' ) -> attributes ( [ 'placeholder' => 'ex. Ford' , ] ) ; $ fieldset -> control ( 'input:text' , 'make' ) -> attributes ( [ 'placeholder' => 'ex. F' , ] ) ; $ fieldset -> control ( 'input:text' , 'model' ) -> attributes ( [ 'placeholder' => 'ex. 150' , ] ) ; $ fieldset -> control ( 'input:text' , 'serial' ) -> attributes ( [ 'placeholder' => 'ex. 153423-13432432-2342423' , ] ) ; $ fieldset -> control ( 'input:text' , 'size' ) -> attributes ( [ 'placeholder' => 'ex. 1905 x 2463' , ] ) ; $ fieldset -> control ( 'input:text' , 'weight' ) -> attributes ( [ 'placeholder' => 'ex. 1 Ton' , ] ) ; $ fieldset -> control ( 'input:text' , 'acquired_at' ) -> attributes ( [ 'class' => 'pickadate' , 'placeholder' => 'Click to Select a Date' , ] ) ; $ fieldset -> control ( 'input:text' , 'end_of_life' ) -> attributes ( [ 'class' => 'pickadate' , 'placeholder' => 'Click to Select a Date' , ] ) ; } ) ; } ) ; } 
public function table ( $ item ) { return $ this -> table -> of ( 'inventory' , function ( TableGrid $ table ) use ( $ item ) { $ table -> with ( $ item ) -> paginate ( $ this -> perPage ) ; $ table -> attributes ( [ 'class' => 'table table-hover table-striped' , ] ) ; $ table -> column ( 'ID' , 'id' ) ; $ table -> column ( 'sku' , function ( Column $ column ) { $ column -> label = 'SKU' ; $ column -> value = function ( Inventory $ item ) { return $ item -> getSku ( ) ; } ; } ) ; $ table -> column ( 'name' , function ( Column $ column ) { $ column -> value = function ( Inventory $ item ) { return link_to_route ( 'maintenance.inventory.show' , $ item -> name , [ $ item -> getKey ( ) ] ) ; } ; } ) ; $ table -> column ( 'category' , function ( Column $ column ) { $ column -> value = function ( Inventory $ item ) { return $ item -> category -> trail ; } ; } ) ; $ table -> column ( 'current_stock' , function ( Column $ column ) { $ column -> value = function ( Inventory $ item ) { return $ item -> getTotalStock ( ) ; } ; } ) ; } ) ; } 
public function tableStocks ( Inventory $ item ) { return ( new InventoryStockPresenter ( $ this -> form , $ this -> table ) ) -> table ( $ item ) ; } 
public function form ( Inventory $ inventory , $ variant = false ) { return $ this -> form -> of ( 'inventory' , function ( FormGrid $ form ) use ( $ inventory , $ variant ) { if ( $ inventory -> exists ) { if ( $ variant === true ) { 
public function navbarStocks ( Inventory $ item ) { return ( new InventoryStockPresenter ( $ this -> form , $ this -> table ) ) -> navbar ( $ item ) ; } 
public function store ( AttachmentRequest $ request , $ workOrderId ) { if ( $ uploaded = $ this -> processor -> store ( $ request , $ workOrderId ) ) { $ count = ( is_array ( $ uploaded ) ? count ( $ uploaded ) : 0 ) ; flash ( ) -> success ( 'Success!' , "Successfully uploaded $count file(s)." ) ; return redirect ( ) -> route ( 'maintenance.work-orders.attachments.index' , [ $ workOrderId ] ) ; } else { flash ( ) -> error ( 'Error!' , 'There was an issue uploading the files you selected. Please try again.' ) ; return redirect ( ) -> route ( 'maintenance.work-orders.attachments.create' , [ $ workOrderId ] ) ; } } 
public function update ( AttachmentUpdateRequest $ request , $ workOrderId , $ attachmentId ) { if ( $ this -> processor -> update ( $ request , $ workOrderId , $ attachmentId ) ) { flash ( ) -> success ( 'Success!' , 'Successfully updated attachment.' ) ; return redirect ( ) -> route ( 'maintenance.work-orders.attachments.show' , [ $ workOrderId , $ attachmentId ] ) ; } else { flash ( ) -> error ( 'Error!' , 'There was an issue updating this attachment. Please try again.' ) ; return redirect ( ) -> route ( 'maintenance.work-orders.attachments.edit' , [ $ workOrderId , $ attachmentId ] ) ; } } 
public function destroy ( $ workOrderId , $ attachmentId ) { if ( $ this -> processor -> destroy ( $ workOrderId , $ attachmentId ) ) { flash ( ) -> success ( 'Success!' , 'Successfully deleted attachment.' ) ; return redirect ( ) -> route ( 'maintenance.work-orders.attachments.index' , [ $ workOrderId ] ) ; } else { flash ( ) -> error ( 'Error!' , 'There was an issue deleting this attachment. Please try again.' ) ; return redirect ( ) -> route ( 'maintenance.work-orders.attachments.show' , [ $ workOrderId , $ attachmentId ] ) ; } } 
public function handle ( ) { 
public function handle ( ) { $ session = $ this -> workOrder -> getLastUsersSession ( auth ( ) -> id ( ) ) ; $ session -> out = $ session -> freshTimestamp ( ) ; return $ session -> save ( ) ; } 
public function table ( Metric $ metric ) { return $ this -> table -> of ( 'metrics' , function ( TableGrid $ table ) use ( $ metric ) { $ table -> with ( $ metric ) -> paginate ( $ this -> perPage ) ; $ table -> column ( 'name' ) ; $ table -> column ( 'symbol' ) ; $ table -> column ( 'Created' , 'created_at' ) ; } ) ; } 
public function tableHistory ( $ for , MorphMany $ revisions ) { return $ this -> table -> of ( "$for.revisions" , function ( TableGrid $ table ) use ( $ revisions ) { $ table -> with ( $ revisions ) -> paginate ( $ this -> perPage ) ; $ table -> pageName = 'history' ; $ table -> column ( 'user_responsible' , function ( Column $ column ) { $ column -> value = function ( Revision $ revision ) { $ user = $ revision -> getUserResponsible ( ) ; if ( $ user instanceof User ) { return $ user -> getRecipientName ( ) ; } return HTML :: create ( 'em' , 'None' ) ; } ; } ) ; $ table -> column ( 'changed' , function ( Column $ column ) { $ column -> value = function ( Revision $ revision ) { return $ revision -> getColumnName ( ) ; } ; } ) ; $ table -> column ( 'from' , function ( Column $ column ) { $ column -> value = function ( Revision $ revision ) { $ old = $ revision -> getOldValue ( ) ; if ( is_null ( $ old ) ) { return HTML :: create ( 'em' , 'None' ) ; } return $ old ; } ; } ) ; $ table -> column ( 'to' , function ( Column $ column ) { $ column -> value = function ( Revision $ revision ) { $ new = $ revision -> getNewValue ( ) ; if ( is_null ( $ new ) ) { return HTML :: create ( 'em' , 'None' ) ; } return $ new ; } ; } ) ; $ table -> column ( 'On' , 'created_at' ) ; } ) ; } 
public function store ( ImageRequest $ request , $ id ) { $ asset = $ this -> asset -> find ( $ id ) ; $ attachments = $ this -> image -> upload ( $ request , $ asset , $ asset -> images ( ) ) ; if ( $ attachments ) { $ message = 'Successfully uploaded files.' ; return redirect ( ) -> route ( 'maintenance.assets.images.index' , [ $ asset -> id ] ) -> withSuccess ( $ message ) ; } else { $ message = 'There was an issue uploading the files you selected. Please try again.' ; return redirect ( ) -> route ( 'maintenance.assets.images.create' , [ $ id ] ) -> withErrors ( $ message ) ; } } 
public function show ( $ id , $ imageId ) { $ asset = $ this -> asset -> find ( $ id ) ; $ image = $ asset -> images ( ) -> find ( $ imageId ) ; if ( $ image ) { return view ( 'assets.images.show' , compact ( 'asset' , 'image' ) ) ; } abort ( 404 ) ; } 
public function update ( AttachmentUpdateRequest $ request , $ id , $ imageId ) { $ asset = $ this -> asset -> find ( $ id ) ; $ image = $ this -> image -> update ( $ request , $ asset -> images ( ) , $ imageId ) ; if ( $ image ) { $ message = 'Successfully updated image.' ; return redirect ( ) -> route ( 'maintenance.assets.images.show' , [ $ asset -> id , $ image -> id ] ) -> withSuccess ( $ message ) ; } else { $ message = 'There was an issue updating this image. Please try again.' ; return redirect ( ) -> route ( 'maintenance.assets.images.show' , [ $ id , $ imageId ] ) -> withErrors ( $ message ) ; } } 
public function destroy ( $ id , $ imageId ) { $ asset = $ this -> asset -> find ( $ id ) ; $ image = $ asset -> images ( ) -> find ( $ imageId ) ; if ( $ image && $ image -> delete ( ) ) { $ message = 'Successfully deleted attachment.' ; return redirect ( ) -> route ( 'maintenance.assets.images.index' , [ $ asset -> id ] ) -> withSuccess ( $ message ) ; } else { $ message = 'There was an issue deleting this attachment. Please try again.' ; return redirect ( ) -> route ( 'maintenance.assets.images.show' , [ $ asset -> id , $ image -> id ] ) -> withErrors ( $ message ) ; } } 
public function download ( $ id , $ imageId ) { $ asset = $ this -> asset -> find ( $ id ) ; $ image = $ asset -> images ( ) -> find ( $ imageId ) ; if ( $ image ) { return response ( ) -> download ( $ image -> download_path ) ; } abort ( 404 ) ; } 
public function index ( ) { $ metrics = $ this -> presenter -> table ( $ this -> metric ) ; $ navbar = $ this -> presenter -> navbar ( ) ; return view ( 'metrics.index' , compact ( 'metrics' , 'navbar' ) ) ; } 
public function store ( MetricRequest $ request ) { $ metric = $ this -> metric -> newInstance ( ) ; return $ this -> dispatch ( new Store ( $ request , $ metric ) ) ; } 
public function edit ( $ id ) { $ metric = $ this -> metric -> findOrFail ( $ id ) ; $ form = $ this -> presenter -> form ( $ metric ) ; return view ( 'metrics.edit' , compact ( 'form' ) ) ; } 
public function index ( ) { $ navbar = $ this -> presenter -> navbar ( ) ; $ assets = $ this -> presenter -> table ( $ this -> asset ) ; return view ( 'assets.index' , compact ( 'assets' , 'navbar' ) ) ; } 
public function store ( AssetRequest $ request ) { $ asset = $ this -> asset -> newInstance ( ) ; $ asset -> user_id = $ this -> guard -> id ( ) ; $ asset -> tag = $ request -> input ( 'tag' ) ; $ asset -> category_id = $ request -> input ( 'category' ) ; $ asset -> location_id = $ request -> input ( 'location' ) ; $ asset -> name = $ request -> input ( 'name' ) ; $ asset -> condition = $ request -> input ( 'condition' ) ; $ asset -> vendor = $ request -> input ( 'vendor' ) ; $ asset -> make = $ request -> input ( 'make' ) ; $ asset -> model = $ request -> input ( 'model' ) ; $ asset -> size = $ request -> input ( 'size' ) ; $ asset -> weight = $ request -> input ( 'weight' ) ; $ asset -> serial = $ request -> input ( 'serial' ) ; $ asset -> acquired_at = $ request -> formatDateWithTime ( $ request -> input ( 'acquired_at' ) ) ; $ asset -> end_of_life = $ request -> formatDateWithTime ( $ request -> input ( 'end_of_life' ) ) ; return $ asset -> save ( ) ; } 
public function edit ( $ id ) { $ asset = $ this -> asset -> findOrFail ( $ id ) ; $ form = $ this -> presenter -> form ( $ asset ) ; return view ( 'assets.edit' , compact ( 'form' ) ) ; } 
public function update ( AssetRequest $ request , $ id ) { $ asset = $ this -> asset -> findOrFail ( $ id ) ; $ asset -> tag = $ request -> input ( 'tag' ) ; $ asset -> category_id = $ request -> input ( 'category' ) ; $ asset -> location_id = $ request -> input ( 'location' ) ; $ asset -> name = $ request -> input ( 'name' ) ; $ asset -> condition = $ request -> input ( 'condition' ) ; $ asset -> vendor = $ request -> input ( 'vendor' ) ; $ asset -> make = $ request -> input ( 'make' ) ; $ asset -> model = $ request -> input ( 'model' ) ; $ asset -> size = $ request -> input ( 'size' ) ; $ asset -> weight = $ request -> input ( 'weight' ) ; $ asset -> serial = $ request -> input ( 'serial' ) ; $ asset -> acquired_at = $ request -> formatDateWithTime ( $ request -> input ( 'acquired_at' ) ) ; $ asset -> end_of_life = $ request -> formatDateWithTime ( $ request -> input ( 'end_of_life' ) ) ; return $ asset -> save ( ) ; } 
public function handle ( ) { $ this -> attachment -> name = $ this -> request -> input ( 'name' , $ this -> attachment -> name ) ; return $ this -> attachment -> save ( ) ; } 
public function scopeId ( $ query , $ id = null ) { if ( ! is_null ( $ id ) ) { $ query -> where ( 'id' , $ id ) ; } return $ query ; } 
public function response ( ) { if ( $ this -> isAjax ( ) ) { if ( $ this -> errors ) { return $ this -> responseJson ( [ 'errors' => $ this -> errors , ] ) ; } else { return $ this -> responseJson ( [ 'message' => $ this -> message , 'messageType' => $ this -> messageType , 'redirect' => $ this -> redirect , ] ) ; } } else { if ( $ this -> errors ) { return redirect ( $ this -> redirect ) -> withInput ( ) -> withErrors ( $ this -> errors ) ; } else { return redirect ( $ this -> redirect ) -> withInput ( ) -> with ( 'message' , $ this -> message ) -> with ( 'messageType' , $ this -> messageType ) ; } } } 
protected function input ( $ name , $ clean = false ) { if ( $ this -> inputHas ( $ name ) ) { if ( $ clean ) { return $ this -> clean ( Input :: get ( $ name ) ) ; } else { return Input :: get ( $ name ) ; } } return ; } 
public static function getSelectHierarchy ( $ belongsTo = null ) { $ query = static :: roots ( ) ; if ( ! is_null ( $ belongsTo ) ) { $ query -> where ( 'belongs_to' , $ belongsTo ) ; } $ roots = $ query -> with ( 'children' ) -> get ( ) ; $ options = [ 0 => 'None' ] ; foreach ( $ roots as $ root ) { $ options = $ options + static :: getRenderedNode ( $ root ) ; } return $ options ; } 
public static function getRenderedNode ( Node $ node ) { $ options = [ ] ; if ( $ node -> isRoot ( ) ) { $ name = $ node -> name ; } else { $ depth = str_repeat ( '--' , $ node -> depth ) ; $ name = sprintf ( '%s %s' , $ depth , $ node -> name ) ; } $ options [ $ node -> id ] = $ name ; if ( $ node -> children ( ) -> count ( ) > 0 ) { foreach ( $ node -> children as $ child ) { $ options = $ options + static :: getRenderedNode ( $ child ) ; } } return $ options ; } 
public function handle ( ) { $ session = new WorkOrderSession ( ) ; $ session -> user_id = auth ( ) -> id ( ) ; $ session -> work_order_id = $ this -> workOrder -> id ; $ session -> in = $ session -> freshTimestamp ( ) ; if ( $ this -> workOrder -> sessions -> count ( ) === 0 || is_null ( $ this -> workOrder -> started_at ) ) { $ this -> workOrder -> update ( [ 'started_at' => $ this -> workOrder -> freshTimestamp ( ) ] ) ; } return $ session -> save ( ) ; } 
public function handle ( ) { $ this -> priority -> name = $ this -> request -> input ( 'name' , $ this -> priority -> name ) ; $ this -> priority -> color = $ this -> request -> input ( 'color' , $ this -> priority -> color ) ; return $ this -> priority -> save ( ) ; } 
public function handle ( ) { $ this -> workOrder -> category_id = $ this -> request -> input ( 'category' ) ; $ this -> workOrder -> location_id = $ this -> request -> input ( 'location' ) ; $ this -> workOrder -> status_id = $ this -> request -> input ( 'status' ) ; $ this -> workOrder -> priority_id = $ this -> request -> input ( 'priority' ) ; $ this -> workOrder -> subject = $ this -> request -> input ( 'subject' ) ; $ this -> workOrder -> description = $ this -> request -> clean ( $ this -> request -> input ( 'description' ) ) ; $ this -> workOrder -> started_at = $ this -> request -> input ( 'started_at' ) ; $ this -> workOrder -> completed_at = $ this -> request -> input ( 'completed_at' ) ; if ( $ this -> workOrder -> save ( ) ) { $ assets = $ this -> request -> input ( 'assets' , [ ] ) ; if ( is_array ( $ assets ) && count ( $ assets ) > 0 ) { $ this -> workOrder -> assets ( ) -> sync ( $ assets ) ; } return true ; } return false ; } 
public function boot ( Factory $ view ) { foreach ( $ this -> composers as $ callback => $ views ) { $ view -> composer ( $ views , $ callback ) ; } } 
public function run ( ) { $ metrics = $ this -> getSeedData ( ) ; foreach ( $ metrics as $ metric ) { $ this -> metric -> model ( ) -> create ( $ metric ) ; } } 
public function handle ( ) { 
public function handle ( Filesystem $ filesystem ) { try { if ( $ filesystem -> delete ( $ this -> attachment -> getStorageFilePath ( ) ) ) { return $ this -> attachment -> delete ( ) ; } } catch ( FileNotFoundException $ e ) { 
public function index ( $ itemId ) { $ item = $ this -> inventory -> findOrFail ( $ itemId ) ; $ navbar = $ this -> presenter -> navbar ( $ item ) ; $ stocks = $ this -> presenter -> table ( $ item ) ; return view ( 'inventory.stocks.index' , compact ( 'stocks' , 'navbar' ) ) ; } 
public function create ( $ itemId ) { $ item = $ this -> inventory -> findOrFail ( $ itemId ) ; $ form = $ this -> presenter -> form ( $ item , $ item -> stocks ( ) -> getRelated ( ) ) ; return view ( 'inventory.stocks.create' , compact ( 'form' ) ) ; } 
public function store ( InventoryStockRequest $ request , $ itemId ) { $ item = $ this -> inventory -> findOrFail ( $ itemId ) ; $ stock = $ item -> stocks ( ) -> getRelated ( ) ; return $ this -> dispatch ( new Store ( $ request , $ item , $ stock ) ) ; } 
public function show ( $ itemId , $ stockId ) { $ item = $ this -> inventory -> findOrFail ( $ itemId ) ; $ stock = $ item -> stocks ( ) -> findOrFail ( $ stockId ) ; $ movements = $ this -> presenter -> tableMovements ( $ item , $ stock ) ; return view ( 'inventory.stocks.show' , compact ( 'item' , 'stock' , 'movements' ) ) ; } 
public function edit ( $ itemId , $ stockId ) { $ item = $ this -> inventory -> findOrFail ( $ itemId ) ; $ stock = $ item -> stocks ( ) -> findOrFail ( $ stockId ) ; $ form = $ this -> presenter -> form ( $ item , $ stock ) ; return view ( 'inventory.stocks.edit' , compact ( 'form' ) ) ; } 
public function update ( InventoryStockRequest $ request , $ itemId , $ stockId ) { $ item = $ this -> inventory -> findOrFail ( $ itemId ) ; $ stock = $ item -> stocks ( ) -> findOrFail ( $ stockId ) ; return $ this -> dispatch ( new Update ( $ request , $ item , $ stock ) ) ; } 
public function destroy ( $ itemId , $ stockId ) { $ item = $ this -> inventory -> findOrFail ( $ itemId ) ; $ stock = $ item -> stocks ( ) -> findOrFail ( $ stockId ) ; return $ stock -> delete ( ) ; } 
public function up ( ) { Schema :: create ( 'asset_manuals' , function ( Blueprint $ table ) { $ table -> integer ( 'asset_id' ) -> unsigned ( ) ; $ table -> integer ( 'attachment_id' ) -> unsigned ( ) ; $ table -> foreign ( 'asset_id' ) -> references ( 'id' ) -> on ( 'assets' ) -> onUpdate ( 'restrict' ) -> onDelete ( 'cascade' ) ; $ table -> foreign ( 'attachment_id' ) -> references ( 'id' ) -> on ( 'attachments' ) -> onUpdate ( 'restrict' ) -> onDelete ( 'cascade' ) ; } ) ; Schema :: create ( 'asset_images' , function ( Blueprint $ table ) { $ table -> integer ( 'asset_id' ) -> unsigned ( ) ; $ table -> integer ( 'attachment_id' ) -> unsigned ( ) ; $ table -> foreign ( 'asset_id' ) -> references ( 'id' ) -> on ( 'assets' ) -> onUpdate ( 'restrict' ) -> onDelete ( 'cascade' ) ; $ table -> foreign ( 'attachment_id' ) -> references ( 'id' ) -> on ( 'attachments' ) -> onUpdate ( 'restrict' ) -> onDelete ( 'cascade' ) ; } ) ; } 
public function index ( $ id ) { $ asset = $ this -> asset -> model ( ) -> findOrFail ( $ id ) ; return view ( 'assets.meters.index' , compact ( 'asset' ) ) ; } 
public function create ( $ id ) { $ asset = $ this -> asset -> model ( ) -> findOrFail ( $ id ) ; return view ( 'assets.meters.create' , compact ( 'asset' ) ) ; } 
public function store ( MeterRequest $ request , $ id ) { $ meter = $ this -> meter -> create ( $ request , $ id ) ; if ( $ meter ) { $ message = 'Successfully created meter.' ; return redirect ( ) -> route ( 'maintenance.assets.meters.index' , [ $ id ] ) -> withSuccess ( $ message ) ; } else { $ message = 'There was an issue creating a meter. Please try again.' ; return redirect ( ) -> route ( 'maintenance.assets.meters.create' , [ $ id ] ) -> withErrors ( $ message ) ; } } 
public function show ( $ id , $ meterId ) { $ asset = $ this -> asset -> model ( ) -> findOrFail ( $ id ) ; $ meter = $ asset -> meters ( ) -> findOrFail ( $ meterId ) ; return view ( 'assets.meters.show' , compact ( 'asset' , 'meter' ) ) ; } 
public function edit ( $ id , $ meterId ) { $ asset = $ this -> asset -> model ( ) -> findOrFail ( $ id ) ; $ meter = $ asset -> meters ( ) -> findOrFail ( $ meterId ) ; $ lastReading = $ meter -> getLastReading ( ) ; return view ( 'assets.meters.edit' , compact ( 'asset' , 'meter' , 'lastReading' ) ) ; } 
public function update ( MeterRequest $ request , $ id , $ meterId ) { $ meter = $ this -> meter -> update ( $ request , $ id , $ meterId ) ; if ( $ meter ) { $ message = 'Successfully updated meter.' ; return redirect ( ) -> route ( 'maintenance.assets.meters.show' , [ $ id , $ meter -> id ] ) -> withSuccess ( $ message ) ; } else { $ message = 'There was an issue updating this meter. Please try again.' ; return redirect ( ) -> route ( 'maintenance.assets.meters.edit' , [ $ id , $ meterId ] ) -> withErrors ( $ message ) ; } } 
public function destroy ( $ id , $ meterId ) { $ asset = $ this -> asset -> model ( ) -> findOrFail ( $ id ) ; $ meter = $ asset -> meters ( ) -> findOrFail ( $ meterId ) ; if ( $ meter -> delete ( ) ) { $ message = 'Successfully deleted meter.' ; return redirect ( ) -> route ( 'maintenance.assets.meters.index' , [ $ id ] ) -> withSuccess ( $ message ) ; } else { $ message = 'There was an issue deleting this meter. Please try again.' ; return redirect ( ) -> route ( 'maintenance.assets.meters.show' , [ $ id , $ meterId ] ) -> withErrors ( $ message ) ; } } 
public function store ( $ workOrderId ) { if ( $ this -> workOrderNotificationValidator -> passes ( ) ) { $ workOrder = $ this -> workOrder -> find ( $ workOrderId ) ; $ data = $ this -> inputAll ( ) ; $ data [ 'work_order_id' ] = $ workOrder -> id ; $ this -> workOrderNotification -> setInput ( $ data ) -> create ( ) ; $ this -> message = 'Successfully updated notifications' ; $ this -> messageType = 'success' ; $ this -> redirect = route ( 'maintenance.work-orders.show' , [ $ workOrder -> id ] ) ; } else { $ this -> errors = $ this -> workOrderNotificationValidator -> getErrors ( ) ; $ this -> redirect = route ( 'maintenance.work-orders.show' , [ $ workOrderId ] ) ; } return $ this -> response ( ) ; } 
public function update ( $ workOrderId , $ notificationId ) { if ( $ this -> workOrderNotificationValidator -> passes ( ) ) { $ workOrder = $ this -> workOrder -> find ( $ workOrderId ) ; $ notifications = $ this -> workOrderNotification -> find ( $ notificationId ) ; $ data = $ this -> inputAll ( ) ; $ data [ 'work_order_id' ] = $ workOrder -> id ; $ this -> workOrderNotification -> setInput ( $ data ) -> update ( $ notifications -> id ) ; $ this -> message = 'Successfully updated notifications' ; $ this -> messageType = 'success' ; $ this -> redirect = route ( 'maintenance.work-orders.show' , [ $ workOrder -> id ] ) ; } else { $ this -> errors = $ this -> workOrderNotificationValidator -> getErrors ( ) ; $ this -> redirect = route ( 'maintenance.work-orders.show' , [ $ workOrderId ] ) ; } return $ this -> response ( ) ; } 
public function startedAtFormatted ( ) { if ( $ this -> entity -> started_at ) { $ date = new \ DateTime ( ) ; $ date -> setTimestamp ( strtotime ( $ this -> entity -> started_at ) ) ; return $ date -> format ( 'M dS Y - h:ia' ) ; } return ; } 
public function completedAtFormatted ( ) { if ( $ this -> entity -> completed_at ) { $ date = new \ DateTime ( ) ; $ date -> setTimestamp ( strtotime ( $ this -> entity -> completed_at ) ) ; return $ date -> format ( 'M dS Y - h:ia' ) ; } return ; } 
public function handle ( ) { $ this -> workRequest -> subject = $ this -> request -> input ( 'subject' , $ this -> workRequest -> subject ) ; $ this -> workRequest -> best_time = $ this -> request -> input ( 'best_time' , $ this -> workRequest -> best_time ) ; $ this -> workRequest -> description = $ this -> request -> clean ( $ this -> request -> input ( 'description' , $ this -> workRequest -> description ) ) ; return $ this -> workRequest -> save ( ) ; } 
public function index ( ) { $ workOrders = $ this -> presenter -> tableAssigned ( $ this -> workOrder ) ; $ navbar = $ this -> presenter -> navbar ( ) ; return view ( 'work-orders.assigned.index' , compact ( 'workOrders' , 'navbar' ) ) ; } 
public function form ( WorkOrder $ workOrder , Comment $ comment ) { return $ this -> form -> of ( 'work-orders.comments' , function ( FormGrid $ form ) use ( $ workOrder , $ comment ) { if ( $ comment -> exists ) { $ method = 'PATCH' ; $ url = route ( 'work-orders.comments.update' , [ $ workOrder -> getKey ( ) , $ comment -> getKey ( ) ] ) ; $ form -> submit = 'Save' ; } else { $ method = 'POST' ; $ url = route ( 'work-orders.comments.store' , [ $ workOrder -> getKey ( ) ] ) ; $ form -> submit = 'Create' ; } $ form -> attributes ( compact ( 'method' , 'url' ) ) ; $ form -> with ( $ comment ) ; $ form -> fieldset ( function ( Fieldset $ fieldset ) { $ fieldset -> control ( 'input:text' , 'content' ) ; } ) ; } ) ; } 
public function getHours ( ) { if ( array_key_exists ( 'out' , $ this -> attributes ) ) { if ( $ this -> attributes [ 'out' ] ) { $ hours = abs ( round ( ( strtotime ( $ this -> attributes [ 'in' ] ) - strtotime ( $ this -> attributes [ 'out' ] ) ) / 3600 , 2 ) ) ; return $ hours ; } } return ; } 
public function handle ( ) { $ this -> stock -> user_id = auth ( ) -> id ( ) ; $ this -> stock -> inventory_id = $ this -> inventory -> getKey ( ) ; $ this -> stock -> location_id = $ this -> request -> input ( 'location' ) ; $ this -> stock -> quantity = $ this -> request -> input ( 'quantity' ) ; $ this -> stock -> cost = $ this -> request -> input ( 'cost' ) ; $ this -> stock -> reason = $ this -> request -> input ( 'reason' ) ; return $ this -> stock -> save ( ) ; } 
public function startFormatted ( Event $ apiObject ) { $ start = new \ DateTime ( ) ; $ start -> setTimestamp ( strtotime ( $ apiObject -> start ) ) ; if ( $ apiObject -> all_day ) { return $ start -> format ( 'M dS Y' ) ; } else { return $ start -> format ( 'M dS Y - h:ia' ) ; } } 
public function startDateFormatted ( Event $ apiObject ) { $ start = new \ DateTime ( ) ; $ start -> setTimestamp ( strtotime ( $ apiObject -> start ) ) ; return $ start -> format ( 'm/d/Y' ) ; } 
public function endFormatted ( Event $ apiObject ) { $ end = new \ DateTime ( ) ; $ end -> setTimestamp ( strtotime ( $ apiObject -> end ) ) ; if ( $ apiObject -> all_day ) { return $ end -> format ( 'M dS Y' ) ; } return $ end -> format ( 'M dS Y - h:ia' ) ; } 
public function endDateFormatted ( Event $ apiObject ) { $ end = new \ DateTime ( ) ; $ end -> setTimestamp ( strtotime ( $ apiObject -> start ) ) ; return $ end -> format ( 'm/d/Y' ) ; } 
public function endTimeFormatted ( Event $ apiObject ) { if ( ! $ apiObject -> all_day ) { $ end = new \ DateTime ( ) ; $ end -> setTimestamp ( strtotime ( $ apiObject -> start ) ) ; return $ end -> format ( 'h:i A' ) ; } return ; } 
public function recurFrequencyFormatted ( Event $ apiObject ) { if ( $ this -> recurFrequency ( $ apiObject ) ) { return ucfirst ( strtolower ( $ this -> recurFrequency ( $ apiObject ) ) ) ; } return 'None' ; } 
public function recurFrequency ( Event $ apiObject ) { if ( $ apiObject -> rruleArray && array_key_exists ( 'FREQ' , $ apiObject -> rruleArray ) ) { $ freq = $ apiObject -> rruleArray [ 'FREQ' ] ; return $ freq ; } return ; } 
public function recurDays ( Event $ apiObject ) { if ( $ apiObject -> rruleArray && array_key_exists ( 'BYDAY' , $ apiObject -> rruleArray ) ) { $ freq = $ apiObject -> rruleArray [ 'BYDAY' ] ; return $ freq ; } return ; } 
public function tags ( ) { if ( $ this -> entity -> parentEvent ) { $ event = $ this -> entity -> parentEvent ; } else { $ event = $ this -> entity ; } return view ( 'viewers.event.tags' , [ 'event' => $ event , ] ) ; } 
public function store ( InventoryStockRequest $ request , $ itemId ) { if ( $ this -> processor -> store ( $ request , $ itemId ) ) { flash ( ) -> success ( 'Success!' , 'Successfully created stock.' ) ; return redirect ( ) -> route ( 'maintenance.inventory.stocks.index' , [ $ itemId ] ) ; } else { flash ( ) -> error ( 'Error!' , 'There was an issue creating an inventory stock. Please try again.' ) ; return redirect ( ) -> route ( 'maintenance.inventory.stocks.create' , [ $ itemId ] ) ; } } 
public function update ( InventoryStockRequest $ request , $ itemId , $ stockId ) { if ( $ this -> processor -> update ( $ request , $ itemId , $ stockId ) ) { flash ( ) -> success ( 'Success!' , 'Successfully updated stock.' ) ; return redirect ( ) -> route ( 'maintenance.inventory.stocks.show' , [ $ itemId , $ stockId ] ) ; } else { flash ( ) -> error ( 'Error!' , 'There was an issue updating this stock. Please try again.' ) ; return redirect ( ) -> route ( 'maintenance.inventory.stocks.update' , [ $ itemId , $ stockId ] ) ; } } 
public function destroy ( $ itemId , $ stockId ) { if ( $ this -> processor -> destroy ( $ itemId , $ stockId ) ) { flash ( ) -> success ( 'Success!' , 'Successfully deleted stock.' ) ; return redirect ( ) -> route ( 'maintenance.inventory.stocks.index' , [ $ itemId ] ) ; } else { flash ( ) -> error ( 'Error!' , 'There was an issue deleting this stock. Please try again.' ) ; return redirect ( ) -> route ( 'maintenance.inventory.stocks.show' , [ $ itemId , $ stockId ] ) ; } } 
public function table ( WorkOrder $ workOrder ) { $ attachments = $ workOrder -> attachments ( ) ; return $ this -> table -> of ( 'work-orders.attachments' , function ( TableGrid $ table ) use ( $ workOrder , $ attachments ) { $ table -> with ( $ attachments ) -> paginate ( $ this -> perPage ) ; $ table -> column ( 'type' , function ( Column $ column ) { $ column -> value = function ( Attachment $ attachment ) { return $ attachment -> icon ; } ; } ) ; $ table -> column ( 'name' , function ( Column $ column ) use ( $ workOrder ) { $ column -> value = function ( Attachment $ attachment ) use ( $ workOrder ) { $ route = 'maintenance.work-orders.attachments.show' ; $ params = [ $ workOrder -> getKey ( ) , $ attachment -> getKey ( ) ] ; return link_to_route ( $ route , $ attachment -> name , $ params ) ; } ; } ) ; $ table -> column ( 'uploaded_by' , function ( Column $ column ) { $ column -> value = function ( Attachment $ attachment ) { if ( $ attachment -> user instanceof User ) { return $ attachment -> user -> getRecipientName ( ) ; } } ; } ) ; $ table -> column ( 'Uploaded On' , 'created_at' ) ; } ) ; } 
public function form ( WorkOrder $ workOrder , Attachment $ attachment ) { return $ this -> form -> of ( 'work-orders.attachments' , function ( FormGrid $ form ) use ( $ workOrder , $ attachment ) { $ files = true ; if ( $ attachment -> exists ) { $ url = route ( 'maintenance.work-orders.attachments.update' , [ $ workOrder -> getKey ( ) , $ attachment -> getKey ( ) ] ) ; $ method = 'PATCH' ; $ form -> submit = 'Save' ; $ form -> with ( $ attachment ) ; } else { $ url = route ( 'maintenance.work-orders.attachments.store' , [ $ workOrder -> getKey ( ) ] ) ; $ method = 'POST' ; $ form -> submit = 'Upload' ; } $ form -> attributes ( compact ( 'url' , 'method' , 'files' ) ) ; $ form -> fieldset ( function ( Fieldset $ fieldset ) use ( $ attachment ) { if ( $ attachment -> exists ) { 
public function authenticate ( LoginRequest $ request ) { $ throttles = $ this -> isUsingThrottlesLoginsTrait ( ) ; if ( $ throttles && $ this -> hasTooManyLoginAttempts ( $ request ) ) { return $ this -> sendLockoutResponse ( $ request ) ; } $ credentials = $ this -> getCredentials ( $ request ) ; try { if ( Auth :: attempt ( $ credentials , $ request -> has ( 'remember' ) ) ) { return $ this -> handleUserWasAuthenticated ( $ request , $ throttles ) ; } } catch ( Exception $ e ) { 
protected function handleUserWasAuthenticated ( Request $ request , $ throttles ) { if ( $ throttles ) { $ this -> clearLoginAttempts ( $ request ) ; } $ user = auth ( ) -> user ( ) ; if ( $ user instanceof User && $ user -> adldapUser instanceof AdldapUser ) { $ this -> handleLdapUserWasAuthenticated ( $ user , $ user -> adldapUser ) ; } flash ( ) -> success ( 'Success!' , "You're logged in!" ) ; return redirect ( ) -> intended ( $ this -> redirectPath ( ) ) ; } 
protected function handleLdapUserWasAuthenticated ( User $ user , AdldapUser $ adldapUser ) { if ( $ adldapUser -> inGroup ( 'Help Desk' ) ) { $ admin = Role :: admin ( ) ; if ( $ admin instanceof Role ) { $ user -> attachRole ( $ admin -> getKey ( ) ) ; } } } 
public function deleted ( InventoryStock $ stock ) { $ movements = $ stock -> movements ( ) -> get ( ) ; if ( count ( $ movements ) > 0 ) { foreach ( $ movements as $ movement ) { $ movement -> delete ( ) ; } } } 
public function restored ( InventoryStock $ stock ) { $ movements = $ stock -> movements ( ) -> onlyTrashed ( ) -> get ( ) ; if ( count ( $ movements ) > 0 ) { foreach ( $ movements as $ movement ) { $ movement -> restore ( ) ; } } } 
public function up ( ) { Schema :: create ( 'suppliers' , function ( Blueprint $ table ) { $ table -> increments ( 'id' ) ; $ table -> timestamps ( ) ; $ table -> string ( 'name' ) ; $ table -> string ( 'address' ) -> nullable ( ) ; $ table -> string ( 'postal_code' ) -> nullable ( ) ; $ table -> string ( 'zip_code' ) -> nullable ( ) ; $ table -> string ( 'region' ) -> nullable ( ) ; $ table -> string ( 'city' ) -> nullable ( ) ; $ table -> string ( 'country' ) -> nullable ( ) ; $ table -> string ( 'contact_title' ) -> nullable ( ) ; $ table -> string ( 'contact_name' ) -> nullable ( ) ; $ table -> string ( 'contact_phone' ) -> nullable ( ) ; $ table -> string ( 'contact_fax' ) -> nullable ( ) ; $ table -> string ( 'contact_email' ) -> nullable ( ) ; } ) ; Schema :: create ( 'inventory_suppliers' , function ( Blueprint $ table ) { $ table -> increments ( 'id' ) ; $ table -> timestamps ( ) ; $ table -> integer ( 'inventory_id' ) -> unsigned ( ) ; $ table -> integer ( 'supplier_id' ) -> unsigned ( ) ; $ table -> foreign ( 'inventory_id' ) -> references ( 'id' ) -> on ( 'inventories' ) -> onUpdate ( 'restrict' ) -> onDelete ( 'cascade' ) ; $ table -> foreign ( 'supplier_id' ) -> references ( 'id' ) -> on ( 'suppliers' ) -> onUpdate ( 'restrict' ) -> onDelete ( 'cascade' ) ; } ) ; } 
public function table ( Priority $ priority ) { return $ this -> table -> of ( 'work-orders.priorities' , function ( TableGrid $ table ) use ( $ priority ) { $ table -> with ( $ priority ) ; $ table -> column ( 'priority' , function ( Column $ column ) { $ column -> value = function ( Priority $ priority ) { return link_to_route ( 'maintenance.work-orders.priorities.edit' , $ priority -> getLabel ( ) , [ $ priority -> getKey ( ) ] ) ; } ; } ) ; $ table -> column ( 'created_at' ) ; $ table -> column ( 'created_by' , function ( Column $ column ) { $ column -> value = function ( Priority $ priority ) { if ( $ priority -> user instanceof User ) { return $ priority -> user -> getRecipientName ( ) ; } else { return HTML :: create ( 'em' , 'None' ) ; } } ; } ) ; } ) ; } 
public function form ( Priority $ priority ) { return $ this -> form -> of ( 'work-orders.priorities' , function ( FormGrid $ form ) use ( $ priority ) { if ( $ priority -> exists ) { $ url = route ( 'maintenance.work-orders.priorities.update' , [ $ priority -> getKey ( ) ] ) ; $ method = 'PATCH' ; $ form -> submit = 'Save' ; } else { $ url = route ( 'maintenance.work-orders.priorities.store' ) ; $ method = 'POST' ; $ form -> submit = 'Create' ; } $ colors = config ( 'maintenance.colors' , [ ] ) ; $ form -> attributes ( compact ( 'method' , 'url' ) ) ; $ form -> with ( $ priority ) ; $ form -> fieldset ( function ( Fieldset $ fieldset ) use ( $ colors ) { $ fieldset -> control ( 'input:text' , 'name' ) -> attributes ( [ 'placeholder' => 'ex. High / Low' , ] ) ; $ fieldset -> control ( 'select' , 'color' ) -> options ( $ colors ) -> value ( function ( Priority $ priority ) { return $ priority -> color ; } ) -> attributes ( [ 'class' => 'select2-color' , ] ) ; } ) ; } ) ; } 
public function handle ( ) { $ this -> inventory -> user_id = auth ( ) -> id ( ) ; $ this -> inventory -> category_id = $ this -> request -> input ( 'category' ) ; $ this -> inventory -> metric_id = $ this -> request -> input ( 'metric' ) ; $ this -> inventory -> name = $ this -> request -> input ( 'name' ) ; $ this -> inventory -> description = $ this -> request -> clean ( $ this -> request -> input ( 'description' ) ) ; return $ this -> inventory -> save ( ) ; } 
public function formatDateWithTime ( $ date , $ time = null ) { if ( ! empty ( $ date ) ) { if ( ! empty ( $ time ) ) { return date ( 'Y-m-d H:i:s' , strtotime ( $ date . ' ' . $ time ) ) ; } return date ( 'Y-m-d H:i:s' , strtotime ( $ date ) ) ; } return ; } 
public function table ( WorkOrder $ workOrder , Inventory $ item ) { $ stocks = $ item -> stocks ( ) ; return $ this -> table -> of ( 'work-orders.parts.stocks' , function ( TableGrid $ table ) use ( $ workOrder , $ item , $ stocks ) { $ table -> with ( $ stocks ) -> paginate ( $ this -> perPage ) ; $ table -> column ( 'location' , function ( Column $ column ) use ( $ item ) { $ column -> value = function ( InventoryStock $ stock ) use ( $ item ) { $ name = $ stock -> location -> trail ; return link_to_route ( 'maintenance.inventory.stocks.show' , $ name , [ $ item -> getKey ( ) , $ stock -> getKey ( ) ] ) ; } ; } ) ; $ table -> column ( 'quantity' ) ; $ table -> column ( 'select' , function ( Column $ column ) use ( $ workOrder , $ item ) { $ column -> value = function ( InventoryStock $ stock ) use ( $ workOrder , $ item ) { $ route = 'maintenance.work-orders.parts.stocks.take' ; $ params = [ $ workOrder -> getKey ( ) , $ item -> getKey ( ) , $ stock -> getKey ( ) ] ; $ attributes = [ 'class' => 'btn btn-default btn-sm' , ] ; return link_to_route ( $ route , 'Select' , $ params , $ attributes ) ; } ; } ) ; } ) ; } 
public function formTake ( WorkOrder $ workOrder , Inventory $ inventory , InventoryStock $ stock ) { return $ this -> form -> of ( 'work-orders.parts.stocks.take' , function ( FormGrid $ form ) use ( $ workOrder , $ inventory , $ stock ) { $ form -> attributes ( [ 'method' => 'POST' , 'url' => route ( 'maintenance.work-orders.parts.stocks.take' , [ $ workOrder -> getKey ( ) , $ inventory -> getKey ( ) , $ stock -> getKey ( ) ] ) , ] ) ; $ form -> submit = 'Save' ; $ form -> fieldset ( function ( Fieldset $ fieldset ) use ( $ inventory ) { $ metric = $ inventory -> getMetricSymbol ( ) ; $ fieldset -> control ( 'input:text' , 'quantity' ) -> value ( 0 ) -> attribute ( [ 'placeholder' => "Enter Quantity in $metric" , ] ) ; } ) ; } ) ; } 
public function formPut ( WorkOrder $ workOrder , Inventory $ inventory , InventoryStock $ stock ) { return $ this -> form -> of ( 'work-orders.parts.stocks.put' , function ( FormGrid $ form ) use ( $ workOrder , $ inventory , $ stock ) { $ form -> attributes ( [ 'method' => 'POST' , 'url' => route ( 'maintenance.work-orders.parts.stocks.put' , [ $ workOrder -> getKey ( ) , $ inventory -> getKey ( ) , $ stock -> getKey ( ) ] ) , ] ) ; $ form -> submit = 'Save' ; $ form -> fieldset ( function ( Fieldset $ fieldset ) use ( $ inventory , $ stock ) { $ metric = $ inventory -> getMetricSymbol ( ) ; $ fieldset -> control ( 'input:text' , 'quantity' , function ( Field $ field ) { $ field -> label = 'Return Quantity' ; } ) -> value ( $ stock -> pivot -> quantity ) -> attribute ( [ 'placeholder' => "Enter Quantity in $metric" , ] ) ; } ) ; } ) ; } 
public function update ( InventoryRequest $ request , $ id ) { if ( $ this -> processor -> update ( $ request , $ id ) ) { flash ( ) -> success ( 'Success!' , 'Successfully updated inventory item.' ) ; return redirect ( ) -> route ( 'maintenance.inventory.show' , [ $ id ] ) ; } else { flash ( ) -> error ( 'Error!' , 'There was an issue updating this inventory item. Please try again.' ) ; return redirect ( ) -> route ( 'maintenance.inventory.edit' , [ $ id ] ) ; } } 
public function destroy ( $ id ) { if ( $ this -> processor -> destroy ( $ id ) ) { flash ( ) -> success ( 'Success!' , 'Successfully deleted inventory item.' ) ; return redirect ( ) -> route ( 'maintenance.inventory.index' ) ; } else { flash ( ) -> error ( 'Error!' , 'There was an issue deleting this inventory item. Please try again.' ) ; return redirect ( ) -> route ( 'maintenance.inventory.show' , [ $ id ] ) ; } } 
public function create ( $ title , $ message , $ level = 'info' , $ key = 'flash_message' ) { $ timer = $ this -> timer ; session ( ) -> flash ( $ key , compact ( 'title' , 'message' , 'level' , 'info' , 'timer' ) ) ; } 
public function create ( $ workOrderId ) { try { return $ this -> processor -> create ( $ workOrderId ) ; } catch ( ReportExistsException $ e ) { flash ( ) -> error ( 'Error!' , 'This work order already has already been completed.' ) ; return redirect ( ) -> route ( 'maintenance.work-orders.show' , [ $ workOrderId ] ) ; } } 
public function store ( ReportRequest $ request , $ workOrderId ) { if ( $ this -> processor -> store ( $ request , $ workOrderId ) ) { flash ( ) -> success ( 'Success!' , 'Successfully created work order report.' ) ; return redirect ( ) -> route ( 'maintenance.work-orders.show' , [ $ workOrderId ] ) ; } else { flash ( ) -> error ( 'Error!' , 'There was an issue creating a work order report. Please try again' ) ; return redirect ( ) -> route ( 'maintenance.work-orders.report.create' , [ $ workOrderId ] ) ; } } 
public function index ( $ resourceId ) { $ routes = $ this -> routes ; $ eventable = $ this -> getEventableRepository ( ) -> model ( ) -> findOrFail ( $ resourceId ) ; return view ( 'events.eventables.index' , compact ( 'eventable' , 'routes' ) ) ; } 
public function store ( EventRequest $ request , $ resourceId ) { $ eventable = $ this -> getEventableRepository ( ) -> model ( ) -> findOrFail ( $ resourceId ) ; $ event = $ this -> event -> create ( $ request ) ; if ( $ event && method_exists ( $ eventable , 'events' ) ) { $ eventable -> events ( ) -> attach ( $ event -> id ) ; $ message = 'Successfully created event.' ; return redirect ( ) -> route ( $ this -> routes [ 'index' ] , $ eventable -> id ) -> withSuccess ( $ message ) ; } else { $ message = 'There was an issue creating an event. Please try again.' ; return redirect ( ) -> route ( $ this -> routes [ 'create' ] ) -> withErrors ( $ message ) ; } } 
public function show ( $ resourceId , $ eventId ) { $ routes = $ this -> routes ; $ eventable = $ this -> getEventableRepository ( ) -> model ( ) -> findOrFail ( $ resourceId ) ; if ( method_exists ( $ eventable , 'events' ) ) { $ event = $ eventable -> events ( ) -> find ( $ eventId ) ; if ( $ event ) { $ apiObject = $ this -> event -> findApiObject ( $ event -> api_id ) ; return view ( 'events.eventables.show' , compact ( 'routes' , 'eventable' , 'event' , 'apiObject' ) ) ; } } abort ( 404 ) ; } 
public function update ( EventRequest $ request , $ resourceId , $ eventId ) { $ eventable = $ this -> getEventableRepository ( ) -> model ( ) -> findOrFail ( $ resourceId ) ; $ event = $ this -> event -> update ( $ request , $ eventId ) ; if ( $ event ) { $ message = 'Successfully updated event.' ; return redirect ( ) -> route ( $ this -> routes [ 'show' ] , [ $ eventable -> id , $ event -> id ] ) -> withSuccess ( $ message ) ; } else { $ message = 'There was an issue updating this event. Please try again.' ; return redirect ( ) -> route ( $ this -> routes [ 'edit' ] , [ $ eventable -> id ] ) -> withErrors ( $ message ) ; } } 
public function destroy ( $ resourceId , $ eventId ) { $ eventable = $ this -> getEventableRepository ( ) -> model ( ) -> findOrFail ( $ resourceId ) ; if ( method_exists ( $ eventable , 'events' ) ) { $ event = $ eventable -> events ( ) -> find ( $ eventId ) ; if ( $ event && $ this -> event -> delete ( $ event -> id ) ) { $ message = 'Successfully deleted event.' ; return redirect ( ) -> route ( $ this -> routes [ 'index' ] , $ eventable -> id ) -> withSuccess ( $ message ) ; } else { $ message = 'There was an issue deleting this event. Please try again.' ; return redirect ( ) -> route ( $ this -> routes [ 'show' ] , $ eventable -> id , $ event -> id ) -> withErrors ( $ message ) ; } } abort ( 404 ) ; } 
public function getRevisedCategoryAttribute ( $ id ) { if ( $ id ) { $ category = $ this -> category ( ) -> find ( $ id ) ; if ( $ category instanceof Category ) { return $ category -> trail ; } } return ; } 
public function scopeCategory ( $ query , $ categoryId = null ) { if ( $ categoryId ) { 
public function run ( ) { $ statuses = $ this -> getSeedData ( ) ; foreach ( $ statuses as $ status ) { $ this -> status -> model ( ) -> create ( $ status ) ; } } 
public function form ( ) { return $ this -> form -> of ( 'label' , function ( FormGrid $ form ) { $ form -> attributes ( [ 'url' => route ( 'maintenance.login.index' ) ] ) ; $ form -> submit = 'Sign In' ; $ form -> fieldset ( function ( Fieldset $ fieldset ) { $ fieldset -> control ( 'input:text' , 'email' ) -> label ( 'Email' ) -> attributes ( [ 'placeholder' => 'Enter your Email' ] ) ; $ fieldset -> control ( 'input:password' , 'password' ) -> label ( 'Password' ) -> attributes ( [ 'placeholder' => 'Enter your Password' ] ) ; } ) ; } ) ; } 
public function store ( ManualRequest $ request , $ id ) { $ asset = $ this -> asset -> find ( $ id ) ; $ attachments = $ this -> manual -> upload ( $ request , $ asset , $ asset -> manuals ( ) ) ; if ( $ attachments ) { $ message = 'Successfully uploaded files.' ; return redirect ( ) -> route ( 'maintenance.assets.manuals.index' , [ $ asset -> id ] ) -> withSuccess ( $ message ) ; } else { $ message = 'There was an issue uploading the files you selected. Please try again.' ; return redirect ( ) -> route ( 'maintenance.assets.manuals.create' , [ $ id ] ) -> withErrors ( $ message ) ; } } 
public function show ( $ id , $ manualId ) { $ asset = $ this -> asset -> find ( $ id ) ; $ manual = $ asset -> manuals ( ) -> find ( $ manualId ) ; if ( $ manual ) { return view ( 'assets.manuals.show' , compact ( 'asset' , 'manual' ) ) ; } abort ( 404 ) ; } 
public function update ( AttachmentUpdateRequest $ request , $ id , $ manualId ) { $ asset = $ this -> asset -> find ( $ id ) ; $ manual = $ this -> manual -> update ( $ request , $ asset -> manuals ( ) , $ manualId ) ; if ( $ manual ) { $ message = 'Successfully updated manual.' ; return redirect ( ) -> route ( 'maintenance.assets.manuals.show' , [ $ asset -> id , $ manual -> id ] ) -> withSuccess ( $ message ) ; } else { $ message = 'There was an issue updating this manual. Please try again.' ; return redirect ( ) -> route ( 'maintenance.assets.manuals.show' , [ $ id , $ manualId ] ) -> withErrors ( $ message ) ; } } 
public function destroy ( $ id , $ manualId ) { $ asset = $ this -> asset -> find ( $ id ) ; $ manual = $ asset -> manuals ( ) -> find ( $ manualId ) ; if ( $ manual && $ manual -> delete ( ) ) { $ message = 'Successfully deleted manual.' ; return redirect ( ) -> route ( 'maintenance.assets.manuals.index' , [ $ asset -> id ] ) -> withSuccess ( $ message ) ; } else { $ message = 'There was an issue deleting this manual. Please try again.' ; return redirect ( ) -> route ( 'maintenance.assets.manuals.show' , [ $ asset -> id , $ manual -> id ] ) -> withErrors ( $ message ) ; } } 
public function download ( $ id , $ manualId ) { $ asset = $ this -> asset -> find ( $ id ) ; $ manual = $ asset -> manuals ( ) -> find ( $ manualId ) ; if ( $ manual ) { return response ( ) -> download ( $ manual -> download_path ) ; } abort ( 404 ) ; } 
public function store ( $ assetId , $ workOrderId ) { if ( $ this -> asset -> attachWorkOrder ( $ assetId , $ workOrderId ) ) { $ message = 'Successfully attached work order.' ; return redirect ( ) -> route ( 'maintenance.assets.work-orders.index' , [ $ assetId ] ) -> withSuccess ( $ message ) ; } else { $ message = 'There was an issue attaching this work order. Please try again.' ; return redirect ( ) -> route ( 'maintenance.assets.work-orders.attach.index' , [ $ assetId ] ) -> withErrors ( $ message ) ; } } 
public function remove ( $ assetId , $ workOrderId ) { if ( $ this -> asset -> detachWorkOrder ( $ assetId , $ workOrderId ) ) { $ message = 'Successfully detached work order.' ; return redirect ( ) -> route ( 'maintenance.assets.work-orders.index' , [ $ assetId ] ) -> withSuccess ( $ message ) ; } else { $ message = 'There was an issue detaching this work order. Please try again.' ; return redirect ( ) -> route ( 'maintenance.assets.work-orders.index' , [ $ assetId ] ) -> withErrors ( $ message ) ; } } 
public function store ( $ workRequestId ) { if ( $ this -> updateValidator -> passes ( ) ) { $ workRequest = $ this -> workRequest -> find ( $ workRequestId ) ; $ update = $ this -> update -> setInput ( $ this -> inputAll ( ) ) -> create ( ) ; $ this -> workRequest -> saveUpdate ( $ workRequest , $ update ) ; $ this -> message = 'Successfully added update' ; $ this -> messageType = 'success' ; $ this -> redirect = routeBack ( 'maintenance.work-requests.show' , [ $ workRequest -> id ] ) ; } else { $ this -> errors = $ this -> updateValidator -> getErrors ( ) ; $ this -> redirect = routeBack ( 'maintenance.work-requests.show' , [ $ workRequestId ] ) ; } return $ this -> response ( ) ; } 
public function destroy ( $ workRequestId , $ updateId ) { $ workRequest = $ this -> workRequest -> find ( $ workRequestId ) ; if ( $ this -> update -> destroy ( $ updateId ) ) { $ this -> message = 'Successfully deleted update' ; $ this -> messageType = 'success' ; $ this -> redirect = route ( 'maintenance.work-requests.show' , [ $ workRequest -> id , '#tab_updates' ] ) ; } else { $ this -> message = 'There was an error trying to delete this update. Please try again.' ; $ this -> messageType = 'danger' ; $ this -> redirect = route ( 'maintenance.work-requests.show' , [ $ workRequest -> id , '#tab_updates' ] ) ; } return $ this -> response ( ) ; } 
public function index ( $ workOrderId , $ itemId ) { $ workOrder = $ this -> workOrder -> findOrFail ( $ workOrderId ) ; $ item = $ this -> inventory -> findOrFail ( $ itemId ) ; $ stocks = $ this -> presenter -> table ( $ workOrder , $ item ) ; $ variants = $ this -> presenter -> tableVariants ( $ workOrder , $ item ) ; return view ( 'work-orders.parts.stocks.index' , compact ( 'stocks' , 'variants' ) ) ; } 
public function getTake ( $ workOrderId , $ itemId , $ stockId ) { $ workOrder = $ this -> workOrder -> findOrFail ( $ workOrderId ) ; $ item = $ this -> inventory -> findOrFail ( $ itemId ) ; $ stock = $ item -> stocks ( ) -> findOrFail ( $ stockId ) ; $ form = $ this -> presenter -> formTake ( $ workOrder , $ item , $ stock ) ; return view ( 'work-orders.parts.stocks.take' , compact ( 'workOrder' , 'item' , 'stock' , 'form' ) ) ; } 
public function postTake ( PartTakeRequest $ request , $ workOrderId , $ itemId , $ stockId ) { $ workOrder = $ this -> workOrder -> findOrFail ( $ workOrderId ) ; $ item = $ this -> inventory -> findOrFail ( $ itemId ) ; $ stock = $ item -> stocks ( ) -> findOrFail ( $ stockId ) ; return $ this -> dispatch ( new Take ( $ request , $ workOrder , $ stock ) ) ; } 
public function getPut ( $ workOrderId , $ itemId , $ stockId ) { $ workOrder = $ this -> workOrder -> findOrFail ( $ workOrderId ) ; $ item = $ this -> inventory -> findOrFail ( $ itemId ) ; $ stock = $ workOrder -> parts ( ) -> findOrFail ( $ stockId ) ; $ form = $ this -> presenter -> formPut ( $ workOrder , $ item , $ stock ) ; return view ( 'work-orders.parts.stocks.put' , compact ( 'workOrder' , 'item' , 'stock' , 'form' ) ) ; } 
public function postPut ( PartReturnRequest $ request , $ workOrderId , $ itemId , $ stockId ) { $ workOrder = $ this -> workOrder -> findOrFail ( $ workOrderId ) ; 
public function index ( ) { $ workRequests = $ this -> presenter -> table ( $ this -> workRequest ) ; $ navbar = $ this -> presenter -> navbar ( ) ; return view ( 'work-requests.index' , compact ( 'workRequests' , 'navbar' ) ) ; } 
public function store ( WorkHttpRequest $ request ) { $ workRequest = $ this -> workRequest -> newInstance ( ) ; if ( $ this -> dispatch ( new Store ( $ request , $ workRequest ) ) ) { $ this -> dispatch ( new StoreFromWorkRequest ( $ workRequest ) ) ; return true ; } return false ; } 
public function edit ( $ id ) { $ workRequest = $ this -> workRequest -> findOrFail ( $ id ) ; $ form = $ this -> presenter -> form ( $ workRequest ) ; return view ( 'work-requests.edit' , compact ( 'form' ) ) ; } 
public function update ( WorkHttpRequest $ request , $ id ) { $ workRequest = $ this -> workRequest -> findOrFail ( $ id ) ; return $ this -> dispatch ( new Update ( $ request , $ workRequest ) ) ; } 
public function create ( $ id = null ) { 
public function store ( CategoryRequest $ request , $ id = null ) { $ category = $ this -> repository -> create ( $ request , $ id ) ; if ( $ category ) { $ message = "Successfully created $this->resource" ; return redirect ( ) -> route ( $ this -> routes [ 'index' ] ) -> withSuccess ( $ message ) ; } else { $ message = "There was an issue creating a $this->resource. Please try again." ; return redirect ( ) -> route ( $ this -> routes [ 'create' ] , $ id ) -> withErrors ( $ message ) ; } } 
public function edit ( $ id ) { $ category = $ this -> repository -> find ( $ id ) ; return view ( 'categories.edit' , [ 'category' => $ category , 'resource' => $ this -> resource , 'routes' => $ this -> routes , ] ) ; } 
public function update ( CategoryRequest $ request , $ id ) { $ category = $ this -> repository -> update ( $ request , $ id ) ; if ( $ category ) { $ message = "Successfully updated $this->resource" ; return redirect ( ) -> route ( $ this -> routes [ 'index' ] ) -> withSuccess ( $ message ) ; } else { $ message = "There was an issue updating this $this->resource. Please try again." ; return redirect ( ) -> route ( $ this -> routes [ 'edit' ] , $ id ) -> withErrors ( $ message ) ; } } 
public function destroy ( $ id ) { $ record = $ this -> repository -> find ( $ id ) ; if ( $ record -> delete ( ) ) { $ message = "Successfully deleted $this->resource." ; return redirect ( ) -> route ( $ this -> routes [ 'index' ] ) -> withSuccess ( $ message ) ; } else { $ message = "There was an issue deleting this $this->resource. Please try again." ; return redirect ( ) -> route ( $ this -> routes [ 'index' ] ) -> withErrors ( $ message ) ; } } 
public function handle ( ) { $ this -> inventory -> category_id = $ this -> request -> input ( 'category' , $ this -> inventory -> category_id ) ; $ this -> inventory -> metric_id = $ this -> request -> input ( 'metric' , $ this -> inventory -> metric_id ) ; $ this -> inventory -> name = $ this -> request -> input ( 'name' , $ this -> inventory -> name ) ; $ this -> inventory -> description = $ this -> request -> clean ( $ this -> request -> input ( 'description' , $ this -> inventory -> description ) ) ; return $ this -> inventory -> save ( ) ; } 
public function table ( WorkOrder $ workOrder ) { $ sessions = $ workOrder -> sessions ( ) ; return $ this -> table -> of ( 'work-orders.sessions' , function ( TableGrid $ table ) use ( $ sessions ) { $ table -> with ( $ sessions ) -> paginate ( $ this -> perPage ) ; $ table -> attributes ( [ 'class' => 'table table-hover table-striped' , ] ) ; $ table -> column ( 'user' , function ( Column $ column ) { $ column -> value = function ( WorkOrderSession $ session ) { return $ session -> user -> fullname ; } ; } ) ; $ table -> column ( 'Hours' , function ( Column $ column ) { $ column -> value = function ( WorkOrderSession $ session ) { return $ session -> getHours ( ) ; } ; } ) ; $ table -> column ( 'in' ) ; $ table -> column ( 'out' , function ( Column $ column ) { $ column -> value = function ( WorkOrderSession $ session ) { return $ session -> getOutLabel ( ) ; } ; } ) ; } ) ; } 
public function tablePerWorker ( WorkOrder $ workOrder ) { $ sessions = $ workOrder -> getUniqueSessions ( ) ; return $ this -> table -> of ( 'work-orders.sessions.per-worker' , function ( TableGrid $ table ) use ( $ sessions ) { $ table -> with ( $ sessions ) ; $ table -> attributes ( [ 'class' => 'table table-hover table-striped' , ] ) ; $ table -> column ( 'worker' , function ( Column $ column ) { $ column -> value = function ( WorkOrderSession $ session ) { return $ session -> user -> fullname ; } ; } ) ; $ table -> column ( 'total_hours' , function ( Column $ column ) { $ column -> value = function ( WorkOrderSession $ session ) { return $ session -> total_hours ; } ; } ) ; } ) ; } 
public function deleted ( Inventory $ model ) { $ stocks = $ model -> stocks ( ) -> get ( ) ; if ( count ( $ stocks ) > 0 ) { foreach ( $ stocks as $ stock ) { $ stock -> delete ( ) ; } } } 
public function restored ( Inventory $ model ) { $ stocks = $ model -> stocks ( ) -> onlyTrashed ( ) -> get ( ) ; if ( count ( $ stocks ) > 0 ) { foreach ( $ stocks as $ stock ) { $ stock -> restore ( ) ; } } } 
public function index ( ) { $ inventory = $ this -> presenter -> tableNoVariants ( $ this -> inventory ) ; $ navbar = $ this -> presenter -> navbar ( ) ; return view ( 'inventory.index' , compact ( 'inventory' , 'navbar' ) ) ; } 
public function store ( InventoryRequest $ request ) { $ item = $ this -> inventory -> newInstance ( ) ; return $ this -> dispatch ( new Store ( $ request , $ item ) ) ; } 
public function show ( $ id ) { $ item = $ this -> inventory -> find ( $ id ) ; $ variants = $ this -> presenter -> tableVariants ( $ item ) ; $ stocks = $ this -> presenter -> tableStocks ( $ item ) ; $ navbarProfile = $ this -> presenter -> navbarProfile ( $ item ) ; $ navbarVariants = $ this -> presenter -> navbarVariants ( $ item ) ; $ navbarStocks = $ this -> presenter -> navbarStocks ( $ item ) ; return view ( 'inventory.show' , compact ( 'item' , 'stocks' , 'variants' , 'navbarProfile' , 'navbarVariants' , 'navbarStocks' ) ) ; } 
public function edit ( $ id ) { $ item = $ this -> inventory -> findOrFail ( $ id ) ; $ form = $ this -> presenter -> form ( $ item ) ; return view ( 'inventory.edit' , compact ( 'form' ) ) ; } 
public function update ( InventoryRequest $ request , $ id ) { $ item = $ this -> inventory -> findOrFail ( $ id ) ; return $ this -> dispatch ( new Update ( $ request , $ item ) ) ; } 
public function handle ( ) { $ this -> workRequest -> user_id = auth ( ) -> id ( ) ; $ this -> workRequest -> subject = $ this -> request -> input ( 'subject' ) ; $ this -> workRequest -> best_time = $ this -> request -> input ( 'best_time' ) ; $ this -> workRequest -> description = $ this -> request -> clean ( $ this -> request -> input ( 'description' ) ) ; return $ this -> workRequest -> save ( ) ; } 
public function table ( Inventory $ item ) { $ stocks = $ item -> stocks ( ) ; return $ this -> table -> of ( 'inventory.stocks' , function ( TableGrid $ table ) use ( $ item , $ stocks ) { $ table -> with ( $ stocks ) ; $ table -> attributes ( [ 'class' => 'table table-hover table-striped' , ] ) ; $ table -> column ( 'quantity' ) ; $ table -> column ( 'location' , function ( Column $ column ) use ( $ item ) { $ column -> value = function ( InventoryStock $ stock ) use ( $ item ) { $ name = $ stock -> location -> trail ; return link_to_route ( 'maintenance.inventory.stocks.show' , $ name , [ $ item -> getKey ( ) , $ stock -> getKey ( ) ] ) ; } ; } ) ; $ table -> column ( 'last_movement' , function ( Column $ column ) { $ column -> value = function ( InventoryStock $ stock ) { return $ stock -> last_movement ; } ; } ) ; $ table -> column ( 'last_movement_by' , function ( Column $ column ) { $ column -> value = function ( InventoryStock $ stock ) { return $ stock -> last_movement_by ; } ; } ) ; } ) ; } 
public function tableMovements ( Inventory $ item , InventoryStock $ stock ) { $ movements = $ stock -> movements ( ) ; return $ this -> table -> of ( 'inventory.stocks.movements' , function ( TableGrid $ table ) use ( $ item , $ movements ) { $ table -> with ( $ movements ) -> paginate ( $ this -> perPage ) ; $ table -> pageName = 'stock-movements' ; $ table -> column ( 'before' ) ; $ table -> column ( 'after' ) ; $ table -> column ( 'change' ) ; $ table -> column ( 'cost' ) ; $ table -> column ( 'reason' ) ; $ table -> column ( 'Change By' , function ( Column $ column ) { return $ column -> value = function ( InventoryStockMovement $ movement ) { if ( $ movement -> user instanceof User ) { return $ movement -> user -> getRecipientName ( ) ; } return HTML :: create ( 'em' , 'Unknown' ) ; } ; } ) ; $ table -> column ( 'Change On' , 'created_at' ) ; } ) ; } 
public function form ( Inventory $ item , InventoryStock $ stock ) { return $ this -> form -> of ( 'inventory.stocks' , function ( FormGrid $ form ) use ( $ item , $ stock ) { if ( $ stock -> exists ) { $ method = 'PATCH' ; $ url = route ( 'maintenance.inventory.stocks.update' , [ $ item -> getKey ( ) , $ stock -> getKey ( ) ] ) ; $ form -> submit = 'Save' ; } else { $ method = 'POST' ; $ url = route ( 'maintenance.inventory.stocks.store' , [ $ item -> getKey ( ) ] ) ; $ form -> submit = 'Create' ; } $ locations = Location :: getSelectHierarchy ( ) ; $ form -> with ( $ stock ) ; $ form -> attributes ( compact ( 'method' , 'url' ) ) ; $ form -> fieldset ( function ( Fieldset $ fieldset ) use ( $ locations ) { $ fieldset -> control ( 'select' , 'location' ) -> value ( function ( InventoryStock $ stock ) { return $ stock -> location_id ; } ) -> options ( $ locations ) ; $ fieldset -> control ( 'input:text' , 'quantity' ) -> attributes ( [ 'placeholder' => 'ex. 45' , ] ) ; $ fieldset -> control ( 'input:text' , 'reason' ) -> attributes ( [ 'placeholder' => 'ex. Stock Update' , ] ) ; $ fieldset -> control ( 'input:text' , 'cost' ) -> attributes ( [ 'placeholder' => 'ex. 15.00' , ] ) ; } ) ; } ) ; } 
public function navbar ( Inventory $ item ) { return $ this -> fluent ( [ 'id' => 'inventory-stocks' , 'title' => 'Item Stocks' , 'url' => route ( 'maintenance.inventory.stocks.index' , [ $ item -> getKey ( ) ] ) , 'menu' => view ( 'inventory.stocks._nav' , compact ( 'item' ) ) , 'attributes' => [ 'class' => 'navbar-default' , ] , ] ) ; } 
public function run ( ) { $ priorities = $ this -> getSeedData ( ) ; foreach ( $ priorities as $ priority ) { $ this -> priority -> model ( ) -> create ( $ priority ) ; } } 
public function up ( ) { Schema :: create ( 'assets' , function ( Blueprint $ table ) { $ table -> increments ( 'id' ) ; $ table -> timestamps ( ) ; $ table -> softDeletes ( ) ; $ table -> date ( 'acquired_at' ) -> nullable ( ) ; $ table -> date ( 'end_of_life' ) -> nullable ( ) ; $ table -> integer ( 'user_id' ) -> unsigned ( ) -> nullable ( ) ; $ table -> integer ( 'location_id' ) -> unsigned ( ) -> nullable ( ) ; $ table -> integer ( 'category_id' ) -> unsigned ( ) ; $ table -> string ( 'tag' ) -> nullable ( ) ; $ table -> string ( 'name' ) ; $ table -> text ( 'description' ) -> nullable ( ) ; $ table -> integer ( 'condition' ) -> nullable ( ) ; $ table -> string ( 'size' ) -> nullable ( ) ; $ table -> string ( 'weight' ) -> nullable ( ) ; $ table -> string ( 'vendor' ) -> nullable ( ) ; $ table -> string ( 'make' ) -> nullable ( ) ; $ table -> string ( 'model' ) -> nullable ( ) ; $ table -> string ( 'serial' ) -> nullable ( ) ; $ table -> decimal ( 'price' , 10 , 2 ) -> nullable ( ) ; $ table -> foreign ( 'user_id' ) -> references ( 'id' ) -> on ( 'users' ) -> onUpdate ( 'restrict' ) -> onDelete ( 'set null' ) ; $ table -> foreign ( 'location_id' ) -> references ( 'id' ) -> on ( 'locations' ) -> onUpdate ( 'restrict' ) -> onDelete ( 'set null' ) ; $ table -> foreign ( 'category_id' ) -> references ( 'id' ) -> on ( 'categories' ) -> onUpdate ( 'restrict' ) -> onDelete ( 'cascade' ) ; } ) ; Schema :: create ( 'asset_meters' , function ( Blueprint $ table ) { $ table -> integer ( 'asset_id' ) -> unsigned ( ) ; $ table -> integer ( 'meter_id' ) -> unsigned ( ) ; $ table -> foreign ( 'asset_id' ) -> references ( 'id' ) -> on ( 'assets' ) -> onUpdate ( 'restrict' ) -> onDelete ( 'cascade' ) ; $ table -> foreign ( 'meter_id' ) -> references ( 'id' ) -> on ( 'meters' ) -> onUpdate ( 'restrict' ) -> onDelete ( 'cascade' ) ; } ) ; } 
public function table ( WorkOrder $ workOrder ) { $ parts = $ workOrder -> parts ( ) ; return $ this -> table -> of ( 'work-orders.parts' , function ( TableGrid $ table ) use ( $ workOrder , $ parts ) { $ table -> with ( $ parts ) -> paginate ( $ this -> perPage ) ; $ table -> pageName = 'page-parts' ; $ table -> column ( 'ID' , 'id' ) ; $ table -> column ( 'SKU' , function ( Column $ column ) { $ column -> value = function ( InventoryStock $ stock ) { return $ stock -> item -> getSku ( ) ; } ; } ) ; $ table -> column ( 'name' , function ( Column $ column ) { $ column -> value = function ( InventoryStock $ stock ) { return $ stock -> item -> name ; } ; } ) ; $ table -> column ( 'location' , function ( Column $ column ) { $ column -> value = function ( InventoryStock $ stock ) { return $ stock -> location -> trail ; } ; } ) ; $ table -> column ( 'taken' , function ( Column $ column ) { $ column -> value = function ( InventoryStock $ stock ) { return $ stock -> quantity ; } ; } ) ; $ table -> column ( 'return' , function ( Column $ column ) use ( $ workOrder ) { $ column -> label = 'Return Stock' ; $ column -> value = function ( InventoryStock $ stock ) use ( $ workOrder ) { $ route = 'maintenance.work-orders.parts.stocks.put' ; $ params = [ $ workOrder -> getKey ( ) , $ stock -> item -> getKey ( ) , $ stock -> getKey ( ) ] ; $ attributes = [ 'class' => 'btn btn-default btn-sm' , ] ; return link_to_route ( $ route , 'Return' , $ params , $ attributes ) ; } ; } ) ; } ) ; } 
public function tableInventory ( WorkOrder $ workOrder , Inventory $ inventory ) { $ inventory = $ inventory -> noVariants ( ) ; return $ this -> table -> of ( 'work-orders.inventory' , function ( TableGrid $ table ) use ( $ inventory , $ workOrder ) { $ table -> with ( $ inventory ) -> paginate ( $ this -> perPage ) ; $ table -> pageName = 'page-inventory' ; $ table -> column ( 'ID' , 'id' ) ; $ table -> column ( 'sku' , function ( Column $ column ) { $ column -> label = 'SKU' ; $ column -> value = function ( Inventory $ item ) { return $ item -> getSku ( ) ; } ; } ) ; $ table -> column ( 'name' , function ( Column $ column ) { $ column -> value = function ( Inventory $ item ) { return link_to_route ( 'maintenance.inventory.show' , $ item -> name , [ $ item -> getKey ( ) ] ) ; } ; } ) ; $ table -> column ( 'category' , function ( Column $ column ) { $ column -> value = function ( Inventory $ item ) { return $ item -> category -> trail ; } ; } ) ; $ table -> column ( 'current_stock' , function ( Column $ column ) { $ column -> value = function ( Inventory $ item ) { return $ item -> getTotalStock ( ) ; } ; } ) ; $ table -> column ( 'select' , function ( Column $ column ) use ( $ workOrder ) { $ column -> value = function ( Inventory $ item ) use ( $ workOrder ) { $ route = 'maintenance.work-orders.parts.stocks.index' ; $ params = [ $ workOrder -> getKey ( ) , $ item -> getKey ( ) ] ; $ attributes = [ 'class' => 'btn btn-default btn-sm' , ] ; return link_to_route ( $ route , 'Select' , $ params , $ attributes ) ; } ; } ) ; } ) ; } 
public function navbarParts ( WorkOrder $ workOrder ) { return $ this -> fluent ( [ 'id' => 'work-orders-parts' , 'title' => 'Parts Added' , 'url' => route ( 'maintenance.work-orders.parts.index' , [ $ workOrder -> getKey ( ) ] ) , 'menu' => view ( 'work-orders.parts._nav' , compact ( 'workOrder' ) ) , 'attributes' => [ 'class' => 'navbar-default' , ] , ] ) ; } 
public function index ( $ workOrderId ) { $ workOrder = $ this -> workOrder -> findOrFail ( $ workOrderId ) ; $ sessions = $ this -> presenter -> table ( $ workOrder ) ; $ navbar = $ this -> presenter -> navbar ( ) ; return view ( 'work-orders.sessions.index' , compact ( 'sessions' , 'navbar' ) ) ; } 
public function start ( $ workOrderId ) { $ workOrder = $ this -> workOrder -> findOrFail ( $ workOrderId ) ; return $ this -> dispatch ( new Start ( $ workOrder ) ) ; } 
public function end ( $ workOrderId ) { $ workOrder = $ this -> workOrder -> findOrFail ( $ workOrderId ) ; return $ this -> dispatch ( new End ( $ workOrder ) ) ; } 
public function handle ( ) { $ this -> priority -> user_id = auth ( ) -> id ( ) ; $ this -> priority -> name = $ this -> request -> input ( 'name' ) ; $ this -> priority -> color = $ this -> request -> input ( 'color' ) ; return $ this -> priority -> save ( ) ; } 
public function handle ( ) { $ this -> status -> name = $ this -> request -> input ( 'name' , $ this -> status -> name ) ; $ this -> status -> color = $ this -> request -> input ( 'color' , $ this -> status -> color ) ; return $ this -> status -> save ( ) ; } 
public function getChangeAttribute ( ) { if ( $ this -> before > $ this -> after ) { return sprintf ( '- %s' , $ this -> before - $ this -> after ) ; } elseif ( $ this -> after > $ this -> before ) { return sprintf ( '+ %s' , $ this -> after - $ this -> before ) ; } else { return 'None' ; } } 
public function store ( NoteRequest $ request , $ id ) { $ note = $ this -> inventory -> createNote ( $ request , $ id ) ; if ( $ note ) { $ message = 'Successfully created note.' ; return redirect ( ) -> route ( 'maintenance.inventory.show' , [ $ id ] ) -> withSuccess ( $ message ) ; } else { $ message = 'There was an issue creating a note. Please try again.' ; return redirect ( ) -> route ( 'maintenance.inventory.notes.create' , [ $ id ] ) -> withErrors ( $ message ) ; } } 
public function show ( $ id , $ noteId ) { $ item = $ this -> inventory -> find ( $ id ) ; $ note = $ item -> notes ( ) -> find ( $ noteId ) ; if ( $ note ) { return view ( 'inventory.notes.show' , compact ( 'item' , 'note' ) ) ; } abort ( 404 ) ; } 
public function update ( NoteRequest $ request , $ id , $ noteId ) { $ note = $ this -> inventory -> updateNote ( $ request , $ id , $ noteId ) ; if ( $ note ) { $ message = 'Successfully updated note.' ; return redirect ( ) -> route ( 'maintenance.inventory.notes.show' , [ $ id , $ noteId ] ) -> withSuccess ( $ message ) ; } else { $ message = 'There was an issue updating this note. Please try again.' ; return redirect ( ) -> route ( 'maintenance.inventory.notes.update' , [ $ id , $ noteId ] ) -> withErrors ( $ message ) ; } } 
public function destroy ( $ id , $ noteId ) { if ( $ this -> inventory -> deleteNote ( $ id , $ noteId ) ) { $ message = 'Successfully updated note.' ; return redirect ( ) -> route ( 'maintenance.inventory.show' , [ $ id ] ) -> withSuccess ( $ message ) ; } else { $ message = 'There was an issue deleting this note. Please try again.' ; return redirect ( ) -> route ( 'maintenance.inventory.notes.show' , [ $ id , $ noteId ] ) -> withErrors ( $ message ) ; } } 
public function handle ( ) { $ this -> status -> user_id = auth ( ) -> id ( ) ; $ this -> status -> name = $ this -> request -> input ( 'name' ) ; $ this -> status -> color = $ this -> request -> input ( 'color' ) ; return $ this -> status -> save ( ) ; } 
public function getLastMovementAttribute ( ) { if ( $ this -> movements -> count ( ) > 0 ) { $ movement = $ this -> movements -> first ( ) ; if ( $ movement instanceof InventoryStockMovement && $ movement -> after > $ movement -> before ) { return sprintf ( '<b>%s</b> (Stock was added - %s) - <b>Reason:</b> %s' , $ movement -> change , $ movement -> created_at , $ movement -> reason ) ; } elseif ( $ movement -> before > $ movement -> after ) { return sprintf ( '<b>%s</b> (Stock was removed - %s) - <b>Reason:</b> %s' , $ movement -> change , $ movement -> created_at , $ movement -> reason ) ; } else { return sprintf ( '<b>%s</b> (No Change - %s) - <b>Reason:</b> %s' , $ movement -> change , $ movement -> created_at , $ movement -> reason ) ; } } return ; } 
public function getLastMovementByAttribute ( ) { if ( $ this -> movements -> count ( ) > 0 ) { $ movement = $ this -> movements -> first ( ) ; if ( $ movement instanceof InventoryStockMovement && $ movement -> user instanceof User ) { return $ movement -> user -> getRecipientName ( ) ; } } return ; } 
public function getQuantityMetricAttribute ( ) { $ quantity = $ this -> getAttribute ( 'quantity' ) ; if ( $ this -> item && $ this -> item -> metric ) { $ metric = $ this -> item -> metric -> name ; } else { $ metric = null ; } return trim ( sprintf ( '%s %s' , $ quantity , $ metric ) ) ; } 
public function btnPutBackSomeForWorkOrder ( WorkOrder $ workOrder ) { if ( $ this -> entity -> item ) { return view ( 'viewers.inventory.stock.buttons.put-back-some-work-order' , [ 'workOrder' => $ workOrder , 'stock' => $ this -> entity , ] ) ; } return ; } 
public function btnPutBackAllForWorkOrder ( WorkOrder $ workOrder ) { if ( $ this -> entity -> item ) { return view ( 'viewers.inventory.stock.buttons.put-back-all-work-order' , [ 'workOrder' => $ workOrder , 'stock' => $ this -> entity , ] ) ; } return ; } 
public function up ( ) { Schema :: create ( 'work_requests' , function ( Blueprint $ table ) { $ table -> increments ( 'id' ) ; $ table -> timestamps ( ) ; $ table -> softDeletes ( ) ; $ table -> integer ( 'user_id' ) -> unsigned ( ) -> nullable ( ) ; $ table -> string ( 'subject' ) ; $ table -> text ( 'description' ) ; $ table -> string ( 'best_time' ) ; $ table -> foreign ( 'user_id' ) -> references ( 'id' ) -> on ( 'users' ) -> onUpdate ( 'restrict' ) -> onDelete ( 'set null' ) ; } ) ; Schema :: create ( 'work_orders' , function ( Blueprint $ table ) { $ table -> increments ( 'id' ) ; $ table -> timestamps ( ) ; $ table -> softDeletes ( ) ; $ table -> integer ( 'user_id' ) -> unsigned ( ) -> nullable ( ) ; $ table -> integer ( 'category_id' ) -> unsigned ( ) -> nullable ( ) ; $ table -> integer ( 'location_id' ) -> unsigned ( ) -> nullable ( ) ; $ table -> integer ( 'request_id' ) -> unsigned ( ) -> nullable ( ) ; $ table -> integer ( 'status_id' ) -> unsigned ( ) ; $ table -> integer ( 'priority_id' ) -> unsigned ( ) ; $ table -> dateTime ( 'started_at' ) -> nullable ( ) ; $ table -> dateTime ( 'completed_at' ) -> nullable ( ) ; $ table -> string ( 'subject' ) ; $ table -> text ( 'description' ) -> nullable ( ) ; $ table -> foreign ( 'user_id' ) -> references ( 'id' ) -> on ( 'users' ) -> onUpdate ( 'restrict' ) -> onDelete ( 'set null' ) ; $ table -> foreign ( 'location_id' ) -> references ( 'id' ) -> on ( 'locations' ) -> onUpdate ( 'restrict' ) -> onDelete ( 'set null' ) ; $ table -> foreign ( 'category_id' ) -> references ( 'id' ) -> on ( 'categories' ) -> onUpdate ( 'restrict' ) -> onDelete ( 'set null' ) ; $ table -> foreign ( 'request_id' ) -> references ( 'id' ) -> on ( 'work_requests' ) -> onUpdate ( 'restrict' ) -> onDelete ( 'set null' ) ; $ table -> foreign ( 'status_id' ) -> references ( 'id' ) -> on ( 'statuses' ) -> onUpdate ( 'restrict' ) -> onDelete ( 'cascade' ) ; $ table -> foreign ( 'priority_id' ) -> references ( 'id' ) -> on ( 'priorities' ) -> onUpdate ( 'restrict' ) -> onDelete ( 'cascade' ) ; $ table -> unique ( [ 'request_id' ] ) ; } ) ; Schema :: create ( 'work_order_notifications' , function ( Blueprint $ table ) { $ table -> increments ( 'id' ) ; $ table -> timestamps ( ) ; $ table -> integer ( 'user_id' ) -> unsigned ( ) ; $ table -> integer ( 'work_order_id' ) -> unsigned ( ) ; $ table -> tinyInteger ( 'status' ) -> default ( 0 ) ; $ table -> tinyInteger ( 'priority' ) -> default ( 0 ) ; $ table -> tinyInteger ( 'parts' ) -> default ( 0 ) ; $ table -> tinyInteger ( 'customer_updates' ) -> default ( 0 ) ; $ table -> tinyInteger ( 'technician_updates' ) -> default ( 0 ) ; $ table -> tinyInteger ( 'completion_report' ) -> default ( 0 ) ; $ table -> foreign ( 'user_id' ) -> references ( 'id' ) -> on ( 'users' ) -> onUpdate ( 'restrict' ) -> onDelete ( 'cascade' ) ; $ table -> foreign ( 'work_order_id' ) -> references ( 'id' ) -> on ( 'work_orders' ) -> onUpdate ( 'restrict' ) -> onDelete ( 'cascade' ) ; } ) ; Schema :: create ( 'work_order_reports' , function ( Blueprint $ table ) { $ table -> increments ( 'id' ) ; $ table -> timestamps ( ) ; $ table -> integer ( 'user_id' ) -> unsigned ( ) ; $ table -> integer ( 'work_order_id' ) -> unsigned ( ) ; $ table -> text ( 'description' ) ; $ table -> foreign ( 'user_id' ) -> references ( 'id' ) -> on ( 'users' ) -> onUpdate ( 'restrict' ) -> onDelete ( 'cascade' ) ; $ table -> foreign ( 'work_order_id' ) -> references ( 'id' ) -> on ( 'work_orders' ) -> onUpdate ( 'restrict' ) -> onDelete ( 'cascade' ) ; } ) ; Schema :: create ( 'work_order_sessions' , function ( Blueprint $ table ) { $ table -> increments ( 'id' ) ; $ table -> timestamps ( ) ; $ table -> integer ( 'user_id' ) -> unsigned ( ) ; $ table -> integer ( 'work_order_id' ) -> unsigned ( ) ; $ table -> dateTime ( 'in' ) ; $ table -> dateTime ( 'out' ) -> nullable ( ) ; $ table -> decimal ( 'hours' , 5 , 2 ) -> nullable ( ) ; 
public function handle ( ) { $ this -> metric -> user_id = auth ( ) -> id ( ) ; $ this -> metric -> name = $ this -> request -> input ( 'name' ) ; $ this -> metric -> symbol = $ this -> request -> input ( 'symbol' ) ; return $ this -> metric -> save ( ) ; } 
public function end ( $ workOrderId ) { if ( $ this -> processor -> end ( $ workOrderId ) ) { flash ( ) -> success ( 'Success!' , 'Successfully ended your session. Your hours have been logged.' ) ; return redirect ( ) -> route ( 'maintenance.work-orders.show' , [ $ workOrderId ] ) ; } else { flash ( ) -> error ( 'Error!' , 'There was an issue ending your session. Please try again.' ) ; return redirect ( ) -> route ( 'maintenance.work-orders.show' , [ $ workOrderId ] ) ; } } 
public function table ( $ workRequest ) { return $ this -> table -> of ( 'work-requests' , function ( TableGrid $ table ) use ( $ workRequest ) { $ table -> with ( $ workRequest ) -> paginate ( $ this -> perPage ) ; $ table -> attributes ( [ 'class' => 'table table-hover table-striped' , ] ) ; $ table -> column ( 'ID' , 'id' ) ; $ table -> column ( 'subject' , function ( Column $ column ) { $ column -> value = function ( WorkRequest $ workRequest ) { return link_to_route ( 'maintenance.work-requests.show' , $ workRequest -> subject , [ $ workRequest -> getKey ( ) ] ) ; } ; } ) ; $ table -> column ( 'best_time' ) ; $ table -> column ( 'created_at' ) ; } ) ; } 
public function form ( WorkRequest $ request ) { return $ this -> form -> of ( 'work-requests' , function ( FormGrid $ form ) use ( $ request ) { if ( $ request -> exists ) { $ method = 'PATCH' ; $ url = route ( 'maintenance.work-requests.update' , [ $ request -> getKey ( ) ] ) ; $ form -> submit = 'Save' ; } else { $ method = 'POST' ; $ url = route ( 'maintenance.work-requests.store' ) ; $ form -> submit = 'Create' ; } $ form -> with ( $ request ) ; $ form -> attributes ( compact ( 'method' , 'url' ) ) ; $ form -> fieldset ( function ( Fieldset $ fieldset ) { $ fieldset -> control ( 'input:text' , 'subject' ) -> attributes ( [ 'placeholder' => 'Enter Subject' , ] ) ; $ fieldset -> control ( 'input:text' , 'best_time' ) -> attributes ( [ 'placeholder' => 'Enter Best Time' , ] ) ; $ fieldset -> control ( 'input:textarea' , 'description' ) ; } ) ; } ) ; } 
public function store ( $ workOrder_id ) { if ( $ this -> assignmentValidator -> passes ( ) ) { $ workOrder = $ this -> workOrder -> find ( $ workOrder_id ) ; $ data = $ this -> inputAll ( ) ; $ data [ 'work_order_id' ] = $ workOrder -> id ; $ records = $ this -> assignment -> setInput ( $ data ) -> create ( ) ; if ( $ records ) { $ this -> message = 'Successfully assigned worker(s)' ; $ this -> messageType = 'success' ; $ this -> redirect = route ( 'maintenance.work-orders.show' , [ $ workOrder -> id ] ) ; } else { $ this -> message = 'There was an error trying to assign workers to this work order. Please try again.' ; $ this -> messageType = 'danger' ; $ this -> redirect = route ( 'maintenance.work-orders.show' , [ $ workOrder -> id ] ) ; } } else { $ this -> errors = $ this -> assignmentValidator -> getErrors ( ) ; $ this -> redirect = route ( 'maintenance.work-orders.show' , [ $ workOrder_id ] ) ; } return $ this -> response ( ) ; } 
public function destroy ( $ workOrder_id , $ assignment_id ) { if ( $ this -> assignment -> destroy ( $ assignment_id ) ) { $ this -> message = 'Successfully removed worker from this work order.' ; $ this -> messageType = 'success' ; $ this -> redirect = route ( 'maintenance.work-orders.show' , [ $ workOrder_id ] ) ; } else { $ this -> message = 'There was an error trying to remove this worker from this work order. Please try again later.' ; $ this -> messageType = 'danger' ; $ this -> redirect = route ( 'maintenance.work-orders.show' , [ $ workOrder_id ] ) ; } return $ this -> response ( ) ; } 
public function getReadingWithMetricAttribute ( ) { if ( $ this -> meter && $ this -> meter -> metric ) { return $ this -> reading . ' ' . $ this -> meter -> metric -> symbol ; } return $ this -> reading ; } 
public function select ( string $ name , iterable $ list = [ ] , $ selected = null , array $ selectAttributes = [ ] , array $ optionsAttributes = [ ] , array $ optgroupsAttributes = [ ] ) : Htmlable { $ this -> type = 'select' ; 
public function datalist ( string $ id , array $ list = [ ] ) : Htmlable { $ this -> type = 'datalist' ; $ attributes [ 'id' ] = $ id ; $ html = [ ] ; if ( Arr :: isAssoc ( $ list ) ) { foreach ( $ list as $ value => $ display ) { $ html [ ] = $ this -> option ( $ display , $ value , null , [ ] ) ; } } else { foreach ( $ list as $ value ) { $ html [ ] = $ this -> option ( $ value , $ value , null , [ ] ) ; } } $ attributes = $ this -> getHtmlBuilder ( ) -> attributes ( $ attributes ) ; $ list = \ implode ( '' , $ html ) ; return $ this -> toHtmlString ( "<datalist{$attributes}>{$list}</datalist>" ) ; } 
public function getSelectOption ( $ display , string $ value , $ selected , array $ attributes = [ ] , array $ optgroups = [ ] ) : Htmlable { if ( \ is_iterable ( $ display ) ) { return $ this -> optionGroup ( $ display , $ value , $ selected , $ optgroups , $ attributes ) ; } return $ this -> option ( $ display , $ value , $ selected , $ attributes ) ; } 
protected function optionGroup ( iterable $ list , string $ label , $ selected , array $ attributes = [ ] , array $ optionsAttributes = [ ] , int $ level = 0 ) : Htmlable { $ html = [ ] ; $ space = \ str_repeat ( '&nbsp;' , $ level ) ; foreach ( $ list as $ value => $ display ) { if ( \ is_iterable ( $ display ) ) { $ html [ ] = $ this -> option ( $ display , $ value , $ selected , $ optionsAttributes [ $ value ] ?? [ ] , $ level + 5 ) ; } else { $ html [ ] = $ this -> option ( $ space . $ display , $ value , $ selected , $ optionsAttributes [ $ value ] ?? [ ] ) ; } } return $ this -> toHtmlString ( \ sprintf ( '<optgroup label="%s"%s>%s</optgroup>' , $ this -> entities ( $ label ) , $ this -> getHtmlBuilder ( ) -> attributes ( $ attributes ) , \ implode ( '' , $ html ) ) ) ; } 
protected function option ( string $ display , string $ value , $ selected , array $ attributes = [ ] , array $ optgroups = [ ] ) : Htmlable { $ selected = $ this -> getSelectedValue ( $ value , $ selected ) ; $ options = [ 'value' => $ value , 'selected' => $ selected ] + $ attributes ; return $ this -> toHtmlString ( \ sprintf ( '<option%s>%s</option>' , $ this -> getHtmlBuilder ( ) -> attributes ( $ options ) , $ this -> entities ( $ display ) ) ) ; } 
protected function placeholderOption ( string $ display , $ selected ) : Htmlable { $ options = [ 'selected' => $ this -> getSelectedValue ( null , $ selected ) , 'disabled' => true , 'value' => '' , ] ; return $ this -> toHtmlString ( \ sprintf ( '<option%s>%s</option>' , $ this -> getHtmlBuilder ( ) -> attributes ( $ options ) , $ this -> entities ( $ display ) ) ) ; } 
protected function getSelectedValue ( ? string $ value , $ selected ) : ? string { $ selection = $ selected instanceof Arrayable ? $ selected -> toArray ( ) : $ selected ; if ( \ is_array ( $ selection ) ) { if ( \ in_array ( $ value , $ selection , true ) || \ in_array ( ( string ) $ value , $ selection , true ) ) { return 'selected' ; } elseif ( $ selected instanceof Collection ) { return $ selected -> contains ( $ value ) ? 'selected' : null ; } return null ; } if ( \ is_int ( $ value ) && \ is_bool ( $ selected ) ) { return ( bool ) $ value === $ selected ; } return ( ( string ) $ value === ( string ) $ selected ) ? 'selected' : null ; } 
public function selectYear ( string $ name , $ begin , $ end , $ selected = null , array $ options = [ ] ) : Htmlable { return $ this -> selectRange ( $ name , $ begin , $ end , $ selected , $ options ) ; } 
public function open ( array $ options = [ ] ) : Htmlable { $ method = $ options [ 'method' ] ?? 'post' ; 
protected function getAppendage ( string $ method ) : string { list ( $ method , $ appendage ) = [ \ strtoupper ( $ method ) , '' ] ; 
protected function getAction ( array $ options ) : string { 
protected function renderComponent ( string $ name , array $ arguments ) : Htmlable { $ component = static :: $ components [ $ name ] ; $ data = $ this -> getComponentData ( $ component [ 'signature' ] , $ arguments ) ; return new HtmlString ( $ this -> view -> make ( $ component [ 'view' ] , $ data ) -> render ( ) ) ; } 
protected function getComponentData ( array $ signature , array $ arguments ) : array { $ data = [ ] ; $ i = 0 ; foreach ( $ signature as $ variable => $ default ) { 
protected function register ( ) { $ this -> app -> afterResolving ( 'blade.compiler' , function ( BladeCompiler $ bladeCompiler ) { $ namespaces = [ 'Html' => \ get_class_methods ( HtmlBuilder :: class ) , 'Form' => \ get_class_methods ( FormBuilder :: class ) , ] ; foreach ( $ namespaces as $ namespace => $ methods ) { foreach ( $ methods as $ method ) { if ( \ in_array ( $ method , $ this -> directives ) ) { $ snakeMethod = Str :: snake ( $ method ) ; $ directive = \ strtolower ( $ namespace ) . '_' . $ snakeMethod ; $ bladeCompiler -> directive ( $ directive , function ( $ expression ) use ( $ namespace , $ method ) { return "<?php echo $namespace::$method($expression); ?>" ; } ) ; } } } } ) ; } 
protected function entities ( string $ value , bool $ encoding = false ) : string { return $ this -> html -> entities ( $ value , $ encoding ) ; } 
public function model ( $ model , array $ options = [ ] ) : Htmlable { $ this -> model = $ model ; return $ this -> open ( $ options ) ; } 
public function label ( string $ name , ? string $ value = null , array $ options = [ ] ) : Htmlable { $ this -> labels [ ] = $ name ; $ options = $ this -> html -> attributes ( $ options ) ; $ value = $ this -> entities ( $ this -> formatLabel ( $ name , $ value ) ) ; return $ this -> toHtmlString ( '<label for="' . $ name . '"' . $ options . '>' . $ value . '</label>' ) ; } 
protected function formatLabel ( string $ name , ? string $ value ) : string { return $ value ?? \ ucwords ( \ str_replace ( '_' , ' ' , $ name ) ) ; } 
protected function missingOldAndModel ( string $ name ) : bool { return \ is_null ( $ this -> old ( $ name ) ) && \ is_null ( $ this -> getModelValueAttribute ( $ name ) ) ; } 
public function reset ( ? string $ value = null , array $ attributes = [ ] ) : Htmlable { return $ this -> input ( 'reset' , null , $ value , $ attributes ) ; } 
public function submit ( ? string $ value = null , array $ options = [ ] ) : Htmlable { return $ this -> input ( 'submit' , null , $ value , $ options ) ; } 
public function button ( ? string $ value = null , array $ options = [ ] , bool $ escape = true ) : Htmlable { if ( ! \ array_key_exists ( 'type' , $ options ) ) { $ options [ 'type' ] = 'button' ; } if ( $ escape ) { $ value = $ this -> html -> entities ( $ value ) ; } return $ this -> toHtmlString ( '<button' . $ this -> html -> attributes ( $ options ) . '>' . $ value . '</button>' ) ; } 
public function getValueAttribute ( ? string $ name , $ value = null ) { if ( \ is_null ( $ name ) ) { return $ value ; } if ( ! \ is_null ( $ old = $ this -> old ( $ name ) ) && $ name !== '_method' ) { return $ old ; } if ( \ class_exists ( Kernel :: class , false ) ) { $ hasNullMiddleware = \ app ( Kernel :: class ) -> hasMiddleware ( ConvertEmptyStringsToNull :: class ) ; if ( $ hasNullMiddleware && \ is_null ( $ old ) && \ is_null ( $ value ) && ! \ is_null ( $ this -> view -> shared ( 'errors' ) ) && \ count ( $ this -> view -> shared ( 'errors' ) ) > 0 ) { return null ; } } if ( ! \ is_null ( $ request = $ this -> request ( $ name ) ) && $ name !== '_method' ) { return $ request ; } if ( ! \ is_null ( $ value ) ) { return $ value ; } if ( isset ( $ this -> model ) ) { return $ this -> getModelValueAttribute ( $ name ) ; } } 
protected function request ( string $ name ) { if ( ! $ this -> considerRequest || ! isset ( $ this -> request ) ) { return null ; } return $ this -> request -> input ( $ this -> transformKey ( $ name ) ) ; } 
public function entities ( $ value , bool $ encoding = false ) : string { if ( $ value instanceof Htmlable ) { return $ value -> toHtml ( ) ; } return \ htmlentities ( $ value , ENT_QUOTES , 'UTF-8' , $ encoding ) ; } 
public function script ( string $ url , array $ attributes = [ ] , ? bool $ secure = null ) : Htmlable { $ attributes [ 'src' ] = $ this -> url -> asset ( $ url , $ secure ) ; return $ this -> toHtmlString ( '<script' . $ this -> attributes ( $ attributes ) . '></script>' ) ; } 
public function style ( string $ url , array $ attributes = [ ] , ? bool $ secure = null ) : Htmlable { $ defaults = [ 'media' => 'all' , 'type' => 'text/css' , 'rel' => 'stylesheet' ] ; $ attributes = \ array_merge ( $ defaults , $ attributes ) ; $ attributes [ 'href' ] = $ this -> url -> asset ( $ url , $ secure ) ; return $ this -> toHtmlString ( '<link' . $ this -> attributes ( $ attributes ) . '>' ) ; } 
public function image ( string $ url , ? string $ alt = null , array $ attributes = [ ] , ? bool $ secure = null ) : Htmlable { $ attributes [ 'alt' ] = $ alt ; return $ this -> toHtmlString ( '<img src="' . $ this -> url -> asset ( $ url , $ secure ) . '"' . $ this -> attributes ( $ attributes ) . '>' ) ; } 
public function linkAsset ( string $ url , ? string $ title = null , array $ attributes = [ ] , ? bool $ secure = null ) : Htmlable { $ url = $ this -> url -> asset ( $ url , $ secure ) ; return $ this -> link ( $ url , $ title ? : $ url , $ attributes , $ secure ) ; } 
public function linkRoute ( string $ name , ? string $ title = null , array $ parameters = [ ] , array $ attributes = [ ] ) : Htmlable { return $ this -> link ( $ this -> url -> route ( $ name , $ parameters ) , $ title , $ attributes ) ; } 
public function mailto ( string $ email , ? string $ title = null , array $ attributes = [ ] , bool $ escape = true ) : Htmlable { $ email = $ this -> email ( $ email ) ; $ title = $ title ? : $ email ; if ( $ escape ) { $ title = $ this -> entities ( $ title ) ; } $ email = $ this -> obfuscate ( 'mailto:' ) . $ email ; return $ this -> toHtmlString ( '<a href="' . $ email . '"' . $ this -> attributes ( $ attributes ) . '>' . $ title . '</a>' ) ; } 
public function dl ( array $ list , array $ attributes = [ ] ) : Htmlable { $ attributes = $ this -> attributes ( $ attributes ) ; $ html = "<dl{$attributes}>" ; foreach ( $ list as $ key => $ value ) { $ html .= "<dt>{$key}</dt>" ; foreach ( ( array ) $ value as $ description ) { $ html .= "<dd>{$description}</dd>" ; } } $ html .= '</dl>' ; return $ this -> toHtmlString ( $ html ) ; } 
protected function listingElement ( $ key , string $ type , $ value ) : string { if ( \ is_array ( $ value ) ) { return $ this -> nestedListing ( $ key , $ type , $ value ) ; } else { return '<li>' . $ this -> entities ( $ value ) . '</li>' ; } } 
public function attributes ( array $ attributes ) : string { $ html = [ ] ; 
protected function attributeElement ( $ key , $ value ) { 
public function meta ( ? string $ name , $ content , array $ attributes = [ ] ) : Htmlable { $ attributes = \ array_merge ( \ compact ( 'name' , 'content' ) , $ attributes ) ; return $ this -> toHtmlString ( '<meta' . $ this -> attributes ( $ attributes ) . '>' ) ; } 
protected function registerHtmlBuilder ( ) : void { $ this -> app -> singleton ( 'html' , function ( $ app ) { return new HtmlBuilder ( $ app -> make ( 'url' ) , $ app -> make ( 'view' ) ) ; } ) ; } 
protected function registerFormBuilder ( ) : void { $ this -> app -> singleton ( 'form' , function ( $ app ) { return ( new FormBuilder ( $ app -> make ( 'html' ) , $ app -> make ( 'url' ) , $ app -> make ( 'view' ) , $ app -> make ( 'request' ) ) ) -> setSessionStore ( $ app -> make ( 'session.store' ) ) ; } ) ; } 
public function checkbox ( string $ name , $ value = 1 , ? bool $ checked = null , array $ options = [ ] ) : Htmlable { return $ this -> checkable ( 'checkbox' , $ name , $ value , $ checked , $ options ) ; } 
public function radio ( string $ name , $ value = null , ? bool $ checked = null , array $ options = [ ] ) : Htmlable { \ is_null ( $ value ) && $ value = $ name ; return $ this -> checkable ( 'radio' , $ name , $ value , $ checked , $ options ) ; } 
protected function checkable ( string $ type , string $ name , $ value , ? bool $ checked , array $ options ) : Htmlable { $ this -> type = $ type ; $ checked = $ this -> getCheckedState ( $ type , $ name , $ value , $ checked ) ; $ checked && $ options [ 'checked' ] = 'checked' ; return $ this -> input ( $ type , $ name , $ value , $ options ) ; } 
public function old ( string $ name ) { if ( ! isset ( $ this -> session ) ) { return null ; } $ key = $ this -> transformKey ( $ name ) ; $ payload = $ this -> session -> getOldInput ( $ key ) ; if ( ! \ is_array ( $ payload ) ) { return $ payload ; } if ( ! \ in_array ( $ this -> type , [ 'select' , 'checkbox' ] ) ) { if ( ! isset ( $ this -> payload [ $ key ] ) ) { $ this -> payload [ $ key ] = Collection :: make ( $ payload ) ; } if ( ! empty ( $ this -> payload [ $ key ] ) ) { $ value = $ this -> payload [ $ key ] -> shift ( ) ; return $ value ; } } return $ payload ; } 
public function search ( string $ name , ? string $ value = null , array $ options = [ ] ) : Htmlable { return $ this -> input ( 'search' , $ name , $ value , $ options ) ; } 
public function datetime ( string $ name , $ value = null , array $ options = [ ] ) : Htmlable { if ( $ value instanceof DateTime ) { $ value = $ value -> format ( DateTime :: RFC3339 ) ; } return $ this -> input ( 'datetime' , $ name , $ value , $ options ) ; } 
public function file ( string $ name , array $ options = [ ] ) : Htmlable { return $ this -> input ( 'file' , $ name , null , $ options ) ; } 
public function up ( ) { Schema :: create ( 'cas_proxy_granting_tickets' , function ( Blueprint $ table ) { $ table -> charset = 'utf8' ; $ table -> collation = 'utf8_general_ci' ; $ table -> increments ( 'id' ) ; $ table -> string ( 'ticket' , 256 ) -> unique ( ) ; $ table -> string ( 'pgt_url' , 1024 ) ; $ table -> integer ( 'service_id' ) -> unsigned ( ) ; $ table -> integer ( 'user_id' ) -> unsigned ( ) ; $ table -> text ( 'proxies' ) -> nullable ( ) ; $ table -> timestamp ( 'created_at' ) -> nullable ( ) ; $ table -> timestamp ( 'expire_at' ) -> nullable ( ) ; $ table -> foreign ( 'service_id' ) -> references ( 'id' ) -> on ( 'cas_services' ) ; $ table -> foreign ( 'user_id' ) -> references ( config ( 'cas.user_table.id' ) ) -> on ( config ( 'cas.user_table.name' ) ) ; } ) ; } 
protected function removeXmlFirstLine ( $ str ) { $ first = '<?xml version="1.0"?>' ; if ( Str :: startsWith ( $ str , $ first ) ) { return trim ( substr ( $ str , strlen ( $ first ) ) ) ; } return $ str ; } 
public function up ( ) { Schema :: create ( 'cas_service_hosts' , function ( Blueprint $ table ) { $ table -> increments ( 'id' ) ; $ table -> string ( 'host' ) -> charset ( 'utf8' ) -> collate ( 'utf8_general_ci' ) -> unique ( ) ; $ table -> integer ( 'service_id' ) -> unsigned ( ) ; $ table -> foreign ( 'service_id' ) -> references ( 'id' ) -> on ( 'cas_services' ) ; } ) ; } 
public function up ( ) { Schema :: create ( 'cas_services' , function ( Blueprint $ table ) { $ table -> increments ( 'id' ) ; $ table -> string ( 'name' ) -> charset ( 'utf8' ) -> collate ( 'utf8_general_ci' ) -> unique ( ) ; $ table -> boolean ( 'allow_proxy' ) -> default ( false ) ; $ table -> boolean ( 'enabled' ) -> default ( true ) ; $ table -> timestamps ( ) ; } ) ; } 
private function tokenize ( $ input ) { $ tokens = array ( ) ; $ splits = preg_split ( "/([" . implode ( "" , $ this -> whitespaces ) . "]+)/u" , $ input , - 1 , PREG_SPLIT_DELIM_CAPTURE ) ; foreach ( $ splits as $ split ) { if ( $ split === '' ) { $ tokens [ ] = new EmptyToken ( $ split ) ; continue ; } if ( preg_match ( "/^[" . implode ( "" , $ this -> whitespaces ) . "]+$/um" , $ split ) ) { $ tokens [ ] = new WhitespaceToken ( $ split ) ; continue ; } $ tokens [ ] = new WordToken ( $ split ) ; } return $ tokens ; } 
public function run ( t \ TokenRegistry $ tokens ) { foreach ( $ tokens as $ token ) { if ( ! $ token instanceof t \ WordToken ) { continue ; } $ string = $ token -> getFilteredContent ( ) ; $ pattern = $ token -> getMergedPattern ( $ this -> options -> getQuality ( ) ) ; $ length = $ token -> length ( ) ; $ lastOne = 0 ; $ result = array ( ) ; for ( $ i = 1 ; $ i <= $ length ; $ i ++ ) { $ currPattern = mb_substr ( $ pattern , $ i , 1 ) ; if ( $ i < $ this -> options -> getLeftMin ( ) ) { continue ; } if ( $ i > ( $ length - $ this -> options -> getRightMin ( ) ) ) { continue ; } if ( 0 == $ currPattern ) { continue ; } if ( 0 === ( int ) $ currPattern % 2 ) { continue ; } $ sylable = mb_substr ( $ string , $ lastOne , $ i - $ lastOne ) ; $ lastOne = $ i ; $ result [ ] = $ sylable ; } $ result [ ] = mb_substr ( $ string , $ lastOne ) ; $ token -> setFilteredContent ( implode ( $ this -> options -> getHyphen ( ) , $ result ) ) ; } return $ tokens ; } 
protected function doConcatenate ( t \ TokenRegistry $ tokens ) { $ string = '' ; foreach ( $ tokens as $ token ) { $ string .= $ token -> getFilteredContent ( ) ; } return $ string ; } 
public function load ( $ locale ) { $ locale = $ this -> unifyLocale ( $ locale ) ; $ file = self :: $ fileLocation . DIRECTORY_SEPARATOR . $ locale . '.ini' ; $ this -> dictionary = array ( ) ; if ( ! file_exists ( realpath ( $ file ) ) ) { return $ this ; } foreach ( parse_ini_file ( $ file ) as $ key => $ val ) { $ this -> dictionary [ str_replace ( '@:' , '' , $ key ) ] = $ val ; } return $ this ; } 
public static function parseFile ( $ locale ) { $ path = self :: $ fileLocation . DIRECTORY_SEPARATOR ; $ file = $ path . 'hyph_' . $ locale . '.dic' ; if ( ! file_Exists ( $ file ) ) { throw new \ Org \ Heigl \ Hyphenator \ Exception \ PathNotFoundException ( 'The given Path does not exist' ) ; } $ items = file ( $ file ) ; $ source = trim ( $ items [ 0 ] ) ; if ( 0 === strpos ( $ source , 'ISO8859' ) ) { $ source = str_Replace ( 'ISO8859' , 'ISO-8859' , $ source ) ; } unset ( $ items [ 0 ] ) ; $ fh = fopen ( $ path . $ locale . '.ini' , 'w+' ) ; foreach ( $ items as $ item ) { 
public function getPatternsForWord ( $ word ) { $ return = array ( ) ; $ word = '.' . $ word . '.' ; $ strlen = mb_strlen ( $ word ) ; for ( $ i = 0 ; $ i <= $ strlen ; $ i ++ ) { for ( $ j = 2 ; $ j <= ( $ strlen - $ i ) ; $ j ++ ) { $ substr = mb_substr ( $ word , $ i , $ j ) ; if ( ! isset ( $ this -> dictionary [ $ substr ] ) ) { continue ; } $ return [ $ substr ] = $ this -> dictionary [ $ substr ] ; } } return $ return ; } 
private function unifyLocale ( $ locale ) { if ( 2 == strlen ( $ locale ) ) { return strtolower ( $ locale ) ; } if ( preg_match ( '/([a-zA-Z]{2})[^a-zA-Z]+([a-zA-Z]{2})/i' , $ locale , $ result ) ) { return strtolower ( $ result [ 1 ] ) . '_' . strtoupper ( $ result [ 2 ] ) ; } return ( string ) $ locale ; } 
public function add ( Tokenizer $ tokenizer ) { if ( ! in_array ( $ tokenizer , $ this -> registry ) ) { $ this -> registry [ ] = $ tokenizer ; } return $ this ; } 
public function getTokenizerWithKey ( $ key ) { if ( array_key_exists ( $ key , $ this -> registry ) ) { return $ this -> registry [ $ key ] ; } return null ; } 
public function tokenize ( $ string ) { if ( ! $ string instanceof TokenRegistry ) { $ wt = new WordToken ( $ string ) ; $ string = new TokenRegistry ( ) ; $ string -> add ( $ wt ) ; } foreach ( $ this as $ tokenizer ) { $ string = $ tokenizer -> run ( $ string ) ; } return $ string ; } 
private function tokenize ( $ input ) { $ tokens = array ( ) ; $ splits = preg_split ( "/(<\/?[^>]+\/?>)/u" , $ input , - 1 , PREG_SPLIT_DELIM_CAPTURE ) ; foreach ( $ splits as $ split ) { if ( ! $ split ) { continue ; } if ( 0 === mb_strpos ( $ split , '<' ) ) { $ tokens [ ] = new NonWordToken ( $ split ) ; continue ; } $ tokens [ ] = new WordToken ( $ split ) ; } return $ tokens ; } 
public function run ( $ input ) { if ( $ input instanceof TokenRegistry ) { 
private function tokenize ( $ input ) { $ tokens = [ ] ; $ splits = preg_split ( sprintf ( '/((?:(?<=\W)%1$s|\b\w+%2$s)\w+?\b)/u' , $ this -> options -> getNoHyphenateString ( ) , $ this -> options -> getCustomHyphen ( ) ) , $ input , - 1 , PREG_SPLIT_DELIM_CAPTURE ) ; foreach ( $ splits as $ split ) { if ( '' == $ split ) { continue ; } if ( 0 === mb_strpos ( $ split , $ this -> options -> getNoHyphenateString ( ) ) ) { $ tokens [ ] = new ExcludedWordToken ( str_replace ( $ this -> options -> getNoHyphenateString ( ) , '' , $ split ) ) ; continue ; } if ( false !== mb_strpos ( $ split , $ this -> options -> getCustomHyphen ( ) ) ) { $ tokens [ ] = new ExcludedWordToken ( str_replace ( $ this -> options -> getCustomHyphen ( ) , $ this -> options -> getHyphen ( ) , $ split ) ) ; continue ; } $ tokens [ ] = new WordToken ( $ split ) ; } return $ tokens ; } 
public function setOptions ( \ Org \ Heigl \ Hyphenator \ Options $ options ) { $ this -> options = $ options ; return $ this ; } 
public function add ( Dictionary $ dict ) { if ( ! in_array ( $ dict , $ this -> registry ) ) { $ this -> registry [ ] = $ dict ; } return $ this ; } 
public function getDictionaryWithKey ( $ key ) { if ( array_key_exists ( $ key , $ this -> registry ) ) { return $ this -> registry [ $ key ] ; } return null ; } 
public function getHyphenationPattterns ( $ word ) { $ pattern = array ( ) ; foreach ( $ this as $ dictionary ) { $ pattern = array_merge ( $ pattern , $ dictionary -> getPatternsForWord ( $ word ) ) ; } return $ pattern ; } 
public function setFilters ( $ filters ) { $ this -> filters = array ( ) ; if ( ! is_array ( $ filters ) ) { $ filters = explode ( ',' , $ filters ) ; } foreach ( $ filters as $ filter ) { $ this -> addFilter ( $ filter ) ; } return $ this ; } 
public function addFilter ( $ filter ) { if ( is_string ( $ filter ) ) { $ filter = trim ( $ filter ) ; } elseif ( ! $ filter instanceof Filter ) { throw new \ UnexpectedValueException ( 'Expceted instanceof Org\Heigl\Hyphenator\Filter\Filter or string' ) ; } if ( ! $ filter ) { return $ this ; } $ this -> filters [ ] = $ filter ; return $ this ; } 
public function setTokenizers ( $ tokenizers ) { $ this -> tokenizers = array ( ) ; if ( ! is_array ( $ tokenizers ) ) { $ tokenizers = explode ( ',' , $ tokenizers ) ; } foreach ( $ tokenizers as $ tokenizer ) { $ this -> addTokenizer ( $ tokenizer ) ; } return $ this ; } 
public function addTokenizer ( $ tokenizer ) { if ( is_string ( $ tokenizer ) ) { $ tokenizer = trim ( $ tokenizer ) ; } elseif ( ! $ tokenizer instanceof Tokenizer ) { throw new \ UnexpectedValueException ( 'Expceted instanceof Org\Heigl\Hyphenator\Tokenizer\Tokenizer or string' ) ; } if ( ! $ tokenizer ) { return $ this ; } $ this -> tokenizers [ ] = $ tokenizer ; return $ this ; } 
public static function factory ( $ file ) { if ( ! file_Exists ( $ file ) ) { $ file = $ file . '.dist' ; if ( ! file_exists ( $ file ) ) { throw new \ Org \ Heigl \ Hyphenator \ Exception \ PathNotFoundException ( $ file ) ; } } $ params = parse_ini_file ( $ file ) ; if ( ! is_array ( $ params ) || 1 > count ( $ params ) ) { throw new \ Org \ Heigl \ Hyphenator \ Exception \ InvalidArgumentException ( $ file . ' is not a parseable file' ) ; } $ option = new Options ( ) ; foreach ( $ params as $ key => $ val ) { if ( ! method_Exists ( $ option , 'set' . $ key ) ) { continue ; } call_user_Func ( array ( $ option , 'set' . $ key ) , $ val ) ; } return $ option ; } 
public function setPattern ( $ pattern ) { $ item = trim ( $ pattern ) ; $ strlen = mb_strlen ( $ item ) ; $ return = array ( ) ; for ( $ i = 0 ; $ i < $ strlen ; $ i ++ ) { if ( ( ( $ i ) <= $ strlen ) && preg_match ( '/[0-9]/u' , mb_substr ( $ item , $ i , 1 ) ) ) { $ this -> pattern .= mb_substr ( $ item , $ i , 1 ) ; $ i ++ ; } else { $ this -> pattern .= '0' ; } } $ this -> text = preg_replace ( array ( '/[0-9]/u' , '/\'/u' ) , array ( '' , '\\’'), $ t em); if ( strlen ( $ this -> pattern ) == mb_strlen ( $ this -> text ) ) { $ this -> pattern .= '0' ; } return $ this ; } 
public function getText ( ) { if ( ! $ this -> text ) { throw new \ Org \ Heigl \ Hyphenator \ Exception \ NoPatternSetException ( 'No Pattern set' ) ; } return $ this -> text ; } 
public function getPattern ( ) { if ( ! $ this -> pattern ) { throw new \ Org \ Heigl \ Hyphenator \ Exception \ NoPatternSetException ( 'No Pattern set' ) ; } return $ this -> pattern ; } 
public function setOptions ( Options $ options ) { $ this -> options = $ options ; $ this -> tokenizers -> cleanup ( ) ; foreach ( $ this -> options -> getTokenizers ( ) as $ tokenizer ) { $ this -> addTokenizer ( $ tokenizer ) ; } return $ this ; } 
public function getOptions ( ) { if ( null === $ this -> options ) { $ optFile = $ this -> getHomePath ( ) . DIRECTORY_SEPARATOR . 'Hyphenator.properties' ; $ this -> setOptions ( Options :: factory ( $ optFile ) ) ; } return $ this -> options ; } 
public function addDictionary ( $ dictionary ) { if ( ! $ dictionary instanceof \ Org \ Heigl \ Hyphenator \ Dictionary \ Dictionary ) { \ Org \ Heigl \ Hyphenator \ Dictionary \ Dictionary :: setFileLocation ( $ this -> getHomePath ( ) . '/files/dictionaries' ) ; $ dictionary = \ Org \ Heigl \ Hyphenator \ Dictionary \ Dictionary :: factory ( $ dictionary ) ; } $ this -> dicts -> add ( $ dictionary ) ; return $ this ; } 
public function addFilter ( $ filter ) { if ( ! $ filter instanceof \ Org \ Heigl \ Hyphenator \ Filter \ Filter ) { $ filter = '\\Org\\Heigl\\Hyphenator\\Filter\\' . ucfirst ( $ filter ) . 'Filter' ; $ filter = new $ filter ( ) ; } $ filter -> setOptions ( $ this -> getOptions ( ) ) ; $ this -> filters -> add ( $ filter ) ; return $ this ; } 
public function addTokenizer ( $ tokenizer ) { if ( ! $ tokenizer instanceof \ Org \ Heigl \ Hyphenator \ Tokenizer \ Tokenizer ) { $ tokenizer = '\\Org\\Heigl\Hyphenator\\Tokenizer\\' . ucfirst ( $ tokenizer ) . 'Tokenizer' ; $ tokenizer = new $ tokenizer ( ) ; } $ this -> tokenizers -> add ( $ tokenizer ) ; return $ this ; } 
public function getTokenizers ( ) { if ( 0 == $ this -> tokenizers -> count ( ) ) { foreach ( $ this -> getOptions ( ) -> getTokenizers ( ) as $ tokenizer ) { $ this -> addTokenizer ( $ tokenizer ) ; } } return $ this -> tokenizers ; } 
public function getDictionaries ( ) { if ( 0 == $ this -> dicts -> count ( ) ) { $ this -> addDictionary ( $ this -> getOptions ( ) -> getDefaultLocale ( ) ) ; } return $ this -> dicts ; } 
public function getFilters ( ) { if ( 0 == $ this -> filters -> count ( ) ) { foreach ( $ this -> getOptions ( ) -> getFilters ( ) as $ filter ) { $ this -> addFilter ( $ filter ) ; } } return $ this -> filters ; } 
public function hyphenate ( $ string ) { $ tokens = $ this -> tokenizers -> tokenize ( $ string ) ; $ tokens = $ this -> getHyphenationPattern ( $ tokens ) ; $ tokens = $ this -> filter ( $ tokens ) ; if ( 1 === count ( $ tokens ) && 1 === $ this -> getFilters ( ) -> count ( ) ) { $ tokens -> rewind ( ) ; return $ tokens -> current ( ) -> getHyphenatedContent ( ) ; } return $ this -> getFilters ( ) -> concatenate ( $ tokens ) ; } 
public function getHyphenationPattern ( Tokenizer \ TokenRegistry $ registry ) { $ minWordLength = $ this -> getOptions ( ) -> getMinWordLength ( ) ; foreach ( $ registry as $ token ) { if ( ! $ token instanceof \ Org \ Heigl \ Hyphenator \ Tokenizer \ WordToken ) { continue ; } if ( $ minWordLength > $ token -> length ( ) ) { continue ; } $ this -> getPatternForToken ( $ token ) ; } return $ registry ; } 
public function getPatternForToken ( Tokenizer \ WordToken $ token ) { foreach ( $ this -> getDictionaries ( ) as $ dictionary ) { $ token -> addPattern ( $ dictionary -> getPatternsForWord ( $ token -> get ( ) ) ) ; } return $ token ; } 
public static function setDefaultHomePath ( $ homePath ) { if ( ! file_exists ( $ homePath ) ) { throw new Exception \ PathNotFoundException ( $ homePath . ' does not exist' ) ; } if ( ! is_Dir ( $ homePath ) ) { throw new Exception \ PathNotDirException ( $ homePath . ' is not a directory' ) ; } self :: $ defaultHomePath = realpath ( $ homePath ) ; } 
public static function getDefaultHomePath ( ) { if ( is_Dir ( self :: $ defaultHomePath ) ) { return self :: $ defaultHomePath ; } if ( defined ( 'HYPHENATOR_HOME' ) && is_Dir ( HYPHENATOR_HOME ) ) { return realpath ( HYPHENATOR_HOME ) ; } if ( $ home = getenv ( 'HYPHENATOR_HOME' ) ) { if ( is_Dir ( $ home ) ) { return $ home ; } } return __DIR__ . '/share' ; } 
public function setHomePath ( $ homePath ) { if ( ! file_exists ( $ homePath ) ) { throw new Exception \ PathNotFoundException ( $ homePath . ' does not exist' ) ; } if ( ! is_Dir ( $ homePath ) ) { throw new Exception \ PathNotDirException ( $ homePath . ' is not a directory' ) ; } $ this -> homePath = realpath ( $ homePath ) ; return $ this ; } 
public static function factory ( $ path = null , $ locale = null ) { $ hyphenator = new Hyphenator ( ) ; if ( null !== $ path && file_Exists ( $ path ) ) { $ hyphenator -> setHomePath ( $ path ) ; } if ( null !== $ locale ) { $ hyphenator -> getOptions ( ) -> setDefaultLocale ( $ locale ) ; } return $ hyphenator ; } 
public static function __autoload ( $ className ) { if ( 0 !== strpos ( $ className , 'Org\\Heigl\\Hyphenator' ) ) { return false ; } $ className = substr ( $ className , strlen ( 'Org\\Heigl\\Hyphenator\\' ) ) ; $ file = str_replace ( '\\' , '/' , $ className ) . '.php' ; $ fileName = __DIR__ . DIRECTORY_SEPARATOR . $ file ; if ( ! file_exists ( realpath ( $ fileName ) ) ) { return false ; } if ( ! @ include_once $ fileName ) { return false ; } return true ; } 
public function replace ( Token $ oldToken , array $ newTokens ) { 
public function getTokenWithKey ( $ key ) { if ( array_key_exists ( $ key , $ this -> registry ) ) { return $ this -> registry [ $ key ] ; } return null ; } 
public function run ( t \ TokenRegistry $ tokens ) { foreach ( $ tokens as $ token ) { if ( ! $ token instanceof t \ WordToken ) { continue ; } $ string = $ token -> getFilteredContent ( ) ; $ pattern = $ token -> getMergedPattern ( $ this -> options -> getQuality ( ) ) ; $ length = $ token -> length ( ) ; $ result = array ( ) ; for ( $ i = 1 ; $ i <= $ length ; $ i ++ ) { $ currPattern = mb_substr ( $ pattern , $ i , 1 ) ; if ( $ i < $ this -> options -> getLeftMin ( ) ) { continue ; } if ( $ i > $ length - $ this -> options -> getRightMin ( ) ) { continue ; } if ( 0 == $ currPattern ) { continue ; } if ( 0 === ( int ) $ currPattern % 2 ) { continue ; } $ start = mb_substr ( $ string , 0 , $ i ) ; $ end = mb_substr ( $ string , $ i ) ; $ result [ ] = $ start . $ this -> options -> getHyphen ( ) . $ end ; } $ token -> setHyphenatedContent ( $ result ) ; } return $ tokens ; } 
public function getMergedPattern ( $ quality = \ Org \ Heigl \ Hyphenator \ Hyphenator :: QUALITY_HIGHEST ) { $ content = $ this -> getHyphenateContent ( ) ; $ endPattern = str_repeat ( '0' , mb_strlen ( $ content ) + 1 ) ; foreach ( $ this -> pattern as $ string => $ pattern ) { $ strStart = - 1 ; while ( false !== $ strStart = @ mb_strpos ( $ content , $ string , $ strStart + 1 ) ) { $ strLen = mb_strlen ( $ string ) ; for ( $ i = 0 ; $ i <= $ strLen ; $ i ++ ) { $ start = $ i + $ strStart ; $ currentQuality = substr ( $ endPattern , $ start , 1 ) ; $ patternQuality = substr ( $ pattern , $ i , 1 ) ; if ( $ currentQuality >= $ patternQuality ) { continue ; } if ( $ quality < $ patternQuality ) { continue ; } $ endPattern = substr ( $ endPattern , 0 , $ start ) . $ patternQuality . substr ( $ endPattern , $ start + 1 ) ; } } } return substr ( $ endPattern , 1 , strlen ( $ endPattern ) - 2 ) ; } 
public function add ( Filter $ filter ) { if ( ! in_array ( $ filter , $ this -> registry ) ) { $ this -> registry [ ] = $ filter ; } return $ this ; } 
public function getFilterWithKey ( $ key ) { if ( array_key_exists ( $ key , $ this -> registry ) ) { return $ this -> registry [ $ key ] ; } return null ; } 
public function filter ( \ Org \ Heigl \ Hyphenator \ Tokenizer \ TokenRegistry $ tokens ) { foreach ( $ this as $ filter ) { $ tokens = $ filter -> run ( $ tokens ) ; } return $ tokens ; } 
private function tokenize ( $ input ) { $ tokens = array ( ) ; $ signs = '\\' . implode ( '\\' , $ this -> tokens ) ; $ splits = preg_split ( '/([' . $ signs . ']+)/u' , $ input , - 1 , PREG_SPLIT_DELIM_CAPTURE ) ; foreach ( $ splits as $ split ) { if ( '' == $ split ) { continue ; } if ( in_array ( mb_substr ( $ split , 0 , 1 ) , $ this -> tokens ) ) { $ tokens [ ] = new NonWordToken ( $ split ) ; continue ; } $ tokens [ ] = new WordToken ( $ split ) ; } return $ tokens ; } 
public function fetchToken ( $ authorizationCode ) { $ additionalParams = [ 'code' => $ authorizationCode , 'redirect_uri' => $ this -> configuration -> getRedirectUrl ( ) , ] ; $ response = parent :: fetchAccessToken ( 'authentication/v1/gettoken' , 'authorization_code' , $ additionalParams ) ; $ this -> saveRefreshToken ( $ response ) ; } 
public function migrateOrders ( ) { $ start = $ count = 0 ; $ batch = Order :: get ( ) -> sort ( 'Created' , 'ASC' ) -> limit ( $ start , self :: $ batch_size ) ; while ( $ batch -> exists ( ) ) { foreach ( $ batch as $ order ) { $ this -> migrate ( $ order ) ; echo '. ' ; $ count ++ ; } $ start += self :: $ batch_size ; $ batch = $ batch -> limit ( $ start , self :: $ batch_size ) ; } ; echo "$count orders updated.\n<br/>" ; } 
public function migrate ( Order $ order ) { 
public function migrateMemberFields ( $ order ) { if ( $ member = $ order -> Member ( ) ) { $ fieldstocopy = array ( 'FirstName' , 'Surname' , 'Email' , 'Address' , 'AddressLine2' , 'City' , 'Country' , 'HomePhone' , 'MobilePhone' , 'Notes' , ) ; foreach ( $ fieldstocopy as $ field ) { if ( ! $ order -> $ field ) { $ order -> $ field = $ member -> $ field ; } } } } 
public function migrateShippingValues ( $ order ) { 
public function migrateOrderCalculation ( $ order ) { if ( ! is_numeric ( $ order -> Total ) || $ order -> Total <= 0 ) { $ order -> calculate ( ) ; $ order -> write ( ) ; } } 
public function viaphp ( ) { $ ps = singleton ( Product :: class ) ; $ q = $ ps -> buildSQL ( '"SilverShop_Product"."AllowPurchase" = 1' ) ; $ select = $ q -> select ; $ select [ 'NewPopularity' ] = self :: config ( ) -> number_sold_calculation_type . '("SilverShop_OrderItem"."Quantity") AS "NewPopularity"' ; $ q -> select ( $ select ) ; $ q -> groupby ( '"Product"."ID"' ) ; $ q -> orderby ( '"NewPopularity" DESC' ) ; $ q -> leftJoin ( 'SilverShop_Product_OrderItem' , '"SilverShop_Product"."ID" = "SilverShop_Product_OrderItem"."ProductID"' ) ; $ q -> leftJoin ( 'SilverShop_OrderItem' , '"SilverShop_Product_OrderItem"."ID" = "SilverShop_OrderItem"."ID"' ) ; $ records = $ q -> execute ( ) ; $ productssold = $ ps -> buildDataObjectSet ( $ records , "DataObjectSet" , $ q , Product :: class ) ; 
public function requireDefaultRecords ( ) { parent :: requireDefaultRecords ( ) ; if ( ! self :: get ( ) -> exists ( ) && $ this -> config ( ) -> create_default_pages ) { $ page = self :: create ( ) -> update ( [ 'Title' => 'Checkout' , 'URLSegment' => CheckoutPageController :: config ( ) -> url_segment , 'ShowInMenus' => 0 , ] ) ; $ page -> write ( ) ; $ page -> publishSingle ( ) ; $ page -> flushCache ( ) ; DB :: alteration_message ( 'Checkout page created' , 'created' ) ; } } 
public function makePayment ( $ gateway , $ gatewaydata = array ( ) , $ successUrl = null , $ cancelUrl = null ) { * @var ServiceFactory $factory */ $ factory = ServiceFactory :: create ( ) ; $ service = $ factory -> getService ( $ payment , ServiceFactory :: INTENT_PAYMENT ) ; 
protected function getGatewayData ( $ customData ) { $ shipping = $ this -> order -> getShippingAddress ( ) ; $ billing = $ this -> order -> getBillingAddress ( ) ; $ numPayments = Payment :: get ( ) -> filter ( array ( 'OrderID' => $ this -> order -> ID ) ) -> count ( ) - 1 ; $ transactionId = $ this -> order -> Reference . ( $ numPayments > 0 ? "-$numPayments" : '' ) ; return array_merge ( $ customData , array ( 'transactionId' => $ transactionId , 'firstName' => $ this -> order -> FirstName , 'lastName' => $ this -> order -> Surname , 'email' => $ this -> order -> Email , 'company' => $ this -> order -> Company , 'billingAddress1' => $ billing -> Address , 'billingAddress2' => $ billing -> AddressLine2 , 'billingCity' => $ billing -> City , 'billingPostcode' => $ billing -> PostalCode , 'billingState' => $ billing -> State , 'billingCountry' => $ billing -> Country , 'billingPhone' => $ billing -> Phone , 'shippingAddress1' => $ shipping -> Address , 'shippingAddress2' => $ shipping -> AddressLine2 , 'shippingCity' => $ shipping -> City , 'shippingPostcode' => $ shipping -> PostalCode , 'shippingState' => $ shipping -> State , 'shippingCountry' => $ shipping -> Country , 'shippingPhone' => $ shipping -> Phone , ) ) ; } 
public function createPayment ( $ gateway ) { if ( ! GatewayInfo :: isSupported ( $ gateway ) ) { $ this -> error ( _t ( __CLASS__ . ".InvalidGateway" , "`{gateway}` isn't a valid payment gateway." , 'gateway is the name of the payment gateway' , array ( 'gateway' => $ gateway ) ) ) ; return false ; } if ( ! $ this -> order -> canPay ( Security :: getCurrentUser ( ) ) ) { $ this -> error ( _t ( __CLASS__ . ".CantPay" , "Order can't be paid for." ) ) ; return false ; } $ payment = Payment :: create ( ) -> init ( $ gateway , $ this -> order -> TotalOutstanding ( true ) , ShopConfigExtension :: config ( ) -> base_currency ) ; $ this -> order -> Payments ( ) -> add ( $ payment ) ; return $ payment ; } 
public function completePayment ( ) { if ( ! $ this -> order -> IsPaid ( ) ) { 
public function canPlace ( Order $ order ) { if ( ! $ order ) { $ this -> error ( _t ( __CLASS__ . ".NoOrder" , "Order does not exist." ) ) ; return false ; } 
public function placeOrder ( ) { if ( ! $ this -> order ) { $ this -> error ( _t ( __CLASS__ . ".NoOrderStarted" , "A new order has not yet been started." ) ) ; return false ; } if ( ! $ this -> canPlace ( $ this -> order ) ) { $cart = ShoppingCart::curr(); if ($cart && $cart->ID == $this->order->ID) { } */ 
public function Nice ( ) { $ val = ShopConfigExtension :: countryCode2name ( $ this -> value ) ; if ( ! $ val ) { $ val = $ this -> value ; } return _t ( __CLASS__ . '.' . $ this -> value , $ val ) ; } 
public function setContactDetails ( $ email , $ firstname , $ surname ) { $ this -> order -> Email = $ email ; $ this -> order -> FirstName = $ firstname ; $ this -> order -> Surname = $ surname ; $ this -> order -> write ( ) ; } 
public function setShippingAddress ( Address $ address ) { $ this -> order -> ShippingAddressID = $ address -> ID ; if ( $ member = Security :: getCurrentUser ( ) ) { $ this -> order -> MemberID = $ member -> ID ; } $ this -> order -> write ( ) ; $ this -> order -> extend ( 'onSetShippingAddress' , $ address ) ; ShopUserInfo :: singleton ( ) -> setAddress ( $ address ) ; } 
public function setPaymentMethod ( $ paymentmethod ) { $ methods = GatewayInfo :: getSupportedGateways ( ) ; if ( ! isset ( $ methods [ $ paymentmethod ] ) ) { ShopTools :: getSession ( ) -> set ( 'Checkout.PaymentMethod' , null ) -> clear ( 'Checkout.PaymentMethod' ) ; return $ this -> error ( _t ( __CLASS__ . '.NoPaymentMethod' , 'Payment method does not exist' ) ) ; } ShopTools :: getSession ( ) -> set ( 'Checkout.PaymentMethod' , $ paymentmethod ) ; return true ; } 
public function getSelectedPaymentMethod ( $ nice = false ) { $ methods = GatewayInfo :: getSupportedGateways ( ) ; reset ( $ methods ) ; $ method = count ( $ methods ) === 1 ? key ( $ methods ) : ShopTools :: getSession ( ) -> get ( 'Checkout.PaymentMethod' ) ; if ( $ nice && isset ( $ methods [ $ method ] ) ) { $ method = $ methods [ $ method ] ; } return $ method ; } 
public function validateMember ( $ member ) { if ( ! CheckoutConfig :: config ( ) -> membership_required ) { return true ; } if ( empty ( $ member ) || ! ( $ member instanceof Member ) ) { return false ; } return true ; } 
protected function buildEmail ( $ template , $ subject ) { $ from = ShopConfigExtension :: config ( ) -> email_from ? ShopConfigExtension :: config ( ) -> email_from : Email :: config ( ) -> admin_email ; $ to = $ this -> order -> getLatestEmail ( ) ; $ checkoutpage = CheckoutPage :: get ( ) -> first ( ) ; $ completemessage = $ checkoutpage ? $ checkoutpage -> PurchaseComplete : '' ; $ email = Email :: create ( ) -> setHTMLTemplate ( $ template ) -> setFrom ( $ from ) -> setTo ( $ to ) -> setSubject ( $ subject ) ; $ email -> setData ( [ 'PurchaseCompleteMessage' => $ completemessage , 'Order' => $ this -> order , 'BaseURL' => Director :: absoluteBaseURL ( ) , ] ) ; return $ email ; } 
public function sendEmail ( $ template , $ subject , $ copyToAdmin = true ) { $ email = $ this -> buildEmail ( $ template , $ subject ) ; if ( $ copyToAdmin ) { $ email -> setBcc ( Email :: config ( ) -> admin_email ) ; } if ( $ this -> debugMode ) { return $ this -> debug ( $ email ) ; } else { return $ email -> send ( ) ; } } 
public function sendConfirmation ( ) { $ subject = _t ( 'SilverShop\ShopEmail.ConfirmationSubject' , 'Order #{OrderNo} confirmation' , '' , array ( 'OrderNo' => $ this -> order -> Reference ) ) ; return $ this -> sendEmail ( 'SilverShop/Model/Order_ConfirmationEmail' , $ subject , self :: config ( ) -> bcc_confirmation_to_admin ) ; } 
public function sendAdminNotification ( ) { $ subject = _t ( 'SilverShop\ShopEmail.AdminNotificationSubject' , 'Order #{OrderNo} notification' , '' , array ( 'OrderNo' => $ this -> order -> Reference ) ) ; $ email = $ this -> buildEmail ( 'SilverShop/Model/Order_AdminNotificationEmail' , $ subject ) -> setTo ( Email :: config ( ) -> admin_email ) ; if ( $ this -> debugMode ) { return $ this -> debug ( $ email ) ; } else { return $ email -> send ( ) ; } } 
public function sendReceipt ( ) { $ subject = _t ( 'SilverShop\ShopEmail.ReceiptSubject' , 'Order #{OrderNo} receipt' , '' , array ( 'OrderNo' => $ this -> order -> Reference ) ) ; return $ this -> sendEmail ( 'SilverShop/Model/Order_ReceiptEmail' , $ subject , self :: config ( ) -> bcc_receipt_to_admin ) ; } 
public function sendCancelNotification ( ) { $ email = Email :: create ( ) -> setSubject ( _t ( 'SilverShop\ShopEmail.CancelSubject' , 'Order #{OrderNo} cancelled by member' , '' , [ 'OrderNo' => $ this -> order -> Reference ] ) ) -> setFrom ( Email :: config ( ) -> admin_email ) -> setTo ( Email :: config ( ) -> admin_email ) -> setBody ( $ this -> order -> renderWith ( Order :: class ) ) ; if ( $ this -> debugMode ) { return $ this -> debug ( $ email ) ; } else { return $ email -> send ( ) ; } } 
public function sendStatusChange ( $ title , $ note = null ) { if ( ! $ note ) { $ latestLog = OrderStatusLog :: get ( ) -> filter ( "OrderID" , $ this -> order -> ID ) -> filter ( "SentToCustomer" , 1 ) -> first ( ) ; if ( $ latestLog ) { $ note = $ latestLog -> Note ; $ title = $ latestLog -> Title ; } } if ( Config :: inst ( ) -> get ( OrderProcessor :: class , 'receipt_email' ) ) { $ adminEmail = Config :: inst ( ) -> get ( OrderProcessor :: class , 'receipt_email' ) ; } else { $ adminEmail = Email :: config ( ) -> admin_email ; } $ email = Email :: create ( ) -> setFrom ( $ adminEmail ) -> setSubject ( _t ( 'SilverShop\ShopEmail.StatusChangeSubject' , 'SilverShop – {Title}', [ T itle' = $ i tle]) ) -> setTo ( $ this -> order -> getLatestEmail ( ) ) -> setHTMLTemplate ( 'SilverShop/Model/Order_StatusEmail' ) -> setData ( [ 'Order' => $ this -> order , 'Note' => $ note , 'FromEmail' => $ adminEmail ] ) ; if ( $ this -> debugMode ) { return $ this -> debug ( $ email ) ; } else { return $ email -> send ( ) ; } } 
protected function debug ( Email $ email ) { $ email -> render ( ) ; $ template = $ email -> getHTMLTemplate ( ) ; $ headers = $ email -> getSwiftMessage ( ) -> getHeaders ( ) -> toString ( ) ; return "<h2>Email HTML template: $template</h2>\n" . "<pre>$headers</pre>" . $ email -> getBody ( ) ; } 
protected static function build_url ( $ action , $ buyable , $ params = [ ] ) { if ( ! $ action || ! $ buyable ) { return false ; } if ( SecurityToken :: is_enabled ( ) && ! self :: config ( ) -> disable_security_token ) { $ params [ SecurityToken :: inst ( ) -> getName ( ) ] = SecurityToken :: inst ( ) -> getValue ( ) ; } $ className = get_class ( $ buyable ) ; $ link = Controller :: join_links ( [ self :: config ( ) -> url_segment , $ action , ShopTools :: sanitiseClassName ( $ className ) , $ buyable -> ID ] ) ; return empty ( $ params ) ? $ link : $ link . '?' . http_build_query ( $ params ) ; } 
public static function direct ( $ status = true ) { if ( Director :: is_ajax ( ) ) { return ( string ) $ status ; } if ( self :: config ( ) -> direct_to_cart_page && ( $ cartlink = CartPage :: find_link ( ) ) ) { return Controller :: curr ( ) -> redirect ( $ cartlink ) ; } else { return Controller :: curr ( ) -> redirectBack ( ) ; } } 
public function removeall ( $ request ) { if ( $ product = $ this -> buyableFromRequest ( ) ) { $ this -> cart -> remove ( $ product , null , $ request -> getVars ( ) ) ; } $ this -> updateLocale ( $ request ) ; $ this -> extend ( 'updateRemoveAllResponse' , $ request , $ response , $ product ) ; return $ response ? $ response : self :: direct ( ) ; } 
public function setquantity ( $ request ) { $ product = $ this -> buyableFromRequest ( ) ; $ quantity = ( int ) $ request -> getVar ( 'quantity' ) ; if ( $ product ) { $ this -> cart -> setQuantity ( $ product , $ quantity , $ request -> getVars ( ) ) ; } $ this -> updateLocale ( $ request ) ; $ this -> extend ( 'updateSetQuantityResponse' , $ request , $ response , $ product , $ quantity ) ; return $ response ? $ response : self :: direct ( ) ; } 
public function clear ( $ request ) { $ this -> updateLocale ( $ request ) ; $ this -> cart -> clear ( ) ; $ this -> extend ( 'updateClearResponse' , $ request , $ response ) ; return $ response ? $ response : self :: direct ( ) ; } 
public function index ( ) { if ( $ cart = $ this -> Cart ( ) ) { return $ this -> redirect ( $ cart -> CartLink ) ; } elseif ( $ response = ErrorPage :: response_for ( 404 ) ) { return $ response ; } return $ this -> httpError ( 404 , _t ( 'SilverShop\Cart\ShoppingCart.NoCartInitialised' , 'no cart initialised' ) ) ; } 
public function debug ( ) { if ( Director :: isDev ( ) || Permission :: check ( 'ADMIN' ) ) { 
public function getFilter ( ) { if ( ! is_array ( $ this -> data ) ) { return null ; } $ allowed = array_keys ( DataObject :: getSchema ( ) -> databaseFields ( $ this -> className ) ) ; $ fields = array_flip ( array_intersect ( $ allowed , $ this -> required ) ) ; $ singleton = singleton ( $ this -> className ) ; $ new = [ ] ; foreach ( $ fields as $ field => $ value ) { $ field = Convert :: raw2sql ( $ field ) ; if ( in_array ( $ field , $ allowed ) ) { if ( isset ( $ this -> data [ $ field ] ) ) { 
public function submit ( $ data , $ form , $ request ) { $ member = Security :: getCurrentUser ( ) ; if ( ! $ member ) { return false ; } $ form -> saveInto ( $ member ) ; $ member -> write ( ) ; $ form -> sessionMessage ( _t ( __CLASS__ . '.DetailsSaved' , 'Your details have been saved' ) , 'good' ) ; $ this -> extend ( 'updateShopAccountFormResponse' , $ request , $ form , $ data , $ response ) ; return $ response ? : $ this -> getController ( ) -> redirectBack ( ) ; } 
public function proceed ( $ data , $ form , $ request ) { $ member = Security :: getCurrentUser ( ) ; if ( ! $ member ) { return false ; } $ form -> saveInto ( $ member ) ; $ member -> write ( ) ; $ form -> sessionMessage ( _t ( __CLASS__ . '.DetailsSaved' , 'Your details have been saved' ) , 'good' ) ; $ this -> extend ( 'updateShopAccountFormResponse' , $ request , $ form , $ data , $ response ) ; return $ response ? : $ this -> getController ( ) -> redirect ( CheckoutPage :: find_link ( ) ) ; } 
public function getModifier ( $ className , $ forcecreate = false ) { if ( ! ClassInfo :: exists ( $ className ) ) { user_error ( "Modifier class \"$className\" does not exist." ) ; } 
public function UnitPrice ( ) { if ( $ this -> Order ( ) -> IsCart ( ) ) { $ buyable = $ this -> Buyable ( ) ; $ unitprice = ( $ buyable ) ? $ buyable -> sellingPrice ( ) : $ this -> UnitPrice ; $ this -> extend ( 'updateUnitPrice' , $ unitprice ) ; return $ this -> UnitPrice = $ unitprice ; } return $ this -> UnitPrice ; } 
protected function calculatetotal ( ) { $ total = $ this -> UnitPrice ( ) * $ this -> Quantity ; $ this -> extend ( 'updateTotal' , $ total ) ; $ this -> CalculatedTotal = $ total ; return $ total ; } 
public function uniquedata ( ) { $ required = self :: config ( ) -> required_fields ; 
public function onBeforeWrite ( ) { parent :: onBeforeWrite ( ) ; if ( $ this -> OrderID && $ this -> Order ( ) && $ this -> Order ( ) -> isCart ( ) ) { $ this -> calculatetotal ( ) ; } } 
public function ProductVariation ( $ forcecurrent = false ) { if ( $ this -> ProductVariationID && $ this -> ProductVariationVersion && ! $ forcecurrent ) { return Versioned :: get_version ( Variation :: class , $ this -> ProductVariationID , $ this -> ProductVariationVersion ) ; } elseif ( $ this -> ProductVariationID && $ product = Variation :: get ( ) -> byID ( $ this -> ProductVariationID ) ) { return $ product ; } return null ; } 
public function setData ( Order $ order , array $ data ) { $ address = $ this -> getAddress ( $ order ) ; 
public function getRequiredFields ( ) { $ fields = self :: config ( ) -> required_fields ; 
public function toString ( $ separator = ', ' ) { $ fields = array ( $ this -> Company , $ this -> getName ( ) , $ this -> Address , $ this -> AddressLine2 , $ this -> City , $ this -> State , $ this -> PostalCode , $ this -> Country ) ; $ this -> extend ( 'updateToString' , $ fields ) ; return implode ( $ separator , array_filter ( $ fields ) ) ; } 
public function getAddress ( ) { $ address = null ; if ( $ data = $ this -> getLocationData ( ) ) { $ address = Address :: create ( ) ; $ address -> update ( $ data ) ; $ address -> ID = 0 ; 
public function CartForm ( ) { $ cart = $ this -> Cart ( ) ; if ( ! $ cart ) { return false ; } $ form = CartForm :: create ( $ this , 'CartForm' , $ cart ) ; $ this -> extend ( 'updateCartForm' , $ form ) ; return $ form ; } 
public function value ( $ subtotal = 0 ) { $ totalWeight = $ this -> Weight ( ) ; if ( ! $ totalWeight ) { return $ this -> Amount = 0 ; } $ amount = 0 ; $ table = $ this -> config ( ) -> weight_cost ; if ( ! empty ( $ table ) && is_array ( $ table ) ) { 
public function Weight ( ) { if ( $ this -> weight ) { return $ this -> weight ; } $ weight = 0 ; $ order = $ this -> Order ( ) ; if ( $ order && $ orderItems = $ order -> Items ( ) ) { foreach ( $ orderItems as $ orderItem ) { if ( $ product = $ orderItem -> Product ( ) ) { $ weight = $ weight + ( $ product -> Weight * $ orderItem -> Quantity ) ; } } } return $ this -> weight = $ weight ; } 
public function addtocart ( $ data , $ form ) { if ( $ variation = $ this -> getBuyable ( $ data ) ) { $ quantity = ( isset ( $ data [ 'Quantity' ] ) && is_numeric ( $ data [ 'Quantity' ] ) ) ? ( int ) $ data [ 'Quantity' ] : 1 ; $ cart = ShoppingCart :: singleton ( ) ; $ request = $ this -> getRequest ( ) ; $ order = $ cart -> current ( ) ; if ( $ request && $ request -> isAjax ( ) && $ order ) { ShopTools :: install_locale ( $ order -> Locale ) ; } 
public function namespaceData ( array $ data ) { $ newdata = array ( ) ; foreach ( $ data as $ key => $ value ) { $ newdata [ $ this -> namespaceFieldName ( $ key ) ] = $ value ; } return $ newdata ; } 
public function Sum ( $ field , $ onproduct = false ) { $ total = 0 ; foreach ( $ this -> getIterator ( ) as $ item ) { $ quantity = ( $ field === 'Quantity' ) ? 1 : $ item -> Quantity ; if ( ! $ onproduct ) { $ total += $ item -> $ field * $ quantity ; } elseif ( $ item -> hasMethod ( $ field ) ) { $ total += $ item -> $ field ( ) * $ quantity ; } elseif ( $ product = $ item -> Product ( ) ) { $ total += $ product -> $ field * $ quantity ; } } return $ total ; } 
public function SubTotal ( ) { $ result = 0 ; foreach ( $ this -> getIterator ( ) as $ item ) { $ result += $ item -> Total ( ) ; } return $ result ; } 
public function onBeforeWrite ( ) { parent :: onBeforeWrite ( ) ; if ( isset ( $ _POST [ 'ProductAttributes' ] ) && is_array ( $ _POST [ 'ProductAttributes' ] ) ) { $ this -> AttributeValues ( ) -> setByIDList ( array_values ( $ _POST [ 'ProductAttributes' ] ) ) ; } $ img = $ this -> Image ( ) ; if ( $ img && $ img -> exists ( ) ) { $ img -> doPublish ( ) ; } } 
public function Item ( ) { $ filter = array ( ) ; $ this -> extend ( 'updateItemFilter' , $ filter ) ; $ item = ShoppingCart :: singleton ( ) -> get ( $ this , $ filter ) ; if ( ! $ item ) { 
public function PaymentErrorMessage ( ) { $ order = $ this -> Cart ( ) ; if ( ! $ order ) { return false ; } $ lastPayment = $ order -> Payments ( ) -> sort ( 'Created' , 'DESC' ) -> first ( ) ; if ( ! $ lastPayment ) { return false ; } $ errorMessages = $ lastPayment -> Messages ( ) -> exclude ( 'Message' , '' ) -> sort ( 'Created' , 'DESC' ) ; $ lastErrorMessage = null ; foreach ( $ errorMessages as $ errorMessage ) { if ( $ errorMessage instanceof GatewayErrorMessage ) { $ lastErrorMessage = $ errorMessage ; break ; } } if ( ! $ lastErrorMessage ) { return false ; } return $ lastErrorMessage -> Message ; } 
public function getViewer ( $ action ) { if ( CheckoutPage :: config ( ) -> first_step && $ action == 'index' ) { $ action = CheckoutPage :: config ( ) -> first_step ; } return parent :: getViewer ( $ action ) ; } 
public function Product ( $ forcecurrent = false ) { 
public function updateCMSFields ( FieldList $ fields ) { $ fields -> addFieldsToTab ( 'Root.Variations' , [ ListboxField :: create ( 'VariationAttributeTypes' , _t ( __CLASS__ . '.Attributes' , "Attributes" ) , AttributeType :: get ( ) -> map ( 'ID' , 'Title' ) -> toArray ( ) ) -> setDescription ( _t ( __CLASS__ . '.AttributesDescription' , 'These are fields to indicate the way(s) each variation varies. Once selected, they can be edited on each variation.' ) ) , GridField :: create ( 'Variations' , _t ( __CLASS__ . '.Variations' , 'Variations' ) , $ this -> owner -> Variations ( ) , GridFieldConfig_RecordEditor :: create ( ) ) ] ) ; if ( $ this -> owner -> Variations ( ) -> exists ( ) ) { $ fields -> addFieldToTab ( 'Root.Pricing' , LabelField :: create ( 'variationspriceinstructinos' , _t ( __CLASS__ . '.VariationsInfo' , 'Price - Because you have one or more variations, the price can be set in the "Variations" tab.' ) ) ) ; $ fields -> removeFieldFromTab ( 'Root.Pricing' , 'BasePrice' ) ; $ fields -> removeFieldFromTab ( 'Root.Main' , 'InternalItemID' ) ; } } 
public function getVariationByAttributes ( array $ attributes ) { if ( ! is_array ( $ attributes ) ) { return null ; } $ attrs = array_filter ( array_values ( $ attributes ) ) ; $ set = Variation :: get ( ) -> filter ( 'ProductID' , $ this -> owner -> ID ) ; foreach ( $ attrs as $ i => $ valueid ) { $ alias = "A$i" ; $ set = $ set -> innerJoin ( 'SilverShop_Variation_AttributeValues' , "\"SilverShop_Variation\".\"ID\" = \"$alias\".\"SilverShop_VariationID\"" , $ alias ) -> where ( [ "\"$alias\".\"SilverShop_AttributeValueID\" = ?" => $ valueid ] ) ; } return $ set -> first ( ) ; } 
public function generateVariationsFromAttributes ( AttributeType $ attributetype , array $ values ) { 
public function possibleValuesForAttributeType ( $ type ) { if ( ! is_numeric ( $ type ) ) { $ type = $ type -> ID ; } if ( ! $ type ) { return null ; } $ list = AttributeValue :: get ( ) -> innerJoin ( 'SilverShop_Variation_AttributeValues' , '"SilverShop_AttributeValue"."ID" = "SilverShop_Variation_AttributeValues"."SilverShop_AttributeValueID"' ) -> innerJoin ( 'SilverShop_Variation' , '"SilverShop_Variation_AttributeValues"."SilverShop_VariationID" = "SilverShop_Variation"."ID"' ) -> where ( "TypeID = $type AND \"SilverShop_Variation\".\"ProductID\" = " . $ this -> owner -> ID ) ; if ( ! Product :: config ( ) -> allow_zero_price ) { $ list = $ list -> where ( '"SilverShop_Variation"."Price" > 0' ) ; } return $ list ; } 
public function onAfterDelete ( ) { $ remove = false ; 
public function getImageAt ( $ width = null , $ height = null , $ upscale = false ) { if ( ! $ this -> owner -> exists ( ) ) { return $ this -> owner ; } $ realWidth = $ this -> owner -> getWidth ( ) ; $ realHeight = $ this -> owner -> getHeight ( ) ; if ( $ width && $ height ) { return $ realWidth < $ width && $ realHeight < $ height && ! $ upscale ? $ this -> owner : $ this -> owner -> Fit ( $ width , $ height ) ; } else { if ( $ width ) { return $ realWidth < $ width && ! $ upscale ? $ this -> owner : $ this -> owner -> ScaleWidth ( $ width ) ; } else { return $ realHeight < $ height && ! $ upscale ? $ this -> owner : $ this -> owner -> ScaleHeight ( $ height ) ; } } } 
public function getComponentByType ( $ type ) { foreach ( $ this -> components as $ component ) { if ( $ this -> namespaced ) { if ( $ component -> Proxy ( ) instanceof $ type ) { return $ component -> Proxy ( ) ; } } else { if ( $ component instanceof $ type ) { return $ component ; } } } } 
public function getFormFields ( ) { $ fields = FieldList :: create ( ) ; foreach ( $ this -> getComponents ( ) as $ component ) { if ( $ cfields = $ component -> getFormFields ( $ this -> order ) ) { $ fields -> merge ( $ cfields ) ; } else { user_error ( 'getFields on ' . get_class ( $ component ) . ' must return a FieldList' ) ; } } return $ fields ; } 
public function validateData ( $ data ) { $ result = ValidationResult :: create ( ) ; foreach ( $ this -> getComponents ( ) as $ component ) { try { $ component -> validateData ( $ this -> order , $ this -> dependantData ( $ component , $ data ) ) ; } catch ( ValidationException $ e ) { 
public function getData ( ) { $ data = array ( ) ; foreach ( $ this -> getComponents ( ) as $ component ) { $ orderdata = $ component -> getData ( $ this -> order ) ; if ( is_array ( $ orderdata ) ) { $ data = array_merge ( $ data , $ orderdata ) ; } else { user_error ( 'getData on ' . $ component -> name ( ) . ' must return an array' ) ; } } return $ data ; } 
public function setData ( $ data ) { foreach ( $ this -> getComponents ( ) as $ component ) { $ component -> setData ( $ this -> order , $ this -> dependantData ( $ component , $ data ) ) ; } } 
protected function dependantData ( $ component , $ data ) { if ( ! $ this -> namespaced ) { 
public function current ( ) { $ session = ShopTools :: getSession ( ) ; 
public function setCurrent ( Order $ cart ) { if ( ! $ cart -> IsCart ( ) ) { trigger_error ( 'Passed Order object is not cart status' , E_ERROR ) ; } $ this -> order = $ cart ; $ session = ShopTools :: getSession ( ) ; $ session -> set ( self :: config ( ) -> cartid_session_name , $ cart -> ID ) ; return $ this ; } 
protected function findOrMake ( ) { if ( $ this -> current ( ) ) { return $ this -> current ( ) ; } $ this -> order = Order :: create ( ) ; if ( Member :: config ( ) -> login_joins_cart && ( $ member = Security :: getCurrentUser ( ) ) ) { $ this -> order -> MemberID = $ member -> ID ; } $ this -> order -> write ( ) ; $ this -> order -> extend ( 'onStartOrder' ) ; $ session = ShopTools :: getSession ( ) ; $ session -> set ( self :: config ( ) -> cartid_session_name , $ this -> order -> ID ) ; return $ this -> order ; } 
public function add ( Buyable $ buyable , $ quantity = 1 , $ filter = [ ] ) { $ order = $ this -> findOrMake ( ) ; 
public function remove ( Buyable $ buyable , $ quantity = null , $ filter = [ ] ) { $ order = $ this -> current ( ) ; if ( ! $ order ) { return $ this -> error ( _t ( __CLASS__ . '.NoOrder' , 'No current order.' ) ) ; } 
public function removeOrderItem ( OrderItem $ item , $ quantity = null ) { $ order = $ this -> current ( ) ; if ( ! $ order ) { return $ this -> error ( _t ( __CLASS__ . '.NoOrder' , 'No current order.' ) ) ; } if ( ! $ item || $ item -> OrderID != $ order -> ID ) { return $ this -> error ( _t ( __CLASS__ . '.ItemNotFound' , 'Item not found.' ) ) ; } 
public function setQuantity ( Buyable $ buyable , $ quantity = 1 , $ filter = [ ] ) { if ( $ quantity <= 0 ) { return $ this -> remove ( $ buyable , $ quantity , $ filter ) ; } $ item = $ this -> findOrMakeItem ( $ buyable , $ quantity , $ filter ) ; if ( ! $ item || ! $ this -> updateOrderItemQuantity ( $ item , $ quantity , $ filter ) ) { return false ; } return $ item ; } 
public function updateOrderItemQuantity ( OrderItem $ item , $ quantity = 1 , $ filter = [ ] ) { $ order = $ this -> current ( ) ; if ( ! $ order ) { return $ this -> error ( _t ( __CLASS__ . '.NoOrder' , 'No current order.' ) ) ; } if ( ! $ item || $ item -> OrderID != $ order -> ID ) { return $ this -> error ( _t ( __CLASS__ . '.ItemNotFound' , 'Item not found.' ) ) ; } $ buyable = $ item -> Buyable ( ) ; 
private function findOrMakeItem ( Buyable $ buyable , $ quantity = 1 , $ filter = [ ] ) { $ order = $ this -> findOrMake ( ) ; if ( ! $ buyable || ! $ order ) { return null ; } $ item = $ this -> get ( $ buyable , $ filter ) ; if ( ! $ item ) { $ member = Security :: getCurrentUser ( ) ; $ buyable = $ this -> getCorrectBuyable ( $ buyable ) ; if ( ! $ buyable -> canPurchase ( $ member , $ quantity ) ) { return $ this -> error ( _t ( __CLASS__ . '.CannotPurchase' , 'This {Title} cannot be purchased.' , '' , [ 'Title' => $ buyable -> i18n_singular_name ( ) ] ) ) ; 
public function get ( Buyable $ buyable , $ customfilter = array ( ) ) { $ order = $ this -> current ( ) ; if ( ! $ buyable || ! $ order ) { return null ; } $ buyable = $ this -> getCorrectBuyable ( $ buyable ) ; $ filter = array ( 'OrderID' => $ order -> ID , ) ; $ itemclass = Config :: inst ( ) -> get ( get_class ( $ buyable ) , 'order_item' ) ; $ relationship = Config :: inst ( ) -> get ( $ itemclass , 'buyable_relationship' ) ; $ filter [ $ relationship . 'ID' ] = $ buyable -> ID ; $ required = [ 'OrderID' , $ relationship . 'ID' ] ; if ( is_array ( $ itemclass :: config ( ) -> required_fields ) ) { $ required = array_merge ( $ required , $ itemclass :: config ( ) -> required_fields ) ; } $ query = new MatchObjectFilter ( $ itemclass , array_merge ( $ customfilter , $ filter ) , $ required ) ; $ item = $ itemclass :: get ( ) -> where ( $ query -> getFilter ( ) ) -> first ( ) ; if ( ! $ item ) { return $ this -> error ( _t ( __CLASS__ . '.ItemNotFound' , 'Item not found.' ) ) ; } return $ item ; } 
public function getCorrectBuyable ( Buyable $ buyable ) { if ( $ buyable instanceof Product && $ buyable -> hasExtension ( ProductVariationsExtension :: class ) && $ buyable -> Variations ( ) -> count ( ) > 0 ) { foreach ( $ buyable -> Variations ( ) as $ variation ) { if ( $ variation -> canPurchase ( ) ) { return $ variation ; } } } return $ buyable ; } 
public function archiveorderid ( $ requestedOrderId = null ) { $ session = ShopTools :: getSession ( ) ; $ sessionId = $ session -> get ( self :: config ( ) -> cartid_session_name ) ; $ order = Order :: get ( ) -> filter ( 'Status:not' , 'Cart' ) -> byId ( $ sessionId ) ; if ( $ order && ! $ order -> IsCart ( ) ) { OrderManipulationExtension :: add_session_order ( $ order ) ; } 
public function clear ( $ write = true ) { $ session = ShopTools :: getSession ( ) ; $ session -> set ( self :: config ( ) -> cartid_session_name , null ) -> clear ( self :: config ( ) -> cartid_session_name ) ; $ order = $ this -> current ( ) ; $ this -> order = null ; if ( $ write ) { if ( ! $ order ) { return $ this -> error ( _t ( __CLASS__ . '.NoCartFound' , 'No cart found.' ) ) ; } $ order -> write ( ) ; } $ this -> message ( _t ( __CLASS__ . '.Cleared' , 'Cart was successfully cleared.' ) ) ; return true ; } 
public function setModifiers ( array $ modifiers ) { $ modifiers = array_map ( 'strtolower' , $ modifiers ) ; if ( ( $ extras = array_diff ( $ modifiers , [ 'not' , 'nocase' , 'case' , 'splitwords' ] ) ) != array ( ) ) { throw new InvalidArgumentException ( get_class ( $ this ) . ' does not accept ' . implode ( ', ' , $ extras ) . ' as modifiers' ) ; } $ this -> modifiers = $ modifiers ; $ this -> subfilterModifiers = array_filter ( $ modifiers , function ( $ v ) { return $ v != 'splitwords' ; } ) ; if ( ! empty ( $ this -> subfilters ) ) { foreach ( $ this -> subfilters as $ f ) { $ f -> setModifiers ( $ this -> subfilterModifiers ) ; } } } 
public function apply ( DataQuery $ query ) { $ orGroup = $ query -> disjunctiveGroup ( ) ; $ orGroup = parent :: apply ( $ orGroup ) ; if ( count ( $ this -> subfilters ) > 0 ) { foreach ( $ this -> subfilters as $ f ) { $ orGroup = $ f -> apply ( $ orGroup ) ; } } 
public function value ( $ incoming ) { $ this -> Rate = self :: config ( ) -> rate ; 
public static function price_for_display ( $ price ) { $ currency = ShopConfigExtension :: get_site_currency ( ) ; $ field = DBMoney :: create_field ( DBMoney :: class , 0 , 'Price' ) ; $ field -> setAmount ( $ price ) ; $ field -> setCurrency ( $ currency ) ; return $ field ; } 
public static function install_locale ( $ locale ) { 
public static function getSession ( HTTPRequest $ request = null ) { if ( $ request && ( $ session = $ request -> getSession ( ) ) ) { return $ session ; } if ( Controller :: has_curr ( ) && ( $ request = Controller :: curr ( ) -> getRequest ( ) ) ) { return $ request -> getSession ( ) ; } try { if ( $ session = Injector :: inst ( ) -> get ( HTTPRequest :: class ) -> getSession ( ) ) { return $ session ; } } catch ( NotFoundExceptionInterface $ e ) { 
public function updatecart ( $ data , $ form ) { $ items = $ this -> cart -> Items ( ) ; $ updatecount = $ removecount = 0 ; $ request = $ this -> getRequest ( ) ; $ order = ShoppingCart :: curr ( ) ; if ( $ request && $ request -> isAjax ( ) && $ order ) { ShopTools :: install_locale ( $ order -> Locale ) ; } $ numericConverter = NumericField :: create ( '_temp' ) ; $ messages = [ ] ; $ badMessages = [ ] ; if ( isset ( $ data [ 'Items' ] ) && is_array ( $ data [ 'Items' ] ) ) { foreach ( $ data [ 'Items' ] as $ itemid => $ fields ) { $ item = $ items -> byID ( $ itemid ) ; if ( ! $ item ) { continue ; } 
public function imageByFilename ( & $ obj , $ val , $ record ) { $ filename = trim ( strtolower ( Convert :: raw2sql ( $ val ) ) ) ; $ filenamedashes = str_replace ( ' ' , '-' , $ filename ) ; if ( $ filename && $ image = Image :: get ( ) -> whereAny ( [ "LOWER(\"FileFilename\") LIKE '%$filename%'" , "LOWER(\"FileFilename\") LIKE '%$filenamedashes%'" ] ) -> first ( ) ) { 
public function setParent ( & $ obj , $ val , $ record ) { $ title = strtolower ( Convert :: raw2sql ( $ val ) ) ; if ( $ title ) { 
public function setContent ( & $ obj , $ val , $ record ) { $ val = trim ( $ val ) ; if ( $ val ) { $ paragraphs = explode ( "\n" , $ val ) ; $ obj -> Content = '<p>' . implode ( '</p><p>' , $ paragraphs ) . '</p>' ; } } 
public function getCountriesList ( $ prefixisocode = false ) { $ countries = self :: config ( ) -> iso_3166_country_codes ; asort ( $ countries ) ; if ( $ allowed = $ this -> owner -> AllowedCountries ) { $ allowed = json_decode ( $ allowed ) ; if ( ! empty ( $ allowed ) ) { $ countries = array_intersect_key ( $ countries , array_flip ( $ allowed ) ) ; } } if ( $ prefixisocode ) { foreach ( $ countries as $ key => $ value ) { $ countries [ $ key ] = "$key - $value" ; } } return $ countries ; } 
public function getSingleCountry ( $ fullname = false ) { $ countries = $ this -> getCountriesList ( ) ; if ( count ( $ countries ) == 1 ) { if ( $ fullname ) { return array_pop ( $ countries ) ; } else { reset ( $ countries ) ; return key ( $ countries ) ; } } return null ; } 
public static function countryCode2name ( $ code ) { $ codes = self :: config ( ) -> iso_3166_country_codes ; if ( isset ( $ codes [ $ code ] ) ) { return $ codes [ $ code ] ; } return $ code ; } 
public function Cart ( ) { $ order = ShoppingCart :: curr ( ) ; if ( ! $ order || ! $ order -> Items ( ) || ! $ order -> Items ( ) -> exists ( ) ) { return false ; } return $ order ; } 
public function convertArrayToValues ( array $ values ) { $ set = ArrayList :: create ( ) ; foreach ( $ values as $ value ) { $ val = $ this -> Values ( ) -> find ( 'Value' , $ value ) ; if ( ! $ val ) { 
public function getDropDownField ( $ emptystring = null , $ values = null ) { $ values = ( $ values ) ? $ values : $ this -> Values ( ) -> sort ( [ 'Sort' => 'ASC' , 'Value' => 'ASC' ] ) ; if ( $ values -> exists ( ) ) { $ field = DropdownField :: create ( 'ProductAttributes[' . $ this -> ID . ']' , $ this -> Name , $ values -> map ( 'ID' , 'Value' ) ) ; if ( $ emptystring ) { $ field -> setEmptyString ( $ emptystring ) ; } return $ field ; } return null ; } 
public function ProductsShowable ( $ recursive = true ) { 
public function AllChildCategoryIDs ( ) { $ ids = [ $ this -> ID ] ; $ allids = [ ] ; do { $ ids = ProductCategory :: get ( ) -> filter ( 'ParentID' , $ ids ) -> getIDList ( ) ; $ allids += $ ids ; } while ( ! empty ( $ ids ) ) ; return $ allids ; } 
public function ChildCategories ( $ recursive = false ) { $ ids = array ( $ this -> ID ) ; if ( $ recursive ) { $ ids += $ this -> AllChildCategoryIDs ( ) ; } return ProductCategory :: get ( ) -> filter ( 'ParentID' , $ ids ) ; } 
public function GroupsMenu ( ) { if ( $ this -> Parent ( ) instanceof ProductCategory ) { return $ this -> Parent ( ) -> GroupsMenu ( ) ; } return ProductCategory :: get ( ) -> filter ( 'ParentID' , $ this -> ID ) ; } 
public function NestedTitle ( $ level = 10 , $ separator = ' > ' , $ field = 'MenuTitle' ) { $ item = $ this ; while ( $ item && $ level > 0 ) { $ parts [ ] = $ item -> { $ field } ; $ item = $ item -> Parent ; $ level -- ; } return implode ( $ separator , array_reverse ( $ parts ) ) ; } 
public function ItemEditForm ( ) { $ form = parent :: ItemEditForm ( ) ; $ printlink = $ this -> Link ( 'printorder' ) . '?print=1' ; $ printwindowjs = <<<JS window.open('$printlink', 'print_order', 'toolbar=0,scrollbars=1,location=1,statusbar=0,menubar=0,resizable=1,width=800,height=600,left = 50,top = 50');return false; JS ; $ form -> Actions ( ) -> push ( LiteralField :: create ( 'PrintOrder' , "<button class=\"no-ajax grid-print-button btn action btn-primary font-icon-print\" onclick=\"javascript:$printwindowjs\">" . _t ( 'SilverShop\Model\Order.Print' , 'Print' ) . '</button>' ) ) ; return $ form ; } 
public function printorder ( ) { Requirements :: clear ( ) ; 
private function nextstep ( ) { $ steps = $ this -> owner -> getSteps ( ) ; $ found = false ; foreach ( $ steps as $ step => $ class ) { 
public function getList ( ) { $ list = parent :: getList ( ) ; if ( $ this -> modelClass == Order :: class ) { 
public function getEditForm ( $ id = null , $ fields = null ) { $ form = parent :: getEditForm ( $ id , $ fields ) ; if ( $ this -> modelClass == Order :: class ) { $ config = $ form -> Fields ( ) -> fieldByName ( $ this -> sanitiseClassName ( $ this -> modelClass ) ) -> getConfig ( ) ; $ config -> getComponentByType ( GridFieldSortableHeader :: class ) -> setFieldSorting ( [ 'StatusI18N' => 'Status' ] ) ; $ config -> getComponentByType ( GridFieldDetailForm :: class ) -> setItemRequestClass ( OrderGridFieldDetailForm_ItemRequest :: class ) ; 
private function getSubset ( FieldList $ fields , $ subset = array ( ) ) { if ( empty ( $ subset ) ) { return $ fields ; } $ subfieldlist = FieldList :: create ( ) ; foreach ( $ subset as $ field ) { if ( $ field = $ fields -> fieldByName ( $ field ) ) { $ subfieldlist -> push ( $ field ) ; } } return $ subfieldlist ; } 
public function modify ( $ subtotal , $ forcecalculation = false ) { $ order = $ this -> Order ( ) ; $ value = ( $ order -> IsCart ( ) || $ forcecalculation ) ? $ this -> value ( $ subtotal ) : $ this -> Amount ; switch ( $ this -> Type ) { case 'Chargable' : $ subtotal += $ value ; break ; case 'Deductable' : $ subtotal -= $ value ; break ; case 'Ignored' : break ; } $ value = round ( $ value , Order :: config ( ) -> rounding_precision ) ; $ this -> Amount = $ value ; return $ subtotal ; } 
public static function setupSteps ( $ steps = null ) { if ( ! is_array ( $ steps ) ) { 
public function onAfterInit ( ) { $ action = $ this -> owner -> getRequest ( ) -> param ( 'Action' ) ; $ steps = $ this -> getSteps ( ) ; if ( ! ShoppingCart :: curr ( ) && ! empty ( $ action ) && isset ( $ steps [ $ action ] ) ) { Controller :: curr ( ) -> redirect ( $ this -> owner -> Link ( ) ) ; return ; } } 
public function IsCurrentStep ( $ name ) { if ( $ this -> owner -> getAction ( ) === $ name ) { return true ; } elseif ( ! $ this -> owner -> getAction ( ) || $ this -> owner -> getAction ( ) === 'index' ) { return $ this -> actionPos ( $ name ) === 0 ; } return false ; } 
private function actionPos ( $ incoming ) { $ count = 0 ; foreach ( $ this -> getSteps ( ) as $ action => $ step ) { if ( $ action == $ incoming ) { return $ count ; } $ count ++ ; } } 
public static function find_link ( $ urlSegment = false , $ action = false , $ id = false ) { $ base = CartPageController :: config ( ) -> url_segment ; if ( $ page = self :: get ( ) -> first ( ) ) { $ base = $ page -> Link ( ) ; } return Controller :: join_links ( $ base , $ action , $ id ) ; } 
public function Products ( $ recursive = true ) { $ products = $ this -> ProductsShowable ( $ recursive ) ; 
public function getSorter ( ) { $ options = array ( ) ; foreach ( ProductCategory :: config ( ) -> sort_options as $ k => $ v ) { 
public function TrimCents ( ) { $ val = $ this -> value ; if ( floor ( $ val ) == $ val ) { return floor ( $ val ) ; } return $ val ; } 
public function getCMSFields ( ) { $ self = $ this ; $ this -> beforeUpdateCMSFields ( function ( FieldList $ fields ) use ( $ self ) { $ fields -> fieldByName ( 'Root.Main.Title' ) -> setTitle ( _t ( __CLASS__ . '.PageTitle' , 'Product Title' ) ) ; $ fields -> addFieldsToTab ( 'Root.Main' , [ TextField :: create ( 'InternalItemID' , _t ( __CLASS__ . '.InternalItemID' , 'Product Code/SKU' ) , '' , 30 ) , DropdownField :: create ( 'ParentID' , _t ( __CLASS__ . '.Category' , 'Category' ) , $ self -> getCategoryOptions ( ) ) -> setDescription ( _t ( __CLASS__ . '.CategoryDescription' , 'This is the parent page or default category.' ) ) , ListboxField :: create ( 'ProductCategories' , _t ( __CLASS__ . '.AdditionalCategories' , 'Additional Categories' ) , $ self -> getCategoryOptionsNoParent ( ) ) , TextField :: create ( 'Model' , _t ( __CLASS__ . '.Model' , 'Model' ) , '' , 30 ) , CheckboxField :: create ( 'Featured' , _t ( __CLASS__ . '.Featured' , 'Featured Product' ) ) , CheckboxField :: create ( 'AllowPurchase' , _t ( __CLASS__ . '.AllowPurchase' , 'Allow product to be purchased' ) , 1 ) , ] , 'Content' ) ; $ fields -> addFieldsToTab ( 'Root.Pricing' , [ TextField :: create ( 'BasePrice' , $ this -> fieldLabel ( 'BasePrice' ) ) -> setDescription ( _t ( __CLASS__ . '.PriceDesc' , 'Base price to sell this product at.' ) ) -> setMaxLength ( 12 ) , ] ) ; $ fieldSubstitutes = [ 'LengthUnit' => $ self :: config ( ) -> length_unit ] ; $ fields -> addFieldsToTab ( 'Root.Shipping' , [ TextField :: create ( 'Weight' , _t ( __CLASS__ . '.WeightWithUnit' , 'Weight ({WeightUnit})' , '' , [ 'WeightUnit' => self :: config ( ) -> weight_unit ] ) , '' , 12 ) , TextField :: create ( 'Height' , _t ( __CLASS__ . '.HeightWithUnit' , 'Height ({LengthUnit})' , '' , $ fieldSubstitutes ) , '' , 12 ) , TextField :: create ( 'Width' , _t ( __CLASS__ . '.WidthWithUnit' , 'Width ({LengthUnit})' , '' , $ fieldSubstitutes ) , '' , 12 ) , TextField :: create ( 'Depth' , _t ( __CLASS__ . '.DepthWithUnit' , 'Depth ({LengthUnit})' , '' , $ fieldSubstitutes ) , '' , 12 ) , ] ) ; if ( ! $ fields -> dataFieldByName ( 'Image' ) ) { $ fields -> addFieldToTab ( 'Root.Images' , UploadField :: create ( 'Image' , _t ( __CLASS__ . '.Image' , 'Product Image' ) ) ) ; } } ) ; return parent :: getCMSFields ( ) ; } 
private function getCategoryOptions ( ) { $ categories = ProductCategory :: get ( ) -> map ( 'ID' , 'NestedTitle' ) -> toArray ( ) ; $ categories = [ 0 => _t ( 'SilverStripe\CMS\Model\SiteTree.PARENTTYPE_ROOT' , 'Top-level page' ) , ] + $ categories ; if ( $ this -> ParentID && ! ( $ this -> Parent ( ) instanceof ProductCategory ) ) { $ categories = [ $ this -> ParentID => $ this -> Parent ( ) -> Title . ' (' . $ this -> Parent ( ) -> i18n_singular_name ( ) . ')' , ] + $ categories ; } return $ categories ; } 
private function getCategoryOptionsNoParent ( ) { $ ancestors = $ this -> getAncestors ( ) -> column ( 'ID' ) ; $ categories = ProductCategory :: get ( ) ; if ( ! empty ( $ ancestors ) ) { $ categories = $ categories -> exclude ( 'ID' , $ ancestors ) ; } return $ categories -> map ( 'ID' , 'NestedTitle' ) -> toArray ( ) ; } 
public function getCategoryIDs ( ) { $ ids = array ( ) ; 
public function canPurchase ( $ member = null , $ quantity = 1 ) { $ global = self :: config ( ) -> global_allow_purchase ; if ( ! $ global || ! $ this -> AllowPurchase ) { return false ; } $ allowpurchase = false ; $ extension = self :: has_extension ( ProductVariationsExtension :: class ) ; if ( $ extension && Variation :: get ( ) -> filter ( 'ProductID' , $ this -> ID ) -> first ( ) ) { foreach ( $ this -> Variations ( ) as $ variation ) { if ( $ variation -> canPurchase ( $ member , $ quantity ) ) { $ allowpurchase = true ; break ; } } } else { $ allowpurchase = ( $ this -> sellingPrice ( ) > 0 || self :: config ( ) -> allow_zero_price ) ; } 
public function sellingPrice ( ) { $ price = $ this -> BasePrice ; 
public function Image ( ) { $ image = $ this -> getComponent ( 'Image' ) ; $ this -> extend ( 'updateImage' , $ image ) ; if ( $ image && $ image -> exists ( ) ) { return $ image ; } $ image = SiteConfig :: current_site_config ( ) -> DefaultProductImage ( ) ; if ( $ image && $ image -> exists ( ) ) { return $ image ; } return null ; } 
public function submitpayment ( $ data , $ form ) { $ data = $ form -> getData ( ) ; $ cancelUrl = $ this -> getFailureLink ( ) ? $ this -> getFailureLink ( ) : $ this -> controller -> Link ( ) ; $ order = $ this -> config -> getOrder ( ) ; 
public function dopayment ( $ data , $ form ) { if ( self :: config ( ) -> allow_paying && $ this -> order && $ this -> order -> canPay ( ) ) { 
public function docancel ( $ data , $ form ) { if ( self :: config ( ) -> allow_cancelling && $ this -> order -> canCancel ( ) ) { $ this -> order -> Status = 'MemberCancelled' ; $ this -> order -> write ( ) ; if ( self :: config ( ) -> email_notification ) { OrderEmailNotifier :: create ( $ this -> order ) -> sendCancelNotification ( ) ; } $ this -> controller -> sessionMessage ( _t ( __CLASS__ . '.OrderCancelled' , 'Order sucessfully cancelled' ) , 'warning' ) ; if ( Security :: getCurrentUser ( ) && $ link = $ this -> order -> Link ( ) ) { $ this -> controller -> redirect ( $ link ) ; } else { $ this -> controller -> redirectBack ( ) ; } } } 
protected function getCCFields ( array $ gateways ) { $ fieldFactory = new GatewayFieldsFactory ( null , array ( 'Card' ) ) ; $ onsiteGateways = array ( ) ; $ allRequired = array ( ) ; foreach ( $ gateways as $ gateway => $ title ) { if ( ! GatewayInfo :: isOffsite ( $ gateway ) ) { $ required = GatewayInfo :: requiredFields ( $ gateway ) ; $ onsiteGateways [ $ gateway ] = $ fieldFactory -> getFieldName ( $ required ) ; $ allRequired += $ required ; } } $ allRequired = array_unique ( $ allRequired ) ; $ allRequired = $ fieldFactory -> getFieldName ( array_combine ( $ allRequired , $ allRequired ) ) ; if ( empty ( $ onsiteGateways ) ) { return null ; } $ ccFields = $ fieldFactory -> getCardFields ( ) ; 
public static function add_session_order ( Order $ order ) { $ history = self :: get_session_order_ids ( ) ; if ( ! is_array ( $ history ) ) { $ history = array ( ) ; } $ history [ $ order -> ID ] = $ order -> ID ; ShopTools :: getSession ( ) -> set ( self :: $ sessname , $ history ) ; } 
public static function get_session_order_ids ( ) { $ history = ShopTools :: getSession ( ) -> get ( self :: $ sessname ) ; if ( ! is_array ( $ history ) ) { $ history = null ; } return $ history ; } 
public function orderfromid ( ) { $ request = $ this -> owner -> getRequest ( ) ; $ id = ( int ) $ request -> param ( 'ID' ) ; if ( ! $ id ) { $ id = ( int ) $ request -> postVar ( 'OrderID' ) ; } return $ this -> allorders ( ) -> byID ( $ id ) ; } 
public function allorders ( ) { $ filters = array ( 'ID' => - 1 
public function PastOrders ( $ paginated = false ) { $ orders = $ this -> allorders ( ) -> filter ( 'Status' , Order :: config ( ) -> placed_status ) ; if ( $ paginated ) { $ orders = PaginatedList :: create ( $ orders , $ this -> owner -> getRequest ( ) ) ; } return $ orders ; } 
public function order ( HTTPRequest $ request ) { 
public function ActionsForm ( ) { if ( $ order = $ this -> orderfromid ( ) ) { $ form = OrderActionsForm :: create ( $ this -> owner , 'ActionsForm' , $ order ) ; $ form -> extend ( 'updateActionsForm' , $ order ) ; if ( ! $ form -> Actions ( ) -> exists ( ) ) { return null ; } return $ form ; } return null ; } 
public function create ( $ data ) { $ result = ValidationResult :: create ( ) ; if ( ! Checkout :: member_creation_enabled ( ) ) { $ result -> addError ( _t ( 'SilverShop\Checkout\Checkout.MembershipIsNotAllowed' , 'Creating new memberships is not allowed' ) ) ; throw new ValidationException ( $ result ) ; } $ idfield = Config :: inst ( ) -> get ( Member :: class , 'unique_identifier_field' ) ; if ( ! isset ( $ data [ $ idfield ] ) || empty ( $ data [ $ idfield ] ) ) { $ result -> addError ( _t ( 'SilverShop\Checkout\Checkout.IdFieldNotFound' , 'Required field not found: {IdentifierField}' , 'Identifier is the field that holds the unique user-identifier, commonly this is \'Email\'' , [ 'IdentifierField' => $ idfield ] ) ) ; throw new ValidationException ( $ result ) ; } if ( ! isset ( $ data [ 'Password' ] ) || empty ( $ data [ 'Password' ] ) ) { $ result -> addError ( _t ( 'SilverShop\Checkout\Checkout.PasswordRequired' , 'A password is required' ) ) ; throw new ValidationException ( $ result ) ; } $ idval = $ data [ $ idfield ] ; if ( $ member = MemberExtension :: get_by_identifier ( $ idval ) ) { 
public static function get_by_identifier ( $ idvalue ) { return Member :: get ( ) -> filter ( Member :: config ( ) -> unique_identifier_field , $ idvalue ) -> first ( ) ; } 
public function afterMemberLoggedIn ( ) { if ( Member :: config ( ) -> login_joins_cart && $ order = ShoppingCart :: singleton ( ) -> current ( ) ) { $ order -> MemberID = $ this -> owner -> ID ; $ order -> write ( ) ; } } 
public function getPastOrders ( ) { return Order :: get ( ) -> filter ( 'MemberID' , $ this -> owner -> ID ) -> filter ( 'Status:not' , Order :: config ( ) -> hidden_status ) ; } 
public function AJAXLinkHiddenField ( ) { if ( $ quantitylink = $ this -> item -> setquantityLink ( ) ) { return HiddenField :: create ( $ this -> MainID ( ) . '_Quantity_SetQuantityLink' ) -> setValue ( $ quantitylink ) -> addExtraClass ( 'ajaxQuantityField_qtylink' ) ; } } 
public function getExistingAddressFields ( ) { $ member = Security :: getCurrentUser ( ) ; if ( $ member && $ member -> AddressBook ( ) -> exists ( ) ) { $ addressoptions = $ member -> AddressBook ( ) -> sort ( 'Created' , 'DESC' ) -> map ( 'ID' , 'toString' ) -> toArray ( ) ; $ addressoptions [ 'newaddress' ] = _t ( 'SilverShop\Model\Address.CreateNewAddress' , 'Create new address' ) ; $ fieldtype = count ( $ addressoptions ) > 3 ? DropdownField :: class : OptionsetField :: class ; $ label = _t ( "SilverShop\Model\Address.Existing{$this->addresstype}Address" , "Existing {$this->addresstype} Address" ) ; return FieldList :: create ( $ fieldtype :: create ( $ this -> addresstype . 'AddressID' , $ label , $ addressoptions , $ member -> { 'Default' . $ this -> addresstype . 'AddressID' } ) -> addExtraClass ( 'existingValues' ) ) ; } return null ; } 
public function validateData ( Order $ order , array $ data ) { $ result = ValidationResult :: create ( ) ; $ existingID = ! empty ( $ data [ $ this -> addresstype . 'AddressID' ] ) ? ( int ) $ data [ $ this -> addresstype . 'AddressID' ] : 0 ; if ( $ existingID ) { $ member = Security :: getCurrentUser ( ) ; 
public function setData ( Order $ order , array $ data ) { $ existingID = ! empty ( $ data [ $ this -> addresstype . 'AddressID' ] ) ? ( int ) $ data [ $ this -> addresstype . 'AddressID' ] : 0 ; if ( $ existingID > 0 ) { $ order -> { $ this -> addresstype . 'AddressID' } = $ existingID ; $ order -> write ( ) ; $ order -> extend ( 'onSet' . $ this -> addresstype . 'Address' , $ address ) ; } else { parent :: setData ( $ order , $ data ) ; } } 
public function getCMSFields ( ) { $ fields = FieldList :: create ( TabSet :: create ( 'Root' , Tab :: create ( 'Main' ) ) ) ; $ fs = '<div class="field">' ; $ fe = '</div>' ; $ parts = array ( DropdownField :: create ( 'Status' , $ this -> fieldLabel ( 'Status' ) , self :: get_order_status_options ( ) ) , LiteralField :: create ( 'Customer' , $ fs . $ this -> renderWith ( 'SilverShop\Admin\OrderAdmin_Customer' ) . $ fe ) , LiteralField :: create ( 'Addresses' , $ fs . $ this -> renderWith ( 'SilverShop\Admin\OrderAdmin_Addresses' ) . $ fe ) , LiteralField :: create ( 'Content' , $ fs . $ this -> renderWith ( 'SilverShop\Admin\OrderAdmin_Content' ) . $ fe ) , ) ; if ( $ this -> Notes ) { $ parts [ ] = LiteralField :: create ( 'Notes' , $ fs . $ this -> renderWith ( 'SilverShop\Admin\OrderAdmin_Notes' ) . $ fe ) ; } $ fields -> addFieldsToTab ( 'Root.Main' , $ parts ) ; $ this -> extend ( 'updateCMSFields' , $ fields ) ; if ( $ payments = $ fields -> fieldByName ( 'Root.Payments.Payments' ) ) { $ fields -> removeByName ( 'Payments' ) ; $ fields -> insertAfter ( 'Content' , $ payments ) ; $ payments -> addExtraClass ( 'order-payments' ) ; } return $ fields ; } 
public function getDefaultSearchContext ( ) { $ context = parent :: getDefaultSearchContext ( ) ; $ fields = $ context -> getFields ( ) ; $ validStates = self :: config ( ) -> placed_status ; $ statusOptions = array_filter ( self :: get_order_status_options ( ) , function ( $ k ) use ( $ validStates ) { return in_array ( $ k , $ validStates ) ; } , ARRAY_FILTER_USE_KEY ) ; $ fields -> push ( 
public function getComponents ( $ componentName , $ id = null ) { $ components = parent :: getComponents ( $ componentName , $ id ) ; if ( $ componentName === 'Items' && get_class ( $ components ) !== UnsavedRelationList :: class ) { $ query = $ components -> dataQuery ( ) ; $ components = OrderItemList :: create ( OrderItem :: class , 'OrderID' ) ; $ components -> setDataQuery ( $ query ) ; $ components = $ components -> forForeignID ( $ this -> ID ) ; } return $ components ; } 
public function calculate ( ) { if ( ! $ this -> IsCart ( ) ) { return $ this -> Total ; } $ calculator = OrderTotalCalculator :: create ( $ this ) ; return $ this -> Total = $ calculator -> calculate ( ) ; } 
public function getModifier ( $ className , $ forcecreate = false ) { $ calculator = OrderTotalCalculator :: create ( $ this ) ; return $ calculator -> getModifier ( $ className , $ forcecreate ) ; } 
public function TotalOutstanding ( $ includeAuthorized = true ) { return round ( $ this -> GrandTotal ( ) - ( $ includeAuthorized ? $ this -> TotalPaidOrAuthorized ( ) : $ this -> TotalPaid ( ) ) , self :: config ( ) -> rounding_precision ) ; } 
public function Link ( ) { if ( Security :: getCurrentUser ( ) ) { $ link = Controller :: join_links ( AccountPage :: find_link ( ) , 'order' , $ this -> ID ) ; } $ link = CheckoutPage :: find_link ( false , 'order' , $ this -> ID ) ; $ this -> extend ( 'updateLink' , $ link ) ; return $ link ; } 
public function canCancel ( $ member = null ) { $ extended = $ this -> extendedCan ( __FUNCTION__ , $ member ) ; if ( $ extended !== null ) { return $ extended ; } switch ( $ this -> Status ) { case 'Unpaid' : return self :: config ( ) -> cancel_before_payment ; case 'Paid' : return self :: config ( ) -> cancel_before_processing ; case 'Processing' : return self :: config ( ) -> cancel_before_sending ; case 'Sent' : case 'Complete' : return self :: config ( ) -> cancel_after_sending ; } return false ; } 
public function canPay ( $ member = null ) { $ extended = $ this -> extendedCan ( __FUNCTION__ , $ member ) ; if ( $ extended !== null ) { return $ extended ; } if ( ! in_array ( $ this -> Status , self :: config ( ) -> payable_status ) ) { return false ; } if ( $ this -> TotalOutstanding ( true ) > 0 && empty ( $ this -> Paid ) ) { return true ; } return false ; } 
public function canDelete ( $ member = null ) { $ extended = $ this -> extendedCan ( __FUNCTION__ , $ member ) ; if ( $ extended !== null ) { return $ extended ; } return false ; } 
public function canView ( $ member = null ) { $ extended = $ this -> extendedCan ( __FUNCTION__ , $ member ) ; if ( $ extended !== null ) { return $ extended ; } return true ; } 
public function getName ( ) { $ firstname = $ this -> FirstName ? $ this -> FirstName : $ this -> Member ( ) -> FirstName ; $ surname = $ this -> FirstName ? $ this -> Surname : $ this -> Member ( ) -> Surname ; return implode ( ' ' , array_filter ( array ( $ firstname , $ surname ) ) ) ; } 
public function getBillingAddress ( ) { if ( ! $ this -> SeparateBillingAddress && $ this -> ShippingAddressID === $ this -> BillingAddressID ) { return $ this -> getShippingAddress ( ) ; } else { return $ this -> getAddress ( 'Billing' ) ; } } 
public function generateReference ( ) { $ reference = str_pad ( $ this -> ID , self :: $ reference_id_padding , '0' , STR_PAD_LEFT ) ; $ this -> extend ( 'generateReference' , $ reference ) ; $ candidate = $ reference ; 
protected function onBeforeWrite ( ) { parent :: onBeforeWrite ( ) ; if ( ! $ this -> getField ( 'Reference' ) && in_array ( $ this -> Status , self :: $ placed_status ) ) { $ this -> generateReference ( ) ; } 
protected function statusTransition ( $ fromStatus , $ toStatus ) { 
protected function onBeforeDelete ( ) { foreach ( $ this -> Items ( ) as $ item ) { $ item -> delete ( ) ; } foreach ( $ this -> Modifiers ( ) as $ modifier ) { $ modifier -> delete ( ) ; } foreach ( $ this -> OrderStatusLogs ( ) as $ logEntry ) { $ logEntry -> delete ( ) ; } 
public function provideI18nEntities ( ) { $ entities = parent :: provideI18nEntities ( ) ; 
public function Field ( $ properties = array ( ) ) { $ editables = $ this -> editableItems ( ) ; $ customcartdata = array ( 'Items' => $ editables , ) ; 
protected function editableItems ( ) { $ editables = ArrayList :: create ( ) ; foreach ( $ this -> items as $ item ) { $ buyable = $ item -> Buyable ( ) ; if ( ! $ buyable ) { continue ; } 
public static function find_link ( $ urlSegment = false ) { $ page = self :: get_if_account_page_exists ( ) ; return ( $ urlSegment ) ? $ page -> URLSegment : $ page -> Link ( ) ; } 
public static function get_order_link ( $ orderID , $ urlSegment = false ) { $ page = self :: get_if_account_page_exists ( ) ; return ( $ urlSegment ? $ page -> URLSegment . '/' : $ page -> Link ( ) ) . 'order/' . $ orderID ; } 
public function browse ( $ _ , $ assoc_args ) { $ this -> set_composer_auth_env_var ( ) ; if ( empty ( $ assoc_args [ 'format' ] ) || 'table' === $ assoc_args [ 'format' ] ) { WP_CLI :: line ( WP_CLI :: colorize ( '%CAlthough the package index will remain in place for backward compatibility reasons, it has been deprecated and will not be updated further. Please refer to https://github.com/wp-cli/ideas/issues/51 to read about its potential replacement.%n' ) ) ; } $ this -> show_packages ( 'browse' , $ this -> get_community_packages ( ) , $ assoc_args ) ; } 
public function install ( $ args , $ assoc_args ) { list ( $ package_name ) = $ args ; $ this -> set_composer_auth_env_var ( ) ; $ git_package = false ; $ dir_package = false ; $ version = 'dev-master' ; if ( $ this -> is_git_repository ( $ package_name ) ) { $ git_package = $ package_name ; preg_match ( '#([^:\/]+\/[^\/]+)\.git#' , $ package_name , $ matches ) ; if ( ! empty ( $ matches [ 1 ] ) ) { $ package_name = $ this -> check_git_package_name ( $ matches [ 1 ] ) ; } else { WP_CLI :: error ( "Couldn't parse package name from expected path '<name>/<package>'." ) ; } } elseif ( ( false !== strpos ( $ package_name , '://' ) && false !== stripos ( $ package_name , '.zip' ) ) || ( pathinfo ( $ package_name , PATHINFO_EXTENSION ) === 'zip' && is_file ( $ package_name ) ) ) { 
public function list_ ( $ args , $ assoc_args ) { $ this -> set_composer_auth_env_var ( ) ; $ this -> show_packages ( 'list' , $ this -> get_installed_packages ( ) , $ assoc_args ) ; } 
public function path ( $ args ) { $ packages_dir = WP_CLI :: get_runner ( ) -> get_packages_dir_path ( ) ; if ( ! empty ( $ args ) ) { $ packages_dir .= 'vendor/' . $ args [ 0 ] ; if ( ! is_dir ( $ packages_dir ) ) { WP_CLI :: error ( 'Invalid package name.' ) ; } } WP_CLI :: line ( $ packages_dir ) ; } 
public function update ( ) { $ this -> set_composer_auth_env_var ( ) ; $ composer = $ this -> get_composer ( ) ; 
public function uninstall ( $ args ) { list ( $ package_name ) = $ args ; $ this -> set_composer_auth_env_var ( ) ; $ package = $ this -> get_installed_package_by_name ( $ package_name ) ; if ( false === $ package ) { WP_CLI :: error ( 'Package not installed.' ) ; } $ package_name = $ package -> getPrettyName ( ) ; 
private function get_composer ( ) { $ this -> avoid_composer_ca_bundle ( ) ; try { $ composer_path = $ this -> get_composer_json_path ( ) ; 
private function get_community_packages ( ) { static $ community_packages ; if ( null === $ community_packages ) { $ this -> avoid_composer_ca_bundle ( ) ; try { $ community_packages = $ this -> package_index ( ) -> getPackages ( ) ; } catch ( Exception $ e ) { WP_CLI :: error ( $ e -> getMessage ( ) ) ; } } return $ community_packages ; } 
private function package_index ( ) { static $ package_index ; if ( ! $ package_index ) { $ config_args = [ 'config' => [ 'secure-http' => true , 'home' => dirname ( $ this -> get_composer_json_path ( ) ) , ] , ] ; $ config = new Config ( ) ; $ config -> merge ( $ config_args ) ; $ config -> setConfigSource ( new JsonConfigSource ( $ this -> get_composer_json ( ) ) ) ; try { $ package_index = new ComposerRepository ( [ 'url' => self :: PACKAGE_INDEX_URL ] , new NullIO ( ) , $ config ) ; } catch ( Exception $ e ) { WP_CLI :: error ( $ e -> getMessage ( ) ) ; } } return $ package_index ; } 
private function show_packages ( $ context , $ packages , $ assoc_args ) { if ( 'list' === $ context ) { $ default_fields = [ 'name' , 'authors' , 'version' , 'update' , 'update_version' , ] ; } elseif ( 'browse' === $ context ) { $ default_fields = [ 'name' , 'description' , 'authors' , 'version' , ] ; } $ defaults = [ 'fields' => implode ( ',' , $ default_fields ) , 'format' => 'table' , ] ; $ assoc_args = array_merge ( $ defaults , $ assoc_args ) ; $ composer = $ this -> get_composer ( ) ; $ list = [ ] ; foreach ( $ packages as $ package ) { $ name = $ package -> getPrettyName ( ) ; if ( isset ( $ list [ $ name ] ) ) { $ list [ $ name ] [ 'version' ] [ ] = $ package -> getPrettyVersion ( ) ; } else { $ package_output = [ ] ; $ package_output [ 'name' ] = $ package -> getPrettyName ( ) ; $ package_output [ 'description' ] = $ package -> getDescription ( ) ; $ package_output [ 'authors' ] = implode ( ', ' , array_column ( ( array ) $ package -> getAuthors ( ) , 'name' ) ) ; $ package_output [ 'version' ] = [ $ package -> getPrettyVersion ( ) ] ; $ update = 'none' ; $ update_version = '' ; if ( 'list' === $ context ) { try { $ latest = $ this -> find_latest_package ( $ package , $ composer , null ) ; if ( $ latest && $ latest -> getFullPrettyVersion ( ) !== $ package -> getFullPrettyVersion ( ) ) { $ update = 'available' ; $ update_version = $ latest -> getPrettyVersion ( ) ; } } catch ( Exception $ e ) { WP_CLI :: warning ( $ e -> getMessage ( ) ) ; $ update = 'error' ; $ update_version = $ update ; } } $ package_output [ 'update' ] = $ update ; $ package_output [ 'update_version' ] = $ update_version ; $ package_output [ 'pretty_name' ] = $ package -> getPrettyName ( ) ; 
private function get_package_by_shortened_identifier ( $ package_name ) { 
private function get_installed_packages ( ) { $ composer = $ this -> get_composer ( ) ; $ repo = $ composer -> getRepositoryManager ( ) -> getLocalRepository ( ) ; $ existing = json_decode ( file_get_contents ( $ this -> get_composer_json_path ( ) ) , true ) ; $ installed_package_keys = ! empty ( $ existing [ 'require' ] ) ? array_keys ( $ existing [ 'require' ] ) : [ ] ; if ( empty ( $ installed_package_keys ) ) { return [ ] ; } 
private function get_installed_package_by_name ( $ package_name ) { foreach ( $ this -> get_installed_packages ( ) as $ package ) { if ( $ package_name === $ package -> getPrettyName ( ) ) { return $ package ; } 
private static function get_package_name_and_version_from_dir_package ( $ dir_package ) { $ composer_file = $ dir_package . '/composer.json' ; if ( ! file_exists ( $ composer_file ) ) { WP_CLI :: error ( sprintf ( "Invalid package: composer.json file '%s' not found." , $ composer_file ) ) ; } $ composer_data = json_decode ( file_get_contents ( $ composer_file ) , true ) ; if ( null === $ composer_data ) { WP_CLI :: error ( sprintf ( "Invalid package: failed to parse composer.json file '%s' as json." , $ composer_file ) ) ; } if ( empty ( $ composer_data [ 'name' ] ) ) { WP_CLI :: error ( sprintf ( "Invalid package: no name in composer.json file '%s'." , $ composer_file ) ) ; } $ package_name = $ composer_data [ 'name' ] ; $ version = 'dev-master' ; if ( ! empty ( $ composer_data [ 'version' ] ) ) { $ version = $ composer_data [ 'version' ] ; } return [ $ package_name , $ version ] ; } 
private function get_composer_json_path ( ) { static $ composer_path ; if ( null === $ composer_path || getenv ( 'WP_CLI_TEST_PACKAGE_GET_COMPOSER_JSON_PATH' ) ) { if ( getenv ( 'WP_CLI_PACKAGES_DIR' ) ) { $ composer_path = Utils \ trailingslashit ( getenv ( 'WP_CLI_PACKAGES_DIR' ) ) . 'composer.json' ; } else { $ composer_path = Utils \ trailingslashit ( Utils \ get_home_dir ( ) ) . '.wp-cli/packages/composer.json' ; } 
private function create_default_composer_json ( $ composer_path ) { $ composer_dir = pathinfo ( $ composer_path , PATHINFO_DIRNAME ) ; if ( ! is_dir ( $ composer_dir ) ) { if ( ! @ mkdir ( $ composer_dir , 0777 , true ) ) { 
private function check_git_package_name ( $ package_name , $ version = '' ) { 
private function get_raw_git_version ( $ version ) { if ( '' === $ version ) { return 'master' ; } 
private function guess_version_constraint_from_tag ( $ tag ) { $ matches = [ ] ; if ( 1 !== preg_match ( '/(?:version|v)\s*((?:[0-9]+\.?)+)(?:-.*)/i' , $ tag , $ matches ) ) { return $ tag ; } $ constraint = "^{$matches[1]}" ; WP_CLI :: debug ( "Guessing version constraint to use: {$constraint}" , 'packages' ) ; return $ constraint ; } 
private function set_composer_auth_env_var ( ) { $ changed = false ; $ composer_auth = getenv ( 'COMPOSER_AUTH' ) ; if ( false !== $ composer_auth ) { $ composer_auth = json_decode ( $ composer_auth , true ) ; } if ( empty ( $ composer_auth ) || ! is_array ( $ composer_auth ) ) { $ composer_auth = [ ] ; } $ github_token = getenv ( 'GITHUB_TOKEN' ) ; if ( ! isset ( $ composer_auth [ 'github-oauth' ] ) && is_string ( $ github_token ) ) { $ composer_auth [ 'github-oauth' ] = [ 'github.com' => $ github_token ] ; $ changed = true ; } if ( $ changed ) { putenv ( 'COMPOSER_AUTH=' . json_encode ( $ composer_auth ) ) ; } } 
private function avoid_composer_ca_bundle ( ) { if ( Utils \ inside_phar ( ) && ! getenv ( 'SSL_CERT_FILE' ) && ! getenv ( 'SSL_CERT_DIR' ) && ! ini_get ( 'openssl.cafile' ) && ! ini_get ( 'openssl.capath' ) ) { $ certificate = Utils \ extract_from_phar ( WP_CLI_VENDOR_DIR . self :: SSL_CERTIFICATE ) ; putenv ( "SSL_CERT_FILE={$certificate}" ) ; } } 
private function get_composer_json_path_backup_decoded ( ) { $ composer_json_obj = $ this -> get_composer_json ( ) ; $ json_path = $ composer_json_obj -> getPath ( ) ; $ composer_backup = file_get_contents ( $ json_path ) ; if ( false === $ composer_backup ) { $ error = error_get_last ( ) ; WP_CLI :: error ( sprintf ( "Failed to read '%s': %s" , $ json_path , $ error [ 'message' ] ) ) ; } try { $ composer_backup_decoded = $ composer_json_obj -> read ( ) ; } catch ( Exception $ e ) { WP_CLI :: error ( sprintf ( "Failed to parse '%s' as json: %s" , $ json_path , $ e -> getMessage ( ) ) ) ; } return [ $ json_path , $ composer_backup , $ composer_backup_decoded ] ; } 
private function register_revert_shutdown_function ( $ json_path , $ composer_backup , & $ revert ) { 
protected function setObject ( DataObject $ object , $ name = 'Object' ) { $ this -> { $ name . 'ID' } = $ object -> ID ; $ this -> { $ name . 'Type' } = $ object -> ClassName ; } 
private function loadCustomConfig ( ) { $ custom = $ this -> getCustomConfig ( ) ; if ( ! is_array ( $ custom ) ) { return ; } foreach ( $ custom as $ class => $ settings ) { foreach ( $ settings as $ setting => $ value ) { Config :: modify ( ) -> set ( $ class , $ setting , $ value ) ; } } } 
public function run ( $ request ) { $ confirm = $ request -> getVar ( 'confirm' ) ; $ jobs = DataObject :: get ( QueuedJobDescriptor :: class ) ; if ( ! $ confirm ) { echo "Really delete " . $ jobs -> count ( ) . " jobs? Please add ?confirm=1 to the URL to confirm." ; return ; } echo "Deleting " . $ jobs -> count ( ) . " jobs...<br>\n" ; $ jobs -> removeAll ( ) ; echo "Done." ; } 
public function process ( ) { FROM "QueuedJobDescriptor" WHERE "JobStatus" IN (\'' . $ statusList . '\') AND "LastEdited" < \'' . $ cutOff . '\'' . $ limit ) ; $ staleJobs = $ stale -> column ( "ID" ) ; break ; // If Number, we need to save n records, then delete from the rest case "number" : $ fresh = DB :: query ( 'SELECT "ID" FROM "QueuedJobDescriptor" ORDER BY "LastEdited" ASC LIMIT ' . $ this -> config ( ) -> cleanup_value ) ; $ freshJobIDs = implode ( '\', \'' , $ fresh -> column ( "ID" ) ) ; $ stale = DB :: query ( 'SELECT "ID" FROM "QueuedJobDescriptor" WHERE "ID" NOT IN (\'' . $ freshJobIDs . '\') AND "JobStatus" IN (\'' . $ statusList . '\')' . $ limit ) ; $ staleJobs = $ stale -> column ( "ID" ) ; break ; default : $ this -> addMessage ( "Incorrect configuration values set. Cleanup ignored" ) ; $ this -> isComplete = true ; return ; } if ( empty ( $ staleJobs ) ) { $ this -> addMessage ( "No jobs to clean up." ) ; $ this -> isComplete = true ; $ this -> reenqueue ( ) ; return ; } $ numJobs = count ( $ staleJobs ) ; $ staleJobs = implode ( '\', \'' , $ staleJobs ) ; DB :: query ( 'DELETE FROM "QueuedJobDescriptor" WHERE "ID" IN (\'' . $ staleJobs . '\')' ) ; $ this -> addMessage ( $ numJobs . " jobs cleaned up." ) ; // let's make sure there is a cleanupJob in the queue $ this -> reenqueue ( ) ; $ this -> isComplete = true ; } 
public function queueJob ( QueuedJob $ job , $ startAfter = null , $ userId = null , $ queueName = null ) { $ signature = $ job -> getSignature ( ) ; 
public function startJob ( $ jobDescriptor , $ startAfter = null ) { if ( $ startAfter && strtotime ( $ startAfter ) > DBDatetime :: now ( ) -> getTimestamp ( ) ) { $ this -> queueHandler -> scheduleJob ( $ jobDescriptor , $ startAfter ) ; } else { 
protected function copyJobToDescriptor ( $ job , $ jobDescriptor ) { $ data = $ job -> getJobData ( ) ; $ jobDescriptor -> TotalSteps = $ data -> totalSteps ; $ jobDescriptor -> StepsProcessed = $ data -> currentStep ; if ( $ data -> isComplete ) { $ jobDescriptor -> JobStatus = QueuedJob :: STATUS_COMPLETE ; $ jobDescriptor -> JobFinished = DBDatetime :: now ( ) -> Rfc2822 ( ) ; } $ jobDescriptor -> SavedJobData = serialize ( $ data -> jobData ) ; $ jobDescriptor -> SavedJobMessages = serialize ( $ data -> messages ) ; } 
public function getNextPendingJob ( $ type = null ) { 
public function checkJobHealth ( $ queue = null ) { $ queue = $ queue ? : QueuedJob :: QUEUED ; 
public function checkDefaultJobs ( $ queue = null ) { $ queue = $ queue ? : QueuedJob :: QUEUED ; if ( count ( $ this -> defaultJobs ) ) { $ activeJobs = QueuedJobDescriptor :: get ( ) -> filter ( 'JobStatus' , [ QueuedJob :: STATUS_NEW , QueuedJob :: STATUS_INIT , QueuedJob :: STATUS_RUN , QueuedJob :: STATUS_WAIT , QueuedJob :: STATUS_PAUSED , ] ) ; foreach ( $ this -> defaultJobs as $ title => $ jobConfig ) { if ( ! isset ( $ jobConfig [ 'filter' ] ) || ! isset ( $ jobConfig [ 'type' ] ) ) { $ this -> getLogger ( ) -> error ( "Default Job config: $title incorrectly set up. Please check the readme for examples" , [ 'file' => __FILE__ , 'line' => __LINE__ , ] ) ; continue ; } $ job = $ activeJobs -> filter ( array_merge ( [ 'Implementation' => $ jobConfig [ 'type' ] ] , $ jobConfig [ 'filter' ] ) ) ; if ( ! $ job -> count ( ) ) { $ this -> getLogger ( ) -> error ( "Default Job config: $title was missing from Queue" , [ 'file' => __FILE__ , 'line' => __LINE__ , ] ) ; Email :: create ( ) -> setTo ( isset ( $ jobConfig [ 'email' ] ) ? $ jobConfig [ 'email' ] : Config :: inst ( ) -> get ( Email :: class , 'queued_job_admin_email' ) ) -> setFrom ( Config :: inst ( ) -> get ( Email :: class , 'admin_email' ) ) -> setSubject ( 'Default Job "' . $ title . '" missing' ) -> setData ( $ jobConfig ) -> addData ( 'Title' , $ title ) -> addData ( 'Site' , Director :: absoluteBaseURL ( ) ) -> setHTMLTemplate ( 'QueuedJobsDefaultJob' ) -> send ( ) ; if ( isset ( $ jobConfig [ 'recreate' ] ) && $ jobConfig [ 'recreate' ] ) { if ( ! array_key_exists ( 'construct' , $ jobConfig ) || ! isset ( $ jobConfig [ 'startDateFormat' ] ) || ! isset ( $ jobConfig [ 'startTimeString' ] ) ) { $ this -> getLogger ( ) -> error ( "Default Job config: $title incorrectly set up. Please check the readme for examples" , [ 'file' => __FILE__ , 'line' => __LINE__ , ] ) ; continue ; } QueuedJobService :: singleton ( ) -> queueJob ( Injector :: inst ( ) -> createWithArgs ( $ jobConfig [ 'type' ] , $ jobConfig [ 'construct' ] ) , date ( $ jobConfig [ 'startDateFormat' ] , strtotime ( $ jobConfig [ 'startTimeString' ] ) ) ) ; $ this -> getLogger ( ) -> info ( "Default Job config: $title has been re-added to the Queue" , [ 'file' => __FILE__ , 'line' => __LINE__ , ] ) ; } } } } } 
protected function restartStalledJob ( $ stalledJob ) { if ( $ stalledJob -> ResumeCounts < static :: config ( ) -> get ( 'stall_threshold' ) ) { $ stalledJob -> restart ( ) ; $ logLevel = 'warning' ; $ message = _t ( __CLASS__ . '.STALLED_JOB_RESTART_MSG' , 'A job named {name} (#{id}) appears to have stalled. It will be stopped and restarted, please ' . 'login to make sure it has continued' , [ 'name' => $ stalledJob -> JobTitle , 'id' => $ stalledJob -> ID ] ) ; } else { $ stalledJob -> pause ( ) ; $ logLevel = 'error' ; $ message = _t ( __CLASS__ . '.STALLED_JOB_MSG' , 'A job named {name} (#{id}) appears to have stalled. It has been paused, please login to check it' , [ 'name' => $ stalledJob -> JobTitle , 'id' => $ stalledJob -> ID ] ) ; } $ this -> getLogger ( ) -> log ( $ logLevel , $ message , [ 'file' => __FILE__ , 'line' => __LINE__ , ] ) ; $ from = Config :: inst ( ) -> get ( Email :: class , 'admin_email' ) ; $ to = Config :: inst ( ) -> get ( Email :: class , 'queued_job_admin_email' ) ; $ subject = _t ( __CLASS__ . '.STALLED_JOB' , 'Stalled job' ) ; if ( $ to ) { $ mail = Email :: create ( $ from , $ to , $ subject ) -> setData ( [ 'JobID' => $ stalledJob -> ID , 'Message' => $ message , 'Site' => Director :: absoluteBaseURL ( ) , ] ) -> setHTMLTemplate ( 'QueuedJobsStalledJob' ) ; $ mail -> send ( ) ; } } 
protected function initialiseJob ( QueuedJobDescriptor $ jobDescriptor ) { 
protected function grabMutex ( QueuedJobDescriptor $ jobDescriptor ) { 
public function runJob ( $ jobId ) { 
protected function hasPassedTimeLimit ( ) { 
protected function isMemoryTooHigh ( ) { $ used = $ this -> getMemoryUsage ( ) ; $ limit = $ this -> getMemoryLimit ( ) ; return $ limit && ( $ used > $ limit ) ; } 
protected function getMemoryLimit ( ) { 
protected function parseMemory ( $ memString ) { switch ( strtolower ( substr ( $ memString , - 1 ) ) ) { case "b" : return round ( substr ( $ memString , 0 , - 1 ) ) ; case "k" : return round ( substr ( $ memString , 0 , - 1 ) * 1024 ) ; case "m" : return round ( substr ( $ memString , 0 , - 1 ) * 1024 * 1024 ) ; case "g" : return round ( substr ( $ memString , 0 , - 1 ) * 1024 * 1024 * 1024 ) ; default : return round ( $ memString ) ; } } 
public function getJobList ( $ type = null , $ includeUpUntil = 0 ) { return DataObject :: get ( QueuedJobDescriptor :: class , $ this -> getJobListFilter ( $ type , $ includeUpUntil ) ) ; } 
public function getJobListFilter ( $ type = null , $ includeUpUntil = 0 ) { $ util = singleton ( QJUtils :: class ) ; $ filter = [ 'JobStatus <>' => QueuedJob :: STATUS_COMPLETE ] ; if ( $ includeUpUntil ) { $ filter [ 'JobFinished > ' ] = DBDatetime :: create ( ) -> setValue ( DBDatetime :: now ( ) -> getTimestamp ( ) - $ includeUpUntil ) -> Rfc2822 ( ) ; } $ filter = $ util -> dbQuote ( $ filter , ' OR ' ) ; if ( $ type ) { $ filter = $ util -> dbQuote ( [ 'JobType =' => ( string ) $ type ] ) . ' AND (' . $ filter . ')' ; } return $ filter ; } 
public function runQueue ( $ queue ) { if ( ! self :: config ( ) -> get ( 'disable_health_check' ) ) { $ this -> checkJobHealth ( $ queue ) ; } $ this -> checkdefaultJobs ( $ queue ) ; $ this -> queueRunner -> runQueue ( $ queue ) ; } 
public function processJobQueue ( $ name ) { 
public function queueTask ( $ request ) { $ name = $ request -> param ( 'TaskName' ) ; $ tasks = $ this -> getTasks ( ) ; $ variables = $ request -> getVars ( ) ; unset ( $ variables [ 'url' ] ) ; unset ( $ variables [ 'flush' ] ) ; unset ( $ variables [ 'flushtoken' ] ) ; unset ( $ variables [ 'isDev' ] ) ; $ querystring = http_build_query ( $ variables ) ; $ title = function ( $ content ) { printf ( Director :: is_cli ( ) ? "%s\n\n" : '<h1>%s</h1>' , $ content ) ; } ; $ message = function ( $ content ) { printf ( Director :: is_cli ( ) ? "%s\n" : '<p>%s</p>' , $ content ) ; } ; foreach ( $ tasks as $ task ) { if ( $ task [ 'segment' ] == $ name ) { $ inst = Injector :: inst ( ) -> create ( $ task [ 'class' ] ) ; if ( ! $ inst -> isEnabled ( ) ) { $ message ( 'The task is disabled' ) ; return ; } $ title ( sprintf ( 'Queuing Task %s' , $ inst -> getTitle ( ) ) ) ; $ job = new RunBuildTaskJob ( $ task [ 'class' ] , $ querystring ) ; $ jobID = Injector :: inst ( ) -> get ( QueuedJobService :: class ) -> queueJob ( $ job ) ; $ message ( 'Done: queued with job ID ' . $ jobID ) ; $ adminUrl = Director :: baseURL ( ) . AdminRootController :: config ( ) -> get ( 'url_base' ) ; $ adminLink = $ adminUrl . "/queuedjobs/" . str_replace ( '\\' , '-' , QueuedJobDescriptor :: class ) ; $ message ( "Visit <a href=\"$adminLink\">queued jobs admin</a> to see job status" ) ; return ; } } $ message ( sprintf ( 'The build task "%s" could not be found' , Convert :: raw2xml ( $ name ) ) ) ; } 
protected function writeLogLine ( $ line , $ prefix = null ) { if ( ! $ prefix ) { $ prefix = '[' . DBDatetime :: now ( ) -> Rfc2822 ( ) . '] ' ; } if ( Director :: is_cli ( ) ) { echo $ prefix . $ line . "\n" ; } else { echo Convert :: raw2xml ( $ prefix . $ line ) . "<br>" ; } } 
protected function logDescriptorStatus ( $ descriptor , $ queue ) { if ( is_null ( $ descriptor ) ) { $ this -> writeLogLine ( 'No new jobs on queue ' . $ queue ) ; } if ( $ descriptor === false ) { $ this -> writeLogLine ( 'Job is still running on queue ' . $ queue ) ; } if ( $ descriptor instanceof QueuedJobDescriptor ) { $ this -> writeLogLine ( 'Running ' . $ descriptor -> JobTitle . ' and others from queue ' . $ queue . '.' ) ; } } 
public function listJobs ( ) { $ service = $ this -> getService ( ) ; for ( $ i = 1 ; $ i <= 3 ; $ i ++ ) { $ jobs = $ service -> getJobList ( $ i ) ; $ num = $ jobs ? $ jobs -> Count ( ) : 0 ; $ this -> writeLogLine ( 'Found ' . $ num . ' jobs for mode ' . $ i . '.' ) ; } } 
protected function refreshDescriptor ( ) { if ( $ this -> descriptor ) { $ this -> descriptor = QueuedJobDescriptor :: get ( ) -> byID ( $ this -> descriptor -> ID ) ; } } 
public function unserialize ( $ serialized ) { $ data = unserialize ( $ serialized ) ; if ( ! isset ( $ data [ 'descriptor' ] ) ) { throw new InvalidArgumentException ( 'Malformed data' ) ; } $ descriptor = QueuedJobDescriptor :: get ( ) -> filter ( 'ID' , $ data [ 'descriptor' ] ) -> first ( ) ; if ( ! $ descriptor ) { throw new InvalidArgumentException ( 'Descriptor not found' ) ; } $ this -> descriptor = $ descriptor ; } 
public function shouldExpire ( $ startedAt ) { if ( $ this -> descriptor -> hasMethod ( 'shouldExpire' ) ) { return $ this -> descriptor -> shouldExpire ( $ startedAt ) ; } return true ; } 
public function canRunTask ( ) { $ this -> refreshDescriptor ( ) ; return in_array ( $ this -> descriptor -> JobStatus , array ( QueuedJob :: STATUS_NEW , QueuedJob :: STATUS_INIT , QueuedJob :: STATUS_WAIT ) ) ; } 
public function isCancelled ( ) { $ this -> refreshDescriptor ( ) ; 
public function run ( $ request ) { $ queue = $ request -> requestVar ( 'queue' ) ? : QueuedJob :: QUEUED ; $ stalledJobCount = $ this -> getService ( ) -> checkJobHealth ( $ queue ) ; echo $ stalledJobCount === 0 ? 'All jobs are healthy' : 'Detected and attempted restart on ' . $ stalledJobCount . ' stalled jobs' ; } 
public function pause ( $ force = false ) { if ( $ force || in_array ( $ this -> JobStatus , [ QueuedJob :: STATUS_WAIT , QueuedJob :: STATUS_RUN , QueuedJob :: STATUS_INIT ] ) ) { $ this -> JobStatus = QueuedJob :: STATUS_PAUSED ; $ this -> write ( ) ; return true ; } return false ; } 
public function resume ( $ force = false ) { if ( $ force || in_array ( $ this -> JobStatus , [ QueuedJob :: STATUS_PAUSED , QueuedJob :: STATUS_BROKEN ] ) ) { $ this -> JobStatus = QueuedJob :: STATUS_WAIT ; $ this -> ResumeCounts ++ ; $ this -> write ( ) ; QueuedJobService :: singleton ( ) -> startJob ( $ this ) ; return true ; } return false ; } 
public function activateOnQueue ( ) { 
protected function getJobDir ( ) { 
public function cleanupJob ( ) { 
public function getMessages ( ) { if ( strlen ( $ this -> SavedJobMessages ) ) { $ messages = @ unserialize ( $ this -> SavedJobMessages ) ; if ( ! empty ( $ messages ) ) { return DBField :: create_field ( 'HTMLText' , '<ul><li>' . nl2br ( implode ( '</li><li>' , Convert :: raw2xml ( $ messages ) ) ) . '</li></ul>' ) ; } return '' ; } } 
public function getLastMessage ( ) { if ( strlen ( $ this -> SavedJobMessages ) ) { $ msgs = @ unserialize ( $ this -> SavedJobMessages ) ; if ( is_array ( $ msgs ) && sizeof ( $ msgs ) ) { return array_pop ( $ msgs ) ; } } } 
public function getJobTypeString ( ) { $ map = $ this -> getJobTypeValues ( ) ; return isset ( $ map [ $ this -> JobType ] ) ? $ map [ $ this -> JobType ] : '(Unknown)' ; } 
public function getJobTypeValues ( ) { return [ QueuedJob :: IMMEDIATE => _t ( __CLASS__ . '.TYPE_IMMEDIATE' , 'Immediate' ) , QueuedJob :: QUEUED => _t ( __CLASS__ . '.TYPE_QUEUED' , 'Queued' ) , QueuedJob :: LARGE => _t ( __CLASS__ . '.TYPE_LARGE' , 'Large' ) , ] ; } 
public function setup ( ) { parent :: setup ( ) ; Environment :: increaseTimeLimitTo ( ) ; $ restart = $ this -> currentStep == 0 ; if ( ! $ this -> tempFile || ! file_exists ( $ this -> tempFile ) ) { $ tmpfile = tempnam ( TempFolder :: getTempFolder ( BASE_PATH ) , 'sitemap' ) ; if ( file_exists ( $ tmpfile ) ) { $ this -> tempFile = $ tmpfile ; } $ restart = true ; } if ( $ restart ) { $ this -> pagesToProcess = DB :: query ( 'SELECT ID FROM SiteTree_Live WHERE ShowInSearch=1' ) -> column ( ) ; } } 
public function prepareForRestart ( ) { parent :: prepareForRestart ( ) ; 
protected function completeJob ( ) { $ content = '<?xml version="1.0" encoding="UTF-8"?>' . '<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">' ; $ content .= file_get_contents ( $ this -> tempFile ) ; $ content .= '</urlset>' ; $ sitemap = Director :: baseFolder ( ) . '/sitemap.xml' ; file_put_contents ( $ sitemap , $ content ) ; if ( file_exists ( $ this -> tempFile ) ) { unlink ( $ this -> tempFile ) ; } $ nextgeneration = Injector :: inst ( ) -> create ( GenerateGoogleSitemapJob :: class ) ; QueuedJobService :: singleton ( ) -> queueJob ( $ nextgeneration , DBDatetime :: create ( ) -> setValue ( DBDatetime :: now ( ) -> getTimestamp ( ) + $ this -> config ( ) -> get ( 'regenerate_time' ) ) -> Rfc2822 ( ) ) ; } 
public function runQueue ( $ queue ) { 
public function handleAction ( GridField $ gridField , $ actionName , $ arguments , $ data ) { $ actions = $ this -> getActions ( null ) ; if ( in_array ( $ actionName , $ actions ) ) { $ item = $ gridField -> getList ( ) -> byID ( $ arguments [ 'RecordID' ] ) ; if ( ! $ item ) { return ; } $ item -> $ actionName ( ) ; Requirements :: clear ( ) ; } } 
public function getTitle ( ) { $ title = 'Unknown' ; if ( $ root = $ this -> getRoot ( ) ) { $ title = $ root -> Title ; } return _t ( __CLASS__ . '.Title' , "Publish items beneath {title}" , [ 'title' => $ title ] ) ; } 
public function setup ( ) { if ( ! $ this -> getRoot ( ) ) { 
public function process ( ) { $ remainingChildren = $ this -> remainingChildren ; 
protected function getQueue ( $ request ) { $ queue = $ request -> getVar ( 'queue' ) ; if ( ! $ queue ) { $ queue = 'Queued' ; } switch ( strtolower ( $ queue ) ) { case 'immediate' : $ queue = QueuedJob :: IMMEDIATE ; break ; case 'queued' : $ queue = QueuedJob :: QUEUED ; break ; case 'large' : $ queue = QueuedJob :: LARGE ; break ; default : break ; } return $ queue ; } 
public static function castModel ( ActiveRecord $ model ) { $ attributes = array_merge ( $ model -> getAttributes ( ) , $ model -> getRelatedRecords ( ) ) ; $ results = [ ] ; foreach ( $ attributes as $ key => $ value ) { $ results [ Caster :: PREFIX_VIRTUAL . $ key ] = $ value ; } return $ results ; } 
public function actionIndex ( ) { $ config = new Configuration ; $ config -> getPresenter ( ) -> addCasters ( $ this -> getCasters ( ) ) ; $ shell = new Shell ( $ config ) ; $ shell -> setIncludes ( $ this -> include ) ; $ shell -> run ( ) ; } 
public function css ( $ file , $ media = null ) { $ css_file = $ this -> processScssFile ( $ file ) ; return parent :: css ( $ css_file , $ media ) ; } 
public function processScssFile ( $ file ) { if ( ! preg_match ( '/\.scss$/' , $ file ) ) { 
public function saveMap ( $ content ) { $ asset_handler = Requirements :: backend ( ) -> getAssetHandler ( ) ; $ css_file = $ this -> options [ 'sourceMapWriteTo' ] ; $ asset_handler -> setContent ( $ css_file , $ content ) ; $ url = $ asset_handler -> getContentURL ( $ css_file ) ; $ this -> options [ 'sourceMapURL' ] = $ url ; return $ this -> options [ 'sourceMapURL' ] ; } 
public function write ( $ data ) { $ size = mb_strlen ( $ data , 'UTF-8' ) ; if ( $ this -> exists ( $ this -> id ) ) { shmop_delete ( $ this -> shmid ) ; shmop_close ( $ this -> shmid ) ; $ this -> shmid = shmop_open ( $ this -> id , "c" , $ this -> perms , $ size ) ; shmop_write ( $ this -> shmid , $ data , 0 ) ; } else { $ this -> shmid = shmop_open ( $ this -> id , "c" , $ this -> perms , $ size ) ; shmop_write ( $ this -> shmid , $ data , 0 ) ; } } 
public function read ( ) { $ size = shmop_size ( $ this -> shmid ) ; $ data = shmop_read ( $ this -> shmid , 0 , $ size ) ; return $ data ; } 
private static function getInitialValue ( string & $ key , bool $ padding_enabled ) : string { if ( false === $ padding_enabled ) { return \ hex2bin ( 'A6A6A6A6A6A6A6A6' ) ; } $ MLI = \ mb_strlen ( $ key , '8bit' ) ; $ iv = \ hex2bin ( 'A65959A6' ) . self :: toXBits ( 32 , $ MLI ) ; $ n = \ intval ( \ ceil ( $ MLI / 8 ) ) ; $ key = \ str_pad ( $ key , 8 * $ n , "\0" , STR_PAD_RIGHT ) ; return $ iv ; } 
public static function wrap ( string $ kek , string $ key , bool $ padding_enabled = false ) : string { $ A = self :: getInitialValue ( $ key , $ padding_enabled ) ; self :: checkKeySize ( $ key , $ padding_enabled ) ; $ P = \ str_split ( $ key , 8 ) ; $ N = \ count ( $ P ) ; $ C = [ ] ; if ( 1 === $ N ) { $ B = self :: encrypt ( $ kek , $ A . $ P [ 0 ] ) ; $ C [ 0 ] = self :: getMSB ( $ B ) ; $ C [ 1 ] = self :: getLSB ( $ B ) ; } elseif ( 1 < $ N ) { $ R = $ P ; for ( $ j = 0 ; $ j <= 5 ; ++ $ j ) { for ( $ i = 1 ; $ i <= $ N ; ++ $ i ) { $ B = self :: encrypt ( $ kek , $ A . $ R [ $ i - 1 ] ) ; $ t = $ i + $ j * $ N ; $ A = self :: toXBits ( 64 , $ t ) ^ self :: getMSB ( $ B ) ; $ R [ $ i - 1 ] = self :: getLSB ( $ B ) ; } } $ C = \ array_merge ( [ $ A ] , $ R ) ; } return \ implode ( '' , $ C ) ; } 
public static function unwrap ( string $ kek , string $ key , bool $ padding_enabled = false ) : string { $ P = \ str_split ( $ key , 8 ) ; $ A = $ P [ 0 ] ; $ N = \ count ( $ P ) ; if ( 2 > $ N ) { throw new \ InvalidArgumentException ( 'Bad data' ) ; } if ( 2 === $ N ) { $ B = self :: decrypt ( $ kek , $ P [ 0 ] . $ P [ 1 ] ) ; $ unwrapped = self :: getLSB ( $ B ) ; $ A = self :: getMSB ( $ B ) ; } else { $ R = $ P ; for ( $ j = 5 ; $ j >= 0 ; -- $ j ) { for ( $ i = $ N - 1 ; $ i >= 1 ; -- $ i ) { $ t = $ i + $ j * ( $ N - 1 ) ; $ B = self :: decrypt ( $ kek , ( self :: toXBits ( 64 , $ t ) ^ $ A ) . $ R [ $ i ] ) ; $ A = self :: getMSB ( $ B ) ; $ R [ $ i ] = self :: getLSB ( $ B ) ; } } unset ( $ R [ 0 ] ) ; $ unwrapped = \ implode ( '' , $ R ) ; } if ( false === self :: checkInitialValue ( $ unwrapped , $ padding_enabled , $ A ) ) { throw new \ InvalidArgumentException ( 'Integrity check failed!' ) ; } return $ unwrapped ; } 
public function list_ ( $ args , $ assoc_args ) { global $ wp_registered_sidebars ; Utils \ wp_register_unused_sidebar ( ) ; if ( ! empty ( $ assoc_args [ 'format' ] ) && 'ids' === $ assoc_args [ 'format' ] ) { $ sidebars = wp_list_pluck ( $ wp_registered_sidebars , 'id' ) ; } else { $ sidebars = $ wp_registered_sidebars ; } $ formatter = new Formatter ( $ assoc_args , $ this -> fields ) ; $ formatter -> display_items ( $ sidebars ) ; } 
public function list_ ( $ args , $ assoc_args ) { list ( $ sidebar_id ) = $ args ; $ this -> validate_sidebar ( $ sidebar_id ) ; $ output_widgets = $ this -> get_sidebar_widgets ( $ sidebar_id ) ; if ( ! empty ( $ assoc_args [ 'format' ] ) && 'ids' === $ assoc_args [ 'format' ] ) { $ output_widgets = wp_list_pluck ( $ output_widgets , 'id' ) ; } $ formatter = new Formatter ( $ assoc_args , $ this -> fields ) ; $ formatter -> display_items ( $ output_widgets ) ; } 
public function add ( $ args , $ assoc_args ) { list ( $ name , $ sidebar_id ) = $ args ; $ position = Utils \ get_flag_value ( $ args , 2 , 1 ) - 1 ; $ this -> validate_sidebar ( $ sidebar_id ) ; $ widget = $ this -> get_widget_obj ( $ name ) ; if ( false === $ widget ) { WP_CLI :: error ( 'Invalid widget type.' ) ; } $ widget_options = $ this -> get_widget_options ( $ name ) ; $ option_keys = $ widget_options ; if ( ! isset ( $ widget_options [ '_multiwidget' ] ) ) { $ widget_options [ '_multiwidget' ] = 1 ; } unset ( $ option_keys [ '_multiwidget' ] ) ; $ option_keys = array_keys ( $ option_keys ) ; $ last_key = array_pop ( $ option_keys ) ; $ option_index = $ last_key + 1 ; $ widget_options [ $ option_index ] = $ this -> sanitize_widget_options ( $ name , $ assoc_args , array ( ) ) ; $ this -> update_widget_options ( $ name , $ widget_options ) ; $ widget_id = $ name . '-' . $ option_index ; $ this -> move_sidebar_widget ( $ widget_id , null , $ sidebar_id , null , $ position ) ; WP_CLI :: success ( 'Added widget to sidebar.' ) ; } 
public function update ( $ args , $ assoc_args ) { list ( $ widget_id ) = $ args ; if ( ! $ this -> validate_sidebar_widget ( $ widget_id ) ) { WP_CLI :: error ( "Widget doesn't exist." ) ; } if ( empty ( $ assoc_args ) ) { WP_CLI :: error ( 'No options specified to update.' ) ; } list ( $ name , $ option_index ) = $ this -> get_widget_data ( $ widget_id ) ; $ widget_options = $ this -> get_widget_options ( $ name ) ; $ clean_options = $ this -> sanitize_widget_options ( $ name , $ assoc_args , $ widget_options [ $ option_index ] ) ; $ widget_options [ $ option_index ] = array_merge ( ( array ) $ widget_options [ $ option_index ] , $ clean_options ) ; $ this -> update_widget_options ( $ name , $ widget_options ) ; WP_CLI :: success ( 'Widget updated.' ) ; } 
public function move ( $ args , $ assoc_args ) { list ( $ widget_id ) = $ args ; if ( ! $ this -> validate_sidebar_widget ( $ widget_id ) ) { WP_CLI :: error ( "Widget doesn't exist." ) ; } if ( empty ( $ assoc_args [ 'position' ] ) && empty ( $ assoc_args [ 'sidebar-id' ] ) ) { WP_CLI :: error ( 'A new position or new sidebar must be specified.' ) ; } list ( $ name , $ option_index , $ current_sidebar_id , $ current_sidebar_index ) = $ this -> get_widget_data ( $ widget_id ) ; $ new_sidebar_id = ! empty ( $ assoc_args [ 'sidebar-id' ] ) ? $ assoc_args [ 'sidebar-id' ] : $ current_sidebar_id ; $ this -> validate_sidebar ( $ new_sidebar_id ) ; $ new_sidebar_index = ! empty ( $ assoc_args [ 'position' ] ) ? $ assoc_args [ 'position' ] - 1 : $ current_sidebar_index ; 
public function deactivate ( $ args , $ assoc_args ) { $ count = 0 ; $ errors = 0 ; foreach ( $ args as $ widget_id ) { if ( ! $ this -> validate_sidebar_widget ( $ widget_id ) ) { WP_CLI :: warning ( "Widget '{$widget_id}' doesn't exist." ) ; $ errors ++ ; continue ; } list ( $ name , $ option_index , $ sidebar_id , $ sidebar_index ) = $ this -> get_widget_data ( $ widget_id ) ; if ( 'wp_inactive_widgets' === $ sidebar_id ) { WP_CLI :: warning ( sprintf ( "'%s' is already deactivated." , $ widget_id ) ) ; continue ; } $ this -> move_sidebar_widget ( $ widget_id , $ sidebar_id , 'wp_inactive_widgets' , $ sidebar_index , 0 ) ; $ count ++ ; } Utils \ report_batch_operation_results ( 'widget' , 'deactivate' , count ( $ args ) , $ count , $ errors ) ; } 
public function delete ( $ args , $ assoc_args ) { $ count = 0 ; $ errors = 0 ; foreach ( $ args as $ widget_id ) { if ( ! $ this -> validate_sidebar_widget ( $ widget_id ) ) { WP_CLI :: warning ( "Widget '{$widget_id}' doesn't exist." ) ; $ errors ++ ; continue ; } 
public function reset ( $ args , $ assoc_args ) { global $ wp_registered_sidebars ; $ all = Utils \ get_flag_value ( $ assoc_args , 'all' , false ) ; 
private function validate_sidebar ( $ sidebar_id ) { global $ wp_registered_sidebars ; Utils \ wp_register_unused_sidebar ( ) ; if ( ! array_key_exists ( $ sidebar_id , $ wp_registered_sidebars ) ) { WP_CLI :: error ( 'Invalid sidebar.' ) ; } } 
private function validate_sidebar_widget ( $ widget_id ) { $ sidebars_widgets = $ this -> wp_get_sidebars_widgets ( ) ; $ widget_exists = false ; foreach ( $ sidebars_widgets as $ sidebar_id => $ widgets ) { if ( in_array ( $ widget_id , $ widgets , true ) ) { $ widget_exists = true ; break ; } } return $ widget_exists ; } 
private function get_sidebar_widgets ( $ sidebar_id ) { $ all_widgets = $ this -> wp_get_sidebars_widgets ( ) ; if ( empty ( $ all_widgets [ $ sidebar_id ] ) ) { return array ( ) ; } $ prepared_widgets = array ( ) ; foreach ( $ all_widgets [ $ sidebar_id ] as $ key => $ widget_id ) { $ prepared_widget = new stdClass ( ) ; $ parts = explode ( '-' , $ widget_id ) ; $ option_index = array_pop ( $ parts ) ; $ widget_name = implode ( '-' , $ parts ) ; $ prepared_widget -> name = $ widget_name ; $ prepared_widget -> id = $ widget_id ; $ prepared_widget -> position = $ key + 1 ; $ widget_options = get_option ( 'widget_' . $ widget_name ) ; $ prepared_widget -> options = $ widget_options [ $ option_index ] ; $ prepared_widgets [ ] = $ prepared_widget ; } return $ prepared_widgets ; } 
private function get_widget_data ( $ widget_id ) { $ parts = explode ( '-' , $ widget_id ) ; $ option_index = array_pop ( $ parts ) ; $ name = implode ( '-' , $ parts ) ; $ sidebar_id = false ; $ sidebar_index = false ; $ all_widgets = $ this -> wp_get_sidebars_widgets ( ) ; foreach ( $ all_widgets as $ s_id => & $ widgets ) { $ key = array_search ( $ widget_id , $ widgets , true ) ; if ( false !== $ key ) { $ sidebar_id = $ s_id ; $ sidebar_index = $ key ; break ; } } return array ( $ name , $ option_index , $ sidebar_id , $ sidebar_index ) ; } 
private function move_sidebar_widget ( $ widget_id , $ current_sidebar_id , $ new_sidebar_id , $ current_index , $ new_index ) { $ all_widgets = $ this -> wp_get_sidebars_widgets ( ) ; $ needs_placement = true ; 
private function get_widget_obj ( $ id_base ) { global $ wp_widget_factory ; $ widget = wp_filter_object_list ( $ wp_widget_factory -> widgets , array ( 'id_base' => $ id_base ) ) ; if ( empty ( $ widget ) ) { return false ; } return array_pop ( $ widget ) ; } 
private function sanitize_widget_options ( $ id_base , $ dirty_options , $ old_options ) { $ widget = $ this -> get_widget_obj ( $ id_base ) ; if ( empty ( $ widget ) ) { return array ( ) ; } 
public function getRandomInteger ( $ min = 0 , $ max = PHP_INT_MAX ) { $ min = ( int ) $ min ; $ max = ( int ) $ max ; $ range = $ max - $ min ; $ bits = $ this -> getBitsInInteger ( $ range ) ; $ bytes = $ this -> getBytesInBits ( $ bits ) ; $ mask = ( int ) ( ( 1 << $ bits ) - 1 ) ; do { $ byteString = $ this -> generator -> generate ( $ bytes ) ; $ result = hexdec ( bin2hex ( $ byteString ) ) & $ mask ; } while ( $ result > $ range ) ; return ( int ) $ result + $ min ; } 
public function getRandomString ( $ length , $ charset = null ) { $ length = ( int ) $ length ; if ( ! $ charset ) { $ charset = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789./' ; } $ charsetLength = strlen ( $ charset ) ; $ neededBytes = $ this -> getBytesInBits ( $ length * ( $ this -> getBitsInInteger ( $ charsetLength ) + 1 ) ) ; $ string = '' ; do { $ byteString = $ this -> generator -> generate ( $ neededBytes ) ; for ( $ i = 0 ; $ i < $ neededBytes ; ++ $ i ) { if ( ord ( $ byteString [ $ i ] ) > ( 255 - ( 255 % $ charsetLength ) ) ) { continue ; } $ string .= $ charset [ ord ( $ byteString [ $ i ] ) % $ charsetLength ] ; } } while ( strlen ( $ string ) < $ length ) ; return substr ( $ string , 0 , $ length ) ; } 
public function encode ( $ string ) { $ encoded = '' ; if ( $ string ) { $ binString = '' ; 
public function decode ( $ string ) { $ decoded = '' ; $ string = preg_replace ( "/[^{$this->charset}]/" , '' , rtrim ( strtoupper ( $ string ) , $ this -> charset [ 32 ] ) ) ; if ( $ string ) { $ binString = '' ; foreach ( str_split ( $ string ) as $ char ) { $ binString .= str_pad ( decbin ( strpos ( $ this -> charset , $ char ) ) , 5 , 0 , STR_PAD_LEFT ) ; } $ binString = substr ( $ binString , 0 , ( floor ( strlen ( $ binString ) / 8 ) * 8 ) ) ; foreach ( str_split ( $ binString , 8 ) as $ chunk ) { $ chunk = str_pad ( $ chunk , 8 , 0 , STR_PAD_RIGHT ) ; $ decoded .= chr ( bindec ( $ chunk ) ) ; } } return $ decoded ; } 
public function generate ( $ byteCount ) { $ bytes = '' ; if ( strlen ( ! $ this -> randomString ) ) { $ this -> randomString = chr ( 0 ) ; } do { $ bytes .= $ this -> randomString ; } while ( strlen ( $ bytes ) < $ byteCount ) ; return substr ( $ bytes , 0 , $ byteCount ) ; } 
public function generate ( $ byteCount ) { $ bytes = '' ; if ( self :: isSupported ( ) ) { if ( $ fp = @ fopen ( $ this -> file , 'rb' ) ) { if ( function_exists ( 'stream_set_read_buffer' ) ) { stream_set_read_buffer ( $ fp , 0 ) ; } $ fileBytes = fread ( $ fp , $ byteCount ) ; if ( $ fileBytes ) { $ bytes = $ fileBytes ; } } } return str_pad ( $ bytes , $ byteCount , chr ( 0 ) ) ; } 
public static function isSupported ( ) { $ supported = false ; $ class = __CLASS__ ; $ self = new $ class ; if ( file_exists ( $ self -> file ) && is_readable ( $ self -> file ) ) { $ supported = true ; } return $ supported ; } 
public function generate ( $ byteCount ) { $ bitsPerRound = 2 ; $ msecPerRound = 400 ; $ hashLength = 20 ; $ total = $ byteCount ; $ generated = '' ; do { $ bytes = ( $ total > $ hashLength ) ? $ hashLength : $ total ; $ total -= $ bytes ; $ entropy = rand ( ) . uniqid ( mt_rand ( ) , true ) ; $ entropy .= implode ( '' , @ fstat ( @ fopen ( __FILE__ , 'r' ) ) ) ; $ entropy .= memory_get_usage ( ) ; for ( $ i = 0 ; $ i < 3 ; $ i ++ ) { $ counter1 = microtime ( true ) ; $ var = sha1 ( mt_rand ( ) ) ; for ( $ j = 0 ; $ j < 50 ; $ j ++ ) { $ var = sha1 ( $ var ) ; } $ counter2 = microtime ( true ) ; $ entropy .= $ counter1 . $ counter2 ; } $ rounds = ( int ) ( $ msecPerRound * 50 / ( int ) ( ( $ counter2 - $ counter1 ) * 1000000 ) ) ; $ iterations = $ bytes * ( int ) ( ceil ( 8 / $ bitsPerRound ) ) ; for ( $ i = 0 ; $ i < $ iterations ; $ i ++ ) { $ counter1 = microtime ( ) ; $ var = sha1 ( mt_rand ( ) ) ; for ( $ j = 0 ; $ j < $ rounds ; $ j ++ ) { $ var = sha1 ( $ var ) ; } $ counter2 = microtime ( ) ; $ entropy .= $ counter1 . $ counter2 ; } $ generated .= sha1 ( $ entropy , true ) ; } while ( $ byteCount > strlen ( $ generated ) ) ; $ bytes = substr ( $ generated , 0 , $ byteCount ) ; return str_pad ( $ bytes , $ byteCount , chr ( 0 ) ) ; } 
public function generate ( $ byteCount ) { $ bytes = '' ; if ( self :: isSupported ( ) ) { $ sslStrong = false ; $ sslBytes = openssl_random_pseudo_bytes ( $ byteCount , $ sslStrong ) ; if ( $ sslStrong ) { $ bytes = $ sslBytes ; } unset ( $ sslStrong ) ; } return str_pad ( $ bytes , $ byteCount , chr ( 0 ) ) ; } 
public static function isSupported ( ) { $ supported = false ; if ( function_exists ( 'openssl_random_pseudo_bytes' ) ) { if ( version_compare ( PHP_VERSION , '5.3.7' ) >= 0 || ( PHP_OS & "\xDF\xDF\xDF" ) !== 'WIN' ) { $ supported = true ; } } return $ supported ; } 
public function generate ( $ byteCount ) { $ bytes = '' ; if ( self :: isSupported ( ) ) { try { $ util = new \ COM ( 'CAPICOM.Utilities.1' ) ; $ capicomBytes = base64_decode ( $ util -> GetRandom ( $ byteCount , 0 ) ) ; if ( $ capicomBytes ) { $ bytes = $ capicomBytes ; } } catch ( \ Exception $ e ) { } } return str_pad ( $ bytes , $ byteCount , chr ( 0 ) ) ; } 
public function addGeneratorPath ( $ prefix , $ path ) { $ path = realpath ( $ path ) ; $ success = false ; if ( $ path && ! array_key_exists ( $ prefix , $ this -> generatorPaths ) ) { $ this -> generatorPaths [ $ prefix ] = $ path ; $ success = true ; } return $ success ; } 
public function removeGeneratorPath ( $ prefixOrPath ) { if ( array_key_exists ( $ prefixOrPath , $ this -> generatorPaths ) ) { $ prefix = $ prefixOrPath ; unset ( $ this -> generatorPaths [ $ prefix ] ) ; } elseif ( ( $ prefixOrPath = realpath ( $ prefixOrPath ) ) && in_array ( $ prefixOrPath , $ this -> generatorPaths ) ) { $ path = $ prefixOrPath ; $ generatorPaths = $ this -> generatorPaths ; $ this -> generatorPaths = array_filter ( $ generatorPaths , function ( $ value ) use ( $ path ) { return ( $ value != $ path ) ; } ) ; } return $ this ; } 
public function getGenerator ( ) { if ( ! $ this -> generators ) { $ this -> loadGenerators ( ) ; } $ generators = $ this -> generators ; usort ( $ generators , function ( $ a , $ b ) { return ( $ b :: getPriority ( ) - $ a :: getPriority ( ) ) ; } ) ; $ generator = null ; if ( isset ( $ generators [ 0 ] ) ) { $ class = $ generators [ 0 ] ; $ generator = new $ class ; } return $ generator ; } 
public function loadGenerators ( ) { 
public function generate ( $ byteCount ) { $ bytes = '' ; if ( self :: isSupported ( ) ) { $ mcryptStr = mcrypt_create_iv ( $ byteCount , MCRYPT_DEV_URANDOM ) ; if ( $ mcryptStr !== false ) { $ bytes = $ mcryptStr ; } } return str_pad ( $ bytes , $ byteCount , chr ( 0 ) ) ; } 
public function getAttribute ( $ attribute , $ fallback = null ) { if ( 'name' === $ attribute ) { return $ this -> name ; } return parent :: getAttribute ( $ attribute , $ fallback ) ; } 
public function label ( $ text , $ screenReaderOnly = false , $ extraClasses = [ ] ) { if ( $ text === null ) { return $ this ; } $ element = clone $ this ; $ element -> label = Label :: create ( ) -> text ( $ text ) -> addClassIf ( $ screenReaderOnly , 'sr-only' ) -> addClass ( 'col-form-label' ) -> addClass ( $ extraClasses ) ; return $ element ; } 
public function helpText ( $ text , $ small = true , $ muted = true , $ extraClass = null ) { if ( $ text === null ) { return $ this ; } $ element = clone $ this ; $ element -> helpText = $ small ? Small :: create ( ) -> text ( $ text ) : P :: create ( ) -> text ( $ text ) ; $ element -> helpText = $ element -> helpText -> addClassIf ( $ extraClass !== null , $ extraClass ) -> addClassIf ( $ muted , 'text-muted' ) ; return $ element ; } 
public function showAsRow ( $ rowConfig = 'default' ) { $ rowConfig = app ( 'config' ) -> get ( "bs4.form_rows.$rowConfig" , null ) ; if ( $ rowConfig === null ) { throw new \ InvalidArgumentException ( "Unknown configuration entry: bs4.form_rows.$rowConfig" ) ; } $ element = clone $ this ; 
public function readOnly ( $ showAsPlainText = false ) { $ element = clone $ this ; $ element -> plainText = $ showAsPlainText ; return $ element -> attribute ( 'readonly' , 'readonly' ) ; } 
public function openForm ( $ method , $ action , array $ options = [ ] ) : Htmlable { 
public function closeForm ( ) : Htmlable { $ out = $ this -> currentForm -> close ( ) ; $ this -> currentForm = null ; $ this -> formState = null ; return $ out ; } 
public function formGroup ( $ control = null , $ label = null , $ helpText = null ) : FormGroup { $ element = new FormGroup ( $ this -> formState , $ control ) ; return $ element -> helpText ( $ helpText ) -> label ( $ label ) ; } 
public function inputGroup ( $ control = null , $ prefix = null , $ suffix = null ) : InputGroup { $ element = new InputGroup ( $ control ) ; return $ element -> prefix ( $ prefix ) -> suffix ( $ suffix ) ; } 
public function input ( $ type = null , $ name = null , $ value = null ) : Input { $ value = $ this -> getFieldValue ( $ name , $ value ) ; $ element = new Input ( $ this -> formState ) ; return $ element -> typeIf ( $ type , $ type ) -> nameIf ( $ name , $ name ) -> idIf ( $ name , field_name_to_id ( $ name ) ) -> valueIf ( $ value !== null , $ value ) ; } 
public function simpleFile ( $ name = null ) : File { $ element = new File ( $ this -> formState ) ; return $ element -> nameIf ( $ name , $ name ) -> idIf ( $ name , field_name_to_id ( $ name ) ) ; } 
public function file ( $ name = null , $ description = null ) : CustomFile { $ element = new CustomFile ( $ this -> formState ) ; return $ element -> nameIf ( $ name , $ name ) -> idIf ( $ name , field_name_to_id ( $ name , 'wrapper' ) ) -> description ( $ description ) ; } 
public function textArea ( $ name = null , $ value = null ) : TextArea { $ value = $ this -> getFieldValue ( $ name , $ value ) ; $ element = new TextArea ( $ this -> formState ) ; return $ element -> nameIf ( $ name , $ name ) -> idIf ( $ name , field_name_to_id ( $ name ) ) -> valueIf ( $ value !== null , $ value ) ; } 
public function checkBox ( $ name = null , $ description = null , $ isChecked = false ) : CheckBox { $ isChecked = $ this -> getFieldValue ( $ name , $ isChecked ) ; $ element = new CheckBox ( $ this -> formState ) ; return $ element -> nameIf ( $ name , $ name ) -> idIf ( $ name , field_name_to_id ( $ name , 'wrapper' ) ) -> description ( $ description ) -> checked ( $ isChecked ) ; } 
public function radio ( $ name = null , $ description = null , $ isChecked = false ) : Radio { $ isChecked = $ this -> getFieldValue ( $ name , $ isChecked ) ; $ element = new Radio ( $ this -> formState ) ; return $ element -> nameIf ( $ name , $ name ) -> idIf ( $ name , field_name_to_id ( $ name , 'wrapper' ) ) -> description ( $ description ) -> checked ( $ isChecked ) ; } 
public function radioGroup ( $ name , $ options , $ selectedOption = null ) : RadioGroup { $ element = new RadioGroup ( $ this -> formState ) ; return $ element -> name ( $ name ) -> id ( field_name_to_id ( $ name ) . '_radio_group' ) -> options ( $ options ) -> selectedOption ( $ selectedOption ) ; } 
public function select ( $ name = null , $ options = [ ] , $ value = null ) : Select { $ value = $ this -> getFieldValue ( $ name , $ value ) ; $ element = new Select ( $ this -> formState ) ; return $ element -> nameIf ( $ name , $ name ) -> idIf ( $ name , field_name_to_id ( $ name ) ) -> options ( $ options ) -> valueIf ( $ value !== null , $ value ) ; } 
public function text ( $ name = null , $ value = null ) : Input { return $ this -> input ( 'text' , $ name , $ value ) ; } 
public function password ( $ name = null , $ value = null ) : Input { return $ this -> input ( 'password' , $ name , $ value ) ; } 
public function email ( $ name = null , $ value = null ) : Input { return $ this -> input ( 'email' , $ name , $ value ) ; } 
public function hidden ( $ name = null , $ value = null ) : Input { $ value = $ this -> getFieldValue ( $ name , $ value ) ; $ element = new Input ( $ this -> formState ) ; return $ element -> type ( 'hidden' ) -> nameIf ( $ name , $ name ) -> valueIf ( $ value !== null , $ value ) ; } 
public function submit ( $ text , $ variant = 'primary' , $ outlined = false ) : Button { return $ this -> button ( $ text , $ variant , $ outlined ) -> type ( 'submit' ) ; } 
public function button ( $ text , $ variant = 'secondary' , $ outlined = false ) : Button { return Button :: create ( ) -> variant ( $ variant , $ outlined ) -> html ( $ text ) ; } 
public function prefix ( $ prefix , $ isPlainText = true ) { if ( $ prefix === null ) { return $ this ; } $ element = clone $ this ; $ element -> prefixes [ ] = [ 'content' => $ prefix , 'plaintext' => $ isPlainText , ] ; return $ element ; } 
public function suffix ( $ suffix , $ isPlainText = true ) { if ( $ suffix === null ) { return $ this ; } $ element = clone $ this ; $ element -> suffixes [ ] = [ 'content' => $ suffix , 'plaintext' => $ isPlainText , ] ; return $ element ; } 
private function assembleAddons ( $ addons , $ addonContainerClass ) { if ( 0 === \ count ( $ addons ) ) { return $ this ; } $ div = Div :: create ( ) -> addClass ( $ addonContainerClass ) -> addChildren ( $ addons , function ( $ token ) { $ content = $ token [ 'content' ] ?? '' ; $ plainText = $ token [ 'plaintext' ] ?? true ; 
public function checked ( $ isChecked = true ) { $ isChecked = $ isChecked || $ isChecked === 'y' || $ isChecked === 1 ; $ element = clone $ this ; return $ isChecked ? $ element -> controlAttribute ( 'checked' , 'checked' ) : $ element -> forgetControlAttribute ( 'checked' ) ; } 
public function disabled ( $ disabled = true ) { $ element = clone $ this ; return $ disabled ? $ element -> controlAttribute ( 'disabled' , 'disabled' ) : $ element -> forgetControlAttribute ( 'disabled' ) ; } 
public function js ( array $ dependencies = [ 'jquery.slim' , 'popper' ] ) { $ dependencies [ ] = 'bs4' ; $ urls = collect ( [ 'jquery' => 'https://code.jquery.com/jquery-' . config ( 'bs4.versions.jquery' ) . '.min.js' , 'jquery.slim' => 'https://code.jquery.com/jquery-' . config ( 'bs4.versions.jquery' ) . '.slim.min.js' , 'popper' => 'https://cdnjs.cloudflare.com/ajax/libs/popper.js/' . config ( 'bs4.versions.popper' ) . '/umd/popper.min.js' , 'bs4' => self :: $ BS4_CDN . config ( 'bs4.versions.bootstrap' ) . '/js/bootstrap.min.js' , ] ) ; return $ this -> html -> div ( ) -> addChildren ( $ urls -> filter ( function ( $ value , $ key ) use ( $ dependencies ) { return \ in_array ( $ key , $ dependencies , true ) ; } ) -> map ( function ( $ v ) { return $ this -> mapScriptElement ( $ v ) ; } ) ) ; } 
public function addProgress ( $ progress , $ options = [ ] ) { $ options [ 'progress' ] = $ progress ; $ element = clone $ this ; $ element -> bars [ ] = $ options ; return $ element ; } 
public function boot ( ) { $ this -> mergeConfigFrom ( __DIR__ . '/../../config/bs4.php' , 'bs4' ) ; $ this -> loadViewsFrom ( __DIR__ . '/../../resources/views' , 'bs' ) ; $ this -> loadTranslationsFrom ( __DIR__ . '/../../resources/lang' , 'bs' ) ; if ( $ this -> app -> runningInConsole ( ) ) { $ this -> publishes ( [ __DIR__ . '/../../resources/views' => resource_path ( 'views/vendor/bs' ) , ] , 'views' ) ; $ this -> publishes ( [ __DIR__ . '/../../resources/lang' => resource_path ( 'lang/vendor/bs' ) , ] , 'lang' ) ; $ this -> publishes ( [ __DIR__ . '/../../config' => config_path ( ) , ] , 'config' ) ; } } 
public function register ( ) { $ this -> app -> singleton ( Bootstrap :: class ) ; $ this -> app -> singleton ( FormErrorProviderContract :: class , FormErrorProvider :: class ) ; $ this -> app -> singleton ( OldFormInputProviderContract :: class , OldFormInputProvider :: class ) ; $ this -> app -> bind ( FormStateContract :: class , FormState :: class ) ; } 
public function getAttribute ( $ attribute , $ fallback = null ) { if ( \ in_array ( $ attribute , $ this -> delegatedControlAttributes , true ) ) { return $ this -> getControlAttribute ( $ attribute , $ fallback ) ; } return parent :: getAttribute ( $ attribute , $ fallback ) ; } 
public function name ( $ name ) { $ element = clone $ this ; $ element -> control = $ this -> control -> nameIf ( $ name , $ name ) ; return $ element ; } 
public function wrapControlIn ( $ wrapper ) { if ( $ wrapper === null ) { return $ this ; } $ element = clone $ this ; $ element -> controlWrapper = $ wrapper ; return $ element ; } 
public function size ( $ size ) { if ( ! property_exists ( $ this , 'sizableClass' ) ) { throw new RuntimeException ( 'You must specify the sizable CSS class' ) ; } $ size = strtolower ( $ size ) ; if ( ! \ in_array ( $ size , [ 'lg' , 'sm' ] , true ) ) { throw new RuntimeException ( 'Invalid size' ) ; } return $ this -> addClass ( "{$this->sizableClass}-$size" ) ; } 
public function mergeProperties ( array $ properties , NodeInterface $ node ) : array { $ nodeProperties = $ node -> getProperties ( ) ; if ( $ nodeProperties instanceof \ Traversable ) { $ nodeProperties = iterator_to_array ( $ nodeProperties ) ; } return array_merge ( $ properties , $ nodeProperties ) ; } 
private function unscrub ( $ msg ) { $ args = $ msg -> arguments ; $ session = $ this ; foreach ( $ msg -> callbacks as $ id => $ path ) { if ( ! isset ( $ this -> wrapped [ $ id ] ) ) { $ this -> wrapped [ $ id ] = function ( ) use ( $ session , $ id ) { $ session -> request ( ( int ) $ id , func_get_args ( ) ) ; } ; } $ location = & $ args ; foreach ( $ path as $ part ) { if ( is_array ( $ location ) ) { $ location = & $ location [ $ part ] ; continue ; } $ location = & $ location -> $ part ; } $ location = $ this -> wrapped [ $ id ] ; } return $ args ; } 
public function clientTempF ( $ cb ) { $ this -> remote -> temperature ( function ( $ degC ) use ( $ cb ) { $ degF = round ( $ degC * 9 / 5 + 32 ) ; $ cb ( $ degF ) ; } ) ; } 
public function getPropertyValue ( $ path , $ cb ) { $ value = null ; try { $ value = $ this -> crSession -> getProperty ( $ path ) -> getValue ( ) ; } catch ( \ Exception $ e ) { $ this -> remote -> setException ( get_class ( $ e ) , $ e -> getMessage ( ) ) ; } $ this -> remote -> setValue ( $ value , function ( ) use ( $ cb ) { $ cb ( ) ; } ) ; } 
public function getNodes ( $ sessionName , $ path , $ cb ) { if ( ! $ this -> validateSessionName ( $ sessionName , $ cb ) ) return false ; $ exception = null ; $ msg = null ; $ names = array ( ) ; try { $ parent = $ this -> sessions [ $ sessionName ] -> getNode ( $ path ) ; $ nodes = $ parent -> getNodes ( ) ; $ names = array_keys ( $ nodes -> getArrayCopy ( ) ) ; } catch ( \ Exception $ e ) { $ exception = get_class ( $ e ) ; $ msg = $ e -> getMessage ( ) ; } $ cb ( $ names , $ exception , $ msg ) ; } 
public function getProperties ( $ sessionName , $ path , $ cb ) { if ( ! $ this -> validateSessionName ( $ sessionName , $ cb ) ) return false ; $ exception = null ; $ msg = null ; $ names = array ( ) ; try { $ parent = $ this -> sessions [ $ sessionName ] -> getNode ( $ path ) ; $ properties = $ parent -> getProperties ( ) ; $ names = array_keys ( $ properties ) ; } catch ( \ Exception $ e ) { $ exception = get_class ( $ e ) ; $ msg = $ e -> getMessage ( ) ; } $ cb ( $ names , $ exception , $ msg ) ; } 
public function getPropertyValue ( $ sessionName , $ path , $ cb ) { if ( ! array_key_exists ( $ sessionName , $ this -> sessions ) ) { $ cb ( null , 'RepositoryException' , 'Named session $sessionName not found' ) ; } $ exception = null ; $ msg = null ; $ val = null ; try { $ val = $ this -> sessions [ $ sessionName ] -> getProperty ( $ path ) -> getValue ( ) ; } catch ( \ Exception $ e ) { $ exception = get_class ( $ e ) ; $ msg = $ e -> getMessage ( ) ; } $ cb ( $ val , $ exception , $ msg ) ; } 
public function itemExists ( $ sessionName , $ path , $ cb ) { if ( ! $ this -> validateSessionName ( $ sessionName , $ cb ) ) return false ; $ exists = $ this -> sessions [ $ sessionName ] -> itemExists ( $ path ) ; $ cb ( $ exists , null , null ) ; } 
public function createSession ( $ sessionName , $ name , $ password ) { $ credentials = new \ PHPCR \ SimpleCredentials ( $ name , $ password ) ; $ this -> sessions [ $ sessionName ] = $ this -> repository -> login ( $ credentials ) ; } 
public function boot ( ) { 
public function register ( ) { $ configPath = __DIR__ . '/config/ytake-laravel-smarty.php' ; $ this -> mergeConfigFrom ( $ configPath , 'ytake-laravel-smarty' ) ; $ this -> publishes ( [ $ configPath => $ this -> resolveConfigurePath ( ) . DIRECTORY_SEPARATOR . 'ytake-laravel-smarty.php' , ] ) ; $ this -> app -> singleton ( 'smarty.view' , function ( $ app ) { $ smartyTemplate = new Smarty ; $ factory = new SmartyFactory ( $ app [ 'view.engine.resolver' ] , $ app [ 'view.finder' ] , $ app [ 'events' ] , $ smartyTemplate , $ this -> app [ 'config' ] ) ; 
protected function connection ( MemcachedExtension $ memcached , array $ servers ) { foreach ( $ servers as $ server ) { $ memcached -> addServer ( $ server [ 'host' ] , $ server [ 'port' ] , $ server [ 'weight' ] ) ; } return $ memcached ; } 
protected function read ( array $ keys ) { $ map = $ lookup = [ ] ; list ( $ map , $ lookup ) = $ this -> eachKeys ( $ keys , $ map , $ lookup ) ; $ result = [ ] ; $ memcachedResult = $ this -> memcached -> getMulti ( $ map ) ; foreach ( $ memcachedResult as $ k => $ v ) { $ result [ $ lookup [ $ k ] ] = $ v ; } return $ result ; } 
protected function delete ( array $ keys ) { foreach ( $ keys as $ k ) { $ k = sha1 ( $ k ) ; $ this -> memcached -> delete ( $ k ) ; } return true ; } 
public function _subTemplateRender ( $ template , $ cache_id , $ compile_id , $ caching , $ cache_lifetime , $ data , $ scope , $ forceTplCache , $ uid = null , $ content_func = null ) { $ this -> templateResourceName = $ template ; parent :: _subTemplateRender ( $ template , $ cache_id , $ compile_id , $ caching , $ cache_lifetime , $ data , $ scope , $ forceTplCache , $ uid , $ content_func ) ; } 
public function _subTemplateRegister ( ) { foreach ( $ this -> compiled -> includes as $ name => $ count ) { 
protected function normalizeName ( string $ name , SmartyFactory $ viewFactory ) { $ name = str_replace ( '.' . $ viewFactory -> getSmartyFileExtension ( ) , '' , $ name ) ; return str_replace ( '/' , '.' , $ name ) ; } 
public function setSmartyConfigure ( ) { $ config = $ this -> config -> get ( 'ytake-laravel-smarty' ) ; $ smarty = $ this -> smarty ; $ smarty -> setTemplateDir ( array_get ( $ config , 'template_path' ) ) ; $ smarty -> setCompileDir ( array_get ( $ config , 'compile_path' ) ) ; $ smarty -> setCacheDir ( array_get ( $ config , 'cache_path' ) ) ; $ smarty -> setConfigDir ( array_get ( $ config , 'config_paths' ) ) ; foreach ( array_get ( $ config , 'plugins_paths' , [ ] ) as $ plugins ) { $ smarty -> addPluginsDir ( $ plugins ) ; } $ smarty -> error_reporting = array_get ( $ config , 'error_reporting' , E_ALL & ~ E_NOTICE ) ; 
public function handle ( ) { $ removedFiles = $ this -> smartyFactory -> getSmarty ( ) -> clearCompiledTemplate ( $ this -> option ( 'file' ) , $ this -> option ( 'compile_id' ) ) ; if ( $ removedFiles > 0 ) { $ this -> info ( "Removed $removedFiles compiled Smarty file" . ( $ removedFiles > 1 ? 's' : '' ) . '.' ) ; } return 0 ; } 
protected function evaluatePath ( string $ path , array $ data = [ ] ) { extract ( $ data , EXTR_SKIP ) ; try { if ( ! $ this -> smarty -> isCached ( $ path ) ) { foreach ( $ data as $ var => $ val ) { $ this -> smarty -> assign ( $ var , $ val ) ; } } 
public function handle ( ) { 
protected function read ( array $ keys ) { $ map = $ lookup = [ ] ; list ( $ map , $ lookup ) = $ this -> eachKeys ( $ keys , $ map , $ lookup ) ; $ result = [ ] ; foreach ( $ map as $ key ) { $ result [ $ lookup [ $ key ] ] = $ this -> redis -> get ( $ key ) ; } return $ result ; } 
protected function write ( array $ keys , $ expire = 1 ) { foreach ( $ keys as $ k => $ v ) { $ k = sha1 ( $ k ) ; $ this -> redis -> setex ( $ k , $ expire , $ v ) ; } return true ; } 
protected function delete ( array $ keys ) { foreach ( $ keys as $ k ) { $ k = sha1 ( $ k ) ; $ this -> redis -> del ( $ k ) ; } return true ; } 
public function handle ( ) { $ configureFileExtension = $ this -> config -> get ( 'ytake-laravel-smarty.extension' , 'tpl' ) ; $ fileExtension = ( is_null ( $ this -> option ( 'extension' ) ) ) ? $ configureFileExtension : $ this -> option ( 'extension' ) ; ob_start ( ) ; $ compileFiles = $ this -> smarty -> compileAllTemplates ( $ fileExtension , $ this -> forceCompile ( ) ) ; $ contents = ob_get_contents ( ) ; ob_get_clean ( ) ; $ this -> comment ( str_replace ( "<br>" , "" , trim ( $ contents ) ) ) ; $ this -> info ( "{$compileFiles} template files recompiled" ) ; return 0 ; } 
protected function eachKeys ( array $ keys , array $ map , array $ lookup ) { foreach ( $ keys as $ k ) { $ hash = sha1 ( $ k ) ; $ map [ ] = $ hash ; $ lookup [ $ hash ] = $ k ; } return [ $ map , $ lookup ] ; } 
public function run ( ) { if ( ! $ this -> isWindows ( ) ) { $ command = $ this -> testsPath . "vendor/bin/selenium-server-standalone " . $ this -> getWebDriver ( ) . $ this -> seleniumParams . ' >> selenium.log 2>&1 &' ; print ( 'executing: ' . $ command ) ; exec ( $ command ) ; return ; } $ command = "START java.exe -jar " . $ this -> getWebDriver ( ) . $ this -> seleniumParams . ' ' . __DIR__ . '\bin\selenium-server-standalone.jar' ; print ( 'executing: ' . $ command ) ; pclose ( popen ( $ command , 'r' ) ) ; } 
public function getWebdriver ( ) { $ browser = $ this -> browser ; $ config = parse_ini_file ( __DIR__ . '/config.dist.ini' , true ) ; if ( file_exists ( __DIR__ . '/config.ini' ) ) { $ config = parse_ini_file ( __DIR__ . '/config.ini' , true ) ; } if ( $ browser == 'chrome' ) { $ driver [ 'type' ] = 'webdriver.chrome.driver' ; } elseif ( $ browser == 'firefox' ) { $ driver [ 'type' ] = 'webdriver.gecko.driver' ; } elseif ( $ browser == 'MicrosoftEdge' ) { $ driver [ 'type' ] = 'webdriver.edge.driver' ; } elseif ( $ browser == 'edg' ) { $ driver [ 'type' ] = 'webdriver.edg.driver' ; } elseif ( $ browser == 'internet explorer' ) { $ driver [ 'type' ] = 'webdriver.ie.driver' ; } 
public function handle ( $ request , Closure $ next ) { $ response = $ next ( $ request ) ; 
public function getAperture ( ) { if ( ! isset ( $ this -> data [ self :: APERTURE ] ) ) { return false ; } return $ this -> data [ self :: APERTURE ] ; } 
public function getAuthor ( ) { if ( ! isset ( $ this -> data [ self :: AUTHOR ] ) ) { return false ; } return $ this -> data [ self :: AUTHOR ] ; } 
public function getHeadline ( ) { if ( ! isset ( $ this -> data [ self :: HEADLINE ] ) ) { return false ; } return $ this -> data [ self :: HEADLINE ] ; } 
public function getCredit ( ) { if ( ! isset ( $ this -> data [ self :: CREDIT ] ) ) { return false ; } return $ this -> data [ self :: CREDIT ] ; } 
public function getSource ( ) { if ( ! isset ( $ this -> data [ self :: SOURCE ] ) ) { return false ; } return $ this -> data [ self :: SOURCE ] ; } 
public function getJobtitle ( ) { if ( ! isset ( $ this -> data [ self :: JOB_TITLE ] ) ) { return false ; } return $ this -> data [ self :: JOB_TITLE ] ; } 
public function getIso ( ) { if ( ! isset ( $ this -> data [ self :: ISO ] ) ) { return false ; } return $ this -> data [ self :: ISO ] ; } 
public function getExposure ( ) { if ( ! isset ( $ this -> data [ self :: EXPOSURE ] ) ) { return false ; } return $ this -> data [ self :: EXPOSURE ] ; } 
public function getExposureMilliseconds ( ) { if ( ! isset ( $ this -> data [ self :: EXPOSURE ] ) ) { return false ; } if ( is_numeric ( $ this -> data [ self :: EXPOSURE ] ) ) { return $ this -> data [ self :: EXPOSURE ] + 0 ; } $ exposureParts = explode ( '/' , $ this -> data [ self :: EXPOSURE ] ) ; return ( int ) reset ( $ exposureParts ) / ( int ) end ( $ exposureParts ) ; } 
public function getFocusDistance ( ) { if ( ! isset ( $ this -> data [ self :: FOCAL_DISTANCE ] ) ) { return false ; } return $ this -> data [ self :: FOCAL_DISTANCE ] ; } 
public function getWidth ( ) { if ( ! isset ( $ this -> data [ self :: WIDTH ] ) ) { return false ; } return $ this -> data [ self :: WIDTH ] ; } 
public function getHeight ( ) { if ( ! isset ( $ this -> data [ self :: HEIGHT ] ) ) { return false ; } return $ this -> data [ self :: HEIGHT ] ; } 
public function getTitle ( ) { if ( ! isset ( $ this -> data [ self :: TITLE ] ) ) { return false ; } return $ this -> data [ self :: TITLE ] ; } 
public function getCaption ( ) { if ( ! isset ( $ this -> data [ self :: CAPTION ] ) ) { return false ; } return $ this -> data [ self :: CAPTION ] ; } 
public function getCopyright ( ) { if ( ! isset ( $ this -> data [ self :: COPYRIGHT ] ) ) { return false ; } return $ this -> data [ self :: COPYRIGHT ] ; } 
public function getKeywords ( ) { if ( ! isset ( $ this -> data [ self :: KEYWORDS ] ) ) { return false ; } return $ this -> data [ self :: KEYWORDS ] ; } 
public function getCamera ( ) { if ( ! isset ( $ this -> data [ self :: CAMERA ] ) ) { return false ; } return $ this -> data [ self :: CAMERA ] ; } 
public function getHorizontalResolution ( ) { if ( ! isset ( $ this -> data [ self :: HORIZONTAL_RESOLUTION ] ) ) { return false ; } return $ this -> data [ self :: HORIZONTAL_RESOLUTION ] ; } 
public function getVerticalResolution ( ) { if ( ! isset ( $ this -> data [ self :: VERTICAL_RESOLUTION ] ) ) { return false ; } return $ this -> data [ self :: VERTICAL_RESOLUTION ] ; } 
public function getSoftware ( ) { if ( ! isset ( $ this -> data [ self :: SOFTWARE ] ) ) { return false ; } return $ this -> data [ self :: SOFTWARE ] ; } 
public function getFocalLength ( ) { if ( ! isset ( $ this -> data [ self :: FOCAL_LENGTH ] ) ) { return false ; } return $ this -> data [ self :: FOCAL_LENGTH ] ; } 
public function getCreationDate ( ) { if ( ! isset ( $ this -> data [ self :: CREATION_DATE ] ) ) { return false ; } return $ this -> data [ self :: CREATION_DATE ] ; } 
public function getColorSpace ( ) { if ( ! isset ( $ this -> data [ self :: COLORSPACE ] ) ) { return false ; } return $ this -> data [ self :: COLORSPACE ] ; } 
public function getMimeType ( ) { if ( ! isset ( $ this -> data [ self :: MIMETYPE ] ) ) { return false ; } return $ this -> data [ self :: MIMETYPE ] ; } 
public function getFileSize ( ) { if ( ! isset ( $ this -> data [ self :: FILESIZE ] ) ) { return false ; } return $ this -> data [ self :: FILESIZE ] ; } 
public function getOrientation ( ) { if ( ! isset ( $ this -> data [ self :: ORIENTATION ] ) ) { return false ; } return $ this -> data [ self :: ORIENTATION ] ; } 
public function getGPS ( ) { if ( ! isset ( $ this -> data [ self :: GPS ] ) ) { return false ; } return $ this -> data [ self :: GPS ] ; } 
public function mapRawData ( array $ data ) { $ mappedData = array ( ) ; $ gpsData = array ( ) ; foreach ( $ data as $ field => $ value ) { if ( $ this -> isSection ( $ field ) && is_array ( $ value ) ) { $ subData = $ this -> mapRawData ( $ value ) ; $ mappedData = array_merge ( $ mappedData , $ subData ) ; continue ; } if ( ! $ this -> isFieldKnown ( $ field ) ) { 
protected function isFieldKnown ( & $ field ) { $ lcfField = lcfirst ( $ field ) ; if ( array_key_exists ( $ lcfField , $ this -> map ) ) { $ field = $ lcfField ; return true ; } $ ucfField = ucfirst ( $ field ) ; if ( array_key_exists ( $ ucfField , $ this -> map ) ) { $ field = $ ucfField ; return true ; } return false ; } 
protected function extractGPSCoordinate ( $ components ) { if ( ! is_array ( $ components ) ) { $ components = array ( $ components ) ; } $ components = array_map ( array ( $ this , 'normalizeComponent' ) , $ components ) ; if ( count ( $ components ) > 2 ) { return floatval ( $ components [ 0 ] ) + ( floatval ( $ components [ 1 ] ) / 60 ) + ( floatval ( $ components [ 2 ] ) / 3600 ) ; } return reset ( $ components ) ; } 
protected function normalizeComponent ( $ component ) { $ parts = explode ( '/' , $ component ) ; if ( count ( $ parts ) > 1 ) { if ( $ parts [ 1 ] ) { return intval ( $ parts [ 0 ] ) / intval ( $ parts [ 1 ] ) ; } return 0 ; } return floatval ( reset ( $ parts ) ) ; } 
public function setToolPath ( $ path ) { if ( ! file_exists ( $ path ) ) { throw new InvalidArgumentException ( sprintf ( 'Given path (%1$s) to the exiftool binary is invalid' , $ path ) ) ; } $ this -> toolPath = $ path ; return $ this ; } 
public function getToolPath ( ) { if ( empty ( $ this -> toolPath ) ) { $ path = exec ( 'which ' . self :: TOOL_NAME ) ; $ this -> setToolPath ( $ path ) ; } return $ this -> toolPath ; } 

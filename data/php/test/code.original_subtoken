public function run ( ) { $ menu = Menu : : where ( 'name ' , 'admin ' ) - > first Or Fail ( ) ; $ menu Item = Menu Item : : first Or New ( [ 'menu _id ' = > $ menu - > id , 'title ' = > _ _ ( 'voyager : :seeders .menu _items .dashboard ' ) , 'url ' = > ' ' , 'route ' = > 'voyager .dashboard ' , ] ) ; if ( ! $ menu Item - > exists ) { $ menu Item - > fill ( [ 'target ' = > ' _self ' , 'icon _class ' = > 'voyager -boat ' , 'color ' = > null , 'parent _id ' = > null , 'order ' = > 1 , ] ) - > save ( ) ; } $ menu Item = Menu Item : : first Or New ( [ 'menu _id ' = > $ menu - > id , 'title ' = > _ _ ( 'voyager : :seeders .menu _items .media ' ) , 'url ' = > ' ' , 'route ' = > 'voyager .media .index ' , ] ) ; if ( ! $ menu Item - > exists ) { $ menu Item - > fill ( [ 'target ' = > ' _self ' , 'icon _class ' = > 'voyager -images ' , 'color ' = > null , 'parent _id ' = > null , 'order ' = > 5 , ] ) - > save ( ) ; } $ menu Item = Menu Item : : first Or New ( [ 'menu _id ' = > $ menu - > id , 'title ' = > _ _ ( 'voyager : :seeders .menu _items .users ' ) , 'url ' = > ' ' , 'route ' = > 'voyager .users .index ' , ] ) ; if ( ! $ menu Item - > exists ) { $ menu Item - > fill ( [ 'target ' = > ' _self ' , 'icon _class ' = > 'voyager -person ' , 'color ' = > null , 'parent _id ' = > null , 'order ' = > 3 , ] ) - > save ( ) ; } $ menu Item = Menu Item : : first Or New ( [ 'menu _id ' = > $ menu - > id , 'title ' = > _ _ ( 'voyager : :seeders .menu _items .roles ' ) , 'url ' = > ' ' , 'route ' = > 'voyager .roles .index ' , ] ) ; if ( ! $ menu Item - > exists ) { $ menu Item - > fill ( [ 'target ' = > ' _self ' , 'icon _class ' = > 'voyager -lock ' , 'color ' = > null , 'parent _id ' = > null , 'order ' = > 2 , ] ) - > save ( ) ; } $ tools Menu Item = Menu Item : : first Or New ( [ 'menu _id ' = > $ menu - > id , 'title ' = > _ _ ( 'voyager : :seeders .menu _items .tools ' ) , 'url ' = > ' ' , ] ) ; if ( ! $ tools Menu Item - > exists ) { $ tools Menu Item - > fill ( [ 'target ' = > ' _self ' , 'icon _class ' = > 'voyager -tools ' , 'color ' = > null , 'parent _id ' = > null , 'order ' = > 9 , ] ) - > save ( ) ; } $ menu Item = Menu Item : : first Or New ( [ 'menu _id ' = > $ menu - > id , 'title ' = > _ _ ( 'voyager : :seeders .menu _items .menu _builder ' ) , 'url ' = > ' ' , 'route ' = > 'voyager .menus .index ' , ] ) ; if ( ! $ menu Item - > exists ) { $ menu Item - > fill ( [ 'target ' = > ' _self ' , 'icon _class ' = > 'voyager -list ' , 'color ' = > null , 'parent _id ' = > $ tools Menu Item - > id , 'order ' = > 1 0 , ] ) - > save ( ) ; } $ menu Item = Menu Item : : first Or New ( [ 'menu _id ' = > $ menu - > id , 'title ' = > _ _ ( 'voyager : :seeders .menu _items .database ' ) , 'url ' = > ' ' , 'route ' = > 'voyager .database .index ' , ] ) ; if ( ! $ menu Item - > exists ) { $ menu Item - > fill ( [ 'target ' = > ' _self ' , 'icon _class ' = > 'voyager -data ' , 'color ' = > null , 'parent _id ' = > $ tools Menu Item - > id , 'order ' = > 1 1 , ] ) - > save ( ) ; } $ menu Item = Menu Item : : first Or New ( [ 'menu _id ' = > $ menu - > id , 'title ' = > _ _ ( 'voyager : :seeders .menu _items .compass ' ) , 'url ' = > ' ' , 'route ' = > 'voyager .compass .index ' , ] ) ; if ( ! $ menu Item - > exists ) { $ menu Item - > fill ( [ 'target ' = > ' _self ' , 'icon _class ' = > 'voyager -compass ' , 'color ' = > null , 'parent _id ' = > $ tools Menu Item - > id , 'order ' = > 1 2 , ] ) - > save ( ) ; } $ menu Item = Menu Item : : first Or New ( [ 'menu _id ' = > $ menu - > id , 'title ' = > _ _ ( 'voyager : :seeders .menu _items .bread ' ) , 'url ' = > ' ' , 'route ' = > 'voyager .bread .index ' , ] ) ; if ( ! $ menu Item - > exists ) { $ menu Item - > fill ( [ 'target ' = > ' _self ' , 'icon _class ' = > 'voyager -bread ' , 'color ' = > null , 'parent _id ' = > $ tools Menu Item - > id , 'order ' = > 1 3 , ] ) - > save ( ) ; } $ menu Item = Menu Item : : first Or New ( [ 'menu _id ' = > $ menu - > id , 'title ' = > _ _ ( 'voyager : :seeders .menu _items .settings ' ) , 'url ' = > ' ' , 'route ' = > 'voyager .settings .index ' , ] ) ; if ( ! $ menu Item - > exists ) { $ menu Item - > fill ( [ 'target ' = > ' _self ' , 'icon _class ' = > 'voyager -settings ' , 'color ' = > null , 'parent _id ' = > null , 'order ' = > 1 4 , ] ) - > save ( ) ; } } 
protected function get Administrator Role ( ) { $ role = Voyager : : model ( 'Role ' ) - > first Or New ( [ 'name ' = > 'admin ' , ] ) ; if ( ! $ role - > exists ) { $ role - > fill ( [ 'display _name ' = > 'Administrator ' , ] ) - > save ( ) ; } return $ role ; } 
protected function get User ( $ create = false ) { $ email = $ this - > argument ( 'email ' ) ; $ model = config ( 'voyager .user .namespace ' ) ? : config ( 'auth .providers .users .model ' ) ; 
public function handle ( Bread Deleted $ bread ) { if ( config ( 'voyager .bread .add _menu _item ' ) ) { $ menu Item = Voyager : : model ( 'Menu Item ' ) - > where ( 'route ' , 'voyager . ' . $ bread - > data Type - > slug . ' .index ' ) ; if ( $ menu Item - > exists ( ) ) { $ menu Item - > delete ( ) ; } } } 
private function categories Translations ( ) { 
private function data Types Translations ( ) { 
private function pages Translations ( ) { $ page = Page : : where ( 'slug ' , 'hello -world ' ) - > first Or Fail ( ) ; if ( $ page - > exists ) { $ _arr = $ this - > arr ( [ 'pages ' , 'title ' ] , $ page - > id ) ; $ this - > trans ( 'pt ' , $ _arr , 'Ol á Mundo ' ) ; $ _arr = $ this - > arr ( [ 'pages ' , 'slug ' ] , $ page - > id ) ; $ this - > trans ( 'pt ' , $ _arr , 'ola -mundo ' ) ; $ _arr = $ this - > arr ( [ 'pages ' , 'body ' ] , $ page - > id ) ; $ this - > trans ( 'pt ' , $ _arr , ' <p >Ol á Mundo . Scallywag grog swab Cat o \ 'nine tails scuttle rigging hardtack cable nipper Yellow Jack . Handsomely spirits knave lad killick landlubber or just lubber deadlights chantey pinnace crack Jennys tea cup . Provost long clothes black spot Yellow Jack bilged on her anchor league lateen sail case shot lee tackle . < /p > ' . " \r \n " . ' <p >Ballast spirits fluke topmast me quarterdeck schooner landlubber or just lubber gabion belaying pin . Pinnace stern galleon starboard warp carouser to go on account dance the hempen jig jolly boat measured fer yer chains . Man -of -war fire in the hole nipperkin handsomely doubloon barkadeer Brethren of the Coast gibbet driver squiffy . < /p > ' ) ; } } 
private function menus Translations ( ) { $ _tpl = [ 'menu _items ' , 'title ' ] ; $ _item = $ this - > find Menu Item ( 'Dashboard ' ) ; if ( $ _item - > exists ) { $ this - > trans ( 'pt ' , $ this - > arr ( $ _tpl , $ _item - > id ) , 'Painel de Controle ' ) ; } $ _item = $ this - > find Menu Item ( 'Media ' ) ; if ( $ _item - > exists ) { $ this - > trans ( 'pt ' , $ this - > arr ( $ _tpl , $ _item - > id ) , 'Media ' ) ; } $ _item = $ this - > find Menu Item ( 'Posts ' ) ; if ( $ _item - > exists ) { $ this - > trans ( 'pt ' , $ this - > arr ( $ _tpl , $ _item - > id ) , 'Publica ç ões ' ) ; } $ _item = $ this - > find Menu Item ( 'Users ' ) ; if ( $ _item - > exists ) { $ this - > trans ( 'pt ' , $ this - > arr ( $ _tpl , $ _item - > id ) , 'Utilizadores ' ) ; } $ _item = $ this - > find Menu Item ( 'Categories ' ) ; if ( $ _item - > exists ) { $ this - > trans ( 'pt ' , $ this - > arr ( $ _tpl , $ _item - > id ) , 'Categorias ' ) ; } $ _item = $ this - > find Menu Item ( 'Pages ' ) ; if ( $ _item - > exists ) { $ this - > trans ( 'pt ' , $ this - > arr ( $ _tpl , $ _item - > id ) , 'P áginas ' ) ; } $ _item = $ this - > find Menu Item ( 'Roles ' ) ; if ( $ _item - > exists ) { $ this - > trans ( 'pt ' , $ this - > arr ( $ _tpl , $ _item - > id ) , 'Fun ç ões ' ) ; } $ _item = $ this - > find Menu Item ( 'Tools ' ) ; if ( $ _item - > exists ) { $ this - > trans ( 'pt ' , $ this - > arr ( $ _tpl , $ _item - > id ) , 'Ferramentas ' ) ; } $ _item = $ this - > find Menu Item ( 'Menu Builder ' ) ; if ( $ _item - > exists ) { $ this - > trans ( 'pt ' , $ this - > arr ( $ _tpl , $ _item - > id ) , 'Menus ' ) ; } $ _item = $ this - > find Menu Item ( 'Database ' ) ; if ( $ _item - > exists ) { $ this - > trans ( 'pt ' , $ this - > arr ( $ _tpl , $ _item - > id ) , 'Base de dados ' ) ; } $ _item = $ this - > find Menu Item ( 'Settings ' ) ; if ( $ _item - > exists ) { $ this - > trans ( 'pt ' , $ this - > arr ( $ _tpl , $ _item - > id ) , 'Configura ç ões ' ) ; } } 
public function highest Order Menu Item ( $ parent = null ) { $ order = 1 ; $ item = $ this - > where ( 'parent _id ' , ' = ' , $ parent ) - > order By ( 'order ' , 'DESC ' ) - > first ( ) ; if ( ! is _null ( $ item ) ) { $ order = intval ( $ item - > order ) + 1 ; } return $ order ; } 
public function run ( ) { $ data Type = $ this - > data Type ( 'slug ' , 'users ' ) ; if ( ! $ data Type - > exists ) { $ data Type - > fill ( [ 'name ' = > 'users ' , 'display _name _singular ' = > _ _ ( 'voyager : :seeders .data _types .user .singular ' ) , 'display _name _plural ' = > _ _ ( 'voyager : :seeders .data _types .user .plural ' ) , 'icon ' = > 'voyager -person ' , 'model _name ' = > 'TCG \ \Voyager \ \Models \ \User ' , 'policy _name ' = > 'TCG \ \Voyager \ \Policies \ \User Policy ' , 'controller ' = > 'TCG \ \Voyager \ \Http \ \Controllers \ \Voyager User Controller ' , 'generate _permissions ' = > 1 , 'description ' = > ' ' , ] ) - > save ( ) ; } $ data Type = $ this - > data Type ( 'slug ' , 'menus ' ) ; if ( ! $ data Type - > exists ) { $ data Type - > fill ( [ 'name ' = > 'menus ' , 'display _name _singular ' = > _ _ ( 'voyager : :seeders .data _types .menu .singular ' ) , 'display _name _plural ' = > _ _ ( 'voyager : :seeders .data _types .menu .plural ' ) , 'icon ' = > 'voyager -list ' , 'model _name ' = > 'TCG \ \Voyager \ \Models \ \Menu ' , 'controller ' = > ' ' , 'generate _permissions ' = > 1 , 'description ' = > ' ' , ] ) - > save ( ) ; } $ data Type = $ this - > data Type ( 'slug ' , 'roles ' ) ; if ( ! $ data Type - > exists ) { $ data Type - > fill ( [ 'name ' = > 'roles ' , 'display _name _singular ' = > _ _ ( 'voyager : :seeders .data _types .role .singular ' ) , 'display _name _plural ' = > _ _ ( 'voyager : :seeders .data _types .role .plural ' ) , 'icon ' = > 'voyager -lock ' , 'model _name ' = > 'TCG \ \Voyager \ \Models \ \Role ' , 'controller ' = > ' ' , 'generate _permissions ' = > 1 , 'description ' = > ' ' , ] ) - > save ( ) ; } } 
protected function check Permission ( User $ user , $ model , $ action ) { if ( self : : $ permissions = = null ) { self : : $ permissions = Voyager : : model ( 'Permission ' ) - > all ( ) ; } if ( self : : $ datatypes = = null ) { self : : $ datatypes = Voyager : : model ( 'Data Type ' ) : : all ( ) - > key By ( 'slug ' ) ; } $ regex = str _replace ( ' / ' , ' \ / ' , preg _quote ( route ( 'voyager .dashboard ' ) ) ) ; $ slug = preg _replace ( ' / ' . $ regex . ' / ' , ' ' , $ model - > link ( true ) ) ; $ slug = str _replace ( ' / ' , ' ' , $ slug ) ; if ( $ str = self : : $ datatypes - > get ( $ slug ) ) { $ slug = $ str - > name ; } if ( $ slug = = ' ' ) { $ slug = 'admin ' ; } elseif ( $ slug = = 'compass ' & & ! \ App : : environment ( 'local ' ) & & ! config ( 'voyager .compass _in _production ' , false ) ) { return false ; } if ( empty ( $ action ) ) { $ action = 'browse ' ; } 
public static function create Name ( array $ columns , $ type , $ table = null ) { $ table = isset ( $ table ) ? trim ( $ table ) . ' _ ' : ' ' ; $ type = trim ( $ type ) ; $ name = strtolower ( $ table . implode ( ' _ ' , $ columns ) . ' _ ' . $ type ) ; return str _replace ( [ ' - ' , ' . ' ] , ' _ ' , $ name ) ; } 
public function up ( ) { $ platform = \ DB : : get Doctrine Schema Manager ( ) - > get Database Platform ( ) ; $ platform - > register Doctrine Type Mapping ( 'enum ' , 'string ' ) ; Schema : : table ( 'posts ' , function ( Blueprint $ table ) { $ table - > text ( 'excerpt ' ) - > nullable ( ) - > change ( ) ; $ table - > text ( 'meta _description ' ) - > nullable ( ) - > change ( ) ; $ table - > text ( 'meta _keywords ' ) - > nullable ( ) - > change ( ) ; } ) ; } 
public function down ( ) { Schema : : table ( 'posts ' , function ( Blueprint $ table ) { $ table - > text ( 'excerpt ' ) - > change ( ) ; $ table - > text ( 'meta _description ' ) - > change ( ) ; $ table - > text ( 'meta _keywords ' ) - > change ( ) ; } ) ; } 
public function handle ( Setting Updated $ event ) { if ( config ( 'voyager .settings .cache ' , false ) = = = true ) { Cache : : tags ( 'settings ' ) - > forget ( $ event - > setting - > key ) ; } } 
public function handle ( Filesystem $ filesystem ) { $ this - > info ( 'Publishing the Voyager assets , database , and config files ' ) ; 
public function run ( ) { $ keys = [ 'browse _admin ' , 'browse _bread ' , 'browse _database ' , 'browse _media ' , 'browse _compass ' , ] ; foreach ( $ keys as $ key ) { Permission : : first Or Create ( [ 'key ' = > $ key , 'table _name ' = > null , ] ) ; } Permission : : generate For ( 'menus ' ) ; Permission : : generate For ( 'roles ' ) ; Permission : : generate For ( 'users ' ) ; Permission : : generate For ( 'settings ' ) ; } 
public function has Role ( $ name ) { $ roles = $ this - > roles _all ( ) - > pluck ( 'name ' ) - > to Array ( ) ; foreach ( ( is _array ( $ name ) ? $ name : [ $ name ] ) as $ role ) { if ( in _array ( $ role , $ roles ) ) { return true ; } } return false ; } 
public static function path To Log File ( $ file ) { $ logs Path = storage _path ( 'logs ' ) ; if ( app ( 'files ' ) - > exists ( $ file ) ) { 
public static function get Files ( $ basename = false ) { $ files = glob ( storage _path ( ) . ' /logs / * .log ' ) ; $ files = array _reverse ( $ files ) ; $ files = array _filter ( $ files , 'is _file ' ) ; if ( $ basename & & is _array ( $ files ) ) { foreach ( $ files as $ k = > $ file ) { $ files [ $ k ] = basename ( $ file ) ; } } return array _values ( $ files ) ; } 
public function run ( ) { $ this - > seeders Path = database _path ( 'seeds ' ) . ' / ' ; $ this - > seed ( 'Categories Table Seeder ' ) ; $ this - > seed ( 'Users Table Seeder ' ) ; $ this - > seed ( 'Posts Table Seeder ' ) ; $ this - > seed ( 'Pages Table Seeder ' ) ; $ this - > seed ( 'Translations Table Seeder ' ) ; $ this - > seed ( 'Permission Role Table Seeder ' ) ; } 
public function handle ( Bread Added $ bread ) { if ( config ( 'voyager .bread .add _menu _item ' ) & & file _exists ( base _path ( 'routes /web .php ' ) ) ) { require base _path ( 'routes /web .php ' ) ; $ menu = Voyager : : model ( 'Menu ' ) - > where ( 'name ' , config ( 'voyager .bread .default _menu ' ) ) - > first Or Fail ( ) ; $ menu Item = Voyager : : model ( 'Menu Item ' ) - > first Or New ( [ 'menu _id ' = > $ menu - > id , 'title ' = > $ bread - > data Type - > display _name _plural , 'url ' = > ' ' , 'route ' = > 'voyager . ' . $ bread - > data Type - > slug . ' .index ' , ] ) ; $ order = Voyager : : model ( 'Menu Item ' ) - > highest Order Menu Item ( ) ; if ( ! $ menu Item - > exists ) { $ menu Item - > fill ( [ 'target ' = > ' _self ' , 'icon _class ' = > $ bread - > data Type - > icon , 'color ' = > null , 'parent _id ' = > null , 'order ' = > $ order , ] ) - > save ( ) ; } } } 
public function up ( ) { Schema : : create ( 'menus ' , function ( Blueprint $ table ) { $ table - > increments ( 'id ' ) ; $ table - > string ( 'name ' ) - > unique ( ) ; $ table - > timestamps ( ) ; } ) ; Schema : : create ( 'menu _items ' , function ( Blueprint $ table ) { $ table - > increments ( 'id ' ) ; $ table - > unsigned Integer ( 'menu _id ' ) - > nullable ( ) ; $ table - > string ( 'title ' ) ; $ table - > string ( 'url ' ) ; $ table - > string ( 'target ' ) - > default ( ' _self ' ) ; $ table - > string ( 'icon _class ' ) - > nullable ( ) ; $ table - > string ( 'color ' ) - > nullable ( ) ; $ table - > integer ( 'parent _id ' ) - > nullable ( ) ; $ table - > integer ( 'order ' ) ; $ table - > timestamps ( ) ; } ) ; Schema : : table ( 'menu _items ' , function ( Blueprint $ table ) { $ table - > foreign ( 'menu _id ' ) - > references ( 'id ' ) - > on ( 'menus ' ) - > on Delete ( 'cascade ' ) ; } ) ; } 
public function up ( ) { Schema : : table ( 'users ' , function ( Blueprint $ table ) { $ table - > text ( 'settings ' ) - > nullable ( ) - > default ( null ) - > after ( 'remember _token ' ) ; } ) ; } 
public function up ( ) { Schema : : table ( 'permissions ' , function ( Blueprint $ table ) { $ table - > string ( 'table _name ' ) - > nullable ( ) - > default ( null ) - > change ( ) ; } ) ; } 
public function up ( ) { Schema : : table ( 'menu _items ' , function ( Blueprint $ table ) { $ table - > string ( 'route ' ) - > nullable ( ) - > default ( null ) ; $ table - > text ( 'parameters ' ) - > nullable ( ) - > default ( null ) ; } ) ; } 
public function update ( Request $ request , $ id ) { $ slug = $ this - > get Slug ( $ request ) ; $ data Type = Voyager : : model ( 'Data Type ' ) - > where ( 'slug ' , ' = ' , $ slug ) - > first ( ) ; 
public static function update ( $ table ) { if ( ! is _array ( $ table ) ) { $ table = json _decode ( $ table , true ) ; } if ( ! Schema Manager : : table Exists ( $ table [ 'old Name ' ] ) ) { throw Schema Exception : : table Does Not Exist ( $ table [ 'old Name ' ] ) ; } $ updater = new self ( $ table ) ; $ updater - > update Table ( ) ; } 
public function update Table ( ) { 
protected function get Renamed Columns Diff ( ) { $ renamed Columns = $ this - > get Renamed Columns ( ) ; if ( empty ( $ renamed Columns ) ) { return false ; } $ renamed Columns Diff = new Table Diff ( $ this - > table Arr [ 'old Name ' ] ) ; $ renamed Columns Diff - > from Table = $ this - > original Table ; foreach ( $ renamed Columns as $ old Name = > $ new Name ) { $ renamed Columns Diff - > renamed Columns [ $ old Name ] = $ this - > table - > get Column ( $ new Name ) ; } return $ renamed Columns Diff ; } 
protected function get Renamed Diff ( ) { $ renamed Columns = $ this - > get Renamed Columns ( ) ; $ renamed Indexes = $ this - > get Renamed Indexes ( ) ; if ( empty ( $ renamed Columns ) & & empty ( $ renamed Indexes ) ) { return false ; } $ renamed Diff = new Table Diff ( $ this - > table Arr [ 'old Name ' ] ) ; $ renamed Diff - > from Table = $ this - > original Table ; foreach ( $ renamed Columns as $ old Name = > $ new Name ) { $ renamed Diff - > renamed Columns [ $ old Name ] = $ this - > table - > get Column ( $ new Name ) ; } foreach ( $ renamed Indexes as $ old Name = > $ new Name ) { $ renamed Diff - > renamed Indexes [ $ old Name ] = $ this - > table - > get Index ( $ new Name ) ; } return $ renamed Diff ; } 
protected function get Renamed Columns ( ) { $ renamed Columns = [ ] ; foreach ( $ this - > table Arr [ 'columns ' ] as $ column ) { $ old Name = $ column [ 'old Name ' ] ; 
protected function get Renamed Indexes ( ) { $ renamed Indexes = [ ] ; foreach ( $ this - > table Arr [ 'indexes ' ] as $ index ) { $ old Name = $ index [ 'old Name ' ] ; 
public function thumbnail ( $ type , $ attribute = 'image ' ) { 
public function get Thumbnail ( $ image , $ type ) { 
public function run ( ) { 
protected function check Permission ( User $ user , $ model , $ action ) { if ( ! isset ( self : : $ datatypes [ get _class ( $ model ) ] ) ) { $ data Type = Voyager : : model ( 'Data Type ' ) ; self : : $ datatypes [ get _class ( $ model ) ] = $ data Type - > where ( 'model _name ' , get _class ( $ model ) ) - > first ( ) ; } $ data Type = self : : $ datatypes [ get _class ( $ model ) ] ; return $ user - > has Permission ( $ action . ' _ ' . $ data Type - > name ) ; } 
public function update ( Request $ request , $ id ) { if ( app ( 'Voyager Auth ' ) - > user ( ) - > get Key ( ) = = $ id ) { $ request - > merge ( [ 'role _id ' = > app ( 'Voyager Auth ' ) - > user ( ) - > role _id , 'user _belongsto _role _relationship ' = > app ( 'Voyager Auth ' ) - > user ( ) - > role _id , 'user _belongstomany _role _relationship ' = > app ( 'Voyager Auth ' ) - > user ( ) - > roles - > pluck ( 'id ' ) - > to Array ( ) , ] ) ; } return parent : : update ( $ request , $ id ) ; } 
public function edit Roles ( User $ user , $ model ) { 
public function dimmers ( ) { $ widget Classes = config ( 'voyager .dashboard .widgets ' ) ; $ dimmers = Widget : : group ( 'voyager : :dimmers ' ) ; foreach ( $ widget Classes as $ widget Class ) { $ widget = app ( $ widget Class ) ; if ( $ widget - > should Be Displayed ( ) ) { $ dimmers - > add Widget ( $ widget Class ) ; } } return $ dimmers ; } 
public static function get Platform ( $ platform Name ) { $ platform = _ _NAMESPACE _ _ . ' \ \ ' . ucfirst ( $ platform Name ) ; if ( ! class _exists ( $ platform ) ) { throw new \ Exception ( "Platform { $platform Name } doesn 't exist " ) ; } return $ platform ; } 
protected function prepare Menu Translations ( & $ data ) { $ trans = json _decode ( $ data [ 'title _i 1 8n ' ] , true ) ; 
public function save ( ) { $ attributes = $ this - > get Modified Attributes ( ) ; $ savings = [ ] ; foreach ( $ attributes as $ key = > $ attribute ) { if ( $ attribute [ 'exists ' ] ) { $ translation = $ this - > get Translation Model ( $ key ) ; } else { $ translation = Voyager Facade : : model ( 'Translation ' ) - > where ( 'table _name ' , $ this - > model - > get Table ( ) ) - > where ( 'column _name ' , $ key ) - > where ( 'foreign _key ' , $ this - > model - > get Key ( ) ) - > where ( 'locale ' , $ this - > locale ) - > first ( ) ; } if ( is _null ( $ translation ) ) { $ translation = Voyager Facade : : model ( 'Translation ' ) ; } $ translation - > fill ( [ 'table _name ' = > $ this - > model - > get Table ( ) , 'column _name ' = > $ key , 'foreign _key ' = > $ this - > model - > get Key ( ) , 'value ' = > $ attribute [ 'value ' ] , 'locale ' = > $ this - > locale , ] ) ; $ savings [ ] = $ translation - > save ( ) ; $ this - > attributes [ $ key ] [ 'locale ' ] = $ this - > locale ; $ this - > attributes [ $ key ] [ 'exists ' ] = true ; $ this - > attributes [ $ key ] [ 'modified ' ] = false ; } return in _array ( false , $ savings ) ; } 
public function read ( User $ user , $ model ) { 
public function run ( ) { <p >Ballast spirits fluke topmast me quarterdeck schooner landlubber or just lubber gabion belaying pin . Pinnace stern galleon starboard warp carouser to go on account dance the hempen jig jolly boat measured fer yer chains . Man -of -war fire in the hole nipperkin handsomely doubloon barkadeer Brethren of the Coast gibbet driver squiffy . < /p > ' , 'image ' = > 'pages /page 1 .jpg ' , 'meta _description ' = > 'Yar Meta Description ' , 'meta _keywords ' = > 'Keyword 1 , Keyword 2 ' , 'status ' = > 'ACTIVE ' , ] ) - > save ( ) ; } } 
public function register ( ) { $ this - > app - > register ( Widget Service Provider : : class ) ; $ this - > register Configs ( ) ; if ( $ this - > app - > running In Console ( ) ) { $ this - > register Publishable Resources ( ) ; } } 
public function up ( ) { Schema : : create ( 'user _roles ' , function ( Blueprint $ table ) { $ type = DB : : connection ( ) - > get Doctrine Column ( 'users ' , 'id ' ) - > get Type ( ) - > get Name ( ) ; if ( $ type = = 'bigint ' ) { $ table - > big Integer ( 'user _id ' ) - > unsigned ( ) - > index ( ) ; } else { $ table - > integer ( 'user _id ' ) - > unsigned ( ) - > index ( ) ; } $ table - > foreign ( 'user _id ' ) - > references ( 'id ' ) - > on ( 'users ' ) - > on Delete ( 'cascade ' ) ; $ table - > big Integer ( 'role _id ' ) - > unsigned ( ) - > index ( ) ; $ table - > foreign ( 'role _id ' ) - > references ( 'id ' ) - > on ( 'roles ' ) - > on Delete ( 'cascade ' ) ; $ table - > primary ( [ 'user _id ' , 'role _id ' ] ) ; } ) ; } 
public function create ( Request $ request , $ table ) { $ this - > authorize ( 'browse _bread ' ) ; $ data Type = Voyager : : model ( 'Data Type ' ) - > where Name ( $ table ) - > first ( ) ; $ data = $ this - > prepopulate Bread Info ( $ table ) ; $ data [ 'field Options ' ] = Schema Manager : : describe Table ( ( isset ( $ data Type ) & & strlen ( $ data Type - > model _name ) ! = 0 ) ? app ( $ data Type - > model _name ) - > get Table ( ) : $ table ) ; return Voyager : : view ( 'voyager : :tools .bread .edit -add ' , $ data ) ; } 
public function store ( Request $ request ) { $ this - > authorize ( 'browse _bread ' ) ; try { $ data Type = Voyager : : model ( 'Data Type ' ) ; $ res = $ data Type - > update Data Type ( $ request - > all ( ) , true ) ; $ data = $ res ? $ this - > alert Success ( _ _ ( 'voyager : :bread .success _created _bread ' ) ) : $ this - > alert Error ( _ _ ( 'voyager : :bread .error _creating _bread ' ) ) ; if ( $ res ) { event ( new Bread Added ( $ data Type , $ data ) ) ; } return redirect ( ) - > route ( 'voyager .bread .index ' ) - > with ( $ data ) ; } catch ( Exception $ e ) { return redirect ( ) - > route ( 'voyager .bread .index ' ) - > with ( $ this - > alert Exception ( $ e , 'Saving Failed ' ) ) ; } } 
public function edit ( $ table ) { $ this - > authorize ( 'browse _bread ' ) ; $ data Type = Voyager : : model ( 'Data Type ' ) - > where Name ( $ table ) - > first ( ) ; $ field Options = Schema Manager : : describe Table ( ( strlen ( $ data Type - > model _name ) ! = 0 ) ? app ( $ data Type - > model _name ) - > get Table ( ) : $ data Type - > name ) ; $ is Model Translatable = is _bread _translatable ( $ data Type ) ; $ tables = Schema Manager : : list Table Names ( ) ; $ data Type Relationships = Voyager : : model ( 'Data Row ' ) - > where ( 'data _type _id ' , ' = ' , $ data Type - > id ) - > where ( 'type ' , ' = ' , 'relationship ' ) - > get ( ) ; $ scopes = [ ] ; if ( $ data Type - > model _name ! = ' ' ) { $ scopes = $ this - > get Model Scopes ( $ data Type - > model _name ) ; } return Voyager : : view ( 'voyager : :tools .bread .edit -add ' , compact ( 'data Type ' , 'field Options ' , 'is Model Translatable ' , 'tables ' , 'data Type Relationships ' , 'scopes ' ) ) ; } 
public function update ( Request $ request , $ id ) { $ this - > authorize ( 'browse _bread ' ) ; try { $ data Type = Voyager : : model ( 'Data Type ' ) - > find ( $ id ) ; 
public function destroy ( $ id ) { $ this - > authorize ( 'browse _bread ' ) ; $ data Type = Voyager : : model ( 'Data Type ' ) - > find ( $ id ) ; 
public function add Relationship ( Request $ request ) { $ relationship Field = $ this - > get Relationship Field ( $ request ) ; if ( ! class _exists ( $ request - > relationship _model ) ) { return back ( ) - > with ( [ 'message ' = > 'Model Class ' . $ request - > relationship _model . ' does not exist . Please create Model before creating relationship . ' , 'alert -type ' = > 'error ' , ] ) ; } try { DB : : begin Transaction ( ) ; $ relationship _column = $ request - > relationship _column _belongs _to ; if ( $ request - > relationship _type = = 'has One ' | | $ request - > relationship _type = = 'has Many ' ) { $ relationship _column = $ request - > relationship _column ; } 
private function get Relationship Field ( $ request ) { 
public function handle ( ) { return empty ( $ this - > request - > input ( $ this - > row - > field ) ) ? null : bcrypt ( $ this - > request - > input ( $ this - > row - > field ) ) ; } 
public function store ( Request $ request ) { $ this - > authorize ( 'browse _database ' ) ; try { $ conn = 'database .connections . ' . config ( 'database .default ' ) ; Type : : register Custom Platform Types ( ) ; $ table = $ request - > table ; if ( ! is _array ( $ request - > table ) ) { $ table = json _decode ( $ request - > table , true ) ; } $ table [ 'options ' ] [ 'collate ' ] = config ( $ conn . ' .collation ' , 'utf 8mb 4 _unicode _ci ' ) ; $ table [ 'options ' ] [ 'charset ' ] = config ( $ conn . ' .charset ' , 'utf 8mb 4 ' ) ; $ table = Table : : make ( $ table ) ; Schema Manager : : create Table ( $ table ) ; if ( isset ( $ request - > create _model ) & & $ request - > create _model = = 'on ' ) { $ model Namespace = config ( 'voyager .models .namespace ' , app ( ) - > get Namespace ( ) ) ; $ params = [ 'name ' = > $ model Namespace . Str : : studly ( Str : : singular ( $ table - > name ) ) , ] ; 
public function edit ( $ table ) { $ this - > authorize ( 'browse _database ' ) ; if ( ! Schema Manager : : table Exists ( $ table ) ) { return redirect ( ) - > route ( 'voyager .database .index ' ) - > with ( $ this - > alert Error ( _ _ ( 'voyager : :database .edit _table _not _exist ' ) ) ) ; } $ db = $ this - > prepare Db Manager ( 'update ' , $ table ) ; return Voyager : : view ( 'voyager : :tools .database .edit -add ' , compact ( 'db ' ) ) ; } 
public function update ( Request $ request ) { $ this - > authorize ( 'browse _database ' ) ; $ table = json _decode ( $ request - > table , true ) ; try { Database Updater : : update ( $ table ) ; 
public function show ( $ table ) { $ this - > authorize ( 'browse _database ' ) ; $ additional _attributes = [ ] ; $ model _name = Voyager : : model ( 'Data Type ' ) - > where ( 'name ' , $ table ) - > pluck ( 'model _name ' ) - > first ( ) ; if ( isset ( $ model _name ) ) { $ model = app ( $ model _name ) ; if ( isset ( $ model - > additional _attributes ) ) { foreach ( $ model - > additional _attributes as $ attribute ) { $ additional _attributes [ $ attribute ] = [ ] ; } } } return response ( ) - > json ( collect ( Schema Manager : : describe Table ( $ table ) ) - > merge ( $ additional _attributes ) ) ; } 
public function destroy ( $ table ) { $ this - > authorize ( 'browse _database ' ) ; try { Schema Manager : : drop Table ( $ table ) ; event ( new Table Deleted ( $ table ) ) ; return redirect ( ) - > route ( 'voyager .database .index ' ) - > with ( $ this - > alert Success ( _ _ ( 'voyager : :database .success _delete _table ' , [ 'table ' = > $ table ] ) ) ) ; } catch ( Exception $ e ) { return back ( ) - > with ( $ this - > alert Exception ( $ e ) ) ; } } 
public function run ( ) { $ count = Voyager : : model ( 'User ' ) - > count ( ) ; $ string = trans _choice ( 'voyager : :dimmer .user ' , $ count ) ; return view ( 'voyager : :dimmer ' , array _merge ( $ this - > config , [ 'icon ' = > 'voyager -group ' , 'title ' = > " { $count } { $string } " , 'text ' = > _ _ ( 'voyager : :dimmer .user _text ' , [ 'count ' = > $ count , 'string ' = > Str : : lower ( $ string ) ] ) , 'button ' = > [ 'text ' = > _ _ ( 'voyager : :dimmer .user _link _text ' ) , 'link ' = > route ( 'voyager .users .index ' ) , ] , 'image ' = > voyager _asset ( 'images /widget -backgrounds / 0 1 .jpg ' ) , ] ) ) ; } 
public function up ( ) { Schema : : table ( 'users ' , function ( Blueprint $ table ) { $ table - > big Integer ( 'role _id ' ) - > unsigned ( ) - > change ( ) ; $ table - > foreign ( 'role _id ' ) - > references ( 'id ' ) - > on ( 'roles ' ) ; } ) ; } 
public function down ( ) { Schema : : table ( 'users ' , function ( Blueprint $ table ) { $ table - > drop Foreign ( [ 'role _id ' ] ) ; } ) ; Schema : : table ( 'users ' , function ( Blueprint $ table ) { $ table - > big Integer ( 'role _id ' ) - > change ( ) ; } ) ; } 
public function sort By Url ( $ order By , $ sort Order ) { $ params = [ ] ; $ is Desc = $ sort Order ! = 'asc ' ; if ( $ this - > is Current Sort Field ( $ order By ) & & $ is Desc ) { $ params [ 'sort _order ' ] = 'asc ' ; } else { $ params [ 'sort _order ' ] = 'desc ' ; } $ params [ 'order _by ' ] = $ this - > field ; return url ( ) - > current ( ) . ' ? ' . http _build _query ( array _merge ( \ Request : : all ( ) , $ params ) ) ; } 
protected function generate File Name ( $ file , $ path ) { if ( isset ( $ this - > options - > preserve File Upload Name ) & & $ this - > options - > preserve File Upload Name ) { $ filename = basename ( $ file - > get Client Original Name ( ) , ' . ' . $ file - > get Client Original Extension ( ) ) ; $ filename _counter = 1 ; 
public function run ( ) { $ user Data Type = Data Type : : where ( 'slug ' , 'users ' ) - > first Or Fail ( ) ; $ menu Data Type = Data Type : : where ( 'slug ' , 'menus ' ) - > first Or Fail ( ) ; $ role Data Type = Data Type : : where ( 'slug ' , 'roles ' ) - > first Or Fail ( ) ; $ data Row = $ this - > data Row ( $ user Data Type , 'id ' ) ; if ( ! $ data Row - > exists ) { $ data Row - > fill ( [ 'type ' = > 'number ' , 'display _name ' = > _ _ ( 'voyager : :seeders .data _rows .id ' ) , 'required ' = > 1 , 'browse ' = > 0 , 'read ' = > 0 , 'edit ' = > 0 , 'add ' = > 0 , 'delete ' = > 0 , 'order ' = > 1 , ] ) - > save ( ) ; } $ data Row = $ this - > data Row ( $ user Data Type , 'name ' ) ; if ( ! $ data Row - > exists ) { $ data Row - > fill ( [ 'type ' = > 'text ' , 'display _name ' = > _ _ ( 'voyager : :seeders .data _rows .name ' ) , 'required ' = > 1 , 'browse ' = > 1 , 'read ' = > 1 , 'edit ' = > 1 , 'add ' = > 1 , 'delete ' = > 1 , 'order ' = > 2 , ] ) - > save ( ) ; } $ data Row = $ this - > data Row ( $ user Data Type , 'email ' ) ; if ( ! $ data Row - > exists ) { $ data Row - > fill ( [ 'type ' = > 'text ' , 'display _name ' = > _ _ ( 'voyager : :seeders .data _rows .email ' ) , 'required ' = > 1 , 'browse ' = > 1 , 'read ' = > 1 , 'edit ' = > 1 , 'add ' = > 1 , 'delete ' = > 1 , 'order ' = > 3 , ] ) - > save ( ) ; } $ data Row = $ this - > data Row ( $ user Data Type , 'password ' ) ; if ( ! $ data Row - > exists ) { $ data Row - > fill ( [ 'type ' = > 'password ' , 'display _name ' = > _ _ ( 'voyager : :seeders .data _rows .password ' ) , 'required ' = > 1 , 'browse ' = > 0 , 'read ' = > 0 , 'edit ' = > 1 , 'add ' = > 1 , 'delete ' = > 0 , 'order ' = > 4 , ] ) - > save ( ) ; } $ data Row = $ this - > data Row ( $ user Data Type , 'remember _token ' ) ; if ( ! $ data Row - > exists ) { $ data Row - > fill ( [ 'type ' = > 'text ' , 'display _name ' = > _ _ ( 'voyager : :seeders .data _rows .remember _token ' ) , 'required ' = > 0 , 'browse ' = > 0 , 'read ' = > 0 , 'edit ' = > 0 , 'add ' = > 0 , 'delete ' = > 0 , 'order ' = > 5 , ] ) - > save ( ) ; } $ data Row = $ this - > data Row ( $ user Data Type , 'created _at ' ) ; if ( ! $ data Row - > exists ) { $ data Row - > fill ( [ 'type ' = > 'timestamp ' , 'display _name ' = > _ _ ( 'voyager : :seeders .data _rows .created _at ' ) , 'required ' = > 0 , 'browse ' = > 1 , 'read ' = > 1 , 'edit ' = > 0 , 'add ' = > 0 , 'delete ' = > 0 , 'order ' = > 6 , ] ) - > save ( ) ; } $ data Row = $ this - > data Row ( $ user Data Type , 'updated _at ' ) ; if ( ! $ data Row - > exists ) { $ data Row - > fill ( [ 'type ' = > 'timestamp ' , 'display _name ' = > _ _ ( 'voyager : :seeders .data _rows .updated _at ' ) , 'required ' = > 0 , 'browse ' = > 0 , 'read ' = > 0 , 'edit ' = > 0 , 'add ' = > 0 , 'delete ' = > 0 , 'order ' = > 7 , ] ) - > save ( ) ; } $ data Row = $ this - > data Row ( $ user Data Type , 'avatar ' ) ; if ( ! $ data Row - > exists ) { $ data Row - > fill ( [ 'type ' = > 'image ' , 'display _name ' = > _ _ ( 'voyager : :seeders .data _rows .avatar ' ) , 'required ' = > 0 , 'browse ' = > 1 , 'read ' = > 1 , 'edit ' = > 1 , 'add ' = > 1 , 'delete ' = > 1 , 'order ' = > 8 , ] ) - > save ( ) ; } $ data Row = $ this - > data Row ( $ user Data Type , 'user _belongsto _role _relationship ' ) ; if ( ! $ data Row - > exists ) { $ data Row - > fill ( [ 'type ' = > 'relationship ' , 'display _name ' = > _ _ ( 'voyager : :seeders .data _rows .role ' ) , 'required ' = > 0 , 'browse ' = > 1 , 'read ' = > 1 , 'edit ' = > 1 , 'add ' = > 1 , 'delete ' = > 0 , 'details ' = > [ 'model ' = > 'TCG \ \Voyager \ \Models \ \Role ' , 'table ' = > 'roles ' , 'type ' = > 'belongs To ' , 'column ' = > 'role _id ' , 'key ' = > 'id ' , 'label ' = > 'display _name ' , 'pivot _table ' = > 'roles ' , 'pivot ' = > 0 , ] , 'order ' = > 1 0 , ] ) - > save ( ) ; } $ data Row = $ this - > data Row ( $ user Data Type , 'user _belongstomany _role _relationship ' ) ; if ( ! $ data Row - > exists ) { $ data Row - > fill ( [ 'type ' = > 'relationship ' , 'display _name ' = > 'Roles ' , 'required ' = > 0 , 'browse ' = > 1 , 'read ' = > 1 , 'edit ' = > 1 , 'add ' = > 1 , 'delete ' = > 0 , 'details ' = > [ 'model ' = > 'TCG \ \Voyager \ \Models \ \Role ' , 'table ' = > 'roles ' , 'type ' = > 'belongs To Many ' , 'column ' = > 'id ' , 'key ' = > 'id ' , 'label ' = > 'display _name ' , 'pivot _table ' = > 'user _roles ' , 'pivot ' = > ' 1 ' , 'taggable ' = > ' 0 ' , ] , 'order ' = > 1 1 , ] ) - > save ( ) ; } $ data Row = $ this - > data Row ( $ user Data Type , 'settings ' ) ; if ( ! $ data Row - > exists ) { $ data Row - > fill ( [ 'type ' = > 'hidden ' , 'display _name ' = > 'Settings ' , 'required ' = > 0 , 'browse ' = > 0 , 'read ' = > 0 , 'edit ' = > 0 , 'add ' = > 0 , 'delete ' = > 0 , 'order ' = > 1 2 , ] ) - > save ( ) ; } $ data Row = $ this - > data Row ( $ menu Data Type , 'id ' ) ; if ( ! $ data Row - > exists ) { $ data Row - > fill ( [ 'type ' = > 'number ' , 'display _name ' = > _ _ ( 'voyager : :seeders .data _rows .id ' ) , 'required ' = > 1 , 'browse ' = > 0 , 'read ' = > 0 , 'edit ' = > 0 , 'add ' = > 0 , 'delete ' = > 0 , 'order ' = > 1 , ] ) - > save ( ) ; } $ data Row = $ this - > data Row ( $ menu Data Type , 'name ' ) ; if ( ! $ data Row - > exists ) { $ data Row - > fill ( [ 'type ' = > 'text ' , 'display _name ' = > _ _ ( 'voyager : :seeders .data _rows .name ' ) , 'required ' = > 1 , 'browse ' = > 1 , 'read ' = > 1 , 'edit ' = > 1 , 'add ' = > 1 , 'delete ' = > 1 , 'order ' = > 2 , ] ) - > save ( ) ; } $ data Row = $ this - > data Row ( $ menu Data Type , 'created _at ' ) ; if ( ! $ data Row - > exists ) { $ data Row - > fill ( [ 'type ' = > 'timestamp ' , 'display _name ' = > _ _ ( 'voyager : :seeders .data _rows .created _at ' ) , 'required ' = > 0 , 'browse ' = > 0 , 'read ' = > 0 , 'edit ' = > 0 , 'add ' = > 0 , 'delete ' = > 0 , 'order ' = > 3 , ] ) - > save ( ) ; } $ data Row = $ this - > data Row ( $ menu Data Type , 'updated _at ' ) ; if ( ! $ data Row - > exists ) { $ data Row - > fill ( [ 'type ' = > 'timestamp ' , 'display _name ' = > _ _ ( 'voyager : :seeders .data _rows .updated _at ' ) , 'required ' = > 0 , 'browse ' = > 0 , 'read ' = > 0 , 'edit ' = > 0 , 'add ' = > 0 , 'delete ' = > 0 , 'order ' = > 4 , ] ) - > save ( ) ; } $ data Row = $ this - > data Row ( $ role Data Type , 'id ' ) ; if ( ! $ data Row - > exists ) { $ data Row - > fill ( [ 'type ' = > 'number ' , 'display _name ' = > _ _ ( 'voyager : :seeders .data _rows .id ' ) , 'required ' = > 1 , 'browse ' = > 0 , 'read ' = > 0 , 'edit ' = > 0 , 'add ' = > 0 , 'delete ' = > 0 , 'order ' = > 1 , ] ) - > save ( ) ; } $ data Row = $ this - > data Row ( $ role Data Type , 'name ' ) ; if ( ! $ data Row - > exists ) { $ data Row - > fill ( [ 'type ' = > 'text ' , 'display _name ' = > _ _ ( 'voyager : :seeders .data _rows .name ' ) , 'required ' = > 1 , 'browse ' = > 1 , 'read ' = > 1 , 'edit ' = > 1 , 'add ' = > 1 , 'delete ' = > 1 , 'order ' = > 2 , ] ) - > save ( ) ; } $ data Row = $ this - > data Row ( $ role Data Type , 'created _at ' ) ; if ( ! $ data Row - > exists ) { $ data Row - > fill ( [ 'type ' = > 'timestamp ' , 'display _name ' = > _ _ ( 'voyager : :seeders .data _rows .created _at ' ) , 'required ' = > 0 , 'browse ' = > 0 , 'read ' = > 0 , 'edit ' = > 0 , 'add ' = > 0 , 'delete ' = > 0 , 'order ' = > 3 , ] ) - > save ( ) ; } $ data Row = $ this - > data Row ( $ role Data Type , 'updated _at ' ) ; if ( ! $ data Row - > exists ) { $ data Row - > fill ( [ 'type ' = > 'timestamp ' , 'display _name ' = > _ _ ( 'voyager : :seeders .data _rows .updated _at ' ) , 'required ' = > 0 , 'browse ' = > 0 , 'read ' = > 0 , 'edit ' = > 0 , 'add ' = > 0 , 'delete ' = > 0 , 'order ' = > 4 , ] ) - > save ( ) ; } $ data Row = $ this - > data Row ( $ role Data Type , 'display _name ' ) ; if ( ! $ data Row - > exists ) { $ data Row - > fill ( [ 'type ' = > 'text ' , 'display _name ' = > _ _ ( 'voyager : :seeders .data _rows .display _name ' ) , 'required ' = > 1 , 'browse ' = > 1 , 'read ' = > 1 , 'edit ' = > 1 , 'add ' = > 1 , 'delete ' = > 1 , 'order ' = > 5 , ] ) - > save ( ) ; } $ data Row = $ this - > data Row ( $ user Data Type , 'role _id ' ) ; if ( ! $ data Row - > exists ) { $ data Row - > fill ( [ 'type ' = > 'text ' , 'display _name ' = > _ _ ( 'voyager : :seeders .data _rows .role ' ) , 'required ' = > 1 , 'browse ' = > 1 , 'read ' = > 1 , 'edit ' = > 1 , 'add ' = > 1 , 'delete ' = > 1 , 'order ' = > 9 , ] ) - > save ( ) ; } } 
public static function display ( $ menu Name , $ type = null , array $ options = [ ] ) { 
public function handle ( $ request , Closure $ next ) { if ( ! app ( 'Voyager Auth ' ) - > guest ( ) ) { $ user = app ( 'Voyager Auth ' ) - > user ( ) ; app ( ) - > set Locale ( $ user - > locale ? ? app ( ) - > get Locale ( ) ) ; return $ user - > has Permission ( 'browse _admin ' ) ? $ next ( $ request ) : redirect ( ' / ' ) ; } $ url Login = route ( 'voyager .login ' ) ; return redirect ( ) - > guest ( $ url Login ) ; } 
public function run ( ) { $ role = Role : : where ( 'name ' , 'admin ' ) - > first Or Fail ( ) ; $ permissions = Permission : : all ( ) ; $ role - > permissions ( ) - > sync ( $ permissions - > pluck ( 'id ' ) - > all ( ) ) ; } 
public function translatable ( ) { if ( isset ( $ this - > translatable ) & & $ this - > translatable = = false ) { return false ; } return ! empty ( $ this - > get Translatable Attributes ( ) ) ; } 
public function translations ( ) { return $ this - > has Many ( Voyager : : model ( 'Translation ' ) , 'foreign _key ' , $ this - > get Key Name ( ) ) - > where ( 'table _name ' , $ this - > get Table ( ) ) - > where In ( 'locale ' , config ( 'voyager .multilingual .locales ' , [ ] ) ) ; } 
public function scope With Translation ( Builder $ query , $ locale = null , $ fallback = true ) { if ( is _null ( $ locale ) ) { $ locale = app ( ) - > get Locale ( ) ; } if ( $ fallback = = = true ) { $ fallback = config ( 'app .fallback _locale ' , 'en ' ) ; } $ query - > with ( [ 'translations ' = > function ( Relation $ query ) use ( $ locale , $ fallback ) { $ query - > where ( function ( $ q ) use ( $ locale , $ fallback ) { $ q - > where ( 'locale ' , $ locale ) ; if ( $ fallback ! = = false ) { $ q - > or Where ( 'locale ' , $ fallback ) ; } } ) ; } ] ) ; } 
public function get Translated Attribute ( $ attribute , $ language = null , $ fallback = true ) { list ( $ value ) = $ this - > get Translated Attribute Meta ( $ attribute , $ language , $ fallback ) ; return $ value ; } 
public static function scope Where Translation ( $ query , $ field , $ operator , $ value = null , $ locales = null , $ default = true ) { if ( $ locales & & ! is _array ( $ locales ) ) { $ locales = [ $ locales ] ; } if ( ! isset ( $ value ) ) { $ value = $ operator ; $ operator = ' = ' ; } $ self = new static ( ) ; $ table = $ self - > get Table ( ) ; return $ query - > where In ( $ self - > get Key Name ( ) , Translation : : where ( 'table _name ' , $ table ) - > where ( 'column _name ' , $ field ) - > where ( 'value ' , $ operator , $ value ) - > when ( ! is _null ( $ locales ) , function ( $ query ) use ( $ locales ) { return $ query - > where In ( 'locale ' , $ locales ) ; } ) - > pluck ( 'foreign _key ' ) ) - > when ( $ default , function ( $ query ) use ( $ field , $ operator , $ value ) { return $ query - > or Where ( $ field , $ operator , $ value ) ; } ) ; } 
public function save Translations ( $ translations ) { foreach ( $ translations as $ field = > $ locales ) { foreach ( $ locales as $ locale = > $ translation ) { $ translation - > save ( ) ; } } } 
public static function list Table Details ( $ table Name ) { $ columns = static : : manager ( ) - > list Table Columns ( $ table Name ) ; $ foreign Keys = [ ] ; if ( static : : manager ( ) - > get Database Platform ( ) - > supports Foreign Key Constraints ( ) ) { $ foreign Keys = static : : manager ( ) - > list Table Foreign Keys ( $ table Name ) ; } $ indexes = static : : manager ( ) - > list Table Indexes ( $ table Name ) ; return new Table ( $ table Name , $ columns , $ indexes , $ foreign Keys , false , [ ] ) ; } 
public static function describe Table ( $ table Name ) { Type : : register Custom Platform Types ( ) ; $ table = static : : list Table Details ( $ table Name ) ; return collect ( $ table - > columns ) - > map ( function ( $ column ) use ( $ table ) { $ column Arr = Column : : to Array ( $ column ) ; $ column Arr [ 'field ' ] = $ column Arr [ 'name ' ] ; $ column Arr [ 'type ' ] = $ column Arr [ 'type ' ] [ 'name ' ] ; 
public function down ( ) { Schema : : table ( 'settings ' , function ( Blueprint $ table ) { $ table - > text ( 'value ' ) - > nullable ( false ) - > change ( ) ; } ) ; } 
public function run ( ) { $ setting = $ this - > find Setting ( 'site .title ' ) ; if ( ! $ setting - > exists ) { $ setting - > fill ( [ 'display _name ' = > _ _ ( 'voyager : :seeders .settings .site .title ' ) , 'value ' = > _ _ ( 'voyager : :seeders .settings .site .title ' ) , 'details ' = > ' ' , 'type ' = > 'text ' , 'order ' = > 1 , 'group ' = > 'Site ' , ] ) - > save ( ) ; } $ setting = $ this - > find Setting ( 'site .description ' ) ; if ( ! $ setting - > exists ) { $ setting - > fill ( [ 'display _name ' = > _ _ ( 'voyager : :seeders .settings .site .description ' ) , 'value ' = > _ _ ( 'voyager : :seeders .settings .site .description ' ) , 'details ' = > ' ' , 'type ' = > 'text ' , 'order ' = > 2 , 'group ' = > 'Site ' , ] ) - > save ( ) ; } $ setting = $ this - > find Setting ( 'site .logo ' ) ; if ( ! $ setting - > exists ) { $ setting - > fill ( [ 'display _name ' = > _ _ ( 'voyager : :seeders .settings .site .logo ' ) , 'value ' = > ' ' , 'details ' = > ' ' , 'type ' = > 'image ' , 'order ' = > 3 , 'group ' = > 'Site ' , ] ) - > save ( ) ; } $ setting = $ this - > find Setting ( 'site .google _analytics _tracking _id ' ) ; if ( ! $ setting - > exists ) { $ setting - > fill ( [ 'display _name ' = > _ _ ( 'voyager : :seeders .settings .site .google _analytics _tracking _id ' ) , 'value ' = > ' ' , 'details ' = > ' ' , 'type ' = > 'text ' , 'order ' = > 4 , 'group ' = > 'Site ' , ] ) - > save ( ) ; } $ setting = $ this - > find Setting ( 'admin .bg _image ' ) ; if ( ! $ setting - > exists ) { $ setting - > fill ( [ 'display _name ' = > _ _ ( 'voyager : :seeders .settings .admin .background _image ' ) , 'value ' = > ' ' , 'details ' = > ' ' , 'type ' = > 'image ' , 'order ' = > 5 , 'group ' = > 'Admin ' , ] ) - > save ( ) ; } $ setting = $ this - > find Setting ( 'admin .title ' ) ; if ( ! $ setting - > exists ) { $ setting - > fill ( [ 'display _name ' = > _ _ ( 'voyager : :seeders .settings .admin .title ' ) , 'value ' = > 'Voyager ' , 'details ' = > ' ' , 'type ' = > 'text ' , 'order ' = > 1 , 'group ' = > 'Admin ' , ] ) - > save ( ) ; } $ setting = $ this - > find Setting ( 'admin .description ' ) ; if ( ! $ setting - > exists ) { $ setting - > fill ( [ 'display _name ' = > _ _ ( 'voyager : :seeders .settings .admin .description ' ) , 'value ' = > _ _ ( 'voyager : :seeders .settings .admin .description _value ' ) , 'details ' = > ' ' , 'type ' = > 'text ' , 'order ' = > 2 , 'group ' = > 'Admin ' , ] ) - > save ( ) ; } $ setting = $ this - > find Setting ( 'admin .loader ' ) ; if ( ! $ setting - > exists ) { $ setting - > fill ( [ 'display _name ' = > _ _ ( 'voyager : :seeders .settings .admin .loader ' ) , 'value ' = > ' ' , 'details ' = > ' ' , 'type ' = > 'image ' , 'order ' = > 3 , 'group ' = > 'Admin ' , ] ) - > save ( ) ; } $ setting = $ this - > find Setting ( 'admin .icon _image ' ) ; if ( ! $ setting - > exists ) { $ setting - > fill ( [ 'display _name ' = > _ _ ( 'voyager : :seeders .settings .admin .icon _image ' ) , 'value ' = > ' ' , 'details ' = > ' ' , 'type ' = > 'image ' , 'order ' = > 4 , 'group ' = > 'Admin ' , ] ) - > save ( ) ; } $ setting = $ this - > find Setting ( 'admin .google _analytics _client _id ' ) ; if ( ! $ setting - > exists ) { $ setting - > fill ( [ 'display _name ' = > _ _ ( 'voyager : :seeders .settings .admin .google _analytics _client _id ' ) , 'value ' = > ' ' , 'details ' = > ' ' , 'type ' = > 'text ' , 'order ' = > 1 , 'group ' = > 'Admin ' , ] ) - > save ( ) ; } } 
public function up ( ) { Schema : : table ( 'users ' , function ( $ table ) { if ( ! Schema : : has Column ( 'users ' , 'avatar ' ) ) { $ table - > string ( 'avatar ' ) - > nullable ( ) - > after ( 'email ' ) - > default ( 'users /default .png ' ) ; } $ table - > big Integer ( 'role _id ' ) - > nullable ( ) - > after ( 'id ' ) ; } ) ; } 
public function handle ( Bread Added $ bread ) { if ( config ( 'voyager .bread .add _permission ' ) & & file _exists ( base _path ( 'routes /web .php ' ) ) ) { 
public function register ( ) { $ this - > app - > register ( Voyager Event Service Provider : : class ) ; $ this - > app - > register ( Image Service Provider : : class ) ; $ this - > app - > register ( Voyager Dummy Service Provider : : class ) ; $ this - > app - > register ( Voyager Hooks Service Provider : : class ) ; $ this - > app - > register ( Doctrine Support Service Provider : : class ) ; $ loader = Alias Loader : : get Instance ( ) ; $ loader - > alias ( 'Voyager ' , Voyager Facade : : class ) ; $ this - > app - > singleton ( 'voyager ' , function ( ) { return new Voyager ( ) ; } ) ; $ this - > app - > singleton ( 'Voyager Auth ' , function ( ) { return auth ( ) ; } ) ; $ this - > load Helpers ( ) ; $ this - > register Alert Components ( ) ; $ this - > register Form Fields ( ) ; $ this - > register Configs ( ) ; if ( $ this - > app - > running In Console ( ) ) { $ this - > register Publishable Resources ( ) ; $ this - > register Console Commands ( ) ; } if ( ! $ this - > app - > running In Console ( ) | | config ( 'app .env ' ) = = 'testing ' ) { $ this - > register App Commands ( ) ; } } 
public function boot ( Router $ router , Dispatcher $ event ) { if ( config ( 'voyager .user .add _default _role _on _register ' ) ) { $ app _user = config ( 'voyager .user .namespace ' ) ? : config ( 'auth .providers .users .model ' ) ; $ app _user : : created ( function ( $ user ) { if ( is _null ( $ user - > role _id ) ) { Voyager Facade : : model ( 'User ' ) - > find Or Fail ( $ user - > id ) - > set Role ( config ( 'voyager .user .default _role ' ) ) - > save ( ) ; } } ) ; } $ this - > load Views From ( _ _DIR _ _ . ' / . . /resources /views ' , 'voyager ' ) ; $ router - > alias Middleware ( 'admin .user ' , Voyager Admin Middleware : : class ) ; $ this - > load Translations From ( realpath ( _ _DIR _ _ . ' / . . /publishable /lang ' ) , 'voyager ' ) ; if ( config ( 'voyager .database .autoload _migrations ' , true ) ) { if ( config ( 'app .env ' ) = = 'testing ' ) { $ this - > load Migrations From ( realpath ( _ _DIR _ _ . ' /migrations ' ) ) ; } $ this - > load Migrations From ( realpath ( _ _DIR _ _ . ' / . . /migrations ' ) ) ; } $ this - > load Auth ( ) ; $ this - > register View Composers ( ) ; $ event - > listen ( 'voyager .alerts .collecting ' , function ( ) { $ this - > add Storage Symlink Alert ( ) ; } ) ; $ this - > boot Translator Collection Macros ( ) ; } 
protected function add Storage Symlink Alert ( ) { if ( app ( 'router ' ) - > current ( ) ! = = null ) { $ current Route Action = app ( 'router ' ) - > current ( ) - > get Action ( ) ; } else { $ current Route Action = null ; } $ route Name = is _array ( $ current Route Action ) ? Arr : : get ( $ current Route Action , 'as ' ) : null ; if ( $ route Name ! = 'voyager .dashboard ' ) { return ; } $ storage _disk = ( ! empty ( config ( 'voyager .storage .disk ' ) ) ) ? config ( 'voyager .storage .disk ' ) : 'public ' ; if ( request ( ) - > has ( 'fix -missing -storage -symlink ' ) ) { if ( file _exists ( public _path ( 'storage ' ) ) ) { if ( @ readlink ( public _path ( 'storage ' ) ) = = public _path ( 'storage ' ) ) { rename ( public _path ( 'storage ' ) , 'storage _old ' ) ; } } if ( ! file _exists ( public _path ( 'storage ' ) ) ) { $ this - > fix Missing Storage Symlink ( ) ; } } elseif ( $ storage _disk = = 'public ' ) { if ( ! file _exists ( public _path ( 'storage ' ) ) | | @ readlink ( public _path ( 'storage ' ) ) = = public _path ( 'storage ' ) ) { $ alert = ( new Alert ( 'missing -storage -symlink ' , 'warning ' ) ) - > title ( _ _ ( 'voyager : :error .symlink _missing _title ' ) ) - > text ( _ _ ( 'voyager : :error .symlink _missing _text ' ) ) - > button ( _ _ ( 'voyager : :error .symlink _missing _button ' ) , ' ?fix -missing -storage -symlink = 1 ' ) ; Voyager Facade : : add Alert ( $ alert ) ; } } } 
private function register Console Commands ( ) { $ this - > commands ( Commands \ Install Command : : class ) ; $ this - > commands ( Commands \ Controllers Command : : class ) ; $ this - > commands ( Commands \ Admin Command : : class ) ; } 
public function index ( Request $ request ) { 
public function show ( Request $ request , $ id ) { $ slug = $ this - > get Slug ( $ request ) ; $ data Type = Voyager : : model ( 'Data Type ' ) - > where ( 'slug ' , ' = ' , $ slug ) - > first ( ) ; $ is Soft Deleted = false ; if ( strlen ( $ data Type - > model _name ) ! = 0 ) { $ model = app ( $ data Type - > model _name ) ; 
public function edit ( Request $ request , $ id ) { $ slug = $ this - > get Slug ( $ request ) ; $ data Type = Voyager : : model ( 'Data Type ' ) - > where ( 'slug ' , ' = ' , $ slug ) - > first ( ) ; if ( strlen ( $ data Type - > model _name ) ! = 0 ) { $ model = app ( $ data Type - > model _name ) ; 
public function update ( Request $ request , $ id ) { $ slug = $ this - > get Slug ( $ request ) ; $ data Type = Voyager : : model ( 'Data Type ' ) - > where ( 'slug ' , ' = ' , $ slug ) - > first ( ) ; 
public function create ( Request $ request ) { $ slug = $ this - > get Slug ( $ request ) ; $ data Type = Voyager : : model ( 'Data Type ' ) - > where ( 'slug ' , ' = ' , $ slug ) - > first ( ) ; 
public function store ( Request $ request ) { $ slug = $ this - > get Slug ( $ request ) ; $ data Type = Voyager : : model ( 'Data Type ' ) - > where ( 'slug ' , ' = ' , $ slug ) - > first ( ) ; 
public function destroy ( Request $ request , $ id ) { $ slug = $ this - > get Slug ( $ request ) ; $ data Type = Voyager : : model ( 'Data Type ' ) - > where ( 'slug ' , ' = ' , $ slug ) - > first ( ) ; 
protected function cleanup ( $ data Type , $ data ) { 
public function delete Bread Images ( $ data , $ rows ) { foreach ( $ rows as $ row ) { if ( $ data - > { $ row - > field } ! = config ( 'voyager .user .default _avatar ' ) ) { $ this - > delete File If Exists ( $ data - > { $ row - > field } ) ; } if ( isset ( $ row - > details - > thumbnails ) ) { foreach ( $ row - > details - > thumbnails as $ thumbnail ) { $ ext = explode ( ' . ' , $ data - > { $ row - > field } ) ; $ extension = ' . ' . $ ext [ count ( $ ext ) - 1 ] ; $ path = str _replace ( $ extension , ' ' , $ data - > { $ row - > field } ) ; $ thumb _name = $ thumbnail - > name ; $ this - > delete File If Exists ( $ path . ' - ' . $ thumb _name . $ extension ) ; } } } if ( $ rows - > count ( ) > 0 ) { event ( new Bread Images Deleted ( $ data , $ rows ) ) ; } } 
public function order ( Request $ request ) { $ slug = $ this - > get Slug ( $ request ) ; $ data Type = Voyager : : model ( 'Data Type ' ) - > where ( 'slug ' , ' = ' , $ slug ) - > first ( ) ; 
public function relation ( Request $ request ) { $ slug = $ this - > get Slug ( $ request ) ; $ page = $ request - > input ( 'page ' ) ; $ on _page = 5 0 ; $ search = $ request - > input ( 'search ' , false ) ; $ data Type = Voyager : : model ( 'Data Type ' ) - > where ( 'slug ' , ' = ' , $ slug ) - > first ( ) ; foreach ( $ data Type - > edit Rows as $ key = > $ row ) { if ( $ row - > field = = = $ request - > input ( 'type ' ) ) { $ options = $ row - > details ; $ skip = $ on _page * ( $ page - 1 ) ; 
protected function resolve Relations ( $ data Type Content , Data Type $ data Type ) { 
public function run ( ) { if ( User : : count ( ) = = 0 ) { $ role = Role : : where ( 'name ' , 'admin ' ) - > first Or Fail ( ) ; User : : create ( [ 'name ' = > 'Admin ' , 'email ' = > 'admin @admin .com ' , 'password ' = > bcrypt ( 'password ' ) , 'remember _token ' = > Str : : random ( 6 0 ) , 'role _id ' = > $ role - > id , ] ) ; } } 
public function up ( ) { 
protected function add Soft Delete ( & $ stub ) { $ trait Incl = $ trait = ' ' ; if ( $ this - > option ( 'softdelete ' ) ) { $ trait Incl = 'use Illuminate \Database \Eloquent \Soft Deletes ; ' ; $ trait = 'use Soft Deletes ; ' ; } $ stub = str _replace ( ' / /Dummy SDTrait Include ' , $ trait Incl , $ stub ) ; $ stub = str _replace ( ' / /Dummy SDTrait ' , $ trait , $ stub ) ; return $ this ; } 
public function validate Bread ( $ request , $ data , $ name = null , $ id = null ) { $ rules = [ ] ; $ messages = [ ] ; $ custom Attributes = [ ] ; $ is _update = $ name & & $ id ; $ fields With Validation Rules = $ this - > get Fields With Validation Rules ( $ data ) ; foreach ( $ fields With Validation Rules as $ field ) { $ field Rules = $ field - > details - > validation - > rule ; $ field Name = $ field - > field ; 
protected function get Fields With Validation Rules ( $ fields Config ) { return $ fields Config - > filter ( function ( $ value ) { if ( empty ( $ value - > details ) ) { return false ; } return ! empty ( $ value - > details - > validation - > rule ) ; } ) ; } 
public function run ( ) { <h 2 >We can use all kinds of format ! < /h 2 > <p >And include a bunch of other stuff . < /p > ' , 'image ' = > 'posts /post 2 .jpg ' , 'slug ' = > 'my -sample -post ' , 'meta _description ' = > 'Meta Description for sample post ' , 'meta _keywords ' = > 'keyword 1 , keyword 2 , keyword 3 ' , 'status ' = > 'PUBLISHED ' , 'featured ' = > 0 , ] ) - > save ( ) ; } $ post = $ this - > find Post ( 'latest -post ' ) ; if ( ! $ post - > exists ) { $ post - > fill ( [ 'title ' = > 'Latest Post ' , 'author _id ' = > 0 , 'seo _title ' = > null , 'excerpt ' = > 'This is the excerpt for the latest post ' , 'body ' = > ' <p >This is the body for the latest post < /p > ' , 'image ' = > 'posts /post 3 .jpg ' , 'slug ' = > 'latest -post ' , 'meta _description ' = > 'This is the meta description ' , 'meta _keywords ' = > 'keyword 1 , keyword 2 , keyword 3 ' , 'status ' = > 'PUBLISHED ' , 'featured ' = > 0 , ] ) - > save ( ) ; } $ post = $ this - > find Post ( 'yarr -post ' ) ; if ( ! $ post - > exists ) { $ post - > fill ( [ 'title ' = > 'Yarr Post ' , 'author _id ' = > 0 , 'seo _title ' = > null , 'excerpt ' = > 'Reef sails nipperkin bring a spring upon her cable coffer jury mast spike marooned Pieces of Eight poop deck pillage . Clipper driver coxswain galleon hempen halter come about pressgang gangplank boatswain swing the lead . Nipperkin yard skysail swab lanyard Blimey bilge water ho quarter Buccaneer . ' , 'body ' = > ' <p >Swab deadlights Buccaneer fire ship square -rigged dance the hempen jig weigh anchor cackle fruit grog furl . Crack Jennys tea cup chase guns pressgang hearties spirits hogshead Gold Road six pounders fathom measured fer yer chains . Main sheet provost come about trysail barkadeer crimp scuttle mizzenmast brig plunder . < /p > <p >Mizzen league keelhaul galleon tender cog chase Barbary Coast doubloon crack Jennys tea cup . Blow the man down lugsail fire ship pinnace cackle fruit line warp Admiral of the Black strike colors doubloon . Tackle Jack Ketch come about crimp rum draft scuppers run a shot across the bow haul wind maroon . < /p > <p >Interloper heave down list driver pressgang holystone scuppers tackle scallywag bilged on her anchor . Jack Tar interloper draught grapple mizzenmast hulk knave cable transom hogshead . Gaff pillage to go on account grog aft chase guns piracy yardarm knave clap of thunder . < /p > ' , 'image ' = > 'posts /post 4 .jpg ' , 'slug ' = > 'yarr -post ' , 'meta _description ' = > 'this be a meta descript ' , 'meta _keywords ' = > 'keyword 1 , keyword 2 , keyword 3 ' , 'status ' = > 'PUBLISHED ' , 'featured ' = > 0 , ] ) - > save ( ) ; } } 
public function revoke Token ( $ token ) { if ( is _array ( $ token ) ) { if ( isset ( $ token [ 'refresh _token ' ] ) ) { $ token = $ token [ 'refresh _token ' ] ; } else { $ token = $ token [ 'access _token ' ] ; } } $ body = Psr 7 \ stream _for ( http _build _query ( array ( 'token ' = > $ token ) ) ) ; $ request = new Request ( 'POST ' , Google _Client : : OAUTH 2 _REVOKE _URI , [ 'Cache -Control ' = > 'no -store ' , 'Content -Type ' = > 'application /x -www -form -urlencoded ' , ] , $ body ) ; $ http Handler = Http Handler Factory : : build ( $ this - > http ) ; $ response = $ http Handler ( $ request ) ; return $ response - > get Status Code ( ) = = 2 0 0 ; } 
public function verify Id Token ( $ id Token , $ audience = null ) { if ( empty ( $ id Token ) ) { throw new Logic Exception ( 'id _token cannot be null ' ) ; } 
private function retrieve Certs From Location ( $ url ) { 
private function get Federated Sign On Certs ( ) { $ certs = null ; if ( $ cache = $ this - > get Cache ( ) ) { $ cache Item = $ cache - > get Item ( 'federated _signon _certs _v 3 ' ) ; $ certs = $ cache Item - > get ( ) ; } if ( ! $ certs ) { $ certs = $ this - > retrieve Certs From Location ( self : : FEDERATED _SIGNON _CERT _URL ) ; if ( $ cache ) { $ cache Item - > expires At ( new Date Time ( ' + 1 hour ' ) ) ; $ cache Item - > set ( $ certs ) ; $ cache - > save ( $ cache Item ) ; } } if ( ! isset ( $ certs [ 'keys ' ] ) ) { throw new Invalid Argument Exception ( 'federated sign -on certs expects "keys " to be set ' ) ; } return $ certs [ 'keys ' ] ; } 
private function set Phpsec Constants ( ) { if ( filter _var ( getenv ( 'GAE _VM ' ) , FILTER _VALIDATE _BOOLEAN ) ) { if ( ! defined ( 'MATH _BIGINTEGER _OPENSSL _ENABLED ' ) ) { define ( 'MATH _BIGINTEGER _OPENSSL _ENABLED ' , true ) ; } if ( ! defined ( 'CRYPT _RSA _MODE ' ) ) { define ( 'CRYPT _RSA _MODE ' , constant ( $ this - > get Open Ssl Constant ( ) ) ) ; } } } 
public function call ( $ name , $ arguments , $ expected Class = null ) { if ( ! isset ( $ this - > methods [ $ name ] ) ) { $ this - > client - > get Logger ( ) - > error ( 'Service method unknown ' , array ( 'service ' = > $ this - > service Name , 'resource ' = > $ this - > resource Name , 'method ' = > $ name ) ) ; throw new Google _Exception ( "Unknown function : " . " { $this - >service Name } - > { $this - >resource Name } - > { $name } ( ) " ) ; } $ method = $ this - > methods [ $ name ] ; $ parameters = $ arguments [ 0 ] ; 
public function create Request Uri ( $ rest Path , $ params ) { 
public function fetch Access Token With Auth Code ( $ code ) { if ( strlen ( $ code ) = = 0 ) { throw new Invalid Argument Exception ( "Invalid code " ) ; } $ auth = $ this - > get OAuth 2Service ( ) ; $ auth - > set Code ( $ code ) ; $ auth - > set Redirect Uri ( $ this - > get Redirect Uri ( ) ) ; $ http Handler = Http Handler Factory : : build ( $ this - > get Http Client ( ) ) ; $ creds = $ auth - > fetch Auth Token ( $ http Handler ) ; if ( $ creds & & isset ( $ creds [ 'access _token ' ] ) ) { $ creds [ 'created ' ] = time ( ) ; $ this - > set Access Token ( $ creds ) ; } return $ creds ; } 
public function fetch Access Token With Assertion ( Client Interface $ auth Http = null ) { if ( ! $ this - > is Using Application Default Credentials ( ) ) { throw new Domain Exception ( 'set the JSON service account credentials using ' . ' Google _Client : :set Auth Config or set the path to your JSON file ' . ' with the "GOOGLE _APPLICATION _CREDENTIALS " environment variable ' . ' and call Google _Client : :use Application Default Credentials to ' . ' refresh a token with assertion . ' ) ; } $ this - > get Logger ( ) - > log ( 'info ' , 'OAuth 2 access token refresh with Signed JWT assertion grants . ' ) ; $ credentials = $ this - > create Application Default Credentials ( ) ; $ http Handler = Http Handler Factory : : build ( $ auth Http ) ; $ creds = $ credentials - > fetch Auth Token ( $ http Handler ) ; if ( $ creds & & isset ( $ creds [ 'access _token ' ] ) ) { $ creds [ 'created ' ] = time ( ) ; $ this - > set Access Token ( $ creds ) ; } return $ creds ; } 
public function fetch Access Token With Refresh Token ( $ refresh Token = null ) { if ( null = = = $ refresh Token ) { if ( ! isset ( $ this - > token [ 'refresh _token ' ] ) ) { throw new Logic Exception ( 'refresh token must be passed in or set as part of set Access Token ' ) ; } $ refresh Token = $ this - > token [ 'refresh _token ' ] ; } $ this - > get Logger ( ) - > info ( 'OAuth 2 access token refresh ' ) ; $ auth = $ this - > get OAuth 2Service ( ) ; $ auth - > set Refresh Token ( $ refresh Token ) ; $ http Handler = Http Handler Factory : : build ( $ this - > get Http Client ( ) ) ; $ creds = $ auth - > fetch Auth Token ( $ http Handler ) ; if ( $ creds & & isset ( $ creds [ 'access _token ' ] ) ) { $ creds [ 'created ' ] = time ( ) ; if ( ! isset ( $ creds [ 'refresh _token ' ] ) ) { $ creds [ 'refresh _token ' ] = $ refresh Token ; } $ this - > set Access Token ( $ creds ) ; } return $ creds ; } 
public function create Auth Url ( $ scope = null ) { if ( empty ( $ scope ) ) { $ scope = $ this - > prepare Scopes ( ) ; } if ( is _array ( $ scope ) ) { $ scope = implode ( ' ' , $ scope ) ; } 
public function authorize ( Client Interface $ http = null ) { $ credentials = null ; $ token = null ; $ scopes = null ; if ( null = = = $ http ) { $ http = $ this - > get Http Client ( ) ; } 
public function is Access Token Expired ( ) { if ( ! $ this - > token ) { return true ; } $ created = 0 ; if ( isset ( $ this - > token [ 'created ' ] ) ) { $ created = $ this - > token [ 'created ' ] ; } elseif ( isset ( $ this - > token [ 'id _token ' ] ) ) { 
public function set Request Visible Actions ( $ request Visible Actions ) { if ( is _array ( $ request Visible Actions ) ) { $ request Visible Actions = implode ( " " , $ request Visible Actions ) ; } $ this - > config [ 'request _visible _actions ' ] = $ request Visible Actions ; } 
public function revoke Token ( $ token = null ) { $ token Revoker = new Google _Access Token _Revoke ( $ this - > get Http Client ( ) ) ; return $ token Revoker - > revoke Token ( $ token ? : $ this - > get Access Token ( ) ) ; } 
public function verify Id Token ( $ id Token = null ) { $ token Verifier = new Google _Access Token _Verify ( $ this - > get Http Client ( ) , $ this - > get Cache ( ) , $ this - > config [ 'jwt ' ] ) ; if ( null = = = $ id Token ) { $ token = $ this - > get Access Token ( ) ; if ( ! isset ( $ token [ 'id _token ' ] ) ) { throw new Logic Exception ( 'id _token must be passed in or set as part of set Access Token ' ) ; } $ id Token = $ token [ 'id _token ' ] ; } return $ token Verifier - > verify Id Token ( $ id Token , $ this - > get Client Id ( ) ) ; } 
public function add Scope ( $ scope _or _scopes ) { if ( is _string ( $ scope _or _scopes ) & & ! in _array ( $ scope _or _scopes , $ this - > requested Scopes ) ) { $ this - > requested Scopes [ ] = $ scope _or _scopes ; } else if ( is _array ( $ scope _or _scopes ) ) { foreach ( $ scope _or _scopes as $ scope ) { $ this - > add Scope ( $ scope ) ; } } } 
public function execute ( Request Interface $ request , $ expected Class = null ) { $ request = $ request - > with Header ( 'User -Agent ' , $ this - > config [ 'application _name ' ] . " " . self : : USER _AGENT _SUFFIX . $ this - > get Library Version ( ) ) ; 
public function set Auth Config ( $ config ) { if ( is _string ( $ config ) ) { if ( ! file _exists ( $ config ) ) { throw new Invalid Argument Exception ( sprintf ( 'file " %s " does not exist ' , $ config ) ) ; } $ json = file _get _contents ( $ config ) ; if ( ! $ config = json _decode ( $ json , true ) ) { throw new Logic Exception ( 'invalid json for auth config ' ) ; } } $ key = isset ( $ config [ 'installed ' ] ) ? 'installed ' : 'web ' ; if ( isset ( $ config [ 'type ' ] ) & & $ config [ 'type ' ] = = 'service _account ' ) { 
protected function create OAuth 2Service ( ) { $ auth = new OAuth 2 ( [ 'client Id ' = > $ this - > get Client Id ( ) , 'client Secret ' = > $ this - > get Client Secret ( ) , 'authorization Uri ' = > self : : OAUTH 2 _AUTH _URL , 'token Credential Uri ' = > self : : OAUTH 2 _TOKEN _URI , 'redirect Uri ' = > $ this - > get Redirect Uri ( ) , 'issuer ' = > $ this - > config [ 'client _id ' ] , 'signing Key ' = > $ this - > config [ 'signing _key ' ] , 'signing Algorithm ' = > $ this - > config [ 'signing _algorithm ' ] , ] ) ; return $ auth ; } 
public function run ( ) { while ( $ this - > attempt ( ) ) { try { return call _user _func _array ( $ this - > action , $ this - > arguments ) ; } catch ( Google _Service _Exception $ exception ) { $ allowed Retries = $ this - > allowed Retries ( $ exception - > get Code ( ) , $ exception - > get Errors ( ) ) ; if ( ! $ this - > can Attempt ( ) | | ! $ allowed Retries ) { throw $ exception ; } if ( $ allowed Retries > 0 ) { $ this - > max Attempts = min ( $ this - > max Attempts , $ this - > attempts + $ allowed Retries ) ; } } } } 
public function attempt ( ) { if ( ! $ this - > can Attempt ( ) ) { return false ; } if ( $ this - > attempts > 0 ) { $ this - > back Off ( ) ; } $ this - > attempts + + ; return true ; } 
private function get Delay ( ) { $ jitter = $ this - > get Jitter ( ) ; $ factor = $ this - > attempts > 1 ? $ this - > factor + $ jitter : 1 + abs ( $ jitter ) ; return $ this - > delay = min ( $ this - > max Delay , $ this - > delay * $ factor ) ; } 
public function allowed Retries ( $ code , $ errors = array ( ) ) { if ( isset ( $ this - > retry Map [ $ code ] ) ) { return $ this - > retry Map [ $ code ] ; } if ( ! empty ( $ errors ) & & isset ( $ errors [ 0 ] [ 'reason ' ] , $ this - > retry Map [ $ errors [ 0 ] [ 'reason ' ] ] ) ) { return $ this - > retry Map [ $ errors [ 0 ] [ 'reason ' ] ] ; } return 0 ; } 
public function next Chunk ( $ chunk = false ) { $ resume Uri = $ this - > get Resume Uri ( ) ; if ( false = = $ chunk ) { $ chunk = substr ( $ this - > data , $ this - > progress , $ this - > chunk Size ) ; } $ last Byte Pos = $ this - > progress + strlen ( $ chunk ) - 1 ; $ headers = array ( 'content -range ' = > "bytes $this - >progress - $last Byte Pos / $this - >size " , 'content -length ' = > strlen ( $ chunk ) , 'expect ' = > ' ' , ) ; $ request = new Request ( 'PUT ' , $ resume Uri , $ headers , Psr 7 \ stream _for ( $ chunk ) ) ; return $ this - > make Put Request ( $ request ) ; } 
private function make Put Request ( Request Interface $ request ) { $ response = $ this - > client - > execute ( $ request ) ; $ this - > http Result Code = $ response - > get Status Code ( ) ; if ( 3 0 8 = = $ this - > http Result Code ) { 
public function get Upload Type ( $ meta ) { if ( $ this - > resumable ) { return self : : UPLOAD _RESUMABLE _TYPE ; } if ( false = = $ meta & & $ this - > data ) { return self : : UPLOAD _MEDIA _TYPE ; } return self : : UPLOAD _MULTIPART _TYPE ; } 
private function parse Http Response ( $ resp Data , $ header Size ) { 
private function resolve Next Section ( $ string , $ parameters ) { $ start = strpos ( $ string , " { " ) ; if ( $ start = = = false ) { return $ string ; } $ end = strpos ( $ string , " } " ) ; if ( $ end = = = false ) { return $ string ; } $ string = $ this - > replace ( $ string , $ start , $ end , $ parameters ) ; return $ this - > resolve Next Section ( $ string , $ parameters ) ; } 
private function get Data Type ( $ data ) { if ( is _array ( $ data ) ) { reset ( $ data ) ; if ( key ( $ data ) ! = = 0 ) { return self : : TYPE _MAP ; } return self : : TYPE _LIST ; } return self : : TYPE _SCALAR ; } 
private function combine List ( $ vars , $ sep , $ parameters , $ combine , $ reserved , $ tag _empty , $ combine _on _empty ) { $ ret = array ( ) ; foreach ( $ vars as $ var ) { $ response = $ this - > combine ( $ var , $ parameters , $ sep , $ combine , $ reserved , $ tag _empty , $ combine _on _empty ) ; if ( $ response = = = false ) { continue ; } $ ret [ ] = $ response ; } return implode ( $ sep , $ ret ) ; } 
private function get Value ( $ value , $ length ) { if ( $ length ) { $ value = substr ( $ value , 0 , $ length ) ; } $ value = rawurlencode ( $ value ) ; return $ value ; } 
public static function execute ( Client Interface $ client , Request Interface $ request , $ expected Class = null , $ config = array ( ) , $ retry Map = null ) { $ runner = new Google _Task _Runner ( $ config , sprintf ( ' %s %s ' , $ request - > get Method ( ) , ( string ) $ request - > get Uri ( ) ) , array ( get _class ( ) , 'do Execute ' ) , array ( $ client , $ request , $ expected Class ) ) ; if ( null ! = = $ retry Map ) { $ runner - > set Retry Map ( $ retry Map ) ; } return $ runner - > run ( ) ; } 
public static function do Execute ( Client Interface $ client , Request Interface $ request , $ expected Class = null ) { try { $ http Handler = Http Handler Factory : : build ( $ client ) ; $ response = $ http Handler ( $ request ) ; } catch ( Request Exception $ e ) { 
public static function decode Http Response ( Response Interface $ response , Request Interface $ request = null , $ expected Class = null ) { $ code = $ response - > get Status Code ( ) ; 
protected function map Types ( $ array ) { 
public function to Simple Object ( ) { $ object = new std Class ( ) ; 
private function get Simple Value ( $ value ) { if ( $ value instanceof Google _Model ) { return $ value - > to Simple Object ( ) ; } else if ( is _array ( $ value ) ) { $ return = array ( ) ; foreach ( $ value as $ key = > $ a _value ) { $ a _value = $ this - > get Simple Value ( $ a _value ) ; if ( $ a _value ! = = null ) { $ key = $ this - > get Mapped Name ( $ key ) ; $ return [ $ key ] = $ this - > null Placeholder Check ( $ a _value ) ; } } return $ return ; } return $ value ; } 
private function get Mapped Name ( $ key ) { if ( isset ( $ this - > internal _gapi _mappings , $ this - > internal _gapi _mappings [ $ key ] ) ) { $ key = $ this - > internal _gapi _mappings [ $ key ] ; } return $ key ; } 
protected function is Associative Array ( $ array ) { if ( ! is _array ( $ array ) ) { return false ; } $ keys = array _keys ( $ array ) ; foreach ( $ keys as $ key ) { if ( is _string ( $ key ) ) { return true ; } } return false ; } 
public static function build ( $ cache = null , array $ cache Config = [ ] ) { $ version = Client Interface : : VERSION ; switch ( $ version [ 0 ] ) { case ' 5 ' : return new Google _Auth Handler _Guzzle 5Auth Handler ( $ cache , $ cache Config ) ; case ' 6 ' : return new Google _Auth Handler _Guzzle 6Auth Handler ( $ cache , $ cache Config ) ; default : throw new Exception ( 'Version not supported ' ) ; } } 
public function find _config ( ) { $ config = $ this - > fix _win 3 2 _path ( $ this - > config ) ; if ( ! empty ( $ config ) & & is _readable ( $ config ) ) { return $ config ; } if ( ! empty ( $ config ) & & ! is _readable ( $ config ) ) { throw new Config Exception ( "User defined config not found at ' $config ' " ) ; } 
public function define _core _constants ( ) { * The following has an awful CRAP index and it would be much shorter reduced to something like * defining an array of ( 'YOURLS _SOMETHING ' = > 'default value ' ) and then a simple loop over the * array , checking if $current is defined as a constant and otherwise define said constant with * its default value . I did not wrote it that way because that would make it difficult for code * parsers to identify which constants are defined and where . So , here it is , that long list of * if ( !defined ) define ( ) . Ho and by the way , such beautiful comment , much right aligned , wow ! * / 
public function set _emulate _state ( ) { try { $ this - > is _emulate _prepare = $ this - > get Attribute ( PDO : : ATTR _EMULATE _PREPARES ) ; } catch ( \ PDOException $ e ) { $ this - > is _emulate _prepare = false ; } } 
public function dead _or _error ( \ Exception $ exception ) { 
public function get _queries ( ) { $ queries = $ this - > get Profiler ( ) - > get Profiles ( ) ; if ( $ this - > get _emulate _state ( ) ) { 
public function add Profile ( $ duration , $ function , $ statement , array $ bind _values = array ( ) ) { parent : : add Profile ( $ duration , $ function , $ statement , $ bind _values ) ; if ( $ function = = 'connect ' ) { $ this - > log ( sprintf ( 'SQL : CONNECT ( %s s ) ' , number _format ( $ duration , 5 ) ) ) ; return ; } 
public function pretty _format ( $ statement , array $ values = array ( ) ) { if ( ! $ values ) { return $ statement ; } return preg _replace _callback ( ' / : ( [ ^ \s ; ) ] * ) / ' , function ( $ matches ) use ( $ values ) { $ replacement = isset ( $ values [ $ matches [ 1 ] ] ) ? $ values [ $ matches [ 1 ] ] : ' ' ; if ( is _array ( $ replacement ) ) { $ replacement = implode ( " , " , $ replacement ) ; } return " ' $replacement ' " ; } , $ statement ) ; } 
function array 2xml ( $ array ) { 
function xml 2array ( $ xml ) { $ this - > depth = - 1 ; $ this - > xml _parser = xml _parser _create ( ) ; xml _set _object ( $ this - > xml _parser , $ this ) ; xml _parser _set _option ( $ this - > xml _parser , XML _OPTION _CASE _FOLDING , 0 ) ; 
function init ( ) { 
function register _globals ( ) { $ GLOBALS [ 'weekday ' ] = $ this - > weekday ; $ GLOBALS [ 'weekday _initial ' ] = $ this - > weekday _initial ; $ GLOBALS [ 'weekday _abbrev ' ] = $ this - > weekday _abbrev ; $ GLOBALS [ 'month ' ] = $ this - > month ; $ GLOBALS [ 'month _abbrev ' ] = $ this - > month _abbrev ; } 
public function get _all _options ( ) { 
public function get ( $ name , $ default ) { $ name = trim ( ( string ) $ name ) ; if ( empty ( $ name ) ) { return $ default ; } * We don 't cache value if option is not set , to make a difference between "not found : returning false " * and "found , and value is false " . * This way , we can : * $check = yourls _get _option ( 'doesnt _exist ' ) ; / / false * yourls _add _option ( 'doesnt _exist ' , 'value ' ) ; * / return $ value ; } 
public function update ( $ name , $ newvalue ) { $ name = trim ( ( string ) $ name ) ; if ( empty ( $ name ) ) { return false ; } 
public function add ( $ name , $ value ) { $ name = trim ( ( string ) $ name ) ; if ( empty ( $ name ) ) { return false ; } 
public function delete ( $ name ) { $ name = trim ( ( string ) $ name ) ; if ( empty ( $ name ) ) { return false ; } $ table = YOURLS _DB _TABLE _OPTIONS ; $ sql = "DELETE FROM $table WHERE option _name = :name " ; $ bind = array ( 'name ' = > $ name ) ; $ do = $ this - > ydb - > fetch Affected ( $ sql , $ bind ) ; if ( $ do ! = = 1 ) { 
public function add Placeholder ( $ placeholder , string $ pattern = null ) : Route Collection Interface { if ( ! is _array ( $ placeholder ) ) { $ placeholder = [ $ placeholder = > $ pattern ] ; } $ this - > placeholders = array _merge ( $ this - > placeholders , $ placeholder ) ; return $ this ; } 
public function set Default Namespace ( string $ value ) : Route Collection Interface { $ this - > default Namespace = filter _var ( $ value , FILTER _SANITIZE _STRING ) ; $ this - > default Namespace = rtrim ( $ this - > default Namespace , ' \ \ ' ) . ' \ \ ' ; return $ this ; } 
public function set Default Controller ( string $ value ) : Route Collection Interface { $ this - > default Controller = filter _var ( $ value , FILTER _SANITIZE _STRING ) ; return $ this ; } 
public function set Default Method ( string $ value ) : Route Collection Interface { $ this - > default Method = filter _var ( $ value , FILTER _SANITIZE _STRING ) ; return $ this ; } 
protected function discover Routes ( ) { if ( $ this - > did Discover ) { return ; } 
public function set Default Constraint ( string $ placeholder ) : Route Collection Interface { if ( array _key _exists ( $ placeholder , $ this - > placeholders ) ) { $ this - > default Placeholder = $ placeholder ; } return $ this ; } 
public function get Routes ( $ verb = null ) : array { if ( empty ( $ verb ) ) { $ verb = $ this - > get HTTPVerb ( ) ; } 
public function get Routes Options ( string $ from = null ) : array { return $ from ? $ this - > routes Options [ $ from ] ? ? [ ] : $ this - > routes Options ; } 
public function map ( array $ routes = [ ] , array $ options = null ) : Route Collection Interface { foreach ( $ routes as $ from = > $ to ) { $ this - > add ( $ from , $ to , $ options ) ; } return $ this ; } 
public function add Redirect ( string $ from , string $ to , int $ status = 3 0 2 ) { 
public function is Redirect ( string $ from ) : bool { foreach ( $ this - > routes [ ' * ' ] as $ name = > $ route ) { 
public function get Redirect Code ( string $ from ) : int { foreach ( $ this - > routes [ ' * ' ] as $ name = > $ route ) { 
public function group ( string $ name , . . . $ params ) { $ old Group = $ this - > group ; $ old Options = $ this - > current Options ; 
public function resource ( string $ name , array $ options = null ) : Route Collection Interface { 
public function match ( array $ verbs = [ ] , string $ from , $ to , array $ options = null ) : Route Collection Interface { foreach ( $ verbs as $ verb ) { $ verb = strtolower ( $ verb ) ; $ this - > { $ verb } ( $ from , $ to , $ options ) ; } return $ this ; } 
public function options ( string $ from , $ to , array $ options = null ) : Route Collection Interface { $ this - > create ( 'options ' , $ from , $ to , $ options ) ; return $ this ; } 
public function environment ( string $ env , \ Closure $ callback ) : Route Collection Interface { if ( ENVIRONMENT = = = $ env ) { $ callback ( $ this ) ; } return $ this ; } 
public function reverse Route ( string $ search , . . . $ params ) { 
public function get Filter For Route ( string $ search ) : string { if ( ! $ this - > is Filtered ( $ search ) ) { return ' ' ; } return $ this - > routes Options [ $ search ] [ 'filter ' ] ; } 
protected function fill Route Params ( string $ from , array $ params = null ) : string { 
protected function create ( string $ verb , string $ from , $ to , array $ options = null ) { $ overwrite = false ; $ prefix = is _null ( $ this - > group ) ? ' ' : $ this - > group . ' / ' ; $ from = filter _var ( $ prefix . $ from , FILTER _SANITIZE _STRING ) ; 
private function check Subdomains ( $ subdomains ) : bool { 
private function determine Current Subdomain ( ) { 
public function reset Routes ( ) { $ this - > routes = [ ' * ' = > [ ] ] ; foreach ( $ this - > default HTTPMethods as $ verb ) { $ this - > routes [ $ verb ] = [ ] ; } } 
public function exception Handler ( Throwable $ exception ) { $ codes = $ this - > determine Codes ( $ exception ) ; $ status Code = $ codes [ 0 ] ; $ exit Code = $ codes [ 1 ] ; 
public function error Handler ( int $ severity , string $ message , string $ file = null , int $ line = null , $ context = null ) { if ( ! ( error _reporting ( ) & $ severity ) ) { return ; } 
public function shutdown Handler ( ) { $ error = error _get _last ( ) ; 
protected function determine View ( Throwable $ exception , string $ template _path ) : string { 
protected function render ( Throwable $ exception , int $ status Code ) { 
protected function collect Vars ( Throwable $ exception , int $ status Code ) : array { return [ 'title ' = > get _class ( $ exception ) , 'type ' = > get _class ( $ exception ) , 'code ' = > $ status Code , 'message ' = > $ exception - > get Message ( ) ? ? ' (null ) ' , 'file ' = > $ exception - > get File ( ) , 'line ' = > $ exception - > get Line ( ) , 'trace ' = > $ exception - > get Trace ( ) , ] ; } 
protected function determine Codes ( Throwable $ exception ) : array { $ status Code = abs ( $ exception - > get Code ( ) ) ; if ( $ status Code < 1 0 0 | | $ status Code > 5 9 9 ) { $ exit Status = $ status Code + EXIT _ _AUTO _MIN ; 
public static function describe Memory ( int $ bytes ) : string { if ( $ bytes < 1 0 2 4 ) { return $ bytes . 'B ' ; } else if ( $ bytes < 1 0 4 8 5 7 6 ) { return round ( $ bytes / 1 0 2 4 , 2 ) . 'KB ' ; } return round ( $ bytes / 1 0 4 8 5 7 6 , 2 ) . 'MB ' ; } 
public static function highlight File ( string $ file , int $ line Number , int $ lines = 1 5 ) { if ( empty ( $ file ) | | ! is _readable ( $ file ) ) { return false ; } 
public function open ( $ save _path , $ name ) : bool { $ this - > memcached = new \ Memcached ( ) ; $ this - > memcached - > set Option ( \ Memcached : : OPT _BINARY _PROTOCOL , true ) ; 
public function read ( $ session ID ) : string { if ( isset ( $ this - > memcached ) & & $ this - > lock Session ( $ session ID ) ) { 
public function write ( $ session ID , $ session Data ) : bool { if ( ! isset ( $ this - > memcached ) ) { return false ; } 
public function close ( ) : bool { if ( isset ( $ this - > memcached ) ) { isset ( $ this - > lock Key ) & & $ this - > memcached - > delete ( $ this - > lock Key ) ; if ( ! $ this - > memcached - > quit ( ) ) { return false ; } $ this - > memcached = null ; return true ; } return false ; } 
public function destroy ( $ session _id ) : bool { if ( isset ( $ this - > memcached , $ this - > lock Key ) ) { $ this - > memcached - > delete ( $ this - > key Prefix . $ session _id ) ; return $ this - > destroy Cookie ( ) ; } return false ; } 
protected function lock Session ( string $ session ID ) : bool { if ( isset ( $ this - > lock Key ) ) { return $ this - > memcached - > replace ( $ this - > lock Key , time ( ) , 3 0 0 ) ; } 
protected function release Lock ( ) : bool { if ( isset ( $ this - > memcached , $ this - > lock Key ) & & $ this - > lock ) { if ( ! $ this - > memcached - > delete ( $ this - > lock Key ) & & $ this - > memcached - > get Result Code ( ) ! = = \ Memcached : : RES _NOTFOUND ) { $ this - > logger - > error ( 'Session : Error while trying to free lock for ' . $ this - > lock Key ) ; return false ; } $ this - > lock Key = null ; $ this - > lock = false ; } return true ; } 
public function alpha _space ( string $ value = null ) : bool { if ( $ value = = = null ) { return true ; } return ( bool ) preg _match ( ' / ^ [A -Z ] + $ /i ' , $ value ) ; } 
public function regex _match ( string $ str = null , string $ pattern , array $ data ) : bool { if ( strpos ( $ pattern , ' / ' ) ! = = 0 ) { $ pattern = " / { $pattern } / " ; } return ( bool ) preg _match ( $ pattern , $ str ) ; } 
public function valid _email ( string $ str = null ) : bool { if ( function _exists ( 'idn _to _ascii ' ) & & defined ( 'INTL _IDNA _VARIANT _UTS 4 6 ' ) & & preg _match ( ' # \A ( [ ^ @ ] + ) @ ( . + ) \z # ' , $ str , $ matches ) ) { $ str = $ matches [ 1 ] . ' @ ' . idn _to _ascii ( $ matches [ 2 ] , 0 , INTL _IDNA _VARIANT _UTS 4 6 ) ; } return ( bool ) filter _var ( $ str , FILTER _VALIDATE _EMAIL ) ; } 
public function valid _emails ( string $ str = null ) : bool { foreach ( explode ( ' , ' , $ str ) as $ email ) { $ email = trim ( $ email ) ; if ( $ email = = = ' ' ) { return false ; } if ( $ this - > valid _email ( $ email ) = = = false ) { return false ; } } return true ; } 
public function valid _ip ( string $ ip = null , string $ which = null , array $ data ) : bool { switch ( strtolower ( $ which ) ) { case 'ipv 4 ' : $ which = FILTER _FLAG _IPV 4 ; break ; case 'ipv 6 ' : $ which = FILTER _FLAG _IPV 6 ; break ; default : $ which = null ; break ; } return ( bool ) filter _var ( $ ip , FILTER _VALIDATE _IP , $ which ) ; } 
public function valid _url ( string $ str = null ) : bool { if ( empty ( $ str ) ) { return false ; } elseif ( preg _match ( ' / ^ ( ? : ( [ ^ : ] * ) \ : ) ? \ / \ / ( . + ) $ / ' , $ str , $ matches ) ) { if ( ! in _array ( $ matches [ 1 ] , [ 'http ' , 'https ' ] , true ) ) { return false ; } $ str = $ matches [ 2 ] ; } $ str = 'http : / / ' . $ str ; return ( filter _var ( $ str , FILTER _VALIDATE _URL ) ! = = false ) ; } 
public function valid _date ( string $ str = null , string $ format = null ) : bool { if ( empty ( $ format ) ) { return ( bool ) strtotime ( $ str ) ; } $ date = \ Date Time : : create From Format ( $ format , $ str ) ; return ( bool ) $ date & & \ Date Time : : get Last Errors ( ) [ 'warning _count ' ] = = = 0 & & \ Date Time : : get Last Errors ( ) [ 'error _count ' ] = = = 0 ; } 
public function drop Database ( string $ db _name ) : bool { 
protected function _alter Table ( string $ alter _type , string $ table , $ field ) { switch ( $ alter _type ) { case 'DROP ' : $ sql Table = new Table ( $ this - > db , $ this ) ; $ sql Table - > from Table ( $ table ) - > drop Column ( $ field ) - > run ( ) ; return ' ' ; break ; case 'CHANGE ' : $ sql Table = new Table ( $ this - > db , $ this ) ; $ sql Table - > from Table ( $ table ) - > modify Column ( $ field ) - > run ( ) ; return null ; break ; default : return parent : : _alter Table ( $ alter _type , $ table , $ field ) ; } } 
protected function _process Column ( array $ field ) : string { if ( $ field [ 'type ' ] = = = 'TEXT ' & & strpos ( $ field [ 'length ' ] , " ( ' " ) = = = 0 ) { $ field [ 'type ' ] . = ' CHECK ( ' . $ this - > db - > escape Identifiers ( $ field [ 'name ' ] ) . ' IN ' . $ field [ 'length ' ] . ' ) ' ; } return $ this - > db - > escape Identifiers ( $ field [ 'name ' ] ) . ' ' . $ field [ 'type ' ] . $ field [ 'auto _increment ' ] . $ field [ 'null ' ] . $ field [ 'unique ' ] . $ field [ 'default ' ] ; } 
protected function _attribute Auto Increment ( array & $ attributes , array & $ field ) { if ( ! empty ( $ attributes [ 'AUTO _INCREMENT ' ] ) & & $ attributes [ 'AUTO _INCREMENT ' ] = = = true & & stripos ( $ field [ 'type ' ] , 'int ' ) ! = = false ) { $ field [ 'type ' ] = 'INTEGER PRIMARY KEY ' ; $ field [ 'default ' ] = ' ' ; $ field [ 'null ' ] = ' ' ; $ field [ 'unique ' ] = ' ' ; $ field [ 'auto _increment ' ] = ' AUTOINCREMENT ' ; $ this - > primary Keys = [ ] ; } } 
public function _prepare ( string $ sql , array $ options = [ ] ) { 
public function _execute ( array $ data ) : bool { if ( is _null ( $ this - > statement ) ) { throw new \ Bad Method Call Exception ( 'You must call prepare before trying to execute a prepared statement . ' ) ; } 
public static function for Move Failed ( string $ source , string $ target , string $ error ) { return new static ( lang ( 'HTTP .move Failed ' , [ $ source , $ target , $ error ] ) ) ; } 
public function valid _cc _number ( string $ cc Number = null , string $ type , array $ data ) : bool { $ type = strtolower ( $ type ) ; $ info = null ; 
protected function is Valid Luhn ( string $ number = null ) : bool { settype ( $ number , 'string ' ) ; $ sum Table = [ [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , ] , [ 0 , 2 , 4 , 6 , 8 , 1 , 3 , 5 , 7 , 9 , ] , ] ; $ sum = 0 ; $ flip = 0 ; for ( $ i = strlen ( $ number ) - 1 ; $ i > = 0 ; $ i - - ) { $ sum + = $ sum Table [ $ flip + + & 0x 1 ] [ $ number [ $ i ] ] ; } return $ sum % 1 0 = = = 0 ; } 
protected static function move File ( string $ source , string $ destination ) : bool { $ source = realpath ( $ source ) ; if ( empty ( $ source ) ) { die ( 'Cannot move file . Source path invalid . ' ) ; } if ( ! is _file ( $ source ) ) { return false ; } return copy ( $ source , $ destination ) ; } 
public static function move Escaper ( ) { if ( class _exists ( ' \ \Zend \ \Escaper \ \Escaper ' ) & & is _file ( static : : get Class File Path ( ' \ \Zend \ \Escaper \ \Escaper ' ) ) ) { $ base = basename ( _ _DIR _ _ ) . ' / ' . static : : $ base Path . 'Zend Escaper ' ; foreach ( [ $ base , $ base . ' /Exception ' ] as $ path ) { if ( ! is _dir ( $ path ) ) { mkdir ( $ path , 0 7 5 5 ) ; } } $ files = [ static : : get Class File Path ( ' \ \Zend \ \Escaper \ \Exception \ \Exception Interface ' ) = > $ base . ' /Exception /Exception Interface .php ' , static : : get Class File Path ( ' \ \Zend \ \Escaper \ \Exception \ \Invalid Argument Exception ' ) = > $ base . ' /Exception /Invalid Argument Exception .php ' , static : : get Class File Path ( ' \ \Zend \ \Escaper \ \Exception \ \Runtime Exception ' ) = > $ base . ' /Exception /Runtime Exception .php ' , static : : get Class File Path ( ' \ \Zend \ \Escaper \ \Escaper ' ) = > $ base . ' /Escaper .php ' , ] ; foreach ( $ files as $ source = > $ dest ) { if ( ! static : : move File ( $ source , $ dest ) ) { die ( 'Error moving : ' . $ source ) ; } } } } 
public static function move Kint ( ) { $ filename = 'vendor /kint -php /kint /build /kint -aante -light .php ' ; if ( is _file ( $ filename ) ) { $ base = basename ( _ _DIR _ _ ) . ' / ' . static : : $ base Path . 'Kint ' ; 
public function start ( ) { if ( is _cli ( ) & & ENVIRONMENT ! = = 'testing ' ) { $ this - > logger - > debug ( 'Session : Initialization under CLI aborted . ' ) ; return ; } elseif ( ( bool ) ini _get ( 'session .auto _start ' ) ) { $ this - > logger - > error ( 'Session : session .auto _start is enabled in php .ini . Aborting . ' ) ; return ; } elseif ( session _status ( ) = = = PHP _SESSION _ACTIVE ) { $ this - > logger - > warning ( 'Session : Sessions is enabled , and one exists .Please don \ 't $session - >start ( ) ; ' ) ; return ; } if ( ! $ this - > driver instanceof \ Session Handler Interface ) { $ this - > logger - > error ( "Session : Handler ' " . $ this - > driver . " ' doesn 't implement Session Handler Interface . Aborting . " ) ; } $ this - > configure ( ) ; $ this - > set Save Handler ( ) ; / / Sanitize the cookie , because apparently PHP doesn 't do that for userspace handlers if ( isset ( $ _COOKIE [ $ this - > session Cookie Name ] ) & & ( ! is _string ( $ _COOKIE [ $ this - > session Cookie Name ] ) | | ! preg _match ( ' # \A ' . $ this - > sid Regexp . ' \z # ' , $ _COOKIE [ $ this - > session Cookie Name ] ) ) ) { unset ( $ _COOKIE [ $ this - > session Cookie Name ] ) ; } $ this - > start Session ( ) ; / / Is session ID auto -regeneration configured ? (ignoring ajax requests ) if ( ( empty ( $ _SERVER [ 'HTTP _X _REQUESTED _WITH ' ] ) | | strtolower ( $ _SERVER [ 'HTTP _X _REQUESTED _WITH ' ] ) ! = = 'xmlhttprequest ' ) & & ( $ regenerate _time = $ this - > session Time To Update ) > 0 ) { if ( ! isset ( $ _SESSION [ ' _ _ci _last _regenerate ' ] ) ) { $ _SESSION [ ' _ _ci _last _regenerate ' ] = time ( ) ; } elseif ( $ _SESSION [ ' _ _ci _last _regenerate ' ] < ( time ( ) - $ regenerate _time ) ) { $ this - > regenerate ( ( bool ) $ this - > session Regenerate Destroy ) ; } } / / Another work -around . . . PHP doesn 't seem to send the session cookie / / unless it is being currently created or regenerated elseif ( isset ( $ _COOKIE [ $ this - > session Cookie Name ] ) & & $ _COOKIE [ $ this - > session Cookie Name ] = = = session _id ( ) ) { $ this - > set Cookie ( ) ; } $ this - > init Vars ( ) ; $ this - > logger - > info ( "Session : Class initialized using ' " . $ this - > session Driver Name . " ' driver . " ) ; return $ this ; } 
public function stop ( ) { setcookie ( $ this - > session Cookie Name , session _id ( ) , 1 , $ this - > cookie Path , $ this - > cookie Domain , $ this - > cookie Secure , true ) ; session _regenerate _id ( true ) ; } 
protected function configure ( ) { if ( empty ( $ this - > session Cookie Name ) ) { $ this - > session Cookie Name = ini _get ( 'session .name ' ) ; } else { ini _set ( 'session .name ' , $ this - > session Cookie Name ) ; } session _set _cookie _params ( $ this - > session Expiration , $ this - > cookie Path , $ this - > cookie Domain , $ this - > cookie Secure , true 
protected function configure Sid Length ( ) { $ bits _per _character = ( int ) ( ini _get ( 'session .sid _bits _per _character ' ) ! = = false ? ini _get ( 'session .sid _bits _per _character ' ) : 4 ) ; $ sid _length = ( int ) ( ini _get ( 'session .sid _length ' ) ! = = false ? ini _get ( 'session .sid _length ' ) : 4 0 ) ; if ( ( $ sid _length * $ bits _per _character ) < 1 6 0 ) { $ bits = ( $ sid _length * $ bits _per _character ) ; 
protected function init Vars ( ) { if ( empty ( $ _SESSION [ ' _ _ci _vars ' ] ) ) { return ; } $ current _time = time ( ) ; foreach ( $ _SESSION [ ' _ _ci _vars ' ] as $ key = > & $ value ) { if ( $ value = = = 'new ' ) { $ _SESSION [ ' _ _ci _vars ' ] [ $ key ] = 'old ' ; } 
public function set ( $ data , $ value = null ) { if ( is _array ( $ data ) ) { foreach ( $ data as $ key = > & $ value ) { if ( is _int ( $ key ) ) { $ _SESSION [ $ value ] = null ; } else { $ _SESSION [ $ key ] = $ value ; } } return ; } $ _SESSION [ $ data ] = $ value ; } 
public function get ( string $ key = null ) { if ( ! empty ( $ key ) & & $ value = dot _array _search ( $ key , $ _SESSION ) ) { return $ value ; } elseif ( empty ( $ _SESSION ) ) { return [ ] ; } if ( ! empty ( $ key ) ) { return null ; } $ userdata = [ ] ; $ _exclude = array _merge ( [ ' _ _ci _vars ' ] , $ this - > get Flash Keys ( ) , $ this - > get Temp Keys ( ) ) ; $ keys = array _keys ( $ _SESSION ) ; foreach ( $ keys as $ key ) { if ( ! in _array ( $ key , $ _exclude , true ) ) { $ userdata [ $ key ] = $ _SESSION [ $ key ] ; } } return $ userdata ; } 
public function push ( string $ key , array $ data ) { if ( $ this - > has ( $ key ) & & is _array ( $ value = $ this - > get ( $ key ) ) ) { $ this - > set ( $ key , array _merge ( $ value , $ data ) ) ; } } 
public function remove ( $ key ) { if ( is _array ( $ key ) ) { foreach ( $ key as $ k ) { unset ( $ _SESSION [ $ k ] ) ; } return ; } unset ( $ _SESSION [ $ key ] ) ; } 
public function set Flashdata ( $ data , $ value = null ) { $ this - > set ( $ data , $ value ) ; $ this - > mark As Flashdata ( is _array ( $ data ) ? array _keys ( $ data ) : $ data ) ; } 
public function get Flashdata ( string $ key = null ) { if ( isset ( $ key ) ) { return ( isset ( $ _SESSION [ ' _ _ci _vars ' ] , $ _SESSION [ ' _ _ci _vars ' ] [ $ key ] , $ _SESSION [ $ key ] ) & & ! is _int ( $ _SESSION [ ' _ _ci _vars ' ] [ $ key ] ) ) ? $ _SESSION [ $ key ] : null ; } $ flashdata = [ ] ; if ( ! empty ( $ _SESSION [ ' _ _ci _vars ' ] ) ) { foreach ( $ _SESSION [ ' _ _ci _vars ' ] as $ key = > & $ value ) { is _int ( $ value ) | | $ flashdata [ $ key ] = $ _SESSION [ $ key ] ; } } return $ flashdata ; } 
public function mark As Flashdata ( $ key ) : bool { if ( is _array ( $ key ) ) { for ( $ i = 0 , $ c = count ( $ key ) ; $ i < $ c ; $ i + + ) { if ( ! isset ( $ _SESSION [ $ key [ $ i ] ] ) ) { return false ; } } $ new = array _fill _keys ( $ key , 'new ' ) ; $ _SESSION [ ' _ _ci _vars ' ] = isset ( $ _SESSION [ ' _ _ci _vars ' ] ) ? array _merge ( $ _SESSION [ ' _ _ci _vars ' ] , $ new ) : $ new ; return true ; } if ( ! isset ( $ _SESSION [ $ key ] ) ) { return false ; } $ _SESSION [ ' _ _ci _vars ' ] [ $ key ] = 'new ' ; return true ; } 
public function get Flash Keys ( ) : array { if ( ! isset ( $ _SESSION [ ' _ _ci _vars ' ] ) ) { return [ ] ; } $ keys = [ ] ; foreach ( array _keys ( $ _SESSION [ ' _ _ci _vars ' ] ) as $ key ) { is _int ( $ _SESSION [ ' _ _ci _vars ' ] [ $ key ] ) | | $ keys [ ] = $ key ; } return $ keys ; } 
public function set Tempdata ( $ data , $ value = null , int $ ttl = 3 0 0 ) { $ this - > set ( $ data , $ value ) ; $ this - > mark As Tempdata ( $ data , $ ttl ) ; } 
public function get Tempdata ( string $ key = null ) { if ( isset ( $ key ) ) { return ( isset ( $ _SESSION [ ' _ _ci _vars ' ] , $ _SESSION [ ' _ _ci _vars ' ] [ $ key ] , $ _SESSION [ $ key ] ) & & is _int ( $ _SESSION [ ' _ _ci _vars ' ] [ $ key ] ) ) ? $ _SESSION [ $ key ] : null ; } $ tempdata = [ ] ; if ( ! empty ( $ _SESSION [ ' _ _ci _vars ' ] ) ) { foreach ( $ _SESSION [ ' _ _ci _vars ' ] as $ key = > & $ value ) { is _int ( $ value ) & & $ tempdata [ $ key ] = $ _SESSION [ $ key ] ; } } return $ tempdata ; } 
public function mark As Tempdata ( $ key , int $ ttl = 3 0 0 ) : bool { $ ttl + = time ( ) ; if ( is _array ( $ key ) ) { $ temp = [ ] ; foreach ( $ key as $ k = > $ v ) { 
public function unmark Tempdata ( $ key ) { if ( empty ( $ _SESSION [ ' _ _ci _vars ' ] ) ) { return ; } is _array ( $ key ) | | $ key = [ $ key ] ; foreach ( $ key as $ k ) { if ( isset ( $ _SESSION [ ' _ _ci _vars ' ] [ $ k ] ) & & is _int ( $ _SESSION [ ' _ _ci _vars ' ] [ $ k ] ) ) { unset ( $ _SESSION [ ' _ _ci _vars ' ] [ $ k ] ) ; } } if ( empty ( $ _SESSION [ ' _ _ci _vars ' ] ) ) { unset ( $ _SESSION [ ' _ _ci _vars ' ] ) ; } } 
public function get Temp Keys ( ) : array { if ( ! isset ( $ _SESSION [ ' _ _ci _vars ' ] ) ) { return [ ] ; } $ keys = [ ] ; foreach ( array _keys ( $ _SESSION [ ' _ _ci _vars ' ] ) as $ key ) { is _int ( $ _SESSION [ ' _ _ci _vars ' ] [ $ key ] ) & & $ keys [ ] = $ key ; } return $ keys ; } 
protected function set Cookie ( ) { setcookie ( $ this - > session Cookie Name , session _id ( ) , ( empty ( $ this - > session Expiration ) ? 0 : time ( ) + $ this - > session Expiration ) , $ this - > cookie Path , $ this - > cookie Domain , $ this - > cookie Secure , true ) ; } 
public function check ( string $ key , int $ capacity , int $ seconds , int $ cost = 1 ) : bool { $ token Name = $ this - > prefix . $ key ; 
public static function guess Type From Extension ( string $ extension ) { $ extension = trim ( strtolower ( $ extension ) , ' . ' ) ; if ( ! array _key _exists ( $ extension , static : : $ mimes ) ) { return null ; } return is _array ( static : : $ mimes [ $ extension ] ) ? static : : $ mimes [ $ extension ] [ 0 ] : static : : $ mimes [ $ extension ] ; } 
public static function guess Extension From Type ( string $ type , ? string $ proposed _extension = null ) { $ type = trim ( strtolower ( $ type ) , ' . ' ) ; $ proposed _extension = trim ( strtolower ( $ proposed _extension ) ) ; if ( ! is _null ( $ proposed _extension ) & & array _key _exists ( $ proposed _extension , static : : $ mimes ) & & in _array ( $ type , is _string ( static : : $ mimes [ $ proposed _extension ] ) ? [ static : : $ mimes [ $ proposed _extension ] ] : static : : $ mimes [ $ proposed _extension ] ) ) { return $ proposed _extension ; } foreach ( static : : $ mimes as $ ext = > $ types ) { if ( is _string ( $ types ) & & $ types = = = $ type ) { return $ ext ; } else if ( is _array ( $ types ) & & in _array ( $ type , $ types ) ) { return $ ext ; } } return null ; } 
public function to ( string $ uri , int $ code = null , string $ method = 'auto ' ) { 
public function route ( string $ route , array $ params = [ ] , int $ code = 3 0 2 , string $ method = 'auto ' ) { $ routes = Services : : routes ( true ) ; $ route = $ routes - > reverse Route ( $ route , . . . $ params ) ; if ( ! $ route ) { throw HTTPException : : for Invalid Redirect Route ( $ route ) ; } return $ this - > redirect ( base _url ( $ route ) , $ method , $ code ) ; } 
public function back ( int $ code = null , string $ method = 'auto ' ) { $ this - > ensure Session ( ) ; return $ this - > redirect ( previous _url ( ) , $ method , $ code ) ; } 
public function with Input ( ) { $ session = $ this - > ensure Session ( ) ; $ input = [ 'get ' = > $ _GET ? ? [ ] , 'post ' = > $ _POST ? ? [ ] , ] ; $ session - > set Flashdata ( ' _ci _old _input ' , $ input ) ; 
public function with ( string $ key , $ message ) { $ session = $ this - > ensure Session ( ) ; $ session - > set Flashdata ( $ key , $ message ) ; return $ this ; } 
public function run ( string $ uri , string $ position = 'before ' ) { $ this - > initialize ( strtolower ( $ uri ) ) ; foreach ( $ this - > filters [ $ position ] as $ alias = > $ rules ) { if ( is _numeric ( $ alias ) & & is _string ( $ rules ) ) { $ alias = $ rules ; } if ( ! array _key _exists ( $ alias , $ this - > config - > aliases ) ) { throw Filter Exception : : for No Alias ( $ alias ) ; } $ class = new $ this - > config - > aliases [ $ alias ] ( ) ; if ( ! $ class instanceof Filter Interface ) { throw Filter Exception : : for Incorrect Interface ( get _class ( $ class ) ) ; } if ( $ position = = = 'before ' ) { $ result = $ class - > before ( $ this - > request , $ this - > arguments [ $ alias ] ? ? null ) ; if ( $ result instanceof Request Interface ) { $ this - > request = $ result ; continue ; } 
public function initialize ( string $ uri = null ) { if ( $ this - > initialized = = = true ) { return $ this ; } $ this - > process Globals ( $ uri ) ; $ this - > process Methods ( ) ; $ this - > process Filters ( $ uri ) ; $ this - > initialized = true ; return $ this ; } 
public function add Filter ( string $ class , string $ alias = null , string $ when = 'before ' , string $ section = 'globals ' ) { $ alias = $ alias ? ? md 5 ( $ class ) ; if ( ! isset ( $ this - > config - > { $ section } ) ) { $ this - > config - > { $ section } = [ ] ; } if ( ! isset ( $ this - > config - > { $ section } [ $ when ] ) ) { $ this - > config - > { $ section } [ $ when ] = [ ] ; } $ this - > config - > aliases [ $ alias ] = $ class ; $ this - > config - > { $ section } [ $ when ] [ ] = $ alias ; return $ this ; } 
public function enable Filter ( string $ name , string $ when = 'before ' ) { 
public function get Arguments ( string $ key = null ) { return is _null ( $ key ) ? $ this - > arguments : $ this - > arguments [ $ key ] ; } 
protected function process Globals ( string $ uri = null ) { if ( ! isset ( $ this - > config - > globals ) | | ! is _array ( $ this - > config - > globals ) ) { return ; } 
protected function process Methods ( ) { if ( ! isset ( $ this - > config - > methods ) | | ! is _array ( $ this - > config - > methods ) ) { return ; } 
protected function process Filters ( string $ uri = null ) { if ( ! isset ( $ this - > config - > filters ) | | ! $ this - > config - > filters ) { return ; } $ uri = strtolower ( trim ( $ uri , ' / ' ) ) ; $ matches = [ ] ; foreach ( $ this - > config - > filters as $ alias = > $ settings ) { 
public function handle ( $ level , $ message ) : bool { 
protected function format ( $ object ) { if ( ! is _object ( $ object ) ) { return $ object ; } 
public function send Logs ( Response Interface & $ response = null ) { if ( is _null ( $ response ) ) { $ response = Services : : response ( null , true ) ; } $ data = base 6 4 _encode ( utf 8 _encode ( json _encode ( $ this - > json ) ) ) ; $ response - > set Header ( $ this - > header , $ data ) ; } 
protected function _create Table Attributes ( array $ attributes ) : string { $ sql = ' ' ; foreach ( array _keys ( $ attributes ) as $ key ) { if ( is _string ( $ key ) ) { $ sql . = ' ' . strtoupper ( $ key ) . ' = ' ; if ( in _array ( strtoupper ( $ key ) , $ this - > _quoted _table _options ) ) { $ sql . = $ this - > db - > escape ( $ attributes [ $ key ] ) ; } else { $ sql . = $ this - > db - > escape String ( $ attributes [ $ key ] ) ; } } } if ( ! empty ( $ this - > db - > charset ) & & ! strpos ( $ sql , 'CHARACTER SET ' ) & & ! strpos ( $ sql , 'CHARSET ' ) ) { $ sql . = ' DEFAULT CHARACTER SET = ' . $ this - > db - > escape String ( $ this - > db - > charset ) ; } if ( ! empty ( $ this - > db - > DBCollat ) & & ! strpos ( $ sql , 'COLLATE ' ) ) { $ sql . = ' COLLATE = ' . $ this - > db - > escape String ( $ this - > db - > DBCollat ) ; } return $ sql ; } 
protected function _alter Table ( string $ alter _type , string $ table , $ field ) { if ( $ alter _type = = = 'DROP ' ) { return parent : : _alter Table ( $ alter _type , $ table , $ field ) ; } $ sql = 'ALTER TABLE ' . $ this - > db - > escape Identifiers ( $ table ) ; foreach ( $ field as $ i = > $ data ) { if ( $ data [ ' _literal ' ] ! = = false ) { $ field [ $ i ] = ( $ alter _type = = = 'ADD ' ) ? " \n \t ADD " . $ data [ ' _literal ' ] : " \n \t MODIFY " . $ data [ ' _literal ' ] ; } else { if ( $ alter _type = = = 'ADD ' ) { $ field [ $ i ] [ ' _literal ' ] = " \n \t ADD " ; } else { $ field [ $ i ] [ ' _literal ' ] = empty ( $ data [ 'new _name ' ] ) ? " \n \t MODIFY " : " \n \t CHANGE " ; } $ field [ $ i ] = $ field [ $ i ] [ ' _literal ' ] . $ this - > _process Column ( $ field [ $ i ] ) ; } } return [ $ sql . implode ( ' , ' , $ field ) ] ; } 
protected function _process Column ( array $ field ) : string { $ extra _clause = isset ( $ field [ 'after ' ] ) ? ' AFTER ' . $ this - > db - > escape Identifiers ( $ field [ 'after ' ] ) : ' ' ; if ( empty ( $ extra _clause ) & & isset ( $ field [ 'first ' ] ) & & $ field [ 'first ' ] = = = true ) { $ extra _clause = ' FIRST ' ; } return $ this - > db - > escape Identifiers ( $ field [ 'name ' ] ) . ( empty ( $ field [ 'new _name ' ] ) ? ' ' : ' ' . $ this - > db - > escape Identifiers ( $ field [ 'new _name ' ] ) ) . ' ' . $ field [ 'type ' ] . $ field [ 'length ' ] . $ field [ 'unsigned ' ] . $ field [ 'null ' ] . $ field [ 'default ' ] . $ field [ 'auto _increment ' ] . $ field [ 'unique ' ] . ( empty ( $ field [ 'comment ' ] ) ? ' ' : ' COMMENT ' . $ field [ 'comment ' ] ) . $ extra _clause ; } 
protected function _process Indexes ( string $ table ) : string { $ sql = ' ' ; for ( $ i = 0 , $ c = count ( $ this - > keys ) ; $ i < $ c ; $ i + + ) { if ( is _array ( $ this - > keys [ $ i ] ) ) { for ( $ i 2 = 0 , $ c 2 = count ( $ this - > keys [ $ i ] ) ; $ i 2 < $ c 2 ; $ i 2 + + ) { if ( ! isset ( $ this - > fields [ $ this - > keys [ $ i ] [ $ i 2 ] ] ) ) { unset ( $ this - > keys [ $ i ] [ $ i 2 ] ) ; continue ; } } } elseif ( ! isset ( $ this - > fields [ $ this - > keys [ $ i ] ] ) ) { unset ( $ this - > keys [ $ i ] ) ; continue ; } is _array ( $ this - > keys [ $ i ] ) | | $ this - > keys [ $ i ] = [ $ this - > keys [ $ i ] ] ; $ unique = in _array ( $ i , $ this - > unique Keys ) ? 'UNIQUE ' : ' ' ; $ sql . = " , \n \t { $unique }KEY " . $ this - > db - > escape Identifiers ( implode ( ' _ ' , $ this - > keys [ $ i ] ) ) . ' ( ' . implode ( ' , ' , $ this - > db - > escape Identifiers ( $ this - > keys [ $ i ] ) ) . ' ) ' ; } $ this - > keys = [ ] ; return $ sql ; } 
public function detect Locale ( $ config ) { $ this - > locale = $ this - > default Locale = $ config - > default Locale ; if ( ! $ config - > negotiate Locale ) { return ; } $ this - > set Locale ( $ this - > negotiate ( 'language ' , $ config - > supported Locales ) ) ; } 
public function set Locale ( string $ locale ) { 
public function is Secure ( ) : bool { if ( ! empty ( $ _SERVER [ 'HTTPS ' ] ) & & strtolower ( $ _SERVER [ 'HTTPS ' ] ) ! = = 'off ' ) { return true ; } elseif ( isset ( $ _SERVER [ 'HTTP _X _FORWARDED _PROTO ' ] ) & & $ _SERVER [ 'HTTP _X _FORWARDED _PROTO ' ] = = = 'https ' ) { return true ; } elseif ( ! empty ( $ _SERVER [ 'HTTP _FRONT _END _HTTPS ' ] ) & & strtolower ( $ _SERVER [ 'HTTP _FRONT _END _HTTPS ' ] ) ! = = 'off ' ) { return true ; } return false ; } 
public function get Var ( $ index = null , $ filter = null , $ flags = null ) { return $ this - > fetch Global ( 'request ' , $ index , $ filter , $ flags ) ; } 
public function get JSON ( bool $ assoc = false , int $ depth = 5 1 2 , int $ options = 0 ) { return json _decode ( $ this - > body , $ assoc , $ depth , $ options ) ; } 
public function get Get ( $ index = null , $ filter = null , $ flags = null ) { return $ this - > fetch Global ( 'get ' , $ index , $ filter , $ flags ) ; } 
public function get Post ( $ index = null , $ filter = null , $ flags = null ) { return $ this - > fetch Global ( 'post ' , $ index , $ filter , $ flags ) ; } 
public function get Post Get ( $ index = null , $ filter = null , $ flags = null ) { 
public function get Get Post ( $ index = null , $ filter = null , $ flags = null ) { 
public function get Cookie ( $ index = null , $ filter = null , $ flags = null ) { return $ this - > fetch Global ( 'cookie ' , $ index , $ filter , $ flags ) ; } 
public function get Old Input ( string $ key ) { 
public function get Files ( ) : array { if ( is _null ( $ this - > files ) ) { $ this - > files = new File Collection ( ) ; } return $ this - > files - > all ( ) ; 
public function get File ( string $ file ID ) { if ( is _null ( $ this - > files ) ) { $ this - > files = new File Collection ( ) ; } return $ this - > files - > get File ( $ file ID ) ; } 
protected function detect URI ( string $ protocol , string $ base URL ) { $ this - > uri - > set Path ( $ this - > detect Path ( $ protocol ) ) ; 
public function detect Path ( string $ protocol = ' ' ) : string { if ( empty ( $ protocol ) ) { $ protocol = 'REQUEST _URI ' ; } switch ( $ protocol ) { case 'REQUEST _URI ' : $ path = $ this - > parse Request URI ( ) ; break ; case 'QUERY _STRING ' : $ path = $ this - > parse Query String ( ) ; break ; case 'PATH _INFO ' : default : $ path = $ this - > fetch Global ( 'server ' , $ protocol ) ? ? $ this - > parse Request URI ( ) ; break ; } return $ path ; } 
public function negotiate ( string $ type , array $ supported , bool $ strict Match = false ) : string { if ( is _null ( $ this - > negotiator ) ) { $ this - > negotiator = Services : : negotiator ( $ this , true ) ; } switch ( strtolower ( $ type ) ) { case 'media ' : return $ this - > negotiator - > media ( $ supported , $ strict Match ) ; case 'charset ' : return $ this - > negotiator - > charset ( $ supported ) ; case 'encoding ' : return $ this - > negotiator - > encoding ( $ supported ) ; case 'language ' : return $ this - > negotiator - > language ( $ supported ) ; } throw HTTPException : : for Invalid Negotiation Type ( $ type ) ; } 
protected function parse Request URI ( ) : string { if ( ! isset ( $ _SERVER [ 'REQUEST _URI ' ] , $ _SERVER [ 'SCRIPT _NAME ' ] ) ) { return ' ' ; } 
protected function parse Query String ( ) : string { $ uri = $ _SERVER [ 'QUERY _STRING ' ] ? ? @ getenv ( 'QUERY _STRING ' ) ; if ( trim ( $ uri , ' / ' ) = = = ' ' ) { return ' ' ; } elseif ( strncmp ( $ uri , ' / ' , 1 ) = = = 0 ) { $ uri = explode ( ' ? ' , $ uri , 2 ) ; $ _SERVER [ 'QUERY _STRING ' ] = $ uri [ 1 ] ? ? ' ' ; $ uri = $ uri [ 0 ] ; } parse _str ( $ _SERVER [ 'QUERY _STRING ' ] , $ _GET ) ; return $ this - > remove Relative Directory ( $ uri ) ; } 
protected function remove Relative Directory ( string $ uri ) : string { $ uris = [ ] ; $ tok = strtok ( $ uri , ' / ' ) ; while ( $ tok ! = = false ) { if ( ( ! empty ( $ tok ) | | $ tok = = = ' 0 ' ) & & $ tok ! = = ' . . ' ) { $ uris [ ] = $ tok ; } $ tok = strtok ( ' / ' ) ; } return implode ( ' / ' , $ uris ) ; } 
public function open ( $ save _path , $ name ) : bool { if ( empty ( $ this - > save Path ) ) { return false ; } $ redis = new \ Redis ( ) ; if ( ! $ redis - > connect ( $ this - > save Path [ 'host ' ] , $ this - > save Path [ 'port ' ] , $ this - > save Path [ 'timeout ' ] ) ) { $ this - > logger - > error ( 'Session : Unable to connect to Redis with the configured settings . ' ) ; } elseif ( isset ( $ this - > save Path [ 'password ' ] ) & & ! $ redis - > auth ( $ this - > save Path [ 'password ' ] ) ) { $ this - > logger - > error ( 'Session : Unable to authenticate to Redis instance . ' ) ; } elseif ( isset ( $ this - > save Path [ 'database ' ] ) & & ! $ redis - > select ( $ this - > save Path [ 'database ' ] ) ) { $ this - > logger - > error ( 'Session : Unable to select Redis database with index ' . $ this - > save Path [ 'database ' ] ) ; } else { $ this - > redis = $ redis ; return true ; } return false ; } 
public function read ( $ session ID ) : string { if ( isset ( $ this - > redis ) & & $ this - > lock Session ( $ session ID ) ) { 
public function write ( $ session ID , $ session Data ) : bool { if ( ! isset ( $ this - > redis ) ) { return false ; } 
public function close ( ) : bool { if ( isset ( $ this - > redis ) ) { try { if ( $ this - > redis - > ping ( ) = = = ' +PONG ' ) { isset ( $ this - > lock Key ) & & $ this - > redis - > delete ( $ this - > lock Key ) ; if ( ! $ this - > redis - > close ( ) ) { return false ; } } } catch ( \ Redis Exception $ e ) { $ this - > logger - > error ( 'Session : Got Redis Exception on close ( ) : ' . $ e - > get Message ( ) ) ; } $ this - > redis = null ; return true ; } return true ; } 
public function destroy ( $ session ID ) : bool { if ( isset ( $ this - > redis , $ this - > lock Key ) ) { if ( ( $ result = $ this - > redis - > delete ( $ this - > key Prefix . $ session ID ) ) ! = = 1 ) { $ this - > logger - > debug ( 'Session : Redis : :delete ( ) expected to return 1 , got ' . var _export ( $ result , true ) . ' instead . ' ) ; } return $ this - > destroy Cookie ( ) ; } return false ; } 
protected function lock Session ( string $ session ID ) : bool { 
protected function release Lock ( ) : bool { if ( isset ( $ this - > redis , $ this - > lock Key ) & & $ this - > lock ) { if ( ! $ this - > redis - > delete ( $ this - > lock Key ) ) { $ this - > logger - > error ( 'Session : Error while trying to free lock for ' . $ this - > lock Key ) ; return false ; } $ this - > lock Key = null ; $ this - > lock = false ; } return true ; } 
public function _prepare ( string $ sql , array $ options = [ ] ) { if ( ! ( $ this - > statement = $ this - > db - > conn ID - > prepare ( $ sql ) ) ) { $ this - > error Code = $ this - > db - > conn ID - > last Error Code ( ) ; $ this - > error String = $ this - > db - > conn ID - > last Error Msg ( ) ; } return $ this ; } 
public function _execute ( array $ data ) : bool { if ( is _null ( $ this - > statement ) ) { throw new \ Bad Method Call Exception ( 'You must call prepare before trying to execute a prepared statement . ' ) ; } foreach ( $ data as $ key = > $ item ) { 
protected function format Timeline Data ( ) : array { $ data = [ ] ; $ benchmark = Services : : timer ( true ) ; $ rows = $ benchmark - > get Timers ( 6 ) ; foreach ( $ rows as $ name = > $ info ) { if ( $ name = = = 'total _execution ' ) { continue ; } $ data [ ] = [ 'name ' = > ucwords ( str _replace ( ' _ ' , ' ' , $ name ) ) , 'component ' = > 'Timer ' , 'start ' = > $ info [ 'start ' ] , 'duration ' = > $ info [ 'end ' ] - $ info [ 'start ' ] , ] ; } return $ data ; } 
public function connect ( bool $ persistent = false ) { if ( empty ( $ this - > DSN ) ) { $ this - > build DSN ( ) ; } 
public function get Version ( ) : string { if ( isset ( $ this - > data Cache [ 'version ' ] ) ) { return $ this - > data Cache [ 'version ' ] ; } if ( ! $ this - > conn ID | | ( $ pg Version = pg _version ( $ this - > conn ID ) ) = = = false ) { $ this - > initialize ( ) ; } return isset ( $ pg Version [ 'server ' ] ) ? $ this - > data Cache [ 'version ' ] = $ pg Version [ 'server ' ] : false ; } 
public function escape ( $ str ) { if ( ! $ this - > conn ID ) { $ this - > initialize ( ) ; } if ( is _string ( $ str ) | | ( is _object ( $ str ) & & method _exists ( $ str , ' _ _to String ' ) ) ) { return pg _escape _literal ( $ this - > conn ID , $ str ) ; } elseif ( is _bool ( $ str ) ) { return $ str ? 'TRUE ' : 'FALSE ' ; } return parent : : escape ( $ str ) ; } 
protected function _escape String ( string $ str ) : string { if ( ! $ this - > conn ID ) { $ this - > initialize ( ) ; } return pg _escape _string ( $ this - > conn ID , $ str ) ; } 
protected function _list Columns ( string $ table = ' ' ) : string { return 'SELECT "column _name " FROM "information _schema " . "columns " WHERE LOWER ( "table _name " ) = ' . $ this - > escape ( $ this - > DBPrefix . strtolower ( $ table ) ) ; } 
public function _field Data ( string $ table ) : array { $ sql = 'SELECT "column _name " , "data _type " , "character _maximum _length " , "numeric _precision " , "column _default " FROM "information _schema " . "columns " WHERE LOWER ( "table _name " ) = ' . $ this - > escape ( strtolower ( $ table ) ) ; if ( ( $ query = $ this - > query ( $ sql ) ) = = = false ) { throw new Database Exception ( lang ( 'Database .fail Get Field Data ' ) ) ; } $ query = $ query - > get Result Object ( ) ; $ ret Val = [ ] ; for ( $ i = 0 , $ c = count ( $ query ) ; $ i < $ c ; $ i + + ) { $ ret Val [ $ i ] = new \ std Class ( ) ; $ ret Val [ $ i ] - > name = $ query [ $ i ] - > column _name ; $ ret Val [ $ i ] - > type = $ query [ $ i ] - > data _type ; $ ret Val [ $ i ] - > default = $ query [ $ i ] - > column _default ; $ ret Val [ $ i ] - > max _length = $ query [ $ i ] - > character _maximum _length > 0 ? $ query [ $ i ] - > character _maximum _length : $ query [ $ i ] - > numeric _precision ; } return $ ret Val ; } 
public function _index Data ( string $ table ) : array { $ sql = 'SELECT "indexname " , "indexdef " FROM "pg _indexes " WHERE LOWER ( "tablename " ) = ' . $ this - > escape ( strtolower ( $ table ) ) . ' AND "schemaname " = ' . $ this - > escape ( 'public ' ) ; if ( ( $ query = $ this - > query ( $ sql ) ) = = = false ) { throw new Database Exception ( lang ( 'Database .fail Get Index Data ' ) ) ; } $ query = $ query - > get Result Object ( ) ; $ ret Val = [ ] ; foreach ( $ query as $ row ) { $ obj = new \ std Class ( ) ; $ obj - > name = $ row - > indexname ; $ _fields = explode ( ' , ' , preg _replace ( ' / ^ . * \ ( ( . + ? ) \ ) $ / ' , ' $ 1 ' , trim ( $ row - > indexdef ) ) ) ; $ obj - > fields = array _map ( function ( $ v ) { return trim ( $ v ) ; } , $ _fields ) ; if ( strpos ( $ row - > indexdef , 'CREATE UNIQUE INDEX pk ' ) = = = 0 ) { $ obj - > type = 'PRIMARY ' ; } else { $ obj - > type = ( strpos ( $ row - > indexdef , 'CREATE UNIQUE ' ) = = = 0 ) ? 'UNIQUE ' : 'INDEX ' ; } $ ret Val [ $ obj - > name ] = $ obj ; } return $ ret Val ; } 
public function _foreign Key Data ( string $ table ) : array { $ sql = 'SELECT tc .constraint _name , tc .table _name , kcu .column _name , ccu .table _name AS foreign _table _name , ccu .column _name AS foreign _column _name FROM information _schema .table _constraints AS tc JOIN information _schema .key _column _usage AS kcu ON tc .constraint _name = kcu .constraint _name JOIN information _schema .constraint _column _usage AS ccu ON ccu .constraint _name = tc .constraint _name WHERE constraint _type = ' . $ this - > escape ( 'FOREIGN KEY ' ) . ' AND tc .table _name = ' . $ this - > escape ( $ table ) ; if ( ( $ query = $ this - > query ( $ sql ) ) = = = false ) { throw new Database Exception ( lang ( 'Database .fail Get Foreign Key Data ' ) ) ; } $ query = $ query - > get Result Object ( ) ; $ ret Val = [ ] ; foreach ( $ query as $ row ) { $ obj = new \ std Class ( ) ; $ obj - > constraint _name = $ row - > constraint _name ; $ obj - > table _name = $ row - > table _name ; $ obj - > foreign _table _name = $ row - > foreign _table _name ; $ ret Val [ ] = $ obj ; } return $ ret Val ; } 
public function insert ID ( ) : int { $ v = pg _version ( $ this - > conn ID ) ; 
protected function build DSN ( ) { $ this - > DSN = = = ' ' | | $ this - > DSN = ' ' ; 
public function get Formatter ( string $ mime ) { if ( ! array _key _exists ( $ mime , $ this - > formatters ) ) { throw new \ Invalid Argument Exception ( 'No Formatter defined for mime type : ' . $ mime ) ; } $ class = $ this - > formatters [ $ mime ] ; if ( ! class _exists ( $ class ) ) { throw new \ Bad Method Call Exception ( $ class . ' is not a valid Formatter . ' ) ; } return new $ class ( ) ; } 
public function before ( Request Interface $ request ) { $ honeypot = Services : : honeypot ( new \ Config \ Honeypot ( ) ) ; if ( $ honeypot - > has Content ( $ request ) ) { throw Honeypot Exception : : is Bot ( ) ; } } 
public function after ( Request Interface $ request , Response Interface $ response ) { $ honeypot = Services : : honeypot ( new \ Config \ Honeypot ( ) ) ; $ honeypot - > attach Honeypot ( $ response ) ; } 
public function _resize ( bool $ maintain Ratio = false ) { $ source = ! empty ( $ this - > resource ) ? $ this - > resource : $ this - > image - > get Pathname ( ) ; $ destination = $ this - > get Resource Path ( ) ; $ escape = ' \ \ ' ; if ( stripos ( PHP _OS , 'WIN ' ) = = = 0 ) { $ escape = ' ' ; } $ action = $ maintain Ratio = = = true ? ' -resize ' . $ this - > width . 'x ' . $ this - > height . ' " ' . $ source . ' " " ' . $ destination . ' " ' : ' -resize ' . $ this - > width . 'x ' . $ this - > height . " { $escape } ! \ " " . $ source . ' " " ' . $ destination . ' " ' ; $ this - > process ( $ action ) ; return $ this ; } 
public function _crop ( ) { $ source = ! empty ( $ this - > resource ) ? $ this - > resource : $ this - > image - > get Pathname ( ) ; $ destination = $ this - > get Resource Path ( ) ; $ action = ' -crop ' . $ this - > width . 'x ' . $ this - > height . ' + ' . $ this - > x Axis . ' + ' . $ this - > y Axis . ' " ' . $ source . ' " " ' . $ destination . ' " ' ; $ this - > process ( $ action ) ; return $ this ; } 
protected function _rotate ( int $ angle ) { $ angle = ' -rotate ' . $ angle ; $ source = ! empty ( $ this - > resource ) ? $ this - > resource : $ this - > image - > get Pathname ( ) ; $ destination = $ this - > get Resource Path ( ) ; $ action = ' ' . $ angle . ' " ' . $ source . ' " " ' . $ destination . ' " ' ; $ this - > process ( $ action ) ; return $ this ; } 
public function _flatten ( int $ red = 2 5 5 , int $ green = 2 5 5 , int $ blue = 2 5 5 ) { $ flatten = " -background RGB ( { $red } , { $green } , { $blue } ) -flatten " ; $ source = ! empty ( $ this - > resource ) ? $ this - > resource : $ this - > image - > get Pathname ( ) ; $ destination = $ this - > get Resource Path ( ) ; $ action = ' ' . $ flatten . ' " ' . $ source . ' " " ' . $ destination . ' " ' ; $ this - > process ( $ action ) ; return $ this ; } 
public function _flip ( string $ direction ) { $ angle = $ direction = = = 'horizontal ' ? ' -flop ' : ' -flip ' ; $ source = ! empty ( $ this - > resource ) ? $ this - > resource : $ this - > image - > get Pathname ( ) ; $ destination = $ this - > get Resource Path ( ) ; $ action = ' ' . $ angle . ' " ' . $ source . ' " " ' . $ destination . ' " ' ; $ this - > process ( $ action ) ; return $ this ; } 
public function get Version ( ) : string { $ result = $ this - > process ( ' -version ' ) ; 
protected function process ( string $ action , int $ quality = 1 0 0 ) { 
public function save ( string $ target = null , int $ quality = 9 0 ) : bool { $ target = empty ( $ target ) ? $ this - > image : $ target ; 
protected function get Resource Path ( ) { if ( ! is _null ( $ this - > resource ) ) { return $ this - > resource ; } $ this - > resource = WRITEPATH . 'cache / ' . time ( ) . ' _ ' . bin 2hex ( random _bytes ( 1 0 ) ) . ' .png ' ; return $ this - > resource ; } 
protected function _text ( string $ text , array $ options = [ ] ) { $ cmd = ' ' ; 
public function run ( array $ params = [ ] ) { $ seeder = new Seeder ( new \ Config \ Database ( ) ) ; $ seed Name = array _shift ( $ params ) ; if ( empty ( $ seed Name ) ) { $ seed Name = CLI : : prompt ( lang ( 'Migrations .mig Seeder ' ) , 'Database Seeder ' ) ; } if ( empty ( $ seed Name ) ) { CLI : : error ( lang ( 'Migrations .mig Missing Seeder ' ) ) ; return ; } try { $ seeder - > call ( $ seed Name ) ; } catch ( \ Exception $ e ) { $ this - > show Error ( $ e ) ; } } 
public function create Database ( string $ db _name ) : bool { if ( $ this - > create Database Str = = = false ) { if ( $ this - > db - > DBDebug ) { throw new Database Exception ( 'This feature is not available for the database you are using . ' ) ; } return false ; } elseif ( ! $ this - > db - > query ( sprintf ( $ this - > create Database Str , $ db _name , $ this - > db - > charset , $ this - > db - > DBCollat ) ) ) { if ( $ this - > db - > DBDebug ) { throw new Database Exception ( 'Unable to create the specified database . ' ) ; } return false ; } if ( ! empty ( $ this - > db - > data Cache [ 'db _names ' ] ) ) { $ this - > db - > data Cache [ 'db _names ' ] [ ] = $ db _name ; } return true ; } 
public function drop Database ( string $ db _name ) : bool { if ( $ this - > drop Database Str = = = false ) { if ( $ this - > db - > DBDebug ) { throw new Database Exception ( 'This feature is not available for the database you are using . ' ) ; } return false ; } elseif ( ! $ this - > db - > query ( sprintf ( $ this - > drop Database Str , $ db _name ) ) ) { if ( $ this - > db - > DBDebug ) { throw new Database Exception ( 'Unable to drop the specified database . ' ) ; } return false ; } if ( ! empty ( $ this - > db - > data Cache [ 'db _names ' ] ) ) { $ key = array _search ( strtolower ( $ db _name ) , array _map ( 'strtolower ' , $ this - > db - > data Cache [ 'db _names ' ] ) , true ) ; if ( $ key ! = = false ) { unset ( $ this - > db - > data Cache [ 'db _names ' ] [ $ key ] ) ; } } return true ; } 
public function add Key ( $ key , bool $ primary = false , bool $ unique = false ) { if ( $ primary = = = true ) { foreach ( ( array ) $ key as $ one ) { $ this - > primary Keys [ ] = $ one ; } } else { $ this - > keys [ ] = $ key ; if ( $ unique = = = true ) { $ this - > unique Keys [ ] = ( $ c = count ( $ this - > keys ) ) ? $ c - 1 : 0 ; } } return $ this ; } 
public function add Field ( $ field ) { if ( is _string ( $ field ) ) { if ( $ field = = = 'id ' ) { $ this - > add Field ( [ 'id ' = > [ 'type ' = > 'INT ' , 'constraint ' = > 9 , 'auto _increment ' = > true , ] , ] ) ; $ this - > add Key ( 'id ' , true ) ; } else { if ( strpos ( $ field , ' ' ) = = = false ) { throw new \ Invalid Argument Exception ( 'Field information is required for that operation . ' ) ; } $ this - > fields [ ] = $ field ; } } if ( is _array ( $ field ) ) { $ this - > fields = array _merge ( $ this - > fields , $ field ) ; } return $ this ; } 
public function add Foreign Key ( string $ field Name = ' ' , string $ table Name = ' ' , string $ table Field = ' ' , string $ on Update = ' ' , string $ on Delete = ' ' ) { if ( ! isset ( $ this - > fields [ $ field Name ] ) ) { throw new Database Exception ( lang ( 'Database .field Not Exists ' , [ $ field Name ] ) ) ; } $ this - > foreign Keys [ $ field Name ] = [ 'table ' = > $ table Name , 'field ' = > $ table Field , 'on Delete ' = > strtoupper ( $ on Delete ) , 'on Update ' = > strtoupper ( $ on Update ) , ] ; return $ this ; } 
public function drop Foreign Key ( string $ table , string $ foreign _name ) { $ sql = sprintf ( $ this - > drop Constraint Str , $ this - > db - > escape Identifiers ( $ this - > db - > DBPrefix . $ table ) , $ this - > db - > escape Identifiers ( $ this - > db - > DBPrefix . $ foreign _name ) ) ; if ( $ sql = = = false ) { if ( $ this - > db - > DBDebug ) { throw new Database Exception ( 'This feature is not available for the database you are using . ' ) ; } return false ; } return $ this - > db - > query ( $ sql ) ; } 
public function create Table ( string $ table , bool $ if _not _exists = false , array $ attributes = [ ] ) { if ( $ table = = = ' ' ) { throw new \ Invalid Argument Exception ( 'A table name is required for that operation . ' ) ; } $ table = $ this - > db - > DBPrefix . $ table ; if ( count ( $ this - > fields ) = = = 0 ) { throw new \ Runtime Exception ( 'Field information is required . ' ) ; } $ sql = $ this - > _create Table ( $ table , $ if _not _exists , $ attributes ) ; if ( is _bool ( $ sql ) ) { $ this - > reset ( ) ; if ( $ sql = = = false ) { if ( $ this - > db - > DBDebug ) { throw new Database Exception ( 'This feature is not available for the database you are using . ' ) ; } return false ; } } if ( ( $ result = $ this - > db - > query ( $ sql ) ) ! = = false ) { empty ( $ this - > db - > data Cache [ 'table _names ' ] ) | | ( $ this - > db - > data Cache [ 'table _names ' ] [ ] = $ table ) ; 
protected function _create Table ( string $ table , bool $ if _not _exists , array $ attributes ) { 
protected function _create Table Attributes ( array $ attributes ) : string { $ sql = ' ' ; foreach ( array _keys ( $ attributes ) as $ key ) { if ( is _string ( $ key ) ) { $ sql . = ' ' . strtoupper ( $ key ) . ' ' . $ this - > db - > escape ( $ attributes [ $ key ] ) ; } } return $ sql ; } 
public function drop Table ( string $ table _name , bool $ if _exists = false , bool $ cascade = false ) { if ( $ table _name = = = ' ' ) { if ( $ this - > db - > DBDebug ) { throw new Database Exception ( 'A table name is required for that operation . ' ) ; } return false ; } 
protected function _drop Table ( string $ table , bool $ if _exists , bool $ cascade ) : string { $ sql = 'DROP TABLE ' ; if ( $ if _exists ) { if ( $ this - > drop Table If Str = = = false ) { if ( ! $ this - > db - > table Exists ( $ table ) ) { return true ; } } else { $ sql = sprintf ( $ this - > drop Table If Str , $ this - > db - > escape Identifiers ( $ table ) ) ; } } $ sql = $ sql . ' ' . $ this - > db - > escape Identifiers ( $ table ) ; return $ sql ; } 
public function rename Table ( string $ table _name , string $ new _table _name ) { if ( $ table _name = = = ' ' | | $ new _table _name = = = ' ' ) { throw new \ Invalid Argument Exception ( 'A table name is required for that operation . ' ) ; } elseif ( $ this - > rename Table Str = = = false ) { if ( $ this - > db - > DBDebug ) { throw new Database Exception ( 'This feature is not available for the database you are using . ' ) ; } return false ; } $ result = $ this - > db - > query ( sprintf ( $ this - > rename Table Str , $ this - > db - > escape Identifiers ( $ this - > db - > DBPrefix . $ table _name ) , $ this - > db - > escape Identifiers ( $ this - > db - > DBPrefix . $ new _table _name ) ) ) ; if ( $ result & & ! empty ( $ this - > db - > data Cache [ 'table _names ' ] ) ) { $ key = array _search ( strtolower ( $ this - > db - > DBPrefix . $ table _name ) , array _map ( 'strtolower ' , $ this - > db - > data Cache [ 'table _names ' ] ) , true ) ; if ( $ key ! = = false ) { $ this - > db - > data Cache [ 'table _names ' ] [ $ key ] = $ this - > db - > DBPrefix . $ new _table _name ; } } return $ result ; } 
public function add Column ( string $ table , $ field ) : bool { 
public function drop Column ( string $ table , string $ column _name ) { $ sql = $ this - > _alter Table ( 'DROP ' , $ this - > db - > DBPrefix . $ table , $ column _name ) ; if ( $ sql = = = false ) { if ( $ this - > db - > DBDebug ) { throw new Database Exception ( 'This feature is not available for the database you are using . ' ) ; } return false ; } return $ this - > db - > query ( $ sql ) ; } 
protected function _alter Table ( string $ alter _type , string $ table , $ field ) { $ sql = 'ALTER TABLE ' . $ this - > db - > escape Identifiers ( $ table ) . ' ' ; 
protected function _process Fields ( bool $ create _table = false ) : array { $ fields = [ ] ; foreach ( $ this - > fields as $ key = > $ attributes ) { if ( is _int ( $ key ) & & ! is _array ( $ attributes ) ) { $ fields [ ] = [ ' _literal ' = > $ attributes ] ; continue ; } $ attributes = array _change _key _case ( $ attributes , CASE _UPPER ) ; if ( $ create _table = = = true & & empty ( $ attributes [ 'TYPE ' ] ) ) { continue ; } isset ( $ attributes [ 'TYPE ' ] ) & & $ this - > _attribute Type ( $ attributes ) ; $ field = [ 'name ' = > $ key , 'new _name ' = > isset ( $ attributes [ 'NAME ' ] ) ? $ attributes [ 'NAME ' ] : null , 'type ' = > isset ( $ attributes [ 'TYPE ' ] ) ? $ attributes [ 'TYPE ' ] : null , 'length ' = > ' ' , 'unsigned ' = > ' ' , 'null ' = > ' ' , 'unique ' = > ' ' , 'default ' = > ' ' , 'auto _increment ' = > ' ' , ' _literal ' = > false , ] ; isset ( $ attributes [ 'TYPE ' ] ) & & $ this - > _attribute Unsigned ( $ attributes , $ field ) ; if ( $ create _table = = = false ) { if ( isset ( $ attributes [ 'AFTER ' ] ) ) { $ field [ 'after ' ] = $ attributes [ 'AFTER ' ] ; } elseif ( isset ( $ attributes [ 'FIRST ' ] ) ) { $ field [ 'first ' ] = ( bool ) $ attributes [ 'FIRST ' ] ; } } $ this - > _attribute Default ( $ attributes , $ field ) ; if ( isset ( $ attributes [ 'NULL ' ] ) ) { if ( $ attributes [ 'NULL ' ] = = = true ) { $ field [ 'null ' ] = empty ( $ this - > null ) ? ' ' : ' ' . $ this - > null ; } else { $ field [ 'null ' ] = ' NOT NULL ' ; } } elseif ( $ create _table = = = true ) { $ field [ 'null ' ] = ' NOT NULL ' ; } $ this - > _attribute Auto Increment ( $ attributes , $ field ) ; $ this - > _attribute Unique ( $ attributes , $ field ) ; if ( isset ( $ attributes [ 'COMMENT ' ] ) ) { $ field [ 'comment ' ] = $ this - > db - > escape ( $ attributes [ 'COMMENT ' ] ) ; } if ( isset ( $ attributes [ 'TYPE ' ] ) & & ! empty ( $ attributes [ 'CONSTRAINT ' ] ) ) { if ( is _array ( $ attributes [ 'CONSTRAINT ' ] ) ) { $ attributes [ 'CONSTRAINT ' ] = $ this - > db - > escape ( $ attributes [ 'CONSTRAINT ' ] ) ; $ attributes [ 'CONSTRAINT ' ] = implode ( ' , ' , $ attributes [ 'CONSTRAINT ' ] ) ; } $ field [ 'length ' ] = ' ( ' . $ attributes [ 'CONSTRAINT ' ] . ' ) ' ; } $ fields [ ] = $ field ; } return $ fields ; } 
protected function _attribute Unsigned ( array & $ attributes , array & $ field ) { if ( empty ( $ attributes [ 'UNSIGNED ' ] ) | | $ attributes [ 'UNSIGNED ' ] ! = = true ) { return ; } 
protected function _attribute Default ( array & $ attributes , array & $ field ) { if ( $ this - > default = = = false ) { return ; } if ( array _key _exists ( 'DEFAULT ' , $ attributes ) ) { if ( $ attributes [ 'DEFAULT ' ] = = = null ) { $ field [ 'default ' ] = empty ( $ this - > null ) ? ' ' : $ this - > default . $ this - > null ; 
protected function _attribute Auto Increment ( array & $ attributes , array & $ field ) { if ( ! empty ( $ attributes [ 'AUTO _INCREMENT ' ] ) & & $ attributes [ 'AUTO _INCREMENT ' ] = = = true & & stripos ( $ field [ 'type ' ] , 'int ' ) ! = = false ) { $ field [ 'auto _increment ' ] = ' AUTO _INCREMENT ' ; } } 
protected function _process Primary Keys ( string $ table ) : string { $ sql = ' ' ; for ( $ i = 0 , $ c = count ( $ this - > primary Keys ) ; $ i < $ c ; $ i + + ) { if ( ! isset ( $ this - > fields [ $ this - > primary Keys [ $ i ] ] ) ) { unset ( $ this - > primary Keys [ $ i ] ) ; } } if ( count ( $ this - > primary Keys ) > 0 ) { $ sql . = " , \n \t CONSTRAINT " . $ this - > db - > escape Identifiers ( 'pk _ ' . $ table ) . ' PRIMARY KEY ( ' . implode ( ' , ' , $ this - > db - > escape Identifiers ( $ this - > primary Keys ) ) . ' ) ' ; } return $ sql ; } 
protected function _process Indexes ( string $ table ) { $ sqls = [ ] ; for ( $ i = 0 , $ c = count ( $ this - > keys ) ; $ i < $ c ; $ i + + ) { $ this - > keys [ $ i ] = ( array ) $ this - > keys [ $ i ] ; for ( $ i 2 = 0 , $ c 2 = count ( $ this - > keys [ $ i ] ) ; $ i 2 < $ c 2 ; $ i 2 + + ) { if ( ! isset ( $ this - > fields [ $ this - > keys [ $ i ] [ $ i 2 ] ] ) ) { unset ( $ this - > keys [ $ i ] [ $ i 2 ] ) ; } } if ( count ( $ this - > keys [ $ i ] ) < = 0 ) { continue ; } if ( in _array ( $ i , $ this - > unique Keys ) ) { $ sqls [ ] = 'ALTER TABLE ' . $ this - > db - > escape Identifiers ( $ table ) . ' ADD CONSTRAINT ' . $ this - > db - > escape Identifiers ( $ table . ' _ ' . implode ( ' _ ' , $ this - > keys [ $ i ] ) ) . ' UNIQUE ( ' . implode ( ' , ' , $ this - > db - > escape Identifiers ( $ this - > keys [ $ i ] ) ) . ' ) ; ' ; continue ; } $ sqls [ ] = 'CREATE INDEX ' . $ this - > db - > escape Identifiers ( $ table . ' _ ' . implode ( ' _ ' , $ this - > keys [ $ i ] ) ) . ' ON ' . $ this - > db - > escape Identifiers ( $ table ) . ' ( ' . implode ( ' , ' , $ this - > db - > escape Identifiers ( $ this - > keys [ $ i ] ) ) . ' ) ; ' ; } return $ sqls ; } 
protected function _process Foreign Keys ( string $ table ) : string { $ sql = ' ' ; $ allow Actions = [ 'CASCADE ' , 'SET NULL ' , 'NO ACTION ' , 'RESTRICT ' , 'SET DEFAULT ' , ] ; if ( count ( $ this - > foreign Keys ) > 0 ) { foreach ( $ this - > foreign Keys as $ field = > $ fkey ) { $ name _index = $ table . ' _ ' . $ field . ' _foreign ' ; $ sql . = " , \n \t CONSTRAINT " . $ this - > db - > escape Identifiers ( $ name _index ) . ' FOREIGN KEY ( ' . $ this - > db - > escape Identifiers ( $ field ) . ' ) REFERENCES ' . $ this - > db - > escape Identifiers ( $ this - > db - > DBPrefix . $ fkey [ 'table ' ] ) . ' ( ' . $ this - > db - > escape Identifiers ( $ fkey [ 'field ' ] ) . ' ) ' ; if ( $ fkey [ 'on Delete ' ] ! = = false & & in _array ( $ fkey [ 'on Delete ' ] , $ allow Actions ) ) { $ sql . = ' ON DELETE ' . $ fkey [ 'on Delete ' ] ; } if ( $ fkey [ 'on Update ' ] ! = = false & & in _array ( $ fkey [ 'on Update ' ] , $ allow Actions ) ) { $ sql . = ' ON UPDATE ' . $ fkey [ 'on Update ' ] ; } } } return $ sql ; } 
public function reset ( ) { $ this - > fields = $ this - > keys = $ this - > unique Keys = $ this - > primary Keys = $ this - > foreign Keys = [ ] ; } 
public function set Locale ( string $ locale = null ) { if ( ! is _null ( $ locale ) ) { $ this - > locale = $ locale ; } return $ this ; } 
public function get Line ( string $ line , array $ args = [ ] ) { 
protected function parse Line ( string $ line , string $ locale ) : array { $ file = substr ( $ line , 0 , strpos ( $ line , ' . ' ) ) ; $ line = substr ( $ line , strlen ( $ file ) + 1 ) ; if ( ! isset ( $ this - > language [ $ locale ] [ $ file ] ) | | ! array _key _exists ( $ line , $ this - > language [ $ locale ] [ $ file ] ) ) { $ this - > load ( $ file , $ locale ) ; } return [ $ file , $ line , ] ; } 
protected function format Message ( $ message , array $ args = [ ] ) { if ( ! $ this - > intl Support | | ! $ args ) { return $ message ; } if ( is _array ( $ message ) ) { foreach ( $ message as $ index = > $ value ) { $ message [ $ index ] = $ this - > format Message ( $ value , $ args ) ; } return $ message ; } return \ Message Formatter : : format Message ( $ this - > locale , $ message , $ args ) ; } 
protected function load ( string $ file , string $ locale , bool $ return = false ) { if ( ! array _key _exists ( $ locale , $ this - > loaded Files ) ) { $ this - > loaded Files [ $ locale ] = [ ] ; } if ( in _array ( $ file , $ this - > loaded Files [ $ locale ] ) ) { 
protected function require File ( string $ path ) : array { $ files = Services : : locator ( ) - > search ( $ path ) ; $ strings = [ ] ; foreach ( $ files as $ file ) { 
public function add Base URI ( $ uri , ? bool $ explicit Reporting = null ) { $ this - > add Option ( $ uri , 'base URI ' , $ explicit Reporting ? ? $ this - > report Only ) ; return $ this ; } 
public function add Child Src ( $ uri , ? bool $ explicit Reporting = null ) { $ this - > add Option ( $ uri , 'child Src ' , $ explicit Reporting ? ? $ this - > report Only ) ; return $ this ; } 
public function add Connect Src ( $ uri , ? bool $ explicit Reporting = null ) { $ this - > add Option ( $ uri , 'connect Src ' , $ explicit Reporting ? ? $ this - > report Only ) ; return $ this ; } 
public function set Default Src ( $ uri , ? bool $ explicit Reporting = null ) { $ this - > default Src = [ ( string ) $ uri = > $ explicit Reporting ? ? $ this - > report Only ] ; return $ this ; } 
public function add Font Src ( $ uri , ? bool $ explicit Reporting = null ) { $ this - > add Option ( $ uri , 'font Src ' , $ explicit Reporting ? ? $ this - > report Only ) ; return $ this ; } 
public function add Form Action ( $ uri , ? bool $ explicit Reporting = null ) { $ this - > add Option ( $ uri , 'form Action ' , $ explicit Reporting ? ? $ this - > report Only ) ; return $ this ; } 
public function add Frame Ancestor ( $ uri , ? bool $ explicit Reporting = null ) { $ this - > add Option ( $ uri , 'frame Ancestors ' , $ explicit Reporting ? ? $ this - > report Only ) ; return $ this ; } 
public function add Image Src ( $ uri , ? bool $ explicit Reporting = null ) { $ this - > add Option ( $ uri , 'image Src ' , $ explicit Reporting ? ? $ this - > report Only ) ; return $ this ; } 
public function add Media Src ( $ uri , ? bool $ explicit Reporting = null ) { $ this - > add Option ( $ uri , 'media Src ' , $ explicit Reporting ? ? $ this - > report Only ) ; return $ this ; } 
public function add Manifest Src ( $ uri , ? bool $ explicit Reporting = null ) { $ this - > add Option ( $ uri , 'manifest Src ' , $ explicit Reporting ? ? $ this - > report Only ) ; return $ this ; } 
public function add Object Src ( $ uri , ? bool $ explicit Reporting = null ) { $ this - > add Option ( $ uri , 'object Src ' , $ explicit Reporting ? ? $ this - > report Only ) ; return $ this ; } 
public function add Plugin Type ( $ mime , ? bool $ explicit Reporting = null ) { $ this - > add Option ( $ mime , 'plugin Types ' , $ explicit Reporting ? ? $ this - > report Only ) ; return $ this ; } 
public function add Sandbox ( $ flags , ? bool $ explicit Reporting = null ) { $ this - > add Option ( $ flags , 'sandbox ' , $ explicit Reporting ? ? $ this - > report Only ) ; return $ this ; } 
public function add Script Src ( $ uri , ? bool $ explicit Reporting = null ) { $ this - > add Option ( $ uri , 'script Src ' , $ explicit Reporting ? ? $ this - > report Only ) ; return $ this ; } 
public function add Style Src ( $ uri , ? bool $ explicit Reporting = null ) { $ this - > add Option ( $ uri , 'style Src ' , $ explicit Reporting ? ? $ this - > report Only ) ; return $ this ; } 
protected function add Option ( $ options , string $ target , ? bool $ explicit Reporting = null ) { 
protected function generate Nonces ( Response Interface & $ response ) { $ body = $ response - > get Body ( ) ; if ( empty ( $ body ) ) { return ; } if ( ! is _array ( $ this - > style Src ) ) { $ this - > style Src = [ $ this - > style Src ] ; } if ( ! is _array ( $ this - > script Src ) ) { $ this - > script Src = [ $ this - > script Src ] ; } 
protected function build Headers ( Response Interface & $ response ) { 
protected function add To Header ( string $ name , $ values = null ) { if ( is _string ( $ values ) ) { $ values = [ $ values = > 0 ] ; } $ sources = [ ] ; $ report Sources = [ ] ; foreach ( $ values as $ value = > $ report Only ) { if ( is _numeric ( $ value ) & & is _string ( $ report Only ) & & ! empty ( $ report Only ) ) { $ value = $ report Only ; $ report Only = 0 ; } if ( $ report Only = = = true ) { $ report Sources [ ] = in _array ( $ value , $ this - > valid Sources ) ? " ' { $value } ' " : $ value ; } else { if ( strpos ( $ value , 'nonce - ' ) = = = 0 ) { $ sources [ ] = " ' { $value } ' " ; } else { $ sources [ ] = in _array ( $ value , $ this - > valid Sources ) ? " ' { $value } ' " : $ value ; } } } if ( ! empty ( $ sources ) ) { $ this - > temp Headers [ $ name ] = implode ( ' ' , $ sources ) ; } if ( ! empty ( $ report Sources ) ) { $ this - > report Only Headers [ $ name ] = implode ( ' ' , $ report Sources ) ; } } 
public function _prepare ( string $ sql , array $ options = [ ] ) { $ this - > name = random _int ( 1 , 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ) ; $ sql = $ this - > parameterize ( $ sql ) ; 
public function _execute ( array $ data ) : bool { if ( is _null ( $ this - > statement ) ) { throw new \ Bad Method Call Exception ( 'You must call prepare before trying to execute a prepared statement . ' ) ; } $ this - > result = pg _execute ( $ this - > db - > conn ID , $ this - > name , $ data ) ; return ( bool ) $ this - > result ; } 
public function parameterize ( string $ sql ) : string { 
public function get Title ( bool $ safe = false ) : string { if ( $ safe ) { return str _replace ( ' ' , ' - ' , strtolower ( $ this - > title ) ) ; } return $ this - > title ; } 
public function clean Path ( string $ file ) : string { if ( strpos ( $ file , APPPATH ) = = = 0 ) { $ file = 'APPPATH / ' . substr ( $ file , strlen ( APPPATH ) ) ; } elseif ( strpos ( $ file , SYSTEMPATH ) = = = 0 ) { $ file = 'SYSTEMPATH / ' . substr ( $ file , strlen ( SYSTEMPATH ) ) ; } elseif ( strpos ( $ file , FCPATH ) = = = 0 ) { $ file = 'FCPATH / ' . substr ( $ file , strlen ( FCPATH ) ) ; } return $ file ; } 
protected function collect Logs ( ) { if ( ! is _null ( $ this - > data ) ) { return $ this - > data ; } return $ this - > data = Services : : logger ( true ) - > log Cache ? ? [ ] ; } 
public function render ( string $ library , $ params = null , int $ ttl = 0 , string $ cache Name = null ) : string { list ( $ class , $ method ) = $ this - > determine Class ( $ library ) ; 
public function prepare Params ( $ params ) { if ( empty ( $ params ) | | ( ! is _string ( $ params ) & & ! is _array ( $ params ) ) ) { return [ ] ; } if ( is _string ( $ params ) ) { $ new _params = [ ] ; $ separator = ' ' ; if ( strpos ( $ params , ' , ' ) ! = = false ) { $ separator = ' , ' ; } $ params = explode ( $ separator , $ params ) ; unset ( $ separator ) ; foreach ( $ params as $ p ) { if ( ! empty ( $ p ) ) { list ( $ key , $ val ) = explode ( ' = ' , $ p ) ; $ new _params [ trim ( $ key ) ] = trim ( $ val , ' , ' ) ; } } $ params = $ new _params ; unset ( $ new _params ) ; } if ( is _array ( $ params ) & & empty ( $ params ) ) { return [ ] ; } return $ params ; } 
protected function determine Class ( string $ library ) : array { 
public function get Result ( string $ type = 'object ' ) : array { if ( $ type = = = 'array ' ) { return $ this - > get Result Array ( ) ; } elseif ( $ type = = = 'object ' ) { return $ this - > get Result Object ( ) ; } return $ this - > get Custom Result Object ( $ type ) ; } 
public function get Custom Result Object ( string $ class Name ) { if ( isset ( $ this - > custom Result Object [ $ class Name ] ) ) { return $ this - > custom Result Object [ $ class Name ] ; } if ( is _bool ( $ this - > result ID ) | | ! $ this - > result ID | | $ this - > num Rows = = = 0 ) { return [ ] ; } 
public function get Result Array ( ) : array { if ( ! empty ( $ this - > result Array ) ) { return $ this - > result Array ; } 
public function get Result Object ( ) : array { if ( ! empty ( $ this - > result Object ) ) { return $ this - > result Object ; } 
public function get Row ( $ n = 0 , string $ type = 'object ' ) { if ( ! is _numeric ( $ n ) ) { 
public function get Custom Row Object ( int $ n , string $ class Name ) { isset ( $ this - > custom Result Object [ $ class Name ] ) | | $ this - > get Custom Result Object ( $ class Name ) ; if ( empty ( $ this - > custom Result Object [ $ class Name ] ) ) { return null ; } if ( $ n ! = = $ this - > current Row & & isset ( $ this - > custom Result Object [ $ class Name ] [ $ n ] ) ) { $ this - > current Row = $ n ; } return $ this - > custom Result Object [ $ class Name ] [ $ this - > current Row ] ; } 
public function get Row Array ( int $ n = 0 ) { $ result = $ this - > get Result Array ( ) ; if ( empty ( $ result ) ) { return null ; } if ( $ n ! = = $ this - > current Row & & isset ( $ result [ $ n ] ) ) { $ this - > current Row = $ n ; } return $ result [ $ this - > current Row ] ; } 
public function get Row Object ( int $ n = 0 ) { $ result = $ this - > get Result Object ( ) ; if ( empty ( $ result ) ) { return null ; } if ( $ n ! = = $ this - > custom Result Object & & isset ( $ result [ $ n ] ) ) { $ this - > current Row = $ n ; } return $ result [ $ this - > current Row ] ; } 
public function set Row ( $ key , $ value = null ) { 
public function get First Row ( string $ type = 'object ' ) { $ result = $ this - > get Result ( $ type ) ; return ( empty ( $ result ) ) ? null : $ result [ 0 ] ; } 
public function get Last Row ( string $ type = 'object ' ) { $ result = $ this - > get Result ( $ type ) ; return ( empty ( $ result ) ) ? null : $ result [ count ( $ result ) - 1 ] ; } 
public function get Next Row ( string $ type = 'object ' ) { $ result = $ this - > get Result ( $ type ) ; if ( empty ( $ result ) ) { return null ; } return isset ( $ result [ $ this - > current Row + 1 ] ) ? $ result [ + + $ this - > current Row ] : null ; } 
public function get Unbuffered Row ( string $ type = 'object ' ) { if ( $ type = = = 'array ' ) { return $ this - > fetch Assoc ( ) ; } elseif ( $ type = = = 'object ' ) { return $ this - > fetch Object ( ) ; } return $ this - > fetch Object ( $ type ) ; } 
public function media ( array $ supported , bool $ strict Match = false ) : string { return $ this - > get Best Match ( $ supported , $ this - > request - > get Header Line ( 'accept ' ) , true , $ strict Match ) ; } 
public function charset ( array $ supported ) : string { $ match = $ this - > get Best Match ( $ supported , $ this - > request - > get Header Line ( 'accept -charset ' ) , false , true ) ; 
public function encoding ( array $ supported = [ ] ) : string { array _push ( $ supported , 'identity ' ) ; return $ this - > get Best Match ( $ supported , $ this - > request - > get Header Line ( 'accept -encoding ' ) ) ; } 
protected function get Best Match ( array $ supported , string $ header = null , bool $ enforce Types = false , bool $ strict Match = false ) : string { if ( empty ( $ supported ) ) { throw HTTPException : : for Empty Supported Negotiations ( ) ; } if ( empty ( $ header ) ) { return $ strict Match ? ' ' : $ supported [ 0 ] ; } $ acceptable = $ this - > parse Header ( $ header ) ; foreach ( $ acceptable as $ accept ) { 
public function parse Header ( string $ header ) : array { $ results = [ ] ; $ acceptable = explode ( ' , ' , $ header ) ; foreach ( $ acceptable as $ value ) { $ pairs = explode ( ' ; ' , $ value ) ; $ value = $ pairs [ 0 ] ; unset ( $ pairs [ 0 ] ) ; $ parameters = [ ] ; foreach ( $ pairs as $ pair ) { $ param = [ ] ; preg _match ( ' / ^ ( ?P <name > . + ? ) = ( ?P <quoted > " | \ ' ) ? ( ?P <value > . * ? ) ( ? : \k <quoted > ) ? $ / ' , $ pair , $ param ) ; $ parameters [ trim ( $ param [ 'name ' ] ) ] = trim ( $ param [ 'value ' ] ) ; } $ quality = 1 . 0 ; if ( array _key _exists ( 'q ' , $ parameters ) ) { $ quality = $ parameters [ 'q ' ] ; unset ( $ parameters [ 'q ' ] ) ; } $ results [ ] = [ 'value ' = > trim ( $ value ) , 'q ' = > ( float ) $ quality , 'params ' = > $ parameters , ] ; } / / Sort to get the highest results first usort ( $ results , function ( $ a , $ b ) { if ( $ a [ 'q ' ] = = = $ b [ 'q ' ] ) { $ a _ast = substr _count ( $ a [ 'value ' ] , ' * ' ) ; $ b _ast = substr _count ( $ b [ 'value ' ] , ' * ' ) ; / / ' * / * ' has lower precedence than 'text / * ' , / / and 'text / * ' has lower priority than 'text /plain ' / / / / This seems backwards , but needs to be that way / / due to the way PHP 7 handles ordering or array / / elements created by reference . if ( $ a _ast > $ b _ast ) { return 1 ; } / / If the counts are the same , but one element / / has more params than another , it has higher precedence . / / / / This seems backwards , but needs to be that way / / due to the way PHP 7 handles ordering or array / / elements created by reference . if ( $ a _ast = = = $ b _ast ) { return count ( $ b [ 'params ' ] ) - count ( $ a [ 'params ' ] ) ; } return 0 ; } / / Still here ? Higher q values have precedence . return ( $ a [ 'q ' ] > $ b [ 'q ' ] ) ? - 1 : 1 ; } ) ; return $ results ; } 
protected function match ( array $ acceptable , string $ supported , bool $ enforce Types = false ) : bool { $ supported = $ this - > parse Header ( $ supported ) ; if ( is _array ( $ supported ) & & count ( $ supported ) = = = 1 ) { $ supported = $ supported [ 0 ] ; } 
protected function match Parameters ( array $ acceptable , array $ supported ) : bool { if ( count ( $ acceptable [ 'params ' ] ) ! = = count ( $ supported [ 'params ' ] ) ) { return false ; } foreach ( $ supported [ 'params ' ] as $ label = > $ value ) { if ( ! isset ( $ acceptable [ 'params ' ] [ $ label ] ) | | $ acceptable [ 'params ' ] [ $ label ] ! = = $ value ) { return false ; } } return true ; } 
public function match Types ( array $ acceptable , array $ supported ) : bool { list ( $ a Type , $ a Sub Type ) = explode ( ' / ' , $ acceptable [ 'value ' ] ) ; list ( $ s Type , $ s Sub Type ) = explode ( ' / ' , $ supported [ 'value ' ] ) ; 
public function get Field Names ( ) : array { $ field Names = [ ] ; $ this - > result ID - > field _seek ( 0 ) ; while ( $ field = $ this - > result ID - > fetch _field ( ) ) { $ field Names [ ] = $ field - > name ; } return $ field Names ; } 
public function get Field Data ( ) : array { $ ret Val = [ ] ; $ field Data = $ this - > result ID - > fetch _fields ( ) ; foreach ( $ field Data as $ i = > $ data ) { $ ret Val [ $ i ] = new \ std Class ( ) ; $ ret Val [ $ i ] - > name = $ data - > name ; $ ret Val [ $ i ] - > type = $ data - > type ; $ ret Val [ $ i ] - > max _length = $ data - > max _length ; $ ret Val [ $ i ] - > primary _key = ( int ) ( $ data - > flags & 2 ) ; $ ret Val [ $ i ] - > default = $ data - > def ; } return $ ret Val ; } 
public function free Result ( ) { if ( is _object ( $ this - > result ID ) ) { $ this - > result ID - > free ( ) ; $ this - > result ID = false ; } } 
public function run ( bool $ use Safe Output = false ) { $ path = CLI : : get URI ( ) ? : 'list ' ; 
public function show Header ( ) { CLI : : new Line ( 1 ) ; CLI : : write ( CLI : : color ( 'Code Igniter CLI Tool ' , 'green ' ) . ' - Version ' . Code Igniter : : CI _VERSION . ' - Server -Time : ' . date ( 'Y -m -d H :i :sa ' ) ) ; CLI : : new Line ( 1 ) ; } 
public function links ( string $ group = 'default ' , string $ template = 'default _full ' ) : string { $ this - > ensure Group ( $ group ) ; return $ this - > display Links ( $ group , $ template ) ; } 
public function simple Links ( string $ group = 'default ' , string $ template = 'default _simple ' ) : string { $ this - > ensure Group ( $ group ) ; return $ this - > display Links ( $ group , $ template ) ; } 
public function make Links ( int $ page , int $ per Page , int $ total , string $ template = 'default _full ' , int $ segment = 0 ) : string { $ name = time ( ) ; $ this - > store ( $ name , $ page , $ per Page , $ total , $ segment ) ; return $ this - > display Links ( $ name , $ template ) ; } 
protected function display Links ( string $ group , string $ template ) : string { $ pager = new Pager Renderer ( $ this - > get Details ( $ group ) ) ; if ( ! array _key _exists ( $ template , $ this - > config - > templates ) ) { throw Pager Exception : : for Invalid Template ( $ template ) ; } return $ this - > view - > set Var ( 'pager ' , $ pager ) - > render ( $ this - > config - > templates [ $ template ] ) ; } 
public function store ( string $ group , int $ page , int $ per Page , int $ total , int $ segment = 0 ) { $ this - > segment [ $ group ] = $ segment ; $ this - > ensure Group ( $ group ) ; $ this - > groups [ $ group ] [ 'current Page ' ] = $ page ; $ this - > groups [ $ group ] [ 'per Page ' ] = $ per Page ; $ this - > groups [ $ group ] [ 'total ' ] = $ total ; $ this - > groups [ $ group ] [ 'page Count ' ] = ( int ) ceil ( $ total / $ per Page ) ; return $ this ; } 
public function set Path ( string $ path , string $ group = 'default ' ) { $ this - > ensure Group ( $ group ) ; $ this - > groups [ $ group ] [ 'uri ' ] - > set Path ( $ path ) ; return $ this ; } 
public function get Page Count ( string $ group = 'default ' ) : int { $ this - > ensure Group ( $ group ) ; return $ this - > groups [ $ group ] [ 'page Count ' ] ; } 
public function get Current Page ( string $ group = 'default ' ) : int { $ this - > ensure Group ( $ group ) ; return $ this - > groups [ $ group ] [ 'current Page ' ] ; } 
public function has More ( string $ group = 'default ' ) : bool { $ this - > ensure Group ( $ group ) ; return ( $ this - > groups [ $ group ] [ 'current Page ' ] * $ this - > groups [ $ group ] [ 'per Page ' ] ) < $ this - > groups [ $ group ] [ 'total ' ] ; } 
public function get Last Page ( string $ group = 'default ' ) { $ this - > ensure Group ( $ group ) ; if ( ! is _numeric ( $ this - > groups [ $ group ] [ 'total ' ] ) | | ! is _numeric ( $ this - > groups [ $ group ] [ 'per Page ' ] ) ) { return null ; } return ( int ) ceil ( $ this - > groups [ $ group ] [ 'total ' ] / $ this - > groups [ $ group ] [ 'per Page ' ] ) ; } 
public function get Page URI ( int $ page = null , string $ group = 'default ' , bool $ return Object = false ) { $ this - > ensure Group ( $ group ) ; $ uri = $ this - > groups [ $ group ] [ 'uri ' ] ; $ segment = $ this - > segment [ $ group ] ? ? 0 ; if ( $ segment ) { $ uri - > set Segment ( $ segment , $ page ) ; } else { $ uri - > add Query ( 'page ' , $ page ) ; } if ( $ this - > only ) { $ query = array _intersect _key ( $ _GET , array _flip ( $ this - > only ) ) ; if ( ! $ segment ) { $ query [ 'page ' ] = $ page ; } $ uri - > set Query Array ( $ query ) ; } return $ return Object = = = true ? $ uri : ( string ) $ uri ; } 
public function get Next Page URI ( string $ group = 'default ' , bool $ return Object = false ) { $ this - > ensure Group ( $ group ) ; $ last = $ this - > get Last Page ( $ group ) ; $ curr = $ this - > get Current Page ( $ group ) ; $ page = null ; if ( ! empty ( $ last ) & & ! empty ( $ curr ) & & $ last = = = $ curr ) { return null ; } if ( $ last > $ curr ) { $ page = $ curr + 1 ; } return $ this - > get Page URI ( $ page , $ group , $ return Object ) ; } 
public function get Previous Page URI ( string $ group = 'default ' , bool $ return Object = false ) { $ this - > ensure Group ( $ group ) ; $ first = $ this - > get First Page ( $ group ) ; $ curr = $ this - > get Current Page ( $ group ) ; $ page = null ; if ( ! empty ( $ first ) & & ! empty ( $ curr ) & & $ first = = = $ curr ) { return null ; } if ( $ first < $ curr ) { $ page = $ curr - 1 ; } return $ this - > get Page URI ( $ page , $ group , $ return Object ) ; } 
public function get Per Page ( string $ group = 'default ' ) : int { $ this - > ensure Group ( $ group ) ; return ( int ) $ this - > groups [ $ group ] [ 'per Page ' ] ; } 
public function get Details ( string $ group = 'default ' ) : array { if ( ! array _key _exists ( $ group , $ this - > groups ) ) { throw Pager Exception : : for Invalid Pagination Group ( $ group ) ; } $ new Group = $ this - > groups [ $ group ] ; $ new Group [ 'next ' ] = $ this - > get Next Page URI ( $ group ) ; $ new Group [ 'previous ' ] = $ this - > get Previous Page URI ( $ group ) ; $ new Group [ 'segment ' ] = $ this - > segment [ $ group ] ? ? 0 ; return $ new Group ; } 
protected function ensure Group ( string $ group ) { if ( array _key _exists ( $ group , $ this - > groups ) ) { return ; } $ this - > groups [ $ group ] = [ 'uri ' = > clone Services : : request ( ) - > uri , 'has More ' = > false , 'total ' = > null , 'per Page ' = > $ this - > config - > per Page , 'page Count ' = > 1 , ] ; if ( array _key _exists ( $ group , $ this - > segment ) ) { try { $ this - > groups [ $ group ] [ 'current Page ' ] = $ this - > groups [ $ group ] [ 'uri ' ] - > get Segment ( $ this - > segment [ $ group ] ) ; } catch ( \ Code Igniter \ HTTP \ Exceptions \ HTTPException $ e ) { $ this - > groups [ $ group ] [ 'current Page ' ] = 1 ; } } else { $ this - > groups [ $ group ] [ 'current Page ' ] = $ _GET [ 'page _ ' . $ group ] ? ? $ _GET [ 'page ' ] ? ? 1 ; } if ( $ _GET ) { $ this - > groups [ $ group ] [ 'uri ' ] = $ this - > groups [ $ group ] [ 'uri ' ] - > set Query Array ( $ _GET ) ; } } 
public function get Years ( bool $ raw = false ) { if ( $ raw ) { return $ this - > difference / YEAR ; } $ time = clone ( $ this - > current Time ) ; return $ time - > field Difference ( $ this - > test Time , Intl Calendar : : FIELD _YEAR ) ; } 
public function get Months ( bool $ raw = false ) { if ( $ raw ) { return $ this - > difference / MONTH ; } $ time = clone ( $ this - > current Time ) ; return $ time - > field Difference ( $ this - > test Time , Intl Calendar : : FIELD _MONTH ) ; } 
public function get Weeks ( bool $ raw = false ) { if ( $ raw ) { return $ this - > difference / WEEK ; } $ time = clone ( $ this - > current Time ) ; return ( int ) ( $ time - > field Difference ( $ this - > test Time , Intl Calendar : : FIELD _DAY _OF _YEAR ) / 7 ) ; } 
public function get Days ( bool $ raw = false ) { if ( $ raw ) { return $ this - > difference / DAY ; } $ time = clone ( $ this - > current Time ) ; return $ time - > field Difference ( $ this - > test Time , Intl Calendar : : FIELD _DAY _OF _YEAR ) ; } 
public function get Hours ( bool $ raw = false ) { if ( $ raw ) { return $ this - > difference / HOUR ; } $ time = clone ( $ this - > current Time ) ; return $ time - > field Difference ( $ this - > test Time , Intl Calendar : : FIELD _HOUR _OF _DAY ) ; } 
public function get Minutes ( bool $ raw = false ) { if ( $ raw ) { return $ this - > difference / MINUTE ; } $ time = clone ( $ this - > current Time ) ; return $ time - > field Difference ( $ this - > test Time , Intl Calendar : : FIELD _MINUTE ) ; } 
public function get Seconds ( bool $ raw = false ) { if ( $ raw ) { return $ this - > difference ; } $ time = clone ( $ this - > current Time ) ; return $ time - > field Difference ( $ this - > test Time , Intl Calendar : : FIELD _SECOND ) ; } 
public function humanize ( string $ locale = null ) : string { $ current = clone ( $ this - > current Time ) ; $ years = $ current - > field Difference ( $ this - > test Time , Intl Calendar : : FIELD _YEAR ) ; $ months = $ current - > field Difference ( $ this - > test Time , Intl Calendar : : FIELD _MONTH ) ; $ days = $ current - > field Difference ( $ this - > test Time , Intl Calendar : : FIELD _DAY _OF _YEAR ) ; $ hours = $ current - > field Difference ( $ this - > test Time , Intl Calendar : : FIELD _HOUR _OF _DAY ) ; $ minutes = $ current - > field Difference ( $ this - > test Time , Intl Calendar : : FIELD _MINUTE ) ; $ phrase = null ; if ( $ years ! = = 0 ) { $ phrase = lang ( 'Time .years ' , [ abs ( $ years ) ] , $ locale ) ; $ before = $ years < 0 ; } else if ( $ months ! = = 0 ) { $ phrase = lang ( 'Time .months ' , [ abs ( $ months ) ] , $ locale ) ; $ before = $ months < 0 ; } else if ( $ days ! = = 0 & & ( abs ( $ days ) > = 7 ) ) { $ weeks = ceil ( $ days / 7 ) ; $ phrase = lang ( 'Time .weeks ' , [ abs ( $ weeks ) ] , $ locale ) ; $ before = $ days < 0 ; } else if ( $ days ! = = 0 ) { $ phrase = lang ( 'Time .days ' , [ abs ( $ days ) ] , $ locale ) ; $ before = $ days < 0 ; } else if ( $ hours ! = = 0 ) { $ phrase = lang ( 'Time .hours ' , [ abs ( $ hours ) ] , $ locale ) ; $ before = $ hours < 0 ; } else if ( $ minutes ! = = 0 ) { $ phrase = lang ( 'Time .minutes ' , [ abs ( $ minutes ) ] , $ locale ) ; $ before = $ minutes < 0 ; } else { return lang ( 'Time .now ' , [ ] , $ locale ) ; } return $ before ? lang ( 'Time .ago ' , [ $ phrase ] , $ locale ) : lang ( 'Time .in Future ' , [ $ phrase ] , $ locale ) ; } 
public function load ( array $ params = [ ] , string $ alias ) { 
public function load Forge ( Connection Interface $ db ) { $ class Name = strpos ( $ db - > DBDriver , ' \ \ ' ) = = = false ? ' \Code Igniter \Database \ \ ' . $ db - > DBDriver . ' \ \Forge ' : $ db - > DBDriver . ' \ \Forge ' ; 
public function fill ( array $ data ) { foreach ( $ data as $ key = > $ value ) { $ key = $ this - > map Property ( $ key ) ; $ method = 'set ' . str _replace ( ' ' , ' ' , ucwords ( str _replace ( [ ' - ' , ' _ ' ] , ' ' , $ key ) ) ) ; if ( method _exists ( $ this , $ method ) ) { $ this - > $ method ( $ value ) ; } elseif ( property _exists ( $ this , $ key ) ) { $ this - > $ key = $ value ; } } return $ this ; } 
public function to Array ( bool $ only Changed = false , bool $ cast = true ) : array { $ this - > _cast = $ cast ; $ return = [ ] ; 
public function to Raw Array ( bool $ only Changed = false ) : array { $ return = [ ] ; $ properties = get _object _vars ( $ this ) ; foreach ( $ properties as $ key = > $ value ) { if ( substr ( $ key , 0 , 1 ) = = = ' _ ' ) { continue ; } if ( $ only Changed & & ! $ this - > has Property Changed ( $ key , $ value ) ) { continue ; } $ return [ $ key ] = $ this - > $ key ; } return $ return ; } 
protected function has Property Changed ( string $ key , $ value = null ) : bool { return ! ( ( $ this - > _original [ $ key ] = = = null & & $ value = = = null ) | | $ this - > _original [ $ key ] = = = $ value ) ; } 
public function _ _isset ( string $ key ) : bool { 
protected function map Property ( string $ key ) { if ( empty ( $ this - > _options [ 'datamap ' ] ) ) { return $ key ; } if ( isset ( $ this - > _options [ 'datamap ' ] [ $ key ] ) & & ! empty ( $ this - > _options [ 'datamap ' ] [ $ key ] ) ) { return $ this - > _options [ 'datamap ' ] [ $ key ] ; } return $ key ; } 
protected function mutate Date ( $ value ) { if ( $ value instanceof Time ) { return $ value ; } if ( $ value instanceof \ Date Time ) { return Time : : instance ( $ value ) ; } if ( is _numeric ( $ value ) ) { return Time : : create From Timestamp ( $ value ) ; } if ( is _string ( $ value ) ) { return Time : : parse ( $ value ) ; } return $ value ; } 
protected function cast As ( $ value , string $ type ) { if ( substr ( $ type , 0 , 1 ) = = = ' ? ' ) { if ( $ value = = = null ) { return null ; } $ type = substr ( $ type , 1 ) ; } switch ( $ type ) { case 'int ' : case 'integer ' : 
private function cast As Json ( $ value , bool $ as Array = false ) { $ tmp = ! is _null ( $ value ) ? ( $ as Array ? [ ] : new \ std Class ) : null ; if ( function _exists ( 'json _decode ' ) ) { if ( ( is _string ( $ value ) & & ( strpos ( $ value , ' [ ' ) = = = 0 | | strpos ( $ value , ' { ' ) = = = 0 | | ( strpos ( $ value , ' " ' ) = = = 0 & & strrpos ( $ value , ' " ' ) = = = 0 ) ) ) | | is _numeric ( $ value ) ) { $ tmp = json _decode ( $ value , $ as Array ) ; if ( json _last _error ( ) ! = = JSON _ERROR _NONE ) { throw Cast Exception : : for Invalid Json Format Exception ( json _last _error ( ) ) ; } } } return $ tmp ; } 
public function should Discover ( string $ alias ) { if ( ! $ this - > enabled ) { return false ; } $ alias = strtolower ( $ alias ) ; return in _array ( $ alias , $ this - > active Explorers ) ; } 
public function find ( $ id = null ) { $ builder = $ this - > builder ( ) ; if ( $ this - > temp Use Soft Deletes = = = true ) { $ builder - > where ( $ this - > table . ' . ' . $ this - > deleted Field , 0 ) ; } if ( is _array ( $ id ) ) { $ row = $ builder - > where In ( $ this - > table . ' . ' . $ this - > primary Key , $ id ) - > get ( ) ; $ row = $ row - > get Result ( $ this - > temp Return Type ) ; } elseif ( is _numeric ( $ id ) | | is _string ( $ id ) ) { $ row = $ builder - > where ( $ this - > table . ' . ' . $ this - > primary Key , $ id ) - > get ( ) ; $ row = $ row - > get First Row ( $ this - > temp Return Type ) ; } else { $ row = $ builder - > get ( ) ; $ row = $ row - > get Result ( $ this - > temp Return Type ) ; } $ row = $ this - > trigger ( 'after Find ' , [ 'id ' = > $ id , 'data ' = > $ row ] ) ; $ this - > temp Return Type = $ this - > return Type ; $ this - > temp Use Soft Deletes = $ this - > use Soft Deletes ; return $ row [ 'data ' ] ; } 
public function find Column ( string $ column Name ) { if ( strpos ( $ column Name , ' , ' ) ! = = false ) { throw Data Exception : : for Find Column Have Multiple Columns ( ) ; } $ result Set = $ this - > select ( $ column Name ) - > as Array ( ) - > find ( ) ; return ( ! empty ( $ result Set ) ) ? array _column ( $ result Set , $ column Name ) : null ; } 
public function find All ( int $ limit = 0 , int $ offset = 0 ) { $ builder = $ this - > builder ( ) ; if ( $ this - > temp Use Soft Deletes = = = true ) { $ builder - > where ( $ this - > table . ' . ' . $ this - > deleted Field , 0 ) ; } $ row = $ builder - > limit ( $ limit , $ offset ) - > get ( ) ; $ row = $ row - > get Result ( $ this - > temp Return Type ) ; $ row = $ this - > trigger ( 'after Find ' , [ 'data ' = > $ row , 'limit ' = > $ limit , 'offset ' = > $ offset ] ) ; $ this - > temp Return Type = $ this - > return Type ; $ this - > temp Use Soft Deletes = $ this - > use Soft Deletes ; return $ row [ 'data ' ] ; } 
public function first ( ) { $ builder = $ this - > builder ( ) ; if ( $ this - > temp Use Soft Deletes = = = true ) { $ builder - > where ( $ this - > table . ' . ' . $ this - > deleted Field , 0 ) ; } 
public function set ( $ key , string $ value = ' ' , bool $ escape = null ) { $ data = is _array ( $ key ) ? $ key : [ $ key = > $ value ] ; $ this - > temp Data [ 'escape ' ] = $ escape ; $ this - > temp Data [ 'data ' ] = array _merge ( $ this - > temp Data [ 'data ' ] ? ? [ ] , $ data ) ; return $ this ; } 
public function save ( $ data ) : bool { if ( empty ( $ data ) ) { return true ; } if ( is _object ( $ data ) & & isset ( $ data - > { $ this - > primary Key } ) ) { $ response = $ this - > update ( $ data - > { $ this - > primary Key } , $ data ) ; } elseif ( is _array ( $ data ) & & ! empty ( $ data [ $ this - > primary Key ] ) ) { $ response = $ this - > update ( $ data [ $ this - > primary Key ] , $ data ) ; } else { $ response = $ this - > insert ( $ data , false ) ; 
public static function class To Array ( $ data , $ primary Key = null , string $ date Format = 'datetime ' , bool $ only Changed = true ) : array { if ( method _exists ( $ data , 'to Raw Array ' ) ) { $ properties = $ data - > to Raw Array ( $ only Changed ) ; 
public function insert ( $ data = null , bool $ return ID = true ) { $ escape = null ; $ this - > insert ID = 0 ; if ( empty ( $ data ) ) { $ data = $ this - > temp Data [ 'data ' ] ? ? null ; $ escape = $ this - > temp Data [ 'escape ' ] ? ? null ; $ this - > temp Data = [ ] ; } if ( empty ( $ data ) ) { throw Data Exception : : for Empty Dataset ( 'insert ' ) ; } 
public function insert Batch ( array $ set = null , bool $ escape = null , int $ batch Size = 1 0 0 , bool $ testing = false ) { if ( is _array ( $ set ) & & $ this - > skip Validation = = = false ) { foreach ( $ set as $ row ) { if ( $ this - > validate ( $ row ) = = = false ) { return false ; } } } return $ this - > builder ( ) - > insert Batch ( $ set , $ escape , $ batch Size , $ testing ) ; } 
public function update ( $ id = null , $ data = null ) : bool { $ escape = null ; if ( is _numeric ( $ id ) | | is _string ( $ id ) ) { $ id = [ $ id ] ; } if ( empty ( $ data ) ) { $ data = $ this - > temp Data [ 'data ' ] ? ? null ; $ escape = $ this - > temp Data [ 'escape ' ] ? ? null ; $ this - > temp Data = [ ] ; } if ( empty ( $ data ) ) { throw Data Exception : : for Empty Dataset ( 'update ' ) ; } 
public function update Batch ( array $ set = null , string $ index = null , int $ batch Size = 1 0 0 , bool $ return SQL = false ) { if ( is _array ( $ set ) & & $ this - > skip Validation = = = false ) { foreach ( $ set as $ row ) { if ( $ this - > validate ( $ row ) = = = false ) { return false ; } } } return $ this - > builder ( ) - > update Batch ( $ set , $ index , $ batch Size , $ return SQL ) ; } 
public function delete ( $ id = null , bool $ purge = false ) { if ( ! empty ( $ id ) & & is _numeric ( $ id ) ) { $ id = [ $ id ] ; } $ builder = $ this - > builder ( ) ; if ( ! empty ( $ id ) ) { $ builder = $ builder - > where In ( $ this - > primary Key , $ id ) ; } $ this - > trigger ( 'before Delete ' , [ 'id ' = > $ id , 'purge ' = > $ purge ] ) ; if ( $ this - > use Soft Deletes & & ! $ purge ) { $ set [ $ this - > deleted Field ] = 1 ; if ( $ this - > use Timestamps & & ! empty ( $ this - > updated Field ) ) { $ set [ $ this - > updated Field ] = $ this - > set Date ( ) ; } $ result = $ builder - > update ( $ set ) ; } else { $ result = $ builder - > delete ( ) ; } $ this - > trigger ( 'after Delete ' , [ 'id ' = > $ id , 'purge ' = > $ purge , 'result ' = > $ result , 'data ' = > null ] ) ; return $ result ; } 
public function purge Deleted ( ) { if ( ! $ this - > use Soft Deletes ) { return true ; } return $ this - > builder ( ) - > where ( $ this - > deleted Field , 1 ) - > delete ( ) ; } 
public function only Deleted ( ) { $ this - > temp Use Soft Deletes = false ; $ this - > builder ( ) - > where ( $ this - > deleted Field , 1 ) ; return $ this ; } 
public function replace ( $ data = null , bool $ return SQL = false ) { 
public function chunk ( int $ size , Closure $ user Func ) { $ total = $ this - > builder ( ) - > count All Results ( false ) ; $ offset = 0 ; while ( $ offset < = $ total ) { $ builder = clone ( $ this - > builder ( ) ) ; $ rows = $ builder - > get ( $ size , $ offset ) ; if ( $ rows = = = false ) { throw Data Exception : : for Empty Dataset ( 'chunk ' ) ; } $ rows = $ rows - > get Result ( $ this - > temp Return Type ) ; $ offset + = $ size ; if ( empty ( $ rows ) ) { continue ; } foreach ( $ rows as $ row ) { if ( $ user Func ( $ row ) = = = false ) { return ; } } } } 
public function paginate ( int $ per Page = 2 0 , string $ group = 'default ' , int $ page = 0 ) { 
protected function builder ( string $ table = null ) { if ( $ this - > builder instanceof Base Builder ) { return $ this - > builder ; } 
protected function do Protect Fields ( array $ data ) : array { if ( $ this - > protect Fields = = = false ) { return $ data ; } if ( empty ( $ this - > allowed Fields ) ) { throw Data Exception : : for Invalid Allowed Fields ( get _class ( $ this ) ) ; } if ( is _array ( $ data ) & & count ( $ data ) ) { foreach ( $ data as $ key = > $ val ) { if ( ! in _array ( $ key , $ this - > allowed Fields ) ) { unset ( $ data [ $ key ] ) ; } } } return $ data ; } 
protected function set Date ( int $ user Data = null ) { $ current Date = is _numeric ( $ user Data ) ? ( int ) $ user Data : time ( ) ; switch ( $ this - > date Format ) { case 'int ' : return $ current Date ; break ; case 'datetime ' : return date ( 'Y -m -d H :i :s ' , $ current Date ) ; break ; case 'date ' : return date ( 'Y -m -d ' , $ current Date ) ; break ; } } 
public function errors ( bool $ force DB = false ) { 
public function validate ( $ data ) : bool { if ( $ this - > skip Validation = = = true | | empty ( $ this - > validation Rules ) | | empty ( $ data ) ) { return true ; } 
protected function clean Validation Rules ( array $ rules , array $ data = null ) : array { if ( empty ( $ data ) ) { return [ ] ; } foreach ( $ rules as $ field = > $ rule ) { if ( ! array _key _exists ( $ field , $ data ) ) { unset ( $ rules [ $ field ] ) ; } } return $ rules ; } 
protected function fill Placeholders ( array $ rules , array $ data ) : array { $ replacements = [ ] ; foreach ( $ data as $ key = > $ value ) { $ replacements [ " { { $key } } " ] = $ value ; } if ( ! empty ( $ replacements ) ) { foreach ( $ rules as & $ rule ) { if ( is _array ( $ rule ) ) { foreach ( $ rule as & $ row ) { 
public function get Validation Rules ( array $ options = [ ] ) : array { $ rules = $ this - > validation Rules ; if ( isset ( $ options [ 'except ' ] ) ) { $ rules = array _diff _key ( $ rules , array _flip ( $ options [ 'except ' ] ) ) ; } elseif ( isset ( $ options [ 'only ' ] ) ) { $ rules = array _intersect _key ( $ rules , array _flip ( $ options [ 'only ' ] ) ) ; } return $ rules ; } 
public function count All Results ( bool $ reset = true , bool $ test = false ) { if ( $ this - > temp Use Soft Deletes = = = true ) { $ this - > builder ( ) - > where ( $ this - > deleted Field , 0 ) ; } return $ this - > builder ( ) - > count All Results ( $ reset , $ test ) ; } 
protected function trigger ( string $ event , array $ data ) { 
public function request ( $ method , string $ url , array $ options = [ ] ) : Response Interface { $ this - > parse Options ( $ options ) ; $ url = $ this - > prepare URL ( $ url ) ; $ method = filter _var ( $ method , FILTER _SANITIZE _STRING ) ; $ this - > send ( $ method , $ url ) ; return $ this - > response ; } 
public function set Auth ( string $ username , string $ password , string $ type = 'basic ' ) { $ this - > config [ 'auth ' ] = [ $ username , $ password , $ type , ] ; return $ this ; } 
public function set Form ( array $ params , bool $ multipart = false ) { if ( $ multipart ) { $ this - > config [ 'multipart ' ] = $ params ; } else { $ this - > config [ 'form _params ' ] = $ params ; } return $ this ; } 
protected function parse Options ( array $ options ) { if ( array _key _exists ( 'base URI ' , $ options ) ) { $ this - > base URI = $ this - > base URI - > set URI ( $ options [ 'base URI ' ] ) ; unset ( $ options [ 'base URI ' ] ) ; } if ( array _key _exists ( 'headers ' , $ options ) & & is _array ( $ options [ 'headers ' ] ) ) { foreach ( $ options [ 'headers ' ] as $ name = > $ value ) { $ this - > set Header ( $ name , $ value ) ; } unset ( $ options [ 'headers ' ] ) ; } if ( array _key _exists ( 'delay ' , $ options ) ) { 
protected function prepare URL ( string $ url ) : string { 
public function get Method ( bool $ upper = false ) : string { return ( $ upper ) ? strtoupper ( $ this - > method ) : strtolower ( $ this - > method ) ; } 
public function send ( string $ method , string $ url ) { 
protected function apply Request Headers ( array $ curl _options = [ ] ) : array { $ headers = $ this - > get Headers ( ) ; if ( empty ( $ headers ) ) { return $ curl _options ; } $ set = [ ] ; foreach ( $ headers as $ name = > $ value ) { $ set [ ] = $ name . ' : ' . $ this - > get Header Line ( $ name ) ; } $ curl _options [ CURLOPT _HTTPHEADER ] = $ set ; return $ curl _options ; } 
protected function apply Method ( string $ method , array $ curl _options ) : array { $ method = strtoupper ( $ method ) ; $ this - > method = $ method ; $ curl _options [ CURLOPT _CUSTOMREQUEST ] = $ method ; $ size = strlen ( $ this - > body ) ; 
protected function apply Body ( array $ curl _options = [ ] ) : array { if ( ! empty ( $ this - > body ) ) { $ curl _options [ CURLOPT _POSTFIELDS ] = ( string ) $ this - > get Body ( ) ; } return $ curl _options ; } 
protected function set Response Headers ( array $ headers = [ ] ) { foreach ( $ headers as $ header ) { if ( ( $ pos = strpos ( $ header , ' : ' ) ) ! = = false ) { $ title = substr ( $ header , 0 , $ pos ) ; $ value = substr ( $ header , $ pos + 1 ) ; $ this - > response - > set Header ( $ title , $ value ) ; } else if ( strpos ( $ header , 'HTTP ' ) = = = 0 ) { preg _match ( ' # ^HTTP \ / ( [ 1 2 ] \ . [ 0 1 ] ) ( [ 0 - 9 ] + ) ( . + ) # ' , $ header , $ matches ) ; if ( isset ( $ matches [ 1 ] ) ) { $ this - > response - > set Protocol Version ( $ matches [ 1 ] ) ; } if ( isset ( $ matches [ 2 ] ) ) { $ this - > response - > set Status Code ( $ matches [ 2 ] , $ matches [ 3 ] ? ? null ) ; } } } } 
protected function set CURLOptions ( array $ curl _options = [ ] , array $ config = [ ] ) { 
protected function send Request ( array $ curl _options = [ ] ) : string { $ ch = curl _init ( ) ; curl _setopt _array ( $ ch , $ curl _options ) ; 
public function run ( array $ params = [ ] ) { $ config = new App ( ) ; $ table Name = CLI : : get Option ( 't ' ) ? ? 'ci _sessions ' ; $ path = APPPATH . 'Database /Migrations / ' . date ( 'Ymd His _ ' ) . 'create _ ' . $ table Name . ' _table ' . ' .php ' ; $ data = [ 'namespace ' = > CLI : : get Option ( 'n ' ) ? ? APP _NAMESPACE ? ? 'App ' , 'DBGroup ' = > CLI : : get Option ( 'g ' ) , 'table Name ' = > $ table Name , 'match IP ' = > $ config - > session Match IP ? ? false , ] ; $ template = view ( ' \Code Igniter \Commands \Sessions \Views \migration .tpl .php ' , $ data , [ 'debug ' = > false ] ) ; $ template = str _replace ( ' @php ' , ' < ?php ' , $ template ) ; 
public function handle ( $ level , $ message ) : bool { $ filepath = $ this - > path . 'log - ' . date ( 'Y -m -d ' ) . ' . ' . $ this - > file Extension ; $ msg = ' ' ; if ( ! is _file ( $ filepath ) ) { $ newfile = true ; 
public function version ( string $ target Version , string $ namespace = null , string $ group = null ) { if ( ! $ this - > enabled ) { throw Config Exception : : for Disabled Migrations ( ) ; } $ this - > ensure Table ( ) ; 
public function current ( string $ group = null ) { $ this - > ensure Table ( ) ; 
public function find Migrations ( ) : array { $ migrations = [ ] ; 
protected function check Migrations ( array $ migrations , string $ method , string $ target Version ) : bool { 
public function get History ( string $ group = 'default ' ) : array { $ this - > ensure Table ( ) ; $ query = $ this - > db - > table ( $ this - > table ) - > where ( 'group ' , $ group ) - > where ( 'namespace ' , $ this - > namespace ) - > order By ( 'version ' , 'ASC ' ) - > get ( ) ; if ( ! $ query ) { return [ ] ; } return $ query - > get Result Array ( ) ; } 
protected function get Migration Name ( string $ migration ) : string { $ parts = explode ( ' _ ' , $ migration ) ; array _shift ( $ parts ) ; return implode ( ' _ ' , $ parts ) ; } 
protected function get Version ( ) : string { $ this - > ensure Table ( ) ; $ row = $ this - > db - > table ( $ this - > table ) - > select ( 'version ' ) - > where ( 'group ' , $ this - > group ) - > where ( 'namespace ' , $ this - > namespace ) - > order By ( 'version ' , 'DESC ' ) - > get ( ) ; return $ row & & ! is _null ( $ row - > get Row ( ) ) ? $ row - > get Row ( ) - > version : ' 0 ' ; } 
protected function add History ( string $ version ) { $ this - > db - > table ( $ this - > table ) - > insert ( [ 'version ' = > $ version , 'name ' = > $ this - > name , 'group ' = > $ this - > group , 'namespace ' = > $ this - > namespace , 'time ' = > time ( ) , ] ) ; if ( is _cli ( ) ) { $ this - > cli Messages [ ] = " \t " . CLI : : color ( lang ( 'Migrations .added ' ) , 'yellow ' ) . " ( $this - >namespace ) " . $ version . ' _ ' . $ this - > name ; } } 
protected function remove History ( string $ version ) { $ this - > db - > table ( $ this - > table ) - > where ( 'version ' , $ version ) - > where ( 'group ' , $ this - > group ) - > where ( 'namespace ' , $ this - > namespace ) - > delete ( ) ; if ( is _cli ( ) ) { $ this - > cli Messages [ ] = " \t " . CLI : : color ( lang ( 'Migrations .removed ' ) , 'yellow ' ) . " ( $this - >namespace ) " . $ version . ' _ ' . $ this - > name ; } } 
public function ensure Table ( ) { if ( $ this - > table Checked | | $ this - > db - > table Exists ( $ this - > table ) ) { return ; } $ forge = \ Config \ Database : : forge ( $ this - > db ) ; $ forge - > add Field ( [ 'version ' = > [ 'type ' = > 'VARCHAR ' , 'constraint ' = > 2 5 5 , 'null ' = > false , ] , 'name ' = > [ 'type ' = > 'VARCHAR ' , 'constraint ' = > 2 5 5 , 'null ' = > false , ] , 'group ' = > [ 'type ' = > 'VARCHAR ' , 'constraint ' = > 2 5 5 , 'null ' = > false , ] , 'namespace ' = > [ 'type ' = > 'VARCHAR ' , 'constraint ' = > 2 5 5 , 'null ' = > false , ] , 'time ' = > [ 'type ' = > 'INT ' , 'constraint ' = > 1 1 , 'null ' = > false , ] , ] ) ; $ forge - > create Table ( $ this - > table , true ) ; $ this - > table Checked = true ; } 
public function run ( array $ data = null , string $ group = null , string $ db _group = null ) : bool { $ data = $ data ? ? $ this - > data ; 
public function check ( $ value , string $ rule , array $ errors = [ ] ) : bool { $ this - > reset ( ) ; $ this - > set Rule ( 'check ' , null , $ rule , $ errors ) ; return $ this - > run ( [ 'check ' = > $ value , ] ) ; } 
protected function process Rules ( string $ field , string $ label = null , $ value , $ rules = null , array $ data ) : bool { 
public function with Request ( Request Interface $ request ) : Validation Interface { if ( in _array ( $ request - > get Method ( ) , [ 'put ' , 'patch ' , 'delete ' ] ) ) { $ this - > data = $ request - > get Raw Input ( ) ; } else { $ this - > data = $ request - > get Var ( ) ? ? [ ] ; } return $ this ; } 
public function set Rule ( string $ field , string $ label = null , string $ rules , array $ errors = [ ] ) { $ this - > rules [ $ field ] = [ 'label ' = > $ label , 'rules ' = > $ rules , ] ; $ this - > custom Errors = array _merge ( $ this - > custom Errors , [ $ field = > $ errors , ] ) ; return $ this ; } 
public function set Rules ( array $ rules , array $ errors = [ ] ) : Validation Interface { $ this - > custom Errors = $ errors ; foreach ( $ rules as $ field = > & $ rule ) { if ( is _array ( $ rule ) ) { if ( array _key _exists ( 'errors ' , $ rule ) ) { $ this - > custom Errors [ $ field ] = $ rule [ 'errors ' ] ; unset ( $ rule [ 'errors ' ] ) ; } } } $ this - > rules = $ rules ; return $ this ; } 
public function get Rule Group ( string $ group ) : array { if ( ! isset ( $ this - > config - > $ group ) ) { throw Validation Exception : : for Group Not Found ( $ group ) ; } if ( ! is _array ( $ this - > config - > $ group ) ) { throw Validation Exception : : for Group Not Array ( $ group ) ; } return $ this - > config - > $ group ; } 
public function set Rule Group ( string $ group ) { $ rules = $ this - > get Rule Group ( $ group ) ; $ this - > rules = $ rules ; $ error Name = $ group . ' _errors ' ; if ( isset ( $ this - > config - > $ error Name ) ) { $ this - > custom Errors = $ this - > config - > $ error Name ; } } 
public function list Errors ( string $ template = 'list ' ) : string { if ( ! array _key _exists ( $ template , $ this - > config - > templates ) ) { throw Validation Exception : : for Invalid Template ( $ template ) ; } return $ this - > view - > set Var ( 'errors ' , $ this - > get Errors ( ) ) - > render ( $ this - > config - > templates [ $ template ] ) ; } 
public function show Error ( string $ field , string $ template = 'single ' ) : string { if ( ! array _key _exists ( $ field , $ this - > get Errors ( ) ) ) { return ' ' ; } if ( ! array _key _exists ( $ template , $ this - > config - > templates ) ) { throw Validation Exception : : for Invalid Template ( $ template ) ; } return $ this - > view - > set Var ( 'error ' , $ this - > get Error ( $ field ) ) - > render ( $ this - > config - > templates [ $ template ] ) ; } 
protected function load Rule Sets ( ) { if ( empty ( $ this - > rule Set Files ) ) { throw Validation Exception : : for No Rule Sets ( ) ; } foreach ( $ this - > rule Set Files as $ file ) { $ this - > rule Set Instances [ ] = new $ file ( ) ; } } 
public function load Rule Group ( string $ group = null ) { if ( empty ( $ group ) ) { return null ; } if ( ! isset ( $ this - > config - > $ group ) ) { throw Validation Exception : : for Group Not Found ( $ group ) ; } if ( ! is _array ( $ this - > config - > $ group ) ) { throw Validation Exception : : for Group Not Array ( $ group ) ; } $ this - > rules = $ this - > config - > $ group ; 
public function get Error ( string $ field = null ) : string { if ( $ field = = = null & & count ( $ this - > rules ) = = = 1 ) { reset ( $ this - > rules ) ; $ field = key ( $ this - > rules ) ; } return array _key _exists ( $ field , $ this - > get Errors ( ) ) ? $ this - > errors [ $ field ] : ' ' ; } 
public function get Errors ( ) : array { 
public function set Error ( string $ field , string $ error ) : Validation Interface { $ this - > errors [ $ field ] = $ error ; return $ this ; } 
protected function get Error Message ( string $ rule , string $ field , string $ label = null , string $ param = null ) : string { 
protected function split Rules ( string $ rules ) : array { $ non _escape _bracket = ' ( ( ? < ! \ \ \ \ ) ( ? : \ \ \ \ \ \ \ \ ) * [ \ [ \ ] ] ) ' ; $ pipe _not _in _bracket = sprintf ( ' / \ | ( ? = ( ? : [ ^ \ [ \ ] ] * %s [ ^ \ [ \ ] ] * %s ) * ( ? ! [ ^ \ [ \ ] ] * %s ) ) / ' , $ non _escape _bracket , $ non _escape _bracket , $ non _escape _bracket ) ; $ _rules = preg _split ( $ pipe _not _in _bracket , $ rules ) ; return array _unique ( $ _rules ) ; } 
public function reset ( ) : Validation Interface { $ this - > data = [ ] ; $ this - > rules = [ ] ; $ this - > errors = [ ] ; $ this - > custom Errors = [ ] ; return $ this ; } 
public function format ( $ data ) { 
protected function array To XML ( array $ data , & $ output ) { foreach ( $ data as $ key = > $ value ) { if ( is _array ( $ value ) ) { if ( ! is _numeric ( $ key ) ) { $ subnode = $ output - > add Child ( " $key " ) ; $ this - > array To XML ( $ value , $ subnode ) ; } else { $ subnode = $ output - > add Child ( "item { $key } " ) ; $ this - > array To XML ( $ value , $ subnode ) ; } } else { $ output - > add Child ( " $key " , htmlspecialchars ( " $value " ) ) ; } } } 
public function log ( $ level , $ message , array $ context = [ ] ) : bool { if ( is _numeric ( $ level ) ) { $ level = array _search ( ( int ) $ level , $ this - > log Levels ) ; } * @var \Code Igniter \Log \Handlers \Handler Interface * / $ handler = $ this - > handlers [ $ class Name ] ; if ( ! $ handler - > can Handle ( $ level ) ) { continue ; } 
protected function interpolate ( $ message , array $ context = [ ] ) { if ( ! is _string ( $ message ) ) { return $ message ; } 
public function determine File ( ) : array { 
protected function clean File Names ( string $ file ) : string { $ file = str _replace ( APPPATH , 'APPPATH / ' , $ file ) ; $ file = str _replace ( SYSTEMPATH , 'SYSTEMPATH / ' , $ file ) ; $ file = str _replace ( FCPATH , 'FCPATH / ' , $ file ) ; return $ file ; } 
public function set URI ( string $ uri = null ) { if ( ! is _null ( $ uri ) ) { $ parts = parse _url ( $ uri ) ; if ( $ parts = = = false ) { throw HTTPException : : for Unable To Parse URI ( $ uri ) ; } $ this - > apply Parts ( $ parts ) ; } return $ this ; } 
public function get Authority ( bool $ ignore Port = false ) : string { if ( empty ( $ this - > host ) ) { return ' ' ; } $ authority = $ this - > host ; if ( ! empty ( $ this - > get User Info ( ) ) ) { $ authority = $ this - > get User Info ( ) . ' @ ' . $ authority ; } if ( ! empty ( $ this - > port ) & & ! $ ignore Port ) { 
public function get User Info ( ) { $ user Info = $ this - > user ; if ( $ this - > show Password = = = true & & ! empty ( $ this - > password ) ) { $ user Info . = ' : ' . $ this - > password ; } return $ user Info ; } 
public function get Query ( array $ options = [ ] ) : string { $ vars = $ this - > query ; if ( array _key _exists ( 'except ' , $ options ) ) { if ( ! is _array ( $ options [ 'except ' ] ) ) { $ options [ 'except ' ] = [ $ options [ 'except ' ] ] ; } foreach ( $ options [ 'except ' ] as $ var ) { unset ( $ vars [ $ var ] ) ; } } elseif ( array _key _exists ( 'only ' , $ options ) ) { $ temp = [ ] ; if ( ! is _array ( $ options [ 'only ' ] ) ) { $ options [ 'only ' ] = [ $ options [ 'only ' ] ] ; } foreach ( $ options [ 'only ' ] as $ var ) { if ( array _key _exists ( $ var , $ vars ) ) { $ temp [ $ var ] = $ vars [ $ var ] ; } } $ vars = $ temp ; } return empty ( $ vars ) ? ' ' : http _build _query ( $ vars ) ; } 
public function get Segment ( int $ number ) : string { 
public function set Segment ( int $ number , $ value ) { 
public static function create URIString ( string $ scheme = null , string $ authority = null , string $ path = null , string $ query = null , string $ fragment = null ) : string { $ uri = ' ' ; if ( ! empty ( $ scheme ) ) { $ uri . = $ scheme . ' : / / ' ; } if ( ! empty ( $ authority ) ) { $ uri . = $ authority ; } if ( $ path ) { $ uri . = substr ( $ uri , - 1 , 1 ) ! = = ' / ' ? ' / ' . ltrim ( $ path , ' / ' ) : $ path ; } if ( $ query ) { $ uri . = ' ? ' . $ query ; } if ( $ fragment ) { $ uri . = ' # ' . $ fragment ; } return $ uri ; } 
public function set Authority ( string $ str ) { $ parts = parse _url ( $ str ) ; if ( empty ( $ parts [ 'host ' ] ) & & ! empty ( $ parts [ 'path ' ] ) ) { $ parts [ 'host ' ] = $ parts [ 'path ' ] ; unset ( $ parts [ 'path ' ] ) ; } $ this - > apply Parts ( $ parts ) ; return $ this ; } 
public function set Scheme ( string $ str ) { $ str = strtolower ( $ str ) ; $ str = preg _replace ( ' # : ( / / ) ? $ # ' , ' ' , $ str ) ; $ this - > scheme = $ str ; return $ this ; } 
public function set User Info ( string $ user , string $ pass ) { $ this - > user = trim ( $ user ) ; $ this - > password = trim ( $ pass ) ; return $ this ; } 
public function set Port ( int $ port = null ) { if ( is _null ( $ port ) ) { return $ this ; } if ( $ port < = 0 | | $ port > 6 5 5 3 5 ) { throw HTTPException : : for Invalid Port ( $ port ) ; } $ this - > port = $ port ; return $ this ; } 
public function set Path ( string $ path ) { $ this - > path = $ this - > filter Path ( $ path ) ; $ this - > segments = explode ( ' / ' , $ this - > path ) ; return $ this ; } 
public function refresh Path ( ) { $ this - > path = $ this - > filter Path ( implode ( ' / ' , $ this - > segments ) ) ; $ this - > segments = explode ( ' / ' , $ this - > path ) ; return $ this ; } 
public function set Query ( string $ query ) { if ( strpos ( $ query , ' # ' ) ! = = false ) { throw HTTPException : : for Malformed Query String ( ) ; } 
protected function decode ( string $ value ) : string { if ( empty ( $ value ) ) { return $ value ; } $ decoded = urldecode ( $ value ) ; 
protected function split Query Part ( string $ part ) { $ parts = explode ( ' = ' , $ part , 2 ) ; 
public function add Query ( string $ key , $ value = null ) { $ this - > query [ $ key ] = $ value ; return $ this ; } 
public function keep Query ( . . . $ params ) { $ temp = [ ] ; foreach ( $ this - > query as $ key = > $ value ) { if ( ! in _array ( $ key , $ params ) ) { continue ; } $ temp [ $ key ] = $ value ; } $ this - > query = $ temp ; return $ this ; } 
protected function filter Path ( string $ path = null ) : string { $ orig = $ path ; 
protected function apply Parts ( array $ parts ) { if ( ! empty ( $ parts [ 'host ' ] ) ) { $ this - > host = $ parts [ 'host ' ] ; } if ( ! empty ( $ parts [ 'user ' ] ) ) { $ this - > user = $ parts [ 'user ' ] ; } if ( ! empty ( $ parts [ 'path ' ] ) ) { $ this - > path = $ this - > filter Path ( $ parts [ 'path ' ] ) ; } if ( ! empty ( $ parts [ 'query ' ] ) ) { $ this - > set Query ( $ parts [ 'query ' ] ) ; } if ( ! empty ( $ parts [ 'fragment ' ] ) ) { $ this - > fragment = $ parts [ 'fragment ' ] ; } 
public function resolve Relative URI ( string $ uri ) { $ relative = new URI ( ) ; $ relative - > set URI ( $ uri ) ; if ( $ relative - > get Scheme ( ) = = = $ this - > get Scheme ( ) ) { $ relative - > set Scheme ( ' ' ) ; } $ transformed = clone $ relative ; 
protected function merge Paths ( URI $ base , URI $ reference ) : string { if ( ! empty ( $ base - > get Authority ( ) ) & & empty ( $ base - > get Path ( ) ) ) { return ' / ' . ltrim ( $ reference - > get Path ( ) , ' / ' ) ; } $ path = explode ( ' / ' , $ base - > get Path ( ) ) ; if ( empty ( $ path [ 0 ] ) ) { unset ( $ path [ 0 ] ) ; } array _pop ( $ path ) ; array _push ( $ path , $ reference - > get Path ( ) ) ; return implode ( ' / ' , $ path ) ; } 
public function remove Dot Segments ( string $ path ) : string { if ( empty ( $ path ) | | $ path = = = ' / ' ) { return $ path ; } $ output = [ ] ; $ input = explode ( ' / ' , $ path ) ; if ( empty ( $ input [ 0 ] ) ) { unset ( $ input [ 0 ] ) ; $ input = array _values ( $ input ) ; } 
public function run ( array $ params ) { $ config = new Autoload ( ) ; $ tbody = [ ] ; foreach ( $ config - > psr 4 as $ ns = > $ path ) { $ path = realpath ( $ path ) ? ? $ path ; $ tbody [ ] = [ $ ns , realpath ( $ path ) ? ? $ path , is _dir ( $ path ) ? 'Yes ' : 'MISSING ' , ] ; } $ thead = [ 'Namespace ' , 'Path ' , 'Found ? ' , ] ; CLI : : table ( $ tbody , $ thead ) ; } 
public function append Value ( $ value = null ) { if ( ! is _array ( $ this - > value ) ) { $ this - > value = [ $ this - > value ] ; } $ this - > value [ ] = $ value ; return $ this ; } 
public function prepend Value ( $ value = null ) { if ( ! is _array ( $ this - > value ) ) { $ this - > value = [ $ this - > value ] ; } array _unshift ( $ this - > value , $ value ) ; return $ this ; } 
public function get Value Line ( ) : string { if ( is _string ( $ this - > value ) ) { return $ this - > value ; } else if ( ! is _array ( $ this - > value ) ) { return ' ' ; } $ options = [ ] ; foreach ( $ this - > value as $ key = > $ value ) { if ( is _string ( $ key ) & & ! is _array ( $ value ) ) { $ options [ ] = $ key . ' = ' . $ value ; } else if ( is _array ( $ value ) ) { $ key = key ( $ value ) ; $ options [ ] = $ key . ' = ' . $ value [ $ key ] ; } else if ( is _numeric ( $ key ) ) { $ options [ ] = $ value ; } } return implode ( ' , ' , $ options ) ; } 
public function get Previous ( ) { if ( ! $ this - > has Previous ( ) ) { return null ; } $ uri = clone $ this - > uri ; if ( $ this - > segment = = = 0 ) { $ uri - > add Query ( 'page ' , $ this - > first - 1 ) ; } else { $ uri - > set Segment ( $ this - > segment , $ this - > first - 1 ) ; } return ( string ) $ uri ; } 
public function get Next ( ) { if ( ! $ this - > has Next ( ) ) { return null ; } $ uri = clone $ this - > uri ; if ( $ this - > segment = = = 0 ) { $ uri - > add Query ( 'page ' , $ this - > last + 1 ) ; } else { $ uri - > set Segment ( $ this - > segment , $ this - > last + 1 ) ; } return ( string ) $ uri ; } 
public function get First ( ) : string { $ uri = clone $ this - > uri ; if ( $ this - > segment = = = 0 ) { $ uri - > add Query ( 'page ' , 1 ) ; } else { $ uri - > set Segment ( $ this - > segment , 1 ) ; } return ( string ) $ uri ; } 
public function get Last ( ) : string { $ uri = clone $ this - > uri ; if ( $ this - > segment = = = 0 ) { $ uri - > add Query ( 'page ' , $ this - > page Count ) ; } else { $ uri - > set Segment ( $ this - > segment , $ this - > page Count ) ; } return ( string ) $ uri ; } 
public function get Current ( ) : string { $ uri = clone $ this - > uri ; if ( $ this - > segment = = = 0 ) { $ uri - > add Query ( 'page ' , $ this - > current ) ; } else { $ uri - > set Segment ( $ this - > segment , $ this - > current ) ; } return ( string ) $ uri ; } 
public function links ( ) : array { $ links = [ ] ; $ uri = clone $ this - > uri ; for ( $ i = $ this - > first ; $ i < = $ this - > last ; $ i + + ) { $ links [ ] = [ 'uri ' = > ( string ) ( $ this - > segment = = = 0 ? $ uri - > add Query ( 'page ' , $ i ) : $ uri - > set Segment ( $ this - > segment , $ i ) ) , 'title ' = > ( int ) $ i , 'active ' = > ( $ i = = = $ this - > current ) , ] ; } return $ links ; } 
protected function update Pages ( int $ count = null ) { if ( is _null ( $ count ) ) { return ; } $ this - > first = $ this - > current - $ count > 0 ? ( int ) ( $ this - > current - $ count ) : 1 ; $ this - > last = $ this - > current + $ count < = $ this - > page Count ? ( int ) ( $ this - > current + $ count ) : ( int ) $ this - > page Count ; } 
public function start ( string $ name , float $ time = null ) { $ this - > timers [ strtolower ( $ name ) ] = [ 'start ' = > ! empty ( $ time ) ? $ time : microtime ( true ) , 'end ' = > null , ] ; return $ this ; } 
public function stop ( string $ name ) { $ name = strtolower ( $ name ) ; if ( empty ( $ this - > timers [ $ name ] ) ) { throw new \ Runtime Exception ( 'Cannot stop timer : invalid name given . ' ) ; } $ this - > timers [ $ name ] [ 'end ' ] = microtime ( true ) ; return $ this ; } 
public function get Elapsed Time ( string $ name , int $ decimals = 4 ) { $ name = strtolower ( $ name ) ; if ( empty ( $ this - > timers [ $ name ] ) ) { return null ; } $ timer = $ this - > timers [ $ name ] ; if ( empty ( $ timer [ 'end ' ] ) ) { $ timer [ 'end ' ] = microtime ( true ) ; } return ( float ) number _format ( $ timer [ 'end ' ] - $ timer [ 'start ' ] , $ decimals ) ; } 
public function get Timers ( int $ decimals = 4 ) : array { $ timers = $ this - > timers ; foreach ( $ timers as & $ timer ) { if ( empty ( $ timer [ 'end ' ] ) ) { $ timer [ 'end ' ] = microtime ( true ) ; } $ timer [ 'duration ' ] = ( float ) number _format ( $ timer [ 'end ' ] - $ timer [ 'start ' ] , $ decimals ) ; } return $ timers ; } 
public function initialize ( ) { if ( $ this - > conn ID ) { return ; } 
public function add Table Alias ( string $ table ) { if ( ! in _array ( $ table , $ this - > aliased Tables ) ) { $ this - > aliased Tables [ ] = $ table ; } return $ this ; } 
public function query ( string $ sql , $ binds = null , bool $ set Escape Flags = true , string $ query Class = 'Code Igniter \ \Database \ \Query ' ) { if ( empty ( $ this - > conn ID ) ) { $ this - > initialize ( ) ; } $ result Class = str _replace ( 'Connection ' , 'Result ' , get _class ( $ this ) ) ; $ query = new $ query Class ( $ this ) ; $ query - > set Query ( $ sql , $ binds , $ set Escape Flags ) ; if ( ! empty ( $ this - > swap Pre ) & & ! empty ( $ this - > DBPrefix ) ) { $ query - > swap Prefix ( $ this - > DBPrefix , $ this - > swap Pre ) ; } $ start Time = microtime ( true ) ; 
public function simple Query ( string $ sql ) { if ( empty ( $ this - > conn ID ) ) { $ this - > initialize ( ) ; } return $ this - > execute ( $ sql ) ; } 
public function trans Start ( bool $ test _mode = false ) : bool { if ( ! $ this - > trans Enabled ) { return false ; } return $ this - > trans Begin ( $ test _mode ) ; } 
public function trans Complete ( ) : bool { if ( ! $ this - > trans Enabled ) { return false ; } 
public function trans Begin ( bool $ test _mode = false ) : bool { if ( ! $ this - > trans Enabled ) { return false ; } 
public function trans Commit ( ) : bool { if ( ! $ this - > trans Enabled | | $ this - > trans Depth = = = 0 ) { return false ; } 
public function trans Rollback ( ) : bool { if ( ! $ this - > trans Enabled | | $ this - > trans Depth = = = 0 ) { return false ; } 
public function table ( $ table Name ) { if ( empty ( $ table Name ) ) { throw new Database Exception ( 'You must set the database table to be used with your query . ' ) ; } $ class Name = str _replace ( 'Connection ' , 'Builder ' , get _class ( $ this ) ) ; return new $ class Name ( $ table Name , $ this ) ; } 
public function prepare ( \ Closure $ func , array $ options = [ ] ) { if ( empty ( $ this - > conn ID ) ) { $ this - > initialize ( ) ; } $ this - > pretend ( true ) ; $ sql = $ func ( $ this ) ; $ this - > pretend ( false ) ; if ( $ sql instanceof Query Interface ) { $ sql = $ sql - > get Original Query ( ) ; } $ class = str _ireplace ( 'Connection ' , 'Prepared Query ' , get _class ( $ this ) ) ; $ class = new $ class ( $ this ) ; return $ class - > prepare ( $ sql , $ options ) ; } 
public function protect Identifiers ( $ item , bool $ prefix Single = false , bool $ protect Identifiers = null , bool $ field Exists = true ) { if ( ! is _bool ( $ protect Identifiers ) ) { $ protect Identifiers = $ this - > protect Identifiers ; } if ( is _array ( $ item ) ) { $ escaped _array = [ ] ; foreach ( $ item as $ k = > $ v ) { $ escaped _array [ $ this - > protect Identifiers ( $ k ) ] = $ this - > protect Identifiers ( $ v , $ prefix Single , $ protect Identifiers , $ field Exists ) ; } return $ escaped _array ; } 
public function escape Identifiers ( $ item ) { if ( $ this - > escape Char = = = ' ' | | empty ( $ item ) | | in _array ( $ item , $ this - > reserved Identifiers ) ) { return $ item ; } elseif ( is _array ( $ item ) ) { foreach ( $ item as $ key = > $ value ) { $ item [ $ key ] = $ this - > escape Identifiers ( $ value ) ; } return $ item ; } 
public function escape ( $ str ) { if ( is _array ( $ str ) ) { $ str = array _map ( [ & $ this , 'escape ' ] , $ str ) ; return $ str ; } else if ( is _string ( $ str ) | | ( is _object ( $ str ) & & method _exists ( $ str , ' _ _to String ' ) ) ) { return " ' " . $ this - > escape String ( $ str ) . " ' " ; } else if ( is _bool ( $ str ) ) { return ( $ str = = = false ) ? 0 : 1 ; } else if ( is _numeric ( $ str ) & & $ str < 0 ) { return " ' { $str } ' " ; } else if ( $ str = = = null ) { return 'NULL ' ; } return $ str ; } 
public function escape String ( $ str , bool $ like = false ) { if ( is _array ( $ str ) ) { foreach ( $ str as $ key = > $ val ) { $ str [ $ key ] = $ this - > escape String ( $ val , $ like ) ; } return $ str ; } $ str = $ this - > _escape String ( $ str ) ; 
public function call Function ( string $ function Name , . . . $ params ) : bool { $ driver = ( $ this - > DBDriver = = = 'postgre ' ? 'pg ' : strtolower ( $ this - > DBDriver ) ) . ' _ ' ; if ( false = = = strpos ( $ driver , $ function Name ) ) { $ function Name = $ driver . $ function Name ; } if ( ! function _exists ( $ function Name ) ) { if ( $ this - > DBDebug ) { throw new Database Exception ( 'This feature is not available for the database you are using . ' ) ; } return false ; } return $ function Name ( . . . $ params ) ; } 
public function list Tables ( bool $ constrain By Prefix = false ) { * Due to array _shift ( ) accepting its argument by reference , if * E _STRICT is on , this would trigger a warning . So we 'll have to * assign it first . * / $ key = array _keys ( $ row ) ; $ key = array _shift ( $ key ) ; } } $ this - > data Cache [ 'table _names ' ] [ ] = $ row [ $ key ] ; } return $ this - > data Cache [ 'table _names ' ] ; } 
public function table Exists ( string $ table Name ) : bool { return in _array ( $ this - > protect Identifiers ( $ table Name , true , false , false ) , $ this - > list Tables ( ) ) ; } 
public function field Exists ( string $ field Name , string $ table Name ) : bool { return in _array ( $ field Name , $ this - > get Field Names ( $ table Name ) ) ; } 
public function get Field Data ( string $ table ) { $ fields = $ this - > _field Data ( $ this - > protect Identifiers ( $ table , true , false , false ) ) ; return $ fields ? ? false ; } 
public function get Index Data ( string $ table ) { $ fields = $ this - > _index Data ( $ this - > protect Identifiers ( $ table , true , false , false ) ) ; return $ fields ? ? false ; } 
public function get Foreign Key Data ( string $ table ) { $ fields = $ this - > _foreign Key Data ( $ this - > protect Identifiers ( $ table , true , false , false ) ) ; return $ fields ? ? false ; } 
protected function get Env Value ( string $ property , string $ prefix , string $ short Prefix ) { $ short Prefix = ltrim ( $ short Prefix , ' \ \ ' ) ; switch ( true ) { case array _key _exists ( " { $short Prefix } . { $property } " , $ _ENV ) : return $ _ENV [ " { $short Prefix } . { $property } " ] ; break ; case array _key _exists ( " { $short Prefix } . { $property } " , $ _SERVER ) : return $ _SERVER [ " { $short Prefix } . { $property } " ] ; break ; case array _key _exists ( " { $prefix } . { $property } " , $ _ENV ) : return $ _ENV [ " { $prefix } . { $property } " ] ; break ; case array _key _exists ( " { $prefix } . { $property } " , $ _SERVER ) : return $ _SERVER [ " { $prefix } . { $property } " ] ; break ; default : $ value = getenv ( $ property ) ; return $ value = = = false ? null : $ value ; } } 
protected function register Properties ( ) { if ( ! static : : $ module Config - > should Discover ( 'registrars ' ) ) { return ; } if ( ! static : : $ did Discovery ) { $ locator = \ Config \ Services : : locator ( ) ; $ registrars Files = $ locator - > search ( 'Config /Registrar .php ' ) ; foreach ( $ registrars Files as $ file ) { $ class Name = $ locator - > get Classname ( $ file ) ; static : : $ registrars [ ] = new $ class Name ( ) ; } static : : $ did Discovery = true ; } $ short Name = ( new \ Reflection Class ( $ this ) ) - > get Short Name ( ) ; 
public function get ( string $ key ) { $ key = $ this - > prefix . $ key ; $ data = $ this - > get Item ( $ key ) ; return is _array ( $ data ) ? $ data [ 'data ' ] : null ; } 
public function save ( string $ key , $ value , int $ ttl = 6 0 ) { $ key = $ this - > prefix . $ key ; $ contents = [ 'time ' = > time ( ) , 'ttl ' = > $ ttl , 'data ' = > $ value , ] ; if ( $ this - > write File ( $ this - > path . $ key , serialize ( $ contents ) ) ) { chmod ( $ this - > path . $ key , 0 6 4 0 ) ; return true ; } return false ; } 
public function delete ( string $ key ) { $ key = $ this - > prefix . $ key ; return is _file ( $ this - > path . $ key ) ? unlink ( $ this - > path . $ key ) : false ; } 
public function decrement ( string $ key , int $ offset = 1 ) { $ key = $ this - > prefix . $ key ; $ data = $ this - > get Item ( $ key ) ; if ( $ data = = = false ) { $ data = [ 'data ' = > 0 , 'ttl ' = > 6 0 , ] ; } elseif ( ! is _int ( $ data [ 'data ' ] ) ) { return false ; } $ new _value = $ data [ 'data ' ] - $ offset ; return $ this - > save ( $ key , $ new _value , $ data [ 'ttl ' ] ) ? $ new _value : false ; } 
public function get Meta Data ( string $ key ) { $ key = $ this - > prefix . $ key ; if ( ! is _file ( $ this - > path . $ key ) ) { return false ; } $ data = @ unserialize ( file _get _contents ( $ this - > path . $ key ) ) ; if ( is _array ( $ data ) ) { $ mtime = filemtime ( $ this - > path . $ key ) ; if ( ! isset ( $ data [ 'ttl ' ] ) ) { return false ; } return [ 'expire ' = > $ mtime + $ data [ 'ttl ' ] , 'mtime ' = > $ mtime , 'data ' = > $ data [ 'data ' ] , ] ; } return false ; } 
protected function get Item ( string $ key ) { if ( ! is _file ( $ this - > path . $ key ) ) { return false ; } $ data = unserialize ( file _get _contents ( $ this - > path . $ key ) ) ; if ( $ data [ 'ttl ' ] > 0 & & time ( ) > $ data [ 'time ' ] + $ data [ 'ttl ' ] ) { unlink ( $ this - > path . $ key ) ; return false ; } return $ data ; } 
protected function write File ( $ path , $ data , $ mode = 'wb ' ) { if ( ( $ fp = @ fopen ( $ path , $ mode ) ) = = = false ) { return false ; } flock ( $ fp , LOCK _EX ) ; for ( $ result = $ written = 0 , $ length = strlen ( $ data ) ; $ written < $ length ; $ written + = $ result ) { if ( ( $ result = fwrite ( $ fp , substr ( $ data , $ written ) ) ) = = = false ) { break ; } } flock ( $ fp , LOCK _UN ) ; fclose ( $ fp ) ; return is _int ( $ result ) ; } 
protected function delete Files ( string $ path , bool $ del _dir = false , bool $ htdocs = false , int $ _level = 0 ) : bool { 
protected function get Dir File Info ( string $ source _dir , bool $ top _level _only = true , bool $ _recursion = false ) { static $ _filedata = [ ] ; $ relative _path = $ source _dir ; if ( $ fp = @ opendir ( $ source _dir ) ) { 
protected function get File Info ( string $ file , $ returned _values = [ 'name ' , 'server _path ' , 'size ' , 'date ' ] ) { if ( ! is _file ( $ file ) ) { return false ; } if ( is _string ( $ returned _values ) ) { $ returned _values = explode ( ' , ' , $ returned _values ) ; } foreach ( $ returned _values as $ key ) { switch ( $ key ) { case 'name ' : $ file Info [ 'name ' ] = basename ( $ file ) ; break ; case 'server _path ' : $ file Info [ 'server _path ' ] = $ file ; break ; case 'size ' : $ file Info [ 'size ' ] = filesize ( $ file ) ; break ; case 'date ' : $ file Info [ 'date ' ] = filemtime ( $ file ) ; break ; case 'readable ' : $ file Info [ 'readable ' ] = is _readable ( $ file ) ; break ; case 'writable ' : $ file Info [ 'writable ' ] = is _writable ( $ file ) ; break ; case 'executable ' : $ file Info [ 'executable ' ] = is _executable ( $ file ) ; break ; case 'fileperms ' : $ file Info [ 'fileperms ' ] = fileperms ( $ file ) ; break ; } } return $ file Info ; } 
public function display ( ) : array { $ raw Files = get _included _files ( ) ; $ core Files = [ ] ; $ user Files = [ ] ; foreach ( $ raw Files as $ file ) { $ path = $ this - > clean Path ( $ file ) ; if ( strpos ( $ path , 'SYSTEMPATH ' ) ! = = false ) { $ core Files [ ] = [ 'name ' = > basename ( $ file ) , 'path ' = > $ path , ] ; } else { $ user Files [ ] = [ 'name ' = > basename ( $ file ) , 'path ' = > $ path , ] ; } } sort ( $ user Files ) ; sort ( $ core Files ) ; return [ 'core Files ' = > $ core Files , 'user Files ' = > $ user Files , ] ; } 
public function initialize ( ) { 
public function run ( Route Collection Interface $ routes = null , bool $ return Response = false ) { $ this - > start Benchmark ( ) ; $ this - > get Request Object ( ) ; $ this - > get Response Object ( ) ; $ this - > force Secure Access ( ) ; $ this - > spoof Request Method ( ) ; Events : : trigger ( 'pre _system ' ) ; 
protected function handle Request ( Route Collection Interface $ routes = null , $ cache Config , bool $ return Response = false ) { $ route Filter = $ this - > try To Route It ( $ routes ) ; 
protected function start Benchmark ( ) { $ this - > start Time = microtime ( true ) ; $ this - > benchmark = Services : : timer ( ) ; $ this - > benchmark - > start ( 'total _execution ' , $ this - > start Time ) ; $ this - > benchmark - > start ( 'bootstrap ' ) ; } 
protected function get Request Object ( ) { if ( $ this - > request instanceof Request ) { return ; } if ( is _cli ( ) & & ! ( ENVIRONMENT = = = 'testing ' ) ) { $ this - > request = Services : : clirequest ( $ this - > config ) ; } else { $ this - > request = Services : : request ( $ this - > config ) ; 
protected function get Response Object ( ) { $ this - > response = Services : : response ( $ this - > config ) ; if ( ! is _cli ( ) | | ENVIRONMENT = = = 'testing ' ) { $ this - > response - > set Protocol Version ( $ this - > request - > get Protocol Version ( ) ) ; } 
protected function force Secure Access ( $ duration = 3 1 5 3 6 0 0 0 ) { if ( $ this - > config - > force Global Secure Requests ! = = true ) { return ; } force _https ( $ duration , $ this - > request , $ this - > response ) ; } 
public function display Cache ( $ config ) { if ( $ cached Response = cache ( ) - > get ( $ this - > generate Cache Name ( $ config ) ) ) { $ cached Response = unserialize ( $ cached Response ) ; if ( ! is _array ( $ cached Response ) | | ! isset ( $ cached Response [ 'output ' ] ) | | ! isset ( $ cached Response [ 'headers ' ] ) ) { throw new Exception ( 'Error unserializing page cache ' ) ; } $ headers = $ cached Response [ 'headers ' ] ; $ output = $ cached Response [ 'output ' ] ; 
public function cache Page ( Cache $ config ) { $ headers = [ ] ; foreach ( $ this - > response - > get Headers ( ) as $ header ) { $ headers [ $ header - > get Name ( ) ] = $ header - > get Value Line ( ) ; } return cache ( ) - > save ( $ this - > generate Cache Name ( $ config ) , serialize ( [ 'headers ' = > $ headers , 'output ' = > $ this - > output ] ) , static : : $ cache TTL ) ; } 
protected function generate Cache Name ( $ config ) : string { if ( is _cli ( ) & & ! ( ENVIRONMENT = = = 'testing ' ) ) { return md 5 ( $ this - > request - > get Path ( ) ) ; } $ uri = $ this - > request - > uri ; if ( $ config - > cache Query String ) { $ name = URI : : create URIString ( $ uri - > get Scheme ( ) , $ uri - > get Authority ( ) , $ uri - > get Path ( ) , $ uri - > get Query ( ) ) ; } else { $ name = URI : : create URIString ( $ uri - > get Scheme ( ) , $ uri - > get Authority ( ) , $ uri - > get Path ( ) ) ; } return md 5 ( $ name ) ; } 
public function display Performance Metrics ( string $ output ) : string { $ this - > total Time = $ this - > benchmark - > get Elapsed Time ( 'total _execution ' ) ; $ output = str _replace ( ' {elapsed _time } ' , $ this - > total Time , $ output ) ; return $ output ; } 
protected function try To Route It ( Route Collection Interface $ routes = null ) { if ( empty ( $ routes ) | | ! $ routes instanceof Route Collection Interface ) { require APPPATH . 'Config /Routes .php ' ; } 
protected function determine Path ( ) { if ( ! empty ( $ this - > path ) ) { return $ this - > path ; } return ( is _cli ( ) & & ! ( ENVIRONMENT = = = 'testing ' ) ) ? $ this - > request - > get Path ( ) : $ this - > request - > uri - > get Path ( ) ; } 
protected function start Controller ( ) { $ this - > benchmark - > start ( 'controller ' ) ; $ this - > benchmark - > start ( 'controller _constructor ' ) ; 
protected function create Controller ( ) { $ class = new $ this - > controller ( ) ; $ class - > init Controller ( $ this - > request , $ this - > response , Services : : logger ( ) ) ; $ this - > benchmark - > stop ( 'controller _constructor ' ) ; return $ class ; } 
protected function run Controller ( $ class ) { if ( method _exists ( $ class , ' _remap ' ) ) { $ output = $ class - > _remap ( $ this - > method , . . . $ this - > router - > params ( ) ) ; } else { $ output = $ class - > { $ this - > method } ( . . . $ this - > router - > params ( ) ) ; } $ this - > benchmark - > stop ( 'controller ' ) ; return $ output ; } 
protected function display 4 0 4errors ( Page Not Found Exception $ e ) { 
protected function gather Output ( $ cache Config = null , $ returned = null ) { $ this - > output = ob _get _contents ( ) ; 
public function store Previous URL ( $ uri ) { 
public function spoof Request Method ( ) { if ( is _cli ( ) ) { return ; } 
public static function get Handler ( $ config , string $ handler = null , string $ backup = null ) { if ( ! isset ( $ config - > valid Handlers ) | | ! is _array ( $ config - > valid Handlers ) ) { throw Cache Exception : : for Invalid Handlers ( ) ; } if ( ! isset ( $ config - > handler ) | | ! isset ( $ config - > backup Handler ) ) { throw Cache Exception : : for No Backup ( ) ; } $ handler = ! empty ( $ handler ) ? $ handler : $ config - > handler ; $ backup = ! empty ( $ backup ) ? $ backup : $ config - > backup Handler ; if ( ! array _key _exists ( $ handler , $ config - > valid Handlers ) | | ! array _key _exists ( $ backup , $ config - > valid Handlers ) ) { throw Cache Exception : : for Handler Not Found ( ) ; } 
public function select ( $ select = ' * ' , bool $ escape = null ) { if ( is _string ( $ select ) ) { $ select = explode ( ' , ' , $ select ) ; } * When doing 'SELECT NULL as field _alias FROM table ' * null gets taken as a field , and therefore escaped * with backticks . * This prevents NULL being escaped * @see https : * / if ( strtoupper ( mb _substr ( trim ( $ val ) , 0 , 4 ) ) = = = 'NULL ' ) { $ escape = false ; } $ this - > QBNo Escape [ ] = $ escape ; } } return $ this ; } 
protected function max Min Avg Sum ( string $ select = ' ' , string $ alias = ' ' , string $ type = 'MAX ' ) { if ( $ select = = = ' ' ) { throw Data Exception : : for Empty Input Given ( 'Select ' ) ; } if ( strpos ( $ select , ' , ' ) ! = = false ) { throw Data Exception : : for Invalid Argument ( 'column name not separated by comma ' ) ; } $ type = strtoupper ( $ type ) ; if ( ! in _array ( $ type , [ 'MAX ' , 'MIN ' , 'AVG ' , 'SUM ' ] ) ) { throw new Database Exception ( 'Invalid function type : ' . $ type ) ; } if ( $ alias = = = ' ' ) { $ alias = $ this - > create Alias From Table ( trim ( $ select ) ) ; } $ sql = $ type . ' ( ' . $ this - > db - > protect Identifiers ( trim ( $ select ) ) . ' ) AS ' . $ this - > db - > escape Identifiers ( trim ( $ alias ) ) ; $ this - > QBSelect [ ] = $ sql ; $ this - > QBNo Escape [ ] = null ; return $ this ; } 
protected function create Alias From Table ( string $ item ) : string { if ( strpos ( $ item , ' . ' ) ! = = false ) { $ item = explode ( ' . ' , $ item ) ; return end ( $ item ) ; } return $ item ; } 
public function from ( $ from , bool $ overwrite = false ) { if ( $ overwrite = = = true ) { $ this - > QBFrom = [ ] ; $ this - > db - > set Aliased Tables ( [ ] ) ; } foreach ( ( array ) $ from as $ val ) { if ( strpos ( $ val , ' , ' ) ! = = false ) { foreach ( explode ( ' , ' , $ val ) as $ v ) { $ v = trim ( $ v ) ; $ this - > track Aliases ( $ v ) ; $ this - > QBFrom [ ] = $ v = $ this - > db - > protect Identifiers ( $ v , true , null , false ) ; } } else { $ val = trim ( $ val ) ; 
public function join ( string $ table , string $ cond , string $ type = ' ' , bool $ escape = null ) { if ( $ type ! = = ' ' ) { $ type = strtoupper ( trim ( $ type ) ) ; if ( ! in _array ( $ type , [ 'LEFT ' , 'RIGHT ' , 'OUTER ' , 'INNER ' , 'LEFT OUTER ' , 'RIGHT OUTER ' ] , true ) ) { $ type = ' ' ; } else { $ type . = ' ' ; } } 
public function where ( $ key , $ value = null , bool $ escape = null ) { return $ this - > where Having ( 'QBWhere ' , $ key , $ value , 'AND ' , $ escape ) ; } 
public function or Where ( $ key , $ value = null , bool $ escape = null ) { return $ this - > where Having ( 'QBWhere ' , $ key , $ value , 'OR ' , $ escape ) ; } 
protected function where Having ( string $ qb _key , $ key , $ value = null , string $ type = 'AND ' , bool $ escape = null ) { if ( ! is _array ( $ key ) ) { $ key = [ $ key = > $ value ] ; } 
public function where In ( string $ key = null , array $ values = null , bool $ escape = null ) { return $ this - > _where In ( $ key , $ values , false , 'AND ' , $ escape ) ; } 
public function where Not In ( string $ key = null , array $ values = null , bool $ escape = null ) { return $ this - > _where In ( $ key , $ values , true , 'AND ' , $ escape ) ; } 
protected function _where In ( string $ key = null , array $ values = null , bool $ not = false , string $ type = 'AND ' , bool $ escape = null ) { if ( $ key = = = null | | $ values = = = null ) { return $ this ; } is _bool ( $ escape ) | | $ escape = $ this - > db - > protect Identifiers ; $ ok = $ key ; if ( $ escape = = = true ) { $ key = $ this - > db - > protect Identifiers ( $ key ) ; } $ not = ( $ not ) ? ' NOT ' : ' ' ; $ where _in = array _values ( $ values ) ; $ ok = $ this - > set Bind ( $ ok , $ where _in , $ escape ) ; $ prefix = empty ( $ this - > QBWhere ) ? $ this - > group Get Type ( ' ' ) : $ this - > group Get Type ( $ type ) ; $ where _in = [ 'condition ' = > $ prefix . $ key . $ not . " IN : { $ok } : " , 'escape ' = > false , ] ; $ this - > QBWhere [ ] = $ where _in ; return $ this ; } 
public function or Like ( $ field , string $ match = ' ' , string $ side = 'both ' , bool $ escape = null , bool $ insensitive Search = false ) { return $ this - > _like ( $ field , $ match , 'OR ' , $ side , ' ' , $ escape , $ insensitive Search ) ; } 
protected function _like ( $ field , string $ match = ' ' , string $ type = 'AND ' , string $ side = 'both ' , string $ not = ' ' , bool $ escape = null , bool $ insensitive Search = false ) { if ( ! is _array ( $ field ) ) { $ field = [ $ field = > $ match ] ; } $ escape = is _bool ( $ escape ) ? $ escape : $ this - > db - > protect Identifiers ; 
protected function _like _statement ( string $ prefix = null , string $ column , string $ not = null , string $ bind , bool $ insensitive Search = false ) : string { $ like _statement = " { $prefix } { $column } { $not } LIKE : { $bind } : " ; if ( $ insensitive Search = = = true ) { $ like _statement = " { $prefix } LOWER ( { $column } ) { $not } LIKE : { $bind } : " ; } return $ like _statement ; } 
public function group Start ( string $ not = ' ' , string $ type = 'AND ' ) { $ type = $ this - > group Get Type ( $ type ) ; $ this - > QBWhere Group Started = true ; $ prefix = empty ( $ this - > QBWhere ) ? ' ' : $ type ; $ where = [ 'condition ' = > $ prefix . $ not . str _repeat ( ' ' , + + $ this - > QBWhere Group Count ) . ' ( ' , 'escape ' = > false , ] ; $ this - > QBWhere [ ] = $ where ; return $ this ; } 
public function group End ( ) { $ this - > QBWhere Group Started = false ; $ where = [ 'condition ' = > str _repeat ( ' ' , $ this - > QBWhere Group Count - - ) . ' ) ' , 'escape ' = > false , ] ; $ this - > QBWhere [ ] = $ where ; return $ this ; } 
protected function group Get Type ( string $ type ) : string { if ( $ this - > QBWhere Group Started ) { $ type = ' ' ; $ this - > QBWhere Group Started = false ; } return $ type ; } 
public function group By ( $ by , bool $ escape = null ) { is _bool ( $ escape ) | | $ escape = $ this - > db - > protect Identifiers ; if ( is _string ( $ by ) ) { $ by = ( $ escape = = = true ) ? explode ( ' , ' , $ by ) : [ $ by ] ; } foreach ( $ by as $ val ) { $ val = trim ( $ val ) ; if ( $ val ! = = ' ' ) { $ val = [ 'field ' = > $ val , 'escape ' = > $ escape , ] ; $ this - > QBGroup By [ ] = $ val ; } } return $ this ; } 
public function having ( $ key , $ value = null , bool $ escape = null ) { return $ this - > where Having ( 'QBHaving ' , $ key , $ value , 'AND ' , $ escape ) ; } 
public function or Having ( $ key , $ value = null , bool $ escape = null ) { return $ this - > where Having ( 'QBHaving ' , $ key , $ value , 'OR ' , $ escape ) ; } 
public function order By ( string $ order By , string $ direction = ' ' , bool $ escape = null ) { $ direction = strtoupper ( trim ( $ direction ) ) ; if ( $ direction = = = 'RANDOM ' ) { $ direction = ' ' ; 
public function limit ( int $ value = null , int $ offset = 0 ) { if ( ! is _null ( $ value ) ) { $ this - > QBLimit = $ value ; } if ( ! empty ( $ offset ) ) { $ this - > QBOffset = $ offset ; } return $ this ; } 
public function offset ( int $ offset ) { if ( ! empty ( $ offset ) ) { $ this - > QBOffset = ( int ) $ offset ; } return $ this ; } 
protected function _limit ( string $ sql ) : string { return $ sql . ' LIMIT ' . ( $ this - > QBOffset ? $ this - > QBOffset . ' , ' : ' ' ) . $ this - > QBLimit ; } 
public function set ( $ key , string $ value = ' ' , bool $ escape = null ) { $ key = $ this - > object To Array ( $ key ) ; if ( ! is _array ( $ key ) ) { $ key = [ $ key = > $ value ] ; } $ escape = is _bool ( $ escape ) ? $ escape : $ this - > db - > protect Identifiers ; foreach ( $ key as $ k = > $ v ) { if ( $ escape ) { $ bind = $ this - > set Bind ( $ k , $ v , $ escape ) ; $ this - > QBSet [ $ this - > db - > protect Identifiers ( $ k , false , $ escape ) ] = " : $bind : " ; } else { $ this - > QBSet [ $ this - > db - > protect Identifiers ( $ k , false , $ escape ) ] = $ v ; } } return $ this ; } 
public function get Set Data ( bool $ clean = false ) : array { $ data = $ this - > QBSet ; if ( $ clean ) { $ this - > QBSet = [ ] ; } return $ data ; } 
public function get Compiled Select ( bool $ reset = true ) : string { $ select = $ this - > compile Select ( ) ; if ( $ reset = = = true ) { $ this - > reset Select ( ) ; } return $ this - > compile Final Query ( $ select ) ; } 
protected function compile Final Query ( string $ sql ) : string { $ query = new Query ( $ this - > db ) ; $ query - > set Query ( $ sql , $ this - > binds , false ) ; if ( ! empty ( $ this - > db - > swap Pre ) & & ! empty ( $ this - > db - > DBPrefix ) ) { $ query - > swap Prefix ( $ this - > db - > DBPrefix , $ this - > db - > swap Pre ) ; } return $ query - > get Query ( ) ; } 
public function get ( int $ limit = null , int $ offset = 0 , bool $ return SQL = false , bool $ reset = true ) { if ( ! is _null ( $ limit ) ) { $ this - > limit ( $ limit , $ offset ) ; } $ result = $ return SQL ? $ this - > get Compiled Select ( ) : $ this - > db - > query ( $ this - > compile Select ( ) , $ this - > binds , false ) ; if ( $ reset = = = true ) { $ this - > reset Select ( ) ; 
public function count All ( bool $ reset = true , bool $ test = false ) { $ table = $ this - > QBFrom [ 0 ] ; $ sql = $ this - > count String . $ this - > db - > escape Identifiers ( 'numrows ' ) . ' FROM ' . $ this - > db - > protect Identifiers ( $ table , true , null , false ) ; if ( $ test ) { return $ sql ; } $ query = $ this - > db - > query ( $ sql , null , false ) ; if ( empty ( $ query - > get Result ( ) ) ) { return 0 ; } $ query = $ query - > get Row ( ) ; if ( $ reset = = = true ) { $ this - > reset Select ( ) ; } return ( int ) $ query - > numrows ; } 
public function count All Results ( bool $ reset = true , bool $ test = false ) { 
public function get Where ( $ where = null , int $ limit = null , int $ offset = null ) { if ( $ where ! = = null ) { $ this - > where ( $ where ) ; } if ( ! empty ( $ limit ) ) { $ this - > limit ( $ limit , $ offset ) ; } $ result = $ this - > db - > query ( $ this - > compile Select ( ) , $ this - > binds , false ) ; $ this - > reset Select ( ) ; return $ result ; } 
public function insert Batch ( array $ set = null , bool $ escape = null , int $ batch Size = 1 0 0 , bool $ testing = false ) { if ( $ set = = = null ) { if ( empty ( $ this - > QBSet ) ) { if ( CI _DEBUG ) { throw new Database Exception ( 'You must use the "set " method to update an entry . ' ) ; } return false ; } } else { if ( empty ( $ set ) ) { if ( CI _DEBUG ) { throw new Database Exception ( 'insert Batch ( ) called with no data ' ) ; } return false ; } $ this - > set Insert Batch ( $ set , ' ' , $ escape ) ; } $ table = $ this - > QBFrom [ 0 ] ; 
protected function _insert Batch ( string $ table , array $ keys , array $ values ) : string { return 'INSERT INTO ' . $ table . ' ( ' . implode ( ' , ' , $ keys ) . ' ) VALUES ' . implode ( ' , ' , $ values ) ; } 
public function set Insert Batch ( $ key , string $ value = ' ' , bool $ escape = null ) { $ key = $ this - > batch Object To Array ( $ key ) ; if ( ! is _array ( $ key ) ) { $ key = [ $ key = > $ value ] ; } $ escape = is _bool ( $ escape ) ? $ escape : $ this - > db - > protect Identifiers ; $ keys = array _keys ( $ this - > object To Array ( current ( $ key ) ) ) ; sort ( $ keys ) ; foreach ( $ key as $ row ) { $ row = $ this - > object To Array ( $ row ) ; if ( count ( array _diff ( $ keys , array _keys ( $ row ) ) ) > 0 | | count ( array _diff ( array _keys ( $ row ) , $ keys ) ) > 0 ) { 
public function get Compiled Insert ( bool $ reset = true ) : string { if ( $ this - > validate Insert ( ) = = = false ) { return false ; } $ sql = $ this - > _insert ( $ this - > db - > protect Identifiers ( $ this - > QBFrom [ 0 ] , true , null , false ) , array _keys ( $ this - > QBSet ) , array _values ( $ this - > QBSet ) ) ; if ( $ reset = = = true ) { $ this - > reset Write ( ) ; } return $ this - > compile Final Query ( $ sql ) ; } 
public function insert ( array $ set = null , bool $ escape = null , bool $ test = false ) { if ( $ set ! = = null ) { $ this - > set ( $ set , ' ' , $ escape ) ; } if ( $ this - > validate Insert ( ) = = = false ) { return false ; } $ sql = $ this - > _insert ( $ this - > db - > protect Identifiers ( $ this - > QBFrom [ 0 ] , true , $ escape , false ) , array _keys ( $ this - > QBSet ) , array _values ( $ this - > QBSet ) ) ; if ( $ test = = = false ) { $ this - > reset Write ( ) ; $ result = $ this - > db - > query ( $ sql , $ this - > binds , false ) ; 
protected function _insert ( string $ table , array $ keys , array $ unescaped Keys ) : string { return 'INSERT INTO ' . $ table . ' ( ' . implode ( ' , ' , $ keys ) . ' ) VALUES ( ' . implode ( ' , ' , $ unescaped Keys ) . ' ) ' ; } 
public function replace ( array $ set = null , bool $ return SQL = false ) { if ( $ set ! = = null ) { $ this - > set ( $ set ) ; } if ( empty ( $ this - > QBSet ) ) { if ( CI _DEBUG ) { throw new Database Exception ( 'You must use the "set " method to update an entry . ' ) ; } return false ; } $ table = $ this - > QBFrom [ 0 ] ; $ sql = $ this - > _replace ( $ table , array _keys ( $ this - > QBSet ) , array _values ( $ this - > QBSet ) ) ; $ this - > reset Write ( ) ; return $ return SQL ? $ sql : $ this - > db - > query ( $ sql , $ this - > binds , false ) ; } 
protected function _replace ( string $ table , array $ keys , array $ values ) : string { return 'REPLACE INTO ' . $ table . ' ( ' . implode ( ' , ' , $ keys ) . ' ) VALUES ( ' . implode ( ' , ' , $ values ) . ' ) ' ; } 
public function get Compiled Update ( bool $ reset = true ) : string { if ( $ this - > validate Update ( ) = = = false ) { return false ; } $ sql = $ this - > _update ( $ this - > QBFrom [ 0 ] , $ this - > QBSet ) ; if ( $ reset = = = true ) { $ this - > reset Write ( ) ; } return $ this - > compile Final Query ( $ sql ) ; } 
public function update ( array $ set = null , $ where = null , int $ limit = null , bool $ test = false ) : bool { if ( $ set ! = = null ) { $ this - > set ( $ set ) ; } if ( $ this - > validate Update ( ) = = = false ) { return false ; } if ( $ where ! = = null ) { $ this - > where ( $ where ) ; } if ( ! empty ( $ limit ) ) { if ( ! $ this - > can Limit Where Updates ) { throw new Database Exception ( 'This driver does not allow LIMITs on UPDATE queries using WHERE . ' ) ; } $ this - > limit ( $ limit ) ; } $ sql = $ this - > _update ( $ this - > QBFrom [ 0 ] , $ this - > QBSet ) ; if ( ! $ test ) { $ this - > reset Write ( ) ; if ( $ this - > db - > query ( $ sql , $ this - > binds , false ) ) { 
protected function _update ( string $ table , array $ values ) : string { $ valstr = [ ] ; foreach ( $ values as $ key = > $ val ) { $ valstr [ ] = $ key . ' = ' . $ val ; } return 'UPDATE ' . $ table . ' SET ' . implode ( ' , ' , $ valstr ) . $ this - > compile Where Having ( 'QBWhere ' ) . $ this - > compile Order By ( ) . ( $ this - > QBLimit ? $ this - > _limit ( ' ' ) : ' ' ) ; } 
public function update Batch ( array $ set = null , string $ index = null , int $ batch Size = 1 0 0 , bool $ return SQL = false ) { if ( $ index = = = null ) { if ( CI _DEBUG ) { throw new Database Exception ( 'You must specify an index to match on for batch updates . ' ) ; } return false ; } if ( $ set = = = null ) { if ( empty ( $ this - > QBSet ) ) { if ( CI _DEBUG ) { throw new Database Exception ( 'You must use the "set " method to update an entry . ' ) ; } return false ; } } else { if ( empty ( $ set ) ) { if ( CI _DEBUG ) { throw new Database Exception ( 'update Batch ( ) called with no data ' ) ; } return false ; } $ this - > set Update Batch ( $ set , $ index ) ; } $ table = $ this - > QBFrom [ 0 ] ; 
protected function _update Batch ( string $ table , array $ values , string $ index ) : string { $ ids = [ ] ; $ final = [ ] ; foreach ( $ values as $ key = > $ val ) { $ ids [ ] = $ val [ $ index ] ; foreach ( array _keys ( $ val ) as $ field ) { if ( $ field ! = = $ index ) { $ final [ $ field ] [ ] = 'WHEN ' . $ index . ' = ' . $ val [ $ index ] . ' THEN ' . $ val [ $ field ] ; } } } $ cases = ' ' ; foreach ( $ final as $ k = > $ v ) { $ cases . = $ k . " = CASE \n " . implode ( " \n " , $ v ) . " \n " . 'ELSE ' . $ k . ' END , ' ; } $ this - > where ( $ index . ' IN ( ' . implode ( ' , ' , $ ids ) . ' ) ' , null , false ) ; return 'UPDATE ' . $ table . ' SET ' . substr ( $ cases , 0 , - 2 ) . $ this - > compile Where Having ( 'QBWhere ' ) ; } 
public function set Update Batch ( $ key , string $ index = ' ' , bool $ escape = null ) { $ key = $ this - > batch Object To Array ( $ key ) ; if ( ! is _array ( $ key ) ) { return null ; } is _bool ( $ escape ) | | $ escape = $ this - > db - > protect Identifiers ; foreach ( $ key as $ k = > $ v ) { $ index _set = false ; $ clean = [ ] ; foreach ( $ v as $ k 2 = > $ v 2 ) { if ( $ k 2 = = = $ index ) { $ index _set = true ; } $ bind = $ this - > set Bind ( $ k 2 , $ v 2 , $ escape ) ; $ clean [ $ this - > db - > protect Identifiers ( $ k 2 , false , $ escape ) ] = " : $bind : " ; } if ( $ index _set = = = false ) { throw new Database Exception ( 'One or more rows submitted for batch updating is missing the specified index . ' ) ; } $ this - > QBSet [ ] = $ clean ; } return $ this ; } 
public function empty Table ( bool $ test = false ) { $ table = $ this - > QBFrom [ 0 ] ; $ sql = $ this - > _delete ( $ table ) ; if ( $ test ) { return $ sql ; } $ this - > reset Write ( ) ; return $ this - > db - > query ( $ sql , null , false ) ; } 
public function truncate ( bool $ test = false ) { $ table = $ this - > QBFrom [ 0 ] ; $ sql = $ this - > _truncate ( $ table ) ; if ( $ test = = = true ) { return $ sql ; } $ this - > reset Write ( ) ; return $ this - > db - > query ( $ sql , null , false ) ; } 
public function get Compiled Delete ( bool $ reset = true ) : string { $ table = $ this - > QBFrom [ 0 ] ; $ sql = $ this - > delete ( $ table , ' ' , $ reset , true ) ; return $ this - > compile Final Query ( $ sql ) ; } 
public function delete ( $ where = ' ' , int $ limit = null , bool $ reset _data = true , bool $ return SQL = false ) { $ table = $ this - > db - > protect Identifiers ( $ this - > QBFrom [ 0 ] , true , null , false ) ; if ( $ where ! = = ' ' ) { $ this - > where ( $ where ) ; } if ( empty ( $ this - > QBWhere ) ) { if ( CI _DEBUG ) { throw new Database Exception ( 'Deletes are not allowed unless they contain a "where " or "like " clause . ' ) ; } return false ; } $ sql = $ this - > _delete ( $ table ) ; if ( ! empty ( $ limit ) ) { $ this - > QBLimit = $ limit ; } if ( ! empty ( $ this - > QBLimit ) ) { if ( ! $ this - > can Limit Deletes ) { throw new Database Exception ( 'SQLite 3 does not allow LIMITs on DELETE queries . ' ) ; } $ sql = $ this - > _limit ( $ sql ) ; } if ( $ reset _data ) { $ this - > reset Write ( ) ; } return ( $ return SQL = = = true ) ? $ sql : $ this - > db - > query ( $ sql , $ this - > binds , false ) ; } 
public function decrement ( string $ column , int $ value = 1 ) { $ column = $ this - > db - > protect Identifiers ( $ column ) ; $ sql = $ this - > _update ( $ this - > QBFrom [ 0 ] , [ $ column = > " { $column } - { $value } " ] ) ; return $ this - > db - > query ( $ sql , $ this - > binds , false ) ; } 
protected function _delete ( string $ table ) : string { return 'DELETE FROM ' . $ table . $ this - > compile Where Having ( 'QBWhere ' ) . ( $ this - > QBLimit ? ' LIMIT ' . $ this - > QBLimit : ' ' ) ; } 
protected function track Aliases ( $ table ) { if ( is _array ( $ table ) ) { foreach ( $ table as $ t ) { $ this - > track Aliases ( $ t ) ; } return ; } 
protected function compile Select ( $ select _override = false ) : string { 
protected function compile Where Having ( string $ qb _key ) : string { if ( ! empty ( $ this - > $ qb _key ) ) { for ( $ i = 0 , $ c = count ( $ this - > $ qb _key ) ; $ i < $ c ; $ i + + ) { 
protected function compile Group By ( ) : string { if ( ! empty ( $ this - > QBGroup By ) ) { for ( $ i = 0 , $ c = count ( $ this - > QBGroup By ) ; $ i < $ c ; $ i + + ) { 
protected function compile Order By ( ) : string { if ( is _array ( $ this - > QBOrder By ) & & ! empty ( $ this - > QBOrder By ) ) { for ( $ i = 0 , $ c = count ( $ this - > QBOrder By ) ; $ i < $ c ; $ i + + ) { if ( $ this - > QBOrder By [ $ i ] [ 'escape ' ] ! = = false & & ! $ this - > is Literal ( $ this - > QBOrder By [ $ i ] [ 'field ' ] ) ) { $ this - > QBOrder By [ $ i ] [ 'field ' ] = $ this - > db - > protect Identifiers ( $ this - > QBOrder By [ $ i ] [ 'field ' ] ) ; } $ this - > QBOrder By [ $ i ] = $ this - > QBOrder By [ $ i ] [ 'field ' ] . $ this - > QBOrder By [ $ i ] [ 'direction ' ] ; } return $ this - > QBOrder By = " \n ORDER BY " . implode ( ' , ' , $ this - > QBOrder By ) ; } elseif ( is _string ( $ this - > QBOrder By ) ) { return $ this - > QBOrder By ; } return ' ' ; } 
protected function object To Array ( $ object ) { if ( ! is _object ( $ object ) ) { return $ object ; } $ array = [ ] ; foreach ( get _object _vars ( $ object ) as $ key = > $ val ) { 
protected function batch Object To Array ( $ object ) { if ( ! is _object ( $ object ) ) { return $ object ; } $ array = [ ] ; $ out = get _object _vars ( $ object ) ; $ fields = array _keys ( $ out ) ; foreach ( $ fields as $ val ) { 
protected function is Literal ( string $ str ) : bool { $ str = trim ( $ str ) ; if ( empty ( $ str ) | | ctype _digit ( $ str ) | | ( string ) ( float ) $ str = = = $ str | | in _array ( strtoupper ( $ str ) , [ 'TRUE ' , 'FALSE ' ] , true ) ) { return true ; } static $ _str ; if ( empty ( $ _str ) ) { $ _str = ( $ this - > db - > escape Char ! = = ' " ' ) ? [ ' " ' , " ' " ] : [ " ' " ] ; } return in _array ( $ str [ 0 ] , $ _str , true ) ; } 
protected function reset Select ( ) { $ this - > reset Run ( [ 'QBSelect ' = > [ ] , 'QBJoin ' = > [ ] , 'QBWhere ' = > [ ] , 'QBGroup By ' = > [ ] , 'QBHaving ' = > [ ] , 'QBOrder By ' = > [ ] , 'QBNo Escape ' = > [ ] , 'QBDistinct ' = > false , 'QBLimit ' = > false , 'QBOffset ' = > false , ] ) ; if ( ! empty ( $ this - > db ) ) { $ this - > db - > set Aliased Tables ( [ ] ) ; } } 
protected function get Operator ( string $ str , bool $ list = false ) { static $ _operators ; if ( empty ( $ _operators ) ) { $ _les = ( $ this - > db - > like Escape Str ! = = ' ' ) ? ' \s + ' . preg _quote ( trim ( sprintf ( $ this - > db - > like Escape Str , $ this - > db - > like Escape Char ) ) , ' / ' ) : ' ' ; $ _operators = [ ' \s * ( ? : < | > | ! ) ? = \s * ' , 
protected function set Bind ( string $ key , $ value = null , bool $ escape = true ) : string { if ( ! array _key _exists ( $ key , $ this - > binds ) ) { $ this - > binds [ $ key ] = [ $ value , $ escape , ] ; return $ key ; } $ count = 0 ; while ( array _key _exists ( $ key . $ count , $ this - > binds ) ) { + + $ count ; } $ this - > binds [ $ key . $ count ] = [ $ value , $ escape , ] ; return $ key . $ count ; } 
public function run ( float $ start Time , float $ total Time , Request Interface $ request , Response Interface $ response ) : string { 
protected function render Timeline ( array $ collectors , $ start Time , int $ segment Count , int $ segment Duration , array & $ styles ) : string { $ display Time = $ segment Count * $ segment Duration ; $ rows = $ this - > collect Timeline Data ( $ collectors ) ; $ output = ' ' ; $ style Count = 0 ; foreach ( $ rows as $ row ) { $ output . = ' <tr > ' ; $ output . = " <td > { $row [ 'name ' ] } < /td > " ; $ output . = " <td > { $row [ 'component ' ] } < /td > " ; $ output . = " <td class = 'debug -bar -align Right ' > " . number _format ( $ row [ 'duration ' ] * 1 0 0 0 , 2 ) . ' ms < /td > ' ; $ output . = " <td class = 'debug -bar -noverflow ' colspan = ' { $segment Count } ' > " ; $ offset = ( ( ( $ row [ 'start ' ] - $ start Time ) * 1 0 0 0 ) / $ display Time ) * 1 0 0 ; $ length = ( ( $ row [ 'duration ' ] * 1 0 0 0 ) / $ display Time ) * 1 0 0 ; $ styles [ 'debug -bar -timeline - ' . $ style Count ] = "left : { $offset } % ; width : { $length } % ; " ; $ output . = " <span class = 'timer debug -bar -timeline - { $style Count } ' title = ' " . number _format ( $ length , 2 ) . " % ' > < /span > " ; $ output . = ' < /td > ' ; $ output . = ' < /tr > ' ; $ style Count + + ; } return $ output ; } 
protected function collect Timeline Data ( $ collectors ) : array { $ data = [ ] ; 
protected function collect Var Data ( ) : array { $ data = [ ] ; foreach ( $ this - > collectors as $ collector ) { if ( ! $ collector - > has Var Data ( ) ) { continue ; } $ data = array _merge ( $ data , $ collector - > get Var Data ( ) ) ; } return $ data ; } 
protected function round To ( float $ number , int $ increments = 5 ) : float { $ increments = 1 / $ increments ; return ( ceil ( $ number * $ increments ) / $ increments ) ; } 
public function prepare ( ) { if ( CI _DEBUG & & ! is _cli ( ) ) { global $ app ; $ request = Services : : request ( ) ; $ response = Services : : response ( ) ; $ toolbar = Services : : toolbar ( config ( Toolbar : : class ) ) ; $ stats = $ app - > get Performance Stats ( ) ; $ data = $ toolbar - > run ( $ stats [ 'start Time ' ] , $ stats [ 'total Time ' ] , $ request , $ response ) ; helper ( 'filesystem ' ) ; 
protected function format ( string $ data , string $ format = 'html ' ) : string { $ data = json _decode ( $ data , true ) ; if ( $ this - > config - > max History ! = = 0 ) { $ history = new History ( ) ; $ history - > set Files ( Services : : request ( ) - > get Get ( 'debugbar _time ' ) , $ this - > config - > max History ) ; $ data [ 'collectors ' ] [ ] = $ history - > get As Array ( ) ; } $ output = ' ' ; switch ( $ format ) { case 'html ' : $ data [ 'styles ' ] = [ ] ; extract ( $ data ) ; $ parser = Services : : parser ( $ this - > config - > views Path , null , false ) ; ob _start ( ) ; include ( $ this - > config - > views Path . 'toolbar .tpl .php ' ) ; $ output = ob _get _clean ( ) ; break ; case 'json ' : $ formatter = new JSONFormatter ( ) ; $ output = $ formatter - > format ( $ data ) ; break ; case 'xml ' : $ formatter = new XMLFormatter ; $ output = $ formatter - > format ( $ data ) ; break ; } return $ output ; } 
public function copy ( string $ target Path , string $ target Name = null , int $ perms = 0 6 4 4 ) : bool { $ target Path = rtrim ( $ target Path , ' / ' ) . ' / ' ; $ target Name = is _null ( $ target Name ) ? $ this - > get Filename ( ) : $ target Name ; if ( empty ( $ target Name ) ) { throw Image Exception : : for Invalid File ( $ target Name ) ; } if ( ! is _dir ( $ target Path ) ) { mkdir ( $ target Name , 0 7 5 5 , true ) ; } if ( ! copy ( $ this - > get Pathname ( ) , " { $target Path } { $target Name } " ) ) { throw Image Exception : : for Copy Error ( $ target Path ) ; } chmod ( " { $target Path } / { $target Name } " , $ perms ) ; return true ; } 
public function get Properties ( bool $ return = false ) { $ path = $ this - > get Pathname ( ) ; $ vals = getimagesize ( $ path ) ; $ types = [ 1 = > 'gif ' , 2 = > 'jpeg ' , 3 = > 'png ' , ] ; $ mime = 'image / ' . ( $ types [ $ vals [ 2 ] ] ? ? 'jpg ' ) ; if ( $ return = = = true ) { return [ 'width ' = > $ vals [ 0 ] , 'height ' = > $ vals [ 1 ] , 'image _type ' = > $ vals [ 2 ] , 'size _str ' = > $ vals [ 3 ] , 'mime _type ' = > $ mime , ] ; } $ this - > orig Width = $ vals [ 0 ] ; $ this - > orig Height = $ vals [ 1 ] ; $ this - > image Type = $ vals [ 2 ] ; $ this - > size Str = $ vals [ 3 ] ; $ this - > mime = $ mime ; return true ; } 
public function open ( $ save Path , $ name ) : bool { if ( empty ( $ this - > db - > conn ID ) ) { $ this - > db - > initialize ( ) ; } return true ; } 
public function read ( $ session ID ) : string { if ( $ this - > lock Session ( $ session ID ) = = = false ) { $ this - > fingerprint = md 5 ( ' ' ) ; return ' ' ; } 
public function write ( $ session ID , $ session Data ) : bool { if ( $ this - > lock = = = false ) { return $ this - > fail ( ) ; } 
public function destroy ( $ session ID ) : bool { if ( $ this - > lock ) { $ builder = $ this - > db - > table ( $ this - > table ) - > where ( 'id ' , $ session ID ) ; if ( $ this - > match IP ) { $ builder = $ builder - > where ( 'ip _address ' , $ this - > ip Address ) ; } if ( ! $ builder - > delete ( ) ) { return $ this - > fail ( ) ; } } if ( $ this - > close ( ) ) { $ this - > destroy Cookie ( ) ; return true ; } return $ this - > fail ( ) ; } 
public function gc ( $ maxlifetime ) : bool { return ( $ this - > db - > table ( $ this - > table ) - > delete ( 'timestamp < ' . ( time ( ) - $ maxlifetime ) ) ) ? true : $ this - > fail ( ) ; } 
protected function lock Session ( string $ session ID ) : bool { if ( $ this - > platform = = = 'mysql ' ) { $ arg = md 5 ( $ session ID . ( $ this - > match IP ? ' _ ' . $ this - > ip Address : ' ' ) ) ; if ( $ this - > db - > query ( "SELECT GET _LOCK ( ' { $arg } ' , 3 0 0 ) AS ci _session _lock " ) - > get Row ( ) - > ci _session _lock ) { $ this - > lock = $ arg ; return true ; } return $ this - > fail ( ) ; } elseif ( $ this - > platform = = = 'postgre ' ) { $ arg = "hashtext ( ' { $session ID } ' ) " . ( $ this - > match IP ? " , hashtext ( ' { $this - >ip Address } ' ) " : ' ' ) ; if ( $ this - > db - > simple Query ( "SELECT pg _advisory _lock ( { $arg } ) " ) ) { $ this - > lock = $ arg ; return true ; } return $ this - > fail ( ) ; } 
protected function release Lock ( ) : bool { if ( ! $ this - > lock ) { return true ; } if ( $ this - > platform = = = 'mysql ' ) { if ( $ this - > db - > query ( "SELECT RELEASE _LOCK ( ' { $this - >lock } ' ) AS ci _session _lock " ) - > get Row ( ) - > ci _session _lock ) { $ this - > lock = false ; return true ; } return $ this - > fail ( ) ; } elseif ( $ this - > platform = = = 'postgre ' ) { if ( $ this - > db - > simple Query ( "SELECT pg _advisory _unlock ( { $this - >lock } ) " ) ) { $ this - > lock = false ; return true ; } return $ this - > fail ( ) ; } 
public function display ( ) : array { $ raw Routes = Services : : routes ( true ) ; $ router = Services : : router ( null , true ) ; $ route = $ router - > get Matched Route ( ) ; * Defined Routes * / $ raw Routes = $ raw Routes - > get Routes ( ) ; $ routes = [ ] ; foreach ( $ raw Routes as $ from = > $ to ) { $ routes [ ] = [ 'from ' = > $ from , 'to ' = > $ to , ] ; } return [ 'matched Route ' = > $ matched Route , 'routes ' = > $ routes , ] ; } 
public function attach Honeypot ( Response Interface $ response ) { $ prep _field = $ this - > prepare Template ( $ this - > config - > template ) ; $ body = $ response - > get Body ( ) ; $ body = str _ireplace ( ' < /form > ' , $ prep _field , $ body ) ; $ response - > set Body ( $ body ) ; } 
protected function prepare Template ( string $ template ) : string { $ template = str _ireplace ( ' {label } ' , $ this - > config - > label , $ template ) ; $ template = str _ireplace ( ' {name } ' , $ this - > config - > name , $ template ) ; if ( $ this - > config - > hidden ) { $ template = ' <div style = "display :none " > ' . $ template . ' < /div > ' ; } return $ template ; } 
protected function _replace ( string $ table , array $ keys , array $ values ) : string { return 'INSERT OR ' . parent : : _replace ( $ table , $ keys , $ values ) ; } 
public function get Field Names ( ) : array { $ field Names = [ ] ; for ( $ i = 0 , $ c = $ this - > get Field Count ( ) ; $ i < $ c ; $ i + + ) { $ field Names [ ] = $ this - > result ID - > column Name ( $ i ) ; } return $ field Names ; } 
public function get Field Data ( ) : array { static $ data _types = [ SQLITE 3 _INTEGER = > 'integer ' , SQLITE 3 _FLOAT = > 'float ' , SQLITE 3 _TEXT = > 'text ' , SQLITE 3 _BLOB = > 'blob ' , SQLITE 3 _NULL = > 'null ' , ] ; $ ret Val = [ ] ; for ( $ i = 0 , $ c = $ this - > get Field Count ( ) ; $ i < $ c ; $ i + + ) { $ ret Val [ $ i ] = new \ std Class ( ) ; $ ret Val [ $ i ] - > name = $ this - > result ID - > column Name ( $ i ) ; $ type = $ this - > result ID - > column Type ( $ i ) ; $ ret Val [ $ i ] - > type = isset ( $ data _types [ $ type ] ) ? $ data _types [ $ type ] : $ type ; $ ret Val [ $ i ] - > max _length = null ; } return $ ret Val ; } 
public function free Result ( ) { if ( is _object ( $ this - > result ID ) ) { $ this - > result ID - > finalize ( ) ; $ this - > result ID = false ; } } 
protected function fetch Object ( string $ class Name = 'std Class ' ) { 
public function make Columns ( $ array = [ ] , $ column Limit = 0 ) { if ( ! is _array ( $ array ) | | count ( $ array ) = = = 0 | | ! is _int ( $ column Limit ) ) { return false ; } 
protected function _prep Args ( $ args ) { 
public function generate ( $ table Data = null ) { 
public function clear ( ) { $ this - > rows = [ ] ; $ this - > heading = [ ] ; $ this - > footing = [ ] ; $ this - > auto Heading = true ; $ this - > caption = null ; return $ this ; } 
protected function _set From DBResult ( $ object ) { 
protected function _set From Array ( $ data ) { if ( $ this - > auto Heading = = = true & & empty ( $ this - > heading ) ) { $ this - > heading = $ this - > _prep Args ( array _shift ( $ data ) ) ; } foreach ( $ data as & $ row ) { $ this - > rows [ ] = $ this - > _prep Args ( $ row ) ; } } 
protected function _compile Template ( ) { if ( $ this - > template = = = null ) { $ this - > template = $ this - > _default Template ( ) ; return ; } $ this - > temp = $ this - > _default Template ( ) ; foreach ( [ 'table _open ' , 'thead _open ' , 'thead _close ' , 'heading _row _start ' , 'heading _row _end ' , 'heading _cell _start ' , 'heading _cell _end ' , 'tbody _open ' , 'tbody _close ' , 'row _start ' , 'row _end ' , 'cell _start ' , 'cell _end ' , 'row _alt _start ' , 'row _alt _end ' , 'cell _alt _start ' , 'cell _alt _end ' , 'table _close ' ] as $ val ) { if ( ! isset ( $ this - > template [ $ val ] ) ) { $ this - > template [ $ val ] = $ this - > temp [ $ val ] ; } } } 
public function initialize ( ) { if ( class _exists ( ' \Memcached ' ) ) { $ this - > memcached = new \ Memcached ( ) ; if ( $ this - > config [ 'raw ' ] ) { $ this - > memcached - > set Option ( \ Memcached : : OPT _BINARY _PROTOCOL , true ) ; } } elseif ( class _exists ( ' \Memcache ' ) ) { $ this - > memcached = new \ Memcache ( ) ; } else { throw new Critical Error ( 'Cache : Not support Memcache (d ) extension . ' ) ; } if ( $ this - > memcached instanceof \ Memcached ) { $ this - > memcached - > add Server ( $ this - > config [ 'host ' ] , $ this - > config [ 'port ' ] , $ this - > config [ 'weight ' ] ) ; } elseif ( $ this - > memcached instanceof \ Memcache ) { 
public function get ( string $ key ) { $ key = $ this - > prefix . $ key ; if ( $ this - > memcached instanceof \ Memcached ) { $ data = $ this - > memcached - > get ( $ key ) ; 
public function save ( string $ key , $ value , int $ ttl = 6 0 ) { $ key = $ this - > prefix . $ key ; if ( ! $ this - > config [ 'raw ' ] ) { $ value = [ $ value , time ( ) , $ ttl , ] ; } if ( $ this - > memcached instanceof \ Memcached ) { return $ this - > memcached - > set ( $ key , $ value , $ ttl ) ; } elseif ( $ this - > memcached instanceof \ Memcache ) { return $ this - > memcached - > set ( $ key , $ value , 0 , $ ttl ) ; } return false ; } 
public function delete ( string $ key ) { $ key = $ this - > prefix . $ key ; return $ this - > memcached - > delete ( $ key ) ; } 
public function increment ( string $ key , int $ offset = 1 ) { if ( ! $ this - > config [ 'raw ' ] ) { return false ; } $ key = $ this - > prefix . $ key ; return $ this - > memcached - > increment ( $ key , $ offset , $ offset , 6 0 ) ; } 
public function get Meta Data ( string $ key ) { $ key = $ this - > prefix . $ key ; $ stored = $ this - > memcached - > get ( $ key ) ; 
public function move ( string $ target Path , string $ name = null , bool $ overwrite = false ) { $ target Path = $ this - > set Path ( $ target Path ) ; 
protected function set Path ( string $ path ) : string { if ( ! is _dir ( $ path ) ) { mkdir ( $ path , 0 7 7 7 , true ) ; 
public function get Error String ( ) : string { $ errors = [ UPLOAD _ERR _OK = > lang ( 'HTTP .upload Err Ok ' ) , UPLOAD _ERR _INI _SIZE = > lang ( 'HTTP .upload Err Ini Size ' ) , UPLOAD _ERR _FORM _SIZE = > lang ( 'HTTP .upload Err Form Size ' ) , UPLOAD _ERR _PARTIAL = > lang ( 'HTTP .upload Err Partial ' ) , UPLOAD _ERR _NO _FILE = > lang ( 'HTTP .upload Err No File ' ) , UPLOAD _ERR _CANT _WRITE = > lang ( 'HTTP .upload Err Cant Write ' ) , UPLOAD _ERR _NO _TMP _DIR = > lang ( 'HTTP .upload Err No Tmp Dir ' ) , UPLOAD _ERR _EXTENSION = > lang ( 'HTTP .upload Err Extension ' ) , ] ; $ error = is _null ( $ this - > error ) ? UPLOAD _ERR _OK : $ this - > error ; return sprintf ( $ errors [ $ error ] ? ? lang ( 'HTTP .upload Err Unknown ' ) , $ this - > get Name ( ) ) ; } 
public function store ( string $ folder Name = null , string $ file Name = null ) : string { $ folder Name = $ folder Name ? ? date ( 'Ymd ' ) ; $ file Name = $ file Name ? ? $ this - > get Random Name ( ) ; 
public function run ( array $ params = [ ] ) { $ name = array _shift ( $ params ) ; if ( empty ( $ name ) ) { $ name = CLI : : prompt ( lang ( 'Migrations .name Migration ' ) ) ; } if ( empty ( $ name ) ) { CLI : : error ( lang ( 'Migrations .bad Create Name ' ) ) ; return ; } $ ns = $ params [ ' -n ' ] ? ? CLI : : get Option ( 'n ' ) ; $ homepath = APPPATH ; if ( ! empty ( $ ns ) ) { < ?php namespace $ns \Database \Migrations ; use Code Igniter \Database \Migration ; class Migration _ {name } extends Migration { public function up ( ) { } public function down ( ) { } } EOD ; $ template = str _replace ( ' {name } ' , $ name , $ template ) ; helper ( 'filesystem ' ) ; if ( ! write _file ( $ path , $ template ) ) { CLI : : error ( lang ( 'Migrations .write Error ' ) ) ; return ; } CLI : : write ( 'Created file : ' . CLI : : color ( str _replace ( $ homepath , $ ns , $ path ) , 'green ' ) ) ; } 
public function uploaded ( string $ blank = null , string $ name , array $ data ) : bool { $ file = $ this - > request - > get File ( $ name ) ; if ( is _null ( $ file ) ) { return false ; } if ( ENVIRONMENT = = = 'testing ' ) { return $ file - > get Error ( ) = = = 0 ; } 
public function max _size ( string $ blank = null , string $ params , array $ data ) : bool { 
public function is _image ( string $ blank = null , string $ params , array $ data ) : bool { 
public function mime _in ( string $ blank = null , string $ params , array $ data ) : bool { 
public function max _dims ( string $ blank = null , string $ params , array $ data ) : bool { 
protected function format Timeline Data ( ) : array { $ data = [ ] ; $ rows = $ this - > viewer - > get Performance Data ( ) ; foreach ( $ rows as $ name = > $ info ) { $ data [ ] = [ 'name ' = > 'View : ' . $ info [ 'view ' ] , 'component ' = > 'Views ' , 'start ' = > $ info [ 'start ' ] , 'duration ' = > $ info [ 'end ' ] - $ info [ 'start ' ] , ] ; } return $ data ; } 
public function display ( ) : array { $ data = [ 'events ' = > [ ] , ] ; foreach ( \ Code Igniter \ Events \ Events : : get Performance Logs ( ) as $ row ) { $ key = $ row [ 'event ' ] ; if ( ! array _key _exists ( $ key , $ data [ 'events ' ] ) ) { $ data [ 'events ' ] [ $ key ] = [ 'event ' = > $ key , 'duration ' = > number _format ( ( $ row [ 'end ' ] - $ row [ 'start ' ] ) * 1 0 0 0 , 2 ) , 'count ' = > 1 , ] ; continue ; } $ data [ 'events ' ] [ $ key ] [ 'duration ' ] + = number _format ( ( $ row [ 'end ' ] - $ row [ 'start ' ] ) * 1 0 0 0 , 2 ) ; $ data [ 'events ' ] [ $ key ] [ 'count ' ] + + ; } return $ data ; } 
public function get IPAddress ( ) : string { if ( ! empty ( $ this - > ip Address ) ) { return $ this - > ip Address ; } $ proxy _ips = $ this - > proxy IPs ; if ( ! empty ( $ this - > proxy IPs ) & & ! is _array ( $ this - > proxy IPs ) ) { $ proxy _ips = explode ( ' , ' , str _replace ( ' ' , ' ' , $ this - > proxy IPs ) ) ; } $ this - > ip Address = $ this - > get Server ( 'REMOTE _ADDR ' ) ; if ( $ proxy _ips ) { foreach ( [ 'HTTP _X _FORWARDED _FOR ' , 'HTTP _CLIENT _IP ' , 'HTTP _X _CLIENT _IP ' , 'HTTP _X _CLUSTER _CLIENT _IP ' ] as $ header ) { if ( ( $ spoof = $ this - > get Server ( $ header ) ) ! = = null ) { 
public function is Valid IP ( string $ ip = null , string $ which = null ) : bool { switch ( strtolower ( $ which ) ) { case 'ipv 4 ' : $ which = FILTER _FLAG _IPV 4 ; break ; case 'ipv 6 ' : $ which = FILTER _FLAG _IPV 6 ; break ; default : $ which = null ; break ; } return ( bool ) filter _var ( $ ip , FILTER _VALIDATE _IP , $ which ) ; } 
public function get Server ( $ index = null , $ filter = null , $ flags = null ) { return $ this - > fetch Global ( 'server ' , $ index , $ filter , $ flags ) ; } 
public function get Env ( $ index = null , $ filter = null , $ flags = null ) { return $ this - > fetch Global ( 'env ' , $ index , $ filter , $ flags ) ; } 
public function fetch Global ( $ method , $ index = null , $ filter = null , $ flags = null ) { $ method = strtolower ( $ method ) ; if ( ! isset ( $ this - > globals [ $ method ] ) ) { $ this - > populate Globals ( $ method ) ; } 
protected function populate Globals ( string $ method ) { if ( ! isset ( $ this - > globals [ $ method ] ) ) { $ this - > globals [ $ method ] = [ ] ; } 
public function run ( array $ params = [ ] ) { $ runner = Services : : migrations ( ) ; 
public function get Option String ( ) : string { if ( empty ( $ this - > options ) ) { return ' ' ; } $ out = ' ' ; foreach ( $ this - > options as $ name = > $ value ) { 
protected function parse Command ( ) { 
public function from Table ( string $ table ) { $ this - > prefixed Table Name = $ table ; 
public function run ( ) : bool { $ this - > db - > query ( 'PRAGMA foreign _keys = OFF ' ) ; $ this - > db - > trans Start ( ) ; $ this - > forge - > rename Table ( $ this - > table Name , "temp _ { $this - >table Name } " ) ; $ this - > forge - > reset ( ) ; $ this - > create Table ( ) ; $ this - > copy Data ( ) ; $ this - > forge - > drop Table ( "temp _ { $this - >table Name } " ) ; $ success = $ this - > db - > trans Complete ( ) ; $ this - > db - > query ( 'PRAGMA foreign _keys = ON ' ) ; return $ success ; } 
public function modify Column ( array $ field ) { $ field = $ field [ 0 ] ; $ old Name = $ field [ 'name ' ] ; unset ( $ field [ 'name ' ] ) ; $ this - > fields [ $ old Name ] = $ field ; return $ this ; } 
protected function create Table ( ) { $ this - > drop Indexes ( ) ; $ this - > db - > reset Data Cache ( ) ; 
protected function copy Data ( ) { $ ex Fields = [ ] ; $ new Fields = [ ] ; foreach ( $ this - > fields as $ name = > $ details ) { 
protected function format Fields ( $ fields ) { if ( ! is _array ( $ fields ) ) { return $ fields ; } $ return = [ ] ; foreach ( $ fields as $ field ) { $ return [ $ field - > name ] = [ 'type ' = > $ field - > type , 'default ' = > $ field - > default , 'nullable ' = > $ field - > nullable , ] ; if ( $ field - > primary _key ) { $ this - > keys [ $ field - > name ] = [ 'fields ' = > [ $ field - > name ] , 'type ' = > 'primary ' , ] ; } } return $ return ; } 
protected function format Keys ( $ keys ) { if ( ! is _array ( $ keys ) ) { return $ keys ; } $ return = [ ] ; foreach ( $ keys as $ name = > $ key ) { $ return [ $ name ] = [ 'fields ' = > $ key - > fields , 'type ' = > 'index ' , ] ; } return $ return ; } 
protected function drop Indexes ( ) { if ( ! is _array ( $ this - > keys ) | | ! count ( $ this - > keys ) ) { return ; } foreach ( $ this - > keys as $ name = > $ key ) { if ( $ key [ 'type ' ] = = = 'primary ' | | $ key [ 'type ' ] = = = 'unique ' ) { continue ; } $ this - > db - > query ( "DROP INDEX IF EXISTS ' { $name } ' " ) ; } } 
public function CSRFVerify ( Request Interface $ request ) { 
public function CSRFSet Cookie ( Request Interface $ request ) { $ expire = time ( ) + $ this - > CSRFExpire ; $ secure _cookie = ( bool ) $ this - > cookie Secure ; if ( $ secure _cookie & & ! $ request - > is Secure ( ) ) { return false ; } setcookie ( $ this - > CSRFCookie Name , $ this - > CSRFHash , $ expire , $ this - > cookie Path , $ this - > cookie Domain , $ secure _cookie , true 
protected function CSRFSet Hash ( ) : string { if ( $ this - > CSRFHash = = = null ) { 
public function sanitize Filename ( string $ str , bool $ relative _path = false ) : string { $ bad = $ this - > filename Bad Chars ; if ( ! $ relative _path ) { $ bad [ ] = ' . / ' ; $ bad [ ] = ' / ' ; } $ str = remove _invisible _characters ( $ str , false ) ; do { $ old = $ str ; $ str = str _replace ( $ bad , ' ' , $ str ) ; } while ( $ old ! = = $ str ) ; return stripslashes ( $ str ) ; } 
public static function now ( $ timezone = null , string $ locale = null ) { return new Time ( null , $ timezone , $ locale ) ; } 
public static function parse ( string $ datetime , $ timezone = null , string $ locale = null ) { return new Time ( $ datetime , $ timezone , $ locale ) ; } 
public static function today ( $ timezone = null , string $ locale = null ) { return new Time ( date ( 'Y -m -d 0 0 : 0 0 : 0 0 ' ) , $ timezone , $ locale ) ; } 
public static function yesterday ( $ timezone = null , string $ locale = null ) { return new Time ( date ( 'Y -m -d 0 0 : 0 0 : 0 0 ' , strtotime ( ' - 1 day ' ) ) , $ timezone , $ locale ) ; } 
public static function tomorrow ( $ timezone = null , string $ locale = null ) { return new Time ( date ( 'Y -m -d 0 0 : 0 0 : 0 0 ' , strtotime ( ' + 1 day ' ) ) , $ timezone , $ locale ) ; } 
public static function create From Date ( int $ year = null , int $ month = null , int $ day = null , $ timezone = null , string $ locale = null ) { return static : : create ( $ year , $ month , $ day , null , null , null , $ timezone , $ locale ) ; } 
public static function create From Time ( int $ hour = null , int $ minutes = null , int $ seconds = null , $ timezone = null , string $ locale = null ) { return static : : create ( null , null , null , $ hour , $ minutes , $ seconds , $ timezone , $ locale ) ; } 
public static function create ( int $ year = null , int $ month = null , int $ day = null , int $ hour = null , int $ minutes = null , int $ seconds = null , $ timezone = null , string $ locale = null ) { $ year = is _null ( $ year ) ? date ( 'Y ' ) : $ year ; $ month = is _null ( $ month ) ? date ( 'm ' ) : $ month ; $ day = is _null ( $ day ) ? date ( 'd ' ) : $ day ; $ hour = empty ( $ hour ) ? 0 : $ hour ; $ minutes = empty ( $ minutes ) ? 0 : $ minutes ; $ seconds = empty ( $ seconds ) ? 0 : $ seconds ; return new Time ( date ( 'Y -m -d H :i :s ' , strtotime ( " { $year } - { $month } - { $day } { $hour } : { $minutes } : { $seconds } " ) ) , $ timezone , $ locale ) ; } 
public static function create From Format ( $ format , $ datetime , $ time Zone = null ) { $ date = parent : : create From Format ( $ format , $ datetime ) ; return new Time ( $ date - > format ( 'Y -m -d H :i :s ' ) , $ time Zone ) ; } 
public static function create From Timestamp ( int $ timestamp , $ time Zone = null , string $ locale = null ) { return new Time ( date ( 'Y -m -d H :i :s ' , $ timestamp ) , $ time Zone , $ locale ) ; } 
public static function instance ( Date Time $ date Time , string $ locale = null ) { $ date = $ date Time - > format ( 'Y -m -d H :i :s ' ) ; $ timezone = $ date Time - > get Timezone ( ) ; return new Time ( $ date , $ timezone , $ locale ) ; } 
public function to Date Time ( ) { $ date Time = new Date Time ( null , $ this - > get Timezone ( ) ) ; $ date Time - > set Timestamp ( parent : : get Timestamp ( ) ) ; return $ date Time ; } 
public function get Age ( ) { $ now = Time : : now ( ) - > get Timestamp ( ) ; $ time = $ this - > get Timestamp ( ) ; 
public function get Dst ( ) : bool { 
public function set Month ( $ value ) { if ( is _numeric ( $ value ) & & $ value < 1 | | $ value > 1 2 ) { throw I 1 8n Exception : : for Invalid Month ( $ value ) ; } if ( is _string ( $ value ) & & ! is _numeric ( $ value ) ) { $ value = date ( 'm ' , strtotime ( " { $value } 1 2 0 1 7 " ) ) ; } return $ this - > set Value ( 'month ' , $ value ) ; } 
public function set Day ( $ value ) { if ( $ value < 1 | | $ value > 3 1 ) { throw I 1 8n Exception : : for Invalid Day ( $ value ) ; } $ date = $ this - > get Year ( ) . ' - ' . $ this - > get Month ( ) ; $ last Day = date ( 't ' , strtotime ( $ date ) ) ; if ( $ value > $ last Day ) { throw I 1 8n Exception : : for Invalid Over Day ( $ last Day , $ value ) ; } return $ this - > set Value ( 'day ' , $ value ) ; } 
public function set Hour ( $ value ) { if ( $ value < 0 | | $ value > 2 3 ) { throw I 1 8n Exception : : for Invalid Hour ( $ value ) ; } return $ this - > set Value ( 'hour ' , $ value ) ; } 
public function set Minute ( $ value ) { if ( $ value < 0 | | $ value > 5 9 ) { throw I 1 8n Exception : : for Invalid Minutes ( $ value ) ; } return $ this - > set Value ( 'minute ' , $ value ) ; } 
public function set Second ( $ value ) { if ( $ value < 0 | | $ value > 5 9 ) { throw I 1 8n Exception : : for Invalid Seconds ( $ value ) ; } return $ this - > set Value ( 'second ' , $ value ) ; } 
protected function set Value ( string $ name , $ value ) { list ( $ year , $ month , $ day , $ hour , $ minute , $ second ) = explode ( ' - ' , $ this - > format ( 'Y -n -j -G -i -s ' ) ) ; $ $ name = $ value ; return Time : : create ( $ year , $ month , $ day , $ hour , $ minute , $ second , $ this - > get Timezone Name ( ) , $ this - > locale ) ; } 
public function set Timestamp ( $ timestamp ) { $ time = date ( 'Y -m -d H :i :s ' , $ timestamp ) ; return Time : : parse ( $ time , $ this - > timezone , $ this - > locale ) ; } 
public function to Localized String ( ? string $ format = null ) { $ format = $ format ? ? $ this - > to String Format ; return Intl Date Formatter : : format Object ( $ this - > to Date Time ( ) , $ format , $ this - > locale ) ; } 
public function equals ( $ test Time , string $ timezone = null ) : bool { $ test Time = $ this - > get UTCObject ( $ test Time , $ timezone ) ; $ our Time = $ this - > to Date Time ( ) - > set Timezone ( new Date Time Zone ( 'UTC ' ) ) - > format ( 'Y -m -d H :i :s ' ) ; return $ test Time - > format ( 'Y -m -d H :i :s ' ) = = = $ our Time ; } 
public function same As ( $ test Time , string $ timezone = null ) : bool { if ( $ test Time instanceof Date Time ) { $ test Time = $ test Time - > format ( 'Y -m -d H :i :s ' ) ; } else if ( is _string ( $ test Time ) ) { $ timezone = $ timezone ? : $ this - > timezone ; $ timezone = $ timezone instanceof Date Time Zone ? $ timezone : new Date Time Zone ( $ timezone ) ; $ test Time = new Date Time ( $ test Time , $ timezone ) ; $ test Time = $ test Time - > format ( 'Y -m -d H :i :s ' ) ; } $ our Time = $ this - > to Date Time String ( ) ; return $ test Time = = = $ our Time ; } 
public function is Before ( $ test Time , string $ timezone = null ) : bool { $ test Time = $ this - > get UTCObject ( $ test Time , $ timezone ) - > get Timestamp ( ) ; $ our Time = $ this - > get Timestamp ( ) ; return $ our Time < $ test Time ; } 
public function humanize ( ) { $ now = Intl Calendar : : from Date Time ( Time : : now ( $ this - > timezone ) - > to Date Time String ( ) ) ; $ time = $ this - > get Calendar ( ) - > get Time ( ) ; $ years = $ now - > field Difference ( $ time , Intl Calendar : : FIELD _YEAR ) ; $ months = $ now - > field Difference ( $ time , Intl Calendar : : FIELD _MONTH ) ; $ days = $ now - > field Difference ( $ time , Intl Calendar : : FIELD _DAY _OF _YEAR ) ; $ hours = $ now - > field Difference ( $ time , Intl Calendar : : FIELD _HOUR _OF _DAY ) ; $ minutes = $ now - > field Difference ( $ time , Intl Calendar : : FIELD _MINUTE ) ; $ phrase = null ; if ( $ years ! = = 0 ) { $ phrase = lang ( 'Time .years ' , [ abs ( $ years ) ] ) ; $ before = $ years < 0 ; } else if ( $ months ! = = 0 ) { $ phrase = lang ( 'Time .months ' , [ abs ( $ months ) ] ) ; $ before = $ months < 0 ; } else if ( $ days ! = = 0 & & ( abs ( $ days ) > = 7 ) ) { $ weeks = ceil ( $ days / 7 ) ; $ phrase = lang ( 'Time .weeks ' , [ abs ( $ weeks ) ] ) ; $ before = $ days < 0 ; } else if ( $ days ! = = 0 ) { $ before = $ days < 0 ; 
public function difference ( $ test Time , string $ timezone = null ) { $ test Time = $ this - > get UTCObject ( $ test Time , $ timezone ) ; $ our Time = $ this - > get UTCObject ( $ this ) ; return new Time Difference ( $ our Time , $ test Time ) ; } 
public function get UTCObject ( $ time , string $ timezone = null ) { if ( $ time instanceof Time ) { $ time = $ time - > to Date Time ( ) - > set Timezone ( new Date Time Zone ( 'UTC ' ) ) ; } else if ( $ time instanceof Date Time ) { $ time = $ time - > set Timezone ( new Date Time Zone ( 'UTC ' ) ) ; } else if ( is _string ( $ time ) ) { $ timezone = $ timezone ? : $ this - > timezone ; $ timezone = $ timezone instanceof Date Time Zone ? $ timezone : new Date Time Zone ( $ timezone ) ; $ time = new Date Time ( $ time , $ timezone ) ; $ time = $ time - > set Timezone ( new Date Time Zone ( 'UTC ' ) ) ; } return $ time ; } 
protected static function has Relative Keywords ( string $ time ) : bool { 
protected function js Matcher ( $ matches ) { $ chr = $ matches [ 0 ] ; if ( strlen ( $ chr ) = = 1 ) { return sprintf ( ' \ \x % 0 2X ' , ord ( $ chr ) ) ; } $ chr = $ this - > convert Encoding ( $ chr , 'UTF - 1 6BE ' , 'UTF - 8 ' ) ; $ hex = strtoupper ( bin 2hex ( $ chr ) ) ; if ( strlen ( $ hex ) < = 4 ) { return sprintf ( ' \ \u % 0 4s ' , $ hex ) ; } $ high Surrogate = substr ( $ hex , 0 , 4 ) ; $ low Surrogate = substr ( $ hex , 4 , 4 ) ; return sprintf ( ' \ \u % 0 4s \ \u % 0 4s ' , $ high Surrogate , $ low Surrogate ) ; } 
protected function css Matcher ( $ matches ) { $ chr = $ matches [ 0 ] ; if ( strlen ( $ chr ) = = 1 ) { $ ord = ord ( $ chr ) ; } else { $ chr = $ this - > convert Encoding ( $ chr , 'UTF - 3 2BE ' , 'UTF - 8 ' ) ; $ ord = hexdec ( bin 2hex ( $ chr ) ) ; } return sprintf ( ' \ \ %X ' , $ ord ) ; } 
protected function to Utf 8 ( $ string ) { if ( $ this - > get Encoding ( ) = = = 'utf - 8 ' ) { $ result = $ string ; } else { $ result = $ this - > convert Encoding ( $ string , 'UTF - 8 ' , $ this - > get Encoding ( ) ) ; } if ( ! $ this - > is Utf 8 ( $ result ) ) { throw new Exception \ Runtime Exception ( sprintf ( 'String to be escaped was not valid UTF - 8 or could not be converted : %s ' , $ result ) ) ; } return $ result ; } 
protected function from Utf 8 ( $ string ) { if ( $ this - > get Encoding ( ) = = = 'utf - 8 ' ) { return $ string ; } return $ this - > convert Encoding ( $ string , $ this - > get Encoding ( ) , 'UTF - 8 ' ) ; } 
public function initialize ( ) { try { 
public function get ( string $ key ) { $ data = array _combine ( [ ' _ _ci _type ' , ' _ _ci _value ' , ] , $ this - > redis - > hmget ( $ key , [ ' _ _ci _type ' , ' _ _ci _value ' ] ) ) ; if ( ! isset ( $ data [ ' _ _ci _type ' ] , $ data [ ' _ _ci _value ' ] ) | | $ data [ ' _ _ci _value ' ] = = = false ) { return null ; } switch ( $ data [ ' _ _ci _type ' ] ) { case 'array ' : case 'object ' : return unserialize ( $ data [ ' _ _ci _value ' ] ) ; case 'boolean ' : case 'integer ' : case 'double ' : 
public function save ( string $ key , $ value , int $ ttl = 6 0 ) { switch ( $ data _type = gettype ( $ value ) ) { case 'array ' : case 'object ' : $ value = serialize ( $ value ) ; break ; case 'boolean ' : case 'integer ' : case 'double ' : 
public function increment ( string $ key , int $ offset = 1 ) { return $ this - > redis - > hincrby ( $ key , 'data ' , $ offset ) ; } 
public function decrement ( string $ key , int $ offset = 1 ) { return $ this - > redis - > hincrby ( $ key , 'data ' , - $ offset ) ; } 
public function get Meta Data ( string $ key ) { $ data = array _combine ( [ ' _ _ci _value ' ] , $ this - > redis - > hmget ( $ key , [ ' _ _ci _value ' ] ) ) ; if ( isset ( $ data [ ' _ _ci _value ' ] ) & & $ data [ ' _ _ci _value ' ] ! = = false ) { return [ 'expire ' = > time ( ) + $ this - > redis - > ttl ( $ key ) , 'data ' = > $ data [ ' _ _ci _value ' ] , ] ; } return false ; } 
public function get File ( string $ name ) { $ this - > populate Files ( ) ; if ( $ this - > has File ( $ name ) ) { if ( strpos ( $ name , ' . ' ) ! = = false ) { $ name = explode ( ' . ' , $ name ) ; $ uploaded File = $ this - > get Value Dot Notation Syntax ( $ name , $ this - > files ) ; return ( $ uploaded File instanceof Uploaded File ) ? $ uploaded File : null ; } if ( array _key _exists ( $ name , $ this - > files ) ) { $ uploaded File = $ this - > files [ $ name ] ; return ( $ uploaded File instanceof Uploaded File ) ? $ uploaded File : null ; } } return null ; } 
public function has File ( string $ file ID ) : bool { $ this - > populate Files ( ) ; if ( strpos ( $ file ID , ' . ' ) ! = = false ) { $ segments = explode ( ' . ' , $ file ID ) ; $ el = $ this - > files ; foreach ( $ segments as $ segment ) { if ( ! array _key _exists ( $ segment , $ el ) ) { return false ; } $ el = $ el [ $ segment ] ; } return true ; } return isset ( $ this - > files [ $ file ID ] ) ; } 
protected function populate Files ( ) { if ( is _array ( $ this - > files ) ) { return ; } $ this - > files = [ ] ; if ( empty ( $ _FILES ) ) { return ; } $ files = $ this - > fix Files Array ( $ _FILES ) ; foreach ( $ files as $ name = > $ file ) { $ this - > files [ $ name ] = $ this - > create File Object ( $ file ) ; } } 
protected function create File Object ( array $ array ) { if ( ! isset ( $ array [ 'name ' ] ) ) { $ output = [ ] ; foreach ( $ array as $ key = > $ values ) { if ( ! is _array ( $ values ) ) { continue ; } $ output [ $ key ] = $ this - > create File Object ( $ values ) ; } return $ output ; } return new Uploaded File ( $ array [ 'tmp _name ' ] ? ? null , $ array [ 'name ' ] ? ? null , $ array [ 'type ' ] ? ? null , $ array [ 'size ' ] ? ? null , $ array [ 'error ' ] ? ? null ) ; } 
protected function fix Files Array ( array $ data ) : array { $ output = [ ] ; foreach ( $ data as $ name = > $ array ) { foreach ( $ array as $ field = > $ value ) { $ pointer = & $ output [ $ name ] ; if ( ! is _array ( $ value ) ) { $ pointer [ $ field ] = $ value ; continue ; } $ stack = [ & $ pointer ] ; $ iterator = new \ Recursive Iterator Iterator ( new \ Recursive Array Iterator ( $ value ) , \ Recursive Iterator Iterator : : SELF _FIRST ) ; foreach ( $ iterator as $ key = > $ val ) { array _splice ( $ stack , $ iterator - > get Depth ( ) + 1 ) ; $ pointer = & $ stack [ count ( $ stack ) - 1 ] ; $ pointer = & $ pointer [ $ key ] ; $ stack [ ] = & $ pointer ; if ( ! $ iterator - > has Children ( ) ) { $ pointer [ $ field ] = $ val ; } } } } return $ output ; } 
protected function get Value Dot Notation Syntax ( array $ index , array $ value ) { if ( is _array ( $ index ) & & ! empty ( $ index ) ) { $ current _index = array _shift ( $ index ) ; } if ( is _array ( $ index ) & & $ index & & is _array ( $ value [ $ current _index ] ) & & $ value [ $ current _index ] ) { return $ this - > get Value Dot Notation Syntax ( $ index , $ value [ $ current _index ] ) ; } return ( isset ( $ value [ $ current _index ] ) ) ? $ value [ $ current _index ] : null ; } 
public function run ( array $ params ) { $ collection = Services : : routes ( true ) ; $ methods = [ 'get ' , 'head ' , 'post ' , 'put ' , 'delete ' , 'options ' , 'trace ' , 'connect ' , 'cli ' , ] ; $ tbody = [ ] ; foreach ( $ methods as $ method ) { $ routes = $ collection - > get Routes ( $ method ) ; foreach ( $ routes as $ from = > $ to ) { 
public function initialize ( ) { $ config = $ this - > config ; $ this - > redis = new \ Redis ( ) ; if ( ! $ this - > redis - > connect ( $ config [ 'host ' ] , ( $ config [ 'host ' ] [ 0 ] = = = ' / ' ? 0 : $ config [ 'port ' ] ) , $ config [ 'timeout ' ] ) ) { log _message ( 'error ' , 'Cache : Redis connection failed . Check your configuration . ' ) ; } if ( isset ( $ config [ 'password ' ] ) & & ! $ this - > redis - > auth ( $ config [ 'password ' ] ) ) { log _message ( 'error ' , 'Cache : Redis authentication failed . ' ) ; } if ( isset ( $ config [ 'database ' ] ) & & ! $ this - > redis - > select ( $ config [ 'database ' ] ) ) { log _message ( 'error ' , 'Cache : Redis select database failed . ' ) ; } } 
public function get ( string $ key ) { $ key = $ this - > prefix . $ key ; $ data = $ this - > redis - > h MGet ( $ key , [ ' _ _ci _type ' , ' _ _ci _value ' ] ) ; if ( ! isset ( $ data [ ' _ _ci _type ' ] , $ data [ ' _ _ci _value ' ] ) | | $ data [ ' _ _ci _value ' ] = = = false ) { return null ; } switch ( $ data [ ' _ _ci _type ' ] ) { case 'array ' : case 'object ' : return unserialize ( $ data [ ' _ _ci _value ' ] ) ; case 'boolean ' : case 'integer ' : case 'double ' : 
public function save ( string $ key , $ value , int $ ttl = 6 0 ) { $ key = $ this - > prefix . $ key ; switch ( $ data _type = gettype ( $ value ) ) { case 'array ' : case 'object ' : $ value = serialize ( $ value ) ; break ; case 'boolean ' : case 'integer ' : case 'double ' : 
public function delete ( string $ key ) { $ key = $ this - > prefix . $ key ; return ( $ this - > redis - > delete ( $ key ) = = = 1 ) ; } 
public function increment ( string $ key , int $ offset = 1 ) { $ key = $ this - > prefix . $ key ; return $ this - > redis - > h Incr By ( $ key , 'data ' , $ offset ) ; } 
public function get Meta Data ( string $ key ) { $ key = $ this - > prefix . $ key ; $ value = $ this - > get ( $ key ) ; if ( $ value ! = = null ) { $ time = time ( ) ; return [ 'expire ' = > $ time + $ this - > redis - > ttl ( $ key ) , 'mtime ' = > $ time , 'data ' = > $ value , ] ; } return null ; } 
public function set Binary ( string $ binary ) { if ( $ this - > file ! = = null ) { throw Download Exception : : for Cannot Set Binary ( ) ; } $ this - > binary = $ binary ; } 
public function set File Path ( string $ filepath ) { if ( $ this - > binary ! = = null ) { throw Download Exception : : for Cannot Set File Path ( $ filepath ) ; } $ this - > file = new File ( $ filepath , true ) ; } 
public function get Content Length ( ) : int { if ( is _string ( $ this - > binary ) ) { return strlen ( $ this - > binary ) ; } elseif ( $ this - > file instanceof File ) { return $ this - > file - > get Size ( ) ; } return 0 ; } 
private function set Content Type By Mime Type ( ) { $ mime = null ; $ charset = ' ' ; if ( $ this - > set Mime = = = true ) { if ( ( $ last _dot _position = strrpos ( $ this - > filename , ' . ' ) ) ! = = false ) { $ mime = Mimes : : guess Type From Extension ( substr ( $ this - > filename , $ last _dot _position + 1 ) ) ; $ charset = $ this - > charset ; } } if ( ! is _string ( $ mime ) ) { 
private function get Download File Name ( ) : string { $ filename = $ this - > filename ; $ x = explode ( ' . ' , $ this - > filename ) ; $ extension = end ( $ x ) ; 
private function get Content Disposition ( ) : string { $ download _filename = $ this - > get Download File Name ( ) ; $ utf 8 _filename = $ download _filename ; if ( strtoupper ( $ this - > charset ) ! = = 'UTF - 8 ' ) { $ utf 8 _filename = mb _convert _encoding ( $ download _filename , 'UTF - 8 ' , $ this - > charset ) ; } $ result = sprintf ( 'attachment ; filename = " %s " ' , $ download _filename ) ; if ( isset ( $ utf 8 _filename ) ) { $ result . = ' ; filename * =UTF - 8 \ ' \ ' ' . rawurlencode ( $ utf 8 _filename ) ; } return $ result ; } 
public function set Date ( \ Date Time $ date ) { $ date - > set Timezone ( new \ Date Time Zone ( 'UTC ' ) ) ; $ this - > set Header ( 'Date ' , $ date - > format ( 'D , d M Y H :i :s ' ) . ' GMT ' ) ; return $ this ; } 
public function set Last Modified ( $ date ) { if ( $ date instanceof \ Date Time ) { $ date - > set Timezone ( new \ Date Time Zone ( 'UTC ' ) ) ; $ this - > set Header ( 'Last -Modified ' , $ date - > format ( 'D , d M Y H :i :s ' ) . ' GMT ' ) ; } elseif ( is _string ( $ date ) ) { $ this - > set Header ( 'Last -Modified ' , $ date ) ; } return $ this ; } 
public function build Headers ( ) { if ( ! $ this - > has Header ( 'Content -Type ' ) ) { $ this - > set Content Type By Mime Type ( ) ; } $ this - > set Header ( 'Content -Disposition ' , $ this - > get Content Disposition ( ) ) ; $ this - > set Header ( 'Expires -Disposition ' , ' 0 ' ) ; $ this - > set Header ( 'Content -Transfer -Encoding ' , 'binary ' ) ; $ this - > set Header ( 'Content -Length ' , ( string ) $ this - > get Content Length ( ) ) ; $ this - > no Cache ( ) ; } 
public function send Body ( ) { if ( $ this - > binary ! = = null ) { return $ this - > send Body By Binary ( ) ; } elseif ( $ this - > file ! = = null ) { return $ this - > send Body By File Path ( ) ; } throw Download Exception : : for Not Found Download Source ( ) ; } 
private function send Body By File Path ( ) { $ spl _file _object = $ this - > file - > open File ( 'rb ' ) ; 
public function _remap ( $ method , . . . $ params ) { 
public function index ( array $ params ) { $ command = array _shift ( $ params ) ; $ this - > create Command List ( ) ; if ( is _null ( $ command ) ) { $ command = 'help ' ; } return $ this - > run Command ( $ command , $ params ) ; } 
protected function run Command ( string $ command , array $ params ) { if ( ! isset ( $ this - > commands [ $ command ] ) ) { CLI : : error ( lang ( 'CLI .command Not Found ' , [ $ command ] ) ) ; CLI : : new Line ( ) ; return ; } 
protected function create Command List ( ) { $ files = Services : : locator ( ) - > list Files ( 'Commands / ' ) ; 
public static function connect ( $ group = null , bool $ get Shared = true ) { 
public static function seeder ( string $ group = null ) { $ config = config ( 'Database ' ) ; return new Seeder ( $ config , static : : connect ( $ group ) ) ; } 
public function run ( array $ params = [ ] ) { $ runner = Services : : migrations ( ) ; CLI : : write ( lang ( 'Migrations .rolling Back ' ) , 'yellow ' ) ; $ group = $ params [ ' -g ' ] ? ? CLI : : get Option ( 'g ' ) ; if ( ! is _null ( $ group ) ) { $ runner - > set Group ( $ group ) ; } try { if ( ! $ this - > is All Namespace ( $ params ) ) { $ namespace = $ params [ ' -n ' ] ? ? CLI : : get Option ( 'n ' ) ; $ runner - > version ( 0 , $ namespace ) ; } else { 
private function is All Namespace ( array $ params ) : bool { if ( array _search ( ' -all ' , $ params ) ! = = false ) { return true ; } return ! is _null ( CLI : : get Option ( 'all ' ) ) ; } 
public function add ( string $ name , \ Closure $ closure ) { $ name = strtolower ( $ name ) ; $ this - > tests [ $ name ] = $ closure ; return $ this ; } 
public function run ( int $ iterations = 1 0 0 0 , bool $ output = true ) { foreach ( $ this - > tests as $ name = > $ test ) { 
public function get Report ( ) : string { if ( empty ( $ this - > results ) ) { return 'No results to display . ' ; } helper ( 'number ' ) ; <thead > <tr > <td >Test < /td > <td >Time < /td > <td >Memory < /td > < /tr > < /thead > <tbody > {rows } < /tbody > < /table > ' ; $ rows = ' ' ; foreach ( $ this - > results as $ name = > $ result ) { $ memory = number _to _size ( $ result [ 'memory ' ] , 4 ) ; $ rows . = " <tr > <td > { $name } < /td > <td > " . number _format ( $ result [ 'time ' ] , 4 ) . " < /td > <td > { $memory } < /td > < /tr > " ; } $ tpl = str _replace ( ' {rows } ' , $ rows , $ tpl ) ; return $ tpl . ' <br / > ' ; } 
public function set Query ( string $ sql , $ binds = null , bool $ set Escape = true ) { $ this - > original Query String = $ sql ; if ( ! is _null ( $ binds ) ) { if ( ! is _array ( $ binds ) ) { $ binds = [ $ binds ] ; } if ( $ set Escape ) { array _walk ( $ binds , function ( & $ item ) { $ item = [ $ item , true , ] ; } ) ; } $ this - > binds = $ binds ; } return $ this ; } 
public function get Query ( ) : string { if ( empty ( $ this - > final Query String ) ) { $ this - > final Query String = $ this - > original Query String ; } $ this - > compile Binds ( ) ; return $ this - > final Query String ; } 
public function set Duration ( float $ start , float $ end = null ) { $ this - > start Time = $ start ; if ( is _null ( $ end ) ) { $ end = microtime ( true ) ; } $ this - > end Time = $ end ; return $ this ; } 
public function get Start Time ( bool $ return Raw = false , int $ decimals = 6 ) : string { if ( $ return Raw ) { return $ this - > start Time ; } return number _format ( $ this - > start Time , $ decimals ) ; } 
public function get Duration ( int $ decimals = 6 ) : string { return number _format ( ( $ this - > end Time - $ this - > start Time ) , $ decimals ) ; } 
public function set Error ( int $ code , string $ error ) { $ this - > error Code = $ code ; $ this - > error String = $ error ; return $ this ; } 
public function swap Prefix ( string $ orig , string $ swap ) { $ sql = empty ( $ this - > final Query String ) ? $ this - > original Query String : $ this - > final Query String ; $ this - > final Query String = preg _replace ( ' / ( \W ) ' . $ orig . ' ( \S + ? ) / ' , ' \ \ 1 ' . $ swap . ' \ \ 2 ' , $ sql ) ; return $ this ; } 
protected function compile Binds ( ) { $ sql = $ this - > final Query String ; $ has Named Binds = strpos ( $ sql , ' : ' ) ! = = false ; if ( empty ( $ this - > binds ) | | empty ( $ this - > bind Marker ) | | ( strpos ( $ sql , $ this - > bind Marker ) = = = false & & $ has Named Binds = = = false ) ) { return ; } if ( ! is _array ( $ this - > binds ) ) { $ binds = [ $ this - > binds ] ; $ bind Count = 1 ; } else { $ binds = $ this - > binds ; $ bind Count = count ( $ binds ) ; } 
protected function match Named Binds ( string $ sql , array $ binds ) : string { $ replacers = [ ] ; foreach ( $ binds as $ placeholder = > $ value ) { 
protected function match Simple Binds ( string $ sql , array $ binds , int $ bind Count , int $ ml ) : string { 
public function init Controller ( Request Interface $ request , Response Interface $ response , Logger Interface $ logger ) { $ this - > request = $ request ; $ this - > response = $ response ; $ this - > logger = $ logger ; $ this - > logger - > info ( 'Controller " ' . get _class ( $ this ) . ' " loaded . ' ) ; if ( $ this - > force HTTPS > 0 ) { $ this - > force HTTPS ( $ this - > force HTTPS ) ; } $ this - > load Helpers ( ) ; } 
protected function load Helpers ( ) { if ( empty ( $ this - > helpers ) ) { return ; } foreach ( $ this - > helpers as $ helper ) { helper ( $ helper ) ; } } 
protected function validate ( $ rules , array $ messages = [ ] ) : bool { $ this - > validator = Services : : validation ( ) ; 
public function initialize ( \ Config \ Autoload $ config , \ Config \ Modules $ module Config ) { 
public function register ( ) { 
public function add Namespace ( $ namespace , string $ path = null ) { if ( is _array ( $ namespace ) ) { foreach ( $ namespace as $ prefix = > $ path ) { $ prefix = trim ( $ prefix , ' \ \ ' ) ; if ( is _array ( $ path ) ) { foreach ( $ path as $ dir ) { $ this - > prefixes [ $ prefix ] [ ] = rtrim ( $ dir , ' / ' ) . ' / ' ; } continue ; } $ this - > prefixes [ $ prefix ] [ ] = rtrim ( $ path , ' / ' ) . ' / ' ; } } else { $ this - > prefixes [ trim ( $ namespace , ' \ \ ' ) ] [ ] = rtrim ( $ path , ' / ' ) . ' / ' ; } return $ this ; } 
public function get Namespace ( string $ prefix = null ) { if ( $ prefix = = = null ) { return $ this - > prefixes ; } return $ this - > prefixes [ trim ( $ prefix , ' \ \ ' ) ] ? ? [ ] ; } 
public function load Class ( string $ class ) { $ class = trim ( $ class , ' \ \ ' ) ; $ class = str _ireplace ( ' .php ' , ' ' , $ class ) ; $ mapped _file = $ this - > load In Namespace ( $ class ) ; 
protected function load In Namespace ( string $ class ) { if ( strpos ( $ class , ' \ \ ' ) = = = false ) { return false ; } foreach ( $ this - > prefixes as $ namespace = > $ directories ) { foreach ( $ directories as $ directory ) { $ directory = rtrim ( $ directory , ' / ' ) ; if ( strpos ( $ class , $ namespace ) = = = 0 ) { $ file Path = $ directory . str _replace ( ' \ \ ' , ' / ' , substr ( $ class , strlen ( $ namespace ) ) ) . ' .php ' ; $ filename = $ this - > require File ( $ file Path ) ; if ( $ filename ) { return $ filename ; } } } } 
protected function load Legacy ( string $ class ) { 
protected function require File ( string $ file ) { $ file = $ this - > sanitize Filename ( $ file ) ; if ( is _file ( $ file ) ) { require _once $ file ; return $ file ; } return false ; } 
public function sanitize Filename ( string $ filename ) : string { 
protected function discover Composer Namespaces ( ) { if ( ! is _file ( COMPOSER _PATH ) ) { return false ; } $ composer = include COMPOSER _PATH ; $ paths = $ composer - > get Prefixes Psr 4 ( ) ; unset ( $ composer ) ; 
public static function date ( $ value , string $ format ) : string { if ( is _string ( $ value ) & & ! is _numeric ( $ value ) ) { $ value = strtotime ( $ value ) ; } return date ( $ format , $ value ) ; } 
public static function date _modify ( $ value , string $ adjustment ) : string { $ value = static : : date ( $ value , 'Y -m -d H :i :s ' ) ; return strtotime ( $ adjustment , strtotime ( $ value ) ) ; } 
public static function excerpt ( string $ value , string $ phrase , int $ radius = 1 0 0 ) : string { helper ( 'text ' ) ; return excerpt ( $ value , $ phrase , $ radius ) ; } 
public static function highlight ( string $ value , string $ phrase ) : string { helper ( 'text ' ) ; return highlight _phrase ( $ value , $ phrase ) ; } 
public static function local _number ( $ value , string $ type = 'decimal ' , int $ precision = 4 , string $ locale = null ) : string { helper ( 'number ' ) ; $ types = [ 'decimal ' = > Number Formatter : : DECIMAL , 'currency ' = > Number Formatter : : CURRENCY , 'percent ' = > Number Formatter : : PERCENT , 'scientific ' = > Number Formatter : : SCIENTIFIC , 'spellout ' = > Number Formatter : : SPELLOUT , 'ordinal ' = > Number Formatter : : ORDINAL , 'duration ' = > Number Formatter : : DURATION , ] ; return format _number ( $ value , $ precision , $ locale , [ 'type ' = > $ types [ $ type ] ] ) ; } 
public static function local _currency ( $ value , string $ currency , string $ locale = null ) : string { helper ( 'number ' ) ; $ options = [ 'type ' = > Number Formatter : : CURRENCY , 'currency ' = > $ currency , ] ; return format _number ( $ value , 2 , $ locale , $ options ) ; } 
public static function nl 2br ( string $ value ) : string { $ typography = Services : : typography ( ) ; return $ typography - > nl 2br Except Pre ( $ value ) ; } 
public static function prose ( string $ value ) : string { $ typography = Services : : typography ( ) ; return $ typography - > auto Typography ( $ value ) ; } 
public static function round ( string $ value , $ precision = 2 , string $ type = 'common ' ) : string { if ( ! is _numeric ( $ precision ) ) { $ type = $ precision ; $ precision = 2 ; } switch ( $ type ) { case 'common ' : return round ( $ value , $ precision ) ; break ; case 'ceil ' : return ceil ( $ value ) ; break ; case 'floor ' : return floor ( $ value ) ; break ; } 
public function load ( ) : bool { 
protected function set Variable ( string $ name , string $ value = ' ' ) { list ( $ name , $ value ) = $ this - > normalise Variable ( $ name , $ value ) ; if ( ! getenv ( $ name , true ) ) { putenv ( " $name = $value " ) ; } if ( empty ( $ _ENV [ $ name ] ) ) { $ _ENV [ $ name ] = $ value ; } if ( empty ( $ _SERVER [ $ name ] ) ) { $ _SERVER [ $ name ] = $ value ; } } 
public function normalise Variable ( string $ name , string $ value = ' ' ) : array { 
protected function sanitize Value ( string $ value ) : string { if ( ! $ value ) { return $ value ; } % 1 $s # match a quote at the start of the value ( # capturing sub -pattern used ( ? : # we do not need to capture this [ ^ % 1 $s \ \ \ \ ] # any character other than a quote or backslash | \ \ \ \ \ \ \ \ # or two backslashes together | \ \ \ \ % 1 $s # or an escaped quote e .g \ " ) * # as many characters that match the previous rules ) # end of the capturing sub -pattern % 1 $s # and the closing quote . * $ # and discard any string after the closing quote /mx ' , $ quote ) ; $ value = preg _replace ( $ regex Pattern , ' $ 1 ' , $ value ) ; $ value = str _replace ( " \ \ $quote " , $ quote , $ value ) ; $ value = str _replace ( ' \ \ \ \ ' , ' \ \ ' , $ value ) ; } else { $ parts = explode ( ' # ' , $ value , 2 ) ; $ value = trim ( $ parts [ 0 ] ) ; 
protected function resolve Nested Variables ( string $ value ) : string { if ( strpos ( $ value , ' $ ' ) ! = = false ) { $ loader = $ this ; $ value = preg _replace _callback ( ' / \ $ { ( [a -z A -Z 0 - 9 _ ] + ) } / ' , function ( $ matched Patterns ) use ( $ loader ) { $ nested Variable = $ loader - > get Variable ( $ matched Patterns [ 1 ] ) ; if ( is _null ( $ nested Variable ) ) { return $ matched Patterns [ 0 ] ; } return $ nested Variable ; } , $ value ) ; } return $ value ; } 
public function connect ( bool $ persistent = false ) { REPLACE (REPLACE (REPLACE (REPLACE (REPLACE (REPLACE ( @ @sql _mode , "STRICT _ALL _TABLES , " , " " ) , " ,STRICT _ALL _TABLES " , " " ) , "STRICT _ALL _TABLES " , " " ) , "STRICT _TRANS _TABLES , " , " " ) , " ,STRICT _TRANS _TABLES " , " " ) , "STRICT _TRANS _TABLES " , " " ) ' ) ; } } if ( is _array ( $ this - > encrypt ) ) { $ ssl = [ ] ; empty ( $ this - > encrypt [ 'ssl _key ' ] ) | | $ ssl [ 'key ' ] = $ this - > encrypt [ 'ssl _key ' ] ; empty ( $ this - > encrypt [ 'ssl _cert ' ] ) | | $ ssl [ 'cert ' ] = $ this - > encrypt [ 'ssl _cert ' ] ; empty ( $ this - > encrypt [ 'ssl _ca ' ] ) | | $ ssl [ 'ca ' ] = $ this - > encrypt [ 'ssl _ca ' ] ; empty ( $ this - > encrypt [ 'ssl _capath ' ] ) | | $ ssl [ 'capath ' ] = $ this - > encrypt [ 'ssl _capath ' ] ; empty ( $ this - > encrypt [ 'ssl _cipher ' ] ) | | $ ssl [ 'cipher ' ] = $ this - > encrypt [ 'ssl _cipher ' ] ; if ( ! empty ( $ ssl ) ) { if ( isset ( $ this - > encrypt [ 'ssl _verify ' ] ) ) { if ( $ this - > encrypt [ 'ssl _verify ' ] ) { defined ( 'MYSQLI _OPT _SSL _VERIFY _SERVER _CERT ' ) & & $ this - > mysqli - > options ( MYSQLI _OPT _SSL _VERIFY _SERVER _CERT , true ) ; } / / Apparently (when it exists ) , setting MYSQLI _OPT _SSL _VERIFY _SERVER _CERT / / to FALSE didn 't do anything , so PHP 5 . 6 . 1 6 introduced yet another 
public function set Database ( string $ database Name ) : bool { if ( $ database Name = = = ' ' ) { $ database Name = $ this - > database ; } if ( empty ( $ this - > conn ID ) ) { $ this - > initialize ( ) ; } if ( $ this - > conn ID - > select _db ( $ database Name ) ) { $ this - > database = $ database Name ; return true ; } return false ; } 
public function get Version ( ) : string { if ( isset ( $ this - > data Cache [ 'version ' ] ) ) { return $ this - > data Cache [ 'version ' ] ; } if ( empty ( $ this - > mysqli ) ) { $ this - > initialize ( ) ; } return $ this - > data Cache [ 'version ' ] = $ this - > mysqli - > server _info ; } 
public function execute ( string $ sql ) { while ( $ this - > conn ID - > more _results ( ) ) { $ this - > conn ID - > next _result ( ) ; if ( $ res = $ this - > conn ID - > store _result ( ) ) { $ res - > free ( ) ; } } return $ this - > conn ID - > query ( $ this - > prep Query ( $ sql ) ) ; } 
protected function prep Query ( string $ sql ) : string { 
protected function _escape String ( string $ str ) : string { if ( is _bool ( $ str ) ) { return $ str ; } if ( ! $ this - > conn ID ) { $ this - > initialize ( ) ; } return $ this - > conn ID - > real _escape _string ( $ str ) ; } 
protected function _list Tables ( bool $ prefix Limit = false ) : string { $ sql = 'SHOW TABLES FROM ' . $ this - > escape Identifiers ( $ this - > database ) ; if ( $ prefix Limit ! = = false & & $ this - > DBPrefix ! = = ' ' ) { return $ sql . " LIKE ' " . $ this - > escape Like String ( $ this - > DBPrefix ) . " % ' " ; } return $ sql ; } 
public function _field Data ( string $ table ) : array { $ table = $ this - > protect Identifiers ( $ table , true , null , false ) ; if ( ( $ query = $ this - > query ( 'SHOW COLUMNS FROM ' . $ table ) ) = = = false ) { throw new Database Exception ( lang ( 'Database .fail Get Field Data ' ) ) ; } $ query = $ query - > get Result Object ( ) ; $ ret Val = [ ] ; for ( $ i = 0 , $ c = count ( $ query ) ; $ i < $ c ; $ i + + ) { $ ret Val [ $ i ] = new \ std Class ( ) ; $ ret Val [ $ i ] - > name = $ query [ $ i ] - > Field ; sscanf ( $ query [ $ i ] - > Type , ' % [a -z ] ( %d ) ' , $ ret Val [ $ i ] - > type , $ ret Val [ $ i ] - > max _length ) ; $ ret Val [ $ i ] - > default = $ query [ $ i ] - > Default ; $ ret Val [ $ i ] - > primary _key = ( int ) ( $ query [ $ i ] - > Key = = = 'PRI ' ) ; } return $ ret Val ; } 
public function _index Data ( string $ table ) : array { $ table = $ this - > protect Identifiers ( $ table , true , null , false ) ; if ( ( $ query = $ this - > query ( 'SHOW INDEX FROM ' . $ table ) ) = = = false ) { throw new Database Exception ( lang ( 'Database .fail Get Index Data ' ) ) ; } if ( ! $ indexes = $ query - > get Result Array ( ) ) { return [ ] ; } $ keys = [ ] ; foreach ( $ indexes as $ index ) { if ( empty ( $ keys [ $ index [ 'Key _name ' ] ] ) ) { $ keys [ $ index [ 'Key _name ' ] ] = new \ std Class ( ) ; $ keys [ $ index [ 'Key _name ' ] ] - > name = $ index [ 'Key _name ' ] ; if ( $ index [ 'Key _name ' ] = = = 'PRIMARY ' ) { $ type = 'PRIMARY ' ; } elseif ( $ index [ 'Index _type ' ] = = = 'FULLTEXT ' ) { $ type = 'FULLTEXT ' ; } elseif ( $ index [ 'Non _unique ' ] ) { if ( $ index [ 'Index _type ' ] = = = 'SPATIAL ' ) { $ type = 'SPATIAL ' ; } else { $ type = 'INDEX ' ; } } else { $ type = 'UNIQUE ' ; } $ keys [ $ index [ 'Key _name ' ] ] - > type = $ type ; } $ keys [ $ index [ 'Key _name ' ] ] - > fields [ ] = $ index [ 'Column _name ' ] ; } return $ keys ; } 
public function error ( ) : array { if ( ! empty ( $ this - > mysqli - > connect _errno ) ) { return [ 'code ' = > $ this - > mysqli - > connect _errno , 'message ' = > $ this - > mysqli - > connect _error , ] ; } return [ 'code ' = > $ this - > conn ID - > errno , 'message ' = > $ this - > conn ID - > error , ] ; } 
protected function _trans Commit ( ) : bool { if ( $ this - > conn ID - > commit ( ) ) { $ this - > conn ID - > autocommit ( true ) ; return true ; } return false ; } 
protected function _trans Rollback ( ) : bool { if ( $ this - > conn ID - > rollback ( ) ) { $ this - > conn ID - > autocommit ( true ) ; return true ; } return false ; } 
public function connect ( bool $ persistent = false ) { if ( $ persistent & & $ this - > db - > DBDebug ) { throw new Database Exception ( 'SQLite 3 doesn \ 't support persistent connections . ' ) ; } try { return ( ! $ this - > password ) ? new \ SQLite 3 ( $ this - > database ) : new \ SQLite 3 ( $ this - > database , SQLITE 3 _OPEN _READWRITE | SQLITE 3 _OPEN _CREATE , $ this - > password ) ; } catch ( \ Exception $ e ) { throw new Database Exception ( 'SQLite 3 error : ' . $ e - > get Message ( ) ) ; } } 
public function get Version ( ) : string { if ( isset ( $ this - > data Cache [ 'version ' ] ) ) { return $ this - > data Cache [ 'version ' ] ; } $ version = \ SQLite 3 : : version ( ) ; return $ this - > data Cache [ 'version ' ] = $ version [ 'version String ' ] ; } 
public function execute ( string $ sql ) { return $ this - > is Write Type ( $ sql ) ? $ this - > conn ID - > exec ( $ sql ) : $ this - > conn ID - > query ( $ sql ) ; } 
protected function _list Tables ( bool $ prefix Limit = false ) : string { return 'SELECT "NAME " FROM "SQLITE _MASTER " WHERE "TYPE " = \ 'table \ ' ' . ( ( $ prefix Limit ! = = false & & $ this - > DBPrefix ! = = ' ' ) ? ' AND "NAME " LIKE \ ' ' . $ this - > escape Like String ( $ this - > DBPrefix ) . ' % \ ' ' . sprintf ( $ this - > like Escape Str , $ this - > like Escape Char ) : ' ' ) ; } 
protected function _list Columns ( string $ table = ' ' ) : string { return 'PRAGMA TABLE _INFO ( ' . $ this - > protect Identifiers ( $ table , true , null , false ) . ' ) ' ; } 
public function get Field Names ( string $ table ) { 
public function _field Data ( string $ table ) : array { if ( ( $ query = $ this - > query ( 'PRAGMA TABLE _INFO ( ' . $ this - > protect Identifiers ( $ table , true , null , false ) . ' ) ' ) ) = = = false ) { throw new Database Exception ( lang ( 'Database .fail Get Field Data ' ) ) ; } $ query = $ query - > get Result Object ( ) ; if ( empty ( $ query ) ) { return [ ] ; } $ ret Val = [ ] ; for ( $ i = 0 , $ c = count ( $ query ) ; $ i < $ c ; $ i + + ) { $ ret Val [ $ i ] = new \ std Class ( ) ; $ ret Val [ $ i ] - > name = $ query [ $ i ] - > name ; $ ret Val [ $ i ] - > type = $ query [ $ i ] - > type ; $ ret Val [ $ i ] - > max _length = null ; $ ret Val [ $ i ] - > default = $ query [ $ i ] - > dflt _value ; $ ret Val [ $ i ] - > primary _key = isset ( $ query [ $ i ] - > pk ) ? ( bool ) $ query [ $ i ] - > pk : false ; $ ret Val [ $ i ] - > nullable = isset ( $ query [ $ i ] - > notnull ) ? ! ( bool ) $ query [ $ i ] - > notnull : false ; } return $ ret Val ; } 
public function _index Data ( string $ table ) : array { 
public function _foreign Key Data ( string $ table ) : array { if ( $ this - > supports Foreign Keys ( ) ! = = true ) { return [ ] ; } $ tables = $ this - > list Tables ( ) ; if ( empty ( $ tables ) ) { return [ ] ; } $ ret Val = [ ] ; foreach ( $ tables as $ table ) { $ query = $ this - > query ( "PRAGMA foreign _key _list ( { $table } ) " ) - > get Result ( ) ; foreach ( $ query as $ row ) { $ obj = new \ std Class ( ) ; $ obj - > constraint _name = $ row - > from . ' to ' . $ row - > table . ' . ' . $ row - > to ; $ obj - > table _name = $ table ; $ obj - > foreign _table _name = $ row - > table ; $ ret Val [ ] = $ obj ; } } return $ ret Val ; } 
public static function cache ( Cache $ config = null , bool $ get Shared = true ) { if ( $ get Shared ) { return static : : get Shared Instance ( 'cache ' , $ config ) ; } if ( ! is _object ( $ config ) ) { $ config = new Cache ( ) ; } return Cache Factory : : get Handler ( $ config ) ; } 
public static function clirequest ( App $ config = null , bool $ get Shared = true ) { if ( $ get Shared ) { return static : : get Shared Instance ( 'clirequest ' , $ config ) ; } if ( ! is _object ( $ config ) ) { $ config = config ( App : : class ) ; } return new CLIRequest ( $ config ) ; } 
public static function curlrequest ( array $ options = [ ] , Response Interface $ response = null , App $ config = null , bool $ get Shared = true ) { if ( $ get Shared = = = true ) { return static : : get Shared Instance ( 'curlrequest ' , $ options , $ response , $ config ) ; } if ( ! is _object ( $ config ) ) { $ config = config ( App : : class ) ; } if ( ! is _object ( $ response ) ) { $ response = new Response ( $ config ) ; } return new CURLRequest ( $ config , new URI ( $ options [ 'base _uri ' ] ? ? null ) , $ response , $ options ) ; } 
public static function exceptions ( \ Config \ Exceptions $ config = null , Incoming Request $ request = null , Response $ response = null , bool $ get Shared = true ) { if ( $ get Shared ) { return static : : get Shared Instance ( 'exceptions ' , $ config , $ request , $ response ) ; } if ( empty ( $ config ) ) { $ config = new \ Config \ Exceptions ( ) ; } if ( empty ( $ request ) ) { $ request = static : : request ( ) ; } if ( empty ( $ response ) ) { $ response = static : : response ( ) ; } return ( new Exceptions ( $ config , $ request , $ response ) ) ; } 
public static function filters ( $ config = null , bool $ get Shared = true ) { if ( $ get Shared ) { return static : : get Shared Instance ( 'filters ' , $ config ) ; } if ( empty ( $ config ) ) { $ config = new \ Config \ Filters ( ) ; } return new Filters ( $ config , static : : request ( ) , static : : response ( ) ) ; } 
public static function honeypot ( Base Config $ config = null , bool $ get Shared = true ) { if ( $ get Shared ) { return static : : get Shared Instance ( 'honeypot ' , $ config ) ; } if ( is _null ( $ config ) ) { $ config = new \ Config \ Honeypot ( ) ; } return new Honeypot ( $ config ) ; } 
public static function image ( string $ handler = null , $ config = null , bool $ get Shared = true ) { if ( $ get Shared ) { return static : : get Shared Instance ( 'image ' , $ handler , $ config ) ; } if ( empty ( $ config ) ) { $ config = new Images ( ) ; } $ handler = is _null ( $ handler ) ? $ config - > default Handler : $ handler ; $ class = $ config - > handlers [ $ handler ] ; return new $ class ( $ config ) ; } 
public static function language ( string $ locale = null , bool $ get Shared = true ) { if ( $ get Shared ) { return static : : get Shared Instance ( 'language ' , $ locale ) - > set Locale ( $ locale ) ; } $ locale = ! empty ( $ locale ) ? $ locale : static : : request ( ) - > get Locale ( ) ; return new Language ( $ locale ) ; } 
public static function logger ( bool $ get Shared = true ) { if ( $ get Shared ) { return static : : get Shared Instance ( 'logger ' ) ; } return new \ Code Igniter \ Log \ Logger ( new Logger ( ) ) ; } 
public static function migrations ( Base Config $ config = null , Connection Interface $ db = null , bool $ get Shared = true ) { if ( $ get Shared ) { return static : : get Shared Instance ( 'migrations ' , $ config , $ db ) ; } $ config = empty ( $ config ) ? new Migrations ( ) : $ config ; return new Migration Runner ( $ config , $ db ) ; } 
public static function negotiator ( Request Interface $ request = null , bool $ get Shared = true ) { if ( $ get Shared ) { return static : : get Shared Instance ( 'negotiator ' , $ request ) ; } if ( is _null ( $ request ) ) { $ request = static : : request ( ) ; } return new Negotiate ( $ request ) ; } 
public static function pager ( $ config = null , Renderer Interface $ view = null , bool $ get Shared = true ) { if ( $ get Shared ) { return static : : get Shared Instance ( 'pager ' , $ config , $ view ) ; } if ( empty ( $ config ) ) { $ config = new \ Config \ Pager ( ) ; } if ( ! $ view instanceof Renderer Interface ) { $ view = static : : renderer ( ) ; } return new Pager ( $ config , $ view ) ; } 
public static function parser ( string $ view Path = null , $ config = null , bool $ get Shared = true ) { if ( $ get Shared ) { return static : : get Shared Instance ( 'parser ' , $ view Path , $ config ) ; } if ( is _null ( $ config ) ) { $ config = new \ Config \ View ( ) ; } if ( is _null ( $ view Path ) ) { $ paths = config ( 'Paths ' ) ; $ view Path = $ paths - > view Directory ; } return new Parser ( $ config , $ view Path , static : : locator ( true ) , CI _DEBUG , static : : logger ( true ) ) ; } 
public static function request ( App $ config = null , bool $ get Shared = true ) { if ( $ get Shared ) { return static : : get Shared Instance ( 'request ' , $ config ) ; } if ( ! is _object ( $ config ) ) { $ config = config ( App : : class ) ; } return new Incoming Request ( $ config , new URI ( ) , 'php : / /input ' , new User Agent ( ) ) ; } 
public static function response ( App $ config = null , bool $ get Shared = true ) { if ( $ get Shared ) { return static : : get Shared Instance ( 'response ' , $ config ) ; } if ( ! is _object ( $ config ) ) { $ config = config ( App : : class ) ; } return new Response ( $ config ) ; } 
public static function redirect Response ( App $ config = null , bool $ get Shared = true ) { if ( $ get Shared ) { return static : : get Shared Instance ( 'redirect Response ' , $ config ) ; } if ( ! is _object ( $ config ) ) { $ config = config ( App : : class ) ; } $ response = new Redirect Response ( $ config ) ; $ response - > set Protocol Version ( static : : request ( ) - > get Protocol Version ( ) ) ; return $ response ; } 
public static function router ( Route Collection Interface $ routes = null , bool $ get Shared = true ) { if ( $ get Shared ) { return static : : get Shared Instance ( 'router ' , $ routes ) ; } if ( empty ( $ routes ) ) { $ routes = static : : routes ( true ) ; } return new Router ( $ routes ) ; } 
public static function security ( App $ config = null , bool $ get Shared = true ) { if ( $ get Shared ) { return static : : get Shared Instance ( 'security ' , $ config ) ; } if ( ! is _object ( $ config ) ) { $ config = config ( App : : class ) ; } return new Security ( $ config ) ; } 
public static function session ( App $ config = null , bool $ get Shared = true ) { if ( $ get Shared ) { return static : : get Shared Instance ( 'session ' , $ config ) ; } if ( ! is _object ( $ config ) ) { $ config = config ( App : : class ) ; } $ logger = static : : logger ( true ) ; $ driver Name = $ config - > session Driver ; $ driver = new $ driver Name ( $ config , static : : request ( ) - > get Ip Address ( ) ) ; $ driver - > set Logger ( $ logger ) ; $ session = new Session ( $ driver , $ config ) ; $ session - > set Logger ( $ logger ) ; if ( session _status ( ) = = = PHP _SESSION _NONE ) { $ session - > start ( ) ; } return $ session ; } 
public static function toolbar ( \ Config \ Toolbar $ config = null , bool $ get Shared = true ) { if ( $ get Shared ) { return static : : get Shared Instance ( 'toolbar ' , $ config ) ; } if ( ! is _object ( $ config ) ) { $ config = config ( 'Toolbar ' ) ; } return new Toolbar ( $ config ) ; } 
public static function uri ( string $ uri = null , bool $ get Shared = true ) { if ( $ get Shared ) { return static : : get Shared Instance ( 'uri ' , $ uri ) ; } return new URI ( $ uri ) ; } 
public static function validation ( \ Config \ Validation $ config = null , bool $ get Shared = true ) { if ( $ get Shared ) { return static : : get Shared Instance ( 'validation ' , $ config ) ; } if ( is _null ( $ config ) ) { $ config = config ( 'Validation ' ) ; } return new Validation ( $ config , static : : renderer ( ) ) ; } 
public function run ( array $ params = [ ] ) { $ runner = Services : : migrations ( ) ; CLI : : write ( lang ( 'Migrations .to Version ' ) , 'yellow ' ) ; $ group = $ params [ ' -g ' ] ? ? CLI : : get Option ( 'g ' ) ; try { $ runner - > current ( $ group ) ; $ messages = $ runner - > get Cli Messages ( ) ; foreach ( $ messages as $ message ) { CLI : : write ( $ message ) ; } CLI : : write ( 'Done ' ) ; } catch ( \ Exception $ e ) { $ this - > show Error ( $ e ) ; } } 
protected function destroy Cookie ( ) : bool { return setcookie ( $ this - > cookie Name , null , 1 , $ this - > cookie Path , $ this - > cookie Domain , $ this - > cookie Secure , true ) ; } 
public function run ( array $ params ) { $ commands = $ this - > commands - > get Commands ( ) ; $ this - > describe Commands ( $ commands ) ; CLI : : new Line ( ) ; } 
protected function describe Commands ( array $ commands = [ ] ) { ksort ( $ commands ) ; 
protected function pad Title ( string $ item , int $ max , int $ extra = 2 , int $ indent = 0 ) : string { $ max + = $ extra + $ indent ; $ item = str _repeat ( ' ' , $ indent ) . $ item ; $ item = str _pad ( $ item , $ max ) ; return $ item ; } 
public function list Databases ( ) { 
public function optimize Table ( string $ table _name ) { if ( $ this - > optimize Table = = = false ) { if ( $ this - > db - > DBDebug ) { throw new Database Exception ( 'Unsupported feature of the database platform you are using . ' ) ; } return false ; } $ query = $ this - > db - > query ( sprintf ( $ this - > optimize Table , $ this - > db - > escape Identifiers ( $ table _name ) ) ) ; if ( $ query ! = = false ) { $ query = $ query - > get Result Array ( ) ; return current ( $ query ) ; } return false ; } 
public function optimize Database ( ) { if ( $ this - > optimize Table = = = false ) { if ( $ this - > db - > DBDebug ) { throw new Database Exception ( 'Unsupported feature of the database platform you are using . ' ) ; } return false ; } $ result = [ ] ; foreach ( $ this - > db - > list Tables ( ) as $ table _name ) { $ res = $ this - > db - > query ( sprintf ( $ this - > optimize Table , $ this - > db - > escape Identifiers ( $ table _name ) ) ) ; if ( is _bool ( $ res ) ) { return $ res ; } 
public function get CSVFrom Result ( Result Interface $ query , string $ delim = ' , ' , string $ newline = " \n " , string $ enclosure = ' " ' ) { $ out = ' ' ; 
public function get XMLFrom Result ( Result Interface $ query , array $ params = [ ] ) : string { 
public function backup ( $ params = [ ] ) { 
protected function call ( string $ command , array $ params = [ ] ) { 
protected function show Error ( \ Exception $ e ) { CLI : : new Line ( ) ; CLI : : error ( $ e - > get Message ( ) ) ; CLI : : write ( $ e - > get File ( ) . ' - ' . $ e - > get Line ( ) ) ; CLI : : new Line ( ) ; } 
public function show Help ( ) { 
public function get Pad ( array $ array , int $ pad ) : int { $ max = 0 ; foreach ( $ array as $ key = > $ value ) { $ max = max ( $ max , strlen ( $ key ) ) ; } return $ max + $ pad ; } 
public function call ( string $ class ) { if ( empty ( $ class ) ) { throw new \ Invalid Argument Exception ( 'No Seeder was specified . ' ) ; } $ path = str _replace ( ' .php ' , ' ' , $ class ) . ' .php ' ; 
public function differs ( string $ str = null , string $ field , array $ data ) : bool { return array _key _exists ( $ field , $ data ) ? ( $ str ! = = $ data [ $ field ] ) : false ; } 
public function exact _length ( string $ str = null , string $ val , array $ data ) : bool { $ val = explode ( ' , ' , $ val ) ; foreach ( $ val as $ tmp ) { if ( is _numeric ( $ tmp ) & & ( int ) $ tmp = = = mb _strlen ( $ str ) ) { return true ; } } return false ; } 
public function greater _than ( string $ str = null , string $ min , array $ data ) : bool { return is _numeric ( $ str ) ? ( $ str > $ min ) : false ; } 
public function in _list ( string $ value = null , string $ list , array $ data ) : bool { $ list = explode ( ' , ' , $ list ) ; $ list = array _map ( function ( $ value ) { return trim ( $ value ) ; } , $ list ) ; return in _array ( $ value , $ list , true ) ; } 
public function is _unique ( string $ str = null , string $ field , array $ data ) : bool { 
public function less _than ( string $ str = null , string $ max ) : bool { return is _numeric ( $ str ) ? ( $ str < $ max ) : false ; } 
public function less _than _equal _to ( string $ str = null , string $ max ) : bool { return is _numeric ( $ str ) ? ( $ str < = $ max ) : false ; } 
public function max _length ( string $ str = null , string $ val , array $ data ) : bool { return ( $ val > = mb _strlen ( $ str ) ) ; } 
public function min _length ( string $ str = null , string $ val , array $ data ) : bool { return ( $ val < = mb _strlen ( $ str ) ) ; } 
public function required ( $ str = null ) : bool { if ( is _object ( $ str ) ) { return true ; } return is _array ( $ str ) ? ! empty ( $ str ) : ( trim ( $ str ) ! = = ' ' ) ; } 
public function required _with ( $ str = null , string $ fields , array $ data ) : bool { $ fields = explode ( ' , ' , $ fields ) ; 
public function required _without ( $ str = null , string $ fields , array $ data ) : bool { $ fields = explode ( ' , ' , $ fields ) ; 
public function get Field Names ( ) : array { $ field Names = [ ] ; for ( $ i = 0 , $ c = $ this - > get Field Count ( ) ; $ i < $ c ; $ i + + ) { $ field Names [ ] = pg _field _name ( $ this - > result ID , $ i ) ; } return $ field Names ; } 
public function get Field Data ( ) : array { $ ret Val = [ ] ; for ( $ i = 0 , $ c = $ this - > get Field Count ( ) ; $ i < $ c ; $ i + + ) { $ ret Val [ $ i ] = new \ std Class ( ) ; $ ret Val [ $ i ] - > name = pg _field _name ( $ this - > result ID , $ i ) ; $ ret Val [ $ i ] - > type = pg _field _type ( $ this - > result ID , $ i ) ; $ ret Val [ $ i ] - > max _length = pg _field _size ( $ this - > result ID , $ i ) ; 
public function free Result ( ) { if ( is _resource ( $ this - > result ID ) ) { pg _free _result ( $ this - > result ID ) ; $ this - > result ID = false ; } } 
public function handle ( string $ uri = null ) { $ this - > translate URIDashes = $ this - > collection - > should Translate URIDashes ( ) ; 
public function get 4 0 4Override ( ) { $ route = $ this - > collection - > get 4 0 4Override ( ) ; if ( is _string ( $ route ) ) { $ route Array = explode ( ' : : ' , $ route ) ; return [ $ route Array [ 0 ] , 
protected function check Routes ( string $ uri ) : bool { $ routes = $ this - > collection - > get Routes ( $ this - > collection - > get HTTPVerb ( ) ) ; $ uri = $ uri = = = ' / ' ? $ uri : ltrim ( $ uri , ' / ' ) ; 
public function auto Route ( string $ uri ) { $ segments = explode ( ' / ' , $ uri ) ; $ segments = $ this - > validate Request ( $ segments ) ; 
protected function validate Request ( array $ segments ) : array { $ segments = array _filter ( $ segments ) ; $ segments = array _values ( $ segments ) ; $ c = count ( $ segments ) ; $ directory _override = isset ( $ this - > directory ) ; 
protected function set Directory ( string $ dir = null , bool $ append = false ) { $ dir = ucfirst ( $ dir ) ; if ( $ append ! = = true | | empty ( $ this - > directory ) ) { $ this - > directory = str _replace ( ' . ' , ' ' , trim ( $ dir , ' / ' ) ) . ' / ' ; } else { $ this - > directory . = str _replace ( ' . ' , ' ' , trim ( $ dir , ' / ' ) ) . ' / ' ; } } 
protected function set Request ( array $ segments = [ ] ) { 
protected function set Default Controller ( ) { if ( empty ( $ this - > controller ) ) { throw Router Exception : : for Missing Default Route ( ) ; } 
public function order By ( string $ order By , string $ direction = ' ' , bool $ escape = null ) { $ direction = strtoupper ( trim ( $ direction ) ) ; if ( $ direction = = = 'RANDOM ' ) { if ( ! is _float ( $ order By ) & & ctype _digit ( ( string ) $ order By ) ) { $ order By = ( float ) ( $ order By > 1 ? " 0 . { $order By } " : $ order By ) ; } if ( is _float ( $ order By ) ) { $ this - > db - > simple Query ( "SET SEED { $order By } " ) ; } $ order By = $ this - > random Keyword [ 0 ] ; $ direction = ' ' ; $ escape = false ; } return parent : : order By ( $ order By , $ direction , $ escape ) ; } 
public function replace ( array $ set = null , bool $ return SQL = false ) { if ( $ set ! = = null ) { $ this - > set ( $ set ) ; } if ( ! $ this - > QBSet ) { if ( CI _DEBUG ) { throw new Database Exception ( 'You must use the "set " method to update an entry . ' ) ; } return false ; } $ table = $ this - > QBFrom [ 0 ] ; $ set = $ this - > binds ; 
public function delete ( $ where = ' ' , int $ limit = null , bool $ reset _data = true , bool $ return SQL = false ) { if ( ! empty ( $ limit ) | | ! empty ( $ this - > QBLimit ) ) { throw new Database Exception ( 'Postgre SQL does not allow LIMITs on DELETE queries . ' ) ; } return parent : : delete ( $ where , $ limit , $ reset _data , $ return SQL ) ; } 
protected function _update ( string $ table , array $ values ) : string { if ( ! empty ( $ this - > QBLimit ) ) { throw new Database Exception ( 'Postgres does not support LIMITs with UPDATE queries . ' ) ; } $ this - > QBOrder By = [ ] ; return parent : : _update ( $ table , $ values ) ; } 
protected function _delete ( string $ table ) : string { $ this - > QBLimit = false ; return parent : : _delete ( $ table ) ; } 
public function get Size ( string $ unit = 'b ' ) { if ( is _null ( $ this - > size ) ) { $ this - > size = filesize ( $ this - > get Pathname ( ) ) ; } switch ( strtolower ( $ unit ) ) { case 'kb ' : return number _format ( $ this - > size / 1 0 2 4 , 3 ) ; case 'mb ' : return number _format ( ( $ this - > size / 1 0 2 4 ) / 1 0 2 4 , 3 ) ; } return ( int ) $ this - > size ; } 
public function get Mime Type ( ) : string { $ finfo = finfo _open ( FILEINFO _MIME _TYPE ) ; $ mime Type = finfo _file ( $ finfo , $ this - > get Real Path ( ) ) ; finfo _close ( $ finfo ) ; return $ mime Type ; } 
public function move ( string $ target Path , string $ name = null , bool $ overwrite = false ) { $ target Path = rtrim ( $ target Path , ' / ' ) . ' / ' ; $ name = $ name ? ? $ this - > get Base Name ( ) ; $ destination = $ overwrite ? $ target Path . $ name : $ this - > get Destination ( $ target Path . $ name ) ; $ old Name = empty ( $ this - > get Real Path ( ) ) ? $ this - > get Path ( ) : $ this - > get Real Path ( ) ; if ( ! @ rename ( $ old Name , $ destination ) ) { $ error = error _get _last ( ) ; throw File Exception : : for Unable To Move ( $ this - > get Basename ( ) , $ target Path , strip _tags ( $ error [ 'message ' ] ) ) ; } @ chmod ( $ target Path , 0 7 7 7 & ~ umask ( ) ) ; return new File ( $ destination ) ; } 
public function get Destination ( string $ destination , string $ delimiter = ' _ ' , int $ i = 0 ) : string { while ( is _file ( $ destination ) ) { $ info = pathinfo ( $ destination ) ; if ( strpos ( $ info [ 'filename ' ] , $ delimiter ) ! = = false ) { $ parts = explode ( $ delimiter , $ info [ 'filename ' ] ) ; if ( is _numeric ( end ( $ parts ) ) ) { $ i = end ( $ parts ) ; array _pop ( $ parts ) ; array _push ( $ parts , + + $ i ) ; $ destination = $ info [ 'dirname ' ] . ' / ' . implode ( $ delimiter , $ parts ) . ' . ' . $ info [ 'extension ' ] ; } else { $ destination = $ info [ 'dirname ' ] . ' / ' . $ info [ 'filename ' ] . $ delimiter . + + $ i . ' . ' . $ info [ 'extension ' ] ; } } else { $ destination = $ info [ 'dirname ' ] . ' / ' . $ info [ 'filename ' ] . $ delimiter . + + $ i . ' . ' . $ info [ 'extension ' ] ; } } return $ destination ; } 
public static function collect ( Query $ query ) { $ config = config ( 'Toolbar ' ) ; 
protected function format Timeline Data ( ) : array { $ data = [ ] ; foreach ( $ this - > connections as $ alias = > $ connection ) { 
public function display ( ) : array { 
public function locate File ( string $ file , string $ folder = null , string $ ext = 'php ' ) { $ file = $ this - > ensure Ext ( $ file , $ ext ) ; 
public function get Classname ( string $ file ) : string { $ php = file _get _contents ( $ file ) ; $ tokens = token _get _all ( $ php ) ; $ count = count ( $ tokens ) ; $ dlm = false ; $ namespace = ' ' ; $ class _name = ' ' ; for ( $ i = 2 ; $ i < $ count ; $ i + + ) { if ( ( isset ( $ tokens [ $ i - 2 ] [ 1 ] ) & & ( $ tokens [ $ i - 2 ] [ 1 ] = = = 'phpnamespace ' | | $ tokens [ $ i - 2 ] [ 1 ] = = = 'namespace ' ) ) | | ( $ dlm & & $ tokens [ $ i - 1 ] [ 0 ] = = = T _NS _SEPARATOR & & $ tokens [ $ i ] [ 0 ] = = = T _STRING ) ) { if ( ! $ dlm ) { $ namespace = 0 ; } if ( isset ( $ tokens [ $ i ] [ 1 ] ) ) { $ namespace = $ namespace ? $ namespace . ' \ \ ' . $ tokens [ $ i ] [ 1 ] : $ tokens [ $ i ] [ 1 ] ; $ dlm = true ; } } elseif ( $ dlm & & ( $ tokens [ $ i ] [ 0 ] ! = = T _NS _SEPARATOR ) & & ( $ tokens [ $ i ] [ 0 ] ! = = T _STRING ) ) { $ dlm = false ; } if ( ( $ tokens [ $ i - 2 ] [ 0 ] = = = T _CLASS | | ( isset ( $ tokens [ $ i - 2 ] [ 1 ] ) & & $ tokens [ $ i - 2 ] [ 1 ] = = = 'phpclass ' ) ) & & $ tokens [ $ i - 1 ] [ 0 ] = = = T _WHITESPACE & & $ tokens [ $ i ] [ 0 ] = = = T _STRING ) { $ class _name = $ tokens [ $ i ] [ 1 ] ; break ; } } if ( empty ( $ class _name ) ) { return ' ' ; } return $ namespace . ' \ \ ' . $ class _name ; } 
public function search ( string $ path , string $ ext = 'php ' ) : array { $ path = $ this - > ensure Ext ( $ path , $ ext ) ; $ found Paths = [ ] ; foreach ( $ this - > get Namespaces ( ) as $ namespace ) { if ( is _file ( $ namespace [ 'path ' ] . $ path ) ) { $ found Paths [ ] = $ namespace [ 'path ' ] . $ path ; } } 
protected function ensure Ext ( string $ path , string $ ext ) : string { if ( $ ext ) { $ ext = ' . ' . $ ext ; if ( substr ( $ path , - strlen ( $ ext ) ) ! = = $ ext ) { $ path . = $ ext ; } } return $ path ; } 
protected function get Namespaces ( string $ prefix = null ) { if ( $ prefix ) { $ path = $ this - > autoloader - > get Namespace ( $ prefix ) ; return isset ( $ path [ 0 ] ) ? rtrim ( $ path [ 0 ] , DIRECTORY _SEPARATOR ) . DIRECTORY _SEPARATOR : ' ' ; } $ namespaces = [ ] ; foreach ( $ this - > autoloader - > get Namespace ( ) as $ prefix = > $ paths ) { foreach ( $ paths as $ path ) { $ namespaces [ ] = [ 'prefix ' = > $ prefix , 'path ' = > rtrim ( $ path , DIRECTORY _SEPARATOR ) . DIRECTORY _SEPARATOR , ] ; } } return $ namespaces ; } 
public function find Qualified Name From Path ( string $ path ) { $ path = realpath ( $ path ) ; if ( ! $ path ) { return false ; } foreach ( $ this - > get Namespaces ( ) as $ namespace ) { $ namespace [ 'path ' ] = realpath ( $ namespace [ 'path ' ] ) ; if ( empty ( $ namespace [ 'path ' ] ) ) { continue ; } if ( mb _strpos ( $ path , $ namespace [ 'path ' ] ) = = = 0 ) { $ class Name = ' \ \ ' . $ namespace [ 'prefix ' ] . ' \ \ ' . ltrim ( str _replace ( ' / ' , ' \ \ ' , mb _substr ( $ path , mb _strlen ( $ namespace [ 'path ' ] ) ) ) , ' \ \ ' ) ; 
public function list Files ( string $ path ) : array { if ( empty ( $ path ) ) { return [ ] ; } $ files = [ ] ; helper ( 'filesystem ' ) ; foreach ( $ this - > get Namespaces ( ) as $ namespace ) { $ full Path = realpath ( $ namespace [ 'path ' ] . $ path ) ; if ( ! is _dir ( $ full Path ) ) { continue ; } $ temp Files = get _filenames ( $ full Path , true ) ; if ( ! empty ( $ temp Files ) ) { $ files = array _merge ( $ files , $ temp Files ) ; } } return $ files ; } 
public function list Namespace Files ( string $ prefix , string $ path ) : array { if ( empty ( $ path ) | | empty ( $ prefix ) ) { return [ ] ; } $ files = [ ] ; helper ( 'filesystem ' ) ; 
protected function legacy Locate ( string $ file , string $ folder = null ) { $ paths = [ APPPATH , SYSTEMPATH , ] ; foreach ( $ paths as $ path ) { $ path . = empty ( $ folder ) ? $ file : $ folder . ' / ' . $ file ; if ( is _file ( $ path ) ) { return $ path ; } } return false ; } 
public function render ( string $ view , array $ options = null , bool $ save Data = null ) : string { $ this - > render Vars [ 'start ' ] = microtime ( true ) ; 
public function render String ( string $ view , array $ options = null , bool $ save Data = null ) : string { $ start = microtime ( true ) ; if ( is _null ( $ save Data ) ) { $ save Data = $ this - > config - > save Data ; } extract ( $ this - > data ) ; if ( ! $ save Data ) { $ this - > data = [ ] ; } ob _start ( ) ; $ incoming = ' ? > ' . $ view ; eval ( $ incoming ) ; $ output = ob _get _contents ( ) ; @ ob _end _clean ( ) ; $ this - > log Performance ( $ start , microtime ( true ) , $ this - > excerpt ( $ view ) ) ; return $ output ; } 
public function excerpt ( string $ string , int $ length = 2 0 ) : string { return ( strlen ( $ string ) > $ length ) ? substr ( $ string , 0 , $ length - 3 ) . ' . . . ' : $ string ; } 
public function set Data ( array $ data = [ ] , string $ context = null ) : Renderer Interface { if ( ! empty ( $ context ) ) { $ data = \ esc ( $ data , $ context ) ; } $ this - > data = array _merge ( $ this - > data , $ data ) ; return $ this ; } 
public function set Var ( string $ name , $ value = null , string $ context = null ) : Renderer Interface { if ( ! empty ( $ context ) ) { $ value = \ esc ( $ value , $ context ) ; } $ this - > data [ $ name ] = $ value ; return $ this ; } 
public function render Section ( string $ section Name ) { if ( ! isset ( $ this - > sections [ $ section Name ] ) ) { echo ' ' ; return ; } foreach ( $ this - > sections [ $ section Name ] as $ contents ) { echo $ contents ; } } 
public function include ( string $ view , array $ options = null , $ save Data = null ) : string { return $ this - > render ( $ view , $ options , $ save Data ) ; } 
protected function log Performance ( float $ start , float $ end , string $ view ) { if ( ! $ this - > debug ) { return ; } $ this - > performance Data [ ] = [ 'start ' = > $ start , 'end ' = > $ end , 'view ' = > $ view , ] ; } 
public function with File ( string $ path ) { 
protected function ensure Resource ( ) { if ( $ this - > resource = = = null ) { $ path = $ this - > image - > get Pathname ( ) ; 
public function resize ( int $ width , int $ height , bool $ maintain Ratio = false , string $ master Dim = 'auto ' ) { 
public function crop ( int $ width = null , int $ height = null , int $ x = null , int $ y = null , bool $ maintain Ratio = false , string $ master Dim = 'auto ' ) { $ this - > width = $ width ; $ this - > height = $ height ; $ this - > x Axis = $ x ; $ this - > y Axis = $ y ; if ( $ maintain Ratio ) { $ this - > master Dim = $ master Dim ; $ this - > reproportion ( ) ; } $ result = $ this - > _crop ( ) ; $ this - > x Axis = null ; $ this - > y Axis = null ; return $ result ; } 
public function rotate ( float $ angle ) { 
public function flatten ( int $ red = 2 5 5 , int $ green = 2 5 5 , int $ blue = 2 5 5 ) { $ this - > width = $ this - > image - > orig Width ; $ this - > height = $ this - > image - > orig Height ; return $ this - > _flatten ( ) ; } 
public function flip ( string $ dir = 'vertical ' ) { $ dir = strtolower ( $ dir ) ; if ( $ dir ! = = 'vertical ' & & $ dir ! = = 'horizontal ' ) { throw Image Exception : : for Invalid Direction ( $ dir ) ; } return $ this - > _flip ( $ dir ) ; } 
public function text ( string $ text , array $ options = [ ] ) { $ options = array _merge ( $ this - > text Defaults , $ options ) ; $ options [ 'color ' ] = trim ( $ options [ 'color ' ] , ' # ' ) ; $ options [ 'shadow Color ' ] = trim ( $ options [ 'shadow Color ' ] , ' # ' ) ; $ this - > _text ( $ text , $ options ) ; return $ this ; } 
public function reorient ( bool $ silent = false ) { $ orientation = $ this - > get EXIF ( 'Orientation ' , $ silent ) ; switch ( $ orientation ) { case 2 : return $ this - > flip ( 'horizontal ' ) ; break ; case 3 : return $ this - > rotate ( 1 8 0 ) ; break ; case 4 : return $ this - > rotate ( 1 8 0 ) - > flip ( 'horizontal ' ) ; break ; case 5 : return $ this - > rotate ( 2 7 0 ) - > flip ( 'horizontal ' ) ; break ; case 6 : return $ this - > rotate ( 2 7 0 ) ; break ; case 7 : return $ this - > rotate ( 9 0 ) - > flip ( 'horizontal ' ) ; break ; case 8 : return $ this - > rotate ( 9 0 ) ; break ; default : return $ this ; } } 
public function get EXIF ( string $ key = null , bool $ silent = false ) { if ( ! function _exists ( 'exif _read _data ' ) ) { if ( $ silent ) { return null ; } } $ exif = exif _read _data ( $ this - > image - > get Pathname ( ) ) ; if ( ! is _null ( $ key ) & & is _array ( $ exif ) ) { $ exif = $ exif [ $ key ] ? ? false ; } return $ exif ; } 
public function fit ( int $ width , int $ height = null , string $ position = 'center ' ) { $ orig Width = $ this - > image - > orig Width ; $ orig Height = $ this - > image - > orig Height ; list ( $ crop Width , $ crop Height ) = $ this - > calc Aspect Ratio ( $ width , $ height , $ orig Width , $ orig Height ) ; if ( is _null ( $ height ) ) { $ height = ceil ( ( $ width / $ crop Width ) * $ crop Height ) ; } list ( $ x , $ y ) = $ this - > calc Crop Coords ( $ width , $ height , $ orig Width , $ orig Height , $ position ) ; return $ this - > crop ( $ crop Width , $ crop Height , $ x , $ y ) - > resize ( $ width , $ height ) ; } 
protected function calc Crop Coords ( $ width , $ height , $ orig Width , $ orig Height , $ position ) : array { $ position = strtolower ( $ position ) ; $ x = $ y = 0 ; switch ( $ position ) { case 'top -left ' : $ x = 0 ; $ y = 0 ; break ; case 'top ' : $ x = floor ( ( $ orig Width - $ width ) / 2 ) ; $ y = 0 ; break ; case 'top -right ' : $ x = $ orig Width - $ width ; $ y = 0 ; break ; case 'left ' : $ x = 0 ; $ y = floor ( ( $ orig Height - $ height ) / 2 ) ; break ; case 'center ' : $ x = floor ( ( $ orig Width - $ width ) / 2 ) ; $ y = floor ( ( $ orig Height - $ height ) / 2 ) ; break ; case 'right ' : $ x = ( $ orig Width - $ width ) ; $ y = floor ( ( $ orig Height - $ height ) / 2 ) ; break ; case 'bottom -left ' : $ x = 0 ; $ y = $ orig Height - $ height ; break ; case 'bottom ' : $ x = floor ( ( $ orig Width - $ width ) / 2 ) ; $ y = $ orig Height - $ height ; break ; case 'bottom -right ' : $ x = ( $ orig Width - $ width ) ; $ y = $ orig Height - $ height ; break ; } return [ $ x , $ y , ] ; } 
protected function reproportion ( ) { if ( ( $ this - > width = = = 0 & & $ this - > height = = = 0 ) | | $ this - > image - > orig Width = = = 0 | | $ this - > image - > orig Height = = = 0 | | ( ! ctype _digit ( ( string ) $ this - > width ) & & ! ctype _digit ( ( string ) $ this - > height ) ) | | ! ctype _digit ( ( string ) $ this - > image - > orig Width ) | | ! ctype _digit ( ( string ) $ this - > image - > orig Height ) ) { return ; } 
public function get ( string $ key ) { $ key = $ this - > prefix . $ key ; $ success = false ; $ data = wincache _ucache _get ( $ key , $ success ) ; 
public function save ( string $ key , $ value , int $ ttl = 6 0 ) { $ key = $ this - > prefix . $ key ; return wincache _ucache _set ( $ key , $ value , $ ttl ) ; } 
public function increment ( string $ key , int $ offset = 1 ) { $ key = $ this - > prefix . $ key ; $ success = false ; $ value = wincache _ucache _inc ( $ key , $ offset , $ success ) ; return ( $ success = = = true ) ? $ value : false ; } 
public function decrement ( string $ key , int $ offset = 1 ) { $ key = $ this - > prefix . $ key ; $ success = false ; $ value = wincache _ucache _dec ( $ key , $ offset , $ success ) ; return ( $ success = = = true ) ? $ value : false ; } 
public function get Meta Data ( string $ key ) { $ key = $ this - > prefix . $ key ; if ( $ stored = wincache _ucache _info ( false , $ key ) ) { $ age = $ stored [ 'ucache _entries ' ] [ 1 ] [ 'age _seconds ' ] ; $ ttl = $ stored [ 'ucache _entries ' ] [ 1 ] [ 'ttl _seconds ' ] ; $ hitcount = $ stored [ 'ucache _entries ' ] [ 1 ] [ 'hitcount ' ] ; return [ 'expire ' = > $ ttl - $ age , 'hitcount ' = > $ hitcount , 'age ' = > $ age , 'ttl ' = > $ ttl , ] ; } return false ; } 
public function run ( array $ params ) { 
public function render ( string $ view , array $ options = null , bool $ save Data = null ) : string { $ start = microtime ( true ) ; if ( is _null ( $ save Data ) ) { $ save Data = $ this - > config - > save Data ; } $ view = str _replace ( ' .php ' , ' ' , $ view ) ; 
public function render String ( string $ template , array $ options = null , bool $ save Data = null ) : string { $ start = microtime ( true ) ; if ( is _null ( $ save Data ) ) { $ save Data = $ this - > config - > save Data ; } $ output = $ this - > parse ( $ template , $ this - > data , $ options ) ; $ this - > log Performance ( $ start , microtime ( true ) , $ this - > excerpt ( $ template ) ) ; if ( ! $ save Data ) { $ this - > data = [ ] ; } return $ output ; } 
public function set Data ( array $ data = [ ] , string $ context = null ) : Renderer Interface { if ( ! empty ( $ context ) ) { foreach ( $ data as $ key = > & $ value ) { if ( is _array ( $ value ) ) { foreach ( $ value as & $ obj ) { $ obj = $ this - > object To Array ( $ obj ) ; } } else { $ value = $ this - > object To Array ( $ value ) ; } $ this - > data Contexts [ $ key ] = $ context ; } } $ this - > data = array _merge ( $ this - > data , $ data ) ; return $ this ; } 
protected function parse ( string $ template , array $ data = [ ] , array $ options = null ) : string { if ( $ template = = = ' ' ) { return ' ' ; } 
protected function parse Single ( string $ key , string $ val ) : array { $ pattern = ' # ' . $ this - > left Delimiter . ' ! ? \s * ' . preg _quote ( $ key ) . ' \s * \ | * \s * ( [ |a -z A -Z 0 - 9 < > = \ ( \ ) , : _ \ - \s \ + ] + ) * \s * ! ? ' . $ this - > right Delimiter . ' #ms ' ; return [ $ pattern = > $ val ] ; } 
protected function parse Pair ( string $ variable , array $ data , string $ template ) : array { * Each match looks like : * * $match [ 0 ] {tag } . . . { /tag } * $match [ 1 ] Contents inside the tag * / foreach ( $ matches as $ match ) { 
protected function extract Noparse ( string $ template ) : string { $ pattern = ' / \ { \s *noparse \s * \ } ( . * ? ) \ { \s * \ /noparse \s * \ } /ms ' ; if ( preg _match _all ( $ pattern , $ template , $ matches , PREG _SET _ORDER ) ) { foreach ( $ matches as $ match ) { 
public function insert Noparse ( string $ template ) : string { foreach ( $ this - > noparse Blocks as $ hash = > $ replace ) { $ template = str _replace ( "noparse _ { $hash } " , $ replace , $ template ) ; unset ( $ this - > noparse Blocks [ $ hash ] ) ; } return $ template ; } 
protected function parse Conditionals ( string $ template ) : string { $ pattern = ' / \ { \s * (if |elseif ) \s * ( ( ? : \ ( ) ? ( . * ? ) ( ? : \ ) ) ? ) \s * \ } /ms ' ; preg _match _all ( $ pattern , $ template , $ matches , PREG _SET _ORDER ) ; foreach ( $ matches as $ match ) { 
public function set Delimiters ( $ left Delimiter = ' { ' , $ right Delimiter = ' } ' ) : Renderer Interface { $ this - > left Delimiter = $ left Delimiter ; $ this - > right Delimiter = $ right Delimiter ; return $ this ; } 
protected function replace Single ( $ pattern , $ content , $ template , bool $ escape = false ) : string { 
protected function prepare Replacement ( array $ matches , string $ replace , bool $ escape = true ) : string { $ orig = array _shift ( $ matches ) ; 
public function should Add Escaping ( string $ key ) { $ escape = false ; $ key = trim ( str _replace ( [ ' { ' , ' } ' ] , ' ' , $ key ) ) ; 
protected function apply Filters ( string $ replace , array $ filters ) : string { 
protected function parse Plugins ( string $ template ) { foreach ( $ this - > plugins as $ plugin = > $ callable ) { * Match tag pairs * * Each match is an array : * $matches [ 0 ] = entire matched string * $matches [ 1 ] = all parameters string in opening tag * $matches [ 2 ] = content between the tags to send to the plugin . * / preg _match _all ( $ pattern , $ template , $ matches , PREG _SET _ORDER ) ; if ( empty ( $ matches ) ) { continue ; } foreach ( $ matches as $ match ) { $ params = [ ] ; 
public function add Plugin ( string $ alias , callable $ callback , bool $ is Pair = false ) { $ this - > plugins [ $ alias ] = $ is Pair ? [ $ callback ] : $ callback ; return $ this ; } 
protected function object To Array ( $ value ) { 
protected function _rotate ( int $ angle ) : bool { 
public function _flatten ( int $ red = 2 5 5 , int $ green = 2 5 5 , int $ blue = 2 5 5 ) { $ src Img = $ this - > create Image ( ) ; if ( function _exists ( 'imagecreatetruecolor ' ) ) { $ create = 'imagecreatetruecolor ' ; $ copy = 'imagecopyresampled ' ; } else { $ create = 'imagecreate ' ; $ copy = 'imagecopyresized ' ; } $ dest = $ create ( $ this - > width , $ this - > height ) ; $ matte = imagecolorallocate ( $ dest , $ red , $ green , $ blue ) ; imagefilledrectangle ( $ dest , 0 , 0 , $ this - > width , $ this - > height , $ matte ) ; imagecopy ( $ dest , $ src Img , 0 , 0 , 0 , 0 , $ this - > width , $ this - > height ) ; 
public function _flip ( string $ direction ) { $ src Img = $ this - > create Image ( ) ; $ width = $ this - > image - > orig Width ; $ height = $ this - > image - > orig Height ; if ( $ direction = = = 'horizontal ' ) { for ( $ i = 0 ; $ i < $ height ; $ i + + ) { $ left = 0 ; $ right = $ width - 1 ; while ( $ left < $ right ) { $ cl = imagecolorat ( $ src Img , $ left , $ i ) ; $ cr = imagecolorat ( $ src Img , $ right , $ i ) ; imagesetpixel ( $ src Img , $ left , $ i , $ cr ) ; imagesetpixel ( $ src Img , $ right , $ i , $ cl ) ; $ left + + ; $ right - - ; } } } else { for ( $ i = 0 ; $ i < $ width ; $ i + + ) { $ top = 0 ; $ bottom = $ height - 1 ; while ( $ top < $ bottom ) { $ ct = imagecolorat ( $ src Img , $ i , $ top ) ; $ cb = imagecolorat ( $ src Img , $ i , $ bottom ) ; imagesetpixel ( $ src Img , $ i , $ top , $ cb ) ; imagesetpixel ( $ src Img , $ i , $ bottom , $ ct ) ; $ top + + ; $ bottom - - ; } } } $ this - > resource = $ src Img ; return $ this ; } 
protected function process ( string $ action ) { $ orig Width = $ this - > image - > orig Width ; $ orig Height = $ this - > image - > orig Height ; if ( $ action = = = 'crop ' ) { 
public function save ( string $ target = null , int $ quality = 9 0 ) : bool { $ target = empty ( $ target ) ? $ this - > image - > get Pathname ( ) : $ target ; switch ( $ this - > image - > image Type ) { case IMAGETYPE _GIF : if ( ! function _exists ( 'imagegif ' ) ) { throw Image Exception : : for Invalid Image Create ( lang ( 'images .gif Not Supported ' ) ) ; } if ( ! @ imagegif ( $ this - > resource , $ target ) ) { throw Image Exception : : for Save Failed ( ) ; } break ; case IMAGETYPE _JPEG : if ( ! function _exists ( 'imagejpeg ' ) ) { throw Image Exception : : for Invalid Image Create ( lang ( 'images .jpg Not Supported ' ) ) ; } if ( ! @ imagejpeg ( $ this - > resource , $ target , $ quality ) ) { throw Image Exception : : for Save Failed ( ) ; } break ; case IMAGETYPE _PNG : if ( ! function _exists ( 'imagepng ' ) ) { throw Image Exception : : for Invalid Image Create ( lang ( 'images .png Not Supported ' ) ) ; } if ( ! @ imagepng ( $ this - > resource , $ target ) ) { throw Image Exception : : for Save Failed ( ) ; } break ; default : throw Image Exception : : for Invalid Image Create ( ) ; break ; } imagedestroy ( $ this - > resource ) ; chmod ( $ target , $ this - > file Permissions ) ; return true ; } 
protected function create Image ( string $ path = ' ' , string $ image Type = ' ' ) { if ( $ this - > resource ! = = null ) { return $ this - > resource ; } if ( $ path = = = ' ' ) { $ path = $ this - > image - > get Pathname ( ) ; } if ( $ image Type = = = ' ' ) { $ image Type = $ this - > image - > image Type ; } switch ( $ image Type ) { case IMAGETYPE _GIF : if ( ! function _exists ( 'imagecreatefromgif ' ) ) { throw Image Exception : : for Invalid Image Create ( lang ( 'images .gif Not Supported ' ) ) ; } return imagecreatefromgif ( $ path ) ; case IMAGETYPE _JPEG : if ( ! function _exists ( 'imagecreatefromjpeg ' ) ) { throw Image Exception : : for Invalid Image Create ( lang ( 'images .jpg Not Supported ' ) ) ; } return imagecreatefromjpeg ( $ path ) ; case IMAGETYPE _PNG : if ( ! function _exists ( 'imagecreatefrompng ' ) ) { throw Image Exception : : for Invalid Image Create ( lang ( 'images .png Not Supported ' ) ) ; } return imagecreatefrompng ( $ path ) ; default : throw Image Exception : : for Invalid Image Create ( 'Ima ' ) ; } } 
protected function _text ( string $ text , array $ options = [ ] ) { 
protected function text Overlay ( string $ text , array $ options = [ ] , bool $ is Shadow = false ) { $ src = $ this - > create Image ( ) ; $ opacity = ( $ options [ 'opacity ' ] * 1 2 7 ) ; 
public function init Controller ( \ Code Igniter \ HTTP \ Request Interface $ request , \ Code Igniter \ HTTP \ Response Interface $ response , \ Psr \ Log \ Logger Interface $ logger ) { 
public function populate Headers ( ) { $ content Type = $ _SERVER [ 'CONTENT _TYPE ' ] ? ? getenv ( 'CONTENT _TYPE ' ) ; if ( ! empty ( $ content Type ) ) { $ this - > set Header ( 'Content -Type ' , $ content Type ) ; } unset ( $ content Type ) ; foreach ( $ _SERVER as $ key = > $ val ) { if ( sscanf ( $ key , 'HTTP _ %s ' , $ header ) = = = 1 ) { 
public function get Header ( string $ name ) { $ orig _name = $ this - > get Header Name ( $ name ) ; if ( ! isset ( $ this - > headers [ $ orig _name ] ) ) { return null ; } return $ this - > headers [ $ orig _name ] ; } 
public function has Header ( string $ name ) : bool { $ orig _name = $ this - > get Header Name ( $ name ) ; return isset ( $ this - > headers [ $ orig _name ] ) ; } 
public function get Header Line ( string $ name ) : string { $ orig _name = $ this - > get Header Name ( $ name ) ; if ( ! array _key _exists ( $ orig _name , $ this - > headers ) ) { return ' ' ; } return $ this - > headers [ $ orig _name ] - > get Value Line ( ) ; } 
public function set Header ( string $ name , $ value ) { if ( ! isset ( $ this - > headers [ $ name ] ) ) { $ this - > headers [ $ name ] = new Header ( $ name , $ value ) ; $ this - > header Map [ strtolower ( $ name ) ] = $ name ; return $ this ; } if ( ! is _array ( $ this - > headers [ $ name ] ) ) { $ this - > headers [ $ name ] = [ $ this - > headers [ $ name ] ] ; } if ( isset ( $ this - > headers [ $ name ] ) ) { $ this - > headers [ $ name ] = new Header ( $ name , $ value ) ; } return $ this ; } 
public function remove Header ( string $ name ) { $ orig _name = $ this - > get Header Name ( $ name ) ; unset ( $ this - > headers [ $ orig _name ] ) ; unset ( $ this - > header Map [ strtolower ( $ name ) ] ) ; return $ this ; } 
public function append Header ( string $ name , string $ value ) { $ orig _name = $ this - > get Header Name ( $ name ) ; $ this - > headers [ $ orig _name ] - > append Value ( $ value ) ; return $ this ; } 
public function prepend Header ( string $ name , string $ value ) { $ orig _name = $ this - > get Header Name ( $ name ) ; $ this - > headers [ $ orig _name ] - > prepend Value ( $ value ) ; return $ this ; } 
public function set Protocol Version ( string $ version ) { if ( ! is _numeric ( $ version ) ) { $ version = substr ( $ version , strpos ( $ version , ' / ' ) + 1 ) ; } if ( ! in _array ( $ version , $ this - > valid Protocol Versions ) ) { throw HTTPException : : for Invalid HTTPProtocol ( implode ( ' , ' , $ this - > valid Protocol Versions ) ) ; } $ this - > protocol Version = $ version ; return $ this ; } 
protected function get Header Name ( string $ name ) : string { $ lower _name = strtolower ( $ name ) ; return $ this - > header Map [ $ lower _name ] ? ? $ name ; } 
public function prepare ( string $ sql , array $ options = [ ] , string $ query Class = 'Code Igniter \ \Database \ \Query ' ) { * @var \Code Igniter \Database \Query $query * / $ query = new $ query Class ( $ this - > db ) ; $ query - > set Query ( $ sql ) ; if ( ! empty ( $ this - > db - > swap Pre ) & & ! empty ( $ this - > db - > DBPrefix ) ) { $ query - > swap Prefix ( $ this - > db - > DBPrefix , $ this - > db - > swap Pre ) ; } $ this - > query = $ query ; return $ this - > _prepare ( $ query - > get Original Query ( ) , $ options ) ; } 
public function execute ( . . . $ data ) { 
public static function mailto ( array $ params = [ ] ) : string { $ email = $ params [ 'email ' ] ? ? ' ' ; $ title = $ params [ 'title ' ] ? ? ' ' ; $ attrs = $ params [ 'attributes ' ] ? ? ' ' ; return mailto ( $ email , $ title , $ attrs ) ; } 
public static function safe Mailto ( array $ params = [ ] ) : string { $ email = $ params [ 'email ' ] ? ? ' ' ; $ title = $ params [ 'title ' ] ? ? ' ' ; $ attrs = $ params [ 'attributes ' ] ? ? ' ' ; return safe _mailto ( $ email , $ title , $ attrs ) ; } 
public static function Validation Errors ( array $ params = [ ] ) : string { $ validator = \ Config \ Services : : validation ( ) ; if ( empty ( $ params ) ) { return $ validator - > list Errors ( ) ; } return $ validator - > show Error ( $ params [ 'field ' ] ) ; } 
public function run ( array $ params ) { $ command = array _shift ( $ params ) ; if ( is _null ( $ command ) ) { $ command = 'help ' ; } $ commands = $ this - > commands - > get Commands ( ) ; $ class = new $ commands [ $ command ] [ 'class ' ] ( $ this - > logger , $ this - > commands ) ; $ class - > show Help ( ) ; } 
public function open ( $ save Path , $ name ) : bool { if ( ! is _dir ( $ save Path ) ) { if ( ! mkdir ( $ save Path , 0 7 0 0 , true ) ) { throw Session Exception : : for Invalid Save Path ( $ this - > save Path ) ; } } elseif ( ! is _writable ( $ save Path ) ) { throw Session Exception : : for Write Protected Save Path ( $ this - > save Path ) ; } $ this - > save Path = $ save Path ; $ this - > file Path = $ this - > save Path . ' / ' . $ name 
public function read ( $ session ID ) : string { 
public function write ( $ session ID , $ session Data ) : bool { 
public function close ( ) : bool { if ( is _resource ( $ this - > file Handle ) ) { flock ( $ this - > file Handle , LOCK _UN ) ; fclose ( $ this - > file Handle ) ; $ this - > file Handle = $ this - > file New = $ this - > session ID = null ; return true ; } return true ; } 
public function destroy ( $ session _id ) : bool { if ( $ this - > close ( ) ) { return is _file ( $ this - > file Path . $ session _id ) ? ( unlink ( $ this - > file Path . $ session _id ) & & $ this - > destroy Cookie ( ) ) : true ; } elseif ( $ this - > file Path ! = = null ) { clearstatcache ( ) ; return is _file ( $ this - > file Path . $ session _id ) ? ( unlink ( $ this - > file Path . $ session _id ) & & $ this - > destroy Cookie ( ) ) : true ; } return false ; } 
public function gc ( $ maxlifetime ) : bool { if ( ! is _dir ( $ this - > save Path ) | | ( $ directory = opendir ( $ this - > save Path ) ) = = = false ) { $ this - > logger - > debug ( "Session : Garbage collector couldn 't list files under directory ' " . $ this - > save Path . " ' . " ) ; return false ; } $ ts = time ( ) - $ maxlifetime ; $ pattern = $ this - > match IP = = = true ? ' [ 0 - 9a -f ] { 3 2 } ' : ' ' ; $ pattern = sprintf ( ' # \A %s ' . $ pattern . $ this - > session IDRegex . ' \z # ' , preg _quote ( $ this - > cookie Name ) ) ; while ( ( $ file = readdir ( $ directory ) ) ! = = false ) { 
protected function configure Session IDRegex ( ) { $ bits Per Character = ( int ) ini _get ( 'session .sid _bits _per _character ' ) ; $ SIDLength = ( int ) ini _get ( 'session .sid _length ' ) ; if ( ( $ bits = $ SIDLength * $ bits Per Character ) < 1 6 0 ) { 
public function set Status Code ( int $ code , string $ reason = ' ' ) { 
public function get Reason ( ) : string { if ( empty ( $ this - > reason ) ) { return ! empty ( $ this - > status Code ) ? static : : $ status Codes [ $ this - > status Code ] : ' ' ; } return $ this - > reason ; } 
public function set Link ( Pager Interface $ pager ) { $ links = ' ' ; if ( $ previous = $ pager - > get Previous Page URI ( ) ) { $ links . = ' < ' . $ pager - > get Page URI ( $ pager - > get First Page ( ) ) . ' > ; rel = "first " , ' ; $ links . = ' < ' . $ previous . ' > ; rel = "prev " ' ; } if ( ( $ next = $ pager - > get Next Page URI ( ) ) & & $ previous ) { $ links . = ' , ' ; } if ( $ next ) { $ links . = ' < ' . $ next . ' > ; rel = "next " , ' ; $ links . = ' < ' . $ pager - > get Page URI ( $ pager - > get Last Page ( ) ) . ' > ; rel = "last " ' ; } $ this - > set Header ( 'Link ' , $ links ) ; return $ this ; } 
public function set Content Type ( string $ mime , string $ charset = 'UTF - 8 ' ) { 
public function get JSON ( ) { $ body = $ this - > body ; if ( $ this - > body Format ! = = 'json ' ) { $ config = config ( Format : : class ) ; $ formatter = $ config - > get Formatter ( 'application /json ' ) ; $ body = $ formatter - > format ( $ body ) ; } return $ body ? : null ; } 
public function get XML ( ) { $ body = $ this - > body ; if ( $ this - > body Format ! = = 'xml ' ) { $ config = config ( Format : : class ) ; $ formatter = $ config - > get Formatter ( 'application /xml ' ) ; $ body = $ formatter - > format ( $ body ) ; } return $ body ; } 
protected function format Body ( $ body , string $ format ) { $ mime = "application / { $format } " ; $ this - > set Content Type ( $ mime ) ; $ this - > body Format = $ format ; * @var Format $config * / $ config = config ( Format : : class ) ; $ formatter = $ config - > get Formatter ( $ mime ) ; $ body = $ formatter - > format ( $ body ) ; } return $ body ; } 
public function set Cache ( array $ options = [ ] ) { if ( empty ( $ options ) ) { return $ this ; } $ this - > remove Header ( 'Cache -Control ' ) ; $ this - > remove Header ( 'ETag ' ) ; 
public function send ( ) { 
public function send Headers ( ) { 
public function redirect ( string $ uri , string $ method = 'auto ' , int $ code = null ) { 
public function set Cookie ( $ name , $ value = ' ' , $ expire = ' ' , $ domain = ' ' , $ path = ' / ' , $ prefix = ' ' , $ secure = false , $ httponly = false ) { if ( is _array ( $ name ) ) { 
public function has Cookie ( string $ name , string $ value = null , string $ prefix = ' ' ) : bool { if ( $ prefix = = = ' ' & & $ this - > cookie Prefix ! = = ' ' ) { $ prefix = $ this - > cookie Prefix ; } $ name = $ prefix . $ name ; foreach ( $ this - > cookies as $ cookie ) { if ( $ cookie [ 'name ' ] ! = = $ name ) { continue ; } if ( $ value = = = null ) { return true ; } return $ cookie [ 'value ' ] = = = $ value ; } return false ; } 
public function get Cookie ( string $ name = null , string $ prefix = ' ' ) { 
public function delete Cookie ( string $ name = ' ' , string $ domain = ' ' , string $ path = ' / ' , string $ prefix = ' ' ) { if ( empty ( $ name ) ) { return $ this ; } if ( $ prefix = = = ' ' & & $ this - > cookie Prefix ! = = ' ' ) { $ prefix = $ this - > cookie Prefix ; } $ name = $ prefix . $ name ; foreach ( $ this - > cookies as & $ cookie ) { if ( $ cookie [ 'name ' ] = = = $ name ) { if ( ! empty ( $ domain ) & & $ cookie [ 'domain ' ] ! = = $ domain ) { continue ; } if ( ! empty ( $ path ) & & $ cookie [ 'path ' ] ! = = $ path ) { continue ; } $ cookie [ 'value ' ] = ' ' ; $ cookie [ 'expires ' ] = ' ' ; break ; } } return $ this ; } 
protected function send Cookies ( ) { if ( $ this - > pretend ) { return ; } foreach ( $ this - > cookies as $ params ) { 
public function download ( string $ filename = ' ' , $ data = ' ' , bool $ set Mime = false ) { if ( $ filename = = = ' ' | | $ data = = = ' ' ) { return null ; } $ filepath = ' ' ; if ( $ data = = = null ) { $ filepath = $ filename ; $ filename = explode ( ' / ' , str _replace ( DIRECTORY _SEPARATOR , ' / ' , $ filename ) ) ; $ filename = end ( $ filename ) ; } $ response = new Download Response ( $ filename , $ set Mime ) ; if ( $ filepath ! = = ' ' ) { $ response - > set File Path ( $ filepath ) ; } elseif ( $ data ! = = null ) { $ response - > set Binary ( $ data ) ; } return $ response ; } 
public static function get ( string $ name , bool $ get Shared = true ) { $ class = $ name ; if ( ( $ pos = strrpos ( $ name , ' \ \ ' ) ) ! = = false ) { $ class = substr ( $ name , $ pos + 1 ) ; } if ( ! $ get Shared ) { return self : : create Class ( $ name ) ; } if ( ! isset ( self : : $ instances [ $ class ] ) ) { self : : $ instances [ $ class ] = self : : create Class ( $ name ) ; } return self : : $ instances [ $ class ] ; } 
private static function create Class ( string $ name ) { if ( class _exists ( $ name ) ) { return new $ name ( ) ; } $ locator = Services : : locator ( ) ; $ file = $ locator - > locate File ( $ name , 'Config ' ) ; if ( empty ( $ file ) ) { return null ; } $ name = $ locator - > get Classname ( $ file ) ; if ( empty ( $ name ) ) { return null ; } return new $ name ( ) ; } 
protected static function get Shared Instance ( string $ key , . . . $ params ) { 
public static function autoloader ( bool $ get Shared = true ) { if ( $ get Shared ) { if ( empty ( static : : $ instances [ 'autoloader ' ] ) ) { static : : $ instances [ 'autoloader ' ] = new Autoloader ( ) ; } return static : : $ instances [ 'autoloader ' ] ; } return new Autoloader ( ) ; } 
public static function locator ( bool $ get Shared = true ) { if ( $ get Shared ) { if ( empty ( static : : $ instances [ 'locator ' ] ) ) { static : : $ instances [ 'locator ' ] = new File Locator ( static : : autoloader ( ) ) ; } return static : : $ instances [ 'locator ' ] ; } return new File Locator ( static : : autoloader ( ) ) ; } 
public static function reset ( bool $ init _autoloader = false ) { static : : $ mocks = [ ] ; static : : $ instances = [ ] ; if ( $ init _autoloader ) { static : : autoloader ( ) - > initialize ( new Autoload ( ) , new Modules ( ) ) ; } } 
public static function inject Mock ( string $ name , $ mock ) { $ name = strtolower ( $ name ) ; static : : $ mocks [ $ name ] = $ mock ; } 
protected static function discover Services ( string $ name , array $ arguments ) { if ( ! static : : $ discovered ) { $ config = config ( 'Modules ' ) ; if ( $ config - > should Discover ( 'services ' ) ) { $ locator = static : : locator ( ) ; $ files = $ locator - > search ( 'Config /Services ' ) ; if ( empty ( $ files ) ) { 
public static function input ( string $ prefix = null ) : string { if ( static : : $ readline _support ) { return readline ( $ prefix ) ; } echo $ prefix ; return fgets ( STDIN ) ; } 
public static function prompt ( string $ field , $ options = null , string $ validation = null ) : string { $ extra _output = ' ' ; $ default = ' ' ; if ( is _string ( $ options ) ) { $ extra _output = ' [ ' . static : : color ( $ options , 'white ' ) . ' ] ' ; $ default = $ options ; } if ( is _array ( $ options ) & & $ options ) { $ opts = $ options ; $ extra _output _default = static : : color ( $ opts [ 0 ] , 'white ' ) ; unset ( $ opts [ 0 ] ) ; if ( empty ( $ opts ) ) { $ extra _output = $ extra _output _default ; } else { $ extra _output = ' [ ' . $ extra _output _default . ' , ' . implode ( ' , ' , $ opts ) . ' ] ' ; $ validation . = ' |in _list [ ' . implode ( ' , ' , $ options ) . ' ] ' ; $ validation = trim ( $ validation , ' | ' ) ; } $ default = $ options [ 0 ] ; } fwrite ( STDOUT , $ field . $ extra _output . ' : ' ) ; 
protected static function validate ( string $ field , string $ value , string $ rules ) : bool { $ validation = \ Config \ Services : : validation ( null , false ) ; $ validation - > set Rule ( $ field , null , $ rules ) ; $ validation - > run ( [ $ field = > $ value ] ) ; if ( $ validation - > has Error ( $ field ) ) { static : : error ( $ validation - > get Error ( $ field ) ) ; return false ; } return true ; } 
public static function print ( string $ text = ' ' , string $ foreground = null , string $ background = null ) { if ( $ foreground | | $ background ) { $ text = static : : color ( $ text , $ foreground , $ background ) ; } static : : $ last Write = null ; fwrite ( STDOUT , $ text ) ; } 
public static function error ( string $ text , string $ foreground = 'light _red ' , string $ background = null ) { if ( $ foreground | | $ background ) { $ text = static : : color ( $ text , $ foreground , $ background ) ; } fwrite ( STDERR , $ text . PHP _EOL ) ; } 
public static function wait ( int $ seconds , bool $ countdown = false ) { if ( $ countdown = = = true ) { $ time = $ seconds ; while ( $ time > 0 ) { fwrite ( STDOUT , $ time . ' . . . ' ) ; sleep ( 1 ) ; $ time - - ; } static : : write ( ) ; } else { if ( $ seconds > 0 ) { sleep ( $ seconds ) ; } else { 
public static function color ( string $ text , string $ foreground , string $ background = null , string $ format = null ) : string { if ( static : : is Windows ( ) & & ! isset ( $ _SERVER [ 'ANSICON ' ] ) ) { 
public static function strlen ( ? string $ string ) : int { if ( is _null ( $ string ) ) { return 0 ; } foreach ( static : : $ foreground _colors as $ color ) { $ string = strtr ( $ string , [ " \ 0 3 3 [ " . $ color . 'm ' = > ' ' ] ) ; } foreach ( static : : $ background _colors as $ color ) { $ string = strtr ( $ string , [ " \ 0 3 3 [ " . $ color . 'm ' = > ' ' ] ) ; } $ string = strtr ( $ string , [ " \ 0 3 3 [ 4m " = > ' ' , " \ 0 3 3 [ 0m " = > ' ' ] ) ; return mb _strlen ( $ string ) ; } 
public static function show Progress ( $ this Step = 1 , int $ total Steps = 1 0 ) { static $ in Progress = false ; 
public static function wrap ( string $ string = null , int $ max = 0 , int $ pad _left = 0 ) : string { if ( empty ( $ string ) ) { return ' ' ; } if ( $ max = = = 0 ) { $ max = CLI : : get Width ( ) ; } if ( CLI : : get Width ( ) < $ max ) { $ max = CLI : : get Width ( ) ; } $ max = $ max - $ pad _left ; $ lines = wordwrap ( $ string , $ max ) ; if ( $ pad _left > 0 ) { $ lines = explode ( PHP _EOL , $ lines ) ; $ first = true ; array _walk ( $ lines , function ( & $ line , $ index ) use ( $ pad _left , & $ first ) { if ( ! $ first ) { $ line = str _repeat ( ' ' , $ pad _left ) . $ line ; } else { $ first = false ; } } ) ; $ lines = implode ( PHP _EOL , $ lines ) ; } return $ lines ; } 
protected static function parse Command Line ( ) { $ options Found = false ; 
public static function get Option ( string $ name ) { if ( ! array _key _exists ( $ name , static : : $ options ) ) { return null ; } 
public static function get Option String ( ) : string { if ( empty ( static : : $ options ) ) { return ' ' ; } $ out = ' ' ; foreach ( static : : $ options as $ name = > $ value ) { 
public static function table ( array $ tbody , array $ thead = [ ] ) { 
public function respond ( $ data = null , int $ status = null , string $ message = ' ' ) { 
public function fail ( $ messages , int $ status = 4 0 0 , string $ code = null , string $ custom Message = ' ' ) { if ( ! is _array ( $ messages ) ) { $ messages = [ 'error ' = > $ messages ] ; } $ response = [ 'status ' = > $ status , 'error ' = > $ code = = = null ? $ status : $ code , 'messages ' = > $ messages , ] ; return $ this - > respond ( $ response , $ status , $ custom Message ) ; } 
public function respond Created ( $ data = null , string $ message = ' ' ) { return $ this - > respond ( $ data , $ this - > codes [ 'created ' ] , $ message ) ; } 
public function respond Deleted ( $ data = null , string $ message = ' ' ) { return $ this - > respond ( $ data , $ this - > codes [ 'deleted ' ] , $ message ) ; } 
public function fail Unauthorized ( string $ description = 'Unauthorized ' , string $ code = null , string $ message = ' ' ) { return $ this - > fail ( $ description , $ this - > codes [ 'unauthorized ' ] , $ code , $ message ) ; } 
public function fail Server Error ( string $ description = 'Internal Server Error ' , string $ code = null , string $ message = ' ' ) : Response { return $ this - > fail ( $ description , $ this - > codes [ 'server _error ' ] , $ code , $ message ) ; } 
protected function format ( $ data = null ) { 
public function before ( Request Interface $ request ) { if ( $ request - > is CLI ( ) ) { return ; } $ security = Services : : security ( ) ; try { $ security - > CSRFVerify ( $ request ) ; } catch ( Security Exception $ e ) { if ( config ( 'App ' ) - > CSRFRedirect & & ! $ request - > is AJAX ( ) ) { return redirect ( ) - > back ( ) - > with ( 'error ' , $ e - > get Message ( ) ) ; } throw $ e ; } } 
public static function initialize ( ) { 
public static function on ( $ event _name , $ callback , $ priority = EVENT _PRIORITY _NORMAL ) { if ( ! isset ( static : : $ listeners [ $ event _name ] ) ) { static : : $ listeners [ $ event _name ] = [ true , 
public static function trigger ( $ event Name , . . . $ arguments ) : bool { 
public static function listeners ( $ event _name ) : array { if ( ! isset ( static : : $ listeners [ $ event _name ] ) ) { return [ ] ; } 
public static function remove Listener ( $ event _name , callable $ listener ) : bool { if ( ! isset ( static : : $ listeners [ $ event _name ] ) ) { return false ; } foreach ( static : : $ listeners [ $ event _name ] [ 2 ] as $ index = > $ check ) { if ( $ check = = = $ listener ) { unset ( static : : $ listeners [ $ event _name ] [ 1 ] [ $ index ] ) ; unset ( static : : $ listeners [ $ event _name ] [ 2 ] [ $ index ] ) ; return true ; } } return false ; } 
public function is Browser ( string $ key = null ) : bool { if ( ! $ this - > is Browser ) { return false ; } 
public function is Robot ( string $ key = null ) : bool { if ( ! $ this - > is Robot ) { return false ; } 
public function is Mobile ( string $ key = null ) : bool { if ( ! $ this - > is Mobile ) { return false ; } 
public function is Referral ( ) : bool { if ( ! isset ( $ this - > referrer ) ) { if ( empty ( $ _SERVER [ 'HTTP _REFERER ' ] ) ) { $ this - > referrer = false ; } else { $ referer _host = @ parse _url ( $ _SERVER [ 'HTTP _REFERER ' ] , PHP _URL _HOST ) ; $ own _host = parse _url ( \ base _url ( ) , PHP _URL _HOST ) ; $ this - > referrer = ( $ referer _host & & $ referer _host ! = = $ own _host ) ; } } return $ this - > referrer ; } 
protected function set Platform ( ) : bool { if ( is _array ( $ this - > config - > platforms ) & & $ this - > config - > platforms ) { foreach ( $ this - > config - > platforms as $ key = > $ val ) { if ( preg _match ( ' | ' . preg _quote ( $ key ) . ' |i ' , $ this - > agent ) ) { $ this - > platform = $ val ; return true ; } } } $ this - > platform = 'Unknown Platform ' ; return false ; } 
protected function set Browser ( ) : bool { if ( is _array ( $ this - > config - > browsers ) & & $ this - > config - > browsers ) { foreach ( $ this - > config - > browsers as $ key = > $ val ) { if ( preg _match ( ' | ' . $ key . ' . * ? ( [ 0 - 9 \ . ] + ) |i ' , $ this - > agent , $ match ) ) { $ this - > is Browser = true ; $ this - > version = $ match [ 1 ] ; $ this - > browser = $ val ; $ this - > set Mobile ( ) ; return true ; } } } return false ; } 
protected function set Robot ( ) : bool { if ( is _array ( $ this - > config - > robots ) & & $ this - > config - > robots ) { foreach ( $ this - > config - > robots as $ key = > $ val ) { if ( preg _match ( ' | ' . preg _quote ( $ key ) . ' |i ' , $ this - > agent ) ) { $ this - > is Robot = true ; $ this - > robot = $ val ; $ this - > set Mobile ( ) ; return true ; } } } return false ; } 
protected function set Mobile ( ) : bool { if ( is _array ( $ this - > config - > mobiles ) & & $ this - > config - > mobiles ) { foreach ( $ this - > config - > mobiles as $ key = > $ val ) { if ( false ! = = ( stripos ( $ this - > agent , $ key ) ) ) { $ this - > is Mobile = true ; $ this - > mobile = $ val ; return true ; } } } return false ; } 
protected function _alter Table ( string $ alter _type , string $ table , $ field ) { if ( in _array ( $ alter _type , [ 'DROP ' , 'ADD ' ] , true ) ) { return parent : : _alter Table ( $ alter _type , $ table , $ field ) ; } $ sql = 'ALTER TABLE ' . $ this - > db - > escape Identifiers ( $ table ) ; $ sqls = [ ] ; foreach ( $ field as $ data ) { if ( $ data [ ' _literal ' ] ! = = false ) { return false ; } if ( version _compare ( $ this - > db - > get Version ( ) , ' 8 ' , ' > = ' ) & & isset ( $ data [ 'type ' ] ) ) { $ sqls [ ] = $ sql . ' ALTER COLUMN ' . $ this - > db - > escape Identifiers ( $ data [ 'name ' ] ) . " TYPE { $data [ 'type ' ] } { $data [ 'length ' ] } " ; } if ( ! empty ( $ data [ 'default ' ] ) ) { $ sqls [ ] = $ sql . ' ALTER COLUMN ' . $ this - > db - > escape Identifiers ( $ data [ 'name ' ] ) . " SET DEFAULT { $data [ 'default ' ] } " ; } if ( isset ( $ data [ 'null ' ] ) ) { $ sqls [ ] = $ sql . ' ALTER COLUMN ' . $ this - > db - > escape Identifiers ( $ data [ 'name ' ] ) . ( $ data [ 'null ' ] = = = true ? ' DROP ' : ' SET ' ) . ' NOT NULL ' ; } if ( ! empty ( $ data [ 'new _name ' ] ) ) { $ sqls [ ] = $ sql . ' RENAME COLUMN ' . $ this - > db - > escape Identifiers ( $ data [ 'name ' ] ) . ' TO ' . $ this - > db - > escape Identifiers ( $ data [ 'new _name ' ] ) ; } if ( ! empty ( $ data [ 'comment ' ] ) ) { $ sqls [ ] = 'COMMENT ON COLUMN ' . $ this - > db - > escape Identifiers ( $ table ) . ' . ' . $ this - > db - > escape Identifiers ( $ data [ 'name ' ] ) . " IS { $data [ 'comment ' ] } " ; } } return $ sqls ; } 
protected function _process Column ( array $ field ) : string { return $ this - > db - > escape Identifiers ( $ field [ 'name ' ] ) . ' ' . $ field [ 'type ' ] . $ field [ 'length ' ] . $ field [ 'default ' ] . $ field [ 'null ' ] . $ field [ 'auto _increment ' ] . $ field [ 'unique ' ] ; } 
protected function _attribute Type ( array & $ attributes ) { 
protected function _drop Table ( string $ table , bool $ if _exists , bool $ cascade ) : string { $ sql = parent : : _drop Table ( $ table , $ if _exists , $ cascade ) ; if ( $ cascade = = = true ) { $ sql . = ' CASCADE ' ; } return $ sql ; } 
public function format ( $ data ) { $ options = JSON _UNESCAPED _UNICODE | JSON _UNESCAPED _SLASHES ; $ options = ENVIRONMENT = = = 'production ' ? $ options : $ options | JSON _PRETTY _PRINT ; $ result = json _encode ( $ data , $ options , 5 1 2 ) ; if ( json _last _error ( ) ! = = JSON _ERROR _NONE ) { throw Format Exception : : for Invalid JSON ( json _last _error _msg ( ) ) ; } return $ result ; } 
public function auto Typography ( string $ str , bool $ reduce _linebreaks = false ) : string { if ( $ str = = = ' ' ) { return ' ' ; } * * [array ] * { * [ 0 ] = <opening tag > * [ 1 ] = Content . . . * [ 2 ] = <closing tag > * Etc . . . * } * / $ chunks = preg _split ( ' / ( < ( ? : [ ^ < > ] + ( ? : " [ ^ " ] * " | \ ' [ ^ \ ' ] * \ ' ) ? ) + > ) / ' , $ str , - 1 , PREG _SPLIT _DELIM _CAPTURE | PREG _SPLIT _NO _EMPTY ) ; / / Build our finalized string . We cycle through the array , skipping tags , and processing the contained text $ str = ' ' ; $ process = true ; for ( $ i = 0 , $ c = count ( $ chunks ) - 1 ; $ i < = $ c ; $ i + + ) { / / Are we dealing with a tag ? If so , we 'll skip the processing for this cycle . 
public function format Characters ( string $ str ) : string { static $ table ; if ( ! isset ( $ table ) ) { $ table = [ 
protected function format New Lines ( string $ str ) : string { if ( $ str = = = ' ' | | ( strpos ( $ str , " \n " ) = = = false & & ! in _array ( $ this - > last Block Element , $ this - > inner Block Required ) ) ) { return $ str ; } 
public function make ( $ msg ) { switch ( $ msg [ 'Msg Type ' ] ) { case 1 : 
public function init ( ) { $ this - > config = vbot ( 'config ' ) - > get ( 'extension . ' . $ this - > name ) ; $ this - > admin ( ) ; $ this - > register ( ) ; return $ this ; } 
final public function message Handler ( Collection $ collection ) { if ( $ collection [ 'type ' ] = = = 'text ' & & $ this - > is Admin ( $ collection [ 'username ' ] ) ) { if ( starts _with ( $ collection [ 'content ' ] , $ this - > name . ' ' ) ) { $ content = str _replace ( $ this - > name . ' ' , ' ' , $ collection [ 'content ' ] ) ; switch ( $ content ) { case 'info ' : $ this - > application Info ( $ collection ) ; break ; case 'on ' : $ this - > set Status ( true , $ collection ) ; break ; case 'off ' : $ this - > set Status ( false , $ collection ) ; break ; default : break ; } } } if ( ! $ this - > status ) { return false ; } return $ this - > handler ( $ collection ) ; } 
final public function set Status ( bool $ boolean , $ collection ) { $ this - > status = $ boolean ; $ status = $ this - > status ? ' 开 ' : ' ' ; Text : : send ( $ collection [ 'from ' ] [ 'User Name ' ] , " 应 用 ： { $this - >zh Name } 状 态 已 更 改 为 ： { $status } " ) ; } 
final public function admin ( ) { $ remark = vbot ( 'config ' ) - > get ( 'extension .admin .remark ' ) ; if ( $ remark ) { static : : $ admin = vbot ( 'friends ' ) - > get Username By Remark Name ( $ remark ) ; } if ( ! $ remark & & ( $ nickname = vbot ( 'config ' ) - > get ( 'extension .admin .nickname ' ) ) ) { static : : $ admin = vbot ( 'friends ' ) - > get Username By Nickname ( $ nickname ) ; } } 
public function request ( $ url , $ method = 'GET ' , $ options = [ ] , $ retry = false ) { try { $ options = array _merge ( [ 'timeout ' = > 1 0 , 'verify ' = > false ] , $ options ) ; $ response = $ this - > get Client ( ) - > request ( $ method , $ url , $ options ) ; $ this - > cookie Jar - > save ( $ this - > vbot - > config [ 'cookie _file ' ] ) ; return $ response - > get Body ( ) - > get Contents ( ) ; } catch ( \ Exception $ e ) { $ this - > vbot - > console - > log ( $ url . $ e - > get Message ( ) , Console : : ERROR , true ) ; if ( ! $ retry ) { return $ this - > request ( $ url , $ method , $ options , true ) ; } return false ; } } 
private function initialize Config ( ) { if ( ! is _dir ( $ this - > vbot - > config [ 'path ' ] ) ) { mkdir ( $ this - > vbot - > config [ 'path ' ] , 0 7 5 5 , true ) ; } $ this - > vbot - > config [ 'storage ' ] = $ this - > vbot - > config [ 'storage ' ] ? : 'collection ' ; $ this - > vbot - > config [ 'path ' ] = realpath ( $ this - > vbot - > config [ 'path ' ] ) ; } 
public function show ( $ text ) { if ( ! array _get ( $ this - > config , 'qrcode ' , true ) ) { return false ; } $ output = new Console Output ( ) ; static : : init Qrcode Style ( $ output ) ; $ px Map [ 0 ] = Console : : is Win ( ) ? ' <whitec >mm < /whitec > ' : ' <whitec > < /whitec > ' ; $ px Map [ 1 ] = ' <blackc > < /blackc > ' ; $ text = Qr Code Console : : text ( $ text ) ; $ length = strlen ( $ text [ 0 ] ) ; $ output - > write ( " \n " ) ; foreach ( $ text as $ line ) { $ output - > write ( $ px Map [ 0 ] ) ; for ( $ i = 0 ; $ i < $ length ; $ i + + ) { $ type = substr ( $ line , $ i , 1 ) ; $ output - > write ( $ px Map [ $ type ] ) ; } $ output - > writeln ( $ px Map [ 0 ] ) ; } } 
private static function init Qrcode Style ( Output Interface $ output ) { $ style = new Output Formatter Style ( 'black ' , 'black ' , [ 'bold ' ] ) ; $ output - > get Formatter ( ) - > set Style ( 'blackc ' , $ style ) ; $ style = new Output Formatter Style ( 'white ' , 'white ' , [ 'bold ' ] ) ; $ output - > get Formatter ( ) - > set Style ( 'whitec ' , $ style ) ; } 
public function get Username ( $ search , $ key , $ blur = false ) { return $ this - > search ( function ( $ item ) use ( $ search , $ key , $ blur ) { if ( ! isset ( $ item [ $ key ] ) ) { return false ; } if ( $ blur & & str _contains ( $ item [ $ key ] , $ search ) ) { return true ; } elseif ( ! $ blur & & $ item [ $ key ] = = = $ search ) { return true ; } return false ; } ) ; } 
public function get Object ( $ search , $ key , $ blur = false ) { $ username = $ this - > get Username ( $ search , $ key , $ blur ) ; return $ username ? $ this - > get ( $ username ) : null ; } 
public function get Account ( $ username ) { if ( starts _with ( $ username , ' @ @ ' ) ) { return $ this - > vbot - > groups - > get ( $ username ) ; } else { $ account = $ this - > vbot - > friends - > get ( $ username , null ) ; $ account = $ account ? : $ this - > vbot - > members - > get ( $ username , null ) ; $ account = $ account ? : $ this - > vbot - > officials - > get ( $ username , null ) ; return $ account ? : $ this - > vbot - > specials - > get ( $ username , null ) ; } } 
public function put ( $ key , $ value ) { $ value = $ this - > format ( $ value ) ; return parent : : put ( $ key , $ value ) ; } 
public function format ( $ contact ) { if ( isset ( $ contact [ 'Display Name ' ] ) ) { $ contact [ 'Display Name ' ] = Content : : emoji Handle ( $ contact [ 'Display Name ' ] ) ; } if ( isset ( $ contact [ 'Remark Name ' ] ) ) { $ contact [ 'Remark Name ' ] = Content : : emoji Handle ( $ contact [ 'Remark Name ' ] ) ; } if ( isset ( $ contact [ 'Signature ' ] ) ) { $ contact [ 'Signature ' ] = Content : : emoji Handle ( $ contact [ 'Signature ' ] ) ; } $ contact [ 'Nick Name ' ] = Content : : emoji Handle ( $ contact [ 'Nick Name ' ] ) ; return $ contact ; } 
public function update ( $ username , $ list ) : array { $ usernames = is _string ( $ username ) ? [ $ username ] : $ username ; $ url = $ this - > vbot - > config [ 'server .uri .base ' ] . ' /webwxbatchgetcontact ?type =ex &r = ' . time ( ) ; $ data = [ 'Base Request ' = > $ this - > vbot - > config [ 'server .base Request ' ] , 'Count ' = > count ( $ usernames ) , 'List ' = > $ list , ] ; $ response = $ this - > vbot - > http - > json ( $ url , $ data , true ) ; if ( ! $ response ) { return [ ] ; } foreach ( $ response [ 'Contact List ' ] as $ item ) { $ this - > put ( $ item [ 'User Name ' ] , $ item ) ; } return is _string ( $ username ) ? head ( $ response [ 'Contact List ' ] ) : $ response [ 'Contact List ' ] ; } 
public static function format Content ( $ content ) { $ content = self : : emoji Handle ( $ content ) ; $ content = self : : replace Br ( $ content ) ; return self : : html Decode ( $ content ) ; } 
public static function emoji Handle ( string $ content ) { 
private function heartbeat ( $ time ) { if ( time ( ) - $ time > 1 8 0 0 ) { Text : : send ( 'filehelper ' , 'heart beat ' . Carbon : : now ( ) - > to Date Time String ( ) ) ; return time ( ) ; } return $ time ; } 
public function handle Check Sync ( $ ret Code , $ selector , $ test = false ) { if ( in _array ( $ ret Code , [ 1 1 0 0 , 1 1 0 1 , 1 1 0 2 , 1 2 0 5 ] ) ) { 
private function handle Message ( $ selector ) { if ( $ selector = = 0 ) { return ; } $ message = $ this - > vbot - > sync - > sync ( ) ; $ this - > log ( $ message ) ; $ this - > store Contacts From Message ( $ message ) ; if ( $ message [ 'Add Msg List ' ] ) { foreach ( $ message [ 'Add Msg List ' ] as $ msg ) { $ collection = $ this - > vbot - > message Factory - > make ( $ msg ) ; if ( $ collection ) { $ this - > cache ( $ msg , $ collection ) ; $ this - > console ( $ collection ) ; if ( ! $ this - > vbot - > message Extension - > exec ( $ collection ) & & $ this - > handler ) { call _user _func _array ( $ this - > handler , [ $ collection ] ) ; } } } } } 
private function log ( $ message ) { if ( $ this - > vbot - > message Log & & ( $ message [ 'Mod Contact List ' ] | | $ message [ 'Add Msg List ' ] ) ) { $ this - > vbot - > message Log - > info ( json _encode ( $ message ) ) ; } } 
private function try Login ( ) : bool { if ( is _file ( $ this - > vbot - > config [ 'cookie _file ' ] ) & & $ this - > vbot - > cache - > has ( $ this - > vbot - > config [ 'session _key ' ] ) ) { $ configs = json _decode ( $ this - > vbot - > cache - > get ( $ this - > vbot - > config [ 'session _key ' ] ) , true ) ; $ this - > vbot - > config [ 'server ' ] = $ configs ; $ this - > vbot - > config [ 'server .time ' ] = $ this - > vbot - > config [ 'server .time ' ] ? : Carbon : : now ( ) - > to Date Time String ( ) ; if ( ! ( $ check Sync = $ this - > vbot - > sync - > check Sync ( ) ) ) { return false ; } $ result = $ this - > vbot - > message Handler - > handle Check Sync ( $ check Sync [ 0 ] , $ check Sync [ 1 ] , true ) ; if ( $ result ) { $ this - > vbot - > re Login Success Observer - > trigger ( ) ; return true ; } } $ this - > vbot - > config [ 'server .time ' ] = Carbon : : now ( ) - > to Date Time String ( ) ; return false ; } 
protected function get Uuid ( ) { $ content = $ this - > vbot - > http - > get ( 'https : / /login .weixin .qq .com /jslogin ' , [ 'query ' = > [ 'appid ' = > 'wx 7 8 2c 2 6e 4c 1 9acffb ' , 'fun ' = > 'new ' , 'lang ' = > 'zh _CN ' , ' _ ' = > time ( ) , ] ] ) ; preg _match ( ' /window .QRLogin .code = ( \d + ) ; window .QRLogin .uuid = \ " ( \S + ? ) \ " / ' , $ content , $ matches ) ; if ( ! $ matches ) { throw new Fetch Uuid Exception ( 'fetch uuid failed . ' ) ; } $ this - > vbot - > config [ 'server .uuid ' ] = $ matches [ 2 ] ; } 
public function show Qr Code ( ) { $ url = 'https : / /login .weixin .qq .com /l / ' . $ this - > vbot - > config [ 'server .uuid ' ] ; $ this - > vbot - > qr Code Observer - > trigger ( $ url ) ; $ this - > vbot - > qr Code - > show ( $ url ) ; } 
protected function wait For Login ( ) { $ retry Time = 1 0 ; $ tip = 1 ; $ this - > vbot - > console - > log ( 'please scan the qr Code with wechat . ' ) ; while ( $ retry Time > 0 ) { $ url = sprintf ( 'https : / /login .weixin .qq .com /cgi -bin /mmwebwx -bin /login ?tip = %s &uuid = %s & _ = %s ' , $ tip , $ this - > vbot - > config [ 'server .uuid ' ] , time ( ) ) ; $ content = $ this - > vbot - > http - > get ( $ url , [ 'timeout ' = > 3 5 ] ) ; preg _match ( ' /window .code = ( \d + ) ; / ' , $ content , $ matches ) ; $ code = $ matches [ 1 ] ; switch ( $ code ) { case ' 2 0 1 ' : $ this - > vbot - > console - > log ( 'please confirm login in wechat . ' ) ; $ tip = 0 ; break ; case ' 2 0 0 ' : preg _match ( ' /window .redirect _uri = " (https : \ / \ / ( \S + ? ) \ / \S + ? ) " ; / ' , $ content , $ matches ) ; $ this - > vbot - > config [ 'server .uri .redirect ' ] = $ matches [ 1 ] . ' &fun =new ' ; $ url = 'https : / / %s /cgi -bin /mmwebwx -bin ' ; $ this - > vbot - > config [ 'server .uri .file ' ] = sprintf ( $ url , 'file . ' . $ matches [ 2 ] ) ; $ this - > vbot - > config [ 'server .uri .push ' ] = sprintf ( $ url , 'webpush . ' . $ matches [ 2 ] ) ; $ this - > vbot - > config [ 'server .uri .base ' ] = sprintf ( $ url , $ matches [ 2 ] ) ; return ; case ' 4 0 8 ' : $ tip = 1 ; $ retry Time - = 1 ; sleep ( 1 ) ; break ; default : $ tip = 1 ; $ retry Time - = 1 ; sleep ( 1 ) ; break ; } } $ this - > vbot - > console - > log ( 'login time out ! ' , Console : : ERROR ) ; throw new Login Timeout Exception ( 'Login time out . ' ) ; } 
private function get Login ( ) { $ content = $ this - > vbot - > http - > get ( $ this - > vbot - > config [ 'server .uri .redirect ' ] ) ; $ data = ( array ) simplexml _load _string ( $ content , 'Simple XMLElement ' , LIBXML _NOCDATA ) ; $ this - > vbot - > config [ 'server .skey ' ] = $ data [ 'skey ' ] ; $ this - > vbot - > config [ 'server .sid ' ] = $ data [ 'wxsid ' ] ; $ this - > vbot - > config [ 'server .uin ' ] = $ data [ 'wxuin ' ] ; $ this - > vbot - > config [ 'server .pass Ticket ' ] = $ data [ 'pass _ticket ' ] ; if ( in _array ( ' ' , [ $ data [ 'wxsid ' ] , $ data [ 'wxuin ' ] , $ data [ 'pass _ticket ' ] ] ) ) { throw new Login Failed Exception ( 'Login failed . ' ) ; } $ this - > vbot - > config [ 'server .device Id ' ] = 'e ' . substr ( mt _rand ( ) . mt _rand ( ) , 1 , 1 5 ) ; $ this - > vbot - > config [ 'server .base Request ' ] = [ 'Uin ' = > $ data [ 'wxuin ' ] , 'Sid ' = > $ data [ 'wxsid ' ] , 'Skey ' = > $ data [ 'skey ' ] , 'Device ID ' = > $ this - > vbot - > config [ 'server .device Id ' ] , ] ; $ this - > save Server ( ) ; } 
private function save Server ( ) { $ this - > vbot - > cache - > forever ( 'session . ' . $ this - > vbot - > config [ 'session ' ] , json _encode ( $ this - > vbot - > config [ 'server ' ] ) ) ; } 
protected function init ( $ first = true ) { $ this - > before Init Success ( ) ; $ url = $ this - > vbot - > config [ 'server .uri .base ' ] . ' /webwxinit ?r = ' . time ( ) ; $ result = $ this - > vbot - > http - > json ( $ url , [ 'Base Request ' = > $ this - > vbot - > config [ 'server .base Request ' ] , ] , true ) ; $ this - > generate Sync Key ( $ result , $ first ) ; $ this - > vbot - > myself - > init ( $ result [ 'User ' ] ) ; Api Exception Handler : : handle ( $ result , function ( $ result ) { $ this - > vbot - > cache - > forget ( 'session . ' . $ this - > vbot - > config [ 'session ' ] ) ; $ this - > vbot - > log - > error ( 'Init failed . ' . json _encode ( $ result ) ) ; throw new Init Fail Exception ( 'Init failed . ' ) ; } ) ; $ this - > after Init Success ( $ result ) ; $ this - > init Contact List ( $ result [ 'Contact List ' ] ) ; $ this - > init Contact ( ) ; } 
private function before Init Success ( ) { $ this - > vbot - > console - > log ( 'current session : ' . $ this - > vbot - > config [ 'session ' ] ) ; $ this - > vbot - > console - > log ( 'init begin . ' ) ; } 
private function after Init Success ( $ content ) { $ this - > vbot - > log - > info ( 'response : ' . json _encode ( $ content ) ) ; $ this - > vbot - > console - > log ( 'init success . ' ) ; $ this - > vbot - > login Success Observer - > trigger ( ) ; $ this - > vbot - > console - > log ( 'init contacts begin . ' ) ; } 
protected function status Notify ( ) { $ url = sprintf ( $ this - > vbot - > config [ 'server .uri .base ' ] . ' /webwxstatusnotify ?lang =zh _CN &pass _ticket = %s ' , $ this - > vbot - > config [ 'server .pass Ticket ' ] ) ; $ this - > vbot - > http - > json ( $ url , [ 'Base Request ' = > $ this - > vbot - > config [ 'server .base Request ' ] , 'Code ' = > 3 , 'From User Name ' = > $ this - > vbot - > myself - > username , 'To User Name ' = > $ this - > vbot - > myself - > username , 'Client Msg Id ' = > time ( ) , ] ) ; } 
public static function download ( $ message , $ callback = null ) { if ( ! $ callback ) { static : : auto Download ( $ message [ 'raw ' ] , true ) ; return true ; } if ( $ callback & & ! is _callable ( $ callback ) ) { throw new Argument Exception ( ) ; } call _user _func _array ( $ callback , [ static : : get Resource ( $ message [ 'raw ' ] ) ] ) ; return true ; } 
private static function get Resource ( $ message ) { $ url = static : : get Download Url ( $ message ) ; $ content = vbot ( 'http ' ) - > get ( $ url , static : : get Download Option ( $ message ) ) ; if ( ! $ content ) { vbot ( 'console ' ) - > log ( 'download file failed . ' , Console : : WARNING ) ; } else { return $ content ; } } 
protected static function auto Download ( $ message , $ force = false ) { $ is Download = vbot ( 'config ' ) [ 'download . ' . static : : TYPE ] ; if ( $ is Download | | $ force ) { $ resource = static : : get Resource ( $ message ) ; if ( $ resource ) { File : : save To ( vbot ( 'config ' ) [ 'user _path ' ] . static : : TYPE . DIRECTORY _SEPARATOR . static : : file Name ( $ message ) , $ resource ) ; } } } 
public static function upload Media ( $ username , $ file ) { if ( ! is _file ( $ file ) ) { return false ; } $ url = vbot ( 'config ' ) [ 'server .uri .file ' ] . ' /webwxuploadmedia ?f =json ' ; static : : $ file = $ file ; list ( $ mime , $ media Type ) = static : : get Media Type ( $ file ) ; $ data = [ 'id ' = > 'WU _FILE _ 0 ' , 'name ' = > basename ( $ file ) , 'type ' = > $ mime , 'last Modifie Date ' = > gmdate ( 'D M d Y H :i :s TO ' , filemtime ( $ file ) ) . ' (CST ) ' , 'size ' = > filesize ( $ file ) , 'mediatype ' = > $ media Type , 'uploadmediarequest ' = > json _encode ( [ 'Base Request ' = > vbot ( 'config ' ) [ 'server .base Request ' ] , 'Client Media Id ' = > time ( ) , 'Total Len ' = > filesize ( $ file ) , 'Start Pos ' = > 0 , 'Data Len ' = > filesize ( $ file ) , 'Media Type ' = > 4 , 'Upload Type ' = > 2 , 'From User Name ' = > vbot ( 'myself ' ) - > username , 'To User Name ' = > $ username , 'File Md 5 ' = > md 5 _file ( $ file ) , ] , JSON _UNESCAPED _UNICODE | JSON _UNESCAPED _SLASHES ) , 'webwx _data _ticket ' = > static : : get Ticket ( ) , 'pass _ticket ' = > vbot ( 'config ' ) [ 'server .pass Ticket ' ] , 'filename ' = > fopen ( $ file , 'r ' ) , ] ; $ data = static : : data To Multipart ( $ data ) ; $ result = vbot ( 'http ' ) - > request ( $ url , 'post ' , [ 'multipart ' = > $ data , ] ) ; $ result = json _decode ( $ result , true ) ; return Api Exception Handler : : handle ( $ result ) ; } 
private static function get Media Type ( $ file ) { $ info = finfo _open ( FILEINFO _MIME _TYPE ) ; $ mime = finfo _file ( $ info , $ file ) ; finfo _close ( $ info ) ; $ file Explode = explode ( ' . ' , $ file ) ; $ file Extension = end ( $ file Explode ) ; return [ $ mime , $ file Extension = = = 'jpg ' ? 'pic ' : ( $ file Extension = = = 'mp 4 ' ? 'video ' : 'doc ' ) ] ; } 
private static function get Ticket ( ) { $ cookies = vbot ( 'http ' ) - > get Client ( ) - > get Config ( 'cookies ' ) - > to Array ( ) ; $ key = array _search ( 'webwx _data _ticket ' , array _column ( $ cookies , 'Name ' ) ) ; return $ cookies [ $ key ] [ 'Value ' ] ; } 
private static function data To Multipart ( $ data ) { $ result = [ ] ; foreach ( $ data as $ key = > $ item ) { $ field = [ 'name ' = > $ key , 'contents ' = > $ item , ] ; if ( $ key = = = 'filename ' ) { $ field [ 'filename ' ] = basename ( static : : $ file ) ; } $ result [ ] = $ field ; } return $ result ; } 
public function bootstrap ( Vbot $ app ) { $ this - > app = $ app ; error _reporting ( - 1 ) ; set _error _handler ( [ $ this , 'handle Error ' ] ) ; set _exception _handler ( [ $ this , 'handle Exception ' ] ) ; register _shutdown _function ( [ $ this , 'handle Shutdown ' ] ) ; } 
public function check Sync ( ) { $ content = $ this - > vbot - > http - > get ( $ this - > vbot - > config [ 'server .uri .push ' ] . ' /synccheck ' , [ 'timeout ' = > 3 5 , 'query ' = > [ 'r ' = > time ( ) , 'sid ' = > $ this - > vbot - > config [ 'server .sid ' ] , 'uin ' = > $ this - > vbot - > config [ 'server .uin ' ] , 'skey ' = > $ this - > vbot - > config [ 'server .skey ' ] , 'deviceid ' = > $ this - > vbot - > config [ 'server .device Id ' ] , 'synckey ' = > $ this - > vbot - > config [ 'server .sync Key Str ' ] , ' _ ' = > time ( ) , ] ] ) ; if ( ! $ content ) { $ this - > vbot - > console - > log ( 'check Sync no response ' ) ; return false ; } return preg _match ( ' /window .synccheck = \ {retcode : " ( \d + ) " ,selector : " ( \d + ) " \ } / ' , $ content , $ matches ) ? [ $ matches [ 1 ] , $ matches [ 2 ] ] : false ; } 
public function sync ( ) { $ url = sprintf ( $ this - > vbot - > config [ 'server .uri .base ' ] . ' /webwxsync ?sid = %s &skey = %s &lang =zh _CN &pass _ticket = %s ' , $ this - > vbot - > config [ 'server .sid ' ] , $ this - > vbot - > config [ 'server .skey ' ] , $ this - > vbot - > config [ 'server .pass Ticket ' ] ) ; $ result = $ this - > vbot - > http - > json ( $ url , [ 'Base Request ' = > $ this - > vbot - > config [ 'server .base Request ' ] , 'Sync Key ' = > $ this - > vbot - > config [ 'server .sync Key ' ] , 'rr ' = > ~ time ( ) , ] , true ) ; if ( $ result & & $ result [ 'Base Response ' ] [ 'Ret ' ] = = 0 ) { $ this - > generate Sync Key ( $ result ) ; } return $ result ; } 
public function generate Sync Key ( $ result ) { $ this - > vbot - > config [ 'server .sync Key ' ] = $ result [ 'Sync Key ' ] ; $ sync Key = [ ] ; if ( is _array ( $ this - > vbot - > config [ 'server .sync Key .List ' ] ) ) { foreach ( $ this - > vbot - > config [ 'server .sync Key .List ' ] as $ item ) { $ sync Key [ ] = $ item [ 'Key ' ] . ' _ ' . $ item [ 'Val ' ] ; } } $ this - > vbot - > config [ 'server .sync Key Str ' ] = implode ( ' | ' , $ sync Key ) ; } 
public function log ( $ str , $ level = 'INFO ' , $ log = false ) { if ( $ this - > is Output ( ) ) { if ( $ log & & in _array ( $ level , array _keys ( Logger : : get Levels ( ) ) ) ) { $ this - > vbot - > log - > log ( $ level , $ str ) ; } echo ' [ ' . Carbon : : now ( ) - > to Date Time String ( ) . ' ] ' . " [ { $level } ] " . $ str . PHP _EOL ; } } 
public function message ( $ str ) { if ( array _get ( $ this - > config , 'message ' , true ) ) { $ this - > log ( $ str , self : : MESSAGE ) ; } } 
public function set Remark Name ( $ username , $ remark Name ) { $ url = sprintf ( ' %s /webwxoplog ?lang =zh _CN &pass _ticket = %s ' , $ this - > vbot - > config [ 'server .uri .base ' ] , $ this - > vbot - > config [ 'server .pass Ticket ' ] ) ; $ result = $ this - > vbot - > http - > post ( $ url , json _encode ( [ 'User Name ' = > $ username , 'Cmd Id ' = > 2 , 'Remark Name ' = > $ remark Name , 'Base Request ' = > $ this - > vbot - > config [ 'server .base Request ' ] , ] , JSON _UNESCAPED _UNICODE | JSON _UNESCAPED _SLASHES ) , true ) ; return $ result [ 'Base Response ' ] [ 'Ret ' ] = = 0 ; } 
public function set Stick ( $ username , $ is Stick = true ) { $ url = sprintf ( ' %s /webwxoplog ?lang =zh _CN &pass _ticket = %s ' , $ this - > vbot - > config [ 'server .uri .base ' ] , $ this - > vbot - > config [ 'server .pass Ticket ' ] ) ; $ result = $ this - > vbot - > http - > json ( $ url , [ 'User Name ' = > $ username , 'Cmd Id ' = > 3 , 'OP ' = > ( int ) $ is Stick , 'Base Request ' = > $ this - > vbot - > config [ 'server .base Request ' ] , ] , true ) ; return $ result [ 'Base Response ' ] [ 'Ret ' ] = = 0 ; } 
public function verify User ( $ code , $ user List , $ content = null ) { $ url = sprintf ( $ this - > vbot - > config [ 'server .uri .base ' ] . ' /webwxverifyuser ?lang =zh _CN &r = %s &pass _ticket = %s ' , time ( ) * 1 0 0 0 , $ this - > vbot - > config [ 'server .pass Ticket ' ] ) ; $ data = [ 'Base Request ' = > $ this - > vbot - > config [ 'server .base Request ' ] , 'Opcode ' = > $ code , 'Verify User List Size ' = > 1 , 'Verify User List ' = > [ $ user List ] , 'Verify Content ' = > $ content , 'Scene List Count ' = > 1 , 'Scene List ' = > [ 3 3 ] , 'skey ' = > $ this - > vbot - > config [ 'server .skey ' ] , ] ; $ result = $ this - > vbot - > http - > post ( $ url , json _encode ( $ data , JSON _UNESCAPED _UNICODE | JSON _UNESCAPED _SLASHES ) , true ) ; return Api Exception Handler : : handle ( $ result ) ; } 
public function update ( $ username , $ list = null ) : array { $ username = is _array ( $ username ) ? : [ $ username ] ; return parent : : update ( $ username , $ this - > make Username List ( $ username ) ) ; } 
public static function send ( $ username , $ word ) { if ( ! $ word | | ! $ username ) { return false ; } return static : : send Msg ( [ 'Type ' = > 1 , 'Content ' = > $ word , 'From User Name ' = > vbot ( 'myself ' ) - > username , 'To User Name ' = > $ username , 'Local ID ' = > time ( ) * 1e 4 , 'Client Msg Id ' = > time ( ) * 1e 4 , ] ) ; } 
public function get Member By Username ( $ username , $ member Username ) { $ members = $ this - > get ( $ username ) [ 'Member List ' ] ; if ( count ( $ members ) = = = 0 ) { return ; } foreach ( $ members as $ member ) { if ( $ member Username = = = $ member [ 'User Name ' ] ) { return $ member ; } } } 
public function get Members By Nickname ( $ group Username , $ member Nickname , $ blur = false ) { $ group = $ this - > get ( $ group Username ) ; if ( ! $ group ) { return false ; } $ result = [ ] ; foreach ( $ group [ 'Member List ' ] as $ member ) { if ( $ blur & & str _contains ( $ member [ 'Nick Name ' ] , $ member Nickname ) ) { $ result [ ] = $ member ; } elseif ( ! $ blur & & $ member [ 'Nick Name ' ] = = = $ member Nickname ) { $ result [ ] = $ member ; } } return $ result ; } 
public function create ( array $ contacts ) { $ url = sprintf ( ' %s /webwxcreatechatroom ?lang =zh _CN &r = %s ' , $ this - > vbot - > config [ 'server .uri .base ' ] , time ( ) ) ; $ result = $ this - > vbot - > http - > json ( $ url , [ 'Member Count ' = > count ( $ contacts ) , 'Member List ' = > $ this - > make Member List ( $ contacts ) , 'Topic ' = > ' ' , 'Base Request ' = > $ this - > vbot - > config [ 'server .base Request ' ] , ] , true ) ; if ( $ result [ 'Base Response ' ] [ 'Ret ' ] ! = 0 ) { return false ; } return $ this - > add ( $ result [ 'Chat Room Name ' ] ) ; } 
public function delete Member ( $ group , $ members ) { $ members = is _string ( $ members ) ? [ $ members ] : $ members ; $ result = $ this - > vbot - > http - > json ( sprintf ( ' %s /webwxupdatechatroom ?fun =delmember &pass _ticket = %s ' , $ this - > vbot - > config [ 'server .uri .base ' ] , $ this - > vbot - > config [ 'server .pass Ticket ' ] ) , [ 'Base Request ' = > $ this - > vbot - > config [ 'server .base Request ' ] , 'Chat Room Name ' = > $ group , 'Del Member List ' = > implode ( ' , ' , $ members ) , ] , true ) ; return $ result [ 'Base Response ' ] [ 'Ret ' ] = = 0 ; } 
public function add Member ( $ group Username , $ members ) { if ( ! $ group Username ) { return false ; } $ group = $ this - > get ( $ group Username ) ; if ( ! $ group ) { return false ; } $ group Count = count ( $ group [ 'Member List ' ] ) ; list ( $ fun , $ key ) = $ group Count > 4 0 ? [ 'invitemember ' , 'Invite Member List ' ] : [ 'addmember ' , 'Add Member List ' ] ; $ members = is _string ( $ members ) ? [ $ members ] : $ members ; $ result = $ this - > vbot - > http - > json ( sprintf ( ' %s /webwxupdatechatroom ?fun = %s &pass _ticket = %s ' , $ this - > vbot - > config [ 'server .uri .base ' ] , $ fun , $ this - > vbot - > config [ 'server .pass Ticket ' ] ) , [ 'Base Request ' = > $ this - > vbot - > config [ 'server .base Request ' ] , 'Chat Room Name ' = > $ group Username , $ key = > implode ( ' , ' , $ members ) , ] , true ) ; return $ result [ 'Base Response ' ] [ 'Ret ' ] = = 0 ; } 
public function set Group Name ( $ group , $ name ) { $ result = $ this - > vbot - > http - > post ( sprintf ( ' %s /webwxupdatechatroom ?fun =modtopic &pass _ticket = %s ' , $ this - > vbot - > config [ 'server .uri .base ' ] , $ this - > vbot - > config [ 'server .pass Ticket ' ] ) , json _encode ( [ 'Base Request ' = > $ this - > vbot - > config [ 'server .base Request ' ] , 'Chat Room Name ' = > $ group , 'New Topic ' = > $ name , ] , JSON _UNESCAPED _UNICODE | JSON _UNESCAPED _SLASHES ) , true ) ; return $ result [ 'Base Response ' ] [ 'Ret ' ] = = 0 ; } 
public function add ( $ username ) { $ result = $ this - > vbot - > http - > json ( sprintf ( ' %s /webwxbatchgetcontact ?type =ex &r = %s &pass _ticket = %s ' , $ this - > vbot - > config [ 'server .uri .base ' ] , time ( ) , $ this - > vbot - > config [ 'server .pass Ticket ' ] ) , [ 'Count ' = > 1 , 'Base Request ' = > $ this - > vbot - > config [ 'server .base Request ' ] , 'List ' = > [ [ 'Chat Room Id ' = > ' ' , 'User Name ' = > $ username , ] , ] , ] , true ) ; if ( $ result [ 'Base Response ' ] [ 'Ret ' ] ! = 0 ) { throw new Create Group Exception ( 'create group chat fail . ' ) ; } $ this - > put ( $ username , $ result [ 'Contact List ' ] [ 0 ] ) ; return $ result [ 'Contact List ' ] [ 0 ] ; } 
public function put ( $ key , $ value ) { foreach ( $ value [ 'Member List ' ] as & $ member ) { $ member = $ this - > format ( $ member ) ; } return parent : : put ( $ key , $ value ) ; } 
public function get ( $ key , $ default = null ) { $ group = parent : : get ( $ key ) ; return $ group ? : current ( $ this - > update ( $ key ) ) ; } 
public function fetch All Contacts ( $ seq = 0 ) { $ url = sprintf ( $ this - > vbot - > config [ 'server .uri .base ' ] . ' /webwxgetcontact ?pass _ticket = %s &skey = %s &r = %s &seq = %s ' , $ this - > vbot - > config [ 'server .pass Ticket ' ] , $ this - > vbot - > config [ 'server .skey ' ] , time ( ) , $ seq ) ; $ result = $ this - > vbot - > http - > json ( $ url , [ ] , true , [ 'timeout ' = > 6 0 ] ) ; if ( isset ( $ result [ 'Member List ' ] ) & & $ result [ 'Member List ' ] ) { $ this - > store ( $ result [ 'Member List ' ] ) ; } if ( isset ( $ result [ 'Seq ' ] ) & & $ result [ 'Seq ' ] ! = 0 ) { $ this - > fetch All Contacts ( $ result [ 'Seq ' ] ) ; } } 
public function store ( $ member List ) { foreach ( $ member List as $ contact ) { if ( in _array ( $ contact [ 'User Name ' ] , static : : SPECIAL _USERS ) ) { $ this - > vbot - > specials - > put ( $ contact [ 'User Name ' ] , $ contact ) ; } elseif ( $ this - > vbot - > officials - > is Official ( $ contact [ 'Verify Flag ' ] ) ) { $ this - > vbot - > officials - > put ( $ contact [ 'User Name ' ] , $ contact ) ; } elseif ( strstr ( $ contact [ 'User Name ' ] , ' @ @ ' ) ! = = false ) { $ this - > vbot - > groups - > put ( $ contact [ 'User Name ' ] , $ contact ) ; } else { $ this - > vbot - > friends - > put ( $ contact [ 'User Name ' ] , $ contact ) ; } } } 
public function fetch Group Members ( ) { $ url = sprintf ( $ this - > vbot - > config [ 'server .uri .base ' ] . ' /webwxbatchgetcontact ?type =ex &r = %s &pass _ticket = %s ' , time ( ) , $ this - > vbot - > config [ 'server .pass Ticket ' ] ) ; $ list = [ ] ; $ this - > vbot - > groups - > each ( function ( $ item , $ key ) use ( & $ list ) { $ list [ ] = [ 'User Name ' = > $ key , 'Encry Chat Room Id ' = > ' ' ] ; } ) ; $ content = $ this - > vbot - > http - > json ( $ url , [ 'Base Request ' = > $ this - > vbot - > config [ 'server .base Request ' ] , 'Count ' = > $ this - > vbot - > groups - > count ( ) , 'List ' = > $ list , ] , true , [ 'timeout ' = > 6 0 ] ) ; $ this - > store Members ( $ content ) ; } 
private function store Members ( $ array ) { if ( isset ( $ array [ 'Contact List ' ] ) & & $ array [ 'Contact List ' ] ) { foreach ( $ array [ 'Contact List ' ] as $ group ) { $ group Account = $ this - > vbot - > groups - > get ( $ group [ 'User Name ' ] ) ; $ group Account [ 'Member List ' ] = $ group [ 'Member List ' ] ; $ group Account [ 'Chat Room Id ' ] = $ group [ 'Encry Chat Room Id ' ] ; $ this - > vbot - > groups - > put ( $ group [ 'User Name ' ] , $ group Account ) ; foreach ( $ group [ 'Member List ' ] as $ member ) { $ this - > vbot - > members - > put ( $ member [ 'User Name ' ] , $ member ) ; } } } } 
public function report ( Exception $ e ) { if ( $ this - > shouldnt Report ( $ e ) ) { return true ; } if ( $ this - > handler ) { call _user _func _array ( $ this - > handler , [ $ e ] ) ; } } 
public function handle Exception ( Throwable $ e ) { $ this - > vbot - > log - > error ( $ e - > get Message ( ) ) ; $ this - > report ( $ e ) ; $ this - > throw Fatal Exception ( $ e ) ; throw $ e ; } 
private function throw Fatal Exception ( Throwable $ e ) { foreach ( $ this - > fatal Exception as $ exception ) { if ( $ e instanceof $ exception ) { throw $ e ; } } } 
public function handle Shutdown ( ) { if ( ! is _null ( $ error = error _get _last ( ) ) & & $ this - > is Fatal ( $ error [ 'type ' ] ) ) { $ this - > handle Exception ( $ this - > fatal Exception From Error ( $ error , 0 ) ) ; } $ this - > vbot - > exit Observer - > trigger ( ) ; } 
public function load ( $ extensions ) { if ( ! is _array ( $ extensions ) ) { throw new Extension Exception ( 'extensions must pass an array . ' ) ; } foreach ( $ extensions as $ extension ) { $ this - > add Service Extension ( $ extension ) ; } $ this - > service Extensions = array _unique ( $ this - > service Extensions ) ; } 
public function init Service Extensions ( ) { $ tmp Extensions = [ ] ; foreach ( $ this - > service Extensions as $ service Extensions ) { $ extension = new $ service Extensions ( ) ; $ tmp Extensions [ ] = $ extension - > init ( ) ; $ this - > base Extensions = array _merge ( $ this - > base Extensions , $ extension - > base Extensions ) ; } $ this - > service Extensions = $ tmp Extensions ; $ this - > base Extensions = array _unique ( $ this - > base Extensions ) ; $ this - > init Base Extensions ( ) ; } 
private function init Base Extensions ( ) { $ tmp Extensions = [ ] ; foreach ( $ this - > base Extensions as $ base Extension ) { $ tmp Extensions [ ] = ( new $ base Extension ( ) ) - > init ( ) ; } $ this - > base Extensions = $ tmp Extensions ; } 
public function exec ( $ collection ) { foreach ( $ this - > service Extensions as $ extension ) { if ( $ extension - > message Handler ( $ collection ) ) { return true ; } } } 
public static function xls Cell ( $ row _number , $ column _number , $ absolute = false ) { $ n = $ column _number ; for ( $ r = " " ; $ n > = 0 ; $ n = intval ( $ n / 2 6 ) - 1 ) { $ r = chr ( $ n % 2 6 + 0x 4 1 ) . $ r ; } if ( $ absolute ) { return ' $ ' . $ r . ' $ ' . ( $ row _number + 1 ) ; } return $ r . ( $ row _number + 1 ) ; } 
public static function log ( $ string ) { file _put _contents ( "php : / /stderr " , date ( "Y -m -d H :i :s : " ) . rtrim ( is _array ( $ string ) ? json _encode ( $ string ) : $ string ) . " \n " ) ; } 
public static function sanitize _filename ( $ filename ) 
public static function xmlspecialchars ( $ val ) { 
public static function add _to _list _get _index ( & $ haystack , $ needle ) { $ existing _idx = array _search ( $ needle , $ haystack , $ strict = true ) ; if ( $ existing _idx = = = false ) { $ existing _idx = count ( $ haystack ) ; $ haystack [ ] = $ needle ; } return $ existing _idx ; } 
public static function convert _date _time ( $ date _input ) 
public function permitted For ( string . . . $ audiences ) : Builder Interface { $ configured = $ this - > claims [ Registered Claims : : AUDIENCE ] ? ? [ ] ; $ to Append = array _diff ( $ audiences , $ configured ) ; return $ this - > set Claim ( Registered Claims : : AUDIENCE , array _merge ( $ configured , $ to Append ) ) ; } 
public function with Header ( string $ name , $ value ) : Builder Interface { $ this - > headers [ $ name ] = $ value ; return $ this ; } 
public function with Claim ( string $ name , $ value ) : Builder Interface { if ( in _array ( $ name , Registered Claims : : ALL , true ) ) { throw new Invalid Argument Exception ( 'You should use the correct methods to set registered claims ' ) ; } return $ this - > set Claim ( $ name , $ value ) ; } 
public function get Token ( Signer $ signer , Key $ key ) : Plain { $ headers = $ this - > headers ; $ headers [ 'alg ' ] = $ signer - > get Algorithm Id ( ) ; $ encoded Headers = $ this - > encode ( $ headers ) ; $ encoded Claims = $ this - > encode ( $ this - > format Claims ( $ this - > claims ) ) ; $ signature = $ signer - > sign ( $ encoded Headers . ' . ' . $ encoded Claims , $ key ) ; $ encoded Signature = $ this - > encoder - > base 6 4Url Encode ( $ signature ) ; return new Plain ( new Data Set ( $ headers , $ encoded Headers ) , new Data Set ( $ this - > claims , $ encoded Claims ) , new Signature ( $ signature , $ encoded Signature ) ) ; } 
private function format Claims ( array $ claims ) : array { if ( isset ( $ claims [ Registered Claims : : AUDIENCE ] [ 0 ] ) & & ! isset ( $ claims [ Registered Claims : : AUDIENCE ] [ 1 ] ) ) { $ claims [ Registered Claims : : AUDIENCE ] = $ claims [ Registered Claims : : AUDIENCE ] [ 0 ] ; } foreach ( array _intersect ( Registered Claims : : DATE _CLAIMS , array _keys ( $ claims ) ) as $ claim ) { $ claims [ $ claim ] = $ this - > convert Date ( $ claims [ $ claim ] ) ; } return $ claims ; } 
public function assert ( Token $ token , Constraint . . . $ constraints ) : void { $ violations = [ ] ; foreach ( $ constraints as $ constraint ) { $ this - > check Constraint ( $ constraint , $ token , $ violations ) ; } if ( $ violations ) { throw Invalid Token : : from Violations ( . . . $ violations ) ; } } 
private function validate Key ( $ key ) : void { if ( ! is _resource ( $ key ) ) { throw new Invalid Argument Exception ( 'It was not possible to parse your key , reason : ' . openssl _error _string ( ) ) ; } $ details = openssl _pkey _get _details ( $ key ) ; assert ( is _array ( $ details ) ) ; if ( ! isset ( $ details [ 'key ' ] ) | | $ details [ 'type ' ] ! = = $ this - > get Key Type ( ) ) { throw new Invalid Argument Exception ( 'This key is not compatible with this signer ' ) ; } } 
final public function sign ( string $ payload , Key $ key ) : string { return $ this - > create Signature ( $ key - > get Content ( ) , $ key - > get Passphrase ( ) , $ payload ) ; } 
final public function verify ( string $ expected , string $ payload , Key $ key ) : bool { return $ this - > verify Signature ( $ expected , $ payload , $ key - > get Content ( ) ) ; } 
final public function sign ( string $ payload , Key $ key ) : string { return $ this - > converter - > from Asn 1 ( $ this - > create Signature ( $ key - > get Content ( ) , $ key - > get Passphrase ( ) , $ payload ) , $ this - > get Key Length ( ) ) ; } 
final public function verify ( string $ expected , string $ payload , Key $ key ) : bool { return $ this - > verify Signature ( $ this - > converter - > to Asn 1 ( $ expected , $ this - > get Key Length ( ) ) , $ payload , $ key - > get Content ( ) ) ; } 
final public function sign ( string $ payload , Key $ key ) : string { return hash _hmac ( $ this - > get Algorithm ( ) , $ payload , $ key - > get Content ( ) , true ) ; } 
final public function verify ( string $ expected , string $ payload , Key $ key ) : bool { return hash _equals ( $ expected , $ this - > sign ( $ payload , $ key ) ) ; } 
public function assert ( Token $ token ) : void { $ now = $ this - > clock - > now ( ) ; $ this - > assert Issue Time ( $ token , $ now - > add ( $ this - > leeway ) ) ; $ this - > assert Minimum Time ( $ token , $ now - > add ( $ this - > leeway ) ) ; $ this - > assert Expiration ( $ token , $ now - > sub ( $ this - > leeway ) ) ; } 
public function assert ( Token $ token ) : void { if ( ! $ token instanceof Token \ Plain ) { throw new Constraint Violation ( 'You should pass a plain token ' ) ; } if ( $ token - > headers ( ) - > get ( 'alg ' ) ! = = $ this - > signer - > get Algorithm Id ( ) ) { throw new Constraint Violation ( 'Token signer mismatch ' ) ; } if ( ! $ this - > signer - > verify ( $ token - > signature ( ) - > hash ( ) , $ token - > payload ( ) , $ this - > key ) ) { throw new Constraint Violation ( 'Token signature mismatch ' ) ; } } 
public function parse ( string $ jwt ) : Token Interface { [ $ encoded Headers , $ encoded Claims , $ encoded Signature ] = $ this - > split Jwt ( $ jwt ) ; $ header = $ this - > parse Header ( $ encoded Headers ) ; return new Plain ( new Data Set ( $ header , $ encoded Headers ) , new Data Set ( $ this - > parse Claims ( $ encoded Claims ) , $ encoded Claims ) , $ this - > parse Signature ( $ header , $ encoded Signature ) ) ; } 
private function split Jwt ( string $ jwt ) : array { $ data = explode ( ' . ' , $ jwt ) ; if ( count ( $ data ) ! = = 3 ) { throw new Invalid Argument Exception ( 'The JWT string must have two dots ' ) ; } return $ data ; } 
private function parse Header ( string $ data ) : array { $ header = $ this - > decoder - > json Decode ( $ this - > decoder - > base 6 4Url Decode ( $ data ) ) ; if ( ! is _array ( $ header ) ) { throw new Invalid Argument Exception ( 'Headers must be an array ' ) ; } if ( isset ( $ header [ 'enc ' ] ) ) { throw new Invalid Argument Exception ( 'Encryption is not supported yet ' ) ; } if ( ! isset ( $ header [ 'typ ' ] ) ) { throw new Invalid Argument Exception ( 'The header "typ " must be present ' ) ; } return $ header ; } 
private function parse Claims ( string $ data ) : array { $ claims = $ this - > decoder - > json Decode ( $ this - > decoder - > base 6 4Url Decode ( $ data ) ) ; if ( ! is _array ( $ claims ) ) { throw new Invalid Argument Exception ( 'Claims must be an array ' ) ; } if ( isset ( $ claims [ Registered Claims : : AUDIENCE ] ) ) { $ claims [ Registered Claims : : AUDIENCE ] = ( array ) $ claims [ Registered Claims : : AUDIENCE ] ; } foreach ( array _intersect ( Registered Claims : : DATE _CLAIMS , array _keys ( $ claims ) ) as $ claim ) { $ claims [ $ claim ] = $ this - > convert Date ( ( string ) $ claims [ $ claim ] ) ; } return $ claims ; } 
private function parse Signature ( array $ header , string $ data ) : Signature { if ( $ data = = = ' ' | | ! isset ( $ header [ 'alg ' ] ) | | $ header [ 'alg ' ] = = = 'none ' ) { return Signature : : from Empty Data ( ) ; } $ hash = $ this - > decoder - > base 6 4Url Decode ( $ data ) ; return new Signature ( $ hash , $ data ) ; } 
public function is Permitted For ( string $ audience ) : bool { return in _array ( $ audience , $ this - > claims - > get ( Registered Claims : : AUDIENCE , [ ] ) , true ) ; } 
public function is Identified By ( string $ id ) : bool { return $ this - > claims - > get ( Registered Claims : : ID ) = = = $ id ; } 
public function is Related To ( string $ subject ) : bool { return $ this - > claims - > get ( Registered Claims : : SUBJECT ) = = = $ subject ; } 
public function has Been Issued By ( string . . . $ issuers ) : bool { return in _array ( $ this - > claims - > get ( Registered Claims : : ISSUER ) , $ issuers , true ) ; } 
public function has Been Issued Before ( Date Time Interface $ now ) : bool { return $ now > = $ this - > claims - > get ( Registered Claims : : ISSUED _AT ) ; } 
public function is Minimum Time Before ( Date Time Interface $ now ) : bool { return $ now > = $ this - > claims - > get ( Registered Claims : : NOT _BEFORE ) ; } 
public function is Expired ( Date Time Interface $ now ) : bool { if ( ! $ this - > claims - > has ( Registered Claims : : EXPIRATION _TIME ) ) { return false ; } return $ now > $ this - > claims - > get ( Registered Claims : : EXPIRATION _TIME ) ; } 
public function handle ( $ request , Closure $ next ) { 
public function handle ( $ request , Closure $ next ) { 
public function handle ( ) { foreach ( $ this - > get Supported Locales ( ) as $ locale ) { $ path = $ this - > make Locale Routes Path ( $ locale ) ; if ( $ this - > files - > exists ( $ path ) ) { $ this - > files - > delete ( $ path ) ; } } $ path = $ this - > laravel - > get Cached Routes Path ( ) ; if ( $ this - > files - > exists ( $ path ) ) { $ this - > files - > delete ( $ path ) ; } $ this - > info ( 'Route caches for locales cleared ! ' ) ; } 
public function negotiate Language ( ) { $ matches = $ this - > get Matches From Accepted Languages ( ) ; foreach ( $ matches as $ key = > $ q ) { $ key = ( $ this - > config Repository - > get ( 'laravellocalization .locales Mapping ' ) [ $ key ] ) ? ? $ key ; if ( ! empty ( $ this - > supported Languages [ $ key ] ) ) { return $ key ; } if ( $ this - > use _intl ) { $ key = Locale : : canonicalize ( $ key ) ; } 
private function get Matches From Accepted Languages ( ) { $ matches = [ ] ; if ( $ accept Languages = $ this - > request - > header ( 'Accept -Language ' ) ) { $ accept Languages = explode ( ' , ' , $ accept Languages ) ; $ generic _matches = [ ] ; foreach ( $ accept Languages as $ option ) { $ option = array _map ( 'trim ' , explode ( ' ; ' , $ option ) ) ; $ l = $ option [ 0 ] ; if ( isset ( $ option [ 1 ] ) ) { $ q = ( float ) str _replace ( 'q = ' , ' ' , $ option [ 1 ] ) ; } else { $ q = null ; 
protected function cache Routes Per Locale ( ) { 
protected function get Fresh Application Routes ( $ locale = null ) { $ app = require $ this - > get Bootstrap Path ( ) . ' /app .php ' ; if ( null ! = = $ locale ) { $ key = Laravel Localization : : ENV _ROUTE _KEY ; putenv ( " { $key } = { $locale } " ) ; $ app - > make ( Kernel : : class ) - > bootstrap ( ) ; putenv ( " { $key } = " ) ; } else { $ app - > make ( Kernel : : class ) - > bootstrap ( ) ; } return $ app [ 'router ' ] - > get Routes ( ) ; } 
protected function build Route Cache File ( Route Collection $ routes ) { $ stub = $ this - > files - > get ( realpath ( _ _DIR _ _ . DIRECTORY _SEPARATOR . ' . . ' . DIRECTORY _SEPARATOR . ' . . ' . DIRECTORY _SEPARATOR . ' . . ' . DIRECTORY _SEPARATOR . 'stubs ' . DIRECTORY _SEPARATOR . 'routes .stub ' ) ) ; return str _replace ( [ ' { {routes } } ' , ' { {translated Routes } } ' , ] , [ base 6 4 _encode ( serialize ( $ routes ) ) , $ this - > get Laravel Localization ( ) - > get Serialized Translated Routes ( ) , ] , $ stub ) ; } 
public function register ( ) { $ package Config File = _ _DIR _ _ . ' / . . / . . /config /config .php ' ; $ this - > merge Config From ( $ package Config File , 'laravellocalization ' ) ; $ this - > register Bindings ( ) ; $ this - > register Commands ( ) ; } 
protected function register Bindings ( ) { $ this - > app - > singleton ( Laravel Localization : : class , function ( ) { return new Laravel Localization ( ) ; } ) ; $ this - > app - > alias ( Laravel Localization : : class , 'laravellocalization ' ) ; } 
protected function register Commands ( ) { $ this - > app - > singleton ( 'laravellocalizationroutecache .cache ' , Commands \ Route Translations Cache Command : : class ) ; $ this - > app - > singleton ( 'laravellocalizationroutecache .clear ' , Commands \ Route Translations Clear Command : : class ) ; $ this - > app - > singleton ( 'laravellocalizationroutecache .list ' , Commands \ Route Translations List Command : : class ) ; $ this - > commands ( [ 'laravellocalizationroutecache .cache ' , 'laravellocalizationroutecache .clear ' , 'laravellocalizationroutecache .list ' , ] ) ; } 
public function handle ( $ request , Closure $ next ) { 
public function set Locale ( $ locale = null ) { if ( empty ( $ locale ) | | ! \ is _string ( $ locale ) ) { 
public function get Localized URL ( $ locale = null , $ url = null , $ attributes = [ ] , $ force Default Location = false ) { if ( $ locale = = = null ) { $ locale = $ this - > get Current Locale ( ) ; } if ( ! $ this - > check Locale In Supported Locales ( $ locale ) ) { throw new Unsupported Locale Exception ( 'Locale \ ' ' . $ locale . ' \ ' is not in the list of supported locales . ' ) ; } if ( empty ( $ attributes ) ) { $ attributes = $ this - > extract Attributes ( $ url , $ locale ) ; } $ url Query = parse _url ( $ url , PHP _URL _QUERY ) ; $ url Query = $ url Query ? ' ? ' . $ url Query : ' ' ; if ( empty ( $ url ) ) { if ( ! empty ( $ this - > route Name ) ) { return $ this - > get URLFrom Route Name Translated ( $ locale , $ this - > route Name , $ attributes , $ force Default Location ) ; } $ url = $ this - > request - > full Url ( ) ; } else { $ url = $ this - > url - > to ( $ url ) ; $ url = preg _replace ( ' / ' . preg _quote ( $ url Query , ' / ' ) . ' $ / ' , ' ' , $ url ) ; } if ( $ locale & & $ translated Route = $ this - > find Translated Route By Url ( $ url , $ attributes , $ this - > current Locale ) ) { return $ this - > get URLFrom Route Name Translated ( $ locale , $ translated Route , $ attributes , $ force Default Location ) . $ url Query ; } $ base _path = $ this - > request - > get Base Url ( ) ; $ parsed _url = parse _url ( $ url ) ; $ url _locale = $ this - > get Default Locale ( ) ; if ( ! $ parsed _url | | empty ( $ parsed _url [ 'path ' ] ) ) { $ path = $ parsed _url [ 'path ' ] = ' ' ; } else { $ parsed _url [ 'path ' ] = str _replace ( $ base _path , ' ' , ' / ' . ltrim ( $ parsed _url [ 'path ' ] , ' / ' ) ) ; $ path = $ parsed _url [ 'path ' ] ; foreach ( $ this - > get Supported Locales ( ) as $ locale Code = > $ lang ) { $ parsed _url [ 'path ' ] = preg _replace ( ' % ^ / ? ' . $ locale Code . ' / % ' , ' $ 1 ' , $ parsed _url [ 'path ' ] ) ; if ( $ parsed _url [ 'path ' ] ! = = $ path ) { $ url _locale = $ locale Code ; break ; } $ parsed _url [ 'path ' ] = preg _replace ( ' % ^ / ? ' . $ locale Code . ' $ % ' , ' $ 1 ' , $ parsed _url [ 'path ' ] ) ; if ( $ parsed _url [ 'path ' ] ! = = $ path ) { $ url _locale = $ locale Code ; break ; } } } $ parsed _url [ 'path ' ] = ltrim ( $ parsed _url [ 'path ' ] , ' / ' ) ; if ( $ translated Route = $ this - > find Translated Route By Path ( $ parsed _url [ 'path ' ] , $ url _locale ) ) { return $ this - > get URLFrom Route Name Translated ( $ locale , $ translated Route , $ attributes , $ force Default Location ) . $ url Query ; } if ( ! empty ( $ locale ) ) { if ( $ force Default Location | | $ locale ! = $ this - > get Default Locale ( ) | | ! $ this - > hide Default Locale In URL ( ) ) { $ parsed _url [ 'path ' ] = $ locale . ' / ' . ltrim ( $ parsed _url [ 'path ' ] , ' / ' ) ; } } $ parsed _url [ 'path ' ] = ltrim ( ltrim ( $ base _path , ' / ' ) . ' / ' . $ parsed _url [ 'path ' ] , ' / ' ) ; 
public function get URLFrom Route Name Translated ( $ locale , $ trans Key Name , $ attributes = [ ] , $ force Default Location = false ) { if ( ! $ this - > check Locale In Supported Locales ( $ locale ) ) { throw new Unsupported Locale Exception ( 'Locale \ ' ' . $ locale . ' \ ' is not in the list of supported locales . ' ) ; } if ( ! \ is _string ( $ locale ) ) { $ locale = $ this - > get Default Locale ( ) ; } $ route = ' ' ; if ( $ force Default Location | | ! ( $ locale = = = $ this - > default Locale & & $ this - > hide Default Locale In URL ( ) ) ) { $ route = ' / ' . $ locale ; } if ( \ is _string ( $ locale ) & & $ this - > translator - > has ( $ trans Key Name , $ locale ) ) { $ translation = $ this - > translator - > trans ( $ trans Key Name , [ ] , $ locale ) ; $ route . = ' / ' . $ translation ; $ route = $ this - > substitute Attributes In Route ( $ attributes , $ route ) ; } if ( empty ( $ route ) ) { 
public function get Supported Locales ( ) { if ( ! empty ( $ this - > supported Locales ) ) { return $ this - > supported Locales ; } $ locales = $ this - > config Repository - > get ( 'laravellocalization .supported Locales ' ) ; if ( empty ( $ locales ) | | ! \ is _array ( $ locales ) ) { throw new Supported Locales Not Defined ( ) ; } $ this - > supported Locales = $ locales ; return $ locales ; } 
public function get Locales Order ( ) { $ locales = $ this - > get Supported Locales ( ) ; $ order = $ this - > config Repository - > get ( 'laravellocalization .locales Order ' ) ; uksort ( $ locales , function ( $ a , $ b ) use ( $ order ) { $ pos _a = array _search ( $ a , $ order ) ; $ pos _b = array _search ( $ b , $ order ) ; return $ pos _a - $ pos _b ; } ) ; return $ locales ; } 
public function get Current Locale Direction ( ) { if ( ! empty ( $ this - > supported Locales [ $ this - > get Current Locale ( ) ] [ 'dir ' ] ) ) { return $ this - > supported Locales [ $ this - > get Current Locale ( ) ] [ 'dir ' ] ; } switch ( $ this - > get Current Locale Script ( ) ) { 
public function get Current Locale ( ) { if ( $ this - > current Locale ) { return $ this - > current Locale ; } if ( $ this - > use Accept Language Header ( ) & & ! $ this - > app - > running In Console ( ) ) { $ negotiator = new Language Negotiator ( $ this - > default Locale , $ this - > get Supported Locales ( ) , $ this - > request ) ; return $ negotiator - > negotiate Language ( ) ; } 
public function get Current Locale Regional ( ) { 
public function check Locale In Supported Locales ( $ locale ) { $ locales = $ this - > get Supported Locales ( ) ; if ( $ locale ! = = false & & empty ( $ locales [ $ locale ] ) ) { return false ; } return true ; } 
protected function substitute Attributes In Route ( $ attributes , $ route ) { foreach ( $ attributes as $ key = > $ value ) { if ( $ value instance Of Url Routable ) { $ value = $ value - > get Route Key ( ) ; } $ route = str _replace ( array ( ' { ' . $ key . ' } ' , ' { ' . $ key . ' ? } ' ) , $ value , $ route ) ; } 
public function trans Route ( $ route Name ) { if ( ! \ in _array ( $ route Name , $ this - > translated Routes ) ) { $ this - > translated Routes [ ] = $ route Name ; } return $ this - > translator - > trans ( $ route Name ) ; } 
public function get Route Name From APath ( $ path ) { $ attributes = $ this - > extract Attributes ( $ path ) ; $ path = parse _url ( $ path ) [ 'path ' ] ; $ path = trim ( str _replace ( ' / ' . $ this - > current Locale . ' / ' , ' ' , $ path ) , " / " ) ; foreach ( $ this - > translated Routes as $ route ) { if ( trim ( $ this - > substitute Attributes In Route ( $ attributes , $ this - > translator - > trans ( $ route ) ) , ' / ' ) = = = $ path ) { return $ route ; } } return false ; } 
protected function find Translated Route By Path ( $ path , $ url _locale ) { 
protected function find Translated Route By Url ( $ url , $ attributes , $ locale ) { if ( empty ( $ url ) ) { return false ; } if ( isset ( $ this - > cached Translated Routes By Url [ $ locale ] [ $ url ] ) ) { return $ this - > cached Translated Routes By Url [ $ locale ] [ $ url ] ; } 
public function create Url From Uri ( $ uri ) { $ uri = ltrim ( $ uri , ' / ' ) ; if ( empty ( $ this - > base Url ) ) { return app ( 'url ' ) - > to ( $ uri ) ; } return $ this - > base Url . $ uri ; } 
protected function extract Attributes ( $ url = false , $ locale = ' ' ) { if ( ! empty ( $ url ) ) { $ attributes = [ ] ; $ parse = parse _url ( $ url ) ; if ( isset ( $ parse [ 'path ' ] ) ) { $ parse [ 'path ' ] = trim ( str _replace ( ' / ' . $ this - > current Locale . ' / ' , ' ' , $ parse [ 'path ' ] ) , " / " ) ; $ url = explode ( ' / ' , trim ( $ parse [ 'path ' ] , ' / ' ) ) ; } else { $ url = [ ] ; } foreach ( $ this - > router - > get Routes ( ) as $ route ) { $ attributes = [ ] ; $ path = method _exists ( $ route , 'uri ' ) ? $ route - > uri ( ) : $ route - > get Uri ( ) ; if ( ! preg _match ( " / { [ \w ] + \ ? ? } / " , $ path ) ) { continue ; } $ path = explode ( ' / ' , $ path ) ; $ i = 0 ; 
protected function normalize Attributes ( $ attributes ) { if ( array _key _exists ( 'data ' , $ attributes ) & & \ is _array ( $ attributes [ 'data ' ] ) & & ! \ count ( $ attributes [ 'data ' ] ) ) { $ attributes [ 'data ' ] = null ; return $ attributes ; } return $ attributes ; } 
protected function load Cached Routes ( ) { $ localization = $ this - > get Laravel Localization ( ) ; $ localization - > set Locale ( ) ; $ locale = $ localization - > get Current Locale ( ) ; $ locale Keys = $ localization - > get Supported Languages Keys ( ) ; 
protected function make Locale Routes Path ( $ locale , $ locale Keys ) { $ path = $ this - > get Default Cached Route Path ( ) ; $ locale Segment = request ( ) - > segment ( 1 ) ; if ( ! $ locale Segment | | ! in _array ( $ locale Segment , $ locale Keys ) ) { return $ path ; } return substr ( $ path , 0 , - 4 ) . ' _ ' . $ locale . ' .php ' ; } 
public function handle ( $ request , Closure $ next ) { 
public function handle ( ) { if ( count ( $ this - > routes ) = = 0 ) { $ this - > error ( "Your application doesn 't have any routes . " ) ; return ; } $ locale = $ this - > argument ( 'locale ' ) ; if ( ! $ this - > is Supported Locale ( $ locale ) ) { $ this - > error ( "Unsupported locale : ' { $locale } ' . " ) ; return ; } $ this - > routes = $ this - > get Fresh Application Routes ( $ locale ) ; $ this - > display Routes ( $ this - > get Routes ( ) ) ; } 
protected function get Fresh Application Routes ( $ locale ) { $ app = require $ this - > get Bootstrap Path ( ) . ' /app .php ' ; $ key = Laravel Localization : : ENV _ROUTE _KEY ; putenv ( " { $key } = { $locale } " ) ; $ app - > make ( Kernel : : class ) - > bootstrap ( ) ; putenv ( " { $key } = " ) ; return $ app [ 'router ' ] - > get Routes ( ) ; } 
public function handle ( $ request , Closure $ next ) { 
public function encode ( array $ payloads = [ ] ) : string { if ( ! isset ( $ payloads [ 'group _id ' ] ) ) { throw new Protocol Exception ( 'given heartbeat data invalid . `group _id ` is undefined . ' ) ; } if ( ! isset ( $ payloads [ 'generation _id ' ] ) ) { throw new Protocol Exception ( 'given heartbeat data invalid . `generation _id ` is undefined . ' ) ; } if ( ! isset ( $ payloads [ 'member _id ' ] ) ) { throw new Protocol Exception ( 'given heartbeat data invalid . `member _id ` is undefined . ' ) ; } $ header = $ this - > request Header ( 'kafka -php ' , self : : HEART _BEAT _REQUEST , self : : HEART _BEAT _REQUEST ) ; $ data = self : : encode String ( $ payloads [ 'group _id ' ] , self : : PACK _INT 1 6 ) ; $ data . = self : : pack ( self : : BIT _B 3 2 , ( string ) $ payloads [ 'generation _id ' ] ) ; $ data . = self : : encode String ( $ payloads [ 'member _id ' ] , self : : PACK _INT 1 6 ) ; $ data = self : : encode String ( $ header . $ data , self : : PACK _INT 3 2 ) ; return $ data ; } 
public function emergency ( string $ message , array $ context = [ ] ) : void { $ this - > log ( Log Level : : EMERGENCY , $ message , $ context ) ; } 
public function alert ( string $ message , array $ context = [ ] ) : void { $ this - > log ( Log Level : : ALERT , $ message , $ context ) ; } 
public function critical ( string $ message , array $ context = [ ] ) : void { $ this - > log ( Log Level : : CRITICAL , $ message , $ context ) ; } 
public function error ( string $ message , array $ context = [ ] ) : void { $ this - > log ( Log Level : : ERROR , $ message , $ context ) ; } 
public function warning ( string $ message , array $ context = [ ] ) : void { $ this - > log ( Log Level : : WARNING , $ message , $ context ) ; } 
public function log ( $ level , $ message , array $ context = [ ] ) : void { if ( $ this - > logger = = = null ) { $ this - > logger = new Null Logger ( ) ; } $ this - > logger - > log ( $ level , $ message , $ context ) ; } 
protected function process Request ( string $ data , int $ fd ) : void { $ correlation Id = Protocol \ Protocol : : unpack ( Protocol \ Protocol : : BIT _B 3 2 , substr ( $ data , 0 , 4 ) ) ; switch ( $ correlation Id ) { case Protocol : : METADATA _REQUEST : $ result = Protocol : : decode ( Protocol : : METADATA _REQUEST , substr ( $ data , 4 ) ) ; if ( ! isset ( $ result [ 'brokers ' ] , $ result [ 'topics ' ] ) ) { $ this - > error ( 'Get metadata is fail , brokers or topics is null . ' ) ; $ this - > state - > fail Run ( State : : REQUEST _METADATA ) ; break ; } $ broker = $ this - > get Broker ( ) ; $ is Change = $ broker - > set Data ( $ result [ 'topics ' ] , $ result [ 'brokers ' ] ) ; $ this - > state - > succ Run ( State : : REQUEST _METADATA , $ is Change ) ; break ; case Protocol : : PRODUCE _REQUEST : $ result = Protocol : : decode ( Protocol : : PRODUCE _REQUEST , substr ( $ data , 4 ) ) ; $ this - > succ Produce ( $ result , $ fd ) ; break ; default : $ this - > error ( 'Error request , correlation Id : ' . $ correlation Id ) ; } } 
protected function convert Record Set ( array $ record Set ) : array { $ send Data = [ ] ; $ broker = $ this - > get Broker ( ) ; $ topics = $ broker - > get Topics ( ) ; foreach ( $ record Set as $ record ) { $ this - > record Validator - > validate ( $ record , $ topics ) ; $ topic Meta = $ topics [ $ record [ 'topic ' ] ] ; $ part Nums = array _keys ( $ topic Meta ) ; shuffle ( $ part Nums ) ; $ part Id = ! isset ( $ record [ 'part Id ' ] , $ topic Meta [ $ record [ 'part Id ' ] ] ) ? $ part Nums [ 0 ] : $ record [ 'part Id ' ] ; $ broker Id = $ topic Meta [ $ part Id ] ; $ topic Data = [ ] ; if ( isset ( $ send Data [ $ broker Id ] [ $ record [ 'topic ' ] ] ) ) { $ topic Data = $ send Data [ $ broker Id ] [ $ record [ 'topic ' ] ] ; } $ partition = [ ] ; if ( isset ( $ topic Data [ 'partitions ' ] [ $ part Id ] ) ) { $ partition = $ topic Data [ 'partitions ' ] [ $ part Id ] ; } $ partition [ 'partition _id ' ] = $ part Id ; if ( trim ( $ record [ 'key ' ] ? ? ' ' ) ! = = ' ' ) { $ partition [ 'messages ' ] [ ] = [ 'value ' = > $ record [ 'value ' ] , 'key ' = > $ record [ 'key ' ] ] ; } else { $ partition [ 'messages ' ] [ ] = $ record [ 'value ' ] ; } $ topic Data [ 'partitions ' ] [ $ part Id ] = $ partition ; $ topic Data [ 'topic _name ' ] = $ record [ 'topic ' ] ; $ send Data [ $ broker Id ] [ $ record [ 'topic ' ] ] = $ topic Data ; } return $ send Data ; } 
public function read ( $ data ) : void { $ this - > read Buffer . = ( string ) $ data ; do { if ( $ this - > read Need Length = = = 0 ) { 
public function write ( ? string $ data = null ) : void { if ( $ data ! = = null ) { $ this - > write Buffer . = $ data ; } $ bytes To Write = strlen ( $ this - > write Buffer ) ; $ bytes Written = @ fwrite ( $ this - > stream , $ this - > write Buffer ) ; if ( $ bytes To Write = = = $ bytes Written ) { Loop : : disable ( $ this - > write Watcher Id ) ; } elseif ( $ bytes Written > = 0 ) { Loop : : enable ( $ this - > write Watcher Id ) ; } elseif ( $ this - > is Socket Dead ( ) ) { $ this - > reconnect ( ) ; } $ this - > write Buffer = substr ( $ this - > write Buffer , $ bytes Written ) ; } 
public function encode ( array $ payloads = [ ] ) : string { if ( ! isset ( $ payloads [ 'data ' ] ) ) { throw new Protocol Exception ( 'given procude data invalid . `data ` is undefined . ' ) ; } $ header = $ this - > request Header ( 'kafka -php ' , 0 , self : : PRODUCE _REQUEST ) ; $ data = self : : pack ( self : : BIT _B 1 6 , ( string ) ( $ payloads [ 'required _ack ' ] ? ? 0 ) ) ; $ data . = self : : pack ( self : : BIT _B 3 2 , ( string ) ( $ payloads [ 'timeout ' ] ? ? 1 0 0 ) ) ; $ data . = self : : encode Array ( $ payloads [ 'data ' ] , [ $ this , 'encode Produce Topic ' ] , $ payloads [ 'compression ' ] ? ? self : : COMPRESSION _NONE ) ; return self : : encode String ( $ header . $ data , self : : PACK _INT 3 2 ) ; } 
public function decode ( string $ data ) : array { $ offset = 0 ; $ version = $ this - > get Api Version ( self : : PRODUCE _REQUEST ) ; $ ret = $ this - > decode Array ( substr ( $ data , $ offset ) , [ $ this , 'produce Topic Pair ' ] , $ version ) ; $ offset + = $ ret [ 'length ' ] ; $ throttle Time = 0 ; if ( $ version = = = self : : API _VERSION 2 ) { $ throttle Time = self : : unpack ( self : : BIT _B 3 2 , substr ( $ data , $ offset , 4 ) ) ; } return [ 'throttle Time ' = > $ throttle Time , 'data ' = > $ ret [ 'data ' ] ] ; } 
protected function encode Message Set ( array $ messages , int $ compression = self : : COMPRESSION _NONE ) : string { $ data = ' ' ; $ next = 0 ; foreach ( $ messages as $ message ) { $ encoded Message = $ this - > encode Message ( $ message ) ; $ data . = self : : pack ( self : : BIT _B 6 4 , ( string ) $ next ) . self : : encode String ( $ encoded Message , self : : PACK _INT 3 2 ) ; + + $ next ; } if ( $ compression = = = self : : COMPRESSION _NONE ) { return $ data ; } return self : : pack ( self : : BIT _B 6 4 , ' 0 ' ) . self : : encode String ( $ this - > encode Message ( $ data , $ compression ) , self : : PACK _INT 3 2 ) ; } 
protected function encode Message ( $ message , int $ compression = self : : COMPRESSION _NONE ) : string { $ magic = $ this - > compute Magic Byte ( ) ; $ attributes = $ this - > compute Attributes ( $ magic , $ compression , $ this - > compute Timestamp Type ( $ magic ) ) ; $ data = self : : pack ( self : : BIT _B 8 , ( string ) $ magic ) ; $ data . = self : : pack ( self : : BIT _B 8 , ( string ) $ attributes ) ; if ( $ magic > = self : : MESSAGE _MAGIC _VERSION 1 ) { $ data . = self : : pack ( self : : BIT _B 6 4 , $ this - > clock - > now ( ) - > format ( 'Uv ' ) ) ; } $ key = ' ' ; if ( is _array ( $ message ) ) { $ key = $ message [ 'key ' ] ; $ message = $ message [ 'value ' ] ; } 
protected function encode Produce Partition ( array $ values , int $ compression ) : string { if ( ! isset ( $ values [ 'partition _id ' ] ) ) { throw new Protocol Exception ( 'given produce data invalid . `partition _id ` is undefined . ' ) ; } if ( ! isset ( $ values [ 'messages ' ] ) | | empty ( $ values [ 'messages ' ] ) ) { throw new Protocol Exception ( 'given produce data invalid . `messages ` is undefined . ' ) ; } $ data = self : : pack ( self : : BIT _B 3 2 , ( string ) $ values [ 'partition _id ' ] ) ; $ data . = self : : encode String ( $ this - > encode Message Set ( ( array ) $ values [ 'messages ' ] , $ compression ) , self : : PACK _INT 3 2 ) ; return $ data ; } 
protected function encode Produce Topic ( array $ values , int $ compression ) : string { if ( ! isset ( $ values [ 'topic _name ' ] ) ) { throw new Protocol Exception ( 'given produce data invalid . `topic _name ` is undefined . ' ) ; } if ( ! isset ( $ values [ 'partitions ' ] ) | | empty ( $ values [ 'partitions ' ] ) ) { throw new Protocol Exception ( 'given produce data invalid . `partitions ` is undefined . ' ) ; } $ topic = self : : encode String ( $ values [ 'topic _name ' ] , self : : PACK _INT 1 6 ) ; $ partitions = self : : encode Array ( $ values [ 'partitions ' ] , [ $ this , 'encode Produce Partition ' ] , $ compression ) ; return $ topic . $ partitions ; } 
protected function produce Topic Pair ( string $ data , int $ version ) : array { $ offset = 0 ; $ topic Info = $ this - > decode String ( $ data , self : : BIT _B 1 6 ) ; $ offset + = $ topic Info [ 'length ' ] ; $ ret = $ this - > decode Array ( substr ( $ data , $ offset ) , [ $ this , 'produce Partition Pair ' ] , $ version ) ; $ offset + = $ ret [ 'length ' ] ; return [ 'length ' = > $ offset , 'data ' = > [ 'topic Name ' = > $ topic Info [ 'data ' ] , 'partitions ' = > $ ret [ 'data ' ] , ] , ] ; } 
protected function produce Partition Pair ( string $ data , int $ version ) : array { $ offset = 0 ; $ partition Id = self : : unpack ( self : : BIT _B 3 2 , substr ( $ data , $ offset , 4 ) ) ; $ offset + = 4 ; $ error Code = self : : unpack ( self : : BIT _B 1 6 _SIGNED , substr ( $ data , $ offset , 2 ) ) ; $ offset + = 2 ; $ partition Offset = self : : unpack ( self : : BIT _B 6 4 , substr ( $ data , $ offset , 8 ) ) ; $ offset + = 8 ; $ timestamp = 0 ; if ( $ version = = = self : : API _VERSION 2 ) { $ timestamp = self : : unpack ( self : : BIT _B 6 4 , substr ( $ data , $ offset , 8 ) ) ; $ offset + = 8 ; } return [ 'length ' = > $ offset , 'data ' = > [ 'partition ' = > $ partition Id , 'error Code ' = > $ error Code , 'offset ' = > $ offset , 'timestamp ' = > $ timestamp , ] , ] ; } 
public function send ( $ data = true ) : ? array { if ( $ this - > logger ) { $ this - > process - > set Logger ( $ this - > logger ) ; } if ( is _array ( $ data ) ) { return $ this - > send Synchronously ( $ data ) ; } $ this - > send Asynchronously ( $ data ) ; return null ; } 
private function send Synchronously ( array $ data ) : array { if ( ! $ this - > process instanceof Sync Process ) { throw new Exception ( 'An asynchronous process is not able to send messages synchronously ' ) ; } return $ this - > process - > send ( $ data ) ; } 
public function encode ( array $ payloads = [ ] ) : string { if ( ! isset ( $ payloads [ 'data ' ] ) ) { throw new Protocol Exception ( 'given fetch offset data invalid . `data ` is undefined . ' ) ; } if ( ! isset ( $ payloads [ 'group _id ' ] ) ) { throw new Protocol Exception ( 'given fetch offset data invalid . `group _id ` is undefined . ' ) ; } $ header = $ this - > request Header ( 'kafka -php ' , self : : OFFSET _FETCH _REQUEST , self : : OFFSET _FETCH _REQUEST ) ; $ data = self : : encode String ( $ payloads [ 'group _id ' ] , self : : PACK _INT 1 6 ) ; $ data . = self : : encode Array ( $ payloads [ 'data ' ] , [ $ this , 'encode Offset Topic ' ] ) ; $ data = self : : encode String ( $ header . $ data , self : : PACK _INT 3 2 ) ; return $ data ; } 
public function encode ( array $ payloads = [ ] ) : string { $ header = $ this - > request Header ( 'kafka -php ' , self : : DESCRIBE _GROUPS _REQUEST , self : : DESCRIBE _GROUPS _REQUEST ) ; $ data = self : : encode Array ( $ payloads , [ $ this , 'encode String ' ] , self : : PACK _INT 1 6 ) ; return self : : encode String ( $ header . $ data , self : : PACK _INT 3 2 ) ; } 
public function send ( array $ record Set ) : array { $ broker = $ this - > get Broker ( ) ; $ config = $ this - > get Config ( ) ; $ required Ack = $ config - > get Required Ack ( ) ; $ timeout = $ config - > get Timeout ( ) ; $ compression = $ config - > get Compression ( ) ; 
public function encode ( array $ payloads = [ ] ) : string { if ( ! isset ( $ payloads [ 'data ' ] ) ) { throw new Protocol Exception ( 'given fetch kafka data invalid . `data ` is undefined . ' ) ; } if ( ! isset ( $ payloads [ 'replica _id ' ] ) ) { $ payloads [ 'replica _id ' ] = - 1 ; } if ( ! isset ( $ payloads [ 'max _wait _time ' ] ) ) { $ payloads [ 'max _wait _time ' ] = 1 0 0 ; 
protected function fetch Partition ( string $ data ) : array { $ offset = 0 ; $ partition Id = self : : unpack ( self : : BIT _B 3 2 , substr ( $ data , $ offset , 4 ) ) ; $ offset + = 4 ; $ error Code = self : : unpack ( self : : BIT _B 1 6 _SIGNED , substr ( $ data , $ offset , 2 ) ) ; $ offset + = 2 ; $ highwater Mark Offset = self : : unpack ( self : : BIT _B 6 4 , substr ( $ data , $ offset , 8 ) ) ; $ offset + = 8 ; $ message Set Size = self : : unpack ( self : : BIT _B 3 2 , substr ( $ data , $ offset , 4 ) ) ; $ offset + = 4 ; $ messages = [ ] ; if ( $ message Set Size > 0 & & $ offset < strlen ( $ data ) ) { $ messages = $ this - > decode Message Set Array ( substr ( $ data , $ offset , $ message Set Size ) , $ message Set Size ) ; $ offset + = $ messages [ 'length ' ] ; } return [ 'length ' = > $ offset , 'data ' = > [ 'partition ' = > $ partition Id , 'error Code ' = > $ error Code , 'highwater Mark Offset ' = > $ highwater Mark Offset , 'message Set Size ' = > $ message Set Size , 'messages ' = > $ messages [ 'data ' ] ? ? [ ] , ] , ] ; } 
protected function decode Message Set Array ( string $ data , int $ message Set Size ) : array { $ offset = 0 ; $ result = [ ] ; while ( $ offset < strlen ( $ data ) ) { $ value = substr ( $ data , $ offset ) ; $ ret = $ this - > decode Message Set ( $ value ) ; if ( $ ret = = = null ) { break ; } if ( ! isset ( $ ret [ 'length ' ] , $ ret [ 'data ' ] ) ) { throw new Protocol Exception ( 'Decode array failed , given function return format is invalid ' ) ; } if ( ( int ) $ ret [ 'length ' ] = = = 0 ) { continue ; } $ offset + = $ ret [ 'length ' ] ; if ( ( $ ret [ 'data ' ] [ 'message ' ] [ 'attr ' ] & Produce : : COMPRESSION _CODEC _MASK ) = = = Produce : : COMPRESSION _NONE ) { $ result [ ] = $ ret [ 'data ' ] ; continue ; } $ inner Messages = $ this - > decode Message Set Array ( $ ret [ 'data ' ] [ 'message ' ] [ 'value ' ] , $ ret [ 'length ' ] ) ; $ result = array _merge ( $ result , $ inner Messages [ 'data ' ] ) ; } if ( $ offset < $ message Set Size ) { $ offset = $ message Set Size ; } return [ 'length ' = > $ offset , 'data ' = > $ result ] ; } 
protected function decode Message Set ( string $ data ) : ? array { if ( strlen ( $ data ) < = 1 2 ) { return null ; } $ offset = 0 ; $ roffset = self : : unpack ( self : : BIT _B 6 4 , substr ( $ data , $ offset , 8 ) ) ; $ offset + = 8 ; $ message Size = self : : unpack ( self : : BIT _B 3 2 , substr ( $ data , $ offset , 4 ) ) ; $ offset + = 4 ; $ ret = $ this - > decode Message ( substr ( $ data , $ offset ) , $ message Size ) ; if ( $ ret = = = null ) { return null ; } $ offset + = $ ret [ 'length ' ] ; return [ 'length ' = > $ offset , 'data ' = > [ 'offset ' = > $ roffset , 'size ' = > $ message Size , 'message ' = > $ ret [ 'data ' ] , ] , ] ; } 
protected function decode Message ( string $ data , int $ message Size ) : ? array { if ( $ message Size = = = 0 | | strlen ( $ data ) < $ message Size ) { return null ; } $ offset = 0 ; $ crc = self : : unpack ( self : : BIT _B 3 2 , substr ( $ data , $ offset , 4 ) ) ; $ offset + = 4 ; $ magic = self : : unpack ( self : : BIT _B 8 , substr ( $ data , $ offset , 1 ) ) ; + + $ offset ; $ attr = self : : unpack ( self : : BIT _B 8 , substr ( $ data , $ offset , 1 ) ) ; + + $ offset ; $ timestamp = 0 ; $ back Offset = $ offset ; try { 
protected function encode Fetch Partition ( array $ values ) : string { if ( ! isset ( $ values [ 'partition _id ' ] ) ) { throw new Protocol Exception ( 'given fetch data invalid . `partition _id ` is undefined . ' ) ; } if ( ! isset ( $ values [ 'offset ' ] ) ) { $ values [ 'offset ' ] = 0 ; } if ( ! isset ( $ values [ 'max _bytes ' ] ) ) { $ values [ 'max _bytes ' ] = 2 * 1 0 2 4 * 1 0 2 4 ; } $ data = self : : pack ( self : : BIT _B 3 2 , ( string ) $ values [ 'partition _id ' ] ) ; $ data . = self : : pack ( self : : BIT _B 6 4 , ( string ) $ values [ 'offset ' ] ) ; $ data . = self : : pack ( self : : BIT _B 3 2 , ( string ) $ values [ 'max _bytes ' ] ) ; return $ data ; } 
public function encode ( array $ payloads = [ ] ) : string { if ( ! isset ( $ payloads [ 'group _id ' ] ) ) { throw new Protocol Exception ( 'given join group data invalid . `group _id ` is undefined . ' ) ; } if ( ! isset ( $ payloads [ 'session _timeout ' ] ) ) { throw new Protocol Exception ( 'given join group data invalid . `session _timeout ` is undefined . ' ) ; } if ( ! isset ( $ payloads [ 'member _id ' ] ) ) { throw new Protocol Exception ( 'given join group data invalid . `member _id ` is undefined . ' ) ; } if ( ! isset ( $ payloads [ 'data ' ] ) ) { throw new Protocol Exception ( 'given join group data invalid . `data ` is undefined . ' ) ; } if ( ! isset ( $ payloads [ 'protocol _type ' ] ) ) { $ payloads [ 'protocol _type ' ] = 'consumer ' ; } if ( ! isset ( $ payloads [ 'rebalance _timeout ' ] ) ) { $ payloads [ 'rebalance _timeout ' ] = $ payloads [ 'session _timeout ' ] ; } $ header = $ this - > request Header ( 'kafka -php ' , self : : JOIN _GROUP _REQUEST , self : : JOIN _GROUP _REQUEST ) ; $ data = self : : encode String ( $ payloads [ 'group _id ' ] , self : : PACK _INT 1 6 ) ; $ data . = self : : pack ( self : : BIT _B 3 2 , ( string ) $ payloads [ 'session _timeout ' ] ) ; if ( $ this - > get Api Version ( self : : JOIN _GROUP _REQUEST ) = = = self : : API _VERSION 1 ) { $ data . = self : : pack ( self : : BIT _B 3 2 , ( string ) $ payloads [ 'rebalance _timeout ' ] ) ; } $ data . = self : : encode String ( $ payloads [ 'member _id ' ] , self : : PACK _INT 1 6 ) ; $ data . = self : : encode String ( $ payloads [ 'protocol _type ' ] , self : : PACK _INT 1 6 ) ; $ data . = self : : encode Array ( $ payloads [ 'data ' ] , [ $ this , 'encode Group Protocol ' ] ) ; $ data = self : : encode String ( $ header . $ data , self : : PACK _INT 3 2 ) ; return $ data ; } 
protected function encode Group Protocol ( array $ values ) : string { if ( ! isset ( $ values [ 'protocol _name ' ] ) ) { throw new Protocol Exception ( 'given join group data invalid . `protocol _name ` is undefined . ' ) ; } $ protocol Name = self : : encode String ( $ values [ 'protocol _name ' ] , self : : PACK _INT 1 6 ) ; if ( ! isset ( $ values [ 'version ' ] ) ) { throw new Protocol Exception ( 'given data invalid . `version ` is undefined . ' ) ; } if ( ! isset ( $ values [ 'subscription ' ] ) | | empty ( $ values [ 'subscription ' ] ) ) { throw new Protocol Exception ( 'given data invalid . `subscription ` is undefined . ' ) ; } if ( ! isset ( $ values [ 'user _data ' ] ) ) { $ values [ 'user _data ' ] = ' ' ; } $ data = self : : pack ( self : : BIT _B 1 6 , ' 0 ' ) ; $ data . = self : : encode Array ( $ values [ 'subscription ' ] , [ $ this , 'encode Group Protocol Meta Topic ' ] ) ; $ data . = self : : encode String ( $ values [ 'user _data ' ] , self : : PACK _INT 3 2 ) ; return $ protocol Name . self : : encode String ( $ data , self : : PACK _INT 3 2 ) ; } 
public function start ( ? callable $ consumer = null ) : void { if ( $ this - > process ! = = null ) { $ this - > error ( 'Consumer is already being executed ' ) ; return ; } $ this - > setup Stop Strategy ( ) ; $ this - > process = $ this - > create Process ( $ consumer ) ; $ this - > process - > start ( ) ; Loop : : run ( ) ; } 
protected function create Process ( ? callable $ consumer ) : Process { $ process = new Process ( $ consumer ) ; if ( $ this - > logger ) { $ process - > set Logger ( $ this - > logger ) ; } return $ process ; } 
protected function create Socket ( string $ remote Socket , $ context , ? int & $ errno , ? string & $ errstr ) { return stream _socket _client ( $ remote Socket , $ errno , $ errstr , $ this - > send Timeout Sec + ( $ this - > send Timeout Usec / 1 0 0 0 0 0 0 ) , STREAM _CLIENT _CONNECT , $ context ) ; } 
protected function select ( array $ sockets , int $ timeout Sec , int $ timeout Usec , bool $ is Read = true ) { $ null = null ; if ( $ is Read ) { return @ stream _select ( $ sockets , $ null , $ null , $ timeout Sec , $ timeout Usec ) ; } return @ stream _select ( $ null , $ sockets , $ null , $ timeout Sec , $ timeout Usec ) ; } 
public function read Blocking ( int $ length ) : string { if ( $ length > self : : READ _MAX _LENGTH ) { throw Exception \ Socket : : invalid Length ( $ length , self : : READ _MAX _LENGTH ) ; } $ readable = $ this - > select ( [ $ this - > stream ] , $ this - > recv Timeout Sec , $ this - > recv Timeout Usec ) ; if ( $ readable = = = false ) { $ this - > close ( ) ; throw Exception \ Socket : : not Readable ( $ length ) ; } if ( $ readable = = = 0 ) { 
public function write Blocking ( string $ buffer ) : int { 
public function encode ( array $ payloads = [ ] ) : string { foreach ( $ payloads as $ topic ) { if ( ! is _string ( $ topic ) ) { throw new Protocol Exception ( 'request metadata topic array have invalid value . ' ) ; } } $ header = $ this - > request Header ( 'kafka -php ' , self : : METADATA _REQUEST , self : : METADATA _REQUEST ) ; $ data = self : : encode Array ( $ payloads , [ $ this , 'encode String ' ] , self : : PACK _INT 1 6 ) ; $ data = self : : encode String ( $ header . $ data , self : : PACK _INT 3 2 ) ; return $ data ; } 
public function encode ( array $ payloads = [ ] ) : string { if ( ! isset ( $ payloads [ 'group _id ' ] ) ) { throw new Protocol Exception ( 'given group coordinator invalid . `group _id ` is undefined . ' ) ; } $ header = $ this - > request Header ( 'kafka -php ' , self : : GROUP _COORDINATOR _REQUEST , self : : GROUP _COORDINATOR _REQUEST ) ; $ data = self : : encode String ( $ payloads [ 'group _id ' ] , self : : PACK _INT 1 6 ) ; $ data = self : : encode String ( $ header . $ data , self : : PACK _INT 3 2 ) ; return $ data ; } 
protected function encode Group Assignment ( array $ values ) : string { if ( ! isset ( $ values [ 'version ' ] ) ) { throw new Protocol Exception ( 'given data invalid . `version ` is undefined . ' ) ; } if ( ! isset ( $ values [ 'member _id ' ] ) ) { throw new Protocol Exception ( 'given data invalid . `member _id ` is undefined . ' ) ; } if ( ! isset ( $ values [ 'assignments ' ] ) ) { throw new Protocol Exception ( 'given data invalid . `assignments ` is undefined . ' ) ; } if ( ! isset ( $ values [ 'user _data ' ] ) ) { $ values [ 'user _data ' ] = ' ' ; } $ member Id = self : : encode String ( $ values [ 'member _id ' ] , self : : PACK _INT 1 6 ) ; $ data = self : : pack ( self : : BIT _B 1 6 , ' 0 ' ) ; $ data . = self : : encode Array ( $ values [ 'assignments ' ] , [ $ this , 'encode Group Assignment Topic ' ] ) ; $ data . = self : : encode String ( $ values [ 'user _data ' ] , self : : PACK _INT 3 2 ) ; return $ member Id . self : : encode String ( $ data , self : : PACK _INT 3 2 ) ; } 
protected function encode Group Assignment Topic ( array $ values ) : string { if ( ! isset ( $ values [ 'topic _name ' ] ) ) { throw new Protocol Exception ( 'given data invalid . `topic _name ` is undefined . ' ) ; } if ( ! isset ( $ values [ 'partitions ' ] ) ) { throw new Protocol Exception ( 'given data invalid . `partitions ` is undefined . ' ) ; } $ topic Name = self : : encode String ( $ values [ 'topic _name ' ] , self : : PACK _INT 1 6 ) ; $ partitions = self : : encode Array ( $ values [ 'partitions ' ] , [ $ this , 'encode Group Assignment Topic Partition ' ] ) ; return $ topic Name . $ partitions ; } 
public static function unpack ( string $ type , string $ bytes ) { self : : check Len ( $ type , $ bytes ) ; if ( $ type = = = self : : BIT _B 6 4 ) { $ set = unpack ( $ type , $ bytes ) ; $ result = ( $ set [ 1 ] & 0x FFFFFFFF ) < < 3 2 | ( $ set [ 2 ] & 0x FFFFFFFF ) ; } elseif ( $ type = = = self : : BIT _B 1 6 _SIGNED ) { 
protected static function check Len ( string $ type , string $ bytes ) : void { $ expected Length = 0 ; switch ( $ type ) { case self : : BIT _B 6 4 : $ expected Length = 8 ; break ; case self : : BIT _B 3 2 : $ expected Length = 4 ; break ; case self : : BIT _B 1 6 : $ expected Length = 2 ; break ; case self : : BIT _B 1 6 _SIGNED : $ expected Length = 2 ; break ; case self : : BIT _B 8 : $ expected Length = 1 ; break ; } $ length = strlen ( $ bytes ) ; if ( $ length ! = = $ expected Length ) { throw new Protocol Exception ( 'unpack failed . string (raw ) length is ' . $ length . ' , TO ' . $ type ) ; } } 
public static function is System Little Endian ( ) : bool { 
public static function convert Signed Short From Little Endian To Big Endian ( array $ bits ) : array { $ convert = function ( int $ bit ) : int { $ lsb = $ bit & 0xff ; $ msb = $ bit > > 8 & 0xff ; $ bit = $ lsb < < 8 | $ msb ; if ( $ bit > = 3 2 7 6 8 ) { $ bit - = 6 5 5 3 6 ; } return $ bit ; } ; return array _map ( $ convert , $ bits ) ; } 
public function get Api Version ( int $ apikey ) : int { switch ( $ apikey ) { case self : : METADATA _REQUEST : return self : : API _VERSION 0 ; case self : : PRODUCE _REQUEST : if ( version _compare ( $ this - > version , ' 0 . 1 0 . 0 ' ) > = 0 ) { return self : : API _VERSION 2 ; } if ( version _compare ( $ this - > version , ' 0 . 9 . 0 ' ) > = 0 ) { return self : : API _VERSION 1 ; } return self : : API _VERSION 0 ; case self : : FETCH _REQUEST : if ( version _compare ( $ this - > version , ' 0 . 1 0 . 0 ' ) > = 0 ) { return self : : API _VERSION 2 ; } if ( version _compare ( $ this - > version , ' 0 . 9 . 0 ' ) > = 0 ) { return self : : API _VERSION 1 ; } return self : : API _VERSION 0 ; case self : : OFFSET _REQUEST : 
public static function get Api Text ( int $ apikey ) : string { $ apis = [ self : : PRODUCE _REQUEST = > 'Produce Request ' , self : : FETCH _REQUEST = > 'Fetch Request ' , self : : OFFSET _REQUEST = > 'Offset Request ' , self : : METADATA _REQUEST = > 'Metadata Request ' , self : : OFFSET _COMMIT _REQUEST = > 'Offset Commit Request ' , self : : OFFSET _FETCH _REQUEST = > 'Offset Fetch Request ' , self : : GROUP _COORDINATOR _REQUEST = > 'Group Coordinator Request ' , self : : JOIN _GROUP _REQUEST = > 'Join Group Request ' , self : : HEART _BEAT _REQUEST = > 'Heartbeat Request ' , self : : LEAVE _GROUP _REQUEST = > 'Leave Group Request ' , self : : SYNC _GROUP _REQUEST = > 'Sync Group Request ' , self : : DESCRIBE _GROUPS _REQUEST = > 'Describe Groups Request ' , self : : LIST _GROUPS _REQUEST = > 'List Groups Request ' , self : : SASL _HAND _SHAKE _REQUEST = > 'Sasl Hand Shake Request ' , self : : API _VERSIONS _REQUEST = > 'Api Versions Request ' , ] ; return $ apis [ $ apikey ] ? ? 'Unknown message ' ; } 
public function decode String ( string $ data , string $ bytes , int $ compression = self : : COMPRESSION _NONE ) : array { $ offset = $ bytes = = = self : : BIT _B 3 2 ? 4 : 2 ; $ pack Len = self : : unpack ( $ bytes , substr ( $ data , 0 , $ offset ) ) ; 
public function decode Array ( string $ data , callable $ func , $ options = null ) : array { $ offset = 0 ; $ array Count = self : : unpack ( self : : BIT _B 3 2 , substr ( $ data , $ offset , 4 ) ) ; $ offset + = 4 ; $ result = [ ] ; for ( $ i = 0 ; $ i < $ array Count ; $ i + + ) { $ value = substr ( $ data , $ offset ) ; $ ret = $ options ! = = null ? $ func ( $ value , $ options ) : $ func ( $ value ) ; if ( ! is _array ( $ ret ) & & $ ret = = = false ) { break ; } if ( ! isset ( $ ret [ 'length ' ] , $ ret [ 'data ' ] ) ) { throw new Protocol Exception ( 'Decode array failed , given function return format is invalid ' ) ; } if ( ( int ) $ ret [ 'length ' ] = = = 0 ) { continue ; } $ offset + = $ ret [ 'length ' ] ; $ result [ ] = $ ret [ 'data ' ] ; } return [ 'length ' = > $ offset , 'data ' = > $ result ] ; } 
public function decode Primitive Array ( string $ data , string $ bit ) : array { $ offset = 0 ; $ array Count = self : : unpack ( self : : BIT _B 3 2 , substr ( $ data , $ offset , 4 ) ) ; $ offset + = 4 ; if ( $ array Count = = = 4 2 9 4 9 6 7 2 9 5 ) { $ array Count = 0 ; } $ result = [ ] ; for ( $ i = 0 ; $ i < $ array Count ; $ i + + ) { if ( $ bit = = = self : : BIT _B 6 4 ) { $ result [ ] = self : : unpack ( self : : BIT _B 6 4 , substr ( $ data , $ offset , 8 ) ) ; $ offset + = 8 ; } elseif ( $ bit = = = self : : BIT _B 3 2 ) { $ result [ ] = self : : unpack ( self : : BIT _B 3 2 , substr ( $ data , $ offset , 4 ) ) ; $ offset + = 4 ; } elseif ( in _array ( $ bit , [ self : : BIT _B 1 6 , self : : BIT _B 1 6 _SIGNED ] , true ) ) { $ result [ ] = self : : unpack ( $ bit , substr ( $ data , $ offset , 2 ) ) ; $ offset + = 2 ; } elseif ( $ bit = = = self : : BIT _B 8 ) { $ result [ ] = self : : unpack ( $ bit , substr ( $ data , $ offset , 1 ) ) ; + + $ offset ; } } return [ 'length ' = > $ offset , 'data ' = > $ result ] ; } 
public function encode ( array $ payloads = [ ] ) : string { if ( ! isset ( $ payloads [ 'group _id ' ] ) ) { throw new Protocol Exception ( 'given commit offset data invalid . `group _id ` is undefined . ' ) ; } if ( ! isset ( $ payloads [ 'data ' ] ) ) { throw new Protocol Exception ( 'given commit data invalid . `data ` is undefined . ' ) ; } if ( ! isset ( $ payloads [ 'generation _id ' ] ) ) { $ payloads [ 'generation _id ' ] = - 1 ; } if ( ! isset ( $ payloads [ 'member _id ' ] ) ) { $ payloads [ 'member _id ' ] = ' ' ; } if ( ! isset ( $ payloads [ 'retention _time ' ] ) ) { $ payloads [ 'retention _time ' ] = - 1 ; } $ version = $ this - > get Api Version ( self : : OFFSET _COMMIT _REQUEST ) ; $ header = $ this - > request Header ( 'kafka -php ' , self : : OFFSET _COMMIT _REQUEST , self : : OFFSET _COMMIT _REQUEST ) ; $ data = self : : encode String ( $ payloads [ 'group _id ' ] , self : : PACK _INT 1 6 ) ; if ( $ version = = = self : : API _VERSION 1 ) { $ data . = self : : pack ( self : : BIT _B 3 2 , ( string ) $ payloads [ 'generation _id ' ] ) ; $ data . = self : : encode String ( $ payloads [ 'member _id ' ] , self : : PACK _INT 1 6 ) ; } if ( $ version = = = self : : API _VERSION 2 ) { $ data . = self : : pack ( self : : BIT _B 3 2 , ( string ) $ payloads [ 'generation _id ' ] ) ; $ data . = self : : encode String ( $ payloads [ 'member _id ' ] , self : : PACK _INT 1 6 ) ; $ data . = self : : pack ( self : : BIT _B 6 4 , ( string ) $ payloads [ 'retention _time ' ] ) ; } $ data . = self : : encode Array ( $ payloads [ 'data ' ] , [ $ this , 'encode Topic ' ] ) ; $ data = self : : encode String ( $ header . $ data , self : : PACK _INT 3 2 ) ; return $ data ; } 
protected function encode Topic ( array $ values ) : string { if ( ! isset ( $ values [ 'topic _name ' ] ) ) { throw new Protocol Exception ( 'given commit offset data invalid . `topic _name ` is undefined . ' ) ; } if ( ! isset ( $ values [ 'partitions ' ] ) ) { throw new Protocol Exception ( 'given commit offset data invalid . `partitions ` is undefined . ' ) ; } $ data = self : : encode String ( $ values [ 'topic _name ' ] , self : : PACK _INT 1 6 ) ; $ data . = self : : encode Array ( $ values [ 'partitions ' ] , [ $ this , 'encode Partition ' ] ) ; return $ data ; } 
protected function encode Partition ( array $ values ) : string { if ( ! isset ( $ values [ 'partition ' ] ) ) { throw new Protocol Exception ( 'given commit offset data invalid . `partition ` is undefined . ' ) ; } if ( ! isset ( $ values [ 'offset ' ] ) ) { throw new Protocol Exception ( 'given commit offset data invalid . `offset ` is undefined . ' ) ; } if ( ! isset ( $ values [ 'metadata ' ] ) ) { $ values [ 'metadata ' ] = ' ' ; } if ( ! isset ( $ values [ 'timestamp ' ] ) ) { $ values [ 'timestamp ' ] = time ( ) * 1 0 0 0 ; } $ version = $ this - > get Api Version ( self : : OFFSET _COMMIT _REQUEST ) ; $ data = self : : pack ( self : : BIT _B 3 2 , ( string ) $ values [ 'partition ' ] ) ; $ data . = self : : pack ( self : : BIT _B 6 4 , ( string ) $ values [ 'offset ' ] ) ; if ( $ version = = = self : : API _VERSION 1 ) { $ data . = self : : pack ( self : : BIT _B 6 4 , ( string ) $ values [ 'timestamp ' ] ) ; } $ data . = self : : encode String ( $ values [ 'metadata ' ] , self : : PACK _INT 1 6 ) ; return $ data ; } 
public function encode ( array $ payloads = [ ] ) : string { $ mechanism = array _shift ( $ payloads ) ; if ( ! is _string ( $ mechanism ) ) { throw new Protocol Exception ( 'Invalid request SASL hand shake mechanism given . ' ) ; } if ( ! in _array ( $ mechanism , self : : ALLOW _SASL _MECHANISMS , true ) ) { throw new Protocol Exception ( 'Invalid request SASL hand shake mechanism given , it must be one of : ' . implode ( ' | ' , self : : ALLOW _SASL _MECHANISMS ) ) ; } $ header = $ this - > request Header ( 'kafka -php ' , self : : SASL _HAND _SHAKE _REQUEST , self : : SASL _HAND _SHAKE _REQUEST ) ; $ data = self : : encode String ( $ mechanism , self : : PACK _INT 1 6 ) ; $ data = self : : encode String ( $ header . $ data , self : : PACK _INT 3 2 ) ; return $ data ; } 
public function before ( $ methods , $ pattern , $ fn ) { $ pattern = $ this - > base Route . ' / ' . trim ( $ pattern , ' / ' ) ; $ pattern = $ this - > base Route ? rtrim ( $ pattern , ' / ' ) : $ pattern ; foreach ( explode ( ' | ' , $ methods ) as $ method ) { $ this - > before Routes [ $ method ] [ ] = [ 'pattern ' = > $ pattern , 'fn ' = > $ fn , ] ; } } 
public function match ( $ methods , $ pattern , $ fn ) { $ pattern = $ this - > base Route . ' / ' . trim ( $ pattern , ' / ' ) ; $ pattern = $ this - > base Route ? rtrim ( $ pattern , ' / ' ) : $ pattern ; foreach ( explode ( ' | ' , $ methods ) as $ method ) { $ this - > after Routes [ $ method ] [ ] = [ 'pattern ' = > $ pattern , 'fn ' = > $ fn , ] ; } } 
public function mount ( $ base Route , $ fn ) { 
public function get Request Method ( ) { 
public function run ( $ callback = null ) { 
public function get Base Path ( ) { 
public function map ( $ pattern , $ callback , $ pass _route = false ) { $ url = $ pattern ; $ methods = array ( ' * ' ) ; if ( strpos ( $ pattern , ' ' ) ! = = false ) { list ( $ method , $ url ) = explode ( ' ' , trim ( $ pattern ) , 2 ) ; $ methods = explode ( ' | ' , $ method ) ; } $ this - > routes [ ] = new Route ( $ url , $ callback , $ methods , $ pass _route ) ; } 
public function route ( Request $ request ) { $ url _decoded = urldecode ( $ request - > url ) ; while ( $ route = $ this - > current ( ) ) { if ( $ route ! = = false & & $ route - > match Method ( $ request - > method ) & & $ route - > match Url ( $ url _decoded , $ this - > case _sensitive ) ) { return $ route ; } $ this - > next ( ) ; } return false ; } 
public function current ( ) { return isset ( $ this - > routes [ $ this - > index ] ) ? $ this - > routes [ $ this - > index ] : false ; } 
public function match Url ( $ url , $ case _sensitive = false ) { 
public function run ( $ name , array $ params = array ( ) ) { $ output = ' ' ; 
public function get ( $ name ) { return isset ( $ this - > events [ $ name ] ) ? $ this - > events [ $ name ] : null ; } 
public function clear ( $ name = null ) { if ( $ name ! = = null ) { unset ( $ this - > events [ $ name ] ) ; unset ( $ this - > filters [ $ name ] ) ; } else { $ this - > events = array ( ) ; $ this - > filters = array ( ) ; } } 
public function filter ( $ filters , & $ params , & $ output ) { $ args = array ( & $ params , & $ output ) ; foreach ( $ filters as $ callback ) { $ continue = $ this - > execute ( $ callback , $ args ) ; if ( $ continue = = = false ) break ; } } 
public static function execute ( $ callback , array & $ params = array ( ) ) { if ( is _callable ( $ callback ) ) { return is _array ( $ callback ) ? self : : invoke Method ( $ callback , $ params ) : self : : call Function ( $ callback , $ params ) ; } else { throw new \ Exception ( 'Invalid callback specified . ' ) ; } } 
public static function call Function ( $ func , array & $ params = array ( ) ) { 
public static function invoke Method ( $ func , array & $ params = array ( ) ) { list ( $ class , $ method ) = $ func ; $ instance = is _object ( $ class ) ; switch ( count ( $ params ) ) { case 0 : return ( $ instance ) ? $ class - > $ method ( ) : $ class : : $ method ( ) ; case 1 : return ( $ instance ) ? $ class - > $ method ( $ params [ 0 ] ) : $ class : : $ method ( $ params [ 0 ] ) ; case 2 : return ( $ instance ) ? $ class - > $ method ( $ params [ 0 ] , $ params [ 1 ] ) : $ class : : $ method ( $ params [ 0 ] , $ params [ 1 ] ) ; case 3 : return ( $ instance ) ? $ class - > $ method ( $ params [ 0 ] , $ params [ 1 ] , $ params [ 2 ] ) : $ class : : $ method ( $ params [ 0 ] , $ params [ 1 ] , $ params [ 2 ] ) ; case 4 : return ( $ instance ) ? $ class - > $ method ( $ params [ 0 ] , $ params [ 1 ] , $ params [ 2 ] , $ params [ 3 ] ) : $ class : : $ method ( $ params [ 0 ] , $ params [ 1 ] , $ params [ 2 ] , $ params [ 3 ] ) ; case 5 : return ( $ instance ) ? $ class - > $ method ( $ params [ 0 ] , $ params [ 1 ] , $ params [ 2 ] , $ params [ 3 ] , $ params [ 4 ] ) : $ class : : $ method ( $ params [ 0 ] , $ params [ 1 ] , $ params [ 2 ] , $ params [ 3 ] , $ params [ 4 ] ) ; default : return call _user _func _array ( $ func , $ params ) ; } } 
public function init ( $ properties = array ( ) ) { 
public static function get Body ( ) { static $ body ; if ( ! is _null ( $ body ) ) { return $ body ; } $ method = self : : get Method ( ) ; if ( $ method = = 'POST ' | | $ method = = 'PUT ' | | $ method = = 'PATCH ' ) { $ body = file _get _contents ( 'php : / /input ' ) ; } return $ body ; } 
public static function get Method ( ) { $ method = self : : get Var ( 'REQUEST _METHOD ' , 'GET ' ) ; if ( isset ( $ _SERVER [ 'HTTP _X _HTTP _METHOD _OVERRIDE ' ] ) ) { $ method = $ _SERVER [ 'HTTP _X _HTTP _METHOD _OVERRIDE ' ] ; } elseif ( isset ( $ _REQUEST [ ' _method ' ] ) ) { $ method = $ _REQUEST [ ' _method ' ] ; } return strtoupper ( $ method ) ; } 
public static function get Proxy Ip Address ( ) { static $ forwarded = array ( 'HTTP _CLIENT _IP ' , 'HTTP _X _FORWARDED _FOR ' , 'HTTP _X _FORWARDED ' , 'HTTP _X _CLUSTER _CLIENT _IP ' , 'HTTP _FORWARDED _FOR ' , 'HTTP _FORWARDED ' ) ; $ flags = \ FILTER _FLAG _NO _PRIV _RANGE | \ FILTER _FLAG _NO _RES _RANGE ; foreach ( $ forwarded as $ key ) { if ( array _key _exists ( $ key , $ _SERVER ) ) { sscanf ( $ _SERVER [ $ key ] , ' % [ ^ , ] ' , $ ip ) ; if ( filter _var ( $ ip , \ FILTER _VALIDATE _IP , $ flags ) ! = = false ) { return $ ip ; } } } return ' ' ; } 
public static function parse Query ( $ url ) { $ params = array ( ) ; $ args = parse _url ( $ url ) ; if ( isset ( $ args [ 'query ' ] ) ) { parse _str ( $ args [ 'query ' ] , $ params ) ; } return $ params ; } 
public function status ( $ code = null ) { if ( $ code = = = null ) { return $ this - > status ; } if ( array _key _exists ( $ code , self : : $ codes ) ) { $ this - > status = $ code ; } else { throw new \ Exception ( 'Invalid status code . ' ) ; } return $ this ; } 
public function header ( $ name , $ value = null ) { if ( is _array ( $ name ) ) { foreach ( $ name as $ k = > $ v ) { $ this - > headers [ $ k ] = $ v ; } } else { $ this - > headers [ $ name ] = $ value ; } return $ this ; } 
public function cache ( $ expires ) { if ( $ expires = = = false ) { $ this - > headers [ 'Expires ' ] = 'Mon , 2 6 Jul 1 9 9 7 0 5 : 0 0 : 0 0 GMT ' ; $ this - > headers [ 'Cache -Control ' ] = array ( 'no -store , no -cache , must -revalidate ' , 'post -check = 0 , pre -check = 0 ' , 'max -age = 0 ' ) ; $ this - > headers [ 'Pragma ' ] = 'no -cache ' ; } else { $ expires = is _int ( $ expires ) ? $ expires : strtotime ( $ expires ) ; $ this - > headers [ 'Expires ' ] = gmdate ( 'D , d M Y H :i :s ' , $ expires ) . ' GMT ' ; $ this - > headers [ 'Cache -Control ' ] = 'max -age = ' . ( $ expires - time ( ) ) ; if ( isset ( $ this - > headers [ 'Pragma ' ] ) & & $ this - > headers [ 'Pragma ' ] = = 'no -cache ' ) { unset ( $ this - > headers [ 'Pragma ' ] ) ; } } return $ this ; } 
public function send Headers ( ) { 
public function send ( ) { if ( ob _get _length ( ) > 0 ) { ob _end _clean ( ) ; } if ( ! headers _sent ( ) ) { $ this - > send Headers ( ) ; } echo $ this - > body ; $ this - > sent = true ; } 
public function init ( ) { static $ initialized = false ; $ self = $ this ; if ( $ initialized ) { $ this - > vars = array ( ) ; $ this - > loader - > reset ( ) ; $ this - > dispatcher - > reset ( ) ; } 
public function handle Error ( $ errno , $ errstr , $ errfile , $ errline ) { if ( $ errno & error _reporting ( ) ) { throw new \ Error Exception ( $ errstr , $ errno , 0 , $ errfile , $ errline ) ; } } 
public function handle Exception ( $ e ) { if ( $ this - > get ( 'flight .log _errors ' ) ) { error _log ( $ e - > get Message ( ) ) ; } $ this - > error ( $ e ) ; } 
public function map ( $ name , $ callback ) { if ( method _exists ( $ this , $ name ) ) { throw new \ Exception ( 'Cannot override an existing framework method . ' ) ; } $ this - > dispatcher - > set ( $ name , $ callback ) ; } 
public function register ( $ name , $ class , array $ params = array ( ) , $ callback = null ) { if ( method _exists ( $ this , $ name ) ) { throw new \ Exception ( 'Cannot override an existing framework method . ' ) ; } $ this - > loader - > register ( $ name , $ class , $ params , $ callback ) ; } 
public function get ( $ key = null ) { if ( $ key = = = null ) return $ this - > vars ; return isset ( $ this - > vars [ $ key ] ) ? $ this - > vars [ $ key ] : null ; } 
public function clear ( $ key = null ) { if ( is _null ( $ key ) ) { $ this - > vars = array ( ) ; } else { unset ( $ this - > vars [ $ key ] ) ; } } 
public function _start ( ) { $ dispatched = false ; $ self = $ this ; $ request = $ this - > request ( ) ; $ response = $ this - > response ( ) ; $ router = $ this - > router ( ) ; 
public function _stop ( $ code = null ) { $ response = $ this - > response ( ) ; if ( ! $ response - > sent ( ) ) { if ( $ code ! = = null ) { $ response - > status ( $ code ) ; } $ response - > write ( ob _get _clean ( ) ) ; $ response - > send ( ) ; } } 
public function _route ( $ pattern , $ callback , $ pass _route = false ) { $ this - > router ( ) - > map ( $ pattern , $ callback , $ pass _route ) ; } 
public function _halt ( $ code = 2 0 0 , $ message = ' ' ) { $ this - > response ( ) - > clear ( ) - > status ( $ code ) - > write ( $ message ) - > send ( ) ; exit ( ) ; } 
public function _error ( $ e ) { $ msg = sprintf ( ' <h 1 > 5 0 0 Internal Server Error < /h 1 > ' . ' <h 3 > %s ( %s ) < /h 3 > ' . ' <pre > %s < /pre > ' , $ e - > get Message ( ) , $ e - > get Code ( ) , $ e - > get Trace As String ( ) ) ; try { $ this - > response ( ) - > clear ( ) - > status ( 5 0 0 ) - > write ( $ msg ) - > send ( ) ; } catch ( \ Throwable $ t ) { 
public function _redirect ( $ url , $ code = 3 0 3 ) { $ base = $ this - > get ( 'flight .base _url ' ) ; if ( $ base = = = null ) { $ base = $ this - > request ( ) - > base ; } 
public function _render ( $ file , $ data = null , $ key = null ) { if ( $ key ! = = null ) { $ this - > view ( ) - > set ( $ key , $ this - > view ( ) - > fetch ( $ file , $ data ) ) ; } else { $ this - > view ( ) - > render ( $ file , $ data ) ; } } 
public function _json ( $ data , $ code = 2 0 0 , $ encode = true , $ charset = 'utf - 8 ' , $ option = 0 ) { $ json = ( $ encode ) ? json _encode ( $ data , $ option ) : $ data ; $ this - > response ( ) - > status ( $ code ) - > header ( 'Content -Type ' , 'application /json ; charset = ' . $ charset ) - > write ( $ json ) - > send ( ) ; } 
public function _jsonp ( $ data , $ param = 'jsonp ' , $ code = 2 0 0 , $ encode = true , $ charset = 'utf - 8 ' , $ option = 0 ) { $ json = ( $ encode ) ? json _encode ( $ data , $ option ) : $ data ; $ callback = $ this - > request ( ) - > query [ $ param ] ; $ this - > response ( ) - > status ( $ code ) - > header ( 'Content -Type ' , 'application /javascript ; charset = ' . $ charset ) - > write ( $ callback . ' ( ' . $ json . ' ) ; ' ) - > send ( ) ; } 
public function _etag ( $ id , $ type = 'strong ' ) { $ id = ( ( $ type = = = 'weak ' ) ? 'W / ' : ' ' ) . $ id ; $ this - > response ( ) - > header ( 'ETag ' , $ id ) ; if ( isset ( $ _SERVER [ 'HTTP _IF _NONE _MATCH ' ] ) & & $ _SERVER [ 'HTTP _IF _NONE _MATCH ' ] = = = $ id ) { $ this - > halt ( 3 0 4 ) ; } } 
public function _last Modified ( $ time ) { $ this - > response ( ) - > header ( 'Last -Modified ' , gmdate ( 'D , d M Y H :i :s \G \M \T ' , $ time ) ) ; if ( isset ( $ _SERVER [ 'HTTP _IF _MODIFIED _SINCE ' ] ) & & strtotime ( $ _SERVER [ 'HTTP _IF _MODIFIED _SINCE ' ] ) = = = $ time ) { $ this - > halt ( 3 0 4 ) ; } } 
public function register ( $ name , $ class , array $ params = array ( ) , $ callback = null ) { unset ( $ this - > instances [ $ name ] ) ; $ this - > classes [ $ name ] = array ( $ class , $ params , $ callback ) ; } 
public function load ( $ name , $ shared = true ) { $ obj = null ; if ( isset ( $ this - > classes [ $ name ] ) ) { list ( $ class , $ params , $ callback ) = $ this - > classes [ $ name ] ; $ exists = isset ( $ this - > instances [ $ name ] ) ; if ( $ shared ) { $ obj = ( $ exists ) ? $ this - > get Instance ( $ name ) : $ this - > new Instance ( $ class , $ params ) ; if ( ! $ exists ) { $ this - > instances [ $ name ] = $ obj ; } } else { $ obj = $ this - > new Instance ( $ class , $ params ) ; } if ( $ callback & & ( ! $ shared | | ! $ exists ) ) { $ ref = array ( & $ obj ) ; call _user _func _array ( $ callback , $ ref ) ; } } return $ obj ; } 
public function get Instance ( $ name ) { return isset ( $ this - > instances [ $ name ] ) ? $ this - > instances [ $ name ] : null ; } 
public function new Instance ( $ class , array $ params = array ( ) ) { if ( is _callable ( $ class ) ) { return call _user _func _array ( $ class , $ params ) ; } switch ( count ( $ params ) ) { case 0 : return new $ class ( ) ; case 1 : return new $ class ( $ params [ 0 ] ) ; case 2 : return new $ class ( $ params [ 0 ] , $ params [ 1 ] ) ; case 3 : return new $ class ( $ params [ 0 ] , $ params [ 1 ] , $ params [ 2 ] ) ; case 4 : return new $ class ( $ params [ 0 ] , $ params [ 1 ] , $ params [ 2 ] , $ params [ 3 ] ) ; case 5 : return new $ class ( $ params [ 0 ] , $ params [ 1 ] , $ params [ 2 ] , $ params [ 3 ] , $ params [ 4 ] ) ; default : try { $ ref Class = new \ Reflection Class ( $ class ) ; return $ ref Class - > new Instance Args ( $ params ) ; } catch ( \ Reflection Exception $ e ) { throw new \ Exception ( "Cannot instantiate { $class } " , 0 , $ e ) ; } } } 
public static function autoload ( $ enabled = true , $ dirs = array ( ) ) { if ( $ enabled ) { spl _autoload _register ( array ( _ _CLASS _ _ , 'load Class ' ) ) ; } else { spl _autoload _unregister ( array ( _ _CLASS _ _ , 'load Class ' ) ) ; } if ( ! empty ( $ dirs ) ) { self : : add Directory ( $ dirs ) ; } } 
public static function load Class ( $ class ) { $ class _file = str _replace ( array ( ' \ \ ' , ' _ ' ) , ' / ' , $ class ) . ' .php ' ; foreach ( self : : $ dirs as $ dir ) { $ file = $ dir . ' / ' . $ class _file ; if ( file _exists ( $ file ) ) { require $ file ; return ; } } } 
public static function add Directory ( $ dir ) { if ( is _array ( $ dir ) | | is _object ( $ dir ) ) { foreach ( $ dir as $ value ) { self : : add Directory ( $ value ) ; } } else if ( is _string ( $ dir ) ) { if ( ! in _array ( $ dir , self : : $ dirs ) ) self : : $ dirs [ ] = $ dir ; } } 
public function render ( $ file , $ data = null ) { $ this - > template = $ this - > get Template ( $ file ) ; if ( ! file _exists ( $ this - > template ) ) { throw new \ Exception ( "Template file not found : { $this - >template } . " ) ; } if ( is _array ( $ data ) ) { $ this - > vars = array _merge ( $ this - > vars , $ data ) ; } extract ( $ this - > vars ) ; include $ this - > template ; } 
public function fetch ( $ file , $ data = null ) { ob _start ( ) ; $ this - > render ( $ file , $ data ) ; $ output = ob _get _clean ( ) ; return $ output ; } 
public function get Template ( $ file ) { $ ext = $ this - > extension ; if ( ! empty ( $ ext ) & & ( substr ( $ file , - 1 * strlen ( $ ext ) ) ! = $ ext ) ) { $ file . = $ ext ; } if ( ( substr ( $ file , 0 , 1 ) = = ' / ' ) ) { return $ file ; } return $ this - > path . ' / ' . $ file ; } 
public function run ( $ files ) { 
public function is Cyclic ( Graph $ graph ) { 
public function get Depth Of Node ( Node $ node ) { $ edges = $ node - > get Edges ( ) ; if ( 0 = = = sizeof ( $ edges ) ) { return 0 ; } 
public function get Number Of Childs ( Node $ node , $ uniqs = false ) { $ edges = $ node - > get Edges ( ) ; if ( 0 = = = sizeof ( $ edges ) ) { return 0 ; } 
public function get Average Height Of Graph ( ) { $ ns = [ ] ; foreach ( $ this - > graph - > get Root Nodes ( ) as $ node ) { array _push ( $ ns , $ this - > get Longest Branch ( $ node ) ) ; } return round ( array _sum ( $ ns ) / max ( 1 , sizeof ( $ ns ) ) , 2 ) ; } 
public function add Edge ( Node $ from , Node $ to ) { $ key = $ from - > get Unique Id ( ) . ' - > ' . $ to - > get Unique Id ( ) ; if ( isset ( $ this - > edges Map [ $ key ] ) ) { return $ this ; } $ this - > edges Map [ $ key ] = true ; return parent : : add Edge ( $ from , $ to ) ; } 
public function read ( Config $ config ) { $ json Text = file _get _contents ( $ this - > filename ) ; if ( false = = = $ json Text ) { throw new \ Invalid Argument Exception ( "Cannot read configuration file ' { $this - >filename } ' " ) ; } $ json Data = json _decode ( $ json Text , true ) ; if ( false = = = $ json Data ) { throw new \ Invalid Argument Exception ( "Bad json file ' { $this - >filename } ' " ) ; } $ json Data Imploded = $ this - > collapse Array ( $ json Data ) ; foreach ( $ json Data Imploded as $ key = > $ value ) { $ config - > set ( $ key , $ value ) ; } } 
private function collapse Array ( array $ arr ) { $ iterator = new Recursive Iterator Iterator ( new Recursive Array Iterator ( $ arr ) ) ; $ result = [ ] ; foreach ( $ iterator as $ leaf Value ) { $ keys = [ ] ; foreach ( range ( 0 , $ iterator - > get Depth ( ) ) as $ depth ) { $ keys [ ] = $ iterator - > get Sub Iterator ( $ depth ) - > key ( ) ; } $ result [ join ( ' - ' , $ keys ) ] = $ leaf Value ; } return $ result ; } 
public function fetch ( array $ paths ) { $ files = array ( ) ; foreach ( $ paths as $ path ) { if ( is _dir ( $ path ) ) { $ path = rtrim ( $ path , DIRECTORY _SEPARATOR ) . DIRECTORY _SEPARATOR ; $ directory = new Recursive Directory Iterator ( $ path , $ this - > flags ) ; $ iterator = new Recursive Iterator Iterator ( $ directory ) ; $ filter Regex = sprintf ( ' ` ^ %s %s %s $ ` ' , preg _quote ( $ path , ' ` ' ) , ! empty ( $ this - > excluded Dirs ) ? ' ( ( ? ! ' . implode ( ' | ' , array _map ( 'preg _quote ' , $ this - > excluded Dirs ) ) . ' ) . ) + ' : ' . + ' , ' \ . ( ' . implode ( ' | ' , $ this - > extensions ) . ' ) ' ) ; $ filtered Iterator = new Regex Iterator ( $ iterator , $ filter Regex , \ Recursive Regex Iterator : : GET _MATCH ) ; foreach ( $ filtered Iterator as $ file ) { $ files [ ] = $ file [ 0 ] ; } } elseif ( is _file ( $ path ) ) { $ files [ ] = $ path ; } } return $ files ; } 
private function traverse ( Tree Node $ node ) { if ( $ node - > visited ) { return 0 ; } $ node - > visited = true ; foreach ( $ node - > get Adjacents ( ) as $ adjacent ) { $ this - > traverse ( $ adjacent ) ; } return 1 ; } 
public function read ( Config $ config ) { $ options = parse _ini _file ( $ this - > filename ) ; if ( false = = = $ options ) { throw new \ Invalid Argument Exception ( "Cannot parse configuration file ' { $this - >filename } ' " ) ; } foreach ( $ options as $ name = > $ value ) { $ config - > set ( $ name , $ value ) ; } } 
public static function create From File Name ( $ filename ) { if ( ! is _file ( $ filename ) | | ! is _readable ( $ filename ) ) { throw new \ Invalid Argument Exception ( "Cannot read configuration file ' { $filename } ' " ) ; } switch ( pathinfo ( $ filename , PATHINFO _EXTENSION ) ) { case 'json ' : return new Config File Reader Json ( $ filename ) ; case 'ini ' : return new Config File Reader Ini ( $ filename ) ; break ; default : throw new \ Invalid Argument Exception ( "Unsupported config file format : ' $filename ' " ) ; } } 
public static function get Name ( Node $ node ) { return ( $ node instanceof Node \ Stmt \ Class _ & & $ node - > is Anonymous ( ) ) ? 'anonymous @ ' . spl _object _hash ( $ node ) : $ node - > namespaced Name - > to String ( ) ; } 
public function get Root Nodes ( ) { $ roots = [ ] ; foreach ( $ this - > all ( ) as $ node ) { $ is Root = true ; foreach ( $ node - > get Edges ( ) as $ edge ) { if ( $ edge - > get To ( ) = = $ node ) { $ is Root = false ; } } if ( $ is Root ) { array _push ( $ roots , $ node ) ; } } return $ roots ; } 
protected function get Composer Json Requirements ( ) { $ raw Requirements = [ [ ] ] ; 
protected function get Composer Lock Installed ( $ root Package Requirements ) { $ raw Installed = [ [ ] ] ; 
public function advance ( ) { $ this - > current + + ; if ( $ this - > has Ansi ( ) ) { $ percent = round ( $ this - > current / $ this - > max * 1 0 0 ) ; $ this - > output - > write ( " \x 0D " ) ; $ this - > output - > write ( " \x 1B [ 2K " ) ; $ this - > output - > write ( sprintf ( ' . . . %s % % . . . ' , $ percent ) ) ; } else { $ this - > output - > write ( ' . ' ) ; } } 
public function clear ( ) { if ( $ this - > has Ansi ( ) ) { $ this - > output - > write ( " \x 0D " ) ; $ this - > output - > write ( " \x 1B [ 2K " ) ; $ this - > output - > clearln ( ) ; } } 
protected function has Ansi ( ) { if ( DIRECTORY _SEPARATOR = = = ' \ \ ' ) { return 0 > = version _compare ( ' 1 0 . 0 . 1 0 5 8 6 ' , PHP _WINDOWS _VERSION _MAJOR . ' . ' . PHP _WINDOWS _VERSION _MINOR . ' . ' . PHP _WINDOWS _VERSION _BUILD ) | | false ! = = getenv ( 'ANSICON ' ) | | 'ON ' = = = getenv ( 'Con Emu ANSI ' ) | | 'xterm ' = = = getenv ( 'TERM ' ) ; } return function _exists ( 'posix _isatty ' ) & & @ posix _isatty ( $ this - > stream ) ; } 
public function process _token ( $ stack Ptr ) { $ superglobals = $ this - > input _superglobals ; * Check for validation first . * / $ validated = false ; for ( $ i = ( $ stack Ptr + 1 ) ; $ i < $ this - > phpcs File - > num Tokens ; $ i + + ) { if ( isset ( Tokens : : $ empty Tokens [ $ this - > tokens [ $ i ] [ 'code ' ] ] ) ) { continue ; } if ( \ T _OPEN _SQUARE _BRACKET = = = $ this - > tokens [ $ i ] [ 'code ' ] & & isset ( $ this - > tokens [ $ i ] [ 'bracket _closer ' ] ) ) { 
protected function merge Function Lists ( ) { if ( $ this - > custom Sanitizing Functions ! = = $ this - > added Custom Functions [ 'sanitize ' ] ) { $ this - > sanitizing Functions = $ this - > merge _custom _array ( $ this - > custom Sanitizing Functions , $ this - > sanitizing Functions ) ; $ this - > added Custom Functions [ 'sanitize ' ] = $ this - > custom Sanitizing Functions ; } if ( $ this - > custom Unslashing Sanitizing Functions ! = = $ this - > added Custom Functions [ 'unslashsanitize ' ] ) { $ this - > unslashing Sanitizing Functions = $ this - > merge _custom _array ( $ this - > custom Unslashing Sanitizing Functions , $ this - > unslashing Sanitizing Functions ) ; $ this - > added Custom Functions [ 'unslashsanitize ' ] = $ this - > custom Unslashing Sanitizing Functions ; } } 
public function register ( ) { $ headers = array _map ( 'preg _quote ' , array _keys ( $ this - > theme _headers ) , array _fill ( 0 , \ count ( $ this - > theme _headers ) , ' ` ' ) ) ; $ this - > theme _header _regex = sprintf ( $ this - > header _regex _template , implode ( ' | ' , $ headers ) ) ; $ headers = array _map ( 'preg _quote ' , array _keys ( $ this - > plugin _headers ) , array _fill ( 0 , \ count ( $ this - > plugin _headers ) , ' ` ' ) ) ; $ this - > plugin _header _regex = sprintf ( $ this - > header _regex _template , implode ( ' | ' , $ headers ) ) ; $ targets = parent : : register ( ) ; $ targets [ ] = \ T _DOC _COMMENT _OPEN _TAG ; $ targets [ ] = \ T _COMMENT ; return $ targets ; } 
public function process _token ( $ stack Ptr ) { 
public function process _parameters ( $ stack Ptr , $ group _name , $ matched _content , $ parameters ) { $ target _param = $ this - > target _functions [ $ matched _content ] ; if ( isset ( $ parameters [ $ target _param ] ) = = = false & & 1 ! = = $ target _param ) { $ error _msg = 'Missing $domain arg ' ; $ error _code = 'Missing Arg Domain ' ; if ( isset ( $ parameters [ ( $ target _param - 1 ) ] ) ) { $ fix = $ this - > phpcs File - > add Fixable Error ( $ error _msg , $ stack Ptr , $ error _code ) ; if ( true = = = $ fix ) { $ start _previous = $ parameters [ ( $ target _param - 1 ) ] [ 'start ' ] ; $ end _previous = $ parameters [ ( $ target _param - 1 ) ] [ 'end ' ] ; if ( \ T _WHITESPACE = = = $ this - > tokens [ $ start _previous ] [ 'code ' ] & & $ this - > tokens [ $ start _previous ] [ 'content ' ] = = = $ this - > phpcs File - > eol Char ) { 
public function process _no _parameters ( $ stack Ptr , $ group _name , $ matched _content ) { $ target _param = $ this - > target _functions [ $ matched _content ] ; if ( 1 ! = = $ target _param ) { 
public function process _comments ( $ stack Ptr ) { if ( true = = = $ this - > header _found & & ! defined ( 'PHP _CODESNIFFER _IN _TESTS ' ) ) { return ; } $ regex = $ this - > plugin _header _regex ; $ headers = $ this - > plugin _headers ; $ type = 'plugin ' ; $ skip _to = $ stack Ptr ; $ file = $ this - > strip _quotes ( $ this - > phpcs File - > get File Name ( ) ) ; if ( 'STDIN ' = = = $ file ) { return ; } $ file _name = basename ( $ file ) ; if ( 'CSS ' = = = $ this - > phpcs File - > tokenizer Type ) { if ( 'style .css ' ! = = $ file _name & & ! defined ( 'PHP _CODESNIFFER _IN _TESTS ' ) ) { 
protected function examine _comment _line ( $ stack Ptr , $ regex , $ headers , $ comment _details ) { if ( preg _match ( $ regex , $ this - > tokens [ $ stack Ptr ] [ 'content ' ] , $ matches ) = = = 1 ) { + + $ comment _details [ 'headers _found ' ] ; if ( true = = = $ headers [ $ matches [ 1 ] ] ) { $ comment _details [ 'required _header _found ' ] = true ; } if ( 'Text Domain ' = = = $ matches [ 1 ] ) { $ comment _details [ 'text _domain _ptr ' ] = $ stack Ptr ; $ comment _details [ 'text _domain _found ' ] = trim ( $ matches [ 2 ] ) ; } $ comment _details [ 'last _header _ptr ' ] = $ stack Ptr ; $ comment _details [ 'last _header _matches ' ] = $ matches ; } return $ comment _details ; } 
public function process _token ( $ stack Ptr ) { $ token = $ this - > tokens [ $ stack Ptr ] ; if ( 'cron _schedules ' ! = = $ this - > strip _quotes ( $ token [ 'content ' ] ) ) { return ; } 
public function process ( File $ phpcs File , $ stack Ptr ) { $ this - > init ( $ phpcs File ) ; return $ this - > process _token ( $ stack Ptr ) ; } 
protected function init ( File $ phpcs File ) { $ this - > phpcs File = $ phpcs File ; $ this - > tokens = $ phpcs File - > get Tokens ( ) ; } 
protected function add Message ( $ message , $ stack Ptr , $ is _error = true , $ code = 'Found ' , $ data = array ( ) , $ severity = 0 ) { return $ this - > throw Message ( $ message , $ stack Ptr , $ is _error , $ code , $ data , $ severity , false ) ; } 
protected function add Fixable Message ( $ message , $ stack Ptr , $ is _error = true , $ code = 'Found ' , $ data = array ( ) , $ severity = 0 ) { return $ this - > throw Message ( $ message , $ stack Ptr , $ is _error , $ code , $ data , $ severity , true ) ; } 
private function throw Message ( $ message , $ stack Ptr , $ is _error = true , $ code = 'Found ' , $ data = array ( ) , $ severity = 0 , $ fixable = false ) { $ method = 'add ' ; if ( true = = = $ fixable ) { $ method . = 'Fixable ' ; } if ( true = = = $ is _error ) { $ method . = 'Error ' ; } else { $ method . = 'Warning ' ; } return \ call _user _func ( array ( $ this - > phpcs File , $ method ) , $ message , $ stack Ptr , $ code , $ data , $ severity ) ; } 
public static function get _snake _case _name _suggestion ( $ name ) { $ suggested = preg _replace ( ' ` ( [A -Z ] ) ` ' , ' _ $ 1 ' , $ name ) ; $ suggested = strtolower ( $ suggested ) ; $ suggested = str _replace ( ' _ _ ' , ' _ ' , $ suggested ) ; $ suggested = trim ( $ suggested , ' _ ' ) ; return $ suggested ; } 
public static function merge _custom _array ( $ custom , $ base = array ( ) , $ flip = true ) { if ( true = = = $ flip ) { $ base = array _filter ( $ base ) ; } if ( empty ( $ custom ) | | ! \ is _array ( $ custom ) ) { return $ base ; } if ( true = = = $ flip ) { $ custom = array _fill _keys ( $ custom , false ) ; } if ( empty ( $ base ) ) { return $ custom ; } return array _merge ( $ base , $ custom ) ; } 
protected function get _last _ptr _on _line ( $ stack Ptr ) { $ tokens = $ this - > tokens ; $ current Line = $ tokens [ $ stack Ptr ] [ 'line ' ] ; $ next Ptr = ( $ stack Ptr + 1 ) ; while ( isset ( $ tokens [ $ next Ptr ] ) & & $ tokens [ $ next Ptr ] [ 'line ' ] = = = $ current Line ) { $ next Ptr + + ; 
protected function get _wp _version _from _cl ( ) { $ cl _supported _version = trim ( PHPCSHelper : : get _config _data ( 'minimum _supported _wp _version ' ) ) ; if ( ! empty ( $ cl _supported _version ) & & filter _var ( $ cl _supported _version , \ FILTER _VALIDATE _FLOAT ) ! = = false ) { $ this - > minimum _supported _version = $ cl _supported _version ; } } 
protected function has _whitelist _comment ( $ comment , $ stack Ptr ) { 
protected function is _assignment ( $ stack Ptr ) { static $ valid = array ( \ T _VARIABLE = > true , \ T _CLOSE _SQUARE _BRACKET = > true , ) ; 
protected function has _nonce _check ( $ stack Ptr ) { static $ last ; $ start = 0 ; $ end = $ stack Ptr ; $ tokens = $ this - > phpcs File - > get Tokens ( ) ; * Now , make sure it is a call to a global function . * / if ( $ this - > is _class _object _call ( $ i ) = = = true ) { continue ; } if ( $ this - > is _token _namespaced ( $ i ) = = = true ) { continue ; } $ last [ 'nonce _check ' ] = $ i ; return true ; } } 
protected function is _in _isset _or _empty ( $ stack Ptr ) { if ( ! isset ( $ this - > tokens [ $ stack Ptr ] [ 'nested _parenthesis ' ] ) ) { return false ; } $ nested _parenthesis = $ this - > tokens [ $ stack Ptr ] [ 'nested _parenthesis ' ] ; end ( $ nested _parenthesis ) ; $ open _parenthesis = key ( $ nested _parenthesis ) ; $ previous _non _empty = $ this - > phpcs File - > find Previous ( Tokens : : $ empty Tokens , ( $ open _parenthesis - 1 ) , null , true , null , true ) ; if ( false = = = $ previous _non _empty ) { return false ; } $ previous _code = $ this - > tokens [ $ previous _non _empty ] [ 'code ' ] ; if ( \ T _ISSET = = = $ previous _code | | \ T _EMPTY = = = $ previous _code ) { return true ; } $ valid _functions = array ( 'array _key _exists ' = > true , 'key _exists ' = > true , 
protected function is _class _object _call ( $ stack Ptr ) { $ before = $ this - > phpcs File - > find Previous ( Tokens : : $ empty Tokens , ( $ stack Ptr - 1 ) , null , true , null , true ) ; if ( false = = = $ before ) { return false ; } if ( \ T _OBJECT _OPERATOR ! = = $ this - > tokens [ $ before ] [ 'code ' ] & & \ T _DOUBLE _COLON ! = = $ this - > tokens [ $ before ] [ 'code ' ] ) { return false ; } return true ; } 
protected function is _token _namespaced ( $ stack Ptr ) { $ prev = $ this - > phpcs File - > find Previous ( Tokens : : $ empty Tokens , ( $ stack Ptr - 1 ) , null , true , null , true ) ; if ( false = = = $ prev ) { return false ; } if ( \ T _NS _SEPARATOR ! = = $ this - > tokens [ $ prev ] [ 'code ' ] ) { return false ; } $ before _prev = $ this - > phpcs File - > find Previous ( Tokens : : $ empty Tokens , ( $ prev - 1 ) , null , true , null , true ) ; if ( false = = = $ before _prev ) { return false ; } if ( \ T _STRING ! = = $ this - > tokens [ $ before _prev ] [ 'code ' ] & & \ T _NAMESPACE ! = = $ this - > tokens [ $ before _prev ] [ 'code ' ] ) { return false ; } return true ; } 
protected function is _in _function _call ( $ stack Ptr , $ valid _functions , $ global = true , $ allow _nested = false ) { if ( ! isset ( $ this - > tokens [ $ stack Ptr ] [ 'nested _parenthesis ' ] ) ) { return false ; } $ nested _parenthesis = $ this - > tokens [ $ stack Ptr ] [ 'nested _parenthesis ' ] ; if ( false = = = $ allow _nested ) { $ nested _parenthesis = array _reverse ( $ nested _parenthesis , true ) ; } foreach ( $ nested _parenthesis as $ open = > $ close ) { $ prev _non _empty = $ this - > phpcs File - > find Previous ( Tokens : : $ empty Tokens , ( $ open - 1 ) , null , true , null , true ) ; if ( false = = = $ prev _non _empty | | \ T _STRING ! = = $ this - > tokens [ $ prev _non _empty ] [ 'code ' ] ) { continue ; } if ( isset ( $ valid _functions [ strtolower ( $ this - > tokens [ $ prev _non _empty ] [ 'content ' ] ) ] ) = = = false ) { if ( false = = = $ allow _nested ) { * Now , make sure it is a global function . * / if ( $ this - > is _class _object _call ( $ prev _non _empty ) = = = true ) { continue ; } if ( $ this - > is _token _namespaced ( $ prev _non _empty ) = = = true ) { continue ; } return $ prev _non _empty ; } return false ; } 
protected function is _only _sanitized ( $ stack Ptr ) { 
protected function is _safe _casted ( $ stack Ptr ) { 
protected function is _sanitized ( $ stack Ptr , $ require _unslash = false ) { * If this is a function callback (not a method callback array ) and we 're able * to resolve the function name , do so . * / $ first _non _empty = $ this - > phpcs File - > find Next ( Tokens : : $ empty Tokens , $ callback [ 'start ' ] , ( $ callback [ 'end ' ] + 1 ) , true ) ; if ( false ! = = $ first _non _empty & & \ T _CONSTANT _ENCAPSED _STRING = = = $ this - > tokens [ $ first _non _empty ] [ 'code ' ] ) { $ function Name = $ this - > strip _quotes ( $ this - > tokens [ $ first _non _empty ] [ 'content ' ] ) ; } } } 
protected function get _array _access _keys ( $ stack Ptr , $ all = true ) { $ keys = array ( ) ; if ( \ T _VARIABLE ! = = $ this - > tokens [ $ stack Ptr ] [ 'code ' ] ) { return $ keys ; } $ current = $ stack Ptr ; do { 
protected function get _array _access _key ( $ stack Ptr ) { $ keys = $ this - > get _array _access _keys ( $ stack Ptr , false ) ; if ( isset ( $ keys [ 0 ] ) ) { return $ keys [ 0 ] ; } return false ; } 
protected function is _validated ( $ stack Ptr , $ array _keys = array ( ) , $ in _condition _only = false ) { if ( $ in _condition _only ) { * We are are more loose , requiring only that the variable be validated * in the same function /file scope as it is used . * / $ scope _start = 0 ; * For multi -level array access , the complete set of keys could be split between * the first and the second parameter , but could also be completely in the second * parameter , so we need to check both options . * / $ found _keys = $ this - > get _array _access _keys ( $ param 2 _first _token ) ; $ found _keys = array _map ( array ( $ this , 'strip _quotes ' ) , $ found _keys ) ; 
protected function is _comparison ( $ stack Ptr , $ include _coalesce = true ) { $ comparison Tokens = Tokens : : $ comparison Tokens ; if ( false = = = $ include _coalesce ) { unset ( $ comparison Tokens [ \ T _COALESCE ] ) ; } 
protected function is _in _array _comparison ( $ stack Ptr ) { $ function _ptr = $ this - > is _in _function _call ( $ stack Ptr , $ this - > array Compare Functions , true , true ) ; if ( false = = = $ function _ptr ) { return false ; } $ function _name = $ this - > tokens [ $ function _ptr ] [ 'content ' ] ; if ( true = = = $ this - > array Compare Functions [ $ function _name ] ) { return true ; } if ( $ this - > get _function _call _parameter _count ( $ function _ptr ) > = $ this - > array Compare Functions [ $ function _name ] ) { return true ; } return false ; } 
protected function get _use _type ( $ stack Ptr ) { 
protected function get _interpolated _variables ( $ string ) { $ variables = array ( ) ; if ( preg _match _all ( ' / ( ?P <backslashes > \ \ \ \ * ) \ $ ( ?P <symbol > \w + ) / ' , $ string , $ match _sets , \ PREG _SET _ORDER ) ) { foreach ( $ match _sets as $ matches ) { if ( ! isset ( $ matches [ 'backslashes ' ] ) | | ( \ strlen ( $ matches [ 'backslashes ' ] ) % 2 ) = = = 0 ) { $ variables [ ] = $ matches [ 'symbol ' ] ; } } } return $ variables ; } 
public function strip _interpolated _variables ( $ string ) { if ( strpos ( $ string , ' $ ' ) = = = false ) { return $ string ; } return preg _replace ( self : : REGEX _COMPLEX _VARS , ' ' , $ string ) ; } 
public function does _function _call _have _parameters ( $ stack Ptr ) { 
public function get _function _call _parameter _count ( $ stack Ptr ) { if ( false = = = $ this - > does _function _call _have _parameters ( $ stack Ptr ) ) { return 0 ; } return \ count ( $ this - > get _function _call _parameters ( $ stack Ptr ) ) ; } 
public function get _function _call _parameters ( $ stack Ptr ) { if ( false = = = $ this - > does _function _call _have _parameters ( $ stack Ptr ) ) { return array ( ) ; } * Check if there are more tokens before the closing parenthesis . * Prevents code like the following from setting a third parameter : * function Call ( $param 1 , $param 2 , ) ; * / $ has _next _param = $ this - > phpcs File - > find Next ( Tokens : : $ empty Tokens , ( $ next _comma + 1 ) , $ closer , true , null , true ) ; if ( false = = = $ has _next _param ) { break ; } 
public function get _function _call _parameter ( $ stack Ptr , $ param _offset ) { $ parameters = $ this - > get _function _call _parameters ( $ stack Ptr ) ; if ( false = = = isset ( $ parameters [ $ param _offset ] ) ) { return false ; } return $ parameters [ $ param _offset ] ; } 
protected function find _array _open _close ( $ stack Ptr ) { if ( \ T _ARRAY = = = $ this - > tokens [ $ stack Ptr ] [ 'code ' ] ) { if ( isset ( $ this - > tokens [ $ stack Ptr ] [ 'parenthesis _opener ' ] ) ) { $ opener = $ this - > tokens [ $ stack Ptr ] [ 'parenthesis _opener ' ] ; if ( isset ( $ this - > tokens [ $ opener ] [ 'parenthesis _closer ' ] ) ) { $ closer = $ this - > tokens [ $ opener ] [ 'parenthesis _closer ' ] ; } } } else { 
public function determine _namespace ( $ stack Ptr ) { * Not in a scoped namespace , so let 's see if we can find a non -scoped namespace instead . * Keeping in mind that : * - there can be multiple non -scoped namespaces in a file (bad practice , but it happens ) . * - the namespace keyword can also be used as part of a function /method call and such . * - that a non -named namespace resolves to the global namespace . * / $ previous NSToken = $ stack Ptr ; $ namespace = false ; do { $ previous NSToken = $ this - > phpcs File - > find Previous ( \ T _NAMESPACE , ( $ previous NSToken - 1 ) ) ; / / Stop if we encounter a scoped namespace declaration as we already know we 're not in one . if ( ! empty ( $ this - > tokens [ $ previous NSToken ] [ 'scope _condition ' ] ) & & $ this - > tokens [ $ previous NSToken ] [ 'scope _condition ' ] = = = $ previous NSToken ) { break ; } $ namespace = $ this - > get _declared _namespace _name ( $ previous NSToken ) ; } while ( false = = = $ namespace & & false ! = = $ previous NSToken ) ; 
public function get _declared _namespace _name ( $ stack Ptr ) { 
public function is _class _constant ( $ stack Ptr ) { if ( ! isset ( $ this - > tokens [ $ stack Ptr ] ) | | \ T _CONST ! = = $ this - > tokens [ $ stack Ptr ] [ 'code ' ] ) { return false ; } 
public function is _class _property ( $ stack Ptr ) { if ( ! isset ( $ this - > tokens [ $ stack Ptr ] ) | | \ T _VARIABLE ! = = $ this - > tokens [ $ stack Ptr ] [ 'code ' ] ) { return false ; } 
protected function valid _direct _scope ( $ stack Ptr , array $ valid _scopes ) { if ( empty ( $ this - > tokens [ $ stack Ptr ] [ 'conditions ' ] ) ) { return false ; } $ conditions = array _keys ( $ this - > tokens [ $ stack Ptr ] [ 'conditions ' ] ) ; $ ptr = array _pop ( $ conditions ) ; if ( ! isset ( $ this - > tokens [ $ ptr ] ) ) { return false ; } if ( isset ( $ valid _scopes [ $ this - > tokens [ $ ptr ] [ 'type ' ] ] ) ) { return $ ptr ; } return false ; } 
protected function is _wpdb _method _call ( $ stack Ptr , $ target _methods ) { 
public function is _use _of _global _constant ( $ stack Ptr ) { * Deal with a number of variations of use statements . * / for ( $ i = $ stack Ptr ; $ i > 0 ; $ i - - ) { if ( $ this - > tokens [ $ i ] [ 'line ' ] ! = = $ this - > tokens [ $ stack Ptr ] [ 'line ' ] ) { break ; } } $ first On Line = $ this - > phpcs File - > find Next ( Tokens : : $ empty Tokens , ( $ i + 1 ) , null , true ) ; if ( false ! = = $ first On Line & & \ T _USE = = = $ this - > tokens [ $ first On Line ] [ 'code ' ] ) { $ next On Line = $ this - > phpcs File - > find Next ( Tokens : : $ empty Tokens , ( $ first On Line + 1 ) , null , true ) ; if ( false ! = = $ next On Line ) { if ( \ T _STRING = = = $ this - > tokens [ $ next On Line ] [ 'code ' ] & & 'const ' = = = $ this - > tokens [ $ next On Line ] [ 'content ' ] ) { $ has Ns Sep = $ this - > phpcs File - > find Next ( \ T _NS _SEPARATOR , ( $ next On Line + 1 ) , $ stack Ptr ) ; if ( false ! = = $ has Ns Sep ) { 
protected function is _foreach _as ( $ stack Ptr ) { if ( ! isset ( $ this - > tokens [ $ stack Ptr ] [ 'nested _parenthesis ' ] ) ) { return false ; } $ nested _parenthesis = $ this - > tokens [ $ stack Ptr ] [ 'nested _parenthesis ' ] ; $ close _parenthesis = end ( $ nested _parenthesis ) ; $ open _parenthesis = key ( $ nested _parenthesis ) ; if ( ! isset ( $ this - > tokens [ $ close _parenthesis ] [ 'parenthesis _owner ' ] ) ) { return false ; } if ( \ T _FOREACH ! = = $ this - > tokens [ $ this - > tokens [ $ close _parenthesis ] [ 'parenthesis _owner ' ] ] [ 'code ' ] ) { return false ; } $ as _ptr = $ this - > phpcs File - > find Next ( \ T _AS , ( $ open _parenthesis + 1 ) , $ close _parenthesis ) ; if ( false = = = $ as _ptr ) { 
public function process _token ( $ stack Ptr ) { $ token = $ this - > tokens [ $ stack Ptr ] ; if ( ! isset ( $ token [ 'bracket _closer ' ] ) ) { $ this - > phpcs File - > add Warning ( 'Missing bracket closer . ' , $ stack Ptr , 'Missing Bracket Closer ' ) ; return ; } $ need _spaces = $ this - > phpcs File - > find Next ( array ( \ T _CONSTANT _ENCAPSED _STRING , \ T _LNUMBER , \ T _WHITESPACE , \ T _MINUS ) , ( $ stack Ptr + 1 ) , $ token [ 'bracket _closer ' ] , true ) ; $ spaced 1 = ( \ T _WHITESPACE = = = $ this - > tokens [ ( $ stack Ptr + 1 ) ] [ 'code ' ] ) ; $ spaced 2 = ( \ T _WHITESPACE = = = $ this - > tokens [ ( $ token [ 'bracket _closer ' ] - 1 ) ] [ 'code ' ] ) ; 
public function process _parameters ( $ stack Ptr , $ group _name , $ matched _content , $ parameters ) { * Here be dragons - a double quoted string can contain extrapolated variables * which don 't have to comply with these rules . * / if ( \ T _DOUBLE _QUOTED _STRING = = = $ this - > tokens [ $ i ] [ 'code ' ] ) { $ transform = $ this - > transform _complex _string ( $ string , $ regex ) ; $ case _transform = $ this - > transform _complex _string ( $ string , $ regex , 'case ' ) ; $ punct _transform = $ this - > transform _complex _string ( $ string , $ regex , 'punctuation ' ) ; } else { $ transform = $ this - > transform ( $ string , $ regex ) ; $ case _transform = $ this - > transform ( $ string , $ regex , 'case ' ) ; $ punct _transform = $ this - > transform ( $ string , $ regex , 'punctuation ' ) ; } if ( $ string = = = $ transform ) { continue ; } if ( \ T _DOUBLE _QUOTED _STRING = = = $ this - > tokens [ $ i ] [ 'code ' ] ) { $ expected [ $ i ] = ' " ' . $ transform . ' " ' ; } else { $ expected [ $ i ] = ' \ ' ' . $ transform . ' \ ' ' ; } if ( $ string ! = = $ case _transform ) { $ case _errors + + ; } if ( $ string ! = = $ punct _transform ) { $ underscores + + ; } } } $ data = array ( implode ( ' ' , $ expected ) , implode ( ' ' , $ content ) , ) ; if ( $ case _errors > 0 ) { $ error = 'Hook names should be lowercase . Expected : %s , but found : %s . ' ; $ this - > phpcs File - > add Error ( $ error , $ stack Ptr , 'Not Lowercase ' , $ data ) ; } if ( $ underscores > 0 ) { $ error = 'Words in hook names should be separated using underscores . Expected : %s , but found : %s . ' ; $ this - > phpcs File - > add Warning ( $ error , $ stack Ptr , 'Use Underscores ' , $ data ) ; } } 
protected function prepare _regex ( ) { $ extra = ' ' ; if ( ' ' ! = = $ this - > additional Word Delimiters & & \ is _string ( $ this - > additional Word Delimiters ) ) { $ extra = preg _quote ( $ this - > additional Word Delimiters , ' ` ' ) ; } return sprintf ( $ this - > punctuation _regex , $ extra ) ; } 
protected function transform ( $ string , $ regex , $ transform _type = 'full ' ) { switch ( $ transform _type ) { case 'case ' : return strtolower ( $ string ) ; case 'punctuation ' : return preg _replace ( $ regex , ' _ ' , $ string ) ; case 'full ' : default : return preg _replace ( $ regex , ' _ ' , strtolower ( $ string ) ) ; } } 
protected function transform _complex _string ( $ string , $ regex , $ transform _type = 'full ' ) { $ output = preg _split ( ' ` ( [ \ { \ } \ $ \ [ \ ] ] ) ` ' , $ string , - 1 , \ PREG _SPLIT _DELIM _CAPTURE ) ; $ is _variable = false ; $ has _braces = false ; $ braces = 0 ; foreach ( $ output as $ i = > $ part ) { if ( \ in _array ( $ part , array ( ' $ ' , ' { ' ) , true ) ) { $ is _variable = true ; if ( ' { ' = = = $ part ) { $ has _braces = true ; $ braces + + ; } continue ; } if ( true = = = $ is _variable ) { if ( ' [ ' = = = $ part ) { $ has _braces = true ; $ braces + + ; } if ( \ in _array ( $ part , array ( ' } ' , ' ] ' ) , true ) ) { $ braces - - ; } if ( false = = = $ has _braces & & ' ' = = = $ part ) { $ is _variable = false ; $ output [ $ i ] = $ this - > transform ( $ part , $ regex , $ transform _type ) ; } if ( ( true = = = $ has _braces & & 0 = = = $ braces ) & & false = = = \ in _array ( $ output [ ( $ i + 1 ) ] , array ( ' { ' , ' [ ' ) , true ) ) { $ has _braces = false ; $ is _variable = false ; } continue ; } $ output [ $ i ] = $ this - > transform ( $ part , $ regex , $ transform _type ) ; } return implode ( ' ' , $ output ) ; } 
public function get Groups ( ) { 
public function process _matched _token ( $ stack Ptr , $ group _name , $ matched _content ) { $ this - > get _wp _version _from _cl ( ) ; $ class _name = ltrim ( strtolower ( $ matched _content ) , ' \ \ ' ) ; $ message = 'The %s class has been deprecated since Word Press version %s . ' ; $ data = array ( ltrim ( $ matched _content , ' \ \ ' ) , $ this - > deprecated _classes [ $ class _name ] [ 'version ' ] , ) ; if ( ! empty ( $ this - > deprecated _classes [ $ class _name ] [ 'alt ' ] ) ) { $ message . = ' Use %s instead . ' ; $ data [ ] = $ this - > deprecated _classes [ $ class _name ] [ 'alt ' ] ; } $ this - > add Message ( $ message , $ stack Ptr , ( version _compare ( $ this - > deprecated _classes [ $ class _name ] [ 'version ' ] , $ this - > minimum _supported _version , ' < ' ) ) , $ this - > string _to _errorcode ( $ class _name . 'Found ' ) , $ data ) ; } 
public function process _parameters ( $ stack Ptr , $ group _name , $ matched _content , $ parameters ) { $ this - > get _wp _version _from _cl ( ) ; $ param _count = \ count ( $ parameters ) ; foreach ( $ this - > target _functions [ $ matched _content ] as $ position = > $ parameter _args ) { 
protected function process _parameter ( $ matched _content , $ parameter , $ parameter _args ) { $ parameter _position = $ this - > phpcs File - > find Next ( Tokens : : $ empty Tokens , $ parameter [ 'start ' ] , $ parameter [ 'end ' ] + 1 , true ) ; if ( false = = = $ parameter _position ) { return ; } $ matched _parameter = $ this - > strip _quotes ( $ this - > tokens [ $ parameter _position ] [ 'content ' ] ) ; if ( ! isset ( $ parameter _args [ $ matched _parameter ] ) ) { return ; } $ message = 'The parameter value " %s " has been deprecated since Word Press version %s . ' ; $ data = array ( $ matched _parameter , $ parameter _args [ $ matched _parameter ] [ 'version ' ] , ) ; if ( ! empty ( $ parameter _args [ $ matched _parameter ] [ 'alt ' ] ) ) { $ message . = ' Use %s instead . ' ; $ data [ ] = $ parameter _args [ $ matched _parameter ] [ 'alt ' ] ; } $ is _error = version _compare ( $ parameter _args [ $ matched _parameter ] [ 'version ' ] , $ this - > minimum _supported _version , ' < ' ) ; $ this - > add Message ( $ message , $ parameter _position , $ is _error , $ this - > string _to _errorcode ( 'Found ' ) , $ data ) ; } 
public function process _parameters ( $ stack Ptr , $ group _name , $ matched _content , $ parameters ) { if ( \ count ( $ parameters ) > 1 ) { return ; } $ this - > phpcs File - > add Warning ( 'Passing the $delimiter as the second parameter to preg _quote ( ) is strongly recommended . ' , $ stack Ptr , 'Missing ' ) ; } 
public function process _token ( $ stack Ptr ) { if ( isset ( $ this - > target _functions [ strtolower ( $ this - > tokens [ $ stack Ptr ] [ 'content ' ] ) ] ) ) { 
public function process _arbitrary _tstring ( $ stack Ptr ) { $ content = $ this - > tokens [ $ stack Ptr ] [ 'content ' ] ; if ( ! isset ( $ this - > discouraged _constants [ $ content ] ) ) { return ; } $ next = $ this - > phpcs File - > find Next ( Tokens : : $ empty Tokens , ( $ stack Ptr + 1 ) , null , true ) ; if ( false ! = = $ next & & \ T _OPEN _PARENTHESIS = = = $ this - > tokens [ $ next ] [ 'code ' ] ) { * Deal with a number of variations of use statements . * / for ( $ i = $ stack Ptr ; $ i > 0 ; $ i - - ) { if ( $ this - > tokens [ $ i ] [ 'line ' ] ! = = $ this - > tokens [ $ stack Ptr ] [ 'line ' ] ) { break ; } } $ first _on _line = $ this - > phpcs File - > find Next ( Tokens : : $ empty Tokens , ( $ i + 1 ) , null , true ) ; if ( false ! = = $ first _on _line & & \ T _USE = = = $ this - > tokens [ $ first _on _line ] [ 'code ' ] ) { $ next _on _line = $ this - > phpcs File - > find Next ( Tokens : : $ empty Tokens , ( $ first _on _line + 1 ) , null , true ) ; if ( false ! = = $ next _on _line ) { if ( ( \ T _STRING = = = $ this - > tokens [ $ next _on _line ] [ 'code ' ] & & 'const ' = = = $ this - > tokens [ $ next _on _line ] [ 'content ' ] ) | | \ T _CONST = = = $ this - > tokens [ $ next _on _line ] [ 'code ' ] 
public function process _parameters ( $ stack Ptr , $ group _name , $ matched _content , $ parameters ) { $ function _name = strtolower ( $ matched _content ) ; $ target _param = $ this - > target _functions [ $ function _name ] ; 
public function process _token ( $ stack Ptr ) { if ( ! $ this - > is _wpdb _method _call ( $ stack Ptr , $ this - > target _methods ) ) { return ; } $ parameters = $ this - > get _function _call _parameters ( $ this - > method Ptr ) ; if ( empty ( $ parameters ) ) { return ; } $ query = $ parameters [ 1 ] ; $ text _string _tokens _found = false ; $ variable _found = false ; $ sql _wildcard _found = false ; $ total _placeholders = 0 ; $ total _parameters = \ count ( $ parameters ) ; $ valid _in _clauses = array ( 'uses _in ' = > 0 , 'implode _fill ' = > 0 , 'adjustment _count ' = > 0 , ) ; for ( $ i = $ query [ 'start ' ] ; $ i < = $ query [ 'end ' ] ; $ i + + ) { * Analyse the query for incorrect LIKE queries . * * - `LIKE %s ` is the only correct one . * - `LIKE ' %s ' ` or `LIKE " %s " ` will not be reported here , but in the quote check . * - Any other `LIKE ` statement should be reported , either for using `LIKE ` without * SQL wildcards or for not passing the SQL wildcards via the replacement . * / $ regex = ' ` \s +LIKE \s * ( ? : ( ' . $ regex _quote . ' ) ( ? ! %s ( ? : \ 1 | $ ) ) ( ?P <content > . * ? ) ( ? : \ 1 | $ ) | ( ? :concat \ ( ( ? ! [ ^ \ ) ] * %s [ ^ \ ) ] * \ ) ) ( ?P <concat > [ ^ \ ) ] * ) ) \ ) ) `i ' ; if ( preg _match _all ( $ regex , $ content , $ matches ) > 0 ) { $ walk = array ( ) ; if ( ! empty ( $ matches [ 'content ' ] ) ) { $ matches [ 'content ' ] = array _filter ( $ matches [ 'content ' ] ) ; if ( ! empty ( $ matches [ 'content ' ] ) ) { $ walk [ ] = 'content ' ; } } if ( ! empty ( $ matches [ 'concat ' ] ) ) { $ matches [ 'concat ' ] = array _filter ( $ matches [ 'concat ' ] ) ; if ( ! empty ( $ matches [ 'concat ' ] ) ) { $ walk [ ] = 'concat ' ; } } if ( ! empty ( $ walk ) ) { foreach ( $ walk as $ match _key ) { foreach ( $ matches [ $ match _key ] as $ index = > $ match ) { $ data = array ( $ matches [ 0 ] [ $ index ] ) ; * Don 't throw `Unescaped Literal ` , `Unsupported Placeholder ` or `Quoted Placeholder ` * for this part of the SQL query . * / $ content = preg _replace ( ' ` ' . preg _quote ( $ match , ' ` ' ) . ' ` ' , ' ' , $ content , 1 ) ; } } } unset ( $ matches , $ index , $ match , $ data ) ; } if ( strpos ( $ content , ' % ' ) = = = false ) { continue ; } / * * Analyse the query for unsupported placeholders . * / if ( preg _match _all ( self : : UNSUPPORTED _PLACEHOLDER _REGEX , $ content , $ matches ) > 0 ) { if ( ! empty ( $ matches [ 0 ] ) ) { foreach ( $ matches [ 0 ] as $ match ) { if ( ' % ' = = = $ match ) { $ this - > phpcs File - > add Error ( 'Found unescaped literal " % % " character . ' , $ i , 'Unescaped Literal ' , array ( $ match ) ) ; } else { $ this - > phpcs File - > add Error ( 'Unsupported placeholder used in $wpdb - >prepare ( ) . Found : " %s " . ' , $ i , 'Unsupported Placeholder ' , array ( $ match ) ) ; } } } unset ( $ match , $ matches ) ; } / * * Analyse the query for quoted placeholders . * / $ regex = ' ` ( ' . $ regex _quote . ' ) % [df Fs ] \ 1 ` ' ; if ( preg _match _all ( $ regex , $ content , $ matches ) > 0 ) { if ( ! empty ( $ matches [ 0 ] ) ) { foreach ( $ matches [ 0 ] as $ match ) { $ this - > phpcs File - > add Error ( 'Simple placeholders should not be quoted in the query string in $wpdb - >prepare ( ) . Found : %s . ' , $ i , 'Quoted Simple Placeholder ' , array ( $ match ) ) ; } } unset ( $ match , $ matches ) ; } / * * Analyse the query for unquoted complex placeholders . * / $ regex = ' ` ( ? < ! ' . $ regex _quote . ' ) ' . self : : PREPARE _PLACEHOLDER _REGEX . ' ( ? ! ' . $ regex _quote . ' ) `x ' ; if ( preg _match _all ( $ regex , $ content , $ matches ) > 0 ) { if ( ! empty ( $ matches [ 0 ] ) ) { foreach ( $ matches [ 0 ] as $ match ) { if ( preg _match ( ' ` % [df Fs ] ` ' , $ match ) ! = = 1 ) { $ this - > phpcs File - > add Warning ( 'Complex placeholders used for values in the query string in $wpdb - >prepare ( ) will NOT be quoted automagically . Found : %s . ' , $ i , 'Unquoted Complex Placeholder ' , array ( $ match ) ) ; } } } unset ( $ match , $ matches ) ; } / * * Check for an ` IN ( %s ) ` clause . * / $ found _in = preg _match _all ( ' ` \s +IN \s * \ ( \s * %s \s * \ ) `i ' , $ content , $ matches ) ; if ( $ found _in > 0 ) { $ valid _in _clauses [ 'uses _in ' ] + = $ found _in ; } unset ( $ found _in ) ; } if ( false = = = $ text _string _tokens _found ) { / / Query string passed in as a variable or function call , nothing to examine . return ; } $ count _diff _whitelisted = $ this - > has _whitelist _comment ( 'Prepared SQLPlaceholders replacement count ' , $ stack Ptr ) ; if ( 0 = = = $ total _placeholders ) { if ( 1 = = = $ total _parameters ) { if ( false = = = $ variable _found & & false = = = $ sql _wildcard _found ) { / * * Only throw this warning if the Prepared SQL sniff won 't throw one about * variables being found . * Also don 't throw it if we just advised to use a replacement variable to pass a * string containing an SQL wildcard . * / $ this - > phpcs File - > add Warning ( 'It is not necessary to prepare a query which doesn \ 't use variable replacement . ' , $ i , 'Unnecessary Prepare ' ) ; } } elseif ( false = = = $ count _diff _whitelisted & & 0 = = = $ valid _in _clauses [ 'uses _in ' ] ) { $ this - > phpcs File - > add Warning ( 'Replacement variables found , but no valid placeholders found in the query . ' , $ i , 'Unfinished Prepare ' ) ; } return ; } if ( 1 = = = $ total _parameters ) { $ this - > phpcs File - > add Error ( 'Placeholders found in the query passed to $wpdb - >prepare ( ) , but no replacements found . Expected %d replacement (s ) parameters . ' , $ stack Ptr , 'Missing Replacements ' , array ( $ total _placeholders ) ) ; return ; } if ( true = = = $ count _diff _whitelisted ) { return ; } $ replacements = $ parameters ; array _shift ( $ replacements ) ; * Verify that the correct amount of replacements have been passed . * / if ( $ total _replacements ! = = $ total _placeholders ) { $ this - > phpcs File - > add Warning ( 'Incorrect number of replacements passed to $wpdb - >prepare ( ) . Found %d replacement parameters , expected %d . ' , $ stack Ptr , 'Replacements Wrong Number ' , array ( $ total _replacements , $ total _placeholders ) ) ; } } 
protected function get _regex _quote _snippet ( $ stripped _content , $ original _content ) { $ regex _quote = $ this - > regex _quote ; if ( $ original _content ! = = $ stripped _content ) { $ quote _style = $ original _content [ 0 ] ; if ( ' " ' = = = $ quote _style ) { $ regex _quote = ' \ \ \ \ " | \ ' ' ; } elseif ( " ' " = = = $ quote _style ) { $ regex _quote = ' " | \ \ \ \ \ ' ' ; } } return $ regex _quote ; } 
protected function analyse _sprintf ( $ sprintf _params ) { $ found = 0 ; unset ( $ sprintf _params [ 1 ] ) ; foreach ( $ sprintf _params as $ sprintf _param ) { if ( strpos ( strtolower ( $ sprintf _param [ 'raw ' ] ) , 'implode ' ) = = = false ) { continue ; } $ implode = $ this - > phpcs File - > find Next ( Tokens : : $ empty Tokens , $ sprintf _param [ 'start ' ] , $ sprintf _param [ 'end ' ] , true ) ; if ( \ T _STRING = = = $ this - > tokens [ $ implode ] [ 'code ' ] & & 'implode ' = = = strtolower ( $ this - > tokens [ $ implode ] [ 'content ' ] ) ) { if ( $ this - > analyse _implode ( $ implode ) = = = true ) { + + $ found ; } } } return $ found ; } 
protected function analyse _implode ( $ implode _token ) { $ implode _params = $ this - > get _function _call _parameters ( $ implode _token ) ; if ( empty ( $ implode _params ) | | \ count ( $ implode _params ) ! = = 2 ) { return false ; } if ( preg _match ( ' ` ^ ( [ " \ ' ] ) , ? \ 1 $ ` ' , $ implode _params [ 1 ] [ 'raw ' ] ) ! = = 1 ) { return false ; } if ( strpos ( strtolower ( $ implode _params [ 2 ] [ 'raw ' ] ) , 'array _fill ' ) = = = false ) { return false ; } $ array _fill = $ this - > phpcs File - > find Next ( Tokens : : $ empty Tokens , $ implode _params [ 2 ] [ 'start ' ] , $ implode _params [ 2 ] [ 'end ' ] , true ) ; if ( \ T _STRING ! = = $ this - > tokens [ $ array _fill ] [ 'code ' ] | | 'array _fill ' ! = = strtolower ( $ this - > tokens [ $ array _fill ] [ 'content ' ] ) ) { return false ; } $ array _fill _params = $ this - > get _function _call _parameters ( $ array _fill ) ; if ( empty ( $ array _fill _params ) | | \ count ( $ array _fill _params ) ! = = 3 ) { return false ; } return ( bool ) preg _match ( ' ` ^ ( [ " \ ' ] ) % [df Fs ] \ 1 $ ` ' , $ array _fill _params [ 3 ] [ 'raw ' ] ) ; } 
public function process _token ( $ stack Ptr ) { $ token = $ this - > tokens [ $ stack Ptr ] ; if ( preg _match ( ' # rel = \ \ \ \ ? [ \ ' " ] ?stylesheet \ \ \ \ ? [ \ ' " ] ? # ' , $ token [ 'content ' ] ) > 0 ) { $ this - > phpcs File - > add Error ( 'Stylesheets must be registered /enqueued via wp _enqueue _style ' , $ stack Ptr , 'Non Enqueued Stylesheet ' ) ; } if ( preg _match ( ' # <script [ ^ > ] * ( ? < =src = ) # ' , $ token [ 'content ' ] ) > 0 ) { $ this - > phpcs File - > add Error ( 'Scripts must be registered /enqueued via wp _enqueue _script ' , $ stack Ptr , 'Non Enqueued Script ' ) ; } } 
public function process _parameters ( $ stack Ptr , $ group _name , $ matched _content , $ parameters ) { $ option _name = $ this - > strip _quotes ( $ parameters [ 1 ] [ 'raw ' ] ) ; $ option _value = $ this - > strip _quotes ( $ parameters [ 2 ] [ 'raw ' ] ) ; if ( isset ( $ this - > whitelisted _options [ $ option _name ] ) ) { $ whitelisted _option = $ this - > whitelisted _options [ $ option _name ] ; if ( ! isset ( $ whitelisted _option [ 'valid _values ' ] ) | | in _array ( strtolower ( $ option _value ) , $ whitelisted _option [ 'valid _values ' ] , true ) ) { return ; } } if ( isset ( $ this - > blacklisted _options [ $ option _name ] ) ) { $ blacklisted _option = $ this - > blacklisted _options [ $ option _name ] ; if ( ! isset ( $ blacklisted _option [ 'invalid _values ' ] ) | | in _array ( strtolower ( $ option _value ) , $ blacklisted _option [ 'invalid _values ' ] , true ) ) { $ this - > phpcs File - > add Error ( ' %s ( %s , %s ) found . %s ' , $ stack Ptr , $ this - > string _to _errorcode ( $ option _name . ' _Blacklisted ' ) , array ( $ matched _content , $ parameters [ 1 ] [ 'raw ' ] , $ parameters [ 2 ] [ 'raw ' ] , $ blacklisted _option [ 'message ' ] , ) ) ; return ; } } $ this - > phpcs File - > add Warning ( ' %s ( %s , %s ) found . Changing configuration values at runtime is strongly discouraged . ' , $ stack Ptr , 'Risky ' , array ( $ matched _content , $ parameters [ 1 ] [ 'raw ' ] , $ parameters [ 2 ] [ 'raw ' ] , ) ) ; } 
public function process _parameters ( $ stack Ptr , $ group _name , $ matched _content , $ parameters ) { * Use a different error code when `false ` is found to allow for excluding * the warning as this will be a conscious choice made by the dev . * / if ( isset ( $ parameters [ 3 ] ) & & 'false ' = = = strtolower ( $ parameters [ 3 ] [ 'raw ' ] ) ) { $ errorcode = 'Found Non Strict False ' ; } $ this - > phpcs File - > add Warning ( 'Not using strict comparison for %s ; supply true for third argument . ' , ( isset ( $ parameters [ 3 ] [ 'start ' ] ) ? $ parameters [ 3 ] [ 'start ' ] : $ parameters [ 1 ] [ 'start ' ] ) , $ errorcode , array ( $ matched _content ) ) ; return ; } } 
public function register ( ) { 
public function process _token ( $ stack Ptr ) { if ( $ this - > has _whitelist _comment ( 'spelling ' , $ stack Ptr ) ) { return ; } if ( \ T _OPEN _SHORT _ARRAY = = = $ this - > tokens [ $ stack Ptr ] [ 'code ' ] & & isset ( $ this - > tokens [ $ stack Ptr ] [ 'bracket _closer ' ] ) ) { return $ this - > tokens [ $ stack Ptr ] [ 'bracket _closer ' ] ; } elseif ( \ T _ARRAY = = = $ this - > tokens [ $ stack Ptr ] [ 'code ' ] & & isset ( $ this - > tokens [ $ stack Ptr ] [ 'parenthesis _closer ' ] ) ) { return $ this - > tokens [ $ stack Ptr ] [ 'parenthesis _closer ' ] ; } if ( isset ( Tokens : : $ oo Scope Tokens [ $ this - > tokens [ $ stack Ptr ] [ 'code ' ] ] ) ) { $ classname = $ this - > phpcs File - > get Declaration Name ( $ stack Ptr ) ; if ( empty ( $ classname ) ) { return ; } if ( preg _match _all ( self : : WP _CLASSNAME _REGEX , $ classname , $ matches , \ PREG _PATTERN _ORDER ) > 0 ) { $ mispelled = $ this - > retrieve _misspellings ( $ matches [ 1 ] ) ; if ( ! empty ( $ mispelled ) ) { $ this - > phpcs File - > add Warning ( 'Please spell "Word Press " correctly . Found : " %s " as part of the class /interface /trait name . ' , $ stack Ptr , 'Misspelled Class Name ' , array ( implode ( ' , ' , $ mispelled ) ) ) ; } } return ; } * Prevent some typical false positives . * / if ( isset ( $ this - > text _and _comment _tokens [ $ this - > tokens [ $ stack Ptr ] [ 'code ' ] ] ) ) { $ offset = 0 ; foreach ( $ matches [ 1 ] as $ key = > $ match _data ) { $ next _offset = ( $ match _data [ 1 ] + \ strlen ( $ match _data [ 0 ] ) ) ; 
protected function retrieve _misspellings ( $ match _stack ) { $ mispelled = array ( ) ; foreach ( $ match _stack as $ match ) { 
public function process _token ( $ stack Ptr ) { if ( $ this - > has _whitelist _comment ( 'slow query ' , $ stack Ptr ) ) { return ; } elseif ( $ this - > has _whitelist _comment ( 'tax _query ' , $ stack Ptr ) ) { return ; } return parent : : process _token ( $ stack Ptr ) ; } 
public function callback ( $ key , $ val , $ line , $ group ) { $ this - > posts _per _page = ( int ) $ this - > posts _per _page ; if ( $ val > $ this - > posts _per _page ) { return 'Detected high pagination limit , ` %s ` is set to ` %s ` ' ; } return false ; } 
public function register ( ) { $ this - > classname _tokens = Tokens : : $ empty Tokens ; $ this - > classname _tokens [ \ T _NS _SEPARATOR ] = \ T _NS _SEPARATOR ; $ this - > classname _tokens [ \ T _STRING ] = \ T _STRING ; $ this - > classname _tokens [ \ T _SELF ] = \ T _SELF ; $ this - > classname _tokens [ \ T _STATIC ] = \ T _STATIC ; $ this - > classname _tokens [ \ T _PARENT ] = \ T _PARENT ; $ this - > classname _tokens [ \ T _ANON _CLASS ] = \ T _ANON _CLASS ; 
public function process _token ( $ stack Ptr ) { * Check for new by reference used in PHP files . * / if ( 'PHP ' = = = $ this - > phpcs File - > tokenizer Type ) { $ prev _non _empty = $ this - > phpcs File - > find Previous ( Tokens : : $ empty Tokens , ( $ stack Ptr - 1 ) , null , true ) ; if ( false ! = = $ prev _non _empty & & 'T _BITWISE _AND ' = = = $ this - > tokens [ $ prev _non _empty ] [ 'type ' ] ) { $ this - > phpcs File - > record Metric ( $ stack Ptr , 'Assigning new by reference ' , 'yes ' ) ; $ this - > phpcs File - > add Error ( 'Assigning the return value of new by reference is no longer supported by PHP . ' , $ stack Ptr , 'New By Reference Found ' ) ; } else { $ this - > phpcs File - > record Metric ( $ stack Ptr , 'Assigning new by reference ' , 'no ' ) ; } } $ next _non _empty _after _class _name = $ this - > phpcs File - > find Next ( $ this - > classname _tokens , ( $ stack Ptr + 1 ) , null , true , null , true ) ; if ( false = = = $ next _non _empty _after _class _name ) { 
public function process _token ( $ stack Ptr ) { $ array _open _close = $ this - > find _array _open _close ( $ stack Ptr ) ; if ( false = = = $ array _open _close ) { * Check if this is a comma at the end of the last item in a single line array . * / if ( true = = = $ single _line & & $ item _index = = = $ array _item _count ) { if ( true = = = $ is _comma ) { $ fix = $ this - > phpcs File - > add Fixable Error ( 'Comma not allowed after last value in single -line array declaration ' , $ maybe _comma , 'Comma After Last ' ) ; if ( true = = = $ fix ) { $ this - > phpcs File - > fixer - > replace Token ( $ maybe _comma , ' ' ) ; } } continue ; } $ last _content = $ this - > phpcs File - > find Previous ( Tokens : : $ empty Tokens , $ item [ 'end ' ] , $ item [ 'start ' ] , true ) ; if ( false = = = $ last _content ) { * Make sure every item in a multi -line array has a comma at the end . * * Should in reality only be triggered by the last item in a multi -line array * as otherwise we 'd have a parse error already . * / if ( false = = = $ is _comma & & false = = = $ single _line ) { $ fix = $ this - > phpcs File - > add Fixable Error ( 'Each array item in a multi -line array declaration must end in a comma ' , $ last _content , 'No Comma ' ) ; if ( true = = = $ fix ) { $ this - > phpcs File - > fixer - > add Content ( $ last _content , ' , ' ) ; } } if ( false = = = $ is _comma ) { / / Can 't check spacing around the comma if there is no comma . continue ; } if ( $ last _content ! = = $ item [ 'end ' ] * No need to worry about removing too much whitespace in * combination with a ` * is part of the comment , so we 're good . * / break ; } } $ this - > phpcs File - > fixer - > end Changeset ( ) ; } } if ( ! isset ( $ this - > tokens [ ( $ maybe _comma + 1 ) ] ) ) { / / Shouldn 't be able to happen , but just in case . continue ; } $ next _token = $ this - > tokens [ ( $ maybe _comma + 1 ) ] ; if ( \ T _WHITESPACE = = = $ next _token [ 'code ' ] ) { if ( false = = = $ single _line & & $ this - > phpcs File - > eol Char = = = $ next _token [ 'content ' ] ) { continue ; } $ next _non _whitespace = $ this - > phpcs File - > find Next ( \ T _WHITESPACE , ( $ maybe _comma + 1 ) , $ closer , true ) ; if ( false = = = $ next _non _whitespace | | ( false = = = $ single _line & & $ this - > tokens [ $ next _non _whitespace ] [ 'line ' ] = = = $ this - > tokens [ $ maybe _comma ] [ 'line ' ] & & ( \ T _COMMENT = = = $ this - > tokens [ $ next _non _whitespace ] [ 'code ' ] | | isset ( Tokens : : $ phpcs Comment Tokens [ $ this - > tokens [ $ next _non _whitespace ] [ 'code ' ] ] ) ) ) ) { continue ; } $ space _length = $ next _token [ 'length ' ] ; if ( 1 = = = $ space _length ) { continue ; } $ fix = $ this - > phpcs File - > add Fixable Error ( 'Expected 1 space between comma and " %s " ; %s found ' , $ maybe _comma , 'Space After Comma ' , array ( $ this - > tokens [ $ next _non _whitespace ] [ 'content ' ] , $ space _length , ) ) ; if ( true = = = $ fix ) { $ this - > phpcs File - > fixer - > replace Token ( ( $ maybe _comma + 1 ) , ' ' ) ; } } else { 
protected function process Token Outside Scope ( File $ phpcs File , $ stack Ptr ) { $ function Name = $ phpcs File - > get Declaration Name ( $ stack Ptr ) ; if ( ! isset ( $ function Name ) ) { 
protected function process Token Within Scope ( File $ phpcs File , $ stack Ptr , $ curr Scope ) { $ tokens = $ phpcs File - > get Tokens ( ) ; 
public function process _token ( $ stack Ptr ) { if ( ! isset ( $ this - > tab _width ) ) { $ this - > tab _width = PHPCSHelper : : get _tab _width ( $ this - > phpcs File ) ; } * Indentation whitespace for subsequent lines of multi -line comments * are tokenized as part of the comment . * / $ comment = ltrim ( $ this - > tokens [ $ i ] [ 'content ' ] ) ; $ whitespace = str _replace ( $ comment , ' ' , $ this - > tokens [ $ i ] [ 'content ' ] ) ; $ length = \ strlen ( $ whitespace ) ; $ spaces = ( $ length % $ this - > tab _width ) ; if ( isset ( $ comment [ 0 ] ) & & ' * ' = = = $ comment [ 0 ] & & 0 ! = = $ spaces ) { - - $ spaces ; } break ; case 'T _INLINE _HTML ' : if ( $ this - > tokens [ $ i ] [ 'content ' ] = = = $ this - > phpcs File - > eol Char ) { $ spaces = 0 ; } else { $ content = ltrim ( $ this - > tokens [ $ i ] [ 'content ' ] ) ; $ whitespace = str _replace ( $ content , ' ' , $ this - > tokens [ $ i ] [ 'content ' ] ) ; $ spaces = ( \ strlen ( $ whitespace ) % $ this - > tab _width ) ; } if ( isset ( $ content [ 0 ] ) & & ' * ' = = = $ content [ 0 ] & & 0 ! = = $ spaces ) { - - $ spaces ; } break ; } if ( $ spaces > 0 & & ! $ this - > has _whitelist _comment ( 'precision alignment ' , $ i ) ) { $ this - > phpcs File - > add Warning ( 'Found precision alignment of %s spaces . ' , $ i , 'Found ' , array ( $ spaces ) ) ; } } 
public static function set _config _data ( $ key , $ value , $ temp = false ) { Config : : set Config Data ( $ key , $ value , $ temp ) ; } 
public static function get _tab _width ( File $ phpcs File ) { $ tab _width = 4 ; if ( isset ( $ phpcs File - > config - > tab Width ) & & $ phpcs File - > config - > tab Width > 0 ) { $ tab _width = $ phpcs File - > config - > tab Width ; } return $ tab _width ; } 
public static function ignore _annotations ( File $ phpcs File = null ) { if ( isset ( $ phpcs File , $ phpcs File - > config - > annotations ) ) { return ! $ phpcs File - > config - > annotations ; } else { $ annotations = Config : : get Config Data ( 'annotations ' ) ; if ( isset ( $ annotations ) ) { return ! $ annotations ; } } } 
public function process _token ( $ stack Ptr ) { $ token _code = $ this - > tokens [ $ stack Ptr ] [ 'code ' ] ; $ typecast = str _replace ( ' ' , ' ' , $ this - > tokens [ $ stack Ptr ] [ 'content ' ] ) ; $ typecast _lc = strtolower ( $ typecast ) ; switch ( $ token _code ) { case \ T _DOUBLE _CAST : if ( ' (float ) ' ! = = $ typecast _lc ) { $ fix = $ this - > phpcs File - > add Fixable Error ( 'Normalized type keywords must be used ; expected " (float ) " but found " %s " ' , $ stack Ptr , 'Double Real Found ' , array ( $ typecast ) ) ; if ( true = = = $ fix ) { $ this - > phpcs File - > fixer - > replace Token ( $ stack Ptr , ' (float ) ' ) ; } } break ; case \ T _UNSET _CAST : $ this - > phpcs File - > add Warning ( 'Using the " (unset ) " cast is strongly discouraged . Use the "unset ( ) " language construct or assign "null " as the value to the variable instead . ' , $ stack Ptr , 'Unset Found ' ) ; break ; case \ T _STRING _CAST : case \ T _BINARY _CAST : if ( \ T _STRING _CAST = = = $ token _code & & ' (binary ) ' ! = = $ typecast _lc ) { break ; } $ this - > phpcs File - > add Warning ( 'Using binary casting is strongly discouraged . Found : " %s " ' , $ stack Ptr , 'Binary Found ' , array ( $ typecast ) ) ; break ; } } 
public function register ( ) { $ this - > empty _tokens = Tokens : : $ empty Tokens ; $ this - > empty _tokens [ \ T _NS _SEPARATOR ] = \ T _NS _SEPARATOR ; $ this - > empty _tokens [ \ T _BITWISE _AND ] = \ T _BITWISE _AND ; return array ( \ T _ASPERAND , ) ; } 
public function process _token ( $ stack Ptr ) { * Check if the error silencing is done for one of the whitelisted functions . * / $ next _non _empty = $ this - > phpcs File - > find Next ( $ this - > empty _tokens , ( $ stack Ptr + 1 ) , null , true , null , true ) ; if ( false ! = = $ next _non _empty & & \ T _STRING = = = $ this - > tokens [ $ next _non _empty ] [ 'code ' ] ) { $ has _parenthesis = $ this - > phpcs File - > find Next ( Tokens : : $ empty Tokens , ( $ next _non _empty + 1 ) , null , true , null , true ) ; if ( false ! = = $ has _parenthesis & & \ T _OPEN _PARENTHESIS = = = $ this - > tokens [ $ has _parenthesis ] [ 'code ' ] ) { $ function _name = strtolower ( $ this - > tokens [ $ next _non _empty ] [ 'content ' ] ) ; if ( ( true = = = $ this - > use _default _whitelist & & isset ( $ this - > function _whitelist [ $ function _name ] ) = = = true ) | | in _array ( $ function _name , $ this - > custom _whitelist , true ) = = = true ) { $ this - > phpcs File - > record Metric ( $ stack Ptr , 'Error silencing ' , 'whitelisted function call : ' . $ function _name ) ; return ; } } } } $ this - > context _length = ( int ) $ this - > context _length ; $ context _length = $ this - > context _length ; if ( $ this - > context _length < = 0 ) { $ context _length = 2 ; } 
public function register ( ) { $ tokens = parent : : register ( ) ; $ tokens [ \ T _BOOLEAN _NOT ] = \ T _BOOLEAN _NOT ; $ tokens [ \ T _INSTANCEOF ] = \ T _INSTANCEOF ; $ logical _operators = Tokens : : $ boolean Operators ; 
public function register ( ) { 
public function process _token ( $ stack Ptr ) { $ token = $ this - > tokens [ $ stack Ptr ] ; * Examine variables within a function scope based on a `global ` statement in the * function . * Examine variable not within a function scope and access to the ` $GLOBALS ` * variable based on the variable token . * / $ in _function _scope = $ this - > phpcs File - > has Condition ( $ stack Ptr , array ( \ T _FUNCTION , \ T _CLOSURE ) ) ; if ( \ T _VARIABLE = = = $ token [ 'code ' ] & & ( ' $GLOBALS ' = = = $ token [ 'content ' ] | | ( false = = = $ in _function _scope & & false = = = $ this - > treat _files _as _scoped ) ) ) { return $ this - > process _variable _assignment ( $ stack Ptr ) ; } elseif ( \ T _GLOBAL = = = $ token [ 'code ' ] & & ( true = = = $ in _function _scope | | true = = = $ this - > treat _files _as _scoped ) ) { return $ this - > process _global _statement ( $ stack Ptr , $ in _function _scope ) ; } } 
protected function process _variable _assignment ( $ stack Ptr ) { if ( $ this - > has _whitelist _comment ( 'override ' , $ stack Ptr ) = = = true ) { return ; } $ token = $ this - > tokens [ $ stack Ptr ] ; $ var _name = substr ( $ token [ 'content ' ] , 1 ) ; * If the globals array key contains a variable , constant , function call * or interpolated variable , bow out . * / if ( \ T _VARIABLE = = = $ this - > tokens [ $ ptr ] [ 'code ' ] | | \ T _STRING = = = $ this - > tokens [ $ ptr ] [ 'code ' ] | | \ T _DOUBLE _QUOTED _STRING = = = $ this - > tokens [ $ ptr ] [ 'code ' ] ) { return ; } if ( \ T _CONSTANT _ENCAPSED _STRING = = = $ this - > tokens [ $ ptr ] [ 'code ' ] ) { $ var _name . = $ this - > strip _quotes ( $ this - > tokens [ $ ptr ] [ 'content ' ] ) ; } } if ( ' ' = = = $ var _name ) { * Is this one of the WP global variables ? * / if ( isset ( $ this - > wp _globals [ $ var _name ] ) = = = false ) { return ; } if ( false = = = $ this - > is _assignment ( $ stack Ptr ) & & false = = = $ this - > is _foreach _as ( $ stack Ptr ) ) { return ; } if ( isset ( $ this - > tokens [ $ stack Ptr ] [ 'nested _parenthesis ' ] ) ) { foreach ( $ this - > tokens [ $ stack Ptr ] [ 'nested _parenthesis ' ] as $ opener = > $ closer ) { if ( isset ( $ this - > tokens [ $ opener ] [ 'parenthesis _owner ' ] ) & & ( \ T _FUNCTION = = = $ this - > tokens [ $ this - > tokens [ $ opener ] [ 'parenthesis _owner ' ] ] [ 'code ' ] | | \ T _CLOSURE = = = $ this - > tokens [ $ this - > tokens [ $ opener ] [ 'parenthesis _owner ' ] ] [ 'code ' ] ) ) { return ; } } unset ( $ opener , $ closer ) ; } if ( true = = = $ this - > is _class _property ( $ stack Ptr ) ) { return ; } 
protected function process _global _statement ( $ stack Ptr , $ in _function _scope ) { $ search = array ( ) ; $ ptr = ( $ stack Ptr + 1 ) ; while ( isset ( $ this - > tokens [ $ ptr ] ) ) { $ var = $ this - > tokens [ $ ptr ] ; * Search for assignments to the imported global variables within the relevant scope . * / $ start = $ ptr ; if ( true = = = $ in _function _scope ) { $ function _cond = $ this - > phpcs File - > get Condition ( $ stack Ptr , \ T _FUNCTION ) ; $ closure _cond = $ this - > phpcs File - > get Condition ( $ stack Ptr , \ T _CLOSURE ) ; $ scope _cond = max ( $ function _cond , $ closure _cond ) ; 
protected function add _error ( $ stack Ptr , $ data = array ( ) ) { if ( empty ( $ data ) ) { $ data [ ] = $ this - > tokens [ $ stack Ptr ] [ 'content ' ] ; } $ this - > phpcs File - > add Error ( 'Overriding Word Press globals is prohibited . Found assignment to %s ' , $ stack Ptr , 'Prohibited ' , $ data ) ; } 
public function process _token ( $ stack Ptr ) { $ this - > spaces _before _closure _open _paren = ( int ) $ this - > spaces _before _closure _open _paren ; if ( isset ( $ this - > tokens [ ( $ stack Ptr + 1 ) ] ) & & \ T _WHITESPACE ! = = $ this - > tokens [ ( $ stack Ptr + 1 ) ] [ 'code ' ] & & ! ( \ T _ELSE = = = $ this - > tokens [ $ stack Ptr ] [ 'code ' ] & & \ T _COLON = = = $ this - > tokens [ ( $ stack Ptr + 1 ) ] [ 'code ' ] ) & & ! ( \ T _CLOSURE = = = $ this - > tokens [ $ stack Ptr ] [ 'code ' ] & & 0 > = $ this - > spaces _before _closure _open _paren ) ) { $ error = 'Space after opening control structure is required ' ; $ fix = $ this - > phpcs File - > add Fixable Error ( $ error , $ stack Ptr , 'No Space After Structure Open ' ) ; if ( true = = = $ fix ) { $ this - > phpcs File - > fixer - > add Content ( $ stack Ptr , ' ' ) ; } } if ( ! isset ( $ this - > tokens [ $ stack Ptr ] [ 'scope _closer ' ] ) ) { if ( \ T _USE = = = $ this - > tokens [ $ stack Ptr ] [ 'code ' ] & & 'closure ' = = = $ this - > get _use _type ( $ stack Ptr ) ) { $ scope Opener = $ this - > phpcs File - > find Next ( \ T _OPEN _CURLY _BRACKET , ( $ stack Ptr + 1 ) ) ; $ scope Closer = $ this - > tokens [ $ scope Opener ] [ 'scope _closer ' ] ; } elseif ( \ T _WHILE ! = = $ this - > tokens [ $ stack Ptr ] [ 'code ' ] ) { return ; } } else { $ scope Opener = $ this - > tokens [ $ stack Ptr ] [ 'scope _opener ' ] ; $ scope Closer = $ this - > tokens [ $ stack Ptr ] [ 'scope _closer ' ] ; } * PHPCS annotations , like normal inline comments , are tokenized including * the new line at the end , so don 't add any extra as it would cause a fixer * conflict . * / if ( \ T _COMMENT ! = = $ this - > tokens [ $ last Content ] [ 'code ' ] & & ! isset ( Tokens : : $ phpcs Comment Tokens [ $ this - > tokens [ $ last Content ] [ 'code ' ] ] ) ) { $ this - > phpcs File - > fixer - > add Newline Before ( $ j ) ; } $ this - > phpcs File - > fixer - > end Changeset ( ) ; } break ; } } } } unset ( $ ignore ) ; } if ( ! isset ( $ scope Closer ) | | true ! = = $ this - > blank _line _after _check ) { return ; } / / { @internal This is just for the blank line check . Only whitespace should be considered , / / not "other " empty tokens . } } $ trailing Content = $ this - > phpcs File - > find Next ( \ T _WHITESPACE , ( $ scope Closer + 1 ) , null , true ) ; if ( false = = = $ trailing Content ) { return ; } if ( \ T _COMMENT = = = $ this - > tokens [ $ trailing Content ] [ 'code ' ] | | isset ( Tokens : : $ phpcs Comment Tokens [ $ this - > tokens [ $ trailing Content ] [ 'code ' ] ] ) ) { / / Special exception for code where the comment about / / an ELSE or ELSEIF is written between the control structures . $ next Code = $ this - > phpcs File - > find Next ( Tokens : : $ empty Tokens , ( $ scope Closer + 1 ) , null , true ) ; if ( \ T _ELSE = = = $ this - > tokens [ $ next Code ] [ 'code ' ] | | \ T _ELSEIF = = = $ this - > tokens [ $ next Code ] [ 'code ' ] ) { $ trailing Content = $ next Code ; } / / Move past end comments . if ( $ this - > tokens [ $ trailing Content ] [ 'line ' ] = = = $ this - > tokens [ $ scope Closer ] [ 'line ' ] ) { if ( preg _match ( ' ` ^ 
public function get Groups ( ) { 
public function process _matched _token ( $ stack Ptr , $ group _name , $ matched _content ) { $ this - > get _wp _version _from _cl ( ) ; $ function _name = strtolower ( $ matched _content ) ; $ message = ' %s ( ) has been deprecated since Word Press version %s . ' ; $ data = array ( $ matched _content , $ this - > deprecated _functions [ $ function _name ] [ 'version ' ] , ) ; if ( ! empty ( $ this - > deprecated _functions [ $ function _name ] [ 'alt ' ] ) ) { $ message . = ' Use %s instead . ' ; $ data [ ] = $ this - > deprecated _functions [ $ function _name ] [ 'alt ' ] ; } $ this - > add Message ( $ message , $ stack Ptr , ( version _compare ( $ this - > deprecated _functions [ $ function _name ] [ 'version ' ] , $ this - > minimum _supported _version , ' < ' ) ) , $ this - > string _to _errorcode ( $ matched _content . 'Found ' ) , $ data ) ; } 
public function process _token ( $ stack Ptr ) { if ( \ T _WHITESPACE ! = = $ this - > tokens [ ( $ stack Ptr - 1 ) ] [ 'code ' ] ) { $ error = 'No space before opening casting parenthesis is prohibited ' ; $ fix = $ this - > phpcs File - > add Fixable Error ( $ error , $ stack Ptr , 'No Space Before Open Parenthesis ' ) ; if ( true = = = $ fix ) { $ this - > phpcs File - > fixer - > add Content Before ( $ stack Ptr , ' ' ) ; } } } 
protected function setup _groups ( $ key ) { 
public function process _token ( $ stack Ptr ) { $ this - > excluded _groups = $ this - > merge _custom _array ( $ this - > exclude ) ; if ( array _diff _key ( $ this - > groups , $ this - > excluded _groups ) = = = array ( ) ) { 
public function is _targetted _token ( $ stack Ptr ) { 
public function check _for _matches ( $ stack Ptr ) { $ token _content = strtolower ( $ this - > tokens [ $ stack Ptr ] [ 'content ' ] ) ; $ skip _to = array ( ) ; foreach ( $ this - > groups as $ group Name = > $ group ) { if ( isset ( $ this - > excluded _groups [ $ group Name ] ) ) { continue ; } if ( isset ( $ group [ 'whitelist ' ] [ $ token _content ] ) ) { continue ; } if ( preg _match ( $ group [ 'regex ' ] , $ token _content ) = = = 1 ) { $ skip _to [ ] = $ this - > process _matched _token ( $ stack Ptr , $ group Name , $ token _content ) ; } } if ( empty ( $ skip _to ) | | min ( $ skip _to ) = = = 0 ) { return ; } return min ( $ skip _to ) ; } 
public function process _matched _token ( $ stack Ptr , $ group _name , $ matched _content ) { $ this - > add Message ( $ this - > groups [ $ group _name ] [ 'message ' ] , $ stack Ptr , ( 'error ' = = = $ this - > groups [ $ group _name ] [ 'type ' ] ) , $ this - > string _to _errorcode ( $ group _name . ' _ ' . $ matched _content ) , array ( $ matched _content ) ) ; } 
public function register ( ) { 
public function get Groups ( ) { $ this - > target _functions = $ this - > hook Invoke Functions ; $ this - > target _functions [ 'define ' ] = true ; return parent : : get Groups ( ) ; } 
public function process _token ( $ stack Ptr ) { if ( $ this - > has _whitelist _comment ( 'prefix ' , $ stack Ptr ) ) { return ; } 
protected function process _variable _variable ( $ stack Ptr ) { static $ indicators = array ( \ T _OPEN _CURLY _BRACKET = > true , \ T _VARIABLE = > true , ) ; * Local variable variables in a function do not need to be prefixed . * But a variable variable could evaluate to the name of an imported global * variable . * Not concerned with imported variable variables (global . . ) as that has been * forbidden since PHP 7 . 0 . Presuming cross -version code and if not , that * is for the PHPCompatibility standard to detect . * / if ( $ this - > phpcs File - > has Condition ( $ stack Ptr , array ( \ T _FUNCTION , \ T _CLOSURE ) ) = = = true ) { $ condition = $ this - > phpcs File - > get Condition ( $ stack Ptr , \ T _FUNCTION ) ; if ( false = = = $ condition ) { $ condition = $ this - > phpcs File - > get Condition ( $ stack Ptr , \ T _CLOSURE ) ; } $ has _global = $ this - > phpcs File - > find Previous ( \ T _GLOBAL , ( $ stack Ptr - 1 ) , $ this - > tokens [ $ condition ] [ 'scope _opener ' ] ) ; if ( false = = = $ has _global ) { 
protected function process _variable _assignment ( $ stack Ptr ) { if ( false = = = $ this - > is _assignment ( $ stack Ptr ) & & false = = = $ this - > is _foreach _as ( $ stack Ptr ) ) { return ; } $ is _error = true ; $ variable _name = substr ( $ this - > tokens [ $ stack Ptr ] [ 'content ' ] , 1 ) ; 
public function process _parameters ( $ stack Ptr , $ group _name , $ matched _content , $ parameters ) { 
private function is _prefixed ( $ stack Ptr , $ name ) { foreach ( $ this - > validated _prefixes as $ prefix ) { if ( stripos ( $ name , $ prefix ) = = = 0 ) { $ this - > phpcs File - > record Metric ( $ stack Ptr , 'Prefix all globals : allowed prefixes ' , $ prefix ) ; return true ; } } return false ; } 
private function variable _prefixed _or _whitelisted ( $ stack Ptr , $ name ) { 
private function validate _prefixes ( ) { if ( $ this - > previous _prefixes = = = $ this - > prefixes ) { return ; } * Replace non -word characters in the prefix with a regex snippet , but only if the * string doesn 't already contain namespace separators . * / $ is _regex = false ; if ( strpos ( $ prefix , ' \ \ ' ) = = = false & & preg _match ( ' ` [ _ \W ] ` ' , $ prefix ) > 0 ) { $ prefix = preg _replace ( ' ` ( [ _ \W ] ) ` ' , ' [ \ \ \ \ \ \ \ \ $ 1 ] ' , $ prefix LC ) ; $ is _regex = true ; } $ ns _prefixes [ $ prefix LC ] = array ( 'prefix ' = > $ prefix , 'is _regex ' = > $ is _regex , ) ; } 
private function record _potential _prefix _metric ( $ stack Ptr , $ construct _name ) { if ( preg _match ( ' ` ^ ( [A -Z ] * [a -z 0 - 9 ] * + ) ` ' , ltrim ( $ construct _name , ' \ $ _ ' ) , $ matches ) > 0 & & isset ( $ matches [ 1 ] ) & & ' ' ! = = $ matches [ 1 ] ) { $ this - > phpcs File - > record Metric ( $ stack Ptr , 'Prefix all globals : potential prefixes - start of non -prefixed construct ' , strtolower ( $ matches [ 1 ] ) ) ; } } 
protected function setup _groups ( ) { $ this - > groups _cache = $ this - > get Groups ( ) ; if ( empty ( $ this - > groups _cache ) & & empty ( self : : $ groups ) ) { return false ; } 
public function process _token ( $ stack Ptr ) { $ this - > excluded _groups = $ this - > merge _custom _array ( $ this - > exclude ) ; if ( array _diff _key ( $ this - > groups _cache , $ this - > excluded _groups ) = = = array ( ) ) { * Covers : * $foo = array ( 'bar ' = > 'taz ' ) ; * $foo [ 'bar ' ] = $taz ; * / if ( \ in _array ( $ token [ 'code ' ] , array ( \ T _CLOSE _SQUARE _BRACKET , \ T _DOUBLE _ARROW ) , true ) ) { $ operator = $ stack Ptr ; 
public function process _token ( $ stack Ptr ) { $ array _open _close = $ this - > find _array _open _close ( $ stack Ptr ) ; if ( false = = = $ array _open _close ) { 
protected function process _single _line _array ( $ stack Ptr , $ items , $ opener , $ closer ) { $ next _arrow = $ this - > phpcs File - > find Next ( \ T _DOUBLE _ARROW , ( $ opener + 1 ) , $ closer ) ; while ( false ! = = $ next _arrow ) { if ( \ T _WHITESPACE = = = $ this - > tokens [ ( $ next _arrow - 1 ) ] [ 'code ' ] ) { $ space _length = $ this - > tokens [ ( $ next _arrow - 1 ) ] [ 'length ' ] ; if ( 1 ! = = $ space _length ) { $ error = 'Expected 1 space between " %s " and double arrow ; %s found ' ; $ data = array ( $ this - > tokens [ ( $ next _arrow - 2 ) ] [ 'content ' ] , $ space _length , ) ; $ fix = $ this - > phpcs File - > add Fixable Warning ( $ error , $ next _arrow , 'Space Before Double Arrow ' , $ data ) ; if ( true = = = $ fix ) { $ this - > phpcs File - > fixer - > replace Token ( ( $ next _arrow - 1 ) , ' ' ) ; } } } 
protected function process _multi _line _array ( $ stack Ptr , $ items , $ opener , $ closer ) { $ this - > max Column = ( int ) $ this - > max Column ; $ this - > validate _align _multiline _items ( ) ; $ index _end _cols = array ( ) ; * Determine whether the operators for multi -line items should be aligned . * / if ( 'always ' = = = $ this - > align Multiline Items ) { $ align Multiline Items = true ; } elseif ( 'never ' = = = $ this - > align Multiline Items ) { $ align Multiline Items = false ; } else { $ percentage = ( string ) round ( ( $ multi _line _count / $ total _items ) * 1 0 0 , 0 ) ; * If necessary , rebuild the $index _end _cols and $double _arrow _cols arrays * excluding multi -line items . * / if ( false = = = $ align Multiline Items ) { $ select _index _end _cols = array ( ) ; $ double _arrow _cols = array ( ) ; foreach ( $ items as $ item ) { if ( false = = = $ item [ 'single _line ' ] ) { continue ; } if ( ( $ item [ 'last _index _col ' ] + 2 ) < = $ this - > max Column ) { $ select _index _end _cols [ ] = $ item [ 'last _index _col ' ] ; } if ( ! isset ( $ double _arrow _cols [ $ this - > tokens [ $ item [ 'operator Ptr ' ] ] [ 'column ' ] ] ) ) { $ double _arrow _cols [ $ this - > tokens [ $ item [ 'operator Ptr ' ] ] [ 'column ' ] ] = 1 ; } else { $ double _arrow _cols [ $ this - > tokens [ $ item [ 'operator Ptr ' ] ] [ 'column ' ] ] + + ; } } } if ( ! empty ( $ select _index _end _cols ) ) { $ max _index _width = max ( $ select _index _end _cols ) ; } else { $ max _index _width = max ( $ index _end _cols ) ; } $ expected _col = ( $ max _index _width + 2 ) ; if ( false = = = $ this - > exact & & ! empty ( $ double _arrow _cols ) ) { arsort ( $ double _arrow _cols , \ SORT _NUMERIC ) ; reset ( $ double _arrow _cols ) ; $ count = current ( $ double _arrow _cols ) ; if ( $ count > 1 | | ( 1 = = = $ count & & \ count ( $ items ) = = = 1 ) ) { * Verify and correct the spacing around the double arrows . * / foreach ( $ items as $ item ) { if ( $ this - > tokens [ $ item [ 'operator Ptr ' ] ] [ 'column ' ] = = = $ expected _col & & $ this - > tokens [ $ item [ 'operator Ptr ' ] ] [ 'line ' ] = = = $ this - > tokens [ $ item [ 'last _index _token ' ] ] [ 'line ' ] ) { * Deal with index sizes larger than max Column and with multi -line * array items which should not be aligned . * / if ( ( $ item [ 'last _index _col ' ] + 2 ) > $ this - > max Column | | ( false = = = $ align Multiline Items & & false = = = $ item [ 'single _line ' ] ) ) { if ( ( $ item [ 'last _index _col ' ] + 2 ) = = = $ this - > tokens [ $ item [ 'operator Ptr ' ] ] [ 'column ' ] & & $ this - > tokens [ $ item [ 'operator Ptr ' ] ] [ 'line ' ] = = = $ this - > tokens [ $ item [ 'last _index _token ' ] ] [ 'line ' ] ) { * Deal with the space before double arrows in all other cases . * / $ expected _whitespace = $ expected _col - ( $ this - > tokens [ $ item [ 'last _index _token ' ] ] [ 'column ' ] + $ this - > tokens [ $ item [ 'last _index _token ' ] ] [ 'length ' ] ) ; $ fix = $ this - > phpcs File - > add Fixable Warning ( 'Array double arrow not aligned correctly ; expected %s space (s ) between " %s " and double arrow , but found %s . ' , $ item [ 'operator Ptr ' ] , 'Double Arrow Not Aligned ' , array ( $ expected _whitespace , $ this - > tokens [ $ item [ 'last _index _token ' ] ] [ 'content ' ] , $ before , ) ) ; if ( true = = = $ fix ) { if ( 0 = = = $ before | | 'newline ' = = = $ before ) { $ this - > phpcs File - > fixer - > begin Changeset ( ) ; 
protected function validate _align _multiline _items ( ) { $ align Multiline Items = $ this - > align Multiline Items ; if ( 'always ' = = = $ align Multiline Items | | 'never ' = = = $ align Multiline Items ) { return ; } else { 
public function process _token ( $ stack Ptr ) { if ( ! $ this - > is _wpdb _method _call ( $ stack Ptr , $ this - > methods ) ) { return ; } if ( $ this - > has _whitelist _comment ( 'unprepared SQL ' , $ stack Ptr ) ) { return ; } for ( $ this - > i ; $ this - > i < $ this - > end ; $ this - > i + + ) { if ( isset ( $ this - > ignored _tokens [ $ this - > tokens [ $ this - > i ] [ 'code ' ] ] ) ) { continue ; } if ( \ T _DOUBLE _QUOTED _STRING = = = $ this - > tokens [ $ this - > i ] [ 'code ' ] | | \ T _HEREDOC = = = $ this - > tokens [ $ this - > i ] [ 'code ' ] ) { $ bad _variables = array _filter ( $ this - > get _interpolated _variables ( $ this - > tokens [ $ this - > i ] [ 'content ' ] ) , function ( $ symbol ) { return ( 'wpdb ' ! = = $ symbol ) ; } ) ; foreach ( $ bad _variables as $ bad _variable ) { $ this - > phpcs File - > add Error ( 'Use placeholders and $wpdb - >prepare ( ) ; found interpolated variable $ %s at %s ' , $ this - > i , 'Interpolated Not Prepared ' , array ( $ bad _variable , $ this - > tokens [ $ this - > i ] [ 'content ' ] , ) ) ; } continue ; } if ( \ T _VARIABLE = = = $ this - > tokens [ $ this - > i ] [ 'code ' ] ) { if ( ' $wpdb ' = = = $ this - > tokens [ $ this - > i ] [ 'content ' ] ) { $ this - > is _wpdb _method _call ( $ this - > i , $ this - > methods ) ; continue ; } if ( $ this - > is _safe _casted ( $ this - > i ) ) { continue ; } } if ( \ T _STRING = = = $ this - > tokens [ $ this - > i ] [ 'code ' ] ) { if ( isset ( $ this - > SQLEscaping Functions [ $ this - > tokens [ $ this - > i ] [ 'content ' ] ] ) | | isset ( $ this - > SQLAuto Escaped Functions [ $ this - > tokens [ $ this - > i ] [ 'content ' ] ] ) ) { 
public function process _token ( $ stack Ptr ) { switch ( $ this - > tokens [ $ stack Ptr ] [ 'type ' ] ) { case 'T _SEMICOLON ' : $ prev Non Empty = $ this - > phpcs File - > find Previous ( Tokens : : $ empty Tokens , ( $ stack Ptr - 1 ) , null , true ) ; if ( false = = = $ prev Non Empty | | ( \ T _SEMICOLON ! = = $ this - > tokens [ $ prev Non Empty ] [ 'code ' ] & & \ T _OPEN _TAG ! = = $ this - > tokens [ $ prev Non Empty ] [ 'code ' ] & & \ T _OPEN _TAG _WITH _ECHO ! = = $ this - > tokens [ $ prev Non Empty ] [ 'code ' ] ) ) { return ; } if ( isset ( $ this - > tokens [ $ stack Ptr ] [ 'nested _parenthesis ' ] ) ) { $ nested = $ this - > tokens [ $ stack Ptr ] [ 'nested _parenthesis ' ] ; $ last _closer = array _pop ( $ nested ) ; if ( isset ( $ this - > tokens [ $ last _closer ] [ 'parenthesis _owner ' ] ) & & \ T _FOR = = = $ this - > tokens [ $ this - > tokens [ $ last _closer ] [ 'parenthesis _owner ' ] ] [ 'code ' ] ) { * Check for superfluous whitespace after the semi -colon which will be * removed as the ` < ?php ` open tag token already contains whitespace , * either a space or a new line and in case of a new line , the indentation * should be done via tabs , so spaces can be safely removed . * / if ( \ T _WHITESPACE = = = $ this - > tokens [ ( $ stack Ptr + 1 ) ] [ 'code ' ] ) { $ replacement = str _replace ( ' ' , ' ' , $ this - > tokens [ ( $ stack Ptr + 1 ) ] [ 'content ' ] ) ; $ this - > phpcs File - > fixer - > replace Token ( ( $ stack Ptr + 1 ) , $ replacement ) ; } } for ( $ i = $ stack Ptr ; $ i > $ prev Non Empty ; $ i - - ) { if ( \ T _SEMICOLON ! = = $ this - > tokens [ $ i ] [ 'code ' ] & & \ T _WHITESPACE ! = = $ this - > tokens [ $ i ] [ 'code ' ] ) { break ; } $ this - > phpcs File - > fixer - > replace Token ( $ i , ' ' ) ; } $ this - > phpcs File - > fixer - > end Changeset ( ) ; } break ; case 'T _CLOSE _TAG ' : $ prev Non Empty = $ this - > phpcs File - > find Previous ( \ T _WHITESPACE , ( $ stack Ptr - 1 ) , null , true ) ; if ( false = = = $ prev Non Empty | | ( \ T _OPEN _TAG ! = = $ this - > tokens [ $ prev Non Empty ] [ 'code ' ] & & \ T _OPEN _TAG _WITH _ECHO ! = = $ this - > tokens [ $ prev Non Empty ] [ 'code ' ] ) ) { return ; } $ fix = $ this - > phpcs File - > add Fixable Warning ( 'Empty PHP open /close tag combination detected . ' , $ prev Non Empty , 'Empty PHPOpen Close Tags Detected ' ) ; if ( true = = = $ fix ) { $ this - > phpcs File - > fixer - > begin Changeset ( ) ; for ( $ i = $ prev Non Empty ; $ i < = $ stack Ptr ; $ i + + ) { $ this - > phpcs File - > fixer - > replace Token ( $ i , ' ' ) ; } $ this - > phpcs File - > fixer - > end Changeset ( ) ; } break ; default : break ; } } 
public function process _token ( $ stack Ptr ) { $ this - > merge Function Lists ( ) ; $ function = $ this - > tokens [ $ stack Ptr ] [ 'content ' ] ; * If this is a function callback (not a method callback array ) and we 're able * to resolve the function name , do so . * / $ mapped _function = $ this - > phpcs File - > find Next ( Tokens : : $ empty Tokens , $ callback [ 'start ' ] , ( $ callback [ 'end ' ] + 1 ) , true ) ; if ( false ! = = $ mapped _function & & \ T _CONSTANT _ENCAPSED _STRING = = = $ this - > tokens [ $ mapped _function ] [ 'code ' ] ) { $ function Name = $ this - > strip _quotes ( $ this - > tokens [ $ mapped _function ] [ 'content ' ] ) ; $ ptr = $ mapped _function ; } } } / / Skip pointer to after the function . / / If this is a formatting function we just skip over the opening / / parenthesis . Otherwise we skip all the way to the closing . if ( $ is _formatting _function ) { $ i = ( $ function _opener + 1 ) ; $ watch = true ; } else { if ( isset ( $ this - > tokens [ $ function _opener ] [ 'parenthesis _closer ' ] ) ) { $ i = $ this - > tokens [ $ function _opener ] [ 'parenthesis _closer ' ] ; } else { / / Live coding or parse error . break ; } } } / / If this is a safe function , we don 't flag it . if ( $ is _formatting _function | | isset ( $ this - > auto Escaped Functions [ $ function Name ] ) | | isset ( $ this - > escaping Functions [ $ function Name ] ) ) { continue ; } $ content = $ function Name ; } else { $ content = $ this - > tokens [ $ i ] [ 'content ' ] ; $ ptr = $ i ; } $ this - > phpcs File - > add Error ( "All output should be run through an escaping function (see the Security sections in the Word Press Developer Handbooks ) , found ' %s ' . " , $ ptr , 'Output Not Escaped ' , $ content ) ; } return $ end _of _statement ; } 
protected function merge Function Lists ( ) { if ( $ this - > custom Escaping Functions ! = = $ this - > added Custom Functions [ 'escape ' ] ) { $ custom Escape Functions = $ this - > merge _custom _array ( $ this - > custom Escaping Functions , array ( ) , false ) ; $ this - > escaping Functions = $ this - > merge _custom _array ( $ custom Escape Functions , $ this - > escaping Functions ) ; $ this - > added Custom Functions [ 'escape ' ] = $ this - > custom Escaping Functions ; } if ( $ this - > custom Auto Escaped Functions ! = = $ this - > added Custom Functions [ 'autoescape ' ] ) { $ this - > auto Escaped Functions = $ this - > merge _custom _array ( $ this - > custom Auto Escaped Functions , $ this - > auto Escaped Functions ) ; $ this - > added Custom Functions [ 'autoescape ' ] = $ this - > custom Auto Escaped Functions ; } if ( $ this - > custom Printing Functions ! = = $ this - > added Custom Functions [ 'print ' ] ) { $ this - > printing Functions = $ this - > merge _custom _array ( $ this - > custom Printing Functions , $ this - > printing Functions ) ; $ this - > added Custom Functions [ 'print ' ] = $ this - > custom Printing Functions ; } } 
public function process _token ( $ stack Ptr ) { $ array _open _close = $ this - > find _array _open _close ( $ stack Ptr ) ; if ( false = = = $ array _open _close ) { * Long arrays only : Check for space between the array keyword and the open parenthesis . * / if ( \ T _ARRAY = = = $ this - > tokens [ $ stack Ptr ] [ 'code ' ] ) { if ( ( $ stack Ptr + 1 ) ! = = $ opener ) { $ error = 'There must be no space between the "array " keyword and the opening parenthesis ' ; $ error _code = 'Space After Keyword ' ; $ next Non Whitespace = $ this - > phpcs File - > find Next ( \ T _WHITESPACE , ( $ stack Ptr + 1 ) , ( $ opener + 1 ) , true ) ; if ( $ next Non Whitespace ! = = $ opener ) { * Check for empty arrays . * / $ next Non Whitespace = $ this - > phpcs File - > find Next ( \ T _WHITESPACE , ( $ opener + 1 ) , ( $ closer + 1 ) , true ) ; if ( $ next Non Whitespace = = = $ closer ) { if ( ( $ opener + 1 ) ! = = $ closer ) { $ fix = $ this - > phpcs File - > add Fixable Error ( 'Empty array declaration must have no space between the parentheses ' , $ stack Ptr , 'Space In Empty Array ' ) ; if ( true = = = $ fix ) { $ this - > phpcs File - > fixer - > begin Changeset ( ) ; for ( $ i = ( $ opener + 1 ) ; $ i < $ closer ; $ i + + ) { $ this - > phpcs File - > fixer - > replace Token ( $ i , ' ' ) ; } $ this - > phpcs File - > fixer - > end Changeset ( ) ; unset ( $ i ) ; } } 
protected function process _single _line _array ( $ stack Ptr , $ opener , $ closer ) { $ array _has _keys = $ this - > phpcs File - > find Next ( \ T _DOUBLE _ARROW , $ opener , $ closer ) ; if ( false ! = = $ array _has _keys ) { $ array _items = $ this - > get _function _call _parameters ( $ stack Ptr ) ; if ( ( false = = = $ this - > allow _single _item _single _line _associative _arrays & & ! empty ( $ array _items ) ) | | ( true = = = $ this - > allow _single _item _single _line _associative _arrays & & \ count ( $ array _items ) > 1 ) ) { $ array _has _keys = false ; * Add a line break before the first non -empty token in the array item . * Prevents extraneous whitespace at the start of the line which could be * interpreted as alignment whitespace . * / $ first _non _empty = $ this - > phpcs File - > find Next ( Tokens : : $ empty Tokens , $ item [ 'start ' ] , ( $ item [ 'end ' ] + 1 ) , true ) ; if ( false = = = $ first _non _empty ) { continue ; } if ( $ item [ 'start ' ] < = ( $ first _non _empty - 1 ) & & \ T _WHITESPACE = = = $ this - > tokens [ ( $ first _non _empty - 1 ) ] [ 'code ' ] ) { * Check that there is a single space after the array opener and before the array closer . * / if ( \ T _WHITESPACE ! = = $ this - > tokens [ ( $ opener + 1 ) ] [ 'code ' ] ) { $ fix = $ this - > phpcs File - > add Fixable Error ( 'Missing space after array opener . ' , $ opener , 'No Space After Array Opener ' ) ; if ( true = = = $ fix ) { $ this - > phpcs File - > fixer - > add Content ( $ opener , ' ' ) ; } } elseif ( ' ' ! = = $ this - > tokens [ ( $ opener + 1 ) ] [ 'content ' ] ) { $ fix = $ this - > phpcs File - > add Fixable Error ( 'Expected 1 space after array opener , found %s . ' , $ opener , 'Space After Array Opener ' , array ( \ strlen ( $ this - > tokens [ ( $ opener + 1 ) ] [ 'content ' ] ) ) ) ; if ( true = = = $ fix ) { $ this - > phpcs File - > fixer - > replace Token ( ( $ opener + 1 ) , ' ' ) ; } } if ( \ T _WHITESPACE ! = = $ this - > tokens [ ( $ closer - 1 ) ] [ 'code ' ] ) { $ fix = $ this - > phpcs File - > add Fixable Error ( 'Missing space before array closer . ' , $ closer , 'No Space Before Array Closer ' ) ; if ( true = = = $ fix ) { $ this - > phpcs File - > fixer - > add Content Before ( $ closer , ' ' ) ; } } elseif ( ' ' ! = = $ this - > tokens [ ( $ closer - 1 ) ] [ 'content ' ] ) { $ fix = $ this - > phpcs File - > add Fixable Error ( 'Expected 1 space before array closer , found %s . ' , $ closer , 'Space Before Array Closer ' , array ( \ strlen ( $ this - > tokens [ ( $ closer - 1 ) ] [ 'content ' ] ) ) ) ; if ( true = = = $ fix ) { $ this - > phpcs File - > fixer - > replace Token ( ( $ closer - 1 ) , ' ' ) ; } } } 
protected function process _multi _line _array ( $ stack Ptr , $ opener , $ closer ) { $ last _content = $ this - > phpcs File - > find Previous ( \ T _WHITESPACE , ( $ closer - 1 ) , $ opener , true ) ; if ( false ! = = $ last _content & & $ this - > tokens [ $ last _content ] [ 'line ' ] = = = $ this - > tokens [ $ closer ] [ 'line ' ] ) { $ fix = $ this - > phpcs File - > add Fixable Error ( 'Closing parenthesis of array declaration must be on a new line ' , $ closer , 'Close Brace New Line ' ) ; if ( true = = = $ fix ) { $ this - > phpcs File - > fixer - > begin Changeset ( ) ; if ( $ last _content < ( $ closer - 1 ) & & \ T _WHITESPACE = = = $ this - > tokens [ ( $ closer - 1 ) ] [ 'code ' ] ) { * Check that each array item starts on a new line . * / $ array _items = $ this - > get _function _call _parameters ( $ stack Ptr ) ; $ end _of _last _item = $ opener ; foreach ( $ array _items as $ item ) { $ end _of _this _item = ( $ item [ 'end ' ] + 1 ) ; 
public function process _matched _token ( $ stack Ptr , $ group _name , $ matched _content ) { $ this - > get _wp _version _from _cl ( ) ; switch ( $ matched _content ) { case 'strip _tags ' : if ( $ this - > get _function _call _parameter _count ( $ stack Ptr ) ! = = 1 ) { return ; } break ; case 'wp _parse _url ' : if ( $ this - > get _function _call _parameter _count ( $ stack Ptr ) ! = = 1 & & version _compare ( $ this - > minimum _supported _version , ' 4 . 7 . 0 ' , ' < ' ) ) { return ; } break ; case 'file _get _contents ' : $ params = $ this - > get _function _call _parameters ( $ stack Ptr ) ; if ( isset ( $ params [ 2 ] ) & & 'true ' = = = $ params [ 2 ] [ 'raw ' ] ) { * Allow for handling raw data streams from the request body . * / $ first _param = $ this - > get _function _call _parameter ( $ stack Ptr , 1 ) ; if ( false = = = $ first _param ) { 
protected function is _local _data _stream ( $ raw _param _value ) { $ raw _stripped = $ this - > strip _quotes ( $ raw _param _value ) ; if ( isset ( $ this - > allowed _local _streams [ $ raw _stripped ] ) | | isset ( $ this - > allowed _local _stream _constants [ $ raw _param _value ] ) ) { return true ; } foreach ( $ this - > allowed _local _stream _partials as $ partial ) { if ( strpos ( $ raw _stripped , $ partial ) = = = 0 ) { return true ; } } return false ; } 
public function process _token ( $ stack Ptr ) { if ( ! isset ( $ this - > tab _width ) ) { $ this - > tab _width = PHPCSHelper : : get _tab _width ( $ this - > phpcs File ) ; } $ check _tokens = array ( \ T _WHITESPACE = > true , \ T _DOC _COMMENT _WHITESPACE = > true , \ T _DOC _COMMENT _STRING = > true , ) ; for ( $ i = ( $ stack Ptr + 1 ) ; $ i < $ this - > phpcs File - > num Tokens ; $ i + + ) { 
public function process _token ( $ stack Ptr ) { 
protected function merge Function Lists ( ) { if ( ! isset ( $ this - > methods [ 'all ' ] ) ) { $ this - > methods [ 'all ' ] = array _merge ( $ this - > methods [ 'cachable ' ] , $ this - > methods [ 'noncachable ' ] ) ; } if ( $ this - > custom Cache Get Functions ! = = $ this - > added Custom Functions [ 'cacheget ' ] ) { $ this - > cache Get Functions = $ this - > merge _custom _array ( $ this - > custom Cache Get Functions , $ this - > cache Get Functions ) ; $ this - > added Custom Functions [ 'cacheget ' ] = $ this - > custom Cache Get Functions ; } if ( $ this - > custom Cache Set Functions ! = = $ this - > added Custom Functions [ 'cacheset ' ] ) { $ this - > cache Set Functions = $ this - > merge _custom _array ( $ this - > custom Cache Set Functions , $ this - > cache Set Functions ) ; $ this - > added Custom Functions [ 'cacheset ' ] = $ this - > custom Cache Set Functions ; } if ( $ this - > custom Cache Delete Functions ! = = $ this - > added Custom Functions [ 'cachedelete ' ] ) { $ this - > cache Delete Functions = $ this - > merge _custom _array ( $ this - > custom Cache Delete Functions , $ this - > cache Delete Functions ) ; $ this - > added Custom Functions [ 'cachedelete ' ] = $ this - > custom Cache Delete Functions ; } } 
public function register ( ) { $ starters = Tokens : : $ boolean Operators ; $ starters + = Tokens : : $ assignment Tokens ; $ starters [ \ T _CASE ] = \ T _CASE ; $ starters [ \ T _RETURN ] = \ T _RETURN ; $ starters [ \ T _INLINE _THEN ] = \ T _INLINE _THEN ; $ starters [ \ T _INLINE _ELSE ] = \ T _INLINE _ELSE ; $ starters [ \ T _SEMICOLON ] = \ T _SEMICOLON ; $ starters [ \ T _OPEN _PARENTHESIS ] = \ T _OPEN _PARENTHESIS ; $ this - > condition _start _tokens = $ starters ; return array ( \ T _IS _EQUAL , \ T _IS _NOT _EQUAL , \ T _IS _IDENTICAL , \ T _IS _NOT _IDENTICAL , ) ; } 
public function process _token ( $ stack Ptr ) { $ start = $ this - > phpcs File - > find Previous ( $ this - > condition _start _tokens , $ stack Ptr , null , false , null , true ) ; $ needs _yoda = false ; 
public function process _parameters ( $ stack Ptr , $ group _name , $ matched _content , $ parameters ) { $ this - > get _wp _version _from _cl ( ) ; $ param Count = \ count ( $ parameters ) ; foreach ( $ this - > target _functions [ $ matched _content ] as $ position = > $ parameter _args ) { 
public function process _token ( $ stack Ptr ) { $ instance = $ this - > tokens [ $ stack Ptr ] ; if ( ! isset ( $ this - > superglobals [ $ instance [ 'content ' ] ] ) ) { return ; } if ( $ this - > has _whitelist _comment ( 'CSRF ' , $ stack Ptr ) ) { return ; } if ( $ this - > is _assignment ( $ stack Ptr ) ) { return ; } $ this - > merge Function Lists ( ) ; if ( $ this - > has _nonce _check ( $ stack Ptr ) ) { return ; } $ error _code = 'Missing ' ; if ( false = = = $ this - > superglobals [ $ instance [ 'content ' ] ] ) { $ error _code = 'Recommended ' ; } 
protected function merge Function Lists ( ) { if ( $ this - > custom Nonce Verification Functions ! = = $ this - > added Custom Functions [ 'nonce ' ] ) { $ this - > nonce Verification Functions = $ this - > merge _custom _array ( $ this - > custom Nonce Verification Functions , $ this - > nonce Verification Functions ) ; $ this - > added Custom Functions [ 'nonce ' ] = $ this - > custom Nonce Verification Functions ; } if ( $ this - > custom Sanitizing Functions ! = = $ this - > added Custom Functions [ 'sanitize ' ] ) { $ this - > sanitizing Functions = $ this - > merge _custom _array ( $ this - > custom Sanitizing Functions , $ this - > sanitizing Functions ) ; $ this - > added Custom Functions [ 'sanitize ' ] = $ this - > custom Sanitizing Functions ; } if ( $ this - > custom Unslashing Sanitizing Functions ! = = $ this - > added Custom Functions [ 'unslashsanitize ' ] ) { $ this - > unslashing Sanitizing Functions = $ this - > merge _custom _array ( $ this - > custom Unslashing Sanitizing Functions , $ this - > unslashing Sanitizing Functions ) ; $ this - > added Custom Functions [ 'unslashsanitize ' ] = $ this - > custom Unslashing Sanitizing Functions ; } } 
public function process _matched _token ( $ stack Ptr , $ group _name , $ matched _content ) { $ parameters = $ this - > get _function _call _parameters ( $ stack Ptr ) ; if ( empty ( $ parameters ) ) { return $ this - > process _no _parameters ( $ stack Ptr , $ group _name , $ matched _content ) ; } else { return $ this - > process _parameters ( $ stack Ptr , $ group _name , $ matched _content , $ parameters ) ; } } 
protected function process Variable ( File $ phpcs _file , $ stack _ptr ) { $ tokens = $ phpcs _file - > get Tokens ( ) ; $ var _name = ltrim ( $ tokens [ $ stack _ptr ] [ 'content ' ] , ' $ ' ) ; 
protected function process Member Var ( File $ phpcs _file , $ stack _ptr ) { $ tokens = $ phpcs _file - > get Tokens ( ) ; $ var _name = ltrim ( $ tokens [ $ stack _ptr ] [ 'content ' ] , ' $ ' ) ; $ member _props = $ phpcs _file - > get Member Properties ( $ stack _ptr ) ; if ( empty ( $ member _props ) ) { 
protected function process Variable In String ( File $ phpcs _file , $ stack _ptr ) { $ tokens = $ phpcs _file - > get Tokens ( ) ; if ( preg _match _all ( ' | [ ^ \ \ \ ] \ $ { ? ( [a -z A -Z _ \x 7f - \xff ] [a -z A -Z 0 - 9 _ \x 7f - \xff ] * ) | ' , $ tokens [ $ stack _ptr ] [ 'content ' ] , $ matches ) > 0 ) { 
protected function merge White List ( ) { if ( $ this - > custom Properties Whitelist ! = = $ this - > added Custom Properties [ 'properties ' ] ) { 
public function process _parameters ( $ stack Ptr , $ group _name , $ matched _content , $ parameters ) { foreach ( $ this - > target _functions [ $ matched _content ] as $ position ) { if ( isset ( $ parameters [ $ position ] ) ) { $ file _constant = $ this - > phpcs File - > find Next ( \ T _FILE , $ parameters [ $ position ] [ 'start ' ] , ( $ parameters [ $ position ] [ 'end ' ] + 1 ) ) ; if ( false ! = = $ file _constant ) { $ this - > phpcs File - > add Warning ( 'Using _ _FILE _ _ for menu slugs risks exposing filesystem structure . ' , $ stack Ptr , 'Using _ _FILE _ _ ' ) ; } } } } 
public function register ( ) { $ this - > ignore _tokens = Tokens : : $ heredoc Tokens ; unset ( $ this - > ignore _tokens [ \ T _START _HEREDOC ] , $ this - > ignore _tokens [ \ T _START _NOWDOC ] ) ; $ this - > ignore _tokens [ \ T _INLINE _HTML ] = \ T _INLINE _HTML ; return array ( \ T _ARRAY , \ T _OPEN _SHORT _ARRAY , ) ; } 
public function process _token ( $ stack Ptr ) { if ( ! isset ( $ this - > tab _width ) ) { $ this - > tab _width = PHPCSHelper : : get _tab _width ( $ this - > phpcs File ) ; } $ array _open _close = $ this - > find _array _open _close ( $ stack Ptr ) ; if ( false = = = $ array _open _close ) { * Check the closing bracket is lined up with the start of the content on the line * containing the array opener . * / $ opener _line _spaces = $ this - > get _indentation _size ( $ opener ) ; $ closer _line _spaces = ( $ this - > tokens [ $ closer ] [ 'column ' ] - 1 ) ; if ( $ closer _line _spaces ! = = $ opener _line _spaces ) { $ error = 'Array closer not aligned correctly ; expected %s space (s ) but found %s ' ; $ error _code = 'Close Brace Not Aligned ' ; if ( 0 = = = $ closer _line _spaces | | ( \ T _WHITESPACE = = = $ this - > tokens [ ( $ closer - 1 ) ] [ 'code ' ] & & 1 = = = $ this - > tokens [ ( $ closer - 1 ) ] [ 'column ' ] ) ) { $ this - > add _array _alignment _error ( $ closer , $ error , $ error _code , $ opener _line _spaces , $ closer _line _spaces , $ this - > get _indentation _string ( $ opener _line _spaces ) ) ; } else { $ this - > phpcs File - > add Error ( $ error , $ closer , $ error _code , array ( $ opener _line _spaces , $ closer _line _spaces ) ) ; } unset ( $ error , $ error _code ) ; } $ array _items = $ this - > get _function _call _parameters ( $ stack Ptr ) ; if ( empty ( $ array _items ) ) { * Multi -line array items . * * Verify & if needed , correct the indentation of subsequent lines . * Subsequent lines may be indented more or less than the mimimum expected indent , * but the "first line after " should be indented - at least - as much as the very first line * of the array item . * Indentation correction for subsequent lines will be based on that diff . * / * Apparently there were only tokens in the ignore list on subsequent lines . * * In that case , the comma after the array item might be on a line by itself , * so check its placement . * / if ( $ this - > tokens [ $ item [ 'end ' ] ] [ 'line ' ] ! = = $ this - > tokens [ $ end _of _this _item ] [ 'line ' ] & & \ T _COMMA = = = $ this - > tokens [ $ end _of _this _item ] [ 'code ' ] & & ( $ this - > tokens [ $ end _of _this _item ] [ 'column ' ] - 1 ) ! = = $ expected _spaces ) { $ this - > add _array _alignment _error ( $ end _of _this _item , 'Comma after multi -line array item not aligned correctly ; expected %s spaces , but found %s ' , 'Multi Line Array Item Comma Not Aligned ' , $ expected _spaces , ( $ this - > tokens [ $ end _of _this _item ] [ 'column ' ] - 1 ) , $ expected _indent ) ; } $ end _of _previous _item = $ end _of _this _item ; continue ; } $ found _spaces _on _line 2 = $ this - > get _indentation _size ( $ first _content _on _line 2 ) ; $ expected _spaces _on _line 2 = $ expected _spaces ; if ( $ found _spaces < $ found _spaces _on _line 2 ) { $ expected _spaces _on _line 2 + = ( $ found _spaces _on _line 2 - $ found _spaces ) ; } if ( $ found _spaces _on _line 2 ! = = $ expected _spaces _on _line 2 ) { $ fix = $ this - > phpcs File - > add Fixable Error ( 'Multi -line array item not aligned correctly ; expected %s spaces , but found %s ' , $ first _content _on _line 2 , 'Multi Line Array Item Not Aligned ' , array ( $ expected _spaces _on _line 2 , $ found _spaces _on _line 2 , ) ) ; if ( true = = = $ fix ) { $ expected _indent _on _line 2 = $ this - > get _indentation _string ( $ expected _spaces _on _line 2 ) ; $ this - > phpcs File - > fixer - > begin Changeset ( ) ; * Check the placement of the comma after the array item as it might be on a line by itself . * / if ( $ this - > tokens [ $ item [ 'end ' ] ] [ 'line ' ] ! = = $ this - > tokens [ $ end _of _this _item ] [ 'line ' ] & & \ T _COMMA = = = $ this - > tokens [ $ end _of _this _item ] [ 'code ' ] & & ( $ this - > tokens [ $ end _of _this _item ] [ 'column ' ] - 1 ) ! = = $ expected _spaces ) { $ this - > add _array _alignment _error ( $ end _of _this _item , 'Comma after array item not aligned correctly ; expected %s spaces , but found %s ' , 'Multi Line Array Item Comma Not Aligned ' , $ expected _spaces , ( $ this - > tokens [ $ end _of _this _item ] [ 'column ' ] - 1 ) , $ expected _indent ) ; } $ this - > phpcs File - > fixer - > end Changeset ( ) ; } } $ end _of _previous _item = $ end _of _this _item ; } } 
protected function ignore _token ( $ ptr ) { $ token _code = $ this - > tokens [ $ ptr ] [ 'code ' ] ; if ( isset ( $ this - > ignore _tokens [ $ token _code ] ) ) { return true ; } if ( \ T _CONSTANT _ENCAPSED _STRING = = = $ token _code | | \ T _DOUBLE _QUOTED _STRING = = = $ token _code ) { 
protected function get _indentation _size ( $ ptr ) { * Special case for multi -line , non -docblock comments . * Only applicable for subsequent lines in an array item . * * First /Single line is tokenized as T _WHITESPACE + T _COMMENT * Subsequent lines are tokenized as T _COMMENT including the indentation whitespace . * / if ( \ T _COMMENT = = = $ this - > tokens [ $ ptr ] [ 'code ' ] ) { $ content = $ this - > tokens [ $ ptr ] [ 'content ' ] ; $ actual _comment = ltrim ( $ content ) ; $ whitespace = str _replace ( $ actual _comment , ' ' , $ content ) ; } return \ strlen ( $ whitespace ) ; } 
protected function get _indentation _string ( $ nr ) { if ( 0 > = $ nr ) { return ' ' ; } 
protected function add _array _alignment _error ( $ ptr , $ error , $ error _code , $ expected , $ found , $ new _indent ) { $ fix = $ this - > phpcs File - > add Fixable Error ( $ error , $ ptr , $ error _code , array ( $ expected , $ found ) ) ; if ( true = = = $ fix ) { $ this - > fix _alignment _error ( $ ptr , $ new _indent ) ; } } 
protected function fix _alignment _error ( $ ptr , $ new _indent ) { if ( 1 = = = $ this - > tokens [ $ ptr ] [ 'column ' ] ) { $ this - > phpcs File - > fixer - > add Content Before ( $ ptr , $ new _indent ) ; } else { $ this - > phpcs File - > fixer - > replace Token ( ( $ ptr - 1 ) , $ new _indent ) ; } } 
public function process _token ( $ stack Ptr ) { if ( ! $ this - > has _whitelist _comment ( 'loose comparison ' , $ stack Ptr ) ) { $ error = 'Found : ' . $ this - > tokens [ $ stack Ptr ] [ 'content ' ] . ' . Use strict comparisons ( = = = or ! = = ) . ' ; $ this - > phpcs File - > add Warning ( $ error , $ stack Ptr , 'Loose Comparison ' ) ; } } 
public function register ( ) { $ this - > false _tokens + = Tokens : : $ empty Tokens ; $ this - > safe _tokens + = Tokens : : $ empty Tokens ; $ this - > safe _tokens + = Tokens : : $ assignment Tokens ; $ this - > safe _tokens + = Tokens : : $ comparison Tokens ; $ this - > safe _tokens + = Tokens : : $ operators ; $ this - > safe _tokens + = Tokens : : $ boolean Operators ; $ this - > safe _tokens + = Tokens : : $ cast Tokens ; return parent : : register ( ) ; } 
public function process _parameters ( $ stack Ptr , $ group _name , $ matched _content , $ parameters ) { * Version Check : Check to make sure the version is set explicitly . * / if ( ! isset ( $ parameters [ 4 ] ) | | 'null ' = = = $ parameters [ 4 ] [ 'raw ' ] ) { $ type = 'script ' ; if ( strpos ( $ matched _content , ' _style ' ) ! = = false ) { $ type = 'style ' ; } $ this - > phpcs File - > add Error ( 'Resource version not set in call to %s ( ) . This means new versions of the %s will not always be loaded due to browser caching . ' , $ stack Ptr , 'Missing Version ' , array ( $ matched _content , $ type ) ) ; } else { * In footer Check * * Check to make sure that $in _footer is set to true . * It will warn the user to make sure it is intended . * * Only wp _register _script and wp _enqueue _script need this check , * as this parameter is not available to wp _register _style and wp _enqueue _style . * / if ( 'wp _register _script ' ! = = $ matched _content & & 'wp _enqueue _script ' ! = = $ matched _content ) { return ; } if ( ! isset ( $ parameters [ 5 ] ) ) { 
protected function is _falsy ( $ start , $ end ) { 
public function process _token ( $ stack _ptr ) { 
public function process _matched _token ( $ stack _ptr , $ group _name , $ matched _content ) { $ func _open _paren _token = $ this - > phpcs File - > find Next ( Tokens : : $ empty Tokens , ( $ stack _ptr + 1 ) , null , true ) ; if ( false = = = $ func _open _paren _token | | \ T _OPEN _PARENTHESIS ! = = $ this - > tokens [ $ func _open _paren _token ] [ 'code ' ] | | ! isset ( $ this - > tokens [ $ func _open _paren _token ] [ 'parenthesis _closer ' ] ) ) { 
protected function check _argument _tokens ( $ context ) { $ stack _ptr = $ context [ 'stack _ptr ' ] ; $ tokens = $ context [ 'tokens ' ] ; $ arg _name = $ context [ 'arg _name ' ] ; $ is _error = empty ( $ context [ 'warning ' ] ) ; $ content = isset ( $ tokens [ 0 ] ) ? $ tokens [ 0 ] [ 'content ' ] : ' ' ; if ( empty ( $ tokens ) | | 0 = = = \ count ( $ tokens ) ) { $ code = $ this - > string _to _errorcode ( 'Missing Arg ' . ucfirst ( $ arg _name ) ) ; if ( 'domain ' ! = = $ arg _name ) { $ this - > add Message ( 'Missing $ %s arg . ' , $ stack _ptr , $ is _error , $ code , array ( $ arg _name ) ) ; return false ; } 
protected function compare _single _and _plural _arguments ( $ stack _ptr , $ single _context , $ plural _context ) { $ single _content = $ single _context [ 'tokens ' ] [ 0 ] [ 'content ' ] ; $ plural _content = $ plural _context [ 'tokens ' ] [ 0 ] [ 'content ' ] ; preg _match _all ( self : : SPRINTF _PLACEHOLDER _REGEX , $ single _content , $ single _placeholders ) ; $ single _placeholders = $ single _placeholders [ 0 ] ; preg _match _all ( self : : SPRINTF _PLACEHOLDER _REGEX , $ plural _content , $ plural _placeholders ) ; $ plural _placeholders = $ plural _placeholders [ 0 ] ; 
protected function check _text ( $ context ) { $ stack _ptr = $ context [ 'stack _ptr ' ] ; $ arg _name = $ context [ 'arg _name ' ] ; $ content = $ context [ 'tokens ' ] [ 0 ] [ 'content ' ] ; $ is _error = empty ( $ context [ 'warning ' ] ) ; * No Empty Strings . * * Strip placeholders and surrounding quotes . * / $ non _placeholder _content = trim ( $ this - > strip _quotes ( $ content ) ) ; $ non _placeholder _content = preg _replace ( self : : SPRINTF _PLACEHOLDER _REGEX , ' ' , $ non _placeholder _content ) ; if ( ' ' = = = $ non _placeholder _content ) { $ this - > phpcs File - > add Error ( 'Strings should have translatable content ' , $ stack _ptr , 'No Empty Strings ' ) ; } } 
protected function check _for _translator _comment ( $ stack _ptr , $ args ) { foreach ( $ args as $ arg ) { if ( false = = = \ in _array ( $ arg [ 'arg _name ' ] , array ( 'text ' , 'single ' , 'plural ' ) , true ) ) { continue ; } if ( empty ( $ arg [ 'tokens ' ] ) ) { continue ; } foreach ( $ arg [ 'tokens ' ] as $ token ) { if ( empty ( $ token [ 'content ' ] ) ) { continue ; } if ( preg _match ( self : : SPRINTF _PLACEHOLDER _REGEX , $ token [ 'content ' ] , $ placeholders ) < 1 ) { * Check that the comment is either on the line before the gettext call or * if it 's not , that there is only whitespace between . * / $ correctly _placed = false ; if ( ( $ this - > tokens [ $ previous _comment ] [ 'line ' ] + 1 ) = = = $ this - > tokens [ $ stack _ptr ] [ 'line ' ] ) { $ correctly _placed = true ; } else { $ next _non _whitespace = $ this - > phpcs File - > find Next ( \ T _WHITESPACE , ( $ previous _comment + 1 ) , $ stack _ptr , true ) ; if ( false = = = $ next _non _whitespace | | $ this - > tokens [ $ next _non _whitespace ] [ 'line ' ] = = = $ this - > tokens [ $ stack _ptr ] [ 'line ' ] ) { / / No non -whitespace found or next non -whitespace is on same line as gettext call . $ correctly _placed = true ; } unset ( $ next _non _whitespace ) ; } / * * Check that the comment starts with 'translators : ' . * / if ( true = = = $ correctly _placed ) { if ( \ T _COMMENT = = = $ this - > tokens [ $ previous _comment ] [ 'code ' ] ) { $ comment _text = trim ( $ this - > tokens [ $ previous _comment ] [ 'content ' ] ) ; / / If it 's multi -line comment , collect all the parts . if ( ' * / ' = = = substr ( $ comment _text , - 2 ) & & ' / * ' ! = = substr ( $ comment _text , 0 , 2 ) ) { for ( $ i = ( $ previous _comment - 1 ) ; 0 < = $ i ; $ i - - ) { if ( \ T _COMMENT ! = = $ this - > tokens [ $ i ] [ 'code ' ] ) { break ; } $ comment _text = trim ( $ this - > tokens [ $ i ] [ 'content ' ] ) . $ comment _text ; } } if ( true = = = $ this - > is _translators _comment ( $ comment _text ) ) { 
public function register ( ) { if ( \ defined ( ' \PHP _CODESNIFFER _IN _TESTS ' ) ) { $ this - > class _exceptions = array _merge ( $ this - > class _exceptions , $ this - > unittest _class _exceptions ) ; } return array ( \ T _OPEN _TAG , \ T _OPEN _TAG _WITH _ECHO , ) ; } 
public function process _token ( $ stack Ptr ) { * Generic check for lowercase hyphenated file names . * / if ( $ file Name ! = = $ expected & & ( false = = = $ this - > is _theme | | 1 ! = = preg _match ( self : : THEME _EXCEPTIONS _REGEX , $ file Name ) ) ) { $ this - > phpcs File - > add Error ( 'Filenames should be all lowercase with hyphens as word separators . Expected %s , but found %s . ' , 0 , 'Not Hyphenated Lowercase ' , array ( $ expected , $ file Name ) ) ; } unset ( $ expected ) ; if ( true = = = $ this - > strict _class _file _names ) { $ has _class = $ this - > phpcs File - > find Next ( \ T _CLASS , $ stack Ptr ) ; if ( false ! = = $ has _class & & false = = = $ this - > is _test _class ( $ has _class ) ) { $ class _name = $ this - > phpcs File - > get Declaration Name ( $ has _class ) ; $ expected = 'class - ' . strtolower ( str _replace ( ' _ ' , ' - ' , $ class _name ) ) ; if ( substr ( $ file Name , 0 , - 4 ) ! = = $ expected & & ! isset ( $ this - > class _exceptions [ $ file Name ] ) ) { $ this - > phpcs File - > add Error ( 'Class file names should be based on the class name with "class - " prepended . Expected %s , but found %s . ' , 0 , 'Invalid Class File Name ' , array ( $ expected . ' .php ' , $ file Name , ) ) ; } unset ( $ expected ) ; } } if ( false ! = = strpos ( $ file , \ DIRECTORY _SEPARATOR . 'wp -includes ' . \ DIRECTORY _SEPARATOR ) ) { $ subpackage _tag = $ this - > phpcs File - > find Next ( \ T _DOC _COMMENT _TAG , $ stack Ptr , null , false , ' @subpackage ' ) ; if ( false ! = = $ subpackage _tag ) { $ subpackage = $ this - > phpcs File - > find Next ( \ T _DOC _COMMENT _STRING , $ subpackage _tag ) ; if ( false ! = = $ subpackage ) { $ file Name _end = substr ( $ file Name , - 1 3 ) ; $ has _class = $ this - > phpcs File - > find Next ( \ T _CLASS , $ stack Ptr ) ; if ( ( 'Template ' = = = trim ( $ this - > tokens [ $ subpackage ] [ 'content ' ] ) & & $ this - > tokens [ $ subpackage _tag ] [ 'line ' ] = = = $ this - > tokens [ $ subpackage ] [ 'line ' ] ) & & ( ( ! \ defined ( ' \PHP _CODESNIFFER _IN _TESTS ' ) & & ' -template .php ' ! = = $ file Name _end ) | | ( \ defined ( ' \PHP _CODESNIFFER _IN _TESTS ' ) & & ' -template .inc ' ! = = $ file Name _end ) ) & & false = = = $ has _class ) { $ this - > phpcs File - > add Error ( 'Files containing template tags should have " -template " appended to the end of the file name . Expected %s , but found %s . ' , 0 , 'Invalid Template Tag File Name ' , array ( substr ( $ file Name , 0 , - 4 ) . ' -template .php ' , $ file Name , ) ) ; } } } } 
public function process _token ( $ stack Ptr ) { 
public function is _targetted _token ( $ stack Ptr ) { $ token = $ this - > tokens [ $ stack Ptr ] ; $ classname = ' ' ; if ( \ in _array ( $ token [ 'code ' ] , array ( \ T _NEW , \ T _EXTENDS , \ T _IMPLEMENTS ) , true ) ) { if ( \ T _NEW = = = $ token [ 'code ' ] ) { $ name End = ( $ this - > phpcs File - > find Next ( array ( \ T _OPEN _PARENTHESIS , \ T _WHITESPACE , \ T _SEMICOLON , \ T _OBJECT _OPERATOR ) , ( $ stack Ptr + 2 ) ) - 1 ) ; } else { $ name End = ( $ this - > phpcs File - > find Next ( array ( \ T _CLOSE _CURLY _BRACKET , \ T _WHITESPACE ) , ( $ stack Ptr + 2 ) ) - 1 ) ; } $ length = ( $ name End - ( $ stack Ptr + 1 ) ) ; $ classname = $ this - > phpcs File - > get Tokens As String ( ( $ stack Ptr + 2 ) , $ length ) ; if ( \ T _NS _SEPARATOR ! = = $ this - > tokens [ ( $ stack Ptr + 2 ) ] [ 'code ' ] ) { $ classname = $ this - > get _namespaced _classname ( $ classname , ( $ stack Ptr - 1 ) ) ; } } if ( \ T _DOUBLE _COLON = = = $ token [ 'code ' ] ) { $ name End = $ this - > phpcs File - > find Previous ( \ T _STRING , ( $ stack Ptr - 1 ) ) ; $ name Start = ( $ this - > phpcs File - > find Previous ( array ( \ T _STRING , \ T _NS _SEPARATOR , \ T _NAMESPACE ) , ( $ name End - 1 ) , null , true , null , true ) + 1 ) ; $ length = ( $ name End - ( $ name Start - 1 ) ) ; $ classname = $ this - > phpcs File - > get Tokens As String ( $ name Start , $ length ) ; if ( \ T _NS _SEPARATOR ! = = $ this - > tokens [ $ name Start ] [ 'code ' ] ) { $ classname = $ this - > get _namespaced _classname ( $ classname , ( $ name Start - 1 ) ) ; } } 
public function check _for _matches ( $ stack Ptr ) { $ skip _to = array ( ) ; foreach ( $ this - > groups as $ group Name = > $ group ) { if ( isset ( $ this - > excluded _groups [ $ group Name ] ) ) { continue ; } if ( preg _match ( $ group [ 'regex ' ] , $ this - > classname ) = = = 1 ) { $ skip _to [ ] = $ this - > process _matched _token ( $ stack Ptr , $ group Name , $ this - > classname ) ; } } if ( empty ( $ skip _to ) | | min ( $ skip _to ) = = = 0 ) { return ; } return min ( $ skip _to ) ; } 
protected function get _namespaced _classname ( $ classname , $ search _from ) { 
public function register ( ) { $ this - > assignment _tokens = Tokens : : $ assignment Tokens ; unset ( $ this - > assignment _tokens [ \ T _DOUBLE _ARROW ] ) ; $ starters = Tokens : : $ boolean Operators ; $ starters [ \ T _SEMICOLON ] = \ T _SEMICOLON ; $ starters [ \ T _OPEN _PARENTHESIS ] = \ T _OPEN _PARENTHESIS ; $ starters [ \ T _INLINE _ELSE ] = \ T _INLINE _ELSE ; $ this - > condition _start _tokens = $ starters ; return array ( \ T _IF , \ T _ELSEIF , \ T _FOR , \ T _SWITCH , \ T _CASE , \ T _WHILE , \ T _INLINE _THEN , ) ; } 
public function process _token ( $ stack Ptr ) { $ token = $ this - > tokens [ $ stack Ptr ] ; 
public function execute ( $ queue ) { $ serializer = new Serializer ( ) ; $ closure = $ serializer - > unserialize ( $ this - > serialized ) ; return $ closure ( ) ; } 
public function listen ( ) { $ this - > open ( ) ; $ callback = function ( AMQPMessage $ payload ) { $ id = $ payload - > get ( 'message _id ' ) ; list ( $ ttr , $ message ) = explode ( ' ; ' , $ payload - > body , 2 ) ; if ( $ this - > handle Message ( $ id , $ message , $ ttr , 1 ) ) { $ payload - > delivery _info [ 'channel ' ] - > basic _ack ( $ payload - > delivery _info [ 'delivery _tag ' ] ) ; } } ; $ this - > channel - > basic _qos ( null , 1 , null ) ; $ this - > channel - > basic _consume ( $ this - > queue Name , ' ' , false , false , false , false , $ callback ) ; while ( count ( $ this - > channel - > callbacks ) ) { $ this - > channel - > wait ( ) ; } } 
protected function open ( ) { if ( $ this - > channel ) { return ; } $ this - > connection = new AMQPStream Connection ( $ this - > host , $ this - > port , $ this - > user , $ this - > password , $ this - > vhost ) ; $ this - > channel = $ this - > connection - > channel ( ) ; $ this - > channel - > queue _declare ( $ this - > queue Name , false , true , false , false ) ; $ this - > channel - > exchange _declare ( $ this - > exchange Name , 'direct ' , false , true , false ) ; $ this - > channel - > queue _bind ( $ this - > queue Name , $ this - > exchange Name ) ; } 
protected function reserve ( $ timeout ) { $ response = $ this - > get Client ( ) - > receive Message ( [ 'Queue Url ' = > $ this - > url , 'Attribute Names ' = > [ 'Approximate Receive Count ' ] , 'Message Attribute Names ' = > [ 'TTR ' ] , 'Max Number Of Messages ' = > 1 , 'Visibility Timeout ' = > $ this - > ttr , 'Wait Time Seconds ' = > $ timeout , ] ) ; if ( ! $ response [ 'Messages ' ] ) { return null ; } $ payload = reset ( $ response [ 'Messages ' ] ) ; $ ttr = ( int ) $ payload [ 'Message Attributes ' ] [ 'TTR ' ] [ 'String Value ' ] ; if ( $ ttr ! = $ this - > ttr ) { $ this - > get Client ( ) - > change Message Visibility ( [ 'Queue Url ' = > $ this - > url , 'Receipt Handle ' = > $ payload [ 'Receipt Handle ' ] , 'Visibility Timeout ' = > $ ttr , ] ) ; } return $ payload ; } 
public function listen ( ) { $ this - > open ( ) ; $ this - > setup Broker ( ) ; $ queue = $ this - > context - > create Queue ( $ this - > queue Name ) ; $ consumer = $ this - > context - > create Consumer ( $ queue ) ; $ this - > context - > subscribe ( $ consumer , function ( Amqp Message $ message , Amqp Consumer $ consumer ) { if ( $ message - > is Redelivered ( ) ) { $ consumer - > acknowledge ( $ message ) ; $ this - > redeliver ( $ message ) ; return true ; } $ ttr = $ message - > get Property ( self : : TTR ) ; $ attempt = $ message - > get Property ( self : : ATTEMPT , 1 ) ; if ( $ this - > handle Message ( $ message - > get Message Id ( ) , $ message - > get Body ( ) , $ ttr , $ attempt ) ) { $ consumer - > acknowledge ( $ message ) ; } else { $ consumer - > acknowledge ( $ message ) ; $ this - > redeliver ( $ message ) ; } return true ; } ) ; $ this - > context - > consume ( ) ; } 
protected function open ( ) { if ( $ this - > context ) { return ; } switch ( $ this - > driver ) { case self : : ENQUEUE _AMQP _LIB : $ connection Class = Amqp Lib Connection Factory : : class ; break ; case self : : ENQUEUE _AMQP _EXT : $ connection Class = Amqp Ext Connection Factory : : class ; break ; case self : : ENQUEUE _AMQP _BUNNY : $ connection Class = Amqp Bunny Connection Factory : : class ; break ; default : throw new \ Logic Exception ( sprintf ( 'The given driver " %s " is not supported . Drivers supported are " %s " ' , $ this - > driver , implode ( ' " , " ' , $ this - > supported Drivers ) ) ) ; } $ config = [ 'dsn ' = > $ this - > dsn , 'host ' = > $ this - > host , 'port ' = > $ this - > port , 'user ' = > $ this - > user , 'pass ' = > $ this - > password , 'vhost ' = > $ this - > vhost , 'read _timeout ' = > $ this - > read Timeout , 'write _timeout ' = > $ this - > write Timeout , 'connection _timeout ' = > $ this - > connection Timeout , 'heartbeat ' = > $ this - > heartbeat , 'persisted ' = > $ this - > persisted , 'lazy ' = > $ this - > lazy , 'qos _global ' = > $ this - > qos Global , 'qos _prefetch _size ' = > $ this - > qos Prefetch Size , 'qos _prefetch _count ' = > $ this - > qos Prefetch Count , 'ssl _on ' = > $ this - > ssl On , 'ssl _verify ' = > $ this - > ssl Verify , 'ssl _cacert ' = > $ this - > ssl Cacert , 'ssl _cert ' = > $ this - > ssl Cert , 'ssl _key ' = > $ this - > ssl Key , ] ; $ config = array _filter ( $ config , function ( $ value ) { return null ! = = $ value ; } ) ; $ factory = new $ connection Class ( $ config ) ; $ this - > context = $ factory - > create Context ( ) ; if ( $ this - > context instanceof Delay Strategy Aware ) { $ this - > context - > set Delay Strategy ( new Rabbit Mq Dlx Delay Strategy ( ) ) ; } } 
protected function close ( ) { if ( ! $ this - > context ) { return ; } $ this - > context - > close ( ) ; $ this - > context = null ; $ this - > setup Broker Done = false ; } 
protected function redeliver ( Amqp Message $ message ) { $ attempt = $ message - > get Property ( self : : ATTEMPT , 1 ) ; $ new Message = $ this - > context - > create Message ( $ message - > get Body ( ) , $ message - > get Properties ( ) , $ message - > get Headers ( ) ) ; $ new Message - > set Delivery Mode ( $ message - > get Delivery Mode ( ) ) ; $ new Message - > set Property ( self : : ATTEMPT , + + $ attempt ) ; $ this - > context - > create Producer ( ) - > send ( $ this - > context - > create Queue ( $ this - > queue Name ) , $ new Message ) ; } 
public function run ( $ repeat ) { return $ this - > run Worker ( function ( callable $ can Continue ) use ( $ repeat ) { $ worker = new \ Gearman Worker ( ) ; $ worker - > add Server ( $ this - > host , $ this - > port ) ; $ worker - > add Function ( $ this - > channel , function ( \ Gearman Job $ payload ) { list ( $ ttr , $ message ) = explode ( ' ; ' , $ payload - > workload ( ) , 2 ) ; $ this - > handle Message ( $ payload - > handle ( ) , $ message , $ ttr , 1 ) ; } ) ; $ worker - > set Timeout ( $ repeat ? 1 0 0 0 : 1 ) ; while ( $ can Continue ( ) ) { $ result = $ worker - > work ( ) ; if ( ! $ result & & ! $ repeat ) { break ; } } } ) ; } 
public function validate Namespace ( $ attribute ) { $ value = $ this - > $ attribute ; $ value = ltrim ( $ value , ' \ \ ' ) ; $ path = Yii : : get Alias ( ' @ ' . str _replace ( ' \ \ ' , ' / ' , $ value ) , false ) ; if ( $ path = = = false ) { $ this - > add Error ( $ attribute , 'Namespace must be associated with an existing directory . ' ) ; } } 
public function push ( $ job ) { $ event = new Push Event ( [ 'job ' = > $ job , 'ttr ' = > $ this - > push Ttr ? : ( $ job instanceof Retryable Job Interface ? $ job - > get Ttr ( ) : $ this - > ttr ) , 'delay ' = > $ this - > push Delay ? : 0 , 'priority ' = > $ this - > push Priority , ] ) ; $ this - > push Ttr = null ; $ this - > push Delay = null ; $ this - > push Priority = null ; $ this - > trigger ( self : : EVENT _BEFORE _PUSH , $ event ) ; if ( $ event - > handled ) { return null ; } if ( $ this - > strict Job Type & & ! ( $ event - > job instanceof Job Interface ) ) { throw new Invalid Argument Exception ( 'Job must be instance of Job Interface . ' ) ; } if ( ! is _numeric ( $ event - > ttr ) ) { throw new Invalid Argument Exception ( 'Job TTR must be integer . ' ) ; } $ event - > ttr = ( int ) $ event - > ttr ; if ( $ event - > ttr < = 0 ) { throw new Invalid Argument Exception ( 'Job TTR must be greater that zero . ' ) ; } if ( ! is _numeric ( $ event - > delay ) ) { throw new Invalid Argument Exception ( 'Job delay must be integer . ' ) ; } $ event - > delay = ( int ) $ event - > delay ; if ( $ event - > delay < 0 ) { throw new Invalid Argument Exception ( 'Job delay must be positive . ' ) ; } $ message = $ this - > serializer - > serialize ( $ event - > job ) ; $ event - > id = $ this - > push Message ( $ message , $ event - > ttr , $ event - > delay , $ event - > priority ) ; $ this - > trigger ( self : : EVENT _AFTER _PUSH , $ event ) ; return $ event - > id ; } 
public function unserialize Message ( $ serialized ) { try { $ job = $ this - > serializer - > unserialize ( $ serialized ) ; } catch ( \ Exception $ e ) { return [ null , new Invalid Job Exception ( $ serialized , $ e - > get Message ( ) , 0 , $ e ) ] ; } if ( $ job instanceof Job Interface ) { return [ $ job , null ] ; } return [ null , new Invalid Job Exception ( $ serialized , sprintf ( 'Job must be a Job Interface instance instead of %s . ' , Var Dumper : : dump As String ( $ job ) ) ) ] ; } 
public function action Listen ( $ timeout = 3 ) { if ( ! is _numeric ( $ timeout ) ) { throw new Exception ( 'Timeout must be numeric . ' ) ; } if ( $ timeout < 1 ) { throw new Exception ( 'Timeout must be greater than zero . ' ) ; } return $ this - > queue - > run ( true , $ timeout ) ; } 
public function action Exec ( $ id , $ ttr , $ attempt , $ pid ) { if ( $ this - > queue - > execute ( $ id , file _get _contents ( 'php : / /stdin ' ) , $ ttr , $ attempt , $ pid ? : null ) ) { return self : : EXEC _DONE ; } return self : : EXEC _RETRY ; } 
protected function handle Message ( $ id , $ message , $ ttr , $ attempt ) { 
public function run ( ) { while ( ( $ payload = array _shift ( $ this - > payloads ) ) ! = = null ) { list ( $ ttr , $ message ) = $ payload ; $ this - > started Id = $ this - > finished Id + 1 ; $ this - > handle Message ( $ this - > started Id , $ message , $ ttr , 1 ) ; $ this - > finished Id = $ this - > started Id ; $ this - > started Id = 0 ; } } 
public function run ( ) { Console : : output ( $ this - > format ( 'Statistical information about the tube : ' , Console : : FG _GREEN ) ) ; foreach ( $ this - > queue - > get Stats Tube ( ) as $ key = > $ value ) { Console : : stdout ( $ this - > format ( " - $key : " , Console : : FG _YELLOW ) ) ; Console : : output ( $ value ) ; } } 
public function run ( ) { $ prefix = $ this - > queue - > channel ; $ waiting = $ this - > queue - > redis - > llen ( " $prefix .waiting " ) ; $ delayed = $ this - > queue - > redis - > zcount ( " $prefix .delayed " , ' -inf ' , ' +inf ' ) ; $ reserved = $ this - > queue - > redis - > zcount ( " $prefix .reserved " , ' -inf ' , ' +inf ' ) ; $ total = $ this - > queue - > redis - > get ( " $prefix .message _id " ) ; $ done = $ total - $ waiting - $ delayed - $ reserved ; Console : : output ( $ this - > format ( 'Jobs ' , Console : : FG _GREEN ) ) ; Console : : stdout ( $ this - > format ( ' - waiting : ' , Console : : FG _YELLOW ) ) ; Console : : output ( $ waiting ) ; Console : : stdout ( $ this - > format ( ' - delayed : ' , Console : : FG _YELLOW ) ) ; Console : : output ( $ delayed ) ; Console : : stdout ( $ this - > format ( ' - reserved : ' , Console : : FG _YELLOW ) ) ; Console : : output ( $ reserved ) ; Console : : stdout ( $ this - > format ( ' - done : ' , Console : : FG _YELLOW ) ) ; Console : : output ( $ done ) ; } 
public function run ( ) { Console : : output ( $ this - > format ( 'Jobs ' , Console : : FG _GREEN ) ) ; Console : : stdout ( $ this - > format ( ' - waiting : ' , Console : : FG _YELLOW ) ) ; Console : : output ( $ this - > get Waiting Count ( ) ) ; Console : : stdout ( $ this - > format ( ' - delayed : ' , Console : : FG _YELLOW ) ) ; Console : : output ( $ this - > get Delayed Count ( ) ) ; Console : : stdout ( $ this - > format ( ' - reserved : ' , Console : : FG _YELLOW ) ) ; Console : : output ( $ this - > get Reserved Count ( ) ) ; Console : : stdout ( $ this - > format ( ' - done : ' , Console : : FG _YELLOW ) ) ; Console : : output ( $ this - > get Done Count ( ) ) ; } 
public function run ( $ repeat , $ timeout = 0 ) { return $ this - > run Worker ( function ( callable $ can Continue ) use ( $ repeat , $ timeout ) { while ( $ can Continue ( ) ) { if ( $ payload = $ this - > reserve ( ) ) { if ( $ this - > handle Message ( $ payload [ 'id ' ] , $ payload [ 'job ' ] , $ payload [ 'ttr ' ] , $ payload [ 'attempt ' ] ) ) { $ this - > release ( $ payload ) ; } } elseif ( ! $ repeat ) { break ; } elseif ( $ timeout ) { sleep ( $ timeout ) ; } } } ) ; } 
public function clear ( ) { $ this - > db - > create Command ( ) - > delete ( $ this - > table Name , [ 'channel ' = > $ this - > channel ] ) - > execute ( ) ; } 
public function remove ( $ id ) { return ( bool ) $ this - > db - > create Command ( ) - > delete ( $ this - > table Name , [ 'channel ' = > $ this - > channel , 'id ' = > $ id ] ) - > execute ( ) ; } 
protected function reserve ( ) { return $ this - > db - > use Master ( function ( ) { if ( ! $ this - > mutex - > acquire ( _ _CLASS _ _ . $ this - > channel , $ this - > mutex Timeout ) ) { throw new Exception ( 'Has not waited the lock . ' ) ; } try { $ this - > move Expired ( ) ; 
private function move Expired ( ) { if ( $ this - > reserve Time ! = = time ( ) ) { $ this - > reserve Time = time ( ) ; $ this - > db - > create Command ( ) - > update ( $ this - > table Name , [ 'reserved _at ' = > null ] , ' [ [reserved _at ] ] < :time - [ [ttr ] ] and [ [done _at ] ] is null ' , [ ' :time ' = > $ this - > reserve Time ] ) - > execute ( ) ; } } 
public function before Push ( Push Event $ event ) { if ( $ event - > job instanceof \ Closure ) { $ serializer = new Serializer ( ) ; $ serialized = $ serializer - > serialize ( $ event - > job ) ; $ event - > job = new Job ( ) ; $ event - > job - > serialized = $ serialized ; } } 
public function run ( $ repeat , $ timeout = 0 ) { return $ this - > run Worker ( function ( callable $ can Continue ) use ( $ repeat , $ timeout ) { while ( $ can Continue ( ) ) { if ( ( $ payload = $ this - > reserve ( $ timeout ) ) ! = = null ) { list ( $ id , $ message , $ ttr , $ attempt ) = $ payload ; if ( $ this - > handle Message ( $ id , $ message , $ ttr , $ attempt ) ) { $ this - > delete ( $ id ) ; } } elseif ( ! $ repeat ) { break ; } } } ) ; } 
public function clear ( ) { while ( ! $ this - > redis - > set ( " $this - >channel .moving _lock " , true , 'NX ' ) ) { usleep ( 1 0 0 0 0 ) ; } $ this - > redis - > execute Command ( 'DEL ' , $ this - > redis - > keys ( " $this - >channel . * " ) ) ; } 
public function remove ( $ id ) { while ( ! $ this - > redis - > set ( " $this - >channel .moving _lock " , true , 'NX ' , 'EX ' , 1 ) ) { usleep ( 1 0 0 0 0 ) ; } if ( $ this - > redis - > hdel ( " $this - >channel .messages " , $ id ) ) { $ this - > redis - > zrem ( " $this - >channel .delayed " , $ id ) ; $ this - > redis - > zrem ( " $this - >channel .reserved " , $ id ) ; $ this - > redis - > lrem ( " $this - >channel .waiting " , 0 , $ id ) ; $ this - > redis - > hdel ( " $this - >channel .attempts " , $ id ) ; return true ; } return false ; } 
protected function delete ( $ id ) { $ this - > redis - > zrem ( " $this - >channel .reserved " , $ id ) ; $ this - > redis - > hdel ( " $this - >channel .attempts " , $ id ) ; $ this - > redis - > hdel ( " $this - >channel .messages " , $ id ) ; } 
protected function run Worker ( callable $ handler ) { $ this - > _worker Pid = getmypid ( ) ; $ loop = Yii : : create Object ( $ this - > loop Config , [ $ this ] ) ; $ event = new Worker Event ( [ 'loop ' = > $ loop ] ) ; $ this - > trigger ( self : : EVENT _WORKER _START , $ event ) ; if ( $ event - > exit Code ! = = null ) { return $ event - > exit Code ; } $ exit Code = null ; try { call _user _func ( $ handler , function ( ) use ( $ loop , $ event ) { $ this - > trigger ( self : : EVENT _WORKER _LOOP , $ event ) ; return $ event - > exit Code = = = null & & $ loop - > can Continue ( ) ; } ) ; } finally { $ this - > trigger ( self : : EVENT _WORKER _STOP , $ event ) ; $ this - > _worker Pid = null ; } return $ event - > exit Code ; } 
public function handle ( $ id , $ message , $ ttr , $ attempt ) { return $ this - > handle Message ( $ id , $ message , $ ttr , $ attempt ) ; } 
public function init ( ) { parent : : init ( ) ; if ( extension _loaded ( 'pcntl ' ) ) { foreach ( $ this - > exit Signals as $ signal ) { pcntl _signal ( $ signal , function ( ) { self : : $ exit = true ; } ) ; } foreach ( $ this - > suspend Signals as $ signal ) { pcntl _signal ( $ signal , function ( ) { self : : $ pause = true ; } ) ; } foreach ( $ this - > resume Signals as $ signal ) { pcntl _signal ( $ signal , function ( ) { self : : $ pause = false ; } ) ; } } } 
public function can Continue ( ) { if ( extension _loaded ( 'pcntl ' ) ) { pcntl _signal _dispatch ( ) ; 
public function run ( ) { Console : : output ( $ this - > format ( 'Jobs ' , Console : : FG _GREEN ) ) ; Console : : stdout ( $ this - > format ( ' - waiting : ' , Console : : FG _YELLOW ) ) ; Console : : output ( $ this - > get Waiting ( ) - > count ( ' * ' , $ this - > queue - > db ) ) ; Console : : stdout ( $ this - > format ( ' - delayed : ' , Console : : FG _YELLOW ) ) ; Console : : output ( $ this - > get Delayed ( ) - > count ( ' * ' , $ this - > queue - > db ) ) ; Console : : stdout ( $ this - > format ( ' - reserved : ' , Console : : FG _YELLOW ) ) ; Console : : output ( $ this - > get Reserved ( ) - > count ( ' * ' , $ this - > queue - > db ) ) ; Console : : stdout ( $ this - > format ( ' - done : ' , Console : : FG _YELLOW ) ) ; Console : : output ( $ this - > get Done ( ) - > count ( ' * ' , $ this - > queue - > db ) ) ; } 
public function run ( $ repeat , $ timeout = 0 ) { return $ this - > run Worker ( function ( callable $ can Continue ) use ( $ repeat , $ timeout ) { while ( $ can Continue ( ) ) { if ( $ payload = $ this - > get Pheanstalk ( ) - > reserve From Tube ( $ this - > tube , $ timeout ) ) { $ info = $ this - > get Pheanstalk ( ) - > stats Job ( $ payload ) ; if ( $ this - > handle Message ( $ payload - > get Id ( ) , $ payload - > get Data ( ) , $ info - > ttr , $ info - > reserves ) ) { $ this - > get Pheanstalk ( ) - > delete ( $ payload ) ; } } elseif ( ! $ repeat ) { break ; } } } ) ; } 
public function remove ( $ id ) { try { $ this - > get Pheanstalk ( ) - > delete ( new Job ( $ id , null ) ) ; return true ; } catch ( Server Exception $ e ) { if ( strpos ( $ e - > get Message ( ) , 'NOT _FOUND ' ) = = = 0 ) { return false ; } throw $ e ; } } 
public static function is Exit ( ) { if ( function _exists ( 'pcntl _signal ' ) ) { 
public function clear ( ) { $ this - > touch Index ( function ( & $ data ) { $ data = [ ] ; foreach ( glob ( " $this - >path /job * .data " ) as $ file Name ) { unlink ( $ file Name ) ; } } ) ; } 
public function remove ( $ id ) { $ removed = false ; $ this - > touch Index ( function ( & $ data ) use ( $ id , & $ removed ) { if ( ! empty ( $ data [ 'waiting ' ] ) ) { foreach ( $ data [ 'waiting ' ] as $ key = > $ payload ) { if ( $ payload [ 0 ] = = = $ id ) { unset ( $ data [ 'waiting ' ] [ $ key ] ) ; $ removed = true ; break ; } } } if ( ! $ removed & & ! empty ( $ data [ 'delayed ' ] ) ) { foreach ( $ data [ 'delayed ' ] as $ key = > $ payload ) { if ( $ payload [ 0 ] = = = $ id ) { unset ( $ data [ 'delayed ' ] [ $ key ] ) ; $ removed = true ; break ; } } } if ( ! $ removed & & ! empty ( $ data [ 'reserved ' ] ) ) { foreach ( $ data [ 'reserved ' ] as $ key = > $ payload ) { if ( $ payload [ 0 ] = = = $ id ) { unset ( $ data [ 'reserved ' ] [ $ key ] ) ; $ removed = true ; break ; } } } if ( $ removed ) { unlink ( " $this - >path /job $id .data " ) ; } } ) ; return $ removed ; } 
protected function reserve ( ) { $ id = null ; $ ttr = null ; $ attempt = null ; $ this - > touch Index ( function ( & $ data ) use ( & $ id , & $ ttr , & $ attempt ) { if ( ! empty ( $ data [ 'reserved ' ] ) ) { foreach ( $ data [ 'reserved ' ] as $ key = > $ payload ) { if ( $ payload [ 1 ] + $ payload [ 3 ] < time ( ) ) { list ( $ id , $ ttr , $ attempt , $ time ) = $ payload ; $ data [ 'reserved ' ] [ $ key ] [ 2 ] = + + $ attempt ; $ data [ 'reserved ' ] [ $ key ] [ 3 ] = time ( ) ; return ; } } } if ( ! empty ( $ data [ 'delayed ' ] ) & & $ data [ 'delayed ' ] [ 0 ] [ 2 ] < = time ( ) ) { list ( $ id , $ ttr , $ time ) = array _shift ( $ data [ 'delayed ' ] ) ; } elseif ( ! empty ( $ data [ 'waiting ' ] ) ) { list ( $ id , $ ttr ) = array _shift ( $ data [ 'waiting ' ] ) ; } if ( $ id ) { $ attempt = 1 ; $ data [ 'reserved ' ] [ "job $id " ] = [ $ id , $ ttr , $ attempt , time ( ) ] ; } } ) ; if ( $ id ) { return [ $ id , file _get _contents ( " $this - >path /job $id .data " ) , $ ttr , $ attempt ] ; } return null ; } 
protected function delete ( $ payload ) { $ id = $ payload [ 0 ] ; $ this - > touch Index ( function ( & $ data ) use ( $ id ) { foreach ( $ data [ 'reserved ' ] as $ key = > $ payload ) { if ( $ payload [ 0 ] = = = $ id ) { unset ( $ data [ 'reserved ' ] [ $ key ] ) ; break ; } } } ) ; unlink ( " $this - >path /job $id .data " ) ; } 
public function parse ( ) : array { $ previous Entity State = libxml _disable _entity _loader ( true ) ; $ previous Setting = libxml _use _internal _errors ( true ) ; try { while ( self : : ELEMENT ! = = $ this - > node Type ) { if ( ! $ this - > read ( ) ) { $ errors = libxml _get _errors ( ) ; libxml _clear _errors ( ) ; if ( $ errors ) { throw new Lib XMLException ( $ errors ) ; } } } $ result = $ this - > parse Current Element ( ) ; 
public function parse Get Elements ( array $ element Map = null ) : array { $ result = $ this - > parse Inner Tree ( $ element Map ) ; if ( ! is _array ( $ result ) ) { return [ ] ; } return $ result ; } 
public function parse Inner Tree ( array $ element Map = null ) { $ text = null ; $ elements = [ ] ; if ( self : : ELEMENT = = = $ this - > node Type & & $ this - > is Empty Element ) { 
public function read Text ( ) : string { $ result = ' ' ; $ previous Depth = $ this - > depth ; while ( $ this - > read ( ) & & $ this - > depth ! = $ previous Depth ) { if ( in _array ( $ this - > node Type , [ XMLReader : : TEXT , XMLReader : : CDATA , XMLReader : : WHITESPACE ] ) ) { $ result . = $ this - > value ; } } return $ result ; } 
public function parse Current Element ( ) : array { $ name = $ this - > get Clark ( ) ; $ attributes = [ ] ; if ( $ this - > has Attributes ) { $ attributes = $ this - > parse Attributes ( ) ; } $ value = call _user _func ( $ this - > get Deserializer For Element Name ( ( string ) $ name ) , $ this ) ; return [ 'name ' = > $ name , 'value ' = > $ value , 'attributes ' = > $ attributes , ] ; } 
public function parse Attributes ( ) : array { $ attributes = [ ] ; while ( $ this - > move To Next Attribute ( ) ) { if ( $ this - > namespace URI ) { 
public function get Deserializer For Element Name ( string $ name ) : callable { if ( ! array _key _exists ( $ name , $ this - > element Map ) ) { if ( ' { } ' = = substr ( $ name , 0 , 2 ) & & array _key _exists ( substr ( $ name , 2 ) , $ this - > element Map ) ) { $ name = substr ( $ name , 2 ) ; } else { return [ 'Sabre \ \Xml \ \Element \ \Base ' , 'xml Deserialize ' ] ; } } $ deserializer = $ this - > element Map [ $ name ] ; if ( is _subclass _of ( $ deserializer , 'Sabre \ \Xml \ \Xml Deserializable ' ) ) { return [ $ deserializer , 'xml Deserialize ' ] ; } if ( is _callable ( $ deserializer ) ) { return $ deserializer ; } $ type = gettype ( $ deserializer ) ; if ( 'string ' = = = $ type ) { $ type . = ' ( ' . $ deserializer . ' ) ' ; } elseif ( 'object ' = = = $ type ) { $ type . = ' ( ' . get _class ( $ deserializer ) . ' ) ' ; } throw new \ Logic Exception ( 'Could not use this type as a deserializer : ' . $ type . ' for element : ' . $ name ) ; } 
public function push Context ( ) { $ this - > context Stack [ ] = [ $ this - > element Map , $ this - > context Uri , $ this - > namespace Map , $ this - > class Map , ] ; } 
public function pop Context ( ) { list ( $ this - > element Map , $ this - > context Uri , $ this - > namespace Map , $ this - > class Map ) = array _pop ( $ this - > context Stack ) ; } 
public function get Writer ( ) : Writer { $ w = new Writer ( ) ; $ w - > namespace Map = $ this - > namespace Map ; $ w - > class Map = $ this - > class Map ; return $ w ; } 
public function parse ( $ input , string $ context Uri = null , string & $ root Element Name = null ) { if ( is _resource ( $ input ) ) { 
public function expect ( $ root Element Name , $ input , string $ context Uri = null ) { if ( is _resource ( $ input ) ) { 
public function write ( string $ root Element Name , $ value , string $ context Uri = null ) { $ w = $ this - > get Writer ( ) ; $ w - > open Memory ( ) ; $ w - > context Uri = $ context Uri ; $ w - > set Indent ( true ) ; $ w - > start Document ( ) ; $ w - > write Element ( $ root Element Name , $ value ) ; return $ w - > output Memory ( ) ; } 
public function map Value Object ( string $ element Name , string $ class Name ) { list ( $ namespace ) = self : : parse Clark Notation ( $ element Name ) ; $ this - > element Map [ $ element Name ] = function ( Reader $ reader ) use ( $ class Name , $ namespace ) { return \ Sabre \ Xml \ Deserializer \ value Object ( $ reader , $ class Name , $ namespace ) ; } ; $ this - > class Map [ $ class Name ] = function ( Writer $ writer , $ value Object ) use ( $ namespace ) { return \ Sabre \ Xml \ Serializer \ value Object ( $ writer , $ value Object , $ namespace ) ; } ; $ this - > value Object Map [ $ class Name ] = $ element Name ; } 
public function write Value Object ( $ object , string $ context Uri = null ) { if ( ! isset ( $ this - > value Object Map [ get _class ( $ object ) ] ) ) { throw new \ Invalid Argument Exception ( ' " ' . get _class ( $ object ) . ' " is not a registered value object class . Register your class with map Value Object . ' ) ; } return $ this - > write ( $ this - > value Object Map [ get _class ( $ object ) ] , $ object , $ context Uri ) ; } 
public static function parse Clark Notation ( string $ str ) : array { static $ cache = [ ] ; if ( ! isset ( $ cache [ $ str ] ) ) { if ( ! preg _match ( ' / ^ { ( [ ^ } ] * ) } ( . * ) $ / ' , $ str , $ matches ) ) { throw new \ Invalid Argument Exception ( ' \ ' ' . $ str . ' \ ' is not a valid clark -notation formatted string ' ) ; } $ cache [ $ str ] = [ $ matches [ 1 ] , $ matches [ 2 ] , ] ; } return $ cache [ $ str ] ; } 
public function xml Serialize ( Writer $ writer ) { $ reader = new Reader ( ) ; < ?xml version = " 1 . 0 " ? > <xml -fragment xmlns = "http : / /sabre .io /ns " > { $this - >get Xml ( ) } < /xml -fragment > XML ; $ reader - > xml ( $ xml ) ; while ( $ reader - > read ( ) ) { if ( $ reader - > depth < 1 ) { 
public static function xml Deserialize ( Reader $ reader ) { $ result = new self ( $ reader - > read Inner Xml ( ) ) ; $ reader - > next ( ) ; return $ result ; } 
public function xml Serialize ( Xml \ Writer $ writer ) { $ writer - > text ( \ Sabre \ Uri \ resolve ( $ writer - > context Uri , $ this - > value ) ) ; } 
public static function xml Deserialize ( Xml \ Reader $ reader ) { return new self ( \ Sabre \ Uri \ resolve ( ( string ) $ reader - > context Uri , $ reader - > read Text ( ) ) ) ; } 
public function start Element ( $ name ) : bool { if ( ' { ' = = = $ name [ 0 ] ) { list ( $ namespace , $ local Name ) = Service : : parse Clark Notation ( $ name ) ; if ( array _key _exists ( $ namespace , $ this - > namespace Map ) ) { $ result = $ this - > start Element NS ( ' ' = = = $ this - > namespace Map [ $ namespace ] ? null : $ this - > namespace Map [ $ namespace ] , $ local Name , null ) ; } else { 
public function write Element ( $ name , $ content = null ) : bool { $ this - > start Element ( $ name ) ; if ( ! is _null ( $ content ) ) { $ this - > write ( $ content ) ; } $ this - > end Element ( ) ; return true ; } 
public function write Attributes ( array $ attributes ) { foreach ( $ attributes as $ name = > $ value ) { $ this - > write Attribute ( $ name , $ value ) ; } } 
public function write Attribute ( $ name , $ value ) : bool { if ( ' { ' ! = = $ name [ 0 ] ) { return parent : : write Attribute ( $ name , $ value ) ; } list ( $ namespace , $ local Name ) = Service : : parse Clark Notation ( $ name ) ; if ( array _key _exists ( $ namespace , $ this - > namespace Map ) ) { 
public function register ( ) { $ this - > merge Config From ( _ _DIR _ _ . ' / . . /config /config .php ' , 'erd -generator ' ) ; $ this - > app - > bind ( 'command .generate :diagram ' , Generate Diagram Command : : class ) ; $ this - > commands ( [ 'command .generate :diagram ' , ] ) ; } 
public function get Model Relations ( string $ model ) { $ class = new Reflection Class ( $ model ) ; $ trait Methods = Collection : : make ( $ class - > get Traits ( ) ) - > map ( function ( Reflection Class $ trait ) { return Collection : : make ( $ trait - > get Methods ( Reflection Method : : IS _PUBLIC ) ) ; } ) - > flatten ( ) ; $ methods = Collection : : make ( $ class - > get Methods ( Reflection Method : : IS _PUBLIC ) ) - > merge ( $ trait Methods ) - > reject ( function ( Reflection Method $ method ) use ( $ model ) { return $ method - > class ! = = $ model | | $ method - > get Number Of Parameters ( ) > 0 ; } ) ; $ relations = Collection : : make ( ) ; $ methods - > map ( function ( Reflection Method $ method ) use ( $ model , & $ relations ) { $ relations = $ relations - > merge ( $ this - > get Relationship From Method And Model ( $ method , $ model ) ) ; } ) ; $ relations = $ relations - > filter ( ) ; if ( $ ignore Relations = array _get ( config ( 'erd -generator .ignore ' , [ ] ) , $ model ) ) { $ relations = $ relations - > diff Keys ( array _flip ( $ ignore Relations ) ) ; } return $ relations ; } 
protected function execute ( Input Interface $ input , Output Interface $ output ) { $ job = new Cron Job ( ) ; $ output - > writeln ( ' ' ) ; $ output - > writeln ( ' <info >The unique name how the job will be referenced . < /info > ' ) ; $ question = new Question ( ' <question >Name : < /question > ' , false ) ; $ name = $ this - > get Question Helper ( ) - > ask ( $ input , $ output , $ question ) ; $ this - > validate Job Name ( $ name ) ; $ job - > set Name ( $ name ) ; $ output - > writeln ( ' ' ) ; $ output - > writeln ( ' <info >The command to execute . You may add extra arguments . < /info > ' ) ; $ question = new Question ( ' <question >Command : < /question > ' , false ) ; $ command = $ this - > get Question Helper ( ) - > ask ( $ input , $ output , $ question ) ; $ this - > validate Command ( $ command ) ; $ job - > set Command ( $ command ) ; $ output - > writeln ( ' ' ) ; $ output - > writeln ( ' <info >The schedule in the crontab syntax . < /info > ' ) ; $ question = new Question ( ' <question >Schedule : < /question > ' , false ) ; $ schedule = $ this - > get Question Helper ( ) - > ask ( $ input , $ output , $ question ) ; $ this - > validate Schedule ( $ schedule ) ; $ job - > set Schedule ( $ schedule ) ; $ output - > writeln ( ' ' ) ; $ output - > writeln ( ' <info >Some more information about the job . < /info > ' ) ; $ question = new Question ( ' <question >Description : < /question > ' , false ) ; $ description = $ this - > get Question Helper ( ) - > ask ( $ input , $ output , $ question ) ; $ job - > set Description ( $ description ) ; $ output - > writeln ( ' ' ) ; $ output - > writeln ( ' <info >Should the cron be enabled . < /info > ' ) ; $ question = new Confirmation Question ( ' <question >Enable ? < /question > [y /n ] : ' , false , ' / ^ (y ) /i ' ) ; $ enabled = $ this - > get Question Helper ( ) - > ask ( $ input , $ output , $ question ) ; $ job - > set Enabled ( $ enabled ) ; $ this - > get Container ( ) - > get ( 'cron .manager ' ) - > save Job ( $ job ) ; $ output - > writeln ( ' ' ) ; $ output - > writeln ( sprintf ( ' <info >Cron " %s " was created . . < /info > ' , $ job - > get Name ( ) ) ) ; } 
protected function validate Job Name ( $ name ) { if ( ! $ name | | strlen ( $ name ) = = 0 ) { throw new \ Invalid Argument Exception ( 'Please set a name . ' ) ; } if ( $ this - > query Job ( $ name ) ) { throw new \ Invalid Argument Exception ( 'Name already in use . ' ) ; } return $ name ; } 
protected function validate Command ( $ command ) { $ parts = explode ( ' ' , $ command ) ; $ this - > get Application ( ) - > get ( ( string ) $ parts [ 0 ] ) ; return $ command ; } 
protected function execute ( Input Interface $ input , Output Interface $ output ) { $ cron = new Cron ( ) ; $ cron - > set Executor ( $ this - > get Container ( ) - > get ( 'cron .executor ' ) ) ; if ( $ input - > get Argument ( 'job ' ) ) { $ resolver = $ this - > get Job Resolver ( $ input - > get Argument ( 'job ' ) , $ input - > has Option ( 'force ' ) ) ; } else { $ resolver = $ this - > get Container ( ) - > get ( 'cron .resolver ' ) ; } $ cron - > set Resolver ( $ resolver ) ; $ time = microtime ( true ) ; $ db Report = $ cron - > run ( ) ; while ( $ cron - > is Running ( ) ) { } $ output - > writeln ( 'time : ' . ( microtime ( true ) - $ time ) ) ; $ manager = $ this - > get Container ( ) - > get ( 'cron .manager ' ) ; $ manager - > save Reports ( $ db Report - > get Reports ( ) ) ; } 
protected function create Job ( Cron Job $ db Job ) { $ job = new Shell Job ( ) ; $ job - > set Command ( $ this - > command Builder - > build ( $ db Job - > get Command ( ) ) , $ this - > root Dir ) ; $ job - > set Schedule ( new Crontab Schedule ( $ db Job - > get Schedule ( ) ) ) ; $ job - > raw = $ db Job ; return $ job ; } 
protected function execute ( Input Interface $ input , Output Interface $ output ) { $ pid File = sys _get _temp _dir ( ) . DIRECTORY _SEPARATOR . Cron Start Command : : PID _FILE ; if ( ! file _exists ( $ pid File ) ) { return 0 ; } if ( ! extension _loaded ( 'pcntl ' ) ) { throw new \ Runtime Exception ( 'This command needs the pcntl extension to run . ' ) ; } if ( ! posix _kill ( file _get _contents ( $ pid File ) , SIGINT ) ) { if ( ! unlink ( $ pid File ) ) { throw new \ Runtime Exception ( 'Unable to stop scheduler . ' ) ; } $ output - > writeln ( sprintf ( ' <comment > %s < /comment > ' , 'Unable to kill cron scheduler process . Scheduler will be stopped before the next run . ' ) ) ; return 0 ; } unlink ( $ pid File ) ; $ output - > writeln ( sprintf ( ' <info > %s < /info > ' , 'Cron scheduler is stopped . ' ) ) ; } 
protected function execute ( Input Interface $ input , Output Interface $ output ) { $ jobs = $ this - > query Jobs ( ) ; foreach ( $ jobs as $ job ) { $ state = $ job - > get Enabled ( ) ? 'x ' : ' ' ; $ output - > writeln ( sprintf ( ' [ %s ] %s ' , $ state , $ job - > get Name ( ) ) ) ; } } 
protected function execute ( Input Interface $ input , Output Interface $ output ) { if ( $ input - > get Option ( 'blocking ' ) ) { $ output - > writeln ( sprintf ( ' <info > %s < /info > ' , 'Starting cron scheduler in blocking mode . ' ) ) ; $ this - > scheduler ( $ output - > is Verbose ( ) ? $ output : new Null Output ( ) , null ) ; return 0 ; } if ( ! extension _loaded ( 'pcntl ' ) ) { throw new \ Runtime Exception ( 'This command needs the pcntl extension to run . ' ) ; } $ pid File = sys _get _temp _dir ( ) . DIRECTORY _SEPARATOR . self : : PID _FILE ; if ( - 1 = = = $ pid = pcntl _fork ( ) ) { throw new \ Runtime Exception ( 'Unable to start the cron process . ' ) ; } elseif ( 0 ! = = $ pid ) { if ( false = = = file _put _contents ( $ pid File , $ pid ) ) { throw new \ Runtime Exception ( 'Unable to create process file . ' ) ; } $ output - > writeln ( sprintf ( ' <info > %s < /info > ' , 'Cron scheduler started in non -blocking mode . . . ' ) ) ; return 0 ; } if ( - 1 = = = posix _setsid ( ) ) { throw new \ Runtime Exception ( 'Unable to set the child process as session leader . ' ) ; } $ this - > scheduler ( new Null Output ( ) , $ pid File ) ; } 
protected function execute ( Input Interface $ input , Output Interface $ output ) { $ job = $ this - > query Job ( $ input - > get Argument ( 'job ' ) ) ; if ( ! $ job ) { throw new \ Invalid Argument Exception ( 'Unknown job . ' ) ; } $ job - > set Enabled ( false ) ; $ this - > get Container ( ) - > get ( 'cron .manager ' ) - > save Job ( $ job ) ; $ output - > writeln ( sprintf ( 'Cron " %s " disabled ' , $ job - > get Name ( ) ) ) ; } 
protected function execute ( Input Interface $ input , Output Interface $ output ) { $ job = $ this - > query Job ( $ input - > get Argument ( 'job ' ) ) ; if ( ! $ job ) { throw new \ Invalid Argument Exception ( 'Unknown job . ' ) ; } if ( $ job - > get Enabled ( ) ) { throw new \ Invalid Argument Exception ( 'The job should be disabled first . ' ) ; } $ output - > writeln ( sprintf ( ' <info >You are about to delete " %s " . < /info > ' , $ job - > get Name ( ) ) ) ; $ question = new Confirmation Question ( ' <question >Delete this job < /question > [N /y ] : ' , false , ' / ^ (y ) /i ' ) ; if ( ! $ this - > get Question Helper ( ) - > ask ( $ input , $ output , $ question ) ) { return ; } $ this - > get Container ( ) - > get ( 'cron .manager ' ) - > delete Job ( $ job ) ; $ output - > writeln ( sprintf ( ' <info >Cron " %s " was deleted . < /info > ' , $ job - > get Name ( ) ) ) ; } 
public function create Scope And Retrieve Its Closer ( ? Trace Context $ current Context = null ) : callable { $ previous = $ this - > context ; $ self = $ this ; $ this - > context = $ current Context ; return function ( ) use ( $ previous , $ self ) { $ self - > context = $ previous ; } ; } 
public function build ( ? array $ options = [ ] ) : callable { return static function ( $ payload ) use ( $ options ) { $ handle = curl _init ( $ options [ 'endpoint _url ' ] ) ; if ( $ handle = = = false ) { throw new Runtime Exception ( sprintf ( 'failed to create the handle for url " %s " ' , $ options [ 'endpoint _url ' ] ) ) ; } curl _setopt ( $ handle , CURLOPT _POST , 1 ) ; curl _setopt ( $ handle , CURLOPT _POSTFIELDS , $ payload ) ; curl _setopt ( $ handle , CURLOPT _RETURNTRANSFER , true ) ; $ required Headers = [ 'Content -Type ' = > 'application /json ' , 'Content -Length ' = > strlen ( $ payload ) , ] ; $ additional Headers = ( isset ( $ options [ 'headers ' ] ) ? $ options [ 'headers ' ] : [ ] ) ; $ headers = array _merge ( $ additional Headers , $ required Headers ) ; $ formatted Headers = array _map ( function ( $ key , $ value ) { return $ key . ' : ' . $ value ; } , array _keys ( $ headers ) , $ headers ) ; curl _setopt ( $ handle , CURLOPT _HTTPHEADER , $ formatted Headers ) ; if ( isset ( $ options [ 'timeout ' ] ) ) { curl _setopt ( $ handle , CURLOPT _TIMEOUT , $ options [ 'timeout ' ] ) ; } if ( curl _exec ( $ handle ) ! = = false ) { $ status Code = curl _getinfo ( $ handle , CURLINFO _HTTP _CODE ) ; curl _close ( $ handle ) ; if ( $ status Code ! = = 2 0 2 ) { throw new Runtime Exception ( sprintf ( 'Reporting of spans failed , status code %d ' , $ status Code ) ) ; } } else { throw new Runtime Exception ( sprintf ( 'Reporting of spans failed : %s , error code %s ' , curl _error ( $ handle ) , curl _errno ( $ handle ) ) ) ; } } ; } 
public function get Injector ( Setter $ setter ) : callable { return function ( Trace Context $ trace Context , & $ carrier ) use ( $ setter ) { $ setter - > put ( $ carrier , self : : TRACE _ID _NAME , $ trace Context - > get Trace Id ( ) ) ; $ setter - > put ( $ carrier , self : : SPAN _ID _NAME , $ trace Context - > get Span Id ( ) ) ; if ( $ trace Context - > get Parent Id ( ) ! = = null ) { $ setter - > put ( $ carrier , self : : PARENT _SPAN _ID _NAME , $ trace Context - > get Parent Id ( ) ) ; } if ( $ trace Context - > is Sampled ( ) ! = = null ) { $ setter - > put ( $ carrier , self : : SAMPLED _NAME , $ trace Context - > is Sampled ( ) ? ' 1 ' : ' 0 ' ) ; } $ setter - > put ( $ carrier , self : : FLAGS _NAME , $ trace Context - > is Debug ( ) ? ' 1 ' : ' 0 ' ) ; } ; } 
public function get Extractor ( Getter $ getter ) : callable { return function ( $ carrier ) use ( $ getter ) { $ is Sampled Raw = $ getter - > get ( $ carrier , self : : SAMPLED _NAME ) ; $ is Sampled = Sampling Flags : : EMPTY _SAMPLED ; if ( $ is Sampled Raw ! = = null ) { if ( $ is Sampled Raw = = = ' 1 ' | | strtolower ( $ is Sampled Raw ) = = = 'true ' ) { $ is Sampled = true ; } elseif ( $ is Sampled Raw = = = ' 0 ' | | strtolower ( $ is Sampled Raw ) = = = 'false ' ) { $ is Sampled = false ; } } $ is Debug Raw = $ getter - > get ( $ carrier , self : : FLAGS _NAME ) ; $ is Debug = Sampling Flags : : EMPTY _DEBUG ; if ( $ is Debug Raw ! = = null ) { $ is Debug = ( $ is Debug Raw = = = ' 1 ' ) ; } $ trace Id = $ getter - > get ( $ carrier , self : : TRACE _ID _NAME ) ; if ( $ is Sampled = = = null & & $ is Debug = = = null & & $ trace Id = = = null ) { return Default Sampling Flags : : create As Empty ( ) ; } $ span Id = $ getter - > get ( $ carrier , self : : SPAN _ID _NAME ) ; if ( $ span Id = = = null ) { return Default Sampling Flags : : create ( $ is Sampled , $ is Debug ) ; } $ parent Span Id = $ getter - > get ( $ carrier , self : : PARENT _SPAN _ID _NAME ) ; try { return Trace Context : : create ( $ trace Id , $ span Id , $ parent Span Id , $ is Sampled , $ is Debug ) ; } catch ( Invalid Trace Context Argument $ e ) { $ this - > logger - > debug ( sprintf ( 'Failed to extract propagated context : %s ' , $ e - > get Message ( ) ) ) ; return Default Sampling Flags : : create As Empty ( ) ; } } ; } 
public function finish ( ? int $ finish Timestamp = null ) : void { if ( $ this - > finished ) { return ; } if ( $ this - > timestamp ! = = null & & $ finish Timestamp ! = = null ) { $ this - > duration = $ finish Timestamp - $ this - > timestamp ; } $ this - > finished = true ; } 
public function new Trace ( Sampling Flags $ sampling Flags = null ) : Span { if ( $ sampling Flags = = = null ) { $ sampling Flags = Default Sampling Flags : : create As Empty ( ) ; } return $ this - > ensure Sampled ( $ this - > new Root Context ( $ sampling Flags ) ) ; } 
public function open Scope ( ? Span $ span = null ) : callable { return $ this - > current Trace Context - > create Scope And Retrieve Its Closer ( $ span = = = null ? null : $ span - > get Context ( ) ) ; } 
public function get Current Span ( ) : ? Span { $ current Context = $ this - > current Trace Context - > get Context ( ) ; return $ current Context = = = null ? null : $ this - > to Span ( $ current Context ) ; } 
public function next Span ( ? Sampling Flags $ context Or Flags = null ) : Span { if ( $ context Or Flags = = = null ) { $ parent = $ this - > current Trace Context - > get Context ( ) ; return $ parent = = = null ? $ this - > new Trace ( ) : $ this - > new Child ( $ parent ) ; } if ( $ context Or Flags instanceof Trace Context ) { return $ this - > to Span ( Trace Context : : create From Parent ( $ context Or Flags ) ) ; } if ( $ context Or Flags instanceof Sampling Flags ) { $ implicit Parent = $ this - > current Trace Context - > get Context ( ) ; if ( $ implicit Parent = = = null ) { return $ this - > to Span ( $ this - > new Root Context ( $ context Or Flags ) ) ; } } throw new Runtime Exception ( 'Context or flags for next span is invalid . ' ) ; } 
private function to Span ( Trace Context $ context ) : Span { if ( ! $ this - > is Noop & & $ context - > is Sampled ( ) ) { return Real Span : : create ( $ context , $ this - > recorder ) ; } return Noop Span : : create ( $ context ) ; } 
public function get ( $ carrier , string $ key ) : ? string { $ l Key = strtolower ( $ key ) ; if ( $ carrier instanceof Array Access ) { return $ carrier - > offset Exists ( $ l Key ) ? $ carrier - > offset Get ( $ l Key ) : null ; } if ( is _array ( $ carrier ) ) { return array _key _exists ( $ l Key , $ carrier ) ? $ carrier [ $ l Key ] : null ; } throw Invalid Propagation Carrier : : for Carrier ( $ carrier ) ; } 
public function put ( & $ carrier , string $ key , string $ value ) : void { if ( $ key = = = ' ' ) { throw Invalid Propagation Key : : for Empty Key ( ) ; } $ l Key = strtolower ( $ key ) ; if ( $ carrier instanceof Array Access | | is _array ( $ carrier ) ) { $ carrier [ $ l Key ] = $ value ; return ; } throw Invalid Propagation Carrier : : for Carrier ( $ carrier ) ; } 
public function start ( ? int $ timestamp = null ) : void { if ( $ timestamp = = = null ) { $ timestamp = now ( ) ; } else { if ( ! is Valid ( $ timestamp ) ) { throw new Invalid Argument Exception ( sprintf ( 'Invalid timestamp . Expected int , got %s ' , $ timestamp ) ) ; } } $ this - > recorder - > start ( $ this - > trace Context , $ timestamp ) ; } 
public function set Name ( string $ name ) : void { $ this - > recorder - > set Name ( $ this - > trace Context , $ name ) ; } 
public function set Kind ( string $ kind ) : void { $ this - > recorder - > set Kind ( $ this - > trace Context , $ kind ) ; } 
public function tag ( string $ key , string $ value ) : void { $ this - > recorder - > tag ( $ this - > trace Context , $ key , $ value ) ; } 
public function annotate ( string $ value , ? int $ timestamp = null ) : void { if ( ! is Valid ( $ timestamp ) ) { throw new Invalid Argument Exception ( sprintf ( 'Valid timestamp represented microtime expected , got \ ' %s \ ' ' , $ timestamp ) ) ; } $ this - > recorder - > annotate ( $ this - > trace Context , $ timestamp , $ value ) ; } 
public function set Remote Endpoint ( Endpoint $ remote Endpoint ) : void { $ this - > recorder - > set Remote Endpoint ( $ this - > trace Context , $ remote Endpoint ) ; } 
public function finish ( ? int $ timestamp = null ) : void { if ( $ timestamp ! = = null & & ! Timestamp \ is Valid ( $ timestamp ) ) { throw new Invalid Argument Exception ( 'Invalid timestamp ' ) ; } if ( $ timestamp = = = null ) { $ timestamp = now ( ) ; } $ this - > recorder - > finish ( $ this - > trace Context , $ timestamp ) ; } 
public function get ( $ carrier , string $ key ) : ? string { $ l Key = strtolower ( $ key ) ; return $ carrier - > has Header ( $ l Key ) ? $ carrier - > get Header ( $ l Key ) [ 0 ] : null ; } 
public function put ( & $ carrier , string $ key , string $ value ) : void { $ l Key = strtolower ( $ key ) ; $ carrier = $ carrier - > with Added Header ( $ l Key , $ value ) ; } 
public function generate Token ( ) { 
public function generate New Token ( Server Request Interface $ request ) { $ pair = $ this - > generate Token ( ) ; $ request = $ this - > attach Request Attributes ( $ request , $ pair ) ; return $ request ; } 
protected function get From Storage ( $ name ) { return isset ( $ this - > storage [ $ name ] ) ? $ this - > storage [ $ name ] : false ; } 
protected function get Last Key Pair ( ) { 
protected function enforce Storage Limit ( ) { if ( $ this - > storage Limit < 1 ) { return ; } 
public static function create ( array $ config ) : Sanitizer Interface { $ builder = new Sanitizer Builder ( ) ; $ builder - > register Extension ( new Basic Extension ( ) ) ; $ builder - > register Extension ( new List Extension ( ) ) ; $ builder - > register Extension ( new Image Extension ( ) ) ; $ builder - > register Extension ( new Code Extension ( ) ) ; $ builder - > register Extension ( new Table Extension ( ) ) ; $ builder - > register Extension ( new Iframe Extension ( ) ) ; $ builder - > register Extension ( new Details Extension ( ) ) ; $ builder - > register Extension ( new Extra Extension ( ) ) ; return $ builder - > build ( $ config ) ; } 
private function set Attributes ( \ DOMNode $ dom Node , Tag Node Interface $ node , array $ allowed Attributes = [ ] ) { if ( ! \ count ( $ dom Node - > attributes ) ) { return ; } foreach ( $ dom Node - > attributes as $ attribute ) { $ name = strtolower ( $ attribute - > name ) ; if ( \ in _array ( $ name , $ allowed Attributes , true ) ) { $ node - > set Attribute ( $ name , $ attribute - > value ) ; } } } 
private function get Attribute ( \ DOMNode $ dom Node , string $ name ) : ? string { if ( ! \ count ( $ dom Node - > attributes ) ) { return null ; } foreach ( $ dom Node - > attributes as $ attribute ) { if ( $ attribute - > name = = = $ name ) { return $ attribute - > value ; } } return null ; } 
public function boot ( ) { if ( $ this - > app - > running In Console ( ) ) { $ this - > publishes ( [ _ _DIR _ _ . ' / . . /config /config .php ' = > config _path ( 'querydetector .php ' ) , ] , 'config ' ) ; } $ this - > register Middleware ( Query Detector Middleware : : class ) ; } 
public function register ( ) { $ this - > app - > singleton ( Query Detector : : class ) ; $ this - > app - > alias ( Query Detector : : class , 'querydetector ' ) ; $ this - > merge Config From ( _ _DIR _ _ . ' / . . /config /config .php ' , 'querydetector ' ) ; } 
public function handle ( $ request , Closure $ next ) { if ( ! $ this - > detector - > is Enabled ( ) ) { return $ next ( $ request ) ; } $ this - > detector - > boot ( ) ; $ response = $ next ( $ request ) ; 
private function process Default Entity ( array $ backend Config ) { $ entity Names = \ array _keys ( $ backend Config [ 'entities ' ] ) ; $ first Entity Name = $ entity Names [ 0 ] ? ? null ; $ backend Config [ 'default _entity _name ' ] = $ first Entity Name ; return $ backend Config ; } 
private function process Default Menu Item ( array $ backend Config ) { $ default Menu Item = $ this - > find Default Menu Item ( $ backend Config [ 'design ' ] [ 'menu ' ] ) ; if ( 'empty ' = = = $ default Menu Item [ 'type ' ] ) { throw new \ Runtime Exception ( \ sprintf ( 'The "menu " configuration sets " %s " as the default item , which is not possible because its type is "empty " and it cannot redirect to a valid URL . ' , $ default Menu Item [ 'label ' ] ) ) ; } $ backend Config [ 'default _menu _item ' ] = $ default Menu Item ; return $ backend Config ; } 
private function find Default Menu Item ( array $ menu Config ) { foreach ( $ menu Config as $ item Config ) { if ( true = = = $ item Config [ 'default ' ] ) { return $ item Config ; } foreach ( $ item Config [ 'children ' ] as $ subitem Config ) { if ( true = = = $ subitem Config [ 'default ' ] ) { return $ subitem Config ; } } } } 
private function process Default Homepage ( array $ backend Config ) { $ backend Homepage = [ ] ; 
public function supports ( $ type , array $ options , array $ metadata ) { $ is Fos Ckeditor Field = \ in _array ( $ type , [ 'fos _ckeditor ' , 'FOS \ \CKEditor Bundle \ \Form \ \Type \ \CKEditor Type ' ] , true ) ; return $ is Fos Ckeditor Field & & ! isset ( $ options [ 'config ' ] [ 'toolbar ' ] ) & & ! isset ( $ options [ 'config _name ' ] ) ; } 
public function supports ( $ type , array $ options , array $ metadata ) { $ is Textarea Field = \ in _array ( $ type , [ 'textarea ' , Textarea Type : : class ] , true ) ; return $ is Textarea Field & & ! isset ( $ options [ 'attr ' ] [ 'rows ' ] ) ; } 
public static function get Type Name ( $ type Fqcn ) { 
public function configure ( $ name , array $ options , array $ metadata , Form Config Interface $ parent Config ) { if ( ! isset ( $ options [ 'multiple ' ] ) & & $ metadata [ 'association Type ' ] & Class Metadata : : TO _MANY ) { $ options [ 'multiple ' ] = true ; } 
public function supports ( $ type , array $ options , array $ metadata ) { $ is Entity Type = \ in _array ( $ type , [ 'entity ' , Entity Type : : class ] , true ) ; return $ is Entity Type & & 'association ' = = = $ metadata [ 'data Type ' ] ; } 
public function finish View ( Form View $ view , Form Interface $ form , array $ options ) { $ request = null ; if ( null ! = = $ this - > request Stack ) { $ request = $ this - > request Stack - > get Current Request ( ) ; } if ( null = = = $ request ) { return ; } if ( $ request - > attributes - > has ( 'easyadmin ' ) ) { $ easyadmin = $ request - > attributes - > get ( 'easyadmin ' ) ; $ entity = $ easyadmin [ 'entity ' ] ; $ action = $ easyadmin [ 'view ' ] ; $ fields = $ entity [ $ action ] [ 'fields ' ] ? ? [ ] ; $ view - > vars [ 'easyadmin ' ] = [ 'entity ' = > $ entity , 'view ' = > $ action , 'item ' = > $ easyadmin [ 'item ' ] , 'field ' = > null , 'form _group ' = > $ form - > get Config ( ) - > get Attribute ( 'easyadmin _form _group ' ) , 'form _tab ' = > $ form - > get Config ( ) - > get Attribute ( 'easyadmin _form _tab ' ) , ] ; if ( null ! = = $ view - > parent & & null = = = $ view - > parent - > parent ) { $ view - > vars [ 'easyadmin ' ] [ 'field ' ] = $ fields [ $ view - > vars [ 'name ' ] ] ? ? null ; } } } 
public function find By All Properties ( array $ entity Config , $ search Query , $ page = 1 , $ max Results = self : : MAX _RESULTS , $ sort Field = null , $ sort Direction = null ) { $ query Builder = $ this - > query Builder - > create Search Query Builder ( $ entity Config , $ search Query , $ sort Field , $ sort Direction ) ; return $ this - > paginator - > create Orm Paginator ( $ query Builder , $ page , $ max Results ) ; } 
private function process Metadata Config ( array $ backend Config ) { foreach ( $ backend Config [ 'entities ' ] as $ entity Name = > $ entity Config ) { $ properties = [ ] ; foreach ( $ entity Config [ 'properties ' ] as $ property Name = > $ property Metadata ) { $ type Guess = $ this - > get Form Type Guess Of Property ( $ entity Config [ 'class ' ] , $ property Name ) ; $ required Guess = $ this - > get Form Required Guess Of Property ( $ entity Config [ 'class ' ] , $ property Name ) ; $ guessed Type = null ! = = $ type Guess ? Form Type Helper : : get Type Name ( $ type Guess - > get Type ( ) ) : $ property Metadata [ 'type ' ] ; $ guessed Type Options = null ! = = $ type Guess ? $ type Guess - > get Options ( ) : [ ] ; if ( null ! = = $ required Guess ) { $ guessed Type Options [ 'required ' ] = $ required Guess - > get Value ( ) ; } $ properties [ $ property Name ] = \ array _replace ( $ this - > default Entity Field Config , $ property Metadata , [ 'property ' = > $ property Name , 'data Type ' = > $ property Metadata [ 'type ' ] , 'field Type ' = > $ guessed Type , 'type _options ' = > $ guessed Type Options , ] ) ; 
private function process Field Config ( array $ backend Config ) { foreach ( $ backend Config [ 'entities ' ] as $ entity Name = > $ entity Config ) { foreach ( [ 'edit ' , 'list ' , 'new ' , 'search ' , 'show ' ] as $ view ) { $ original View Config = $ backend Config [ 'entities ' ] [ $ entity Name ] [ $ view ] ; foreach ( $ entity Config [ $ view ] [ 'fields ' ] as $ field Name = > $ field Config ) { $ original Field Config = $ original View Config [ 'fields ' ] [ $ field Name ] ? ? null ; if ( \ array _key _exists ( $ field Name , $ entity Config [ 'properties ' ] ) ) { $ field Metadata = \ array _merge ( $ entity Config [ 'properties ' ] [ $ field Name ] , [ 'virtual ' = > false ] ) ; } else { 
private function get Form Type Options Of Property ( array $ merged Config , array $ guessed Config , array $ user Defined Config ) { $ resolved Form Options = $ merged Config [ 'type _options ' ] ; 
private function get Field Format ( $ field Type , array $ backend Config ) { if ( \ in _array ( $ field Type , [ 'date ' , 'date _immutable ' , 'dateinterval ' , 'time ' , 'time _immutable ' , 'datetime ' , 'datetime _immutable ' , 'datetimetz ' ] ) ) { 
public function configure ( $ name , array $ options , array $ metadata , Form Config Interface $ parent Config ) { if ( ! \ array _key _exists ( 'label ' , $ options ) & & \ array _key _exists ( 'label ' , $ metadata ) ) { $ options [ 'label ' ] = $ metadata [ 'label ' ] ; } if ( empty ( $ options [ 'translation _domain ' ] ) ) { $ entity Config = $ this - > config Manager - > get Entity Config ( $ parent Config - > get Option ( 'entity ' ) ) ; if ( ! empty ( $ entity Config [ 'translation _domain ' ] ) ) { $ options [ 'translation _domain ' ] = $ entity Config [ 'translation _domain ' ] ; } } return $ options ; } 
public function index Action ( Request $ request ) { $ this - > initialize ( $ request ) ; if ( null = = = $ request - > query - > get ( 'entity ' ) ) { return $ this - > redirect To Backend Homepage ( ) ; } $ action = $ request - > query - > get ( 'action ' , 'list ' ) ; if ( ! $ this - > is Action Allowed ( $ action ) ) { throw new Forbidden Action Exception ( [ 'action ' = > $ action , 'entity _name ' = > $ this - > entity [ 'name ' ] ] ) ; } return $ this - > execute Dynamic Method ( $ action . ' <Entity Name >Action ' ) ; } 
protected function initialize ( Request $ request ) { $ this - > dispatch ( Easy Admin Events : : PRE _INITIALIZE ) ; $ this - > config = $ this - > get ( 'easyadmin .config .manager ' ) - > get Backend Config ( ) ; if ( 0 = = = \ count ( $ this - > config [ 'entities ' ] ) ) { throw new No Entities Configured Exception ( ) ; } 
protected function autocomplete Action ( ) { $ results = $ this - > get ( 'easyadmin .autocomplete ' ) - > find ( $ this - > request - > query - > get ( 'entity ' ) , $ this - > request - > query - > get ( 'query ' ) , $ this - > request - > query - > get ( 'page ' , 1 ) ) ; return new Json Response ( $ results ) ; } 
protected function list Action ( ) { $ this - > dispatch ( Easy Admin Events : : PRE _LIST ) ; $ fields = $ this - > entity [ 'list ' ] [ 'fields ' ] ; $ paginator = $ this - > find All ( $ this - > entity [ 'class ' ] , $ this - > request - > query - > get ( 'page ' , 1 ) , $ this - > entity [ 'list ' ] [ 'max _results ' ] , $ this - > request - > query - > get ( 'sort Field ' ) , $ this - > request - > query - > get ( 'sort Direction ' ) , $ this - > entity [ 'list ' ] [ 'dql _filter ' ] ) ; $ this - > dispatch ( Easy Admin Events : : POST _LIST , [ 'paginator ' = > $ paginator ] ) ; $ parameters = [ 'paginator ' = > $ paginator , 'fields ' = > $ fields , 'batch _form ' = > $ this - > create Batch Form ( $ this - > entity [ 'name ' ] ) - > create View ( ) , 'delete _form _template ' = > $ this - > create Delete Form ( $ this - > entity [ 'name ' ] , ' _ _id _ _ ' ) - > create View ( ) , ] ; return $ this - > execute Dynamic Method ( 'render <Entity Name >Template ' , [ 'list ' , $ this - > entity [ 'templates ' ] [ 'list ' ] , $ parameters ] ) ; } 
protected function edit Action ( ) { $ this - > dispatch ( Easy Admin Events : : PRE _EDIT ) ; $ id = $ this - > request - > query - > get ( 'id ' ) ; $ easyadmin = $ this - > request - > attributes - > get ( 'easyadmin ' ) ; $ entity = $ easyadmin [ 'item ' ] ; if ( $ this - > request - > is Xml Http Request ( ) & & $ property = $ this - > request - > query - > get ( 'property ' ) ) { $ new Value = 'true ' = = = \ mb _strtolower ( $ this - > request - > query - > get ( 'new Value ' ) ) ; $ fields Metadata = $ this - > entity [ 'list ' ] [ 'fields ' ] ; if ( ! isset ( $ fields Metadata [ $ property ] ) | | 'toggle ' ! = = $ fields Metadata [ $ property ] [ 'data Type ' ] ) { throw new \ Runtime Exception ( \ sprintf ( 'The type of the " %s " property is not "toggle " . ' , $ property ) ) ; } $ this - > update Entity Property ( $ entity , $ property , $ new Value ) ; 
protected function show Action ( ) { $ this - > dispatch ( Easy Admin Events : : PRE _SHOW ) ; $ id = $ this - > request - > query - > get ( 'id ' ) ; $ easyadmin = $ this - > request - > attributes - > get ( 'easyadmin ' ) ; $ entity = $ easyadmin [ 'item ' ] ; $ fields = $ this - > entity [ 'show ' ] [ 'fields ' ] ; $ delete Form = $ this - > create Delete Form ( $ this - > entity [ 'name ' ] , $ id ) ; $ this - > dispatch ( Easy Admin Events : : POST _SHOW , [ 'delete Form ' = > $ delete Form , 'fields ' = > $ fields , 'entity ' = > $ entity , ] ) ; $ parameters = [ 'entity ' = > $ entity , 'fields ' = > $ fields , 'delete _form ' = > $ delete Form - > create View ( ) , ] ; return $ this - > execute Dynamic Method ( 'render <Entity Name >Template ' , [ 'show ' , $ this - > entity [ 'templates ' ] [ 'show ' ] , $ parameters ] ) ; } 
protected function new Action ( ) { $ this - > dispatch ( Easy Admin Events : : PRE _NEW ) ; $ entity = $ this - > execute Dynamic Method ( 'create New <Entity Name >Entity ' ) ; $ easyadmin = $ this - > request - > attributes - > get ( 'easyadmin ' ) ; $ easyadmin [ 'item ' ] = $ entity ; $ this - > request - > attributes - > set ( 'easyadmin ' , $ easyadmin ) ; $ fields = $ this - > entity [ 'new ' ] [ 'fields ' ] ; $ new Form = $ this - > execute Dynamic Method ( 'create <Entity Name >New Form ' , [ $ entity , $ fields ] ) ; $ new Form - > handle Request ( $ this - > request ) ; if ( $ new Form - > is Submitted ( ) & & $ new Form - > is Valid ( ) ) { $ this - > dispatch ( Easy Admin Events : : PRE _PERSIST , [ 'entity ' = > $ entity ] ) ; $ this - > execute Dynamic Method ( 'persist <Entity Name >Entity ' , [ $ entity , $ new Form ] ) ; $ this - > dispatch ( Easy Admin Events : : POST _PERSIST , [ 'entity ' = > $ entity ] ) ; return $ this - > redirect To Referrer ( ) ; } $ this - > dispatch ( Easy Admin Events : : POST _NEW , [ 'entity _fields ' = > $ fields , 'form ' = > $ new Form , 'entity ' = > $ entity , ] ) ; $ parameters = [ 'form ' = > $ new Form - > create View ( ) , 'entity _fields ' = > $ fields , 'entity ' = > $ entity , ] ; return $ this - > execute Dynamic Method ( 'render <Entity Name >Template ' , [ 'new ' , $ this - > entity [ 'templates ' ] [ 'new ' ] , $ parameters ] ) ; } 
protected function delete Action ( ) { $ this - > dispatch ( Easy Admin Events : : PRE _DELETE ) ; if ( 'DELETE ' ! = = $ this - > request - > get Method ( ) ) { return $ this - > redirect ( $ this - > generate Url ( 'easyadmin ' , [ 'action ' = > 'list ' , 'entity ' = > $ this - > entity [ 'name ' ] ] ) ) ; } $ id = $ this - > request - > query - > get ( 'id ' ) ; $ form = $ this - > create Delete Form ( $ this - > entity [ 'name ' ] , $ id ) ; $ form - > handle Request ( $ this - > request ) ; if ( $ form - > is Submitted ( ) & & $ form - > is Valid ( ) ) { $ easyadmin = $ this - > request - > attributes - > get ( 'easyadmin ' ) ; $ entity = $ easyadmin [ 'item ' ] ; $ this - > dispatch ( Easy Admin Events : : PRE _REMOVE , [ 'entity ' = > $ entity ] ) ; try { $ this - > execute Dynamic Method ( 'remove <Entity Name >Entity ' , [ $ entity , $ form ] ) ; } catch ( Foreign Key Constraint Violation Exception $ e ) { throw new Entity Remove Exception ( [ 'entity _name ' = > $ this - > entity [ 'name ' ] , 'message ' = > $ e - > get Message ( ) ] ) ; } $ this - > dispatch ( Easy Admin Events : : POST _REMOVE , [ 'entity ' = > $ entity ] ) ; } $ this - > dispatch ( Easy Admin Events : : POST _DELETE ) ; return $ this - > redirect To Referrer ( ) ; } 
protected function search Action ( ) { $ this - > dispatch ( Easy Admin Events : : PRE _SEARCH ) ; $ query = \ trim ( $ this - > request - > query - > get ( 'query ' ) ) ; 
protected function batch Action ( ) : Redirect Response { $ batch Form = $ this - > create Batch Form ( $ this - > entity [ 'name ' ] ) ; $ batch Form - > handle Request ( $ this - > request ) ; if ( $ batch Form - > is Submitted ( ) & & $ batch Form - > is Valid ( ) ) { $ action Name = $ batch Form - > get ( 'name ' ) - > get Data ( ) ; $ action Ids = $ batch Form - > get ( 'ids ' ) - > get Data ( ) ; $ this - > execute Dynamic Method ( $ action Name . ' <Entity Name >Batch Action ' , [ $ action Ids , $ batch Form ] ) ; } return $ this - > redirect To Referrer ( ) ; } 
protected function update Entity Property ( $ entity , $ property , $ value ) { $ entity Config = $ this - > entity ; if ( ! $ this - > get ( 'easyadmin .property _accessor ' ) - > is Writable ( $ entity , $ property ) ) { throw new \ Runtime Exception ( \ sprintf ( 'The " %s " property of the " %s " entity is not writable . ' , $ property , $ entity Config [ 'name ' ] ) ) ; } $ this - > get ( 'easyadmin .property _accessor ' ) - > set Value ( $ entity , $ property , $ value ) ; $ this - > dispatch ( Easy Admin Events : : PRE _UPDATE , [ 'entity ' = > $ entity , 'new Value ' = > $ value ] ) ; $ this - > execute Dynamic Method ( 'update <Entity Name >Entity ' , [ $ entity ] ) ; $ this - > dispatch ( Easy Admin Events : : POST _UPDATE , [ 'entity ' = > $ entity , 'new Value ' = > $ value ] ) ; $ this - > dispatch ( Easy Admin Events : : POST _EDIT ) ; } 
protected function find All ( $ entity Class , $ page = 1 , $ max Per Page = 1 5 , $ sort Field = null , $ sort Direction = null , $ dql Filter = null ) { if ( null = = = $ sort Direction | | ! \ in _array ( \ strtoupper ( $ sort Direction ) , [ 'ASC ' , 'DESC ' ] ) ) { $ sort Direction = 'DESC ' ; } $ query Builder = $ this - > execute Dynamic Method ( 'create <Entity Name >List Query Builder ' , [ $ entity Class , $ sort Direction , $ sort Field , $ dql Filter ] ) ; $ this - > dispatch ( Easy Admin Events : : POST _LIST _QUERY _BUILDER , [ 'query _builder ' = > $ query Builder , 'sort _field ' = > $ sort Field , 'sort _direction ' = > $ sort Direction , ] ) ; return $ this - > get ( 'easyadmin .paginator ' ) - > create Orm Paginator ( $ query Builder , $ page , $ max Per Page ) ; } 
protected function create List Query Builder ( $ entity Class , $ sort Direction , $ sort Field = null , $ dql Filter = null ) { return $ this - > get ( 'easyadmin .query _builder ' ) - > create List Query Builder ( $ this - > entity , $ sort Field , $ sort Direction , $ dql Filter ) ; } 
protected function find By ( $ entity Class , $ search Query , array $ searchable Fields , $ page = 1 , $ max Per Page = 1 5 , $ sort Field = null , $ sort Direction = null , $ dql Filter = null ) { if ( empty ( $ sort Direction ) | | ! \ in _array ( \ strtoupper ( $ sort Direction ) , [ 'ASC ' , 'DESC ' ] ) ) { $ sort Direction = 'DESC ' ; } $ query Builder = $ this - > execute Dynamic Method ( 'create <Entity Name >Search Query Builder ' , [ $ entity Class , $ search Query , $ searchable Fields , $ sort Field , $ sort Direction , $ dql Filter ] ) ; $ this - > dispatch ( Easy Admin Events : : POST _SEARCH _QUERY _BUILDER , [ 'query _builder ' = > $ query Builder , 'search _query ' = > $ search Query , 'searchable _fields ' = > $ searchable Fields , ] ) ; return $ this - > get ( 'easyadmin .paginator ' ) - > create Orm Paginator ( $ query Builder , $ page , $ max Per Page ) ; } 
protected function create Search Query Builder ( $ entity Class , $ search Query , array $ searchable Fields , $ sort Field = null , $ sort Direction = null , $ dql Filter = null ) { return $ this - > get ( 'easyadmin .query _builder ' ) - > create Search Query Builder ( $ this - > entity , $ search Query , $ sort Field , $ sort Direction , $ dql Filter ) ; } 
protected function create Entity Form Builder ( $ entity , $ view ) { $ form Options = $ this - > execute Dynamic Method ( 'get <Entity Name >Entity Form Options ' , [ $ entity , $ view ] ) ; return $ this - > get ( 'form .factory ' ) - > create Named Builder ( \ mb _strtolower ( $ this - > entity [ 'name ' ] ) , Easy Admin Form Type : : class , $ entity , $ form Options ) ; } 
protected function get Entity Form Options ( $ entity , $ view ) { $ form Options = $ this - > entity [ $ view ] [ 'form _options ' ] ; $ form Options [ 'entity ' ] = $ this - > entity [ 'name ' ] ; $ form Options [ 'view ' ] = $ view ; return $ form Options ; } 
protected function create Entity Form ( $ entity , array $ entity Properties , $ view ) { if ( \ method _exists ( $ this , $ custom Method Name = 'create ' . $ this - > entity [ 'name ' ] . 'Entity Form ' ) ) { $ form = $ this - > { $ custom Method Name } ( $ entity , $ entity Properties , $ view ) ; if ( ! $ form instanceof Form Interface ) { throw new \ Unexpected Value Exception ( \ sprintf ( 'The " %s " method must return a Form Interface , " %s " given . ' , $ custom Method Name , \ is _object ( $ form ) ? \ get _class ( $ form ) : \ gettype ( $ form ) ) ) ; } return $ form ; } $ form Builder = $ this - > execute Dynamic Method ( 'create <Entity Name >Entity Form Builder ' , [ $ entity , $ view ] ) ; if ( ! $ form Builder instanceof Form Builder Interface ) { throw new \ Unexpected Value Exception ( \ sprintf ( 'The " %s " method must return a Form Builder Interface , " %s " given . ' , 'create Entity Form ' , \ is _object ( $ form Builder ) ? \ get _class ( $ form Builder ) : \ gettype ( $ form Builder ) ) ) ; } return $ form Builder - > get Form ( ) ; } 
protected function create Delete Form ( $ entity Name , $ entity Id ) { $ form Builder = $ this - > get ( 'form .factory ' ) - > create Named Builder ( 'delete _form ' ) - > set Action ( $ this - > generate Url ( 'easyadmin ' , [ 'action ' = > 'delete ' , 'entity ' = > $ entity Name , 'id ' = > $ entity Id ] ) ) - > set Method ( 'DELETE ' ) ; $ form Builder - > add ( 'submit ' , Submit Type : : class , [ 'label ' = > 'delete _modal .action ' , 'translation _domain ' = > 'Easy Admin Bundle ' ] ) ; 
protected function execute Dynamic Method ( $ method Name Pattern , array $ arguments = [ ] ) { $ method Name = \ str _replace ( ' <Entity Name > ' , $ this - > entity [ 'name ' ] , $ method Name Pattern ) ; if ( ! \ is _callable ( [ $ this , $ method Name ] ) ) { $ method Name = \ str _replace ( ' <Entity Name > ' , ' ' , $ method Name Pattern ) ; } return \ call _user _func _array ( [ $ this , $ method Name ] , $ arguments ) ; } 
protected function redirect To Backend Homepage ( ) { $ homepage Config = $ this - > config [ 'homepage ' ] ; $ url = $ homepage Config [ 'url ' ] ? ? $ this - > get ( 'router ' ) - > generate ( $ homepage Config [ 'route ' ] , $ homepage Config [ 'params ' ] ) ; return $ this - > redirect ( $ url ) ; } 
public function process ( Container Builder $ container ) { $ config Passes = $ this - > find And Sort Tagged Services ( 'easyadmin .config _pass ' , $ container ) ; $ definition = $ container - > get Definition ( 'easyadmin .config .manager ' ) ; foreach ( $ config Passes as $ service ) { $ definition - > add Method Call ( 'add Config Pass ' , [ $ service ] ) ; } } 
public function on Kernel Controller ( Filter Controller Event $ event ) { $ request = $ event - > get Request ( ) ; if ( 'easyadmin ' ! = = $ request - > attributes - > get ( ' _route ' ) ) { return ; } $ current Controller = $ event - > get Controller ( ) ; 
public function build View ( Form View $ view , Form Interface $ form , array $ options ) { if ( null = = = $ config = $ this - > config Manager - > get Entity Config By Class ( $ options [ 'class ' ] ) ) { throw new \ Invalid Argument Exception ( \ sprintf ( 'The configuration of the " %s " entity is not available (this entity is used as the target of the " %s " autocomplete field ) . ' , $ options [ 'class ' ] , $ form - > get Name ( ) ) ) ; } $ view - > vars [ 'autocomplete _entity _name ' ] = $ config [ 'name ' ] ; } 
public function map Data To Forms ( $ data , $ forms ) { $ form = \ current ( \ iterator _to _array ( $ forms ) ) ; $ form - > set Data ( $ data ) ; } 
public function map Forms To Data ( $ forms , & $ data ) { $ form = \ current ( \ iterator _to _array ( $ forms ) ) ; $ data = $ form - > get Data ( ) ; } 
public function generate ( $ entity , $ action , array $ parameters = [ ] ) { if ( \ is _object ( $ entity ) ) { $ config = $ this - > get Entity Config By Class ( \ get _class ( $ entity ) ) ; 
private function get Real Class ( $ class ) { if ( false = = = $ pos = \ strrpos ( $ class , ' \ \ ' . Proxy : : MARKER . ' \ \ ' ) ) { return $ class ; } return \ substr ( $ class , $ pos + Proxy : : MARKER _LENGTH + 2 ) ; } 
public function configure ( $ name , array $ options , array $ metadata , Form Config Interface $ parent Config ) { 
public function supports ( $ type , array $ options , array $ metadata ) { $ supported Types = [ 'easyadmin _autocomplete ' , Easy Admin Autocomplete Type : : class , ] ; return \ in _array ( $ type , $ supported Types , true ) ; } 
private function process Entity Templates ( array $ backend Config ) { 
private function process Default Templates ( array $ backend Config ) { 
private function process Field Templates ( array $ backend Config ) { foreach ( $ backend Config [ 'entities ' ] as $ entity Name = > $ entity Config ) { foreach ( [ 'list ' , 'show ' ] as $ view ) { foreach ( $ entity Config [ $ view ] [ 'fields ' ] as $ field Name = > $ field Metadata ) { if ( null ! = = $ field Metadata [ 'template ' ] ) { continue ; } 
private function normalize Menu Config ( array $ menu Config , array $ backend Config , $ parent Item Index = - 1 ) { 
public function configure ( $ name , array $ options , array $ metadata , Form Config Interface $ parent Config ) { 
public function guess Type ( $ class , $ property ) { if ( null ! = = $ metadata And Name = $ this - > get Metadata ( $ class ) ) { $ metadata = $ metadata And Name [ 0 ] ; switch ( $ metadata - > get Type Of Field ( $ property ) ) { case 'datetime _immutable ' : 
public function supports ( $ type , array $ options , array $ metadata ) { $ is Ckeditor Field = \ in _array ( $ type , [ 'ckeditor ' , 'Ivory \ \CKEditor Bundle \ \Form \ \Type \ \CKEditor Type ' ] , true ) ; return $ is Ckeditor Field & & ! isset ( $ options [ 'config ' ] [ 'toolbar ' ] ) & & ! isset ( $ options [ 'config _name ' ] ) ; } 
public function get Functions ( ) { return [ new Twig Function ( 'easyadmin _render _field _for _ * _view ' , [ $ this , 'render Entity Field ' ] , [ 'is _safe ' = > [ 'html ' ] , 'needs _environment ' = > true ] ) , new Twig Function ( 'easyadmin _config ' , [ $ this , 'get Backend Configuration ' ] ) , new Twig Function ( 'easyadmin _entity ' , [ $ this , 'get Entity Configuration ' ] ) , new Twig Function ( 'easyadmin _path ' , [ $ this , 'get Entity Path ' ] ) , new Twig Function ( 'easyadmin _action _is _enabled ' , [ $ this , 'is Action Enabled ' ] ) , new Twig Function ( 'easyadmin _action _is _enabled _for _ * _view ' , [ $ this , 'is Action Enabled ' ] ) , new Twig Function ( 'easyadmin _get _action ' , [ $ this , 'get Action Configuration ' ] ) , new Twig Function ( 'easyadmin _get _action _for _ * _view ' , [ $ this , 'get Action Configuration ' ] ) , new Twig Function ( 'easyadmin _get _actions _for _ * _item ' , [ $ this , 'get Actions For Item ' ] ) , new Twig Function ( 'easyadmin _logout _path ' , [ $ this , 'get Logout Path ' ] ) , new Twig Function ( 'easyadmin _read _property ' , [ $ this , 'read Property ' ] ) , ] ; } 
public function get Filters ( ) { $ filters = [ new Twig Filter ( 'easyadmin _truncate ' , [ $ this , 'truncate Text ' ] , [ 'needs _environment ' = > true ] ) , new Twig Filter ( 'easyadmin _urldecode ' , 'urldecode ' ) , ] ; if ( Kernel : : VERSION _ID > = 4 0 2 0 0 ) { $ filters [ ] = new Twig Filter ( 'transchoice ' , [ $ this , 'transchoice ' ] ) ; } return $ filters ; } 
public function get Entity Configuration ( $ entity Name ) { return null ! = = $ this - > get Backend Configuration ( 'entities . ' . $ entity Name ) ? $ this - > config Manager - > get Entity Config ( $ entity Name ) : null ; } 
public function get Entity Path ( $ entity , $ action , array $ parameters = [ ] ) { return $ this - > easy Admin Router - > generate ( $ entity , $ action , $ parameters ) ; } 
public function render Entity Field ( \ Twig _Environment $ twig , $ view , $ entity Name , $ item , array $ field Metadata ) { $ entity Configuration = $ this - > config Manager - > get Entity Config ( $ entity Name ) ; $ has Custom Template = 0 ! = = \ strpos ( $ field Metadata [ 'template ' ] , ' @Easy Admin / ' ) ; $ template Parameters = [ ] ; try { $ template Parameters = $ this - > get Template Parameters ( $ entity Name , $ view , $ field Metadata , $ item ) ; 
public function is Action Enabled ( $ view , $ action , $ entity Name ) { return $ this - > config Manager - > is Action Enabled ( $ entity Name , $ view , $ action ) ; } 
public function get Action Configuration ( $ view , $ action , $ entity Name ) { return $ this - > config Manager - > get Action Config ( $ entity Name , $ view , $ action ) ; } 
public function get Actions For Item ( $ view , $ entity Name ) { try { $ entity Config = $ this - > config Manager - > get Entity Config ( $ entity Name ) ; } catch ( \ Exception $ e ) { return [ ] ; } $ disabled Actions = $ entity Config [ 'disabled _actions ' ] ; $ view Actions = $ entity Config [ $ view ] [ 'actions ' ] ; $ actions Excluded For Items = [ 'list ' = > [ 'new ' , 'search ' ] , 'edit ' = > [ ] , 'new ' = > [ ] , 'show ' = > [ ] , ] ; $ excluded Actions = $ actions Excluded For Items [ $ view ] ; return \ array _filter ( $ view Actions , function ( $ action ) use ( $ excluded Actions , $ disabled Actions ) { return ! \ in _array ( $ action [ 'name ' ] , $ excluded Actions ) & & ! \ in _array ( $ action [ 'name ' ] , $ disabled Actions ) ; } ) ; } 
public function truncate Text ( \ Twig _Environment $ env , $ value , $ length = 6 4 , $ preserve = false , $ separator = ' . . . ' ) { try { $ value = ( string ) $ value ; } catch ( \ Exception $ e ) { $ value = ' ' ; } if ( \ mb _strlen ( $ value , $ env - > get Charset ( ) ) > $ length ) { if ( $ preserve ) { 
public function transchoice ( $ message , $ count , array $ arguments = [ ] , $ domain = null , $ locale = null ) { if ( null = = = $ this - > translator ) { return strtr ( $ message , $ arguments ) ; } return $ this - > translator - > trans ( $ message , array _merge ( [ ' %count % ' = > $ count ] , $ arguments ) , $ domain , $ locale ) ; } 
public function configure ( $ name , array $ options , array $ metadata , Form Config Interface $ parent Config ) { if ( ! isset ( $ options [ 'allow _add ' ] ) ) { $ options [ 'allow _add ' ] = true ; } if ( ! isset ( $ options [ 'allow _delete ' ] ) ) { $ options [ 'allow _delete ' ] = true ; } if ( ! isset ( $ options [ 'delete _empty ' ] ) ) { $ options [ 'delete _empty ' ] = true ; } 
public function create Orm Paginator ( $ query Builder , $ page = 1 , $ max Per Page = self : : MAX _ITEMS ) { $ query = $ query Builder - > get Query ( ) ; if ( 0 = = = \ count ( $ query Builder - > get DQLPart ( 'join ' ) ) ) { $ query - > set Hint ( Count Walker : : HINT _DISTINCT , false ) ; } 
public function build Form ( Form Builder Interface $ builder , array $ options ) : void { $ builder - > add ( 'name ' , Hidden Type : : class ) ; $ builder - > add ( 'ids ' , Hidden Type : : class ) ; $ builder - > get ( 'ids ' ) - > add Model Transformer ( new Callback Transformer ( function ( $ value ) { return $ value ; } , function ( $ value ) { return explode ( ' , ' , $ value ) ; } ) ) ; } 
public function build View ( Form View $ view , Form Interface $ form , array $ options ) : void { $ entity Config = $ this - > config Manager - > get Entity Config ( $ options [ 'entity ' ] ) ; $ disabled Actions = $ entity Config [ 'disabled _actions ' ] ; $ batch Actions = $ entity Config [ 'list ' ] [ 'batch _actions ' ] ; $ view - > vars [ 'batch _actions ' ] = \ array _filter ( $ batch Actions , function ( $ batch Action ) use ( $ disabled Actions ) { return ! \ in _array ( $ batch Action [ 'name ' ] , $ disabled Actions , true ) ; } ) ; } 
public function finish View ( Form View $ view , Form Interface $ form , array $ options ) : void { 
private function do Process Config ( $ backend Config ) : array { foreach ( $ this - > config Passes as $ config Pass ) { $ backend Config = $ config Pass - > process ( $ backend Config ) ; } return $ backend Config ; } 
public function initialize Request ( Generic Event $ event ) { $ request = null ; if ( null ! = = $ this - > request Stack ) { $ request = $ this - > request Stack - > get Current Request ( ) ; } if ( null = = = $ request ) { return ; } $ request - > attributes - > set ( 'easyadmin ' , [ 'entity ' = > $ entity = $ event - > get Argument ( 'entity ' ) , 'view ' = > $ request - > query - > get ( 'action ' , 'list ' ) , 'item ' = > ( $ id = $ request - > query - > get ( 'id ' ) ) ? $ this - > find Current Item ( $ entity , $ id ) : null , ] ) ; } 
private function find Current Item ( array $ entity Config , $ item Id ) { if ( null = = = $ manager = $ this - > doctrine - > get Manager For Class ( $ entity Config [ 'class ' ] ) ) { throw new \ Runtime Exception ( \ sprintf ( 'There is no Doctrine Entity Manager defined for the " %s " class ' , $ entity Config [ 'class ' ] ) ) ; } if ( null = = = $ entity = $ manager - > get Repository ( $ entity Config [ 'class ' ] ) - > find ( $ item Id ) ) { throw new Entity Not Found Exception ( [ 'entity _name ' = > $ entity Config [ 'name ' ] , 'entity _id _name ' = > $ entity Config [ 'primary _key _field _name ' ] , 'entity _id _value ' = > $ item Id ] ) ; } return $ entity ; } 
public static function create ( \ Exception $ exception , $ status Code = null , array $ headers = [ ] ) { if ( ! $ exception instanceof Base Exception ) { throw new \ Runtime Exception ( \ sprintf ( 'You should only try to create an instance of " %s " with a "Easy Corp \Bundle \Easy Admin Bundle \Exception \Base Exception " instance , or subclass . " %s " given . ' , _ _CLASS _ _ , \ get _class ( $ exception ) ) ) ; } $ e = parent : : create ( $ exception , $ status Code , $ headers ) ; $ e - > context = $ exception - > get Context ( ) ; return $ e ; } 
public function build Form ( Form Builder Interface $ builder , array $ options ) { $ entity = $ options [ 'entity ' ] ; $ view = $ options [ 'view ' ] ; $ entity Config = $ this - > config Manager - > get Entity Config ( $ entity ) ; $ entity Properties = $ entity Config [ $ view ] [ 'fields ' ] ? ? [ ] ; $ form Tabs = [ ] ; $ current Form Tab = null ; $ form Groups = [ ] ; $ current Form Group = null ; foreach ( $ entity Properties as $ name = > $ metadata ) { $ form Field Options = $ metadata [ 'type _options ' ] ; 
public function finish View ( Form View $ view , Form Interface $ form , array $ options ) { $ view - > vars [ 'easyadmin _form _tabs ' ] = $ form - > get Config ( ) - > get Attribute ( 'easyadmin _form _tabs ' ) ; $ view - > vars [ 'easyadmin _form _groups ' ] = $ form - > get Config ( ) - > get Attribute ( 'easyadmin _form _groups ' ) ; } 
public function configure Options ( Options Resolver $ resolver ) { $ resolver - > set Defaults ( [ 'allow _extra _fields ' = > true , 'data _class ' = > function ( Options $ options , $ data Class ) { if ( null ! = = $ data Class ) { return $ data Class ; } $ entity Config = $ this - > config Manager - > get Entity Config ( $ options [ 'entity ' ] ) ; return $ entity Config [ 'class ' ] ; } , ] ) - > set Required ( [ 'entity ' , 'view ' ] ) - > set Normalizer ( 'attr ' , $ this - > get Attributes Normalizer ( ) ) ; } 
private function get Attributes Normalizer ( ) { return function ( Options $ options , $ value ) { return \ array _replace ( [ 'id ' = > \ sprintf ( ' %s - %s -form ' , $ options [ 'view ' ] , \ mb _strtolower ( $ options [ 'entity ' ] ) ) , ] , $ value ) ; } ; } 
protected function duplicate Request ( \ Exception $ exception , Request $ request ) { $ request = parent : : duplicate Request ( $ exception , $ request ) ; $ request - > attributes - > set ( 'exception ' , Flatten Exception : : create ( $ exception ) ) ; return $ request ; } 
private function process Entity Properties Metadata ( Class Metadata $ entity Metadata ) { $ entity Properties Metadata = [ ] ; if ( $ entity Metadata - > is Identifier Composite ) { throw new \ Runtime Exception ( \ sprintf ( "The ' %s ' entity isn 't valid because it contains a composite primary key . " , $ entity Metadata - > name ) ) ; } 
private function normalize Actions Config ( array $ backend Config ) { 
private function normalize Batch Actions Config ( array $ backend Config ) { 
private function do Normalize Default Actions Config ( array $ actions Config , $ view ) { $ default Actions Config = $ this - > get Default Actions Config ( $ view ) ; foreach ( $ actions Config as $ action Name = > $ action Config ) { if ( \ array _key _exists ( $ action Name , $ default Actions Config ) ) { 
private function resolve Action Inheritance ( array $ backend Config ) { foreach ( $ backend Config [ 'entities ' ] as $ entity Name = > $ entity Config ) { foreach ( $ this - > views as $ view ) { $ default Actions = $ this - > get Default Actions ( $ view ) ; $ backend Actions = $ backend Config [ $ view ] [ 'actions ' ] ; $ entity Actions = $ entity Config [ $ view ] [ 'actions ' ] ; 
private function resolve Batch Action Inheritance ( array $ backend Config ) { foreach ( $ backend Config [ 'entities ' ] as $ entity Name = > $ entity Config ) { $ backend Batch Actions = $ backend Config [ 'list ' ] [ 'batch _actions ' ] ; $ entity Batch Actions = $ entity Config [ 'list ' ] [ 'batch _actions ' ] ; 
private function get Default Actions Config ( $ view ) { $ actions = $ this - > do Normalize Actions Config ( [ 'delete ' = > [ 'name ' = > 'delete ' , 'label ' = > 'action .delete ' , 'icon ' = > 'trash -o ' , 'css _class ' = > 'btn text -danger ' ] , 'edit ' = > [ 'name ' = > 'edit ' , 'label ' = > 'action .edit ' , 'icon ' = > 'edit ' , 'css _class ' = > 'btn btn -primary ' ] , 'new ' = > [ 'name ' = > 'new ' , 'label ' = > 'action .new ' , 'css _class ' = > 'btn btn -primary ' ] , 'search ' = > [ 'name ' = > 'search ' , 'label ' = > 'action .search ' ] , 'show ' = > [ 'name ' = > 'show ' , 'label ' = > 'action .show ' ] , 'list ' = > [ 'name ' = > 'list ' , 'label ' = > 'action .list ' , 'css _class ' = > 'btn btn -link pr - 0 ' ] , ] ) ; 
private function get Default Actions ( $ view ) { $ default Actions = [ ] ; $ default Actions Config = $ this - > get Default Actions Config ( $ view ) ; 
public function handle Violations ( Form Event $ event ) { $ form Tabs = $ event - > get Form ( ) - > get Config ( ) - > get Attribute ( 'easyadmin _form _tabs ' ) ; $ first Tab With Errors = null ; foreach ( $ event - > get Form ( ) as $ child ) { $ errors = $ child - > get Errors ( true ) ; if ( \ count ( $ errors ) > 0 ) { $ form Tab = $ child - > get Config ( ) - > get Attribute ( 'easyadmin _form _tab ' ) ; $ form Tabs [ $ form Tab ] [ 'errors ' ] + = \ count ( $ errors ) ; if ( null = = = $ first Tab With Errors ) { $ first Tab With Errors = $ form Tab ; } } } 
public function collect ( Request $ request , Response $ response , \ Exception $ exception = null ) { if ( 'easyadmin ' ! = = $ request - > attributes - > get ( ' _route ' ) ) { return ; } $ backend Config = $ this - > config Manager - > get Backend Config ( ) ; $ entity Name = $ request - > query - > get ( 'entity ' ) ; $ current Entity Config = \ array _key _exists ( $ entity Name , $ backend Config [ 'entities ' ] ) ? $ backend Config [ 'entities ' ] [ $ entity Name ] : [ ] ; $ this - > data = [ 'num _entities ' = > \ count ( $ backend Config [ 'entities ' ] ) , 'request _parameters ' = > $ this - > get Easy Admin Parameters ( $ request ) , 'current _entity _configuration ' = > $ current Entity Config , 'backend _configuration ' = > $ backend Config , ] ; } 
private function get Easy Admin Parameters ( Request $ request ) { return [ 'action ' = > $ request - > query - > get ( 'action ' ) , 'entity ' = > $ request - > query - > get ( 'entity ' ) , 'id ' = > $ request - > query - > get ( 'id ' ) , 'sort _field ' = > $ request - > query - > get ( 'sort Field ' ) , 'sort _direction ' = > $ request - > query - > get ( 'sort Direction ' ) , ] ; } 
public function dump ( $ variable ) { if ( \ class _exists ( Html Dumper : : class ) ) { $ cloner = new Var Cloner ( ) ; $ dumper = new Html Dumper ( ) ; $ dumper - > dump ( $ cloner - > clone Var ( $ variable ) , $ output = \ fopen ( 'php : / /memory ' , 'r +b ' ) ) ; if ( false ! = = $ dumped Data = \ stream _get _contents ( $ output , - 1 , 0 ) ) { return $ dumped Data ; } } if ( \ class _exists ( Yaml : : class ) ) { return \ sprintf ( ' <pre class = "sf -dump " > %s < /pre > ' , Yaml : : dump ( ( array ) $ variable , 1 0 2 4 ) ) ; } return \ sprintf ( ' <pre class = "sf -dump " > %s < /pre > ' , \ var _export ( $ variable , true ) ) ; } 
public function find ( $ entity , $ query , $ page = 1 ) { if ( empty ( $ entity ) | | empty ( $ query ) ) { return [ 'results ' = > [ ] ] ; } $ backend Config = $ this - > config Manager - > get Backend Config ( ) ; if ( ! isset ( $ backend Config [ 'entities ' ] [ $ entity ] ) ) { throw new \ Invalid Argument Exception ( \ sprintf ( 'The "entity " argument must contain the name of an entity managed by Easy Admin ( " %s " given ) . ' , $ entity ) ) ; } $ paginator = $ this - > finder - > find By All Properties ( $ backend Config [ 'entities ' ] [ $ entity ] , $ query , $ page , $ backend Config [ 'show ' ] [ 'max _results ' ] ) ; return [ 'results ' = > $ this - > process Results ( $ paginator - > get Current Page Results ( ) , $ backend Config [ 'entities ' ] [ $ entity ] ) , 'has _next _page ' = > $ paginator - > has Next Page ( ) , ] ; } 
public function load ( array $ configs , Container Builder $ container ) { 
private function process Config Files ( array $ configs ) { $ existing Entity Names = [ ] ; foreach ( $ configs as $ i = > $ config ) { if ( \ array _key _exists ( 'entities ' , $ config ) ) { $ processed Config = [ ] ; foreach ( $ config [ 'entities ' ] as $ key = > $ value ) { $ entity Config = $ this - > normalize Entity Config ( $ key , $ value ) ; $ entity Name = $ this - > get Unique Entity Name ( $ key , $ entity Config , $ existing Entity Names ) ; $ entity Config [ 'name ' ] = $ entity Name ; $ processed Config [ $ entity Name ] = $ entity Config ; $ existing Entity Names [ ] = $ entity Name ; } $ config [ 'entities ' ] = $ processed Config ; } $ configs [ $ i ] = $ config ; } return $ configs ; } 
private function normalize Entity Config ( $ entity Name , $ entity Config ) { 
private function get Unique Entity Name ( $ entity Name , array $ entity Config , array $ existing Entity Names ) { 
private function normalize Entity Config ( array $ backend Config ) { foreach ( $ backend Config [ 'entities ' ] as $ entity Name = > $ entity Config ) { if ( ! isset ( $ entity Config [ 'label ' ] ) ) { $ backend Config [ 'entities ' ] [ $ entity Name ] [ 'label ' ] = $ entity Name ; } } return $ backend Config ; } 
private function normalize Form Config ( array $ backend Config ) { foreach ( $ backend Config [ 'entities ' ] as $ entity Name = > $ entity Config ) { if ( isset ( $ entity Config [ 'form ' ] ) ) { $ entity Config [ 'new ' ] = isset ( $ entity Config [ 'new ' ] ) ? $ this - > merge Form Config ( $ entity Config [ 'form ' ] , $ entity Config [ 'new ' ] ) : $ entity Config [ 'form ' ] ; $ entity Config [ 'edit ' ] = isset ( $ entity Config [ 'edit ' ] ) ? $ this - > merge Form Config ( $ entity Config [ 'form ' ] , $ entity Config [ 'edit ' ] ) : $ entity Config [ 'form ' ] ; } $ backend Config [ 'entities ' ] [ $ entity Name ] = $ entity Config ; } return $ backend Config ; } 
private function normalize View Config ( array $ backend Config ) { foreach ( $ backend Config [ 'entities ' ] as $ entity Name = > $ entity Config ) { 
private function normalize Property Config ( array $ backend Config ) { foreach ( $ backend Config [ 'entities ' ] as $ entity Name = > $ entity Config ) { $ design Element Index = 0 ; foreach ( [ 'form ' , 'edit ' , 'list ' , 'new ' , 'search ' , 'show ' ] as $ view ) { $ fields = [ ] ; foreach ( $ entity Config [ $ view ] [ 'fields ' ] as $ i = > $ field ) { if ( ! \ is _string ( $ field ) & & ! \ is _array ( $ field ) ) { throw new \ Runtime Exception ( \ sprintf ( 'The values of the "fields " option for the " %s " view of the " %s " entity can only be strings or arrays . ' , $ view , $ entity Config [ 'class ' ] ) ) ; } if ( \ is _string ( $ field ) ) { 
private function normalize Form Design Config ( array $ backend Config ) { 
private function normalize Controller Config ( array $ backend Config ) { foreach ( $ backend Config [ 'entities ' ] as $ entity Name = > $ entity Config ) { if ( isset ( $ entity Config [ 'controller ' ] ) ) { $ controller = \ trim ( $ entity Config [ 'controller ' ] ) ; if ( ! $ this - > container - > has ( $ controller ) & & ! \ class _exists ( $ controller ) ) { throw new \ Invalid Argument Exception ( \ sprintf ( 'The " %s " value defined in the "controller " option of the " %s " entity is not a valid controller . For a regular controller , set its FQCN as the value ; for a controller defined as service , set its service name as the value . ' , $ controller , $ entity Name ) ) ; } $ backend Config [ 'entities ' ] [ $ entity Name ] [ 'controller ' ] = $ controller ; } } return $ backend Config ; } 
private function merge Form Config ( array $ parent Config , array $ child Config ) { 
private function get Removed Field Names ( array $ fields Config ) { $ removed Field Names = [ ] ; foreach ( $ fields Config as $ field Config ) { if ( isset ( $ field Config [ 'property ' ] ) & & 0 = = = \ strpos ( $ field Config [ 'property ' ] , ' - ' ) ) { $ removed Field Names [ ] = \ mb _substr ( $ field Config [ 'property ' ] , 1 ) ; } } return $ removed Field Names ; } 
public function create List Query Builder ( array $ entity Config , $ sort Field = null , $ sort Direction = null , $ dql Filter = null ) { $ em = $ this - > doctrine - > get Manager For Class ( $ entity Config [ 'class ' ] ) ; $ class Metadata = $ em - > get Class Metadata ( $ entity Config [ 'class ' ] ) ; $ query Builder = $ em - > create Query Builder ( ) - > select ( 'entity ' ) - > from ( $ entity Config [ 'class ' ] , 'entity ' ) ; $ is Sorted By Doctrine Association = $ this - > is Doctrine Association ( $ class Metadata , $ sort Field ) ; if ( $ is Sorted By Doctrine Association ) { $ sort Field Parts = \ explode ( ' . ' , $ sort Field ) ; $ query Builder - > left Join ( 'entity . ' . $ sort Field Parts [ 0 ] , $ sort Field Parts [ 0 ] ) ; } if ( ! empty ( $ dql Filter ) ) { $ query Builder - > and Where ( $ dql Filter ) ; } if ( null ! = = $ sort Field ) { $ query Builder - > order By ( \ sprintf ( ' %s %s ' , $ is Sorted By Doctrine Association ? ' ' : 'entity . ' , $ sort Field ) , $ sort Direction ) ; } return $ query Builder ; } 
public function create Search Query Builder ( array $ entity Config , $ search Query , $ sort Field = null , $ sort Direction = null , $ dql Filter = null ) { $ em = $ this - > doctrine - > get Manager For Class ( $ entity Config [ 'class ' ] ) ; $ class Metadata = $ em - > get Class Metadata ( $ entity Config [ 'class ' ] ) ; $ query Builder = $ em - > create Query Builder ( ) - > select ( 'entity ' ) - > from ( $ entity Config [ 'class ' ] , 'entity ' ) ; $ is Search Query Numeric = \ is _numeric ( $ search Query ) ; $ is Search Query Small Integer = \ ctype _digit ( $ search Query ) & & $ search Query > = - 3 2 7 6 8 & & $ search Query < = 3 2 7 6 7 ; $ is Search Query Integer = \ ctype _digit ( $ search Query ) & & $ search Query > = - 2 1 4 7 4 8 3 6 4 8 & & $ search Query < = 2 1 4 7 4 8 3 6 4 7 ; $ is Search Query Uuid = 1 = = = \ preg _match ( ' / ^ [ 0 - 9a -f ] { 8 } - [ 0 - 9a -f ] { 4 } - [ 1 - 5 ] [ 0 - 9a -f ] { 3 } - [ 8 9ab ] [ 0 - 9a -f ] { 3 } - [ 0 - 9a -f ] { 1 2 } $ /i ' , $ search Query ) ; $ lower Search Query = \ mb _strtolower ( $ search Query ) ; $ query Parameters = [ ] ; $ entities Already Joined = [ ] ; foreach ( $ entity Config [ 'search ' ] [ 'fields ' ] as $ field Name = > $ metadata ) { $ entity Name = 'entity ' ; if ( $ this - > is Doctrine Association ( $ class Metadata , $ field Name ) ) { 
protected function is Doctrine Association ( Class Metadata $ class Metadata , $ field Name ) { if ( null = = = $ field Name ) { return false ; } $ field Name Parts = \ explode ( ' . ' , $ field Name ) ; return false ! = = \ strpos ( $ field Name , ' . ' ) & & ! \ array _key _exists ( $ field Name Parts [ 0 ] , $ class Metadata - > embedded Classes ) ; } 
private function process Default Fields Config ( array $ backend Config ) { foreach ( $ backend Config [ 'entities ' ] as $ entity Name = > $ entity Config ) { foreach ( [ 'edit ' , 'list ' , 'new ' , 'search ' , 'show ' ] as $ view ) { if ( 0 = = = \ count ( $ entity Config [ $ view ] [ 'fields ' ] ) ) { $ fields Config = $ this - > filter Field List ( $ entity Config [ 'properties ' ] , $ this - > get Excluded Field Names ( $ view , $ entity Config ) , $ this - > get Excluded Field Types ( $ view ) , $ this - > get Max Number Fields ( $ view ) ) ; foreach ( $ fields Config as $ field Name = > $ field Config ) { if ( null = = = $ fields Config [ $ field Name ] [ 'format ' ] ) { $ fields Config [ $ field Name ] [ 'format ' ] = $ this - > get Field Format ( $ field Config [ 'type ' ] , $ backend Config ) ; } } $ backend Config [ 'entities ' ] [ $ entity Name ] [ $ view ] [ 'fields ' ] = $ fields Config ; } } } return $ backend Config ; } 
private function process Field Config ( array $ backend Config ) { foreach ( $ backend Config [ 'entities ' ] as $ entity Name = > $ entity Config ) { foreach ( [ 'edit ' , 'list ' , 'new ' , 'search ' , 'show ' ] as $ view ) { foreach ( $ entity Config [ $ view ] [ 'fields ' ] as $ field Name = > $ field Config ) { if ( ! isset ( $ field Config [ 'label ' ] ) & & 'id ' = = = $ field Config [ 'property ' ] ) { 
private function process Page Title Config ( array $ backend Config ) { foreach ( $ backend Config [ 'entities ' ] as $ entity Name = > $ entity Config ) { foreach ( [ 'edit ' , 'list ' , 'new ' , 'search ' , 'show ' ] as $ view ) { if ( ! isset ( $ entity Config [ $ view ] [ 'title ' ] ) & & isset ( $ backend Config [ $ view ] [ 'title ' ] ) ) { $ backend Config [ 'entities ' ] [ $ entity Name ] [ $ view ] [ 'title ' ] = $ backend Config [ $ view ] [ 'title ' ] ; } } } return $ backend Config ; } 
private function process Max Results Config ( array $ backend Config ) { foreach ( $ backend Config [ 'entities ' ] as $ entity Name = > $ entity Config ) { foreach ( [ 'list ' , 'search ' , 'show ' ] as $ view ) { if ( ! isset ( $ entity Config [ $ view ] [ 'max _results ' ] ) & & isset ( $ backend Config [ $ view ] [ 'max _results ' ] ) ) { $ backend Config [ 'entities ' ] [ $ entity Name ] [ $ view ] [ 'max _results ' ] = $ backend Config [ $ view ] [ 'max _results ' ] ; } } } return $ backend Config ; } 
private function process Sorting Config ( array $ backend Config ) { foreach ( $ backend Config [ 'entities ' ] as $ entity Name = > $ entity Config ) { foreach ( [ 'list ' , 'search ' ] as $ view ) { if ( ! isset ( $ entity Config [ $ view ] [ 'sort ' ] ) ) { continue ; } $ sort Config = $ entity Config [ $ view ] [ 'sort ' ] ; if ( ! \ is _string ( $ sort Config ) & & ! \ is _array ( $ sort Config ) ) { throw new \ Invalid Argument Exception ( \ sprintf ( 'The "sort " option of the " %s " view of the " %s " entity contains an invalid value (it can only be a string or an array ) . ' , $ view , $ entity Name ) ) ; } if ( \ is _string ( $ sort Config ) ) { $ sort Config = [ 'field ' = > $ sort Config , 'direction ' = > 'DESC ' ] ; } else { $ sort Config = [ 'field ' = > $ sort Config [ 0 ] , 'direction ' = > \ strtoupper ( $ sort Config [ 1 ] ) ] ; } if ( ! \ in _array ( $ sort Config [ 'direction ' ] , [ 'ASC ' , 'DESC ' ] ) ) { throw new \ Invalid Argument Exception ( \ sprintf ( 'If defined , the second value of the "sort " option of the " %s " view of the " %s " entity can only be "ASC " or "DESC " . ' , $ view , $ entity Name ) ) ; } $ is Sorted By Doctrine Association = false ! = = \ strpos ( $ sort Config [ 'field ' ] , ' . ' ) ; if ( ! $ is Sorted By Doctrine Association & & ( isset ( $ entity Config [ $ view ] [ 'fields ' ] [ $ sort Config [ 'field ' ] ] ) & & true = = = $ entity Config [ $ view ] [ 'fields ' ] [ $ sort Config [ 'field ' ] ] [ 'virtual ' ] ) ) { throw new \ Invalid Argument Exception ( \ sprintf ( 'The " %s " field cannot be used in the "sort " option of the " %s " view of the " %s " entity because it \ 's a virtual property that is not persisted in the database . ' , $ sort Config [ 'field ' ] , $ view , $ entity Name ) ) ; } / / sort can be defined using simple properties (sort : author ) or association properties (sort : author .name ) if ( \ substr _count ( $ sort Config [ 'field ' ] , ' . ' ) > 1 ) { throw new \ Invalid Argument Exception ( \ sprintf ( 'The " %s " value cannot be used as the "sort " option in the " %s " view of the " %s " entity because it defines multiple sorting levels (e .g . "aaa .bbb .ccc " ) but only up to one level is supported (e .g . "aaa .bbb " ) . ' , $ sort Config [ 'field ' ] , $ view , $ entity Name ) ) ; } / / sort field can be a Doctrine association (sort : author .name ) instead of a simple property $ sort Field Parts = \ explode ( ' . ' , $ sort Config [ 'field ' ] ) ; $ sort Field Property = $ sort Field Parts [ 0 ] ; if ( ! \ array _key _exists ( $ sort Field Property , $ entity Config [ 'properties ' ] ) & & ! isset ( $ entity Config [ $ view ] [ 'fields ' ] [ $ sort Field Property ] ) ) { throw new \ Invalid Argument Exception ( \ sprintf ( 'The " %s " field used in the "sort " option of the " %s " view of the " %s " entity does not exist neither as a property of that entity nor as a virtual field of that view . ' , $ sort Field Property , $ view , $ entity Name ) ) ; } $ backend Config [ 'entities ' ] [ $ entity Name ] [ $ view ] [ 'sort ' ] = $ sort Config ; } } return $ backend Config ; } 
private function get Excluded Field Names ( $ view , array $ entity Config ) { $ excluded Field Names = [ 'edit ' = > [ $ entity Config [ 'primary _key _field _name ' ] ] , 'list ' = > [ 'password ' , 'salt ' , 'slug ' , 'updated At ' , 'uuid ' ] , 'new ' = > [ $ entity Config [ 'primary _key _field _name ' ] ] , 'search ' = > [ 'password ' , 'salt ' ] , 'show ' = > [ ] , ] ; return isset ( $ excluded Field Names [ $ view ] ) ? $ excluded Field Names [ $ view ] : [ ] ; } 
private function filter Field List ( array $ fields , array $ excluded Field Names , array $ excluded Field Types , $ max Num Fields ) { $ filtered Fields = [ ] ; foreach ( $ fields as $ name = > $ metadata ) { if ( ! \ in _array ( $ name , $ excluded Field Names ) & & ! \ in _array ( $ metadata [ 'type ' ] , $ excluded Field Types ) ) { $ filtered Fields [ $ name ] = $ fields [ $ name ] ; } } if ( \ count ( $ filtered Fields ) > $ max Num Fields ) { $ filtered Fields = \ array _slice ( $ filtered Fields , 0 , $ max Num Fields , true ) ; } return $ filtered Fields ; } 
public function run ( array $ argv ) { $ command = count ( $ argv ) > = 2 ? $ argv [ 1 ] : false ; $ this - > setting Config ( $ argv ) ; $ this - > command Handler ( $ command ) ; } 
protected function setting Config ( array $ argv ) { 
protected function command Handler ( string $ command ) { $ server Command = new Server Command ( ) ; if ( ' -h ' = = $ command | | ' - -help ' = = $ command ) { echo $ server Command - > desc , PHP _EOL ; return ; } if ( ' -v ' = = $ command | | ' - -version ' = = $ command ) { echo $ server Command - > logo , PHP _EOL ; return ; } if ( ! $ command | | ! method _exists ( $ server Command , $ command ) ) { echo $ server Command - > usage , PHP _EOL ; return ; } Php Helper : : call ( [ $ server Command , $ command ] ) ; } 
public static function set Process Title ( string $ title ) : bool { if ( Php Helper : : is Mac ( ) ) { return false ; } if ( \ function _exists ( 'cli _set _process _title ' ) ) { return @ cli _set _process _title ( $ title ) ; } return true ; } 
public static function run ( string $ command , string $ cwd = null ) : array { $ descriptors = [ 0 = > [ 'pipe ' , 'r ' ] , 
private static function t Check ( string $ stmt , int $ offset ) { if ( strlen ( $ stmt ) > $ offset + 7 ) { $ c 1 = $ stmt [ + + $ offset ] ; $ c 2 = $ stmt [ + + $ offset ] ; $ c 3 = $ stmt [ + + $ offset ] ; $ c 4 = $ stmt [ + + $ offset ] ; $ c 5 = $ stmt [ + + $ offset ] ; $ c 6 = $ stmt [ + + $ offset ] ; $ c 7 = $ stmt [ + + $ offset ] ; $ c 8 = $ stmt [ + + $ offset ] ; if ( ( $ c 1 = = 'R ' | | $ c 1 = = 'r ' ) & & ( $ c 2 = = 'U ' | | $ c 2 = = 'u ' ) & & ( $ c 3 = = 'N ' | | $ c 3 = = 'n ' ) & & ( $ c 4 = = 'C ' | | $ c 4 = = 'c ' ) & & ( $ c 5 = = 'A ' | | $ c 5 = = 'a ' ) & & ( $ c 6 = = 'T ' | | $ c 6 = = 't ' ) & & ( $ c 7 = = 'E ' | | $ c 7 = = 'e ' ) & & ( $ c 8 = = ' ' | | $ c 8 = = ' \t ' | | $ c 8 = = ' \r ' | | $ c 8 = = ' \n ' ) ) { return self : : DDL ; } } return self : : OTHER ; } 
private static function a Check ( string $ stmt , int $ offset ) { if ( strlen ( $ stmt ) > $ offset + 4 ) { $ c 1 = $ stmt [ + + $ offset ] ; $ c 2 = $ stmt [ + + $ offset ] ; $ c 3 = $ stmt [ + + $ offset ] ; $ c 4 = $ stmt [ + + $ offset ] ; $ c 5 = $ stmt [ + + $ offset ] ; if ( ( $ c 1 = = 'L ' | | $ c 1 = = 'l ' ) & & ( $ c 2 = = 'T ' | | $ c 2 = = 't ' ) & & ( $ c 3 = = 'E ' | | $ c 3 = = 'e ' ) & & ( $ c 4 = = 'R ' | | $ c 4 = = 'r ' ) & & ( $ c 5 = = ' ' | | $ c 5 = = ' \t ' | | $ c 5 = = ' \r ' | | $ c 5 = = ' \n ' ) ) { return self : : DDL ; } } return self : : OTHER ; } 
public static function delete Ord Check ( string $ stmt , int $ offset ) { $ sql Type = self : : OTHER ; switch ( $ stmt [ $ offset + 1 ] ) { case 'E ' : case 'e ' : $ sql Type = self : : d Check ( $ stmt , $ offset ) ; break ; case 'R ' : case 'r ' : $ sql Type = self : : drop Check ( $ stmt , $ offset ) ; break ; default : $ sql Type = self : : OTHER ; } return $ sql Type ; } 
public static function help Check ( string $ stmt , int $ offset ) { if ( strlen ( $ stmt ) > $ offset + 3 ) { $ c 1 = $ stmt [ + + $ offset ] ; $ c 2 = $ stmt [ + + $ offset ] ; $ c 3 = $ stmt [ + + $ offset ] ; if ( ( $ c 1 = = 'E ' | | $ c 1 = = 'e ' ) & & ( $ c 2 = = 'L ' | | $ c 2 = = 'l ' ) & & ( $ c 3 = = 'P ' | | $ c 3 = = 'p ' ) ) { return ( $ offset < < 8 ) | self : : HELP ; } } return self : : OTHER ; } 
public static function explain Check ( string $ stmt , int $ offset ) { if ( strlen ( $ stmt ) > $ offset + 6 ) { $ c 1 = $ stmt [ + + $ offset ] ; $ c 2 = $ stmt [ + + $ offset ] ; $ c 3 = $ stmt [ + + $ offset ] ; $ c 4 = $ stmt [ + + $ offset ] ; $ c 5 = $ stmt [ + + $ offset ] ; $ c 6 = $ stmt [ + + $ offset ] ; $ c 7 = $ stmt [ + + $ offset ] ; if ( ( $ c 1 = = 'X ' | | $ c 1 = = 'x ' ) & & ( $ c 2 = = 'P ' | | $ c 2 = = 'p ' ) & & ( $ c 3 = = 'L ' | | $ c 3 = = 'l ' ) & & ( $ c 4 = = 'A ' | | $ c 4 = = 'a ' ) & & ( $ c 5 = = 'I ' | | $ c 5 = = 'i ' ) & & ( $ c 6 = = 'N ' | | $ c 6 = = 'n ' ) & & ( $ c 7 = = ' ' | | $ c 7 = = ' \t ' | | $ c 7 = = ' \r ' | | $ c 7 = = ' \n ' ) ) { return ( $ offset < < 8 ) | self : : EXPLAIN ; } } if ( $ stmt ! = null & & starts With ( strtolower ( $ stmt ) , "explain 2 " ) ) { return ( $ offset < < 8 ) | self : : EXPLAIN 2 ; } return self : : OTHER ; } 
public static function kill Check ( string $ stmt , int $ offset ) { if ( strlen ( $ stmt ) > $ offset + 3 ) { $ c 1 = $ stmt [ + + $ offset ] ; $ c 2 = $ stmt [ + + $ offset ] ; $ c 3 = $ stmt [ + + $ offset ] ; $ c 4 = $ stmt [ + + $ offset ] ; if ( ( $ c 1 = = 'I ' | | $ c 1 = = 'i ' ) & & ( $ c 2 = = 'L ' | | $ c 2 = = 'l ' ) & & ( $ c 3 = = 'L ' | | $ c 3 = = 'l ' ) & & ( $ c 4 = = ' ' | | $ c 4 = = ' \t ' | | $ c 4 = = ' \r ' | | $ c 4 = = ' \n ' ) ) { while ( strlen ( $ stmt ) > + + $ offset ) { switch ( $ stmt [ $ offset ] ) { case ' ' : case ' \t ' : case ' \r ' : case ' \n ' : continue 2 ; case 'Q ' : case 'q ' : return self : : kill Query Check ( $ stmt , $ offset ) ; default : return ( $ offset < < 8 ) | self : : KILL ; } } return self : : OTHER ; } } return self : : OTHER ; } 
public static function kill Query Check ( string $ stmt , int $ offset ) { if ( strlen ( $ stmt ) > $ offset + 4 ) { $ c 1 = $ stmt [ + + $ offset ] ; $ c 2 = $ stmt [ + + $ offset ] ; $ c 3 = $ stmt [ + + $ offset ] ; $ c 4 = $ stmt [ + + $ offset ] ; $ c 5 = $ stmt [ + + $ offset ] ; if ( ( $ c 1 = = 'U ' | | $ c 1 = = 'u ' ) & & ( $ c 2 = = 'E ' | | $ c 2 = = 'e ' ) & & ( $ c 3 = = 'R ' | | $ c 3 = = 'r ' ) & & ( $ c 4 = = 'Y ' | | $ c 4 = = 'y ' ) & & ( $ c 5 = = ' ' | | $ c 5 = = ' \t ' | | $ c 5 = = ' \r ' | | $ c 5 = = ' \n ' ) ) { while ( strlen ( $ stmt ) > + + $ offset ) { switch ( $ stmt [ $ offset ] ) { case ' ' : case ' \t ' : case ' \r ' : case ' \n ' : continue 2 ; default : return ( $ offset < < 8 ) | self : : KILL _QUERY ; } } return self : : OTHER ; } } return self : : OTHER ; } 
public static function begin Check ( string $ stmt , int $ offset ) { if ( strlen ( $ stmt ) > $ offset + 4 ) { $ c 1 = $ stmt [ + + $ offset ] ; $ c 2 = $ stmt [ + + $ offset ] ; $ c 3 = $ stmt [ + + $ offset ] ; $ c 4 = $ stmt [ + + $ offset ] ; if ( ( $ c 1 = = 'E ' | | $ c 1 = = 'e ' ) & & ( $ c 2 = = 'G ' | | $ c 2 = = 'g ' ) & & ( $ c 3 = = 'I ' | | $ c 3 = = 'i ' ) & & ( $ c 4 = = 'N ' | | $ c 4 = = 'n ' ) & & ( strlen ( $ stmt ) = = + + $ offset | | Parse Util : : is EOF ( $ stmt [ $ offset ] ) ) ) { return self : : BEGIN ; } } return self : : OTHER ; } 
public static function commit Check ( string $ stmt , int $ offset ) { if ( strlen ( $ stmt ) > $ offset + 5 ) { $ c 1 = $ stmt [ + + $ offset ] ; $ c 2 = $ stmt [ + + $ offset ] ; $ c 3 = $ stmt [ + + $ offset ] ; $ c 4 = $ stmt [ + + $ offset ] ; $ c 5 = $ stmt [ + + $ offset ] ; if ( ( $ c 1 = = 'O ' | | $ c 1 = = 'o ' ) & & ( $ c 2 = = 'M ' | | $ c 2 = = 'm ' ) & & ( $ c 3 = = 'M ' | | $ c 3 = = 'm ' ) & & ( $ c 4 = = 'I ' | | $ c 4 = = 'i ' ) & & ( $ c 5 = = 'T ' | | $ c 5 = = 't ' ) & & ( strlen ( $ stmt ) = = + + $ offset | | Parse Util : : is EOF ( $ stmt [ $ offset ] ) ) ) { return self : : COMMIT ; } } return self : : OTHER ; } 
public static function call Check ( string $ stmt , int $ offset ) { if ( strlen ( $ stmt ) > $ offset + 3 ) { $ c 1 = $ stmt [ + + $ offset ] ; $ c 2 = $ stmt [ + + $ offset ] ; $ c 3 = $ stmt [ + + $ offset ] ; if ( ( $ c 1 = = 'A ' | | $ c 1 = = 'a ' ) & & ( $ c 2 = = 'L ' | | $ c 2 = = 'l ' ) & & ( $ c 3 = = 'L ' | | $ c 3 = = 'l ' ) ) { return self : : CALL ; } } return self : : OTHER ; } 
public static function d Check ( string $ stmt , int $ offset ) { if ( strlen ( $ stmt ) > $ offset + 4 ) { $ res = self : : describe Check ( $ stmt , $ offset ) ; if ( $ res = = self : : DESCRIBE ) { return $ res ; } } 
public static function describe Check ( string $ stmt , int $ offset ) { 
public static function insert Check ( string $ stmt , int $ offset ) { if ( strlen ( $ stmt ) > $ offset + 6 ) { $ c 1 = $ stmt [ + + $ offset ] ; $ c 2 = $ stmt [ + + $ offset ] ; $ c 3 = $ stmt [ + + $ offset ] ; $ c 4 = $ stmt [ + + $ offset ] ; $ c 5 = $ stmt [ + + $ offset ] ; $ c 6 = $ stmt [ + + $ offset ] ; if ( ( $ c 1 = = 'N ' | | $ c 1 = = 'n ' ) & & ( $ c 2 = = 'S ' | | $ c 2 = = 's ' ) & & ( $ c 3 = = 'E ' | | $ c 3 = = 'e ' ) & & ( $ c 4 = = 'R ' | | $ c 4 = = 'r ' ) & & ( $ c 5 = = 'T ' | | $ c 5 = = 't ' ) & & ( $ c 6 = = ' ' | | $ c 6 = = ' \t ' | | $ c 6 = = ' \r ' | | $ c 6 = = ' \n ' ) ) { return self : : INSERT ; } } return self : : OTHER ; } 
public static function replace Check ( string $ stmt , int $ offset ) { if ( strlen ( $ stmt ) > $ offset + 6 ) { $ c 1 = $ stmt [ + + $ offset ] ; $ c 2 = $ stmt [ + + $ offset ] ; $ c 3 = $ stmt [ + + $ offset ] ; $ c 4 = $ stmt [ + + $ offset ] ; $ c 5 = $ stmt [ + + $ offset ] ; $ c 6 = $ stmt [ + + $ offset ] ; if ( ( $ c 1 = = 'P ' | | $ c 1 = = 'p ' ) & & ( $ c 2 = = 'L ' | | $ c 2 = = 'l ' ) & & ( $ c 3 = = 'A ' | | $ c 3 = = 'a ' ) & & ( $ c 4 = = 'C ' | | $ c 4 = = 'c ' ) & & ( $ c 5 = = 'E ' | | $ c 5 = = 'e ' ) & & ( $ c 6 = = ' ' | | $ c 6 = = ' \t ' | | $ c 6 = = ' \r ' | | $ c 6 = = ' \n ' ) ) { return self : : REPLACE ; } } return self : : OTHER ; } 
public static function rollabck Check ( string $ stmt , int $ offset ) { if ( strlen ( $ stmt ) > $ offset + 6 ) { $ c 1 = $ stmt [ + + $ offset ] ; $ c 2 = $ stmt [ + + $ offset ] ; $ c 3 = $ stmt [ + + $ offset ] ; $ c 4 = $ stmt [ + + $ offset ] ; $ c 5 = $ stmt [ + + $ offset ] ; $ c 6 = $ stmt [ + + $ offset ] ; if ( ( $ c 1 = = 'L ' | | $ c 1 = = 'l ' ) & & ( $ c 2 = = 'L ' | | $ c 2 = = 'l ' ) & & ( $ c 3 = = 'B ' | | $ c 3 = = 'b ' ) & & ( $ c 4 = = 'A ' | | $ c 4 = = 'a ' ) & & ( $ c 5 = = 'C ' | | $ c 5 = = 'c ' ) & & ( $ c 6 = = 'K ' | | $ c 6 = = 'k ' ) & & ( strlen ( $ stmt ) = = + + $ offset | | Parse Util : : is EOF ( $ stmt [ $ offset ] ) ) ) { return self : : ROLLBACK ; } } return self : : OTHER ; } 
public static function savepoint Check ( string $ stmt , int $ offset ) { if ( strlen ( $ stmt ) > $ offset + 8 ) { $ c 1 = $ stmt [ + + $ offset ] ; $ c 2 = $ stmt [ + + $ offset ] ; $ c 3 = $ stmt [ + + $ offset ] ; $ c 4 = $ stmt [ + + $ offset ] ; $ c 5 = $ stmt [ + + $ offset ] ; $ c 6 = $ stmt [ + + $ offset ] ; $ c 7 = $ stmt [ + + $ offset ] ; $ c 8 = $ stmt [ + + $ offset ] ; if ( ( $ c 1 = = 'V ' | | $ c 1 = = 'v ' ) & & ( $ c 2 = = 'E ' | | $ c 2 = = 'e ' ) & & ( $ c 3 = = 'P ' | | $ c 3 = = 'p ' ) & & ( $ c 4 = = 'O ' | | $ c 4 = = 'o ' ) & & ( $ c 5 = = 'I ' | | $ c 5 = = 'i ' ) & & ( $ c 6 = = 'N ' | | $ c 6 = = 'n ' ) & & ( $ c 7 = = 'T ' | | $ c 7 = = 't ' ) & & ( $ c 8 = = ' ' | | $ c 8 = = ' \t ' | | $ c 8 = = ' \r ' | | $ c 8 = = ' \n ' ) ) { return self : : SAVEPOINT ; } } return self : : OTHER ; } 
public static function select Check ( string $ stmt , int $ offset ) { if ( strlen ( $ stmt ) > $ offset + 4 ) { $ c 1 = $ stmt [ + + $ offset ] ; $ c 2 = $ stmt [ + + $ offset ] ; $ c 3 = $ stmt [ + + $ offset ] ; $ c 4 = $ stmt [ + + $ offset ] ; if ( ( $ c 1 = = 'E ' | | $ c 1 = = 'e ' ) & & ( $ c 2 = = 'C ' | | $ c 2 = = 'c ' ) & & ( $ c 3 = = 'T ' | | $ c 3 = = 't ' ) & & ( $ c 4 = = ' ' | | $ c 4 = = ' \t ' | | $ c 4 = = ' \r ' | | $ c 4 = = ' \n ' | | $ c 4 = = ' / ' | | $ c 4 = = ' # ' ) ) { return ( $ offset < < 8 ) | self : : SELECT ; } } return self : : OTHER ; } 
public static function show Check ( string $ stmt , int $ offset ) { if ( strlen ( $ stmt ) > $ offset + 3 ) { $ c 1 = $ stmt [ + + $ offset ] ; $ c 2 = $ stmt [ + + $ offset ] ; $ c 3 = $ stmt [ + + $ offset ] ; if ( ( $ c 1 = = 'O ' | | $ c 1 = = 'o ' ) & & ( $ c 2 = = 'W ' | | $ c 2 = = 'w ' ) & & ( $ c 3 = = ' ' | | $ c 3 = = ' \t ' | | $ c 3 = = ' \r ' | | $ c 3 = = ' \n ' ) ) { return ( $ offset < < 8 ) | self : : SHOW ; } } return self : : OTHER ; } 
public static function start Check ( string $ stmt , int $ offset ) { if ( strlen ( $ stmt ) > $ offset + 4 ) { $ c 1 = $ stmt [ + + $ offset ] ; $ c 2 = $ stmt [ + + $ offset ] ; $ c 3 = $ stmt [ + + $ offset ] ; $ c 4 = $ stmt [ + + $ offset ] ; if ( ( $ c 1 = = 'A ' | | $ c 1 = = 'a ' ) & & ( $ c 2 = = 'R ' | | $ c 2 = = 'r ' ) & & ( $ c 3 = = 'T ' | | $ c 3 = = 't ' ) & & ( $ c 4 = = ' ' | | $ c 4 = = ' \t ' | | $ c 4 = = ' \r ' | | $ c 4 = = ' \n ' ) ) { return ( $ offset < < 8 ) | self : : START ; } } return self : : OTHER ; } 
public static function u Check ( string $ stmt , int $ offset , bool $ has _Space = true ) { if ( strlen ( $ stmt ) > + + $ offset ) { switch ( $ stmt [ $ offset ] ) { case 'P ' : case 'p ' : if ( strlen ( $ stmt ) > $ offset + 5 ) { $ c 1 = $ stmt [ + + $ offset ] ; $ c 2 = $ stmt [ + + $ offset ] ; $ c 3 = $ stmt [ + + $ offset ] ; $ c 4 = $ stmt [ + + $ offset ] ; $ c 5 = $ stmt [ + + $ offset ] ; if ( ( $ c 1 = = 'D ' | | $ c 1 = = 'd ' ) & & ( $ c 2 = = 'A ' | | $ c 2 = = 'a ' ) & & ( $ c 3 = = 'T ' | | $ c 3 = = 't ' ) & & ( $ c 4 = = 'E ' | | $ c 4 = = 'e ' ) & & ( $ has _Space ? ( ' ' = = $ c 5 | | ' \t ' = = $ c 5 | | ' \r ' = = $ c 5 | | ' \n ' = = $ c 5 ) : true ) ) { return self : : UPDATE ; } } break ; case 'S ' : case 's ' : if ( strlen ( $ stmt ) > $ offset + 2 ) { $ c 1 = $ stmt [ + + $ offset ] ; $ c 2 = $ stmt [ + + $ offset ] ; if ( ( $ c 1 = = 'E ' | | $ c 1 = = 'e ' ) & & ( $ c 2 = = ' ' | | $ c 2 = = ' \t ' | | $ c 2 = = ' \r ' | | $ c 2 = = ' \n ' ) ) { return ( $ offset < < 8 ) | self : : USE ; } } break ; case 'N ' : case 'n ' : if ( strlen ( $ stmt ) > $ offset + 5 ) { $ c 1 = $ stmt [ + + $ offset ] ; $ c 2 = $ stmt [ + + $ offset ] ; $ c 3 = $ stmt [ + + $ offset ] ; $ c 4 = $ stmt [ + + $ offset ] ; $ c 5 = $ stmt [ + + $ offset ] ; if ( ( $ c 1 = = 'L ' | | $ c 1 = = 'l ' ) & & ( $ c 2 = = 'O ' | | $ c 2 = = 'o ' ) & & ( $ c 3 = = 'C ' | | $ c 3 = = 'c ' ) & & ( $ c 4 = = 'K ' | | $ c 4 = = 'k ' ) & & ( $ c 5 = = ' ' | | $ c 5 = = ' \t ' | | $ c 5 = = ' \r ' | | $ c 5 = = ' \n ' ) ) { return self : : UNLOCK ; } } break ; default : return self : : OTHER ; } } return self : : OTHER ; } 
public static function read Length ( array $ data ) { $ length = $ data [ 0 ] ; switch ( $ length ) { case 2 5 1 : return My SQLMessage : : $ NULL _LENGTH ; case 2 5 2 : return self : : read UB 2 ( $ data ) ; case 2 5 3 : return self : : read UB 3 ( $ data ) ; case 2 5 4 : return self : : read Long ( $ data ) ; default : return $ length ; } } 
public function decode ( string $ data ) { $ data = get Bytes ( $ data ) ; 
public function start ( ) { 
public function stop ( ) { if ( ! $ this - > is Running ( ) ) { smproxy _error ( 'ERROR : The server is not running ! cannot stop ! ' ) ; } echo 'SMProxy is stopping . . . ' , PHP _EOL ; $ result = function ( ) { 
public function reload ( ) { 
public function is Running ( ) { $ master Is Live = false ; $ p File = CONFIG [ 'server ' ] [ 'swoole ' ] [ 'pid _file ' ] ; 
public static function call ( $ cb , array $ args = [ ] ) { if ( version _compare ( SWOOLE _VERSION , ' 4 . 0 ' , ' > = ' ) ) { $ ret = call _user _func _array ( $ cb , $ args ) ; } else { $ ret = \ Swoole \ Coroutine : : call _user _func _array ( $ cb , $ args ) ; } return $ ret ; } 
public function query ( Binary Packet $ bin ) { 
public function connect ( string $ host , int $ port , float $ timeout = 0 . 1 , int $ try Step = 0 ) { $ this - > timeout = $ timeout ; if ( ! $ this - > client - > connect ( $ host , $ port , $ timeout ) ) { if ( $ try Step < 3 ) { $ this - > client - > close ( ) ; return $ this - > connect ( $ host , $ port , $ timeout , + + $ try Step ) ; } else { $ this - > on Client Error ( $ this - > client ) ; return false ; } } else { if ( ! $ this - > is Duplex ) { $ this - > mysql Client - > push ( $ this - > client ) ; } self : : go ( function ( ) { while ( true ) { $ data = $ this - > recv ( ) ; if ( $ data = = = ' ' ) { break ; } } } ) ; return $ this - > client ; } } 
public function on Client Receive ( \ Swoole \ Coroutine \ Client $ cli , string $ data ) { if ( $ this - > connected ) { $ packages = [ $ data ] ; } else { $ packages = package Split ( $ data , true , 3 , true ) ; } foreach ( $ packages as $ package ) { $ data = $ package ; self : : go ( function ( ) use ( $ cli , $ data ) { $ fd = $ this - > server Fd ; $ binary Packet = new Binary Packet ( ) ; $ binary Packet - > data = get Bytes ( $ data ) ; $ binary Packet - > packet Length = $ binary Packet - > calc Packet Size ( ) ; if ( isset ( $ binary Packet - > data [ 4 ] ) ) { $ send = true ; if ( $ binary Packet - > data [ 4 ] = = Error Packet : : $ FIELD _COUNT ) { $ error Packet = new Error Packet ( ) ; $ error Packet - > read ( $ binary Packet ) ; $ error Packet - > errno = Error Code : : ER _SYNTAX _ERROR ; $ data = get String ( $ error Packet - > write ( ) ) ; } elseif ( ! $ this - > connected ) { if ( $ binary Packet - > data [ 4 ] = = Ok Packet : : $ FIELD _COUNT ) { if ( ! array _diff _assoc ( $ binary Packet - > data , Ok Packet : : $ AUTH _OK ) | | ! array _diff _assoc ( $ binary Packet - > data , Ok Packet : : $ FAST _AUTH _OK ) | | ! array _diff _assoc ( $ binary Packet - > data , Ok Packet : : $ SWITCH _AUTH _OK ) | | ! array _diff _assoc ( $ binary Packet - > data , Ok Packet : : $ FULL _AUTH _OK ) ) { $ send = false ; $ this - > connected = true ; $ this - > chan - > push ( $ this ) ; } # 快 速 认 证 } elseif ( $ binary Packet - > data [ 4 ] = = 0x 0 1 ) { # 请 求 公 钥 if ( $ binary Packet - > packet Length = = 6 ) { if ( $ binary Packet - > data [ $ binary Packet - > packet Length - 1 ] = = 4 ) { $ data = get String ( array _merge ( get Mysql Pack Size ( 1 ) , [ 3 , 2 ] ) ) ; $ this - > send ( $ data ) ; } } else { $ this - > server Public Key = substr ( $ data , 5 , strlen ( $ data ) - 2 ) ; $ encrypt Data = Security Util : : sha 2Rsa Encrypt ( $ this - > account [ 'password ' ] , $ this - > salt , $ this - > server Public Key ) ; $ data = get String ( array _merge ( get Mysql Pack Size ( strlen ( $ encrypt Data ) ) , [ 5 ] ) ) . $ encrypt Data ; $ this - > send ( $ data ) ; } $ send = false ; } elseif ( $ binary Packet - > data [ 4 ] = = 0xfe ) { $ mm = new My SQLMessage ( $ binary Packet - > data ) ; $ mm - > move ( 5 ) ; $ plugin Name = $ mm - > read String With Null ( ) ; $ this - > salt = $ mm - > read Bytes With Null ( ) ; $ password = $ this - > process Auth ( $ plugin Name ? : 'mysql _native _password ' ) ; $ this - > send ( get String ( array _merge ( get Mysql Pack Size ( count ( $ password ) ) , [ 3 ] , $ password ) ) ) ; $ send = false ; } elseif ( ! $ this - > auth ) { $ handshake Packet = ( new Handshake Packet ( ) ) - > read ( $ binary Packet ) ; $ this - > salt = array _merge ( $ handshake Packet - > seed , $ handshake Packet - > rest Of Scramble Buff ) ; $ password = $ this - > process Auth ( $ handshake Packet - > plugin Name ) ; $ client Flag = Capabilities : : CLIENT _CAPABILITIES ; $ auth Packet = new Auth Packet ( ) ; $ auth Packet - > plugin Name = $ handshake Packet - > plugin Name ; $ auth Packet - > packet Id = 1 ; if ( isset ( $ this - > database ) & & $ this - > database ) { $ auth Packet - > database = $ this - > database ; } else { $ auth Packet - > database = 0 ; } if ( $ auth Packet - > database ) { $ client Flag | = Capabilities : : CLIENT _CONNECT _WITH _DB ; } if ( version _compare ( $ handshake Packet - > server Version , ' 5 . 0 ' , ' > = ' ) ) { $ client Flag | = Capabilities : : CLIENT _MULTI _RESULTS ; } $ auth Packet - > client Flags = $ client Flag ; $ auth Packet - > server Capabilities = $ handshake Packet - > server Capabilities ; $ auth Packet - > max Packet Size = CONFIG [ 'server ' ] [ 'swoole _client _setting ' ] [ 'package _max _length ' ] ? ? 1 6 7 7 7 2 1 5 ; $ auth Packet - > charset Index = Charset Util : : get Index ( $ this - > charset ? ? 'utf 8mb 4 ' ) ; $ auth Packet - > user = $ this - > account [ 'user ' ] ; $ auth Packet - > password = $ password ; $ this - > auth = true ; $ this - > send ( get String ( $ auth Packet - > write ( ) ) ) ; $ send = false ; } } if ( $ send & & $ this - > server - > exist ( $ fd ) ) { $ this - > server - > send ( $ fd , $ data ) ; } } } ) ; } } 
public function process Auth ( string $ plugin Name ) { switch ( $ plugin Name ) { case 'mysql _native _password ' : $ password = Security Util : : scramble 4 1 1 ( $ this - > account [ 'password ' ] , $ this - > salt ) ; break ; case 'caching _sha 2 _password ' : $ password = Security Util : : scramble Sha 2 5 6 ( $ this - > account [ 'password ' ] , $ this - > salt ) ; break ; case 'sha 2 5 6 _password ' : throw new My SQLException ( 'Sha 2 5 6 _password plugin is not supported yet ' ) ; break ; case 'mysql _old _password ' : throw new My SQLException ( 'mysql _old _password plugin is not supported yet ' ) ; break ; case 'mysql _clear _password ' : $ password = array _merge ( get Bytes ( $ this - > account [ 'password ' ] ) , [ 0 ] ) ; break ; default : $ password = Security Util : : scramble 4 1 1 ( $ this - > account [ 'password ' ] , $ this - > salt ) ; break ; } return $ password ; } 
public function send ( . . . $ data ) { if ( $ this - > is Duplex ) { if ( $ this - > client - > is Connected ( ) ) { return $ this - > client - > send ( . . . $ data ) ; } else { return false ; } } else { $ client = self : : co Pop ( $ this - > mysql Client ) ; if ( $ client = = = false ) { 
public function recv ( ) { if ( $ this - > is Duplex ) { $ data = $ this - > client - > recv ( - 1 ) ; if ( $ data = = = ' ' ) { $ this - > on Client Close ( $ this - > client ) ; } elseif ( is _string ( $ data ) ) { $ this - > on Client Receive ( $ this - > client , $ data ) ; } return $ data ; } else { $ client = self : : co Pop ( $ this - > mysql Client , $ this - > timeout ) ; if ( $ client = = = false ) { 
public function on Client Close ( \ Swoole \ Coroutine \ Client $ cli ) { My SQLPool : : destruct ( $ cli , $ this - > database ? ( $ this - > model . DB _DELIMITER . $ this - > database ) : $ this - > model ) ; } 
private static function parsestring 2 ( string $ stmt , int $ offset ) { $ sb = ' ' ; $ stmt Len = strlen ( $ stmt ) ; for ( + + $ offset ; $ offset < $ stmt Len ; + + $ offset ) { $ c = $ stmt = [ $ offset ] ; if ( ' \ \ ' = = $ c ) { switch ( $ c = $ stmt [ + + $ offset ] ) { case ' 0 ' : $ sb . = " \ 0 " ; break ; case 'b ' : $ sb . = " \b " ; break ; case 'n ' : $ sb . = " \n " ; break ; case 'r ' : $ sb . = " \r " ; break ; case 't ' : $ sb . = " \t " ; break ; case 'Z ' : $ sb . = chr ( 2 6 ) ; break ; default : $ sb . = $ c ; } } elseif ( ' " ' = = $ c ) { if ( $ offset + 1 < strlen ( $ stmt ) & & ' " ' = = $ stmt [ $ offset + 1 ] ) { + + $ offset ; $ sb . = ' " ' ; } else { break ; } } else { $ sb . = $ c ; } } return $ sb ; } 
private static function parse Identifier Escape ( string $ stmt , int $ offset ) { $ sb = ' ' ; for ( + + $ offset , $ stem Len = strlen ( $ stmt ) ; $ offset < $ stem Len ; + + $ offset ) { $ c = $ stmt [ $ offset ] ; if ( ' ` ' = = $ c ) { if ( $ offset + 1 < strlen ( $ stmt ) & & ' ` ' = = $ stmt [ $ offset + 1 ] ) { + + $ offset ; $ sb . = ' ` ' ; } else { break ; } } else { $ sb . = $ c ; } } return $ sb ; } 
public static function nextstring Is Expected With Ignore Sep Char ( string $ stmt , int $ offset , string $ next Expectedstring , bool $ check Sep Char ) { if ( null = = $ next Expectedstring | | strlen ( $ next Expectedstring ) < 1 ) { return $ offset ; } $ i = $ offset ; $ index = 0 ; for ( $ stmt Len = strlen ( $ stmt ) ; $ i < $ stmt Len & & $ index < strlen ( $ next Expectedstring ) ; + + $ i ) { if ( 0 = = $ index ) { $ is Sep = self : : current Char Is Sep ( $ stmt , $ i ) ; if ( $ is Sep ) { continue ; } } $ actual Char = $ stmt [ $ i ] ; $ expected Char = $ next Expectedstring [ $ index + + ] ; if ( $ actual Char ! = $ expected Char ) { return $ offset ; } } if ( $ index = = strlen ( $ next Expectedstring ) ) { $ ok = true ; if ( $ check Sep Char ) { $ ok = self : : next Char Is Sep ( $ stmt , $ i ) ; } if ( $ ok ) { return $ i ; } } return $ offset ; } 
public static function nextstring Is Json Eq ( string $ stmt , int $ offset ) { $ i = $ offset ; 
public function log ( $ level , $ message , array $ context = [ ] ) { if ( self : : $ open ) { if ( ! isset ( self : : $ levels [ $ level ] ) ) { throw new Invalid Argument Exception ( sprintf ( 'The log level " %s " does not exist . ' , $ level ) ) ; } if ( self : : $ levels [ $ level ] < $ this - > min Level Index ) { return ; } $ log _data = $ this - > format ( $ level , $ message , $ context ) ; 
public static function get Logger ( string $ tag = 'system ' ) { if ( ! is _array ( self : : $ CONFIG ) | | empty ( self : : $ CONFIG ) ) { self : : $ CONFIG = CONFIG [ 'server ' ] [ 'logs ' ] [ 'config ' ] ; self : : $ open = CONFIG [ 'server ' ] [ 'logs ' ] [ 'open ' ] ; } 
private function create Log Path ( string $ log _path ) { if ( ! file _exists ( $ log _path ) | | ! is _dir ( $ log _path ) ) { return mkdir ( $ log _path , 0 7 5 5 , true ) ; } return true ; } 
private function get Log File ( ) { 
private function co Write ( string $ log File , string $ message Text ) { go ( function ( ) use ( $ log File , $ message Text ) { $ res = Coroutine : : write File ( $ log File , $ message Text , FILE _APPEND ) ; if ( $ res = = = false ) { throw new \ Invalid Argument Exception ( "Unable to append to log file : { $this - >log File } " ) ; } } ) ; } 
private function sync Write ( string $ log File , string $ message Text ) { $ fp = fopen ( $ log File , 'a ' ) ; if ( $ fp = = = false ) { throw new \ Invalid Argument Exception ( "Unable to append to log file : { $this - >log File } " ) ; } flock ( $ fp , LOCK _EX ) ; fwrite ( $ fp , $ message Text ) ; flock ( $ fp , LOCK _UN ) ; fclose ( $ fp ) ; } 
public function on Connect ( \ swoole _server $ server , int $ fd ) { 
public function on Receive ( \ swoole _server $ server , int $ fd , int $ reactor _id , string $ data ) { self : : go ( function ( ) use ( $ server , $ fd , $ reactor _id , $ data ) { if ( ! isset ( $ this - > source [ $ fd ] - > auth ) ) { throw new SMProxy Exception ( 'Must be connected before sending data ! ' ) ; } if ( ! isset ( $ this - > half Pack [ $ fd ] ) ) { $ this - > half Pack [ $ fd ] = ' ' ; } if ( $ this - > source [ $ fd ] - > auth ) { $ header Length = 4 ; } else { $ header Length = 3 ; } $ packages = package Split ( $ data , $ this - > source [ $ fd ] - > auth ? : false , $ header Length , false , $ this - > half Pack [ $ fd ] ) ; foreach ( $ packages as $ package ) { $ data = $ package ; self : : go ( function ( ) use ( $ server , $ fd , $ reactor _id , $ data ) { $ bin = ( new My Sql Packet Decoder ( ) ) - > decode ( $ data ) ; if ( ! $ this - > source [ $ fd ] - > auth ) { $ this - > auth ( $ bin , $ server , $ fd ) ; } else { $ this - > query ( $ bin , $ data , $ fd ) ; if ( isset ( $ this - > connect Read State [ $ fd ] ) & & true = = = $ this - > connect Read State [ $ fd ] ) { $ model = 'read ' ; } else { $ model = 'write ' ; } $ key = $ this - > compare Model ( $ model , $ server , $ fd ) ; if ( $ data ) { if ( isset ( $ this - > mysql Client [ $ fd ] [ $ key ] ) ) { $ this - > mysql Client [ $ fd ] [ $ key ] - > send ( $ data ) ; } else { $ client = My SQLPool : : fetch ( $ key , $ server , $ fd ) ; $ result = $ client - > send ( $ data ) ; if ( $ result ) { $ this - > mysql Client [ $ fd ] [ $ key ] = $ client ; } } } 
public function on Close ( \ swoole _server $ server , int $ fd ) { if ( isset ( $ this - > source [ $ fd ] ) ) { unset ( $ this - > source [ $ fd ] ) ; } if ( isset ( $ this - > half Pack [ $ fd ] ) ) { unset ( $ this - > half Pack [ $ fd ] ) ; } $ connect Has Transaction = false ; $ connect Has Auto Commit = false ; if ( isset ( $ this - > connect Has Transaction [ $ fd ] ) & & true = = = $ this - > connect Has Transaction [ $ fd ] ) { 
public function on Worker Start ( \ swoole _server $ server , int $ worker _id ) { self : : go ( function ( ) use ( $ server , $ worker _id ) { if ( $ worker _id > = CONFIG [ 'server ' ] [ 'swoole ' ] [ 'worker _num ' ] ) { Process Helper : : set Process Title ( 'SMProxy task process ' ) ; } else { Process Helper : : set Process Title ( 'SMProxy worker process ' ) ; } try { $ this - > db Config = $ this - > parse Db Config ( init Config ( CONFIG _PATH ) ) ; 
private function set Start Conns ( ) { $ clients = [ ] ; foreach ( $ this - > db Config as $ key = > $ value ) { if ( count ( explode ( DB _DELIMITER , $ key ) ) < 2 ) { continue ; } 
private function check Account ( \ swoole _server $ server , int $ fd , string $ user , array $ password ) { $ check Password = $ this - > source [ $ fd ] - > check Password ( $ password , CONFIG [ 'server ' ] [ 'password ' ] ) ; return CONFIG [ 'server ' ] [ 'user ' ] = = $ user & & $ check Password ; } 
private function access Denied ( \ swoole _server $ server , int $ fd , int $ server Id ) { $ message = 'SMProxy @access denied for user \ ' ' . $ this - > source [ $ fd ] - > user . ' \ ' @ \ ' ' . $ server - > get Client Info ( $ fd ) [ 'remote _ip ' ] . ' \ ' (using password : YES ) ' ; $ err Message = self : : write Err Message ( $ server Id , $ message , Error Code : : ER _ACCESS _DENIED _ERROR , 2 8 0 0 0 ) ; if ( $ server - > exist ( $ fd ) ) { $ server - > send ( $ fd , get String ( $ err Message ) ) ; } throw new My SQLException ( $ message ) ; } 
private function compare Model ( string $ model , \ swoole _server $ server , int $ fd ) { $ splice Key = function ( int $ fd , string $ model ) { return $ this - > source [ $ fd ] - > database ? $ model . DB _DELIMITER . $ this - > source [ $ fd ] - > database : $ model ; } ; switch ( $ model ) { case 'read ' : $ key = $ splice Key ( $ fd , $ model ) ; 
private function exists DBKey ( \ swoole _server $ server , int $ fd , string $ model , string $ key ) { 
private function auth ( Binary Packet $ bin , \ swoole _server $ server , int $ fd ) { if ( $ bin - > data [ 0 ] = = 2 0 ) { $ check Account = $ this - > check Account ( $ server , $ fd , $ this - > source [ $ fd ] - > user , array _copy ( $ bin - > data , 4 , 2 0 ) ) ; if ( ! $ check Account ) { $ this - > access Denied ( $ server , $ fd , 4 ) ; } else { if ( $ server - > exist ( $ fd ) ) { $ server - > send ( $ fd , get String ( Ok Packet : : $ SWITCH _AUTH _OK ) ) ; } $ this - > source [ $ fd ] - > auth = true ; } } elseif ( $ bin - > data [ 4 ] = = 1 4 ) { if ( $ server - > exist ( $ fd ) ) { $ server - > send ( $ fd , get String ( Ok Packet : : $ OK ) ) ; } } else { $ auth Packet = new Auth Packet ( ) ; $ auth Packet - > read ( $ bin ) ; $ check Account = $ this - > check Account ( $ server , $ fd , $ auth Packet - > user ? ? ' ' , $ auth Packet - > password ? ? [ ] ) ; if ( ! $ check Account ) { if ( $ auth Packet - > plugin Name = = 'mysql _native _password ' ) { $ this - > access Denied ( $ server , $ fd , 2 ) ; } else { $ this - > source [ $ fd ] - > user = $ auth Packet - > user ; $ this - > source [ $ fd ] - > database = $ auth Packet - > database ; $ this - > source [ $ fd ] - > seed = Random Util : : random Bytes ( 2 0 ) ; $ auth Switch Request = array _merge ( [ 2 5 4 ] , get Bytes ( 'mysql _native _password ' ) , [ 0 ] , $ this - > source [ $ fd ] - > seed , [ 0 ] ) ; if ( $ server - > exist ( $ fd ) ) { $ server - > send ( $ fd , get String ( array _merge ( get Mysql Pack Size ( count ( $ auth Switch Request ) ) , [ 2 ] , $ auth Switch Request ) ) ) ; } } } else { if ( $ server - > exist ( $ fd ) ) { $ server - > send ( $ fd , get String ( Ok Packet : : $ AUTH _OK ) ) ; } $ this - > source [ $ fd ] - > auth = true ; $ this - > source [ $ fd ] - > database = $ auth Packet - > database ; } } } 
private function query ( Binary Packet $ bin , string & $ data , int $ fd ) { $ trim _data = rtrim ( $ data ) ; switch ( $ bin - > data [ 4 ] ) { case My SQLPacket : : $ COM _INIT _DB : 
public static function init ( array $ conns Config ) { if ( self : : $ init ) { return ; } self : : $ conns Config = $ conns Config ; foreach ( $ conns Config as $ name = > $ config ) { self : : $ spare Conns [ $ name ] = [ ] ; self : : $ busy Conns [ $ name ] = [ ] ; self : : $ pending Fetch Count [ $ name ] = 0 ; self : : $ resume Fetch Count [ $ name ] = 0 ; self : : $ init Conn Count [ $ name ] = 0 ; if ( $ config [ 'max Spare Conns ' ] < = 0 | | $ config [ 'max Conns ' ] < = 0 ) { throw new My SQLException ( "Invalid max Spare Conns or max Conns in { $name } " ) ; } } self : : $ init = true ; } 
public static function recycle ( Mysql Proxy $ conn , bool $ busy = true ) { self : : go ( function ( ) use ( $ conn , $ busy ) { if ( ! self : : $ init ) { throw new My SQLException ( 'Should call My SQLPool : :init . ' ) ; } $ id = spl _object _hash ( $ conn ) ; $ conn Name = self : : $ conns Name Map [ $ id ] ; if ( $ busy ) { if ( isset ( self : : $ busy Conns [ $ conn Name ] [ $ id ] ) ) { unset ( self : : $ busy Conns [ $ conn Name ] [ $ id ] ) ; } else { throw new My SQLException ( 'Unknow My SQL connection . ' ) ; } } $ conns Pool = & self : : $ spare Conns [ $ conn Name ] ; if ( ( ( count ( $ conns Pool ) + self : : $ init Conn Count [ $ conn Name ] ) > = self : : $ conns Config [ $ conn Name ] [ 'max Spare Conns ' ] ) & & ( ( microtime ( true ) - self : : $ last Conns Time [ $ id ] ) > = ( ( self : : $ conns Config [ $ conn Name ] [ 'max Spare Exp ' ] ) ? ? 0 ) ) ) { if ( $ conn - > client - > is Connected ( ) ) { $ conn - > client - > close ( ) ; } unset ( self : : $ conns Name Map [ $ id ] ) ; } else { if ( ! $ conn - > client - > is Connected ( ) ) { unset ( self : : $ conns Name Map [ $ id ] ) ; $ conn = self : : init Conn ( $ conn - > server , $ conn - > server Fd , $ conn Name ) ; $ id = spl _object _hash ( $ conn ) ; } $ conns Pool [ ] = $ conn ; if ( self : : $ pending Fetch Count [ $ conn Name ] > 0 ) { + + self : : $ resume Fetch Count [ $ conn Name ] ; self : : $ yield Channel [ $ conn Name ] - > push ( $ id ) ; } } } ) ; } 
public static function fetch ( string $ conn Name , \ swoole _server $ server , int $ fd ) { if ( ! self : : $ init ) { throw new My SQLException ( 'Should call My SQLPool : :init ! ' ) ; } if ( ! isset ( self : : $ conns Config [ $ conn Name ] ) ) { throw new My SQLException ( "Unvalid conn Name : { $conn Name } . " ) ; } $ conns Pool = & self : : $ spare Conns [ $ conn Name ] ; if ( ! empty ( $ conns Pool ) & & count ( $ conns Pool ) > self : : $ resume Fetch Count [ $ conn Name ] ) { $ conn = array _pop ( $ conns Pool ) ; if ( ! $ conn - > client - > is Connected ( ) ) { return self : : reconnect ( $ server , $ fd , $ conn , $ conn Name ) ; } else { $ conn - > server Fd = $ fd ; $ id = spl _object _hash ( $ conn ) ; self : : $ busy Conns [ $ conn Name ] [ $ id ] = $ conn ; self : : $ last Conns Time [ $ id ] = microtime ( true ) ; return $ conn ; } } if ( ( count ( self : : $ busy Conns [ $ conn Name ] ) + count ( $ conns Pool ) + self : : $ pending Fetch Count [ $ conn Name ] + self : : $ init Conn Count [ $ conn Name ] ) > = self : : $ conns Config [ $ conn Name ] [ 'max Conns ' ] ) { if ( ! isset ( self : : $ yield Channel [ $ conn Name ] ) ) { self : : $ yield Channel [ $ conn Name ] = new \ Swoole \ Coroutine \ Channel ( 1 ) ; } + + self : : $ pending Fetch Count [ $ conn Name ] ; $ client = self : : co Pop ( self : : $ yield Channel [ $ conn Name ] , self : : $ conns Config [ $ conn Name ] [ 'server Info ' ] [ 'timeout ' ] ) ; if ( false = = = $ client ) { - - self : : $ pending Fetch Count [ $ conn Name ] ; $ message = 'SMProxy @Reach max connections ! Cann \ 't pending fetch ! ' ; $ err Message = self : : write Err Message ( 1 , $ message , Error Code : : ER _HAS _GONE _AWAY ) ; if ( $ server - > exist ( $ fd ) ) { $ server - > send ( $ fd , get String ( $ err Message ) ) ; } throw new My SQLException ( $ message ) ; } - - self : : $ resume Fetch Count [ $ conn Name ] ; if ( ! empty ( $ conns Pool ) ) { $ conn = array _pop ( $ conns Pool ) ; if ( ! $ conn - > client - > is Connected ( ) ) { $ conn = self : : reconnect ( $ server , $ fd , $ conn , $ conn Name ) ; - - self : : $ pending Fetch Count [ $ conn Name ] ; return $ conn ; } else { $ conn - > server Fd = $ fd ; $ id = spl _object _hash ( $ conn ) ; self : : $ busy Conns [ $ conn Name ] [ $ id ] = $ conn ; self : : $ last Conns Time [ $ id ] = microtime ( true ) ; - - self : : $ pending Fetch Count [ $ conn Name ] ; return $ conn ; } } else { return false ; 
public static function init Conn ( \ swoole _server $ server , int $ fd , string $ conn Name , $ try Step = 0 ) { + + self : : $ init Conn Count [ $ conn Name ] ; $ chan = new \ Swoole \ Coroutine \ Channel ( 1 ) ; $ conn = new Mysql Proxy ( $ server , $ fd , $ chan ) ; $ server Info = self : : $ conns Config [ $ conn Name ] [ 'server Info ' ] ; if ( false = = strpos ( $ conn Name , DB _DELIMITER ) ) { $ conn - > database = 0 ; $ conn - > model = $ conn Name ; } else { $ conn - > database = substr ( $ conn Name , strpos ( $ conn Name , DB _DELIMITER ) + strlen ( DB _DELIMITER ) ) ; $ conn - > model = substr ( $ conn Name , 0 , strpos ( $ conn Name , DB _DELIMITER ) ) ; } $ conn - > account = $ server Info [ 'account ' ] ; $ conn - > charset = self : : $ conns Config [ $ conn Name ] [ 'charset ' ] ; if ( false = = $ conn - > connect ( $ server Info [ 'host ' ] , $ server Info [ 'port ' ] , $ server Info [ 'timeout ' ] ? ? 0 . 1 ) ) { - - self : : $ init Conn Count [ $ conn Name ] ; $ message = 'SMProxy @My SQL server has gone away ' ; $ err Message = self : : write Err Message ( 1 , $ message , Error Code : : ER _HAS _GONE _AWAY ) ; if ( $ server - > exist ( $ fd ) ) { $ server - > send ( $ fd , get String ( $ err Message ) ) ; } throw new My SQLException ( $ message ) ; } $ client = self : : co Pop ( $ chan , $ server Info [ 'timeout ' ] * 3 ) ; if ( $ client = = = false ) { - - self : : $ init Conn Count [ $ conn Name ] ; if ( $ try Step < 3 ) { return self : : init Conn ( $ server , $ fd , $ conn Name , + + $ try Step ) ; } else { $ message = 'SMProxy @Connection ' . $ server Info [ 'host ' ] . ' : ' . $ server Info [ 'port ' ] . ' waiting timeout , timeout = ' . $ server Info [ 'timeout ' ] ; $ err Message = self : : write Err Message ( 1 , $ message , Error Code : : ER _HAS _GONE _AWAY ) ; if ( $ server - > exist ( $ fd ) ) { $ server - > send ( $ fd , get String ( $ err Message ) ) ; } throw new My SQLException ( $ message ) ; } } $ id = spl _object _hash ( $ client ) ; self : : $ conns Name Map [ $ id ] = $ conn Name ; self : : $ busy Conns [ $ conn Name ] [ $ id ] = $ client ; self : : $ last Conns Time [ $ id ] = microtime ( true ) ; - - self : : $ init Conn Count [ $ conn Name ] ; return $ client ; } 
public static function destruct ( Client $ cli , string $ conn Name ) { self : : go ( function ( ) use ( $ cli , $ conn Name ) { if ( $ cli - > is Connected ( ) ) { $ cli - > close ( ) ; } $ proxy Conn = false ; foreach ( self : : $ spare Conns [ $ conn Name ] as $ key = > $ conn ) { if ( spl _object _hash ( $ conn - > client ) = = spl _object _hash ( $ cli ) ) { $ proxy Conn = $ conn ; unset ( self : : $ spare Conns [ $ conn Name ] [ $ key ] ) ; break ; } } if ( $ proxy Conn ) { self : : recycle ( $ proxy Conn , false ) ; } } ) ; } 
public static function reconnect ( \ swoole _server $ server , int $ fd , Mysql Proxy $ conn , string $ conn Name ) { if ( $ conn - > client - > is Connected ( ) ) { $ conn - > client - > close ( ) ; } $ old _id = spl _object _hash ( $ conn ) ; unset ( self : : $ busy Conns [ $ conn Name ] [ $ old _id ] ) ; unset ( self : : $ conns Name Map [ $ old _id ] ) ; self : : $ last Conns Time [ $ old _id ] = 0 ; return self : : init Conn ( $ server , $ fd , $ conn Name ) ; } 
protected static function go ( \ Closure $ function ) { if ( - 1 ! = = \ Swoole \ Coroutine : : getuid ( ) ) { $ pool = self : : $ pool [ \ Swoole \ Coroutine : : getuid ( ) ] ? ? false ; } else { $ pool = false ; } go ( function ( ) use ( $ function , $ pool ) { try { if ( $ pool ) { self : : $ pool [ \ Swoole \ Coroutine : : getuid ( ) ] = $ pool ; } $ function ( ) ; if ( $ pool ) { unset ( self : : $ pool [ \ Swoole \ Coroutine : : getuid ( ) ] ) ; } } catch ( SMProxy Exception $ SMProxy Exception ) { self : : write Error Message ( $ SMProxy Exception , 'system ' ) ; } catch ( My SQLException $ My SQLException ) { self : : write Error Message ( $ My SQLException , 'mysql ' ) ; } } ) ; } 
protected static function write Error Message ( $ exception , string $ tag = 'mysql ' ) { $ log = Log : : get Logger ( $ tag ) ; $ err Level = $ exception - > get Code ( ) ? array _search ( $ exception - > get Code ( ) , Log : : $ levels ) : 'warning ' ; $ log - > $ err Level ( $ exception - > error Message ( ) ) ; if ( CONFIG [ 'server ' ] [ 'swoole ' ] [ 'daemonize ' ] ! = true ) { echo ' [ ' . ucfirst ( $ err Level ) . ' ] ' , $ exception - > error Message ( ) , PHP _EOL ; } } 
public function parse Db Config ( array $ _config ) { $ config = $ _config [ 'database ' ] ? ? [ ] ; foreach ( $ config [ 'databases ' ] as $ key = > $ database ) { if ( isset ( $ config [ 'server Info ' ] [ $ database [ 'server Info ' ] ] ) ) { $ config [ 'databases ' ] [ $ key ] [ 'max Conns ' ] = floor ( eval ( 'return ' . $ config [ 'databases ' ] [ $ key ] [ 'max Conns ' ] . ' ; ' ) / CONFIG [ 'server ' ] [ 'swoole ' ] [ 'worker _num ' ] ) ; $ config [ 'databases ' ] [ $ key ] [ 'max Spare Conns ' ] = floor ( eval ( 'return ' . $ config [ 'databases ' ] [ $ key ] [ 'max Spare Conns ' ] . ' ; ' ) / CONFIG [ 'server ' ] [ 'swoole ' ] [ 'worker _num ' ] ) ; $ config [ 'databases ' ] [ $ key ] [ 'start Conns ' ] = eval ( 'return ' . $ config [ 'databases ' ] [ $ key ] [ 'start Conns ' ] . ' ; ' ) ; $ config [ 'databases ' ] [ $ key ] [ 'max Spare Exp ' ] = eval ( 'return ' . $ config [ 'databases ' ] [ $ key ] [ 'max Spare Exp ' ] . ' ; ' ) ; foreach ( $ config [ 'server Info ' ] [ $ database [ 'server Info ' ] ] as $ s _key = > $ value ) { if ( isset ( $ config [ 'account ' ] [ $ value [ 'account ' ] ] ) ) { $ host = & $ config [ 'server Info ' ] [ $ database [ 'server Info ' ] ] [ $ s _key ] [ 'host ' ] ; if ( is _array ( $ host ) ) { $ host = $ host [ array _rand ( $ host ) ] ; } if ( ! isset ( $ config [ 'databases ' ] [ $ s _key ] ) ) { $ config [ 'databases ' ] [ $ s _key ] = $ config [ 'databases ' ] [ $ key ] ; $ config [ 'databases ' ] [ $ s _key ] [ 'server Info ' ] = $ config [ 'server Info ' ] [ $ database [ 'server Info ' ] ] [ $ s _key ] ; $ config [ 'databases ' ] [ $ s _key ] [ 'server Info ' ] [ 'account ' ] = $ config [ 'account ' ] [ $ value [ 'account ' ] ] ; } $ config [ 'databases ' ] [ $ s _key . DB _DELIMITER . $ key ] = $ config [ 'databases ' ] [ $ key ] ; $ config [ 'databases ' ] [ $ s _key . DB _DELIMITER . $ key ] [ 'server Info ' ] = $ config [ 'server Info ' ] [ $ database [ 'server Info ' ] ] [ $ s _key ] ; $ config [ 'databases ' ] [ $ s _key . DB _DELIMITER . $ key ] [ 'server Info ' ] [ 'account ' ] = $ config [ 'account ' ] [ $ value [ 'account ' ] ] ; } else { throw new SMProxy Exception ( 'Config server Info - > ' . $ s _key . ' - >account is not exists ! ' ) ; } } } else { throw new SMProxy Exception ( 'Config server Info key ' . $ database [ 'server Info ' ] . 'is not exists ! ' ) ; } unset ( $ config [ 'databases ' ] [ $ key ] ) ; } return $ config [ 'databases ' ] ; } 
protected static function co Pop ( Channel $ chan , int $ timeout = 0 ) { if ( version _compare ( swoole _version ( ) , ' 4 . 0 . 3 ' , ' > = ' ) ) { return $ chan - > pop ( $ timeout ) ; } else { if ( 0 = = $ timeout ) { return $ chan - > pop ( ) ; } else { $ writes = [ ] ; $ reads = [ $ chan ] ; $ result = $ chan - > select ( $ reads , $ writes , $ timeout ) ; if ( false = = = $ result | | empty ( $ reads ) ) { return false ; } $ read Channel = $ reads [ 0 ] ; return $ read Channel - > pop ( ) ; } } } 
public function provide ( array $ options = array ( ) ) { $ options = array _replace ( $ this - > base Options , $ options ) ; $ manager = $ this - > doctrine - > get Manager For Class ( $ this - > object Class ) ; $ repository = $ manager - > get Repository ( $ this - > object Class ) ; $ qb = \ call _user _func ( [ $ repository , $ options [ 'query _builder _method ' ] ] , self : : ENTITY _ALIAS ) ; 
public function serialize ( $ object ) { $ context = $ this - > serializer instanceof JMSSerializer ? Serialization Context : : create ( ) - > enable Max Depth Checks ( ) : [ ] ; if ( ! empty ( $ this - > groups ) ) { if ( $ context instanceof Serialization Context ) { $ context - > set Groups ( $ this - > groups ) ; } else { $ context [ 'groups ' ] = $ this - > groups ; } } if ( $ this - > version ) { $ context - > set Version ( $ this - > version ) ; } if ( ! is _array ( $ context ) ) { $ context - > set Serialize Null ( $ this - > serialize Null ) ; } return $ this - > serializer - > serialize ( $ object , 'json ' , $ context ) ; } 
public static function build ( Output Interface $ output , $ action , $ index , $ type , $ offset ) { $ progress = null ; return function ( $ increment , $ total Objects , $ message = null ) use ( & $ progress , $ output , $ action , $ index , $ type , $ offset ) { if ( null = = = $ progress ) { $ progress = new Progress Bar ( $ output , $ total Objects ) ; $ progress - > start ( ) ; $ progress - > set Progress ( $ offset ) ; } if ( null ! = = $ message ) { $ progress - > clear ( ) ; $ output - > writeln ( sprintf ( ' <info > %s < /info > <error > %s < /error > ' , $ action , $ message ) ) ; $ progress - > display ( ) ; } $ progress - > set Message ( sprintf ( ' <info > %s < /info > <comment > %s / %s < /comment > ' , $ action , $ index , $ type ) ) ; $ progress - > advance ( $ increment ) ; } ; } 
public function insert Many ( array $ objects ) { $ documents = [ ] ; foreach ( $ objects as $ object ) { $ documents [ ] = $ this - > transform To Elastica Document ( $ object ) ; } try { $ this - > type - > add Documents ( $ documents , $ this - > options ) ; } catch ( Bulk Exception $ e ) { $ this - > log ( $ e ) ; } } 
public function replace Many ( array $ objects ) { $ documents = [ ] ; foreach ( $ objects as $ object ) { $ document = $ this - > transform To Elastica Document ( $ object ) ; $ document - > set Doc As Upsert ( true ) ; $ documents [ ] = $ document ; } try { $ this - > type - > update Documents ( $ documents , $ this - > options ) ; } catch ( Bulk Exception $ e ) { $ this - > log ( $ e ) ; } } 
public function delete Many ( array $ objects ) { $ documents = [ ] ; foreach ( $ objects as $ object ) { $ documents [ ] = $ this - > transform To Elastica Document ( $ object ) ; } try { $ this - > type - > delete Documents ( $ documents ) ; } catch ( Bulk Exception $ e ) { $ this - > log ( $ e ) ; } } 
public function delete Many By Identifiers ( array $ identifiers , $ routing = false ) { try { $ this - > type - > delete Ids ( $ identifiers , $ routing ) ; } catch ( Bulk Exception $ e ) { $ this - > log ( $ e ) ; } } 
private function log ( Bulk Exception $ e ) { if ( ! $ this - > logger ) { throw $ e ; } $ this - > logger - > error ( $ e ) ; } 
protected function execute ( Input Interface $ input , Output Interface $ output ) { $ index Template = $ input - > get Option ( 'index ' ) ; $ delete By Pattern = $ input - > get Option ( 'force -delete ' ) ; if ( $ delete By Pattern ) { $ helper = $ this - > get Helper ( 'question ' ) ; $ question = new Confirmation Question ( 'You are going to remove all template indexes . Are you sure ? ' , false ) ; if ( ! $ helper - > ask ( $ input , $ output , $ question ) ) { return 1 ; } } if ( null ! = = $ index Template ) { $ output - > writeln ( sprintf ( ' <info >Resetting template < /info > <comment > %s < /comment > ' , $ index Template ) ) ; $ this - > resetter - > reset Index ( $ index Template , $ delete By Pattern ) ; } else { $ output - > writeln ( ' <info >Resetting all templates < /info > ' ) ; $ this - > resetter - > reset All Indexes ( $ delete By Pattern ) ; } return 0 ; } 
public function process ( Container Builder $ container ) { if ( ! $ container - > has Definition ( 'fos _elastica .config _manager ' ) ) { return ; } $ index Sources = [ ] ; $ index Template Sources = [ ] ; foreach ( array _keys ( $ container - > find Tagged Service Ids ( 'fos _elastica .config _source ' ) ) as $ id ) { $ tag = $ container - > find Definition ( $ id ) - > get Tag ( 'fos _elastica .config _source ' ) ; if ( isset ( $ tag [ 0 ] [ 'source ' ] ) & & $ tag [ 0 ] [ 'source ' ] = = = self : : SOURCE _TYPE _INDEX _TEMPLATE ) { $ index Template Sources [ ] = new Reference ( $ id ) ; } else { $ index Sources [ ] = new Reference ( $ id ) ; } } $ container - > get Definition ( 'fos _elastica .config _manager ' ) - > replace Argument ( 0 , $ index Sources ) ; $ container - > get Definition ( 'fos _elastica .config _manager .index _templates ' ) - > replace Argument ( 0 , $ index Template Sources ) ; } 
protected function get Types ( $ config ) { $ types = array ( ) ; if ( isset ( $ config [ 'types ' ] ) ) { foreach ( $ config [ 'types ' ] as $ type Config ) { $ types [ $ type Config [ 'name ' ] ] = new Type Config ( $ type Config [ 'name ' ] , $ type Config [ 'mapping ' ] , $ type Config [ 'config ' ] ) ; } } return $ types ; } 
public function provide ( array $ options = array ( ) ) { $ options = array _replace ( $ this - > base Options , $ options ) ; $ manager = $ this - > doctrine - > get Manager For Class ( $ this - > object Class ) ; $ repository = $ manager - > get Repository ( $ this - > object Class ) ; $ pager = new Pagerfanta Pager ( new Pagerfanta ( new Doctrine ODMMongo DBAdapter ( call _user _func ( [ $ repository , $ options [ 'query _builder _method ' ] ] ) ) ) ) ; $ this - > register Listeners Service - > register ( $ manager , $ pager , $ options ) ; return $ pager ; } 
public function get Configuration ( ) { $ indexes = [ ] ; foreach ( $ this - > config Array as $ config ) { $ types = $ this - > get Types ( $ config ) ; $ index = new Index Config ( $ config [ 'name ' ] , $ types , [ 'elastic Search Name ' = > $ config [ 'elasticsearch _name ' ] , 'settings ' = > $ config [ 'settings ' ] , 'use Alias ' = > $ config [ 'use _alias ' ] , ] ) ; $ indexes [ $ config [ 'name ' ] ] = $ index ; } return $ indexes ; } 
public function get Type ( $ type Name ) { if ( ! array _key _exists ( $ type Name , $ this - > types ) ) { throw new \ Invalid Argument Exception ( sprintf ( 'Type " %s " does not exist on index " %s " ' , $ type Name , $ this - > name ) ) ; } return $ this - > types [ $ type Name ] ; } 
public function get All Providers ( ) { $ providers = [ ] ; foreach ( $ this - > providers as $ index = > $ index Providers ) { foreach ( $ index Providers as $ type = > $ provider Id ) { $ providers [ sprintf ( ' %s / %s ' , $ index , $ type ) ] = $ this - > container - > get ( $ provider Id ) ; } } return $ providers ; } 
public function get Index Providers ( $ index ) { if ( ! isset ( $ this - > providers [ $ index ] ) ) { throw new \ Invalid Argument Exception ( sprintf ( 'No providers were registered for index " %s " . ' , $ index ) ) ; } $ providers = [ ] ; foreach ( $ this - > providers [ $ index ] as $ type = > $ provider Id ) { $ providers [ $ type ] = $ this - > get Provider ( $ index , $ type ) ; } return $ providers ; } 
public function get Provider ( $ index , $ type ) { if ( ! isset ( $ this - > providers [ $ index ] [ $ type ] ) ) { throw new \ Invalid Argument Exception ( sprintf ( 'No provider was registered for index " %s " and type " %s " . ' , $ index , $ type ) ) ; } return $ this - > container - > get ( $ this - > providers [ $ index ] [ $ type ] ) ; } 
protected function set Sorting ( Items Event $ event ) { $ options = $ event - > options ; $ sort Field = $ this - > get Request ( ) - > get ( $ options [ 'sort Field Parameter Name ' ] ) ; if ( ! $ sort Field & & isset ( $ options [ 'default Sort Field Name ' ] ) ) { $ sort Field = $ options [ 'default Sort Field Name ' ] ; } if ( ! empty ( $ sort Field ) ) { $ event - > target - > get Query ( ) - > set Sort ( [ $ sort Field = > $ this - > get Sort ( $ sort Field , $ options ) , ] ) ; } } 
public function get Results ( $ offset , $ length ) { return new Transformed Partial Results ( $ this - > get Elastica Results ( $ offset , $ length ) , $ this - > transformer ) ; } 
protected function format Result ( Result $ result , $ show Field , $ show Source , $ show Id , $ explain ) { $ source = $ result - > get Source ( ) ; if ( $ show Field ) { $ to String = isset ( $ source [ $ show Field ] ) ? $ source [ $ show Field ] : ' - ' ; } else { $ to String = reset ( $ source ) ; } $ string = sprintf ( ' [ % 0 . 2f ] %s ' , $ result - > get Score ( ) , var _export ( $ to String , true ) ) ; if ( $ show Source ) { $ string = sprintf ( ' %s %s ' , $ string , json _encode ( $ source ) ) ; } if ( $ show Id ) { $ string = sprintf ( ' { %s } %s ' , $ result - > get Id ( ) , $ string ) ; } if ( $ explain ) { $ string = sprintf ( ' %s %s ' , $ string , json _encode ( $ result - > get Explanation ( ) ) ) ; } return $ string ; } 
public function build Index Mapping ( Index Config Interface $ index Config ) { $ type Mappings = [ ] ; foreach ( $ index Config - > get Types ( ) as $ type Config ) { $ type Mappings [ $ type Config - > get Name ( ) ] = $ this - > build Type Mapping ( $ type Config ) ; } $ mapping = [ ] ; if ( ! empty ( $ type Mappings ) ) { $ mapping [ 'mappings ' ] = $ type Mappings ; } 
public function build Index Template Mapping ( Index Template Config $ index Template Config ) { $ mapping = $ this - > build Index Mapping ( $ index Template Config ) ; $ mapping [ 'template ' ] = $ index Template Config - > get Template ( ) ; return $ mapping ; } 
public function build Type Mapping ( Type Config $ type Config ) { $ mapping = $ type Config - > get Mapping ( ) ; if ( null ! = = $ type Config - > get Dynamic Date Formats ( ) ) { $ mapping [ 'dynamic _date _formats ' ] = $ type Config - > get Dynamic Date Formats ( ) ; } if ( null ! = = $ type Config - > get Date Detection ( ) ) { $ mapping [ 'date _detection ' ] = $ type Config - > get Date Detection ( ) ; } if ( null ! = = $ type Config - > get Numeric Detection ( ) ) { $ mapping [ 'numeric _detection ' ] = $ type Config - > get Numeric Detection ( ) ; } if ( $ type Config - > get Analyzer ( ) ) { $ mapping [ 'analyzer ' ] = $ type Config - > get Analyzer ( ) ; } if ( null ! = = $ type Config - > get Dynamic ( ) ) { $ mapping [ 'dynamic ' ] = $ type Config - > get Dynamic ( ) ; } if ( isset ( $ mapping [ 'dynamic _templates ' ] ) and empty ( $ mapping [ 'dynamic _templates ' ] ) ) { unset ( $ mapping [ 'dynamic _templates ' ] ) ; } $ this - > fix Properties ( $ mapping [ 'properties ' ] ) ; if ( ! $ mapping [ 'properties ' ] ) { unset ( $ mapping [ 'properties ' ] ) ; } if ( $ type Config - > get Model ( ) ) { $ mapping [ ' _meta ' ] [ 'model ' ] = $ type Config - > get Model ( ) ; } unset ( $ mapping [ ' _parent ' ] [ 'identifier ' ] , $ mapping [ ' _parent ' ] [ 'property ' ] ) ; if ( empty ( $ mapping ) ) { 
private function fix Properties ( & $ properties ) { foreach ( $ properties as $ name = > & $ property ) { unset ( $ property [ 'property _path ' ] ) ; if ( ! isset ( $ property [ 'type ' ] ) ) { $ property [ 'type ' ] = 'text ' ; } if ( isset ( $ property [ 'fields ' ] ) ) { $ this - > fix Properties ( $ property [ 'fields ' ] ) ; } if ( isset ( $ property [ 'properties ' ] ) ) { $ this - > fix Properties ( $ property [ 'properties ' ] ) ; } } } 
public function process ( Container Builder $ container ) { if ( ! $ container - > has Definition ( 'fos _elastica .pager _persister _registry ' ) ) { return ; } $ registry = $ container - > get Definition ( 'fos _elastica .pager _persister _registry ' ) ; $ name To Service Id Map = [ ] ; foreach ( $ container - > find Tagged Service Ids ( 'fos _elastica .pager _persister ' , true ) as $ id = > $ attributes ) { foreach ( $ attributes as $ attribute ) { if ( ! isset ( $ attribute [ 'persister Name ' ] ) ) { throw new \ Invalid Argument Exception ( sprintf ( 'Elastica pager persister " %s " must specify the "persister Name " attribute . ' , $ id ) ) ; } $ persister Name = $ attribute [ 'persister Name ' ] ; if ( isset ( $ name To Service Id Map [ $ persister Name ] ) ) { throw new \ Invalid Argument Exception ( sprintf ( 'Cannot register pager persister " %s " . The pager persister " %s " has been registered for same name " %s " ' , $ id , $ name To Service Id Map [ $ persister Name ] , $ persister Name ) ) ; } $ persister Def = $ container - > get Definition ( $ id ) ; if ( ! $ persister Def - > get Factory ( ) & & $ persister Def - > get Class ( ) ) { 
private function assert Class Implements Pager Persister Interface ( $ persister Id , $ persister Class ) { $ rc = new \ Reflection Class ( $ persister Class ) ; if ( ! $ rc - > implements Interface ( Pager Persister Interface : : class ) ) { throw new \ Invalid Argument Exception ( sprintf ( 'Elastica pager persister " %s " with class " %s " must implement " %s " . ' , $ persister Id , $ persister Class , Pager Persister Interface : : class ) ) ; } } 
public function log Query ( $ path , $ method , $ data , $ query Time , $ connection = [ ] , $ query = [ ] , $ engine Time = 0 , $ item Count = 0 ) { $ execution MS = $ query Time * 1 0 0 0 ; if ( $ this - > debug ) { $ e = new \ Exception ( ) ; if ( is _string ( $ data ) ) { $ json Strings = explode ( " \n " , $ data ) ; $ data = [ ] ; foreach ( $ json Strings as $ json ) { if ( $ json ! = ' ' ) { $ data [ ] = json _decode ( $ json , true ) ; } } } else { $ data = [ $ data ] ; } $ this - > queries [ ] = [ 'path ' = > $ path , 'method ' = > $ method , 'data ' = > $ data , 'execution MS ' = > $ execution MS , 'engine MS ' = > $ engine Time , 'connection ' = > $ connection , 'query String ' = > $ query , 'item Count ' = > $ item Count , 'backtrace ' = > $ e - > get Trace As String ( ) , ] ; } if ( null ! = = $ this - > logger ) { $ message = sprintf ( ' %s ( %s ) % 0 . 2f ms ' , $ path , $ method , $ execution MS ) ; $ this - > logger - > info ( $ message , ( array ) $ data ) ; } } 
public function insert ( Pager Interface $ pager , array $ options = array ( ) ) { $ pager - > set Max Per Page ( empty ( $ options [ 'max _per _page ' ] ) ? 1 0 0 : $ options [ 'max _per _page ' ] ) ; $ options = array _replace ( [ 'max _per _page ' = > $ pager - > get Max Per Page ( ) , 'first _page ' = > $ pager - > get Current Page ( ) , 'last _page ' = > $ pager - > get Nb Pages ( ) , ] , $ options ) ; $ pager - > set Current Page ( $ options [ 'first _page ' ] ) ; $ object Persister = $ this - > registry - > get Persister ( $ options [ 'index Name ' ] , $ options [ 'type Name ' ] ) ; try { $ event = new Pre Persist Event ( $ pager , $ object Persister , $ options ) ; $ this - > dispatcher - > dispatch ( Events : : PRE _PERSIST , $ event ) ; $ pager = $ event - > get Pager ( ) ; $ options = $ event - > get Options ( ) ; $ last Page = min ( $ options [ 'last _page ' ] , $ pager - > get Nb Pages ( ) ) ; $ page = $ pager - > get Current Page ( ) ; do { $ pager - > set Current Page ( $ page ) ; $ this - > insert Page ( $ page , $ pager , $ object Persister , $ options ) ; $ page + + ; } while ( $ page < = $ last Page ) ; } finally { $ event = new Post Persist Event ( $ pager , $ object Persister , $ options ) ; $ this - > dispatcher - > dispatch ( Events : : POST _PERSIST , $ event ) ; } } 
private function insert Page ( $ page , Pager Interface $ pager , Object Persister Interface $ object Persister , array $ options = array ( ) ) { $ pager - > set Current Page ( $ page ) ; $ event = new Pre Fetch Objects Event ( $ pager , $ object Persister , $ options ) ; $ this - > dispatcher - > dispatch ( Events : : PRE _FETCH _OBJECTS , $ event ) ; $ pager = $ event - > get Pager ( ) ; $ options = $ event - > get Options ( ) ; $ objects = $ pager - > get Current Page Results ( ) ; if ( $ objects instanceof \ Traversable ) { $ objects = iterator _to _array ( $ objects ) ; } $ event = new Pre Insert Objects Event ( $ pager , $ object Persister , $ objects , $ options ) ; $ this - > dispatcher - > dispatch ( Events : : PRE _INSERT _OBJECTS , $ event ) ; $ pager = $ event - > get Pager ( ) ; $ options = $ event - > get Options ( ) ; $ objects = $ event - > get Objects ( ) ; try { if ( ! empty ( $ objects ) ) { $ object Persister - > insert Many ( $ objects ) ; } $ event = new Post Insert Objects Event ( $ pager , $ object Persister , $ objects , $ options ) ; $ this - > dispatcher - > dispatch ( Events : : POST _INSERT _OBJECTS , $ event ) ; } catch ( \ Exception $ e ) { $ event = new On Exception Event ( $ pager , $ object Persister , $ e , $ objects , $ options ) ; $ this - > dispatcher - > dispatch ( Events : : ON _EXCEPTION , $ event ) ; if ( $ event - > is Ignored ( ) ) { $ event = new Post Insert Objects Event ( $ pager , $ object Persister , $ objects , $ options ) ; $ this - > dispatcher - > dispatch ( Events : : POST _INSERT _OBJECTS , $ event ) ; } else { $ e = $ event - > get Exception ( ) ; throw $ e ; } } } 
private function assert Class Implements Pager Provider Interface ( $ provider Id , $ provider Class ) { $ rc = new \ Reflection Class ( $ provider Class ) ; if ( ! $ rc - > implements Interface ( Pager Provider Interface : : class ) ) { throw new \ Invalid Argument Exception ( sprintf ( 'Elastica provider " %s " with class " %s " must implement " %s " . ' , $ provider Id , $ provider Class , Pager Provider Interface : : class ) ) ; } } 
public function transform To Elastica Document ( $ object ) { $ document = $ this - > transformer - > transform ( $ object , [ ] ) ; $ data = call _user _func ( $ this - > serializer , $ object ) ; $ document - > set Data ( $ data ) ; return $ document ; } 
public function get Total Hits ( $ genuine Total = false ) { if ( ! isset ( $ this - > total Hits ) ) { $ this - > total Hits = $ this - > searchable - > count ( $ this - > query ) ; } return $ this - > query - > has Param ( 'size ' ) & & ! $ genuine Total ? min ( $ this - > total Hits , ( int ) $ this - > query - > get Param ( 'size ' ) ) : $ this - > total Hits ; } 
public function get Aggregations ( ) { if ( ! isset ( $ this - > aggregations ) ) { $ this - > aggregations = $ this - > searchable - > search ( $ this - > query ) - > get Aggregations ( ) ; } return $ this - > aggregations ; } 
public function get Suggests ( ) { if ( ! isset ( $ this - > suggests ) ) { $ this - > suggests = $ this - > searchable - > search ( $ this - > query ) - > get Suggests ( ) ; } return $ this - > suggests ; } 
protected function get Elastica Results ( $ offset , $ item Count Per Page ) { $ offset = ( int ) $ offset ; $ item Count Per Page = ( int ) $ item Count Per Page ; $ size = $ this - > query - > has Param ( 'size ' ) ? ( int ) $ this - > query - > get Param ( 'size ' ) : null ; if ( null ! = = $ size & & $ size < $ offset + $ item Count Per Page ) { $ item Count Per Page = $ size - $ offset ; } if ( $ item Count Per Page < 1 ) { throw new Invalid Argument Exception ( ' $item Count Per Page must be greater than zero ' ) ; } $ query = clone $ this - > query ; $ query - > set From ( $ offset ) ; $ query - > set Size ( $ item Count Per Page ) ; $ result Set = $ this - > searchable - > search ( $ query , $ this - > options ) ; $ this - > total Hits = $ result Set - > get Total Hits ( ) ; $ this - > aggregations = $ result Set - > get Aggregations ( ) ; $ this - > suggests = $ result Set - > get Suggests ( ) ; $ this - > max Score = $ result Set - > get Max Score ( ) ; return $ result Set ; } 
public function delete Template Indexes ( Index Template Config $ template ) { $ this - > client - > request ( $ template - > get Template ( ) . ' / ' , Request : : DELETE ) ; } 
public function get Index ( $ name = null ) { if ( null = = = $ name ) { return $ this - > default Index ; } if ( ! isset ( $ this - > indexes [ $ name ] ) ) { throw new \ Invalid Argument Exception ( sprintf ( 'The index " %s " does not exist ' , $ name ) ) ; } return $ this - > indexes [ $ name ] ; } 
public function get Persister ( $ index , $ type ) { if ( ! isset ( $ this - > persisters [ $ index ] [ $ type ] ) ) { throw new \ Invalid Argument Exception ( sprintf ( 'No persister was registered for index " %s " and type " %s " . ' , $ index , $ type ) ) ; } return $ this - > container - > get ( $ this - > persisters [ $ index ] [ $ type ] ) ; } 
private function populate Index ( Output Interface $ output , $ index , $ reset , $ options ) { $ event = new Index Populate Event ( $ index , $ reset , $ options ) ; $ this - > dispatcher - > dispatch ( Index Populate Event : : PRE _INDEX _POPULATE , $ event ) ; if ( $ event - > is Reset ( ) ) { $ output - > writeln ( sprintf ( ' <info >Resetting < /info > <comment > %s < /comment > ' , $ index ) ) ; $ this - > resetter - > reset Index ( $ index , true ) ; } $ types = array _keys ( $ this - > pager Provider Registry - > get Index Providers ( $ index ) ) ; foreach ( $ types as $ type ) { $ this - > populate Index Type ( $ output , $ index , $ type , false , $ event - > get Options ( ) ) ; } $ this - > dispatcher - > dispatch ( Index Populate Event : : POST _INDEX _POPULATE , $ event ) ; $ this - > refresh Index ( $ output , $ index ) ; } 
private function populate Index Type ( Output Interface $ output , $ index , $ type , $ reset , $ options ) { $ event = new Type Populate Event ( $ index , $ type , $ reset , $ options ) ; $ this - > dispatcher - > dispatch ( Type Populate Event : : PRE _TYPE _POPULATE , $ event ) ; if ( $ event - > is Reset ( ) ) { $ output - > writeln ( sprintf ( ' <info >Resetting < /info > <comment > %s / %s < /comment > ' , $ index , $ type ) ) ; $ this - > resetter - > reset Index Type ( $ index , $ type ) ; } $ offset = 1 < $ options [ 'first _page ' ] ? ( $ options [ 'first _page ' ] - 1 ) * $ options [ 'max _per _page ' ] : 0 ; $ logger Closure = Progress Closure Builder : : build ( $ output , 'Populating ' , $ index , $ type , $ offset ) ; $ this - > dispatcher - > add Listener ( Events : : ON _EXCEPTION , function ( On Exception Event $ event ) use ( $ logger Closure ) { $ logger Closure ( count ( $ event - > get Objects ( ) ) , $ event - > get Pager ( ) - > get Nb Results ( ) , sprintf ( ' <error > %s < /error > ' , $ event - > get Exception ( ) - > get Message ( ) ) ) ; } ) ; $ this - > dispatcher - > add Listener ( Events : : POST _INSERT _OBJECTS , function ( Post Insert Objects Event $ event ) use ( $ logger Closure ) { $ logger Closure ( count ( $ event - > get Objects ( ) ) , $ event - > get Pager ( ) - > get Nb Results ( ) ) ; } ) ; $ this - > dispatcher - > add Listener ( Events : : POST _ASYNC _INSERT _OBJECTS , function ( Post Async Insert Objects Event $ event ) use ( $ logger Closure ) { $ logger Closure ( $ event - > get Objects Count ( ) , $ event - > get Pager ( ) - > get Nb Results ( ) , $ event - > get Error Message ( ) ) ; } ) ; if ( $ options [ 'ignore _errors ' ] ) { $ this - > dispatcher - > add Listener ( Events : : ON _EXCEPTION , function ( On Exception Event $ event ) { if ( $ event - > get Exception ( ) instanceof Bulk Response Exception ) { $ event - > set Ignore ( true ) ; } } ) ; } $ provider = $ this - > pager Provider Registry - > get Provider ( $ index , $ type ) ; $ pager = $ provider - > provide ( $ options ) ; $ options [ 'index Name ' ] = $ index ; $ options [ 'type Name ' ] = $ type ; $ this - > pager Persister - > insert ( $ pager , $ options ) ; $ this - > dispatcher - > dispatch ( Type Populate Event : : POST _TYPE _POPULATE , $ event ) ; $ this - > refresh Index ( $ output , $ index ) ; } 
private function refresh Index ( Output Interface $ output , $ index ) { $ output - > writeln ( sprintf ( ' <info >Refreshing < /info > <comment > %s < /comment > ' , $ index ) ) ; $ this - > index Manager - > get Index ( $ index ) - > refresh ( ) ; } 
public function transform ( $ object , array $ fields ) { $ identifier = $ this - > property Accessor - > get Value ( $ object , $ this - > options [ 'identifier ' ] ) ; if ( $ identifier & & ! is _scalar ( $ identifier ) ) { $ identifier = ( string ) $ identifier ; } return $ this - > transform Object To Document ( $ object , $ fields , $ identifier ) ; } 
protected function transform Nested ( $ objects , array $ fields ) { if ( is _array ( $ objects ) | | $ objects instanceof \ Traversable | | $ objects instanceof \ Array Access ) { $ documents = [ ] ; foreach ( $ objects as $ object ) { $ document = $ this - > transform Object To Document ( $ object , $ fields ) ; $ documents [ ] = $ document - > get Data ( ) ; } return $ documents ; } elseif ( null ! = = $ objects ) { $ document = $ this - > transform Object To Document ( $ objects , $ fields ) ; return $ document - > get Data ( ) ; } return [ ] ; } 
protected function normalize Value ( $ value ) { $ normalize Value = function ( & $ v ) { if ( $ v instanceof \ Date Time Interface ) { $ v = $ v - > format ( 'c ' ) ; } elseif ( ! is _scalar ( $ v ) & & ! is _null ( $ v ) ) { $ v = ( string ) $ v ; } } ; if ( is _array ( $ value ) | | $ value instanceof \ Traversable | | $ value instanceof \ Array Access ) { $ value = is _array ( $ value ) ? $ value : iterator _to _array ( $ value , false ) ; array _walk _recursive ( $ value , $ normalize Value ) ; } else { $ normalize Value ( $ value ) ; } return $ value ; } 
protected function transform Object To Document ( $ object , array $ fields , $ identifier = ' ' ) { $ document = new Document ( $ identifier , [ ] , ' ' , $ this - > options [ 'index ' ] ) ; if ( $ this - > dispatcher ) { $ event = new Transform Event ( $ document , $ fields , $ object ) ; $ this - > dispatcher - > dispatch ( Transform Event : : PRE _TRANSFORM , $ event ) ; $ document = $ event - > get Document ( ) ; } foreach ( $ fields as $ key = > $ mapping ) { if ( ' _parent ' = = $ key ) { $ property = ( null ! = = $ mapping [ 'property ' ] ) ? $ mapping [ 'property ' ] : $ mapping [ 'type ' ] ; $ value = $ this - > property Accessor - > get Value ( $ object , $ property ) ; $ document - > set Parent ( $ this - > property Accessor - > get Value ( $ value , $ mapping [ 'identifier ' ] ) ) ; continue ; } $ path = isset ( $ mapping [ 'property _path ' ] ) ? $ mapping [ 'property _path ' ] : $ key ; if ( false = = = $ path ) { continue ; } $ value = $ this - > property Accessor - > get Value ( $ object , $ path ) ; if ( isset ( $ mapping [ 'type ' ] ) & & in _array ( $ mapping [ 'type ' ] , [ 'nested ' , 'object ' ] ) & & isset ( $ mapping [ 'properties ' ] ) & & ! empty ( $ mapping [ 'properties ' ] ) ) { $ document - > set ( $ key , $ this - > transform Nested ( $ value , $ mapping [ 'properties ' ] ) ) ; continue ; } if ( isset ( $ mapping [ 'type ' ] ) & & 'attachment ' = = $ mapping [ 'type ' ] ) { 
protected function find By Identifiers ( array $ identifier Values , $ hydrate ) { if ( empty ( $ identifier Values ) ) { return [ ] ; } $ hydration Mode = $ hydrate ? Query : : HYDRATE _OBJECT : Query : : HYDRATE _ARRAY ; $ qb = $ this - > get Entity Query Builder ( ) ; $ qb - > and Where ( $ qb - > expr ( ) - > in ( static : : ENTITY _ALIAS . ' . ' . $ this - > options [ 'identifier ' ] , ' :values ' ) ) - > set Parameter ( 'values ' , $ identifier Values ) ; $ query = $ qb - > get Query ( ) ; foreach ( $ this - > options [ 'hints ' ] as $ hint ) { $ query - > set Hint ( $ hint [ 'name ' ] , $ hint [ 'value ' ] ) ; } return $ query - > set Hydration Mode ( $ hydration Mode ) - > execute ( ) ; } 
protected function get Entity Query Builder ( ) { $ repository = $ this - > registry - > get Manager For Class ( $ this - > object Class ) - > get Repository ( $ this - > object Class ) ; return $ repository - > { $ this - > options [ 'query _builder _method ' ] } ( static : : ENTITY _ALIAS ) ; } 
public function process ( Container Builder $ container ) { if ( ! $ container - > has Definition ( 'fos _elastica .persister _registry ' ) ) { return ; } $ default Index = $ container - > get Parameter ( 'fos _elastica .default _index ' ) ; $ registry = $ container - > get Definition ( 'fos _elastica .persister _registry ' ) ; $ registered Persisters = [ ] ; foreach ( $ container - > find Tagged Service Ids ( 'fos _elastica .persister ' , true ) as $ id = > $ attributes ) { foreach ( $ attributes as $ attribute ) { if ( ! isset ( $ attribute [ 'type ' ] ) ) { throw new \ Invalid Argument Exception ( sprintf ( 'Elastica persister " %s " must specify the "type " attribute . ' , $ id ) ) ; } $ index = isset ( $ attribute [ 'index ' ] ) ? $ attribute [ 'index ' ] : $ default Index ; $ type = $ attribute [ 'type ' ] ; if ( isset ( $ registered Persisters [ $ index ] [ $ type ] ) ) { throw new \ Invalid Argument Exception ( sprintf ( 'Cannot register persister " %s " . The persister " %s " has been registered for same index " %s " and type " %s " ' , $ id , $ registered Persisters [ $ index ] [ $ type ] , $ index , $ type ) ) ; } $ persister Def = $ container - > get Definition ( $ id ) ; if ( ! $ persister Def - > get Factory ( ) & & $ persister Def - > get Class ( ) ) { 
private function assert Class Implements Persister Interface ( $ persister Id , $ persister Class ) { $ rc = new \ Reflection Class ( $ persister Class ) ; if ( ! $ rc - > implements Interface ( Object Persister Interface : : class ) ) { throw new \ Invalid Argument Exception ( sprintf ( 'Elastica persister " %s " with class " %s " must implement " %s " . ' , $ persister Id , $ persister Class , Object Persister Interface : : class ) ) ; } } 
public function transform ( array $ elastica Objects ) { $ sorted = [ ] ; foreach ( $ elastica Objects as $ object ) { $ sorted [ $ object - > get Type ( ) ] [ ] = $ object ; } $ transformed = [ ] ; foreach ( $ sorted as $ type = > $ objects ) { $ transformed Objects = $ this - > transformers [ $ type ] - > transform ( $ objects ) ; $ identifier Getter = 'get ' . ucfirst ( $ this - > transformers [ $ type ] - > get Identifier Field ( ) ) ; $ transformed [ $ type ] = array _combine ( array _map ( function ( $ o ) use ( $ identifier Getter ) { return $ o - > $ identifier Getter ( ) ; } , $ transformed Objects ) , $ transformed Objects ) ; } $ result = [ ] ; foreach ( $ elastica Objects as $ object ) { if ( array _key _exists ( ( string ) $ object - > get Id ( ) , $ transformed [ $ object - > get Type ( ) ] ) ) { $ result [ ] = $ transformed [ $ object - > get Type ( ) ] [ ( string ) $ object - > get Id ( ) ] ; } } return $ result ; } 
public function process ( Container Builder $ container ) { if ( ! $ container - > has Definition ( 'fos _elastica .index _manager ' ) ) { return ; } $ indexes = [ ] ; foreach ( $ container - > find Tagged Service Ids ( 'fos _elastica .index ' ) as $ id = > $ tags ) { foreach ( $ tags as $ tag ) { $ indexes [ $ tag [ 'name ' ] ] = new Reference ( $ id ) ; } } $ container - > get Definition ( 'fos _elastica .index _manager ' ) - > replace Argument ( 0 , $ indexes ) ; } 
public function find ( $ query , $ limit = null , $ options = [ ] ) { $ results = $ this - > search ( $ query , $ limit , $ options ) ; return $ this - > transformer - > transform ( $ results ) ; } 
public function find Hybrid ( $ query , $ limit = null , $ options = [ ] ) { $ results = $ this - > search ( $ query , $ limit , $ options ) ; return $ this - > transformer - > hybrid Transform ( $ results ) ; } 
public function find Paginated ( $ query , $ options = [ ] ) { $ query Object = Query : : create ( $ query ) ; $ paginator Adapter = $ this - > create Paginator Adapter ( $ query Object , $ options ) ; return new Pagerfanta ( new Fanta Paginator Adapter ( $ paginator Adapter ) ) ; } 
public function create Paginator Adapter ( $ query , $ options = [ ] ) { $ query = Query : : create ( $ query ) ; return new Transformed Paginator Adapter ( $ this - > searchable , $ query , $ options , $ this - > transformer ) ; } 
public function create Hybrid Paginator Adapter ( $ query ) { $ query = Query : : create ( $ query ) ; return new Hybrid Paginator Adapter ( $ this - > searchable , $ query , $ this - > transformer ) ; } 
public function create Raw Paginator Adapter ( $ query , $ options = [ ] ) { $ query = Query : : create ( $ query ) ; return new Raw Paginator Adapter ( $ this - > searchable , $ query , $ options ) ; } 
protected function search ( $ query , $ limit = null , $ options = [ ] ) { $ query Object = Query : : create ( $ query ) ; if ( null ! = = $ limit ) { $ query Object - > set Size ( $ limit ) ; } $ results = $ this - > searchable - > search ( $ query Object , $ options ) - > get Results ( ) ; return $ results ; } 
public function get Index Template ( $ name ) { if ( ! isset ( $ this - > templates [ $ name ] ) ) { throw new \ Invalid Argument Exception ( sprintf ( 'The index template " %s " does not exist ' , $ name ) ) ; } return $ this - > templates [ $ name ] ; } 
public function build ( Container Builder $ container ) { parent : : build ( $ container ) ; $ container - > add Compiler Pass ( new Config Source Pass ( ) ) ; $ container - > add Compiler Pass ( new Index Pass ( ) ) ; $ container - > add Compiler Pass ( new Register Pager Providers Pass ( ) ) ; $ container - > add Compiler Pass ( new Register Persisters Pass ( ) ) ; $ container - > add Compiler Pass ( new Register Pager Persisters Pass ( ) ) ; $ container - > add Compiler Pass ( new Transformer Pass ( ) ) ; } 
public function get Results ( $ offset , $ length ) { return new Hybrid Partial Results ( $ this - > get Elastica Results ( $ offset , $ length ) , $ this - > transformer ) ; } 
public function reset All Indexes ( $ populating = false , $ force = false ) { foreach ( $ this - > config Manager - > get Index Names ( ) as $ name ) { $ this - > reset Index ( $ name , $ populating , $ force ) ; } } 
public function reset Index ( $ index Name , $ populating = false , $ force = false ) { $ index Config = $ this - > config Manager - > get Index Configuration ( $ index Name ) ; $ index = $ this - > index Manager - > get Index ( $ index Name ) ; if ( $ index Config - > is Use Alias ( ) ) { $ this - > alias Processor - > set Root Name ( $ index Config , $ index ) ; } $ event = new Index Reset Event ( $ index Name , $ populating , $ force ) ; $ this - > dispatcher - > dispatch ( Index Reset Event : : PRE _INDEX _RESET , $ event ) ; $ mapping = $ this - > mapping Builder - > build Index Mapping ( $ index Config ) ; $ index - > create ( $ mapping , true ) ; if ( ! $ populating and $ index Config - > is Use Alias ( ) ) { $ this - > alias Processor - > switch Index Alias ( $ index Config , $ index , $ force ) ; } $ this - > dispatcher - > dispatch ( Index Reset Event : : POST _INDEX _RESET , $ event ) ; } 
public function reset Index Type ( $ index Name , $ type Name ) { $ type Config = $ this - > config Manager - > get Type Configuration ( $ index Name , $ type Name ) ; $ this - > reset Index ( $ index Name , true ) ; $ index = $ this - > index Manager - > get Index ( $ index Name ) ; $ type = $ index - > get Type ( $ type Name ) ; $ event = new Type Reset Event ( $ index Name , $ type Name ) ; $ this - > dispatcher - > dispatch ( Type Reset Event : : PRE _TYPE _RESET , $ event ) ; $ mapping = new Mapping ( ) ; foreach ( $ this - > mapping Builder - > build Type Mapping ( $ type Config ) as $ name = > $ field ) { $ mapping - > set Param ( $ name , $ field ) ; } $ type - > set Mapping ( $ mapping ) ; $ this - > dispatcher - > dispatch ( Type Reset Event : : POST _TYPE _RESET , $ event ) ; } 
public function switch Index Alias ( $ index Name , $ delete = true ) { $ index Config = $ this - > config Manager - > get Index Configuration ( $ index Name ) ; if ( $ index Config - > is Use Alias ( ) ) { $ index = $ this - > index Manager - > get Index ( $ index Name ) ; $ this - > alias Processor - > switch Index Alias ( $ index Config , $ index , false , $ delete ) ; } } 
public function get Pager Persister ( $ name ) { if ( ! isset ( $ this - > name To Service Id Map [ $ name ] ) ) { throw new \ Invalid Argument Exception ( sprintf ( 'No pager persister was registered for the give name " %s " . ' , $ name ) ) ; } $ service Id = $ this - > name To Service Id Map [ $ name ] ; $ pager Persister = $ this - > container - > get ( $ service Id ) ; if ( ! $ pager Persister instanceof Pager Persister Interface ) { throw new \ Logic Exception ( sprintf ( 'The pager provider service " %s " must implement " %s " interface but it is an instance of " %s " class . ' , $ service Id , Pager Persister Interface : : class , get _class ( $ pager Persister ) ) ) ; } return $ pager Persister ; } 
private function load Indexes ( array $ indexes , Container Builder $ container ) { $ indexable Callbacks = [ ] ; foreach ( $ indexes as $ name = > $ index ) { $ index Id = sprintf ( 'fos _elastica .index . %s ' , $ name ) ; $ index Name = isset ( $ index [ 'index _name ' ] ) ? $ index [ 'index _name ' ] : $ name ; $ index Def = new Child Definition ( 'fos _elastica .index _prototype ' ) ; $ index Def - > set Factory ( [ new Reference ( 'fos _elastica .client ' ) , 'get Index ' ] ) ; $ index Def - > replace Argument ( 0 , $ index Name ) ; $ index Def - > add Tag ( 'fos _elastica .index ' , [ 'name ' = > $ name , ] ) ; if ( isset ( $ index [ 'client ' ] ) ) { $ client = $ this - > get Client ( $ index [ 'client ' ] ) ; $ index Def - > set Factory ( [ $ client , 'get Index ' ] ) ; } $ container - > set Definition ( $ index Id , $ index Def ) ; $ reference = new Reference ( $ index Id ) ; $ this - > index Configs [ $ name ] = [ 'elasticsearch _name ' = > $ index Name , 'reference ' = > $ reference , 'name ' = > $ name , 'settings ' = > $ index [ 'settings ' ] , 'type _prototype ' = > isset ( $ index [ 'type _prototype ' ] ) ? $ index [ 'type _prototype ' ] : [ ] , 'use _alias ' = > $ index [ 'use _alias ' ] , ] ; if ( $ index [ 'finder ' ] ) { $ this - > load Index Finder ( $ container , $ name , $ reference ) ; } $ this - > load Types ( ( array ) $ index [ 'types ' ] , $ container , $ this - > index Configs [ $ name ] , $ indexable Callbacks ) ; } $ indexable = $ container - > get Definition ( 'fos _elastica .indexable ' ) ; $ indexable - > replace Argument ( 0 , $ indexable Callbacks ) ; } 
private function load Index Templates ( array $ index Templates , Container Builder $ container ) { $ indexable Callbacks = array ( ) ; foreach ( $ index Templates as $ name = > $ index Template ) { $ index Id = sprintf ( 'fos _elastica .index _template . %s ' , $ name ) ; $ index Template Name = isset ( $ index Template [ 'template _name ' ] ) ? $ index Template [ 'template _name ' ] : $ name ; $ index Def = new Child Definition ( 'fos _elastica .index _template _prototype ' ) ; $ index Def - > set Factory ( [ new Reference ( 'fos _elastica .client ' ) , 'get Index Template ' ] ) ; $ index Def - > replace Argument ( 0 , $ index Template Name ) ; $ index Def - > add Tag ( 'fos _elastica .index _template ' , array ( 'name ' = > $ name , ) ) ; if ( isset ( $ index Template [ 'client ' ] ) ) { $ client = $ this - > get Client ( $ index Template [ 'client ' ] ) ; $ index Def - > set Factory ( [ $ client , 'get Index Template ' ] ) ; } $ container - > set Definition ( $ index Id , $ index Def ) ; $ reference = new Reference ( $ index Id ) ; $ this - > index Template Configs [ $ name ] = array ( 'elasticsearch _name ' = > $ index Template Name , 'reference ' = > $ reference , 'name ' = > $ name , 'settings ' = > $ index Template [ 'settings ' ] , 'template ' = > $ index Template [ 'template ' ] , ) ; $ this - > load Types ( ( array ) $ index Template [ 'types ' ] , $ container , $ this - > index Template Configs [ $ name ] , $ indexable Callbacks ) ; } if ( $ indexable Callbacks ) { throw new \ Runtime Exception ( ' `indexable _callback ` option is not supported by index templates ' ) ; } } 
private function load Index Finder ( Container Builder $ container , $ name , Reference $ index ) { $ transformer Id = sprintf ( 'fos _elastica .elastica _to _model _transformer .collection . %s ' , $ name ) ; $ transformer Def = new Child Definition ( 'fos _elastica .elastica _to _model _transformer .collection ' ) ; $ container - > set Definition ( $ transformer Id , $ transformer Def ) ; $ finder Id = sprintf ( 'fos _elastica .finder . %s ' , $ name ) ; $ finder Def = new Child Definition ( 'fos _elastica .finder ' ) ; $ finder Def - > replace Argument ( 0 , $ index ) ; $ finder Def - > replace Argument ( 1 , new Reference ( $ transformer Id ) ) ; $ container - > set Definition ( $ finder Id , $ finder Def ) ; } 
private function load Types ( array $ types , Container Builder $ container , array & $ index Config , array & $ indexable Callbacks ) { foreach ( $ types as $ name = > $ type ) { $ index Name = $ index Config [ 'name ' ] ; $ type Id = sprintf ( ' %s . %s ' , $ index Config [ 'reference ' ] , $ name ) ; $ type Def = new Child Definition ( 'fos _elastica .type _prototype ' ) ; $ type Def - > set Factory ( [ $ index Config [ 'reference ' ] , 'get Type ' ] ) ; $ type Def - > replace Argument ( 0 , $ name ) ; $ container - > set Definition ( $ type Id , $ type Def ) ; $ type Config = [ 'name ' = > $ name , 'mapping ' = > [ ] , 
private function load Type Persistence Integration ( array $ type Config , Container Builder $ container , Reference $ type Ref , $ index Name , $ type Name ) { if ( isset ( $ type Config [ 'driver ' ] ) ) { $ this - > load Driver ( $ container , $ type Config [ 'driver ' ] ) ; } $ elastica To Model Transformer Id = $ this - > load Elastica To Model Transformer ( $ type Config , $ container , $ index Name , $ type Name ) ; $ model To Elastica Transformer Id = $ this - > load Model To Elastica Transformer ( $ type Config , $ container , $ index Name , $ type Name ) ; $ object Persister Id = $ this - > load Object Persister ( $ type Config , $ type Ref , $ container , $ index Name , $ type Name , $ model To Elastica Transformer Id ) ; if ( isset ( $ type Config [ 'provider ' ] ) ) { $ this - > load Type Pager Provider ( $ type Config , $ container , $ index Name , $ type Name ) ; } if ( isset ( $ type Config [ 'finder ' ] ) ) { $ this - > load Type Finder ( $ type Config , $ container , $ elastica To Model Transformer Id , $ type Ref , $ index Name , $ type Name ) ; } if ( isset ( $ type Config [ 'listener ' ] ) & & $ type Config [ 'listener ' ] [ 'enabled ' ] ) { $ this - > load Type Listener ( $ type Config , $ container , $ object Persister Id , $ index Name , $ type Name ) ; } } 
private function load Elastica To Model Transformer ( array $ type Config , Container Builder $ container , $ index Name , $ type Name ) { if ( isset ( $ type Config [ 'elastica _to _model _transformer ' ] [ 'service ' ] ) ) { return $ type Config [ 'elastica _to _model _transformer ' ] [ 'service ' ] ; } $ abstract Id = sprintf ( 'fos _elastica .elastica _to _model _transformer .prototype . %s ' , $ type Config [ 'driver ' ] ) ; $ service Id = sprintf ( 'fos _elastica .elastica _to _model _transformer . %s . %s ' , $ index Name , $ type Name ) ; $ service Def = new Child Definition ( $ abstract Id ) ; $ service Def - > add Tag ( 'fos _elastica .elastica _to _model _transformer ' , [ 'type ' = > $ type Name , 'index ' = > $ index Name ] ) ; $ service Def - > replace Argument ( 1 , $ type Config [ 'model ' ] ) ; $ service Def - > replace Argument ( 2 , array _merge ( $ type Config [ 'elastica _to _model _transformer ' ] , [ 'identifier ' = > $ type Config [ 'identifier ' ] , ] ) ) ; $ container - > set Definition ( $ service Id , $ service Def ) ; return $ service Id ; } 
private function load Model To Elastica Transformer ( array $ type Config , Container Builder $ container , $ index Name , $ type Name ) { if ( isset ( $ type Config [ 'model _to _elastica _transformer ' ] [ 'service ' ] ) ) { return $ type Config [ 'model _to _elastica _transformer ' ] [ 'service ' ] ; } $ abstract Id = $ container - > has Definition ( 'fos _elastica .serializer _callback _prototype ' ) ? 'fos _elastica .model _to _elastica _identifier _transformer ' : 'fos _elastica .model _to _elastica _transformer ' ; $ service Id = sprintf ( 'fos _elastica .model _to _elastica _transformer . %s . %s ' , $ index Name , $ type Name ) ; $ service Def = new Child Definition ( $ abstract Id ) ; $ service Def - > replace Argument ( 0 , [ 'identifier ' = > $ type Config [ 'identifier ' ] , 'index ' = > $ index Name , ] ) ; $ container - > set Definition ( $ service Id , $ service Def ) ; return $ service Id ; } 
private function load Object Persister ( array $ type Config , Reference $ type Ref , Container Builder $ container , $ index Name , $ type Name , $ transformer Id ) { if ( isset ( $ type Config [ 'persister ' ] [ 'service ' ] ) ) { return $ type Config [ 'persister ' ] [ 'service ' ] ; } $ arguments = [ $ type Ref , new Reference ( $ transformer Id ) , $ type Config [ 'model ' ] , ] ; if ( $ container - > has Definition ( 'fos _elastica .serializer _callback _prototype ' ) ) { $ abstract Id = 'fos _elastica .object _serializer _persister ' ; $ callback Id = sprintf ( ' %s . %s .serializer .callback ' , $ this - > index Configs [ $ index Name ] [ 'reference ' ] , $ type Name ) ; $ arguments [ ] = [ new Reference ( $ callback Id ) , 'serialize ' ] ; } else { $ abstract Id = 'fos _elastica .object _persister ' ; $ mapping = $ this - > index Configs [ $ index Name ] [ 'types ' ] [ $ type Name ] [ 'mapping ' ] ; $ argument = $ mapping [ 'properties ' ] ; if ( isset ( $ mapping [ ' _parent ' ] ) ) { $ argument [ ' _parent ' ] = $ mapping [ ' _parent ' ] ; } $ arguments [ ] = $ argument ; } $ arguments [ ] = array _intersect _key ( $ type Config [ 'persister ' ] , array _flip ( [ 'refresh ' ] ) ) ; $ service Id = sprintf ( 'fos _elastica .object _persister . %s . %s ' , $ index Name , $ type Name ) ; $ service Def = new Child Definition ( $ abstract Id ) ; foreach ( $ arguments as $ i = > $ argument ) { $ service Def - > replace Argument ( $ i , $ argument ) ; } $ service Def - > add Tag ( 'fos _elastica .persister ' , [ 'index ' = > $ index Name , 'type ' = > $ type Name ] ) ; $ container - > set Definition ( $ service Id , $ service Def ) ; return $ service Id ; } 
private function load Type Pager Provider ( array $ type Config , Container Builder $ container , $ index Name , $ type Name ) { if ( isset ( $ type Config [ 'provider ' ] [ 'service ' ] ) ) { return $ type Config [ 'provider ' ] [ 'service ' ] ; } $ base Config = $ type Config [ 'provider ' ] ; unset ( $ base Config [ 'service ' ] ) ; $ driver = $ type Config [ 'driver ' ] ; switch ( $ driver ) { case 'orm ' : $ provider Def = new Child Definition ( 'fos _elastica .pager _provider .prototype . ' . $ driver ) ; $ provider Def - > replace Argument ( 2 , $ type Config [ 'model ' ] ) ; $ provider Def - > replace Argument ( 3 , $ base Config ) ; break ; case 'mongodb ' : $ provider Def = new Child Definition ( 'fos _elastica .pager _provider .prototype . ' . $ driver ) ; $ provider Def - > replace Argument ( 2 , $ type Config [ 'model ' ] ) ; $ provider Def - > replace Argument ( 3 , $ base Config ) ; break ; case 'phpcr ' : $ provider Def = new Child Definition ( 'fos _elastica .pager _provider .prototype . ' . $ driver ) ; $ provider Def - > replace Argument ( 2 , $ type Config [ 'model ' ] ) ; $ provider Def - > replace Argument ( 3 , $ base Config ) ; break ; default : throw new \ Logic Exception ( sprintf ( 'The pager provider for driver " %s " does not exist . ' , $ driver ) ) ; } $ provider Id = sprintf ( 'fos _elastica .pager _provider . %s . %s ' , $ index Name , $ type Name ) ; $ provider Def - > add Tag ( 'fos _elastica .pager _provider ' , [ 'index ' = > $ index Name , 'type ' = > $ type Name ] ) ; $ container - > set Definition ( $ provider Id , $ provider Def ) ; return $ provider Id ; } 
private function load Type Listener ( array $ type Config , Container Builder $ container , $ object Persister Id , $ index Name , $ type Name ) { if ( isset ( $ type Config [ 'listener ' ] [ 'service ' ] ) ) { return $ type Config [ 'listener ' ] [ 'service ' ] ; } $ abstract Listener Id = sprintf ( 'fos _elastica .listener .prototype . %s ' , $ type Config [ 'driver ' ] ) ; $ listener Id = sprintf ( 'fos _elastica .listener . %s . %s ' , $ index Name , $ type Name ) ; $ listener Def = new Child Definition ( $ abstract Listener Id ) ; $ listener Def - > replace Argument ( 0 , new Reference ( $ object Persister Id ) ) ; $ listener Def - > replace Argument ( 3 , $ type Config [ 'listener ' ] [ 'logger ' ] ? new Reference ( $ type Config [ 'listener ' ] [ 'logger ' ] ) : null ) ; $ listener Config = [ 'identifier ' = > $ type Config [ 'identifier ' ] , 'index Name ' = > $ index Name , 'type Name ' = > $ type Name , ] ; $ tag Name = null ; switch ( $ type Config [ 'driver ' ] ) { case 'orm ' : $ tag Name = 'doctrine .event _listener ' ; break ; case 'phpcr ' : $ tag Name = 'doctrine _phpcr .event _listener ' ; break ; case 'mongodb ' : $ tag Name = 'doctrine _mongodb .odm .event _listener ' ; break ; } if ( $ type Config [ 'listener ' ] [ 'defer ' ] ) { $ listener Def - > set Public ( true ) ; $ listener Def - > add Tag ( 'kernel .event _listener ' , [ 'event ' = > 'kernel .terminate ' , 'method ' = > 'on Terminate ' ] ) ; $ listener Def - > add Tag ( 'kernel .event _listener ' , [ 'event ' = > 'console .terminate ' , 'method ' = > 'on Terminate ' ] ) ; $ listener Config [ 'defer ' ] = true ; } $ listener Def - > replace Argument ( 2 , $ listener Config ) ; if ( null ! = = $ tag Name ) { foreach ( $ this - > get Doctrine Events ( $ type Config ) as $ event ) { $ listener Def - > add Tag ( $ tag Name , [ 'event ' = > $ event ] ) ; } } $ container - > set Definition ( $ listener Id , $ listener Def ) ; return $ listener Id ; } 
private function get Doctrine Events ( array $ type Config ) { switch ( $ type Config [ 'driver ' ] ) { case 'orm ' : $ events Class = ' \Doctrine \ORM \Events ' ; break ; case 'phpcr ' : $ events Class = ' \Doctrine \ODM \PHPCR \Event ' ; break ; case 'mongodb ' : $ events Class = ' \Doctrine \ODM \Mongo DB \Events ' ; break ; default : throw new \ Invalid Argument Exception ( sprintf ( 'Cannot determine events for driver " %s " ' , $ type Config [ 'driver ' ] ) ) ; } $ events = [ ] ; $ event Mapping = [ 'insert ' = > [ constant ( $ events Class . ' : :post Persist ' ) ] , 'update ' = > [ constant ( $ events Class . ' : :post Update ' ) ] , 'delete ' = > [ constant ( $ events Class . ' : :pre Remove ' ) ] , 'flush ' = > [ constant ( $ events Class . ' : :post Flush ' ) ] , ] ; foreach ( $ event Mapping as $ event = > $ doctrine Events ) { if ( isset ( $ type Config [ 'listener ' ] [ $ event ] ) & & $ type Config [ 'listener ' ] [ $ event ] ) { $ events = array _merge ( $ events , $ doctrine Events ) ; } } return $ events ; } 
private function load Type Finder ( array $ type Config , Container Builder $ container , $ elastica To Model Id , Reference $ type Ref , $ index Name , $ type Name ) { if ( isset ( $ type Config [ 'finder ' ] [ 'service ' ] ) ) { $ finder Id = $ type Config [ 'finder ' ] [ 'service ' ] ; } else { $ finder Id = sprintf ( 'fos _elastica .finder . %s . %s ' , $ index Name , $ type Name ) ; $ finder Def = new Child Definition ( 'fos _elastica .finder ' ) ; $ finder Def - > replace Argument ( 0 , $ type Ref ) ; $ finder Def - > replace Argument ( 1 , new Reference ( $ elastica To Model Id ) ) ; $ container - > set Definition ( $ finder Id , $ finder Def ) ; } $ index Type Name = " $index Name / $type Name " ; $ arguments = [ $ index Type Name , new Reference ( $ finder Id ) ] ; if ( isset ( $ type Config [ 'repository ' ] ) ) { $ arguments [ ] = $ type Config [ 'repository ' ] ; } $ container - > get Definition ( 'fos _elastica .repository _manager ' ) - > add Method Call ( 'add Type ' , $ arguments ) ; $ manager Id = sprintf ( 'fos _elastica .manager . %s ' , $ type Config [ 'driver ' ] ) ; $ container - > get Definition ( $ manager Id ) - > add Method Call ( 'add Entity ' , [ $ type Config [ 'model ' ] , $ index Type Name ] ) ; return $ finder Id ; } 
private function load Index Manager ( Container Builder $ container ) { $ index Refs = array _map ( function ( $ index ) { return $ index [ 'reference ' ] ; } , $ this - > index Configs ) ; $ manager Def = $ container - > get Definition ( 'fos _elastica .index _manager ' ) ; $ manager Def - > replace Argument ( 0 , $ index Refs ) ; } 
private function load Index Template Manager ( Container Builder $ container ) { $ index Template Refs = array _map ( function ( $ index ) { return $ index [ 'reference ' ] ; } , $ this - > index Template Configs ) ; $ manager Def = $ container - > get Definition ( 'fos _elastica .index _template _manager ' ) ; $ manager Def - > replace Argument ( 0 , $ index Template Refs ) ; } 
private function load Driver ( Container Builder $ container , $ driver ) { if ( in _array ( $ driver , $ this - > loaded Drivers ) ) { return ; } $ loader = new Xml File Loader ( $ container , new File Locator ( _ _DIR _ _ . ' / . . /Resources /config ' ) ) ; $ loader - > load ( $ driver . ' .xml ' ) ; $ this - > loaded Drivers [ ] = $ driver ; } 
private function load Serializer ( $ config , Container Builder $ container ) { $ container - > set Alias ( 'fos _elastica .serializer ' , $ config [ 'serializer ' ] ) ; $ serializer = $ container - > get Definition ( 'fos _elastica .serializer _callback _prototype ' ) ; $ serializer - > set Class ( $ config [ 'callback _class ' ] ) ; if ( is _subclass _of ( $ config [ 'callback _class ' ] , Container Aware Interface : : class ) ) { $ serializer - > add Method Call ( 'set Container ' , [ new Reference ( 'service _container ' ) ] ) ; } } 
private function create Default Manager Alias ( $ default Manager , Container Builder $ container ) { if ( 0 = = count ( $ this - > loaded Drivers ) ) { return ; } if ( count ( $ this - > loaded Drivers ) > 1 & & in _array ( $ default Manager , $ this - > loaded Drivers ) ) { $ default Manager Service = $ default Manager ; } else { $ default Manager Service = $ this - > loaded Drivers [ 0 ] ; } $ container - > set Alias ( 'fos _elastica .manager ' , sprintf ( 'fos _elastica .manager . %s ' , $ default Manager Service ) ) ; $ container - > get Alias ( 'fos _elastica .manager ' ) - > set Public ( true ) ; $ container - > set Alias ( Repository Manager Interface : : class , 'fos _elastica .manager ' ) ; $ container - > get Alias ( Repository Manager Interface : : class ) - > set Public ( false ) ; } 
public function get Config Tree Builder ( ) { $ tree Builder = new Tree Builder ( 'fos _elastica ' ) ; if ( method _exists ( $ tree Builder , 'get Root Node ' ) ) { $ root Node = $ tree Builder - > get Root Node ( ) ; } else { 
private function get Dynamic Template Node ( ) { $ node = $ this - > create Tree Builder Node ( 'dynamic _templates ' ) ; $ node - > prototype ( 'array ' ) - > prototype ( 'array ' ) - > children ( ) - > scalar Node ( 'match ' ) - > end ( ) - > scalar Node ( 'unmatch ' ) - > end ( ) - > scalar Node ( 'match _mapping _type ' ) - > end ( ) - > scalar Node ( 'path _match ' ) - > end ( ) - > scalar Node ( 'path _unmatch ' ) - > end ( ) - > scalar Node ( 'match _pattern ' ) - > end ( ) - > array Node ( 'mapping ' ) - > prototype ( 'variable ' ) - > treat Null Like ( [ ] ) - > end ( ) - > end ( ) - > end ( ) - > end ( ) - > end ( ) ; return $ node ; } 
private function get Types Node ( ) { $ node = $ this - > create Tree Builder Node ( 'types ' ) ; $ node - > use Attribute As Key ( 'name ' ) - > prototype ( 'array ' ) - > treat Null Like ( [ ] ) - > before Normalization ( ) - > if Null ( ) - > then Empty Array ( ) - > end ( ) 
private function get Id Node ( ) { $ node = $ this - > create Tree Builder Node ( ' _id ' ) ; $ node - > children ( ) - > scalar Node ( 'path ' ) - > end ( ) - > end ( ) ; return $ node ; } 
private function get Source Node ( ) { $ node = $ this - > create Tree Builder Node ( ' _source ' ) ; $ node - > children ( ) - > array Node ( 'excludes ' ) - > use Attribute As Key ( 'name ' ) - > prototype ( 'scalar ' ) - > end ( ) - > end ( ) - > array Node ( 'includes ' ) - > use Attribute As Key ( 'name ' ) - > prototype ( 'scalar ' ) - > end ( ) - > end ( ) - > scalar Node ( 'compress ' ) - > end ( ) - > scalar Node ( 'compress _threshold ' ) - > end ( ) - > scalar Node ( 'enabled ' ) - > default True ( ) - > end ( ) - > end ( ) ; return $ node ; } 
private function get Routing Node ( ) { $ node = $ this - > create Tree Builder Node ( ' _routing ' ) ; $ node - > children ( ) - > scalar Node ( 'required ' ) - > end ( ) - > scalar Node ( 'path ' ) - > end ( ) - > end ( ) ; return $ node ; } 
private function get Parent Node ( ) { $ node = $ this - > create Tree Builder Node ( ' _parent ' ) ; $ node - > children ( ) - > scalar Node ( 'type ' ) - > end ( ) - > scalar Node ( 'property ' ) - > default Value ( null ) - > end ( ) - > scalar Node ( 'identifier ' ) - > default Value ( 'id ' ) - > end ( ) - > end ( ) ; return $ node ; } 
private function get All Node ( ) { $ node = $ this - > create Tree Builder Node ( ' _all ' ) ; $ node - > children ( ) - > scalar Node ( 'enabled ' ) - > default Value ( true ) - > end ( ) - > scalar Node ( 'analyzer ' ) - > end ( ) - > end ( ) ; return $ node ; } 
private function add Clients Section ( Array Node Definition $ root Node ) { $ root Node - > fix Xml Config ( 'client ' ) - > children ( ) - > array Node ( 'clients ' ) - > use Attribute As Key ( 'id ' ) - > prototype ( 'array ' ) - > perform No Deep Merging ( ) 
private function add Indexes Section ( Array Node Definition $ root Node ) { $ root Node - > fix Xml Config ( 'index ' ) - > children ( ) - > array Node ( 'indexes ' ) - > use Attribute As Key ( 'name ' ) - > prototype ( 'array ' ) - > children ( ) - > scalar Node ( 'index _name ' ) - > info ( 'Defaults to the name of the index , but can be modified if the index name is different in Elastic Search ' ) - > end ( ) - > boolean Node ( 'use _alias ' ) - > default Value ( false ) - > end ( ) - > scalar Node ( 'client ' ) - > end ( ) - > scalar Node ( 'finder ' ) - > treat Null Like ( true ) - > default False ( ) - > end ( ) - > array Node ( 'type _prototype ' ) - > children ( ) - > scalar Node ( 'analyzer ' ) - > end ( ) - > append ( $ this - > get Persistence Node ( ) ) - > append ( $ this - > get Serializer Node ( ) ) - > end ( ) - > end ( ) - > variable Node ( 'settings ' ) - > default Value ( [ ] ) - > end ( ) - > end ( ) - > append ( $ this - > get Types Node ( ) ) - > end ( ) - > end ( ) - > end ( ) ; } 
private function add Index Templates Section ( Array Node Definition $ root Node ) { $ root Node - > fix Xml Config ( 'index _template ' ) - > children ( ) - > array Node ( 'index _templates ' ) - > use Attribute As Key ( 'name ' ) - > prototype ( 'array ' ) - > children ( ) - > scalar Node ( 'template _name ' ) - > info ( 'Defaults to the name of the index template , but can be modified if the index name is different in Elastic Search ' ) - > end ( ) - > scalar Node ( 'template ' ) - > is Required ( ) - > end ( ) - > scalar Node ( 'client ' ) - > end ( ) - > variable Node ( 'settings ' ) - > default Value ( [ ] ) - > end ( ) - > end ( ) - > append ( $ this - > get Types Node ( ) ) - > end ( ) - > end ( ) - > end ( ) ; } 
public function transform ( array $ elastica Objects ) { $ ids = $ highlights = [ ] ; foreach ( $ elastica Objects as $ elastica Object ) { $ ids [ ] = $ elastica Object - > get Id ( ) ; $ highlights [ $ elastica Object - > get Id ( ) ] = $ elastica Object - > get Highlights ( ) ; } $ objects = $ this - > find By Identifiers ( $ ids , $ this - > options [ 'hydrate ' ] ) ; $ objects Cnt = count ( $ objects ) ; $ elastica Objects Cnt = count ( $ elastica Objects ) ; if ( ! $ this - > options [ 'ignore _missing ' ] & & $ objects Cnt < $ elastica Objects Cnt ) { throw new \ Runtime Exception ( sprintf ( 'Cannot find corresponding Doctrine objects ( %d ) for all Elastica results ( %d ) . IDs : %s ' , $ objects Cnt , $ elastica Objects Cnt , implode ( ' , ' , $ ids ) ) ) ; } $ property Accessor = $ this - > property Accessor ; $ identifier = $ this - > options [ 'identifier ' ] ; foreach ( $ objects as $ object ) { if ( $ object instanceof Highlightable Model Interface ) { $ id = $ property Accessor - > get Value ( $ object , $ identifier ) ; $ object - > set Elastic Highlights ( $ highlights [ ( string ) $ id ] ) ; } } 
public function process ( Container Builder $ container ) { if ( ! $ container - > has Definition ( 'fos _elastica .elastica _to _model _transformer .collection ' ) ) { return ; } $ transformers = [ ] ; foreach ( $ container - > find Tagged Service Ids ( 'fos _elastica .elastica _to _model _transformer ' ) as $ id = > $ tags ) { foreach ( $ tags as $ tag ) { if ( empty ( $ tag [ 'index ' ] ) | | empty ( $ tag [ 'type ' ] ) ) { throw new Invalid Argument Exception ( 'The Transformer must have both a type and an index defined . ' ) ; } $ transformers [ $ tag [ 'index ' ] ] [ $ tag [ 'type ' ] ] = new Reference ( $ id ) ; } } foreach ( $ transformers as $ index = > $ index Transformers ) { if ( ! $ container - > has Definition ( sprintf ( 'fos _elastica .elastica _to _model _transformer .collection . %s ' , $ index ) ) ) { continue ; } $ index = $ container - > get Definition ( sprintf ( 'fos _elastica .elastica _to _model _transformer .collection . %s ' , $ index ) ) ; $ index - > replace Argument ( 0 , $ index Transformers ) ; } } 
protected function find By Identifiers ( array $ identifier Values , $ hydrate ) { return $ this - > registry - > get Manager For Class ( $ this - > object Class ) - > get Repository ( $ this - > object Class ) - > { $ this - > options [ 'query _builder _method ' ] } ( $ this - > object Class ) - > field ( $ this - > options [ 'identifier ' ] ) - > in ( $ identifier Values ) - > hydrate ( $ hydrate ) - > get Query ( ) - > execute ( ) - > to Array ( ) ; } 
public function is Object Indexable ( $ index Name , $ type Name , $ object ) { $ type = sprintf ( ' %s / %s ' , $ index Name , $ type Name ) ; $ callback = $ this - > get Callback ( $ type , $ object ) ; if ( ! $ callback ) { return true ; } if ( $ callback instanceof Expression ) { return ( bool ) $ this - > get Expression Language ( ) - > evaluate ( $ callback , [ 'object ' = > $ object , $ this - > get Expression Var ( $ object ) = > $ object , ] ) ; } return is _string ( $ callback ) ? call _user _func ( [ $ object , $ callback ] ) : call _user _func ( $ callback , $ object ) ; } 
private function build Callback ( $ type , $ object ) { if ( ! array _key _exists ( $ type , $ this - > callbacks ) ) { return null ; } $ callback = $ this - > callbacks [ $ type ] ; if ( is _callable ( $ callback ) or is _callable ( [ $ object , $ callback ] ) ) { return $ callback ; } if ( is _string ( $ callback ) ) { return $ this - > build Expression Callback ( $ type , $ object , $ callback ) ; } throw new \ Invalid Argument Exception ( sprintf ( 'Callback for type " %s " is not a valid callback . ' , $ type ) ) ; } 
private function build Expression Callback ( $ type , $ object , $ callback ) { $ expression = $ this - > get Expression Language ( ) ; if ( ! $ expression ) { throw new \ Runtime Exception ( 'Unable to process an expression without the Expression Language component . ' ) ; } try { $ callback = new Expression ( $ callback ) ; $ expression - > compile ( $ callback , [ 'object ' , $ this - > get Expression Var ( $ object ) , ] ) ; return $ callback ; } catch ( Syntax Error $ e ) { throw new \ Invalid Argument Exception ( sprintf ( 'Callback for type " %s " is an invalid expression ' , $ type ) , $ e - > get Code ( ) , $ e ) ; } } 
private function get Callback ( $ type , $ object ) { if ( ! array _key _exists ( $ type , $ this - > initialised Callbacks ) ) { $ this - > initialised Callbacks [ $ type ] = $ this - > build Callback ( $ type , $ object ) ; } return $ this - > initialised Callbacks [ $ type ] ; } 
private function get Expression Var ( $ object = null ) { if ( ! is _object ( $ object ) ) { return 'object ' ; } $ ref = new \ Reflection Class ( $ object ) ; return strtolower ( $ ref - > get Short Name ( ) ) ; } 
public function get Index Configuration ( $ index Name ) { if ( ! $ this - > has Index Configuration ( $ index Name ) ) { throw new \ Invalid Argument Exception ( sprintf ( 'Index with name " %s " is not configured . ' , $ index Name ) ) ; } return $ this - > indexes [ $ index Name ] ; } 
public function get Type Configuration ( $ index Name , $ type Name ) { $ index = $ this - > get Index Configuration ( $ index Name ) ; $ type = $ index - > get Type ( $ type Name ) ; if ( ! $ type ) { throw new \ Invalid Argument Exception ( sprintf ( 'Type with name " %s " on index " %s " is not configured ' , $ type Name , $ index Name ) ) ; } return $ type ; } 
public function set Root Name ( Index Config $ index Config , Index $ index ) { $ index - > override Name ( sprintf ( ' %s _ %s ' , $ index Config - > get Elastic Search Name ( ) , date ( 'Y -m -d -His ' ) ) ) ; } 
public function switch Index Alias ( Index Config $ index Config , Index $ index , $ force = false , $ delete = true ) { $ client = $ index - > get Client ( ) ; $ alias Name = $ index Config - > get Elastic Search Name ( ) ; $ old Index Name = null ; $ new Index Name = $ index - > get Name ( ) ; try { $ old Index Name = $ this - > get Aliased Index ( $ client , $ alias Name ) ; } catch ( Alias Is Index Exception $ e ) { if ( ! $ force ) { throw $ e ; } if ( $ delete ) { $ this - > delete Index ( $ client , $ alias Name ) ; } else { $ this - > close Index ( $ client , $ alias Name ) ; } } try { $ alias Update Request = $ this - > build Alias Update Request ( $ old Index Name , $ alias Name , $ new Index Name ) ; $ client - > request ( ' _aliases ' , 'POST ' , $ alias Update Request ) ; } catch ( Exception Interface $ e ) { $ this - > cleanup Rename Failure ( $ client , $ new Index Name , $ e ) ; } 
private function build Alias Update Request ( $ aliased Index , $ alias Name , $ new Index Name ) { $ alias Update Request = [ 'actions ' = > [ ] ] ; if ( null ! = = $ aliased Index ) { 
private function cleanup Rename Failure ( Client $ client , $ index Name , \ Exception $ rename Alias Exception ) { $ additional Error = ' ' ; try { $ this - > delete Index ( $ client , $ index Name ) ; } catch ( Exception Interface $ delete New Index Exception ) { $ additional Error = sprintf ( 'Tried to delete newly built index %s , but also failed : %s ' , $ index Name , $ delete New Index Exception - > get Message ( ) ) ; } throw new \ Runtime Exception ( sprintf ( 'Failed to updated index alias : %s . %s ' , $ rename Alias Exception - > get Message ( ) , $ additional Error ? : sprintf ( 'Newly built index %s was deleted ' , $ index Name ) ) , 0 , $ rename Alias Exception ) ; } 
private function delete Index ( Client $ client , $ index Name ) { try { $ path = sprintf ( ' %s ' , $ index Name ) ; $ client - > request ( $ path , Request : : DELETE ) ; } catch ( Exception Interface $ delete Old Index Exception ) { throw new \ Runtime Exception ( sprintf ( 'Failed to delete index %s with message : %s ' , $ index Name , $ delete Old Index Exception - > get Message ( ) ) , 0 , $ delete Old Index Exception ) ; } } 
private function close Index ( Client $ client , $ index Name ) { try { $ path = sprintf ( ' %s / _close ' , $ index Name ) ; $ client - > request ( $ path , Request : : POST ) ; } catch ( Exception Interface $ e ) { throw new \ Runtime Exception ( sprintf ( 'Failed to close index %s with message : %s ' , $ index Name , $ e - > get Message ( ) ) , 0 , $ e ) ; } } 
private function get Aliased Index ( Client $ client , $ alias Name ) { $ aliases Info = $ client - > request ( ' _aliases ' , 'GET ' ) - > get Data ( ) ; $ aliased Indexes = [ ] ; foreach ( $ aliases Info as $ index Name = > $ index Info ) { if ( $ index Name = = = $ alias Name ) { throw new Alias Is Index Exception ( $ index Name ) ; } if ( ! isset ( $ index Info [ 'aliases ' ] ) ) { continue ; } $ aliases = array _keys ( $ index Info [ 'aliases ' ] ) ; if ( in _array ( $ alias Name , $ aliases ) ) { $ aliased Indexes [ ] = $ index Name ; } } if ( count ( $ aliased Indexes ) > 1 ) { throw new \ Runtime Exception ( sprintf ( 'Alias %s is used for multiple indexes : [ %s ] . Make sure it \ 's ' . 'either not used or is assigned to one index only ' , $ alias Name , implode ( ' , ' , $ aliased Indexes ) ) ) ; } return array _shift ( $ aliased Indexes ) ; } 
public function request ( $ path , $ method = Request : : GET , $ data = [ ] , array $ query = [ ] , $ content Type = Request : : DEFAULT _CONTENT _TYPE ) { if ( $ this - > stopwatch ) { $ this - > stopwatch - > start ( 'es _request ' , 'fos _elastica ' ) ; } $ response = parent : : request ( $ path , $ method , $ data , $ query , $ content Type ) ; $ response Data = $ response - > get Data ( ) ; $ transport Info = $ response - > get Transfer Info ( ) ; $ connection = $ this - > get Last Request ( ) - > get Connection ( ) ; $ forbidden Http Codes = $ connection - > has Config ( 'http _error _codes ' ) ? $ connection - > get Config ( 'http _error _codes ' ) : [ ] ; if ( isset ( $ transport Info [ 'http _code ' ] ) & & in _array ( $ transport Info [ 'http _code ' ] , $ forbidden Http Codes , true ) ) { $ body = is _array ( $ response Data ) ? json _encode ( $ response Data ) : $ response Data ; $ message = sprintf ( 'Error in transport Info : response code is %s , response body is %s ' , $ transport Info [ 'http _code ' ] , $ body ) ; throw new Client Exception ( $ message ) ; } if ( isset ( $ response Data [ 'took ' ] ) & & isset ( $ response Data [ 'hits ' ] ) ) { $ this - > log Query ( $ path , $ method , $ data , $ query , $ response - > get Query Time ( ) , $ response - > get Engine Time ( ) , $ response Data [ 'hits ' ] [ 'total ' ] ) ; } else { $ this - > log Query ( $ path , $ method , $ data , $ query , $ response - > get Query Time ( ) , 0 , 0 ) ; } if ( $ this - > stopwatch ) { $ this - > stopwatch - > stop ( 'es _request ' ) ; } return $ response ; } 
public function get Index ( $ name ) { if ( isset ( $ this - > index Cache [ $ name ] ) ) { return $ this - > index Cache [ $ name ] ; } return $ this - > index Cache [ $ name ] = new Index ( $ this , $ name ) ; } 
private function log Query ( $ path , $ method , $ data , array $ query , $ query Time , $ engine MS = 0 , $ item Count = 0 ) { if ( ! $ this - > _logger or ! $ this - > _logger instanceof Elastica Logger ) { return ; } $ connection = $ this - > get Last Request ( ) - > get Connection ( ) ; $ connection Array = [ 'host ' = > $ connection - > get Host ( ) , 'port ' = > $ connection - > get Port ( ) , 'transport ' = > $ connection - > get Transport ( ) , 'headers ' = > $ connection - > has Config ( 'headers ' ) ? $ connection - > get Config ( 'headers ' ) : [ ] , ] ; $ logger = $ this - > _logger ; $ logger - > log Query ( $ path , $ method , $ data , $ query Time , $ connection Array , $ query , $ engine MS , $ item Count ) ; } 
public function find ( $ query , $ limit = null , $ options = [ ] ) { return $ this - > finder - > find ( $ query , $ limit , $ options ) ; } 
public function find Hybrid ( $ query , $ limit = null , $ options = [ ] ) { return $ this - > finder - > find Hybrid ( $ query , $ limit , $ options ) ; } 
public function post Persist ( Lifecycle Event Args $ event Args ) { $ entity = $ event Args - > get Object ( ) ; if ( $ this - > object Persister - > handles Object ( $ entity ) & & $ this - > is Object Indexable ( $ entity ) ) { $ this - > scheduled For Insertion [ ] = $ entity ; } } 
public function post Update ( Lifecycle Event Args $ event Args ) { $ entity = $ event Args - > get Object ( ) ; if ( $ this - > object Persister - > handles Object ( $ entity ) ) { if ( $ this - > is Object Indexable ( $ entity ) ) { $ this - > scheduled For Update [ ] = $ entity ; } else { 
public function pre Remove ( Lifecycle Event Args $ event Args ) { $ entity = $ event Args - > get Object ( ) ; if ( $ this - > object Persister - > handles Object ( $ entity ) ) { $ this - > schedule For Deletion ( $ entity ) ; } } 
private function persist Scheduled ( ) { if ( $ this - > should Persist ( ) ) { if ( count ( $ this - > scheduled For Insertion ) ) { $ this - > object Persister - > insert Many ( $ this - > scheduled For Insertion ) ; $ this - > scheduled For Insertion = [ ] ; } if ( count ( $ this - > scheduled For Update ) ) { $ this - > object Persister - > replace Many ( $ this - > scheduled For Update ) ; $ this - > scheduled For Update = [ ] ; } if ( count ( $ this - > scheduled For Deletion ) ) { $ this - > object Persister - > delete Many By Identifiers ( $ this - > scheduled For Deletion ) ; $ this - > scheduled For Deletion = [ ] ; } } } 
private function schedule For Deletion ( $ object ) { if ( $ identifier Value = $ this - > property Accessor - > get Value ( $ object , $ this - > config [ 'identifier ' ] ) ) { $ this - > scheduled For Deletion [ ] = ! is _scalar ( $ identifier Value ) ? ( string ) $ identifier Value : $ identifier Value ; } } 
private function is Object Indexable ( $ object ) { return $ this - > indexable - > is Object Indexable ( $ this - > config [ 'index Name ' ] , $ this - > config [ 'type Name ' ] , $ object ) ; } 
public function get Repository ( $ entity Name ) { $ real Entity Name = $ entity Name ; if ( false ! = = strpos ( $ entity Name , ' : ' ) ) { list ( $ namespace Alias , $ simple Class Name ) = explode ( ' : ' , $ entity Name ) ; $ real Entity Name = $ this - > manager Registry - > get Alias Namespace ( $ namespace Alias ) . ' \ \ ' . $ simple Class Name ; } if ( isset ( $ this - > entities [ $ real Entity Name ] ) ) { $ real Entity Name = $ this - > entities [ $ real Entity Name ] ; } return $ this - > repository Manager - > get Repository ( $ real Entity Name ) ; } 
protected function find By Identifiers ( array $ identifier Values , $ hydrate ) { return $ this - > registry - > get Manager ( ) - > get Repository ( $ this - > object Class ) - > find Many ( $ identifier Values ) - > to Array ( ) ; } 
public function transform ( $ object , array $ fields ) { $ identifier = $ this - > property Accessor - > get Value ( $ object , $ this - > options [ 'identifier ' ] ) ; return new Document ( $ identifier ) ; } 
public function get Repository ( $ type Name ) { if ( isset ( $ this - > repositories [ $ type Name ] ) ) { return $ this - > repositories [ $ type Name ] ; } if ( ! isset ( $ this - > types [ $ type Name ] ) ) { throw new Runtime Exception ( sprintf ( 'No search finder configured for %s ' , $ type Name ) ) ; } $ repository = $ this - > create Repository ( $ type Name ) ; $ this - > repositories [ $ type Name ] = $ repository ; return $ repository ; } 
private function create Repository ( $ type Name ) { if ( ! class _exists ( $ repository Name = $ this - > get Repository Name ( $ type Name ) ) ) { throw new Runtime Exception ( sprintf ( ' %s repository for %s does not exist ' , $ repository Name , $ type Name ) ) ; } return new $ repository Name ( $ this - > types [ $ type Name ] [ 'finder ' ] ) ; } 
public function make ( array $ config ) : Hashids { $ config = $ this - > get Config ( $ config ) ; return $ this - > get Client ( $ config ) ; } 
protected function register Factory ( ) : void { $ this - > app - > singleton ( 'hashids .factory ' , function ( ) { return new Hashids Factory ( ) ; } ) ; $ this - > app - > alias ( 'hashids .factory ' , Hashids Factory : : class ) ; } 
public function execute ( $ request ) { Request Not Supported Exception : : assert Supports ( $ this , $ request ) ; $ this - > gateway - > execute ( $ http Request = new Get Http Request ( ) ) ; if ( 'POST ' = = $ http Request - > method & & false = = empty ( $ http Request - > request [ 'confirm ' ] ) ) { return ; } $ render Template = new Render Template ( $ this - > template Name , array ( 'model ' = > Array Object : : ensure Array Object ( $ request - > get Model ( ) ) , 'first Model ' = > $ request - > get First Model ( ) , ) ) ; $ this - > gateway - > execute ( $ render Template ) ; throw new Http Response ( $ render Template - > get Result ( ) ) ; } 
public function execute ( $ request ) { Request Not Supported Exception : : assert Supports ( $ this , $ request ) ; $ model = Array Object : : ensure Array Object ( $ request - > get Model ( ) ) ; if ( $ model [ 'status ' ] ) { return ; } if ( $ model [ 'customer ' ] ) { } else { if ( false = = $ model [ 'card ' ] ) { $ obtain Token = new Obtain Token ( $ request - > get Token ( ) ) ; $ obtain Token - > set Model ( $ model ) ; $ this - > gateway - > execute ( $ obtain Token ) ; } } $ this - > gateway - > execute ( new Create Charge ( $ model ) ) ; } 
public function execute ( $ request ) { Request Not Supported Exception : : assert Supports ( $ this , $ request ) ; $ this - > gateway - > execute ( new Refund Transaction ( $ request - > get Model ( ) ) ) ; $ this - > gateway - > execute ( new Sync ( $ request - > get Model ( ) ) ) ; } 
public function create Config ( array $ config = array ( ) ) { $ config = Array Object : : ensure Array Object ( $ config ) ; $ config - > defaults ( $ this - > default Config ) ; $ config - > defaults ( $ this - > core Gateway Factory - > create Config ( ( array ) $ config ) ) ; $ this - > populate Config ( $ config ) ; return ( array ) $ config ; } 
protected function populate Config ( Array Object $ config ) { if ( false = = class _exists ( Sofortueberweisung : : class ) ) { throw new Logic Exception ( 'You must install "sofort /sofortlib -php : ^ 3 . 0 " library . ' ) ; } $ config - > defaults ( array ( 'payum .factory _name ' = > 'sofort ' , 'payum .factory _title ' = > 'Sofort ' , 'payum .action .capture ' = > new Capture Action ( ) , 'payum .action .status ' = > new Status Action ( ) , 'payum .action .notify ' = > new Notify Action ( ) , 'payum .action .sync ' = > new Sync Action ( ) , 'payum .action .refund ' = > new Refund Action ( ) , 'payum .action .convert _payment ' = > new Convert Payment Action ( ) , 'payum .action .api .create _transaction ' = > new Create Transaction Action ( ) , 'payum .action .api .get _transaction _data ' = > new Get Transaction Data Action ( ) , 'payum .action .api .refund _transaction ' = > new Refund Transaction Action ( ) , ) ) ; if ( false = = $ config [ 'payum .api ' ] ) { $ config [ 'payum .default _options ' ] = [ 'config _key ' = > ' ' , 'abort _url ' = > ' ' , 'disable _notification ' = > false , ] ; $ config - > defaults ( $ config [ 'payum .default _options ' ] ) ; $ config [ 'payum .required _options ' ] = [ 'config _key ' ] ; $ config [ 'payum .api ' ] = function ( Array Object $ config ) { $ config - > validate Not Empty ( $ config [ 'payum .required _options ' ] ) ; if ( false = = preg _match ( ' / . * \ : . * \ : . * / ' , $ config [ 'config _key ' ] ) ) { throw new \ Logic Exception ( 'The config _key is invalid . It must match the regexp " / . * \ : . * \ : . * / " . ' ) ; } return new Api ( [ 'config _key ' = > $ config [ 'config _key ' ] , 'abort _url ' = > $ config [ 'abort _url ' ] , 'disable _notification ' = > $ config [ 'disable _notification ' ] , ] ) ; } ; } } 
public function execute ( $ request ) { Request Not Supported Exception : : assert Supports ( $ this , $ request ) ; $ model = Array Object : : ensure Array Object ( $ request - > get Model ( ) ) ; if ( $ model [ 'location ' ] ) { $ this - > gateway - > execute ( $ fetch Order = new Fetch Order ( $ model ) ) ; $ model - > replace ( $ fetch Order - > get Order ( ) - > marshal ( ) ) ; } } 
public function execute ( $ request ) { Request Not Supported Exception : : assert Supports ( $ this , $ request ) ; $ model = Array Object : : ensure Array Object ( $ request - > get Model ( ) ) ; if ( $ model [ 'error ' ] ) { $ request - > mark Failed ( ) ; return ; } if ( false = = $ model [ 'status ' ] & & false = = $ model [ 'card ' ] ) { $ request - > mark New ( ) ; return ; } if ( false = = $ model [ 'status ' ] & & $ model [ 'card ' ] ) { $ request - > mark Pending ( ) ; return ; } if ( Constants : : STATUS _FAILED = = $ model [ 'status ' ] ) { $ request - > mark Failed ( ) ; return ; } if ( $ model [ 'refunded ' ] ) { $ request - > mark Refunded ( ) ; return ; } if ( Constants : : STATUS _SUCCEEDED = = $ model [ 'status ' ] & & $ model [ 'captured ' ] & & $ model [ 'paid ' ] ) { $ request - > mark Captured ( ) ; return ; } if ( Constants : : STATUS _PAID = = $ model [ 'status ' ] & & $ model [ 'captured ' ] & & $ model [ 'paid ' ] ) { $ request - > mark Captured ( ) ; return ; } if ( Constants : : STATUS _SUCCEEDED = = $ model [ 'status ' ] & & false = = $ model [ 'captured ' ] ) { $ request - > mark Authorized ( ) ; return ; } if ( Constants : : STATUS _PAID = = $ model [ 'status ' ] & & false = = $ model [ 'captured ' ] ) { $ request - > mark Authorized ( ) ; return ; } $ request - > mark Unknown ( ) ; } 
public function on Execute ( Context $ context ) { $ action = $ context - > get Action ( ) ; if ( $ action instanceof Generic Token Factory Aware Interface ) { $ action - > set Generic Token Factory ( $ this - > generic Token Factory ) ; } } 
public function on Post Execute ( Context $ context ) { $ action = $ context - > get Action ( ) ; if ( $ action instanceof Generic Token Factory Aware Interface ) { $ action - > set Generic Token Factory ( null ) ; } } 
protected function populate Config ( Array Object $ config ) { $ config - > defaults ( [ 'payum .factory _name ' = > 'be 2bill _offsite ' , 'payum .factory _title ' = > 'Be 2Bill Offsite ' , 'payum .action .capture ' = > new Capture Offsite Action ( ) , 'payum .action .capture _null ' = > new Capture Offsite Null Action ( ) , 'payum .action .notify _null ' = > new Notify Null Action ( ) , 'payum .action .notify ' = > new Notify Action ( ) , ] ) ; parent : : populate Config ( $ config ) ; } 
public function execute ( $ request ) { Request Not Supported Exception : : assert Supports ( $ this , $ request ) ; $ model = Array Object : : ensure Array Object ( $ request - > get Model ( ) ) ; if ( $ model [ 'card ' ] ) { throw new Logic Exception ( 'The token has already been set . ' ) ; } $ get Http Request = new Get Http Request ( ) ; $ this - > gateway - > execute ( $ get Http Request ) ; if ( $ get Http Request - > method = = 'POST ' & & isset ( $ get Http Request - > request [ 'stripe Token ' ] ) ) { $ model [ 'card ' ] = $ get Http Request - > request [ 'stripe Token ' ] ; return ; } $ this - > gateway - > execute ( $ render Template = new Render Template ( $ this - > template Name , array ( 'model ' = > $ model , 'publishable _key ' = > $ this - > keys - > get Publishable Key ( ) , 'action Url ' = > $ request - > get Token ( ) ? $ request - > get Token ( ) - > get Target Url ( ) : null , ) ) ) ; throw new Http Response ( $ render Template - > get Result ( ) ) ; } 
public function set Holder ( $ holder ) { $ this - > secured Holder = Sensitive Value : : ensure Sensitive ( $ holder ) ; $ this - > masked Holder = Mask : : mask ( $ this - > secured Holder - > peek ( ) ) ; 
public function set Number ( $ number ) { $ this - > secured Number = Sensitive Value : : ensure Sensitive ( $ number ) ; $ this - > masked Number = Mask : : mask ( $ this - > secured Number - > peek ( ) ) ; 
public function set Security Code ( $ security Code ) { $ this - > secured Security Code = Sensitive Value : : ensure Sensitive ( $ security Code ) ; 
public function set Expire At ( $ date = null ) { $ date = Sensitive Value : : ensure Sensitive ( $ date ) ; if ( false = = ( null = = = $ date - > peek ( ) | | $ date - > peek ( ) instanceof \ Date Time ) ) { throw new Invalid Argument Exception ( 'The date argument must be either instance of Date Time or null ' ) ; } $ this - > secured Expire At = $ date ; 
public function secure ( ) { $ this - > holder = $ this - > number = $ this - > expire At = $ this - > security Code = null ; } 
public function set Details ( $ details ) { if ( $ details instanceof \ Traversable ) { $ details = iterator _to _array ( $ details ) ; } $ this - > details = $ details ; } 
public function execute ( $ request ) { Request Not Supported Exception : : assert Supports ( $ this , $ request ) ; $ model = Array Object : : ensure Array Object ( $ request - > get Model ( ) ) ; if ( $ model [ Constants : : FIELD _PAYOUT ] ) { $ model [ Constants : : FIELD _STATUS ] = Constants : : STATUS _PAYEDOUT ; } else { $ model [ Constants : : FIELD _STATUS ] = Constants : : STATUS _PENDING ; } } 
public function execute ( $ request ) { Request Not Supported Exception : : assert Supports ( $ this , $ request ) ; $ model = Array Object : : ensure Array Object ( $ request - > get Model ( ) ) ; $ model - > validate Not Empty ( [ 'subtotal ' , 'currency _code ' , ] ) ; $ result = $ this - > api - > do Create Button ( ( array ) $ model ) ; $ model - > replace ( ( array ) $ result ) ; if ( $ model [ 'EMAILLINK ' ] ! = null ) { throw new Http Redirect ( $ model [ 'EMAILLINK ' ] ) ; } } 
public function execute ( $ request ) { Request Not Supported Exception : : assert Supports ( $ this , $ request ) ; $ this - > gateway - > execute ( new Sync ( $ request - > get Model ( ) ) ) ; } 
public function payment ( array $ params ) { $ params [ 'OPERATIONTYPE ' ] = static : : OPERATION _PAYMENT ; $ this - > add Global Params ( $ params ) ; return $ this - > do Request ( [ 'method ' = > 'payment ' , 'params ' = > $ params ] ) ; } 
public function verify Hash ( array $ params ) { if ( empty ( $ params [ 'HASH ' ] ) ) { return false ; } $ hash = $ params [ 'HASH ' ] ; unset ( $ params [ 'HASH ' ] ) ; return $ hash = = = $ this - > calculate Hash ( $ params ) ; } 
protected function do Request ( array $ fields ) { $ headers = array ( 'Content -Type ' = > 'application /x -www -form -urlencoded ' , ) ; $ request = $ this - > message Factory - > create Request ( 'POST ' , $ this - > get Api Endpoint ( ) , $ headers , http _build _query ( $ fields ) ) ; $ response = $ this - > client - > send ( $ request ) ; if ( false = = ( $ response - > get Status Code ( ) > = 2 0 0 & & $ response - > get Status Code ( ) < 3 0 0 ) ) { throw Http Exception : : factory ( $ request , $ response ) ; } $ result = json _decode ( $ response - > get Body ( ) - > get Contents ( ) ) ; if ( null = = = $ result ) { throw new Logic Exception ( "Response content is not valid json : \n \n { $response - >get Body ( ) - >get Contents ( ) } " ) ; } return $ result ; } 
public function prepare Offsite Payment ( array $ params ) { $ supported Params = array ( 'CLIENTIDENT ' = > null , 'DESCRIPTION ' = > null , 'ORDERID ' = > null , 'AMOUNT ' = > null , 'CARDTYPE ' = > null , 'CLIENTEMAIL ' = > null , 'CARDFULLNAME ' = > null , 'LANGUAGE ' = > null , 'EXTRADATA ' = > null , 'CLIENTDOB ' = > null , 'CLIENTADDRESS ' = > null , 'CREATEALIAS ' = > null , ' 3DSECURE ' = > null , ' 3DSECUREDISPLAYMODE ' = > null , 'USETEMPLATE ' = > null , 'HIDECLIENTEMAIL ' = > null , 'HIDEFULLNAME ' = > null , ) ; $ params = array _filter ( array _replace ( $ supported Params , array _intersect _key ( $ params , $ supported Params ) ) ) ; $ params [ 'OPERATIONTYPE ' ] = static : : OPERATION _PAYMENT ; $ this - > add Global Params ( $ params ) ; return $ params ; } 
public function calculate Hash ( array $ params ) { #Alpha sort ksort ( $ params ) ; $ clear String = $ this - > options [ 'password ' ] ; foreach ( $ params as $ key = > $ value ) { $ clear String . = $ key . ' = ' . $ value . $ this - > options [ 'password ' ] ; } return hash ( 'sha 2 5 6 ' , $ clear String ) ; } 
public function execute ( $ request ) { Request Not Supported Exception : : assert Supports ( $ this , $ request ) ; $ details = Array Object : : ensure Array Object ( $ request - > get Model ( ) ) ; if ( false = = $ details [ 'rno ' ] ) { $ this - > gateway - > execute ( new Authorize ( $ details ) ) ; } if ( $ details [ 'rno ' ] & & false = = $ details [ 'invoice _number ' ] ) { $ this - > gateway - > execute ( new Activate ( $ details ) ) ; } } 
public function execute ( $ request ) { Request Not Supported Exception : : assert Supports ( $ this , $ request ) ; $ payout = $ request - > get Source ( ) ; $ this - > gateway - > execute ( $ currency = new Get Currency ( $ payout - > get Currency Code ( ) ) ) ; $ divisor = pow ( 1 0 , $ currency - > exp ) ; $ details = Array Object : : ensure Array Object ( $ payout - > get Details ( ) ) ; $ details [ 'CURRENCYCODE ' ] = $ payout - > get Currency Code ( ) ; $ details [ 'L _AMT 0 ' ] = $ payout - > get Total Amount ( ) / $ divisor ; $ details [ 'L _NOTE 0 ' ] = $ payout - > get Description ( ) ; if ( $ payout - > get Recipient Email ( ) ) { $ details [ 'RECEIVERTYPE ' ] = 'Email Address ' ; $ details [ 'L _EMAIL 0 ' ] = $ payout - > get Recipient Email ( ) ; } elseif ( $ payout - > get Recipient Id ( ) ) { $ details [ 'RECEIVERTYPE ' ] = 'User ID ' ; $ details [ 'L _RECEIVERID 0 ' ] = $ payout - > get Recipient Id ( ) ; } else { throw new Logic Exception ( 'Either recipient id or email must be set . ' ) ; } $ request - > set Result ( ( array ) $ details ) ; } 
public function execute ( $ request ) { Request Not Supported Exception : : assert Supports ( $ this , $ request ) ; $ model = Array Object : : ensure Array Object ( $ request - > get Model ( ) ) ; $ this - > gateway - > execute ( $ http Request = new Get Http Request ( ) ) ; $ response = Array Object : : ensure Array Object ( $ http Request - > request ) ; if ( isset ( $ http Request - > query [ 'cancelled ' ] ) ) { $ new Response [ 'CANCELLED ' ] = true ; $ model - > replace ( $ new Response ) ; return ; } if ( $ response [ 'txn _id ' ] ! = null ) { $ response - > validate Not Empty ( [ 'payment _status ' , 'business ' , 'invoice ' , 'txn _id ' , 'mc _gross ' , ] ) ; $ this - > gateway - > execute ( new Sync ( $ response ) ) ; $ model - > replace ( $ response ) ; } else { if ( $ model [ 'cancel _return ' ] ) { $ cancel Uri = Http Uri : : create From String ( $ model [ 'cancel _return ' ] ) ; $ modifier = new Merge Query ( 'cancelled = 1 ' ) ; $ cancel Uri = $ modifier - > process ( $ cancel Uri ) ; $ model [ 'cancel _return ' ] = ( string ) $ cancel Uri ; } $ this - > gateway - > execute ( new Create Button Payment ( $ model ) ) ; } } 
public function execute ( $ request ) { Request Not Supported Exception : : assert Supports ( $ this , $ request ) ; $ http Request = null ; if ( $ this - > http Request instanceof Request ) { $ http Request = $ this - > http Request ; } elseif ( $ this - > http Request Stack instanceof Request Stack ) { $ http Request = $ this - > http Request Stack - > get Master Request ( ) ; } if ( false = = $ http Request ) { throw new Logic Exception ( 'The action can be run only when http request is set . ' ) ; } $ form = $ this - > create Credit Card Form ( ) ; $ form - > handle Request ( $ http Request ) ; if ( $ form - > is Submitted ( ) ) { $ card = $ form - > get Data ( ) ; $ card - > secure ( ) ; if ( $ form - > is Valid ( ) ) { $ request - > set ( $ card ) ; return ; } } $ render Template = new Render Template ( $ this - > template Name , array ( 'model ' = > $ request - > get Model ( ) , 'first Model ' = > $ request - > get First Model ( ) , 'form ' = > $ form - > create View ( ) , 'action Url ' = > $ request - > get Token ( ) ? $ request - > get Token ( ) - > get Target Url ( ) : null , ) ) ; $ this - > gateway - > execute ( $ render Template ) ; throw new Http Response ( new Response ( $ render Template - > get Result ( ) , 2 0 0 , array ( 'Cache -Control ' = > 'no -store , no -cache , max -age = 0 , post -check = 0 , pre -check = 0 ' , 'X -Status -Code ' = > 2 0 0 , 'Pragma ' = > 'no -cache ' , ) ) ) ; } 
public function get Gateway Factory ( $ name ) { try { return $ this - > registry - > get Gateway Factory ( $ name ) ; } catch ( Invalid Argument Exception $ e ) { return $ this - > fallback Registry - > get Gateway Factory ( $ name ) ; } } 
public function get Gateway ( $ name ) { try { return $ this - > registry - > get Gateway ( $ name ) ; } catch ( Invalid Argument Exception $ e ) { return $ this - > fallback Registry - > get Gateway ( $ name ) ; } } 
public function execute ( $ request ) { Request Not Supported Exception : : assert Supports ( $ this , $ request ) ; $ model = Array Object : : ensure Array Object ( $ request - > get Model ( ) ) ; $ http Request = new Get Http Request ( ) ; $ this - > gateway - > execute ( $ http Request ) ; 
protected function populate Config ( Array Object $ config ) { $ config - > defaults ( [ 'payum .factory _name ' = > 'offline ' , 'payum .factory _title ' = > 'Offline ' , 'payum .action .capture ' = > new Capture Action ( ) , 'payum .action .authorize ' = > new Authorize Action ( ) , 'payum .action .payout ' = > new Payout Action ( ) , 'payum .action .refund ' = > new Refund Action ( ) , 'payum .action .status ' = > new Status Action ( ) , 'payum .action .convert _payment ' = > new Convert Payment Action ( ) , 'payum .action .convert _payout ' = > new Convert Payout Action ( ) , ] ) ; } 
public function verify ( $ http Request ) { if ( false = = $ http Request instanceof Request ) { throw new Invalid Argument Exception ( sprintf ( 'Invalid request given . Expected %s but it is %s ' , 'Symfony \Component \Http Foundation \Request ' , is _object ( $ http Request ) ? get _class ( $ http Request ) : gettype ( $ http Request ) ) ) ; } if ( false = = = $ hash = $ http Request - > attributes - > get ( 'payum _token ' , $ http Request - > get ( 'payum _token ' , false ) ) ) { throw new Not Found Http Exception ( 'Token parameter not set in request ' ) ; } if ( $ hash instanceof Token Interface ) { $ token = $ hash ; } else { if ( false = = $ token = $ this - > token Storage - > find ( $ hash ) ) { throw new Not Found Http Exception ( sprintf ( 'A token with hash ` %s ` could not be found . ' , $ hash ) ) ; } if ( ! Request Token Verifier : : is Valid ( $ http Request - > get Uri ( ) , $ token - > get Target Url ( ) ) ) { throw new Http Exception ( 4 0 0 , sprintf ( 'The current url %s not match target url %s set in the token . ' , $ http Request - > get Uri ( ) , $ token - > get Target Url ( ) ) ) ; } } return $ token ; } 
public function execute ( $ request ) { Request Not Supported Exception : : assert Supports ( $ this , $ request ) ; $ payment = $ request - > get Source ( ) ; $ details = Array Object : : ensure Array Object ( $ payment - > get Details ( ) ) ; $ details [ 'amount ' ] = $ payment - > get Total Amount ( ) ; $ details [ 'currency ' ] = $ payment - > get Currency Code ( ) ; $ details [ 'number ' ] = $ payment - > get Number ( ) ; $ details [ 'description ' ] = $ payment - > get Description ( ) ; $ details [ 'client _email ' ] = $ payment - > get Client Email ( ) ; $ details [ 'client _id ' ] = $ payment - > get Client Id ( ) ; $ details - > defaults ( array ( Constants : : FIELD _PAID = > true , ) ) ; $ request - > set Result ( ( array ) $ details ) ; } 
public function execute ( $ request ) { Request Not Supported Exception : : assert Supports ( $ this , $ request ) ; $ details = Array Object : : ensure Array Object ( $ request - > get Model ( ) ) ; $ klarna = $ this - > get Klarna ( ) ; try { $ klarna - > email Invoice ( $ details [ 'invoice _number ' ] ) ; } catch ( \ Klarna Exception $ e ) { $ this - > populate Details With Error ( $ details , $ e , $ request ) ; } } 
protected function do Request ( $ method , array $ fields ) { $ headers = [ ] ; $ request = $ this - > message Factory - > create Request ( $ method , $ this - > get Api Endpoint ( ) , $ headers , http _build _query ( $ fields ) ) ; $ response = $ this - > client - > send ( $ request ) ; if ( false = = ( $ response - > get Status Code ( ) > = 2 0 0 & & $ response - > get Status Code ( ) < 3 0 0 ) ) { throw Http Exception : : factory ( $ request , $ response ) ; } return $ response ; } 
public function execute ( $ request ) { Request Not Supported Exception : : assert Supports ( $ this , $ request ) ; $ model = new Array Object ( $ request - > get Model ( ) ) ; if ( Api : : EXECCODE _ 3DSECURE _IDENTIFICATION _REQUIRED = = = $ model [ 'EXECCODE ' ] ) { throw new Http Response ( base 6 4 _decode ( $ model [ ' 3DSECUREHTML ' ] ) , 3 0 2 ) ; } if ( null ! = = $ model [ 'EXECCODE ' ] ) { return ; } if ( false = = $ model [ 'CLIENTUSERAGENT ' ] ) { $ this - > gateway - > execute ( $ http Request = new Get Http Request ( ) ) ; $ model [ 'CLIENTUSERAGENT ' ] = $ http Request - > user Agent ; } if ( false = = $ model [ 'CLIENTIP ' ] ) { $ this - > gateway - > execute ( $ http Request = new Get Http Request ( ) ) ; $ model [ 'CLIENTIP ' ] = $ http Request - > client Ip ; } $ card Fields = array ( 'CARDCODE ' , 'CARDCVV ' , 'CARDVALIDITYDATE ' , 'CARDFULLNAME ' ) ; if ( false = = $ model - > validate Not Empty ( $ card Fields , false ) & & false = = $ model [ 'ALIAS ' ] ) { try { $ obtain Credit Card = new Obtain Credit Card ( $ request - > get Token ( ) ) ; $ obtain Credit Card - > set Model ( $ request - > get First Model ( ) ) ; $ obtain Credit Card - > set Model ( $ request - > get Model ( ) ) ; $ this - > gateway - > execute ( $ obtain Credit Card ) ; $ card = $ obtain Credit Card - > obtain ( ) ; if ( $ card - > get Token ( ) ) { $ model [ 'ALIAS ' ] = $ card - > get Token ( ) ; } else { $ model [ 'CARDVALIDITYDATE ' ] = Sensitive Value : : ensure Sensitive ( $ card - > get Expire At ( ) - > format ( 'm -y ' ) ) ; $ model [ 'CARDCODE ' ] = Sensitive Value : : ensure Sensitive ( $ card - > get Number ( ) ) ; $ model [ 'CARDFULLNAME ' ] = Sensitive Value : : ensure Sensitive ( $ card - > get Holder ( ) ) ; $ model [ 'CARDCVV ' ] = Sensitive Value : : ensure Sensitive ( $ card - > get Security Code ( ) ) ; } } catch ( Request Not Supported Exception $ e ) { throw new Logic Exception ( 'Credit card details has to be set explicitly or there has to be an action that supports Obtain Credit Card request . ' ) ; } } 
public function set Field ( $ name , $ value ) { 
public function execute ( $ request ) { Request Not Supported Exception : : assert Supports ( $ this , $ request ) ; $ model = $ request - > get Model ( ) ; if ( false = = isset ( $ model - > state ) & & isset ( $ model - > payer - > payment _method ) & & 'paypal ' = = $ model - > payer - > payment _method ) { $ model - > create ( $ this - > api ) ; foreach ( $ model - > links as $ link ) { if ( $ link - > rel = = 'approval _url ' ) { throw new Http Redirect ( $ link - > href ) ; } } } if ( false = = isset ( $ model - > state ) & & isset ( $ model - > payer - > payment _method ) & & 'credit _card ' = = $ model - > payer - > payment _method ) { $ model - > create ( $ this - > api ) ; } if ( true = = isset ( $ model - > state ) & & isset ( $ model - > payer - > payment _method ) & & 'paypal ' = = $ model - > payer - > payment _method ) { $ execution = new Payment Execution ( ) ; $ execution - > payer _id = $ _GET [ 'Payer ID ' ] ; 
public function execute ( $ request ) { Request Not Supported Exception : : assert Supports ( $ this , $ request ) ; $ model = Array Object : : ensure Array Object ( $ request - > get Model ( ) ) ; foreach ( range ( 0 , 9 ) as $ index ) { if ( Api : : L _ERRORCODE _PAYMENT _NOT _AUTHORIZED = = $ model [ 'L _ERRORCODE ' . $ index ] ) { $ request - > mark Canceled ( ) ; return ; } } foreach ( range ( 0 , 9 ) as $ index ) { if ( $ model [ 'L _ERRORCODE ' . $ index ] ) { $ request - > mark Failed ( ) ; return ; } } if ( isset ( $ model [ 'CANCELLED ' ] ) ) { $ request - > mark Canceled ( ) ; return ; } if ( false = = $ model [ 'PAYERID ' ] & & Api : : CHECKOUTSTATUS _PAYMENT _ACTION _NOT _INITIATED = = $ model [ 'CHECKOUTSTATUS ' ] ) { $ request - > mark Pending ( ) ; return ; } 
public function decrypt ( Cypher Interface $ cypher ) { if ( empty ( $ this - > config [ 'encrypted ' ] ) ) { return ; } foreach ( $ this - > config as $ name = > $ value ) { if ( 'encrypted ' = = $ name | | is _bool ( $ value ) ) { $ this - > decrypted Config [ $ name ] = $ value ; continue ; } $ this - > decrypted Config [ $ name ] = $ cypher - > decrypt ( $ value ) ; } } 
public function encrypt ( Cypher Interface $ cypher ) { $ this - > decrypted Config [ 'encrypted ' ] = true ; foreach ( $ this - > decrypted Config as $ name = > $ value ) { if ( 'encrypted ' = = $ name | | is _bool ( $ value ) ) { $ this - > config [ $ name ] = $ value ; continue ; } $ this - > config [ $ name ] = $ cypher - > encrypt ( $ value ) ; } } 
protected function prepare Content ( $ url , array $ fields ) { $ form Inputs = ' ' ; foreach ( $ fields as $ name = > $ value ) { $ form Inputs . = sprintf ( ' <input type = "hidden " name = " % 1 $s " value = " % 2 $s " / > ' , htmlspecialchars ( $ name , ENT _QUOTES , 'UTF - 8 ' ) , htmlspecialchars ( $ value , ENT _QUOTES , 'UTF - 8 ' ) ) . " \n " ; } $ content = < < < 'HTML ' < !DOCTYPE html > <html > <head > <title >Redirecting . . . < /title > < /head > <body onload = "document .forms [ 0 ] .submit ( ) ; " > <form action = " % 1 $s " method = "post " > <p >Redirecting to payment page . . . < /p > <p > % 2 $s < /p > < /form > < /body > < /html > HTML ; return sprintf ( $ content , htmlspecialchars ( $ url , ENT _QUOTES , 'UTF - 8 ' ) , $ form Inputs ) ; } 
public function execute ( $ request ) { Request Not Supported Exception : : assert Supports ( $ this , $ request ) ; $ model = new Array Object ( $ request - > get Model ( ) ) ; if ( null = = = $ model [ 'EXECCODE ' ] ) { $ request - > mark New ( ) ; return ; } if ( Api : : EXECCODE _SUCCESSFUL = = = $ model [ 'EXECCODE ' ] ) { $ request - > mark Captured ( ) ; return ; } if ( Api : : EXECCODE _TIME _OUT = = = $ model [ 'EXECCODE ' ] ) { $ request - > mark Unknown ( ) ; return ; } $ request - > mark Failed ( ) ; } 
public function execute ( $ request ) { Request Not Supported Exception : : assert Supports ( $ this , $ request ) ; $ details = Array Object : : ensure Array Object ( $ request - > get Model ( ) ) ; $ details [ 'PAYMENTREQUEST _ 0 _PAYMENTACTION ' ] = Api : : PAYMENTACTION _SALE ; foreach ( range ( 0 , 9 ) as $ index ) { if ( Api : : PENDINGREASON _AUTHORIZATION = = $ details [ 'PAYMENTINFO _ ' . $ index . ' _PENDINGREASON ' ] ) { $ details - > defaults ( [ 'PAYMENTREQUEST _ ' . $ index . ' _COMPLETETYPE ' = > 'Complete ' ] ) ; $ this - > gateway - > execute ( new Do Capture ( $ details , $ index ) ) ; } } parent : : execute ( $ request ) ; } 
public function execute ( $ request ) { Request Not Supported Exception : : assert Supports ( $ this , $ request ) ; $ details = Array Object : : ensure Array Object ( $ request - > get Model ( ) ) ; if ( ! $ details [ 'TRANSACTIONID ' ] ) { return ; } $ void Details = new Array Object ( [ 'AUTHORIZATIONID ' = > $ details [ 'TRANSACTIONID ' ] , ] ) ; $ this - > gateway - > execute ( new Do Void ( $ void Details ) ) ; $ this - > gateway - > execute ( new Sync ( $ request - > get Model ( ) ) ) ; } 
public function supports ( $ request ) { if ( false = = ( $ request instanceof Cancel & & $ request - > get Model ( ) instanceof \ Array Access ) ) { return false ; } 
public function add Gateway ( $ name , $ gateway ) { 
public function add Gateway Factory ( $ name , $ gateway Factory ) { if ( $ gateway Factory instanceof Gateway Factory Interface | | is _callable ( $ gateway Factory ) ) { $ this - > gateway Factories [ $ name ] = $ gateway Factory ; return $ this ; } throw new Invalid Argument Exception ( 'Invalid argument ' ) ; } 
public function add Gateway Factory Config ( $ name , array $ config ) { $ current Config = isset ( $ this - > gateway Factory Configs [ $ name ] ) ? $ this - > gateway Factory Configs [ $ name ] : [ ] ; $ this - > gateway Factory Configs [ $ name ] = array _replace _recursive ( $ current Config , $ config ) ; return $ this ; } 
public function set Http Request Verifier ( $ http Request Verifier = null ) { if ( null = = = $ http Request Verifier | | $ http Request Verifier instanceof Http Request Verifier Interface | | is _callable ( $ http Request Verifier ) ) { $ this - > http Request Verifier = $ http Request Verifier ; return $ this ; } throw new Invalid Argument Exception ( 'Invalid argument ' ) ; } 
public function set Token Factory ( $ token Factory = null ) { if ( null = = = $ token Factory | | $ token Factory instanceof Token Factory Interface | | is _callable ( $ token Factory ) ) { $ this - > token Factory = $ token Factory ; return $ this ; } throw new Invalid Argument Exception ( 'Invalid argument ' ) ; } 
public function set Generic Token Factory ( $ token Factory = null ) { if ( null = = = $ token Factory | | $ token Factory instanceof Generic Token Factory Interface | | is _callable ( $ token Factory ) ) { $ this - > generic Token Factory = $ token Factory ; return $ this ; } throw new Invalid Argument Exception ( 'Invalid argument ' ) ; } 
public function set Core Gateway Factory ( $ core Gateway Factory = null ) { if ( null = = = $ core Gateway Factory | | $ core Gateway Factory instanceof Gateway Factory Interface | | is _callable ( $ core Gateway Factory ) ) { $ this - > core Gateway Factory = $ core Gateway Factory ; return $ this ; } throw new Invalid Argument Exception ( 'Invalid argument ' ) ; } 
public function add Core Gateway Factory Config ( array $ config ) { $ current Config = $ this - > core Gateway Factory Config ? : [ ] ; $ this - > core Gateway Factory Config = array _replace _recursive ( $ current Config , $ config ) ; return $ this ; } 
protected function build Token Factory ( Storage Interface $ token Storage , Storage Registry Interface $ storage Registry ) { $ token Factory = $ this - > token Factory ; if ( is _callable ( $ token Factory ) ) { $ token Factory = call _user _func ( $ token Factory , $ token Storage , $ storage Registry ) ; if ( false = = $ token Factory instanceof Token Factory Interface ) { throw new \ Logic Exception ( 'Builder returned invalid instance ' ) ; } } return $ token Factory ? : new Token Factory ( $ token Storage , $ storage Registry ) ; } 
protected function build Generic Token Factory ( Token Factory Interface $ token Factory , array $ paths ) { $ generic Token Factory = $ this - > generic Token Factory ; if ( is _callable ( $ generic Token Factory ) ) { $ generic Token Factory = call _user _func ( $ generic Token Factory , $ token Factory , $ paths ) ; if ( false = = $ generic Token Factory instanceof Generic Token Factory Interface ) { throw new \ Logic Exception ( 'Builder returned invalid instance ' ) ; } } return $ generic Token Factory ? : new Generic Token Factory ( $ token Factory , $ paths ) ; } 
private function build Http Request Verifier ( Storage Interface $ token Storage ) { $ http Request Verifier = $ this - > http Request Verifier ; if ( is _callable ( $ http Request Verifier ) ) { $ http Request Verifier = call _user _func ( $ http Request Verifier , $ token Storage ) ; if ( false = = $ http Request Verifier instanceof Http Request Verifier Interface ) { throw new \ Logic Exception ( 'Builder returned invalid instance ' ) ; } } return $ http Request Verifier ? : new Http Request Verifier ( $ token Storage ) ; } 
protected function build Registry ( array $ gateways = [ ] , array $ storages = [ ] , array $ gateway Factories = [ ] ) { $ registry = new Simple Registry ( $ gateways , $ storages , $ gateway Factories ) ; $ registry - > set Add Storage Extensions ( false ) ; if ( $ this - > gateway Config Storage ) { $ dynamic Registry = new Dynamic Registry ( $ this - > gateway Config Storage , $ registry ) ; $ dynamic Registry - > set Backward Compatibility ( false ) ; $ registry = new Fallback Registry ( $ dynamic Registry , $ registry ) ; } if ( $ this - > main Registry ) { $ registry = new Fallback Registry ( $ this - > main Registry , $ registry ) ; } return $ registry ; } 
protected function build Gateway Factories ( Gateway Factory Interface $ core Gateway Factory ) { $ map = [ 'paypal _express _checkout ' = > Paypal Express Checkout Gateway Factory : : class , 'paypal _pro _checkout ' = > Paypal Pro Checkout Gateway Factory : : class , 'paypal _pro _hosted ' = > Paypal Pro Hosted Gateway Factory : : class , 'paypal _masspay ' = > Paypal Masspay Gateway Factory : : class , 'paypal _rest ' = > Paypal Rest Gateway Factory : : class , 'authorize _net _aim ' = > Authorize Net Aim Gateway Factory : : class , 'be 2bill _direct ' = > Be 2Bill Direct Gateway Factory : : class , 'be 2bill _offsite ' = > Be 2Bill Offsite Gateway Factory : : class , 'klarna _checkout ' = > Klarna Checkout Gateway Factory : : class , 'klarna _invoice ' = > Klarna Invoice Gateway Factory : : class , 'offline ' = > Offline Gateway Factory : : class , 'payex ' = > Payex Gateway Factory : : class , 'stripe _checkout ' = > Stripe Checkout Gateway Factory : : class , 'stripe _js ' = > Stripe Js Gateway Factory : : class , 'sofort ' = > Sofort Gateway Factory : : class , ] ; $ gateway Factories = [ ] ; foreach ( $ map as $ name = > $ factory Class ) { if ( class _exists ( $ factory Class ) ) { $ gateway Factories [ $ name ] = new $ factory Class ( isset ( $ this - > gateway Factory Configs [ $ name ] ) ? $ this - > gateway Factory Configs [ $ name ] : [ ] , $ core Gateway Factory ) ; } } return $ gateway Factories ; } 
protected function build Added Gateway Factories ( Gateway Factory Interface $ core Gateway Factory ) { $ gateway Factories = [ ] ; foreach ( $ this - > gateway Factories as $ name = > $ factory ) { if ( is _callable ( $ factory ) ) { $ config = isset ( $ this - > gateway Factory Configs [ $ name ] ) ? $ this - > gateway Factory Configs [ $ name ] : [ ] ; $ factory = call _user _func ( $ factory , $ config , $ core Gateway Factory ) ; } $ gateway Factories [ $ name ] = $ factory ; } return $ gateway Factories ; } 
protected function build Omnipay Gateway Factories ( Gateway Factory Interface $ core Gateway Factory ) { $ gateway Factories = [ ] ; if ( false = = class _exists ( \ Omnipay \ Omnipay : : class ) | | false = = class _exists ( Omnipay Gateway Factory : : class ) ) { return $ gateway Factories ; } $ factory = \ Omnipay \ Omnipay : : get Factory ( ) ; $ gateway Factories [ 'omnipay ' ] = new Omnipay Gateway Factory ( ' ' , $ factory , [ ] , $ core Gateway Factory ) ; $ gateway Factories [ 'omnipay _direct ' ] = new Omnipay Gateway Factory ( ' ' , $ factory , [ ] , $ core Gateway Factory ) ; $ gateway Factories [ 'omnipay _offsite ' ] = new Omnipay Gateway Factory ( ' ' , $ factory , [ ] , $ core Gateway Factory ) ; foreach ( $ factory - > get Supported Gateways ( ) as $ type ) { 
protected function build Omnipay V 3Gateway Factories ( Gateway Factory Interface $ core Gateway Factory ) { $ gateway Factories = [ ] ; if ( false = = class _exists ( \ Omnipay \ Omnipay : : class ) | | false = = class _exists ( Omnipay V 3Gateway Factory : : class ) ) { return $ gateway Factories ; } $ factory = \ Omnipay \ Omnipay : : get Factory ( ) ; $ gateway Factories [ 'omnipay ' ] = new Omnipay V 3Gateway Factory ( $ factory , [ ] , $ core Gateway Factory ) ; return $ gateway Factories ; } 
public function build ( array $ default Config ) { $ core Gateway Factory = new Container Aware Core Gateway Factory ( $ default Config ) ; $ core Gateway Factory - > set Container ( $ this - > container ) ; return $ core Gateway Factory ; } 
public function find By ( array $ criteria ) { $ crit = new Criteria ( ) ; foreach ( $ criteria as $ column = > $ value ) { $ crit - > add ( $ column , $ value ) ; } $ model Peer = $ this - > model Peer ; return $ model Peer : : do Select ( $ crit ) ; } 
protected function do Get Identity ( $ model ) { $ id = $ this - > get Model Id ( $ model ) ; if ( count ( $ id ) > 1 ) { throw new Logic Exception ( 'Storage not support composite primary ids ' ) ; } return new Identity ( array _shift ( $ id ) , $ model ) ; } 
protected function get Model Id ( $ model ) { $ id = array ( ) ; $ model Peer = get _class ( $ model ) . 'Peer ' ; $ model Columns = $ model Peer : : get Table Map ( ) - > get Columns ( ) ; foreach ( $ model Columns as $ column ) { if ( $ column - > is Primary Key ( ) ) { $ name = $ column - > get Php Name ( ) ; $ id [ $ name ] = $ model - > get By Name ( $ name ) ; 
public function execute ( $ request ) { Request Not Supported Exception : : assert Supports ( $ this , $ request ) ; $ model = Array Object : : ensure Array Object ( $ request - > get Model ( ) ) ; throw new \ Logic Exception ( 'Not implemented ' ) ; } 
public function execute ( $ request ) { Request Not Supported Exception : : assert Supports ( $ this , $ request ) ; $ model = Array Object : : ensure Array Object ( $ request - > get Model ( ) ) ; if ( false = = $ model [ Constants : : FIELD _STATUS ] ) { $ request - > mark New ( ) ; return ; } if ( Constants : : STATUS _PENDING = = $ model [ Constants : : FIELD _STATUS ] ) { $ request - > mark Pending ( ) ; return ; } if ( Constants : : STATUS _AUTHORIZED = = $ model [ Constants : : FIELD _STATUS ] ) { $ request - > mark Authorized ( ) ; return ; } if ( Constants : : STATUS _CAPTURED = = $ model [ Constants : : FIELD _STATUS ] ) { $ request - > mark Captured ( ) ; return ; } if ( Constants : : STATUS _PAYEDOUT = = $ model [ Constants : : FIELD _STATUS ] ) { $ request - > mark Payedout ( ) ; return ; } if ( Constants : : STATUS _REFUNDED = = $ model [ Constants : : FIELD _STATUS ] ) { $ request - > mark Refunded ( ) ; return ; } if ( Constants : : STATUS _CANCELED = = $ model [ Constants : : FIELD _STATUS ] ) { $ request - > mark Canceled ( ) ; return ; } $ request - > mark Unknown ( ) ; } 
public static function guess Views Path ( $ gateway Factory Or Root Class ) { if ( false = = class _exists ( $ gateway Factory Or Root Class ) ) { return ; } $ rc = new \ Reflection Class ( $ gateway Factory Or Root Class ) ; return dirname ( $ rc - > get File Name ( ) ) . ' /Resources /views ' ; } 
protected function populate Config ( Array Object $ config ) { if ( ! class _exists ( 'Soap Client ' ) ) { throw new \ Logic Exception ( 'You must install "ext -soap " extension . ' ) ; } $ config [ 'payum .default _options ' ] = array ( 'account _number ' = > ' ' , 'encryption _key ' = > ' ' , 'sandbox ' = > true , ) ; $ config - > defaults ( $ config [ 'payum .default _options ' ] ) ; $ config [ 'payum .required _options ' ] = array ( 'account _number ' , 'encryption _key ' ) ; $ config - > defaults ( array ( 'payum .factory _name ' = > 'payex ' , 'payum .factory _title ' = > 'Payex ' , 'soap .client _factory ' = > new Soap Client Factory ( ) , 'payum .api .order ' = > function ( Array Object $ config ) { $ config - > validate Not Empty ( $ config [ 'payum .required _options ' ] ) ; $ payex Config = array ( 'account _number ' = > $ config [ 'account _number ' ] , 'encryption _key ' = > $ config [ 'encryption _key ' ] , 'sandbox ' = > $ config [ 'sandbox ' ] , ) ; return new Order Api ( $ config [ 'soap .client _factory ' ] , $ payex Config ) ; } , 'payum .api .agreement ' = > function ( Array Object $ config ) { $ config - > validate Not Empty ( $ config [ 'payum .required _options ' ] ) ; $ payex Config = array ( 'account _number ' = > $ config [ 'account _number ' ] , 'encryption _key ' = > $ config [ 'encryption _key ' ] , 'sandbox ' = > $ config [ 'sandbox ' ] , ) ; return new Agreement Api ( $ config [ 'soap .client _factory ' ] , $ payex Config ) ; } , 'payum .api .recurring ' = > function ( Array Object $ config ) { $ config - > validate Not Empty ( $ config [ 'payum .required _options ' ] ) ; $ payex Config = array ( 'account _number ' = > $ config [ 'account _number ' ] , 'encryption _key ' = > $ config [ 'encryption _key ' ] , 'sandbox ' = > $ config [ 'sandbox ' ] , ) ; return new Recurring Api ( $ config [ 'soap .client _factory ' ] , $ payex Config ) ; } , 'payum .action .capture ' = > new Payment Details Capture Action ( ) , 'payum .action .status ' = > new Payment Details Status Action ( ) , 'payum .action .sync ' = > new Payment Details Sync Action ( ) , 'payum .action .auto _pay _capture ' = > new Auto Pay Payment Details Capture Action ( ) , 'payum .action .auto _pay _status ' = > new Auto Pay Payment Details Status Action ( ) , 'payum .action .convert _payment ' = > new Convert Payment Action ( ) , 
public function execute ( $ request ) { Request Not Supported Exception : : assert Supports ( $ this , $ request ) ; $ model = Array Object : : ensure Array Object ( $ request - > get Model ( ) ) ; 
public function supports ( $ request ) { return $ request instanceof Get Status Interface & & $ request - > get Model ( ) instanceof \ Array Access & & 
public function on Pre Execute ( Context $ context ) { if ( count ( $ context - > get Previous ( ) ) > = $ this - > limit ) { throw new Logic Exception ( sprintf ( 'Possible endless cycle detected . : :on Pre Execute was called %d times before reach the limit . ' , $ this - > limit ) ) ; } } 
public function on Pre Execute ( Context $ context ) { $ request = $ context - > get Request ( ) ; if ( false = = $ request instanceof Model Aggregate Interface ) { return ; } if ( $ request - > get Model ( ) instanceof Identity Interface ) { $ identity = $ request - > get Model ( ) ; if ( false = = $ model = $ this - > storage - > find ( $ identity ) ) { return ; } $ request - > set Model ( $ model ) ; } $ this - > schedule For Update If Supported ( $ request - > get Model ( ) ) ; } 
public function on Post Execute ( Context $ context ) { $ request = $ context - > get Request ( ) ; if ( $ request instanceof Model Aggregate Interface ) { $ this - > schedule For Update If Supported ( $ request - > get Model ( ) ) ; } if ( false = = $ context - > get Previous ( ) ) { foreach ( $ this - > scheduled For Update Models as $ model Hash = > $ model ) { $ this - > storage - > update ( $ model ) ; unset ( $ this - > scheduled For Update Models [ $ model Hash ] ) ; } } } 
public function create ( array $ parameters ) { $ parameters [ 'account Number ' ] = $ this - > options [ 'account _number ' ] ; 
public function check ( array $ parameters ) { $ parameters [ 'account Number ' ] = $ this - > options [ 'account _number ' ] ; $ parameters [ 'hash ' ] = $ this - > calculate Hash ( $ parameters , array ( 'account Number ' , 'agreement Ref ' , ) ) ; return $ this - > call ( 'Check ' , $ parameters , $ this - > get Px Agreement Wsdl ( ) ) ; } 
public function delete ( array $ parameters ) { $ parameters [ 'account Number ' ] = $ this - > options [ 'account _number ' ] ; $ parameters [ 'hash ' ] = $ this - > calculate Hash ( $ parameters , array ( 'account Number ' , 'agreement Ref ' , ) ) ; return $ this - > call ( 'Delete Agreement ' , $ parameters , $ this - > get Px Agreement Wsdl ( ) ) ; } 
public function auto Pay ( array $ parameters ) { $ parameters [ 'account Number ' ] = $ this - > options [ 'account _number ' ] ; $ parameters [ 'hash ' ] = $ this - > calculate Hash ( $ parameters , array ( 'account Number ' , 'agreement Ref ' , 'price ' , 'product Number ' , 'description ' , 'order Id ' , 'purchase Operation ' , 'currency ' , ) ) ; return $ this - > call ( 'Auto Pay 3 ' , $ parameters , $ this - > get Px Agreement Wsdl ( ) ) ; } 
public function execute ( $ request ) { Request Not Supported Exception : : assert Supports ( $ this , $ request ) ; $ details = Array Object : : ensure Array Object ( $ request - > get Model ( ) ) ; if ( $ details [ 'transaction _id ' ] ) { throw new Logic Exception ( sprintf ( 'The transaction has already been created for this payment . transaction _id : %s ' , $ details [ 'transaction _id ' ] ) ) ; } $ details - > validate Not Empty ( [ 'amount ' , 'currency _code ' , 'reason ' , 'success _url ' , 'notification _url ' ] ) ; $ details - > replace ( $ this - > api - > create Transaction ( ( array ) $ details ) ) ; if ( $ details [ 'payment _url ' ] ) { throw new Http Redirect ( $ details [ 'payment _url ' ] ) ; } } 
protected function generate Url ( $ path , array $ parameters = array ( ) ) { return $ this - > url Generator - > generate ( $ path , $ parameters , Url Generator Interface : : ABSOLUTE _URL ) ; } 
public function get Gateway Factory ( $ name ) { 
public function get Gateway ( $ name ) { if ( array _key _exists ( $ name , $ this - > gateways ) ) { return $ this - > gateways [ $ name ] ; } if ( $ gateway Configs = $ this - > gateway Config Store - > find By ( array ( 'gateway Name ' = > $ name ) ) ) { $ gateway = $ this - > create Gateway ( array _shift ( $ gateway Configs ) ) ; $ this - > gateways [ $ name ] = $ gateway ; return $ gateway ; } 
public function get Gateways ( ) { 
public function get Storage ( $ class ) { 
protected function create Gateway ( Gateway Config Interface $ gateway Config ) { $ config = $ gateway Config - > get Config ( ) ; if ( isset ( $ config [ 'factory ' ] ) ) { $ factory = $ this - > gateway Factory Registry - > get Gateway Factory ( $ config [ 'factory ' ] ) ; unset ( $ config [ 'factory ' ] ) ; } else { 
public function execute ( $ request ) { Request Not Supported Exception : : assert Supports ( $ this , $ request ) ; $ payment = $ request - > get Source ( ) ; $ details = Array Object : : ensure Array Object ( $ payment - > get Details ( ) ) ; $ details [ "amount " ] = $ payment - > get Total Amount ( ) ; $ details [ "currency " ] = $ payment - > get Currency Code ( ) ; $ details [ "description " ] = $ payment - > get Description ( ) ; if ( $ card = $ payment - > get Credit Card ( ) ) { if ( $ card - > get Token ( ) ) { $ details [ "customer " ] = $ card - > get Token ( ) ; } else { $ details [ "card " ] = Sensitive Value : : ensure Sensitive ( [ 'number ' = > $ card - > get Number ( ) , 'exp _month ' = > $ card - > get Expire At ( ) - > format ( 'm ' ) , 'exp _year ' = > $ card - > get Expire At ( ) - > format ( 'Y ' ) , 'cvc ' = > $ card - > get Security Code ( ) , ] ) ; } } $ request - > set Result ( ( array ) $ details ) ; } 
public function execute ( $ request ) { Request Not Supported Exception : : assert Supports ( $ this , $ request ) ; $ model = Array Object : : ensure Array Object ( $ request - > get Model ( ) ) ; if ( false = = $ model [ 'TOKEN ' ] ) { throw new Logic Exception ( 'The TOKEN must be set by Set Express Checkout request but it was not executed or failed . Review payment details model for more information ' ) ; } if ( false = = $ model [ 'PAYERID ' ] | | $ request - > is Forced ( ) ) { throw new Http Redirect ( $ this - > api - > get Authorize Token Url ( $ model [ 'TOKEN ' ] , array ( 'useraction ' = > $ model [ 'AUTHORIZE _TOKEN _USERACTION ' ] , 'cmd ' = > $ model [ 'AUTHORIZE _TOKEN _CMD ' ] , ) ) ) ; } } 
public function execute ( $ request ) { Request Not Supported Exception : : assert Supports ( $ this , $ request ) ; $ payment = $ request - > get Source ( ) ; throw new \ Logic Exception ( 'Not implemented ' ) ; } 
public function build ( Storage Interface $ token Storage , Storage Registry Interface $ storage Registry ) { return new Token Factory ( $ token Storage , $ storage Registry , $ this - > url Generator ) ; } 
public function do Create Button ( array $ fields ) { if ( false = = isset ( $ fields [ 'return ' ] ) ) { if ( false = = $ this - > options [ 'return ' ] ) { throw new Runtime Exception ( 'The return must be set either to Form Request or to options . ' ) ; } $ fields [ 'return ' ] = $ this - > options [ 'return ' ] ; } $ fields [ 'paymentaction ' ] = self : : PAYMENTACTION _SALE ; $ fields [ 'cmd ' ] = self : : FORM _CMD ; $ new Fields = [ ] ; $ i = 0 ; foreach ( $ fields as $ key = > $ val ) { $ new Fields [ 'L _BUTTONVAR ' . $ i ] = $ key . ' = ' . $ val ; $ i + + ; } $ new Fields [ 'METHOD ' ] = 'BMCreate Button ' ; $ new Fields [ 'BUTTONTYPE ' ] = 'PAYMENT ' ; $ new Fields [ 'BUTTONCODE ' ] = 'TOKEN ' ; $ this - > add Version Field ( $ new Fields ) ; $ this - > add Authorize Fields ( $ new Fields ) ; $ response = $ this - > do Request ( $ new Fields ) ; return $ response ; } 
public function get Transaction Details ( $ fields ) { $ fields [ 'METHOD ' ] = 'Get Transaction Details ' ; $ this - > add Authorize Fields ( $ fields ) ; $ this - > add Version Field ( $ fields ) ; return $ this - > do Request ( $ fields ) ; } 
protected function do Request ( array $ fields ) { $ headers = array ( 'Content -Type ' = > 'application /x -www -form -urlencoded ' , ) ; $ request = $ this - > message Factory - > create Request ( 'POST ' , $ this - > get Api Endpoint ( ) , $ headers , http _build _query ( $ fields ) ) ; $ response = $ this - > client - > send ( $ request ) ; if ( false = = ( $ response - > get Status Code ( ) > = 2 0 0 & & $ response - > get Status Code ( ) < 3 0 0 ) ) { throw Http Exception : : factory ( $ request , $ response ) ; } parse _str ( $ response - > get Body ( ) - > get Contents ( ) , $ result ) ; foreach ( $ result as & $ value ) { $ value = urldecode ( $ value ) ; } return $ result ; } 
protected function do Find ( $ id ) { $ query = new $ this - > model Query ( ) ; $ model = $ query - > find Pk ( $ id ) ; return $ model ? : new $ this - > model Class ( ) ; } 
public function find By ( array $ criteria ) { $ query = new $ this - > model Query ( ) ; foreach ( $ criteria as $ column = > $ value ) { $ query - > filter By ( $ column , $ value ) ; } return $ query - > find ( ) ; } 
public static function mask ( $ value , $ mask Symbol = null , $ show Last = 3 ) { $ mask Symbol = $ mask Symbol ? : 'X ' ; $ show Last = max ( 0 , $ show Last ) ; if ( mb _strlen ( $ value ) < = ( $ show Last + 1 ) * 2 | | false = = $ show Last ) { $ show Reg Exp Part = " " ; } else { $ show Reg Exp Part = " ( ? ! ( . ) { 0 , $show Last } $ ) " ; } return preg _replace ( " / ( ? ! ^ . ? ) [ ^ - _ \s ] $show Reg Exp Part /u " , $ mask Symbol , $ value ) ; } 
protected function call With Retry ( \ Closure $ function , $ max Retry = 3 ) { $ attempts = 1 ; while ( true ) { try { return call _user _func ( $ function ) ; } catch ( \ Klarna _Checkout _Connection Error Exception $ e ) { if ( $ attempts > = $ max Retry ) { throw $ e ; } $ attempts + + ; } } } 
public function execute ( $ request ) { Request Not Supported Exception : : assert Supports ( $ this , $ request ) ; $ model = Array Object : : ensure Array Object ( $ request - > get Model ( ) ) ; if ( null = = = $ model [ 'TOKEN ' ] ) { throw new Logic Exception ( 'TOKEN must be set . Have you run Set Express Checkout Action ? ' ) ; } if ( null = = = $ model [ 'PAYERID ' ] ) { throw new Logic Exception ( 'PAYERID must be set . Has user authorized this transaction ? ' ) ; } if ( null = = = $ model [ 'PAYMENTREQUEST _ 0 _PAYMENTACTION ' ] ) { throw new Logic Exception ( 'PAYMENTREQUEST _ 0 _PAYMENTACTION must be set . ' ) ; } if ( null = = = $ model [ 'PAYMENTREQUEST _ 0 _AMT ' ] ) { throw new Logic Exception ( 'PAYMENTREQUEST _ 0 _AMT must be set . ' ) ; } $ model - > replace ( $ this - > api - > do Express Checkout Payment ( ( array ) $ model ) ) ; } 
protected function do Update Model ( $ model ) { if ( $ id = $ this - > get Model Id ( $ model ) ) { $ this - > table Gateway - > update ( $ this - > table Gateway - > get Result Set Prototype ( ) - > get Hydrator ( ) - > extract ( $ model ) , array ( " { $this - >id Field } = ? " = > $ id ) ) ; } else { $ this - > table Gateway - > insert ( $ this - > table Gateway - > get Result Set Prototype ( ) - > get Hydrator ( ) - > extract ( $ model ) ) ; } } 
protected function do Get Identity ( $ model ) { $ id = $ this - > get Model Id ( $ model ) ; if ( ! $ id ) { throw new Logic Exception ( 'The model must be persisted before usage of this method ' ) ; } return new Identity ( $ id , $ model ) ; } 
protected function get Model Id ( $ model ) { $ rp = new \ Reflection Property ( $ model , $ this - > id Field ) ; $ rp - > set Accessible ( true ) ; $ id = $ rp - > get Value ( $ model ) ; $ rp - > set Accessible ( false ) ; return $ id ; } 
public function execute ( $ request ) { Request Not Supported Exception : : assert Supports ( $ this , $ request ) ; if ( false = = $ token = $ this - > token Storage - > find ( $ request - > get Hash ( ) ) ) { throw new Logic Exception ( sprintf ( 'The token %s could not be found ' , $ request - > get Hash ( ) ) ) ; } $ request - > set Token ( $ token ) ; } 
public function execute ( $ request ) { Request Not Supported Exception : : assert Supports ( $ this , $ request ) ; $ model = $ request - > get Model ( ) ; if ( isset ( $ model - > state ) & & 'approved ' = = $ model - > state ) { $ request - > mark Captured ( ) ; return ; } if ( isset ( $ model - > state ) & & 'created ' = = $ model - > state ) { $ request - > mark New ( ) ; return ; } if ( false = = isset ( $ model - > state ) ) { $ request - > mark New ( ) ; return ; } $ request - > mark Unknown ( ) ; } 
public function supports ( $ request ) { if ( false = = $ request instanceof Get Status Interface ) { return false ; } $ model = $ request - > get Model ( ) ; if ( false = = $ model instanceof Payment ) { return false ; } return true ; } 
public function on Execute ( Context $ context ) { $ this - > logger - > debug ( sprintf ( ' [Payum ] %d # %s : :execute ( %s ) ' , count ( $ context - > get Previous ( ) ) + 1 , Humanify : : value ( $ context - > get Action ( ) , false ) , Humanify : : request ( $ context - > get Request ( ) ) ) ) ; } 
public function on Post Execute ( Context $ context ) { if ( $ context - > get Reply ( ) ) { $ this - > logger - > debug ( sprintf ( ' [Payum ] %d # %s : :execute ( %s ) throws reply %s ' , count ( $ context - > get Previous ( ) ) + 1 , Humanify : : value ( $ context - > get Action ( ) ) , Humanify : : request ( $ context - > get Request ( ) ) , Humanify : : request ( $ context - > get Reply ( ) ) ) ) ; } elseif ( $ context - > get Exception ( ) ) { $ this - > logger - > debug ( sprintf ( ' [Payum ] %d # %s : :execute ( %s ) throws exception %s ' , count ( $ context - > get Previous ( ) ) + 1 , $ context - > get Action ( ) ? Humanify : : value ( $ context - > get Action ( ) ) : 'Gateway ' , Humanify : : request ( $ context - > get Request ( ) ) , Humanify : : value ( $ context - > get Exception ( ) ) ) ) ; } } 
public function build Form ( Form Builder Interface $ builder , array $ options ) { $ builder - > add ( 'gateway Name ' ) - > add ( 'factory Name ' , Gateway Factories Choice Type : : class ) ; $ builder - > add Event Listener ( Form Events : : PRE _SUBMIT , array ( $ this , 'build Credentials ' ) ) ; $ builder - > add Event Listener ( Form Events : : PRE _SET _DATA , array ( $ this , 'build Credentials ' ) ) ; } 
public function execute ( $ request ) { Request Not Supported Exception : : assert Supports ( $ this , $ request ) ; $ this - > gateway - > execute ( $ http Request = new Get Http Request ( ) ) ; 
public function execute ( $ request ) { Request Not Supported Exception : : assert Supports ( $ this , $ request ) ; $ model = Array Object : : ensure Array Object ( $ request - > get Model ( ) ) ; if ( $ model [ 'agreement Ref ' ] ) { throw new Logic Exception ( 'The agreement has already been created . ' ) ; } $ model - > validated Keys Set ( array ( 'merchant Ref ' , 'description ' , 'purchase Operation ' , 'max Amount ' , 'start Date ' , 'stop Date ' , ) ) ; $ model - > validate Not Empty ( array ( 'max Amount ' , 'merchant Ref ' , 'description ' , ) ) ; $ result = $ this - > api - > create ( ( array ) $ model ) ; $ model - > replace ( $ result ) ; } 
protected function populate Config ( Array Object $ config ) { $ config - > defaults ( array ( 'payum .factory _name ' = > 'paypal _express _checkout _nvp ' , 'payum .factory _title ' = > 'Pay Pal Express Checkout ' , 'payum .template .confirm _order ' = > ' @Payum Paypal Express Checkout /confirm Order .html .twig ' , 'payum .action .capture ' = > new Capture Action ( ) , 'payum .action .cancel ' = > new Cancel Action ( ) , 'payum .action .authorize ' = > new Authorize Action ( ) , 'payum .action .convert _payment ' = > new Convert Payment Action ( ) , 'payum .action .notify ' = > new Notify Action ( ) , 'payum .action .status ' = > new Payment Details Status Action ( ) , 'payum .action .sync ' = > new Payment Details Sync Action ( ) , 'payum .action .recurring _status ' = > new Recurring Payment Details Status Action ( ) , 'payum .action .recurring _sync ' = > new Recurring Payment Details Sync Action ( ) , 'payum .action .api .set _express _checkout ' = > new Set Express Checkout Action ( ) , 'payum .action .api .get _express _checkout _details ' = > new Get Express Checkout Details Action ( ) , 'payum .action .api .get _transaction _details ' = > new Get Transaction Details Action ( ) , 'payum .action .api .do _express _checkout _payment ' = > new Do Express Checkout Payment Action ( ) , 'payum .action .api .create _recurring _payment _profile ' = > new Create Recurring Payment Profile Action ( ) , 'payum .action .api .update _recurring _payment _profile ' = > new Update Recurring Payment Profile Action ( ) , 'payum .action .api .get _recurring _payments _profile _details ' = > new Get Recurring Payments Profile Details Action ( ) , 'payum .action .api .cancel _recurring _payments _profile ' = > new Cancel Recurring Payments Profile Action ( ) , 'payum .action .api .manage _recurring _payments _profile _status ' = > new Manage Recurring Payments Profile Status Action ( ) , 'payum .action .api .create _billing _agreement ' = > new Create Billing Agreement Action ( ) , 'payum .action .api .do _reference _transaction ' = > new Do Reference Transaction Action ( ) , 'payum .action .api .do _capture ' = > new Do Capture Action ( ) , 'payum .action .api .authorize _token ' = > new Authorize Token Action ( ) , 'payum .action .api .do _void ' = > new Do Void Action ( ) , 'payum .action .api .confirm _order ' = > function ( Array Object $ config ) { return new Confirm Order Action ( $ config [ 'payum .template .confirm _order ' ] ) ; } , 'payum .action .api .transaction _search ' = > new Transaction Search Action ( ) , ) ) ; if ( false = = $ config [ 'payum .api ' ] ) { $ config [ 'payum .default _options ' ] = array ( 'username ' = > ' ' , 'password ' = > ' ' , 'signature ' = > ' ' , 'sandbox ' = > true , ) ; $ config - > defaults ( $ config [ 'payum .default _options ' ] ) ; $ config [ 'payum .required _options ' ] = array ( 'username ' , 'password ' , 'signature ' ) ; $ config [ 'payum .api ' ] = function ( Array Object $ config ) { $ config - > validate Not Empty ( $ config [ 'payum .required _options ' ] ) ; $ paypal Config = array ( 'username ' = > $ config [ 'username ' ] , 'password ' = > $ config [ 'password ' ] , 'signature ' = > $ config [ 'signature ' ] , 'sandbox ' = > $ config [ 'sandbox ' ] , ) ; return new Api ( $ paypal Config , $ config [ 'payum .http _client ' ] , $ config [ 'httplug .message _factory ' ] ) ; } ; } $ config [ 'payum .paths ' ] = array _replace ( [ 'Payum Paypal Express Checkout ' = > _ _DIR _ _ . ' /Resources /views ' , ] , $ config [ 'payum .paths ' ] ? : [ ] ) ; } 
public function execute ( $ request ) { Request Not Supported Exception : : assert Supports ( $ this , $ request ) ; $ model = Array Object : : ensure Array Object ( $ request - > get Model ( ) ) ; $ transaction Index = 'PAYMENTREQUEST _ ' . $ request - > get Payment Request N ( ) . ' _TRANSACTIONID ' ; if ( false = = $ model [ $ transaction Index ] ) { throw new Logic Exception ( $ transaction Index . ' must be set . ' ) ; } $ result = $ this - > api - > get Transaction Details ( array ( 'TRANSACTIONID ' = > $ model [ $ transaction Index ] ) ) ; foreach ( $ result as $ name = > $ value ) { if ( in _array ( $ name , $ this - > get Payment Request NFields ( ) ) ) { $ model [ 'PAYMENTREQUEST _ ' . $ request - > get Payment Request N ( ) . ' _ ' . $ name ] = $ value ; } } } 
public function execute ( $ request ) { Request Not Supported Exception : : assert Supports ( $ this , $ request ) ; $ details = Array Object : : ensure Array Object ( $ request - > get Model ( ) ) ; $ details - > validate Not Empty ( 'PAYMENTREQUEST _ 0 _PAYMENTACTION ' ) ; $ details - > defaults ( array ( 'AUTHORIZE _TOKEN _USERACTION ' = > Api : : USERACTION _COMMIT , ) ) ; $ this - > gateway - > execute ( $ http Request = new Get Http Request ( ) ) ; if ( isset ( $ http Request - > query [ 'cancelled ' ] ) ) { $ details [ 'CANCELLED ' ] = true ; return ; } if ( false = = $ details [ 'TOKEN ' ] ) { if ( false = = $ details [ 'RETURNURL ' ] & & $ request - > get Token ( ) ) { $ details [ 'RETURNURL ' ] = $ request - > get Token ( ) - > get Target Url ( ) ; } if ( false = = $ details [ 'CANCELURL ' ] & & $ request - > get Token ( ) ) { $ details [ 'CANCELURL ' ] = $ request - > get Token ( ) - > get Target Url ( ) ; } if ( empty ( $ details [ 'PAYMENTREQUEST _ 0 _NOTIFYURL ' ] ) & & $ request - > get Token ( ) & & $ this - > token Factory ) { $ notify Token = $ this - > token Factory - > create Notify Token ( $ request - > get Token ( ) - > get Gateway Name ( ) , $ request - > get Token ( ) - > get Details ( ) ) ; $ details [ 'PAYMENTREQUEST _ 0 _NOTIFYURL ' ] = $ notify Token - > get Target Url ( ) ; } if ( $ details [ 'CANCELURL ' ] ) { $ cancel Uri = Http Uri : : create From String ( $ details [ 'CANCELURL ' ] ) ; $ modifier = new Merge Query ( 'cancelled = 1 ' ) ; $ cancel Uri = $ modifier - > process ( $ cancel Uri ) ; $ details [ 'CANCELURL ' ] = ( string ) $ cancel Uri ; } $ this - > gateway - > execute ( new Set Express Checkout ( $ details ) ) ; if ( $ details [ 'L _ERRORCODE 0 ' ] ) { return ; } } $ this - > gateway - > execute ( new Sync ( $ details ) ) ; if ( $ details [ 'PAYERID ' ] & & Api : : CHECKOUTSTATUS _PAYMENT _ACTION _NOT _INITIATED = = $ details [ 'CHECKOUTSTATUS ' ] & & $ details [ 'PAYMENTREQUEST _ 0 _AMT ' ] > 0 ) { if ( Api : : USERACTION _COMMIT ! = = $ details [ 'AUTHORIZE _TOKEN _USERACTION ' ] ) { $ confirm Order = new Confirm Order ( $ request - > get First Model ( ) ) ; $ confirm Order - > set Model ( $ request - > get Model ( ) ) ; $ this - > gateway - > execute ( $ confirm Order ) ; } $ this - > gateway - > execute ( new Do Express Checkout Payment ( $ details ) ) ; } if ( false = = $ details [ 'PAYERID ' ] ) { $ this - > gateway - > execute ( new Authorize Token ( $ details ) ) ; } $ this - > gateway - > execute ( new Sync ( $ details ) ) ; } 
public function finish View ( Form View $ view , Form Interface $ form , array $ options ) { if ( 'choice ' = = $ options [ 'widget ' ] ) { if ( empty ( $ view [ 'day ' ] - > vars [ 'value ' ] ) ) { $ view [ 'day ' ] - > vars [ 'value ' ] = $ view [ 'day ' ] - > vars [ 'choices ' ] [ 0 ] - > value ; } $ style = 'display :none ' ; if ( false = = empty ( $ view [ 'day ' ] - > vars [ 'attr ' ] [ 'style ' ] ) ) { $ style = $ view [ 'day ' ] - > vars [ 'attr ' ] [ 'style ' ] . ' ; ' . $ style ; } $ view [ 'day ' ] - > vars [ 'attr ' ] [ 'style ' ] = $ style ; } } 
public function configure Options ( Options Resolver $ resolver ) { $ resolver - > set Defaults ( array ( 'max _expiration _year ' = > date ( 'Y ' ) + 1 0 , 'min _expiration _year ' = > date ( 'Y ' ) , 'years ' = > function ( Options $ options ) { return range ( $ options [ 'min _expiration _year ' ] , $ options [ 'max _expiration _year ' ] ) ; } , ) ) ; } 
public function execute ( $ request ) { Request Not Supported Exception : : assert Supports ( $ this , $ request ) ; $ model = Array Object : : ensure Array Object ( $ request - > get Model ( ) ) ; $ payment Request N = $ request - > get Payment Request N ( ) ; $ fields = new Array Object ( [ ] ) ; foreach ( $ this - > get Payment Request NFields ( ) as $ field ) { $ fields [ $ field ] = $ model [ 'PAYMENTREQUEST _ ' . $ payment Request N . ' _ ' . $ field ] ; } $ fields [ 'AUTHORIZATIONID ' ] = $ fields [ 'TRANSACTIONID ' ] ; $ fields - > validate Not Empty ( [ 'AMT ' , 'COMPLETETYPE ' , 'AUTHORIZATIONID ' ] ) ; $ this - > api - > do Capture ( ( array ) $ fields ) ; $ this - > gateway - > execute ( new Get Transaction Details ( $ model , $ payment Request N ) ) ; } 
public function execute ( $ request ) { Request Not Supported Exception : : assert Supports ( $ this , $ request ) ; $ model = Array Object : : ensure Array Object ( $ request - > get Model ( ) ) ; try { Stripe : : set Api Key ( $ this - > keys - > get Secret Key ( ) ) ; $ plan = Plan : : create ( $ model - > to Unsafe Array Without Local ( ) ) ; $ model - > replace ( $ plan - > _ _to Array ( true ) ) ; } catch ( Error \ Base $ e ) { $ model - > replace ( $ e - > get Json Body ( ) ) ; } } 
public function update ( $ model ) { $ this - > assert Crypted ( $ model ) ; $ model - > encrypt ( $ this - > crypto ) ; $ this - > decorated Storage - > update ( $ model ) ; } 
public function find ( $ id ) { $ model = $ this - > decorated Storage - > find ( $ id ) ; $ this - > assert Crypted ( $ model ) ; $ model - > decrypt ( $ this - > crypto ) ; return $ model ; } 
public function find By ( array $ criteria ) { $ models = $ this - > decorated Storage - > find By ( $ criteria ) ; foreach ( $ models as $ model ) { $ this - > assert Crypted ( $ model ) ; $ model - > decrypt ( $ this - > crypto ) ; } return $ models ; } 
public function execute ( $ request ) { Request Not Supported Exception : : assert Supports ( $ this , $ request ) ; $ model = Array Object : : ensure Array Object ( $ request - > get Model ( ) ) ; if ( null ! = $ model [ 'response _code ' ] ) { return ; } if ( false = = $ model - > validate Not Empty ( array ( 'card _num ' , 'exp _date ' ) , false ) ) { try { $ obtain Credit Card = new Obtain Credit Card ( $ request - > get Token ( ) ) ; $ obtain Credit Card - > set Model ( $ request - > get First Model ( ) ) ; $ obtain Credit Card - > set Model ( $ request - > get Model ( ) ) ; $ this - > gateway - > execute ( $ obtain Credit Card ) ; $ card = $ obtain Credit Card - > obtain ( ) ; $ model [ 'exp _date ' ] = Sensitive Value : : ensure Sensitive ( $ card - > get Expire At ( ) - > format ( 'm /y ' ) ) ; $ model [ 'card _num ' ] = Sensitive Value : : ensure Sensitive ( $ card - > get Number ( ) ) ; $ model [ 'card _code ' ] = Sensitive Value : : ensure Sensitive ( $ card - > get Security Code ( ) ) ; } catch ( Request Not Supported Exception $ e ) { throw new Logic Exception ( 'Credit card details has to be set explicitly or there has to be an action that supports Obtain Credit Card request . ' ) ; } } $ api = clone $ this - > api ; $ api - > ignore _not _x _fields = true ; $ api - > set Fields ( array _filter ( $ model - > to Unsafe Array ( ) ) ) ; $ response = $ api - > authorize And Capture ( ) ; $ model - > replace ( get _object _vars ( $ response ) ) ; } 
public function execute ( $ request ) { Request Not Supported Exception : : assert Supports ( $ this , $ request ) ; $ model = new Array Object ( $ request - > get Model ( ) ) ; if ( null = = = $ model [ 'RESULT ' ] ) { $ request - > mark New ( ) ; return ; } if ( false = = is _numeric ( $ model [ 'RESULT ' ] ) ) { $ request - > mark Unknown ( ) ; return ; } if ( $ model [ 'RESULT ' ] > 0 ) { $ request - > mark Failed ( ) ; return ; } if ( $ model [ 'ORIGID ' ] & & Api : : TRXTYPE _CREDIT = = $ model [ 'TRXTYPE ' ] & & Api : : RESULT _SUCCESS = = $ model [ 'RESULT ' ] ) { $ request - > mark Refunded ( ) ; return ; } if ( Api : : TRXTYPE _SALE = = $ model [ 'TRXTYPE ' ] & & Api : : RESULT _SUCCESS = = $ model [ 'RESULT ' ] ) { $ request - > mark Captured ( ) ; return ; } $ request - > mark Unknown ( ) ; } 
public function find ( $ id ) { if ( $ id instanceof Identity Interface ) { if ( ltrim ( $ id - > get Class ( ) , ' \ \ ' ) = = = ltrim ( $ this - > model Class , ' \ \ ' ) ) { return $ this - > do Find ( $ id - > get Id ( ) ) ; } return ; } return $ this - > do Find ( $ id ) ; } 
protected function assert Model Supported ( $ model ) { if ( false = = $ this - > support ( $ model ) ) { throw new Invalid Argument Exception ( sprintf ( 'Invalid model given . Should be instance of %s but it is %s ' , $ this - > model Class , is _object ( $ model ) ? get _class ( $ model ) : gettype ( $ model ) ) ) ; } } 
public function get Gateway ( $ name ) { $ gateway = parent : : get Gateway ( $ name ) ; if ( $ this - > add Storage Extensions ) { $ this - > add Storage To Gateway ( $ name , $ gateway ) ; } return $ gateway ; } 
protected function add Storage To Gateway ( $ name , Gateway Interface $ gateway ) { if ( false = = $ gateway instanceof Gateway ) { return ; } if ( isset ( $ this - > initialized Storage Extensions [ $ name ] ) ) { return ; } foreach ( $ this - > get Storages ( ) as $ storage ) { $ gateway - > add Extension ( new Storage Extension ( $ storage ) ) ; } $ this - > initialized Storage Extensions [ $ name ] = true ; } 
protected function populate Config ( Array Object $ config ) { $ config - > defaults ( [ 'payum .factory _name ' = > 'paypal _pro _hosted ' , 'payum .factory _title ' = > 'Paypal Pro Hosted ' , 'payum .action .capture ' = > new Capture Action ( ) , 'payum .action .notify ' = > new Notify Action ( ) , 'payum .action .status ' = > new Status Action ( ) , 'payum .action .sync ' = > new Sync Action ( ) , 'payum .action .convert _payment ' = > new Convert Payment Action ( ) , 'payum .action .api .get _transaction _details ' = > new Get Transaction Details Action ( ) , 'payum .action .api .create _button _payment ' = > new Create Button Payment Action ( ) , ] ) ; if ( false = = $ config [ 'payum .api ' ] ) { $ config [ 'payum .default _options ' ] = [ 'username ' = > ' ' , 'password ' = > ' ' , 'signature ' = > ' ' , 'business ' = > ' ' , 'sandbox ' = > true , ] ; $ config - > defaults ( $ config [ 'payum .default _options ' ] ) ; $ config [ 'payum .required _options ' ] = [ 'username ' , 'password ' , 'signature ' , ] ; $ config [ 'payum .api ' ] = function ( Array Object $ config ) { $ config - > validate Not Empty ( $ config [ 'payum .required _options ' ] ) ; $ paypal Config = array ( 'username ' = > $ config [ 'username ' ] , 'password ' = > $ config [ 'password ' ] , 'signature ' = > $ config [ 'signature ' ] , 'business ' = > $ config [ 'business ' ] , 'sandbox ' = > $ config [ 'sandbox ' ] , ) ; return new Api ( $ paypal Config , $ config [ 'payum .http _client ' ] , $ config [ 'httplug .message _factory ' ] ) ; } ; } } 
public function execute ( $ request ) { Request Not Supported Exception : : assert Supports ( $ this , $ request ) ; $ details = Array Object : : ensure Array Object ( $ request - > get Model ( ) ) ; $ klarna = $ this - > get Klarna ( ) ; try { $ this - > gateway - > execute ( new Populate Klarna From Details ( $ details , $ klarna ) ) ; $ details [ 'updated ' ] = $ klarna - > update ( $ details [ 'rno ' ] ) ; } catch ( \ Klarna Exception $ e ) { $ this - > populate Details With Error ( $ details , $ e , $ request ) ; } } 
public static function value ( $ value , $ short Class = true ) { if ( is _object ( $ value ) ) { if ( $ short Class ) { $ ro = new \ Reflection Object ( $ value ) ; return $ ro - > get Short Name ( ) ; } return get _class ( $ value ) ; } return gettype ( $ value ) ; } 
public function execute ( $ request ) { Request Not Supported Exception : : assert Supports ( $ this , $ request ) ; $ details = Array Object : : ensure Array Object ( $ request - > get Model ( ) ) ; if ( ! isset ( $ details [ 'status ' ] ) & & isset ( $ details [ 'transaction _id ' ] ) & & isset ( $ details [ 'expires ' ] ) & & $ details [ 'expires ' ] < time ( ) ) { $ request - > mark Expired ( ) ; return ; } if ( ! isset ( $ details [ 'transaction _id ' ] ) | | ! strlen ( $ details [ 'transaction _id ' ] ) ) { $ request - > mark New ( ) ; return ; } if ( ! isset ( $ details [ 'status ' ] ) ) { $ request - > mark New ( ) ; return ; } $ subcode = isset ( $ details [ 'status Reason ' ] ) ? $ details [ 'status Reason ' ] : null ; switch ( $ details [ 'status ' ] ) { case Api : : STATUS _LOSS : $ request - > mark Failed ( ) ; break ; case Api : : STATUS _PENDING : $ request - > mark Pending ( ) ; break ; case Api : : STATUS _RECEIVED : switch ( $ subcode ) { case Api : : SUB _PARTIALLY : $ request - > mark Unknown ( ) ; break ; case Api : : SUB _CREDITED : case Api : : SUB _OVERPAYMENT : $ request - > mark Captured ( ) ; break ; } break ; case Api : : STATUS _REFUNDED : switch ( $ subcode ) { default : case Api : : SUB _COMPENSATION : $ request - > mark Unknown ( ) ; break ; case Api : : SUB _REFUNDED : $ request - > mark Refunded ( ) ; break ; } break ; case Api : : STATUS _UNTRACEABLE : $ request - > mark Captured ( ) ; break ; default : $ request - > mark Unknown ( ) ; break ; } } 
protected function populate Config ( Array Object $ config ) { if ( false = = class _exists ( Stripe : : class ) ) { throw new Logic Exception ( 'You must install "stripe /stripe -php : ~ 2 . 0 | ~ 3 . 0 " library . ' ) ; } $ config - > defaults ( [ 'payum .factory _name ' = > 'stripe _checkout ' , 'payum .factory _title ' = > 'Stripe Checkout ' , 'payum .template .obtain _token ' = > ' @Payum Stripe /Action /obtain _checkout _token .html .twig ' , 'payum .action .capture ' = > new Capture Action ( ) , 'payum .action .convert _payment ' = > new Convert Payment Action ( ) , 'payum .action .status ' = > new Status Action ( ) , 'payum .action .get _credit _card _token ' = > new Get Credit Card Token Action ( ) , 'payum .action .obtain _token ' = > function ( Array Object $ config ) { return new Obtain Token Action ( $ config [ 'payum .template .obtain _token ' ] ) ; } , 'payum .action .create _charge ' = > new Create Charge Action ( ) , 'payum .action .create _customer ' = > new Create Customer Action ( ) , 'payum .action .create _plan ' = > new Create Plan Action ( ) , 'payum .action .create _token ' = > new Create Token Action ( ) , 'payum .action .create _subscription ' = > new Create Subscription Action ( ) , 'payum .extension .create _customer ' = > new Create Customer Extension ( ) , ] ) ; if ( false = = $ config [ 'payum .api ' ] ) { $ config [ 'payum .default _options ' ] = [ 'publishable _key ' = > ' ' , 'secret _key ' = > ' ' ] ; $ config - > defaults ( $ config [ 'payum .default _options ' ] ) ; $ config [ 'payum .required _options ' ] = [ 'publishable _key ' , 'secret _key ' ] ; $ config [ 'payum .api ' ] = function ( Array Object $ config ) { $ config - > validate Not Empty ( $ config [ 'payum .required _options ' ] ) ; return new Keys ( $ config [ 'publishable _key ' ] , $ config [ 'secret _key ' ] ) ; } ; } $ config [ 'payum .paths ' ] = array _replace ( [ 'Payum Stripe ' = > _ _DIR _ _ . ' /Resources /views ' , ] , $ config [ 'payum .paths ' ] ? : [ ] ) ; } 
public function execute ( $ request ) { Request Not Supported Exception : : assert Supports ( $ this , $ request ) ; $ request - > method = isset ( $ _SERVER [ 'REQUEST _METHOD ' ] ) ? $ _SERVER [ 'REQUEST _METHOD ' ] : 'GET ' ; $ request - > query = $ _GET ; $ request - > request = $ _REQUEST ; $ request - > client Ip = isset ( $ _SERVER [ 'REMOTE _ADDR ' ] ) ? $ _SERVER [ 'REMOTE _ADDR ' ] : ' ' ; $ request - > uri = isset ( $ _SERVER [ 'REQUEST _URI ' ] ) ? $ _SERVER [ 'REQUEST _URI ' ] : ' ' ; $ request - > user Agent = isset ( $ _SERVER [ 'HTTP _USER _AGENT ' ] ) ? $ _SERVER [ 'HTTP _USER _AGENT ' ] : ' ' ; $ request - > content = file _get _contents ( 'php : / /input ' ) ; } 
public static function create Guzzle ( ) { $ client = null ; if ( ! class _exists ( Client : : class ) ) { @ trigger _error ( 'The function "Http Client Factory : :create Guzzle " is depcrecated and will be removed in 2 . 0 . ' , E _USER _DEPRECATED ) ; throw new \ Logic Exception ( 'Can not use "Http Client Factory : :create Guzzle " since Guzzle is not installed . This function is deprecated and will be removed in 2 . 0 . ' ) ; } $ version = \ Guzzle Http \ Client Interface : : VERSION ; if ( substr ( $ version , 0 , 1 ) ! = = ' 6 ' ) { throw new \ Logic Exception ( 'This version of Guzzle is not supported . ' ) ; } $ curl = curl _version ( ) ; $ curl Options = [ CURLOPT _USERAGENT = > sprintf ( 'Payum / 1 .x curl / %s PHP / %s ' , $ curl [ 'version ' ] , phpversion ( ) ) , ] ; return new \ Guzzle Http \ Client ( [ 'curl ' = > $ curl Options , ] ) ; } 
public function execute ( $ request ) { Request Not Supported Exception : : assert Supports ( $ this , $ request ) ; $ currency = is _numeric ( $ request - > code ) ? $ this - > iso 4 2 1 7 - > find By Numeric ( $ request - > code ) : $ this - > iso 4 2 1 7 - > find By Alpha 3 ( $ request - > code ) ; $ request - > alpha 3 = $ currency - > get Alpha 3 ( ) ; $ request - > country = $ currency - > get Country ( ) ; $ request - > exp = $ currency - > get Exp ( ) ; $ request - > name = $ currency - > get Name ( ) ; $ request - > numeric = $ currency - > get Numeric ( ) ; } 
public function build ( Array Object $ config ) { $ action = new Obtain Credit Card Action ( $ this - > form Factory , $ config [ 'payum .template .obtain _credit _card ' ] ) ; $ action - > set Request Stack ( $ this - > request Stack ) ; return $ action ; } 
protected function populate Config ( Array Object $ config ) { if ( ! class _exists ( 'Klarna Currency ' ) ) { throw new \ Logic Exception ( 'You must install "fp /klarna -invoice " library . ' ) ; } $ config - > defaults ( array ( 'payum .factory _name ' = > 'klarna _invoice ' , 'payum .factory _title ' = > 'Klarna Invoice ' , 'sandbox ' = > true , 'p Class Storage ' = > 'json ' , 'p Class Storage Path ' = > ' . /pclasses .json ' , 'xml Rpc Verify Host ' = > 2 , 'xml Rpc Verify Peer ' = > true , 'payum .action .capture ' = > new Capture Action ( ) , 'payum .action .authorize ' = > new Authorize Action ( ) , 'payum .action .status ' = > new Status Action ( ) , 'payum .action .sync ' = > new Sync Action ( ) , 'payum .action .refund ' = > new Refund Action ( ) , 'payum .action .api .activate ' = > new Activate Action ( ) , 'payum .action .api .activate _reservation ' = > new Activate Reservation Action ( ) , 'payum .action .api .cancel _reservation ' = > new Cancel Reservation Action ( ) , 'payum .action .api .check _order _status ' = > new Check Order Status Action ( ) , 'payum .action .api .get _addresses ' = > new Get Addresses Action ( ) , 'payum .action .api .populate _klarna _from _details ' = > new Populate Klarna From Details Action ( ) , 'payum .action .api .credit _invoice ' = > new Credit Invoice Action ( ) , 'payum .action .api .credit _part ' = > new Credit Part Action ( ) , 'payum .action .api .reserve _amount ' = > new Reserve Amount Action ( ) , 'payum .action .api .return _amount ' = > new Return Amount Action ( ) , 'payum .action .api .email _invoice ' = > new Email Invoice Action ( ) , 'payum .action .api .send _invoice ' = > new Send Invoice Action ( ) , 'payum .action .api .update ' = > new Update Action ( ) , ) ) ; if ( false = = $ config [ 'payum .api ' ] ) { $ config [ 'payum .default _options ' ] = array ( 'eid ' = > ' ' , 'secret ' = > ' ' , 'country ' = > ' ' , 'language ' = > ' ' , 'currency ' = > ' ' , 'sandbox ' = > true , ) ; $ config - > defaults ( $ config [ 'payum .default _options ' ] ) ; $ config [ 'payum .required _options ' ] = array ( 'eid ' , 'secret ' , 'country ' , 'language ' , 'currency ' ) ; $ config - > defaults ( array ( 'sandbox ' = > true , ) ) ; $ config [ 'payum .api ' ] = function ( Array Object $ config ) { $ config - > validate Not Empty ( $ config [ 'payum .required _options ' ] ) ; $ config [ 'mode ' ] = $ config [ 'sandbox ' ] ? \ Klarna : : BETA : \ Klarna : : LIVE ; if ( null = = = $ country = \ Klarna Country : : from Code ( $ config [ 'country ' ] ) ) { throw new Logic Exception ( sprintf ( 'Given %s country code is not valid . Klarna cannot recognize it . ' , $ config [ 'country ' ] ) ) ; } if ( null = = = $ language = \ Klarna Language : : from Code ( $ config [ 'language ' ] ) ) { throw new Logic Exception ( sprintf ( 'Given %s language code is not valid . Klarna cannot recognize it . ' , $ config [ 'language ' ] ) ) ; } if ( null = = = $ currency = \ Klarna Currency : : from Code ( $ config [ 'currency ' ] ) ) { throw new Logic Exception ( sprintf ( 'Given %s currency code is not valid . Klarna cannot recognize it . ' , $ config [ 'currency ' ] ) ) ; } $ klarna Config = new Config ( ) ; $ klarna Config - > eid = $ config [ 'eid ' ] ; $ klarna Config - > secret = $ config [ 'secret ' ] ; $ klarna Config - > mode = $ config [ 'mode ' ] ; $ klarna Config - > country = $ country ; $ klarna Config - > language = $ language ; $ klarna Config - > currency = $ currency ; $ klarna Config - > p Class Storage = $ config [ 'p Class Storage ' ] ; $ klarna Config - > p Class Storage Path = $ config [ 'p Class Storage Path ' ] ; $ klarna Config - > xml Rpc Verify Host = $ config [ 'xml Rpc Verify Host ' ] ; $ klarna Config - > xml Rpc Verify Host = $ config [ 'xml Rpc Verify Host ' ] ; return $ klarna Config ; } ; } } 
public function execute ( $ request ) { Request Not Supported Exception : : assert Supports ( $ this , $ request ) ; $ this - > gateway - > execute ( new Auto Pay Agreement ( $ request - > get Model ( ) ) ) ; } 
public function execute ( $ request ) { Request Not Supported Exception : : assert Supports ( $ this , $ request ) ; $ model = Array Object : : ensure Array Object ( $ request - > get Model ( ) ) ; if ( $ model [ 'reservation ' ] ) { return ; } $ model [ 'activate ' ] = false ; $ backup Config = clone $ this - > api ; $ token = $ model [ 'recurring _token ' ] ; try { unset ( $ model [ 'recurring _token ' ] ) ; $ base Uri = Constants : : BASE _URI _LIVE = = $ backup Config - > base Uri ? Constants : : BASE _URI _RECURRING _LIVE : Constants : : BASE _URI _RECURRING _SANDBOX ; $ this - > api - > content Type = Constants : : CONTENT _TYPE _RECURRING _ORDER _V 1 ; $ this - > api - > accept Header = Constants : : ACCEPT _HEADER _RECURRING _ORDER _ACCEPTED _V 1 ; $ this - > api - > base Uri = str _replace ( ' {recurring _token } ' , $ token , $ base Uri ) ; $ this - > gateway - > execute ( $ create Order Request = new Create Order ( $ model ) ) ; $ model - > replace ( $ create Order Request - > get Order ( ) - > marshal ( ) ) ; } catch ( \ Exception $ e ) { $ this - > api - > content Type = $ backup Config - > content Type ; $ this - > api - > accept Header = $ backup Config - > accept Header ; $ this - > api - > base Uri = $ backup Config - > base Uri ; $ model [ 'recurring _token ' ] = $ token ; throw $ e ; } $ model [ 'recurring _token ' ] = $ token ; $ this - > api - > content Type = $ backup Config - > content Type ; $ this - > api - > accept Header = $ backup Config - > accept Header ; $ this - > api - > base Uri = $ backup Config - > base Uri ; } 
public function supports ( $ request ) { if ( false = = ( $ request instanceof Authorize & & $ request - > get Model ( ) instanceof \ Array Access ) ) { return false ; } $ model = Array Object : : ensure Array Object ( $ request - > get Model ( ) ) ; return false = = $ model [ 'recurring ' ] & & $ model [ 'recurring _token ' ] ; } 
public function execute ( $ request ) { Request Not Supported Exception : : assert Supports ( $ this , $ request ) ; $ payout = $ request - > get Source ( ) ; $ details = Array Object : : ensure Array Object ( $ payout - > get Details ( ) ) ; $ details [ 'amount ' ] = $ payout - > get Total Amount ( ) ; $ details [ 'currency ' ] = $ payout - > get Currency Code ( ) ; $ details [ 'description ' ] = $ payout - > get Description ( ) ; $ details [ 'recipient _email ' ] = $ payout - > get Recipient Email ( ) ; $ details [ 'recipient _id ' ] = $ payout - > get Recipient Id ( ) ; $ details - > defaults ( array ( Constants : : FIELD _PAYOUT = > true , ) ) ; $ request - > set Result ( ( array ) $ details ) ; } 
public function execute ( $ request ) { Request Not Supported Exception : : assert Supports ( $ this , $ request ) ; $ model = $ request - > get Model ( ) ; $ details = $ model - > get Details ( ) ; if ( is _array ( $ details ) ) { $ details = Array Object : : ensure Array Object ( $ details ) ; } $ request - > set Model ( $ details ) ; try { $ this - > gateway - > execute ( $ request ) ; } finally { if ( $ model instanceof Details Aware Interface ) { $ model - > set Details ( $ details ) ; } } } 
protected function populate Config ( Array Object $ config ) { if ( ! class _exists ( \ Authorize Net AIM : : class ) ) { throw new \ Logic Exception ( 'You must install "authorizenet /authorizenet " library . ' ) ; } $ config - > defaults ( array ( 'payum .factory _name ' = > 'authorize _net _aim ' , 'payum .factory _title ' = > 'Authorize .NET AIM ' , 'payum .action .capture ' = > new Capture Action ( ) , 'payum .action .status ' = > new Status Action ( ) , 'payum .action .convert _payment ' = > new Convert Payment Action ( ) , ) ) ; if ( false = = $ config [ 'payum .api ' ] ) { $ config [ 'payum .default _options ' ] = array ( 'login _id ' = > ' ' , 'transaction _key ' = > ' ' , 'sandbox ' = > true , ) ; $ config - > defaults ( $ config [ 'payum .default _options ' ] ) ; $ config [ 'payum .required _options ' ] = array ( 'login _id ' , 'transaction _key ' ) ; $ config [ 'payum .api ' ] = function ( Array Object $ config ) { $ config - > validate Not Empty ( $ config [ 'payum .required _options ' ] ) ; $ api = new Authorize Net AIM ( $ config [ 'login _id ' ] , $ config [ 'transaction _key ' ] ) ; $ api - > set Sandbox ( $ config [ 'sandbox ' ] ) ; return $ api ; } ; } } 
public function execute ( $ request ) { Request Not Supported Exception : : assert Supports ( $ this , $ request ) ; $ model = Array Object : : ensure Array Object ( $ request - > get Model ( ) ) ; if ( false = = ( $ model [ 'card ' ] | | $ model [ 'customer ' ] ) ) { throw new Logic Exception ( 'The either card token or customer id has to be set . ' ) ; } if ( is _array ( $ model [ 'card ' ] ) ) { throw new Logic Exception ( 'The token has already been used . ' ) ; } try { Stripe : : set Api Key ( $ this - > keys - > get Secret Key ( ) ) ; $ charge = Charge : : create ( $ model - > to Unsafe Array Without Local ( ) ) ; $ model - > replace ( $ charge - > _ _to Array ( true ) ) ; } catch ( Error \ Base $ e ) { $ model - > replace ( $ e - > get Json Body ( ) ) ; } } 
public function execute ( $ request ) { Request Not Supported Exception : : assert Supports ( $ this , $ request ) ; $ model = Array Object : : ensure Array Object ( $ request - > get Model ( ) ) ; if ( $ model [ 'error _code ' ] ) { $ request - > mark Failed ( ) ; return ; } if ( $ model [ 'invoice _number ' ] ) { $ request - > mark Captured ( ) ; return ; } if ( $ model [ 'reservation ' ] ) { $ request - > mark Authorized ( ) ; return ; } if ( false = = $ model [ 'status ' ] | | Constants : : STATUS _CHECKOUT _INCOMPLETE = = $ model [ 'status ' ] ) { $ request - > mark New ( ) ; return ; } if ( Constants : : STATUS _CHECKOUT _COMPLETE = = $ model [ 'status ' ] ) { $ request - > mark Pending ( ) ; return ; } $ request - > mark Unknown ( ) ; } 
public function execute ( $ request ) { Request Not Supported Exception : : assert Supports ( $ this , $ request ) ; $ this - > gateway - > execute ( new Check Agreement ( $ request - > get Model ( ) ) ) ; } 
public function supports ( $ request ) { return $ request instanceof Sync & & $ request - > get Model ( ) instanceof \ Array Access & & 
public function initialize ( array $ parameters ) { $ parameters [ 'account Number ' ] = $ this - > options [ 'account _number ' ] ; 
public function complete ( array $ parameters ) { $ parameters [ 'account Number ' ] = $ this - > options [ 'account _number ' ] ; $ parameters [ 'hash ' ] = $ this - > calculate Hash ( $ parameters , array ( 'account Number ' , 'order Ref ' , ) ) ; return $ this - > call ( 'Complete ' , $ parameters , $ this - > get Px Order Wsdl ( ) ) ; } 
public function check ( array $ parameters ) { $ parameters [ 'account Number ' ] = $ this - > options [ 'account _number ' ] ; $ parameters [ 'hash ' ] = $ this - > calculate Hash ( $ parameters , array ( 'account Number ' , 'transaction Number ' , ) ) ; return $ this - > call ( 'Check 2 ' , $ parameters , $ this - > get Px Order Wsdl ( ) ) ; } 
public function execute ( $ request ) { Request Not Supported Exception : : assert Supports ( $ this , $ request ) ; $ model = Array Object : : ensure Array Object ( $ request - > get Model ( ) ) ; if ( $ model [ 'order Ref ' ] ) { throw new Logic Exception ( 'The order has already been initialized . ' ) ; } $ model - > validated Keys Set ( array ( 'price ' , 'price Arg List ' , 'vat ' , 'currency ' , 'order Id ' , 'product Number ' , 'purchase Operation ' , 'view ' , 'description ' , 'additional Values ' , 'return Url ' , 'cancel Url ' , 'client IPAddress ' , 'client Identifier ' , 'agreement Ref ' , 'client Language ' , ) ) ; $ result = $ this - > api - > initialize ( ( array ) $ model ) ; $ model - > replace ( $ result ) ; if ( $ model [ 'redirect Url ' ] ) { throw new Http Redirect ( $ model [ 'redirect Url ' ] ) ; } } 
public function on Pre Execute ( Context $ context ) { $ event = new Execute Event ( $ context ) ; $ this - > dispatcher - > dispatch ( Payum Events : : GATEWAY _PRE _EXECUTE , $ event ) ; } 
public function on Execute ( Context $ context ) { $ event = new Execute Event ( $ context ) ; $ this - > dispatcher - > dispatch ( Payum Events : : GATEWAY _EXECUTE , $ event ) ; } 
public function on Post Execute ( Context $ context ) { $ event = new Execute Event ( $ context ) ; $ this - > dispatcher - > dispatch ( Payum Events : : GATEWAY _POST _EXECUTE , $ event ) ; } 
public function execute ( $ request ) { Request Not Supported Exception : : assert Supports ( $ this , $ request ) ; $ model = Array Object : : ensure Array Object ( $ request - > get Model ( ) ) ; if ( false = = $ model [ 'PROFILEID ' ] ) { return ; } $ this - > gateway - > execute ( new Get Recurring Payments Profile Details ( $ model ) ) ; } 
public function supports ( $ request ) { if ( false = = $ request instanceof Sync ) { return false ; } $ model = $ request - > get Model ( ) ; if ( false = = $ model instanceof \ Array Access ) { return false ; } return isset ( $ model [ 'BILLINGPERIOD ' ] ) & & null ! = = $ model [ 'BILLINGPERIOD ' ] ; } 
public function execute ( $ request ) { Request Not Supported Exception : : assert Supports ( $ this , $ request ) ; $ details = Array Object : : ensure Array Object ( $ request - > get Model ( ) ) ; if ( false = = $ details [ 'transaction _id ' ] ) { if ( false = = $ details [ 'success _url ' ] & & $ request - > get Token ( ) ) { $ details [ 'success _url ' ] = $ request - > get Token ( ) - > get Target Url ( ) ; } if ( false = = $ details [ 'abort _url ' ] & & $ request - > get Token ( ) ) { $ details [ 'abort _url ' ] = $ request - > get Token ( ) - > get Target Url ( ) ; } if ( false = = $ details [ 'notification _url ' ] & & $ request - > get Token ( ) & & $ this - > token Factory ) { $ notify Token = $ this - > token Factory - > create Notify Token ( $ request - > get Token ( ) - > get Gateway Name ( ) , $ request - > get Token ( ) - > get Details ( ) ) ; $ details [ 'notification _url ' ] = $ notify Token - > get Target Url ( ) ; } $ this - > gateway - > execute ( new Create Transaction ( $ details ) ) ; } $ this - > gateway - > execute ( new Sync ( $ details ) ) ; } 
public function do Sale ( array $ fields ) { $ fields [ 'TRXTYPE ' ] = self : : TRXTYPE _SALE ; $ this - > add Authorize Fields ( $ fields ) ; $ result = $ this - > do Request ( $ fields ) ; $ result [ 'TRXTYPE ' ] = self : : TRXTYPE _SALE ; return $ result ; } 
public function do Credit ( array $ fields ) { $ fields [ 'TRXTYPE ' ] = self : : TRXTYPE _CREDIT ; $ this - > add Authorize Fields ( $ fields ) ; $ result = $ this - > do Request ( $ fields ) ; $ result [ 'TRXTYPE ' ] = self : : TRXTYPE _CREDIT ; return $ result ; } 
protected function do Get Identity ( $ model ) { $ model Metadata = $ this - > object Manager - > get Class Metadata ( get _class ( $ model ) ) ; $ id = $ model Metadata - > get Identifier Values ( $ model ) ; if ( count ( $ id ) > 1 ) { throw new \ Logic Exception ( 'Storage not support composite primary ids ' ) ; } return new Identity ( array _shift ( $ id ) , $ model ) ; } 
public function execute ( $ request ) { Request Not Supported Exception : : assert Supports ( $ this , $ request ) ; $ details = Array Object : : ensure Array Object ( $ request - > get Model ( ) ) ; if ( ! isset ( $ details [ 'transaction _id ' ] ) ) { throw new Logic Exception ( 'The parameter "transaction _id " must be set . Have you run Create Transaction Action ? ' ) ; } if ( ! isset ( $ details [ 'refund _amount ' ] ) ) { if ( ! isset ( $ details [ 'amount ' ] ) ) { throw new Logic Exception ( 'One of the parameters "refund _amount " or "amount " must be set . ' ) ; } $ details [ 'refund _amount ' ] = $ details [ 'amount ' ] ; } $ details - > replace ( $ this - > api - > refund Transaction ( ( array ) $ details ) ) ; } 
public function execute ( $ request ) { Request Not Supported Exception : : assert Supports ( $ this , $ request ) ; $ model = Array Object : : ensure Array Object ( $ request - > get Model ( ) ) ; $ merchant = Array Object : : ensure Array Object ( $ model [ 'merchant ' ] ? : [ ] ) ; if ( false = = $ merchant [ 'checkout _uri ' ] & & $ this - > api - > checkout Uri ) { $ merchant [ 'checkout _uri ' ] = $ this - > api - > checkout Uri ; } if ( false = = $ merchant [ 'terms _uri ' ] & & $ this - > api - > terms Uri ) { $ merchant [ 'terms _uri ' ] = $ this - > api - > terms Uri ; } if ( false = = $ merchant [ 'confirmation _uri ' ] & & $ request - > get Token ( ) ) { $ merchant [ 'confirmation _uri ' ] = $ request - > get Token ( ) - > get Target Url ( ) ; } if ( empty ( $ merchant [ 'push _uri ' ] ) & & $ request - > get Token ( ) & & $ this - > token Factory ) { $ notify Token = $ this - > token Factory - > create Notify Token ( $ request - > get Token ( ) - > get Gateway Name ( ) , $ request - > get Token ( ) - > get Details ( ) ) ; $ merchant [ 'push _uri ' ] = $ notify Token - > get Target Url ( ) ; } $ merchant - > validate Not Empty ( [ 'checkout _uri ' , 'terms _uri ' , 'confirmation _uri ' , 'push _uri ' ] ) ; $ model [ 'merchant ' ] = ( array ) $ merchant ; if ( false = = $ model [ 'location ' ] ) { $ create Order Request = new Create Order ( $ model ) ; $ this - > gateway - > execute ( $ create Order Request ) ; $ model - > replace ( $ create Order Request - > get Order ( ) - > marshal ( ) ) ; $ model [ 'location ' ] = $ create Order Request - > get Order ( ) - > get Location ( ) ; } $ this - > gateway - > execute ( new Sync ( $ model ) ) ; if ( Constants : : STATUS _CHECKOUT _INCOMPLETE = = $ model [ 'status ' ] ) { $ render Template = new Render Template ( $ this - > template Name , array ( 'snippet ' = > $ model [ 'gui ' ] [ 'snippet ' ] , ) ) ; $ this - > gateway - > execute ( $ render Template ) ; throw new Http Response ( $ render Template - > get Result ( ) ) ; } } 
public function convert ( Reply Interface $ reply ) { if ( $ reply instanceof Symfony Http Response ) { return $ reply - > get Response ( ) ; } elseif ( $ reply instanceof Http Response ) { $ headers = $ reply - > get Headers ( ) ; $ headers [ 'X -Status -Code ' ] = $ reply - > get Status Code ( ) ; return new Response ( $ reply - > get Content ( ) , $ reply - > get Status Code ( ) , $ headers ) ; } $ ro = new \ Reflection Object ( $ reply ) ; throw new Logic Exception ( sprintf ( 'Cannot convert reply %s to http response . ' , $ ro - > get Short Name ( ) ) , null , $ reply ) ; } 
public function execute ( $ request ) { Request Not Supported Exception : : assert Supports ( $ this , $ request ) ; $ model = Array Object : : ensure Array Object ( $ request - > get Model ( ) ) ; if ( false = = $ model [ 'location ' ] ) { throw new Logic Exception ( 'Location has to be provided to fetch an order ' ) ; } $ this - > call With Retry ( function ( ) use ( $ model , $ request ) { $ order = new \ Klarna _Checkout _Order ( $ this - > get Connector ( ) , $ model [ 'location ' ] ) ; $ order - > fetch ( ) ; $ request - > set Order ( $ order ) ; } ) ; } 
public function execute ( $ request ) { Request Not Supported Exception : : assert Supports ( $ this , $ request ) ; $ payout = $ request - > get Model ( ) ; $ this - > gateway - > execute ( $ status = new Get Human Status ( $ payout ) ) ; if ( $ status - > is New ( ) ) { $ this - > gateway - > execute ( $ convert = new Convert ( $ payout , 'array ' , $ request - > get Token ( ) ) ) ; $ payout - > set Details ( $ convert - > get Result ( ) ) ; } $ details = Array Object : : ensure Array Object ( $ payout - > get Details ( ) ) ; $ request - > set Model ( $ details ) ; try { $ this - > gateway - > execute ( $ request ) ; } finally { $ payout - > set Details ( $ details ) ; } } 
public function execute ( $ request ) { Request Not Supported Exception : : assert Supports ( $ this , $ request ) ; $ model = new Array Object ( $ request - > get Model ( ) ) ; if ( is _numeric ( $ model [ 'RESULT ' ] ) ) { return ; } $ card Fields = array ( 'ACCT ' , 'CVV 2 ' , 'EXPDATE ' ) ; if ( false = = $ model - > validate Not Empty ( $ card Fields , false ) ) { try { $ obtain Credit Card = new Obtain Credit Card ( $ request - > get Token ( ) ) ; $ obtain Credit Card - > set Model ( $ request - > get First Model ( ) ) ; $ obtain Credit Card - > set Model ( $ request - > get Model ( ) ) ; $ this - > gateway - > execute ( $ obtain Credit Card ) ; $ card = $ obtain Credit Card - > obtain ( ) ; $ model [ 'EXPDATE ' ] = Sensitive Value : : ensure Sensitive ( $ card - > get Expire At ( ) - > format ( 'my ' ) ) ; $ model [ 'ACCT ' ] = Sensitive Value : : ensure Sensitive ( $ card - > get Number ( ) ) ; $ model [ 'CVV 2 ' ] = Sensitive Value : : ensure Sensitive ( $ card - > get Security Code ( ) ) ; } catch ( Request Not Supported Exception $ e ) { throw new Logic Exception ( 'Credit card details has to be set explicitly or there has to be an action that supports Obtain Credit Card request . ' ) ; } } $ model - > replace ( $ this - > api - > do Sale ( $ model - > to Unsafe Array ( ) ) ) ; } 
public function execute ( $ request ) { Request Not Supported Exception : : assert Supports ( $ this , $ request ) ; $ model = Array Object : : ensure Array Object ( $ request - > get Model ( ) ) ; if ( false = = $ model [ 'TOKEN ' ] ) { return ; } $ copied Model = new Array Object ( array ( 'TOKEN ' = > $ model [ 'TOKEN ' ] , ) ) ; $ this - > gateway - > execute ( new Get Express Checkout Details ( $ copied Model ) ) ; if ( Api : : L _ERRORCODE _SESSION _HAS _EXPIRED ! = $ copied Model [ 'L _ERRORCODE 0 ' ] ) { $ model - > replace ( $ copied Model ) ; } foreach ( range ( 0 , 9 ) as $ index ) { if ( $ model [ 'PAYMENTREQUEST _ ' . $ index . ' _TRANSACTIONID ' ] ) { $ this - > gateway - > execute ( new Get Transaction Details ( $ model , $ index ) ) ; } } } 
public function execute ( $ request ) { Request Not Supported Exception : : assert Supports ( $ this , $ request ) ; $ details = Array Object : : ensure Array Object ( $ request - > get Model ( ) ) ; if ( false = = $ details [ 'return Url ' ] & & $ request - > get Token ( ) ) { $ details [ 'return Url ' ] = $ request - > get Token ( ) - > get Target Url ( ) ; } if ( false = = $ details [ 'cancel Url ' ] & & $ request - > get Token ( ) ) { $ details [ 'cancel Url ' ] = $ request - > get Token ( ) - > get Target Url ( ) ; } if ( false = = $ details [ 'client IPAddress ' ] ) { $ this - > gateway - > execute ( $ http Request = new Get Http Request ( ) ) ; $ details [ 'client IPAddress ' ] = $ http Request - > client Ip ; } if ( false = = $ details [ 'order Ref ' ] ) { $ this - > gateway - > execute ( new Initialize Order ( $ details ) ) ; } if ( $ details [ 'order Ref ' ] ) { $ this - > gateway - > execute ( new Complete Order ( $ details ) ) ; if ( $ details [ 'recurring ' ] ) { $ this - > gateway - > execute ( new Start Recurring Payment ( $ details ) ) ; } } } 
public function supports ( $ request ) { if ( false = = ( $ request instanceof Capture & & $ request - > get Model ( ) instanceof \ Array Access ) ) { return false ; } $ model = Array Object : : ensure Array Object ( $ request - > get Model ( ) ) ; if ( $ model [ 'recurring ' ] ) { return true ; } 
public function execute ( $ request ) { Request Not Supported Exception : : assert Supports ( $ this , $ request ) ; $ model = Array Object : : ensure Array Object ( $ request - > get Model ( ) ) ; if ( null = = $ model [ 'txn _id ' ] ) { throw new Logic Exception ( 'TRANSACTIONID must be set . ' ) ; } $ fields = new Array Object ( [ ] ) ; $ fields [ 'TRANSACTIONID ' ] = $ model [ 'txn _id ' ] ; $ result = $ this - > api - > get Transaction Details ( ( array ) $ fields ) ; $ model - > replace ( $ result ) ; } 
public function execute ( $ request ) { Request Not Supported Exception : : assert Supports ( $ this , $ request ) ; $ details = Array Object : : ensure Array Object ( $ request - > get Model ( ) ) ; $ klarna = $ this - > get Klarna ( ) ; try { $ klarna - > return Amount ( $ details [ 'invoice _number ' ] , $ details [ 'amount ' ] , $ details [ 'vat ' ] , $ details [ 'flags ' ] ? : \ Klarna Flags : : NO _FLAG , $ details [ 'description ' ] ) ; } catch ( \ Klarna Exception $ e ) { $ this - > populate Details With Error ( $ details , $ e , $ request ) ; } } 
public function execute ( $ request ) { Request Not Supported Exception : : assert Supports ( $ this , $ request ) ; $ details = Array Object : : ensure Array Object ( $ request - > get Model ( ) ) ; $ klarna = $ this - > get Klarna ( ) ; try { $ this - > gateway - > execute ( new Populate Klarna From Details ( $ details , $ klarna ) ) ; $ result = $ klarna - > reserve Amount ( $ details [ 'pno ' ] , $ details [ 'gender ' ] , $ details [ 'amount ' ] ? : - 1 , $ details [ 'reservation _flags ' ] ? : \ Klarna Flags : : NO _FLAG ) ; $ details [ 'rno ' ] = $ result [ 0 ] ; $ details [ 'status ' ] = $ result [ 1 ] ; } catch ( \ Klarna Exception $ e ) { $ this - > populate Details With Error ( $ details , $ e , $ request ) ; } } 
public function get Storage ( $ class ) { $ class = is _object ( $ class ) ? get _class ( $ class ) : $ class ; 
public function get Storages ( ) { $ storages = array ( ) ; foreach ( $ this - > storages as $ model Class = > $ storage Id ) { $ storages [ $ model Class ] = $ this - > get Service ( $ storage Id ) ; } return $ storages ; } 
public function get Gateway ( $ name ) { if ( ! isset ( $ this - > gateways [ $ name ] ) ) { throw new Invalid Argument Exception ( sprintf ( 'Gateway " %s " does not exist . ' , $ name ) ) ; } return $ this - > get Service ( $ this - > gateways [ $ name ] ) ; } 
public function get Gateways ( ) { $ gateways = array ( ) ; foreach ( $ this - > gateways as $ name = > $ id ) { $ gateways [ $ name ] = $ this - > get Gateway ( $ name ) ; } return $ gateways ; } 
public function get Gateway Factory ( $ name ) { if ( ! isset ( $ this - > gateway Factories [ $ name ] ) ) { throw new Invalid Argument Exception ( sprintf ( 'Gateway factory " %s " does not exist . ' , $ name ) ) ; } return $ this - > get Service ( $ this - > gateway Factories [ $ name ] ) ; } 
public function get Gateway Factories ( ) { $ gateway Factories = array ( ) ; foreach ( $ this - > gateway Factories as $ name = > $ id ) { $ gateway Factories [ $ name ] = $ this - > get Gateway Factory ( $ name ) ; } return $ gateway Factories ; } 
public function execute ( $ request ) { Request Not Supported Exception : : assert Supports ( $ this , $ request ) ; $ model = Array Object : : ensure Array Object ( $ request - > get Model ( ) ) ; try { Stripe : : set Api Key ( $ this - > api - > get Secret Key ( ) ) ; $ subscription = Subscription : : create ( $ model - > to Unsafe Array Without Local ( ) ) ; $ model - > replace ( $ subscription - > _ _to Array ( true ) ) ; } catch ( Error \ Base $ e ) { $ model - > replace ( $ e - > get Json Body ( ) ) ; } } 
public function execute ( $ request ) { Request Not Supported Exception : : assert Supports ( $ this , $ request ) ; $ details = Array Object : : ensure Array Object ( $ request - > get Model ( ) ) ; $ klarna = $ request - > get Klarna ( ) ; if ( $ details [ 'articles ' ] ) { foreach ( $ details [ 'articles ' ] as $ article ) { $ article = Array Object : : ensure Array Object ( $ article ) ; $ klarna - > add Article ( utf 8 _decode ( $ article [ 'qty ' ] ) , utf 8 _decode ( $ article [ 'art No ' ] ) , utf 8 _decode ( $ article [ 'title ' ] ) , utf 8 _decode ( $ article [ 'price ' ] ) , utf 8 _decode ( $ article [ 'vat ' ] ) , utf 8 _decode ( $ article [ 'discount ' ] ) , $ article [ 'flags ' ] ? : \ Klarna Flags : : NO _FLAG ) ; } } if ( $ details [ 'partial _articles ' ] ) { foreach ( $ details [ 'partial _articles ' ] as $ article ) { $ klarna - > add Art No ( utf 8 _decode ( $ article [ 'qty ' ] ) , utf 8 _decode ( $ article [ 'art No ' ] ) ) ; } } if ( $ details [ 'shipping _address ' ] ) { $ address = Array Object : : ensure Array Object ( $ details [ 'shipping _address ' ] ) ; $ klarna - > set Address ( \ Klarna Flags : : IS _SHIPPING , new \ Klarna Addr ( utf 8 _decode ( $ address [ 'email ' ] ) , utf 8 _decode ( $ address [ 'telno ' ] ) , utf 8 _decode ( $ address [ 'cellno ' ] ) , utf 8 _decode ( $ address [ 'fname ' ] ) , utf 8 _decode ( $ address [ 'lname ' ] ) , utf 8 _decode ( $ address [ 'careof ' ] ) , utf 8 _decode ( $ address [ 'street ' ] ) , utf 8 _decode ( $ address [ 'zip ' ] ) , utf 8 _decode ( $ address [ 'city ' ] ) , utf 8 _decode ( $ address [ 'country ' ] ) , utf 8 _decode ( $ address [ 'house _number ' ] ) , utf 8 _decode ( $ address [ 'house _extension ' ] ) ) ) ; } if ( $ details [ 'billing _address ' ] ) { $ address = Array Object : : ensure Array Object ( $ details [ 'billing _address ' ] ) ; $ klarna - > set Address ( \ Klarna Flags : : IS _BILLING , new \ Klarna Addr ( utf 8 _decode ( $ address [ 'email ' ] ) , utf 8 _decode ( $ address [ 'telno ' ] ) , utf 8 _decode ( $ address [ 'cellno ' ] ) , utf 8 _decode ( $ address [ 'fname ' ] ) , utf 8 _decode ( $ address [ 'lname ' ] ) , utf 8 _decode ( $ address [ 'careof ' ] ) , utf 8 _decode ( $ address [ 'street ' ] ) , utf 8 _decode ( $ address [ 'zip ' ] ) , utf 8 _decode ( $ address [ 'city ' ] ) , utf 8 _decode ( $ address [ 'country ' ] ) , utf 8 _decode ( $ address [ 'house _number ' ] ) , utf 8 _decode ( $ address [ 'house _extension ' ] ) ) ) ; } if ( $ details [ 'estore _info ' ] ) { $ estore Info = Array Object : : ensure Array Object ( $ details [ 'estore _info ' ] ) ; $ klarna - > set Estore Info ( utf 8 _decode ( $ estore Info [ 'order _id 1 ' ] ) , utf 8 _decode ( $ estore Info [ 'order _id 2 ' ] ) , utf 8 _decode ( $ estore Info [ 'username ' ] ) ) ; } $ klarna - > set Comment ( utf 8 _decode ( $ details [ 'comment ' ] ) ) ; } 
public function execute ( $ request ) { Request Not Supported Exception : : assert Supports ( $ this , $ request ) ; $ this - > gateway - > execute ( $ http Request = new Get Http Request ( ) ) ; 
public function execute ( $ request ) { Request Not Supported Exception : : assert Supports ( $ this , $ request ) ; $ details = Array Object : : ensure Array Object ( $ request - > get Model ( ) ) ; $ details [ 'PAYMENTREQUEST _ 0 _PAYMENTACTION ' ] = Api : : PAYMENTACTION _AUTHORIZATION ; parent : : execute ( $ request ) ; } 
public function verify ( $ http Request ) { if ( false = = is _array ( $ http Request ) ) { throw new Invalid Argument Exception ( 'Invalid request given . In most cases you have to pass $ _REQUEST array . ' ) ; } if ( false = = isset ( $ http Request [ $ this - > token Parameter ] ) ) { throw new Invalid Argument Exception ( sprintf ( 'Token parameter ` %s ` was not found in in the http request . ' , $ this - > token Parameter ) ) ; } if ( $ http Request [ $ this - > token Parameter ] instanceof Token Interface ) { return $ http Request [ $ this - > token Parameter ] ; } if ( false = = $ token = $ this - > token Storage - > find ( $ http Request [ $ this - > token Parameter ] ) ) { throw new Invalid Argument Exception ( sprintf ( 'A token with hash ` %s ` could not be found . ' , $ http Request [ $ this - > token Parameter ] ) ) ; } if ( ! Request Token Verifier : : is Valid ( $ _SERVER [ 'REQUEST _URI ' ] , $ token - > get Target Url ( ) ) ) { throw new Invalid Argument Exception ( sprintf ( 'The current url %s not match target url %s set in the token . ' , $ _SERVER [ 'REQUEST _URI ' ] , $ token - > get Target Url ( ) ) ) ; } return $ token ; } 
public function execute ( $ request ) { Request Not Supported Exception : : assert Supports ( $ this , $ request ) ; $ payment = $ request - > get Source ( ) ; $ details = Array Object : : ensure Array Object ( $ payment - > get Details ( ) ) ; $ details [ 'price ' ] = $ payment - > get Total Amount ( ) ; $ details [ 'price Arg List ' ] = ' ' ; $ details [ 'vat ' ] = 0 ; $ details [ 'currency ' ] = $ payment - > get Currency Code ( ) ; $ details [ 'order Id ' ] = $ payment - > get Number ( ) ; $ details [ 'product Number ' ] = 'n \a ' ; $ details [ 'purchase Operation ' ] = Order Api : : PURCHASEOPERATION _SALE ; $ details [ 'view ' ] = Order Api : : VIEW _CREDITCARD ; $ details [ 'description ' ] = $ payment - > get Description ( ) ; $ details [ 'client Identifier ' ] = ' ' ; $ details [ 'additional Values ' ] = ' ' ; $ details [ 'agreement Ref ' ] = ' ' ; $ details [ 'client Language ' ] = isset ( $ details [ 'client Language ' ] ) ? $ details [ 'client Language ' ] : 'en -US ' ; $ details [ 'auto Pay ' ] = false ; $ request - > set Result ( ( array ) $ details ) ; } 
public function execute ( $ request ) { Request Not Supported Exception : : assert Supports ( $ this , $ request ) ; $ model = Array Object : : ensure Array Object ( $ request - > get Model ( ) ) ; foreach ( range ( 0 , 9 ) as $ index ) { if ( $ model [ 'L _ERRORCODE ' . $ index ] ) { $ request - > mark Failed ( ) ; return ; } } if ( isset ( $ model [ 'CANCELLED ' ] ) ) { $ request - > mark Canceled ( ) ; return ; } if ( null = = = $ payment Status = $ model [ 'PAYMENTSTATUS ' ] ) { $ request - > mark Unknown ( ) ; return ; } $ refund Statuses = [ Api : : PAYMENTSTATUS _REFUNDED , Api : : PAYMENTSTATUS _PARTIALLY _REFUNDED , ] ; if ( in _array ( $ payment Status , $ refund Statuses ) ) { $ request - > mark Refunded ( ) ; return ; } if ( $ payment Status = = Api : : PAYMENTSTATUS _COMPLETED ) { $ request - > mark Captured ( ) ; return ; } $ pending Statuses = [ Api : : PAYMENTSTATUS _IN _PROGRESS , Api : : PAYMENTSTATUS _PENDING , ] ; if ( in _array ( $ payment Status , $ pending Statuses ) ) { if ( Api : : PENDINGREASON _AUTHORIZATION = = $ model [ 'PENDINGREASON ' ] ) { $ request - > mark Authorized ( ) ; return ; } } if ( $ payment Status = = Api : : PAYMENTSTATUS _PENDING ) { $ request - > mark Pending ( ) ; return ; } $ failed Statuses = array ( Api : : PAYMENTSTATUS _FAILED , Api : : PAYMENTSTATUS _EXPIRED , Api : : PAYMENTSTATUS _DENIED , Api : : PAYMENTSTATUS _CANCELED _REVERSAL , ) ; if ( in _array ( $ payment Status , $ failed Statuses ) ) { $ request - > mark Failed ( ) ; return ; } } 
public function execute ( $ request ) { Request Not Supported Exception : : assert Supports ( $ this , $ request ) ; $ model = Array Object : : ensure Array Object ( $ request - > get Model ( ) ) ; $ model - > validate Not Empty ( array ( 'PROFILEID ' , 'BILLINGPERIOD ' ) ) ; $ cancel Details = new Array Object ( [ 'PROFILEID ' = > $ model [ 'PROFILEID ' ] , 'ACTION ' = > Api : : RECURRINGPAYMENTACTION _CANCEL , ] ) ; $ this - > gateway - > execute ( new Manage Recurring Payments Profile Status ( $ cancel Details ) ) ; $ this - > gateway - > execute ( new Sync ( $ request - > get Model ( ) ) ) ; } 
public function supports ( $ request ) { if ( false = = ( $ request instanceof Cancel & & $ request - > get Model ( ) instanceof \ Array Access ) ) { return false ; } 
public function execute ( $ request ) { Request Not Supported Exception : : assert Supports ( $ this , $ request ) ; $ details = Array Object : : ensure Array Object ( $ request - > get Model ( ) ) ; if ( false = = $ details [ 'rno ' ] ) { $ this - > gateway - > execute ( new Reserve Amount ( $ details ) ) ; } } 
public function execute ( $ request ) { Request Not Supported Exception : : assert Supports ( $ this , $ request ) ; $ model = $ request - > get Model ( ) ; $ payment = Paypal Payment : : get ( $ model - > id ) ; $ model - > from Array ( $ payment - > to Array ( ) ) ; } 
public function start ( array $ parameters ) { $ parameters [ 'account Number ' ] = $ this - > options [ 'account _number ' ] ; if ( isset ( $ parameters [ 'order Id ' ] ) ) { $ parameters [ 'order ID ' ] = $ parameters [ 'order Id ' ] ; unset ( $ parameters [ 'order Id ' ] ) ; } 
public function stop ( array $ parameters ) { $ parameters [ 'account Number ' ] = $ this - > options [ 'account _number ' ] ; $ parameters [ 'hash ' ] = $ this - > calculate Hash ( $ parameters , array ( 'account Number ' , 'agreement Ref ' , ) ) ; return $ this - > call ( 'Stop ' , $ parameters , $ this - > get Px Recurring Wsdl ( ) ) ; } 
public function check ( array $ parameters ) { $ parameters [ 'account Number ' ] = $ this - > options [ 'account _number ' ] ; $ parameters [ 'hash ' ] = $ this - > calculate Hash ( $ parameters , array ( 'account Number ' , 'agreement Ref ' , ) ) ; return $ this - > call ( 'Check ' , $ parameters , $ this - > get Px Recurring Wsdl ( ) ) ; } 
public function notify Validate ( array $ fields ) { $ fields [ 'cmd ' ] = self : : CMD _NOTIFY _VALIDATE ; $ headers = array ( 'Content -Type ' = > 'application /x -www -form -urlencoded ' , ) ; $ request = $ this - > message Factory - > create Request ( 'POST ' , $ this - > get Ipn Endpoint ( ) , $ headers , http _build _query ( $ fields ) ) ; $ response = $ this - > client - > send ( $ request ) ; if ( false = = ( $ response - > get Status Code ( ) > = 2 0 0 & & $ response - > get Status Code ( ) < 3 0 0 ) ) { throw Http Exception : : factory ( $ request , $ response ) ; } $ result = $ response - > get Body ( ) - > get Contents ( ) ; return self : : NOTIFY _VERIFIED = = = $ result ? self : : NOTIFY _VERIFIED : self : : NOTIFY _INVALID ; } 
public function execute ( $ request ) { Request Not Supported Exception : : assert Supports ( $ this , $ request ) ; $ model = Array Object : : ensure Array Object ( $ request - > get Model ( ) ) ; foreach ( range ( 0 , 9 ) as $ index ) { if ( $ model [ 'L _ERRORCODE ' . $ index ] ) { $ request - > mark Failed ( ) ; return ; } } if ( false = = $ model [ 'PROFILESTATUS ' ] & & false = = $ model [ 'STATUS ' ] ) { $ request - > mark New ( ) ; return ; } if ( Api : : RECURRINGPAYMENTSTATUS _ACTIVE = = $ model [ 'STATUS ' ] ) { $ request - > mark Captured ( ) ; return ; } if ( Api : : RECURRINGPAYMENTSTATUS _CANCELLED = = $ model [ 'STATUS ' ] ) { $ request - > mark Canceled ( ) ; return ; } if ( Api : : RECURRINGPAYMENTSTATUS _PENDING = = $ model [ 'STATUS ' ] ) { $ request - > mark Pending ( ) ; return ; } if ( Api : : RECURRINGPAYMENTSTATUS _EXPIRED = = $ model [ 'STATUS ' ] ) { $ request - > mark Expired ( ) ; return ; } if ( Api : : RECURRINGPAYMENTSTATUS _SUSPENDED = = $ model [ 'STATUS ' ] ) { $ request - > mark Suspended ( ) ; return ; } if ( Api : : PROFILESTATUS _PENDINGPROFILE = = $ model [ 'PROFILESTATUS ' ] ) { $ request - > mark Pending ( ) ; return ; } if ( Api : : PROFILESTATUS _ACTIVEPROFILE = = $ model [ 'PROFILESTATUS ' ] ) { $ request - > mark Captured ( ) ; return ; } $ request - > mark Unknown ( ) ; } 
public function add Extension ( Extension Interface $ extension , $ force Prepend = false ) { $ force Prepend ? array _unshift ( $ this - > extensions , $ extension ) : array _push ( $ this - > extensions , $ extension ) ; } 
public function on Pre Execute ( Context $ context ) { foreach ( $ this - > extensions as $ extension ) { $ extension - > on Pre Execute ( $ context ) ; } } 
public function on Execute ( Context $ context ) { foreach ( $ this - > extensions as $ extension ) { $ extension - > on Execute ( $ context ) ; } } 
public function on Post Execute ( Context $ context ) { foreach ( $ this - > extensions as $ extension ) { $ extension - > on Post Execute ( $ context ) ; } } 
public function execute ( $ request ) { Request Not Supported Exception : : assert Supports ( $ this , $ request ) ; $ model = Array Object : : ensure Array Object ( $ request - > get Model ( ) ) ; if ( false = = $ model [ 'ACK ' ] ) { $ request - > mark New ( ) ; return ; } if ( in _array ( $ model [ 'ACK ' ] , [ Api : : ACK _SUCCESS , Api : : ACK _SUCCESS _WITH _WARNING ] ) ) { $ request - > mark Payedout ( ) ; return ; } if ( in _array ( $ model [ 'ACK ' ] , [ Api : : ACK _FAILURE , Api : : ACK _FAILURE _WITH _WARNING ] ) ) { $ request - > mark Failed ( ) ; return ; } $ request - > mark Unknown ( ) ; } 
public function execute ( $ request ) { Request Not Supported Exception : : assert Supports ( $ this , $ request ) ; $ details = Array Object : : ensure Array Object ( $ request - > get Model ( ) ) ; if ( $ details [ 'error _code ' ] ) { $ request - > mark Failed ( ) ; return ; } if ( $ details [ 'canceled ' ] ) { $ request - > mark Canceled ( ) ; return ; } if ( $ details [ 'refund _invoice _number ' ] ) { $ request - > mark Refunded ( ) ; return ; } if ( $ details [ 'invoice _number ' ] ) { $ request - > mark Captured ( ) ; return ; } if ( false = = $ details [ 'status ' ] ) { $ request - > mark New ( ) ; return ; } if ( \ Klarna Flags : : ACCEPTED = = $ details [ 'status ' ] ) { $ request - > mark Authorized ( ) ; return ; } if ( \ Klarna Flags : : PENDING = = $ details [ 'status ' ] ) { $ request - > mark Pending ( ) ; return ; } if ( \ Klarna Flags : : DENIED = = $ details [ 'status ' ] ) { $ request - > mark Failed ( ) ; return ; } $ request - > mark Unknown ( ) ; } 
public function execute ( $ request ) { Request Not Supported Exception : : assert Supports ( $ this , $ request ) ; $ model = Array Object : : ensure Array Object ( $ request - > get Model ( ) ) ; 
public function supports ( $ request ) { if ( false = = ( $ request instanceof Get Status Interface & & $ request - > get Model ( ) instanceof \ Array Access ) ) { return false ; } $ model = Array Object : : ensure Array Object ( $ request - > get Model ( ) ) ; if ( count ( iterator _to _array ( $ model ) ) = = 0 ) { return true ; } if ( $ model [ 'recurring ' ] ) { return true ; } 
public function create Token ( $ gateway Name , $ model , $ target Path , array $ target Parameters = [ ] , $ after Path = null , array $ after Parameters = [ ] ) { $ token = $ this - > token Storage - > create ( ) ; $ token - > set Hash ( $ token - > get Hash ( ) ? : Random : : generate Token ( ) ) ; $ target Parameters = array _replace ( [ 'payum _token ' = > $ token - > get Hash ( ) ] , $ target Parameters ) ; $ token - > set Gateway Name ( $ gateway Name ) ; if ( $ model instanceof Identity Interface ) { $ token - > set Details ( $ model ) ; } elseif ( null ! = = $ model ) { $ token - > set Details ( $ this - > storage Registry - > get Storage ( $ model ) - > identify ( $ model ) ) ; } if ( 0 = = = strpos ( $ target Path , 'http ' ) ) { $ target Uri = Http Uri : : create From String ( $ target Path ) ; $ target Uri = $ this - > add Query To Uri ( $ target Uri , $ target Parameters ) ; $ token - > set Target Url ( ( string ) $ target Uri ) ; } else { $ token - > set Target Url ( $ this - > generate Url ( $ target Path , $ target Parameters ) ) ; } if ( $ after Path & & 0 = = = strpos ( $ after Path , 'http ' ) ) { $ after Uri = Http Uri : : create From String ( $ after Path ) ; $ after Uri = $ this - > add Query To Uri ( $ after Uri , $ after Parameters ) ; $ token - > set After Url ( ( string ) $ after Uri ) ; } elseif ( $ after Path ) { $ token - > set After Url ( $ this - > generate Url ( $ after Path , $ after Parameters ) ) ; } $ this - > token Storage - > update ( $ token ) ; return $ token ; } 
protected function add Query To Uri ( Http Uri $ uri , array $ query ) { $ query = array _replace ( ( new Query Parser ( ) ) - > parse ( $ uri - > get Query ( ) ) , $ query ) ; $ query = array _filter ( $ query , function ( $ value ) { return null ! = = $ value ; } ) ; return $ uri - > with Query ( ( string ) Query : : create From Pairs ( $ query ) ) ; } 
public static function factory ( Request Interface $ request , Response Interface $ response ) { if ( $ response - > get Status Code ( ) > = 4 0 0 & & $ response - > get Status Code ( ) < 5 0 0 ) { $ label = 'Client error response ' ; } elseif ( $ response - > get Status Code ( ) > = 5 0 0 & & $ response - > get Status Code ( ) < 6 0 0 ) { $ label = 'Server error response ' ; } else { $ label = 'Unsuccessful response ' ; } $ message = implode ( PHP _EOL , array ( $ label , ' [status code ] ' . $ response - > get Status Code ( ) , ' [reason phrase ] ' . $ response - > get Reason Phrase ( ) , ' [url ] ' . $ request - > get Uri ( ) , ) ) ; $ e = new static ( $ message , $ response - > get Status Code ( ) ) ; $ e - > set Response ( $ response ) ; $ e - > set Request ( $ request ) ; return $ e ; } 
public function mass Pay ( array $ fields ) { $ fields [ 'METHOD ' ] = 'Mass Pay ' ; $ this - > add Version Field ( $ fields ) ; $ this - > add Authorize Fields ( $ fields ) ; return $ this - > do Request ( $ fields ) ; } 
protected function do Find ( $ id ) { if ( isset ( $ this - > identity Map [ $ id ] ) ) { return $ this - > identity Map [ $ id ] ; } if ( file _exists ( $ this - > storage Dir . ' /payum -model - ' . $ id ) ) { return $ this - > identity Map [ $ id ] = unserialize ( file _get _contents ( $ this - > storage Dir . ' /payum -model - ' . $ id ) ) ; } } 
protected function do Update Model ( $ model ) { $ ro = new \ Reflection Object ( $ model ) ; if ( false = = $ ro - > has Property ( $ this - > id Property ) ) { $ model - > { $ this - > id Property } = null ; } $ rp = new \ Reflection Property ( $ model , $ this - > id Property ) ; $ rp - > set Accessible ( true ) ; $ id = $ rp - > get Value ( $ model ) ; if ( false = = $ id ) { $ rp - > set Value ( $ model , $ id = uniqid ( ) ) ; } $ rp - > set Accessible ( false ) ; $ this - > identity Map [ $ id ] = $ model ; file _put _contents ( $ this - > storage Dir . ' /payum -model - ' . $ id , serialize ( $ model ) ) ; } 
protected function do Delete Model ( $ model ) { $ rp = new \ Reflection Property ( $ model , $ this - > id Property ) ; $ rp - > set Accessible ( true ) ; if ( $ id = $ rp - > get Value ( $ model ) ) { unlink ( $ this - > storage Dir . ' /payum -model - ' . $ id ) ; unset ( $ this - > identity Map [ $ id ] ) ; } } 
protected function do Get Identity ( $ model ) { $ rp = new \ Reflection Property ( $ model , $ this - > id Property ) ; $ rp - > set Accessible ( true ) ; if ( false = = $ id = $ rp - > get Value ( $ model ) ) { throw new Logic Exception ( 'The model must be persisted before usage of this method ' ) ; } return new Identity ( $ id , $ model ) ; } 
public static function assert Supports ( Action Interface $ action , $ request ) { if ( false = = $ action - > supports ( $ request ) ) { throw static : : create Action Not Supported ( $ action , $ request ) ; } } 
public static function create ( $ request ) { $ exception = new self ( sprintf ( 'Request %s is not supported . %s ' , Humanify : : request ( $ request ) , implode ( " " , static : : suggestions ( $ request ) ) ) ) ; $ exception - > request = $ request ; return $ exception ; } 
public static function create Action Not Supported ( Action Interface $ action , $ request ) { $ exception = new self ( sprintf ( "Action %s is not supported the request %s . %s " , Humanify : : value ( $ action ) , Humanify : : request ( $ request ) , implode ( " " , static : : suggestions ( $ request ) ) ) ) ; $ exception - > request = $ request ; $ exception - > action = $ action ; return $ exception ; } 
protected static function suggestions ( $ request ) { $ suggestions = [ ] ; if ( $ request instanceof Generic & & $ request - > get Model ( ) instanceof Identity Interface ) { $ suggestions [ ] = sprintf ( 'Make sure the storage extension for " %s " is registered to the gateway . ' , $ request - > get Model ( ) - > get Class ( ) ) ; $ suggestions [ ] = sprintf ( 'Make sure the storage find method returns an instance by id " %s " . ' , $ request - > get Model ( ) - > get Id ( ) ) ; } $ suggestions [ ] = 'Make sure the gateway supports the requests and there is an action which supports this request (The method returns true ) . ' ; $ suggestions [ ] = 'There may be a bug , so look for a related issue on the issue tracker . ' ; return $ suggestions ; } 
protected function populate Config ( Array Object $ config ) { if ( false = = class _exists ( Api Context : : class ) ) { throw new \ Logic Exception ( 'You must install "paypal /rest -api -sdk -php " library . ' ) ; } $ config - > defaults ( [ 'payum .factory _name ' = > 'paypal _rest ' , 'payum .factory _title ' = > 'Pay Pal Rest ' , 'payum .action .capture ' = > new Capture Action ( ) , 'payum .action .sync ' = > new Sync Action ( ) , 'payum .action .status ' = > new Status Action ( ) , ] ) ; if ( false = = $ config [ 'payum .api ' ] ) { $ config [ 'payum .default _options ' ] = [ 'client _id ' = > ' ' , 'client _secret ' = > ' ' , 'config _path ' = > ' ' , ] ; $ config - > defaults ( $ config [ 'payum .default _options ' ] ) ; $ config [ 'payum .required _options ' ] = [ 'client _id ' , 'client _secret ' , 'config _path ' ] ; $ config [ 'payum .api ' ] = function ( Array Object $ config ) { $ config - > validate Not Empty ( $ config [ 'payum .required _options ' ] ) ; if ( false = = defined ( 'PP _CONFIG _PATH ' ) ) { define ( 'PP _CONFIG _PATH ' , $ config [ 'config _path ' ] ) ; } elseif ( PP _CONFIG _PATH ! = = $ config [ 'config _path ' ] ) { throw new Invalid Argument Exception ( sprintf ( 'Given "config _path " is invalid . Should be equal to the defined "PP _CONFIG _PATH " : %s . ' , PP _CONFIG _PATH ) ) ; } $ credential = new OAuth Token Credential ( $ config [ 'client _id ' ] , $ config [ 'client _secret ' ] ) ; return new Api Context ( $ credential ) ; } ; } } 
public function execute ( $ request ) { Request Not Supported Exception : : assert Supports ( $ this , $ request ) ; $ details = Array Object : : ensure Array Object ( $ request - > get Model ( ) ) ; if ( $ details [ 'refund _invoice _number ' ] ) { return ; } $ details - > validate Not Empty ( array ( 'invoice _number ' ) ) ; $ this - > gateway - > execute ( new Credit Part ( $ details ) ) ; } 
public function execute ( $ request ) { Request Not Supported Exception : : assert Supports ( $ this , $ request ) ; $ model = Array Object : : ensure Array Object ( $ request - > get Model ( ) ) ; 
public function execute ( $ request ) { Request Not Supported Exception : : assert Supports ( $ this , $ request ) ; $ details = Array Object : : ensure Array Object ( $ request - > get Model ( ) ) ; $ this - > gateway - > execute ( new Sync ( $ details ) ) ; if ( Constants : : STATUS _CHECKOUT _COMPLETE = = $ details [ 'status ' ] ) { $ this - > gateway - > execute ( new Update Order ( array ( 'location ' = > $ details [ 'location ' ] , 'status ' = > Constants : : STATUS _CREATED , 'merchant _reference ' = > array ( 'orderid 1 ' = > $ details [ 'merchant _reference ' ] [ 'orderid 1 ' ] , ) , ) ) ) ; $ this - > gateway - > execute ( new Sync ( $ details ) ) ; } } 
public function execute ( $ request ) { Request Not Supported Exception : : assert Supports ( $ this , $ request ) ; $ card = $ request - > get Model ( ) ; $ token = Array Object : : ensure Array Object ( $ request - > get Token ( ) ) ; $ token [ 'object ' ] = 'card ' ; $ token [ 'number ' ] = Sensitive Value : : ensure Sensitive ( $ card - > get Number ( ) ) ; $ token [ 'exp _month ' ] = Sensitive Value : : ensure Sensitive ( $ card - > get Expire At ( ) - > format ( 'm ' ) ) ; $ token [ 'exp _year ' ] = Sensitive Value : : ensure Sensitive ( $ card - > get Expire At ( ) - > format ( 'Y ' ) ) ; if ( $ card - > get Security Code ( ) ) { $ token [ 'cvc ' ] = Sensitive Value : : ensure Sensitive ( $ card - > get Security Code ( ) ) ; } $ this - > gateway - > execute ( new Create Token ( $ token ) ) ; $ request - > set Token ( $ token - > to Unsafe Array ( ) ) ; } 
public function execute ( $ request ) { Request Not Supported Exception : : assert Supports ( $ this , $ request ) ; $ model = Array Object : : ensure Array Object ( $ request - > get Model ( ) ) ; if ( $ model [ 'card ' ] ) { throw new Logic Exception ( 'Payment already has token set ' ) ; } $ obtain Credit Card = new Obtain Credit Card ( $ request - > get Token ( ) ) ; $ obtain Credit Card - > set Model ( $ request - > get First Model ( ) ) ; $ obtain Credit Card - > set Model ( $ request - > get Model ( ) ) ; $ this - > gateway - > execute ( $ obtain Credit Card ) ; $ card = $ obtain Credit Card - > obtain ( ) ; $ local = $ model - > get Array ( 'local ' ) ; $ create Token For Credit Card = new Create Token For Credit Card ( $ card ) ; $ create Token For Credit Card - > set Token ( ( array ) $ local - > get Array ( 'token ' ) ) ; $ this - > gateway - > execute ( $ create Token For Credit Card ) ; $ token = Array Object : : ensure Array Object ( $ create Token For Credit Card - > get Token ( ) ) ; $ local [ 'token ' ] = $ token - > to Unsafe Array ( ) ; $ model [ 'local ' ] = ( array ) $ local ; if ( $ token [ 'id ' ] ) { $ model [ 'card ' ] = $ token [ 'id ' ] ; } else { $ model [ 'status ' ] = Constants : : STATUS _FAILED ; } } 
public function replace ( $ input ) { if ( false = = ( is _array ( $ input ) | | $ input instanceof \ Traversable ) ) { throw new Invalid Argument Exception ( 'Invalid input given . Should be an array or instance of \Traversable ' ) ; } foreach ( $ input as $ index = > $ value ) { $ this [ $ index ] = $ value ; } } 
public function defaults ( $ input ) { if ( false = = ( is _array ( $ input ) | | $ input instanceof \ Traversable ) ) { throw new Invalid Argument Exception ( 'Invalid input given . Should be an array or instance of \Traversable ' ) ; } foreach ( $ input as $ index = > $ value ) { if ( null = = = $ this [ $ index ] ) { $ this [ $ index ] = $ value ; } } } 
public function validate Not Empty ( $ required , $ throw On Invalid = true ) { $ required = is _array ( $ required ) ? $ required : array ( $ required ) ; $ empty = array ( ) ; foreach ( $ required as $ r ) { $ value = $ this [ $ r ] ; if ( empty ( $ value ) ) { $ empty [ ] = $ r ; } } if ( $ empty & & $ throw On Invalid ) { throw new Logic Exception ( sprintf ( 'The %s fields are required . ' , implode ( ' , ' , $ empty ) ) ) ; } if ( $ empty ) { return false ; } return true ; } 
public function validated Keys Set ( $ required , $ throw On Invalid = true ) { $ required = is _array ( $ required ) ? $ required : array ( $ required ) ; foreach ( $ required as $ required ) { if ( false = = $ this - > offset Exists ( $ required ) ) { if ( $ throw On Invalid ) { throw new Logic Exception ( sprintf ( 'The %s fields is not set . ' , $ required ) ) ; } return false ; } } return true ; } 
public function offset Set ( $ index , $ value ) { if ( $ this - > input ) { $ this - > input [ $ index ] = $ value ; } return parent : : offset Set ( $ index , $ value ) ; } 
public function offset Unset ( $ index ) { if ( $ this - > input ) { unset ( $ this - > input [ $ index ] ) ; } return parent : : offset Unset ( $ index ) ; } 
public function to Unsafe Array ( ) { $ array = [ ] ; foreach ( $ this as $ name = > $ value ) { if ( $ value instanceof Sensitive Value ) { $ array [ $ name ] = $ value - > get ( ) ; continue ; } $ array [ $ name ] = $ value ; } return $ array ; } 
public function set Api ( $ api ) { if ( empty ( $ this - > api Class ) ) { throw new Logic Exception ( sprintf ( 'You must configure api Class in _ _constructor method of the class the trait is applied to . ' ) ) ; } if ( false = = ( class _exists ( $ this - > api Class ) | | interface _exists ( $ this - > api Class ) ) ) { throw new Logic Exception ( sprintf ( 'Api class not found or invalid class . " %s " , $this - >api Class ' , $ this - > api Class ) ) ; } if ( false = = $ api instanceof $ this - > api Class ) { throw new Unsupported Api Exception ( sprintf ( 'Not supported api given . It must be an instance of %s ' , $ this - > api Class ) ) ; } $ this - > api = $ api ; } 
public function create Token ( $ gateway Name , $ model , $ target Path , array $ target Parameters = [ ] , $ after Path = null , array $ after Parameters = [ ] ) { return $ this - > token Factory - > create Token ( $ gateway Name , $ model , $ target Path , $ target Parameters , $ after Path , $ after Parameters ) ; } 
public function create Authorize Token ( $ gateway Name , $ model , $ after Path , array $ after Parameters = [ ] ) { $ authorize Path = $ this - > get Path ( 'authorize ' ) ; $ after Token = $ this - > create Token ( $ gateway Name , $ model , $ after Path , $ after Parameters ) ; return $ this - > create Token ( $ gateway Name , $ model , $ authorize Path , [ ] , $ after Token - > get Target Url ( ) ) ; } 
public function create Refund Token ( $ gateway Name , $ model , $ after Path = null , array $ after Parameters = [ ] ) { $ refund Path = $ this - > get Path ( 'refund ' ) ; $ after Url = null ; if ( $ after Path ) { $ after Url = $ this - > create Token ( $ gateway Name , $ model , $ after Path , $ after Parameters ) - > get Target Url ( ) ; } return $ this - > create Token ( $ gateway Name , $ model , $ refund Path , [ ] , $ after Url ) ; } 
public function create Cancel Token ( $ gateway Name , $ model , $ after Path = null , array $ after Parameters = [ ] ) { $ cancel Path = $ this - > get Path ( 'cancel ' ) ; $ after Url = null ; if ( $ after Path ) { $ after Url = $ this - > create Token ( $ gateway Name , $ model , $ after Path , $ after Parameters ) - > get Target Url ( ) ; } return $ this - > create Token ( $ gateway Name , $ model , $ cancel Path , [ ] , $ after Url ) ; } 
public function create Payout Token ( $ gateway Name , $ model , $ after Path , array $ after Parameters = [ ] ) { $ capture Path = $ this - > get Path ( 'payout ' ) ; $ after Token = $ this - > create Token ( $ gateway Name , $ model , $ after Path , $ after Parameters ) ; return $ this - > create Token ( $ gateway Name , $ model , $ capture Path , [ ] , $ after Token - > get Target Url ( ) ) ; } 
public function create Notify Token ( $ gateway Name , $ model = null ) { return $ this - > create Token ( $ gateway Name , $ model , $ this - > get Path ( 'notify ' ) ) ; } 
protected function get Path ( $ name ) { if ( empty ( $ this - > paths [ $ name ] ) ) { throw new Logic Exception ( sprintf ( 'The path " %s " is not found . Possible paths are %s ' , $ name , implode ( ' , ' , array _keys ( $ this - > paths ) ) ) ) ; } return $ this - > paths [ $ name ] ; } 
public function build ( array $ default Config , Gateway Factory Interface $ core Gateway Factory ) { $ gateway Factory Class = $ this - > gateway Factory Class ; return new $ gateway Factory Class ( $ default Config , $ core Gateway Factory ) ; } 
public function execute ( $ request ) { Request Not Supported Exception : : assert Supports ( $ this , $ request ) ; $ model = Array Object : : ensure Array Object ( $ request - > get Model ( ) ) ; $ this - > add Merchant Id ( $ model ) ; $ this - > call With Retry ( function ( ) use ( $ model , $ request ) { $ order = new \ Klarna _Checkout _Order ( $ this - > get Connector ( ) ) ; $ order - > create ( $ model - > to Unsafe Array ( ) ) ; $ request - > set Order ( $ order ) ; } ) ; } 
public function execute ( $ request ) { Request Not Supported Exception : : assert Supports ( $ this , $ request ) ; $ request - > set Result ( $ this - > twig - > render ( $ request - > get Template Name ( ) , array _replace ( array ( 'layout ' = > $ this - > layout ) , $ request - > get Parameters ( ) ) ) ) ; } 
public function execute ( $ request ) { Request Not Supported Exception : : assert Supports ( $ this , $ request ) ; $ details = Array Object : : ensure Array Object ( $ request - > get Model ( ) ) ; if ( null = = = $ details [ 'RESULT ' ] ) { return ; } $ refundable Trx Types = array ( Api : : TRXTYPE _SALE , Api : : TRXTYPE _DELAYED _CAPUTER , Api : : TRXTYPE _VOICE _AUTHORIZATION ) ; if ( false = = in _array ( $ details [ 'TRXTYPE ' ] , $ refundable Trx Types ) ) { throw new Logic Exception ( sprintf ( 'You cannot refund transaction with type %s . Only these types could be refunded : %s ' , $ details [ 'TRXTYPE ' ] , implode ( ' , ' , $ refundable Trx Types ) ) ) ; } $ details - > validate Not Empty ( array ( 'PNREF ' ) , true ) ; $ details [ 'PURCHASE _TRXTYPE ' ] = $ details [ 'TRXTYPE ' ] ; $ details [ 'TRXTYPE ' ] = null ; $ details [ 'PURCHASE _RESULT ' ] = $ details [ 'RESULT ' ] ; $ details [ 'RESULT ' ] = null ; $ details [ 'ORIGID ' ] = $ details [ 'PNREF ' ] ; $ details - > replace ( $ this - > api - > do Credit ( $ details - > to Unsafe Array ( ) ) ) ; } 
public function execute ( $ request ) { Request Not Supported Exception : : assert Supports ( $ this , $ request ) ; $ model = Array Object : : ensure Array Object ( $ request - > get Model ( ) ) ; if ( null = = = $ model [ 'response _code ' ] ) { $ request - > mark New ( ) ; return ; } if ( \ Authorize Net AIM _Response : : APPROVED = = $ model [ 'response _code ' ] ) { $ request - > mark Captured ( ) ; return ; } if ( \ Authorize Net AIM _Response : : DECLINED = = $ model [ 'response _code ' ] ) { $ request - > mark Canceled ( ) ; return ; } if ( \ Authorize Net AIM _Response : : ERROR = = $ model [ 'response _code ' ] ) { $ request - > mark Failed ( ) ; return ; } if ( \ Authorize Net AIM _Response : : HELD = = $ model [ 'response _code ' ] ) { $ request - > mark Pending ( ) ; return ; } $ request - > mark Unknown ( ) ; } 
public function on Execute ( Context $ context ) { $ action = $ context - > get Action ( ) ; if ( $ action instanceof Logger Aware Interface ) { $ action - > set Logger ( $ this - > logger ) ; } } 
public function on Post Execute ( Context $ context ) { $ action = $ context - > get Action ( ) ; if ( $ action instanceof Logger Aware Interface ) { $ action - > set Logger ( $ this - > null Logger ) ; } } 
protected function populate Config ( Array Object $ config ) { $ config - > defaults ( array ( 'payum .factory _name ' = > 'paypal _pro _checkout _nvp ' , 'payum .factory _title ' = > 'Pay Pal Pro Checkout ' , 'payum .action .capture ' = > new Capture Action ( ) , 'payum .action .refund ' = > new Refund Action ( ) , 'payum .action .convert _payment ' = > new Convert Payment Action ( ) , 'payum .action .status ' = > new Status Action ( ) , ) ) ; if ( false = = $ config [ 'payum .api ' ] ) { $ config [ 'payum .default _options ' ] = array ( 'username ' = > ' ' , 'password ' = > ' ' , 'partner ' = > ' ' , 'vendor ' = > ' ' , 'tender ' = > ' ' , 'sandbox ' = > true , ) ; $ config - > defaults ( $ config [ 'payum .default _options ' ] ) ; $ config [ 'payum .required _options ' ] = array ( 'username ' , 'password ' , 'partner ' , 'vendor ' , 'tender ' ) ; $ config [ 'payum .api ' ] = function ( Array Object $ config ) { $ config - > validate Not Empty ( $ config [ 'payum .required _options ' ] ) ; $ paypal Config = array ( 'username ' = > $ config [ 'username ' ] , 'password ' = > $ config [ 'password ' ] , 'partner ' = > $ config [ 'partner ' ] , 'vendor ' = > $ config [ 'vendor ' ] , 'tender ' = > $ config [ 'tender ' ] , 'sandbox ' = > $ config [ 'sandbox ' ] , ) ; return new Api ( $ paypal Config , $ config [ 'payum .http _client ' ] , $ config [ 'httplug .message _factory ' ] ) ; } ; } } 
protected function generate Url ( $ path , array $ parameters = [ ] ) { $ new Path = ( new Path ( $ this - > base Url - > get Path ( ) ) ) - > with Trailing Slash ( ) . $ path ; $ uri = $ this - > base Url - > with Path ( $ new Path ) ; $ uri = $ this - > add Query To Uri ( $ uri , $ parameters ) ; return ( string ) $ uri ; } 
public function execute ( $ request ) { Request Not Supported Exception : : assert Supports ( $ this , $ request ) ; $ model = Array Object : : ensure Array Object ( $ request - > get Model ( ) ) ; $ this - > call With Retry ( function ( ) use ( $ model , $ request ) { $ order = new \ Klarna _Checkout _Order ( $ this - > get Connector ( ) , $ model [ 'location ' ] ) ; $ data = $ model - > to Unsafe Array ( ) ; unset ( $ data [ 'location ' ] ) ; $ order - > update ( $ data ) ; $ request - > set Order ( $ order ) ; } ) ; } 
protected function populate Config ( Array Object $ config ) { if ( ! class _exists ( 'Klarna _Checkout _Order ' ) ) { throw new \ Logic Exception ( 'You must install "klarna /checkout " library . ' ) ; } $ config - > defaults ( array ( 'payum .factory _name ' = > 'klarna _checkout ' , 'payum .factory _title ' = > 'Klarna Checkout ' , 'payum .template .authorize ' = > ' @Payum Klarna Checkout /Action /capture .html .twig ' , 'content Type ' = > Constants : : CONTENT _TYPE _AGGREGATED _ORDER _V 2 , 'sandbox ' = > true , ) ) ; $ config - > defaults ( array ( 'payum .action .authorize _recurring ' = > new Authorize Recurring Action ( ) , 
protected function populate Config ( Array Object $ config ) { $ config - > defaults ( array ( 'payum .factory _name ' = > 'paypal _masspay _nvp ' , 'payum .factory _title ' = > 'Pay Pal Masspay ' , 'payum .action .payout ' = > new Payout Action ( ) , 'payum .action .api .masspay ' = > new Masspay Action ( ) , 'payum .action .convert _payout ' = > new Convert Payout Action ( ) , 'payum .action .get _payout _status ' = > new Get Payout Status Action ( ) , ) ) ; if ( false = = $ config [ 'payum .api ' ] ) { $ config [ 'payum .default _options ' ] = array ( 'username ' = > ' ' , 'password ' = > ' ' , 'signature ' = > ' ' , 'sandbox ' = > true , ) ; $ config - > defaults ( $ config [ 'payum .default _options ' ] ) ; $ config [ 'payum .required _options ' ] = array ( 'username ' , 'password ' , 'signature ' ) ; $ config [ 'payum .api ' ] = function ( Array Object $ config ) { $ config - > validate Not Empty ( $ config [ 'payum .required _options ' ] ) ; $ paypal Config = [ 'username ' = > $ config [ 'username ' ] , 'password ' = > $ config [ 'password ' ] , 'signature ' = > $ config [ 'signature ' ] , 'sandbox ' = > $ config [ 'sandbox ' ] , ] ; return new Api ( $ paypal Config , $ config [ 'payum .http _client ' ] , $ config [ 'httplug .message _factory ' ] ) ; } ; } } 
protected function call ( $ operation , array $ parameters , $ service Wsdl ) { $ client = $ this - > client Factory - > create Wsdl Client ( $ service Wsdl ) ; $ response = @ $ client - > $ operation ( $ parameters ) ; $ result = $ this - > convert Simple Xml To Array ( new \ Simple XMLElement ( $ response - > { $ operation . 'Result ' } ) ) ; $ result = $ this - > normalize Status Fields ( $ result ) ; $ result = $ this - > remove Header ( $ result ) ; $ result = $ this - > remove Obsolete ( $ result ) ; return $ result ; } 
protected function calculate Hash ( array $ parameters , array $ parameters Keys ) { $ ordered Parameters = array ( ) ; foreach ( $ parameters Keys as $ parameters Key ) { if ( false = = isset ( $ parameters [ $ parameters Key ] ) ) { 
protected function normalize Status Fields ( array $ input Result ) { $ result = $ input Result ; unset ( $ result [ 'status ' ] ) ; if ( array _key _exists ( 'status ' , $ input Result ) & & is _array ( $ input Result [ 'status ' ] ) ) { $ statuses = $ input Result [ 'status ' ] ; 
public function execute ( $ request ) { Request Not Supported Exception : : assert Supports ( $ this , $ request ) ; $ klarna = $ this - > get Klarna ( ) ; foreach ( $ klarna - > get Addresses ( $ request - > get Pno ( ) ) as $ address ) { $ address - > set Email ( utf 8 _encode ( $ address - > get Email ( ) ) ) ; $ address - > set Telno ( utf 8 _encode ( $ address - > get Telno ( ) ) ) ; $ address - > set Cellno ( utf 8 _encode ( $ address - > get Cellno ( ) ) ) ; $ address - > set First Name ( utf 8 _encode ( $ address - > get First Name ( ) ) ) ; $ address - > set Last Name ( utf 8 _encode ( $ address - > get Last Name ( ) ) ) ; $ address - > set Company Name ( utf 8 _encode ( $ address - > get Company Name ( ) ) ) ; $ address - > set Careof ( utf 8 _encode ( $ address - > get Careof ( ) ) ) ; $ address - > set Street ( utf 8 _encode ( $ address - > get Street ( ) ) ) ; $ address - > set House Number ( utf 8 _encode ( $ address - > get House Number ( ) ) ) ; $ address - > set House Ext ( utf 8 _encode ( $ address - > get House Ext ( ) ) ) ; $ address - > set Zip Code ( utf 8 _encode ( $ address - > get Zip Code ( ) ) ) ; $ address - > set City ( utf 8 _encode ( $ address - > get City ( ) ) ) ; $ address - > set Country ( utf 8 _encode ( $ address - > get Country ( ) ) ) ; $ request - > add Address ( $ address ) ; } } 
public function set Express Checkout ( array $ fields ) { if ( false = = isset ( $ fields [ 'RETURNURL ' ] ) ) { if ( false = = $ this - > options [ 'return _url ' ] ) { throw new Runtime Exception ( 'The return _url must be set either to Form Request or to options . ' ) ; } $ fields [ 'RETURNURL ' ] = $ this - > options [ 'return _url ' ] ; } if ( false = = isset ( $ fields [ 'CANCELURL ' ] ) ) { if ( false = = $ this - > options [ 'cancel _url ' ] ) { throw new Runtime Exception ( 'The cancel _url must be set either to Form Request or to options . ' ) ; } $ fields [ 'CANCELURL ' ] = $ this - > options [ 'cancel _url ' ] ; } $ fields [ 'METHOD ' ] = 'Set Express Checkout ' ; $ this - > add Version Field ( $ fields ) ; $ this - > add Authorize Fields ( $ fields ) ; return $ this - > do Request ( $ fields ) ; } 
public function get Express Checkout Details ( array $ fields ) { $ fields [ 'METHOD ' ] = 'Get Express Checkout Details ' ; $ this - > add Version Field ( $ fields ) ; $ this - > add Authorize Fields ( $ fields ) ; return $ this - > do Request ( $ fields ) ; } 
public function transaction Search ( array $ fields ) { $ fields [ 'METHOD ' ] = 'Transaction Search ' ; $ this - > add Version Field ( $ fields ) ; $ this - > add Authorize Fields ( $ fields ) ; return $ this - > do Request ( $ fields ) ; } 
public function do Express Checkout Payment ( array $ fields ) { $ fields [ 'METHOD ' ] = 'Do Express Checkout Payment ' ; $ this - > add Version Field ( $ fields ) ; $ this - > add Authorize Fields ( $ fields ) ; return $ this - > do Request ( $ fields ) ; } 
public function create Recurring Payments Profile ( array $ fields ) { $ fields [ 'METHOD ' ] = 'Create Recurring Payments Profile ' ; $ this - > add Version Field ( $ fields ) ; $ this - > add Authorize Fields ( $ fields ) ; return $ this - > do Request ( $ fields ) ; } 
public function update Recurring Payments Profile ( array $ fields ) { $ fields [ 'METHOD ' ] = 'Update Recurring Payments Profile ' ; $ this - > add Version Field ( $ fields ) ; $ this - > add Authorize Fields ( $ fields ) ; return $ this - > do Request ( $ fields ) ; } 
public function get Recurring Payments Profile Details ( array $ fields ) { $ fields [ 'METHOD ' ] = 'Get Recurring Payments Profile Details ' ; $ this - > add Version Field ( $ fields ) ; $ this - > add Authorize Fields ( $ fields ) ; return $ this - > do Request ( $ fields ) ; } 
public function manage Recurring Payments Profile Status ( array $ fields ) { $ fields [ 'METHOD ' ] = 'Manage Recurring Payments Profile Status ' ; $ this - > add Version Field ( $ fields ) ; $ this - > add Authorize Fields ( $ fields ) ; return $ this - > do Request ( $ fields ) ; } 
public function create Billing Agreement ( array $ fields ) { $ fields [ 'METHOD ' ] = 'Create Billing Agreement ' ; $ this - > add Version Field ( $ fields ) ; $ this - > add Authorize Fields ( $ fields ) ; return $ this - > do Request ( $ fields ) ; } 
public function do Reference Transaction ( array $ fields ) { $ fields [ 'METHOD ' ] = 'Do Reference Transaction ' ; $ this - > add Version Field ( $ fields ) ; $ this - > add Authorize Fields ( $ fields ) ; return $ this - > do Request ( $ fields ) ; } 
public function do Capture ( array $ fields ) { $ fields [ 'METHOD ' ] = 'Do Capture ' ; $ this - > add Version Field ( $ fields ) ; $ this - > add Authorize Fields ( $ fields ) ; return $ this - > do Request ( $ fields ) ; } 
public function do Void ( array $ fields ) { $ fields [ 'METHOD ' ] = 'Do Void ' ; $ this - > add Version Field ( $ fields ) ; $ this - > add Authorize Fields ( $ fields ) ; return $ this - > do Request ( $ fields ) ; } 
public function get Authorize Token Url ( $ token , array $ query = array ( ) ) { $ default Query = array _filter ( array ( 'useraction ' = > $ this - > options [ 'useraction ' ] , 'cmd ' = > $ this - > options [ 'cmd ' ] , 'token ' = > $ token , ) ) ; $ query = array _filter ( $ query ) ; return sprintf ( 'https : / / %s /cgi -bin /webscr ? %s ' , $ this - > options [ 'sandbox ' ] ? 'www .sandbox .paypal .com ' : 'www .paypal .com ' , http _build _query ( array _replace ( $ default Query , $ query ) ) ) ; } 
public function execute ( $ request ) { Request Not Supported Exception : : assert Supports ( $ this , $ request ) ; if ( $ this - > http Request instanceof Request ) { $ this - > update Request ( $ request , $ this - > http Request ) ; } elseif ( $ this - > http Request Stack instanceof Request Stack & & null ! = = $ this - > http Request Stack - > get Master Request ( ) ) { $ this - > update Request ( $ request , $ this - > http Request Stack - > get Master Request ( ) ) ; } } 
public function create ( array $ config = [ ] ) { $ config = Array Object : : ensure Array Object ( $ config ) ; $ config - > defaults ( $ this - > create Config ( ) ) ; $ gateway = new Gateway ( ) ; $ this - > build Closures ( $ config ) ; $ this - > build Actions ( $ gateway , $ config ) ; $ this - > build Apis ( $ gateway , $ config ) ; $ this - > build Extensions ( $ gateway , $ config ) ; return $ gateway ; } 
public function create Config ( array $ config = [ ] ) { $ config = Array Object : : ensure Array Object ( $ config ) ; $ config - > defaults ( $ this - > default Config ) ; $ config - > defaults ( [ 'httplug .message _factory ' = > function ( Array Object $ config ) { if ( class _exists ( Message Factory Discovery : : class ) ) { return Message Factory Discovery : : find ( ) ; } if ( class _exists ( \ Guzzle Http \ Psr 7 \ Request : : class ) ) { return new Guzzle Message Factory ( ) ; } if ( class _exists ( \ Zend \ Diactoros \ Request : : class ) ) { return new Diactoros Message Factory ( ) ; } throw new \ Logic Exception ( 'The httplug .message _factory could not be guessed . Install one of the following packages : php -http /guzzle 6 -adapter , zendframework /zend -diactoros . You can also overwrite the config option with your implementation . ' ) ; } , 'httplug .stream _factory ' = > function ( Array Object $ config ) { if ( class _exists ( Stream Factory Discovery : : class ) ) { return Stream Factory Discovery : : find ( ) ; } if ( class _exists ( \ Guzzle Http \ Psr 7 \ Request : : class ) ) { return new Guzzle Stream Factory ( ) ; } if ( class _exists ( \ Zend \ Diactoros \ Request : : class ) ) { return new Diactoros Stream Factory ( ) ; } throw new \ Logic Exception ( 'The httplug .stream _factory could not be guessed . Install one of the following packages : php -http /guzzle 6 -adapter , zendframework /zend -diactoros . You can also overwrite the config option with your implementation . ' ) ; } , 'httplug .client ' = > function ( Array Object $ config ) { if ( class _exists ( Http Client Discovery : : class ) ) { return Http Client Discovery : : find ( ) ; } if ( class _exists ( Http Guzzle 6Client : : class ) ) { return new Http Guzzle 6Client ( ) ; } if ( class _exists ( Http Guzzle 5Client : : class ) ) { return new Http Guzzle 5Client ( ) ; } if ( class _exists ( Http Socket Client : : class ) ) { return new Http Socket Client ( ) ; } if ( class _exists ( Http Curl Client : : class ) ) { return new Http Curl Client ( $ config [ 'httplug .message _factory ' ] , $ config [ 'httplug .stream _factory ' ] ) ; } if ( class _exists ( Http Buzz Client : : class ) ) { return new Http Buzz Client ( ) ; } throw new \ Logic Exception ( 'The httplug .client could not be guessed . Install one of the following packages : php -http /guzzle 6 -adapter . You can also overwrite the config option with your implementation . ' ) ; } , 'payum .http _client ' = > function ( Array Object $ config ) { return new Httplug Client ( $ config [ 'httplug .client ' ] ) ; } , 'payum .template .layout ' = > ' @Payum Core /layout .html .twig ' , 'twig .env ' = > function ( ) { return new \ Twig _Environment ( new \ Twig _Loader _Chain ( ) ) ; } , 'twig .register _paths ' = > function ( Array Object $ config ) { $ twig = $ config [ 'twig .env ' ] ; if ( false = = $ twig instanceof \ Twig _Environment ) { throw new \ Logic Exception ( sprintf ( 'The `twig .env config option must contains instance of Twig _Environment but got %s ` ' , is _object ( $ twig ) ? get _class ( $ twig ) : gettype ( $ twig ) ) ) ; } Twig Util : : register Paths ( $ twig , $ config [ 'payum .paths ' ] ) ; return null ; } , 'payum .action .get _http _request ' = > new Get Http Request Action ( ) , 'payum .action .capture _payment ' = > new Capture Payment Action ( ) , 'payum .action .authorize _payment ' = > new Authorize Payment Action ( ) , 'payum .action .payout _payout ' = > new Payout Payout Action ( ) , 'payum .action .execute _same _request _with _model _details ' = > new Execute Same Request With Model Details Action ( ) , 'payum .action .render _template ' = > function ( Array Object $ config ) { return new Render Template Action ( $ config [ 'twig .env ' ] , $ config [ 'payum .template .layout ' ] ) ; } , 'payum .extension .endless _cycle _detector ' = > new Endless Cycle Detector Extension ( ) , 'payum .action .get _currency ' = > function ( Array Object $ config ) { return new Get Currency Action ( $ config [ 'payum .iso 4 2 1 7 ' ] ) ; } , 'payum .prepend _actions ' = > [ ] , 'payum .prepend _extensions ' = > [ ] , 'payum .prepend _apis ' = > [ ] , 'payum .default _options ' = > [ ] , 'payum .required _options ' = > [ ] , 'payum .api .http _client ' = > function ( Array Object $ config ) { return $ config [ 'payum .http _client ' ] ; } , 'payum .security .token _storage ' = > null , ] ) ; if ( $ config [ 'payum .security .token _storage ' ] ) { $ config [ 'payum .action .get _token ' ] = function ( Array Object $ config ) { return new Get Token Action ( $ config [ 'payum .security .token _storage ' ] ) ; } ; } $ config [ 'payum .paths ' ] = array _replace ( [ 'Payum Core ' = > _ _DIR _ _ . ' /Resources /views ' , ] , $ config [ 'payum .paths ' ] ? : [ ] ) ; return ( array ) $ config ; } 
public function add Api ( $ api , $ force Prepend = false ) { $ force Prepend ? array _unshift ( $ this - > apis , $ api ) : array _push ( $ this - > apis , $ api ) ; } 
public function add Action ( Action Interface $ action , $ force Prepend = false ) { $ force Prepend ? array _unshift ( $ this - > actions , $ action ) : array _push ( $ this - > actions , $ action ) ; } 
public function add Extension ( Extension Interface $ extension , $ force Prepend = false ) { $ this - > extensions - > add Extension ( $ extension , $ force Prepend ) ; } 
public function execute ( $ request , $ catch Reply = false ) { $ context = new Context ( $ this , $ request , $ this - > stack ) ; array _push ( $ this - > stack , $ context ) ; try { $ this - > extensions - > on Pre Execute ( $ context ) ; if ( false = = $ context - > get Action ( ) ) { if ( false = = $ action = $ this - > find Action Supported ( $ context - > get Request ( ) ) ) { throw Request Not Supported Exception : : create ( $ context - > get Request ( ) ) ; } $ context - > set Action ( $ action ) ; } $ this - > extensions - > on Execute ( $ context ) ; $ context - > get Action ( ) - > execute ( $ request ) ; $ this - > extensions - > on Post Execute ( $ context ) ; array _pop ( $ this - > stack ) ; } catch ( Reply Interface $ reply ) { $ context - > set Reply ( $ reply ) ; $ this - > extensions - > on Post Execute ( $ context ) ; array _pop ( $ this - > stack ) ; if ( $ catch Reply & & $ context - > get Reply ( ) ) { return $ context - > get Reply ( ) ; } if ( $ context - > get Reply ( ) ) { throw $ context - > get Reply ( ) ; } } catch ( \ Exception $ e ) { $ context - > set Exception ( $ e ) ; $ this - > on Post Execute With Exception ( $ context ) ; } return ; } 
protected function find Action Supported ( $ request ) { foreach ( $ this - > actions as $ action ) { if ( $ action instanceof Gateway Aware Interface ) { $ action - > set Gateway ( $ this ) ; } if ( $ action instanceof Api Aware Interface ) { $ api Set = false ; $ unsupported Exception = null ; foreach ( $ this - > apis as $ api ) { try { $ action - > set Api ( $ api ) ; $ api Set = true ; break ; } catch ( Unsupported Api Exception $ e ) { $ unsupported Exception = $ e ; } } if ( false = = $ api Set ) { throw new Logic Exception ( sprintf ( 'Cannot find right api for the action %s ' , get _class ( $ action ) ) , null , $ unsupported Exception ) ; } } if ( $ action - > supports ( $ request ) ) { return $ action ; } } return false ; } 
public function validate ( $ value , Constraint $ constraint ) { if ( null = = = $ value ) { return ; } if ( ! ( $ value instanceof \ Date Time ) ) { if ( method _exists ( $ this - > context , 'build Violation ' ) ) { $ this - > context - > build Violation ( $ constraint - > invalid Message , array ( ' { { value } } ' = > $ value , ) ) - > add Violation ( ) ; return ; } $ this - > context - > add Violation At ( 'expire At ' , $ constraint - > invalid Message , array ( ' { { value } } ' = > $ value , ) ) ; } $ value - > modify ( 'last day of this month ' ) ; if ( null ! = = $ constraint - > min & & $ value < $ constraint - > min ) { if ( method _exists ( $ this - > context , 'build Violation ' ) ) { $ this - > context - > build Violation ( $ constraint - > min Message ) - > at Path ( 'expire At ' ) - > add Violation ( ) ; return ; } $ this - > context - > add Violation At ( 'expire At ' , $ constraint - > min Message ) ; } } 
public function create Transaction ( array $ fields ) { $ fields = ( array _replace ( [ 'success _url ' = > null , 'success _link _redirect ' = > true , 'abort _url ' = > null , 'notification _url ' = > null , 'notify _on ' = > implode ( ' , ' , [ self : : STATUS _PENDING , self : : STATUS _LOSS , self : : STATUS _RECEIVED , self : : STATUS _REFUNDED , self : : STATUS _UNTRACEABLE ] ) , 'reason ' = > ' ' , 'reason _ 2 ' = > ' ' , 'product _code ' = > null , ] , $ fields ) ) ; $ sofort = new Sofortueberweisung ( $ this - > options [ 'config _key ' ] ) ; $ sofort - > set Amount ( $ fields [ 'amount ' ] ) ; $ sofort - > set Currency Code ( $ fields [ 'currency _code ' ] ) ; $ sofort - > set Reason ( $ fields [ 'reason ' ] , $ fields [ 'reason _ 2 ' ] , $ fields [ 'product _code ' ] ) ; $ sofort - > set Success Url ( $ fields [ 'success _url ' ] , $ fields [ 'success _link _redirect ' ] ) ; $ sofort - > set Abort Url ( $ fields [ 'abort _url ' ] ) ; if ( false = = $ this - > options [ 'disable _notification ' ] ) { $ sofort - > set Notification Url ( $ fields [ 'notification _url ' ] , $ fields [ 'notify _on ' ] ) ; } $ sofort - > send Request ( ) ; return array _filter ( [ 'error ' = > $ sofort - > get Error ( ) , 'transaction _id ' = > $ sofort - > get Transaction Id ( ) , 'payment _url ' = > $ sofort - > get Payment Url ( ) , ] ) ; } 
public function get Transaction Data ( $ transaction Id ) { $ transaction Data = new Transaction Data ( $ this - > options [ 'config _key ' ] ) ; $ transaction Data - > add Transaction ( $ transaction Id ) ; $ transaction Data - > set Api Version ( ' 2 . 0 ' ) ; $ transaction Data - > send Request ( ) ; $ fields = array ( ) ; $ methods = array ( 'get Amount ' = > ' ' , 'get Amount Refunded ' = > ' ' , 'get Count ' = > ' ' , 'get Payment Method ' = > ' ' , 'get Consumer Protection ' = > ' ' , 'get Status ' = > ' ' , 'get Status Reason ' = > ' ' , 'get Status Modified Time ' = > ' ' , 'get Language Code ' = > ' ' , 'get Currency ' = > ' ' , 'get Transaction ' = > ' ' , 'get Reason ' = > array ( 0 , 0 ) , 'get User Variable ' = > 0 , 'get Time ' = > ' ' , 'get Project Id ' = > ' ' , 'get Recipient Holder ' = > ' ' , 'get Recipient Account Number ' = > ' ' , 'get Recipient Bank Code ' = > ' ' , 'get Recipient Country Code ' = > ' ' , 'get Recipient Bank Name ' = > ' ' , 'get Recipient Bic ' = > ' ' , 'get Recipient Iban ' = > ' ' , 'get Sender Holder ' = > ' ' , 'get Sender Account Number ' = > ' ' , 'get Sender Bank Code ' = > ' ' , 'get Sender Country Code ' = > ' ' , 'get Sender Bank Name ' = > ' ' , 'get Sender Bic ' = > ' ' , 'get Sender Iban ' = > ' ' , ) ; foreach ( $ methods as $ method = > $ params ) { $ var Name = $ method ; $ var Name = strtolower ( preg _replace ( ' / ( [ ^A -Z ] ) ( [A -Z ] ) / ' , ' $ 1 _ $ 2 ' , substr ( $ var Name , 3 ) ) ) ; if ( count ( $ params ) = = 2 ) { $ fields [ $ var Name ] = $ transaction Data - > $ method ( $ params [ 0 ] , $ params [ 1 ] ) ; } elseif ( $ params ! = = ' ' ) { $ fields [ $ var Name ] = $ transaction Data - > $ method ( $ params ) ; } else { $ fields [ $ var Name ] = $ transaction Data - > $ method ( ) ; } } if ( $ transaction Data - > is Error ( ) ) { $ fields [ 'error ' ] = $ transaction Data - > get Error ( ) ; } return $ fields ; } 
public function refund Transaction ( array $ fields ) { $ refund = new Refund ( $ this - > options [ 'config _key ' ] ) ; $ refund - > set Sender Sepa Account ( $ fields [ 'recipient _bic ' ] , $ fields [ 'recipient _iban ' ] , $ fields [ 'recipient _holder ' ] ) ; $ refund - > add Refund ( $ fields [ 'transaction _id ' ] , $ fields [ 'refund _amount ' ] ) ; $ refund - > set Partial Refund Id ( md 5 ( uniqid ( ) ) ) ; $ refund - > set Reason ( $ fields [ 'reason ' ] ) ; $ refund - > send Request ( ) ; if ( $ refund - > is Error ( ) ) { $ fields [ 'refund _error ' ] = $ refund - > get Error ( ) ; } else { $ fields [ 'refund _url ' ] = $ refund - > get Payment Url ( ) ; } return $ fields ; } 
public function convert To PHPValue ( $ value ) { if ( $ value = = = null ) { return ; } $ value = ( is _resource ( $ value ) ) ? stream _get _contents ( $ value ) : $ value ; $ val = unserialize ( $ value ) ; if ( $ val = = = false & & $ value ! = = 'b : 0 ; ' ) { throw new \ Logic Exception ( 'Conversion exception : ' . $ value . ' . ' . $ this - > get Name ( ) ) ; } return $ val ; } 
protected function validate Options ( array $ options = [ ] ) : Parameter Bag { if ( empty ( $ options ) ) { return $ this - > options ; } return $ this - > do Validate Options ( $ options ) ; } 
private function do Validate Options ( array $ options = [ ] ) : Parameter Bag { $ parameter Bag = $ this - > options - > add ( $ options ) ; try { $ parameters = $ this - > get Options Resolver ( ) - > resolve ( $ parameter Bag - > all ( ) ) ; } catch ( \ Throwable $ e ) { 
public function add Cookie ( Cookie $ cookie ) : void { $ this - > cookies [ $ this - > get Hash ( $ cookie ) ] = $ cookie ; } 
public function add Cookie Headers ( Request Interface $ request ) : Request Interface { $ cookies = [ ] ; foreach ( $ this - > get Cookies ( ) as $ cookie ) { if ( $ cookie - > matches Request ( $ request ) ) { $ cookies [ ] = $ cookie - > to Cookie Header ( ) ; } } if ( $ cookies ) { $ request = $ request - > with Added Header ( 'Cookie ' , implode ( ' ; ' , $ cookies ) ) ; } return $ request ; } 
public function process Set Cookie Headers ( Request Interface $ request , Response Interface $ response ) : void { $ host = $ request - > get Uri ( ) - > get Host ( ) ; foreach ( $ response - > get Header ( 'Set -Cookie ' ) as $ header ) { $ cookie = new Cookie ( ) ; $ cookie - > from Set Cookie Header ( $ header , $ host ) ; $ this - > add Cookie ( $ cookie ) ; } } 
public function clear Expired Cookies ( ) : void { $ cookies = $ this - > get Cookies ( ) ; foreach ( $ cookies as $ i = > $ cookie ) { if ( $ cookie - > is Expired ( ) ) { unset ( $ cookies [ $ i ] ) ; } } $ this - > clear ( ) ; $ this - > set Cookies ( array _values ( $ cookies ) ) ; } 
private function get Hash ( Cookie $ cookie ) : string { return sha 1 ( sprintf ( ' %s | %s | %s ' , $ cookie - > get Name ( ) , $ cookie - > get Attribute ( Cookie : : ATTR _DOMAIN ) , $ cookie - > get Attribute ( Cookie : : ATTR _PATH ) ) ) ; } 
public function add Header ( string $ input ) : void { list ( $ key , $ value ) = explode ( ' : ' , $ input , 2 ) ; $ this - > response = $ this - > response - > with Added Header ( trim ( $ key ) , trim ( $ value ) ) ; } 
public function parse Http Headers ( array $ headers ) : void { $ headers = $ this - > filter Headers ( $ headers ) ; $ status Line = array _shift ( $ headers ) ; try { $ this - > set Status ( $ status Line ) ; } catch ( Invalid Argument Exception $ e ) { array _unshift ( $ headers , $ status Line ) ; } foreach ( $ headers as $ header ) { $ this - > add Header ( $ header ) ; } } 
public function handle Request ( Request Interface $ request , callable $ next ) { $ this - > set Uri ( $ request - > get Uri ( ) - > get Path ( ) ) ; $ this - > set Method ( strtoupper ( $ request - > get Method ( ) ) ) ; $ this - > set Entity Body ( $ request - > get Body ( ) - > _ _to String ( ) ) ; $ header = $ this - > get Header ( ) ; if ( null ! = = $ header ) { $ request = $ request - > with Header ( 'Authorization ' , $ header ) ; } return $ next ( $ request ) ; } 
public function handle Response ( Request Interface $ request , Response Interface $ response , callable $ next ) { $ this - > parse Server Headers ( $ response ) ; return $ next ( $ request , $ response ) ; } 
public function set Options ( $ options ) : void { if ( $ options & self : : OPTION _QOP _AUTH _INT ) { if ( $ options & self : : OPTION _QOP _AUTH ) { throw new \ Invalid Argument Exception ( 'Digest Auth Middleware : Only one value of OPTION _QOP _AUTH _INT or OPTION _QOP _AUTH may be set . ' ) ; } $ this - > options = $ this - > options | self : : OPTION _QOP _AUTH _INT ; } elseif ( $ options & self : : OPTION _QOP _AUTH ) { $ this - > options = $ this - > options | self : : OPTION _QOP _AUTH ; } if ( $ options & self : : OPTION _IGNORE _DOWNGRADE _REQUEST ) { $ this - > options = $ this - > options | self : : OPTION _IGNORE _DOWNGRADE _REQUEST ; } if ( $ options & self : : OPTION _DISCARD _CLIENT _NONCE ) { $ this - > options = $ this - > options | self : : OPTION _DISCARD _CLIENT _NONCE ; } } 
private function get Client Nonce ( ) : ? string { if ( null = = $ this - > client Nonce ) { $ this - > client Nonce = uniqid ( ) ; if ( null = = $ this - > nonce Count ) { 
private function get HA 1 ( ) : ? string { $ username = $ this - > get Username ( ) ; $ password = $ this - > get Password ( ) ; $ realm = $ this - > get Realm ( ) ; if ( ( $ username ) & & ( $ password ) & & ( $ realm ) ) { $ algorithm = $ this - > get Algorithm ( ) ; if ( 'MD 5 ' = = = $ algorithm ) { $ A 1 = " { $username } : { $realm } : { $password } " ; return $ this - > hash ( $ A 1 ) ; } elseif ( 'MD 5 -sess ' = = = $ algorithm ) { $ nonce = $ this - > get Nonce ( ) ; $ cnonce = $ this - > get Client Nonce ( ) ; if ( ( $ nonce ) & & ( $ cnonce ) ) { $ A 1 = $ this - > hash ( " { $username } : { $realm } : { $password } " ) . " : { $nonce } : { $cnonce } " ; return $ this - > hash ( $ A 1 ) ; } } } return null ; } 
private function get HA 2 ( ) : ? string { $ method = $ this - > get Method ( ) ; $ uri = $ this - > get Uri ( ) ; if ( ( $ method ) & & ( $ uri ) ) { $ qop = $ this - > get QOP ( ) ; if ( null = = = $ qop | | 'auth ' = = = $ qop ) { $ A 2 = " { $method } : { $uri } " ; } elseif ( 'auth -int ' = = = $ qop ) { $ entity Body = ( string ) $ this - > get Entity Body ( ) ; $ A 2 = " { $method } : { $uri } : " . ( string ) $ this - > hash ( $ entity Body ) ; } else { return null ; } $ HA 2 = $ this - > hash ( $ A 2 ) ; return $ HA 2 ; } return null ; } 
private function get Header ( ) : ? string { if ( 'Digest ' = = $ this - > get Authentication Method ( ) ) { $ username = $ this - > get Username ( ) ; $ realm = $ this - > get Realm ( ) ; $ nonce = $ this - > get Nonce ( ) ; $ response = $ this - > get Response ( ) ; if ( ( $ username ) & & ( $ realm ) & & ( $ nonce ) & & ( $ response ) ) { $ uri = $ this - > get Uri ( ) ; $ opaque = $ this - > get Opaque ( ) ; $ qop = $ this - > get QOP ( ) ; $ header = 'Digest ' ; $ header . = ' username = " ' . $ username . ' " , ' ; $ header . = ' realm = " ' . $ realm . ' " , ' ; $ header . = ' nonce = " ' . $ nonce . ' " , ' ; $ header . = ' response = " ' . $ response . ' " , ' ; if ( $ uri ) { $ header . = ' uri = " ' . $ uri . ' " , ' ; } if ( $ opaque ) { $ header . = ' opaque = " ' . $ opaque . ' " , ' ; } if ( $ qop ) { $ header . = ' qop = ' . $ qop . ' , ' ; $ cnonce = $ this - > get Client Nonce ( ) ; $ nc = $ this - > get Nonce Count ( ) ; if ( $ cnonce ) { $ header . = ' nc = ' . $ nc . ' , ' ; } if ( $ cnonce ) { $ header . = ' cnonce = " ' . $ cnonce . ' " , ' ; } } 
private function get Response ( ) : ? string { $ HA 1 = $ this - > get HA 1 ( ) ; $ nonce = $ this - > get Nonce ( ) ; $ HA 2 = $ this - > get HA 2 ( ) ; if ( null ! = = $ HA 1 & & ( $ nonce ) & & null ! = = $ HA 2 ) { $ qop = $ this - > get QOP ( ) ; if ( empty ( $ qop ) ) { $ response = $ this - > hash ( " { $HA 1 } : { $nonce } : { $HA 2 } " ) ; return $ response ; } $ cnonce = $ this - > get Client Nonce ( ) ; $ nc = $ this - > get Nonce Count ( ) ; if ( ( $ cnonce ) & & ( $ nc ) ) { $ response = $ this - > hash ( " { $HA 1 } : { $nonce } : { $nc } : { $cnonce } : { $qop } : { $HA 2 } " ) ; return $ response ; } } return null ; } 
private function get QOP ( ) : ? string { 
private function hash ( $ value ) : ? string { $ algorithm = $ this - > get Algorithm ( ) ; if ( ( 'MD 5 ' = = $ algorithm ) | | ( 'MD 5 -sess ' = = $ algorithm ) ) { return hash ( 'md 5 ' , $ value ) ; } return null ; } 
private function parse Authentication Info Header ( string $ authentication Info ) : void { $ name Value Pairs = $ this - > parse Name Value Pairs ( $ authentication Info ) ; foreach ( $ name Value Pairs as $ name = > $ value ) { switch ( $ name ) { case 'message -qop ' : break ; case 'nextnonce ' : 
private function parse Name Value Pairs ( string $ name Value Pairs ) : array { $ parsed Name Value Pairs = [ ] ; $ name Value Pairs = explode ( ' , ' , $ name Value Pairs ) ; foreach ( $ name Value Pairs as $ name Value Pair ) { 
private function parse Server Headers ( Response Interface $ response ) : void { 
private function parse Www Authenticate Header ( string $ www Authenticate ) : void { if ( 'Digest ' = = substr ( $ www Authenticate , 0 , 7 ) ) { $ this - > set Authentication Method ( 'Digest ' ) ; 
private function set Algorithm ( string $ algorithm ) : void { if ( ( 'MD 5 ' = = $ algorithm ) | | ( 'MD 5 -sess ' = = $ algorithm ) ) { $ this - > algorithm = $ algorithm ; } else { throw new \ Invalid Argument Exception ( 'Digest Auth Middleware : Only MD 5 and MD 5 -sess algorithms are currently supported . ' ) ; } } 
private function set Authentication Method ( string $ authentication Method ) : void { if ( 'Digest ' = = = $ authentication Method | | 'Basic ' = = = $ authentication Method ) { $ this - > authentication Method = $ authentication Method ; } else { throw new \ Invalid Argument Exception ( 'Digest Auth Middleware : Only Digest and Basic authentication methods are currently supported . ' ) ; } } 
private function set Method ( string $ method = null ) : void { if ( 'GET ' = = $ method ) { $ this - > method = 'GET ' ; return ; } if ( 'POST ' = = $ method ) { $ this - > method = 'POST ' ; return ; } if ( 'PUT ' = = $ method ) { $ this - > method = 'PUT ' ; return ; } if ( 'DELETE ' = = $ method ) { $ this - > method = 'DELETE ' ; return ; } if ( 'HEAD ' = = $ method ) { $ this - > method = 'HEAD ' ; return ; } throw new \ Invalid Argument Exception ( 'Digest Auth Middleware : Only GET ,POST ,PUT ,DELETE ,HEAD HTTP methods are currently supported . ' ) ; } 
private function set QOP ( array $ qop = [ ] ) : void { $ this - > qop = [ ] ; foreach ( $ qop as $ protection ) { $ protection = trim ( $ protection ) ; if ( 'auth -int ' = = $ protection ) { $ this - > qop [ ] = 'auth -int ' ; } elseif ( 'auth ' = = $ protection ) { $ this - > qop [ ] = 'auth ' ; } else { throw new \ Invalid Argument Exception ( 'Digest Auth Middleware : Only auth -int and auth are supported Quality of Protection mechanisms . ' ) ; } } } 
private function unquote String ( string $ str = null ) : ? string { if ( $ str ) { if ( ' " ' = = substr ( $ str , 0 , 1 ) ) { $ str = substr ( $ str , 1 , \ strlen ( $ str ) - 1 ) ; } if ( ' " ' = = substr ( $ str , \ strlen ( $ str ) - 1 , 1 ) ) { $ str = substr ( $ str , 0 , \ strlen ( $ str ) - 1 ) ; } } return $ str ; } 
public function add ( array $ parameters = [ ] ) : self { 
public static function to Buzz Headers ( array $ headers ) : array { $ buzz = [ ] ; foreach ( $ headers as $ key = > $ values ) { if ( ! \ is _array ( $ values ) ) { $ buzz [ ] = sprintf ( ' %s : %s ' , $ key , $ values ) ; } else { foreach ( $ values as $ value ) { $ buzz [ ] = sprintf ( ' %s : %s ' , $ key , $ value ) ; } } } return $ buzz ; } 
public static function to Psr Headers ( array $ headers ) : array { $ psr = [ ] ; foreach ( $ headers as $ header ) { list ( $ key , $ value ) = explode ( ' : ' , $ header , 2 ) ; $ psr [ trim ( $ key ) ] [ ] = trim ( $ value ) ; } return $ psr ; } 
protected function get Stream Context Array ( Request Interface $ request , Parameter Bag $ options ) : array { $ headers = $ request - > get Headers ( ) ; unset ( $ headers [ 'Host ' ] ) ; $ context = [ 'http ' = > [ 
public function send Async Request ( Request Interface $ request , array $ options = [ ] ) : void { $ options = $ this - > validate Options ( $ options ) ; $ this - > add To Queue ( $ request , $ options ) ; } 
public function send Request ( Request Interface $ request , array $ options = [ ] ) : Response Interface { $ options = $ this - > validate Options ( $ options ) ; $ original Callback = $ options - > get ( 'callback ' ) ; $ response To Return = null ; $ options = $ options - > add ( [ 'callback ' = > function ( Request Interface $ request , Response Interface $ response = null , Client Exception $ e = null ) use ( & $ response To Return , $ original Callback ) { $ response To Return = $ response ; $ original Callback ( $ request , $ response , $ e ) ; if ( null ! = = $ e ) { throw $ e ; } } ] ) ; $ this - > add To Queue ( $ request , $ options ) ; $ this - > flush ( ) ; return $ response To Return ; } 
public function proceed ( ) : void { if ( empty ( $ this - > queue ) ) { return ; } if ( ! $ this - > curlm ) { $ this - > init Multi Curl Handle ( ) ; } $ this - > init Queue ( ) ; $ exception = null ; do { 
private function init Multi Curl Handle ( ) : void { $ this - > curlm = curl _multi _init ( ) ; if ( false = = = $ this - > curlm ) { throw new Client Exception ( 'Unable to create a new c URL multi handle ' ) ; } if ( $ this - > server Push Supported ) { $ user Callbacks = $ this - > push Functions ; curl _multi _setopt ( $ this - > curlm , CURLMOPT _PIPELINING , CURLPIPE _MULTIPLEX ) ; 
private function init Queue ( ) : void { foreach ( $ this - > queue as $ i = > $ queue Item ) { if ( 2 ! = = \ count ( $ queue Item ) ) { 
private function cleanup ( ) : void { if ( empty ( $ this - > queue ) ) { curl _multi _close ( $ this - > curlm ) ; $ this - > curlm = null ; $ this - > push Functions = [ ] ; $ this - > push Cb = [ ] ; } } 
public function matches Request ( Request Interface $ request ) : bool { $ uri = $ request - > get Uri ( ) ; 
public function is Expired ( ) : bool { $ max Age = $ this - > get Attribute ( static : : ATTR _MAX _AGE ) ; if ( $ max Age & & time ( ) - $ this - > get Created At ( ) > $ max Age ) { return true ; } $ expires = $ this - > get Attribute ( static : : ATTR _EXPIRES ) ; if ( $ expires & & strtotime ( $ expires ) < time ( ) ) { return true ; } return false ; } 
public function matches Domain ( string $ domain ) : bool { $ cookie Domain = $ this - > get Attribute ( static : : ATTR _DOMAIN ) ? ? ' ' ; if ( 0 = = = strpos ( $ cookie Domain , ' . ' ) ) { $ pattern = ' / \b ' . preg _quote ( substr ( $ cookie Domain , 1 ) , ' / ' ) . ' $ /i ' ; return ( bool ) preg _match ( $ pattern , $ domain ) ; } else { return 0 = = strcasecmp ( $ cookie Domain , $ domain ) ; } } 
public function matches Path ( string $ path ) : bool { $ needle = $ this - > get Attribute ( static : : ATTR _PATH ) ; return null = = = $ needle | | 0 = = = strpos ( $ path , $ needle ) ; } 
public function from Set Cookie Header ( string $ header , string $ issuing Domain ) : void { list ( $ this - > name , $ header ) = explode ( ' = ' , $ header , 2 ) ; if ( false = = = strpos ( $ header , ' ; ' ) ) { $ this - > value = $ header ; $ header = null ; } else { list ( $ this - > value , $ header ) = explode ( ' ; ' , $ header , 2 ) ; } $ this - > clear Attributes ( ) ; if ( null ! = = $ header ) { foreach ( array _map ( 'trim ' , explode ( ' ; ' , trim ( $ header ) ) ) as $ pair ) { if ( false = = = strpos ( $ pair , ' = ' ) ) { $ name = $ pair ; $ value = null ; } else { list ( $ name , $ value ) = explode ( ' = ' , $ pair ) ; } $ this - > set Attribute ( $ name , $ value ) ; } } if ( ! $ this - > get Attribute ( static : : ATTR _DOMAIN ) ) { $ this - > set Attribute ( static : : ATTR _DOMAIN , $ issuing Domain ) ; } } 
protected function release Handle ( $ curl ) : void { if ( \ count ( $ this - > handles ) > = $ this - > max Handles ) { curl _close ( $ curl ) ; } else { 
protected function prepare ( $ curl , Request Interface $ request , Parameter Bag $ options ) : Response Builder { if ( \ defined ( 'CURLOPT _PROTOCOLS ' ) ) { curl _setopt ( $ curl , CURLOPT _PROTOCOLS , CURLPROTO _HTTP | CURLPROTO _HTTPS ) ; curl _setopt ( $ curl , CURLOPT _REDIR _PROTOCOLS , CURLPROTO _HTTP | CURLPROTO _HTTPS ) ; } curl _setopt ( $ curl , CURLOPT _HEADER , false ) ; curl _setopt ( $ curl , CURLOPT _RETURNTRANSFER , false ) ; curl _setopt ( $ curl , CURLOPT _FAILONERROR , false ) ; $ this - > set Options From Parameter Bag ( $ curl , $ options ) ; $ this - > set Options From Request ( $ curl , $ request ) ; $ response Builder = new Response Builder ( $ this - > response Factory ) ; curl _setopt ( $ curl , CURLOPT _HEADERFUNCTION , function ( $ ch , $ data ) use ( $ response Builder ) { $ str = trim ( $ data ) ; if ( ' ' ! = = $ str ) { if ( 0 = = = strpos ( strtolower ( $ str ) , 'http / ' ) ) { $ response Builder - > set Status ( $ str ) ; } else { $ response Builder - > add Header ( $ str ) ; } } return \ strlen ( $ data ) ; } ) ; curl _setopt ( $ curl , CURLOPT _WRITEFUNCTION , function ( $ ch , $ data ) use ( $ response Builder ) { return $ response Builder - > write Body ( $ data ) ; } ) ; 
private function set Options From Request ( $ curl , Request Interface $ request ) : void { $ options = [ CURLOPT _CUSTOMREQUEST = > $ request - > get Method ( ) , CURLOPT _URL = > $ request - > get Uri ( ) - > _ _to String ( ) , CURLOPT _HTTPHEADER = > Header Converter : : to Buzz Headers ( $ request - > get Headers ( ) ) , ] ; if ( 0 ! = = $ version = $ this - > get Protocol Version ( $ request ) ) { $ options [ CURLOPT _HTTP _VERSION ] = $ version ; } if ( $ request - > get Uri ( ) - > get User Info ( ) ) { $ options [ CURLOPT _USERPWD ] = $ request - > get Uri ( ) - > get User Info ( ) ; } switch ( strtoupper ( $ request - > get Method ( ) ) ) { case 'HEAD ' : $ options [ CURLOPT _NOBODY ] = true ; break ; case 'GET ' : $ options [ CURLOPT _HTTPGET ] = true ; break ; case 'POST ' : case 'PUT ' : case 'DELETE ' : case 'PATCH ' : case 'OPTIONS ' : $ body = $ request - > get Body ( ) ; $ body Size = $ body - > get Size ( ) ; if ( 0 ! = = $ body Size ) { if ( $ body - > is Seekable ( ) ) { $ body - > rewind ( ) ; } 
protected function parse Error ( Request Interface $ request , int $ errno , $ curl ) : void { switch ( $ errno ) { case CURLE _OK : 
public function send Request ( Request Interface $ request , array $ options = [ ] ) : Response Interface { $ chain = $ this - > create Middleware Chain ( $ this - > middleware , function ( Request Interface $ request , callable $ response Chain ) use ( $ options ) { $ response = $ this - > client - > send Request ( $ request , $ options ) ; $ response Chain ( $ request , $ response ) ; } , function ( Request Interface $ request , Response Interface $ response ) { $ this - > last Request = $ request ; $ this - > last Response = $ response ; } ) ; 
public function record ( Request Interface $ request , Response Interface $ response , float $ duration = null ) : void { $ this - > add Entry ( new Entry ( $ request , $ response , $ duration ) ) ; } 
public function set Page ( $ page ) { $ this - > _page = preg _match ( self : : REGEX _HTML , $ page ) ? new File ( $ page , ' .html ' ) : $ page ; return $ this ; } 
public function save As ( $ filename ) { if ( ! $ this - > _is Created & & ! $ this - > create Image ( ) ) { return false ; } if ( ! $ this - > _tmp Image File - > save As ( $ filename ) ) { $ tmp File = $ this - > _tmp Image File - > get File Name ( ) ; $ this - > _error = "Could not copy image from tmp location ' $tmp File ' to ' $filename ' " ; return false ; } return true ; } 
public function send ( $ filename = null , $ inline = false ) { if ( ! $ this - > _is Created & & ! $ this - > create Image ( ) ) { return false ; } $ this - > _tmp Image File - > send ( $ filename , $ this - > get Mime Type ( ) , $ inline ) ; return true ; } 
public function to String ( ) { if ( ! $ this - > _is Created & & ! $ this - > create Image ( ) ) { return false ; } return file _get _contents ( $ this - > _tmp Image File - > get File Name ( ) ) ; } 
public function set Options ( $ options = array ( ) ) { foreach ( $ options as $ key = > $ val ) { if ( is _int ( $ key ) ) { $ this - > _options [ ] = $ val ; } elseif ( $ key [ 0 ] ! = = ' _ ' & & property _exists ( $ this , $ key ) ) { $ this - > $ key = $ val ; } else { $ this - > _options [ $ key ] = $ val ; } } return $ this ; } 
protected function create Image ( ) { if ( $ this - > _is Created ) { return false ; } $ command = $ this - > get Command ( ) ; $ file Name = $ this - > get Image Filename ( ) ; $ command - > add Args ( $ this - > _options ) ; 
public function add Page ( $ input , $ options = array ( ) , $ type = null ) { $ options [ 'input Arg ' ] = $ this - > ensure Url Or File ( $ input , $ type ) ; $ this - > _objects [ ] = $ this - > ensure Url Or File Options ( $ options ) ; return $ this ; } 
public function add Cover ( $ input , $ options = array ( ) , $ type = null ) { $ options [ 'input ' ] = ( $ this - > version 9 ? ' - - ' : ' ' ) . 'cover ' ; $ options [ 'input Arg ' ] = $ this - > ensure Url Or File ( $ input , $ type ) ; $ this - > _objects [ ] = $ this - > ensure Url Or File Options ( $ options ) ; return $ this ; } 
public function add Toc ( $ options = array ( ) ) { $ options [ 'input ' ] = ( $ this - > version 9 ? ' - - ' : ' ' ) . 'toc ' ; $ this - > _objects [ ] = $ this - > ensure Url Or File Options ( $ options ) ; return $ this ; } 
public function save As ( $ filename ) { if ( ! $ this - > _is Created & & ! $ this - > create Pdf ( ) ) { return false ; } if ( ! $ this - > _tmp Pdf File - > save As ( $ filename ) ) { $ this - > _error = "Could not save PDF as ' $filename ' " ; return false ; } return true ; } 
public function send ( $ filename = null , $ inline = false ) { if ( ! $ this - > _is Created & & ! $ this - > create Pdf ( ) ) { return false ; } $ this - > _tmp Pdf File - > send ( $ filename , 'application /pdf ' , $ inline ) ; return true ; } 
public function to String ( ) { if ( ! $ this - > _is Created & & ! $ this - > create Pdf ( ) ) { return false ; } return file _get _contents ( $ this - > _tmp Pdf File - > get File Name ( ) ) ; } 
public function set Options ( $ options = array ( ) ) { 
protected function create Pdf ( ) { if ( $ this - > _is Created ) { return false ; } $ command = $ this - > get Command ( ) ; $ file Name = $ this - > get Pdf Filename ( ) ; $ command - > add Args ( $ this - > _options ) ; foreach ( $ this - > _objects as $ object ) { $ command - > add Args ( $ object ) ; } $ command - > add Arg ( $ file Name , null , true ) ; 
protected function ensure Url Or File ( $ input , $ type = null ) { if ( $ input instanceof File ) { $ this - > _tmp Files [ ] = $ input ; return $ input ; } elseif ( preg _match ( self : : REGEX _URL , $ input ) ) { return $ input ; } elseif ( $ type = = = self : : TYPE _XML | | $ type = = = null & & preg _match ( self : : REGEX _XML , $ input ) ) { $ ext = ' .xml ' ; } else { 
public function add Args ( $ args ) { if ( isset ( $ args [ 'input ' ] ) ) { 
public static function create ( array $ parsed Response ) { $ result = new Logging ( ) ; $ result - > set Version ( $ parsed Response [ 'Version ' ] ) ; $ result - > set Delete ( Utilities : : to Boolean ( $ parsed Response [ 'Delete ' ] ) ) ; $ result - > set Read ( Utilities : : to Boolean ( $ parsed Response [ 'Read ' ] ) ) ; $ result - > set Write ( Utilities : : to Boolean ( $ parsed Response [ 'Write ' ] ) ) ; $ result - > set Retention Policy ( Retention Policy : : create ( $ parsed Response [ 'Retention Policy ' ] ) ) ; return $ result ; } 
public function to Array ( ) { return array ( 'Version ' = > $ this - > _version , 'Delete ' = > Utilities : : boolean To String ( $ this - > _delete ) , 'Read ' = > Utilities : : boolean To String ( $ this - > _read ) , 'Write ' = > Utilities : : boolean To String ( $ this - > _write ) , 'Retention Policy ' = > ! empty ( $ this - > _retention Policy ) ? $ this - > _retention Policy - > to Array ( ) : null ) ; } 
private static function create Client ( array $ options ) { $ verify = true ; 
protected function create Middleware Stack ( Service Options $ service Options ) { 
protected function send Concurrent Async ( callable $ generator , $ status Code , Service Options $ options ) { $ client = $ this - > client ; $ middleware Stack = $ this - > create Middleware Stack ( $ options ) ; $ send Async = function ( $ request , $ options ) use ( $ client ) { if ( $ request - > get Method ( ) = = 'HEAD ' ) { $ options [ 'decode _content ' ] = false ; } return $ client - > send Async ( $ request , $ options ) ; } ; $ handler = $ middleware Stack - > apply ( $ send Async ) ; $ request Options = $ this - > generate Request Options ( $ options , $ handler ) ; $ promises = \ call _user _func ( function ( ) use ( $ generator , $ handler , $ request Options ) { while ( is _callable ( $ generator ) & & ( $ request = $ generator ( ) ) ) { yield \ call _user _func ( $ handler , $ request , $ request Options ) ; } } ) ; $ each Promise = new Each Promise ( $ promises , [ 'concurrency ' = > $ options - > get Number Of Concurrency ( ) , 'fulfilled ' = > function ( $ response , $ index ) use ( $ status Code ) { 
protected function create Request ( $ method , array $ headers , array $ query Params , array $ post Parameters , $ path , $ location Mode , $ body = Resources : : EMPTY _STRING ) { if ( $ location Mode = = Location Mode : : SECONDARY _ONLY | | $ location Mode = = Location Mode : : SECONDARY _THEN _PRIMARY ) { $ uri = $ this - > psr Secondary Uri ; } else { $ uri = $ this - > psr Primary Uri ; } 
protected function send Async ( $ method , array $ headers , array $ query Params , array $ post Parameters , $ path , $ expected = Resources : : STATUS _OK , $ body = Resources : : EMPTY _STRING , Service Options $ service Options = null ) { if ( $ service Options = = null ) { $ service Options = new Service Options ( ) ; } $ this - > add Optional Query Param ( $ query Params , Resources : : QP _TIMEOUT , $ service Options - > get Timeout ( ) ) ; $ request = $ this - > create Request ( $ method , $ headers , $ query Params , $ post Parameters , $ path , $ service Options - > get Location Mode ( ) , $ body ) ; $ client = $ this - > client ; $ middleware Stack = $ this - > create Middleware Stack ( $ service Options ) ; $ send Async = function ( $ request , $ options ) use ( $ client ) { return $ client - > send Async ( $ request , $ options ) ; } ; $ handler = $ middleware Stack - > apply ( $ send Async ) ; $ request Options = $ this - > generate Request Options ( $ service Options , $ handler ) ; if ( $ request - > get Method ( ) = = 'HEAD ' ) { $ request Options [ Resources : : ROS _DECODE _CONTENT ] = false ; } $ promise = \ call _user _func ( $ handler , $ request , $ request Options ) ; return $ promise - > then ( function ( $ response ) use ( $ expected , $ request Options ) { self : : throw If Error ( $ response , $ expected ) ; return self : : add Location Header To Response ( $ response , $ request Options [ Resources : : ROS _LOCATION _MODE ] ) ; } , function ( $ reason ) use ( $ expected ) { if ( ! ( $ reason instanceof Request Exception ) ) { throw $ reason ; } $ response = $ reason - > get Response ( ) ; if ( $ response ! = null ) { self : : throw If Error ( $ response , $ expected ) ; } else { 
protected function generate Request Options ( Service Options $ service Options , callable $ handler ) { $ result = array ( ) ; $ result [ Resources : : ROS _LOCATION _MODE ] = $ service Options - > get Location Mode ( ) ; $ result [ Resources : : ROS _STREAM ] = $ service Options - > get Is Streaming ( ) ; $ result [ Resources : : ROS _DECODE _CONTENT ] = $ service Options - > get Decode Content ( ) ; $ result [ Resources : : ROS _HANDLER ] = $ handler ; $ result [ Resources : : ROS _SECONDARY _URI ] = $ this - > get Psr Secondary Uri ( ) ; $ result [ Resources : : ROS _PRIMARY _URI ] = $ this - > get Psr Primary Uri ( ) ; return $ result ; } 
protected function send Context Async ( Http Call Context $ context ) { return $ this - > send Async ( $ context - > get Method ( ) , $ context - > get Headers ( ) , $ context - > get Query Parameters ( ) , $ context - > get Post Parameters ( ) , $ context - > get Path ( ) , $ context - > get Status Codes ( ) , $ context - > get Body ( ) , $ context - > get Service Options ( ) ) ; } 
public static function throw If Error ( Response Interface $ response , $ expected ) { $ expected Status Codes = is _array ( $ expected ) ? $ expected : array ( $ expected ) ; if ( ! in _array ( $ response - > get Status Code ( ) , $ expected Status Codes ) ) { throw new Service Exception ( $ response ) ; } } 
public function add Post Parameter ( array $ post Parameters , $ key , $ value ) { Validate : : is Array ( $ post Parameters , 'post Parameters ' ) ; $ post Parameters [ $ key ] = $ value ; return $ post Parameters ; } 
public static function group Query Values ( array $ values ) { Validate : : is Array ( $ values , 'values ' ) ; $ joined = Resources : : EMPTY _STRING ; sort ( $ values ) ; foreach ( $ values as $ value ) { if ( ! is _null ( $ value ) & & ! empty ( $ value ) ) { $ joined . = $ value . Resources : : SEPARATOR ; } } return trim ( $ joined , Resources : : SEPARATOR ) ; } 
protected function add Metadata Headers ( array $ headers , array $ metadata = null ) { Utilities : : validate Metadata ( $ metadata ) ; $ metadata = $ this - > generate Metadata Headers ( $ metadata ) ; $ headers = array _merge ( $ headers , $ metadata ) ; return $ headers ; } 
private static function add Location Header To Response ( Response Interface $ response , $ location Mode ) { 
private function _validate Properties ( $ properties ) { Validate : : is Array ( $ properties , 'entity properties ' ) ; foreach ( $ properties as $ key = > $ value ) { Validate : : can Cast As String ( $ key , 'key ' ) ; Validate : : is True ( $ value instanceof Property , Resources : : INVALID _PROP _MSG ) ; Validate : : is True ( Edm Type : : validate Edm Value ( $ value - > get Edm Type ( ) , $ value - > get Value ( ) , $ condition ) , sprintf ( Resources : : INVALID _PROP _VAL _MSG , $ key , $ condition ) ) ; } } 
public function get Property Value ( $ name ) { $ p = Utilities : : try Get Value ( $ this - > _properties , $ name ) ; return is _null ( $ p ) ? null : $ p - > get Value ( ) ; } 
public function set Property Value ( $ name , $ value ) { $ p = Utilities : : try Get Value ( $ this - > _properties , $ name ) ; if ( ! is _null ( $ p ) ) { $ p - > set Value ( $ value ) ; } } 
public function set Property ( $ name , $ property ) { Validate : : is True ( $ property instanceof Property , Resources : : INVALID _PROP _MSG ) ; $ this - > _properties [ $ name ] = $ property ; } 
public function add Property ( $ name , $ edm Type , $ value , $ raw Value = ' ' ) { $ p = new Property ( ) ; $ p - > set Edm Type ( $ edm Type ) ; $ p - > set Value ( $ value ) ; $ p - > set Raw Value ( $ raw Value ) ; $ this - > set Property ( $ name , $ p ) ; } 
public function is Valid ( & $ msg = null ) { try { $ this - > _validate Properties ( $ this - > _properties ) ; } catch ( \ Exception $ exc ) { $ msg = $ exc - > get Message ( ) ; return false ; } if ( is _null ( $ this - > get Partition Key ( ) ) | | is _null ( $ this - > get Row Key ( ) ) ) { $ msg = Resources : : NULL _TABLE _KEY _MSG ; return false ; } else { return true ; } } 
public static function create ( $ body , $ odata Serializer ) { $ result = new Get Table Result ( ) ; $ name = $ odata Serializer - > parse Table ( $ body ) ; $ result - > set Name ( $ name ) ; return $ result ; } 
protected function compute Signature ( array $ headers , $ url , array $ query Params , $ http Method ) { $ canonicalized Headers = $ this - > compute Canonicalized Headers ( $ headers ) ; $ canonicalized Resource = $ this - > compute Canonicalized Resource ( $ url , $ query Params ) ; $ string To Sign = array ( ) ; $ string To Sign [ ] = strtoupper ( $ http Method ) ; foreach ( $ this - > included Headers as $ header ) { $ string To Sign [ ] = Utilities : : try Get Value ( $ headers , $ header ) ; } if ( count ( $ canonicalized Headers ) > 0 ) { $ string To Sign [ ] = implode ( " \n " , $ canonicalized Headers ) ; } $ string To Sign [ ] = $ canonicalized Resource ; $ string To Sign = implode ( " \n " , $ string To Sign ) ; return $ string To Sign ; } 
public function get Authorization Header ( array $ headers , $ url , array $ query Params , $ http Method ) { $ signature = $ this - > compute Signature ( $ headers , $ url , $ query Params , $ http Method ) ; return 'Shared Key ' . $ this - > account Name . ' : ' . base 6 4 _encode ( hash _hmac ( 'sha 2 5 6 ' , $ signature , base 6 4 _decode ( $ this - > account Key ) , true ) ) ; } 
protected function compute Canonicalized Headers ( $ headers ) { $ canonicalized Headers = array ( ) ; $ normalized Headers = array ( ) ; $ valid Prefix = Resources : : X _MS _HEADER _PREFIX ; if ( is _null ( $ normalized Headers ) ) { return $ canonicalized Headers ; } foreach ( $ headers as $ header = > $ value ) { 
protected function compute Canonicalized Resource For Table ( $ url , $ query Params ) { $ query Params = array _change _key _case ( $ query Params ) ; 
protected function compute Canonicalized Resource ( $ url , $ query Params ) { $ query Params = array _change _key _case ( $ query Params ) ; 
public function sign Request ( Request $ request ) { $ request Headers = Http Formatter : : format Headers ( $ request - > get Headers ( ) ) ; $ signed Key = $ this - > get Authorization Header ( $ request Headers , $ request - > get Uri ( ) , \ Guzzle Http \ Psr 7 \ parse _query ( $ request - > get Uri ( ) - > get Query ( ) ) , $ request - > get Method ( ) ) ; return $ request - > with Header ( Resources : : AUTHENTICATION , $ signed Key ) ; } 
public function to Xml ( Xml Serializer $ serializer ) { $ properties = array ( Xml Serializer : : DEFAULT _TAG = > Resources : : XTAG _SIGNED _IDENTIFIER , Xml Serializer : : ROOT _NAME = > Resources : : XTAG _SIGNED _IDENTIFIERS ) ; return $ serializer - > serialize ( $ this - > to Array ( ) , $ properties ) ; } 
public function from Xml Array ( array $ parsed = null ) { $ this - > set Signed Identifiers ( array ( ) ) ; 
public function add Signed Identifier ( $ id , \ Date Time $ start , \ Date Time $ expiry , $ permissions ) { Validate : : can Cast As String ( $ id , 'id ' ) ; if ( $ start ! = null ) { Validate : : is Date ( $ start ) ; } Validate : : is Date ( $ expiry ) ; Validate : : can Cast As String ( $ permissions , 'permissions ' ) ; $ access Policy = static : : create Access Policy ( ) ; $ access Policy - > set Start ( $ start ) ; $ access Policy - > set Expiry ( $ expiry ) ; $ access Policy - > set Permission ( $ permissions ) ; $ signed Identifier = new Signed Identifier ( ) ; $ signed Identifier - > set Id ( $ id ) ; $ signed Identifier - > set Access Policy ( $ access Policy ) ; 
public function remove Signed Identifier ( $ id ) { Validate : : can Cast As String ( $ id , 'id ' ) ; 
public function set Operations ( array $ operations ) { $ this - > _operations = array ( ) ; foreach ( $ operations as $ operation ) { $ this - > add Operation ( $ operation ) ; } } 
public function add Operation ( $ operation ) { Validate : : is True ( $ operation instanceof Batch Operation , Resources : : INVALID _BO _TYPE _MSG ) ; $ this - > _operations [ ] = $ operation ; } 
public function add Insert Entity ( $ table , Entity $ entity ) { Validate : : can Cast As String ( $ table , 'table ' ) ; Validate : : not Null Or Empty ( $ entity , 'entity ' ) ; $ operation = new Batch Operation ( ) ; $ type = Batch Operation Type : : INSERT _ENTITY _OPERATION ; $ operation - > set Type ( $ type ) ; $ operation - > add Parameter ( Batch Operation Parameter Name : : BP _TABLE , $ table ) ; $ operation - > add Parameter ( Batch Operation Parameter Name : : BP _ENTITY , $ entity ) ; $ this - > add Operation ( $ operation ) ; } 
public function add Delete Entity ( $ table , $ partition Key , $ row Key , $ etag = null ) { Validate : : can Cast As String ( $ table , 'table ' ) ; Validate : : is True ( ! is _null ( $ partition Key ) , Resources : : NULL _TABLE _KEY _MSG ) ; Validate : : is True ( ! is _null ( $ row Key ) , Resources : : NULL _TABLE _KEY _MSG ) ; $ operation = new Batch Operation ( ) ; $ type = Batch Operation Type : : DELETE _ENTITY _OPERATION ; $ operation - > set Type ( $ type ) ; $ operation - > add Parameter ( Batch Operation Parameter Name : : BP _TABLE , $ table ) ; $ operation - > add Parameter ( Batch Operation Parameter Name : : BP _ROW _KEY , $ row Key ) ; $ operation - > add Parameter ( Batch Operation Parameter Name : : BP _ETAG , $ etag ) ; $ operation - > add Parameter ( Batch Operation Parameter Name : : BP _PARTITION _KEY , $ partition Key ) ; $ this - > add Operation ( $ operation ) ; } 
public static function create ( array $ headers ) { $ result = new Copy File Result ( ) ; $ headers = array _change _key _case ( $ headers ) ; $ date = $ headers [ Resources : : LAST _MODIFIED ] ; $ date = Utilities : : rfc 1 1 2 3To Date Time ( $ date ) ; $ result - > set Copy Status ( $ headers [ Resources : : X _MS _COPY _STATUS ] ) ; $ result - > set Copy ID ( $ headers [ Resources : : X _MS _COPY _ID ] ) ; $ result - > set ETag ( $ headers [ Resources : : ETAG ] ) ; $ result - > set Last Modified ( $ date ) ; return $ result ; } 
public static function create From List Messages ( array $ parsed Response ) { $ time Next Visible = $ parsed Response [ 'Time Next Visible ' ] ; $ msg = self : : create From Peek Messages ( $ parsed Response ) ; $ date = Utilities : : rfc 1 1 2 3To Date Time ( $ time Next Visible ) ; $ msg - > set Time Next Visible ( $ date ) ; $ msg - > set Pop Receipt ( $ parsed Response [ 'Pop Receipt ' ] ) ; return $ msg ; } 
public static function create From Peek Messages ( array $ parsed Response ) { $ msg = new Queue Message ( ) ; $ expiration Date = $ parsed Response [ 'Expiration Time ' ] ; $ insertion Date = $ parsed Response [ 'Insertion Time ' ] ; $ msg - > set Dequeue Count ( intval ( $ parsed Response [ 'Dequeue Count ' ] ) ) ; $ date = Utilities : : rfc 1 1 2 3To Date Time ( $ expiration Date ) ; $ msg - > set Expiration Date ( $ date ) ; $ date = Utilities : : rfc 1 1 2 3To Date Time ( $ insertion Date ) ; $ msg - > set Insertion Date ( $ date ) ; $ msg - > set Message Id ( $ parsed Response [ 'Message Id ' ] ) ; $ msg - > set Message Text ( $ parsed Response [ 'Message Text ' ] ) ; return $ msg ; } 
public static function create From Create Message ( array $ parsed Response ) { $ msg = new Queue Message ( ) ; $ expiration Date = $ parsed Response [ 'Expiration Time ' ] ; $ insertion Date = $ parsed Response [ 'Insertion Time ' ] ; $ time Next Visible = $ parsed Response [ 'Time Next Visible ' ] ; $ date = Utilities : : rfc 1 1 2 3To Date Time ( $ expiration Date ) ; $ msg - > set Expiration Date ( $ date ) ; $ date = Utilities : : rfc 1 1 2 3To Date Time ( $ insertion Date ) ; $ msg - > set Insertion Date ( $ date ) ; $ date = Utilities : : rfc 1 1 2 3To Date Time ( $ time Next Visible ) ; $ msg - > set Time Next Visible ( $ date ) ; $ msg - > set Message Id ( $ parsed Response [ 'Message Id ' ] ) ; $ msg - > set Pop Receipt ( $ parsed Response [ 'Pop Receipt ' ] ) ; return $ msg ; } 
protected static function init ( ) { self : : $ use Development Storage Setting = self : : setting ( Resources : : USE _DEVELOPMENT _STORAGE _NAME , 'true ' ) ; self : : $ development Storage Proxy Uri Setting = self : : setting With Func ( Resources : : DEVELOPMENT _STORAGE _PROXY _URI _NAME , Validate : : get Is Valid Uri ( ) ) ; self : : $ default Endpoints Protocol Setting = self : : setting ( Resources : : DEFAULT _ENDPOINTS _PROTOCOL _NAME , 'http ' , 'https ' ) ; self : : $ account Name Setting = self : : setting ( Resources : : ACCOUNT _NAME _NAME ) ; self : : $ account Key Setting = self : : setting With Func ( Resources : : ACCOUNT _KEY _NAME , 
private static function get Development Storage Account ( $ proxy Uri ) { if ( is _null ( $ proxy Uri ) ) { return self : : development Storage Account ( ) ; } $ scheme = parse _url ( $ proxy Uri , PHP _URL _SCHEME ) ; $ host = parse _url ( $ proxy Uri , PHP _URL _HOST ) ; $ prefix = $ scheme . " : / / " . $ host ; return new Storage Service Settings ( Resources : : DEV _STORE _NAME , Resources : : DEV _STORE _KEY , $ prefix . ' : 1 0 0 0 0 /devstoreaccount 1 / ' , $ prefix . ' : 1 0 0 0 1 /devstoreaccount 1 / ' , $ prefix . ' : 1 0 0 0 2 /devstoreaccount 1 / ' , null ) ; } 
public static function development Storage Account ( ) { if ( is _null ( self : : $ dev Store Account ) ) { self : : $ dev Store Account = self : : get Development Storage Account ( Resources : : DEV _STORE _URI ) ; } return self : : $ dev Store Account ; } 
private static function get Service Endpoint ( $ scheme , $ account Name , $ dns Prefix , $ dns Suffix = null , $ is Secondary = false ) { if ( $ is Secondary ) { $ account Name . = Resources : : SECONDARY _STRING ; } if ( $ dns Suffix = = = null ) { $ dns Suffix = Resources : : DEFAULT _ENDPOINT _SUFFIX ; } return sprintf ( Resources : : SERVICE _URI _FORMAT , $ scheme , $ account Name , $ dns Prefix . $ dns Suffix ) ; } 
private static function create Storage Service Settings ( array $ settings , $ blob Endpoint Uri = null , $ queue Endpoint Uri = null , $ table Endpoint Uri = null , $ file Endpoint Uri = null , $ blob Secondary Endpoint Uri = null , $ queue Secondary Endpoint Uri = null , $ table Secondary Endpoint Uri = null , $ file Secondary Endpoint Uri = null ) { $ blob Endpoint Uri = Utilities : : try Get Value Insensitive ( Resources : : BLOB _ENDPOINT _NAME , $ settings , $ blob Endpoint Uri ) ; $ queue Endpoint Uri = Utilities : : try Get Value Insensitive ( Resources : : QUEUE _ENDPOINT _NAME , $ settings , $ queue Endpoint Uri ) ; $ table Endpoint Uri = Utilities : : try Get Value Insensitive ( Resources : : TABLE _ENDPOINT _NAME , $ settings , $ table Endpoint Uri ) ; $ file Endpoint Uri = Utilities : : try Get Value Insensitive ( Resources : : FILE _ENDPOINT _NAME , $ settings , $ file Endpoint Uri ) ; $ account Name = Utilities : : try Get Value Insensitive ( Resources : : ACCOUNT _NAME _NAME , $ settings ) ; $ account Key = Utilities : : try Get Value Insensitive ( Resources : : ACCOUNT _KEY _NAME , $ settings ) ; $ sas Token = Utilities : : try Get Value Insensitive ( Resources : : SAS _TOKEN _NAME , $ settings ) ; return new Storage Service Settings ( $ account Name , $ account Key , $ blob Endpoint Uri , $ queue Endpoint Uri , $ table Endpoint Uri , $ file Endpoint Uri , $ blob Secondary Endpoint Uri , $ queue Secondary Endpoint Uri , $ table Secondary Endpoint Uri , $ file Secondary Endpoint Uri , $ sas Token ) ; } 
public static function create From Connection String ( $ connection String ) { $ tokenized Settings = self : : parse And Validate Keys ( $ connection String ) ; 
public static function create From Connection String For Token Credential ( $ connection String ) { 
public function encode Mime Multipart ( array $ body Part Contents ) { $ count = count ( $ body Part Contents ) ; $ mime Type = Resources : : MULTIPART _MIXED _TYPE ; $ batch Guid = Utilities : : get Guid ( ) ; $ batch Id = sprintf ( 'batch _ %s ' , $ batch Guid ) ; $ content Type 1 = array ( 'content _type ' = > " $mime Type " ) ; $ change Set Guid = Utilities : : get Guid ( ) ; $ change Set Id = sprintf ( 'changeset _ %s ' , $ change Set Guid ) ; $ content Type 2 = array ( 'content _type ' = > " $mime Type ; boundary = $change Set Id " ) ; $ options = array ( 'encoding ' = > 'binary ' , 'content _type ' = > Resources : : HTTP _TYPE ) ; $ eof = " \r \n " ; $ result = array ( ) ; $ result [ 'body ' ] = Resources : : EMPTY _STRING ; $ result [ 'headers ' ] = array ( ) ; $ batch Body = & $ result [ 'body ' ] ; $ batch Headers = & $ result [ 'headers ' ] ; $ batch Headers [ 'Content -Type ' ] = $ mime Type . " ; $eof boundary = \ " $batch Id \ " " ; $ batch Body . = " - - " . $ batch Id . $ eof ; $ batch Body . = "Content -Type : $mime Type ; boundary = \ " $change Set Id \ " " . $ eof ; $ batch Body . = $ eof ; for ( $ i = 0 ; $ i < count ( $ body Part Contents ) ; $ i + + ) { $ batch Body . = " - - " . $ change Set Id . $ eof ; $ batch Body . = "Content -Transfer -Encoding : binary " . $ eof ; $ batch Body . = "Content -Type : " . Resources : : HTTP _TYPE . $ eof ; $ batch Body . = $ eof . $ body Part Contents [ $ i ] . $ eof ; } $ batch Body . = " - - " . $ change Set Id . " - - " . $ eof ; $ batch Body . = $ eof ; $ batch Body . = " - - " . $ batch Id . " - - " . $ eof ; return $ result ; } 
public function decode Mime Multipart ( $ mime Body ) { 
public static function create ( array $ parsed Response , $ location = ' ' ) { $ result = new List Shares Result ( ) ; $ service Endpoint = Utilities : : try Get Keys Chain Value ( $ parsed Response , Resources : : XTAG _ATTRIBUTES , Resources : : XTAG _SERVICE _ENDPOINT ) ; $ result - > set Account Name ( Utilities : : try Parse Account Name From Url ( $ service Endpoint ) ) ; $ result - > set Prefix ( Utilities : : try Get Value ( $ parsed Response , Resources : : QP _PREFIX ) ) ; $ result - > set Marker ( Utilities : : try Get Value ( $ parsed Response , Resources : : QP _MARKER ) ) ; $ next Marker = Utilities : : try Get Value ( $ parsed Response , Resources : : QP _NEXT _MARKER ) ; if ( $ next Marker ! = null ) { $ result - > set Continuation Token ( new Marker Continuation Token ( $ next Marker , $ location ) ) ; } $ result - > set Max Results ( Utilities : : try Get Value ( $ parsed Response , Resources : : QP _MAX _RESULTS ) ) ; $ shares = array ( ) ; $ share Arrays = array ( ) ; if ( ! empty ( $ parsed Response [ Resources : : QP _SHARES ] ) ) { $ array = $ parsed Response [ Resources : : QP _SHARES ] [ Resources : : QP _SHARE ] ; $ share Arrays = Utilities : : get Array ( $ array ) ; } foreach ( $ share Arrays as $ share Array ) { $ shares [ ] = Share : : create ( $ share Array ) ; } $ result - > set Shares ( $ shares ) ; return $ result ; } 
protected function set Shares ( array $ shares ) { $ this - > shares = array ( ) ; foreach ( $ shares as $ share ) { $ this - > shares [ ] = clone $ share ; } } 
protected function on Fulfilled ( Request Interface $ request , array $ options ) { return function ( Response Interface $ response ) use ( $ request , $ options ) { $ is Secondary = Utilities : : request Sent To Secondary ( $ request , $ options ) ; if ( ! isset ( $ options [ 'retries ' ] ) ) { $ options [ 'retries ' ] = 0 ; } if ( call _user _func ( $ this - > decider , $ options [ 'retries ' ] , $ request , $ response , null , $ is Secondary ) ) { return $ this - > retry ( $ request , $ options , $ response ) ; } 
protected function on Rejected ( Request Interface $ request , array $ options ) { return function ( $ reason ) use ( $ request , $ options ) { $ is Secondary = Utilities : : request Sent To Secondary ( $ request , $ options ) ; if ( ! isset ( $ options [ 'retries ' ] ) ) { $ options [ 'retries ' ] = 0 ; } if ( call _user _func ( $ this - > decider , $ options [ 'retries ' ] , $ request , null , $ reason , $ is Secondary ) ) { return $ this - > retry ( $ request , $ options ) ; } return new Rejected Promise ( $ reason ) ; } ; } 
private function retry ( Request Interface $ request , array $ options , Response Interface $ response = null ) { $ options [ 'delay ' ] = call _user _func ( $ this - > interval Calculator , + + $ options [ 'retries ' ] ) ; 
public static function apply And ( Filter $ left , Filter $ right ) { $ filter = new Binary Filter ( $ left , 'and ' , $ right ) ; return $ filter ; } 
public static function apply Or ( Filter $ left , Filter $ right ) { $ filter = new Binary Filter ( $ left , 'or ' , $ right ) ; return $ filter ; } 
public static function apply Eq ( Filter $ left , Filter $ right ) { $ filter = new Binary Filter ( $ left , 'eq ' , $ right ) ; return $ filter ; } 
public static function apply Ne ( Filter $ left , Filter $ right ) { $ filter = new Binary Filter ( $ left , 'ne ' , $ right ) ; return $ filter ; } 
public static function apply Ge ( Filter $ left , Filter $ right ) { $ filter = new Binary Filter ( $ left , 'ge ' , $ right ) ; return $ filter ; } 
public static function apply Gt ( Filter $ left , Filter $ right ) { $ filter = new Binary Filter ( $ left , 'gt ' , $ right ) ; return $ filter ; } 
public static function apply Lt ( Filter $ left , Filter $ right ) { $ filter = new Binary Filter ( $ left , 'lt ' , $ right ) ; return $ filter ; } 
public static function apply Le ( Filter $ left , Filter $ right ) { $ filter = new Binary Filter ( $ left , 'le ' , $ right ) ; return $ filter ; } 
public function sign Request ( Request $ request ) { $ bearer Token = "Bearer " . $ this - > token Ref ; return $ request - > with Header ( Resources : : AUTHENTICATION , $ bearer Token ) ; } 
public static function create ( array $ parsed ) { $ result = new Get Share Stats Result ( ) ; $ result - > set Share Usage ( \ intval ( Utilities : : try Get Value Insensitive ( Resources : : XTAG _SHARE _USAGE , $ parsed ) ) ) ; return $ result ; } 
public function set Location ( $ location ) { Validate : : can Cast As String ( $ location , 'location ' ) ; Validate : : is True ( $ location = = Location Mode : : PRIMARY _ONLY | | $ location = = Location Mode : : SECONDARY _ONLY | | $ location = = ' ' , sprintf ( Resources : : INVALID _VALUE _MSG , 'location ' , Location Mode : : PRIMARY _ONLY . ' or ' . Location Mode : : SECONDARY _ONLY ) ) ; $ this - > location = $ location ; } 
public static function object Serialize ( $ target Object , $ root Name ) { Validate : : not Null ( $ target Object , 'target Object ' ) ; Validate : : can Cast As String ( $ root Name , 'root Name ' ) ; $ contianer = new \ std Class ( ) ; $ contianer - > $ root Name = $ target Object ; return json _encode ( $ contianer ) ; } 
public function unserialize ( $ serialized ) { Validate : : can Cast As String ( $ serialized , 'serialized ' ) ; $ json = json _decode ( $ serialized ) ; if ( $ json & & ! is _array ( $ json ) ) { return get _object _vars ( $ json ) ; } else { return $ json ; } } 
public static function create ( $ parsed Response ) { $ result = new Peek Messages Result ( ) ; $ queue Messages = array ( ) ; if ( ! empty ( $ parsed Response ) ) { $ raw Messages = Utilities : : get Array ( $ parsed Response [ Resources : : QP _QUEUE _MESSAGE ] ) ; foreach ( $ raw Messages as $ value ) { $ message = Queue Message : : create From Peek Messages ( $ value ) ; $ queue Messages [ ] = $ message ; } } $ result - > set Queue Messages ( $ queue Messages ) ; return $ result ; } 
public static function create ( $ body , IOData Reader Writer $ serializer ) { $ result = new Get Entity Result ( ) ; $ result - > set Entity ( $ serializer - > parse Entity ( $ body ) ) ; return $ result ; } 
public static function create Table Service ( $ connection String , array $ options = [ ] ) { $ settings = Storage Service Settings : : create From Connection String ( $ connection String ) ; $ odata Serializer = new Json OData Reader Writer ( ) ; $ mime Serializer = new Mime Reader Writer ( ) ; $ primary Uri = Utilities : : try Add Url Scheme ( $ settings - > get Table Endpoint Uri ( ) ) ; $ secondary Uri = Utilities : : try Add Url Scheme ( $ settings - > get Table Secondary Endpoint Uri ( ) ) ; $ table Wrapper = new Table Rest Proxy ( $ primary Uri , $ secondary Uri , $ odata Serializer , $ mime Serializer , $ options ) ; 
private function create Operations Contexts ( array $ operations ) { $ contexts = array ( ) ; foreach ( $ operations as $ operation ) { $ context = null ; $ type = $ operation - > get Type ( ) ; switch ( $ type ) { case Batch Operation Type : : INSERT _ENTITY _OPERATION : case Batch Operation Type : : UPDATE _ENTITY _OPERATION : case Batch Operation Type : : MERGE _ENTITY _OPERATION : case Batch Operation Type : : INSERT _REPLACE _ENTITY _OPERATION : case Batch Operation Type : : INSERT _MERGE _ENTITY _OPERATION : $ table = $ operation - > get Parameter ( Batch Operation Parameter Name : : BP _TABLE ) ; $ entity = $ operation - > get Parameter ( Batch Operation Parameter Name : : BP _ENTITY ) ; $ context = $ this - > get Operation Context ( $ table , $ entity , $ type ) ; break ; case Batch Operation Type : : DELETE _ENTITY _OPERATION : $ table = $ operation - > get Parameter ( Batch Operation Parameter Name : : BP _TABLE ) ; $ partition Key = $ operation - > get Parameter ( Batch Operation Parameter Name : : BP _PARTITION _KEY ) ; $ row Key = $ operation - > get Parameter ( Batch Operation Parameter Name : : BP _ROW _KEY ) ; $ etag = $ operation - > get Parameter ( Batch Operation Parameter Name : : BP _ETAG ) ; $ options = new Delete Entity Options ( ) ; $ options - > set ETag ( $ etag ) ; $ context = $ this - > construct Delete Entity Context ( $ table , $ partition Key , $ row Key , $ options ) ; break ; default : throw new \ Invalid Argument Exception ( ) ; } $ contexts [ ] = $ context ; } return $ contexts ; } 
private function get Operation Context ( $ table , Entity $ entity , $ type ) { switch ( $ type ) { case Batch Operation Type : : INSERT _ENTITY _OPERATION : return $ this - > construct Insert Entity Context ( $ table , $ entity , null ) ; case Batch Operation Type : : UPDATE _ENTITY _OPERATION : return $ this - > construct Put Or Merge Entity Context ( $ table , $ entity , Resources : : HTTP _PUT , true , null ) ; case Batch Operation Type : : MERGE _ENTITY _OPERATION : return $ this - > construct Put Or Merge Entity Context ( $ table , $ entity , Resources : : HTTP _MERGE , true , null ) ; case Batch Operation Type : : INSERT _REPLACE _ENTITY _OPERATION : return $ this - > construct Put Or Merge Entity Context ( $ table , $ entity , Resources : : HTTP _PUT , false , null ) ; case Batch Operation Type : : INSERT _MERGE _ENTITY _OPERATION : return $ this - > construct Put Or Merge Entity Context ( $ table , $ entity , Resources : : HTTP _MERGE , false , null ) ; default : throw new \ Invalid Argument Exception ( ) ; } } 
private function create Batch Request Body ( array $ operations , array $ contexts ) { $ mime Body Parts = array ( ) ; $ content Id = 1 ; $ count = count ( $ operations ) ; Validate : : is True ( count ( $ operations ) = = count ( $ contexts ) , Resources : : INVALID _OC _COUNT _MSG ) ; for ( $ i = 0 ; $ i < $ count ; $ i + + ) { $ operation = $ operations [ $ i ] ; $ context = $ contexts [ $ i ] ; $ type = $ operation - > get Type ( ) ; switch ( $ type ) { case Batch Operation Type : : INSERT _ENTITY _OPERATION : case Batch Operation Type : : UPDATE _ENTITY _OPERATION : case Batch Operation Type : : MERGE _ENTITY _OPERATION : case Batch Operation Type : : INSERT _REPLACE _ENTITY _OPERATION : case Batch Operation Type : : INSERT _MERGE _ENTITY _OPERATION : $ content Type = $ context - > get Header ( Resources : : CONTENT _TYPE ) ; $ body = $ context - > get Body ( ) ; $ content Type . = ' ;type =entry ' ; $ context - > add Optional Header ( Resources : : CONTENT _TYPE , $ content Type ) ; 
private function construct Delete Entity Context ( $ table , $ partition Key , $ row Key , Delete Entity Options $ options = null ) { Validate : : can Cast As String ( $ table , 'table ' ) ; Validate : : not Null Or Empty ( $ table , 'table ' ) ; Validate : : is True ( ! is _null ( $ partition Key ) , Resources : : NULL _TABLE _KEY _MSG ) ; Validate : : is True ( ! is _null ( $ row Key ) , Resources : : NULL _TABLE _KEY _MSG ) ; $ method = Resources : : HTTP _DELETE ; $ headers = array ( ) ; $ query Params = array ( ) ; $ status Code = Resources : : STATUS _NO _CONTENT ; $ path = $ this - > get Entity Path ( $ table , $ partition Key , $ row Key ) ; if ( is _null ( $ options ) ) { $ options = new Delete Entity Options ( ) ; } $ etag Obj = $ options - > get ETag ( ) ; $ ETag = ! is _null ( $ etag Obj ) ; $ this - > add Optional Header ( $ headers , Resources : : IF _MATCH , $ ETag ? $ etag Obj : Resources : : ASTERISK ) ; $ this - > add Optional Header ( $ headers , Resources : : ACCEPT _HEADER , Resources : : JSON _CONTENT _TYPE ) ; $ options - > set Location Mode ( Location Mode : : PRIMARY _ONLY ) ; $ context = new Http Call Context ( ) ; $ context - > set Headers ( $ headers ) ; $ context - > set Method ( $ method ) ; $ context - > set Path ( $ path ) ; $ context - > set Query Parameters ( $ query Params ) ; $ context - > add Status Code ( $ status Code ) ; $ context - > set Body ( ' ' ) ; $ context - > set Service Options ( $ options ) ; return $ context ; } 
private function construct Put Or Merge Entity Context ( $ table , Entity $ entity , $ verb , $ use ETag , Table Service Options $ options = null ) { Validate : : can Cast As String ( $ table , 'table ' ) ; Validate : : not Null Or Empty ( $ table , 'table ' ) ; Validate : : not Null Or Empty ( $ entity , 'entity ' ) ; Validate : : is True ( $ entity - > is Valid ( $ msg ) , $ msg ) ; $ method = $ verb ; $ headers = array ( ) ; $ query Params = array ( ) ; $ status Code = Resources : : STATUS _NO _CONTENT ; $ partition Key = $ entity - > get Partition Key ( ) ; $ row Key = $ entity - > get Row Key ( ) ; $ path = $ this - > get Entity Path ( $ table , $ partition Key , $ row Key ) ; $ body = $ this - > odata Serializer - > get Entity ( $ entity ) ; if ( is _null ( $ options ) ) { $ options = new Table Service Options ( ) ; } if ( $ use ETag ) { $ etag = $ entity - > get ETag ( ) ; $ if Match Value = is _null ( $ etag ) ? Resources : : ASTERISK : $ etag ; $ this - > add Optional Header ( $ headers , Resources : : IF _MATCH , $ if Match Value ) ; } $ this - > add Optional Header ( $ headers , Resources : : CONTENT _TYPE , Resources : : JSON _CONTENT _TYPE ) ; $ this - > add Optional Header ( $ headers , Resources : : ACCEPT _HEADER , Resources : : JSON _FULL _METADATA _CONTENT _TYPE ) ; $ options - > set Location Mode ( Location Mode : : PRIMARY _ONLY ) ; $ context = new Http Call Context ( ) ; $ context - > set Body ( $ body ) ; $ context - > set Headers ( $ headers ) ; $ context - > set Method ( $ method ) ; $ context - > set Path ( $ path ) ; $ context - > set Query Parameters ( $ query Params ) ; $ context - > add Status Code ( $ status Code ) ; $ context - > set Service Options ( $ options ) ; return $ context ; } 
private function construct Insert Entity Context ( $ table , Entity $ entity , Table Service Create Options $ options = null ) { Validate : : can Cast As String ( $ table , 'table ' ) ; Validate : : not Null Or Empty ( $ table , 'table ' ) ; Validate : : not Null Or Empty ( $ entity , 'entity ' ) ; Validate : : is True ( $ entity - > is Valid ( $ msg ) , $ msg ) ; $ method = Resources : : HTTP _POST ; $ context = new Http Call Context ( ) ; $ headers = array ( ) ; $ query Params = array ( ) ; $ status Code = Resources : : STATUS _CREATED ; $ path = $ table ; $ body = $ this - > odata Serializer - > get Entity ( $ entity ) ; if ( is _null ( $ options ) ) { $ options = new Table Service Create Options ( ) ; } $ this - > add Optional Header ( $ headers , Resources : : CONTENT _TYPE , Resources : : JSON _CONTENT _TYPE ) ; $ this - > add Optional Header ( $ headers , Resources : : ACCEPT _HEADER , $ options - > get Accept ( ) ) ; $ this - > add Optional Header ( $ headers , Resources : : PREFER , $ options - > get Does Return Content ( ) ? Resources : : RETURN _CONTENT : null ) ; $ options - > set Location Mode ( Location Mode : : PRIMARY _ONLY ) ; $ context - > set Body ( $ body ) ; $ context - > set Headers ( $ headers ) ; $ context - > set Method ( $ method ) ; $ context - > set Path ( $ path ) ; $ context - > set Query Parameters ( $ query Params ) ; $ context - > add Status Code ( $ status Code ) ; $ context - > set Service Options ( $ options ) ; return $ context ; } 
private function get Entity Path ( $ table , $ partition Key , $ row Key ) { $ encoded PK = $ this - > encode OData Uri Value ( $ partition Key ) ; $ encoded RK = $ this - > encode OData Uri Value ( $ row Key ) ; return " $table (Partition Key = ' $encoded PK ' ,Row Key = ' $encoded RK ' ) " ; } 
private function put Or Merge Entity Async Impl ( $ table , Entity $ entity , $ verb , $ use ETag , Table Service Options $ options = null ) { $ context = $ this - > construct Put Or Merge Entity Context ( $ table , $ entity , $ verb , $ use ETag , $ options ) ; return $ this - > send Context Async ( $ context ) - > then ( function ( $ response ) { return Update Entity Result : : create ( Http Formatter : : format Headers ( $ response - > get Headers ( ) ) ) ; } , null ) ; } 
private function build Filter Expression ( Filter $ filter ) { $ e = Resources : : EMPTY _STRING ; $ this - > build Filter Expression Rec ( $ filter , $ e ) ; return $ e ; } 
private function build Filter Expression Rec ( Filter $ filter , & $ e ) { if ( is _null ( $ filter ) ) { return ; } if ( $ filter instanceof Property Name Filter ) { $ e . = $ filter - > get Property Name ( ) ; } elseif ( $ filter instanceof Constant Filter ) { $ value = $ filter - > get Value ( ) ; 
private function add Optional Query ( array $ query Param , Query $ query ) { if ( ! is _null ( $ query ) ) { $ selected Fields = $ query - > get Select Fields ( ) ; if ( ! empty ( $ selected Fields ) ) { $ final = $ this - > encode OData Uri Values ( $ selected Fields ) ; $ this - > add Optional Query Param ( $ query Param , Resources : : QP _SELECT , implode ( ' , ' , $ final ) ) ; } if ( ! is _null ( $ query - > get Top ( ) ) ) { $ final = strval ( $ this - > encode OData Uri Value ( $ query - > get Top ( ) ) ) ; $ this - > add Optional Query Param ( $ query Param , Resources : : QP _TOP , $ final ) ; } if ( ! is _null ( $ query - > get Filter ( ) ) ) { $ final = $ this - > build Filter Expression ( $ query - > get Filter ( ) ) ; $ this - > add Optional Query Param ( $ query Param , Resources : : QP _FILTER , $ final ) ; } } return $ query Param ; } 
private function encode OData Uri Values ( array $ values ) { $ list = array ( ) ; foreach ( $ values as $ value ) { $ list [ ] = $ this - > encode OData Uri Value ( $ value ) ; } return $ list ; } 
public function query Tables Async ( $ options = null ) { $ method = Resources : : HTTP _GET ; $ headers = array ( ) ; $ post Params = array ( ) ; $ query Params = array ( ) ; $ path = 'Tables ' ; if ( is _null ( $ options ) ) { $ options = new Query Tables Options ( ) ; } elseif ( is _string ( $ options ) ) { $ prefix = $ options ; $ options = new Query Tables Options ( ) ; $ options - > set Prefix ( $ prefix ) ; } elseif ( $ options instanceof Filter ) { $ filter = $ options ; $ options = new Query Tables Options ( ) ; $ options - > set Filter ( $ filter ) ; } $ query = $ options - > get Query ( ) ; $ next = $ options - > get Next Table Name ( ) ; $ prefix = $ options - > get Prefix ( ) ; if ( ! empty ( $ prefix ) ) { 
public function create Table ( $ table , Table Service Create Options $ options = null ) { return $ this - > create Table Async ( $ table , $ options ) - > wait ( ) ; } 
public function create Table Async ( $ table , Table Service Create Options $ options = null ) { Validate : : can Cast As String ( $ table , 'table ' ) ; Validate : : not Null Or Empty ( $ table , 'table ' ) ; $ method = Resources : : HTTP _POST ; $ headers = array ( ) ; $ post Params = array ( ) ; $ query Params = array ( ) ; $ path = 'Tables ' ; $ body = $ this - > odata Serializer - > get Table ( $ table ) ; if ( is _null ( $ options ) ) { $ options = new Table Service Create Options ( ) ; } $ this - > add Optional Header ( $ headers , Resources : : CONTENT _TYPE , Resources : : JSON _CONTENT _TYPE ) ; $ this - > add Optional Header ( $ headers , Resources : : ACCEPT _HEADER , $ options - > get Accept ( ) ) ; $ this - > add Optional Header ( $ headers , Resources : : PREFER , $ options - > get Does Return Content ( ) ? Resources : : RETURN _CONTENT : null ) ; $ options - > set Location Mode ( Location Mode : : PRIMARY _ONLY ) ; return $ this - > send Async ( $ method , $ headers , $ query Params , $ post Params , $ path , Resources : : STATUS _CREATED , $ body , $ options ) ; } 
public function get Table ( $ table , Get Table Options $ options = null ) { return $ this - > get Table Async ( $ table , $ options ) - > wait ( ) ; } 
public function get Table Async ( $ table , Get Table Options $ options = null ) { Validate : : can Cast As String ( $ table , 'table ' ) ; Validate : : not Null Or Empty ( $ table , 'table ' ) ; $ method = Resources : : HTTP _GET ; $ headers = array ( ) ; $ post Params = array ( ) ; $ query Params = array ( ) ; $ path = "Tables ( ' $table ' ) " ; if ( is _null ( $ options ) ) { $ options = new Get Table Options ( ) ; } $ this - > add Optional Header ( $ headers , Resources : : CONTENT _TYPE , Resources : : JSON _CONTENT _TYPE ) ; $ this - > add Optional Header ( $ headers , Resources : : ACCEPT _HEADER , $ options - > get Accept ( ) ) ; $ odata Serializer = $ this - > odata Serializer ; return $ this - > send Async ( $ method , $ headers , $ query Params , $ post Params , $ path , Resources : : STATUS _OK , Resources : : EMPTY _STRING , $ options ) - > then ( function ( $ response ) use ( $ odata Serializer ) { return Get Table Result : : create ( $ response - > get Body ( ) , $ odata Serializer ) ; } , null ) ; } 
public function delete Table ( $ table , Table Service Options $ options = null ) { $ this - > delete Table Async ( $ table , $ options ) - > wait ( ) ; } 
public function delete Table Async ( $ table , Table Service Options $ options = null ) { Validate : : can Cast As String ( $ table , 'table ' ) ; Validate : : not Null Or Empty ( $ table , 'table ' ) ; $ method = Resources : : HTTP _DELETE ; $ headers = array ( ) ; $ post Params = array ( ) ; $ query Params = array ( ) ; $ path = "Tables ( ' $table ' ) " ; if ( is _null ( $ options ) ) { $ options = new Table Service Options ( ) ; } return $ this - > send Async ( $ method , $ headers , $ query Params , $ post Params , $ path , Resources : : STATUS _NO _CONTENT , Resources : : EMPTY _STRING , $ options ) ; } 
public function query Entities Async ( $ table , $ options = null ) { Validate : : can Cast As String ( $ table , 'table ' ) ; Validate : : not Null Or Empty ( $ table , 'table ' ) ; $ method = Resources : : HTTP _GET ; $ headers = array ( ) ; $ post Params = array ( ) ; $ query Params = array ( ) ; $ path = $ table ; if ( is _null ( $ options ) ) { $ options = new Query Entities Options ( ) ; } elseif ( is _string ( $ options ) ) { $ query String = $ options ; $ options = new Query Entities Options ( ) ; $ options - > set Filter ( Filter : : apply Query String ( $ query String ) ) ; } elseif ( $ options instanceof Filter ) { $ filter = $ options ; $ options = new Query Entities Options ( ) ; $ options - > set Filter ( $ filter ) ; } $ query Params = $ this - > add Optional Query ( $ query Params , $ options - > get Query ( ) ) ; $ this - > add Optional Query Param ( $ query Params , Resources : : QP _NEXT _PK , $ options - > get Next Partition Key ( ) ) ; $ this - > add Optional Query Param ( $ query Params , Resources : : QP _NEXT _RK , $ options - > get Next Row Key ( ) ) ; $ this - > add Optional Header ( $ headers , Resources : : CONTENT _TYPE , Resources : : JSON _CONTENT _TYPE ) ; $ this - > add Optional Header ( $ headers , Resources : : ACCEPT _HEADER , $ options - > get Accept ( ) ) ; if ( ! is _null ( $ options - > get Query ( ) ) ) { $ ds Header = Resources : : DATA _SERVICE _VERSION ; $ maxds Value = Resources : : MAX _DATA _SERVICE _VERSION _VALUE ; $ fields = $ options - > get Query ( ) - > get Select Fields ( ) ; $ has Select = ! empty ( $ fields ) ; if ( $ has Select ) { $ this - > add Optional Header ( $ headers , $ ds Header , $ maxds Value ) ; } } $ odata Serializer = $ this - > odata Serializer ; return $ this - > send Async ( $ method , $ headers , $ query Params , $ post Params , $ path , Resources : : STATUS _OK , Resources : : EMPTY _STRING , $ options ) - > then ( function ( $ response ) use ( $ odata Serializer ) { $ entities = $ odata Serializer - > parse Entities ( $ response - > get Body ( ) ) ; return Query Entities Result : : create ( Http Formatter : : format Headers ( $ response - > get Headers ( ) ) , $ entities ) ; } , null ) ; } 
public function insert Entity ( $ table , Entity $ entity , Table Service Create Options $ options = null ) { return $ this - > insert Entity Async ( $ table , $ entity , $ options ) - > wait ( ) ; } 
public function insert Entity Async ( $ table , Entity $ entity , Table Service Create Options $ options = null ) { $ context = $ this - > construct Insert Entity Context ( $ table , $ entity , $ options ) ; $ odata Serializer = $ this - > odata Serializer ; return $ this - > send Context Async ( $ context ) - > then ( function ( $ response ) use ( $ odata Serializer ) { $ body = $ response - > get Body ( ) ; $ headers = Http Formatter : : format Headers ( $ response - > get Headers ( ) ) ; return Insert Entity Result : : create ( $ body , $ headers , $ odata Serializer ) ; } , null ) ; } 
public function insert Or Merge Entity ( $ table , Entity $ entity , Table Service Options $ options = null ) { return $ this - > insert Or Merge Entity Async ( $ table , $ entity , $ options ) - > wait ( ) ; } 
public function insert Or Merge Entity Async ( $ table , Entity $ entity , Table Service Options $ options = null ) { return $ this - > put Or Merge Entity Async Impl ( $ table , $ entity , Resources : : HTTP _MERGE , false , $ options ) ; } 
public function insert Or Replace Entity ( $ table , Entity $ entity , Table Service Options $ options = null ) { return $ this - > insert Or Replace Entity Async ( $ table , $ entity , $ options ) - > wait ( ) ; } 
public function insert Or Replace Entity Async ( $ table , Entity $ entity , Table Service Options $ options = null ) { return $ this - > put Or Merge Entity Async Impl ( $ table , $ entity , Resources : : HTTP _PUT , false , $ options ) ; } 
public function update Entity ( $ table , Entity $ entity , Table Service Options $ options = null ) { return $ this - > update Entity Async ( $ table , $ entity , $ options ) - > wait ( ) ; } 
public function update Entity Async ( $ table , Entity $ entity , Table Service Options $ options = null ) { return $ this - > put Or Merge Entity Async Impl ( $ table , $ entity , Resources : : HTTP _PUT , true , $ options ) ; } 
public function merge Entity ( $ table , Entity $ entity , Table Service Options $ options = null ) { return $ this - > merge Entity Async ( $ table , $ entity , $ options ) - > wait ( ) ; } 
public function merge Entity Async ( $ table , Entity $ entity , Table Service Options $ options = null ) { return $ this - > put Or Merge Entity Async Impl ( $ table , $ entity , Resources : : HTTP _MERGE , true , $ options ) ; } 
public function delete Entity ( $ table , $ partition Key , $ row Key , Delete Entity Options $ options = null ) { $ this - > delete Entity Async ( $ table , $ partition Key , $ row Key , $ options ) - > wait ( ) ; } 
public function delete Entity Async ( $ table , $ partition Key , $ row Key , Delete Entity Options $ options = null ) { $ context = $ this - > construct Delete Entity Context ( $ table , $ partition Key , $ row Key , $ options ) ; return $ this - > send Context Async ( $ context ) ; } 
public function get Entity ( $ table , $ partition Key , $ row Key , Get Entity Options $ options = null ) { return $ this - > get Entity Async ( $ table , $ partition Key , $ row Key , $ options ) - > wait ( ) ; } 
public function get Entity Async ( $ table , $ partition Key , $ row Key , Get Entity Options $ options = null ) { Validate : : can Cast As String ( $ table , 'table ' ) ; Validate : : not Null Or Empty ( $ table , 'table ' ) ; Validate : : is True ( ! is _null ( $ partition Key ) , Resources : : NULL _TABLE _KEY _MSG ) ; Validate : : is True ( ! is _null ( $ row Key ) , Resources : : NULL _TABLE _KEY _MSG ) ; $ method = Resources : : HTTP _GET ; $ headers = array ( ) ; $ query Params = array ( ) ; $ path = $ this - > get Entity Path ( $ table , $ partition Key , $ row Key ) ; if ( is _null ( $ options ) ) { $ options = new Get Entity Options ( ) ; } 
public function batch ( Models \ Batch Operations $ batch Operations , Models \ Table Service Options $ options = null ) { return $ this - > batch Async ( $ batch Operations , $ options ) - > wait ( ) ; } 
public function batch Async ( Models \ Batch Operations $ batch Operations , Models \ Table Service Options $ options = null ) { Validate : : not Null Or Empty ( $ batch Operations , 'batch Operations ' ) ; $ method = Resources : : HTTP _POST ; $ operations = $ batch Operations - > get Operations ( ) ; $ contexts = $ this - > create Operations Contexts ( $ operations ) ; $ mime = $ this - > create Batch Request Body ( $ operations , $ contexts ) ; $ body = $ mime [ 'body ' ] ; $ headers = $ mime [ 'headers ' ] ; $ post Params = array ( ) ; $ query Params = array ( ) ; $ path = ' $batch ' ; if ( is _null ( $ options ) ) { $ options = new Table Service Options ( ) ; } $ odata Serializer = $ this - > odata Serializer ; $ mime Serializer = $ this - > mime Serializer ; $ options - > set Location Mode ( Location Mode : : PRIMARY _ONLY ) ; $ this - > add Optional Header ( $ headers , Resources : : ACCEPT _HEADER , Resources : : JSON _FULL _METADATA _CONTENT _TYPE ) ; return $ this - > send Async ( $ method , $ headers , $ query Params , $ post Params , $ path , Resources : : STATUS _ACCEPTED , $ body , $ options ) - > then ( function ( $ response ) use ( $ operations , $ contexts , $ odata Serializer , $ mime Serializer ) { return Batch Result : : create ( $ response - > get Body ( ) , $ operations , $ contexts , $ odata Serializer , $ mime Serializer ) ; } , null ) ; } 
public function get Table Acl ( $ table , Models \ Table Service Options $ options = null ) { return $ this - > get Table Acl Async ( $ table , $ options ) - > wait ( ) ; } 
public function get Table Acl Async ( $ table , Models \ Table Service Options $ options = null ) { Validate : : can Cast As String ( $ table , 'table ' ) ; $ method = Resources : : HTTP _GET ; $ headers = array ( ) ; $ post Params = array ( ) ; $ query Params = array ( ) ; $ status Code = Resources : : STATUS _OK ; $ path = $ table ; if ( is _null ( $ options ) ) { $ options = new Table Service Options ( ) ; } $ this - > add Optional Query Param ( $ query Params , Resources : : QP _COMP , 'acl ' ) ; $ this - > add Optional Header ( $ headers , Resources : : ACCEPT _HEADER , Resources : : XML _CONTENT _TYPE ) ; $ data Serializer = $ this - > data Serializer ; $ promise = $ this - > send Async ( $ method , $ headers , $ query Params , $ post Params , $ path , Resources : : STATUS _OK , Resources : : EMPTY _STRING , $ options ) ; return $ promise - > then ( function ( $ response ) use ( $ data Serializer ) { $ parsed = $ data Serializer - > unserialize ( $ response - > get Body ( ) ) ; return Table ACL : : create ( $ parsed ) ; } , null ) ; } 
public function set Table Acl ( $ table , Table ACL $ acl , Table Service Options $ options = null ) { $ this - > set Table Acl Async ( $ table , $ acl , $ options ) - > wait ( ) ; } 
public function set Table Acl Async ( $ table , Table ACL $ acl , Table Service Options $ options = null ) { Validate : : can Cast As String ( $ table , 'table ' ) ; Validate : : not Null Or Empty ( $ acl , 'acl ' ) ; $ method = Resources : : HTTP _PUT ; $ headers = array ( ) ; $ post Params = array ( ) ; $ query Params = array ( ) ; $ body = $ acl - > to Xml ( $ this - > data Serializer ) ; $ path = $ table ; if ( is _null ( $ options ) ) { $ options = new Table Service Options ( ) ; } $ this - > add Optional Query Param ( $ query Params , Resources : : QP _COMP , 'acl ' ) ; $ this - > add Optional Header ( $ headers , Resources : : ACCEPT _HEADER , Resources : : XML _CONTENT _TYPE ) ; $ options - > set Location Mode ( Location Mode : : PRIMARY _ONLY ) ; return $ this - > send Async ( $ method , $ headers , $ query Params , $ post Params , $ path , Resources : : STATUS _NO _CONTENT , $ body , $ options ) ; } 
public static function create ( array $ response Headers ) { $ result = static : : create Metadata Result ( $ response Headers ) ; $ result - > set Quota ( \ intval ( Utilities : : try Get Value Insensitive ( Resources : : X _MS _SHARE _QUOTA , $ response Headers ) ) ) ; return $ result ; } 
public static function log ( $ var , $ tip = Resources : : EMPTY _STRING ) { if ( ! empty ( $ tip ) ) { error _log ( $ tip . " \n " , 3 , self : : $ _file Path ) ; } if ( is _array ( $ var ) | | is _object ( $ var ) ) { error _log ( print _r ( $ var , true ) , 3 , self : : $ _file Path ) ; } else { error _log ( $ var . " \n " , 3 , self : : $ _file Path ) ; } } 
public static function create ( array $ parsed Response , $ location = ' ' ) { $ result = new List Directories And Files Result ( ) ; $ service Endpoint = Utilities : : try Get Keys Chain Value ( $ parsed Response , Resources : : XTAG _ATTRIBUTES , Resources : : XTAG _SERVICE _ENDPOINT ) ; $ result - > set Account Name ( Utilities : : try Parse Account Name From Url ( $ service Endpoint ) ) ; $ next Marker = Utilities : : try Get Value ( $ parsed Response , Resources : : QP _NEXT _MARKER ) ; if ( $ next Marker ! = null ) { $ result - > set Continuation Token ( new Marker Continuation Token ( $ next Marker , $ location ) ) ; } $ result - > set Max Results ( Utilities : : try Get Value ( $ parsed Response , Resources : : QP _MAX _RESULTS ) ) ; $ result - > set Marker ( Utilities : : try Get Value ( $ parsed Response , Resources : : QP _MARKER ) ) ; $ entries = Utilities : : try Get Value ( $ parsed Response , Resources : : QP _ENTRIES ) ; if ( empty ( $ entries ) ) { $ result - > set Directories ( array ( ) ) ; $ result - > set Files ( array ( ) ) ; } else { $ directories Array = Utilities : : try Get Value ( $ entries , Resources : : QP _DIRECTORY ) ; $ files Array = Utilities : : try Get Value ( $ entries , Resources : : QP _FILE ) ; $ directories = array ( ) ; $ files = array ( ) ; if ( $ directories Array ! = null ) { if ( array _key _exists ( Resources : : QP _NAME , $ directories Array ) ) { $ directories Array = [ $ directories Array ] ; } foreach ( $ directories Array as $ directory Array ) { $ directories [ ] = Directory : : create ( $ directory Array ) ; } } if ( $ files Array ! = null ) { if ( array _key _exists ( Resources : : QP _NAME , $ files Array ) ) { $ files Array = [ $ files Array ] ; } foreach ( $ files Array as $ file Array ) { $ files [ ] = File : : create ( $ file Array ) ; } } $ result - > set Directories ( $ directories ) ; $ result - > set Files ( $ files ) ; } return $ result ; } 
protected function set Directories ( array $ directories ) { $ this - > directories = array ( ) ; foreach ( $ directories as $ directory ) { $ this - > directories [ ] = clone $ directory ; } } 
protected function set Files ( array $ files ) { $ this - > files = array ( ) ; foreach ( $ files as $ file ) { $ this - > files [ ] = clone $ file ; } } 
public static function create ( array $ parsed ) { $ result = new Directory ( ) ; $ name = Utilities : : try Get Value ( $ parsed , Resources : : QP _NAME ) ; $ result - > set Name ( $ name ) ; return $ result ; } 
public static function create ( array $ headers ) { $ result = new Update Entity Result ( ) ; $ result - > set ETag ( Utilities : : try Get Value Insensitive ( Resources : : ETAG , $ headers ) ) ; return $ result ; } 
public function set Query Parameters ( array $ query Params ) { $ this - > _query Params = array ( ) ; foreach ( $ query Params as $ key = > $ value ) { $ this - > add Query Parameter ( $ key , $ value ) ; } } 
public function set Status Codes ( array $ status Codes ) { $ this - > _status Codes = array ( ) ; foreach ( $ status Codes as $ value ) { $ this - > add Status Code ( $ value ) ; } } 
public function add Header ( $ name , $ value ) { Validate : : can Cast As String ( $ name , 'name ' ) ; Validate : : can Cast As String ( $ value , 'value ' ) ; $ this - > _headers [ $ name ] = $ value ; } 
public function add Optional Header ( $ name , $ value ) { Validate : : can Cast As String ( $ name , 'name ' ) ; Validate : : can Cast As String ( $ value , 'value ' ) ; if ( ! empty ( $ value ) ) { $ this - > _headers [ $ name ] = $ value ; } } 
public function remove Header ( $ name ) { Validate : : can Cast As String ( $ name , 'name ' ) ; Validate : : not Null Or Empty ( $ name , 'name ' ) ; unset ( $ this - > _headers [ $ name ] ) ; } 
public function add Query Parameter ( $ name , $ value ) { Validate : : can Cast As String ( $ name , 'name ' ) ; Validate : : can Cast As String ( $ value , 'value ' ) ; $ this - > _query Params [ $ name ] = $ value ; } 
public function add Optional Query Parameter ( $ name , $ value ) { Validate : : can Cast As String ( $ name , 'name ' ) ; Validate : : can Cast As String ( $ value , 'value ' ) ; if ( ! empty ( $ value ) ) { $ this - > _query Params [ $ name ] = $ value ; } } 
public function add History ( array $ entry ) { if ( $ this - > path ! = = ' ' ) { $ this - > append New Entry To Path ( $ entry ) ; } else { Validate : : is True ( array _key _exists ( 'request ' , $ entry ) & & array _key _exists ( 'options ' , $ entry ) & & ( array _key _exists ( 'response ' , $ entry ) | | array _key _exists ( 'reason ' , $ entry ) ) , 'Given history entry not in correct format ' ) ; $ this - > history [ ] = $ entry ; } + + $ this - > count ; } 
protected function on Fulfilled ( Request Interface $ request , array $ options ) { $ reflection = $ this ; return function ( Response Interface $ response ) use ( $ reflection , $ request , $ options ) { $ reflection - > add History ( [ 'request ' = > $ request , 'response ' = > $ response , 'options ' = > $ options ] ) ; return $ response ; } ; } 
protected function on Rejected ( Request Interface $ request , array $ options ) { $ reflection = $ this ; return function ( $ reason ) use ( $ reflection , $ request , $ options ) { $ reflection - > add History ( [ 'request ' = > $ request , 'reason ' = > $ reason , 'options ' = > $ options ] ) ; return new Rejected Promise ( $ reason ) ; } ; } 
private function append New Entry To Path ( array $ entry ) { $ entry No String = "Entry " . $ this - > count ; $ delimiter = str _pad ( $ entry No String , self : : TITLE _LENGTH , ' - ' , STR _PAD _BOTH ) . PHP _EOL ; $ entry String = $ delimiter ; $ entry String . = sprintf ( "Time : %s \n " , ( new \ Date Time ( "now " , new \ Date Time Zone ( 'UTC ' ) ) ) - > format ( 'Y -m -d H :i :s ' ) ) ; $ entry String . = Message Serializer : : object Serialize ( $ entry [ 'request ' ] ) ; if ( array _key _exists ( 'reason ' , $ entry ) ) { $ entry String . = Message Serializer : : object Serialize ( $ entry [ 'reason ' ] ) ; } elseif ( array _key _exists ( 'response ' , $ entry ) ) { $ entry String . = Message Serializer : : object Serialize ( $ entry [ 'response ' ] ) ; } $ entry String . = $ delimiter ; Utilities : : append To File ( $ this - > path , $ entry String ) ; } 
public static function create ( array $ headers , array $ entries ) { $ result = new Query Tables Result ( ) ; $ headers = array _change _key _case ( $ headers ) ; $ result - > set Tables ( $ entries ) ; $ next Table Name = Utilities : : try Get Value ( $ headers , Resources : : X _MS _CONTINUATION _NEXTTABLENAME ) ; if ( $ next Table Name ! = null ) { $ result - > set Continuation Token ( new Table Continuation Token ( $ next Table Name , ' ' , ' ' , Utilities : : get Location From Headers ( $ headers ) ) ) ; } return $ result ; } 
public static function create ( array $ parsed Response = null ) { $ result = new List Messages Result ( ) ; $ queue Messages = array ( ) ; if ( ! empty ( $ parsed Response ) ) { $ raw Messages = Utilities : : get Array ( $ parsed Response [ 'Queue Message ' ] ) ; foreach ( $ raw Messages as $ value ) { $ message = Queue Message : : create From List Messages ( $ value ) ; $ queue Messages [ ] = $ message ; } } $ result - > set Queue Messages ( $ queue Messages ) ; return $ result ; } 
protected function set Queue Messages ( array $ queue Messages ) { $ this - > _queue Messages = array ( ) ; foreach ( $ queue Messages as $ value ) { $ this - > _queue Messages [ ] = clone $ value ; } } 
public static function create ( array $ parsed Response ) { $ result = new Share ( ) ; $ result - > set Name ( $ parsed Response [ Resources : : QP _NAME ] ) ; $ result - > set Metadata ( Utilities : : try Get Value ( $ parsed Response , Resources : : QP _METADATA , array ( ) ) ) ; $ result - > set Properties ( Share Properties : : create ( $ parsed Response [ Resources : : QP _PROPERTIES ] ) ) ; return $ result ; } 
private static function _init ( ) { if ( ! self : : $ _is Initialized ) { self : : $ _sources = array ( ) ; 
public static function is Instance Of ( $ object Instance , $ class Instance , $ name ) { Validate : : not Null ( $ class Instance , 'class Instance ' ) ; if ( is _null ( $ object Instance ) ) { return true ; } $ object Type = gettype ( $ object Instance ) ; $ class Type = gettype ( $ class Instance ) ; if ( $ object Type = = = $ class Type ) { return true ; } else { throw new \ Invalid Argument Exception ( sprintf ( Resources : : INSTANCE _TYPE _VALIDATION _MSG , $ name , $ object Type , $ class Type ) ) ; } } 
public static function is Valid Hostname ( $ hostname ) { if ( defined ( 'FILTER _VALIDATE _DOMAIN ' ) ) { $ is Valid = filter _var ( $ hostname , FILTER _VALIDATE _DOMAIN , FILTER _FLAG _HOSTNAME ) ; } else { 
public static function is Valid Uri ( $ uri ) { $ is Valid = filter _var ( $ uri , FILTER _VALIDATE _URL ) ; if ( $ is Valid ) { return true ; } else { throw new \ Runtime Exception ( sprintf ( Resources : : INVALID _CONFIG _URI , $ uri ) ) ; } } 
public static function is A ( $ object Instance , $ class , $ name ) { Validate : : can Cast As String ( $ class , 'class ' ) ; Validate : : not Null ( $ object Instance , 'object Instance ' ) ; Validate : : is Object ( $ object Instance , 'object Instance ' ) ; $ object Type = get _class ( $ object Instance ) ; if ( is _a ( $ object Instance , $ class ) ) { return true ; } else { throw new \ Invalid Argument Exception ( sprintf ( Resources : : INSTANCE _TYPE _VALIDATION _MSG , $ name , $ object Type , $ class ) ) ; } } 
public static function method Exists ( $ object Instance , $ method , $ name ) { Validate : : can Cast As String ( $ method , 'method ' ) ; Validate : : not Null ( $ object Instance , 'object Instance ' ) ; Validate : : is Object ( $ object Instance , 'object Instance ' ) ; if ( method _exists ( $ object Instance , $ method ) ) { return true ; } else { throw new \ Invalid Argument Exception ( sprintf ( Resources : : ERROR _METHOD _NOT _FOUND , $ method , $ name ) ) ; } } 
public static function is Date String ( $ value , $ name ) { Validate : : can Cast As String ( $ value , 'value ' ) ; try { new \ Date Time ( $ value ) ; return true ; } catch ( \ Exception $ e ) { throw new \ Invalid Argument Exception ( sprintf ( Resources : : ERROR _INVALID _DATE _STRING , $ name , $ value ) ) ; } } 
public static function has Key ( $ key , $ name , array $ array ) { Validate : : is Array ( $ array , $ name ) ; if ( ! array _key _exists ( $ key , $ array ) ) { throw new \ Unexpected Value Exception ( sprintf ( Resources : : INVALID _VALUE _MSG , $ name , sprintf ( Resources : : ERROR _KEY _NOT _EXIST , $ key ) ) ) ; } return true ; } 
public function get Range String ( ) { $ range String = ' ' ; $ range String . = ( 'bytes = ' . $ this - > start . ' - ' ) ; if ( $ this - > end ! = null ) { $ range String . = $ this - > end ; } return $ range String ; } 
public static function create Queue Service ( $ connection String , array $ options = [ ] ) { $ settings = Storage Service Settings : : create From Connection String ( $ connection String ) ; $ primary Uri = Utilities : : try Add Url Scheme ( $ settings - > get Queue Endpoint Uri ( ) ) ; $ secondary Uri = Utilities : : try Add Url Scheme ( $ settings - > get Queue Secondary Endpoint Uri ( ) ) ; $ queue Wrapper = new Queue Rest Proxy ( $ primary Uri , $ secondary Uri , $ settings - > get Name ( ) , $ options ) ; 
public static function create Queue Service With Token Credential ( & $ token , $ connection String , array $ options = [ ] ) { $ settings = Storage Service Settings : : create From Connection String For Token Credential ( $ connection String ) ; $ primary Uri = Utilities : : try Add Url Scheme ( $ settings - > get Queue Endpoint Uri ( ) ) ; $ secondary Uri = Utilities : : try Add Url Scheme ( $ settings - > get Queue Secondary Endpoint Uri ( ) ) ; $ queue Wrapper = new Queue Rest Proxy ( $ primary Uri , $ secondary Uri , $ settings - > get Name ( ) , $ options ) ; 
public function list Queues Async ( List Queues Options $ options = null ) { $ method = Resources : : HTTP _GET ; $ headers = array ( ) ; $ post Params = array ( ) ; $ query Params = array ( ) ; $ path = Resources : : EMPTY _STRING ; if ( is _null ( $ options ) ) { $ options = new List Queues Options ( ) ; } $ max Results = $ options - > get Max Results ( ) ; $ include = $ options - > get Include Metadata ( ) ; $ include = $ include ? 'metadata ' : null ; $ prefix = $ options - > get Prefix ( ) ; $ marker = $ options - > get Next Marker ( ) ; $ this - > add Optional Query Param ( $ query Params , Resources : : QP _COMP , 'list ' ) ; $ this - > add Optional Query Param ( $ query Params , Resources : : QP _PREFIX , $ prefix ) ; $ this - > add Optional Query Param ( $ query Params , Resources : : QP _MARKER , $ marker ) ; $ this - > add Optional Query Param ( $ query Params , Resources : : QP _INCLUDE , $ include ) ; $ this - > add Optional Query Param ( $ query Params , Resources : : QP _MAX _RESULTS , $ max Results ) ; $ data Serializer = $ this - > data Serializer ; return $ this - > send Async ( $ method , $ headers , $ query Params , $ post Params , $ path , Resources : : STATUS _OK , Resources : : EMPTY _STRING , $ options ) - > then ( function ( $ response ) use ( $ data Serializer ) { $ parsed = $ data Serializer - > unserialize ( $ response - > get Body ( ) ) ; return List Queues Result : : create ( $ parsed , Utilities : : get Location From Headers ( $ response - > get Headers ( ) ) ) ; } , null ) ; } 
public function clear Messages ( $ queue Name , Queue Service Options $ options = null ) { $ this - > clear Messages Async ( $ queue Name , $ options ) - > wait ( ) ; } 
public function create Message ( $ queue Name , $ message Text , Create Message Options $ options = null ) { return $ this - > create Message Async ( $ queue Name , $ message Text , $ options ) - > wait ( ) ; } 
public function create Message Async ( $ queue Name , $ message Text , Create Message Options $ options = null ) { Validate : : can Cast As String ( $ queue Name , 'queue Name ' ) ; Validate : : not Null Or Empty ( $ queue Name , 'queue Name ' ) ; Validate : : can Cast As String ( $ message Text , 'message Text ' ) ; $ method = Resources : : HTTP _POST ; $ headers = array ( ) ; $ post Params = array ( ) ; $ query Params = array ( ) ; $ path = $ queue Name . ' /messages ' ; $ body = Resources : : EMPTY _STRING ; $ message = new Queue Message ( ) ; $ message - > set Message Text ( $ message Text ) ; $ body = $ message - > to Xml ( $ this - > data Serializer ) ; if ( is _null ( $ options ) ) { $ options = new Create Message Options ( ) ; } $ this - > add Optional Header ( $ headers , Resources : : CONTENT _TYPE , Resources : : URL _ENCODED _CONTENT _TYPE ) ; $ visibility = $ options - > get Visibility Timeout In Seconds ( ) ; $ time To Live = $ options - > get Time To Live In Seconds ( ) ; $ this - > add Optional Query Param ( $ query Params , Resources : : QP _VISIBILITY _TIMEOUT , $ visibility ) ; $ this - > add Optional Query Param ( $ query Params , Resources : : QP _MESSAGE _TTL , $ time To Live ) ; $ options - > set Location Mode ( Location Mode : : PRIMARY _ONLY ) ; $ data Serializer = $ this - > data Serializer ; return $ this - > send Async ( $ method , $ headers , $ query Params , $ post Params , $ path , Resources : : STATUS _CREATED , $ body , $ options ) - > then ( function ( $ response ) use ( $ data Serializer ) { $ parsed = $ data Serializer - > unserialize ( $ response - > get Body ( ) ) ; return Create Message Result : : create ( $ parsed ) ; } , null ) ; } 
public function create Queue ( $ queue Name , Models \ Create Queue Options $ options = null ) { $ this - > create Queue Async ( $ queue Name , $ options ) - > wait ( ) ; } 
public function create Queue Async ( $ queue Name , Models \ Create Queue Options $ options = null ) { Validate : : can Cast As String ( $ queue Name , 'queue Name ' ) ; Validate : : not Null Or Empty ( $ queue Name , 'queue Name ' ) ; $ method = Resources : : HTTP _PUT ; $ headers = array ( ) ; $ post Params = array ( ) ; $ query Params = array ( ) ; $ path = $ queue Name ; if ( is _null ( $ options ) ) { $ options = new Create Queue Options ( ) ; } $ metadata = $ options - > get Metadata ( ) ; $ headers = $ this - > generate Metadata Headers ( $ metadata ) ; $ options - > set Location Mode ( Location Mode : : PRIMARY _ONLY ) ; return $ this - > send Async ( $ method , $ headers , $ query Params , $ post Params , $ path , array ( Resources : : STATUS _CREATED , Resources : : STATUS _NO _CONTENT ) , Resources : : EMPTY _STRING , $ options ) ; } 
public function delete Message ( $ queue Name , $ message Id , $ pop Receipt , Queue Service Options $ options = null ) { $ this - > delete Message Async ( $ queue Name , $ message Id , $ pop Receipt , $ options ) - > wait ( ) ; } 
public function delete Message Async ( $ queue Name , $ message Id , $ pop Receipt , Queue Service Options $ options = null ) { Validate : : can Cast As String ( $ queue Name , 'queue Name ' ) ; Validate : : not Null Or Empty ( $ queue Name , 'queue Name ' ) ; Validate : : can Cast As String ( $ message Id , 'message Id ' ) ; Validate : : not Null Or Empty ( $ message Id , 'message Id ' ) ; Validate : : can Cast As String ( $ pop Receipt , 'pop Receipt ' ) ; Validate : : not Null Or Empty ( $ pop Receipt , 'pop Receipt ' ) ; $ method = Resources : : HTTP _DELETE ; $ headers = array ( ) ; $ post Params = array ( ) ; $ query Params = array ( ) ; $ path = $ queue Name . ' /messages / ' . $ message Id ; $ body = Resources : : EMPTY _STRING ; if ( is _null ( $ options ) ) { $ options = new Queue Service Options ( ) ; } $ this - > add Optional Query Param ( $ query Params , Resources : : QP _POPRECEIPT , $ pop Receipt ) ; $ options - > set Location Mode ( Location Mode : : PRIMARY _ONLY ) ; return $ this - > send Async ( $ method , $ headers , $ query Params , $ post Params , $ path , Resources : : STATUS _NO _CONTENT , $ body , $ options ) ; } 
public function delete Queue ( $ queue Name , Queue Service Options $ options = null ) { $ this - > delete Queue Async ( $ queue Name , $ options ) - > wait ( ) ; } 
public function delete Queue Async ( $ queue Name , Queue Service Options $ options = null ) { Validate : : can Cast As String ( $ queue Name , 'queue Name ' ) ; Validate : : not Null Or Empty ( $ queue Name , 'queue Name ' ) ; $ method = Resources : : HTTP _DELETE ; $ headers = array ( ) ; $ post Params = array ( ) ; $ query Params = array ( ) ; $ path = $ queue Name ; if ( is _null ( $ options ) ) { $ options = new Queue Service Options ( ) ; } $ options - > set Location Mode ( Location Mode : : PRIMARY _ONLY ) ; return $ this - > send Async ( $ method , $ headers , $ query Params , $ post Params , $ path , Resources : : STATUS _NO _CONTENT , Resources : : EMPTY _STRING , $ options ) ; } 
public function get Queue Metadata ( $ queue Name , Queue Service Options $ options = null ) { return $ this - > get Queue Metadata Async ( $ queue Name , $ options ) - > wait ( ) ; } 
public function get Queue Metadata Async ( $ queue Name , Queue Service Options $ options = null ) { Validate : : can Cast As String ( $ queue Name , 'queue Name ' ) ; Validate : : not Null Or Empty ( $ queue Name , 'queue Name ' ) ; $ method = Resources : : HTTP _GET ; $ headers = array ( ) ; $ post Params = array ( ) ; $ query Params = array ( ) ; $ path = $ queue Name ; $ body = Resources : : EMPTY _STRING ; if ( is _null ( $ options ) ) { $ options = new Queue Service Options ( ) ; } $ this - > add Optional Query Param ( $ query Params , Resources : : QP _COMP , 'metadata ' ) ; return $ this - > send Async ( $ method , $ headers , $ query Params , $ post Params , $ path , Resources : : STATUS _OK , $ body , $ options ) - > then ( function ( $ response ) { $ response Headers = Http Formatter : : format Headers ( $ response - > get Headers ( ) ) ; $ metadata = Utilities : : get Metadata Array ( $ response Headers ) ; $ max Count = intval ( Utilities : : try Get Value ( $ response Headers , Resources : : X _MS _APPROXIMATE _MESSAGES _COUNT ) ) ; return new Get Queue Metadata Result ( $ max Count , $ metadata ) ; } , null ) ; } 
public function list Messages ( $ queue Name , List Messages Options $ options = null ) { return $ this - > list Messages Async ( $ queue Name , $ options ) - > wait ( ) ; } 
public function list Messages Async ( $ queue Name , List Messages Options $ options = null ) { Validate : : can Cast As String ( $ queue Name , 'queue Name ' ) ; Validate : : not Null Or Empty ( $ queue Name , 'queue Name ' ) ; $ method = Resources : : HTTP _GET ; $ headers = array ( ) ; $ query Params = array ( ) ; $ post Params = array ( ) ; $ path = $ queue Name . ' /messages ' ; if ( is _null ( $ options ) ) { $ options = new List Messages Options ( ) ; } $ messages Count = $ options - > get Number Of Messages ( ) ; $ visibility = $ options - > get Visibility Timeout In Seconds ( ) ; $ this - > add Optional Query Param ( $ query Params , Resources : : QP _NUM _OF _MESSAGES , $ messages Count ) ; $ this - > add Optional Query Param ( $ query Params , Resources : : QP _VISIBILITY _TIMEOUT , $ visibility ) ; $ data Serializer = $ this - > data Serializer ; $ options - > set Location Mode ( Location Mode : : PRIMARY _ONLY ) ; return $ this - > send Async ( $ method , $ headers , $ query Params , $ post Params , $ path , Resources : : STATUS _OK , Resources : : EMPTY _STRING , $ options ) - > then ( function ( $ response ) use ( $ data Serializer ) { $ parsed = $ data Serializer - > unserialize ( $ response - > get Body ( ) ) ; return List Messages Result : : create ( $ parsed ) ; } , null ) ; } 
public function peek Messages ( $ queue Name , Peek Messages Options $ options = null ) { return $ this - > peek Messages Async ( $ queue Name , $ options ) - > wait ( ) ; } 
public function peek Messages Async ( $ queue Name , Peek Messages Options $ options = null ) { Validate : : can Cast As String ( $ queue Name , 'queue Name ' ) ; Validate : : not Null Or Empty ( $ queue Name , 'queue Name ' ) ; $ method = Resources : : HTTP _GET ; $ headers = array ( ) ; $ query Params = array ( ) ; $ post Params = array ( ) ; $ path = $ queue Name . ' /messages ' ; if ( is _null ( $ options ) ) { $ options = new Peek Messages Options ( ) ; } $ messages Count = $ options - > get Number Of Messages ( ) ; $ this - > add Optional Query Param ( $ query Params , Resources : : QP _PEEK _ONLY , 'true ' ) ; $ this - > add Optional Query Param ( $ query Params , Resources : : QP _NUM _OF _MESSAGES , $ messages Count ) ; $ data Serializer = $ this - > data Serializer ; return $ this - > send Async ( $ method , $ headers , $ query Params , $ post Params , $ path , Resources : : STATUS _OK , Resources : : EMPTY _STRING , $ options ) - > then ( function ( $ response ) use ( $ data Serializer ) { $ parsed = $ data Serializer - > unserialize ( $ response - > get Body ( ) ) ; return Peek Messages Result : : create ( $ parsed ) ; } , null ) ; } 
public function set Queue Metadata ( $ queue Name , array $ metadata = null , Queue Service Options $ options = null ) { $ this - > set Queue Metadata Async ( $ queue Name , $ metadata , $ options ) - > wait ( ) ; } 
public function set Queue Metadata Async ( $ queue Name , array $ metadata = null , Queue Service Options $ options = null ) { Validate : : can Cast As String ( $ queue Name , 'queue Name ' ) ; Validate : : not Null Or Empty ( $ queue Name , 'queue Name ' ) ; Utilities : : validate Metadata ( $ metadata ) ; $ method = Resources : : HTTP _PUT ; $ headers = array ( ) ; $ query Params = array ( ) ; $ post Params = array ( ) ; $ path = $ queue Name ; $ body = Resources : : EMPTY _STRING ; if ( is _null ( $ options ) ) { $ options = new Queue Service Options ( ) ; } $ this - > add Optional Query Param ( $ query Params , Resources : : QP _COMP , 'metadata ' ) ; $ metadata Headers = $ this - > generate Metadata Headers ( $ metadata ) ; $ headers = $ metadata Headers ; $ options - > set Location Mode ( Location Mode : : PRIMARY _ONLY ) ; return $ this - > send Async ( $ method , $ headers , $ query Params , $ post Params , $ path , Resources : : STATUS _NO _CONTENT , $ body , $ options ) ; } 
public function update Message ( $ queue Name , $ message Id , $ pop Receipt , $ message Text , $ visibility Timeout In Seconds , Queue Service Options $ options = null ) { return $ this - > update Message Async ( $ queue Name , $ message Id , $ pop Receipt , $ message Text , $ visibility Timeout In Seconds , $ options ) - > wait ( ) ; } 
public function update Message Async ( $ queue Name , $ message Id , $ pop Receipt , $ message Text , $ visibility Timeout In Seconds , Queue Service Options $ options = null ) { Validate : : can Cast As String ( $ queue Name , 'queue Name ' ) ; Validate : : not Null Or Empty ( $ queue Name , 'queue Name ' ) ; Validate : : can Cast As String ( $ message Id , 'message Id ' ) ; Validate : : not Null Or Empty ( $ message Id , 'message Id ' ) ; Validate : : can Cast As String ( $ pop Receipt , 'pop Receipt ' ) ; Validate : : not Null Or Empty ( $ pop Receipt , 'pop Receipt ' ) ; Validate : : can Cast As String ( $ message Text , 'message Text ' ) ; Validate : : is Integer ( $ visibility Timeout In Seconds , 'visibility Timeout In Seconds ' ) ; Validate : : not Null ( $ visibility Timeout In Seconds , 'visibility Timeout In Seconds ' ) ; $ method = Resources : : HTTP _PUT ; $ headers = array ( ) ; $ post Params = array ( ) ; $ query Params = array ( ) ; $ path = $ queue Name . ' /messages ' . ' / ' . $ message Id ; $ body = Resources : : EMPTY _STRING ; if ( is _null ( $ options ) ) { $ options = new Queue Service Options ( ) ; } $ this - > add Optional Query Param ( $ query Params , Resources : : QP _VISIBILITY _TIMEOUT , $ visibility Timeout In Seconds ) ; $ this - > add Optional Query Param ( $ query Params , Resources : : QP _POPRECEIPT , $ pop Receipt ) ; if ( ! empty ( $ message Text ) ) { $ this - > add Optional Header ( $ headers , Resources : : CONTENT _TYPE , Resources : : URL _ENCODED _CONTENT _TYPE ) ; $ message = new Queue Message ( ) ; $ message - > set Message Text ( $ message Text ) ; $ body = $ message - > to Xml ( $ this - > data Serializer ) ; } $ options - > set Location Mode ( Location Mode : : PRIMARY _ONLY ) ; return $ this - > send Async ( $ method , $ headers , $ query Params , $ post Params , $ path , Resources : : STATUS _NO _CONTENT , $ body , $ options ) - > then ( function ( $ response ) { $ response Headers = Http Formatter : : format Headers ( $ response - > get Headers ( ) ) ; return Update Message Result : : create ( $ response Headers ) ; } , null ) ; } 
public function get Queue Acl ( $ queue , Models \ Queue Service Options $ options = null ) { return $ this - > get Queue Acl Async ( $ queue , $ options ) - > wait ( ) ; } 
public function get Queue Acl Async ( $ queue , Models \ Queue Service Options $ options = null ) { Validate : : can Cast As String ( $ queue , 'queue ' ) ; $ method = Resources : : HTTP _GET ; $ headers = array ( ) ; $ post Params = array ( ) ; $ query Params = array ( ) ; $ status Code = Resources : : STATUS _OK ; $ path = $ queue ; if ( is _null ( $ options ) ) { $ options = new Queue Service Options ( ) ; } $ this - > add Optional Query Param ( $ query Params , Resources : : QP _COMP , 'acl ' ) ; $ data Serializer = $ this - > data Serializer ; $ promise = $ this - > send Async ( $ method , $ headers , $ query Params , $ post Params , $ path , Resources : : STATUS _OK , Resources : : EMPTY _STRING , $ options ) ; return $ promise - > then ( function ( $ response ) use ( $ data Serializer ) { $ parsed = $ data Serializer - > unserialize ( $ response - > get Body ( ) ) ; return Queue ACL : : create ( $ parsed ) ; } , null ) ; } 
public function set Queue Acl ( $ queue , Models \ Queue ACL $ acl , Models \ Queue Service Options $ options = null ) { $ this - > set Queue Acl Async ( $ queue , $ acl , $ options ) - > wait ( ) ; } 
public function set Queue Acl Async ( $ queue , Models \ Queue ACL $ acl , Models \ Queue Service Options $ options = null ) { Validate : : can Cast As String ( $ queue , 'queue ' ) ; Validate : : not Null Or Empty ( $ acl , 'acl ' ) ; $ method = Resources : : HTTP _PUT ; $ headers = array ( ) ; $ post Params = array ( ) ; $ query Params = array ( ) ; $ body = $ acl - > to Xml ( $ this - > data Serializer ) ; $ path = $ queue ; if ( is _null ( $ options ) ) { $ options = new Queue Service Options ( ) ; } $ this - > add Optional Query Param ( $ query Params , Resources : : QP _COMP , 'acl ' ) ; $ options - > set Location Mode ( Location Mode : : PRIMARY _ONLY ) ; return $ this - > send Async ( $ method , $ headers , $ query Params , $ post Params , $ path , Resources : : STATUS _NO _CONTENT , $ body , $ options ) ; } 
public function generate Account Shared Access Signature Token ( $ signed Version , $ signed Permissions , $ signed Service , $ signed Resource Type , $ signed Expiry , $ signed Start = " " , $ signed IP = " " , $ signed Protocol = " " ) { 
protected function validate And Sanitize Signed Service ( $ signed Service ) { 
protected function validate And Sanitize Signed Resource Type ( $ signed Resource Type ) { 
protected function validate And Sanitize Signed Permissions ( $ signed Permissions ) { 
protected function validate And Sanitize Signed Protocol ( $ signed Protocol ) { Validate : : can Cast As String ( $ signed Protocol , 'signed Protocol ' ) ; 
protected function validate And Sanitize String With Array ( $ input , array $ array ) { $ result = ' ' ; foreach ( $ array as $ value ) { if ( strpos ( $ input , $ value ) ! = = false ) { 
protected static function generate Canonical Resource ( $ account Name , $ service , $ resource ) { static $ service Map = array ( Resources : : RESOURCE _TYPE _BLOB = > 'blob ' , Resources : : RESOURCE _TYPE _FILE = > 'file ' , Resources : : RESOURCE _TYPE _QUEUE = > 'queue ' , Resources : : RESOURCE _TYPE _TABLE = > 'table ' , ) ; $ service Name = $ service Map [ $ service ] ; if ( Utilities : : starts With ( $ resource , ' / ' ) ) { $ resource = substr ( $ resource , 1 ) ; } return sprintf ( ' / %s / %s / %s ' , $ service Name , $ account Name , $ resource ) ; } 
public function to Array ( ) { $ array = array ( ) ; $ access Policy Array = array ( ) ; $ access Policy Array [ Resources : : XTAG _SIGNED _ID ] = $ this - > get Id ( ) ; $ access Policy Array [ Resources : : XTAG _ACCESS _POLICY ] = $ this - > get Access Policy ( ) - > to Array ( ) ; $ array [ Resources : : XTAG _SIGNED _IDENTIFIER ] = $ access Policy Array ; return $ array ; } 
protected static function parse Error Message ( Response Interface $ response ) { 
public function get Request ID ( ) { $ request ID = ' ' ; if ( array _key _exists ( Resources : : X _MS _REQUEST _ID , $ this - > get Response ( ) - > get Headers ( ) ) ) { $ request ID = $ this - > get Response ( ) - > get Headers ( ) [ Resources : : X _MS _REQUEST _ID ] [ 0 ] ; } return $ request ID ; } 
public function get Date ( ) { $ date = ' ' ; if ( array _key _exists ( Resources : : DATE , $ this - > get Response ( ) - > get Headers ( ) ) ) { $ date = $ this - > get Response ( ) - > get Headers ( ) [ Resources : : DATE ] [ 0 ] ; } return $ date ; } 
public function set Middlewares ( array $ middlewares ) { foreach ( $ middlewares as $ middleware ) { self : : validate Is Middleware ( $ middleware ) ; } $ this - > middlewares = $ middlewares ; } 
private static function validate Is Middleware ( $ middleware ) { if ( ! ( is _callable ( $ middleware ) | | $ middleware instanceof IMiddleware ) ) { Validate : : is True ( false , Resources : : INVALID _TYPE _MSG . 'callable or IMiddleware ' ) ; } } 
public static function create ( array $ parsed Response ) { $ result = new Share Properties ( ) ; $ date = $ parsed Response [ Resources : : QP _LAST _MODIFIED ] ; $ date = Utilities : : rfc 1 1 2 3To Date Time ( $ date ) ; $ result - > set Last Modified ( $ date ) ; $ result - > set ETag ( $ parsed Response [ Resources : : QP _ETAG ] ) ; $ result - > set Quota ( $ parsed Response [ Resources : : QP _QUOTA ] ) ; return $ result ; } 
public static function parse Connection String ( $ argument Name , $ connection String ) { Validate : : can Cast As String ( $ argument Name , 'argument Name ' ) ; Validate : : not Null Or Empty ( $ argument Name , 'argument Name ' ) ; Validate : : can Cast As String ( $ connection String , 'connection String ' ) ; Validate : : not Null Or Empty ( $ connection String , 'connection String ' ) ; $ parser = new Connection String Parser ( $ argument Name , $ connection String ) ; return $ parser - > _parse ( ) ; } 
private function _parse ( ) { $ key = null ; $ value = null ; $ connection String Values = array ( ) ; while ( true ) { $ this - > _skip White Spaces ( ) ; if ( $ this - > _pos = = strlen ( $ this - > _value ) & & $ this - > _state ! = Connection String Parser : : EXPECT _VALUE ) { 
private function _create Exception ( $ position , $ error String ) { $ arguments = func _get _args ( ) ; 
private function _extract Key ( ) { $ key = null ; $ first Pos = $ this - > _pos ; $ ch = $ this - > _value [ $ this - > _pos ] ; if ( $ ch = = ' " ' | | $ ch = = ' \ ' ' ) { $ this - > _pos + + ; $ key = $ this - > _extract String ( $ ch ) ; } elseif ( $ ch = = ' ; ' | | $ ch = = ' = ' ) { / / Key name was expected . throw $ this - > _create Exception ( $ first Pos , Resources : : ERROR _CONNECTION _STRING _MISSING _KEY ) ; } else { while ( $ this - > _pos < strlen ( $ this - > _value ) ) { $ ch = $ this - > _value [ $ this - > _pos ] ; / / At this point we 've read the key , break . if ( $ ch = = ' = ' ) { break ; } $ this - > _pos + + ; } $ key = rtrim ( substr ( $ this - > _value , $ first Pos , $ this - > _pos - $ first Pos ) ) ; } if ( strlen ( $ key ) = = 0 ) { 
private function _extract String ( $ quote ) { $ first Pos = $ this - > _pos ; while ( $ this - > _pos < strlen ( $ this - > _value ) & & $ this - > _value [ $ this - > _pos ] ! = $ quote ) { $ this - > _pos + + ; } if ( $ this - > _pos = = strlen ( $ this - > _value ) ) { 
private function _skip Operator ( $ operator Char ) { if ( $ this - > _value [ $ this - > _pos ] ! = $ operator Char ) { 
public static function create ( $ etag , \ Date Time $ last Modified , array $ parsed = null ) { $ result = new Get Share Acl Result ( ) ; $ result - > set ETag ( $ etag ) ; $ result - > set Last Modified ( $ last Modified ) ; $ acl = Share ACL : : create ( $ parsed ) ; $ result - > set Share Acl ( $ acl ) ; return $ result ; } 
public static function create ( array $ headers , array $ parsed = null ) { $ result = new List File Ranges Result ( ) ; $ headers = array _change _key _case ( $ headers ) ; $ date = $ headers [ Resources : : LAST _MODIFIED ] ; $ date = Utilities : : rfc 1 1 2 3To Date Time ( $ date ) ; $ file Length = intval ( $ headers [ Resources : : X _MS _CONTENT _LENGTH ] ) ; $ raw Ranges = array ( ) ; if ( ! empty ( $ parsed [ 'Range ' ] ) ) { $ raw Ranges = Utilities : : get Array ( $ parsed [ 'Range ' ] ) ; } $ ranges = array ( ) ; foreach ( $ raw Ranges as $ value ) { $ ranges [ ] = new Range ( intval ( $ value [ 'Start ' ] ) , intval ( $ value [ 'End ' ] ) ) ; } $ result - > set Ranges ( $ ranges ) ; $ result - > set Content Length ( $ file Length ) ; $ result - > set ETag ( $ headers [ Resources : : ETAG ] ) ; $ result - > set Last Modified ( $ date ) ; return $ result ; } 
protected function set Ranges ( array $ ranges ) { $ this - > ranges = array ( ) ; foreach ( $ ranges as $ range ) { $ this - > ranges [ ] = clone $ range ; } } 
public static function create ( array $ parsed Response ) { $ result = new Get Service Stats Result ( ) ; if ( Utilities : : array Key Exists Insensitive ( Resources : : XTAG _GEO _REPLICATION , $ parsed Response ) ) { $ geo Replication = $ parsed Response [ Resources : : XTAG _GEO _REPLICATION ] ; if ( Utilities : : array Key Exists Insensitive ( Resources : : XTAG _STATUS , $ geo Replication ) ) { $ result - > set Status ( $ geo Replication [ Resources : : XTAG _STATUS ] ) ; } if ( Utilities : : array Key Exists Insensitive ( Resources : : XTAG _LAST _SYNC _TIME , $ geo Replication ) ) { $ last Sync Time = $ geo Replication [ Resources : : XTAG _LAST _SYNC _TIME ] ; $ result - > set Last Sync Time ( Utilities : : convert To Date Time ( $ last Sync Time ) ) ; } } return $ result ; } 
protected function on Request ( Request Interface $ request ) { $ result = $ request ; 
protected static function parse And Validate Keys ( $ connection String ) { 
protected static function setting With Func ( $ name , $ predicate ) { $ requirement = array ( ) ; $ requirement [ Resources : : SETTING _NAME ] = $ name ; $ requirement [ Resources : : SETTING _CONSTRAINT ] = $ predicate ; return $ requirement ; } 
protected static function setting ( $ name ) { $ valid Values = func _get _args ( ) ; 
protected static function matched Specification ( array $ settings ) { $ constraints = func _get _args ( ) ; 
public function sign Request ( Request $ request ) { 
public static function create From Http Headers ( array $ parsed ) { $ result = new File Properties ( ) ; $ clean = array _change _key _case ( $ parsed ) ; $ last Modified = Utilities : : try Get Value ( $ parsed , Resources : : LAST _MODIFIED ) ; $ result - > set Last Modified ( Utilities : : rfc 1 1 2 3To Date Time ( $ last Modified ) ) ; $ result - > set Content Length ( Utilities : : try Get Value ( $ parsed , Resources : : CONTENT _LENGTH ) ) ; $ result - > set Content Type ( Utilities : : try Get Value ( $ parsed , Resources : : CONTENT _TYPE ) ) ; $ result - > set ETag ( Utilities : : try Get Value ( $ parsed , Resources : : ETAG ) ) ; if ( Utilities : : try Get Value ( $ parsed , Resources : : CONTENT _MD 5 ) & & ! Utilities : : try Get Value ( $ parsed , Resources : : CONTENT _RANGE ) ) { $ result - > set Content MD 5 ( Utilities : : try Get Value ( $ parsed , Resources : : CONTENT _MD 5 ) ) ; } else { $ result - > set Content MD 5 ( Utilities : : try Get Value ( $ parsed , Resources : : FILE _CONTENT _MD 5 ) ) ; $ result - > set Range Content MD 5 ( Utilities : : try Get Value ( $ parsed , Resources : : CONTENT _MD 5 ) ) ; } $ result - > set Content Encoding ( Utilities : : try Get Value ( $ parsed , Resources : : CONTENT _ENCODING ) ) ; $ result - > set Content Language ( Utilities : : try Get Value ( $ parsed , Resources : : CONTENT _LANGUAGE ) ) ; $ result - > set Cache Control ( Utilities : : try Get Value ( $ parsed , Resources : : CACHE _CONTROL ) ) ; $ result - > set Content Disposition ( Utilities : : try Get Value ( $ parsed , Resources : : CONTENT _DISPOSITION ) ) ; $ result - > set Content Range ( Utilities : : try Get Value ( $ parsed , Resources : : CONTENT _RANGE ) ) ; $ result - > set Copy Completion Time ( Utilities : : try Get Value ( $ parsed , Resources : : X _MS _COPY _COMPLETION _TIME ) ) ; $ result - > set Copy Status Description ( Utilities : : try Get Value ( $ parsed , Resources : : X _MS _COPY _STATUS _DESCRIPTION ) ) ; $ result - > set Copy ID ( Utilities : : try Get Value ( $ parsed , Resources : : X _MS _COPY _ID ) ) ; $ result - > set Copy Progress ( Utilities : : try Get Value ( $ parsed , Resources : : X _MS _COPY _PROGRESS ) ) ; $ result - > set Copy Source ( Utilities : : try Get Value ( $ parsed , Resources : : X _MS _COPY _SOURCE ) ) ; $ result - > set Copy Status ( Utilities : : try Get Value ( $ parsed , Resources : : X _MS _COPY _STATUS ) ) ; return $ result ; } 
public function set Next Row Key ( $ next Row Key ) { if ( $ this - > continuation Token = = null ) { $ this - > set Continuation Token ( new Table Continuation Token ( ) ) ; } $ this - > continuation Token - > set Next Row Key ( $ next Row Key ) ; } 
public function set Next Partition Key ( $ next Partition Key ) { if ( $ this - > continuation Token = = null ) { $ this - > set Continuation Token ( new Table Continuation Token ( ) ) ; } $ this - > continuation Token - > set Next Partition Key ( $ next Partition Key ) ; } 
public function set Next Table Name ( $ next Table Name ) { if ( $ this - > continuation Token = = null ) { $ this - > set Continuation Token ( new Table Continuation Token ( ) ) ; } $ this - > continuation Token - > set Next Table Name ( $ next Table Name ) ; } 
public static function process Type ( $ type ) { $ type = empty ( $ type ) ? self : : STRING : $ type ; Validate : : is True ( self : : is Valid ( $ type ) , Resources : : INVALID _EDM _MSG ) ; return $ type ; } 
public static function validate Edm Value ( $ type , $ value , & $ condition = null ) { 
public static function serialize Value ( $ type , $ value ) { switch ( $ type ) { case null : return $ value ; case Edm Type : : INT 3 2 : return intval ( $ value ) ; case Edm Type : : INT 6 4 : case Edm Type : : GUID : case Edm Type : : STRING : return strval ( $ value ) ; case Edm Type : : DOUBLE : return strval ( $ value ) ; case Edm Type : : BINARY : return base 6 4 _encode ( $ value ) ; case Edm Type : : DATETIME : return Utilities : : convert To Edm Date Time ( $ value ) ; case Edm Type : : BOOLEAN : return ( is _null ( $ value ) ? ' ' : ( $ value = = true ? true : false ) ) ; default : throw new \ Invalid Argument Exception ( ) ; } } 
public static function serialize Query Value ( $ type , $ value ) { switch ( $ type ) { case Edm Type : : DATETIME : $ edm Date = Utilities : : convert To Edm Date Time ( $ value ) ; return 'datetime \ ' ' . $ edm Date . ' \ ' ' ; case Edm Type : : BINARY : return 'X \ ' ' . implode ( ' ' , unpack ( "H * " , $ value ) ) . ' \ ' ' ; case Edm Type : : BOOLEAN : return ( $ value ? 'true ' : 'false ' ) ; case Edm Type : : DOUBLE : case Edm Type : : INT 3 2 : return $ value ; case Edm Type : : INT 6 4 : return $ value . 'L ' ; case Edm Type : : GUID : return 'guid \ ' ' . $ value . ' \ ' ' ; case null : case Edm Type : : STRING : 
public static function unserialize Query Value ( $ type , $ value ) { 
public static function is Valid ( $ type ) { switch ( $ type ) { case $ type = = self : : DATETIME : case $ type = = self : : BINARY : case $ type = = self : : BOOLEAN : case $ type = = self : : DOUBLE : case $ type = = self : : GUID : case $ type = = self : : INT 3 2 : case $ type = = self : : INT 6 4 : case $ type = = self : : STRING : case $ type = = null : 
public static function create ( array $ parsed Response ) { $ result = new Service Properties ( ) ; if ( array _key _exists ( Resources : : XTAG _DEFAULT _SERVICE _VERSION , $ parsed Response ) & & $ parsed Response [ Resources : : XTAG _DEFAULT _SERVICE _VERSION ] ! = null ) { $ result - > set Default Service Version ( $ parsed Response [ Resources : : XTAG _DEFAULT _SERVICE _VERSION ] ) ; } if ( array _key _exists ( Resources : : XTAG _LOGGING , $ parsed Response ) ) { $ result - > set Logging ( Logging : : create ( $ parsed Response [ Resources : : XTAG _LOGGING ] ) ) ; } $ result - > set Hour Metrics ( Metrics : : create ( $ parsed Response [ Resources : : XTAG _HOUR _METRICS ] ) ) ; if ( array _key _exists ( Resources : : XTAG _MINUTE _METRICS , $ parsed Response ) ) { $ result - > set Minute Metrics ( Metrics : : create ( $ parsed Response [ Resources : : XTAG _MINUTE _METRICS ] ) ) ; } if ( array _key _exists ( Resources : : XTAG _CORS , $ parsed Response ) & & $ parsed Response [ Resources : : XTAG _CORS ] ! = null ) { 
public function to Array ( ) { $ result = array ( ) ; if ( ! empty ( $ this - > get Logging ( ) ) ) { $ result [ Resources : : XTAG _LOGGING ] = $ this - > get Logging ( ) - > to Array ( ) ; } if ( ! empty ( $ this - > get Hour Metrics ( ) ) ) { $ result [ Resources : : XTAG _HOUR _METRICS ] = $ this - > get Hour Metrics ( ) - > to Array ( ) ; } if ( ! empty ( $ this - > get Minute Metrics ( ) ) ) { $ result [ Resources : : XTAG _MINUTE _METRICS ] = $ this - > get Minute Metrics ( ) - > to Array ( ) ; } $ corses Array = $ this - > get Corses Array ( ) ; if ( ! empty ( $ corses Array ) ) { $ result [ Resources : : XTAG _CORS ] = $ corses Array ; } if ( $ this - > default Service Version ! = null ) { $ result [ Resources : : XTAG _DEFAULT _SERVICE _VERSION ] = $ this - > default Service Version ; } return $ result ; } 
private function get Corses Array ( ) { $ corses Array = array ( ) ; if ( count ( $ this - > get Corses ( ) ) = = 1 ) { $ corses Array = array ( Resources : : XTAG _CORS _RULE = > $ this - > get Corses ( ) [ 0 ] - > to Array ( ) ) ; } elseif ( $ this - > get Corses ( ) ! = array ( ) ) { foreach ( $ this - > get Corses ( ) as $ cors ) { $ corses Array [ ] = [ Resources : : XTAG _CORS _RULE = > $ cors - > to Array ( ) ] ; } } return $ corses Array ; } 
public function to Xml ( Xml Serializer $ xml Serializer ) { $ properties = array ( Xml Serializer : : ROOT _NAME = > self : : $ xml Root Name ) ; return $ xml Serializer - > serialize ( $ this - > to Array ( ) , $ properties ) ; } 
private static function _init ( ) { if ( ! self : : $ _is Initialized ) { self : : $ _default Sources = array ( self : : ENVIRONMENT _SOURCE = > array ( _ _CLASS _ _ , 'environment Source ' ) ) ; self : : $ _is Initialized = true ; } } 
public function parse Table Entries ( $ body ) { $ tables = array ( ) ; $ result = json _decode ( $ body , true ) ; $ raw Entries = $ result [ Resources : : JSON _VALUE ] ; foreach ( $ raw Entries as $ entry ) { $ tables [ ] = $ entry [ Resources : : JSON _TABLE _NAME ] ; } return $ tables ; } 
public function get Entity ( Entity $ entity ) { $ entity Properties = $ entity - > get Properties ( ) ; $ properties = array ( ) ; foreach ( $ entity Properties as $ name = > $ property ) { $ edm Type = $ property - > get Edm Type ( ) ; $ edm Value = $ property - > get Value ( ) ; if ( is _null ( $ edm Value ) ) { 
public function parse Entities ( $ body ) { $ raw Entities = json _decode ( $ body , true ) ; $ entities = array ( ) ; foreach ( $ raw Entities [ Resources : : JSON _VALUE ] as $ raw Entity ) { $ entities [ ] = $ this - > parse One Entity ( $ raw Entity ) ; } return $ entities ; } 
public static function is Valid ( $ param Name ) { switch ( $ param Name ) { case self : : BP _TABLE : case self : : BP _ENTITY : case self : : BP _PARTITION _KEY : case self : : BP _ROW _KEY : case self : : BP _ETAG : return true ; default : return false ; } } 
public function set Start ( \ Date Time $ start = null ) { if ( $ start ! = null ) { Validate : : is Date ( $ start ) ; } $ this - > start = $ start ; } 
private function validate Permission ( $ permission ) { $ valid Permissions = static : : get Resource Valid Permissions ( ) ; $ result = ' ' ; foreach ( $ valid Permissions as $ valid Permission ) { if ( strpos ( $ permission , $ valid Permission ) ! = = false ) { 
public function to Array ( ) { $ array = array ( ) ; if ( $ this - > get Start ( ) ! = null ) { $ array [ Resources : : XTAG _SIGNED _START ] = Utilities : : convert To Edm Date Time ( $ this - > get Start ( ) ) ; } $ array [ Resources : : XTAG _SIGNED _EXPIRY ] = Utilities : : convert To Edm Date Time ( $ this - > get Expiry ( ) ) ; $ array [ Resources : : XTAG _SIGNED _PERMISSION ] = $ this - > get Permission ( ) ; return $ array ; } 
public static function is Valid ( $ type ) { switch ( $ type ) { case self : : INSERT _ENTITY _OPERATION : case self : : UPDATE _ENTITY _OPERATION : case self : : DELETE _ENTITY _OPERATION : case self : : MERGE _ENTITY _OPERATION : case self : : INSERT _REPLACE _ENTITY _OPERATION : case self : : INSERT _MERGE _ENTITY _OPERATION : return true ; default : return false ; } } 
public static function create File Service ( $ connection String , array $ options = [ ] ) { $ settings = Storage Service Settings : : create From Connection String ( $ connection String ) ; $ primary Uri = Utilities : : try Add Url Scheme ( $ settings - > get File Endpoint Uri ( ) ) ; $ secondary Uri = Utilities : : try Add Url Scheme ( $ settings - > get File Secondary Endpoint Uri ( ) ) ; $ file Wrapper = new File Rest Proxy ( $ primary Uri , $ secondary Uri , $ settings - > get Name ( ) , $ options ) ; 
private function create Path ( $ share , $ directory = ' ' ) { if ( empty ( $ directory ) & & ( $ directory ! = ' 0 ' ) ) { return empty ( $ share ) ? ' / ' : $ share ; } $ encoded File = urlencode ( $ directory ) ; 
private function get Share Properties Async Impl ( $ share , File Service Options $ options = null , $ operation = null ) { Validate : : can Cast As String ( $ share , 'share ' ) ; Validate : : is True ( $ operation = = 'properties ' | | $ operation = = 'metadata ' , Resources : : FILE _SHARE _PROPERTIES _OPERATION _INVALID ) ; $ method = Resources : : HTTP _GET ; $ headers = array ( ) ; $ query Params = array ( ) ; $ post Params = array ( ) ; $ path = $ this - > create Path ( $ share ) ; if ( is _null ( $ options ) ) { $ options = new File Service Options ( ) ; } $ this - > add Optional Query Param ( $ query Params , Resources : : QP _REST _TYPE , 'share ' ) ; $ this - > add Optional Query Param ( $ query Params , Resources : : QP _TIMEOUT , $ options - > get Timeout ( ) ) ; if ( $ operation = = 'metadata ' ) { $ this - > add Optional Query Param ( $ query Params , Resources : : QP _COMP , $ operation ) ; } return $ this - > send Async ( $ method , $ headers , $ query Params , $ post Params , $ path , Resources : : STATUS _OK , Resources : : EMPTY _STRING , $ options ) - > then ( function ( $ response ) { $ response Headers = Http Formatter : : format Headers ( $ response - > get Headers ( ) ) ; return Get Share Properties Result : : create ( $ response Headers ) ; } , null ) ; } 
private function set Share Properties Async Impl ( $ share , array $ properties , File Service Options $ options = null , $ operation = 'properties ' ) { Validate : : can Cast As String ( $ share , 'share ' ) ; Validate : : is True ( $ operation = = 'properties ' | | $ operation = = 'metadata ' , Resources : : FILE _SHARE _PROPERTIES _OPERATION _INVALID ) ; Validate : : can Cast As String ( $ share , 'share ' ) ; $ headers = array ( ) ; if ( $ operation = = 'properties ' ) { $ headers [ Resources : : X _MS _SHARE _QUOTA ] = $ properties [ Resources : : X _MS _SHARE _QUOTA ] ; } else { Utilities : : validate Metadata ( $ properties ) ; $ headers = $ this - > generate Metadata Headers ( $ properties ) ; } $ method = Resources : : HTTP _PUT ; $ post Params = array ( ) ; $ query Params = array ( ) ; $ path = $ this - > create Path ( $ share ) ; if ( is _null ( $ options ) ) { $ options = new File Service Options ( ) ; } $ this - > add Optional Query Param ( $ query Params , Resources : : QP _TIMEOUT , $ options - > get Timeout ( ) ) ; $ this - > add Optional Query Param ( $ query Params , Resources : : QP _REST _TYPE , 'share ' ) ; $ this - > add Optional Query Param ( $ query Params , Resources : : QP _COMP , $ operation ) ; return $ this - > send Async ( $ method , $ headers , $ query Params , $ post Params , $ path , Resources : : STATUS _OK , Resources : : EMPTY _STRING , $ options ) ; } 
private function multiple Put Range Concurrent Async ( $ share , $ path , $ content , Range $ range , Put File Range Options $ options = null , $ use Transactional MD 5 = false ) { $ query Params = array ( ) ; $ headers = array ( ) ; $ path = $ this - > create Path ( $ share , $ path ) ; $ self Instance = $ this ; if ( $ options = = null ) { $ options = new Put File Range Options ( ) ; } $ this - > add Optional Query Param ( $ query Params , Resources : : QP _COMP , 'range ' ) ; $ this - > add Optional Query Param ( $ query Params , Resources : : QP _TIMEOUT , $ options - > get Timeout ( ) ) ; $ this - > add Optional Header ( $ headers , Resources : : X _MS _WRITE , 'Update ' ) ; $ counter = 0 ; 
public function list Shares Async ( List Shares Options $ options = null ) { $ method = Resources : : HTTP _GET ; $ headers = array ( ) ; $ query Params = array ( ) ; $ post Params = array ( ) ; $ path = Resources : : EMPTY _STRING ; if ( is _null ( $ options ) ) { $ options = new List Shares Options ( ) ; } $ this - > add Optional Query Param ( $ query Params , Resources : : QP _COMP , 'list ' ) ; $ this - > add Optional Query Param ( $ query Params , Resources : : QP _TIMEOUT , $ options - > get Timeout ( ) ) ; $ this - > add Optional Query Param ( $ query Params , Resources : : QP _PREFIX , $ options - > get Prefix ( ) ) ; $ this - > add Optional Query Param ( $ query Params , Resources : : QP _MARKER , $ options - > get Next Marker ( ) ) ; $ this - > add Optional Query Param ( $ query Params , Resources : : QP _MAX _RESULTS , $ options - > get Max Results ( ) ) ; $ is Include = $ options - > get Include Metadata ( ) ; $ is Include = $ is Include ? 'metadata ' : null ; $ this - > add Optional Query Param ( $ query Params , Resources : : QP _INCLUDE , $ is Include ) ; $ data Serializer = $ this - > data Serializer ; return $ this - > send Async ( $ method , $ headers , $ query Params , $ post Params , $ path , Resources : : STATUS _OK , Resources : : EMPTY _STRING , $ options ) - > then ( function ( $ response ) use ( $ data Serializer ) { $ parsed = $ data Serializer - > unserialize ( $ response - > get Body ( ) ) ; return List Shares Result : : create ( $ parsed , Utilities : : get Location From Headers ( $ response - > get Headers ( ) ) ) ; } ) ; } 
public function create Share ( $ share , Create Share Options $ options = null ) { $ this - > create Share Async ( $ share , $ options ) - > wait ( ) ; } 
public function create Share Async ( $ share , Create Share Options $ options = null ) { Validate : : can Cast As String ( $ share , 'share ' ) ; Validate : : not Null Or Empty ( $ share , 'share ' ) ; $ method = Resources : : HTTP _PUT ; $ post Params = array ( ) ; $ query Params = array ( Resources : : QP _REST _TYPE = > 'share ' ) ; $ path = $ this - > create Path ( $ share ) ; if ( is _null ( $ options ) ) { $ options = new Create Share Options ( ) ; } $ metadata = $ options - > get Metadata ( ) ; $ headers = $ this - > generate Metadata Headers ( $ metadata ) ; $ this - > add Optional Header ( $ headers , Resources : : X _MS _SHARE _QUOTA , $ options - > get Quota ( ) ) ; $ this - > add Optional Query Param ( $ query Params , Resources : : QP _TIMEOUT , $ options - > get Timeout ( ) ) ; return $ this - > send Async ( $ method , $ headers , $ query Params , $ post Params , $ path , Resources : : STATUS _CREATED , Resources : : EMPTY _STRING , $ options ) ; } 
public function delete Share ( $ share , File Service Options $ options = null ) { $ this - > delete Share Async ( $ share , $ options ) - > wait ( ) ; } 
public function get Share Properties ( $ share , File Service Options $ options = null ) { return $ this - > get Share Properties Async ( $ share , $ options ) - > wait ( ) ; } 
public function set Share Properties ( $ share , $ quota , File Service Options $ options = null ) { $ this - > set Share Properties Async ( $ share , $ quota , $ options ) - > wait ( ) ; } 
public function set Share Properties Async ( $ share , $ quota , File Service Options $ options = null ) { return $ this - > set Share Properties Async Impl ( $ share , [ Resources : : X _MS _SHARE _QUOTA = > $ quota ] , $ options , 'properties ' ) ; } 
public function get Share Metadata ( $ share , File Service Options $ options = null ) { return $ this - > get Share Metadata Async ( $ share , $ options ) - > wait ( ) ; } 
public function set Share Metadata ( $ share , array $ metadata , File Service Options $ options = null ) { $ this - > set Share Metadata Async ( $ share , $ metadata , $ options ) - > wait ( ) ; } 
public function set Share Metadata Async ( $ share , array $ metadata , File Service Options $ options = null ) { return $ this - > set Share Properties Async Impl ( $ share , $ metadata , $ options , 'metadata ' ) ; } 
public function get Share Acl ( $ share , File Service Options $ options = null ) { return $ this - > get Share Acl Async ( $ share , $ options ) - > wait ( ) ; } 
public function get Share Acl Async ( $ share , File Service Options $ options = null ) { Validate : : can Cast As String ( $ share , 'share ' ) ; $ method = Resources : : HTTP _GET ; $ headers = array ( ) ; $ post Params = array ( ) ; $ query Params = array ( ) ; $ path = $ this - > create Path ( $ share ) ; if ( is _null ( $ options ) ) { $ options = new File Service Options ( ) ; } $ this - > add Optional Query Param ( $ query Params , Resources : : QP _REST _TYPE , 'share ' ) ; $ this - > add Optional Query Param ( $ query Params , Resources : : QP _COMP , 'acl ' ) ; $ this - > add Optional Query Param ( $ query Params , Resources : : QP _TIMEOUT , $ options - > get Timeout ( ) ) ; $ data Serializer = $ this - > data Serializer ; $ promise = $ this - > send Async ( $ method , $ headers , $ query Params , $ post Params , $ path , Resources : : STATUS _OK , Resources : : EMPTY _STRING , $ options ) ; return $ promise - > then ( function ( $ response ) use ( $ data Serializer ) { $ response Headers = Http Formatter : : format Headers ( $ response - > get Headers ( ) ) ; $ etag = Utilities : : try Get Value ( $ response Headers , Resources : : ETAG ) ; $ modified = Utilities : : try Get Value ( $ response Headers , Resources : : LAST _MODIFIED ) ; $ modified Date = Utilities : : convert To Date Time ( $ modified ) ; $ parsed = $ data Serializer - > unserialize ( $ response - > get Body ( ) ) ; return Get Share Acl Result : : create ( $ etag , $ modified Date , $ parsed ) ; } , null ) ; } 
public function set Share Acl ( $ share , Share ACL $ acl , File Service Options $ options = null ) { $ this - > set Share Acl Async ( $ share , $ acl , $ options ) - > wait ( ) ; } 
public function set Share Acl Async ( $ share , Share ACL $ acl , File Service Options $ options = null ) { Validate : : can Cast As String ( $ share , 'share ' ) ; Validate : : not Null Or Empty ( $ acl , 'acl ' ) ; $ method = Resources : : HTTP _PUT ; $ headers = array ( ) ; $ post Params = array ( ) ; $ query Params = array ( ) ; $ path = $ this - > create Path ( $ share ) ; $ body = $ acl - > to Xml ( $ this - > data Serializer ) ; if ( is _null ( $ options ) ) { $ options = new File Service Options ( ) ; } $ this - > add Optional Query Param ( $ query Params , Resources : : QP _REST _TYPE , 'share ' ) ; $ this - > add Optional Query Param ( $ query Params , Resources : : QP _COMP , 'acl ' ) ; $ this - > add Optional Query Param ( $ query Params , Resources : : QP _TIMEOUT , $ options - > get Timeout ( ) ) ; $ this - > add Optional Header ( $ headers , Resources : : CONTENT _TYPE , Resources : : URL _ENCODED _CONTENT _TYPE ) ; return $ this - > send Async ( $ method , $ headers , $ query Params , $ post Params , $ path , Resources : : STATUS _OK , $ body , $ options ) ; } 
public function get Share Stats ( $ share , File Service Options $ options = null ) { return $ this - > get Share Stats Async ( $ share , $ options ) - > wait ( ) ; } 
public function get Share Stats Async ( $ share , File Service Options $ options = null ) { Validate : : can Cast As String ( $ share , 'share ' ) ; $ method = Resources : : HTTP _GET ; $ headers = array ( ) ; $ query Params = array ( ) ; $ post Params = array ( ) ; $ path = $ this - > create Path ( $ share ) ; if ( is _null ( $ options ) ) { $ options = new File Service Options ( ) ; } $ this - > add Optional Query Param ( $ query Params , Resources : : QP _REST _TYPE , 'share ' ) ; $ this - > add Optional Query Param ( $ query Params , Resources : : QP _COMP , 'stats ' ) ; $ this - > add Optional Query Param ( $ query Params , Resources : : QP _TIMEOUT , $ options - > get Timeout ( ) ) ; $ data Serializer = $ this - > data Serializer ; return $ this - > send Async ( $ method , $ headers , $ query Params , $ post Params , $ path , Resources : : STATUS _OK , Resources : : EMPTY _STRING , $ options ) - > then ( function ( $ response ) use ( $ data Serializer ) { $ parsed = $ data Serializer - > unserialize ( $ response - > get Body ( ) ) ; return Get Share Stats Result : : create ( $ parsed ) ; } , null ) ; } 
public function list Directories And Files ( $ share , $ path = ' ' , List Directories And Files Options $ options = null ) { return $ this - > list Directories And Files Async ( $ share , $ path , $ options ) - > wait ( ) ; } 
public function list Directories And Files Async ( $ share , $ path = ' ' , List Directories And Files Options $ options = null ) { Validate : : not Null ( $ share , 'share ' ) ; Validate : : can Cast As String ( $ share , 'share ' ) ; Validate : : can Cast As String ( $ path , 'path ' ) ; $ method = Resources : : HTTP _GET ; $ headers = array ( ) ; $ post Params = array ( ) ; $ query Params = array ( ) ; $ path = $ this - > create Path ( $ share , $ path ) ; if ( is _null ( $ options ) ) { $ options = new List Directories And Files Options ( ) ; } $ this - > add Optional Query Param ( $ query Params , Resources : : QP _REST _TYPE , 'directory ' ) ; $ this - > add Optional Query Param ( $ query Params , Resources : : QP _COMP , 'list ' ) ; $ this - > add Optional Query Param ( $ query Params , Resources : : QP _PREFIX , $ options - > get Prefix ( ) ) ; $ this - > add Optional Query Param ( $ query Params , Resources : : QP _MARKER , $ options - > get Next Marker ( ) ) ; $ this - > add Optional Query Param ( $ query Params , Resources : : QP _MAX _RESULTS , $ options - > get Max Results ( ) ) ; $ this - > add Optional Query Param ( $ query Params , Resources : : QP _TIMEOUT , $ options - > get Timeout ( ) ) ; $ data Serializer = $ this - > data Serializer ; return $ this - > send Async ( $ method , $ headers , $ query Params , $ post Params , $ path , Resources : : STATUS _OK , Resources : : EMPTY _STRING , $ options ) - > then ( function ( $ response ) use ( $ data Serializer ) { $ parsed = $ data Serializer - > unserialize ( $ response - > get Body ( ) ) ; return List Directories And Files Result : : create ( $ parsed , Utilities : : get Location From Headers ( $ response - > get Headers ( ) ) ) ; } , null ) ; } 
public function create Directory ( $ share , $ path , Create Directory Options $ options = null ) { $ this - > create Directory Async ( $ share , $ path , $ options ) - > wait ( ) ; } 
public function create Directory Async ( $ share , $ path , Create Directory Options $ options = null ) { Validate : : can Cast As String ( $ share , 'share ' ) ; Validate : : can Cast As String ( $ path , 'path ' ) ; Validate : : not Null Or Empty ( $ path , 'path ' ) ; $ method = Resources : : HTTP _PUT ; $ post Params = array ( ) ; $ query Params = array ( Resources : : QP _REST _TYPE = > 'directory ' ) ; $ path = $ this - > create Path ( $ share , $ path ) ; if ( is _null ( $ options ) ) { $ options = new Create Directory Options ( ) ; } $ this - > add Optional Query Param ( $ query Params , Resources : : QP _TIMEOUT , $ options - > get Timeout ( ) ) ; $ metadata = $ options - > get Metadata ( ) ; $ headers = $ this - > generate Metadata Headers ( $ metadata ) ; return $ this - > send Async ( $ method , $ headers , $ query Params , $ post Params , $ path , Resources : : STATUS _CREATED , Resources : : EMPTY _STRING , $ options ) ; } 
public function delete Directory ( $ share , $ path , File Service Options $ options = null ) { $ this - > delete Directory Async ( $ share , $ path , $ options ) - > wait ( ) ; } 
public function get Directory Properties ( $ share , $ path , File Service Options $ options = null ) { return $ this - > get Directory Properties Async ( $ share , $ path , $ options ) - > wait ( ) ; } 
public function get Directory Properties Async ( $ share , $ path , File Service Options $ options = null ) { Validate : : can Cast As String ( $ share , 'share ' ) ; Validate : : can Cast As String ( $ path , 'path ' ) ; $ method = Resources : : HTTP _GET ; $ headers = array ( ) ; $ post Params = array ( ) ; $ query Params = array ( Resources : : QP _REST _TYPE = > 'directory ' ) ; $ path = $ this - > create Path ( $ share , $ path ) ; if ( is _null ( $ options ) ) { $ options = new File Service Options ( ) ; } $ this - > add Optional Query Param ( $ query Params , Resources : : QP _TIMEOUT , $ options - > get Timeout ( ) ) ; return $ this - > send Async ( $ method , $ headers , $ query Params , $ post Params , $ path , Resources : : STATUS _OK , Resources : : EMPTY _STRING , $ options ) - > then ( function ( $ response ) { $ parsed = Http Formatter : : format Headers ( $ response - > get Headers ( ) ) ; return Get Directory Properties Result : : create ( $ parsed ) ; } , null ) ; } 
public function get Directory Metadata ( $ share , $ path , File Service Options $ options = null ) { return $ this - > get Directory Metadata Async ( $ share , $ path , $ options ) - > wait ( ) ; } 
public function set Directory Metadata ( $ share , $ path , array $ metadata , File Service Options $ options = null ) { $ this - > set Directory Metadata Async ( $ share , $ path , $ metadata , $ options ) - > wait ( ) ; } 
public function create File ( $ share , $ path , $ size , Create File Options $ options = null ) { return $ this - > create File Async ( $ share , $ path , $ size , $ options ) - > wait ( ) ; } 
public function create File Async ( $ share , $ path , $ size , Create File Options $ options = null ) { Validate : : can Cast As String ( $ share , 'share ' ) ; Validate : : not Null Or Empty ( $ share , 'share ' ) ; Validate : : can Cast As String ( $ path , 'path ' ) ; Validate : : not Null Or Empty ( $ path , 'path ' ) ; Validate : : is Integer ( $ size , 'size ' ) ; $ method = Resources : : HTTP _PUT ; $ post Params = array ( ) ; $ query Params = array ( ) ; $ path = $ this - > create Path ( $ share , $ path ) ; if ( is _null ( $ options ) ) { $ options = new Create File Options ( ) ; } Utilities : : validate Metadata ( $ options - > get Metadata ( ) ) ; $ headers = $ this - > generate Metadata Headers ( $ options - > get Metadata ( ) ) ; $ this - > add Optional Header ( $ headers , Resources : : X _MS _TYPE , 'file ' ) ; $ this - > add Optional Query Param ( $ query Params , Resources : : QP _TIMEOUT , $ options - > get Timeout ( ) ) ; $ this - > add Optional Header ( $ headers , Resources : : X _MS _CONTENT _LENGTH , $ size ) ; $ this - > add Optional Header ( $ headers , Resources : : CONTENT _TYPE , $ options - > get Content Type ( ) ) ; $ this - > add Optional Header ( $ headers , Resources : : CONTENT _ENCODING , $ options - > get Content Encoding ( ) ) ; $ this - > add Optional Header ( $ headers , Resources : : CONTENT _LANGUAGE , $ options - > get Content Language ( ) ) ; $ this - > add Optional Header ( $ headers , Resources : : CACHE _CONTROL , $ options - > get Cache Control ( ) ) ; $ this - > add Optional Header ( $ headers , Resources : : FILE _CONTENT _MD 5 , $ options - > get Content MD 5 ( ) ) ; $ this - > add Optional Header ( $ headers , Resources : : CONTENT _DISPOSITION , $ options - > get Content Disposition ( ) ) ; $ this - > add Optional Header ( $ headers , Resources : : CONTENT _DISPOSITION , $ options - > get Content Disposition ( ) ) ; return $ this - > send Async ( $ method , $ headers , $ query Params , $ post Params , $ path , Resources : : STATUS _CREATED , Resources : : EMPTY _STRING , $ options ) ; } 
public function delete File ( $ share , $ path , File Service Options $ options = null ) { $ this - > delete File Async ( $ share , $ path , $ options ) - > wait ( ) ; } 
public function delete File Async ( $ share , $ path , File Service Options $ options = null ) { Validate : : can Cast As String ( $ share , 'share ' ) ; Validate : : can Cast As String ( $ path , 'path ' ) ; $ method = Resources : : HTTP _DELETE ; $ headers = array ( ) ; $ post Params = array ( ) ; $ query Params = array ( ) ; $ path = $ this - > create Path ( $ share , $ path ) ; if ( is _null ( $ options ) ) { $ options = new File Service Options ( ) ; } $ this - > add Optional Query Param ( $ query Params , Resources : : QP _TIMEOUT , $ options - > get Timeout ( ) ) ; return $ this - > send Async ( $ method , $ headers , $ query Params , $ post Params , $ path , Resources : : STATUS _ACCEPTED , Resources : : EMPTY _STRING , $ options ) ; } 
public function get File ( $ share , $ path , Get File Options $ options = null ) { return $ this - > get File Async ( $ share , $ path , $ options ) - > wait ( ) ; } 
public function get File Async ( $ share , $ path , Get File Options $ options = null ) { Validate : : can Cast As String ( $ share , 'share ' ) ; Validate : : can Cast As String ( $ path , 'path ' ) ; $ method = Resources : : HTTP _GET ; $ headers = array ( ) ; $ post Params = array ( ) ; $ query Params = array ( ) ; $ path = $ this - > create Path ( $ share , $ path ) ; if ( is _null ( $ options ) ) { $ options = new Get File Options ( ) ; } $ this - > add Optional Query Param ( $ query Params , Resources : : QP _TIMEOUT , $ options - > get Timeout ( ) ) ; $ this - > add Optional Header ( $ headers , Resources : : X _MS _RANGE , $ options - > get Range String ( ) = = ' ' ? null : $ options - > get Range String ( ) ) ; $ this - > add Optional Header ( $ headers , Resources : : X _MS _RANGE _GET _CONTENT _MD 5 , $ options - > get Range Get Content MD 5 ( ) ? 'true ' : null ) ; $ options - > set Is Streaming ( true ) ; return $ this - > send Async ( $ method , $ headers , $ query Params , $ post Params , $ path , array ( Resources : : STATUS _OK , Resources : : STATUS _PARTIAL _CONTENT ) , Resources : : EMPTY _STRING , $ options ) - > then ( function ( $ response ) { $ metadata = Utilities : : get Metadata Array ( Http Formatter : : format Headers ( $ response - > get Headers ( ) ) ) ; return Get File Result : : create ( Http Formatter : : format Headers ( $ response - > get Headers ( ) ) , $ response - > get Body ( ) , $ metadata ) ; } ) ; } 
public function get File Properties ( $ share , $ path , File Service Options $ options = null ) { return $ this - > get File Properties Async ( $ share , $ path , $ options ) - > wait ( ) ; } 
public function get File Properties Async ( $ share , $ path , File Service Options $ options = null ) { Validate : : can Cast As String ( $ share , 'share ' ) ; Validate : : can Cast As String ( $ path , 'path ' ) ; $ method = Resources : : HTTP _HEAD ; $ headers = array ( ) ; $ query Params = array ( ) ; $ post Params = array ( ) ; $ path = $ this - > create Path ( $ share , $ path ) ; if ( is _null ( $ options ) ) { $ options = new File Service Options ( ) ; } $ this - > add Optional Query Param ( $ query Params , Resources : : QP _TIMEOUT , $ options - > get Timeout ( ) ) ; return $ this - > send Async ( $ method , $ headers , $ query Params , $ post Params , $ path , Resources : : STATUS _OK , Resources : : EMPTY _STRING , $ options ) - > then ( function ( $ response ) { $ parsed = Http Formatter : : format Headers ( $ response - > get Headers ( ) ) ; return File Properties : : create From Http Headers ( $ parsed ) ; } , null ) ; } 
public function set File Properties ( $ share , $ path , File Properties $ properties , File Service Options $ options = null ) { $ this - > set File Properties Async ( $ share , $ path , $ properties , $ options ) - > wait ( ) ; } 
public function set File Properties Async ( $ share , $ path , File Properties $ properties , File Service Options $ options = null ) { Validate : : can Cast As String ( $ share , 'share ' ) ; Validate : : can Cast As String ( $ path , 'path ' ) ; $ headers = array ( ) ; $ method = Resources : : HTTP _PUT ; $ post Params = array ( ) ; $ query Params = array ( Resources : : QP _COMP = > 'properties ' ) ; $ path = $ this - > create Path ( $ share , $ path ) ; if ( is _null ( $ options ) ) { $ options = new File Service Options ( ) ; } $ this - > add Optional Query Param ( $ query Params , Resources : : QP _TIMEOUT , $ options - > get Timeout ( ) ) ; $ this - > add Optional Header ( $ headers , Resources : : X _MS _CACHE _CONTROL , $ properties - > get Cache Control ( ) ) ; $ this - > add Optional Header ( $ headers , Resources : : X _MS _CONTENT _TYPE , $ properties - > get Content Type ( ) ) ; $ this - > add Optional Header ( $ headers , Resources : : X _MS _CONTENT _MD 5 , $ properties - > get Content MD 5 ( ) ) ; $ this - > add Optional Header ( $ headers , Resources : : X _MS _CONTENT _ENCODING , $ properties - > get Content Encoding ( ) ) ; $ this - > add Optional Header ( $ headers , Resources : : X _MS _CONTENT _LANGUAGE , $ properties - > get Content Language ( ) ) ; $ this - > add Optional Header ( $ headers , Resources : : X _MS _CONTENT _DISPOSITION , $ properties - > get Content Disposition ( ) ) ; $ this - > add Optional Header ( $ headers , Resources : : X _MS _CONTENT _LENGTH , $ properties - > get Content Length ( ) ) ; return $ this - > send Async ( $ method , $ headers , $ query Params , $ post Params , $ path , Resources : : STATUS _OK , Resources : : EMPTY _STRING , $ options ) ; } 
public function get File Metadata ( $ share , $ path , File Service Options $ options = null ) { return $ this - > get File Metadata Async ( $ share , $ path , $ options ) - > wait ( ) ; } 
public function set File Metadata ( $ share , $ path , array $ metadata , File Service Options $ options = null ) { return $ this - > set File Metadata Async ( $ share , $ path , $ metadata , $ options ) - > wait ( ) ; } 
public function set File Metadata Async ( $ share , $ path , array $ metadata , File Service Options $ options = null ) { Validate : : can Cast As String ( $ share , 'share ' ) ; Validate : : can Cast As String ( $ path , 'path ' ) ; $ method = Resources : : HTTP _PUT ; $ post Params = array ( ) ; $ query Params = array ( ) ; $ path = $ this - > create Path ( $ share , $ path ) ; Utilities : : validate Metadata ( $ metadata ) ; $ headers = $ this - > generate Metadata Headers ( $ metadata ) ; if ( is _null ( $ options ) ) { $ options = new File Service Options ( ) ; } $ this - > add Optional Query Param ( $ query Params , Resources : : QP _COMP , 'metadata ' ) ; $ this - > add Optional Query Param ( $ query Params , Resources : : QP _TIMEOUT , $ options - > get Timeout ( ) ) ; return $ this - > send Async ( $ method , $ headers , $ query Params , $ post Params , $ path , Resources : : STATUS _OK , Resources : : EMPTY _STRING , $ options ) ; } 
public function put File Range ( $ share , $ path , $ content , Range $ range , Put File Range Options $ options = null ) { $ this - > put File Range Async ( $ share , $ path , $ content , $ range , $ options ) - > wait ( ) ; } 
public function put File Range Async ( $ share , $ path , $ content , Range $ range , Put File Range Options $ options = null ) { Validate : : can Cast As String ( $ share , 'share ' ) ; Validate : : can Cast As String ( $ path , 'path ' ) ; Validate : : not Null Or Empty ( $ path , 'path ' ) ; Validate : : not Null Or Empty ( $ share , 'share ' ) ; Validate : : not Null ( $ range - > get Length ( ) , Resources : : RESOURCE _RANGE _LENGTH _MUST _SET ) ; $ stream = Psr 7 \ stream _for ( $ content ) ; $ method = Resources : : HTTP _PUT ; $ headers = array ( ) ; $ query Params = array ( ) ; $ post Params = array ( ) ; $ path = $ this - > create Path ( $ share , $ path ) ; if ( $ options = = null ) { $ options = new Put File Range Options ( ) ; } $ this - > add Optional Query Param ( $ query Params , Resources : : QP _TIMEOUT , $ options - > get Timeout ( ) ) ; $ this - > add Optional Header ( $ headers , Resources : : X _MS _RANGE , $ range - > get Range String ( ) ) ; $ this - > add Optional Header ( $ headers , Resources : : CONTENT _LENGTH , $ range - > get Length ( ) ) ; $ this - > add Optional Header ( $ headers , Resources : : X _MS _WRITE , 'Update ' ) ; $ this - > add Optional Header ( $ headers , Resources : : CONTENT _MD 5 , $ options - > get Content MD 5 ( ) ) ; $ this - > add Optional Query Param ( $ query Params , Resources : : QP _COMP , 'range ' ) ; return $ this - > send Async ( $ method , $ headers , $ query Params , $ post Params , $ path , Resources : : STATUS _CREATED , $ stream , $ options ) ; } 
public function create File From Content ( $ share , $ path , $ content , Create File From Content Options $ options = null ) { $ this - > create File From Content Async ( $ share , $ path , $ content , $ options ) - > wait ( ) ; } 
public function create File From Content Async ( $ share , $ path , $ content , Create File From Content Options $ options = null ) { $ stream = Psr 7 \ stream _for ( $ content ) ; $ size = $ stream - > get Size ( ) ; if ( $ options = = null ) { $ options = new Create File From Content Options ( ) ; } 
public function clear File Range ( $ share , $ path , Range $ range , File Service Options $ options = null ) { $ this - > clear File Range Async ( $ share , $ path , $ range , $ options ) - > wait ( ) ; } 
public function clear File Range Async ( $ share , $ path , Range $ range , File Service Options $ options = null ) { Validate : : can Cast As String ( $ share , 'share ' ) ; Validate : : can Cast As String ( $ path , 'path ' ) ; Validate : : not Null Or Empty ( $ path , 'path ' ) ; Validate : : not Null Or Empty ( $ share , 'share ' ) ; $ method = Resources : : HTTP _PUT ; $ headers = array ( ) ; $ query Params = array ( ) ; $ post Params = array ( ) ; $ path = $ this - > create Path ( $ share , $ path ) ; if ( is _null ( $ options ) ) { $ options = new File Service Options ( ) ; } $ this - > add Optional Header ( $ headers , Resources : : X _MS _RANGE , $ range - > get Range String ( ) ) ; $ this - > add Optional Query Param ( $ query Params , Resources : : QP _TIMEOUT , $ options - > get Timeout ( ) ) ; $ this - > add Optional Header ( $ headers , Resources : : X _MS _WRITE , 'Clear ' ) ; $ this - > add Optional Query Param ( $ query Params , Resources : : QP _COMP , 'range ' ) ; return $ this - > send Async ( $ method , $ headers , $ query Params , $ post Params , $ path , Resources : : STATUS _CREATED , Resources : : EMPTY _STRING , $ options ) ; } 
public function list File Range ( $ share , $ path , Range $ range = null , File Service Options $ options = null ) { return $ this - > list File Range Async ( $ share , $ path , $ range , $ options ) - > wait ( ) ; } 
public function list File Range Async ( $ share , $ path , Range $ range = null , File Service Options $ options = null ) { Validate : : can Cast As String ( $ share , 'share ' ) ; Validate : : can Cast As String ( $ path , 'path ' ) ; Validate : : not Null Or Empty ( $ path , 'path ' ) ; Validate : : not Null Or Empty ( $ share , 'share ' ) ; $ method = Resources : : HTTP _GET ; $ headers = array ( ) ; $ query Params = array ( ) ; $ post Params = array ( ) ; $ path = $ this - > create Path ( $ share , $ path ) ; if ( is _null ( $ options ) ) { $ options = new File Service Options ( ) ; } if ( $ range ! = null ) { $ this - > add Optional Header ( $ headers , Resources : : X _MS _RANGE , $ range - > get Range String ( ) ) ; } $ this - > add Optional Query Param ( $ query Params , Resources : : QP _COMP , 'rangelist ' ) ; $ this - > add Optional Query Param ( $ query Params , Resources : : QP _TIMEOUT , $ options - > get Timeout ( ) ) ; $ data Serializer = $ this - > data Serializer ; return $ this - > send Async ( $ method , $ headers , $ query Params , $ post Params , $ path , Resources : : STATUS _OK , Resources : : EMPTY _STRING , $ options ) - > then ( function ( $ response ) use ( $ data Serializer ) { $ response Headers = Http Formatter : : format Headers ( $ response - > get Headers ( ) ) ; $ parsed = $ data Serializer - > unserialize ( $ response - > get Body ( ) ) ; return List File Ranges Result : : create ( $ response Headers , $ parsed ) ; } , null ) ; } 
public function copy File ( $ share , $ path , $ source Path , array $ metadata = array ( ) , File Service Options $ options = null ) { return $ this - > copy File Async ( $ share , $ path , $ source Path , $ metadata , $ options ) - > wait ( ) ; } 
public function copy File Async ( $ share , $ path , $ source Path , array $ metadata = array ( ) , File Service Options $ options = null ) { Validate : : can Cast As String ( $ share , 'share ' ) ; Validate : : can Cast As String ( $ path , 'path ' ) ; Validate : : can Cast As String ( $ source Path , 'source Path ' ) ; Validate : : not Null Or Empty ( $ path , 'path ' ) ; Validate : : not Null Or Empty ( $ share , 'share ' ) ; Validate : : not Null Or Empty ( $ source Path , 'source Path ' ) ; $ method = Resources : : HTTP _PUT ; $ query Params = array ( ) ; $ post Params = array ( ) ; $ path = $ this - > create Path ( $ share , $ path ) ; Utilities : : validate Metadata ( $ metadata ) ; $ headers = $ this - > generate Metadata Headers ( $ metadata ) ; if ( is _null ( $ options ) ) { $ options = new File Service Options ( ) ; } $ this - > add Optional Header ( $ headers , Resources : : X _MS _COPY _SOURCE , $ source Path ) ; $ this - > add Optional Query Param ( $ query Params , Resources : : QP _TIMEOUT , $ options - > get Timeout ( ) ) ; return $ this - > send Async ( $ method , $ headers , $ query Params , $ post Params , $ path , Resources : : STATUS _ACCEPTED , Resources : : EMPTY _STRING , $ options ) - > then ( function ( $ response ) { $ headers = Http Formatter : : format Headers ( $ response - > get Headers ( ) ) ; return Copy File Result : : create ( $ headers ) ; } , null ) ; } 
public function abort Copy ( $ share , $ path , $ copy ID , File Service Options $ options = null ) { return $ this - > abort Copy Async ( $ share , $ path , $ copy ID , $ options ) - > wait ( ) ; } 
public function abort Copy Async ( $ share , $ path , $ copy ID , File Service Options $ options = null ) { Validate : : can Cast As String ( $ share , 'share ' ) ; Validate : : can Cast As String ( $ path , 'path ' ) ; Validate : : can Cast As String ( $ copy ID , 'copy ID ' ) ; Validate : : not Null Or Empty ( $ share , 'share ' ) ; Validate : : not Null Or Empty ( $ path , 'path ' ) ; Validate : : not Null Or Empty ( $ copy ID , 'copy ID ' ) ; $ method = Resources : : HTTP _PUT ; $ headers = array ( ) ; $ post Params = array ( ) ; $ query Params = array ( ) ; $ path = $ this - > create Path ( $ share , $ path ) ; if ( is _null ( $ options ) ) { $ options = new File Service Options ( ) ; } $ this - > add Optional Query Param ( $ query Params , Resources : : QP _TIMEOUT , $ options - > get Timeout ( ) ) ; $ this - > add Optional Query Param ( $ query Params , Resources : : QP _COMP , 'copy ' ) ; $ this - > add Optional Query Param ( $ query Params , Resources : : QP _COPY _ID , $ copy ID ) ; $ this - > add Optional Header ( $ headers , Resources : : X _MS _COPY _ACTION , 'abort ' ) ; return $ this - > send Async ( $ method , $ headers , $ query Params , $ post Params , $ path , Resources : : STATUS _NO _CONTENT , Resources : : EMPTY _STRING , $ options ) ; } 
public function set Type ( $ type ) { Validate : : is True ( Batch Operation Type : : is Valid ( $ type ) , Resources : : INVALID _BO _TYPE _MSG ) ; $ this - > _type = $ type ; } 
public function add Parameter ( $ name , $ value ) { Validate : : is True ( Batch Operation Parameter Name : : is Valid ( $ name ) , Resources : : INVALID _BO _PN _MSG ) ; $ this - > _params [ $ name ] = $ value ; } 
private static function _construct Responses ( $ body , IMime Reader Writer $ mime Serializer ) { $ responses = array ( ) ; $ parts = $ mime Serializer - > decode Mime Multipart ( $ body ) ; 
private static function _compare Using Content Id ( $ r 1 , $ r 2 ) { $ h 1 = array _change _key _case ( $ r 1 - > headers ) ; $ h 2 = array _change _key _case ( $ r 2 - > headers ) ; $ c 1 = Utilities : : try Get Value ( $ h 1 , Resources : : CONTENT _ID , 0 ) ; $ c 2 = Utilities : : try Get Value ( $ h 2 , Resources : : CONTENT _ID , 0 ) ; return intval ( $ c 1 ) > = intval ( $ c 2 ) ; } 
public static function create ( $ body , array $ operations , array $ contexts , IOData Reader Writer $ odata Serializer , IMime Reader Writer $ mime Serializer ) { $ result = new Batch Result ( ) ; $ responses = self : : _construct Responses ( $ body , $ mime Serializer ) ; $ callback Name = _ _CLASS _ _ . ' : : _compare Using Content Id ' ; $ count = count ( $ responses ) ; $ entries = array ( ) ; 
private function sxml 2arr ( $ sxml , array $ arr = null ) { foreach ( ( array ) $ sxml as $ key = > $ value ) { if ( is _object ( $ value ) | | ( is _array ( $ value ) ) ) { $ arr [ $ key ] = $ this - > sxml 2arr ( $ value ) ; } else { $ arr [ $ key ] = $ value ; } } return $ arr ; } 
private function arr 2xml ( \ XMLWriter $ xmlw , array $ data , $ default Tag = null ) { foreach ( $ data as $ key = > $ value ) { if ( $ key = = = Resources : : XTAG _ATTRIBUTES ) { foreach ( $ value as $ attribute Name = > $ attribute Value ) { $ xmlw - > write Attribute ( $ attribute Name , $ attribute Value ) ; } } elseif ( is _array ( $ value ) ) { if ( ! is _int ( $ key ) ) { if ( $ key ! = Resources : : EMPTY _STRING ) { $ xmlw - > start Element ( $ key ) ; } else { $ xmlw - > start Element ( $ default Tag ) ; } } $ this - > arr 2xml ( $ xmlw , $ value ) ; if ( ! is _int ( $ key ) ) { $ xmlw - > end Element ( ) ; } } else { $ xmlw - > write Element ( $ key , $ value ) ; } } } 
private static function get Instance Attributes ( $ target Object , array $ method Array ) { foreach ( $ method Array as $ method ) { if ( $ method - > name = = 'get Attributes ' ) { $ class Property = $ method - > invoke ( $ target Object ) ; return $ class Property ; } } return null ; } 
public static function object Serialize ( $ target Object , $ root Name ) { Validate : : not Null ( $ target Object , 'target Object ' ) ; Validate : : can Cast As String ( $ root Name , 'root Name ' ) ; $ xml Writer = new \ Xml Writer ( ) ; $ xml Writer - > open Memory ( ) ; $ xml Writer - > set Indent ( true ) ; $ reflection Class = new \ Reflection Class ( $ target Object ) ; $ method Array = $ reflection Class - > get Methods ( ) ; $ attributes = self : : get Instance Attributes ( $ target Object , $ method Array ) ; $ xml Writer - > start Element ( $ root Name ) ; if ( ! is _null ( $ attributes ) ) { foreach ( array _keys ( $ attributes ) as $ attribute Key ) { $ xml Writer - > write Attribute ( $ attribute Key , $ attributes [ $ attribute Key ] ) ; } } foreach ( $ method Array as $ method ) { if ( ( strpos ( $ method - > name , 'get ' ) = = = 0 ) & & $ method - > is Public ( ) & & ( $ method - > name ! = 'get Attributes ' ) ) { $ variable Name = substr ( $ method - > name , 3 ) ; $ variable Value = $ method - > invoke ( $ target Object ) ; if ( ! empty ( $ variable Value ) ) { if ( gettype ( $ variable Value ) = = = 'object ' ) { $ xml Writer - > write Raw ( Xml Serializer : : object Serialize ( $ variable Value , $ variable Name ) ) ; } else { $ xml Writer - > write Element ( $ variable Name , $ variable Value ) ; } } } } $ xml Writer - > end Element ( ) ; return $ xml Writer - > output Memory ( true ) ; } 
public function serialize ( array $ array , array $ properties = null ) { $ xml Version = ' 1 . 0 ' ; $ xml Encoding = 'UTF - 8 ' ; $ standalone = Utilities : : try Get Value ( $ properties , self : : STANDALONE ) ; $ default Tag = Utilities : : try Get Value ( $ properties , self : : DEFAULT _TAG ) ; $ root Name = Utilities : : try Get Value ( $ properties , self : : ROOT _NAME ) ; $ doc Namespace = Utilities : : try Get Value ( $ array , Resources : : XTAG _NAMESPACE , null ) ; if ( ! is _array ( $ array ) ) { return false ; } $ xmlw = new \ Xml Writer ( ) ; $ xmlw - > open Memory ( ) ; $ xmlw - > set Indent ( true ) ; $ xmlw - > start Document ( $ xml Version , $ xml Encoding , $ standalone ) ; if ( is _null ( $ doc Namespace ) ) { $ xmlw - > start Element ( $ root Name ) ; } else { foreach ( $ doc Namespace as $ uri = > $ prefix ) { $ xmlw - > start Element NS ( $ prefix , $ root Name , $ uri ) ; break ; } } unset ( $ array [ Resources : : XTAG _NAMESPACE ] ) ; self : : arr 2xml ( $ xmlw , $ array , $ default Tag ) ; $ xmlw - > end Element ( ) ; return $ xmlw - > output Memory ( true ) ; } 
public static function create ( array $ parsed Response ) { Validate : : has Key ( Resources : : XTAG _ALLOWED _ORIGINS , 'parsed Response ' , $ parsed Response ) ; Validate : : has Key ( Resources : : XTAG _ALLOWED _METHODS , 'parsed Response ' , $ parsed Response ) ; Validate : : has Key ( Resources : : XTAG _ALLOWED _HEADERS , 'parsed Response ' , $ parsed Response ) ; Validate : : has Key ( Resources : : XTAG _EXPOSED _HEADERS , 'parsed Response ' , $ parsed Response ) ; Validate : : has Key ( Resources : : XTAG _MAX _AGE _IN _SECONDS , 'parsed Response ' , $ parsed Response ) ; 
public function to Array ( ) { return array ( Resources : : XTAG _ALLOWED _ORIGINS = > implode ( ' , ' , $ this - > get Allowed Origins ( ) ) , Resources : : XTAG _ALLOWED _METHODS = > implode ( ' , ' , $ this - > get Allowed Methods ( ) ) , Resources : : XTAG _ALLOWED _HEADERS = > implode ( ' , ' , $ this - > get Allowed Headers ( ) ) , Resources : : XTAG _EXPOSED _HEADERS = > implode ( ' , ' , $ this - > get Exposed Headers ( ) ) , Resources : : XTAG _MAX _AGE _IN _SECONDS = > $ this - > get Maxed Age In Seconds ( ) ) ; } 
public function get Service Properties Async ( Service Options $ options = null ) { $ method = Resources : : HTTP _GET ; $ headers = array ( ) ; $ query Params = array ( ) ; $ post Params = array ( ) ; $ path = Resources : : EMPTY _STRING ; if ( is _null ( $ options ) ) { $ options = new Service Options ( ) ; } $ this - > add Optional Query Param ( $ query Params , Resources : : QP _REST _TYPE , 'service ' ) ; $ this - > add Optional Query Param ( $ query Params , Resources : : QP _COMP , 'properties ' ) ; $ data Serializer = $ this - > data Serializer ; return $ this - > send Async ( $ method , $ headers , $ query Params , $ post Params , $ path , Resources : : STATUS _OK , Resources : : EMPTY _STRING , $ options ) - > then ( function ( $ response ) use ( $ data Serializer ) { $ parsed = $ data Serializer - > unserialize ( $ response - > get Body ( ) ) ; return Get Service Properties Result : : create ( $ parsed ) ; } , null ) ; } 
public function set Service Properties ( Service Properties $ service Properties , Service Options $ options = null ) { $ this - > set Service Properties Async ( $ service Properties , $ options ) - > wait ( ) ; } 
public function set Service Properties Async ( Service Properties $ service Properties , Service Options $ options = null ) { Validate : : is True ( $ service Properties instanceof Service Properties , Resources : : INVALID _SVC _PROP _MSG ) ; $ method = Resources : : HTTP _PUT ; $ headers = array ( ) ; $ query Params = array ( ) ; $ post Params = array ( ) ; $ path = Resources : : EMPTY _STRING ; $ body = $ service Properties - > to Xml ( $ this - > data Serializer ) ; if ( is _null ( $ options ) ) { $ options = new Service Options ( ) ; } $ this - > add Optional Query Param ( $ query Params , Resources : : QP _REST _TYPE , 'service ' ) ; $ this - > add Optional Query Param ( $ query Params , Resources : : QP _COMP , 'properties ' ) ; $ this - > add Optional Header ( $ headers , Resources : : CONTENT _TYPE , Resources : : URL _ENCODED _CONTENT _TYPE ) ; $ options - > set Location Mode ( Location Mode : : PRIMARY _ONLY ) ; return $ this - > send Async ( $ method , $ headers , $ query Params , $ post Params , $ path , Resources : : STATUS _ACCEPTED , $ body , $ options ) ; } 
public function get Service Stats Async ( Service Options $ options = null ) { $ method = Resources : : HTTP _GET ; $ headers = array ( ) ; $ query Params = array ( ) ; $ post Params = array ( ) ; $ path = Resources : : EMPTY _STRING ; if ( is _null ( $ options ) ) { $ options = new Service Options ( ) ; } $ this - > add Optional Query Param ( $ query Params , Resources : : QP _REST _TYPE , 'service ' ) ; $ this - > add Optional Query Param ( $ query Params , Resources : : QP _COMP , 'stats ' ) ; $ data Serializer = $ this - > data Serializer ; $ options - > set Location Mode ( Location Mode : : SECONDARY _ONLY ) ; return $ this - > send Async ( $ method , $ headers , $ query Params , $ post Params , $ path , Resources : : STATUS _OK , Resources : : EMPTY _STRING , $ options ) - > then ( function ( $ response ) use ( $ data Serializer ) { $ parsed = $ data Serializer - > unserialize ( $ response - > get Body ( ) ) ; return Get Service Stats Result : : create ( $ parsed ) ; } , null ) ; } 
public static function create ( array $ parsed Response , $ location = ' ' ) { $ result = new List Queues Result ( ) ; $ service Endpoint = Utilities : : try Get Keys Chain Value ( $ parsed Response , Resources : : XTAG _ATTRIBUTES , Resources : : XTAG _SERVICE _ENDPOINT ) ; $ result - > set Account Name ( Utilities : : try Parse Account Name From Url ( $ service Endpoint ) ) ; $ result - > set Prefix ( Utilities : : try Get Value ( $ parsed Response , Resources : : QP _PREFIX ) ) ; $ result - > set Marker ( Utilities : : try Get Value ( $ parsed Response , Resources : : QP _MARKER ) ) ; $ next Marker = Utilities : : try Get Value ( $ parsed Response , Resources : : QP _NEXT _MARKER ) ; if ( $ next Marker ! = null ) { $ result - > set Continuation Token ( new Marker Continuation Token ( $ next Marker , $ location ) ) ; } $ result - > set Max Results ( Utilities : : try Get Value ( $ parsed Response , Resources : : QP _MAX _RESULTS ) ) ; $ queues = array ( ) ; $ raw Queues = array ( ) ; if ( ! empty ( $ parsed Response [ 'Queues ' ] ) ) { $ raw Queues = Utilities : : get Array ( $ parsed Response [ 'Queues ' ] [ 'Queue ' ] ) ; } foreach ( $ raw Queues as $ value ) { $ queue = new Queue ( $ value [ 'Name ' ] , $ service Endpoint . $ value [ 'Name ' ] ) ; $ metadata = Utilities : : try Get Value ( $ value , Resources : : QP _METADATA ) ; $ queue - > set Metadata ( is _null ( $ metadata ) ? array ( ) : $ metadata ) ; $ queues [ ] = $ queue ; } $ result - > set Queues ( $ queues ) ; return $ result ; } 
protected function set Queues ( array $ queues ) { $ this - > _queues = array ( ) ; foreach ( $ queues as $ queue ) { $ this - > _queues [ ] = clone $ queue ; } } 
public static function try Get Secondary Endpoint From Primary Endpoint ( $ uri ) { $ split Tokens = explode ( ' . ' , $ uri ) ; if ( count ( $ split Tokens ) > 0 & & $ split Tokens [ 0 ] ! = ' ' ) { $ schema Account Token = $ split Tokens [ 0 ] ; $ schema Account Split Tokens = explode ( ' / ' , $ schema Account Token ) ; if ( count ( $ schema Account Split Tokens ) > 0 & & $ schema Account Split Tokens [ 0 ] ! = ' ' ) { $ account Name = $ schema Account Split Tokens [ count ( $ schema Account Split Tokens ) - 1 ] ; $ schema Account Split Tokens [ count ( $ schema Account Split Tokens ) - 1 ] = $ account Name . Resources : : SECONDARY _STRING ; $ split Tokens [ 0 ] = implode ( ' / ' , $ schema Account Split Tokens ) ; $ secondary Uri = implode ( ' . ' , $ split Tokens ) ; return $ secondary Uri ; } } return null ; } 
public static function add If Not Empty ( $ key , $ value , array & $ array ) { if ( ! is _null ( $ array ) ) { Validate : : is Array ( $ array , 'array ' ) ; } if ( ! empty ( $ value ) ) { $ array [ $ key ] = $ value ; } } 
private static function _sxml 2arr ( $ sxml , array $ arr = null ) { foreach ( ( array ) $ sxml as $ key = > $ value ) { if ( is _object ( $ value ) | | ( is _array ( $ value ) ) ) { $ arr [ $ key ] = self : : _sxml 2arr ( $ value ) ; } else { $ arr [ $ key ] = $ value ; } } return $ arr ; } 
public static function serialize ( array $ array , $ root Name , $ default Tag = null , $ standalone = null ) { $ xml Version = ' 1 . 0 ' ; $ xml Encoding = 'UTF - 8 ' ; if ( ! is _array ( $ array ) ) { return false ; } $ xmlw = new \ Xml Writer ( ) ; $ xmlw - > open Memory ( ) ; $ xmlw - > start Document ( $ xml Version , $ xml Encoding , $ standalone ) ; $ xmlw - > start Element ( $ root Name ) ; self : : _arr 2xml ( $ xmlw , $ array , $ default Tag ) ; $ xmlw - > end Element ( ) ; return $ xmlw - > output Memory ( true ) ; } 
private static function _arr 2xml ( \ XMLWriter $ xmlw , array $ data , $ default Tag = null ) { foreach ( $ data as $ key = > $ value ) { if ( strcmp ( $ key , ' @attributes ' ) = = 0 ) { foreach ( $ value as $ attribute Name = > $ attribute Value ) { $ xmlw - > write Attribute ( $ attribute Name , $ attribute Value ) ; } } elseif ( is _array ( $ value ) ) { if ( ! is _int ( $ key ) ) { if ( $ key ! = Resources : : EMPTY _STRING ) { $ xmlw - > start Element ( $ key ) ; } else { $ xmlw - > start Element ( $ default Tag ) ; } } self : : _arr 2xml ( $ xmlw , $ value ) ; if ( ! is _int ( $ key ) ) { $ xmlw - > end Element ( ) ; } continue ; } else { $ xmlw - > write Element ( $ key , $ value ) ; } } } 
public static function to Boolean ( $ obj , $ skip Null = false ) { if ( $ skip Null & & is _null ( $ obj ) ) { return null ; } return filter _var ( $ obj , FILTER _VALIDATE _BOOLEAN ) ; } 
public static function rfc 1 1 2 3To Date Time ( $ date ) { $ time Zone = new \ Date Time Zone ( 'GMT ' ) ; $ format = Resources : : AZURE _DATE _FORMAT ; return \ Date Time : : create From Format ( $ format , $ date , $ time Zone ) ; } 
public static function iso Date ( \ Date Time Interface $ date ) { $ date = clone $ date ; $ date = $ date - > set Timezone ( new \ Date Time Zone ( 'UTC ' ) ) ; return str _replace ( ' + 0 0 : 0 0 ' , 'Z ' , $ date - > format ( 'c ' ) ) ; } 
public static function convert To Date Time ( $ value ) { if ( $ value instanceof \ Date Time ) { return $ value ; } if ( substr ( $ value , - 1 ) = = 'Z ' ) { $ value = substr ( $ value , 0 , strlen ( $ value ) - 1 ) ; } return new \ Date Time ( $ value , new \ Date Time Zone ( 'UTC ' ) ) ; } 
public static function try Get Value Insensitive ( $ key , $ haystack , $ default = null ) { $ array = array _change _key _case ( $ haystack ) ; return Utilities : : try Get Value ( $ array , strtolower ( $ key ) , $ default ) ; } 
public static function get Guid ( ) { 
public static function ends With ( $ haystack , $ needle , $ ignore Case = false ) { if ( $ ignore Case ) { $ haystack = strtolower ( $ haystack ) ; $ needle = strtolower ( $ needle ) ; } $ length = strlen ( $ needle ) ; if ( $ length = = 0 ) { return true ; } return ( substr ( $ haystack , - $ length ) = = = $ needle ) ; } 
public static function get Entity Id ( $ entity , $ type , $ method = 'get Id ' ) { if ( is _string ( $ entity ) ) { return $ entity ; } else { Validate : : is A ( $ entity , $ type , 'entity ' ) ; Validate : : method Exists ( $ entity , $ method , $ type ) ; return $ entity - > $ method ( ) ; } } 
public static function base 2 5 6To Dec ( $ number ) { Validate : : can Cast As String ( $ number , 'number ' ) ; $ result = 0 ; $ base = 1 ; for ( $ i = strlen ( $ number ) - 1 ; $ i > = 0 ; $ i - - ) { $ result = bcadd ( $ result , bcmul ( ord ( $ number [ $ i ] ) , $ base ) ) ; $ base = bcmul ( $ base , 2 5 6 ) ; } return $ result ; } 
public static function is Stream Larger Than Size Or Not Seekable ( Stream $ stream , $ size ) { Validate : : is Integer ( $ size , 'size ' ) ; Validate : : is True ( $ stream instanceof Stream , sprintf ( Resources : : INVALID _PARAM _MSG , 'stream ' , 'Guzzle \Stream ' ) ) ; $ result = true ; if ( $ stream - > is Seekable ( ) ) { $ position = $ stream - > tell ( ) ; try { $ stream - > seek ( $ size ) ; } catch ( \ Runtime Exception $ e ) { $ pos = strpos ( $ e - > get Message ( ) , 'to seek to stream position ' ) ; if ( $ pos = = null ) { throw $ e ; } $ result = false ; } if ( $ stream - > eof ( ) ) { $ result = false ; } elseif ( $ stream - > read ( 1 ) = = ' ' ) { $ result = false ; } $ stream - > seek ( $ position ) ; } return $ result ; } 
public static function append To File ( $ path , $ content ) { $ resource = @ fopen ( $ path , 'a + ' ) ; if ( $ resource ! = null ) { fwrite ( $ resource , $ content ) ; fclose ( $ resource ) ; } } 
public static function all Zero ( $ content ) { $ size = strlen ( $ content ) ; 
public static function append Delimiter ( $ string , $ delimiter ) { if ( ! self : : ends With ( $ string , $ delimiter ) ) { $ string . = $ delimiter ; } return $ string ; } 
public static function request Sent To Secondary ( \ Psr \ Http \ Message \ Request Interface $ request , array $ options ) { $ uri = $ request - > get Uri ( ) ; $ secondary Uri = $ options [ Resources : : ROS _SECONDARY _URI ] ; $ is Secondary = false ; if ( strpos ( ( string ) $ uri , ( string ) $ secondary Uri ) ! = = false ) { $ is Secondary = true ; } return $ is Secondary ; } 
public static function get Location From Headers ( array $ headers ) { $ value = Utilities : : try Get Value ( $ headers , Resources : : X _MS _CONTINUATION _LOCATION _MODE ) ; $ result = ' ' ; if ( \ is _string ( $ value ) ) { $ result = $ value ; } elseif ( ! empty ( $ value ) ) { $ result = $ value [ 0 ] ; } return $ result ; } 
public static function calculate Content MD 5 ( $ content ) { Validate : : not Null ( $ content , 'content ' ) ; Validate : : can Cast As String ( $ content , 'content ' ) ; return base 6 4 _encode ( md 5 ( $ content , true ) ) ; } 
public static function create ( array $ parsed Response = null ) { $ result = new Retention Policy ( ) ; $ result - > set Enabled ( Utilities : : to Boolean ( $ parsed Response [ 'Enabled ' ] ) ) ; if ( $ result - > get Enabled ( ) ) { $ result - > set Days ( intval ( $ parsed Response [ 'Days ' ] ) ) ; } return $ result ; } 
protected static function validate Resource Type ( $ resource Type ) { Validate : : is True ( $ resource Type = = Resources : : RESOURCE _TYPE _SHARE | | $ resource Type = = Resources : : RESOURCE _TYPE _FILE , Resources : : INVALID _RESOURCE _TYPE ) ; } 
public static function create ( array $ headers ) { $ result = new Update Message Result ( ) ; $ result - > set Pop Receipt ( Utilities : : try Get Value Insensitive ( Resources : : X _MS _POPRECEIPT , $ headers ) ) ; $ time Next Visible = Utilities : : try Get Value Insensitive ( Resources : : X _MS _TIME _NEXT _VISIBLE , $ headers ) ; $ date = Utilities : : rfc 1 1 2 3To Date Time ( $ time Next Visible ) ; $ result - > set Time Next Visible ( $ date ) ; return $ result ; } 
public static function create ( $ type = self : : GENERAL _RETRY _TYPE , $ number Of Retries = Resources : : DEFAULT _NUMBER _OF _RETRIES , $ interval = Resources : : DEFAULT _RETRY _INTERVAL , $ accumulation Method = self : : LINEAR _INTERVAL _ACCUMULATION , $ retry Connect = false ) { 
protected static function create Retry Decider ( $ type , $ max Retries , $ retry Connect ) { return function ( $ retries , $ request , $ response = null , $ exception = null , $ is Secondary = false ) use ( $ type , $ max Retries , $ retry Connect ) { 
protected static function general Retry Decider ( $ status Code , $ is Secondary ) { $ retry = false ; if ( $ status Code = = 4 0 8 ) { $ retry = true ; } elseif ( $ status Code > = 5 0 0 ) { if ( $ status Code ! = 5 0 1 & & $ status Code ! = 5 0 5 ) { $ retry = true ; } } elseif ( $ is Secondary & & $ status Code = = 4 0 4 ) { $ retry = true ; } return $ retry ; } 
protected function add Optional Query Param ( array & $ query Parameters , $ key , $ value ) { Validate : : is Array ( $ query Parameters , 'query Parameters ' ) ; Validate : : can Cast As String ( $ key , 'key ' ) ; Validate : : can Cast As String ( $ value , 'value ' ) ; if ( ! is _null ( $ value ) & & Resources : : EMPTY _STRING ! = = $ value ) { $ query Parameters [ $ key ] = $ value ; } } 
protected function add Optional Header ( array & $ headers , $ key , $ value ) { Validate : : is Array ( $ headers , 'headers ' ) ; Validate : : can Cast As String ( $ key , 'key ' ) ; Validate : : can Cast As String ( $ value , 'value ' ) ; if ( ! is _null ( $ value ) & & Resources : : EMPTY _STRING ! = = $ value ) { $ headers [ $ key ] = $ value ; } } 
public static function create ( array $ headers , Stream Interface $ body , array $ metadata ) { $ result = new Get File Result ( ) ; $ result - > set Content Stream ( $ body - > detach ( ) ) ; $ result - > set Properties ( File Properties : : create From Http Headers ( $ headers ) ) ; $ result - > set Metadata ( is _null ( $ metadata ) ? array ( ) : $ metadata ) ; return $ result ; } 
public static function create Metadata Result ( array $ response Headers ) { $ result = new static ( ) ; $ metadata = Utilities : : get Metadata Array ( $ response Headers ) ; $ date = Utilities : : try Get Value Insensitive ( Resources : : LAST _MODIFIED , $ response Headers ) ; $ date = Utilities : : rfc 1 1 2 3To Date Time ( $ date ) ; $ result - > set ETag ( Utilities : : try Get Value Insensitive ( Resources : : ETAG , $ response Headers ) ) ; $ result - > set Metadata ( $ metadata ) ; $ result - > set Last Modified ( $ date ) ; return $ result ; } 
public static function object Serialize ( $ target Object ) { 
private static function serialize Request ( $ request ) { $ headers = $ request - > get Headers ( ) ; $ version = $ request - > get Protocol Version ( ) ; $ uri = $ request - > get Uri ( ) ; $ method = $ request - > get Method ( ) ; $ result String = "Request : \n " ; $ result String . = "URI : { $uri } \n HTTP Version : { $version } \n Method : { $method } \n " ; $ result String . = self : : serialize Headers ( $ headers ) ; return $ result String ; } 
private static function serialize Response ( $ response ) { $ headers = $ response - > get Headers ( ) ; $ version = $ response - > get Protocol Version ( ) ; $ status = $ response - > get Status Code ( ) ; $ reason = $ response - > get Reason Phrase ( ) ; $ result String = "Response : \n " ; $ result String . = "Status Code : { $status } \n Reason : { $reason } \n " ; $ result String . = "HTTP Version : { $version } \n " ; $ result String . = self : : serialize Headers ( $ headers ) ; return $ result String ; } 
private static function serialize Headers ( array $ headers ) { $ result String = "Headers : \n " ; foreach ( $ headers as $ key = > $ value ) { $ result String . = sprintf ( " %s : %s \n " , $ key , $ value [ 0 ] ) ; } return $ result String ; } 
private static function serialize Request Exception ( Request Exception $ e ) { $ result String = sprintf ( "Reason : \n %s \n " , $ e ) ; if ( $ e - > has Response ( ) ) { $ result String . = self : : serialize Response ( $ e - > get Response ( ) ) ; } return $ result String ; } 
public static function create ( $ parsed Response ) { $ result = new Create Message Result ( ) ; if ( ! empty ( $ parsed Response ) & & ! empty ( $ parsed Response [ Resources : : QP _QUEUE _MESSAGE ] ) ) { $ result - > set Queue Message ( Queue Message : : create From Create Message ( $ parsed Response [ Resources : : QP _QUEUE _MESSAGE ] ) ) ; } return $ result ; } 
public static function create ( $ body , $ headers , $ odata Serializer ) { $ result = new Insert Entity Result ( ) ; $ entity = $ odata Serializer - > parse Entity ( $ body ) ; $ entity - > set ETag ( Utilities : : try Get Value ( $ headers , Resources : : ETAG ) ) ; $ result - > set Entity ( $ entity ) ; return $ result ; } 
public static function create ( array $ headers , array $ entities ) { $ result = new Query Entities Result ( ) ; $ headers = array _change _key _case ( $ headers ) ; $ next PK = Utilities : : try Get Value ( $ headers , Resources : : X _MS _CONTINUATION _NEXTPARTITIONKEY ) ; $ next RK = Utilities : : try Get Value ( $ headers , Resources : : X _MS _CONTINUATION _NEXTROWKEY ) ; if ( $ next RK ! = null & & $ next PK ! = null ) { $ result - > set Continuation Token ( new Table Continuation Token ( ' ' , $ next PK , $ next RK , Utilities : : get Location From Headers ( $ headers ) ) ) ; } $ result - > set Entities ( $ entities ) ; return $ result ; } 
public static function format Headers ( array $ headers ) { $ result = array ( ) ; foreach ( $ headers as $ key = > $ value ) { if ( is _array ( $ value ) & & count ( $ value ) = = 1 ) { $ result [ strtolower ( $ key ) ] = $ value [ 0 ] ; } else { $ result [ strtolower ( $ key ) ] = $ value ; } } return $ result ; } 
public static function create ( array $ parsed Response ) { $ result = new Get Service Properties Result ( ) ; $ result - > set Value ( Service Properties : : create ( $ parsed Response ) ) ; return $ result ; } 
public static function create ( array $ parsed ) { $ result = new File ( ) ; $ name = Utilities : : try Get Value ( $ parsed , Resources : : QP _NAME ) ; $ result - > set Name ( $ name ) ; $ properties = Utilities : : try Get Value ( $ parsed , Resources : : QP _PROPERTIES ) ; $ length = \ intval ( Utilities : : try Get Value ( $ properties , Resources : : QP _CONTENT _LENGTH ) ) ; $ result - > set Length ( $ length ) ; return $ result ; } 
public function apply ( callable $ handler ) { $ result = $ handler ; foreach ( $ this - > middlewares as $ middleware ) { $ result = $ middleware ( $ result ) ; } return $ result ; } 
public function get Available Includes ( ) { if ( $ this - > relations = = [ ' * ' ] ) { return $ this - > resolve Scoped Includes ( $ this - > get Current Scope ( ) ) ; } return array _keys ( $ this - > normalize Relations ( $ this - > relations ) ) ; } 
protected function call Include Method ( Scope $ scope , $ identifier , $ data ) { $ parameters = iterator _to _array ( $ scope - > get Manager ( ) - > get Include Params ( $ scope - > get Identifier ( $ identifier ) ) ) ; return $ this - > include Resource ( $ identifier , $ data , $ parameters ) ; } 
protected function resolve Scoped Includes ( Scope $ scope ) : array { $ level = count ( $ scope - > get Parent Scopes ( ) ) ; $ includes = $ scope - > get Manager ( ) - > get Requested Includes ( ) ; return collect ( $ includes ) - > map ( function ( $ include ) { return explode ( ' . ' , $ include ) ; } ) - > filter ( function ( $ include ) use ( $ level ) { return count ( $ include ) > $ level ; } ) - > pluck ( $ level ) - > unique ( ) - > all ( ) ; } 
public function error ( $ error Code = null , string $ message = null ) { $ this - > error Code = $ error Code ; $ this - > message = $ message ; return $ this ; } 
public function data ( array $ data = null ) { $ this - > data = array _merge ( ( array ) $ this - > data , ( array ) $ data ) ; return $ this ; } 
public function serializer ( $ serializer ) { if ( is _string ( $ serializer ) ) { $ serializer = new $ serializer ; } if ( ! $ serializer instanceof Error Serializer ) { throw new Invalid Error Serializer Exception ; } $ this - > serializer = $ serializer ; return $ this ; } 
protected function get Output ( ) : array { return $ this - > error Factory - > make ( $ this - > serializer , $ this - > error Code , $ this - > message , $ this - > data ) ; } 
public function resource ( $ data = null , $ transformer = null , string $ resource Key = null ) { $ this - > resource = $ this - > resource Factory - > make ( $ data , $ transformer , $ resource Key ) ; if ( $ data instanceof Cursor Paginator ) { $ this - > cursor ( $ this - > paginator Factory - > make Cursor ( $ data ) ) ; } elseif ( $ data instanceof Length Aware Paginator ) { $ this - > paginator ( $ this - > paginator Factory - > make ( $ data ) ) ; } return $ this ; } 
public function cursor ( Cursor $ cursor ) { if ( $ this - > resource instanceof Collection Resource ) { $ this - > resource - > set Cursor ( $ cursor ) ; } return $ this ; } 
public function paginator ( Illuminate Paginator Adapter $ paginator ) { if ( $ this - > resource instanceof Collection Resource ) { $ this - > resource - > set Paginator ( $ paginator ) ; } return $ this ; } 
public function with ( $ relations ) { $ relations = is _array ( $ relations ) ? $ relations : func _get _args ( ) ; foreach ( $ relations as $ relation = > $ constraint ) { if ( is _numeric ( $ relation ) ) { $ relation = $ constraint ; $ constraint = null ; } $ this - > with = array _merge ( $ this - > with , [ $ relation = > $ constraint ] ) ; } return $ this ; } 
public function without ( $ relations ) { $ this - > without = array _merge ( $ this - > without , is _array ( $ relations ) ? $ relations : func _get _args ( ) ) ; return $ this ; } 
public function only ( $ fields ) { $ this - > only = array _merge ( $ this - > only , is _array ( $ fields ) ? $ fields : func _get _args ( ) ) ; return $ this ; } 
public function serializer ( $ serializer ) { if ( is _string ( $ serializer ) ) { $ serializer = new $ serializer ; } if ( ! $ serializer instanceof Serializer Abstract ) { throw new Invalid Success Serializer Exception ; } $ this - > serializer = $ serializer ; return $ this ; } 
public function transform ( ) { $ this - > prepare Relations ( $ this - > resource - > get Data ( ) , $ this - > resource - > get Transformer ( ) ) ; return $ this - > transform Factory - > make ( $ this - > resource ? : new Null Resource , $ this - > serializer , [ 'includes ' = > $ this - > with , 'excludes ' = > $ this - > without , 'fieldsets ' = > $ this - > only , ] ) ; } 
protected function prepare Relations ( $ data , $ transformer ) { if ( $ transformer instanceof Transformer ) { $ relations = $ transformer - > relations ( $ this - > with ) ; $ default Relations = $ this - > remove Excluded Relations ( $ transformer - > default Relations ( $ this - > with ) ) ; $ this - > with = array _merge ( $ relations , $ default Relations ) ; } if ( $ data instanceof Model | | $ data instanceof Collection ) { $ this - > eager Load Relations ( $ data , $ this - > with , $ transformer ) ; } $ this - > with = array _keys ( $ this - > with ) ; } 
protected function remove Excluded Relations ( array $ relations ) : array { return array _filter ( $ relations , function ( $ relation ) { return ! in _array ( $ this - > strip Parameters From Relation ( $ relation ) , $ this - > without ) ; } , ARRAY _FILTER _USE _KEY ) ; } 
protected function eager Load Relations ( $ data , array $ requested , $ transformer ) { $ relations = collect ( array _keys ( $ requested ) ) - > reduce ( function ( $ eager Loads , $ relation ) use ( $ requested , $ transformer ) { $ identifier = camel _case ( $ this - > strip Parameters From Relation ( $ relation ) ) ; if ( method _exists ( $ transformer , 'include ' . ucfirst ( $ identifier ) ) ) { return $ eager Loads ; } return array _merge ( $ eager Loads , [ $ identifier = > $ requested [ $ relation ] ? : function ( ) { } ] ) ; } , [ ] ) ; $ data - > load ( $ relations ) ; } 
public function make ( Length Aware Paginator $ paginator ) : Paginator Interface { $ paginator - > appends ( $ this - > parameters ) ; return new Illuminate Paginator Adapter ( $ paginator ) ; } 
public function make Cursor ( Cursor Paginator $ paginator ) : Cursor { return new Cursor ( $ paginator - > cursor ( ) , $ paginator - > previous ( ) , $ paginator - > next ( ) , $ paginator - > get ( ) - > count ( ) ) ; } 
public function paginator ( Paginator Interface $ paginator ) { $ pagination = parent : : paginator ( $ paginator ) [ 'pagination ' ] ; return [ 'pagination ' = > [ 'count ' = > $ pagination [ 'count ' ] , 'total ' = > $ pagination [ 'total ' ] , 'per Page ' = > $ pagination [ 'per _page ' ] , 'current Page ' = > $ pagination [ 'current _page ' ] , 'total Pages ' = > $ pagination [ 'total _pages ' ] , 'links ' = > $ pagination [ 'links ' ] , ] , ] ; } 
public function cursor ( Cursor Interface $ cursor ) { return [ 'cursor ' = > [ 'current ' = > $ cursor - > get Current ( ) , 'previous ' = > $ cursor - > get Prev ( ) , 'next ' = > $ cursor - > get Next ( ) , 'count ' = > ( int ) $ cursor - > get Count ( ) , ] , ] ; } 
public function merge Includes ( $ transformed Data , $ included Data ) { foreach ( array _keys ( $ included Data ) as $ key ) { $ included Data [ $ key ] = $ included Data [ $ key ] [ 'data ' ] ; } return array _merge ( $ transformed Data , $ included Data ) ; } 
public function bind ( $ transformable , string $ resource Key ) { $ this - > bindings = array _merge ( $ this - > bindings , is _array ( $ transformable ) ? $ transformable : [ $ transformable = > $ resource Key , ] ) ; } 
public function resolve ( $ data ) { $ transformable = $ this - > resolve Transformable Item ( $ data ) ; if ( is _object ( $ transformable ) & & key _exists ( get _class ( $ transformable ) , $ this - > bindings ) ) { return $ this - > bindings [ get _class ( $ transformable ) ] ; } if ( $ transformable instanceof Model ) { return $ this - > resolve From Model ( $ transformable ) ; } return 'data ' ; } 
protected function resolve Transformable Item ( $ data ) { if ( is _array ( $ data ) | | $ data instanceof Traversable ) { foreach ( $ data as $ item ) { return $ item ; } } return $ data ; } 
protected function resolve Transformer ( string $ transformer ) { $ transformer Resolver = $ this - > resolve Container ( ) - > make ( Transformer Resolver : : class ) ; return $ transformer Resolver - > resolve ( $ transformer ) ; } 
public function render ( $ request , Exception $ exception ) { if ( $ request - > wants Json ( ) ) { $ this - > convert Default Exception ( $ exception ) ; if ( $ exception instanceof Http Exception ) { return $ this - > render Response ( $ exception ) ; } } return parent : : render ( $ request , $ exception ) ; } 
public function make ( Error Serializer $ serializer , $ error Code = null , string $ message = null , array $ data = null ) : array { if ( isset ( $ error Code ) & & ! isset ( $ message ) ) { $ message = $ this - > message Resolver - > resolve ( $ error Code ) ; } return $ serializer - > format ( $ error Code , $ message , $ data ) ; } 
public function make ( Resource Interface $ resource , Serializer Abstract $ serializer , array $ options = [ ] ) { $ options = $ this - > parse Options ( $ options , $ resource ) ; return $ this - > manager - > set Serializer ( $ serializer ) - > parse Includes ( $ options [ 'includes ' ] ) - > parse Excludes ( $ options [ 'excludes ' ] ) - > parse Fieldsets ( $ options [ 'fieldsets ' ] ) - > create Data ( $ resource ) - > to Array ( ) ; } 
protected function parse Options ( array $ options , Resource Interface $ resource ) : array { $ options = array _merge ( [ 'includes ' = > [ ] , 'excludes ' = > [ ] , 'fieldsets ' = > [ ] , ] , $ options ) ; if ( ! empty ( $ options [ 'fieldsets ' ] ) ) { if ( is _null ( $ resource Key = $ resource - > get Resource Key ( ) ) ) { throw new Logic Exception ( 'Filtering fields using sparse fieldsets require resource key to be set . ' ) ; } $ options [ 'fieldsets ' ] = $ this - > parse Fieldsets ( $ options [ 'fieldsets ' ] , $ resource Key , $ options [ 'includes ' ] ) ; } return $ options ; } 
protected function parse Fieldsets ( array $ fieldsets , string $ resource Key , array $ includes ) : array { $ includes = array _map ( function ( $ include ) use ( $ resource Key ) { return " $resource Key . $include " ; } , $ includes ) ; foreach ( $ fieldsets as $ key = > $ fields ) { if ( is _numeric ( $ key ) ) { unset ( $ fieldsets [ $ key ] ) ; $ key = $ resource Key ; } $ fields = $ this - > parse Fieldset ( $ key , ( array ) $ fields , $ includes ) ; $ fieldsets [ $ key ] = array _unique ( array _merge ( key _exists ( $ key , $ fieldsets ) ? ( array ) $ fieldsets [ $ key ] : [ ] , $ fields ) ) ; } return array _map ( function ( $ fields ) { return implode ( ' , ' , $ fields ) ; } , $ fieldsets ) ; } 
protected function parse Fieldset ( string $ key , array $ fields , array $ includes ) : array { $ child Includes = array _reduce ( $ includes , function ( $ segments , $ include ) use ( $ key ) { return array _merge ( $ segments , $ this - > resolve Child Includes ( $ key , $ include ) ) ; } , [ ] ) ; return array _merge ( $ fields , array _unique ( $ child Includes ) ) ; } 
protected function resolve Child Includes ( $ key , string $ include ) : array { if ( count ( $ segments = explode ( ' . ' , $ include ) ) < = 1 ) { return [ ] ; } $ relation = $ key = = = array _shift ( $ segments ) ? [ $ segments [ 0 ] ] : [ ] ; return array _merge ( $ relation , $ this - > resolve Child Includes ( $ key , implode ( ' . ' , $ segments ) ) ) ; } 
public function success ( $ data = null , $ transformer = null , string $ resource Key = null ) : Success Response Builder { return $ this - > success Response Builder - > transform ( $ data , $ transformer , $ resource Key ) ; } 
public function error ( $ error Code = null , string $ message = null ) : Error Response Builder { return $ this - > error Response Builder - > error ( $ error Code , $ message ) ; } 
public function register ( $ error Code , string $ message ) { $ this - > messages = array _merge ( $ this - > messages , is _array ( $ error Code ) ? $ error Code : [ $ error Code = > $ message , ] ) ; } 
public function resolve ( $ error Code ) { if ( key _exists ( $ error Code , $ this - > messages ) ) { return $ this - > messages [ $ error Code ] ; } if ( $ this - > translator - > has ( $ error Code = "errors . $error Code " ) ) { return $ this - > translator - > trans ( $ error Code ) ; } return null ; } 
protected function clean Array ( array $ data ) { $ parameters = [ ] ; foreach ( $ data as $ key = > $ value ) { $ parameters [ in _array ( $ key , $ this - > except ) ? $ key : snake _case ( $ key ) ] = $ value ; } return $ parameters ; } 
public function bind ( $ transformable , $ transformer = null ) { $ this - > bindings = array _merge ( $ this - > bindings , is _array ( $ transformable ) ? $ transformable : [ $ transformable = > $ transformer , ] ) ; } 
public function resolve ( $ transformer ) { if ( is _string ( $ transformer ) ) { return $ this - > container - > make ( $ transformer ) ; } if ( ! is _callable ( $ transformer ) & & ! $ transformer instanceof Transformer ) { throw new Invalid Transformer Exception ; } return $ transformer ; } 
public function resolve From Data ( $ data ) { $ transformer = $ this - > resolve Transformer ( $ this - > resolve Transformable Item ( $ data ) ) ; return $ this - > resolve ( $ transformer ) ; } 
protected function resolve Transformer ( $ transformable ) { if ( is _object ( $ transformable ) & & key _exists ( get _class ( $ transformable ) , $ this - > bindings ) ) { return $ this - > bindings [ get _class ( $ transformable ) ] ; } if ( $ transformable instanceof Transformable ) { return $ transformable - > transformer ( ) ; } return $ this - > resolve ( $ this - > fallback ) ; } 
public function register ( ) { if ( $ this - > app instanceof Laravel ) { $ this - > register Laravel Bindings ( ) ; } elseif ( $ this - > app instanceof Lumen ) { $ this - > register Lumen Bindings ( ) ; } $ this - > register Serializer Bindings ( ) ; $ this - > register Error Bindings ( ) ; $ this - > register Fractal Bindings ( ) ; $ this - > register Transformer Bindings ( ) ; $ this - > register Resource Bindings ( ) ; $ this - > register Pagination Bindings ( ) ; $ this - > register Transformation Bindings ( ) ; $ this - > register Service Bindings ( ) ; } 
protected function register Laravel Bindings ( ) { $ this - > app - > singleton ( Response Factory Contract : : class , function ( $ app ) { return $ this - > decorate Response Factory ( $ app - > make ( Laravel Response Factory : : class ) ) ; } ) ; } 
protected function register Lumen Bindings ( ) { $ this - > app - > singleton ( Response Factory Contract : : class , function ( $ app ) { return $ this - > decorate Response Factory ( $ app - > make ( Lumen Response Factory : : class ) ) ; } ) ; $ this - > app - > bind ( Translator : : class , function ( $ app ) { return $ app [ 'translator ' ] ; } ) ; } 
protected function decorate Response Factory ( Response Factory Contract $ factory ) : Response Factory { foreach ( $ this - > app - > config [ 'responder .decorators ' ] as $ decorator ) { $ factory = new $ decorator ( $ factory ) ; } ; return $ factory ; } 
protected function register Serializer Bindings ( ) { $ this - > app - > bind ( Error Serializer Contract : : class , function ( $ app ) { return $ app - > make ( $ app - > config [ 'responder .serializers .error ' ] ) ; } ) ; $ this - > app - > bind ( Serializer Abstract : : class , function ( $ app ) { return $ app - > make ( $ app - > config [ 'responder .serializers .success ' ] ) ; } ) ; } 
protected function register Error Bindings ( ) { $ this - > app - > singleton ( Error Message Resolver Contract : : class , function ( $ app ) { return $ app - > make ( Error Message Resolver : : class ) ; } ) ; $ this - > app - > singleton ( Error Factory Contract : : class , function ( $ app ) { return $ app - > make ( Error Factory : : class ) ; } ) ; $ this - > app - > bind ( Error Response Builder : : class , function ( $ app ) { return ( new Error Response Builder ( $ app - > make ( Response Factory Contract : : class ) , $ app - > make ( Error Factory Contract : : class ) ) ) - > serializer ( $ app - > make ( Error Serializer Contract : : class ) ) ; } ) ; } 
protected function register Fractal Bindings ( ) { $ this - > app - > bind ( Manager : : class , function ( $ app ) { return ( new Manager ) - > set Recursion Limit ( $ app - > config [ 'responder .recursion _limit ' ] ) ; } ) ; } 
protected function register Transformer Bindings ( ) { $ this - > app - > singleton ( Transformer Resolver Contract : : class , function ( $ app ) { return new Transformer Resolver ( $ app , $ app - > config [ 'responder .fallback _transformer ' ] ) ; } ) ; Base Transformer : : container Resolver ( function ( ) { return $ this - > app - > make ( Container : : class ) ; } ) ; } 
protected function register Resource Bindings ( ) { $ this - > app - > singleton ( Resource Key Resolver Contract : : class , function ( $ app ) { return $ app - > make ( Resource Key Resolver : : class ) ; } ) ; $ this - > app - > singleton ( Resource Factory Contract : : class , function ( $ app ) { return $ app - > make ( Resource Factory : : class ) ; } ) ; } 
protected function register Pagination Bindings ( ) { $ this - > app - > bind ( Paginator Factory Contract : : class , function ( $ app ) { return new Paginator Factory ( $ app - > make ( Request : : class ) - > query ( ) ) ; } ) ; } 
protected function register Transformation Bindings ( ) { $ this - > app - > bind ( Transform Factory Contract : : class , function ( $ app ) { return $ app - > make ( Fractal Transform Factory : : class ) ; } ) ; $ this - > app - > bind ( Transform Builder : : class , function ( $ app ) { $ request = $ this - > app - > make ( Request : : class ) ; $ relations = $ request - > input ( $ this - > app - > config [ 'responder .load _relations _parameter ' ] , [ ] ) ; $ fieldsets = $ request - > input ( $ app - > config [ 'responder .filter _fields _parameter ' ] , [ ] ) ; return ( new Transform Builder ( $ app - > make ( Resource Factory Contract : : class ) , $ app - > make ( Transform Factory Contract : : class ) , $ app - > make ( Paginator Factory Contract : : class ) ) ) - > serializer ( $ app - > make ( Serializer Abstract : : class ) ) - > with ( is _string ( $ relations ) ? explode ( ' , ' , $ relations ) : $ relations ) - > only ( $ fieldsets ) ; } ) ; } 
protected function boot Laravel Application ( ) { if ( $ this - > app - > running In Console ( ) ) { $ this - > publishes ( [ _ _DIR _ _ . ' / . . /config /responder .php ' = > config _path ( 'responder .php ' ) , ] , 'config ' ) ; $ this - > publishes ( [ _ _DIR _ _ . ' / . . /resources /lang /en /errors .php ' = > base _path ( 'resources /lang /en /errors .php ' ) , ] , 'lang ' ) ; } } 
public function set ( $ data ) : Cursor Paginator { $ this - > items = $ data instanceof Collection ? $ data : collect ( $ data ) ; return $ this ; } 
protected function build Class ( $ name ) { $ replace = [ ] ; if ( ! $ this - > option ( 'model ' ) & & ! $ this - > option ( 'plain ' ) ) { $ this - > input - > set Option ( 'model ' , $ this - > resolve Model From Class Name ( ) ) ; } if ( $ this - > option ( 'model ' ) ) { $ replace = $ this - > build Model Replacements ( $ replace ) ; } return str _replace ( array _keys ( $ replace ) , array _values ( $ replace ) , parent : : build Class ( $ name ) ) ; } 
protected function parse Model ( $ model ) { if ( preg _match ( ' ( [ ^A -Za -z 0 - 9 _ / \ \ \ \ ] ) ' , $ model ) ) { throw new Invalid Argument Exception ( 'Model name contains invalid characters . ' ) ; } $ model = trim ( str _replace ( ' / ' , ' \ \ ' , $ model ) , ' \ \ ' ) ; if ( ! starts _with ( $ model , $ root Namespace = $ this - > laravel - > get Namespace ( ) ) ) { $ model = $ root Namespace . $ model ; } return $ model ; } 
public function format ( $ error Code = null , string $ message = null , array $ data = null ) : array { $ response = [ 'error ' = > [ 'code ' = > $ error Code , 'message ' = > $ message , ] , ] ; if ( is _array ( $ data ) ) { $ response [ 'error ' ] = array _merge ( $ response [ 'error ' ] , $ data ) ; } return $ response ; } 
public function relations ( array $ requested = [ ] ) : array { $ requested = $ this - > normalize Relations ( $ requested ) ; $ relations = $ this - > apply Query Constraints ( $ this - > extract Relations ( $ requested ) ) ; $ nested Relations = $ this - > nested Relations ( $ requested , $ relations , 'relations ' ) ; return array _merge ( $ relations , $ nested Relations ) ; } 
public function default Relations ( array $ requested = [ ] ) : array { $ requested = $ this - > normalize Relations ( $ requested ) ; $ relations = $ this - > apply Query Constraints ( $ this - > normalize Relations ( $ this - > load ) ) ; $ nested Relations = $ this - > nested Relations ( $ relations , array _merge ( $ relations , $ requested ) , 'default Relations ' ) ; return array _merge ( $ relations , $ nested Relations ) ; } 
protected function nested Relations ( array $ requested , array $ available , string $ method ) : array { $ transformers = $ this - > mapped Transformers ( $ available ) ; return collect ( array _keys ( $ transformers ) ) - > reduce ( function ( $ nested Relations , $ relation ) use ( $ requested , $ method , $ transformers ) { $ transformer = $ transformers [ $ relation ] ; $ children = $ this - > extract Child Relations ( $ requested , $ relation ) ; $ child Relations = $ this - > wrap Child Relations ( $ transformer - > $ method ( $ children ) , $ relation ) ; return array _merge ( $ nested Relations , $ child Relations ) ; } , [ ] ) ; } 
protected function extract Relations ( array $ relations ) : array { $ available = $ this - > available Relations ( ) ; return array _filter ( $ this - > map Relations ( $ relations , function ( $ relation , $ constraint ) { $ identifier = explode ( ' . ' , $ relation ) [ 0 ] ; $ constraint = $ identifier = = = $ relation ? $ constraint : null ; return [ $ identifier = > $ constraint ? : $ this - > resolve Query Constraint ( $ identifier ) ] ; } ) , function ( $ relation ) use ( $ available ) { return array _has ( $ available , explode ( ' : ' , $ relation ) [ 0 ] ) ; } , ARRAY _FILTER _USE _KEY ) ; } 
protected function extract Child Relations ( array $ relations , string $ identifier ) : array { return array _reduce ( array _keys ( $ relations ) , function ( $ nested , $ relation ) use ( $ relations , $ identifier ) { if ( ! starts _with ( $ relation , " $identifier . " ) ) { return $ nested ; } $ nested Identifier = explode ( ' . ' , $ relation ) ; array _shift ( $ nested Identifier ) ; return array _merge ( $ nested , [ implode ( ' . ' , $ nested Identifier ) = > $ relations [ $ relation ] ] ) ; } , [ ] ) ; } 
protected function wrap Child Relations ( array $ nested Relations , string $ relation ) : array { return $ this - > map Relations ( $ nested Relations , function ( $ nested Relation , $ constraint ) use ( $ relation ) { return [ " $relation . $nested Relation " = > $ constraint ] ; } ) ; } 
protected function normalize Relations ( array $ relations ) : array { return array _reduce ( array _keys ( $ relations ) , function ( $ normalized , $ relation ) use ( $ relations ) { if ( is _numeric ( $ relation ) ) { return array _merge ( $ normalized , [ $ relations [ $ relation ] = > null ] ) ; } return array _merge ( $ normalized , [ $ relation = > $ relations [ $ relation ] ] ) ; } , [ ] ) ; } 
protected function map Relations ( array $ relations , callable $ callback ) : array { $ mapped = [ ] ; foreach ( $ relations as $ identifier = > $ value ) { $ mapped = array _merge ( $ mapped , $ callback ( $ identifier , $ value ) ) ; } return $ mapped ; } 
protected function apply Query Constraints ( array $ relations ) : array { return $ this - > map Relations ( $ relations , function ( $ relation , $ constraint ) { return [ $ relation = > is _callable ( $ constraint ) ? $ constraint : $ this - > resolve Query Constraint ( $ relation ) ] ; } ) ; } 
protected function resolve Query Constraint ( string $ identifier ) { if ( ! method _exists ( $ this , $ method = 'load ' . ucfirst ( camel _case ( $ identifier ) ) ) ) { return null ; } return function ( $ query ) use ( $ method ) { return $ this - > $ method ( $ query ) ; } ; } 
protected function resolve Relation ( Model $ model , string $ identifier ) { $ identifier = camel _case ( $ identifier ) ; $ relation = $ model - > $ identifier ; if ( method _exists ( $ this , $ method = 'filter ' . ucfirst ( $ identifier ) ) ) { return $ this - > $ method ( $ relation ) ; } return $ relation ; } 
protected function mapped Transformers ( array $ relations ) : array { $ transformers = collect ( $ this - > available Relations ( ) ) - > filter ( function ( $ transformer ) { return ! is _null ( $ transformer ) ; } ) - > map ( function ( $ transformer ) { return $ this - > resolve Transformer ( $ transformer ) ; } ) - > all ( ) ; return array _intersect _key ( $ transformers , $ relations ) ; } 
protected function resource ( $ data = null , $ transformer = null , string $ resource Key = null ) : Resource Interface { if ( $ data instanceof Resource Interface ) { return $ data ; } $ resource Factory = $ this - > resolve Container ( ) - > make ( Resource Factory : : class ) ; return $ resource Factory - > make ( $ data , $ transformer , $ resource Key ) ; } 
protected function include Resource ( string $ identifier , $ data , array $ parameters ) : Resource Interface { $ transformer = $ this - > mapped Transformer Class ( $ identifier ) ; if ( method _exists ( $ this , $ method = 'include ' . ucfirst ( camel _case ( $ identifier ) ) ) ) { $ resource = $ this - > resource ( $ this - > $ method ( $ data , collect ( $ parameters ) ) , $ transformer , $ identifier ) ; } elseif ( $ data instanceof Model ) { $ resource = $ this - > include Resource From Model ( $ data , $ identifier , $ transformer ) ; } else { throw new Logic Exception ( 'Relation [ ' . $ identifier . ' ] not found in [ ' . get _class ( $ this ) . ' ] . ' ) ; } return $ resource ; } 
protected function include Resource From Model ( Model $ model , string $ identifier , $ transformer = null ) : Resource Interface { $ data = $ this - > resolve Relation ( $ model , $ identifier ) ; if ( ! $ this - > should Cache Resource ( $ data ) ) { return $ this - > resource ( $ data , $ transformer , $ identifier ) ; } elseif ( key _exists ( $ identifier , $ this - > resources ) ) { return $ this - > resources [ $ identifier ] - > set Data ( $ data ) ; } return $ this - > resources [ $ identifier ] = $ this - > resource ( $ data , $ transformer , $ identifier ) ; } 
protected function should Cache Resource ( $ data ) : bool { return is _array ( $ data ) | | $ data instanceof Countable ? count ( $ data ) > 0 : is _null ( $ data ) ; } 
public function make ( $ data = null , $ transformer = null , string $ resource Key = null ) : Resource Interface { if ( $ data instanceof Resource Interface ) { return $ this - > make From Resource ( $ data , $ transformer , $ resource Key ) ; } elseif ( is _null ( $ data = $ this - > normalizer - > normalize ( $ data ) ) ) { return $ this - > instatiate Resource ( $ data , null , $ resource Key ) ; } $ transformer = $ this - > resolve Transformer ( $ data , $ transformer ) ; $ resource Key = $ this - > resolve Resource Key ( $ data , $ resource Key ) ; return $ this - > instatiate Resource ( $ data , $ transformer , $ resource Key ) ; } 
public function make From Resource ( Resource Interface $ resource , $ transformer = null , string $ resource Key = null ) : Resource Interface { $ transformer = $ this - > resolve Transformer ( $ resource - > get Data ( ) , $ transformer ? : $ resource - > get Transformer ( ) ) ; $ resource Key = $ this - > resolve Resource Key ( $ resource - > get Data ( ) , $ resource Key ? : $ resource - > get Resource Key ( ) ) ; return $ resource - > set Transformer ( $ transformer ) - > set Resource Key ( $ resource Key ) ; } 
protected function instatiate Resource ( $ data , $ transformer = null , string $ resource Key = null ) : Resource Interface { if ( is _null ( $ data ) ) { return new Null Resource ( null , null , $ resource Key ) ; } elseif ( $ this - > should Create Collection ( $ data ) ) { return new Collection Resource ( $ data , $ transformer , $ resource Key ) ; } elseif ( is _scalar ( $ data ) ) { return new Primitive ( $ data , $ transformer , $ resource Key ) ; } return new Item Resource ( $ data , $ transformer , $ resource Key ) ; } 
protected function should Create Collection ( $ data ) : bool { if ( is _array ( $ data ) ) { return ! Arr : : is Assoc ( $ data ) & & ! is _scalar ( Arr : : first ( $ data ) ) ; } return $ data instanceof Traversable ; } 
protected function resolve Transformer ( $ data , $ transformer ) { if ( isset ( $ transformer ) ) { return $ this - > transformer Resolver - > resolve ( $ transformer ) ; } return $ this - > transformer Resolver - > resolve From Data ( $ data ) ; } 
protected function resolve Resource Key ( $ data , string $ resource Key = null ) { return isset ( $ resource Key ) ? $ resource Key : $ this - > resource Key Resolver - > resolve ( $ data ) ; } 
public function decorator ( $ decorator ) { $ decorators = is _array ( $ decorator ) ? $ decorator : func _get _args ( ) ; foreach ( $ decorators as $ decorator ) { $ this - > response Factory = new $ decorator ( $ this - > response Factory ) ; } ; return $ this ; } 
public function respond ( int $ status = null , array $ headers = [ ] ) : Json Response { if ( ! is _null ( $ status ) ) { $ this - > set Status Code ( $ status ) ; } return $ this - > response Factory - > make ( $ this - > get Output ( ) , $ this - > status , $ headers ) ; } 
public function normalize ( $ data = null ) { if ( $ this - > is Instance Of ( $ data , [ Builder : : class , Eloquent Builder : : class , Cursor Paginator : : class ] ) ) { return $ data - > get ( ) ; } elseif ( $ data instanceof Paginator ) { return $ data - > get Collection ( ) ; } elseif ( $ data instanceof Relation ) { return $ this - > normalize Relation ( $ data ) ; } return $ data ; } 
protected function normalize Relation ( Relation $ relation ) { if ( $ this - > is Instance Of ( $ relation , [ Belongs To : : class , Has One : : class , Morph One : : class , Morph To : : class ] ) ) { return $ relation - > first ( ) ; } return $ relation - > get ( ) ; } 
public function transform ( $ data = null , $ transformer = null , string $ resource Key = null ) : Success Response Builder { $ this - > transform Builder - > resource ( $ data , $ transformer , $ resource Key ) ; return $ this ; } 
protected function convert ( Exception $ exception , array $ convert ) { foreach ( $ convert as $ source = > $ target ) { if ( $ exception instanceof $ source ) { if ( is _callable ( $ target ) ) { $ target ( $ exception ) ; } throw new $ target ; } } } 
protected function convert Default Exception ( Exception $ exception ) { $ this - > convert ( $ exception , array _diff _key ( [ Authentication Exception : : class = > Unauthenticated Exception : : class , Authorization Exception : : class = > Unauthorized Exception : : class , Not Found Http Exception : : class = > Page Not Found Exception : : class , Model Not Found Exception : : class = > Page Not Found Exception : : class , Base Relation Not Found Exception : : class = > Relation Not Found Exception : : class , Validation Exception : : class = > function ( $ exception ) { throw new Validation Failed Exception ( $ exception - > validator ) ; } , ] , array _flip ( $ this - > dont Convert ) ) ) ; } 
protected function render Response ( Http Exception $ exception ) : Json Response { return app ( Responder : : class ) - > error ( $ exception - > error Code ( ) , $ exception - > message ( ) ) - > data ( $ exception - > data ( ) ) - > respond ( $ exception - > status Code ( ) , $ exception - > get Headers ( ) ) ; } 
public function success ( $ data = null , $ transformer = null , string $ resource Key = null ) : Success Response Builder { return app ( Responder : : class ) - > success ( . . . func _get _args ( ) ) ; } 
public function error ( $ error Code = null , string $ message = null ) : Error Response Builder { return app ( Responder : : class ) - > error ( . . . func _get _args ( ) ) ; } 
public function make ( array $ data , int $ status , array $ headers = [ ] ) : Json Response { return $ this - > factory - > make ( array _merge ( [ 'status ' = > $ status , ] , $ data ) , $ status , $ headers ) ; } 
public function make ( array $ data , int $ status , array $ headers = [ ] ) : Json Response { $ response = $ this - > factory - > make ( $ data , $ status , $ headers ) ; $ response - > set Encoding Options ( $ response - > get Encoding Options ( ) | JSON _PRETTY _PRINT ) ; return $ response ; } 
public function make ( $ data = null , $ transformer = null , string $ resource Key = null ) : Transform Builder { return $ this - > transform Builder - > resource ( $ data , $ transformer , $ resource Key ) - > serializer ( new Noop Serializer ) ; } 
public function make ( array $ data , int $ status , array $ headers = [ ] ) : Json Response { array _walk _recursive ( $ data , function ( & $ value ) { if ( is _string ( $ value ) ) { $ value = e ( $ value ) ; } } ) ; return $ this - > factory - > make ( $ data , $ status , $ headers ) ; } 
protected function configure Terminal ( ) : void { $ this - > assert Terminal Is Valid TTY ( ) ; $ this - > terminal - > disable Canonical Mode ( ) ; $ this - > terminal - > disable Echo Back ( ) ; $ this - > terminal - > disable Cursor ( ) ; $ this - > terminal - > clear ( ) ; } 
public function add Items ( array $ items ) : void { foreach ( $ items as $ item ) { $ this - > items [ ] = $ item ; } $ this - > select First Item ( ) ; } 
public function set Items ( array $ items ) : void { $ this - > selected Item = null ; $ this - > items = $ items ; $ this - > select First Item ( ) ; } 
private function select First Item ( ) : void { if ( null = = = $ this - > selected Item ) { foreach ( $ this - > items as $ key = > $ item ) { if ( $ item - > can Select ( ) ) { $ this - > selected Item = $ key ; break ; } } } } 
public function add Custom Control Mapping ( string $ input , callable $ callable ) : void { if ( isset ( $ this - > default Control Mappings [ $ input ] ) | | isset ( $ this - > custom Control Mappings [ $ input ] ) ) { throw new \ Invalid Argument Exception ( 'Cannot rebind this input ' ) ; } $ this - > custom Control Mappings [ $ input ] = $ callable ; } 
public function remove Custom Control Mapping ( string $ input ) : void { if ( ! isset ( $ this - > custom Control Mappings [ $ input ] ) ) { throw new \ Invalid Argument Exception ( 'This input is not registered ' ) ; } unset ( $ this - > custom Control Mappings [ $ input ] ) ; } 
private function display ( ) : void { $ this - > draw ( ) ; $ reader = new Non Canonical Reader ( $ this - > terminal ) ; $ reader - > add Control Mappings ( $ this - > default Control Mappings ) ; while ( $ this - > is Open ( ) ) { $ char = $ reader - > read Character ( ) ; if ( ! $ char - > is Handled Control ( ) ) { $ raw Char = $ char - > get ( ) ; if ( isset ( $ this - > custom Control Mappings [ $ raw Char ] ) ) { $ this - > custom Control Mappings [ $ raw Char ] ( $ this ) ; } continue ; } switch ( $ char - > get Control ( ) ) { case Input Character : : UP : case Input Character : : DOWN : $ this - > move Selection Vertically ( $ char - > get Control ( ) ) ; $ this - > draw ( ) ; break ; case Input Character : : LEFT : case Input Character : : RIGHT : $ this - > move Selection Horizontally ( $ char - > get Control ( ) ) ; $ this - > draw ( ) ; break ; case Input Character : : ENTER : $ this - > execute Current Item ( ) ; break ; } } } 
protected function move Selection Vertically ( string $ direction ) : void { $ item Keys = array _keys ( $ this - > items ) ; $ increments = 0 ; do { $ increments + + ; if ( $ increments > count ( $ item Keys ) ) { 
protected function move Selection Horizontally ( string $ direction ) : void { if ( ! $ this - > items [ $ this - > selected Item ] instanceof Split Item ) { return ; } $ item = $ this - > items [ $ this - > selected Item ] ; $ item Keys = array _keys ( $ item - > get Items ( ) ) ; $ selected Item Index = $ item - > get Selected Item Index ( ) ; do { $ direction = = = 'LEFT ' ? $ selected Item Index - - : $ selected Item Index + + ; if ( ! array _key _exists ( $ selected Item Index , $ item - > get Items ( ) ) ) { $ selected Item Index = $ direction = = = 'LEFT ' ? end ( $ item Keys ) : reset ( $ item Keys ) ; } } while ( ! $ item - > can Select Index ( $ selected Item Index ) ) ; $ item - > set Selected Item Index ( $ selected Item Index ) ; } 
public function get Selected Item ( ) : Menu Item Interface { if ( null = = = $ this - > selected Item ) { throw new \ Runtime Exception ( 'No selected item ' ) ; } $ item = $ this - > items [ $ this - > selected Item ] ; return $ item instanceof Split Item ? $ item - > get Selected Item ( ) : $ item ; } 
protected function execute Current Item ( ) : void { $ item = $ this - > get Selected Item ( ) ; if ( $ item - > can Select ( ) ) { $ callable = $ item - > get Select Action ( ) ; if ( $ callable ) { $ callable ( $ this ) ; } } } 
public function redraw ( bool $ clear = false ) : void { if ( $ clear ) { $ this - > terminal - > clear ( ) ; } $ this - > assert Open ( ) ; $ this - > draw ( ) ; } 
protected function draw ( ) : void { $ frame = new Frame ; $ frame - > new Line ( 2 ) ; if ( $ this - > style - > get Border Top Width ( ) > 0 ) { $ frame - > add Rows ( $ this - > style - > get Border Top Rows ( ) ) ; } if ( $ this - > style - > get Padding Top Bottom ( ) > 0 ) { $ frame - > add Rows ( $ this - > style - > get Padding Top Bottom Rows ( ) ) ; } if ( $ this - > title ) { $ frame - > add Rows ( $ this - > draw Menu Item ( new Static Item ( $ this - > title ) ) ) ; $ frame - > add Rows ( $ this - > draw Menu Item ( new Line Break Item ( $ this - > style - > get Title Separator ( ) ) ) ) ; } array _map ( function ( $ item , $ index ) use ( $ frame ) { $ frame - > add Rows ( $ this - > draw Menu Item ( $ item , $ index = = = $ this - > selected Item ) ) ; } , $ this - > items , array _keys ( $ this - > items ) ) ; if ( $ this - > style - > get Padding Top Bottom ( ) > 0 ) { $ frame - > add Rows ( $ this - > style - > get Padding Top Bottom Rows ( ) ) ; } if ( $ this - > style - > get Border Bottom Width ( ) > 0 ) { $ frame - > add Rows ( $ this - > style - > get Border Bottom Rows ( ) ) ; } $ frame - > new Line ( 2 ) ; $ this - > terminal - > move Cursor To Top ( ) ; foreach ( $ frame - > get Rows ( ) as $ row ) { if ( $ row = = " \n " ) { $ this - > terminal - > clear Line ( ) ; } $ this - > terminal - > write ( $ row ) ; } $ this - > terminal - > clear Down ( ) ; $ this - > current Frame = $ frame ; } 
protected function draw Menu Item ( Menu Item Interface $ item , bool $ selected = false ) : array { $ rows = $ item - > get Rows ( $ this - > style , $ selected ) ; if ( $ item instanceof Split Item ) { $ selected = false ; } $ inverted Colours Set Code = $ selected ? $ this - > style - > get Inverted Colours Set Code ( ) : ' ' ; $ inverted Colours Unset Code = $ selected ? $ this - > style - > get Inverted Colours Unset Code ( ) : ' ' ; if ( $ this - > style - > get Border Left Width ( ) | | $ this - > style - > get Border Right Width ( ) ) { $ border Colour = $ this - > style - > get Border Colour Code ( ) ; } else { $ border Colour = ' ' ; } return array _map ( function ( $ row ) use ( $ inverted Colours Set Code , $ inverted Colours Unset Code , $ border Colour ) { return sprintf ( " %s %s %s %s %s %s %s %s %s %s %s %s \n " , str _repeat ( ' ' , $ this - > style - > get Margin ( ) ) , $ border Colour , str _repeat ( ' ' , $ this - > style - > get Border Left Width ( ) ) , $ this - > style - > get Colours Set Code ( ) , $ inverted Colours Set Code , str _repeat ( ' ' , $ this - > style - > get Padding Left Right ( ) ) , $ row , str _repeat ( ' ' , $ this - > style - > get Right Hand Padding ( mb _strlen ( s : : strip Ansi Escape Sequence ( $ row ) ) ) ) , $ inverted Colours Unset Code , $ border Colour , str _repeat ( ' ' , $ this - > style - > get Border Right Width ( ) ) , $ this - > style - > get Colours Reset Code ( ) ) ; } , $ rows ) ; } 
public function close ( ) : void { $ menu = $ this ; do { $ menu - > close This ( ) ; $ menu = $ menu - > get Parent ( ) ; } while ( null ! = = $ menu ) ; $ this - > tear Down Terminal ( ) ; } 
private function set Default Selected Item ( ) : void { foreach ( $ this - > items as $ index = > $ item ) { if ( $ item - > can Select ( ) ) { $ this - > can Be Selected = true ; $ this - > selected Item Index = $ index ; return ; } } $ this - > can Be Selected = false ; $ this - > selected Item Index = null ; } 
public function get Rows ( Menu Style $ style , bool $ selected = false ) : array { $ number Of Items = count ( $ this - > items ) ; if ( $ number Of Items = = = 0 ) { throw new \ Runtime Exception ( sprintf ( 'There should be at least one item added to : %s ' , _ _CLASS _ _ ) ) ; } if ( ! $ selected ) { $ this - > set Default Selected Item ( ) ; } $ length = $ style - > get Displays Extra ( ) ? floor ( $ style - > get Content Width ( ) / $ number Of Items ) - ( mb _strlen ( $ style - > get Item Extra ( ) ) + 2 ) : floor ( $ style - > get Content Width ( ) / $ number Of Items ) ; $ length - = $ this - > gutter ; $ length = ( int ) $ length ; $ missing Length = $ style - > get Content Width ( ) % $ number Of Items ; return $ this - > build Rows ( array _map ( function ( $ index , $ item ) use ( $ selected , $ length , $ style ) { $ is Selected = $ selected & & $ index = = = $ this - > selected Item Index ; $ marker = $ item - > can Select ( ) ? sprintf ( ' %s ' , $ style - > get Marker ( $ is Selected ) ) : ' ' ; $ item Extra = ' ' ; if ( $ style - > get Displays Extra ( ) ) { $ item Extra = $ item - > shows Item Extra ( ) ? sprintf ( ' %s ' , $ style - > get Item Extra ( ) ) : sprintf ( ' %s ' , str _repeat ( ' ' , mb _strlen ( $ style - > get Item Extra ( ) ) ) ) ; } return $ this - > build Cell ( explode ( " \n " , String Util : : wordwrap ( sprintf ( ' %s %s ' , $ marker , $ item - > get Text ( ) ) , $ length , sprintf ( " \n %s " , str _repeat ( ' ' , mb _strlen ( $ marker ) ) ) ) ) , $ length , $ style , $ is Selected , $ item Extra ) ; } , array _keys ( $ this - > items ) , $ this - > items ) , $ style , $ missing Length , $ length ) ; } 
public function can Select Index ( int $ index ) : bool { return isset ( $ this - > items [ $ index ] ) & & $ this - > items [ $ index ] - > can Select ( ) ; } 
public function set Selected Item Index ( int $ index ) : void { if ( ! isset ( $ this - > items [ $ index ] ) ) { throw new \ Invalid Argument Exception ( sprintf ( 'Index : " %s " does not exist ' , $ index ) ) ; } $ this - > selected Item Index = $ index ; } 
public function get Selected Item ( ) : Menu Item Interface { if ( null = = = $ this - > selected Item Index ) { throw new \ Runtime Exception ( 'No item is selected ' ) ; } return $ this - > items [ $ this - > selected Item Index ] ; } 
public function get Rows ( Menu Style $ style , bool $ selected = false ) : array { return explode ( " \n " , rtrim ( str _repeat ( sprintf ( " %s \n " , mb _substr ( str _repeat ( $ this - > break Char , $ style - > get Content Width ( ) ) , 0 , $ style - > get Content Width ( ) ) ) , $ this - > lines ) ) ) ; } 
public static function wordwrap ( string $ string , int $ width , string $ break = " \n " ) : string { return implode ( $ break , array _map ( function ( string $ line ) use ( $ width , $ break ) { $ line = rtrim ( $ line ) ; if ( mb _strlen ( $ line ) < = $ width ) { return $ line ; } $ words = explode ( ' ' , $ line ) ; $ line = ' ' ; $ actual = ' ' ; foreach ( $ words as $ word ) { if ( mb _strlen ( $ actual . $ word ) < = $ width ) { $ actual . = $ word . ' ' ; } else { if ( $ actual ! = = ' ' ) { $ line . = rtrim ( $ actual ) . $ break ; } $ actual = $ word . ' ' ; } } return $ line . trim ( $ actual ) ; } , explode ( " \n " , $ string ) ) ) ; } 
public function get Rows ( Menu Style $ style , bool $ selected = false ) : array { $ marker = sprintf ( " %s " , $ style - > get Marker ( $ selected ) ) ; $ length = $ style - > get Displays Extra ( ) ? $ style - > get Content Width ( ) - ( mb _strlen ( $ style - > get Item Extra ( ) ) + 2 ) : $ style - > get Content Width ( ) ; $ rows = explode ( " \n " , String Util : : wordwrap ( sprintf ( ' %s %s ' , $ marker , $ this - > text ) , $ length , sprintf ( " \n %s " , str _repeat ( ' ' , mb _strlen ( $ marker ) ) ) ) ) ; return array _map ( function ( $ row , $ key ) use ( $ style , $ length ) { $ text = $ this - > disabled ? $ style - > get Disabled Item Text ( $ row ) : $ row ; if ( $ key = = = 0 ) { return $ this - > show Item Extra ? sprintf ( ' %s %s %s ' , $ text , str _repeat ( ' ' , $ length - mb _strlen ( $ row ) ) , $ style - > get Item Extra ( ) ) : $ text ; } return $ text ; } , $ rows , array _keys ( $ rows ) ) ; } 
private function generate Colours Set Code ( ) : void { if ( ! ctype _digit ( $ this - > fg ) ) { $ fg Code = self : : $ available Foreground Colors [ $ this - > fg ] ; } else { $ fg Code = sprintf ( " 3 8 ; 5 ; %s " , $ this - > fg ) ; } if ( ! ctype _digit ( $ this - > bg ) ) { $ bg Code = self : : $ available Background Colors [ $ this - > bg ] ; } else { $ bg Code = sprintf ( " 4 8 ; 5 ; %s " , $ this - > bg ) ; } $ this - > colours Set Code = sprintf ( " \ 0 3 3 [ %s ; %sm " , $ fg Code , $ bg Code ) ; } 
protected function calculate Content Width ( ) : void { $ this - > content Width = $ this - > width - ( $ this - > padding Left Right * 2 ) - ( $ this - > border Right Width + $ this - > border Left Width ) ; if ( $ this - > content Width < 0 ) { $ this - > content Width = 0 ; } } 
public function get Right Hand Padding ( int $ content Length ) : int { $ right Padding = $ this - > get Content Width ( ) - $ content Length + $ this - > get Padding Left Right ( ) ; if ( $ right Padding < 0 ) { $ right Padding = 0 ; } return $ right Padding ; } 
public function set Border ( int $ top Width , $ right Width = null , $ bottom Width = null , $ left Width = null , string $ colour = null ) : self { if ( ! is _int ( $ right Width ) ) { $ colour = $ right Width ; $ right Width = $ bottom Width = $ left Width = $ top Width ; } elseif ( ! is _int ( $ bottom Width ) ) { $ colour = $ bottom Width ; $ bottom Width = $ top Width ; $ left Width = $ right Width ; } elseif ( ! is _int ( $ left Width ) ) { $ colour = $ left Width ; $ left Width = $ right Width ; } $ this - > border Top Width = $ top Width ; $ this - > border Right Width = $ right Width ; $ this - > border Bottom Width = $ bottom Width ; $ this - > border Left Width = $ left Width ; if ( is _string ( $ colour ) ) { $ this - > set Border Colour ( $ colour ) ; } elseif ( $ colour ! = = null ) { throw new \ Invalid Argument Exception ( 'Invalid colour ' ) ; } $ this - > calculate Content Width ( ) ; $ this - > generate Border Rows ( ) ; $ this - > generate Padding Top Bottom Rows ( ) ; return $ this ; } 
public function display ( ) : void { $ this - > assert Menu Open ( ) ; $ this - > terminal - > move Cursor To Row ( $ this - > y ) ; $ this - > empty Row ( ) ; $ this - > write ( sprintf ( " %s %s %s %s %s \n " , $ this - > style - > get Colours Set Code ( ) , str _repeat ( ' ' , $ this - > style - > get Padding Left Right ( ) ) , $ this - > text , str _repeat ( ' ' , $ this - > style - > get Padding Left Right ( ) ) , $ this - > style - > get Colours Reset Code ( ) ) ) ; $ this - > empty Row ( ) ; $ this - > terminal - > move Cursor To Top ( ) ; $ reader = new Non Canonical Reader ( $ this - > terminal ) ; $ reader - > read Character ( ) ; $ this - > parent Menu - > redraw ( ) ; } 
protected function calculate Coordinates ( ) : void { 
protected function empty Row ( ) : void { $ this - > write ( sprintf ( " %s %s %s %s %s \n " , $ this - > style - > get Colours Set Code ( ) , str _repeat ( ' ' , $ this - > style - > get Padding Left Right ( ) ) , str _repeat ( ' ' , mb _strlen ( $ this - > text ) ) , str _repeat ( ' ' , $ this - > style - > get Padding Left Right ( ) ) , $ this - > style - > get Colours Reset Code ( ) ) ) ; } 
protected function write ( string $ text , int $ column = null ) : void { $ this - > terminal - > move Cursor To Column ( $ column ? : $ this - > x ) ; $ this - > terminal - > write ( $ text ) ; } 
public function get Rows ( Menu Style $ style , bool $ selected = false ) : array { if ( $ this - > art Length > $ style - > get Content Width ( ) ) { $ alternate = new Static Item ( $ this - > alternate Text ) ; return $ alternate - > get Rows ( $ style , false ) ; } $ padding = $ style - > get Content Width ( ) - $ this - > art Length ; return array _map ( function ( $ row ) use ( $ padding ) { switch ( $ this - > position ) { case self : : POSITION _LEFT : break ; case self : : POSITION _RIGHT : $ row = sprintf ( ' %s %s ' , str _repeat ( ' ' , $ padding ) , $ row ) ; break ; case self : : POSITION _CENTER : default : $ left = ( int ) ceil ( $ padding / 2 ) ; $ row = sprintf ( ' %s %s ' , str _repeat ( ' ' , $ left ) , $ row ) ; break ; } return $ row ; } , explode ( " \n " , $ this - > text ) ) ; } 
public function set Text ( string $ text ) : void { $ this - > text = implode ( " \n " , array _map ( function ( string $ line ) { return rtrim ( $ line , ' ' ) ; } , explode ( " \n " , $ text ) ) ) ; $ this - > calculate Art Length ( ) ; } 
private function calculate Art Length ( ) : void { $ this - > art Length = ( int ) max ( array _map ( 'mb _strlen ' , explode ( " \n " , $ this - > text ) ) ) ; } 
public static function map 2 5 6To 8 ( int $ colour Code ) : string { if ( ! isset ( self : : $ colours Map [ $ colour Code ] ) ) { throw new \ Invalid Argument Exception ( 'Invalid colour code ' ) ; } return self : : $ colours Map [ $ colour Code ] ; } 
public static function validate Colour ( Terminal $ terminal , string $ colour , string $ fallback = null ) : string { if ( ! ctype _digit ( $ colour ) ) { return static : : validate Colour Name ( $ colour ) ; } Assertion : : between ( $ colour , 0 , 2 5 5 , 'Invalid colour code ' ) ; if ( $ terminal - > get Colour Support ( ) > = 2 5 6 ) { return $ colour ; } if ( $ fallback ! = = null ) { return static : : validate Colour Name ( $ fallback ) ; } return static : : map 2 5 6To 8 ( ( int ) $ colour ) ; } 
public function display ( string $ confirm Text = 'OK ' ) : void { $ this - > assert Menu Open ( ) ; $ this - > terminal - > move Cursor To Row ( $ this - > y ) ; $ prompt Width = mb _strlen ( $ this - > text ) + 4 ; $ this - > empty Row ( ) ; $ this - > write ( sprintf ( " %s %s %s %s %s \n " , $ this - > style - > get Colours Set Code ( ) , str _repeat ( ' ' , $ this - > style - > get Padding Left Right ( ) ) , $ this - > text , str _repeat ( ' ' , $ this - > style - > get Padding Left Right ( ) ) , $ this - > style - > get Colours Reset Code ( ) ) ) ; $ this - > empty Row ( ) ; $ confirm Text = sprintf ( ' < %s > ' , $ confirm Text ) ; $ left Fill = ( int ) ( ( $ prompt Width / 2 ) - ( mb _strlen ( $ confirm Text ) / 2 ) ) ; $ this - > write ( sprintf ( " %s %s %s %s %s %s %s \n " , $ this - > style - > get Colours Set Code ( ) , str _repeat ( ' ' , $ left Fill ) , $ this - > style - > get Inverted Colours Set Code ( ) , $ confirm Text , $ this - > style - > get Inverted Colours Unset Code ( ) , str _repeat ( ' ' , ( int ) ceil ( $ prompt Width - $ left Fill - mb _strlen ( $ confirm Text ) ) ) , $ this - > style - > get Colours Reset Code ( ) ) ) ; $ this - > write ( sprintf ( " %s %s %s %s %s \n " , $ this - > style - > get Colours Set Code ( ) , str _repeat ( ' ' , $ this - > style - > get Padding Left Right ( ) ) , str _repeat ( ' ' , mb _strlen ( $ this - > text ) ) , str _repeat ( ' ' , $ this - > style - > get Padding Left Right ( ) ) , $ this - > style - > get Colours Reset Code ( ) ) ) ; $ this - > terminal - > move Cursor To Top ( ) ; $ reader = new Non Canonical Reader ( $ this - > terminal ) ; while ( $ char = $ reader - > read Character ( ) ) { if ( $ char - > is Control ( ) & & $ char - > get Control ( ) = = = Input Character : : ENTER ) { $ this - > parent Menu - > redraw ( ) ; return ; } } } 
public function get Rows ( Menu Style $ style , bool $ selected = false ) : array { return explode ( " \n " , String Util : : wordwrap ( $ this - > text , $ style - > get Content Width ( ) ) ) ; } 
public function Data Contrast ( $ fee , $ time , $ Minute = 3 , $ Remarks = false ) { 
public function get Sync Key ( ) { try { $ html = ( new \ Guzzle Http \ Client ( ) ) - > request ( 'POST ' , "https : / / " . $ this - > url . " /cgi -bin /mmwebwx -bin /webwxinit ?r = 6 9 5 8 8 8 6 0 9 " , [ 'timeout ' = > 1 0 , 'headers ' = > [ 'Accept ' = > 'application /json , text /javascript ' , 'Accept -Encoding ' = > 'gzip , deflate , br ' , 'Accept -Language ' = > 'en -US ,en ;q = 0 . 9 ,zh -CN ;q = 0 . 8 ,zh ;q = 0 . 7 ' , 'Connection ' = > 'keep -alive ' , 'Content -Length ' = > ' 2 9 5 ' , 'Content -Type ' = > 'application /json ;charset =UTF - 8 ' , 'Cookie ' = > $ this - > cookie , 'Host ' = > $ this - > url , 'Origin ' = > 'https : / / ' . $ this - > url , 'Referer ' = > 'https : / / ' . $ this - > url . ' / ' , 'User -Agent ' = > 'Mozilla / 5 . 0 (Windows NT 1 0 . 0 ; Win 6 4 ; x 6 4 ) Apple Web Kit / 5 3 7 . 3 6 (KHTML , like Gecko ) Chrome / 6 8 . 0 . 3 4 4 0 . 1 0 6 Safari / 5 3 7 . 3 6 ' ] , 'body ' = > ' { "Base Request " : { "Uin " : ' . Cookie : : get Cookie Name ( 'wxuin ' , $ this - > cookie ) . ' , "Sid " : " ' . Cookie : : get Cookie Name ( 'wxsid ' , $ this - > cookie ) . ' " , "Skey " : ' . ' " " , "Device ID " : "e 4 5 3 7 3 1 5 0 6 7 5 4 0 0 0 " } } ' ] ) - > get Body ( ) ; return json _decode ( $ html - > get Contents ( ) , true ) ; } catch ( Guzzle Exception $ e ) { throw new Pay Exception ( ' 访 问 出 错 ' , 5 0 0 ) ; } catch ( Pay Exception $ e ) { throw new Pay Exception ( $ e - > get Message ( ) , $ e - > get Code ( ) ) ; } catch ( \ Exception $ e ) { throw new Pay Exception ( ' 处 理 出 错 ' , 4 4 4 ) ; } } 
public function Data Contrast ( $ fee , $ time , $ Minute = 3 , $ Remarks = false ) { 
public static function get Cookie Name ( $ name = 'uid ' , $ cookie = false ) { $ get Cookie = explode ( $ name . ' = ' , $ cookie ) ; if ( count ( $ get Cookie ) < = 1 ) throw new Pay Exception ( 'cookie 有 误 ' , 4 4 5 ; if ( $ name = = 'uid ' ) return explode ( ' " ' , $ get Cookie [ 1 ] ) [ 0 ] ; else return explode ( ' ; ' , $ get Cookie [ 1 ] ) [ 0 ] ; } 
protected function build Client ( array $ config ) : Client { $ client Builder = Client Builder : : create ( ) ; 
public function register ( ) { $ app = $ this - > app ; $ app - > singleton ( 'elasticsearch .factory ' , function ( $ app ) { return new Factory ( ) ; } ) ; $ app - > singleton ( 'elasticsearch ' , function ( $ app ) { return new Manager ( $ app , $ app [ 'elasticsearch .factory ' ] ) ; } ) ; $ app - > alias ( 'elasticsearch ' , Manager : : class ) ; $ app - > singleton ( Client : : class , function ( $ app ) { return $ app [ 'elasticsearch ' ] - > connection ( ) ; } ) ; } 
public function connection ( string $ name = null ) : Client { $ name = $ name ? : $ this - > get Default Connection ( ) ; if ( ! isset ( $ this - > connections [ $ name ] ) ) { $ client = $ this - > make Connection ( $ name ) ; $ this - > connections [ $ name ] = $ client ; } return $ this - > connections [ $ name ] ; } 
protected function make Connection ( string $ name ) : Client { $ config = $ this - > get Config ( $ name ) ; return $ this - > factory - > make ( $ config ) ; } 
protected function get Config ( string $ name ) { $ connections = $ this - > app [ 'config ' ] [ 'elasticsearch .connections ' ] ; if ( null = = = $ config = array _get ( $ connections , $ name ) ) { throw new \ Invalid Argument Exception ( "Elasticsearch connection [ $name ] not configured . " ) ; } return $ config ; } 
public function Compress ( & $ curl _headers , & $ request Body ) { if ( ! function _exists ( 'gzencode ' ) ) { return ; } $ request Body = gzencode ( $ request Body ) ; $ curl _headers [ 'content -encoding ' ] = 'deflate ' ; $ curl _headers [ 'content -length ' ] = strlen ( $ request Body ) ; } 
public static function update ( $ obj To Update , array $ data ) { $ class Of Obj = get _class ( $ obj To Update ) ; if ( strcmp ( $ class Of Obj , Facade Helper : : simple Append Class Name Space ( "Account " ) ) ! = 0 ) { throw new \ Exception ( "Target object class : { " . $ class Of Obj . " } is not an instance of Account . " ) ; } $ new Account Obj = Account : : create ( $ data ) ; $ cloned Of Obj = Facade Helper : : clone Obj ( $ obj To Update ) ; Facade Helper : : merge Obj ( $ cloned Of Obj , $ new Account Obj ) ; return $ cloned Of Obj ; } 
public function _ _isset ( $ key ) { $ this - > parse ( ) ; if ( isset ( $ this - > _rule Map [ $ key ] ) ) { $ key = $ this - > _rule Map [ $ key ] ; return isset ( $ this - > _options [ $ key ] ) ; } return false ; } 
public function add Arguments ( $ argv ) { if ( ! is _array ( $ argv ) ) { require _once 'Zend /Console /Getopt /Exception .php ' ; throw new Zend _Console _Getopt _Exception ( "Parameter # 1 to add Arguments should be an array " ) ; } $ this - > _argv = array _merge ( $ this - > _argv , $ argv ) ; $ this - > _parsed = false ; return $ this ; } 
public function set Arguments ( $ argv ) { if ( ! is _array ( $ argv ) ) { require _once 'Zend /Console /Getopt /Exception .php ' ; throw new Zend _Console _Getopt _Exception ( "Parameter # 1 to set Arguments should be an array " ) ; } $ this - > _argv = $ argv ; $ this - > _parsed = false ; return $ this ; } 
public function set Options ( $ getopt Config ) { if ( isset ( $ getopt Config ) ) { foreach ( $ getopt Config as $ key = > $ value ) { $ this - > set Option ( $ key , $ value ) ; } } return $ this ; } 
public function set Option ( $ config Key , $ config Value ) { if ( $ config Key ! = = null ) { $ this - > _getopt Config [ $ config Key ] = $ config Value ; } return $ this ; } 
public function add Rules ( $ rules ) { $ rule Mode = $ this - > _getopt Config [ 'rule Mode ' ] ; switch ( $ this - > _getopt Config [ 'rule Mode ' ] ) { case self : : MODE _ZEND : if ( is _array ( $ rules ) ) { $ this - > _add Rules Mode Zend ( $ rules ) ; break ; } * Call add Rules Mode Foo ( ) for rule Mode 'foo ' . * The developer should subclass Getopt and * provide this method . * / $ method = ' _add Rules Mode ' . ucfirst ( $ rule Mode ) ; $ this - > $ method ( $ rules ) ; } $ this - > _parsed = false ; return $ this ; } 
public function to String ( ) { $ this - > parse ( ) ; $ s = array ( ) ; foreach ( $ this - > _options as $ flag = > $ value ) { $ s [ ] = $ flag . ' = ' . ( $ value = = = true ? 'true ' : $ value ) ; } return implode ( ' ' , $ s ) ; } 
public function to Array ( ) { $ this - > parse ( ) ; $ s = array ( ) ; foreach ( $ this - > _options as $ flag = > $ value ) { $ s [ ] = $ flag ; if ( $ value ! = = true ) { $ s [ ] = $ value ; } } return $ s ; } 
public function to Json ( ) { $ this - > parse ( ) ; $ j = array ( ) ; foreach ( $ this - > _options as $ flag = > $ value ) { $ j [ 'options ' ] [ ] = array ( 'option ' = > array ( 'flag ' = > $ flag , 'parameter ' = > $ value ) ) ; } require _once 'Zend /Json .php ' ; $ json = Zend _Json : : encode ( $ j ) ; return $ json ; } 
public function to Xml ( ) { $ this - > parse ( ) ; $ doc = new Dom Document ( ' 1 . 0 ' , 'utf - 8 ' ) ; $ options Node = $ doc - > create Element ( 'options ' ) ; $ doc - > append Child ( $ options Node ) ; foreach ( $ this - > _options as $ flag = > $ value ) { $ option Node = $ doc - > create Element ( 'option ' ) ; $ option Node - > set Attribute ( 'flag ' , utf 8 _encode ( $ flag ) ) ; if ( $ value ! = = true ) { $ option Node - > set Attribute ( 'parameter ' , utf 8 _encode ( $ value ) ) ; } $ options Node - > append Child ( $ option Node ) ; } $ xml = $ doc - > save XML ( ) ; return $ xml ; } 
public function get Option ( $ flag ) { $ this - > parse ( ) ; if ( $ this - > _getopt Config [ self : : CONFIG _IGNORECASE ] ) { $ flag = strtolower ( $ flag ) ; } if ( isset ( $ this - > _rule Map [ $ flag ] ) ) { $ flag = $ this - > _rule Map [ $ flag ] ; if ( isset ( $ this - > _options [ $ flag ] ) ) { return $ this - > _options [ $ flag ] ; } } return null ; } 
public function get Usage Message ( ) { $ usage = "Usage : { $this - > _progname } [ options ] \n " ; $ max Len = 2 0 ; $ lines = array ( ) ; foreach ( $ this - > _rules as $ rule ) { $ flags = array ( ) ; if ( is _array ( $ rule [ 'alias ' ] ) ) { foreach ( $ rule [ 'alias ' ] as $ flag ) { $ flags [ ] = ( strlen ( $ flag ) = = 1 ? ' - ' : ' - - ' ) . $ flag ; } } $ linepart [ 'name ' ] = implode ( ' | ' , $ flags ) ; if ( isset ( $ rule [ 'param ' ] ) & & $ rule [ 'param ' ] ! = 'none ' ) { $ linepart [ 'name ' ] . = ' ' ; switch ( $ rule [ 'param ' ] ) { case 'optional ' : $ linepart [ 'name ' ] . = " [ < { $rule [ 'param Type ' ] } > ] " ; break ; case 'required ' : $ linepart [ 'name ' ] . = " < { $rule [ 'param Type ' ] } > " ; break ; } } if ( strlen ( $ linepart [ 'name ' ] ) > $ max Len ) { $ max Len = strlen ( $ linepart [ 'name ' ] ) ; } $ linepart [ 'help ' ] = ' ' ; if ( isset ( $ rule [ 'help ' ] ) ) { $ linepart [ 'help ' ] . = $ rule [ 'help ' ] ; } $ lines [ ] = $ linepart ; } foreach ( $ lines as $ linepart ) { $ usage . = sprintf ( " %s %s \n " , str _pad ( $ linepart [ 'name ' ] , $ max Len ) , $ linepart [ 'help ' ] ) ; } return $ usage ; } 
public function set Aliases ( $ alias Map ) { foreach ( $ alias Map as $ flag = > $ alias ) { if ( $ this - > _getopt Config [ self : : CONFIG _IGNORECASE ] ) { $ flag = strtolower ( $ flag ) ; $ alias = strtolower ( $ alias ) ; } if ( ! isset ( $ this - > _rule Map [ $ flag ] ) ) { continue ; } $ flag = $ this - > _rule Map [ $ flag ] ; if ( isset ( $ this - > _rules [ $ alias ] ) | | isset ( $ this - > _rule Map [ $ alias ] ) ) { $ o = ( strlen ( $ alias ) = = 1 ? ' - ' : ' - - ' ) . $ alias ; require _once 'Zend /Console /Getopt /Exception .php ' ; throw new Zend _Console _Getopt _Exception ( "Option \ " $o \ " is being defined more than once . " ) ; } $ this - > _rules [ $ flag ] [ 'alias ' ] [ ] = $ alias ; $ this - > _rule Map [ $ alias ] = $ flag ; } return $ this ; } 
public function set Help ( $ help Map ) { foreach ( $ help Map as $ flag = > $ help ) { if ( ! isset ( $ this - > _rule Map [ $ flag ] ) ) { continue ; } $ flag = $ this - > _rule Map [ $ flag ] ; $ this - > _rules [ $ flag ] [ 'help ' ] = $ help ; } return $ this ; } 
public function parse ( ) { if ( $ this - > _parsed = = = true ) { return ; } $ argv = $ this - > _argv ; $ this - > _options = array ( ) ; $ this - > _remaining Args = array ( ) ; while ( count ( $ argv ) > 0 ) { if ( $ argv [ 0 ] = = ' - - ' ) { array _shift ( $ argv ) ; if ( $ this - > _getopt Config [ self : : CONFIG _DASHDASH ] ) { $ this - > _remaining Args = array _merge ( $ this - > _remaining Args , $ argv ) ; break ; } } if ( substr ( $ argv [ 0 ] , 0 , 2 ) = = ' - - ' ) { $ this - > _parse Long Option ( $ argv ) ; } elseif ( substr ( $ argv [ 0 ] , 0 , 1 ) = = ' - ' & & ( ' - ' ! = $ argv [ 0 ] | | count ( $ argv ) > 1 ) ) { $ this - > _parse Short Option Cluster ( $ argv ) ; } elseif ( $ this - > _getopt Config [ self : : CONFIG _PARSEALL ] ) { $ this - > _remaining Args [ ] = array _shift ( $ argv ) ; } else { $ this - > _remaining Args = array _merge ( $ this - > _remaining Args , $ argv ) ; break ; } } $ this - > _parsed = true ; return $ this ; } 
protected function _parse Long Option ( & $ argv ) { $ option With Param = ltrim ( array _shift ( $ argv ) , ' - ' ) ; $ l = explode ( ' = ' , $ option With Param , 2 ) ; $ flag = array _shift ( $ l ) ; $ param = array _shift ( $ l ) ; if ( isset ( $ param ) ) { array _unshift ( $ argv , $ param ) ; } $ this - > _parse Single Option ( $ flag , $ argv ) ; } 
protected function _parse Short Option Cluster ( & $ argv ) { $ flag Cluster = ltrim ( array _shift ( $ argv ) , ' - ' ) ; foreach ( str _split ( $ flag Cluster ) as $ flag ) { $ this - > _parse Single Option ( $ flag , $ argv ) ; } } 
protected function _parse Single Option ( $ flag , & $ argv ) { if ( $ this - > _getopt Config [ self : : CONFIG _IGNORECASE ] ) { $ flag = strtolower ( $ flag ) ; } if ( ! isset ( $ this - > _rule Map [ $ flag ] ) ) { require _once 'Zend /Console /Getopt /Exception .php ' ; throw new Zend _Console _Getopt _Exception ( "Option \ " $flag \ " is not recognized . " , $ this - > get Usage Message ( ) ) ; } $ real Flag = $ this - > _rule Map [ $ flag ] ; switch ( $ this - > _rules [ $ real Flag ] [ 'param ' ] ) { case 'required ' : if ( count ( $ argv ) > 0 ) { $ param = array _shift ( $ argv ) ; $ this - > _check Parameter Type ( $ real Flag , $ param ) ; } else { require _once 'Zend /Console /Getopt /Exception .php ' ; throw new Zend _Console _Getopt _Exception ( "Option \ " $flag \ " requires a parameter . " , $ this - > get Usage Message ( ) ) ; } break ; case 'optional ' : if ( count ( $ argv ) > 0 & & substr ( $ argv [ 0 ] , 0 , 1 ) ! = ' - ' ) { $ param = array _shift ( $ argv ) ; $ this - > _check Parameter Type ( $ real Flag , $ param ) ; } else { $ param = true ; } break ; default : $ param = true ; } $ this - > _options [ $ real Flag ] = $ param ; } 
protected function _check Parameter Type ( $ flag , $ param ) { $ type = 'string ' ; if ( isset ( $ this - > _rules [ $ flag ] [ 'param Type ' ] ) ) { $ type = $ this - > _rules [ $ flag ] [ 'param Type ' ] ; } switch ( $ type ) { case 'word ' : if ( preg _match ( ' / \W / ' , $ param ) ) { require _once 'Zend /Console /Getopt /Exception .php ' ; throw new Zend _Console _Getopt _Exception ( "Option \ " $flag \ " requires a single -word parameter , but was given \ " $param \ " . " , $ this - > get Usage Message ( ) ) ; } break ; case 'integer ' : if ( preg _match ( ' / \D / ' , $ param ) ) { require _once 'Zend /Console /Getopt /Exception .php ' ; throw new Zend _Console _Getopt _Exception ( "Option \ " $flag \ " requires an integer parameter , but was given \ " $param \ " . " , $ this - > get Usage Message ( ) ) ; } break ; case 'string ' : default : break ; } return true ; } 
protected function _add Rules Mode Gnu ( $ rules ) { $ rule Array = array ( ) ; preg _match _all ( ' / ( [a -z A -Z 0 - 9 ] : ? ) / ' , $ rules , $ rule Array ) ; foreach ( $ rule Array [ 1 ] as $ rule ) { $ r = array ( ) ; $ flag = substr ( $ rule , 0 , 1 ) ; if ( $ this - > _getopt Config [ self : : CONFIG _IGNORECASE ] ) { $ flag = strtolower ( $ flag ) ; } $ r [ 'alias ' ] [ ] = $ flag ; if ( substr ( $ rule , 1 , 1 ) = = ' : ' ) { $ r [ 'param ' ] = 'required ' ; $ r [ 'param Type ' ] = 'string ' ; } else { $ r [ 'param ' ] = 'none ' ; } $ this - > _rules [ $ flag ] = $ r ; $ this - > _rule Map [ $ flag ] = $ flag ; } } 
protected function _add Rules Mode Zend ( $ rules ) { foreach ( $ rules as $ rule Code = > $ help Message ) { 
public function get OAuth Header ( $ uri , $ query Parameters , $ http Method ) { $ this - > sign ( $ uri , $ query Parameters , $ http Method ) ; foreach ( $ this - > oauth Parameters as $ k = > $ v ) { $ this - > oauth Parameters [ $ k ] = $ k . ' = " ' . rawurlencode ( $ v ) . ' " ' ; } return 'OAuth ' . implode ( ' , ' , $ this - > oauth Parameters ) ; } 
public function sign ( $ uri , $ query Parameters , $ http Method ) { $ base String = $ this - > get Base String ( $ uri , $ http Method , $ query Parameters ) ; $ oauth Signature = $ this - > sign Using Hmac Sha 1 ( $ base String ) ; $ this - > oauth Parameters [ 'oauth _signature ' ] = $ oauth Signature ; } 
public function get Base String ( $ uri , $ method , array $ parameters = array ( ) ) { $ base String = $ this - > prepare Http Method ( $ method ) . ' & ' . $ this - > prepare URL ( $ uri ) . ' & ' . $ this - > prepare Query Params ( $ parameters ) ; return $ base String ; } 
private function prepare Http Method ( $ method ) { $ trimmed Method = trim ( $ method ) ; $ upper Method = strtoupper ( $ trimmed Method ) ; return rawurlencode ( $ method ) ; } 
private function prepare Query Params ( $ query Parameters ) { $ appended Query Params = $ this - > append OAuth Parts To ( $ query Parameters ) ; array _walk _recursive ( $ appended Query Params , function ( & $ key , & $ value ) { $ key = rawurlencode ( $ key ) ; $ value = rawurlencode ( $ value ) ; } ) ; uksort ( $ appended Query Params , 'strcmp ' ) ; $ pairs = [ ] ; foreach ( $ appended Query Params as $ parameter = > $ value ) { if ( is _array ( $ value ) ) { 
public function sign Using Hmac Sha 1 ( $ base String ) { $ key = rawurlencode ( $ this - > consumer Secret ) . ' & ' . rawurlencode ( $ this - > oauth Token Secret ) ; return base 6 4 _encode ( hash _hmac ( self : : SIGNATURE _METHOD , $ base String , $ key , TRUE ) ) ; } 
private function set Nonce ( $ length = 6 ) { $ result = ' ' ; $ c Length = strlen ( self : : NONCE _CHARS ) ; for ( $ i = 0 ; $ i < $ length ; $ i + + ) { $ rnum = rand ( 0 , $ c Length - 1 ) ; $ result . = substr ( self : : NONCE _CHARS , $ rnum , 1 ) ; } $ this - > oauth Nonce = $ result ; } 
private function append OAuth Parts To ( array $ query Parameters = null ) { if ( $ query Parameters = = null ) { $ query Parameters = array ( ) ; } $ query Parameters [ 'oauth _consumer _key ' ] = $ this - > consumer Key ; $ query Parameters [ 'oauth _token ' ] = $ this - > oauth Token ; $ query Parameters [ 'oauth _signature _method ' ] = 'HMAC -SHA 1 ' ; $ query Parameters [ 'oauth _timestamp ' ] = $ this - > oauth Time Stamp ; $ query Parameters [ 'oauth _nonce ' ] = $ this - > oauth Nonce ; $ query Parameters [ 'oauth _version ' ] = ' 1 . 0 ' ; return $ query Parameters ; } 
public function get String ( ) { if ( empty ( $ this - > sql ) | | empty ( $ this - > entity ) ) { return null ; } $ query = " " ; $ query . = $ this - > sql ; if ( 0 = = count ( $ this - > projection ) ) { $ query . = " " . " * " ; } else { if ( count ( $ this - > projection ) ) { $ query . = " " . implode ( " , " , $ this - > projection ) ; } } $ query . = " FROM " . $ this - > entity ; if ( ! empty ( $ this - > where Clause ) ) { if ( count ( $ this - > where Clause ) ) { $ query . = " WHERE " . implode ( " AND " , $ this - > where Clause ) ; } } if ( ! empty ( $ this - > order By Clause ) ) { $ query . = " ORDERBY " . $ this - > order By Clause ; } if ( ! empty ( $ this - > startposition ) ) { $ query . = " STARTPOSITION " . $ this - > startposition ; } if ( ! empty ( $ this - > maxresults ) ) { $ query . = " MAXRESULTS " . $ this - > maxresults ; } return $ query ; } 
public static function create Client ( $ client Name = Core Constants : : CLIENT _CURL ) { if ( $ client Name = = Core Constants : : CLIENT _CURL ) { if ( extension _loaded ( 'curl ' ) ) { return new Curl Http Client ( ) ; } else { throw new Sdk Exception ( "curl extension is not enabled . Cannot create curl http client for the SDK . " ) ; } } if ( strcasecmp ( $ client Name , Core Constants : : CLIENT _GUZZLE ) = = 0 | | strcasecmp ( $ client Name , Core Constants : : CLIENT _GUZZLE _FULL ) = = 0 ) { if ( class _exists ( 'Guzzle Http \Client ' ) ) { return new Guzzle Http Client ( ) ; } else { throw new Sdk Exception ( "guzzle client cannot be found . Cannot create guzzle http client for the SDK . " ) ; } } throw new Sdk Exception ( "The client Name you passed is not supported . Please use either 'curl ' or 'guzzle ' for the client Name . " ) ; } 
public static function update ( $ obj To Update , array $ data ) { $ data = Journal Entry : : change Array Name ( $ data ) ; $ class Of Obj = get _class ( $ obj To Update ) ; if ( strcmp ( $ class Of Obj , Facade Helper : : simple Append Class Name Space ( "Journal Entry " ) ) ! = 0 ) { throw new \ Exception ( "Target object class : { " . $ class Of Obj . " } is not an instance of Journal Entry . " ) ; } $ new Journal Entry Obj = Journal Entry : : create ( $ data ) ; $ cloned Of Obj = Facade Helper : : clone Obj ( $ obj To Update ) ; Facade Helper : : merge Obj ( $ cloned Of Obj , $ new Journal Entry Obj ) ; return $ cloned Of Obj ; } 
public function Get Log Destination ( ) { if ( $ this - > Enable Service Requests Logging ) { if ( false = = = file _exists ( $ this - > Service Request Logging Location ) ) { $ this - > Service Request Logging Location = sys _get _temp _dir ( ) ; } } return $ this - > Service Request Logging Location ; } 
public function Log Platform Requests ( $ xml , $ url , $ headers , $ is Request ) { if ( $ this - > Enable Service Requests Logging ) { if ( false = = = file _exists ( $ this - > Service Request Logging Location ) ) { $ this - > Service Request Logging Location = sys _get _temp _dir ( ) ; } 
public function is Allowed ( $ entity , $ operation ) { 
private function prepare Dom ( ) { $ this - > dom = new \ DOMDocument ( ' 1 . 0 ' , 'UTF - 8 ' ) ; if ( $ this - > debug ) { $ this - > dom - > format Output = true ; } $ this - > ws Definitions = $ this - > dom - > create Element NS ( $ this - > namespaces [ 'wsdl ' ] , 'wsdl :definitions ' ) ; $ this - > dom - > append Child ( $ this - > ws Definitions ) ; $ this - > ws Definitions - > set Attribute ( 'name ' , $ this - > wsdl Name ) ; $ this - > ws Definitions - > set Attribute ( 'target Namespace ' , $ this - > wsdl Target Namespace ) ; $ this - > dom - > create Attribute NS ( $ this - > wsdl Target Namespace , $ this - > target Ns Prefix . ' :definitions ' ) ; 
private function prepare Reflection ( ) { $ methods = $ this - > get Class Methods ( ) ; foreach ( $ methods as $ method ) { $ this - > methods Meta [ $ method - > name ] = $ this - > get Method IO ( $ method - > name ) ; } } 
public function to Xml ( ) { if ( is _string ( $ this - > wsdl Xml Source ) & & $ this - > wsdl Xml Source ! = ' ' ) { return $ this - > wsdl Xml Source ; } else { $ this - > prepare Dom ( ) ; $ this - > prepare Reflection ( ) ; $ this - > prepare ( ) ; $ this - > wsdl Xml Source = $ this - > dom - > save XML ( ) ; return $ this - > wsdl Xml Source ; } } 
protected function get Type Name ( $ type ) { 
private function add Import To Schema ( $ namespace , $ code ) { if ( array _key _exists ( $ namespace , $ this - > doc Namespaces ) ) { if ( in _array ( $ namespace , $ this - > imported Namespaces ) ) { return ; } 
public function get Schema Location ( $ ns ) { if ( $ this - > get Schemas Path ( ) = = null ) { throw new \ Runtime Exception ( "Schemas path is not specified - cannot start search for imports " ) ; } if ( ! file _exists ( $ this - > get Schemas Path ( ) ) ) { throw new \ Runtime Exception ( "Schemas path doesn 't exist - cannot start search for imports " ) ; } if ( $ this - > get Public Path ( ) = = null | | ! file _exists ( $ this - > get Public Path ( ) ) ) { throw new \ Runtime Exception ( "Public folder for imported schemas is not specified or is not exist - cannot save imports " ) ; } if ( ! is _readable ( $ this - > get Schemas Path ( ) ) ) { throw new \ Runtime Exception ( $ this - > get Schemas Path ( ) . " is not readable " ) ; } if ( ! is _writeable ( $ this - > get Public Path ( ) ) ) { throw new \ Runtime Exception ( $ this - > get Public Path ( ) . " is not writable " ) ; } 
public function imports To Abs Url ( $ schema Path , $ rel Path = ' ' ) { $ dom = new \ DOMDocument ( ) ; $ dom - > load ( $ schema Path ) ; $ xpath = new \ DOMXPath ( $ dom ) ; $ query = " / / * [local -name ( ) = 'schema ' ] / * [local -name ( ) = 'import ' ] " ; $ imports = $ xpath - > query ( $ query ) ; $ url Parts = parse _url ( $ this - > get Location ( ) ) ; $ root Url = $ this - > compose Url ( $ url Parts ) ; $ url = $ root Url . $ this - > get Public Url ( ) . " / " . basename ( $ schema Path ) ; if ( ! is _object ( $ imports - > item ( 0 ) ) ) { return $ url ; } $ url Parts = parse _url ( $ this - > get Location ( ) ) ; $ root Url = $ this - > compose Url ( $ url Parts ) ; foreach ( $ imports as $ import ) { $ sc Path = realpath ( $ rel Path . DIRECTORY _SEPARATOR . $ import - > get Attribute ( 'schema Location ' ) ) ; $ copied Schema = $ this - > copy To Public ( $ sc Path , true ) ; $ schema Url = $ root Url . $ this - > get Public Url ( ) . " / " . basename ( $ copied Schema ) ; $ import - > set Attribute ( 'schema Location ' , $ schema Url ) ; $ this - > imports To Abs Url ( $ copied Schema , dirname ( $ sc Path ) ) ; } $ dom - > save ( $ schema Path ) ; return $ url ; } 
protected function get Class Namespace ( $ class ) { $ refl = new \ Reflection Class ( $ class ) ; $ docs = $ this - > common - > parse Doc Comments ( $ refl - > get Doc Comment ( ) ) ; if ( ! array _key _exists ( "xml Namespace " , $ docs ) ) { throw new \ Runtime Exception ( 'Cannot find namespace in class description in ' . $ class ) ; } return $ docs [ 'xml Namespace ' ] ; } 
public function is Target Namespace Equals To ( $ schema , $ ns ) { $ dom = new \ DOMDocument ( ) ; $ dom - > load ( $ schema ) ; $ xpath = new \ DOMXPath ( $ dom ) ; $ query = " / / * [local -name ( ) = 'schema ' ] / @target Namespace " ; $ t Ns = $ xpath - > query ( $ query ) ; if ( ! is _object ( $ t Ns - > item ( 0 ) ) ) { return false ; } if ( $ t Ns - > item ( 0 ) - > node Value = = = $ ns ) { return true ; } else { return false ; } } 
public function copy To Public ( $ path , $ overwrite = false ) { $ public Path = realpath ( $ this - > get Public Path ( ) ) ; $ target File Path = $ public Path . DIRECTORY _SEPARATOR . basename ( $ path ) ; if ( ( $ overwrite = = = true & & file _exists ( $ target File Path ) ) | | ! file _exists ( $ target File Path ) ) { if ( ! copy ( $ path , $ target File Path ) ) { throw new \ Runtime Exception ( "Cannot copy " . basename ( $ path ) . " to " . $ public Path ) ; } } return $ target File Path ; } 
public function compose Url ( $ parts ) { $ url = " " ; if ( array _key _exists ( 'scheme ' , $ parts ) ) { $ url . = $ parts [ 'scheme ' ] . " : / / " ; } if ( array _key _exists ( 'host ' , $ parts ) ) { $ url . = $ parts [ 'host ' ] ; } if ( array _key _exists ( 'port ' , $ parts ) ) { $ url . = " : " . $ parts [ 'port ' ] ; } if ( array _key _exists ( 'path ' , $ parts ) ) { } return $ url ; } 
private function get _class _vars _fix _order ( $ class Name ) { $ prop Names = array ( ) ; $ parent Class Name = get _parent _class ( $ class Name ) ; $ class Members Only Inherited = array ( ) ; if ( $ parent Class Name ) { $ class Members Only Inherited = $ this - > get _class _vars _fix _order ( get _parent _class ( $ class Name ) ) ; } $ class Members Including Inherited = array _keys ( get _class _vars ( $ class Name ) ) ; $ class Members Not Inherited = array _diff ( $ class Members Including Inherited , $ class Members Only Inherited ) ; $ ordered Class Members = array _merge ( $ class Members Only Inherited , $ class Members Not Inherited ) ; return $ ordered Class Members ; } 
private function cast To String Zero ( $ prop , $ obj ) { if ( $ this - > is Empty Int ( $ prop - > get Value ( $ obj ) ) ) { 
public function Log ( $ ids Trace Level , $ message To Write ) { $ file To Write = Core Constants : : DEFAULT _LOGGINGLOCATION . ' /executionlog .txt ' ; if ( file _exists ( $ file To Write ) & & is _writable ( $ file To Write ) ) { file _put _contents ( $ file To Write , $ message To Write . " \n " , FILE _APPEND ) ; } } 
public static function Read Configuration From File ( $ file Path , $ OAuth Option = Core Constants : : OAUTH 1 ) { $ ipp Config = new Ipp Configuration ( ) ; try { if ( isset ( $ file Path ) & & file _exists ( $ file Path ) ) { $ xml Obj = simplexml _load _file ( $ file Path ) ; } else { 
public static function initialize APIEntity Rules ( $ xml Obj , $ ipp Config ) { $ rules = Core Constants : : get Quick Books Online APIEntity Rules ( ) ; Local Config Reader : : init Operation Control List ( $ ipp Config , $ rules ) ; $ special Config = Local Config Reader : : populate Json Only Entities ( $ xml Obj ) ; if ( is _array ( $ special Config ) & & ( $ ipp Config - > Op Control List instanceof Operation Control List ) ) { $ ipp Config - > Op Control List - > append Rules ( $ special Config ) ; } } 
public static function init Operation Control List ( $ ipp Config , $ array ) { $ ipp Config - > Op Control List = new Operation Control List ( Operation Control List : : get Default List ( true ) ) ; $ ipp Config - > Op Control List - > append Rules ( $ array ) ; } 
public static function setup Minor Version ( $ ipp Config , $ xml Obj ) { if ( isset ( $ xml Obj ) & & isset ( $ xml Obj - > intuit - > ipp - > minor Version ) ) { $ ipp Config - > minor Version = ( int ) $ xml Obj - > intuit - > ipp - > minor Version ; } } 
public static function populate Json Only Entities ( $ xml Obj ) { if ( isset ( $ xml Obj ) & & isset ( $ xml Obj - > intuit - > ipp - > special Configuration ) ) { $ special Cnf = $ xml Obj - > intuit - > ipp - > special Configuration ; if ( ! $ special Cnf instanceof Simple XMLElement ) { return false ; } if ( ! $ special Cnf - > children ( ) instanceof Simple XMLElement ) { return false ; } if ( ! $ special Cnf - > children ( ) - > count ( ) ) { return false ; } $ rules = array ( ) ; foreach ( $ special Cnf - > children ( ) as $ entity ) { if ( ! $ entity - > attributes ( ) - > count ( ) ) { continue ; } $ name = self : : decorate Entity ( $ entity - > get Name ( ) ) ; if ( ! array _key _exists ( $ name , $ rules ) ) { $ rules [ $ name ] = array ( ) ; } foreach ( $ entity - > attributes ( ) as $ attr ) { $ rules [ $ name ] [ $ attr - > get Name ( ) ] = filter _var ( ( string ) $ entity - > attributes ( ) , FILTER _VALIDATE _BOOLEAN ) ; } } return $ rules ; } return false ; } 
public static function initialize OAuth Settings ( $ xml Obj , $ ipp Config , $ OAuth Option ) { 
public static function initialize Request And Response Serialization And Compression Format ( $ xml Obj , $ ipp Config ) { Local Config Reader : : intialize Message ( $ ipp Config ) ; $ request Serialization Format = null ; $ request Compression Format = null ; $ response Serialization Format = null ; $ response Compression Format = null ; if ( isset ( $ xml Obj ) & & isset ( $ xml Obj - > intuit - > ipp - > message - > request ) ) { $ request Attr = $ xml Obj - > intuit - > ipp - > message - > request - > attributes ( ) ; $ request Serialization Format = ( string ) $ request Attr - > serialization Format ; $ request Compression Format = ( string ) $ request Attr - > compression Format ; } 
public static function intializae Service Base URLAnd Logger ( $ xml Obj , $ ipp Config ) { 
public function get Entity ( $ key ) { foreach ( $ this - > entities as $ entity Key = > $ entity Val ) { if ( $ entity Key = = $ key ) { return $ entity Val ; } } return null ; } 
public static function clean Php Class Name To Intuit Entity Name ( $ php Class Name ) { 
public static function update ( $ obj To Update , array $ data ) { $ class Of Obj = get _class ( $ obj To Update ) ; if ( strcmp ( $ class Of Obj , Facade Helper : : simple Append Class Name Space ( "Payment " ) ) ! = 0 ) { throw new \ Exception ( "Target object class : { " . $ class Of Obj . " } is not an instance of Payment . " ) ; } $ new Payment Obj = Payment : : create ( $ data ) ; $ cloned Of Obj = Facade Helper : : clone Obj ( $ obj To Update ) ; Facade Helper : : merge Obj ( $ cloned Of Obj , $ new Payment Obj ) ; return $ cloned Of Obj ; } 
public static function Handle Errors ( $ response ) { 
public static function Handle Errors Xml ( $ response Xml ) { $ err Code Node = $ response Xml - > { Utility Constants : : ERRCODEXPATH } ; if ( $ err Code Node = = null ) { return ; } if ( ( int ) $ err Code Node ) { throw new Ids Exception ( 'Handle Errors error code (Utility Constants : :ERRCODEXPATH ) : ' . ( int ) $ err Code Node ) ; } $ err Text Node = $ response Xml - > { Utility Constants : : ERRTEXTXPATH } ; if ( $ err Text Node = = null ) { throw new Ids Exception ( 'Handle Errors error code (Utility Constants : :ERRTEXTXPATH ) : ' . ( int ) $ err Code Node ) ; } $ error Text = ( string ) $ err Text Node ; $ err Detail Node = $ response Xml - > { Utility Constants : : ERRDETAILXPATH } ; $ error Detail = $ err Detail Node ! = null ? ( string ) $ err Detail Node : null ; if ( ! $ error Detail ) { throw new Ids Exception ( 'Handle Errors error code (Utility Constants : :ERRDETAILXPATH ) : ' . ( string ) $ error Detail ) ; } throw new Ids Exception ( 'Handle Errors error code : ' . $ error Text ) ; } 
public static function Is Valid Xml ( $ input String ) { if ( 0 ! = = strpos ( $ input String , ' < ' ) ) { return false ; } try { $ doc = simplexml _load _string ( $ input String ) ; } catch ( \ Exception $ e ) { return false ; } return true ; } 
public function verify Configuration ( ) { if ( ( $ this - > strategy = = = Core Constants : : EXPORT _STRATEGY ) & & ! empty ( $ this - > strategy ) ) { if ( is _null ( $ this - > export Dir ) ) { throw new Sdk Exception ( "Invalid value for export Directory property . It can not be null with 'export ' strategy . " ) ; } 
public static function load Web Services Class And Return Names ( $ dir = null ) { if ( $ dir = = null ) { $ dir = dirname ( _ _DIR _ _ ) . DIRECTORY _SEPARATOR . Utility Constants : : WEBHOOKSDIR ; } $ webhooks Class Names = array ( ) ; foreach ( glob ( " { $dir } / * .php " ) as $ file Name ) { require _once ( $ file Name ) ; 
public static function is Valid Webhooks Class ( $ class Name , $ class Collection = null ) { if ( ! isset ( $ class Collection ) ) { $ class Collection = Reflection Util : : load Web Services Class And Return Names ( ) ; } if ( ! isset ( $ class Name ) | | trim ( $ class Name ) = = = ' ' ) { return null ; } $ singler Class Name = Class Naming Util : : singularize ( $ class Name ) ; $ capital First Singler Class Name = ucfirst ( $ singler Class Name ) ; foreach ( $ class Collection as $ k = > $ v ) { if ( strcmp ( $ capital First Singler Class Name , $ v ) = = 0 ) { return $ capital First Singler Class Name ; } } return null ; } 
public static function construct Object From Webhooks Array ( $ array , $ array Container Class Name ) { $ clazz = Reflection Util : : is Valid Webhooks Class ( $ array Container Class Name ) ; if ( ! isset ( $ clazz ) ) { return null ; } $ wrap Object = new $ clazz ( ) ; if ( isset ( $ array ) & & ! empty ( $ array ) ) { foreach ( $ array as $ key = > $ value ) { if ( is _array ( $ value ) ) { 
public function set Options ( $ options ) { if ( $ options instanceof Zend _Config ) { $ options = $ options - > to Array ( ) ; } foreach ( $ options as $ key = > $ value ) { switch ( $ key ) { case 'actor ' : $ this - > set Actor ( $ value ) ; break ; case 'classmap ' : case 'class Map ' : $ this - > set Classmap ( $ value ) ; break ; case 'encoding ' : $ this - > set Encoding ( $ value ) ; break ; case 'soap Version ' : case 'soap _version ' : $ this - > set Soap Version ( $ value ) ; break ; case 'uri ' : $ this - > set Uri ( $ value ) ; break ; case 'wsdl ' : $ this - > set Wsdl ( $ value ) ; break ; case 'featues ' : $ this - > set Soap Features ( $ value ) ; break ; case 'cache _wsdl ' : $ this - > set Wsdl Cache ( $ value ) ; break ; default : break ; } } return $ this ; } 
public function get Options ( ) { $ options = array ( ) ; if ( null ! = = $ this - > _actor ) { $ options [ 'actor ' ] = $ this - > _actor ; } if ( null ! = = $ this - > _classmap ) { $ options [ 'classmap ' ] = $ this - > _classmap ; } if ( null ! = = $ this - > _encoding ) { $ options [ 'encoding ' ] = $ this - > _encoding ; } if ( null ! = = $ this - > _soap Version ) { $ options [ 'soap _version ' ] = $ this - > _soap Version ; } if ( null ! = = $ this - > _uri ) { $ options [ 'uri ' ] = $ this - > _uri ; } if ( null ! = = $ this - > _features ) { $ options [ 'features ' ] = $ this - > _features ; } if ( null ! = = $ this - > _wsdl Cache ) { $ options [ 'cache _wsdl ' ] = $ this - > _wsdl Cache ; } return $ options ; } 
public function set Soap Version ( $ version ) { if ( ! in _array ( $ version , array ( SOAP _ 1 _ 1 , SOAP _ 1 _ 2 ) ) ) { require _once 'Zend /Soap /Server /Exception .php ' ; throw new Zend _Soap _Server _Exception ( 'Invalid soap version specified ' ) ; } $ this - > _soap Version = $ version ; return $ this ; } 
public function validate Urn ( $ urn ) { $ scheme = parse _url ( $ urn , PHP _URL _SCHEME ) ; if ( $ scheme = = = false | | $ scheme = = = null ) { require _once 'Zend /Soap /Server /Exception .php ' ; throw new Zend _Soap _Server _Exception ( 'Invalid URN ' ) ; } return true ; } 
public function set Classmap ( $ classmap ) { if ( ! is _array ( $ classmap ) ) { require _once 'Zend /Soap /Server /Exception .php ' ; throw new Zend _Soap _Server _Exception ( 'Classmap must be an array ' ) ; } foreach ( $ classmap as $ type = > $ class ) { if ( ! class _exists ( $ class ) ) { require _once 'Zend /Soap /Server /Exception .php ' ; throw new Zend _Soap _Server _Exception ( 'Invalid class in class map ' ) ; } } $ this - > _classmap = $ classmap ; return $ this ; } 
public function add Function ( $ function , $ namespace = ' ' ) { 
public function set Class ( $ class , $ namespace = ' ' , $ argv = null ) { if ( isset ( $ this - > _class ) ) { require _once 'Zend /Soap /Server /Exception .php ' ; throw new Zend _Soap _Server _Exception ( 'A class has already been registered with this soap server instance ' ) ; } if ( ! is _string ( $ class ) ) { require _once 'Zend /Soap /Server /Exception .php ' ; throw new Zend _Soap _Server _Exception ( 'Invalid class argument ( ' . gettype ( $ class ) . ' ) ' ) ; } if ( ! class _exists ( $ class ) ) { require _once 'Zend /Soap /Server /Exception .php ' ; throw new Zend _Soap _Server _Exception ( 'Class " ' . $ class . ' " does not exist ' ) ; } $ this - > _class = $ class ; if ( 1 < func _num _args ( ) ) { $ argv = func _get _args ( ) ; array _shift ( $ argv ) ; $ this - > _class Args = $ argv ; } return $ this ; } 
public function set Object ( $ object ) { if ( ! is _object ( $ object ) ) { require _once 'Zend /Soap /Server /Exception .php ' ; throw new Zend _Soap _Server _Exception ( 'Invalid object argument ( ' . gettype ( $ object ) . ' ) ' ) ; } if ( isset ( $ this - > _object ) ) { require _once 'Zend /Soap /Server /Exception .php ' ; throw new Zend _Soap _Server _Exception ( 'An object has already been registered with this soap server instance ' ) ; } $ this - > _object = $ object ; return $ this ; } 
public function get Functions ( ) { $ functions = array ( ) ; if ( null ! = = $ this - > _class ) { $ functions = get _class _methods ( $ this - > _class ) ; } elseif ( null ! = = $ this - > _object ) { $ functions = get _class _methods ( $ this - > _object ) ; } return array _merge ( ( array ) $ this - > _functions , $ functions ) ; } 
public function set Persistence ( $ mode ) { if ( ! in _array ( $ mode , array ( SOAP _PERSISTENCE _SESSION , SOAP _PERSISTENCE _REQUEST ) ) ) { require _once 'Zend /Soap /Server /Exception .php ' ; throw new Zend _Soap _Server _Exception ( 'Invalid persistence mode specified ' ) ; } $ this - > _persistence = $ mode ; return $ this ; } 
protected function _set Request ( $ request ) { if ( $ request instanceof DOMDocument ) { $ xml = $ request - > save XML ( ) ; } elseif ( $ request instanceof DOMNode ) { $ xml = $ request - > owner Document - > save XML ( ) ; } elseif ( $ request instanceof Simple XMLElement ) { $ xml = $ request - > as XML ( ) ; } elseif ( is _object ( $ request ) | | is _string ( $ request ) ) { if ( is _object ( $ request ) ) { $ xml = $ request - > _ _to String ( ) ; } else { $ xml = $ request ; } $ dom = new DOMDocument ( ) ; if ( strlen ( $ xml ) = = 0 | | ! $ dom - > load XML ( $ xml ) ) { require _once 'Zend /Soap /Server /Exception .php ' ; throw new Zend _Soap _Server _Exception ( 'Invalid XML ' ) ; } } $ this - > _request = $ xml ; return $ this ; } 
protected function _get Soap ( ) { $ options = $ this - > get Options ( ) ; $ server = new Soap Server ( $ this - > _wsdl , $ options ) ; if ( ! empty ( $ this - > _functions ) ) { $ server - > add Function ( $ this - > _functions ) ; } if ( ! empty ( $ this - > _class ) ) { $ args = $ this - > _class Args ; array _unshift ( $ args , $ this - > _class ) ; call _user _func _array ( array ( $ server , 'set Class ' ) , $ args ) ; } if ( ! empty ( $ this - > _object ) ) { $ server - > set Object ( $ this - > _object ) ; } if ( null ! = = $ this - > _persistence ) { $ server - > set Persistence ( $ this - > _persistence ) ; } return $ server ; } 
public function handle ( $ request = null ) { if ( null = = = $ request ) { $ request = file _get _contents ( 'php : / /input ' ) ; } * @see Zend _Soap _Server _Exception * / require _once 'Zend /Soap /Server /Exception .php ' ; try { $ this - > _set Request ( $ request ) ; } catch ( Zend _Soap _Server _Exception $ e ) { $ set Request Exception = $ e ; } $ soap = $ this - > _get Soap ( ) ; ob _start ( ) ; if ( $ set Request Exception instanceof Exception ) { 
public function deregister Fault Exception ( $ class ) { if ( in _array ( $ class , $ this - > _fault Exceptions , true ) ) { $ index = array _search ( $ class , $ this - > _fault Exceptions ) ; unset ( $ this - > _fault Exceptions [ $ index ] ) ; return true ; } return false ; } 
public function fault ( $ fault = null , $ code = "Receiver " ) { if ( $ fault instanceof Exception ) { $ class = get _class ( $ fault ) ; if ( in _array ( $ class , $ this - > _fault Exceptions ) ) { $ message = $ fault - > get Message ( ) ; $ e Code = $ fault - > get Code ( ) ; $ code = empty ( $ e Code ) ? $ code : $ e Code ; } else { $ message = 'Unknown error ' ; } } elseif ( is _string ( $ fault ) ) { $ message = $ fault ; } else { $ message = 'Unknown error ' ; } $ allowed Fault Modes = array ( 'Version Mismatch ' , 'Must Understand ' , 'Data Encoding Unknown ' , 'Sender ' , 'Receiver ' , 'Server ' ) ; if ( ! in _array ( $ code , $ allowed Fault Modes ) ) { $ code = "Receiver " ; } return new Soap Fault ( $ code , $ message ) ; } 
public function handle Php Errors ( $ errno , $ errstr , $ errfile = null , $ errline = null , array $ errcontext = null ) { throw $ this - > fault ( $ errstr , "Receiver " ) ; } 
public function get Access Token ( ) { if ( isset ( $ this - > oauth 2Access Token ) & & ! empty ( $ this - > oauth 2Access Token ) ) { return $ this - > oauth 2Access Token ; } else { throw new Sdk Exception ( "Can 't get OAuth 2 Access Token Object . It is not set yet . " ) ; } } 
public function get Client ID ( ) { if ( isset ( $ this - > client ID ) & & ! empty ( $ this - > client ID ) ) { return ( String ) $ this - > client ID ; } else { throw new Sdk Exception ( "Can 't get OAuth 2 Client ID . It is not set . " ) ; } } 
public function get Client Secret ( ) { if ( isset ( $ this - > client Secret ) & & ! empty ( $ this - > client Secret ) ) { return ( String ) $ this - > client Secret ; } else { throw new Sdk Exception ( "Can 't get OAuth 2 Client Secret . It is not set . " ) ; } } 
public function get Scope ( ) { if ( isset ( $ this - > scope ) & & ! empty ( $ this - > scope ) ) { return ( String ) $ this - > scope ; } else { throw new Sdk Exception ( "Can 't get OAuth 2 Scope . It is not set . " ) ; } } 
public function get Redirect URL ( ) { if ( isset ( $ this - > redirect Uri ) & & ! empty ( $ this - > redirect Uri ) ) { return ( String ) $ this - > redirect Uri ; } else { throw new Sdk Exception ( "Can 't get OAuth 2 redirect Uri . It is not set . " ) ; } } 
public function get State ( ) { if ( isset ( $ this - > state ) & & ! empty ( $ this - > state ) ) { return ( String ) $ this - > state ; } else { throw new Sdk Exception ( "Can 't get OAuth 2 state . It is not set . " ) ; } } 
public function get Authorization Code URL ( ) { $ parameters = array ( 'client _id ' = > $ this - > get Client ID ( ) , 'scope ' = > $ this - > get Scope ( ) , 'redirect _uri ' = > $ this - > get Redirect URL ( ) , 'response _type ' = > 'code ' , 'state ' = > $ this - > get State ( ) ) ; $ authorization Request Url = Core Constants : : OAUTH 2 _AUTHORIZATION _REQUEST _URL ; $ authorization Request Url . = ' ? ' . http _build _query ( $ parameters , null , ' & ' , PHP _QUERY _RFC 1 7 3 8 ) ; return $ authorization Request Url ; } 
public function exchange Authorization Code For Token ( $ code , $ realm ID ) { if ( ! isset ( $ code ) ) { throw new Sdk Exception ( "The code is not set . Can 't exchange for OAuth 2 Access Token . " ) ; } $ parameters = array ( 'grant _type ' = > 'authorization _code ' , 'code ' = > ( String ) $ code , 'redirect _uri ' = > $ this - > get Redirect URL ( ) ) ; $ authorization Header Info = $ this - > generate Authorization Header ( ) ; $ http _header = array ( 'Accept ' = > 'application /json ' , 'Authorization ' = > $ authorization Header Info , 'Content -Type ' = > 'application /x -www -form -urlencoded ' ) ; $ intuit Response = $ this - > curl Http Client - > make APICall ( Core Constants : : OAUTH 2 _TOKEN _ENDPOINT _URL , Core Constants : : HTTP _POST , $ http _header , http _build _query ( $ parameters ) , null , true ) ; $ this - > fault Handler = $ intuit Response - > get Fault Handler ( ) ; if ( $ this - > fault Handler ) { throw new Service Exception ( "Exchange Authorization Code for Access Token failed . Body : [ " . $ this - > fault Handler - > get Response Body ( ) . " ] . " , $ this - > fault Handler - > get Http Status Code ( ) ) ; } else { $ this - > fault Handler = false ; $ this - > oauth 2Access Token = $ this - > parse New Access Token From Response ( $ intuit Response - > get Body ( ) , $ realm ID ) ; return $ this - > get Access Token ( ) ; } } 
public function refresh Token ( ) { $ refresh Token = $ this - > get Access Token ( ) - > get Refresh Token ( ) ; $ http _header = $ this - > construct Refresh Token Header ( ) ; $ request Body = $ this - > construct Refresh Token Body ( $ refresh Token ) ; $ intuit Response = $ this - > curl Http Client - > make APICall ( Core Constants : : OAUTH 2 _TOKEN _ENDPOINT _URL , Core Constants : : HTTP _POST , $ http _header , $ request Body , null , true ) ; $ this - > fault Handler = $ intuit Response - > get Fault Handler ( ) ; if ( $ this - > fault Handler ) { throw new Service Exception ( "Refresh OAuth 2 Access token with Refresh Token failed . Body : [ " . $ this - > fault Handler - > get Response Body ( ) . " ] . " , $ this - > fault Handler - > get Http Status Code ( ) ) ; } else { $ this - > fault Handler = false ; $ this - > oauth 2Access Token = $ this - > parse New Access Token From Response ( $ intuit Response - > get Body ( ) ) ; return $ this - > get Access Token ( ) ; } } 
public function revoke Token ( $ access Token Or Refresh Token ) { if ( ! isset ( $ access Token Or Refresh Token ) ) { throw new Sdk Exception ( "The refresh token or access token is not set . Can 't revoke OAuth 2 Token . " ) ; } $ parameters = array ( "token " = > ( String ) $ access Token Or Refresh Token ) ; $ authorization Header Info = $ this - > generate Authorization Header ( ) ; $ http _header = array ( 'Accept ' = > 'application /json ' , 'Authorization ' = > $ authorization Header Info , 'Content -Type ' = > 'application /json ' ) ; $ intuit Response = $ this - > curl Http Client - > make APICall ( Core Constants : : REVOCATION _ENDPONT , Core Constants : : HTTP _POST , $ http _header , json _encode ( $ parameters ) , null , true ) ; $ this - > fault Handler = $ intuit Response - > get Fault Handler ( ) ; if ( $ this - > fault Handler ) { throw new Service Exception ( "Revoke Token failed . Body : [ " . $ this - > fault Handler - > get Response Body ( ) . " ] . " , $ this - > fault Handler - > get Http Status Code ( ) ) ; } else { $ this - > fault Handler = false ; return true ; } } 
public function OAuth 1To OAuth 2Migration ( $ consumer Key , $ consumer Secret , $ access Token , $ access Token Secret , $ scope ) { $ oauth 1Encrypter = new OAuth 1 ( $ consumer Key , $ consumer Secret , $ access Token , $ access Token Secret ) ; $ parameters = array ( 'scope ' = > $ scope , 'redirect _uri ' = > "https : / /developer .intuit .com /v 2 /OAuth 2Playground /Redirect Url " , 'client _id ' = > $ this - > get Client ID ( ) , 'client _secret ' = > $ this - > get Client Secret ( ) ) ; $ base URL = "https : / /developer .api .intuit .com /v 2 /oauth 2 /tokens /migrate " ; $ authorization Header Info = $ oauth 1Encrypter - > get OAuth Header ( $ base URL , array ( ) , "POST " ) ; $ http _header = array ( 'Accept ' = > 'application /json ' , 'Authorization ' = > $ authorization Header Info , 'Content -Type ' = > 'application /json ' ) ; $ intuit Response = $ this - > curl Http Client - > make APICall ( $ base URL , Core Constants : : HTTP _POST , $ http _header , json _encode ( $ parameters ) , null , false ) ; $ this - > fault Handler = $ intuit Response - > get Fault Handler ( ) ; if ( $ this - > fault Handler ) { throw new Service Exception ( "Migrate OAuth 1 token to OAuth 2 token failed . Body : [ " . $ this - > fault Handler - > get Response Body ( ) . " ] . " , $ this - > fault Handler - > get Http Status Code ( ) ) ; } else { $ this - > fault Handler = false ; $ this - > oauth 2Access Token = $ this - > parse New Access Token From Response ( $ intuit Response - > get Body ( ) ) ; return $ this - > get Access Token ( ) ; } } 
private function parse New Access Token From Response ( $ body , $ realm ID = null ) { if ( is _string ( $ body ) ) { $ json _body = json _decode ( $ body , true ) ; if ( json _last _error ( ) = = = JSON _ERROR _NONE ) { $ token Expires Time = $ json _body [ Core Constants : : EXPIRES _IN ] ; $ refresh Token = $ json _body [ Core Constants : : OAUTH 2 _REFRESH _GRANTYPE ] ; $ refresh Token Expires Time = $ json _body [ Core Constants : : X _REFRESH _TOKEN _EXPIRES _IN ] ; $ access Token = $ json _body [ Core Constants : : ACCESS _TOKEN ] ; $ this - > check If Empty Value Returned ( $ token Expires Time , $ refresh Token , $ refresh Token Expires Time , $ access Token ) ; 
private function check If Empty Value Returned ( $ token Expires Time , $ refresh Token , $ refresh Token Expires Time , $ access Token ) { if ( empty ( $ token Expires Time ) ) { throw new Sdk Exception ( "Error Retrieve Refresh Token from Response . Token Expires In Time is Empty . " ) ; } if ( empty ( $ refresh Token ) ) { throw new Sdk Exception ( "Error Retrieve Refresh Token from Response . Refresh Token is Empty . " ) ; } if ( empty ( $ refresh Token Expires Time ) ) { throw new Sdk Exception ( "Error Retrieve Refresh Token from Response . Refresh Token Expires Time is Empty . " ) ; } if ( empty ( $ access Token ) ) { throw new Sdk Exception ( "Error Retrieve Refresh Token from Response . Access Token is Empty . " ) ; } } 
private function generate Authorization Header ( ) { $ encoded Client IDClient Secrets = base 6 4 _encode ( $ this - > get Client ID ( ) . ' : ' . $ this - > get Client Secret ( ) ) ; $ authorizationheader = Core Constants : : OAUTH 2 _AUTHORIZATION _TYPE . $ encoded Client IDClient Secrets ; return $ authorizationheader ; } 
private function construct Refresh Token Header ( ) { $ authorization Header Info = $ this - > generate Authorization Header ( ) ; $ http _header = array ( 'Accept ' = > Core Constants : : CONTENTTYPE _APPLICATIONJSON , 'Authorization ' = > $ authorization Header Info , 'Content -Type ' = > Core Constants : : CONTENTTYPE _URLFORMENCODED , 'connection ' = > 'close ' ) ; return $ http _header ; } 
private function check Result ( $ result ) { $ this - > last Error = json _last _error ( ) ; if ( JSON _ERROR _NONE ! = = $ this - > last Error ) { Ids Exception Manager : : Handle Exception ( $ this - > get Message From Error Code ( $ this - > last Error ) ) ; } 
private function get Message From Error Code ( $ error ) { if ( function _exists ( 'json _last _error _msg ' ) ) { return json _last _error _msg ( ) ; } $ errors = array ( JSON _ERROR _NONE = > null , JSON _ERROR _DEPTH = > 'Maximum stack depth exceeded ' , JSON _ERROR _STATE _MISMATCH = > 'Underflow or the modes mismatch ' , JSON _ERROR _CTRL _CHAR = > 'Unexpected control character found ' , JSON _ERROR _SYNTAX = > 'Syntax error , malformed JSON ' , JSON _ERROR _UTF 8 = > 'Malformed UTF - 8 characters , possibly incorrectly encoded ' ) ; return array _key _exists ( $ error , $ errors ) ? $ errors [ $ error ] : "Unknown error ( { $error } ) " ; } 
private function convert Object ( $ object , $ limit To One ) { if ( $ object instanceof \ std Class ) { $ result = array ( ) ; $ vars = get _object _vars ( $ object ) ; if ( empty ( $ vars ) ) { return null ; } foreach ( $ vars as $ key = > $ value ) { $ class Name = self : : decorate Intuit Entity To Php Class Name ( $ key ) ; if ( ! class _exists ( $ class Name ) ) { continue ; } $ entity = Domain Entity Builder : : create ( $ class Name , $ value ) ; if ( $ limit To One ) { return $ entity ; } $ result [ ] = $ entity ; } if ( empty ( $ result ) ) { 
public function Serialize ( $ entity ) { $ this - > collect Resource URL ( $ entity ) ; $ array Obj = $ this - > customer Convert Object To Array ( $ entity ) ; $ array = $ this - > remove Null Properties ( $ array Obj ) ; return $ this - > check Result ( json _encode ( $ array , true ) ) ; } 
private function remove Null Properties ( $ val ) { $ filter Array = array _filter ( $ val ) ; $ returned = array ( ) ; foreach ( $ filter Array as $ k = > $ v ) { if ( is _array ( $ v ) ) { if ( Facade Helper : : is Recurrsive Array ( $ v ) ) { $ list = array ( ) ; foreach ( $ v as $ kk = > $ vv ) { $ list [ ] = array _filter ( $ vv ) ; } $ returned [ $ k ] = $ list ; } } else { $ returned [ $ k ] = $ v ; } } return $ returned ; } 
public function Deserialize ( $ message , $ limit To One = false ) { return $ this - > convert Object ( $ this - > check Result ( json _decode ( $ message ) ) , $ limit To One ) ; } 
public function add Complex Type ( $ type ) { if ( ! class _exists ( $ type ) ) { require _once "Zend /Soap /Wsdl /Exception .php " ; throw new Zend _Soap _Wsdl _Exception ( sprintf ( "Cannot add a complex type %s that is not an object or where " . "class could not be found in 'Default Complex Type ' strategy . " , $ type ) ) ; } $ dom = $ this - > get Context ( ) - > to Dom Document ( ) ; $ class = new Reflection Class ( $ type ) ; $ complex Type = $ dom - > create Element ( 'xsd :complex Type ' ) ; $ complex Type - > set Attribute ( 'name ' , $ type ) ; $ all = $ dom - > create Element ( 'xsd :all ' ) ; foreach ( $ class - > get Properties ( ) as $ property ) { if ( $ property - > is Public ( ) & & preg _match _all ( ' / @var \s + ( [ ^ \s ] + ) /m ' , $ property - > get Doc Comment ( ) , $ matches ) ) { $ element = $ dom - > create Element ( 'xsd :element ' ) ; $ element - > set Attribute ( 'name ' , $ property - > get Name ( ) ) ; $ element - > set Attribute ( 'type ' , $ this - > get Context ( ) - > get Type ( trim ( $ matches [ 1 ] [ 0 ] ) ) ) ; $ all - > append Child ( $ element ) ; } } $ complex Type - > append Child ( $ all ) ; $ this - > get Context ( ) - > get Schema ( ) - > append Child ( $ complex Type ) ; $ this - > get Context ( ) - > add Type ( $ type ) ; return "tns : $type " ; } 
public function get Wsdl ( $ class = null ) { $this - >add Types ( ) ; $this - >add Messages ( ) ; $this - >add Port Type ( ) ; $this - >add Bindings ( ) ; $this - >add Services ( ) ; $dom = $this - >wsdl - >to Dom Document ( ) ; if ( $this - >debug ) { $dom - >format Output = true ; } * / return $ this - > wsdl - > to Xml ( ) ; 
private function add Bindings ( ) { $ this - > binding = $ this - > wsdl - > add Binding ( $ this - > refl - > get Short Name ( ) . $ this - > binding Name Suffix , $ this - > target Ns Prefix . " : " . $ this - > get Binding Type Name ( ) ) ; $ this - > wsdl - > add Soap Binding ( $ this - > binding , $ this - > get Soap Binding Style ( ) , $ this - > get Soap Binding Transport ( ) ) ; $ this - > add Binding Operations ( ) ; return $ this - > binding ; } 
private function add Port Type ( ) { $ this - > port Type = $ this - > wsdl - > add Port Type ( $ this - > get Port Name ( ) ) ; $ this - > add Port Operations ( ) ; return $ this - > port Type ; } 
public function add Types ( ) { $ methods = $ this - > get Class Methods ( ) ; foreach ( $ methods as $ method ) { $ data = $ this - > get Method IO ( $ method - > name ) ; $ element = array ( 'name ' = > $ method - > name , 'sequence ' = > array ( ) ) ; if ( array _key _exists ( "params " , $ data ) ) { foreach ( $ data [ 'params ' ] as $ param ) { if ( $ this - > is Local Type ( $ this - > get Type Name ( $ param [ 'type ' ] ) ) ) { array _push ( $ element [ 'sequence ' ] , array ( 'name ' = > $ param [ 'name ' ] , 'type ' = > $ this - > get Type Name ( $ param [ 'type ' ] ) ) ) ; } else { array _push ( $ element [ 'sequence ' ] , array ( 'ref ' = > $ this - > get Type Name ( $ param [ 'type ' ] ) ) ) ; } } $ this - > wsdl - > add Element ( $ element ) ; } if ( array _key _exists ( "return " , $ data ) ) { $ return = " " ; if ( $ this - > is Local Type ( $ this - > get Type Name ( $ data [ 'return ' ] [ 'type ' ] ) ) ) { $ return = array ( 'name ' = > $ method - > name . $ this - > response Suffix , 'sequence ' = > array ( array ( 'name ' = > 'Response ' , 'type ' = > $ this - > get Type Name ( $ data [ 'return ' ] [ 'type ' ] ) ) ) ) ; } else { $ return = array ( 'name ' = > $ method - > name . $ this - > response Suffix , 'sequence ' = > array ( array ( 'ref ' = > $ this - > get Type Name ( $ data [ 'return ' ] [ 'type ' ] ) ) ) ) ; } $ this - > wsdl - > add Element ( $ return ) ; } } } 
public function add Binding Operations ( ) { $ methods = $ this - > get Class Methods ( ) ; 
private function add Port Operations ( ) { $ methods = $ this - > get Class Methods ( ) ; foreach ( $ methods as $ method ) { $ data = $ this - > get Method IO ( $ method - > name ) ; $ input = false ; $ output = false ; $ binding Input = false ; $ binding Output = false ; if ( array _key _exists ( "params " , $ data ) ) { $ input = $ this - > target Ns Prefix . " : " . $ method - > name . $ this - > request Suffix ; } if ( array _key _exists ( "return " , $ data ) ) { $ output = $ this - > target Ns Prefix . " : " . $ method - > name . $ this - > response Suffix ; } $ this - > wsdl - > add Port Operation ( $ this - > port Type , $ method - > name , $ input , $ output ) ; } } 
public function is Local Type ( $ type ) { if ( preg _match ( ' / : / ' , $ type ) ) { list ( $ ns , $ type Name ) = explode ( " : " , $ type ) ; if ( $ ns = = $ this - > target Ns Prefix | | $ ns = = $ this - > xml Schema Preffix ) { return true ; 
public function add Messages ( ) { $ methods = $ this - > get Class Methods ( ) ; $ messages = array ( ) ; foreach ( $ methods as $ method ) { $ data = $ this - > get Method IO ( $ method - > name ) ; $ input = false ; $ output = false ; 
private function get Method IO ( $ method ) { $ method Docs = $ this - > refl - > get Method ( $ method ) - > get Doc Comment ( ) ; return $ this - > parse Doc Comments ( $ method Docs ) ; } 
private function add Services ( ) { $ this - > wsdl - > add Service ( $ this - > get Service Name ( ) , $ this - > get Port Name ( ) , $ this - > get Binding Name ( ) , $ this - > get Location ( ) ) ; } 
private function get Type Name ( $ type ) { 
private function add Import To Schema ( $ namespace , $ code ) { if ( array _key _exists ( $ namespace , $ this - > namespaces ) ) { if ( in _array ( $ namespace , $ this - > imported Namespaces ) ) { return ; } $ dom = $ this - > wsdl - > to Dom Document ( ) ; $ dom - > create Attribute Ns ( $ namespace , $ code . " :definitions " ) ; $ import El = $ dom - > create Element ( $ this - > xml Schema Preffix . " :import " ) ; $ ns Attr = $ dom - > create Attribute ( "namespace " ) ; $ txt Node = $ dom - > create Text Node ( $ namespace ) ; $ ns Attr - > append Child ( $ txt Node ) ; $ ns Attr 2 = $ dom - > create Attribute ( "schema Location " ) ; $ schema Location = $ this - > get Schema Location ( $ namespace ) ; $ public Schema = $ this - > copy To Public ( $ schema Location , true ) ; $ public Schema = $ this - > copy To Public ( $ schema Location , true ) ; $ schema Url = $ this - > imports To Abs Url ( $ public Schema , $ this - > get Schemas Path ( ) ) ; $ txt Node 2 = $ dom - > create Text Node ( $ schema Url ) ; $ ns Attr 2 - > append Child ( $ txt Node 2 ) ; $ import El - > append Child ( $ ns Attr ) ; $ import El - > append Child ( $ ns Attr 2 ) ; $ this - > wsdl - > get Schema ( ) ; $ xpath = new \ DOMXPath ( $ dom ) ; $ query = " / / * [local -name ( ) = 'types ' ] /child : : * / * " ; $ first Element = $ xpath - > query ( $ query ) ; if ( ! is _object ( $ first Element - > item ( 0 ) ) ) { $ query = " / / * [local -name ( ) = 'types ' ] /child : : * " ; $ schema = $ xpath - > query ( $ query ) ; $ schema - > item ( 0 ) - > append Child ( $ import El ) ; } else { $ this - > wsdl - > get Schema ( ) - > insert Before ( $ import El , $ first Element - > item ( 0 ) ) ; } array _push ( $ this - > imported Namespaces , $ namespace ) ; } } 
private function add Type ( $ type ) { if ( ! in _array ( $ type , $ this - > basic Types ) ) { $ type Name = $ this - > get Short Name ( $ type ) ; $ type Namespace = $ this - > get Class Namespace ( $ type ) ; $ ns Code = $ this - > get Ns Code ( $ type Namespace , true ) ; } else { return $ type ; } } 
private function get Target NS ( $ xpath ) { $ query = " / / * [local -name ( ) = 'schema ' and namespace -uri ( ) = 'http : / /www .w 3 .org / 2 0 0 1 /XMLSchema ' ] / @target Namespace " ; $ target Ns = $ xpath - > query ( $ query ) ; if ( $ target Ns ) { foreach ( $ target Ns as $ entry ) { return $ entry - > node Value ; } } } 
public function get Namespaces ( $ xpath ) { $ query = " / /namespace : : * " ; $ entries = $ xpath - > query ( $ query ) ; $ nspaces = array ( ) ; foreach ( $ entries as $ entry ) { if ( $ entry - > node Value = = "http : / /www .w 3 .org / 2 0 0 1 /XMLSchema " ) { $ this - > xsd Ns = preg _replace ( ' /xmlns : ( . * ) / ' , " $ 1 " , $ entry - > node Name ) ; } if ( 
public function save Classes ( $ dir , $ create Directory = false ) { $ this - > set Xml Source ( $ this - > get XML ( ) - > save XML ( ) ) ; $ this - > save Php Files ( $ dir , $ create Directory ) ; } 
public function load Imports ( $ dom , $ xsd File = ' ' ) { $ xpath = new \ DOMXPath ( $ dom ) ; $ query = " / / * [local -name ( ) = 'import ' and namespace -uri ( ) = 'http : / /www .w 3 .org / 2 0 0 1 /XMLSchema ' ] " ; $ entries = $ xpath - > query ( $ query ) ; if ( $ entries - > length = = 0 ) { return $ dom ; } foreach ( $ entries as $ entry ) { 
public function load Includes ( $ dom , $ filepath = ' ' , $ namespace = ' ' ) { $ xpath = new \ DOMXPath ( $ dom ) ; $ query = " / / * [local -name ( ) = 'include ' and namespace -uri ( ) = 'http : / /www .w 3 .org / 2 0 0 1 /XMLSchema ' ] " ; $ includes = $ xpath - > query ( $ query ) ; foreach ( $ includes as $ entry ) { $ parent = $ entry - > parent Node ; $ xsd = new \ DOMDocument ( ) ; $ xsd File Name = realpath ( $ filepath . DIRECTORY _SEPARATOR . $ entry - > get Attribute ( "schema Location " ) ) ; if ( $ this - > debug ) { print ( 'Including ' . $ xsd File Name . " \n " ) ; } if ( ! file _exists ( $ xsd File Name ) ) { if ( $ this - > debug ) { print $ xsd File Name . " is not found \n " ; } continue ; } $ result = $ xsd - > load ( $ xsd File Name , LIBXML _DTDLOAD | LIBXML _DTDATTR | LIBXML _NOENT | LIBXML _XINCLUDE ) ; if ( $ result ) { $ mxpath = new \ DOMXPath ( $ xsd ) ; $ this - > short Namespaces = array _merge ( $ this - > short Namespaces , $ this - > get Namespaces ( $ mxpath ) ) ; } foreach ( $ xsd - > document Element - > child Nodes as $ node ) { if ( $ node - > node Name = = $ this - > xsd Ns . " :include " ) { $ loc = realpath ( $ filepath . DIRECTORY _SEPARATOR . $ node - > get Attribute ( 'schema Location ' ) ) ; $ node - > set Attribute ( 'schema Location ' , $ loc ) ; if ( $ this - > debug ) { print ( 'Change included schema location to ' . $ loc . " \n " ) ; } $ new Node = $ dom - > import Node ( $ node , true ) ; $ parent - > insert Before ( $ new Node , $ entry ) ; } else { if ( $ namespace ! = ' ' ) { $ new Node Ns = $ xsd - > create Attribute ( "namespace " ) ; $ text El = $ xsd - > create Text Node ( $ namespace ) ; $ new Node Ns - > append Child ( $ text El ) ; $ node - > append Child ( $ new Node Ns ) ; } $ new Node = $ dom - > import Node ( $ node , true ) ; $ parent - > insert Before ( $ new Node , $ entry ) ; } } $ parent - > remove Child ( $ entry ) ; } if ( $ this - > debug ) { print _r ( " \n - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - \n " ) ; } return $ dom ; } 
public function get XML ( ) { try { $ xsl = new \ XSLTProcessor ( ) ; $ xsl Dom = new \ DOMDocument ( ) ; $ xsl Dom - > load ( dirname ( _ _FILE _ _ ) . " /xsd 2php 2 .xsl " ) ; $ xsl - > register PHPFunctions ( ) ; $ xsl - > import Style Sheet ( $ xsl Dom ) ; $ dom = $ xsl - > transform To Doc ( $ this - > dom ) ; $ dom - > format Output = true ; return $ dom ; } catch ( \ Exception $ e ) { throw new \ Exception ( "Error interpreting XSD document ( " . $ e - > get Message ( ) . " ) " ) ; } } 
private function save Php Files ( $ dir , $ create Directory = false ) { if ( ! file _exists ( $ dir ) & & $ create Directory = = = false ) { throw new \ Runtime Exception ( $ dir . " does not exist " ) ; } if ( ! file _exists ( $ dir ) & & $ create Directory = = = true ) { 
private function get PHP ( ) { $ phpfile = $ this - > get Xml For Php ( ) ; if ( $ phpfile = = ' ' & & $ this - > get Xml Source ( ) = = ' ' ) { throw new \ Runtime Exception ( 'There is no XML generated ' ) ; } $ dom = new \ DOMDocument ( ) ; * In general it 's stange to give to Type name 's namespace . Reconsider this part * / if ( $ prop - > get Attribute ( 'namespace ' ) ! = ' ' & & $ prop - > get Attribute ( 'namespace ' ) ! = $ this - > xsd Ns ) { $ ns = " " ; if ( $ prop - > get Attribute ( 'namespace ' ) = = " #default # " ) { $ ns = $ this - > namespace To Php ( $ this - > target Namespace ) ; } else { $ ns = $ this - > namespace To Php ( $ this - > expand NS ( $ prop - > get Attribute ( 'namespace ' ) ) ) ; } $ properties [ $ i ] [ "docs " ] [ 'var ' ] = $ ns . ' \ \ ' . $ this - > class Prefix . $ prop - > get Attribute ( 'type ' ) ; } else { $ properties [ $ i ] [ "docs " ] [ 'var ' ] = $ prop - > get Attribute ( 'type ' ) ; } 
private function expand NS ( $ ns ) { if ( $ ns = = " #default # " ) { $ ns = $ this - > target Namespace ; } foreach ( $ this - > short Namespaces as $ short Ns = > $ long Ns ) { if ( $ ns = = $ short Ns ) { $ ns = $ long Ns ; } } return $ ns ; } 
public function namespace To Php ( $ xml NS ) { $ ns = $ xml NS ; $ ns = $ this - > expand NS ( $ ns ) ; if ( preg _match ( ' /urn : / ' , $ ns ) ) { if (preg _match ( ' /http : \ / \ / / ' , $ns ) ) { $ns = preg _replace ( ' /http : \ / \ / / ' , ' ' , $ns ) ; $ns = preg _replace ( ' / \ / / ' , ' \ \ ' , $ns ) ; $ns = preg _replace ( ' / \ . / ' , ' \ \ ' , $ns ) ; } * / $ matches = array ( ) ; if ( preg _match ( " # ( (http |https |ftp ) : / / ( \S * ? \ . \S * ? ) ) ( \s | \ ; | \ ) | \ ] | \ [ | \ { | \ } | , | \ " | ' | : | \ < | $ | \ . \s ) # " , $ ns , $ matches ) ) { $ elements = explode ( " / " , $ matches [ 3 ] ) ; $ domain = $ elements [ 0 ] ; array _shift ( $ elements ) ; / /print _r ( $domain . " \n " ) ; $ ns = implode ( " \ \ " , array _reverse ( explode ( " . " , $ domain ) ) ) ; / / $ns = preg _replace ( ' / \ . / ' , ' \ \ ' , ) ; / /print $ns . " \n " ; foreach ( $ elements as $ key = > $ value ) { if ( $ value ! = ' ' ) { $ value = preg _replace ( ' / \ . / ' , ' _ ' , $ value ) ; $ ns . = " \ \ " . $ value ; } } } $ ns = explode ( ' \ \ ' , $ ns ) ; $ i = 0 ; foreach ( $ ns as $ elem ) { if ( preg _match ( ' / ^ ( [ 0 - 9 ] + ) ( . * ) $ / ' , $ elem ) ) { $ ns [ $ i ] = " _ " . $ elem ; } if ( in _array ( $ elem , $ this - > reserved Words ) ) { $ ns [ $ i ] = " _ " . $ elem ; } $ i + + ; } $ ns = implode ( ' \ \ ' , $ ns ) ; return $ ns ; } 
public function set Base URL ( $ base URL ) { if ( strcasecmp ( $ base URL , Core Constants : : DEVELOPMENT _SANDBOX ) = = 0 ) { $ this - > base URL = Core Constants : : SANDBOX _DEVELOPMENT ; } else if ( strcasecmp ( $ base URL , Core Constants : : PRODUCTION _QBO ) = = 0 ) { $ this - > base URL = Core Constants : : QBO _BASEURL ; } else { $ this - > base URL = $ base URL ; } } 
public function get Refresh Token Validation Period In Seconds ( ) { if ( isset ( $ this - > refresh Token Validation Period ) & & ! empty ( $ this - > refresh Token Validation Period ) ) { return $ this - > refresh Token Validation Period ; } else { throw new Sdk Exception ( "The validation period for OAuth 2 refresh Token is not set . " ) ; } } 
public function get Access Token Validation Period In Seconds ( ) { if ( isset ( $ this - > access Token Validation Period ) & & ! empty ( $ this - > access Token Validation Period ) ) { return $ this - > access Token Validation Period ; } else { throw new Sdk Exception ( "The validation period for OAuth 2 access Token is not set . " ) ; } } 
public function get Refresh Token ( ) { if ( isset ( $ this - > refresh _token ) & & ! empty ( $ this - > refresh _token ) ) return $ this - > refresh _token ; else throw new Sdk Exception ( "The OAuth 2 Refresh Token is not set in the Access Token Object . " ) ; } 
public function get Access Token ( ) { if ( isset ( $ this - > access Token Key ) & & ! empty ( $ this - > access Token Key ) ) return $ this - > access Token Key ; else throw new Sdk Exception ( "The OAuth 2 Access Token is not set in the Access Token Object . " ) ; } 
public function update Access Token ( $ token Expires Time , $ refresh Token , $ refresh Token Expires Time , $ access Token ) { $ this - > set Access Token ( $ access Token ) ; $ this - > set Refresh Token ( $ refresh Token ) ; $ this - > set Access Token Validation Period In Seconds ( $ token Expires Time ) ; $ this - > set Refresh Token Validation Period In Seconds ( $ refresh Token Expires Time ) ; $ this - > set Access Token Expires At ( time ( ) + $ token Expires Time ) ; $ this - > set Refresh Token Expires At ( time ( ) + $ refresh Token Expires Time ) ; } 
public static function update ( $ obj To Update , array $ data ) { $ class Of Obj = get _class ( $ obj To Update ) ; if ( strcmp ( $ class Of Obj , Facade Helper : : simple Append Class Name Space ( "Credit Memo " ) ) ! = 0 ) { throw new \ Exception ( "Target object class : { " . $ class Of Obj . " } is not an instance of Credit Memo . " ) ; } $ new Credit Memo Obj = Credit Memo : : create ( $ data ) ; $ cloned Of Obj = Facade Helper : : clone Obj ( $ obj To Update ) ; Facade Helper : : merge Obj ( $ cloned Of Obj , $ new Credit Memo Obj ) ; return $ cloned Of Obj ; } 
public function add Complex Type ( $ type ) { if ( in _array ( $ type , $ this - > _in Process ) ) { require _once "Zend /Soap /Wsdl /Exception .php " ; throw new Zend _Soap _Wsdl _Exception ( "Infinite recursion , cannot nest ' " . $ type . " ' into itself . " ) ; } $ this - > _in Process [ $ type ] = $ type ; $ nesting Level = $ this - > _get Nested Count ( $ type ) ; if ( $ nesting Level > 1 ) { require _once "Zend /Soap /Wsdl /Exception .php " ; throw new Zend _Soap _Wsdl _Exception ( "Array Of Type Complex cannot return nested Array Of Object deeper than " . "one level . Use array object properties to return deep nested data . " ) ; } $ singular Type = $ this - > _get Singular Php Type ( $ type ) ; if ( ! class _exists ( $ singular Type ) ) { require _once "Zend /Soap /Wsdl /Exception .php " ; throw new Zend _Soap _Wsdl _Exception ( sprintf ( "Cannot add a complex type %s that is not an object or where " . "class could not be found in 'Default Complex Type ' strategy . " , $ type ) ) ; } if ( $ nesting Level = = 1 ) { 
public static function update ( $ obj To Update , array $ data ) { $ class Of Obj = get _class ( $ obj To Update ) ; if ( strcmp ( $ class Of Obj , Facade Helper : : simple Append Class Name Space ( "Line " ) ) ! = 0 ) { throw new \ Exception ( "Target object class : { " . $ class Of Obj . " } is not an instance of Line . " ) ; } $ new Line Obj = Line : : create ( $ data ) ; $ cloned Of Obj = Facade Helper : : clone Obj ( $ obj To Update ) ; Facade Helper : : merge Obj ( $ cloned Of Obj , $ new Line Obj ) ; return $ cloned Of Obj ; } 
private static function get Xml From Obj ( $ php Obj ) { if ( ! $ php Obj ) { $ this - > IDSLogger - > Custom Logger - > Log ( Trace Level : : Error , "Encountered an error parsing the xml From Obj . " ) ; $ this - > IDSLogger - > Custom Logger - > Log ( Trace Level : : Error , "Stack Trace : " . implode ( " \n " , debug _backtrace ( ) ) ) ; return false ; } $ php 2xml = new Php 2Xml ( Core Constants : : PHP _CLASS _PREFIX ) ; $ php 2xml - > override As Single Namespace = 'http : / /schema .intuit .com /finance /v 3 ' ; try { return $ php 2xml - > get Xml ( $ php Obj ) ; } catch ( \ Exception $ e ) { $ this - > IDSLogger - > Custom Logger - > Log ( Trace Level : : Error , "Encountered an error parsing the batch response . " . $ e - > get Message ( ) ) ; $ this - > IDSLogger - > Custom Logger - > Log ( Trace Level : : Error , "Object : " . var _export ( $ php Obj , true ) ) ; $ this - > IDSLogger - > Custom Logger - > Log ( Trace Level : : Error , "Stack Trace : " . $ e - > get Trace As String ( ) ) ; return false ; } } 
public static function get Post Xml From Arbitrary Entity ( $ entity , & $ url Resource ) { if ( null = = $ entity ) { return false ; } $ xml Element Name = Xml Object Serializer : : clean Php Class Name To Intuit Entity Name ( get _class ( $ entity ) ) ; $ xml Element Name = trim ( $ xml Element Name ) ; $ url Resource = strtolower ( $ xml Element Name ) ; $ https Post Body = Xml Object Serializer : : get Xml From Obj ( $ entity ) ; return $ https Post Body ; } 
private static function Php Obj From Xml ( $ class Name , $ xml Str ) { $ class Name = trim ( $ class Name ) ; if ( class _exists ( $ class Name , Core Constants : : USE _AUTOLOADER ) ) { $ php Obj = new $ class Name ; } elseif ( class _exists ( Core Constants : : NAMEPSACE _DATA _PREFIX . $ class Name , Core Constants : : USE _AUTOLOADER ) ) { $ class Name = Core Constants : : NAMEPSACE _DATA _PREFIX . $ class Name ; $ php Obj = new $ class Name ; } else { throw new \ Exception ( "Can 't find corresponding CLASS for class Name " . $ class Name . "during unmarshall XML into POPO Object " ) ; } $ bind = new Bind ( Core Constants : : PHP _CLASS _PREFIX ) ; $ bind - > override As Single Namespace = 'http : / /schema .intuit .com /finance /v 3 ' ; $ bind - > bind Xml ( $ xml Str , $ php Obj ) ; return $ php Obj ; } 
private static function Parse Arbitrary Result Objects ( $ response Xml , $ b Limit To One ) { if ( ! $ response Xml ) { return null ; } $ result Object = null ; $ result Objects = null ; $ response Xml Obj = simplexml _load _string ( $ response Xml ) ; foreach ( $ response Xml Obj as $ one Xml Obj ) { $ one Xml Element Name = ( string ) $ one Xml Obj - > get Name ( ) ; 
public static function clean Php Class Name To Intuit Entity Name ( $ php Class Name ) { $ php Class Name = trim ( $ php Class Name ) ; 
public function Deserialize ( $ message , $ b Limit To One = false ) { if ( ! $ message ) { return null ; } $ result Object = null ; $ result Objects = null ; $ response Xml Obj = simplexml _load _string ( $ message ) ; 
public function setup Option ( $ k , $ v ) { if ( $ this - > is Curl Set ( ) ) { curl _setopt ( $ this - > curl , $ k , $ v ) ; } else { throw new Sdk Exception ( "c URL instance is not set when calling setup Option . " ) ; } } 
public function version Of TLS ( ) { $ tls Version = " " ; $ curl = curl _init ( ) ; curl _setopt ( $ curl , CURLOPT _URL , "https : / /www .howsmyssl .com /a /check " ) ; curl _setopt ( $ curl , CURLOPT _SSLVERSION , 6 ) ; curl _setopt ( $ curl , CURLOPT _RETURNTRANSFER , true ) ; $ curl Version Response = curl _exec ( $ curl ) ; if ( $ curl Version Response = = = false ) { throw new Sdk Exception ( "Error in checking c URL version for TLS 1 . 2 . Error Num : [ " . curl _errno ( $ curl ) . " ] Error message : [ " . curl _error ( $ curl ) . " ] " ) ; } else { $ tls Version = json _decode ( $ curl Version Response ) - > tls _version ; } curl _close ( $ curl ) ; return $ tls Version ; } 
public function get Info ( $ type ) { if ( $ this - > is Curl Set ( ) ) { return curl _getinfo ( $ this - > curl , $ type ) ; } else { throw new Sdk Exception ( "c URL instance is not set when trying to get info from the type : " . $ type ) ; } } 
public static function Handle Exception ( $ error Message = null , $ error Code = null , $ source = null , $ inner Exception = null ) { $ message = implode ( " , " , array ( $ error Message , $ error Code , $ source ) ) ; throw new Ids Exception ( $ message ) ; } 
private function extract Var Value From Comment ( $ text ) { $ matches = array ( ) ; $ result = preg _match _all ( self : : REGULAR _GET _VAR , $ text , $ matches ) ; 
private function verify Variable Type ( $ value ) { 
private function generate Object Names ( $ value ) { $ reversive Stack = array ( ) ; $ reversive Stack [ ] = $ value ; 
private function complete Property ( $ a , Reflection Property $ p ) { if ( ! $ a instanceof Abstract Entity ) { throw new Invalid Argument Exception ( "Expected instance of Abstract Entity here " ) ; } $ a - > set Name ( $ p - > get Name ( ) ) ; $ a - > set Class ( $ p - > get Declaring Class ( ) ) ; } 
public function unmarshal ( $ xml ) { 
public function bind Xml ( $ xml , $ model ) { *Vish Singh : Solution to Bug # IPP - 4 7 4 8 *Add Check if the class Exists . @Hao * / if ( class _exists ( $ class Name , Core Constants : : USE _AUTOLOADER ) ) { 
public static function Get Serializer ( $ service Context , $ is Request ) { $ service Context - > Ipp Configuration - > Logger - > Request Log - > Log ( Trace Level : : Info , "Get Serializer " ) ; $ serializer = null ; if ( $ is Request ) { switch ( $ service Context - > Ipp Configuration - > Message - > Request - > Serialization Format ) { case Serialization Format : : Xml : $ service Context - > Ipp Configuration - > Logger - > Request Log - > Log ( Trace Level : : Info , "Get Serializer (Request ) : Xml " ) ; $ serializer = new Xml Object Serializer ( ) ; break ; case Serialization Format : : Json : $ service Context - > Ipp Configuration - > Logger - > Request Log - > Log ( Trace Level : : Info , "Get Serializer (Request ) : JSON " ) ; $ serializer = new Json Object Serializer ( ) ; break ; case Serialization Format : : Custom : 
public static function Check Null Response And Throw Exception ( $ response ) { if ( ! $ response ) { $ message To Write = 'Response Null or Empty ' ; $ back Trace = debug _backtrace ( ) ; $ caller File Name = $ back Trace [ 0 ] [ 'file ' ] ; $ caller File Line Number = $ back Trace [ 0 ] [ 'line ' ] ; $ caller Function Name = $ back Trace [ 0 ] [ 'function ' ] ; $ log Message = implode ( " - " , array ( date ( 'Y -m -d H :i :s ' ) , $ caller File Name , $ caller File Line Number , $ caller Function Name , $ message To Write ) ) ; throw new Ids Exception ( $ log Message ) ; } } 
public static function Get Compressor ( $ service Context , $ is Request ) { $ compressor = null ; if ( $ is Request ) { switch ( $ service Context - > Ipp Configuration - > Message - > Request - > Compression Format ) { case Compression Format : : GZip : $ compressor = new GZip Compressor ( ) ; break ; case Compression Format : : Deflate : $ compressor = new Deflate Compressor ( ) ; break ; } } else { switch ( $ service Context - > Ipp Configuration - > Message - > Response - > Compression Format ) { case Compression Format : : GZip : $ compressor = new GZip Compressor ( ) ; break ; case Compression Format : : Deflate : $ compressor = new Deflate Compressor ( ) ; break ; } } return $ compressor ; } 
public static function Get Request Logging ( $ service Context ) { $ request Logger = null ; try { if ( isset ( $ service Context - > Ipp Configuration ) & & isset ( $ service Context - > Ipp Configuration - > Logger ) & & isset ( $ service Context - > Ipp Configuration - > Logger - > Request Log ) & & isset ( $ service Context - > Ipp Configuration - > Logger - > Request Log - > Enable Request Response Logging ) & & isset ( $ service Context - > Ipp Configuration - > Logger - > Request Log - > Service Request Logging Location ) ) { $ request Logger = new Log Requests To Disk ( $ service Context - > Ipp Configuration - > Logger - > Request Log - > Enable Request Response Logging , $ service Context - > Ipp Configuration - > Logger - > Request Log - > Service Request Logging Location ) ; } else { $ request Logger = new Log Requests To Disk ( false , null ) ; } } catch ( \ Exception $ e ) { $ request Logger = new Log Requests To Disk ( false , null ) ; } return $ request Logger ; } 
public function connect Type To Strategy ( $ type , $ strategy ) { if ( ! is _string ( $ type ) ) { require _once "Zend /Soap /Wsdl /Exception .php " ; throw new Zend _Soap _Wsdl _Exception ( "Invalid type given to Composite Type Map . " ) ; } $ this - > _type Map [ $ type ] = $ strategy ; return $ this ; } 
public function get Default Strategy ( ) { $ strategy = $ this - > _default Strategy ; if ( is _string ( $ strategy ) & & class _exists ( $ strategy ) ) { $ strategy = new $ strategy ; } if ( ! ( $ strategy instanceof Zend _Soap _Wsdl _Strategy _Interface ) ) { require _once "Zend /Soap /Wsdl /Exception .php " ; throw new Zend _Soap _Wsdl _Exception ( "Default Strategy for Complex Types is not a valid strategy object . " ) ; } $ this - > _default Strategy = $ strategy ; return $ strategy ; } 
public function get Strategy Of Type ( $ type ) { if ( isset ( $ this - > _type Map [ $ type ] ) ) { $ strategy = $ this - > _type Map [ $ type ] ; if ( is _string ( $ strategy ) & & class _exists ( $ strategy ) ) { $ strategy = new $ strategy ( ) ; } if ( ! ( $ strategy instanceof Zend _Soap _Wsdl _Strategy _Interface ) ) { require _once "Zend /Soap /Wsdl /Exception .php " ; throw new Zend _Soap _Wsdl _Exception ( "Strategy for Complex Type ' " . $ type . " ' is not a valid strategy object . " ) ; } $ this - > _type Map [ $ type ] = $ strategy ; } else { $ strategy = $ this - > get Default Strategy ( ) ; } return $ strategy ; } 
public function add Complex Type ( $ type ) { if ( ! ( $ this - > _context instanceof Zend _Soap _Wsdl ) ) { require _once "Zend /Soap /Wsdl /Exception .php " ; throw new Zend _Soap _Wsdl _Exception ( "Cannot add complex type ' " . $ type . " ' , no context is set for this composite strategy . " ) ; } $ strategy = $ this - > get Strategy Of Type ( $ type ) ; $ strategy - > set Context ( $ this - > _context ) ; return $ strategy - > add Complex Type ( $ type ) ; } 
private function make Reflection ( ) { if ( ! class _exists ( $ this - > get Original Class Name ( ) ) ) { throw new Invalid Argument Exception ( 'Class name ' . $ this - > get Original Class Name ( ) . ' not exists ' ) ; } $ this - > reflection = new Reflection Class ( $ this - > get Original Class Name ( ) ) ; } 
private function populate Property Comments ( ) { if ( is _null ( $ this - > properties ) ) { throw new Unexpected Value Exception ( 'Properties are expected here ' ) ; } if ( ! is _array ( $ this - > properties ) ) { throw new Unexpected Value Exception ( 'Properties should be provided as array ' ) ; } 
private function forge Instance ( $ instance ) { $ reflection = new Reflection Class ( $ instance ) ; foreach ( $ reflection - > get Properties ( ) as $ key = > $ property ) { if ( ! $ property instanceof Reflection Property ) { continue ; } $ entity = $ this - > get Entity From Model ( $ key , $ property - > get Name ( ) ) ; $ value = $ property - > get Value ( $ instance ) ; if ( is _array ( $ value ) ) { $ this - > process Property Values ( $ instance , $ property , $ entity , $ value ) ; } else { $ this - > process Property Value ( $ instance , $ property , $ entity , $ value ) ; } } return $ instance ; } 
private function process Property Values ( $ instance , $ property , $ model , $ values ) { $ changed = false ; foreach ( $ values as & $ value ) { if ( ! $ this - > is Morhing ( $ model , $ value ) ) { continue ; } $ new Type = $ model - > get Type ( ) ; 
public static function create ( $ type , $ values ) { $ i = new static ( $ type ) ; $ i - > use Property Values ( $ values ) ; return $ i - > create Instance ( ) ; } 
private function is Morhing ( $ entity , $ value ) { if ( ! $ entity instanceof Object Entity ) { return false ; } 
private function process Property Value ( $ instance , $ property , $ model , $ value ) { if ( $ this - > is Morhing ( $ model , $ value ) ) { $ new Type = $ model - > get Type ( ) ; $ new = static : : create ( $ new Type , ( array ) $ value ) ; $ property - > set Value ( $ instance , $ new ) ; } } 
private function get Entity From Model ( $ index , $ property Name ) { $ entity = $ this - > model [ $ index ] ; if ( $ entity - > get Name ( ) = = = $ property Name ) { return $ entity ; } 
public function update Service Context Settings For Others ( $ service Context ) { $ this - > setup Service Context ( $ service Context ) ; $ this - > setup Serializers ( ) ; $ this - > use Minor Version ( ) ; $ this - > setup Rest Handler ( $ service Context ) ; } 
protected function setup Rest Handler ( $ service Context ) { if ( isset ( $ service Context ) ) { $ client = Client Factory : : create Client ( $ this - > get Client Name ( ) ) ; $ this - > rest Handler = new Sync Rest Handler ( $ service Context , $ client ) ; } else { throw new Sdk Exception ( "Can not set the Rest Client based on null Service Context . " ) ; } return $ this ; } 
public function use Xml ( ) { $ service Context = $ this - > get Service Context ( ) ; $ service Context - > use Xml ( ) ; $ this - > update Service Context Settings For Others ( $ service Context ) ; return $ this ; } 
public function use Json ( ) { $ service Context = $ this - > get Service Context ( ) ; $ service Context - > use Json ( ) ; $ this - > update Service Context Settings For Others ( $ service Context ) ; return $ this ; } 
public function set Log Location ( $ new _log _location ) { $ rest Handler = $ this - > rest Handler ; $ logger Used By Rest Handler = $ rest Handler - > get Request Logger ( ) ; $ logger Used By Rest Handler - > set Log Directory ( $ new _log _location ) ; return $ this ; } 
public function set Minor Version ( $ new Minor Version ) { $ service Context = $ this - > get Service Context ( ) ; $ service Context - > set Minor Version ( $ new Minor Version ) ; $ this - > update Service Context Settings For Others ( $ service Context ) ; return $ this ; } 
public function disable Log ( ) { $ rest Handler = $ this - > rest Handler ; $ logger Used By Rest Handler = $ rest Handler - > get Request Logger ( ) ; $ logger Used By Rest Handler - > set Log Status ( false ) ; return $ this ; } 
public function enable Log ( ) { $ rest Handler = $ this - > rest Handler ; $ logger Used By Rest Handler = $ rest Handler - > get Request Logger ( ) ; $ logger Used By Rest Handler - > set Log Status ( true ) ; return $ this ; } 
public function set Client Name ( $ client Name ) { $ this - > client Name = $ client Name ; $ service Context = $ this - > get Service Context ( ) ; $ this - > setup Rest Handler ( $ service Context ) ; return $ this ; } 
public static function Configure ( $ settings ) { if ( isset ( $ settings ) ) { if ( is _array ( $ settings ) ) { $ Service Context = Service Context : : Configure From Passed Array ( $ settings ) ; if ( ! isset ( $ Service Context ) ) { throw new Sdk Exception ( 'Construct Service Context from OAuth Settigs failed . ' ) ; } $ Data Service Instance = new Data Service ( $ Service Context ) ; } elseif ( is _string ( $ settings ) ) { $ Service Context = Service Context : : Configure From Local File ( $ settings ) ; if ( ! isset ( $ Service Context ) ) { throw new Sdk Exception ( 'Construct Service Context from File failed . ' ) ; } $ Data Service Instance = new Data Service ( $ Service Context ) ; } if ( $ Service Context - > Ipp Configuration - > OAuth Mode = = Core Constants : : OAUTH 2 ) { $ oauth 2Config = $ Service Context - > Ipp Configuration - > Security ; if ( $ oauth 2Config instanceof OAuth 2Access Token ) { $ Data Service Instance - > configure OAuth 2Login Helper ( $ oauth 2Config , $ settings ) ; } else { throw new Sdk Exception ( "SDK Error . OAuth mode is not OAuth 2 . " ) ; } } return $ Data Service Instance ; } else { throw new Sdk Exception ( "Passed Null to Configure method . It expects either a file path for the config file or an array containing OAuth settings and Base URL . " ) ; } } 
private function configure OAuth 2Login Helper ( $ oauth 2Conifg , $ settings ) { $ refresh Token = Core Constants : : get Refresh Token From Array ( $ settings ) ; if ( isset ( $ refresh Token ) ) { 
public function update OAuth 2Token ( $ new OAuth 2Access Token ) { try { $ this - > service Context - > update OAuth 2Token ( $ new OAuth 2Access Token ) ; $ realm ID = $ new OAuth 2Access Token - > get Realm ID ( ) ; $ this - > service Context - > realm Id = $ realm ID ; $ this - > setup Rest Handler ( $ this - > service Context ) ; } catch ( Sdk Exception $ e ) { $ this - > service Context - > Ipp Configuration - > Logger - > Custom Logger - > Log ( Trace Level : : Error , "Encountered an error while updating OAuth 2Token . " . $ e - > get Message ( ) ) ; $ this - > service Context - > Ipp Configuration - > Logger - > Custom Logger - > Log ( Trace Level : : Error , "Stack Trace : " . $ e - > get Trace As String ( ) ) ; } return $ this ; } 
public function setup Serializers ( ) { $ this - > response Serializer = Core Helper : : Get Serializer ( $ this - > service Context , false ) ; $ this - > request Serializer = Core Helper : : Get Serializer ( $ this - > service Context , true ) ; } 
private function get Xml From Obj ( $ php Obj ) { if ( ! $ php Obj ) { $ this - > service Context - > Ipp Configuration - > Logger - > Custom Logger - > Log ( Trace Level : : Error , "get Xml From Obj NULL arg . " ) ; return false ; } $ php 2xml = new Php 2Xml ( Core Constants : : PHP _CLASS _PREFIX ) ; $ php 2xml - > override As Single Namespace = 'http : / /schema .intuit .com /finance /v 3 ' ; try { return $ php 2xml - > get Xml ( $ php Obj ) ; } catch ( \ Exception $ e ) { $ this - > service Context - > Ipp Configuration - > Logger - > Custom Logger - > Log ( Trace Level : : Error , "Encountered an error parsing Object to XML . " . $ e - > get Message ( ) ) ; $ this - > service Context - > Ipp Configuration - > Logger - > Custom Logger - > Log ( Trace Level : : Error , "Stack Trace : " . $ e - > get Trace As String ( ) ) ; return false ; } } 
private static function decorate Intuit Entity To Php Class Name ( $ intuit Entity Name ) { $ class Name = Core Constants : : PHP _CLASS _PREFIX . $ intuit Entity Name ; $ class Name = trim ( $ class Name ) ; return $ class Name ; } 
private static function clean Php Class Name To Intuit Entity Name ( $ php Class Name ) { $ php Class Name = self : : remove Name Space From Php Class Name ( $ php Class Name ) ; if ( 0 = = strpos ( $ php Class Name , Core Constants : : PHP _CLASS _PREFIX ) ) { return substr ( $ php Class Name , strlen ( Core Constants : : PHP _CLASS _PREFIX ) ) ; } return null ; } 
private function send Request Parse Response Body And Handle Http Error ( $ entity , $ uri , $ https Post Body , $ CALLINGMETHOD , $ boundary String = null , $ email = null ) { switch ( $ CALLINGMETHOD ) { case Data Service : : DELETE : case Data Service : : ADD : case Data Service : : VOID : case Data Service : : UPDATE : $ request Parameters = $ this - > init Post Request ( $ entity , $ uri ) ; break ; case Data Service : : FINDBYID : if ( $ this - > service Context - > Ipp Configuration - > Message - > Request - > Serialization Format = = Serialization Format : : Json ) { $ request Parameters = new Request Parameters ( $ uri , 'GET ' , Core Constants : : CONTENTTYPE _APPLICATIONJSON , null ) ; } else { $ request Parameters = new Request Parameters ( $ uri , 'GET ' , Core Constants : : CONTENTTYPE _APPLICATIONXML , null ) ; } break ; case Data Service : : UPLOAD : if ( ! isset ( $ boundary String ) ) { throw new \ Exception ( "Upload Image has unset value : boundary String . " ) ; } 
public function Update ( $ entity ) { $ this - > service Context - > Ipp Configuration - > Logger - > Request Log - > Log ( Trace Level : : Info , "Called Method : Update . " ) ; (Core Constants : :Intuit Services Type QBO = = $this - >service Context - >service Type ) ) { $url Resource = 'company Info ' ; $uri = implode (Core Constants : :SLASH _CHAR , array ( 'company ' , $this - >service Context - >realm Id , $url Resource . ' ?operation =update ' ) ) ; } * / else { 
public function Find By Id ( $ entity , $ Id = null ) { $ this - > service Context - > Ipp Configuration - > Logger - > Request Log - > Log ( Trace Level : : Info , "Called Method Find By Id . " ) ; if ( is _object ( $ entity ) ) { $ https Post Body = $ this - > execute Object Serializer ( $ entity , $ url Resource ) ; 
public function Add ( $ entity ) { $ this - > service Context - > Ipp Configuration - > Logger - > Request Log - > Log ( Trace Level : : Info , "Called Method Add . " ) ; 
public function Delete ( $ entity ) { $ this - > service Context - > Ipp Configuration - > Logger - > Request Log - > Log ( Trace Level : : Info , "Called Method Delete . " ) ; 
public function Upload ( $ img Bits , $ file Name , $ mime Type , $ obj Attachable ) { $ this - > service Context - > Ipp Configuration - > Logger - > Request Log - > Log ( Trace Level : : Info , "Called Method Upload . " ) ; 
public function Download PDF ( $ entity , $ dir = null ) { $ this - > validate Entity Id ( $ entity ) ; $ this - > verify Operation Access ( $ entity , _ _FUNCTION _ _ ) ; 
public function Send Email ( $ entity , $ email = null ) { $ this - > validate Entity Id ( $ entity ) ; $ this - > verify Operation Access ( $ entity , _ _FUNCTION _ _ ) ; $ entity Id = $ this - > get IDString ( $ entity - > Id ) ; $ uri = implode ( Core Constants : : SLASH _CHAR , array ( 'company ' , $ this - > service Context - > realm Id , self : : get Entity Resource Name ( $ entity ) , $ entity Id , 'send ' ) ) ; if ( is _null ( $ email ) ) { $ this - > log Info ( "Entity " . get _class ( $ entity ) . " with id = " . $ entity Id . " is using default email " ) ; } else { $ this - > log Info ( "Entity " . get _class ( $ entity ) . " with id = " . $ entity Id . " is using $email " ) ; if ( ! $ this - > verify Email Address ( $ email ) ) { $ this - > log Error ( "Valid email is expected , but received $email " ) ; throw new Sdk Exception ( "Valid email is expected , but received $email " ) ; } } return $ this - > send Request Parse Response Body And Handle Http Error ( $ entity , $ uri , null , Data Service : : SENDEMAIL , null , $ email ) ; } 
public function Query ( $ query , $ start Position = null , $ max Results = null ) { $ this - > service Context - > Ipp Configuration - > Logger - > Request Log - > Log ( Trace Level : : Info , "Called Method Query . " ) ; if ( 'QBO ' = = $ this - > service Context - > service Type ) { $ https Content Type = Core Constants : : CONTENTTYPE _APPLICATIONTEXT ; } else { $ https Content Type = Core Constants : : CONTENTTYPE _TEXTPLAIN ; } $ https Uri = implode ( Core Constants : : SLASH _CHAR , array ( 'company ' , $ this - > service Context - > realm Id , 'query ' ) ) ; $ https Post Body = $ this - > append Pagination Info ( $ query , $ start Position , $ max Results ) ; $ request Parameters = $ this - > get Post Request Parameters ( $ https Uri , $ https Content Type ) ; $ rest Request Handler = $ this - > get Rest Handler ( ) ; list ( $ response Code , $ response Body ) = $ rest Request Handler - > send Request ( $ request Parameters , $ https Post Body , null , $ this - > is Thrown Exception On Error ( ) ) ; $ fault Handler = $ rest Request Handler - > get Fault Handler ( ) ; if ( $ fault Handler ) { $ this - > last Error = $ fault Handler ; return null ; } else { $ this - > last Error = false ; $ parsed Response Body = null ; try { $ response Xml Obj = simplexml _load _string ( $ response Body ) ; if ( $ response Xml Obj & & $ response Xml Obj - > Query Response ) { $ tmp XML = $ response Xml Obj - > Query Response - > as XML ( ) ; } $ parsed Response Body = $ this - > response Serializer - > Deserialize ( $ tmp XML , false ) ; $ this - > service Context - > Ipp Configuration - > Logger - > Custom Logger - > Log ( Trace Level : : Info , $ parsed Response Body ) ; } catch ( \ Exception $ e ) { throw new \ Exception ( "Exception appears in converting Response to XML . " ) ; } return $ parsed Response Body ; } } 
private function append Pagination Info ( $ query , $ start Position , $ max Results ) { $ query = trim ( $ query ) ; if ( isset ( $ start Position ) & & ! empty ( $ start Position ) ) { if ( stripos ( $ query , "STARTPOSITION " ) = = = false ) { if ( stripos ( $ query , "MAXRESULTS " ) ! = = false ) { 
public function Find All ( $ entity Name , $ page Number = 0 , $ page Size = 5 0 0 ) { $ this - > service Context - > Ipp Configuration - > Logger - > Request Log - > Log ( Trace Level : : Info , "Called Method Find All . " ) ; $ php Class Name = Data Service : : decorate Intuit Entity To Php Class Name ( $ entity Name ) ; 
public function CDC ( $ entity List , $ changed Since ) { $ this - > service Context - > Ipp Configuration - > Logger - > Custom Logger - > Log ( Trace Level : : Info , "Called Method CDC . " ) ; 
protected function execute Object Serializer ( $ entity , & $ url Resource ) { 
protected function init Post Request ( $ entity , $ uri ) { return $ this - > is Json Only ( $ entity ) ? $ this - > get Post Json Request ( $ uri ) : $ this - > get Post Request ( $ uri ) ; } 
protected function get Request Parameters ( $ uri , $ method , $ type , $ api Name = null ) { return new Request Parameters ( $ uri , $ method , $ type , $ api Name ) ; } 
private function fix Tax Service Payload ( $ entity , $ content ) { if ( $ this - > is Tax Service Safe ( $ entity ) ) { 
public function get Export File Name For PDF ( $ entity , $ ext , $ usetimestamp = true ) { 
protected function process Downloaded Content ( Content Writer $ writer , $ response Code , $ file Name = null , $ dir ) { $ writer - > set Prefix ( $ this - > get Prefix From Settings ( ) ) ; try { if ( isset ( $ dir ) & & ! empty ( $ dir ) ) { $ writer - > save File ( $ dir , $ file Name ) ; } else if ( $ this - > is Temp File ( ) ) { $ writer - > save Temp ( ) ; } elseif ( $ this - > is File Export ( ) ) { $ writer - > save File ( $ this - > get File Export Dir ( ) , $ file Name ) ; } else { $ writer - > save As Handler ( ) ; } 
private function is Allowed ( $ entity , $ method ) { $ class Name = get _class ( $ entity ) ; if ( ! $ class Name ) { $ this - > log Error ( "Intuit entity is expected here instead of $entity " ) ; throw new Ids Exception ( 'Unexpected Argument Exception ' ) ; } $ class Array = explode ( ' \ \ ' , $ class Name ) ; $ trimed Class Name = end ( $ class Array ) ; return $ this - > service Context - > Ipp Configuration - > Op Control List - > is Allowed ( $ trimed Class Name , $ method ) ; } 
public function Create New Batch ( ) { $ batch = new Batch ( $ this - > service Context , $ this - > get Rest Handler ( ) , $ this - > is Thrown Exception On Error ( ) ) ; return $ batch ; } 
private function convert To Timestamp ( $ str ) { $ result = date _parse ( $ str ) ; if ( ! $ result ) { return false ; } if ( empty ( $ result ) | | ! is _array ( $ result ) ) { return false ; } extract ( $ result ) ; if ( ! empty ( $ errors ) ) { throw new Sdk Exception ( "SDK failed to parse date value \ " $str \ " : " . ( is _array ( $ errors ) ? implode ( " \n " , $ errors ) : $ errors ) ) ; } 
public function is Valid Time Stamp ( $ timestamp ) { return ( ( string ) ( int ) $ timestamp = = = $ timestamp ) & & ( $ timestamp < = PHP _INT _MAX ) & & ( $ timestamp > = ~ PHP _INT _MAX ) ; } 
protected function verify Changed Since ( $ value ) { if ( is _int ( $ value ) ) { return $ value ; } 
public function get Company Info ( ) { $ current Service Context = $ this - > get Service Context ( ) ; if ( ! isset ( $ current Service Context ) | | empty ( $ current Service Context - > realm Id ) ) { throw new Sdk Exception ( "Please Setup Service Context before making get Company Info call . " ) ; } 
private function get IDString ( $ id ) { if ( $ id instanceof IPPid | | $ id instanceof Quick Books Online \ API \ Data \ IPPid ) { return ( String ) $ id - > value ; } else { return ( String ) $ id ; } } 
public static function get Quick Books Online APIEntity Rules ( ) { return array ( ' * ' = > array ( "Download PDF " = > false , "json Only " = > false , "Send Email " = > false ) , "IPPTax Service " = > array ( ' * ' = > false , 'Add ' = > true , 'json Only ' = > true ) , "IPPSales Receipt " = > array ( "Download PDF " = > true , "Send Email " = > true ) , "IPPInvoice " = > array ( "Download PDF " = > true , "Send Email " = > true ) , "IPPEstimate " = > array ( "Download PDF " = > true , "Send Email " = > true ) , ) ; } 
public static function get Access Token From Array ( array $ settings ) { if ( array _key _exists ( 'access Token Key ' , $ settings ) ) { return $ settings [ 'access Token Key ' ] ; } else if ( array _key _exists ( 'access Token ' , $ settings ) ) { return $ settings [ 'access Token ' ] ; } else if ( array _key _exists ( 'Access Token ' , $ settings ) ) { return $ settings [ 'Access Token ' ] ; } else { return null ; } } 
public static function get Refresh Token From Array ( array $ settings ) { if ( array _key _exists ( 'refresh Token Key ' , $ settings ) ) { return $ settings [ 'refresh Token Key ' ] ; } else if ( array _key _exists ( 'refresh Token ' , $ settings ) ) { return $ settings [ 'refresh Token ' ] ; } else if ( array _key _exists ( 'Refresh Token ' , $ settings ) ) { return $ settings [ 'Refresh Token ' ] ; } else { return null ; } } 
public static function get Redirect URL ( array $ settings ) { if ( array _key _exists ( 'redirect URL ' , $ settings ) ) { return $ settings [ 'redirect URL ' ] ; } else if ( array _key _exists ( 'Redirect Url ' , $ settings ) ) { return $ settings [ 'Redirect Url ' ] ; } else if ( array _key _exists ( 'redirecturl ' , $ settings ) ) { return $ settings [ 'redirecturl ' ] ; } else if ( array _key _exists ( 'redirect Url ' , $ settings ) ) { return $ settings [ 'redirect Url ' ] ; } else if ( array _key _exists ( 'Redirect URL ' , $ settings ) ) { return $ settings [ 'Redirect URL ' ] ; } else if ( array _key _exists ( 'redirect URI ' , $ settings ) ) { return $ settings [ 'redirect URI ' ] ; } else if ( array _key _exists ( 'Redirect Uri ' , $ settings ) ) { return $ settings [ 'Redirect Uri ' ] ; } else if ( array _key _exists ( 'redirecturi ' , $ settings ) ) { return $ settings [ 'redirecturl ' ] ; } else if ( array _key _exists ( 'redirect Uri ' , $ settings ) ) { return $ settings [ 'redirect Url ' ] ; } else if ( array _key _exists ( 'Redirect URI ' , $ settings ) ) { return $ settings [ 'Redirect URI ' ] ; } else { return null ; } } 
public function save Temp ( ) { $ this - > temp Path = $ this - > create Temp File ( ) ; if ( is _writable ( $ this - > get Temp Path ( ) ) ) { $ result = file _put _contents ( $ this - > get Temp Path ( ) , $ this - > get Content ( ) ) ; if ( false = = = $ result ) { throw new Sdk Exception ( 'Unable to put content into temp file : ' . $ this - > get Temp Path ( ) ) ; } if ( empty ( $ result ) ) { throw new Sdk Exception ( 'Empty or zero file was received : ' . $ this - > get Temp Path ( ) ) ; } $ this - > bytes = $ result ; return true ; } throw new Sdk Exception ( 'Unable to write temp file : ' . $ this - > temp Path ) ; } 
public function save As Handler ( ) { $ this - > handler = tmpfile ( ) ; if ( false = = = $ this - > handler ) { throw new Sdk Exception ( 'Unable to create a handler for tempfile in ' . sys _get _temp _dir ( ) ) ; } if ( empty ( $ this - > handler ) ) { throw new Sdk Exception ( 'Handler has an invalid state . It is empty . ' ) ; } $ this - > temp Path = $ this - > get Path From Handler ( ) ; if ( empty ( $ this - > temp Path ) ) { throw new Sdk Exception ( 'Unable to locate path from stream source ' ) ; } $ result = fwrite ( $ this - > handler , $ this - > get Content ( ) ) ; if ( false = = = $ result ) { throw new Sdk Exception ( 'Unable to write content into temp file : ' . $ this - > get Temp Path ( ) ) ; } if ( empty ( $ result ) ) { throw new Sdk Exception ( 'Empty or zero file was received : ' . $ this - > get Temp Path ( ) ) ; } if ( - 1 = = = fseek ( $ this - > handler , 0 ) ) { throw new Sdk Exception ( 'Unable to reset file pointer in the file ' . $ this - > get Temp Path ( ) ) ; } $ this - > bytes = $ result ; } 
public function save File ( $ dir , $ name = null ) { if ( empty ( $ dir ) ) { throw new Sdk Exception ( "Directory is empty . " ) ; } if ( ! file _exists ( $ dir ) ) { throw new Sdk Exception ( "Directory ( $dir ) doesn 't exist . " ) ; } if ( ! is _writable ( $ dir ) ) { throw new Sdk Exception ( "Directory ( $dir ) is not writable " ) ; } $ this - > temp Path = $ dir . DIRECTORY _SEPARATOR . $ this - > generate File Name ( $ name ) ; if ( file _exists ( $ this - > temp Path ) ) { throw new Sdk Exception ( "File ( $this - >temp Path ) already exists " ) ; } try { $ result = file _put _contents ( $ this - > temp Path , $ this - > get Content ( ) ) ; } catch ( \ Exception $ e ) { if ( ! is _writable ( $ this - > temp Path ) ) { throw new Sdk Exception ( "File ( { $this - >temp Path } ) is not writable " ) ; } throw new Sdk Exception ( "Error was thrown : " . $ e - > get Message ( ) . " \File : " . $ e - > get File ( ) . " on line " . $ e - > get Line ( ) ) ; } if ( false = = = $ result ) { throw new Sdk Exception ( 'Unable to write content into temp file : ' . $ this - > temp Path ) ; } $ this - > bytes = $ result ; } 
private function generate File Name ( $ name ) { $ filename = is _null ( $ name ) ? $ this - > get Uniq Id ( ) : $ name ; return is _null ( $ this - > get Prefix ( ) ) ? $ filename : $ this - > get Prefix ( ) . $ filename ; } 
public static function update ( $ obj To Update , array $ data ) { $ class Of Obj = get _class ( $ obj To Update ) ; if ( strcmp ( $ class Of Obj , Facade Helper : : simple Append Class Name Space ( "Estimate " ) ) ! = 0 ) { throw new \ Exception ( "Target object class : { " . $ class Of Obj . " } is not an instance of Estimate . " ) ; } $ new Estimate Obj = Estimate : : create ( $ data ) ; $ cloned Of Obj = Facade Helper : : clone Obj ( $ obj To Update ) ; Facade Helper : : merge Obj ( $ cloned Of Obj , $ new Estimate Obj ) ; return $ cloned Of Obj ; } 
private function generate Error From OAuth Msg ( $ OAuth Exception ) { if ( get _class ( $ OAuth Exception ) = = 'OAuth Exception ' ) { $ this - > http Status Code = $ OAuth Exception - > get Code ( ) ; $ this - > help Msg = $ OAuth Exception - > get Message ( ) ; $ this - > response Body = $ OAuth Exception - > last Response ; } else { throw new \ Exception ( "OAuth Exception required for generate error from Intuit . The passed parameters for Fault handler is not OAuth Exception " ) ; } } 
public function parse Response ( $ message ) { $ xml Obj = simplexml _load _string ( $ message ) ; if ( ! $ this - > is The Error Body In Standard Format ( $ xml Obj ) ) { return ; } $ type = ( string ) $ xml Obj - > Fault - > attributes ( ) [ 'type ' ] ; if ( isset ( $ type ) & & ! empty ( $ type ) ) { $ this - > intuit Error Type = $ type ; } $ code = ( string ) $ xml Obj - > Fault - > Error - > attributes ( ) [ 'code ' ] ; if ( isset ( $ code ) & & ! empty ( $ code ) ) { $ this - > intuit Error Code = $ code ; } $ element = ( string ) $ xml Obj - > Fault - > Error - > attributes ( ) [ 'element ' ] ; if ( isset ( $ element ) & & ! empty ( $ element ) ) { $ this - > intuit Error Element = $ element ; } $ message = ( string ) $ xml Obj - > Fault - > Error - > Message ; if ( isset ( $ message ) & & ! empty ( $ message ) ) { $ this - > intuit Error Message = $ message ; } $ detail = ( string ) $ xml Obj - > Fault - > Error - > Detail ; if ( isset ( $ detail ) & & ! empty ( $ detail ) ) { $ this - > intuit Error Detail = $ detail ; } } 
private function is The Error Body In Standard Format ( $ xml Obj ) { if ( ! isset ( $ xml Obj - > Fault ) | | ! isset ( $ xml Obj - > Fault - > Error ) ) { return false ; } return true ; } 
public static function update ( $ obj To Update , array $ data ) { $ class Of Obj = get _class ( $ obj To Update ) ; if ( strcmp ( $ class Of Obj , Facade Helper : : simple Append Class Name Space ( "Deposit " ) ) ! = 0 ) { throw new \ Exception ( "Target object class : { " . $ class Of Obj . " } is not an instance of Deposit . " ) ; } $ new Deposit Obj = Deposit : : create ( $ data ) ; $ cloned Of Obj = Facade Helper : : clone Obj ( $ obj To Update ) ; Facade Helper : : merge Obj ( $ cloned Of Obj , $ new Deposit Obj ) ; return $ cloned Of Obj ; } 
public static function update ( $ obj To Update , array $ data ) { $ class Of Obj = get _class ( $ obj To Update ) ; if ( strcmp ( $ class Of Obj , Facade Helper : : simple Append Class Name Space ( "Customer " ) ) ! = 0 ) { throw new \ Exception ( "Target object class : { " . $ class Of Obj . " } is not an instance of Customer . " ) ; } $ new Customer Obj = Customer : : create ( $ data ) ; $ cloned Of Obj = Facade Helper : : clone Obj ( $ obj To Update ) ; Facade Helper : : merge Obj ( $ cloned Of Obj , $ new Customer Obj ) ; return $ cloned Of Obj ; } 
private function set Response As It Is ( $ passed Headers , $ passed Body , $ passed Http Response Code ) { if ( isset ( $ passed Headers ) & & isset ( $ passed Body ) & & isset ( $ passed Http Response Code ) ) { $ this - > headers = $ passed Headers ; $ this - > body = $ passed Body ; $ this - > http Response Code = $ passed Http Response Code ; $ this - > set Content Type ( Core Constants : : CONTENT _TYPE , $ passed Headers [ Core Constants : : CONTENT _TYPE ] ) ; $ this - > set Intuit Tid ( Core Constants : : INTUIT _TID , $ passed Headers [ Core Constants : : INTUIT _TID ] ) ; $ this - > set Fault Handler ( $ passed Body , $ passed Http Response Code , $ this - > get Intuit Tid ( ) ) ; } else { throw new Sdk Exception ( "Passed Headers , body , or status code is Null . " ) ; } } 
private function parse Response To Intuit Response ( $ passed Headers , $ passed Body , $ passed Http Response Code , $ client Name ) { if ( $ client Name = = Core Constants : : CLIENT _CURL ) { if ( isset ( $ passed Headers ) ) { $ this - > set Headers ( $ passed Headers ) ; } else { throw new Sdk Exception ( "The response header from c URL is null . " ) ; } if ( isset ( $ passed Body ) ) { $ this - > body = $ passed Body ; } else { throw new Sdk Exception ( "The Http Response Body from c URL is null . " ) ; } if ( isset ( $ passed Http Response Code ) ) { $ this - > http Response Code = ( int ) $ passed Http Response Code ; $ this - > set Fault Handler ( $ this - > get Body ( ) , $ this - > get Status Code ( ) , $ this - > get Intuit Tid ( ) ) ; } else { throw new Sdk Exception ( "Passed Http status code from c URL is null . " ) ; } } else { throw new Sdk Exception ( "This should not be thrown . Intuit Response currently don 't support parse other client response to Intuit Response other than curl . " ) ; } } 
private function set Fault Handler ( $ body , $ http Response Code , $ tid ) { 
public function set Headers ( $ raw Headers ) { $ raw Headers = str _replace ( " \r \n " , " \n " , $ raw Headers ) ; $ response _headers _rows = explode ( " \n " , trim ( $ raw Headers ) ) ; foreach ( $ response _headers _rows as $ line ) { if ( strpos ( $ line , ' : ' ) = = false ) { continue ; } else { list ( $ key , $ value ) = explode ( ' : ' , $ line ) ; $ this - > headers [ $ key ] = $ value ; 
private function set Content Type ( $ key , $ val ) { $ trimed Key = trim ( $ key ) ; if ( strcasecmp ( $ trimed Key , Core Constants : : CONTENT _TYPE ) = = 0 ) { $ this - > content Type = trim ( $ val ) ; } } 
private function set Intuit Tid ( $ key , $ val ) { $ trimed Key = trim ( $ key ) ; if ( strcasecmp ( $ trimed Key , Core Constants : : INTUIT _TID ) = = 0 ) { $ this - > intuit _tid = trim ( $ val ) ; } } 
public static function update ( $ obj To Update , array $ data ) { $ class Of Obj = get _class ( $ obj To Update ) ; if ( strcmp ( $ class Of Obj , Facade Helper : : simple Append Class Name Space ( "Department " ) ) ! = 0 ) { throw new \ Exception ( "Target object class : { " . $ class Of Obj . " } is not an instance of Department . " ) ; } $ new Department Obj = Department : : create ( $ data ) ; $ cloned Of Obj = Facade Helper : : clone Obj ( $ obj To Update ) ; Facade Helper : : merge Obj ( $ cloned Of Obj , $ new Department Obj ) ; return $ cloned Of Obj ; } 
public function Get App Menu ( ) { $ this - > request Xml Document = ' ' ; $ uri Fragment = implode ( Core Constants : : SLASH _CHAR , array ( 'v 1 ' , 'Account ' , 'App Menu ' ) ) ; $ request Parameters = new Request Parameters ( null , 'GET ' , null , $ uri Fragment ) ; list ( $ resp Code , $ resp Html ) = $ this - > rest Request Handler - > send Request ( $ request Parameters , $ this - > request Xml Document , null ) ; return $ resp Html ; } 
public function Reconnect ( ) { $ this - > request Xml Document = ' ' ; $ uri Fragment = implode ( Core Constants : : SLASH _CHAR , array ( 'v 1 ' , 'Connection ' , 'Reconnect ' ) ) ; $ request Parameters = new Request Parameters ( null , 'GET ' , null , $ uri Fragment ) ; list ( $ resp Code , $ resp Xml ) = $ this - > rest Request Handler - > send Request ( $ request Parameters , $ this - > request Xml Document , null ) ; return simplexml _load _string ( $ resp Xml ) ; } 
public function set Uri ( $ uri ) { if ( $ uri instanceof Zend _Uri _Http ) { $ uri = $ uri - > get Uri ( ) ; } $ old Uri = $ this - > _uri ; $ this - > _uri = $ uri ; if ( $ this - > _dom ! = = null ) { 
public function set Complex Type Strategy ( $ strategy ) { if ( $ strategy = = = true ) { require _once "Zend /Soap /Wsdl /Strategy /Default Complex Type .php " ; $ strategy = new Zend _Soap _Wsdl _Strategy _Default Complex Type ( ) ; } elseif ( $ strategy = = = false ) { require _once "Zend /Soap /Wsdl /Strategy /Any Type .php " ; $ strategy = new Zend _Soap _Wsdl _Strategy _Any Type ( ) ; } elseif ( is _string ( $ strategy ) ) { if ( class _exists ( $ strategy ) ) { $ strategy = new $ strategy ( ) ; } else { require _once "Zend /Soap /Wsdl /Exception .php " ; throw new Zend _Soap _Wsdl _Exception ( sprintf ( "Strategy with name ' %s does not exist . " , $ strategy ) ) ; } } if ( ! ( $ strategy instanceof Zend _Soap _Wsdl _Strategy _Interface ) ) { require _once "Zend /Soap /Wsdl /Exception .php " ; throw new Zend _Soap _Wsdl _Exception ( "Set a strategy that is not of type 'Zend _Soap _Wsdl _Strategy _Interface ' " ) ; } $ this - > _strategy = $ strategy ; return $ this ; } 
public function add Message ( $ name , $ parts ) { $ message = $ this - > _dom - > create Element ( 'message ' ) ; $ message - > set Attribute ( 'name ' , $ name ) ; if ( sizeof ( $ parts ) > 0 ) { foreach ( $ parts as $ name = > $ type ) { $ part = $ this - > _dom - > create Element ( 'part ' ) ; $ part - > set Attribute ( 'name ' , $ name ) ; if ( is _array ( $ type ) ) { foreach ( $ type as $ key = > $ value ) { $ part - > set Attribute ( $ key , $ value ) ; } } else { $ part - > set Attribute ( 'type ' , $ type ) ; } $ message - > append Child ( $ part ) ; } } $ this - > _wsdl - > append Child ( $ message ) ; return $ message ; } 
public function add Port Type ( $ name ) { $ port Type = $ this - > _dom - > create Element ( 'port Type ' ) ; $ port Type - > set Attribute ( 'name ' , $ name ) ; $ this - > _wsdl - > append Child ( $ port Type ) ; return $ port Type ; } 
public function add Port Operation ( $ port Type , $ name , $ input = false , $ output = false , $ fault = false ) { $ operation = $ this - > _dom - > create Element ( 'operation ' ) ; $ operation - > set Attribute ( 'name ' , $ name ) ; if ( is _string ( $ input ) & & ( strlen ( trim ( $ input ) ) > = 1 ) ) { $ node = $ this - > _dom - > create Element ( 'input ' ) ; $ node - > set Attribute ( 'message ' , $ input ) ; $ operation - > append Child ( $ node ) ; } if ( is _string ( $ output ) & & ( strlen ( trim ( $ output ) ) > = 1 ) ) { $ node = $ this - > _dom - > create Element ( 'output ' ) ; $ node - > set Attribute ( 'message ' , $ output ) ; $ operation - > append Child ( $ node ) ; } if ( is _string ( $ fault ) & & ( strlen ( trim ( $ fault ) ) > = 1 ) ) { $ node = $ this - > _dom - > create Element ( 'fault ' ) ; $ node - > set Attribute ( 'message ' , $ fault ) ; $ operation - > append Child ( $ node ) ; } $ port Type - > append Child ( $ operation ) ; return $ operation ; } 
public function add Binding ( $ name , $ port Type ) { $ binding = $ this - > _dom - > create Element ( 'binding ' ) ; $ binding - > set Attribute ( 'name ' , $ name ) ; $ binding - > set Attribute ( 'type ' , $ port Type ) ; $ this - > _wsdl - > append Child ( $ binding ) ; return $ binding ; } 
public function add Binding Operation ( $ binding , $ name , $ input = false , $ output = false , $ fault = false ) { $ operation = $ this - > _dom - > create Element ( 'operation ' ) ; $ operation - > set Attribute ( 'name ' , $ name ) ; if ( is _array ( $ input ) ) { $ node = $ this - > _dom - > create Element ( 'input ' ) ; $ soap _node = $ this - > _dom - > create Element ( 'soap :body ' ) ; foreach ( $ input as $ name = > $ value ) { $ soap _node - > set Attribute ( $ name , $ value ) ; } $ node - > append Child ( $ soap _node ) ; $ operation - > append Child ( $ node ) ; } if ( is _array ( $ output ) ) { $ node = $ this - > _dom - > create Element ( 'output ' ) ; $ soap _node = $ this - > _dom - > create Element ( 'soap :body ' ) ; foreach ( $ output as $ name = > $ value ) { $ soap _node - > set Attribute ( $ name , $ value ) ; } $ node - > append Child ( $ soap _node ) ; $ operation - > append Child ( $ node ) ; } if ( is _array ( $ fault ) ) { $ node = $ this - > _dom - > create Element ( 'fault ' ) ; if ( isset ( $ fault [ 'name ' ] ) ) { $ node - > set Attribute ( 'name ' , $ fault [ 'name ' ] ) ; } $ soap _node = $ this - > _dom - > create Element ( 'soap :body ' ) ; foreach ( $ output as $ name = > $ value ) { $ soap _node - > set Attribute ( $ name , $ value ) ; } $ node - > append Child ( $ soap _node ) ; $ operation - > append Child ( $ node ) ; } $ binding - > append Child ( $ operation ) ; return $ operation ; } 
public function add Soap Binding ( $ binding , $ style = 'document ' , $ transport = 'http : / /schemas .xmlsoap .org /soap /http ' ) { $ soap _binding = $ this - > _dom - > create Element ( 'soap :binding ' ) ; $ soap _binding - > set Attribute ( 'style ' , $ style ) ; $ soap _binding - > set Attribute ( 'transport ' , $ transport ) ; $ binding - > append Child ( $ soap _binding ) ; return $ soap _binding ; } 
public function add Soap Operation ( $ binding , $ soap _action ) { if ( $ soap _action instanceof Zend _Uri _Http ) { $ soap _action = $ soap _action - > get Uri ( ) ; } $ soap _operation = $ this - > _dom - > create Element ( 'soap :operation ' ) ; $ soap _operation - > set Attribute ( 'soap Action ' , $ soap _action ) ; $ binding - > insert Before ( $ soap _operation , $ binding - > first Child ) ; return $ soap _operation ; } 
public function add Service ( $ name , $ port _name , $ binding , $ location ) { if ( $ location instanceof Zend _Uri _Http ) { $ location = $ location - > get Uri ( ) ; } $ service = $ this - > _dom - > create Element ( 'service ' ) ; $ service - > set Attribute ( 'name ' , $ name ) ; $ port = $ this - > _dom - > create Element ( 'port ' ) ; $ port - > set Attribute ( 'name ' , $ port _name ) ; $ port - > set Attribute ( 'binding ' , $ binding ) ; $ soap _address = $ this - > _dom - > create Element ( 'soap :address ' ) ; $ soap _address - > set Attribute ( 'location ' , $ location ) ; $ port - > append Child ( $ soap _address ) ; $ service - > append Child ( $ port ) ; $ this - > _wsdl - > append Child ( $ service ) ; return $ service ; } 
public function add Documentation ( $ input _node , $ documentation ) { if ( $ input _node = = = $ this ) { $ node = $ this - > _dom - > document Element ; } else { $ node = $ input _node ; } $ doc = $ this - > _dom - > create Element ( 'documentation ' ) ; $ doc _cdata = $ this - > _dom - > create Text Node ( $ documentation ) ; $ doc - > append Child ( $ doc _cdata ) ; if ( $ node - > has Child Nodes ( ) ) { $ node - > insert Before ( $ doc , $ node - > first Child ) ; } else { $ node - > append Child ( $ doc ) ; } return $ doc ; } 
public function add Types ( $ types ) { if ( $ types instanceof Dom Document ) { $ dom = $ this - > _dom - > import Node ( $ types - > document Element ) ; $ this - > _wsdl - > append Child ( $ types - > document Element ) ; } elseif ( $ types instanceof Dom Node | | $ types instanceof Dom Element | | $ types instanceof Dom Document Fragment ) { $ dom = $ this - > _dom - > import Node ( $ types ) ; $ this - > _wsdl - > append Child ( $ dom ) ; } } 
public function add Type ( $ type ) { if ( ! in _array ( $ type , $ this - > _included Types ) ) { $ this - > _included Types [ ] = $ type ; } return $ this ; } 
public function dump ( $ filename = false ) { if ( ! $ filename ) { echo $ this - > to XML ( ) ; return true ; } else { return file _put _contents ( $ filename , $ this - > to XML ( ) ) ; } } 
public function add Schema Type Section ( ) { if ( $ this - > _schema = = = null ) { $ this - > _schema = $ this - > _dom - > create Element ( 'xsd :schema ' ) ; $ this - > _schema - > set Attribute ( 'target Namespace ' , $ this - > _uri ) ; $ types = $ this - > _dom - > create Element ( 'types ' ) ; $ types - > append Child ( $ this - > _schema ) ; $ this - > _wsdl - > append Child ( $ types ) ; } return $ this ; } 
public function add Complex Type ( $ type ) { if ( in _array ( $ type , $ this - > get Types ( ) ) ) { return "tns : $type " ; } $ this - > add Schema Type Section ( ) ; $ strategy = $ this - > get Complex Type Strategy ( ) ; $ strategy - > set Context ( $ this ) ; 
private function _parse Element ( $ element ) { if ( ! is _array ( $ element ) ) { require _once "Zend /Soap /Wsdl /Exception .php " ; throw new Zend _Soap _Wsdl _Exception ( "The 'element ' parameter needs to be an associative array . " ) ; } $ element Xml = $ this - > _dom - > create Element ( 'xsd :element ' ) ; foreach ( $ element as $ key = > $ value ) { if ( in _array ( $ key , array ( 'sequence ' , 'all ' , 'choice ' ) ) ) { if ( is _array ( $ value ) ) { $ complex Type = $ this - > _dom - > create Element ( 'xsd :complex Type ' ) ; if ( count ( $ value ) > 0 ) { $ container = $ this - > _dom - > create Element ( 'xsd : ' . $ key ) ; foreach ( $ value as $ subelement ) { $ subelement Xml = $ this - > _parse Element ( $ subelement ) ; $ container - > append Child ( $ subelement Xml ) ; } $ complex Type - > append Child ( $ container ) ; } $ element Xml - > append Child ( $ complex Type ) ; } } else { $ element Xml - > set Attribute ( $ key , $ value ) ; } } return $ element Xml ; } 
public function add Element ( $ element ) { $ schema = $ this - > get Schema ( ) ; $ element Xml = $ this - > _parse Element ( $ element ) ; $ schema - > append Child ( $ element Xml ) ; return 'tns : ' . $ element [ 'name ' ] ; } 
public static function update ( $ obj To Update , array $ data ) { $ class Of Obj = get _class ( $ obj To Update ) ; if ( strcmp ( $ class Of Obj , Facade Helper : : simple Append Class Name Space ( "Purchase Order " ) ) ! = 0 ) { throw new \ Exception ( "Target object class : { " . $ class Of Obj . " } is not an instance of Purchase Order . " ) ; } $ new Purchase Order Obj = Purchase Order : : create ( $ data ) ; $ cloned Of Obj = Facade Helper : : clone Obj ( $ obj To Update ) ; Facade Helper : : merge Obj ( $ cloned Of Obj , $ new Purchase Order Obj ) ; return $ cloned Of Obj ; } 
public static function Configure From Passed Array ( array $ settings ) { Service Context : : check If OAuth Is Valid ( $ settings ) ; if ( strcasecmp ( $ settings [ 'auth _mode ' ] , Core Constants : : OAUTH 1 ) = = 0 ) { $ OAuth Config = new OAuth Request Validator ( $ settings [ 'access Token Key ' ] , $ settings [ 'access Token Secret ' ] , $ settings [ 'consumer Key ' ] , $ settings [ 'consumer Secret ' ] ) ; } else { $ OAuth Config = new OAuth 2Access Token ( $ settings [ 'Client ID ' ] , $ settings [ 'Client Secret ' ] , Core Constants : : get Access Token From Array ( $ settings ) , Core Constants : : get Refresh Token From Array ( $ settings ) ) ; } $ QBORealm ID = array _key _exists ( 'QBORealm ID ' , $ settings ) ? $ settings [ 'QBORealm ID ' ] : null ; $ base URL = array _key _exists ( 'base Url ' , $ settings ) ? $ settings [ 'base Url ' ] : null ; if ( strcasecmp ( $ base URL , Core Constants : : DEVELOPMENT _SANDBOX ) = = 0 ) { $ base URL = Core Constants : : SANDBOX _DEVELOPMENT ; } else if ( strcasecmp ( $ base URL , Core Constants : : PRODUCTION _QBO ) = = 0 ) { $ base URL = Core Constants : : QBO _BASEURL ; } $ checked Base URL = Service Context : : check And Add Base URLSlash ( $ base URL ) ; if ( $ OAuth Config instanceof OAuth 2Access Token ) { $ OAuth Config - > set Realm ID ( $ QBORealm ID ) ; $ OAuth Config - > set Base URL ( $ checked Base URL ) ; } $ service Type = Core Constants : : Intuit Services Type QBO ; $ Ipp Configuration = Local Config Reader : : Read Configuration From Parameters ( $ OAuth Config , $ checked Base URL , Core Constants : : DEFAULT _LOGGINGLOCATION , Core Constants : : DEFAULT _SDK _MINOR _VERSION ) ; $ service Context Instance = new Service Context ( $ QBORealm ID , $ service Type , $ OAuth Config , $ Ipp Configuration ) ; return $ service Context Instance ; } 
public static function check If OAuth Is Valid ( array $ settings ) { if ( ! isset ( $ settings ) | | empty ( $ settings ) ) { throw new Sdk Exception ( "Empty OAuth Array passed . Can 't construct Service Context based on Empty Array . " ) ; } if ( ! isset ( $ settings [ 'auth _mode ' ] ) ) { throw new Sdk Exception ( "No OAuth 1 or OAuth 2 Mode specified . Can 't validate OAuth tokens . " ) ; } $ mode = $ settings [ 'auth _mode ' ] ; 
private static function check And Add Base URLSlash ( $ base URL ) { $ last Char = substr ( $ base URL , - 1 ) ; if ( strcmp ( $ last Char , " / " ) ! = 0 ) { $ base URL = $ base URL . " / " ; } return $ base URL ; } 
public function get Base URL ( ) { $ this - > Ipp Configuration - > Logger - > Request Log - > Log ( Trace Level : : Info , "Called Get Base URL method . " ) ; try { if ( $ this - > service Type = = = Core Constants : : Intuit Services Type QBO ) { $ baseurl = $ this - > Ipp Configuration - > Base Url - > Qbo . implode ( Core Constants : : SLASH _CHAR , array ( Core Constants : : VERSION ) ) . Core Constants : : SLASH _CHAR ; } else if ( $ this - > service Type = = = Core Constants : : Intuit Services Type IPP ) { $ this - > Ipp Configuration - > Base Url - > Ipp = Core Constants : : IPP _BASEURL ; $ baseurl = $ this - > Ipp Configuration - > Base Url - > Ipp ; } } catch ( \ Exception $ e ) { throw new \ Exception ( "Base URL is not setup " ) ; } return $ baseurl ; } 
public function use Xml ( ) { $ this - > Ipp Configuration - > Message - > Request - > Compression Format = Compression Format : : None ; $ this - > Ipp Configuration - > Message - > Response - > Compression Format = Compression Format : : None ; $ this - > Ipp Configuration - > Message - > Request - > Serialization Format = Serialization Format : : Xml ; $ this - > Ipp Configuration - > Message - > Response - > Serialization Format = Serialization Format : : Xml ; } 
public function use Json ( ) { $ this - > Ipp Configuration - > Message - > Request - > Compression Format = Compression Format : : None ; $ this - > Ipp Configuration - > Message - > Response - > Compression Format = Compression Format : : None ; $ this - > Ipp Configuration - > Message - > Request - > Serialization Format = Serialization Format : : Json ; $ this - > Ipp Configuration - > Message - > Response - > Serialization Format = Serialization Format : : Json ; } 
public function disable Log ( ) { try { $ _ipp Config Instance = $ this - > get Ipp Config ( ) ; Local Config Reader : : setup Logger ( $ _ipp Config Instance , Core Constants : : DEFAULT _LOGGINGLOCATION , "FALSE " ) ; } catch ( \ Exception $ e ) { throw new \ Exception ( "Error in disable Log . " ) ; } } 
public function set Log Location ( $ new _log _location ) { try { $ _ipp Config Instance = $ this - > get Ipp Config ( ) ; Local Config Reader : : setup Logger ( $ _ipp Config Instance , $ new _log _location , "TRUE " ) ; } catch ( \ Exception $ e ) { throw new \ Exception ( "Error in setting up new Log Configuration : " . $ new _log _location ) ; } } 
public function update OAuth 2Token ( $ OAuth 2Access Token ) { if ( $ OAuth 2Access Token instanceof OAuth 2Access Token & & $ this - > request Validator instanceof OAuth 2Access Token ) { $ this - > Ipp Configuration - > Security = $ OAuth 2Access Token ; $ this - > request Validator = $ OAuth 2Access Token ; } } 
public function Log ( $ ids Trace Level , $ message To Write ) { if ( ( int ) $ this - > trace Switch Level < ( int ) $ ids Trace Level ) { return ; } $ back Trace = debug _backtrace ( ) ; $ caller File Name = $ back Trace [ 0 ] [ 'file ' ] ; $ caller File Line Number = $ back Trace [ 0 ] [ 'line ' ] ; $ caller Function Name = $ back Trace [ 0 ] [ 'function ' ] ; $ log Message = implode ( " - " , array ( date ( 'Y -m -d H :i :s ' ) , $ caller File Name , $ caller File Line Number , $ caller Function Name , $ message To Write ) ) ; parent : : Log ( $ ids Trace Level , $ log Message ) ; } 
public function get Php Code ( ) { $ code = " \n " ; if ( $ this - > extends Namespace ! = ' ' ) { if ( false = = = $ this - > override As Single Namespace ) { $ code . = "use " . $ this - > extends Namespace . " ; \n " ; } } if ( ! empty ( $ this - > class Doc Block ) ) { $ code . = $ this - > get Doc Block ( $ this - > class Doc Block ) ; } if ( $ this - > name = = $ this - > class Prefix . $ this - > extends ) { $ this - > name = $ this - > name . "Wrapper " ; } $ code . = 'class ' . $ this - > name . " \n " ; if ( $ this - > extends ! = ' ' ) { if ( $ this - > extends Namespace ! = ' ' ) { $ ns Last Name = array _reverse ( explode ( ' \ \ ' , $ this - > extends Namespace ) ) ; $ code . = " \t " . 'extends ' . $ this - > class Prefix . $ ns Last Name [ 0 ] ; 
public function get Class Properties ( $ props , $ indent = " \t " ) { $ code = $ indent . " \n " ; foreach ( $ props as $ prop ) { if ( ! empty ( $ prop [ 'docs ' ] ) ) { $ code . = $ indent . $ this - > get Doc Block ( $ prop [ 'docs ' ] , $ indent ) ; } $ code . = $ indent . 'public $ ' . $ prop [ 'name ' ] . " ; \n " ; } return $ code ; } 
public function get Doc Block ( $ docs , $ indent = " " ) { $ code = ' / * * ' . " \n " ; foreach ( $ docs as $ key = > $ value ) { $ code . = $ indent . ' * @ ' . $ key . ' ' . $ value . " \n " ; } $ code . = $ indent . ' * / ' . " \n " ; return $ code ; } 
public static function update ( $ obj To Update , array $ data ) { $ class Of Obj = get _class ( $ obj To Update ) ; if ( strcmp ( $ class Of Obj , Facade Helper : : simple Append Class Name Space ( "Purchase " ) ) ! = 0 ) { throw new \ Exception ( "Target object class : { " . $ class Of Obj . " } is not an instance of Purchase . " ) ; } $ new Purchase Obj = Purchase : : create ( $ data ) ; $ cloned Of Obj = Facade Helper : : clone Obj ( $ obj To Update ) ; Facade Helper : : merge Obj ( $ cloned Of Obj , $ new Purchase Obj ) ; return $ cloned Of Obj ; } 
public function get Result ( ) { if ( isset ( $ this - > entity ) ) { return $ this - > entity ; } else if ( isset ( $ this - > entities ) ) { return $ this - > entities ; } else { return null ; } } 
public function set Uri ( $ uri ) { if ( ! is _string ( $ uri ) & & ! ( $ uri instanceof Zend _Uri ) ) { require _once "Zend /Soap /Auto Discover /Exception .php " ; throw new Zend _Soap _Auto Discover _Exception ( "No uri given to Zend _Soap _Auto Discover : :set Uri as string or Zend _Uri instance . " ) ; } $ this - > _uri = $ uri ; 
public function get Uri ( ) { if ( $ this - > _uri ! = = null ) { $ uri = $ this - > _uri ; } else { $ schema = $ this - > get Schema ( ) ; $ host = $ this - > get Host Name ( ) ; $ script Name = $ this - > get Request Uri Without Parameters ( ) ; $ uri = Zend _Uri : : factory ( $ schema . ' : / / ' . $ host . $ script Name ) ; $ this - > set Uri ( $ uri ) ; } return $ uri ; } 
public function set Binding Style ( array $ binding Style = array ( ) ) { if ( isset ( $ binding Style [ 'style ' ] ) ) { $ this - > _binding Style [ 'style ' ] = $ binding Style [ 'style ' ] ; } if ( isset ( $ binding Style [ 'transport ' ] ) ) { $ this - > _binding Style [ 'transport ' ] = $ binding Style [ 'transport ' ] ; } return $ this ; } 
protected function get Request Uri Without Parameters ( ) { if ( isset ( $ _SERVER [ 'HTTP _X _REWRITE _URL ' ] ) ) { 
public function set Complex Type Strategy ( $ strategy ) { $ this - > _strategy = $ strategy ; if ( $ this - > _wsdl instanceof Zend _Soap _Wsdl ) { $ this - > _wsdl - > set Complex Type Strategy ( $ strategy ) ; } return $ this ; } 
public function set Class ( $ class , $ namespace = ' ' , $ argv = null ) { $ uri = $ this - > get Uri ( ) ; $ wsdl = new Zend _Soap _Wsdl ( $ class , $ uri , $ this - > _strategy ) ; 
public function add Function ( $ function , $ namespace = ' ' ) { static $ port ; static $ operation ; static $ binding ; if ( ! is _array ( $ function ) ) { $ function = ( array ) $ function ; } $ uri = $ this - > get Uri ( ) ; if ( ! ( $ this - > _wsdl instanceof Zend _Soap _Wsdl ) ) { $ parts = explode ( ' . ' , basename ( $ _SERVER [ 'SCRIPT _NAME ' ] ) ) ; $ name = $ parts [ 0 ] ; $ wsdl = new Zend _Soap _Wsdl ( $ name , $ uri , $ this - > _strategy ) ; 
protected function _add Function To Wsdl ( $ function , $ wsdl , $ port , $ binding ) { $ uri = $ this - > get Uri ( ) ; 
public function dump ( $ filename ) { if ( $ this - > _wsdl ! = = null ) { return $ this - > _wsdl - > dump ( $ filename ) ; } else { require _once "Zend /Soap /Auto Discover /Exception .php " ; throw new Zend _Soap _Auto Discover _Exception ( "Cannot dump autodiscovered contents , WSDL file has not been generated yet . " ) ; } } 
public static function update ( $ obj To Update , array $ data ) { $ class Of Obj = get _class ( $ obj To Update ) ; if ( strcmp ( $ class Of Obj , Facade Helper : : simple Append Class Name Space ( "Class " ) ) ! = 0 ) { throw new \ Exception ( "Target object class : { " . $ class Of Obj . " } is not an instance of Class . " ) ; } $ new Class Obj = Quick Book Class : : create ( $ data ) ; $ cloned Of Obj = Facade Helper : : clone Obj ( $ obj To Update ) ; Facade Helper : : merge Obj ( $ cloned Of Obj , $ new Class Obj ) ; return $ cloned Of Obj ; } 
public function update Context ( $ new Service Context ) { if ( isset ( $ new Service Context ) & & $ new Service Context instanceof Service Context ) { $ this - > context = $ new Service Context ; } else { throw new Sdk Exception ( "Cannot Update Service Context . The service context either is undefined or not an instance of Service Context . " ) ; } } 
public function send Request ( $ request Parameters , $ request Body , $ specified Request Uri , $ throw Exception On Error = false ) { 
private function OAuth 1APICall ( $ base URL , $ query Parameters , $ Http Method , $ request Uri , $ request Parameters , $ request Body , $ throw Exception On Error ) { $ Authorization Header = $ this - > get OAuth 1Authorization Header ( $ base URL , $ query Parameters , $ Http Method ) ; $ http Headers = $ this - > set Common Headers For PHPSDK ( $ Authorization Header , $ request Uri , $ request Parameters - > Content Type , $ request Body ) ; 
private function get OAuth 1Authorization Header ( $ base URL , $ query Parameters , $ Http Method ) { $ oauth 1 = new OAuth 1 ( $ this - > context - > request Validator - > Consumer Key , $ this - > context - > request Validator - > Consumer Secret , $ this - > context - > request Validator - > Access Token , $ this - > context - > request Validator - > Access Token Secret ) ; $ Authorization Header = $ oauth 1 - > get OAuth Header ( $ base URL , $ query Parameters , $ Http Method ) ; return $ Authorization Header ; } 
private function OAuth 2APICall ( $ base URL , $ query Parameters , $ Http Method , $ request Uri , $ request Parameters , $ request Body , $ throw Exception On Error ) { $ Authorization Header = $ this - > get OAuth 2Authorization Header ( $ this - > context - > request Validator ) ; 
private function get OAuth 2Authorization Header ( $ OAuth 2Access Token ) { if ( ! $ OAuth 2Access Token instanceof OAuth 2Access Token ) { throw new Sdk Exception ( "Internal Error . The OAuth 2 configuration is not complete . " ) ; } $ access Token = $ OAuth 2Access Token - > get Access Token ( ) ; $ Authorization Header = "Bearer " . $ access Token ; return $ Authorization Header ; } 
private function set Common Headers For PHPSDK ( $ Authorization Header , $ request Uri , $ Content Type , $ request Body ) { $ http Headers = array ( 'Authorization ' = > $ Authorization Header , 'host ' = > parse _url ( $ request Uri , PHP _URL _HOST ) , 'user -agent ' = > Core Constants : : USERAGENT , 'accept ' = > $ this - > get Accept Content Type ( $ Content Type ) , 'connection ' = > 'close ' , 'content -type ' = > $ Content Type , 'content -length ' = > strlen ( $ request Body ) ) ; return $ http Headers ; } 
public function Log APIResponse To Log ( $ body , $ request Uri , $ http Headers ) { if ( strcasecmp ( $ http Headers [ Core Constants : : CONTENT _TYPE ] , Core Constants : : CONTENTTYPE _APPLICATIONXML ) = = 0 | | strcasecmp ( $ http Headers [ Core Constants : : CONTENT _TYPE ] , Core Constants : : CONTENTTYPE _APPLICATIONXML _WITH _CHARSET ) = = 0 ) { $ body = $ this - > parse String To Dom ( $ body ) ; } $ this - > Request Logging - > Log Platform Requests ( $ body , $ request Uri , $ http Headers , false ) ; } 
public function Log APIRequest To Log ( $ request Body , $ request Uri , $ http Headers ) { $ this - > Request Logging - > Log Platform Requests ( $ request Body , $ request Uri , $ http Headers , true ) ; if ( $ request Body & & $ this - > Request Compressor ) { $ this - > Request Compressor - > Compress ( $ http Headers , $ request Body ) ; } if ( $ this - > Response Compressor ) { $ this - > Response Compressor - > Prepare Decompress ( $ http Headers ) ; } } 
private function parse String To Dom ( $ string ) { $ dom = new \ DOMDocument ( ) ; $ dom - > preserve White Space = FALSE ; $ dom - > load XML ( $ string ) ; $ dom - > format Output = TRUE ; return $ dom - > save Xml ( ) ; } 
private function reset Compressor And Serializer ( ) { $ this - > Request Compressor = Core Helper : : Get Compressor ( $ this - > context , true ) ; $ this - > Response Compressor = Core Helper : : Get Compressor ( $ this - > context , false ) ; $ this - > Request Serializer = Core Helper : : Get Serializer ( $ this - > context , true ) ; $ this - > Response Serializer = Core Helper : : Get Serializer ( $ this - > context , false ) ; } 
private function get Destination URL ( $ request Parameters , $ o Mode , $ specified Request Uri ) { 
private function append Minor Version To Request URI ( $ request Uri ) { $ set Minor Version = $ this - > context - > minor Version ; if ( isset ( $ set Minor Version ) ) { if ( $ this - > query To Array ( $ request Uri ) = = false ) { 
private function check HTTPMethod ( $ request Parameters ) { $ verb = $ request Parameters - > Http Verb Type ; if ( strcasecmp ( $ verb , Core Constants : : HTTP _POST ) = = 0 ) { return Core Constants : : HTTP _POST ; } else if ( strcasecmp ( $ verb , Core Constants : : HTTP _GET ) = = 0 ) { return Core Constants : : HTTP _GET ; } else { throw new Sdk Exception ( "Internal Error . Unsupported HTTP Method : " . $ verb ) ; } } 
private function parse URL ( $ url ) { $ query _str = parse _url ( $ url , PHP _URL _QUERY ) ; parse _str ( $ query _str , $ parameters ) ; return $ parameters ; } 
private function get Accept Content Type ( $ value ) { if ( Core Constants : : CONTENTTYPE _APPLICATIONXML = = = $ value ) { return $ value ; } if ( Core Constants : : CONTENTTYPE _APPLICATIONJSON = = = $ value ) { return $ value ; } if ( Core Constants : : CONTENTTYPE _APPLICATIONPDF = = = $ value ) { return $ value ; } if ( Core Constants : : CONTENTTYPE _OCTETSTREAM = = = $ value ) { if ( $ this - > Response Serializer instanceof Xml Object Serializer ) { return Core Constants : : CONTENTTYPE _APPLICATIONXML ; } if ( $ this - > Response Serializer instanceof Json Object Serializer ) { return Core Constants : : CONTENTTYPE _APPLICATIONJSON ; } } return " * / * " ; } 
private function query To Array ( $ qry ) { $ result = array ( ) ; 
public function Get Response Sync Rest ( $ request Parameters , $ request Body , $ oauth Request Uri ) { $ handler = new Fault Handler ( $ this - > context ) ; 
public function verify Pay Load ( $ pay Load , $ sig , $ algo = null ) { $ encrypted Payload = $ this - > encrypt Pay Load Based On Token ( $ pay Load , $ algo ) ; if ( strcmp ( $ sig , $ encrypted Payload ) = = 0 ) { return true ; } else { return false ; } } 
private function encrypt Pay Load Based On Token ( $ pay Load , $ hash Algorithm = null ) { if ( $ hash Algorithm = = null ) { $ hash Algorithm = Token Verifier : : HASH _ALGORITHM ; } $ hashed Pay Load = hash _hmac ( $ hash Algorithm , $ pay Load , $ this - > verifier Token ) ; $ encoded Hashed Pay Load = base 6 4 _encode ( hex 2bin ( $ hashed Pay Load ) ) ; return $ encoded Hashed Pay Load ; } 
public static function update ( $ obj To Update , array $ data ) { $ class Of Obj = get _class ( $ obj To Update ) ; if ( strcmp ( $ class Of Obj , Facade Helper : : simple Append Class Name Space ( "Employee " ) ) ! = 0 ) { throw new \ Exception ( "Target object class : { " . $ class Of Obj . " } is not an instance of Employee . " ) ; } $ new Employee Obj = Employee : : create ( $ data ) ; $ cloned Of Obj = Facade Helper : : clone Obj ( $ obj To Update ) ; Facade Helper : : merge Obj ( $ cloned Of Obj , $ new Employee Obj ) ; return $ cloned Of Obj ; } 
public function Intuit Batch Response ( $ id ) { if ( array _key _exists ( $ id , $ this - > intuit Batch Item Responses ) ) { return $ this - > intuit Batch Item Responses [ $ id ] ; } else { return null ; } } 
public function Add Query ( $ query , $ id ) { if ( ! $ query ) { $ exception = new Ids Exception ( 'String Parameter Null Or Empty : query ' ) ; Ids Exception Manager : : Handle Exception ( $ exception ) ; } if ( ! $ id ) { $ exception = new Ids Exception ( 'String Parameter Null Or Empty : id ' ) ; Ids Exception Manager : : Handle Exception ( $ exception ) ; } if ( count ( $ this - > batch Requests ) > 2 5 ) { $ exception = new Ids Exception ( 'Batch Items Exceeded Exception ' ) ; Ids Exception Manager : : Handle Exception ( $ exception ) ; } $ batch Item = new IPPBatch Item Request ( ) ; $ batch Item - > Query = $ query ; $ batch Item - > b Id = $ id ; $ batch Item - > operation Specified = true ; 
public function Add Entity ( $ entity , $ id , $ operation ) { if ( ! $ entity ) { $ exception = new Ids Exception ( 'String Parameter Null Or Empty : entity ' ) ; Ids Exception Manager : : Handle Exception ( $ exception ) ; } if ( ! $ id ) { $ exception = new Ids Exception ( 'String Parameter Null Or Empty : id ' ) ; Ids Exception Manager : : Handle Exception ( $ exception ) ; } if ( ! $ operation ) { $ exception = new Ids Exception ( 'String Parameter Null Or Empty : operation ' ) ; Ids Exception Manager : : Handle Exception ( $ exception ) ; } foreach ( $ this - > batch Requests as $ one Batch Request ) { if ( $ one Batch Request - > b Id = = $ id ) { $ exception = new Ids Exception ( 'Batch Id Already Used ' ) ; Ids Exception Manager : : Handle Exception ( $ exception ) ; } } $ batch Item = new IPPBatch Item Request ( ) ; $ batch Item - > Intuit Object = $ entity ; $ batch Item - > b Id = $ id ; $ batch Item - > operation = $ operation ; $ batch Item - > operation Specified = true ; $ this - > batch Requests [ ] = $ batch Item ; } 
public function Remove ( $ id ) { if ( ! $ id ) { $ exception = new Ids Exception ( 'Batch Item Id Not Found : id ' ) ; Ids Exception Manager : : Handle Exception ( $ exception ) ; } $ revised Batch Requests = array ( ) ; foreach ( $ this - > batch Requests as $ one Batch Request ) { if ( $ one Batch Request - > b Id = = $ id ) { 
public function Execute With Request ID ( $ request ID ) { if ( isset ( $ request ID ) & & ! empty ( $ request ID ) ) { $ this - > send Request ( $ request ID ) ; } else { throw new \ Exception ( "Execute With Request ID called with Empty or Null request ID " ) ; } } 
private function array To Message And Code ( array $ array ) { if ( empty ( $ array ) ) { return array ( null , null ) ; } if ( 1 = = count ( $ array ) ) { $ item = array _pop ( $ array ) ; return array ( $ item - > message , $ item - > code ) ; } $ message = " " ; $ code = " " ; foreach ( $ array as $ item ) { $ message . = "Exception : " . $ item - > message . " \n " ; if ( empty ( $ code ) & & ! empty ( $ item - > code ) ) { $ code = $ item - > code ; } } return array ( $ message , $ code ) ; } 
public function Iterate Fault And Prepare Exception ( $ fault ) { if ( ! $ this - > verify Fault ( $ fault ) ) { return null ; } 
private function Process Batch Item Response ( $ one Xml Obj ) { $ result = new Intuit Batch Response ( ) ; if ( null = = $ one Xml Obj ) { return $ result ; } if ( isset ( $ one Xml Obj [ "b Id " ] ) ) { $ bid = ( String ) $ one Xml Obj [ "b Id " ] ; $ result - > batch Item Id = $ bid ; } else { throw new \ Exception ( "No bid Found on the Batch Response . " ) ; } $ first Child = null ; foreach ( $ one Xml Obj - > children ( ) as $ one Child ) { $ first Child = $ one Child ; break ; } if ( ! $ first Child ) { return $ result ; } $ first Child Name = ( string ) $ first Child - > get Name ( ) ; switch ( $ first Child Name ) { 
public function set Options ( $ options ) { if ( $ options instanceof Zend _Config ) { $ options = $ options - > to Array ( ) ; } foreach ( $ options as $ key = > $ value ) { switch ( $ key ) { case 'classmap ' : case 'class Map ' : $ this - > set Classmap ( $ value ) ; break ; case 'encoding ' : $ this - > set Encoding ( $ value ) ; break ; case 'soap Version ' : case 'soap _version ' : $ this - > set Soap Version ( $ value ) ; break ; case 'wsdl ' : $ this - > set Wsdl ( $ value ) ; break ; case 'uri ' : $ this - > set Uri ( $ value ) ; break ; case 'location ' : $ this - > set Location ( $ value ) ; break ; case 'style ' : $ this - > set Style ( $ value ) ; break ; case 'use ' : $ this - > set Encoding Method ( $ value ) ; break ; case 'login ' : $ this - > set Http Login ( $ value ) ; break ; case 'password ' : $ this - > set Http Password ( $ value ) ; break ; case 'proxy _host ' : $ this - > set Proxy Host ( $ value ) ; break ; case 'proxy _port ' : $ this - > set Proxy Port ( $ value ) ; break ; case 'proxy _login ' : $ this - > set Proxy Login ( $ value ) ; break ; case 'proxy _password ' : $ this - > set Proxy Password ( $ value ) ; break ; case 'local _cert ' : $ this - > set Https Certificate ( $ value ) ; break ; case 'passphrase ' : $ this - > set Https Cert Passphrase ( $ value ) ; break ; case 'compression ' : $ this - > set Compression Options ( $ value ) ; break ; case 'stream _context ' : $ this - > set Stream Context ( $ value ) ; break ; case 'features ' : $ this - > set Soap Features ( $ value ) ; break ; case 'cache _wsdl ' : $ this - > set Wsdl Cache ( $ value ) ; break ; case 'useragent ' : case 'user Agent ' : case 'user _agent ' : $ this - > set User Agent ( $ value ) ; break ; 
public function get Options ( ) { $ options = array ( ) ; $ options [ 'classmap ' ] = $ this - > get Classmap ( ) ; $ options [ 'encoding ' ] = $ this - > get Encoding ( ) ; $ options [ 'soap _version ' ] = $ this - > get Soap Version ( ) ; $ options [ 'wsdl ' ] = $ this - > get Wsdl ( ) ; $ options [ 'uri ' ] = $ this - > get Uri ( ) ; $ options [ 'location ' ] = $ this - > get Location ( ) ; $ options [ 'style ' ] = $ this - > get Style ( ) ; $ options [ 'use ' ] = $ this - > get Encoding Method ( ) ; $ options [ 'login ' ] = $ this - > get Http Login ( ) ; $ options [ 'password ' ] = $ this - > get Http Password ( ) ; $ options [ 'proxy _host ' ] = $ this - > get Proxy Host ( ) ; $ options [ 'proxy _port ' ] = $ this - > get Proxy Port ( ) ; $ options [ 'proxy _login ' ] = $ this - > get Proxy Login ( ) ; $ options [ 'proxy _password ' ] = $ this - > get Proxy Password ( ) ; $ options [ 'local _cert ' ] = $ this - > get Https Certificate ( ) ; $ options [ 'passphrase ' ] = $ this - > get Https Cert Passphrase ( ) ; $ options [ 'compression ' ] = $ this - > get Compression Options ( ) ; * ugly hack as I don 't know if checking for ' = = = null ' * breaks some other option * / if ( $ key = = 'user _agent ' ) { if ( $ value = = = null ) { unset ( $ options [ $ key ] ) ; } } else { if ( $ value = = null ) { unset ( $ options [ $ key ] ) ; } } } return $ options ; } 
public function set Soap Version ( $ version ) { if ( ! in _array ( $ version , array ( SOAP _ 1 _ 1 , SOAP _ 1 _ 2 ) ) ) { require _once 'Zend /Soap /Client /Exception .php ' ; throw new Zend _Soap _Client _Exception ( 'Invalid soap version specified . Use SOAP _ 1 _ 1 or SOAP _ 1 _ 2 constants . ' ) ; } $ this - > _soap Version = $ version ; $ this - > _soap Client = null ; return $ this ; } 
public function set Classmap ( array $ classmap ) { foreach ( $ classmap as $ type = > $ class ) { if ( ! class _exists ( $ class ) ) { require _once 'Zend /Soap /Client /Exception .php ' ; throw new Zend _Soap _Client _Exception ( 'Invalid class in class map ' ) ; } } $ this - > _classmap = $ classmap ; $ this - > _soap Client = null ; return $ this ; } 
public function set Encoding ( $ encoding ) { if ( ! is _string ( $ encoding ) ) { require _once 'Zend /Soap /Client /Exception .php ' ; throw new Zend _Soap _Client _Exception ( 'Invalid encoding specified ' ) ; } $ this - > _encoding = $ encoding ; $ this - > _soap Client = null ; return $ this ; } 
public function set Uri ( $ uri ) { $ this - > validate Urn ( $ uri ) ; $ this - > _uri = $ uri ; $ this - > _soap Client = null ; return $ this ; } 
public function set Location ( $ location ) { $ this - > validate Urn ( $ location ) ; $ this - > _location = $ location ; $ this - > _soap Client = null ; return $ this ; } 
public function set Style ( $ style ) { if ( ! in _array ( $ style , array ( SOAP _RPC , SOAP _DOCUMENT ) ) ) { require _once 'Zend /Soap /Client /Exception .php ' ; throw new Zend _Soap _Client _Exception ( 'Invalid request style specified . Use SOAP _RPC or SOAP _DOCUMENT constants . ' ) ; } $ this - > _style = $ style ; $ this - > _soap Client = null ; return $ this ; } 
public function set Encoding Method ( $ use ) { if ( ! in _array ( $ use , array ( SOAP _ENCODED , SOAP _LITERAL ) ) ) { require _once 'Zend /Soap /Client /Exception .php ' ; throw new Zend _Soap _Client _Exception ( 'Invalid message encoding method . Use SOAP _ENCODED or SOAP _LITERAL constants . ' ) ; } $ this - > _use = $ use ; $ this - > _soap Client = null ; return $ this ; } 
public function set Proxy Port ( $ proxy Port ) { $ this - > _proxy _port = ( int ) $ proxy Port ; $ this - > _soap Client = null ; return $ this ; } 
public function set Https Certificate ( $ local Cert ) { if ( ! is _readable ( $ local Cert ) ) { require _once 'Zend /Soap /Client /Exception .php ' ; throw new Zend _Soap _Client _Exception ( 'Invalid HTTPS client certificate path . ' ) ; } $ this - > _local _cert = $ local Cert ; $ this - > _soap Client = null ; return $ this ; } 
public function set Stream Context ( $ context ) { if ( ! is _resource ( $ context ) | | get _resource _type ( $ context ) ! = = "stream -context " ) { require _once "Zend /Soap /Client /Exception .php " ; throw new Zend _Soap _Client _Exception ( "Invalid stream context resource given . " ) ; } $ this - > _stream _context = $ context ; return $ this ; } 
public function set User Agent ( $ user Agent ) { if ( $ user Agent = = = null ) { $ this - > _user _agent = null ; } else { $ this - > _user _agent = ( string ) $ user Agent ; } return $ this ; } 
public function _do Request ( Zend _Soap _Client _Common $ client , $ request , $ location , $ action , $ version , $ one _way = null ) { 
protected function _init Soap Client Object ( ) { $ wsdl = $ this - > get Wsdl ( ) ; $ options = array _merge ( $ this - > get Options ( ) , array ( 'trace ' = > true ) ) ; if ( $ wsdl = = null ) { if ( ! isset ( $ options [ 'location ' ] ) ) { require _once 'Zend /Soap /Client /Exception .php ' ; throw new Zend _Soap _Client _Exception ( ' \ 'location \ ' parameter is required in non -WSDL mode . ' ) ; } if ( ! isset ( $ options [ 'uri ' ] ) ) { require _once 'Zend /Soap /Client /Exception .php ' ; throw new Zend _Soap _Client _Exception ( ' \ 'uri \ ' parameter is required in non -WSDL mode . ' ) ; } } else { if ( isset ( $ options [ 'use ' ] ) ) { require _once 'Zend /Soap /Client /Exception .php ' ; throw new Zend _Soap _Client _Exception ( ' \ 'use \ ' parameter only works in non -WSDL mode . ' ) ; } if ( isset ( $ options [ 'style ' ] ) ) { require _once 'Zend /Soap /Client /Exception .php ' ; throw new Zend _Soap _Client _Exception ( ' \ 'style \ ' parameter only works in non -WSDL mode . ' ) ; } } unset ( $ options [ 'wsdl ' ] ) ; $ this - > _soap Client = new Zend _Soap _Client _Common ( array ( $ this , ' _do Request ' ) , $ wsdl , $ options ) ; } 
public function add Soap Input Header ( Soap Header $ header , $ permanent = false ) { if ( $ permanent ) { $ this - > _permanent Soap Input Headers [ ] = $ header ; } else { $ this - > _soap Input Headers [ ] = $ header ; } return $ this ; } 
public function get Functions ( ) { if ( $ this - > get Wsdl ( ) = = null ) { require _once 'Zend /Soap /Client /Exception .php ' ; throw new Zend _Soap _Client _Exception ( ' \ 'get Functions \ ' method is available only in WSDL mode . ' ) ; } $ soap Client = $ this - > get Soap Client ( ) ; return $ soap Client - > _ _get Functions ( ) ; } 
public function get Types ( ) { if ( $ this - > get Wsdl ( ) = = null ) { require _once 'Zend /Soap /Client /Exception .php ' ; throw new Zend _Soap _Client _Exception ( ' \ 'get Types \ ' method is available only in WSDL mode . ' ) ; } $ soap Client = $ this - > get Soap Client ( ) ; return $ soap Client - > _ _get Types ( ) ; } 
public function add Complex Type ( $ type ) { $ nested Counter = $ this - > _get Nested Count ( $ type ) ; if ( $ nested Counter > 0 ) { $ singular Type = $ this - > _get Singular Type ( $ type ) ; for ( $ i = 1 ; $ i < = $ nested Counter ; $ i + + ) { $ complex Type Name = substr ( $ this - > _get Type Name Based On Nesting Level ( $ singular Type , $ i ) , 4 ) ; $ child Type Name = $ this - > _get Type Name Based On Nesting Level ( $ singular Type , $ i - 1 ) ; $ this - > _add Element From Wsdl And Child Types ( $ complex Type Name , $ child Type Name ) ; } 
protected function _get Type Name Based On Nesting Level ( $ singular Type , $ level ) { if ( $ level = = 0 ) { 
protected function _add Element From Wsdl And Child Types ( $ array Type , $ child Type Name ) { if ( ! in _array ( $ array Type , $ this - > get Context ( ) - > get Types ( ) ) ) { $ dom = $ this - > get Context ( ) - > to Dom Document ( ) ; $ complex Type = $ dom - > create Element ( 'xsd :complex Type ' ) ; $ complex Type - > set Attribute ( 'name ' , $ array Type ) ; $ sequence = $ dom - > create Element ( 'xsd :sequence ' ) ; $ element = $ dom - > create Element ( 'xsd :element ' ) ; $ element - > set Attribute ( 'name ' , 'item ' ) ; $ element - > set Attribute ( 'type ' , $ child Type Name ) ; $ element - > set Attribute ( 'min Occurs ' , 0 ) ; $ element - > set Attribute ( 'max Occurs ' , 'unbounded ' ) ; $ sequence - > append Child ( $ element ) ; $ complex Type - > append Child ( $ sequence ) ; $ this - > get Context ( ) - > get Schema ( ) - > append Child ( $ complex Type ) ; $ this - > get Context ( ) - > add Type ( $ array Type ) ; } } 
public function prepare ( ) { $ this - > dom - > create Attribute NS ( $ this - > namespaces [ 'soap ' ] , 'soap :definitions ' ) ; $ this - > dom - > create Attribute NS ( $ this - > namespaces [ $ this - > xml Schema Preffix ] , $ this - > xml Schema Preffix . ' :definitions ' ) ; 
private function extract Types ( ) { $ all El = array ( ) ; $ all Imp = array ( ) ; $ methods = array ( ) ; foreach ( $ this - > methods Meta as $ method Name = > $ data ) { $ elements = array ( ) ; $ input = false ; $ output = false ; if ( count ( $ data [ 'params ' ] ) = = 1 ) { $ type = $ this - > common - > php Type To Soap ( $ data [ 'params ' ] [ 0 ] [ 'type ' ] ) ; $ els = array ( ) ; if ( $ type = = = false ) { $ type = $ this - > get Type Name ( $ data [ 'params ' ] [ 0 ] [ 'type ' ] ) ; $ els [ ] = $ this - > create Ref Element ( $ type ) ; } else { $ els [ ] = $ this - > create Simple Element ( ucfirst ( $ data [ 'params ' ] [ 0 ] [ 'name ' ] ) , $ data [ 'params ' ] [ 0 ] [ 'type ' ] ) ; } $ elements [ ] = $ this - > create Element With Complex Type ( ucfirst ( $ method Name ) , $ els ) ; $ this - > add Message ( ucfirst ( $ method Name ) , $ this - > target Ns Prefix . " : " . ucfirst ( $ method Name ) ) ; $ input = true ; } elseif ( $ data [ 'params ' ] > 1 ) { $ els = array ( ) ; foreach ( $ data [ 'params ' ] as $ input ) { $ type = $ this - > common - > php Type To Soap ( $ input [ 'type ' ] ) ; if ( $ type = = = false ) { $ type = $ this - > get Type Name ( $ input [ 'type ' ] ) ; $ els [ ] = $ this - > create Ref Element ( $ type ) ; } else { $ els [ ] = $ this - > create Simple Element ( ucfirst ( $ input [ 'name ' ] ) , $ input [ 'type ' ] ) ; } } $ elements [ ] = $ this - > create Element With Complex Type ( ucfirst ( $ method Name ) , $ els ) ; $ this - > add Message ( ucfirst ( $ method Name ) , $ this - > target Ns Prefix . " : " . ucfirst ( $ method Name ) ) ; $ input = true ; } if ( array _key _exists ( 'return ' , $ data ) ) { $ type = $ this - > common - > php Type To Soap ( $ data [ 'return ' ] [ 'type ' ] ) ; if ( $ type = = = false ) { 
private function add Binding Operations ( $ operation , $ input = false , $ output = false ) { $ el = $ this - > dom - > create Element ( 'wsdl :operation ' ) ; $ el - > set Attribute ( 'name ' , $ operation ) ; $ soap Operation = $ this - > dom - > create Element ( 'soap :operation ' ) ; $ soap Operation - > set Attribute ( 'soap Action ' , $ this - > wsdl Target Namespace . " / " . $ operation ) ; $ el - > append Child ( $ soap Operation ) ; if ( $ input = = = true ) { $ inp = $ this - > dom - > create Element ( 'wsdl :input ' ) ; $ body = $ this - > dom - > create Element ( 'soap :body ' ) ; $ body - > set Attribute ( 'use ' , 'literal ' ) ; $ inp - > append Child ( $ body ) ; $ el - > append Child ( $ inp ) ; } if ( $ output = = = true ) { $ out = $ this - > dom - > create Element ( 'wsdl :output ' ) ; $ body = $ this - > dom - > create Element ( 'soap :body ' ) ; $ body - > set Attribute ( 'use ' , 'literal ' ) ; $ out - > append Child ( $ body ) ; $ el - > append Child ( $ out ) ; } $ this - > ws Binding - > append Child ( $ el ) ; } 
private function add Port Operations ( $ operation , $ input = false , $ output = false ) { $ el = $ this - > dom - > create Element ( "wsdl :operation " ) ; $ el - > set Attribute ( 'name ' , $ operation ) ; if ( $ input = = = true ) { $ input = $ this - > dom - > create Element ( 'wsdl :input ' ) ; $ input - > set Attribute ( 'message ' , $ this - > target Ns Prefix . " : " . $ operation ) ; } if ( $ output = = = true ) { $ output = $ this - > dom - > create Element ( 'wsdl :output ' ) ; $ output - > set Attribute ( 'message ' , $ this - > target Ns Prefix . " : " . $ operation . "Response " ) ; } $ el - > append Child ( $ input ) ; $ el - > append Child ( $ output ) ; $ this - > ws Port Type - > append Child ( $ el ) ; } 
private function add Message ( $ name , $ type ) { $ el = $ this - > dom - > create Element ( "wsdl :message " ) ; $ el - > set Attribute ( 'name ' , $ name ) ; $ parts = $ this - > dom - > create Element ( "wsdl :part " ) ; $ parts - > set Attribute ( 'name ' , $ name ) ; $ parts - > set Attribute ( 'element ' , $ type ) ; $ el - > append Child ( $ parts ) ; 
private function create Ref Element ( $ ref ) { $ el = $ this - > dom - > create Element ( $ this - > xml Schema Preffix . ' :element ' ) ; $ el - > set Attribute ( 'ref ' , $ ref ) ; return $ el ; } 
private function create Element With Complex Type ( $ name , $ elements ) { 
private function create Simple Element ( $ name , $ type ) { $ el = $ this - > dom - > create Element ( $ this - > xml Schema Preffix . ' :element ' ) ; $ el - > set Attribute ( 'name ' , $ name ) ; if ( preg _match ( ' / : / ' , $ type ) ) { $ el - > set Attribute ( 'type ' , $ type ) ; } else { $ el - > set Attribute ( 'type ' , $ this - > xml Schema Preffix . ' : ' . $ type ) ; } return $ el ; } 
public function resolve Namespace ( $ short Ns ) { if ( ! ( $ this - > dom instanceof \ DOMDocument ) ) { throw new Runtime Exception ( "DOM is not initialized " ) ; } if ( ! is _array ( $ this - > namespaces ) ) { $ this - > namespaces = $ this - > get Doc Namespaces ( $ this - > dom ) ; } if ( array _key _exists ( $ short Ns , $ this - > namespaces ) ) { return $ this - > namespaces [ $ short Ns ] ; } else { return $ short Ns ; } } 
public function parse Doc Comments ( $ comments ) { $ comments = explode ( " \n " , $ comments ) ; $ comments Out = array ( ) ; $ params = array ( ) ; foreach ( $ comments as $ com ) { if ( preg _match ( ' / @ / ' , $ com ) ) { $ com = preg _replace ( ' / \ * / ' , ' ' , $ com ) ; $ com = preg _replace ( ' / @ ( [a -z A -Z ] * ) ( * ) ( . * ) / ' , ' $ 1 | $ 3 ' , $ com ) ; $ com = explode ( ' | ' , $ com ) ; 
public static function is Associate Array ( array $ arr ) { if ( ! empty ( $ arr ) ) { foreach ( $ arr as $ k = > $ v ) { if ( is _int ( $ k ) ) { return false ; } } return true ; } return false ; } 
public static function get Webhooks Event ( $ pay Load ) { Json Validator : : validate ( $ pay Load ) ; $ string _arry = json _decode ( $ pay Load , true ) ; $ obj = Reflection Util : : construct Object From Webhooks Array ( $ string _arry , Webhooks Service : : WEBHOOKSWRAPPERNAME ) ; return $ obj ; } 
public static function verify Payload ( $ token , $ payload , $ intuit Header Signature ) { $ verifier = new Token Verifier ( $ token ) ; return $ verifier - > verify Pay Load ( $ payload , $ intuit Header Signature ) ; } 
public static function reflect Array To Object ( $ class Name Or Key Name , $ data , $ throw Exception = TRUE ) { if ( ! isset ( $ class Name Or Key Name ) ) { throw new \ Exception ( "The Class Name or Key Name cannot be NULL when generating Objects . " ) ; } if ( ! isset ( $ data ) | | empty ( $ data ) ) { throw new \ Exception ( "The passed data cannot be NULL . " ) ; } if ( is _object ( $ data ) ) { if ( ! Facade Helper : : check If The Object Is An Instance Of The Class ( $ class Name Or Key Name , $ data ) ) { throw new \ Exception ( "The assigned object is not an instance of required object : { " . $ class Name Or Key Name . " } . " ) ; } else { return $ data ; } } 
private static function is Key In Complex List ( $ key , $ complex List = NULL ) { if ( isset ( $ complex List ) ) { $ Object Map = $ complex List ; } else { $ Object Map = Facade Class Mapper : : class Method To List ( ) ; } foreach ( $ Object Map as $ object Method Name = > $ entity Type ) { if ( in _array ( $ key , $ entity Type ) ) { return $ object Method Name ; } } return false ; } 
private static function set Key In Complex List ( $ object Method Name , $ target Object , $ key , $ val ) { $ reflection Class Of Target Object = new \ Reflection Class ( $ target Object ) ; $ set Object = Facade Helper : : get Complex List Object ( $ object Method Name , $ key , $ val ) ; $ property = $ reflection Class Of Target Object - > get Property ( $ key ) ; if ( $ property instanceof \ Reflection Property ) { $ property - > set Value ( $ target Object , $ set Object ) ; return true ; } else { throw new \ Exception ( "No Reflection Property Found . " ) ; } } 
private static function get Complex List Object ( $ object Method Name , $ key , $ val ) { 
public static function get Class Method ( $ class Name , $ method Name ) { try { $ helper Refelction Method = new \ Reflection Method ( $ class Name , $ method Name ) ; return $ helper Refelction Method ; } catch ( \ Exception $ e ) { return null ; } } 
public static function get IPPReference Type Based On Array ( $ data ) { $ trimed Data Array = Facade Helper : : trim Spaces For Array Keys ( $ data ) ; if ( is _object ( $ trimed Data Array ) ) { if ( $ trimed Data Array instanceof IPPReference Type ) { return $ trimed Data Array ; } else { throw new \ Exception ( "The assigned obj to IPPReference Type is not matched with IPPReference Type . " ) ; } } 
public static function get IPPId ( $ data ) { 
public static function merge Obj ( $ obj A , $ obj B ) { if ( get _class ( $ obj A ) ! = get _class ( $ obj B ) ) throw new \ Exception ( "Can 't assign object value to a different type . " ) ; $ property _fields = get _object _vars ( $ obj A ) ; foreach ( $ property _fields as $ property Name = > $ val ) { $ Bs Value = $ obj B - > $ property Name ; if ( isset ( $ Bs Value ) ) { $ obj A - > $ property Name = $ Bs Value ; } } return $ obj A ; } 
public static function trim Spaces For Array Keys ( $ data ) { if ( ! isset ( $ data ) | | empty ( $ data ) ) return $ data ; if ( is _array ( $ data ) ) { if ( Facade Helper : : is Array Of Obj ( $ data ) ) { return $ data ; } else { $ trimed Keys = array _map ( 'trim ' , array _keys ( $ data ) ) ; $ trimed Result = array _combine ( $ trimed Keys , $ data ) ; return $ trimed Result ; } } else { if ( is _object ( $ data ) ) { return $ data ; } else { return trim ( $ data ) ; } } } 
private function handle Errors ( ) { if ( $ this - > basec URL - > errno ( ) | | $ this - > basec URL - > error ( ) ) { $ error Msg = $ this - > basec URL - > error ( ) ; $ error Number = $ this - > basec URL - > errno ( ) ; throw new Sdk Exception ( "c URL error during making API call . c URL Error Number : [ " . $ error Number . " ] with error : [ " . $ error Msg . " ] " ) ; } } 
private function get Headers ( $ headers ) { if ( ! isset ( $ headers ) | | empty ( $ headers ) ) { throw new Sdk Exception ( "Error . The headers set for c URL are either NULL or Empty " ) ; } else { $ converted Headers = $ this - > convert Header Array To Headers ( $ headers ) ; return $ converted Headers ; } } 
private function set SSL ( & $ curl _opt , $ verify SSL ) { $ tls Version = $ this - > basec URL - > version Of TLS ( ) ; $ versions = [ 'TLS 1 . 2 ' , 'TLS 1 . 3 ' ] ; if ( ! in _array ( $ tls Version , $ versions ) ) { throw new Sdk Exception ( "Error . Checking TLS 1 . 2 / 1 . 3 version failed . Please make sure your PHP c URL supports TSL 1 . 2 / 1 . 3 " ) ; } if ( $ verify SSL ) { $ curl _opt [ CURLOPT _SSL _VERIFYPEER ] = true ; $ curl _opt [ CURLOPT _SSL _VERIFYHOST ] = 2 ; 
public function convert Header Array To Headers ( array $ header Array ) { $ headers = array ( ) ; foreach ( $ header Array as $ k = > $ v ) { $ headers [ ] = $ k . " : " . $ v ; } return $ headers ; } 
public function process ( ) : void { $ this - > parse ( ) ; $ this - > fixer - > start File ( $ this ) ; foreach ( $ this - > tokens as $ stack Ptr = > $ token ) { if ( isset ( $ this - > token Listeners [ $ token [ 'code ' ] ] ) = = = false ) { continue ; } foreach ( $ this - > token Listeners [ $ token [ 'code ' ] ] as $ sniff ) { if ( $ this - > skipper - > should Skip Checker And File ( $ sniff , $ this - > file Info ) ) { continue ; } $ this - > report Active Sniff Class ( $ sniff ) ; $ sniff - > process ( $ this , $ stack Ptr ) ; } } $ this - > fixed Count + = $ this - > fixer - > get Fix Count ( ) ; } 
public function add Fixable Error ( $ error , $ stack Ptr , $ code , $ data = [ ] , $ severity = 0 ) : bool { $ this - > applied Checkers Collector - > add File Info And Checker ( $ this - > file Info , $ this - > resolve Fully Qualified Code ( $ code ) ) ; return ! $ this - > should Skip Error ( $ error , $ code , $ data ) ; } 
public function add Error ( $ error , $ stack Ptr , $ code , $ data = [ ] , $ severity = 0 , $ fixable = false ) : bool { if ( $ this - > should Skip Error ( $ error , $ code , $ data ) ) { return false ; } return parent : : add Error ( $ error , $ stack Ptr , $ code , $ data , $ severity , $ fixable ) ; } 
public function add Warning ( $ warning , $ stack Ptr , $ code , $ data = [ ] , $ severity = 0 , $ fixable = false ) : bool { if ( ! $ this - > is Sniff Class Warning Allowed ( $ this - > active Sniff Class ) ) { return false ; } return $ this - > add Error ( $ warning , $ stack Ptr , $ code , $ data , $ severity , $ fixable ) ; } 
protected function add Message ( $ is Error , $ message , $ line , $ column , $ sniff Class Or Code , $ data , $ severity , $ is Fixable = false ) : bool { if ( ! $ is Error ) { 
protected function build ( Container Builder $ container Builder ) : void { 
private function file Matches Pattern ( Smart File Info $ smart File Info , string $ ignored Path ) : bool { $ ignored Path = $ this - > normalize For Fnmatch ( $ ignored Path ) ; return $ smart File Info - > ends With ( $ ignored Path ) | | $ smart File Info - > fnmatches ( $ ignored Path ) ; } 
public function resolve From Input ( Input Interface $ input ) : void { $ sources = $ input - > get Argument ( Option : : SOURCE ) ; $ this - > set Sources ( $ sources ) ; $ this - > is Fixer = ( bool ) $ input - > get Option ( Option : : FIX ) ; $ this - > should Clear Cache = ( bool ) $ input - > get Option ( Option : : CLEAR _CACHE ) ; $ this - > show Progress Bar = $ this - > can Show Progress Bar ( $ input ) ; $ this - > show Error Table = ! ( bool ) $ input - > get Option ( Option : : NO _ERROR _TABLE ) ; } 
public function change Configuration File ( string $ configuration File ) : void { $ this - > store Configuration Data Hash ( $ this - > file Hash Computer - > compute ( $ configuration File ) ) ; } 
public function create Container Builder And Config ( Container Builder $ container Builder , string $ config ) : Delegating Loader { $ file Locator = new Simple File Locator ( dirname ( $ config ) ) ; return $ this - > create From Container Builder And File Locator ( $ container Builder , $ file Locator ) ; } 
public function up ( ) { $ connection = config ( 'taggable .connection ' ) ; if ( ! Schema : : connection ( $ connection ) - > has Table ( 'taggable _tags ' ) ) { Schema : : connection ( $ connection ) - > create ( 'taggable _tags ' , function ( Blueprint $ table ) { $ table - > increments ( 'tag _id ' ) ; $ table - > string ( 'name ' ) ; $ table - > string ( 'normalized ' ) ; $ table - > timestamps ( ) ; $ table - > index ( 'normalized ' ) ; } ) ; } if ( ! Schema : : connection ( $ connection ) - > has Table ( 'taggable _taggables ' ) ) { Schema : : connection ( $ connection ) - > create ( 'taggable _taggables ' , function ( Blueprint $ table ) { $ table - > unsigned Integer ( 'tag _id ' ) ; $ table - > unsigned Integer ( 'taggable _id ' ) ; $ table - > string ( 'taggable _type ' ) ; $ table - > timestamps ( ) ; $ table - > index ( [ 'tag _id ' , 'taggable _id ' ] , 'i _taggable _fwd ' ) ; $ table - > index ( [ 'taggable _id ' , 'tag _id ' ] , 'i _taggable _rev ' ) ; $ table - > index ( 'taggable _type ' , 'i _taggable _type ' ) ; } ) ; } } 
public function down ( ) { $ connection = config ( 'taggable .connection ' ) ; if ( Schema : : connection ( $ connection ) - > has Table ( 'taggable _tags ' ) ) { Schema : : connection ( $ connection ) - > drop ( 'taggable _tags ' ) ; } if ( Schema : : connection ( $ connection ) - > has Table ( 'taggable _taggables ' ) ) { Schema : : connection ( $ connection ) - > drop ( 'taggable _taggables ' ) ; } } 
public function set Name Attribute ( $ value ) { $ value = trim ( $ value ) ; $ this - > attributes [ 'name ' ] = $ value ; $ this - > attributes [ 'normalized ' ] = app ( Tag Service : : class ) - > normalize ( $ value ) ; } 
public function scope By Name ( Builder $ query , string $ value ) : Builder { $ normalized = app ( Tag Service : : class ) - > normalize ( $ value ) ; return $ query - > where ( 'normalized ' , $ normalized ) ; } 
protected static function boot Taggable ( ) : void { static : : deleting ( function ( $ model ) { if ( ! method _exists ( $ model , 'run Soft Delete ' ) | | $ model - > is Force Deleting ( ) ) { $ model - > detag ( ) ; } } ) ; } 
public function tag ( $ tags ) : self { $ tags = app ( Tag Service : : class ) - > build Tag Array ( $ tags ) ; foreach ( $ tags as $ tag Name ) { $ this - > add One Tag ( $ tag Name ) ; $ this - > load ( 'tags ' ) ; } event ( new Model Tagged ( $ this , $ tags ) ) ; return $ this ; } 
public function untag ( $ tags ) : self { $ tags = app ( Tag Service : : class ) - > build Tag Array ( $ tags ) ; foreach ( $ tags as $ tag Name ) { $ this - > remove One Tag ( $ tag Name ) ; } event ( new Model Untagged ( $ this , $ tags ) ) ; return $ this - > load ( 'tags ' ) ; } 
protected function add One Tag ( string $ tag Name ) : void { $ tag = app ( Tag Service : : class ) - > find Or Create ( $ tag Name ) ; $ tag Key = $ tag - > get Key ( ) ; if ( ! $ this - > get Attribute ( 'tags ' ) - > contains ( $ tag Key ) ) { $ this - > tags ( ) - > attach ( $ tag Key ) ; } } 
protected function remove One Tag ( string $ tag Name ) : void { $ tag = app ( Tag Service : : class ) - > find ( $ tag Name ) ; if ( $ tag ) { $ this - > tags ( ) - > detach ( $ tag ) ; } } 
public function has Tag ( $ tag ) : bool { if ( $ tag instanceof Tag ) { $ normalized = $ tag - > get Attribute ( 'normalized ' ) ; } else { $ normalized = app ( Tag Service : : class ) - > normalize ( $ tag ) ; } return in _array ( $ normalized , $ this - > get Tag Array Normalized Attribute ( ) , true ) ; } 
public function scope With All Tags ( Builder $ query , $ tags ) : Builder { $ service = app ( Tag Service : : class ) ; $ normalized = $ service - > build Tag Array Normalized ( $ tags ) ; 
public function scope Is Tagged ( Builder $ query ) : Builder { $ alias = $ this - > taggable Create New Alias ( _ _FUNCTION _ _ ) ; return $ this - > prepare Table Join ( $ query , 'inner ' , $ alias ) ; } 
public function scope Without All Tags ( Builder $ query , $ tags , bool $ include Untagged = false ) : Builder { $ service = app ( Tag Service : : class ) ; $ normalized = $ service - > build Tag Array Normalized ( $ tags ) ; $ tag Keys = $ service - > get Tag Model Keys ( $ normalized ) ; $ tag Key List = implode ( ' , ' , $ tag Keys ) ; $ alias = $ this - > taggable Create New Alias ( _ _FUNCTION _ _ ) ; $ morph Tag Key Name = $ this - > get Qualified Related Pivot Key Name With Alias ( $ alias ) ; $ query = $ this - > prepare Table Join ( $ query , 'left ' , $ alias ) - > having Raw ( "COUNT (DISTINCT CASE WHEN ( { $morph Tag Key Name } IN ( { $tag Key List } ) ) THEN { $morph Tag Key Name } ELSE NULL END ) < ? " , [ count ( $ tag Keys ) ] ) ; if ( ! $ include Untagged ) { $ query - > having Raw ( "COUNT (DISTINCT { $morph Tag Key Name } ) > 0 " ) ; } return $ query ; } 
public function scope Is Not Tagged ( Builder $ query ) : Builder { $ alias = $ this - > taggable Create New Alias ( _ _FUNCTION _ _ ) ; $ morph Foreign Key Name = $ this - > get Qualified Foreign Pivot Key Name With Alias ( $ alias ) ; return $ this - > prepare Table Join ( $ query , 'left ' , $ alias ) - > having Raw ( "COUNT (DISTINCT { $morph Foreign Key Name } ) = 0 " ) ; } 
private function prepare Table Join ( Builder $ query , string $ join Type , string $ alias ) : Builder { $ morph Table = $ this - > tags ( ) - > get Table ( ) ; $ morph Table Alias = $ morph Table . ' _ ' . $ alias ; $ model Key Name = $ this - > get Qualified Key Name ( ) ; $ morph Foreign Key Name = $ this - > get Qualified Foreign Pivot Key Name With Alias ( $ alias ) ; $ morph Type Name = $ morph Table Alias . ' . ' . $ this - > tags ( ) - > get Morph Type ( ) ; $ morph Class = $ this - > tags ( ) - > get Morph Class ( ) ; $ closure = function ( Join Clause $ join ) use ( $ model Key Name , $ morph Foreign Key Name , $ morph Type Name , $ morph Class ) { $ join - > on ( $ model Key Name , $ morph Foreign Key Name ) - > where ( $ morph Type Name , $ morph Class ) ; } ; return $ query - > select ( $ this - > get Table ( ) . ' . * ' ) - > join ( $ morph Table . ' as ' . $ morph Table Alias , $ closure , null , null , $ join Type ) - > group By ( $ model Key Name ) ; } 
public static function rename Tag ( string $ old Tag , string $ new Tag ) : int { return app ( Tag Service : : class ) - > rename Tags ( $ old Tag , $ new Tag , static : : class ) ; } 
public static function popular Tags ( int $ limit = null , int $ min Count = 1 ) : array { $ tags = app ( Tag Service : : class ) - > get Popular Tags ( $ limit , static : : class , $ min Count ) ; return $ tags - > pluck ( 'taggable _count ' , 'name ' ) - > all ( ) ; } 
private function get Qualified Related Pivot Key Name With Alias ( string $ alias ) : string { $ morph = $ this - > tags ( ) ; return $ morph - > get Table ( ) . ' _ ' . $ alias . ' . ' . $ morph - > get Related Pivot Key Name ( ) ; } 
private function get Qualified Foreign Pivot Key Name With Alias ( string $ alias ) : string { $ morph = $ this - > tags ( ) ; return $ morph - > get Table ( ) . ' _ ' . $ alias . ' . ' . $ morph - > get Foreign Pivot Key Name ( ) ; } 
private function taggable Create New Alias ( string $ scope ) : string { $ this - > taggable Alias Sequence + + ; $ alias = strtolower ( $ scope ) . ' _ ' . $ this - > taggable Alias Sequence ; return $ alias ; } 
public function find Or Create ( string $ tag Name ) : Tag { $ tag = $ this - > find ( $ tag Name ) ; if ( ! $ tag ) { $ tag = $ this - > tag Model : : create ( [ 'name ' = > $ tag Name ] ) ; } return $ tag ; } 
public function build Tag Array ( $ tags ) : array { if ( is _array ( $ tags ) ) { $ array = $ tags ; } elseif ( $ tags instanceof Base Collection ) { $ array = $ this - > build Tag Array ( $ tags - > all ( ) ) ; } elseif ( is _string ( $ tags ) ) { $ array = preg _split ( ' # [ ' . preg _quote ( config ( 'taggable .delimiters ' ) , ' # ' ) . ' ] # ' , $ tags , null , PREG _SPLIT _NO _EMPTY ) ; } else { throw new \ Error Exception ( _ _CLASS _ _ . ' : : ' . _ _METHOD _ _ . ' expects parameter 1 to be string , array or Collection ; ' . gettype ( $ tags ) . ' given ' ) ; } return array _filter ( array _map ( 'trim ' , $ array ) ) ; } 
public function get Tag Model Keys ( array $ normalized = [ ] ) : array { if ( count ( $ normalized ) = = = 0 ) { return [ ] ; } return $ this - > tag Model : : where In ( 'normalized ' , $ normalized ) - > pluck ( 'tag _id ' ) - > to Array ( ) ; } 
public function make Tag List ( Model $ model , string $ field = 'name ' ) : string { $ tags = $ this - > make Tag Array ( $ model , $ field ) ; return $ this - > join List ( $ tags ) ; } 
public function make Tag Array ( Model $ model , string $ field = 'name ' ) : array { $ tags = $ model - > tags ; return $ tags - > pluck ( $ field ) - > all ( ) ; } 
public function get All Tags ( $ class = null ) : Collection { if ( $ class = = = null ) { return $ this - > tag Model : : all ( ) ; } if ( $ class instanceof Model ) { $ class = get _class ( $ class ) ; } $ tag Table = $ this - > get Qualified Tag Table Name ( ) ; $ pivot Table = $ this - > get Qualified Pivot Table Name ( $ class ) ; $ sql = "SELECT DISTINCT t . * FROM { $pivot Table } tt LEFT JOIN { $tag Table } t ON tt .tag _id =t .tag _id WHERE tt .taggable _type = ? " ; return $ this - > tag Model : : from Query ( $ sql , [ $ class ] ) ; } 
public function get All Unused Tags ( ) : Collection { $ tag Table = $ this - > get Qualified Tag Table Name ( ) ; $ pivot Table = $ this - > get Qualified Pivot Table Name ( ) ; $ sql = "SELECT t . * FROM { $tag Table } t LEFT JOIN { $pivot Table } tt ON tt .tag _id =t .tag _id WHERE tt .taggable _id IS NULL " ; return $ this - > tag Model : : from Query ( $ sql ) ; } 
public function get Popular Tags ( int $ limit = null , $ class = null , int $ min Count = 1 ) : Collection { $ tag Table = $ this - > get Qualified Tag Table Name ( ) ; $ pivot Table = $ this - > get Qualified Pivot Table Name ( ) ; $ sql = "SELECT t . * , COUNT (t .tag _id ) AS taggable _count FROM { $tag Table } t LEFT JOIN { $pivot Table } tt ON tt .tag _id =t .tag _id " ; $ bindings = [ ] ; if ( $ class ) { $ sql . = ' WHERE tt .taggable _type = ? ' ; $ bindings [ ] = ( $ class instanceof Model ) ? get _class ( $ class ) : $ class ; } 
public function rename Tags ( string $ old Name , string $ new Name , $ class = null ) : int { 
private function get Qualified Tag Table Name ( ) : string { $ tag = new $ this - > tag Model ; return $ tag - > get Connection ( ) - > get Table Prefix ( ) . $ tag - > get Table ( ) ; } 
private function get Qualified Pivot Table Name ( string $ class = null ) : string { $ instance = $ class ? new $ class : new class extends Model { use Taggable ; } ; return $ instance - > tags ( ) - > get Connection ( ) - > get Table Prefix ( ) . $ instance - > tags ( ) - > get Table ( ) ; } 
protected function save Compound Parameter Data ( array $ compound Data ) { foreach ( $ compound Data as $ name = > $ value ) { $ match Exists = false ; foreach ( $ this - > parameter Name Mapper as $ regex = > $ parameter Name ) { if ( preg _match ( $ regex , $ name , $ matches ) = = = 1 ) { $ parameter Last Index = ' ' ; if ( isset ( $ matches [ 1 ] ) ) { $ parameter Last Index = $ matches [ 1 ] ; } $ match Exists = true ; $ this - > parameters [ $ parameter Name . $ parameter Last Index ] = $ value ; break ; } } if ( ! $ match Exists ) { throw new \ Invalid Argument Exception ( "Unknown parameter $name for " . get _class ( $ this ) . ' data ' ) ; } } } 
public function build ( $ url , array $ single Parameters , array $ compound Parameters ) { $ singles Post = $ this - > get Single Parameters Payload ( $ single Parameters ) ; $ compounds Post = $ this - > get Compound Parameters Payload ( $ compound Parameters ) ; $ this - > payload Parameters = array _merge ( $ singles Post , $ compounds Post ) ; if ( ! empty ( $ this - > cache Buster ) ) { $ this - > payload Parameters [ 'z ' ] = $ this - > cache Buster ; } $ query = http _build _query ( $ this - > payload Parameters , null , ini _get ( 'arg _separator .output ' ) , PHP _QUERY _RFC 3 9 8 6 ) ; return $ url . ' ? ' . $ query ; } 
private function get Single Parameters Payload ( array $ single Parameters ) { $ post Data = [ ] ; $ cache Buster = new Cache Buster ( ) ; foreach ( $ single Parameters as $ parameter Obj ) { if ( $ parameter Obj - > get Name ( ) = = = $ cache Buster - > get Name ( ) ) { $ this - > cache Buster = $ parameter Obj - > get Value ( ) ; continue ; } $ post Data [ $ parameter Obj - > get Name ( ) ] = $ parameter Obj - > get Value ( ) ; } return $ post Data ; } 
private function get Compound Parameters Payload ( array $ compound Parameters ) { $ post Data = [ ] ; foreach ( $ compound Parameters as $ compound Collection ) { $ parameter Array = $ compound Collection - > get Parameters Array ( ) ; $ post Data = array _merge ( $ post Data , $ parameter Array ) ; } return $ post Data ; } 
protected function add Index ( $ string , $ index ) { if ( empty ( $ string ) ) { throw new Invalid Name Exception ( 'Name attribute not defined for class ' . get _class ( $ this ) ) ; } if ( strpos ( $ string , $ this - > index Placeholder ) ! = = false ) { if ( ! is _numeric ( $ index ) | | $ index < $ this - > min Index ( ) | | $ index > $ this - > max Index ( ) ) { throw new Invalid Index Exception ( 'When setting parameter ' . get _class ( $ this ) . ' a numeric index between 1 - 2 0 0 must be passed for the second argument ' ) ; } } return str _replace ( $ this - > index Placeholder , $ index , $ string ) ; } 
public function get Debug Response ( ) { $ debug Response = [ ] ; if ( ! empty ( $ this - > response Body ) ) { $ debug Response = json _decode ( $ this - > response Body , true ) ; $ debug Response = ( is _array ( $ debug Response ) ) ? $ debug Response : [ ] ; } return $ debug Response ; } 
protected function get Endpoint ( ) { return ( $ this - > is Debug ) ? $ this - > uri Scheme . $ this - > debug Endpoint : $ this - > uri Scheme . $ this - > endpoint ; } 
protected function send Hit ( $ method Name ) { $ hit Type = strtoupper ( substr ( $ method Name , 4 ) ) ; $ hit Constant = $ this - > get Parameter Class Constant ( 'The Iconic \Tracking \Google Analytics \Parameters \Hit \Hit Type : :HIT _TYPE _ ' . $ hit Type , 'Hit type ' . $ hit Type . ' is not defined , check spelling ' ) ; $ this - > set Hit Type ( $ hit Constant ) ; if ( ! $ this - > has Minimum Required Parameters ( ) ) { throw new Invalid Payload Data Exception ( ) ; } if ( $ this - > is Disabled ) { return new Null Analytics Response ( ) ; } return $ this - > get Http Client ( ) - > post ( $ this - > get Url ( ) , $ this - > get Http Client Options ( ) ) ; } 
protected function get Http Client Options ( ) { $ options = [ 'async ' = > $ this - > is Async Request ] ; if ( isset ( $ this - > options [ 'timeout ' ] ) ) { $ options [ 'timeout ' ] = $ this - > options [ 'timeout ' ] ; } return $ options ; } 
public function get Url ( ) { $ prepare Url = new Prepare Url ; return $ prepare Url - > build ( $ this - > get Endpoint ( ) , $ this - > single Parameters , $ this - > compound Parameters Collections ) ; } 
protected function has Minimum Required Parameters ( ) { $ minimum Required Parameters = [ 'v ' = > false , 'tid ' = > false , 'cid ' = > false , 'uid ' = > false , 't ' = > false , ] ; foreach ( $ minimum Required Parameters as $ parameter Name = > $ is Param Present ) { if ( array _key _exists ( $ parameter Name , $ this - > single Parameters ) ) { $ minimum Required Parameters [ $ parameter Name ] = true ; } } if ( ! $ minimum Required Parameters [ 'cid ' ] & & $ minimum Required Parameters [ 'uid ' ] ) { $ minimum Required Parameters [ 'cid ' ] = true ; } if ( ! $ minimum Required Parameters [ 'uid ' ] & & $ minimum Required Parameters [ 'cid ' ] ) { $ minimum Required Parameters [ 'uid ' ] = true ; } return ! in _array ( false , $ minimum Required Parameters , true ) ; } 
protected function set Parameter Action To ( $ parameter , $ action ) { $ action Constant = $ this - > get Parameter Class Constant ( 'The Iconic \Tracking \Google Analytics \Parameters \Enhanced Ecommerce \ \ ' . $ parameter . 'Action : :ACTION _ ' . strtoupper ( $ action ) , $ parameter . ' action ' . $ action . ' does not exist , check spelling ' ) ; $ function = 'set ' . $ parameter . 'Action ' ; $ this - > $ function ( $ action Constant ) ; return $ this ; } 
protected function set Parameter ( $ method Name , array $ method Arguments ) { $ parameter Class = substr ( $ method Name , 3 ) ; $ full Parameter Class = $ this - > get Full Parameter Class ( $ parameter Class , $ method Name ) ; $ parameter Index = $ this - > get Index From Arguments ( $ method Arguments ) ; $ parameter Object = new $ full Parameter Class ( $ parameter Index ) ; if ( ! isset ( $ method Arguments [ 0 ] ) ) { throw new \ Invalid Argument Exception ( 'For Analytics object , you must specify a value to be set for ' . $ method Name ) ; } else { $ parameter Object - > set Value ( $ method Arguments [ 0 ] ) ; } $ this - > single Parameters [ $ parameter Object - > get Name ( ) ] = $ parameter Object ; return $ this ; } 
protected function add Item ( $ method Name , array $ method Arguments ) { $ parameter Class = substr ( $ method Name , 3 ) ; $ full Parameter Class = $ this - > get Full Parameter Class ( $ parameter Class , $ method Name ) ; if ( ! isset ( $ method Arguments [ 0 ] ) ) { throw new \ Invalid Argument Exception ( 'You must specify a ' . $ parameter Class . ' to be add for ' . $ method Name ) ; } else { $ parameter Object = new $ full Parameter Class ( $ method Arguments [ 0 ] ) ; } $ collection Index = $ this - > get Index From Arguments ( $ method Arguments ) ; if ( isset ( $ this - > compound Parameters Collections [ $ parameter Class . $ collection Index ] ) ) { $ this - > compound Parameters Collections [ $ parameter Class . $ collection Index ] - > add ( $ parameter Object ) ; } else { $ full Parameter Collection Class = $ full Parameter Class . 'Collection ' ; $ parameter Object Collection = new $ full Parameter Collection Class ( $ collection Index ) ; $ parameter Object Collection - > add ( $ parameter Object ) ; $ this - > compound Parameters Collections [ $ parameter Class . $ collection Index ] = $ parameter Object Collection ; } return $ this ; } 
protected function get Parameter ( $ method Name , array $ method Arguments ) { $ parameter Class = substr ( $ method Name , 3 ) ; $ full Parameter Class = $ this - > get Full Parameter Class ( $ parameter Class , $ method Name ) ; 
protected function get Index From Arguments ( $ method Arguments ) { $ index = ' ' ; if ( isset ( $ method Arguments [ 1 ] ) & & is _numeric ( $ method Arguments [ 1 ] ) ) { $ index = $ method Arguments [ 1 ] ; } return $ index ; } 
protected function get Full Parameter Class ( $ parameter Class , $ method Name ) { if ( empty ( $ this - > available Parameters [ $ parameter Class ] ) ) { throw new \ Bad Method Call Exception ( 'Method ' . $ method Name . ' not defined for Analytics class ' ) ; } else { return ' \ \The Iconic \ \Tracking \ \Google Analytics \ \Parameters \ \ ' . $ this - > available Parameters [ $ parameter Class ] ; } } 
public function post ( $ url , array $ options = [ ] ) { $ request = new Request ( 'GET ' , $ url , [ 'User -Agent ' = > self : : PHP _GA _MEASUREMENT _PROTOCOL _USER _AGENT ] ) ; $ opts = $ this - > parse Options ( $ options ) ; $ response = $ this - > get Client ( ) - > send Async ( $ request , [ 'synchronous ' = > ! $ opts [ 'async ' ] , 'timeout ' = > $ opts [ 'timeout ' ] , 'connect _timeout ' = > $ opts [ 'timeout ' ] , ] ) ; if ( $ opts [ 'async ' ] ) { self : : $ promises [ ] = $ response ; } else { $ response = $ response - > wait ( ) ; } return $ this - > get Analytics Response ( $ request , $ response ) ; } 
private function parse Options ( array $ options ) { $ default Options = [ 'timeout ' = > static : : REQUEST _TIMEOUT _SECONDS , 'async ' = > false , ] ; $ opts = [ ] ; foreach ( $ default Options as $ option = > $ value ) { $ opts [ $ option ] = isset ( $ options [ $ option ] ) ? $ options [ $ option ] : $ default Options [ $ option ] ; } if ( ! is _int ( $ opts [ 'timeout ' ] ) | | $ opts [ 'timeout ' ] < = 0 ) { throw new \ Unexpected Value Exception ( 'The timeout must be an integer with a value greater than 0 ' ) ; } if ( ! is _bool ( $ opts [ 'async ' ] ) ) { throw new \ Unexpected Value Exception ( 'The async option must be boolean ' ) ; } return $ opts ; } 
public function get Readable Items ( ) { $ readables Items = [ ] ; foreach ( $ this - > items as $ key = > $ item ) { array _push ( $ readables Items , $ item - > get Readable Parameters ( ) ) ; } return $ readables Items ; } 
public function register ( ) { $ config Path = _ _DIR _ _ . ' / . . /config /report -generator .php ' ; $ this - > merge Config From ( $ config Path , 'report -generator ' ) ; $ this - > app - > bind ( 'pdf .report .generator ' , function ( $ app ) { return new Pdf Report ( $ app ) ; } ) ; $ this - > app - > bind ( 'excel .report .generator ' , function ( $ app ) { return new Excel Report ( $ app ) ; } ) ; $ this - > app - > bind ( 'csv .report .generator ' , function ( $ app ) { return new CSVReport ( $ app ) ; } ) ; $ this - > app - > register ( 'Maatwebsite \Excel \Excel Service Provider ' ) ; $ this - > register Aliases ( ) ; } 
public function add Supported Brand ( $ name , $ expression ) { $ known _brands = array _keys ( $ this - > supported _cards ) ; if ( in _array ( $ name , $ known _brands ) ) { return false ; } $ this - > supported _cards [ $ name ] = $ expression ; return true ; } 
protected function set Year Parameter ( $ key , $ value ) { 
public function validate ( ) { $ required Parameters = array ( 'number ' = > 'credit card number ' , 'expiry Month ' = > 'expiration month ' , 'expiry Year ' = > 'expiration year ' ) ; foreach ( $ required Parameters as $ key = > $ val ) { if ( ! $ this - > get Parameter ( $ key ) ) { throw new Invalid Credit Card Exception ( "The $val is required " ) ; } } if ( $ this - > get Expiry Date ( 'Ym ' ) < gmdate ( 'Ym ' ) ) { throw new Invalid Credit Card Exception ( 'Card has expired ' ) ; } if ( ! Helper : : validate Luhn ( $ this - > get Number ( ) ) ) { throw new Invalid Credit Card Exception ( 'Card number is invalid ' ) ; } if ( ! is _null ( $ this - > get Number ( ) ) & & ! preg _match ( ' / ^ \d { 1 2 , 1 9 } $ /i ' , $ this - > get Number ( ) ) ) { throw new Invalid Credit Card Exception ( 'Card number should have 1 2 to 1 9 digits ' ) ; } } 
public function get Number Masked ( $ mask = 'X ' ) { $ mask Length = strlen ( $ this - > get Number ( ) ) - 4 ; return str _repeat ( $ mask , $ mask Length ) . $ this - > get Number Last Four ( ) ; } 
public function get Brand ( ) { foreach ( $ this - > get Supported Brands ( ) as $ brand = > $ val ) { if ( preg _match ( $ val , $ this - > get Number ( ) ) ) { return $ brand ; } } } 
protected function get Track By Pattern ( $ pattern ) { if ( $ tracks = $ this - > get Tracks ( ) ) { if ( preg _match ( $ pattern , $ tracks , $ matches ) = = = 1 ) { return $ matches [ 0 ] ; } } } 
protected function list First Last Name ( $ full Name ) { $ names = explode ( ' ' , $ full Name , 2 ) ; return [ $ names [ 0 ] , isset ( $ names [ 1 ] ) ? $ names [ 1 ] : null ] ; } 
public function set Billing Name ( $ value ) { $ names = $ this - > list First Last Name ( $ value ) ; $ this - > set Billing First Name ( $ names [ 0 ] ) ; $ this - > set Billing Last Name ( $ names [ 1 ] ) ; return $ this ; } 
public function set Shipping Name ( $ value ) { $ names = $ this - > list First Last Name ( $ value ) ; $ this - > set Shipping First Name ( $ names [ 0 ] ) ; $ this - > set Shipping Last Name ( $ names [ 1 ] ) ; return $ this ; } 
public function get Birthday ( $ format = 'Y -m -d ' ) { $ value = $ this - > get Parameter ( 'birthday ' ) ; return $ value ? $ value - > format ( $ format ) : null ; } 
public function set Birthday ( $ value ) { if ( $ value ) { $ value = new Date Time ( $ value , new Date Time Zone ( 'UTC ' ) ) ; } else { $ value = null ; } return $ this - > set Parameter ( 'birthday ' , $ value ) ; } 
public function initialize ( array $ parameters = array ( ) ) { if ( null ! = = $ this - > response ) { throw new Runtime Exception ( 'Request cannot be modified after it has been sent ! ' ) ; } $ this - > parameters = new Parameter Bag ; Helper : : initialize ( $ this , $ parameters ) ; return $ this ; } 
protected function set Parameter ( $ key , $ value ) { if ( null ! = = $ this - > response ) { throw new Runtime Exception ( 'Request cannot be modified after it has been sent ! ' ) ; } return $ this - > trait Set Parameter ( $ key , $ value ) ; } 
public function set Card ( $ value ) { if ( $ value & & ! $ value instanceof Credit Card ) { $ value = new Credit Card ( $ value ) ; } return $ this - > set Parameter ( 'card ' , $ value ) ; } 
public function get Amount ( ) { $ money = $ this - > get Money ( ) ; if ( $ money ! = = null ) { $ money Formatter = new Decimal Money Formatter ( $ this - > get Currencies ( ) ) ; return $ money Formatter - > format ( $ money ) ; } } 
public function set Money ( Money $ value ) { $ currency = $ value - > get Currency ( ) - > get Code ( ) ; $ this - > set Currency ( $ currency ) ; return $ this - > set Parameter ( 'amount ' , $ value ) ; } 
public function set Currency ( $ value ) { if ( $ value ! = = null ) { $ value = strtoupper ( $ value ) ; } return $ this - > set Parameter ( 'currency ' , $ value ) ; } 
public function get Currency Numeric ( ) { if ( ! $ this - > get Currency ( ) ) { return null ; } $ currency = new Currency ( $ this - > get Currency ( ) ) ; if ( $ this - > get Currencies ( ) - > contains ( $ currency ) ) { return ( string ) $ this - > get Currencies ( ) - > numeric Code For ( $ currency ) ; } } 
public function get Currency Decimal Places ( ) { if ( $ this - > get Currency ( ) ) { $ currency = new Currency ( $ this - > get Currency ( ) ) ; if ( $ this - > get Currencies ( ) - > contains ( $ currency ) ) { return $ this - > get Currencies ( ) - > subunit For ( $ currency ) ; } } return 2 ; } 
public function format Currency ( $ amount ) { $ money = $ this - > get Money ( ( string ) $ amount ) ; $ formatter = new Decimal Money Formatter ( $ this - > get Currencies ( ) ) ; return $ formatter - > format ( $ money ) ; } 
public function replace ( array $ items = array ( ) ) { $ this - > items = array ( ) ; foreach ( $ items as $ item ) { $ this - > add ( $ item ) ; } } 
public function add ( $ item ) { if ( $ item instanceof Item Interface ) { $ this - > items [ ] = $ item ; } else { $ this - > items [ ] = new Item ( $ item ) ; } } 
protected function validate Redirect ( ) { if ( ! $ this instanceof Redirect Response Interface | | ! $ this - > is Redirect ( ) ) { throw new Runtime Exception ( 'This response does not support redirection . ' ) ; } if ( empty ( $ this - > get Redirect Url ( ) ) ) { throw new Runtime Exception ( 'The given redirect Url cannot be empty . ' ) ; } if ( ! in _array ( $ this - > get Redirect Method ( ) , [ 'GET ' , 'POST ' ] ) ) { throw new Runtime Exception ( 'Invalid redirect method " ' . $ this - > get Redirect Method ( ) . ' " . ' ) ; } } 
public static function camel Case ( $ str ) { $ str = self : : convert To Lowercase ( $ str ) ; return preg _replace _callback ( ' / _ ( [a -z ] ) / ' , function ( $ match ) { return strtoupper ( $ match [ 1 ] ) ; } , $ str ) ; } 
public static function validate Luhn ( $ number ) { $ str = ' ' ; foreach ( array _reverse ( str _split ( $ number ) ) as $ i = > $ c ) { $ str . = $ i % 2 ? $ c * 2 : $ c ; } return array _sum ( str _split ( $ str ) ) % 1 0 = = = 0 ; } 
public static function get Gateway Short Name ( $ class Name ) { if ( 0 = = = strpos ( $ class Name , ' \ \ ' ) ) { $ class Name = substr ( $ class Name , 1 ) ; } if ( 0 = = = strpos ( $ class Name , 'Omnipay \ \ ' ) ) { return trim ( str _replace ( ' \ \ ' , ' _ ' , substr ( $ class Name , 8 , - 7 ) ) , ' _ ' ) ; } return ' \ \ ' . $ class Name ; } 
public static function get Gateway Class Name ( $ short Name ) { if ( 0 = = = strpos ( $ short Name , ' \ \ ' ) ) { return $ short Name ; } 
public function get Data ( ) { $ this - > validate ( 'app _id ' , 'mch _id ' , 'out _trade _no ' , 'cert _path ' , 'key _path ' ) ; $ data = [ 'appid ' = > $ this - > get App Id ( ) , 'mch _id ' = > $ this - > get Mch Id ( ) , 'sub _appid ' = > $ this - > get Sub App Id ( ) , 'sub _mch _id ' = > $ this - > get Sub Mch Id ( ) , 'device _info ' = > $ this - > get Device Info ( ) , 
public function get Data ( ) { $ this - > validate ( 'app _id ' , 'mch _id ' , 'partner _trade _no ' , 'cert _path ' , 'key _path ' ) ; $ data = array ( 'mch _appid ' = > $ this - > get App Id ( ) , 'mchid ' = > $ this - > get Mch Id ( ) , 'device _info ' = > $ this - > get Device Info ( ) , 
public function send Data ( $ data ) { $ body = Helper : : array 2xml ( $ data ) ; $ client = new Client ( ) ; $ options = [ 'body ' = > $ body , 'verify ' = > true , 'cert ' = > $ this - > get Cert Path ( ) , 'ssl _key ' = > $ this - > get Key Path ( ) , ] ; $ response = $ client - > request ( 'POST ' , $ this - > endpoint , $ options ) - > get Body ( ) ; $ response Data = Helper : : xml 2array ( $ response ) ; return $ this - > response = new Promotion Transfer Response ( $ this , $ response Data ) ; } 
public function get Data ( ) { $ this - > validate ( 'app _id ' , 'mch _id ' ) ; $ query Id Empty = ! $ this - > get Transaction Id ( ) & & ! $ this - > get Out Trade No ( ) ; $ query Id Empty = ( $ query Id Empty & & ! $ this - > get Out Refund No ( ) & & ! $ this - > get Refund Id ( ) ) ; if ( $ query Id Empty ) { $ message = "The 'transaction _id ' or 'out _trade _no ' or 'out _refund _no ' or 'refund _id ' parameter is required " ; throw new Invalid Request Exception ( $ message ) ; } $ data = array ( 'appid ' = > $ this - > get App Id ( ) , 'mch _id ' = > $ this - > get Mch Id ( ) , 'sub _appid ' = > $ this - > get Sub App Id ( ) , 'sub _mch _id ' = > $ this - > get Sub Mch Id ( ) , 'device _info ' = > $ this - > get Device Info ( ) , 'transaction _id ' = > $ this - > get Transaction Id ( ) , 'out _trade _no ' = > $ this - > get Out Trade No ( ) , 'out _refund _no ' = > $ this - > get Out Refund No ( ) , 'refund _id ' = > $ this - > get Refund Id ( ) , 'nonce _str ' = > md 5 ( uniqid ( ) ) , ) ; $ data = array _filter ( $ data ) ; $ data [ 'sign ' ] = Helper : : sign ( $ data , $ this - > get Api Key ( ) ) ; return $ data ; } 
public function get Data ( ) { $ this - > validate ( 'app _id ' , 'mch _id ' , 'body ' , 'out _trade _no ' , 'total _fee ' , 'auth _code ' ) ; $ data = array ( 'appid ' = > $ this - > get App Id ( ) , 
public function get Data ( ) { $ this - > validate ( 'app _id ' , 'mch _id ' , 'body ' , 'out _trade _no ' , 'total _fee ' , 'notify _url ' , 'trade _type ' , 'spbill _create _ip ' ) ; $ trade Type = strtoupper ( $ this - > get Trade Type ( ) ) ; if ( $ trade Type = = 'JSAPI ' ) { $ this - > validate ( 'open _id ' ) ; } $ data = array ( 'appid ' = > $ this - > get App Id ( ) , 
public function get Data ( ) { $ this - > validate ( 'app _id ' , 'mch _id ' , 'bill _date ' ) ; $ data = array ( 'appid ' = > $ this - > get App Id ( ) , 'mch _id ' = > $ this - > get Mch Id ( ) , 'sub _appid ' = > $ this - > get Sub App Id ( ) , 'sub _mch _id ' = > $ this - > get Sub Mch Id ( ) , 'device _info ' = > $ this - > get Device Info ( ) , 'bill _date ' = > $ this - > get Bill Date ( ) , 'bill _type ' = > $ this - > get Bill Type ( ) , 
public function send Data ( $ data ) { $ response Data = $ this - > post ( $ this - > endpoint , $ data , 1 2 0 ) ; return $ this - > response = new Download Bill Response ( $ this , $ response Data ) ; } 
public function get Data ( ) { $ data = $ this - > get Request Params ( ) ; if ( is _string ( $ data ) ) { $ data = Helper : : xml 2array ( $ data ) ; } return $ data ; } 
public function send Data ( $ data ) { $ options = array ( CURLOPT _SSL _VERIFYPEER = > true , CURLOPT _SSL _VERIFYHOST = > 2 , CURLOPT _SSLCERTTYPE = > 'PEM ' , CURLOPT _SSLKEYTYPE = > 'PEM ' , CURLOPT _SSLCERT = > $ this - > get Cert Path ( ) , CURLOPT _SSLKEY = > $ this - > get Key Path ( ) , ) ; $ body = Helper : : array 2xml ( $ data ) ; $ request = $ this - > http Client - > request ( 'POST ' , $ this - > endpoint , $ options , $ body ) ; $ response = $ request - > get Body ( ) ; $ response Data = Helper : : xml 2array ( $ response ) ; return $ this - > response = new Query Transfer Response ( $ this , $ response Data ) ; } 
public function get Data ( ) { $ this - > validate ( 'app _id ' , 'mch _id ' , 'auth _code ' ) ; $ data = array ( 'appid ' = > $ this - > get App Id ( ) , 'mch _id ' = > $ this - > get Mch Id ( ) , 'sub _mch _id ' = > $ this - > get Sub Mch Id ( ) , 'auth _code ' = > $ this - > get Auth Code ( ) , 'nonce _str ' = > md 5 ( uniqid ( ) ) , ) ; $ data = array _filter ( $ data ) ; $ data [ 'sign ' ] = Helper : : sign ( $ data , $ this - > get Api Key ( ) ) ; return $ data ; } 
public function send Data ( $ data ) { $ request = $ this - > http Client - > request ( 'POST ' , $ this - > endpoint , [ ] , Helper : : array 2xml ( $ data ) ) ; $ response = $ request - > get Body ( ) ; $ response Data = Helper : : xml 2array ( $ response ) ; return $ this - > response = new Close Order Response ( $ this , $ response Data ) ; } 
protected function get Fixed Query Builder ( Query Builder $ query Builder ) { $ query Builder Id = clone $ query Builder ; $ root Alias = current ( $ query Builder Id - > get Root Aliases ( ) ) ; SELECT DISTINCT x FROM tab ORDER BY y ; For any particular x -value in the table there might be many different y values . Which one will you use to sort that x -value in the output ? * / $ query Id = $ query Builder Id - > get Query ( ) ; $ query Id - > set Hint ( Query : : HINT _CUSTOM _TREE _WALKERS , [ Order By To Select Walker : : class ] ) ; $ results = $ query Id - > execute ( [ ] , Query : : HYDRATE _ARRAY ) ; $ platform = $ query Builder Id - > get Entity Manager ( ) - > get Connection ( ) - > get Database Platform ( ) ; $ idx Matrix = [ ] ; foreach ( $ results as $ id ) { foreach ( $ id Names as $ id Name ) { 
private function get Model Name ( Container Builder $ container , $ name ) { if ( ' % ' = = = $ name [ 0 ] ) { return $ container - > get Parameter ( substr ( $ name , 1 , - 1 ) ) ; } return $ name ; } 
public function get Parent Metadata For Property ( $ base Class , $ property Full Name ) { $ name Elements = explode ( ' . ' , $ property Full Name ) ; $ last Property Name = array _pop ( $ name Elements ) ; $ class = $ base Class ; $ parent Association Mappings = [ ] ; foreach ( $ name Elements as $ name Element ) { $ metadata = $ this - > get Metadata ( $ class ) ; if ( isset ( $ metadata - > association Mappings [ $ name Element ] ) ) { $ parent Association Mappings [ ] = $ metadata - > association Mappings [ $ name Element ] ; $ class = $ metadata - > get Association Target Class ( $ name Element ) ; continue ; } break ; } $ properties = \ array _slice ( $ name Elements , \ count ( $ parent Association Mappings ) ) ; $ properties [ ] = $ last Property Name ; return [ $ this - > get Metadata ( $ class ) , implode ( ' . ' , $ properties ) , $ parent Association Mappings ] ; } 
public function get Entity Manager ( $ class ) { if ( \ is _object ( $ class ) ) { $ class = \ get _class ( $ class ) ; } if ( ! isset ( $ this - > cache [ $ class ] ) ) { $ em = $ this - > registry - > get Manager For Class ( $ class ) ; if ( ! $ em ) { throw new \ Runtime Exception ( sprintf ( 'No entity manager defined for class %s ' , $ class ) ) ; } $ this - > cache [ $ class ] = $ em ; } return $ this - > cache [ $ class ] ; } 
private function create Select Expression Item ( Path Expression $ path Expression ) { if ( Path Expression : : TYPE _SINGLE _VALUED _ASSOCIATION = = = $ path Expression - > type ) { $ identity = new Identity Function ( 'identity ' ) ; $ identity - > path Expression = clone $ path Expression ; return $ identity ; } return clone $ path Expression ; } 
private function get Operator ( $ type ) { $ choices = [ Number Type : : TYPE _EQUAL = > ' = ' , Number Type : : TYPE _GREATER _EQUAL = > ' > = ' , Number Type : : TYPE _GREATER _THAN = > ' > ' , Number Type : : TYPE _LESS _EQUAL = > ' < = ' , Number Type : : TYPE _LESS _THAN = > ' < ' , ] ; return $ choices [ $ type ] ? ? false ; } 
protected function get Pager ( $ pager Type ) { switch ( $ pager Type ) { case Pager : : TYPE _DEFAULT : return new Pager ( ) ; case Pager : : TYPE _SIMPLE : return new Simple Pager ( ) ; default : throw new \ Runtime Exception ( sprintf ( 'Unknown pager type " %s " . ' , $ pager Type ) ) ; } } 
public function get Config Tree Builder ( ) { $ tree Builder = new Tree Builder ( 'sonata _doctrine _orm _admin ' ) ; 
protected function handle Multiple ( Proxy Query Interface $ query Builder , $ alias , $ data ) { if ( 0 = = = \ count ( $ data [ 'value ' ] ) ) { return ; } $ parameter Name = $ this - > get New Parameter Name ( $ query Builder ) ; if ( isset ( $ data [ 'type ' ] ) & & Equal Type : : TYPE _IS _NOT _EQUAL = = = $ data [ 'type ' ] ) { $ this - > apply Where ( $ query Builder , $ query Builder - > expr ( ) - > not In ( $ alias , ' : ' . $ parameter Name ) ) ; } else { $ this - > apply Where ( $ query Builder , $ query Builder - > expr ( ) - > in ( $ alias , ' : ' . $ parameter Name ) ) ; } $ query Builder - > set Parameter ( $ parameter Name , $ data [ 'value ' ] ) ; } 
protected function handle Model ( Proxy Query Interface $ query Builder , $ alias , $ data ) { if ( empty ( $ data [ 'value ' ] ) ) { return ; } $ parameter Name = $ this - > get New Parameter Name ( $ query Builder ) ; if ( isset ( $ data [ 'type ' ] ) & & Equal Type : : TYPE _IS _NOT _EQUAL = = = $ data [ 'type ' ] ) { $ this - > apply Where ( $ query Builder , sprintf ( ' %s ! = : %s ' , $ alias , $ parameter Name ) ) ; } else { $ this - > apply Where ( $ query Builder , sprintf ( ' %s = : %s ' , $ alias , $ parameter Name ) ) ; } $ query Builder - > set Parameter ( $ parameter Name , $ data [ 'value ' ] ) ; } 
protected function get Parent Metadata For Property ( $ base Class , $ property Full Name , Model Manager Interface $ model Manager ) { try { return $ model Manager - > get Parent Metadata For Property ( $ base Class , $ property Full Name ) ; } catch ( Mapping Exception $ e ) { 
protected function handle Multiple ( Proxy Query Interface $ query Builder , $ alias , $ data ) { if ( 0 = = = \ count ( $ data [ 'value ' ] ) ) { return ; } $ parameter Name = $ this - > get New Parameter Name ( $ query Builder ) ; if ( isset ( $ data [ 'type ' ] ) & & Equal Type : : TYPE _IS _NOT _EQUAL = = = $ data [ 'type ' ] ) { $ or = $ query Builder - > expr ( ) - > or X ( ) ; $ or - > add ( $ query Builder - > expr ( ) - > not In ( $ alias , ' : ' . $ parameter Name ) ) ; if ( Class Metadata : : MANY _TO _MANY = = = $ this - > get Option ( 'mapping _type ' ) ) { $ or - > add ( sprintf ( ' %s . %s IS EMPTY ' , $ this - > get Parent Alias ( $ query Builder , $ alias ) , $ this - > get Field Name ( ) ) ) ; } else { $ or - > add ( $ query Builder - > expr ( ) - > is Null ( sprintf ( 'IDENTITY ( %s . %s ) ' , $ this - > get Parent Alias ( $ query Builder , $ alias ) , $ this - > get Field Name ( ) ) ) ) ; } $ this - > apply Where ( $ query Builder , $ or ) ; } else { $ this - > apply Where ( $ query Builder , $ query Builder - > expr ( ) - > in ( $ alias , ' : ' . $ parameter Name ) ) ; } $ query Builder - > set Parameter ( $ parameter Name , $ data [ 'value ' ] ) ; } 
private function get Parent Alias ( Proxy Query Interface $ query Builder , $ alias ) { $ parent Alias = $ root Alias = current ( $ query Builder - > get Root Aliases ( ) ) ; $ joins = $ query Builder - > get DQLPart ( 'join ' ) ; if ( isset ( $ joins [ $ root Alias ] ) ) { foreach ( $ joins [ $ root Alias ] as $ join ) { if ( $ join - > get Alias ( ) = = = $ alias ) { $ parts = explode ( ' . ' , $ join - > get Join ( ) ) ; $ parent Alias = $ parts [ 0 ] ; break ; } } } return $ parent Alias ; } 
private function get Operator ( $ type ) { $ choices = [ Equal Type : : TYPE _IS _EQUAL = > 'INSTANCE OF ' , Equal Type : : TYPE _IS _NOT _EQUAL = > 'NOT INSTANCE OF ' , ] ; return $ choices [ $ type ] ? ? false ; } 
private function get Operator ( $ type ) { $ choices = [ Choice Type : : TYPE _CONTAINS = > 'LIKE ' , Choice Type : : TYPE _NOT _CONTAINS = > 'NOT LIKE ' , Choice Type : : TYPE _EQUAL = > ' = ' , ] ; return $ choices [ $ type ] ? ? false ; } 
protected function _find By Name ( $ Context , $ realm ID , $ resource , $ name , $ xml = ' ' ) { $ IPP = $ Context - > IPP ( ) ; if ( $ IPP - > flavor ( ) = = Quick Books _IPP _IDS : : FLAVOR _DESKTOP ) { if ( ! $ xml ) { $ xml = ' ' ; $ xml . = ' < ?xml version = " 1 . 0 " encoding = "UTF - 8 " ? > ' . QUICKBOOKS _CRLF ; $ xml . = ' < ' . $ resource . 'Query xmlns :xsi = "http : / /www .w 3 .org / 2 0 0 1 /XMLSchema -instance " xmlns = "http : / /www .intuit .com /sb /cdm / ' . $ IPP - > version ( ) . ' " > ' . QUICKBOOKS _CRLF ; $ xml . = ' <First Last Inside > ' . Quick Books _XML : : encode ( $ name ) . ' < /First Last Inside > ' . QUICKBOOKS _CRLF ; $ xml . = ' < / ' . $ resource . 'Query > ' ; } } else { $ xml = http _build _query ( array ( 'Filter ' = > 'Name :EQUALS : ' . $ name ) ) ; } $ return = $ IPP - > IDS ( $ Context , $ realm ID , $ resource , Quick Books _IPP _IDS : : OPTYPE _QUERY , $ xml ) ; $ this - > _set Last Request Response ( $ Context - > last Request ( ) , $ Context - > last Response ( ) ) ; $ this - > _set Last Debug ( $ Context - > last Debug ( ) ) ; if ( count ( $ return ) ) { return $ return [ 0 ] ; } return null ; } 
protected function _add ( $ Context , $ realm ID , $ resource , $ Object ) { $ IPP = $ Context - > IPP ( ) ; switch ( $ IPP - > version ( ) ) { case Quick Books _IPP _IDS : : VERSION _ 2 : return $ this - > _add _v 2 ( $ Context , $ realm ID , $ resource , $ Object ) ; case Quick Books _IPP _IDS : : VERSION _ 3 : return $ this - > _add _v 3 ( $ Context , $ realm ID , $ resource , $ Object ) ; } } 
protected function _update ( $ Context , $ realm ID , $ resource , $ Object , $ ID ) { $ IPP = $ Context - > IPP ( ) ; switch ( $ IPP - > version ( ) ) { case Quick Books _IPP _IDS : : VERSION _ 2 : return $ this - > _update _v 2 ( $ Context , $ realm ID , $ resource , $ Object , $ ID ) ; case Quick Books _IPP _IDS : : VERSION _ 3 : return $ this - > _update _v 3 ( $ Context , $ realm ID , $ resource , $ Object , $ ID ) ; } return false ; } 
protected function _find By Id ( $ Context , $ realm ID , $ resource , $ IDType , $ xml _or _IDType = ' ' , $ query = null ) { $ IPP = $ Context - > IPP ( ) ; $ flavor = $ IPP - > flavor ( ) ; if ( ! $ xml _or _IDType ) { if ( $ flavor = = Quick Books _IPP _IDS : : FLAVOR _DESKTOP ) { $ parse = Quick Books _IPP _IDS : : parse IDType ( $ IDType ) ; $ xml _or _IDType = ' ' ; $ xml _or _IDType . = ' < ?xml version = " 1 . 0 " encoding = "UTF - 8 " ? > ' . QUICKBOOKS _CRLF ; $ xml _or _IDType . = ' < ' . $ resource . 'Query xmlns :xsi = "http : / /www .w 3 .org / 2 0 0 1 /XMLSchema -instance " xmlns = "http : / /www .intuit .com /sb /cdm / ' . $ IPP - > version ( ) . ' " > ' . QUICKBOOKS _CRLF ; if ( $ resource = = Quick Books _IPP _IDS : : RESOURCE _CUSTOMER ) { $ xml _or _IDType . = ' <Custom Field Enable >true < /Custom Field Enable > ' ; } if ( $ query ) { $ xml _or _IDType . = $ query ; } $ xml _or _IDType . = ' < ' . Quick Books _IPP _IDS : : resource To Key Type ( $ resource ) . 'Set > ' . QUICKBOOKS _CRLF ; $ xml _or _IDType . = ' <Id id Domain = " ' . $ parse [ 'domain ' ] . ' " > ' . $ parse [ 'ID ' ] . ' < /Id > ' . QUICKBOOKS _CRLF ; $ xml _or _IDType . = ' < / ' . Quick Books _IPP _IDS : : resource To Key Type ( $ resource ) . 'Set > ' . QUICKBOOKS _CRLF ; $ xml _or _IDType . = ' < / ' . $ resource . 'Query > ' ; } else if ( $ flavor = = Quick Books _IPP _IDS : : FLAVOR _ONLINE ) { $ xml _or _IDType = $ IDType ; } } $ return = $ IPP - > IDS ( $ Context , $ realm ID , $ resource , Quick Books _IPP _IDS : : OPTYPE _FINDBYID , $ xml _or _IDType ) ; $ this - > _set Last Request Response ( $ Context - > last Request ( ) , $ Context - > last Response ( ) ) ; $ this - > _set Last Debug ( $ Context - > last Debug ( ) ) ; if ( count ( $ return ) ) { return $ return [ 0 ] ; } return null ; } 
protected function _set Error ( $ errcode , $ errtext = ' ' , $ errdetail = ' ' ) { $ this - > _errcode = $ errcode ; $ this - > _errtext = $ errtext ; $ this - > _errdetail = $ errdetail ; } 
public function authenticate ( $ user , $ pass ) { $ req = new Quick Books _Request _Authenticate ( $ user , $ pass ) ; $ resp = parent : : _ _soap Call ( 'authenticate ' , array ( $ req ) ) ; $ tmp = current ( $ resp ) ; return current ( $ tmp ) ; } 
public function is Sales And Purchase ( $ enable = null ) { $ current = $ this - > _is _sales _and _purchase ; if ( ! is _null ( $ enable ) ) { $ this - > _is _sales _and _purchase = ( boolean ) $ enable ; } return $ current ; } 
public function is Sales Or Purchase ( $ enable = null ) { $ current = ! $ this - > _is _sales _and _purchase ; if ( ! is _null ( $ enable ) ) { $ this - > _is _sales _and _purchase = ! ( boolean ) $ enable ; } return $ current ; } 
public function set Parent Application ID ( $ id ) { return $ this - > set ( 'Parent Ref ' . QUICKBOOKS _API _APPLICATIONID , $ this - > encode Application ID ( QUICKBOOKS _OBJECT _CUSTOMER , QUICKBOOKS _LISTID , $ id ) ) ; } 
public function set Credit Card Info ( $ cardno , $ expmonth , $ expyear , $ name , $ address , $ postalcode ) { 
public function get Credit Card Info ( $ part = null , $ defaults = array ( ) ) { if ( ! is _null ( $ part ) ) { return $ this - > get ( 'Credit Card Info ' . $ part ) ; } return $ this - > get Array ( 'Credit Card Info * ' , $ defaults ) ; } 
public function add ( $ Context , $ realm ID , $ Object ) { return parent : : _add ( $ Context , $ realm ID , Quick Books _IPP _IDS : : RESOURCE _SALESRECEIPT , $ Object ) ; } 
public function find By Id ( $ Context , $ realm ID , $ IDType ) { $ xml = null ; return parent : : _find By Id ( $ Context , $ realm ID , Quick Books _IPP _IDS : : RESOURCE _CLASS , $ IDType , $ xml ) ; } 
public function add ( $ Context , $ realm ID , $ Object ) { return parent : : _add ( $ Context , $ realm ID , Quick Books _IPP _IDS : : RESOURCE _CLASS , $ Object ) ; } 
public function set Item Group Application ID ( $ value ) { return $ this - > set ( 'Item Group Ref ' . QUICKBOOKS _API _APPLICATIONID , $ this - > encode Application ID ( QUICKBOOKS _OBJECT _ITEMGROUP , QUICKBOOKS _LISTID , $ value ) ) ; } 
static protected function _guid ( $ surround = true ) { $ guid = sprintf ( ' % 0 4x % 0 4x - % 0 4x - % 0 3x 4 - % 0 4x - % 0 4x % 0 4x % 0 4x ' , mt _rand ( 0 , 6 5 5 3 5 ) , mt _rand ( 0 , 6 5 5 3 5 ) , mt _rand ( 0 , 6 5 5 3 5 ) , mt _rand ( 0 , 4 0 9 5 ) , bindec ( substr _replace ( sprintf ( ' % 0 1 6b ' , mt _rand ( 0 , 6 5 5 3 5 ) ) , ' 0 1 ' , 6 , 2 ) ) , mt _rand ( 0 , 6 5 5 3 5 ) , mt _rand ( 0 , 6 5 5 3 5 ) , mt _rand ( 0 , 6 5 5 3 5 ) ) ; if ( $ surround ) { $ guid = ' { ' . $ guid . ' } ' ; } return $ guid ; } 
public function find By Id ( $ Context , $ realm ID , $ ID ) { $ xml = null ; return parent : : _find By Id ( $ Context , $ realm ID , Quick Books _IPP _IDS : : RESOURCE _EMPLOYEE , $ ID , null , $ xml ) ; } 
static public function create ( $ dsn _or _conn , $ config = array ( ) , $ hooks = array ( ) , $ log _level = QUICKBOOKS _LOG _NORMAL ) { static $ instances = array ( ) ; if ( ! is _array ( $ hooks ) ) { $ hooks = array ( ) ; } static $static = 0 ; $static + + ; print ( 'Constructed new instance ' . $static . ' [ ' . $key . ' ] ' . " \n " ) ; mysql _query ( "INSERT INTO quickbooks _log ( msg , log _datetime ) VALUES ( 'Here is my " . $static . " key : " . $key . " ' , NOW ( ) ) " ) ; * / 
public function signature ( $ method , $ keyfile = null ) { $ this - > _signature = $ method ; $ this - > _keyfile = $ keyfile ; } 
public function sign ( $ method , $ url , $ oauth _token = null , $ oauth _token _secret = null , $ params = array ( ) ) { if ( ! is _array ( $ params ) ) { $ params = array ( ) ; } $ params = array _merge ( $ params , array ( 'oauth _consumer _key ' = > $ this - > _oauth _consumer _key , 'oauth _signature _method ' = > $ this - > _signature , 'oauth _nonce ' = > $ this - > _nonce ( ) , 'oauth _timestamp ' = > $ this - > _timestamp ( ) , 'oauth _version ' = > $ this - > _version , ) ) ; print ( ' <pre > ' ) ; print ( 'BASE STRING IS [ ' . $signature _and _basestring [ 0 ] . ' ] ' . " \n \n " ) ; print ( 'SIGNATURE IS : [ ' . $params [ 'oauth _signature ' ] . ' ] ' ) ; print ( ' < /pre > ' ) ; * / $ normalized = $ this - > _normalize ( $ params ) ; if ( false ! = = ( $ pos = strpos ( $ url , ' ? ' ) ) ) { $ url = substr ( $ url , 0 , $ pos ) ; } $ normalized _url = $ url . ' ? ' . $ normalized ; 
protected function _generate Signature _RSA ( $ sbs , $ method , $ url , $ params = array ( ) ) { print ( 'key id is : [ ' ) ; print _r ( $res ) ; print ( ' ] ' ) ; print ( " \n \n \n " ) ; * / $ signature = null ; $ retr = openssl _sign ( $ sbs , $ signature , $ res ) ; openssl _free _key ( $ res ) ; return array ( 0 = > $ sbs , 1 = > base 6 4 _encode ( $ signature ) , ) ; } 
protected function _generate Signature _HMAC ( $ sbs , $ method , $ url , $ params = array ( ) ) { $ secret = $ this - > _escape ( $ this - > _oauth _consumer _secret ) ; $ secret . = ' & ' ; if ( ! empty ( $ params [ 'oauth _secret ' ] ) ) { $ secret . = $ this - > _escape ( $ params [ 'oauth _secret ' ] ) ; } 
public function set Payee Entity Application ID ( $ value ) { return $ this - > set ( 'Payee Entity Ref ' . QUICKBOOKS _API _APPLICATIONID , $ this - > encode Application ID ( QUICKBOOKS _OBJECT _PAYEEENTITY , QUICKBOOKS _LISTID , $ value ) ) ; } 
public function handle Error 5 0 0 ( $ request ID , $ user , $ action , $ ID , $ extra , & $ err , $ xml , $ errnum , $ errmsg ) { mail ( 'your -email @your -domain .com ' , 'Quick Books error occured ! ' , 'The following error occured : ' . $ errnum . ' : ' . $ errmsg ) ; 
public function hook Login Success ( $ request ID , $ user , $ hook , & $ err , $ hook _data , $ callback _config ) { if ( $ this - > _dsn ) { Quick Books _Utilities : : log ( $ this - > _dsn , 'This user logged in and the user login hook was called : ' . $ user . ' , params : ' . print _r ( $ hook _data , true ) ) ; return true ; } return false ; } 
public function is Repeatable ( $ path ) { $ paths = $ this - > _is Repeatable Paths ( ) ; if ( isset ( $ paths [ $ path ] ) ) { return $ paths [ $ path ] ; } return false ; } 
public function exists ( $ path , $ case _doesnt _matter = true , $ is _end _element = false ) { $ ordered _paths = $ this - > _reorder Paths Paths ( ) ; if ( in _array ( $ path , $ ordered _paths ) ) { return true ; } else if ( $ case _doesnt _matter ) { foreach ( $ ordered _paths as $ ordered _path ) { if ( strtolower ( $ path ) = = strtolower ( $ ordered _path ) ) { return true ; } } } return false ; } 
public function reorder Paths ( $ unordered _paths , $ allow _application _id = true , $ allow _application _editsequence = true ) { $ ordered _paths = $ this - > _reorder Paths Paths ( ) ; $ tmp = array ( ) ; foreach ( $ ordered _paths as $ key = > $ path ) { if ( in _array ( $ path , $ unordered _paths ) ) { $ tmp [ $ key ] = $ path ; } } return array _merge ( $ tmp ) ; } 
static protected function _call Function ( $ function , & $ vars , & $ err , $ which = null ) { if ( ! function _exists ( $ function ) ) { $ err = 'Callback does not exist : [function ] ' . $ function . ' ( . . . ) ' ; return false ; } $ ret = call _user _func _array ( $ function , $ vars ) ; if ( ! is _null ( $ which ) ) { $ err = $ vars [ $ which ] ; } return $ ret ; } 
static protected function _call Object Method ( $ object _and _method , & $ vars , & $ err , $ which = null ) { $ object = current ( $ object _and _method ) ; $ method = next ( $ object _and _method ) ; if ( is _callable ( array ( $ object , $ method ) ) ) { $ ret = call _user _func _array ( array ( $ object , $ method ) , $ vars ) ; if ( ! is _null ( $ which ) ) { $ err = $ vars [ $ which ] ; } return $ ret ; } $ err = 'Object method does not exist : instance of ' . get _class ( $ object ) . ' - > ' . $ method . ' ( . . . ) ' ; return false ; } 
static protected function _call Static Method ( $ class _and _method , & $ vars , & $ err , $ which = null ) { $ tmp = explode ( ' : : ' , $ class _and _method ) ; $ class = current ( $ tmp ) ; $ method = next ( $ tmp ) ; if ( is _callable ( array ( $ class , $ method ) ) ) { $ ret = call _user _func _array ( array ( $ class , $ method ) , $ vars ) ; if ( ! is _null ( $ which ) ) { 
static protected function _type ( & $ callback , $ Driver = null , $ ticket = null ) { 
static public function call Hook ( $ Driver , & $ hooks , $ hook , $ request ID , $ user , $ ticket , & $ err , $ hook _data , $ callback _config = array ( ) ) { 
public function find By Id ( $ Context , $ realm , $ IDType , $ query = null ) { $ xml = null ; return parent : : _find By Id ( $ Context , $ realm , Quick Books _IPP _IDS : : RESOURCE _CUSTOMER , $ IDType , $ xml , $ query ) ; } 
public function find By Name ( $ Context , $ realm , $ name ) { $ xml = null ; return parent : : _find By Name ( $ Context , $ realm , Quick Books _IPP _IDS : : RESOURCE _CUSTOMER , $ name , $ xml ) ; } 
public function delete ( $ Context , $ realm , $ IDType ) { return parent : : _delete ( $ Context , $ realm , Quick Books _IPP _IDS : : RESOURCE _CUSTOMER , $ IDType ) ; } 
protected function _connect ( $ host , $ port , $ user , $ pass , $ db , $ new _link , $ client _flags ) { if ( $ port ) { $ this - > _conn = mysql _connect ( $ host . ' : ' . $ port , $ user , $ pass , $ new _link , $ client _flags ) or die ( 'host : ' . $ host . ' , user : ' . $ user . ' , pass : XXXX , mysql _error ( ) : ' . mysql _error ( ) ) ; } else { $ this - > _conn = mysql _connect ( $ host , $ user , $ pass , $ new _link , $ client _flags ) or die ( 'host : ' . $ host . ' , user : ' . $ user . ' , pass : XXXX , mysql _error ( ) : ' . mysql _error ( ) ) ; } static $connections = array ( ) ; $connections [ ] = $user . ' : ' . $pass . ' @ ' . $host . ' : ' . $port . ' / ' . $db ; mysql _query ( "INSERT INTO quickbooks _log ( msg , log _datetime ) VALUES ( 'My SQL connection # " . count ( $connections ) . " , " . print _r ( $connections , true ) . " ' , NOW ( ) ) " , $this - > _conn ) or die (mysql _error ( ) ) ; * / return $ tmp ; } 
protected function _query ( $ sql , & $ errnum , & $ errmsg , $ offset = 0 , $ limit = null ) { if ( $ limit ) { if ( $ offset ) { $ sql . = " LIMIT " . ( int ) $ offset . " , " . ( int ) $ limit ; } else { $ sql . = " LIMIT " . ( int ) $ limit ; } } else if ( $ offset ) { CREATE TABLE quickbooks _debug ( quickbooks _debug _id int ( 1 0 ) unsigned NOT NULL AUTO _INCREMENT , msg text NOT NULL , debug _datetime datetime NOT NULL , PRIMARY KEY (quickbooks _debug _id ) ) ENGINE =My ISAM * / mysql _query ( " INSERT INTO quickbooks _debug ( msg , debug _datetime ) VALUES ( ' " . $this - > _escape ( $sql ) . " ' , NOW ( ) ) " ) ; * / if ( ! $ res ) { $ errnum = mysql _errno ( $ this - > _conn ) ; $ errmsg = mysql _error ( $ this - > _conn ) ; 
protected function _map Table Name ( $ table ) { switch ( $ table ) { case QUICKBOOKS _DRIVER _SQL _LOGTABLE : return QUICKBOOKS _DRIVER _SQL _MYSQL _PREFIX . QUICKBOOKS _DRIVER _SQL _MYSQL _LOGTABLE ; case QUICKBOOKS _DRIVER _SQL _QUEUETABLE : return QUICKBOOKS _DRIVER _SQL _MYSQL _PREFIX . QUICKBOOKS _DRIVER _SQL _MYSQL _QUEUETABLE ; case QUICKBOOKS _DRIVER _SQL _RECURTABLE : return QUICKBOOKS _DRIVER _SQL _MYSQL _PREFIX . QUICKBOOKS _DRIVER _SQL _MYSQL _RECURTABLE ; case QUICKBOOKS _DRIVER _SQL _TICKETTABLE : return QUICKBOOKS _DRIVER _SQL _MYSQL _PREFIX . QUICKBOOKS _DRIVER _SQL _MYSQL _TICKETTABLE ; case QUICKBOOKS _DRIVER _SQL _USERTABLE : return QUICKBOOKS _DRIVER _SQL _MYSQL _PREFIX . QUICKBOOKS _DRIVER _SQL _MYSQL _USERTABLE ; case QUICKBOOKS _DRIVER _SQL _CONFIGTABLE : return QUICKBOOKS _DRIVER _SQL _MYSQL _PREFIX . QUICKBOOKS _DRIVER _SQL _MYSQL _CONFIGTABLE ; 
public function set Customer Application ID ( $ value ) { return $ this - > set ( 'Customer Ref ' . QUICKBOOKS _API _APPLICATIONID , $ this - > encode Application ID ( QUICKBOOKS _OBJECT _CUSTOMER , QUICKBOOKS _LISTID , $ value ) ) ; } 
public function set Class Application ID ( $ value ) { return $ this - > set ( 'Class Ref ' . QUICKBOOKS _API _APPLICATIONID , $ this - > encode Application ID ( QUICKBOOKS _OBJECT _CLASS , QUICKBOOKS _LISTID , $ value ) ) ; } 
public function get Ship Address ( $ part = null , $ defaults = array ( ) ) { if ( ! is _null ( $ part ) ) { return $ this - > get ( 'Ship Address ' . $ part ) ; } return $ this - > get Array ( 'Ship Address * ' , $ defaults ) ; } 
public function get Bill Address ( $ part = null , $ defaults = array ( ) ) { if ( ! is _null ( $ part ) ) { return $ this - > get ( 'Bill Address ' . $ part ) ; } return $ this - > get Array ( 'Bill Address * ' , $ defaults ) ; } 
public function set Ship Method Application ID ( $ value ) { return $ this - > set ( 'Ship Method Ref ' . QUICKBOOKS _API _APPLICATIONID , $ this - > encode Application ID ( QUICKBOOKS _OBJECT _SHIPMETHOD , QUICKBOOKS _LISTID , $ value ) ) ; } 
public function set Payment Method Application ID ( $ value ) { return $ this - > set ( 'Payment Method Ref ' . QUICKBOOKS _API _APPLICATIONID , $ this - > encode Application ID ( QUICKBOOKS _OBJECT _PAYMENTMETHOD , QUICKBOOKS _LISTID , $ value ) ) ; } 
protected function _connect ( $ host , $ port , $ user , $ pass , $ db , $ new _link , $ client _flags ) { $ this - > _conn = sqlite _open ( $ db ) or die ( 'db : ' . $ db . ' ' ) ; return true ; } 
protected function _query ( $ sql , & $ errnum , & $ errmsg , $ offset = 0 , $ limit = null ) { if ( $ limit and strtoupper ( substr ( trim ( $ sql ) , 0 , 6 ) ) = = 'SELECT ' ) { if ( $ offset ) { $ sql . = " LIMIT " . ( int ) $ offset . " , " . ( int ) $ limit ; } else { $ sql . = " LIMIT " . ( int ) $ limit ; } } else if ( $ offset and strtoupper ( substr ( trim ( $ sql ) , 0 , 6 ) ) = = 'SELECT ' ) { 
protected function _generate Field Schema ( $ name , $ def ) { switch ( $ def [ 0 ] ) { case QUICKBOOKS _DRIVER _SQL _SERIAL : $ sql = $ name . ' INTEGER PRIMARY KEY ' ; 
protected function _map Table Name ( $ table ) { switch ( $ table ) { case QUICKBOOKS _DRIVER _SQL _LOGTABLE : return QUICKBOOKS _DRIVER _SQL _SQLITE _PREFIX . QUICKBOOKS _DRIVER _SQL _SQLITE _LOGTABLE ; case QUICKBOOKS _DRIVER _SQL _QUEUETABLE : return QUICKBOOKS _DRIVER _SQL _SQLITE _PREFIX . QUICKBOOKS _DRIVER _SQL _SQLITE _QUEUETABLE ; case QUICKBOOKS _DRIVER _SQL _RECURTABLE : return QUICKBOOKS _DRIVER _SQL _SQLITE _PREFIX . QUICKBOOKS _DRIVER _SQL _SQLITE _RECURTABLE ; case QUICKBOOKS _DRIVER _SQL _TICKETTABLE : return QUICKBOOKS _DRIVER _SQL _SQLITE _PREFIX . QUICKBOOKS _DRIVER _SQL _SQLITE _TICKETTABLE ; case QUICKBOOKS _DRIVER _SQL _USERTABLE : return QUICKBOOKS _DRIVER _SQL _SQLITE _PREFIX . QUICKBOOKS _DRIVER _SQL _SQLITE _USERTABLE ; case QUICKBOOKS _DRIVER _SQL _CONFIGTABLE : return QUICKBOOKS _DRIVER _SQL _SQLITE _PREFIX . QUICKBOOKS _DRIVER _SQL _SQLITE _CONFIGTABLE ; case QUICKBOOKS _DRIVER _SQL _IDENTTABLE : return QUICKBOOKS _DRIVER _SQL _SQLITE _PREFIX . QUICKBOOKS _DRIVER _SQL _SQLITE _IDENTTABLE ; case QUICKBOOKS _DRIVER _SQL _NOTIFYTABLE : return QUICKBOOKS _DRIVER _SQL _SQLITE _PREFIX . QUICKBOOKS _DRIVER _SQL _SQLITE _NOTIFYTABLE ; case QUICKBOOKS _DRIVER _SQL _CONNECTIONTABLE : return QUICKBOOKS _DRIVER _SQL _SQLITE _PREFIX . QUICKBOOKS _DRIVER _SQL _SQLITE _CONNECTIONTABLE ; default : return QUICKBOOKS _DRIVER _SQL _SQLITE _PREFIX . $ table ; } } 
static public function create ( $ encrypt ) { $ class = 'Quick Books _Encryption _ ' . ucfirst ( strtolower ( $ encrypt ) ) ; $ file = ' /Quick Books /Encryption / ' . ucfirst ( strtolower ( $ encrypt ) ) . ' .php ' ; Quick Books _Loader : : load ( $ file ) ; return new $ class ( ) ; } 
public function add Child ( $ node , $ prepend = false ) { if ( $ prepend ) { array _unshift ( $ this - > _children , $ node ) ; } else { $ this - > _children [ ] = $ node ; } return true ; } 
protected function _get Child At Helper ( $ root , $ path ) { if ( false ! = = strpos ( $ path , ' ' ) and false = = = strpos ( $ path , ' / ' ) ) { $ path = str _replace ( ' ' , ' / ' , $ path ) ; } $ explode = explode ( ' / ' , $ path ) ; 
public function add Child At ( $ path , $ node , $ create = false ) { return $ this - > _add Child At Helper ( $ this , $ path , $ node , $ create ) ; } 
public function children ( $ pattern = null ) { if ( ! is _null ( $ pattern ) ) { $ list = array ( ) ; foreach ( $ this - > _children as $ Child ) { if ( $ this - > _fnmatch ( $ pattern , $ Child - > name ( ) ) ) { $ list [ ] = $ Child ; } } return $ list ; } return $ this - > _children ; } 
public function remove Attribute ( $ attr ) { if ( $ this - > attribute Exists ( $ attr ) ) { unset ( $ this - > _attributes [ $ attr ] ) ; return true ; } return false ; } 
public function _as XMLHelper ( $ node , $ tabs , $ empty , $ indent ) { $ xml = ' ' ; if ( $ node - > child Count ( ) ) { $ xml . = str _repeat ( $ indent , $ tabs ) . ' < ' . $ node - > name ( ) ; foreach ( $ node - > attributes ( ) as $ key = > $ value ) { 
public function as Array ( $ mode = Quick Books _XML : : ARRAY _NOATTRIBUTES ) { switch ( $ mode ) { case Quick Books _XML : : ARRAY _EXPANDATTRIBUTES : return $ this - > _as Array Expand Attributes Helper ( $ this ) ; case Quick Books _XML : : ARRAY _BRANCHED : return $ this - > _as Array Branched Helper ( $ this ) ; case Quick Books _XML : : ARRAY _PATHS : $ current = ' ' ; $ paths = array ( ) ; $ this - > _as Array Paths Helper ( $ this , $ current , $ paths ) ; return $ paths ; case Quick Books _XML : : ARRAY _NOATTRIBUTES : default : return $ this - > _as Array No Attributes Helper ( $ this ) ; } } 
protected function _as Array Paths Helper ( $ node , $ current , & $ paths ) { if ( $ node - > has Child Nodes ( ) ) { foreach ( $ node - > children ( ) as $ child ) { $ this - > _as Array Paths Helper ( $ child , $ current . ' ' . $ node - > name ( ) , $ paths ) ; } } else if ( $ node - > has Data ( ) ) { $ paths [ trim ( $ current . ' ' . $ node - > name ( ) ) ] = $ node - > data ( ) ; } } 
public function save XML ( $ path _or _resource , $ mode = 'wb ' , $ todo _for _empty _elements = Quick Books _XML : : XML _COMPRESS ) { $ xml = $ this - > as XML ( $ todo _for _empty _elements ) ; if ( is _resource ( $ path _or _resource ) ) { return fwrite ( $ path _or _resource , $ xml ) ; } $ fp = fopen ( $ path _or _resource , $ mode ) ; $ bytes = fwrite ( $ fp , $ xml ) ; fclose ( $ fp ) ; return $ bytes ; } 
public function save JSON ( $ path _or _resource , $ mode = 'wb ' ) { $ json = $ this - > _root - > as JSON ( ) ; if ( is _resource ( $ path _or _resource ) ) { return fwrite ( $ path _or _resource , $ json ) ; } $ fp = fopen ( $ path _or _resource , $ mode ) ; $ bytes = fwrite ( $ fp , $ json ) ; fclose ( $ fp ) ; return $ bytes ; } 
static protected function _cast Truncate ( $ value , $ length , $ with _abbrevs = true ) { 
static public function cast ( $ type _or _action , $ field , $ value , $ use _abbrevs = true , $ htmlspecialchars = true ) { $ type _or _action = strtolower ( $ type _or _action ) ; static $ files = array ( ) ; if ( ! count ( $ files ) ) { $ dh = opendir ( dirname ( _ _FILE _ _ ) . ' /QBXML /Schema /Object ' ) ; while ( false ! = = ( $ file = readdir ( $ dh ) ) ) { if ( $ file { 0 } = = ' . ' or substr ( $ file , - 6 , 6 ) ! = 'Rq .php ' ) { continue ; } $ files [ ] = $ file ; } sort ( $ files ) ; } $ types = array ( ) ; $ types 3 = array ( ) ; $ types 5 = array ( ) ; reset ( $ files ) ; foreach ( $ files as $ file ) { $ substr = substr ( $ file , 0 , - 4 ) ; $ substrlower = strtolower ( $ substr ) ; $ types [ $ substrlower ] = $ substr ; $ substr 3 = substr ( $ file , 0 , - 3 + - 3 ) ; $ substr 3lower = strtolower ( $ substr 3 ) ; $ substr 5 = substr ( $ file , 0 , - 3 + - 6 ) ; $ substr 5lower = strtolower ( $ substr 5 ) ; if ( ! isset ( $ types 3 [ $ substr 3lower ] ) ) { $ types 3 [ $ substr 3lower ] = $ substr ; } if ( ! isset ( $ types 5 [ $ substr 5lower ] ) ) { $ types 5 [ $ substr 5lower ] = $ substr ; } } $ class = null ; $ schema = null ; if ( isset ( $ types [ $ type _or _action ] ) ) { Quick Books _Loader : : load ( ' /Quick Books /QBXML /Schema /Object / ' . $ types [ $ type _or _action ] . ' .php ' ) ; $ class = 'Quick Books _QBXML _Schema _Object _ ' . $ types [ $ type _or _action ] ; $ schema = new $ class ( ) ; } else if ( isset ( $ types 3 [ $ type _or _action ] ) ) if ( $htmlspecialchars ) { $entities = array ( ' & ' = > ' &amp ; ' , ' < ' = > ' &lt ; ' , ' > ' = > ' &gt ; ' , ' " ' = > ' &quot ; ' , ) ; $value = str _replace (array _values ( $entities ) , array _keys ( $entities ) , $value ) ; $value = str _replace (array _keys ( $entities ) , array _values ( $entities ) , $value ) ; } * / if ( $ htmlspecialchars ) { 
static protected function _decode UTF 8 ( $ string ) { 
static public function parse DSN ( $ dsn , $ defaults = array ( ) , $ part = null ) { 
static public function mask ( $ message ) { $ masks = array ( ' <Session Ticket > ' , ' <Connection Ticket > ' , ' <Credit Card Number > ' , ' <Card Security Code > ' , ' <App ID > ' , ' <str Password > ' , ) ; foreach ( $ masks as $ key ) { if ( $ key { 0 } = = ' < ' ) { 
static public function log ( $ dsn , $ msg , $ lvl = QUICKBOOKS _LOG _NORMAL ) { $ Driver = Quick Books _Utilities : : driver Factory ( $ dsn ) ; 
static public function extract Request ID ( $ xml ) { $ look = array ( ) ; if ( false ! = = ( $ start = strpos ( $ xml , ' request ID = " ' ) ) and false ! = = ( $ end = strpos ( $ xml , ' " ' , $ start + 1 2 ) ) ) { return substr ( $ xml , $ start + 1 2 , $ end - $ start - 1 2 ) ; } return false ; } 
static public function parse Request ID ( $ request ID , & $ action , & $ ident ) { $ tmp = explode ( ' | ' , base 6 4 _decode ( $ request ID ) ) ; if ( count ( $ tmp ) = = 2 ) { $ action = $ tmp [ 0 ] ; $ ident = $ tmp [ 1 ] ; return true ; } $ action = null ; $ ident = null ; return false ; } 
static public function driver Factory ( $ dsn _or _conn , $ config = array ( ) , $ hooks = array ( ) , $ log _level = QUICKBOOKS _LOG _NORMAL ) { return Quick Books _Driver _Factory : : create ( $ dsn _or _conn , $ config , $ hooks , $ log _level ) ; } 
static public function interval To Seconds ( $ interval ) { if ( ( string ) ( int ) $ interval = = = ( string ) $ interval ) { 
static protected function _check CIDR ( $ remoteaddr , $ CIDR ) { $ remoteaddr _long = ip 2long ( $ remoteaddr ) ; list ( $ net , $ mask ) = split ( ' / ' , $ CIDR ) ; $ ip _net = ip 2long ( $ net ) ; $ ip _mask = ~ ( ( 1 < < ( 3 2 - $ mask ) ) - 1 ) ; $ remoteaddr _net = $ remoteaddr _long & $ ip _mask ; return $ remoteaddr _net = = $ ip _net ; } 
static public function check Remote Address ( $ remoteaddr , $ arr _allow , $ arr _deny ) { $ allowed = true ; if ( count ( $ arr _allow ) ) { 
static public function create User ( $ dsn , $ username , $ password , $ company _file = null , $ wait _before _next _update = null , $ min _run _every _n _seconds = null ) { $ driver = Quick Books _Utilities : : driver Factory ( $ dsn ) ; return $ driver - > auth Create ( $ username , $ password , $ company _file , $ wait _before _next _update , $ min _run _every _n _seconds ) ; } 
static public function disable User ( $ dsn , $ username ) { $ driver = Quick Books _Utilities : : driver Factory ( $ dsn ) ; return $ driver - > auth Disable ( $ username ) ; } 
static public function generate Unique Hash ( $ mixed 1 , $ mixed 2 = null , $ mixed 3 = null , $ mixed 4 = null , $ mixed 5 = null ) { return md 5 ( serialize ( $ mixed 1 ) . serialize ( $ mixed 2 ) . serialize ( $ mixed 3 ) . serialize ( $ mixed 4 ) . serialize ( $ mixed 5 ) ) ; } 
public static function create Mapping ( $ dsn , $ user , $ object _type , $ Txn ID _or _List ID , $ app _ID , $ editsequence = ' ' ) { $ Driver = Quick Books _Utilities : : driver Factory ( $ dsn ) ; return $ Driver - > ident Map ( $ user , $ object _type , $ app _ID , $ Txn ID _or _List ID , $ editsequence ) ; } 
public static function fetch Edit Sequence ( $ dsn , $ user , $ object _type , $ webapp _ID ) { return Quick Books _Utilities : : fetch Quick Books Edit Sequence ( $ dsn , $ user , $ object _type , $ webapp _ID ) ; } 
public static function has Quick Books ID ( $ dsn , $ user , $ object _type , $ app _ID ) { if ( Quick Books _Utilities : : fetch Quick Books ID ( $ dsn , $ user , $ object _type , $ app _ID ) ) { return true ; } return false ; } 
static public function initialize ( $ dsn , $ driver _options = array ( ) , $ init _options = array ( ) ) { $ Driver = Quick Books _Utilities : : driver Factory ( $ dsn , $ driver _options ) ; return $ Driver - > initialize ( $ init _options ) ; } 
static public function initialized ( $ dsn , $ driver _options = array ( ) ) { $ Driver = Quick Books _Utilities : : driver Factory ( $ dsn , $ driver _options ) ; return $ Driver - > initialized ( ) ; } 
static public function fnmatch ( $ pattern , $ str ) { if ( function _exists ( 'fnmatch ' ) ) { return fnmatch ( $ pattern , $ str , FNM _CASEFOLD ) ; } $ arr = array ( ' \ * ' = > ' . * ' , ' \ ? ' = > ' . ' ) ; return preg _match ( ' # ^ ' . strtr ( preg _quote ( $ pattern , ' # ' ) , $ arr ) . ' $ #i ' , $ str ) ; } 
static public function list Objects ( $ filter = null , $ return _keys = false , $ order _for _mapping = false ) { static $ cache = array ( ) ; $ crunch = $ filter . ' [ ' . $ return _keys . ' [ ' . $ order _for _mapping ; if ( isset ( $ cache [ $ crunch ] ) ) { return $ cache [ $ crunch ] ; } $ constants = array ( ) ; foreach ( get _defined _constants ( ) as $ constant = > $ value ) { if ( substr ( $ constant , 0 , strlen ( 'QUICKBOOKS _OBJECT _ ' ) ) = = 'QUICKBOOKS _OBJECT _ ' and substr _count ( $ constant , ' _ ' ) = = 2 ) { if ( ! $ return _keys ) { $ constant = $ value ; } if ( $ filter ) { if ( Quick Books _Utilities : : fnmatch ( $ filter , $ constant ) ) { $ constants [ ] = $ constant ; } } else { $ constants [ ] = $ constant ; } } } if ( $ order _for _mapping ) { 
static public function action To Object ( $ action ) { static $ cache = array ( ) ; if ( isset ( $ cache [ $ action ] ) ) { 
static public function GUID ( ) { $ guid = sprintf ( ' % 0 4x % 0 4x - % 0 4x - % 0 3x 4 - % 0 4x - % 0 4x % 0 4x % 0 4x ' , mt _rand ( 0 , 6 5 5 3 5 ) , mt _rand ( 0 , 6 5 5 3 5 ) , mt _rand ( 0 , 6 5 5 3 5 ) , mt _rand ( 0 , 4 0 9 5 ) , bindec ( substr _replace ( sprintf ( ' % 0 1 6b ' , mt _rand ( 0 , 6 5 5 3 5 ) ) , ' 0 1 ' , 6 , 2 ) ) , mt _rand ( 0 , 6 5 5 3 5 ) , mt _rand ( 0 , 6 5 5 3 5 ) , mt _rand ( 0 , 6 5 5 3 5 ) ) ; return $ guid ; } 
static public function priority For Action ( $ action , $ dependency = null ) { 
static public function list Actions ( $ filter = null , $ return _keys = false ) { $ startswith = array ( 'QUICKBOOKS _IMPORT _ ' , 'QUICKBOOKS _QUERY _ ' , 'QUICKBOOKS _ADD _ ' , 'QUICKBOOKS _MOD _ ' , 'QUICKBOOKS _DEL _ ' , 'QUICKBOOKS _VOID _ ' , ) ; $ constants = array ( ) ; if (is _null ( $filter ) ) { if ( $return _keys ) { $constants [ ] = $inter _key ; } else { $constants [ ] = $inter _val ; } } * / foreach ( get _defined _constants ( ) as $ constant = > $ value ) { foreach ( $ startswith as $ start ) { if ( substr ( $ constant , 0 , strlen ( $ start ) ) = = $ start ) { if ( ! $ return _keys ) { $ constant = $ value ; } if ( ! is _null ( $ filter ) ) { if ( Quick Books _Utilities : : fnmatch ( $ filter , $ constant ) ) { $ constants [ ] = $ constant ; } } else { $ constants [ ] = $ constant ; } } } } sort ( $ constants ) ; return $ constants ; } 
static public function key For Object ( $ object ) { 
protected function _connect ( $ host , $ port , $ user , $ pass , $ db , $ new _link , $ client _flags ) { if ( $ port ) { $ this - > _conn = new mysqli ( $ host , $ user , $ pass , $ db , $ port ) or die ( 'host : ' . $ host . ' , user : ' . $ user . ' , pass : ' . $ pass . ' mysqli _error ( ) : ' . mysqli _connect _error ( ) ) ; } else { $ this - > _conn = new mysqli ( $ host , $ user , $ pass , $ db ) or die ( 'host : ' . $ host . ' , user : ' . $ user . ' , pass : ' . $ pass . ' mysqli _error ( ) : ' . mysqli _connect _error ( ) ) ; } return true ; } 
protected function _query ( $ sql , & $ errnum , & $ errmsg , $ offset = 0 , $ limit = null ) { if ( $ limit ) { if ( $ offset ) { $ sql . = " LIMIT " . ( int ) $ offset . " , " . ( int ) $ limit ; } else { $ sql . = " LIMIT " . ( int ) $ limit ; } } else if ( $ offset ) { 
protected function _escape ( $ str ) { if ( is _array ( $ str ) ) { error _log ( 'Param passed to _escape ( $str ) was an array : ' . print _r ( $ str , true ) ) ; $ str = ' ' ; } return $ this - > _conn - > real _escape _string ( $ str ) ; } 
protected function _map Table Name ( $ table ) { switch ( $ table ) { case QUICKBOOKS _DRIVER _SQL _LOGTABLE : return QUICKBOOKS _DRIVER _SQL _MYSQLI _PREFIX . QUICKBOOKS _DRIVER _SQL _MYSQLI _LOGTABLE ; case QUICKBOOKS _DRIVER _SQL _QUEUETABLE : return QUICKBOOKS _DRIVER _SQL _MYSQLI _PREFIX . QUICKBOOKS _DRIVER _SQL _MYSQLI _QUEUETABLE ; case QUICKBOOKS _DRIVER _SQL _RECURTABLE : return QUICKBOOKS _DRIVER _SQL _MYSQLI _PREFIX . QUICKBOOKS _DRIVER _SQL _MYSQLI _RECURTABLE ; case QUICKBOOKS _DRIVER _SQL _TICKETTABLE : return QUICKBOOKS _DRIVER _SQL _MYSQLI _PREFIX . QUICKBOOKS _DRIVER _SQL _MYSQLI _TICKETTABLE ; case QUICKBOOKS _DRIVER _SQL _USERTABLE : return QUICKBOOKS _DRIVER _SQL _MYSQLI _PREFIX . QUICKBOOKS _DRIVER _SQL _MYSQLI _USERTABLE ; case QUICKBOOKS _DRIVER _SQL _CONFIGTABLE : return QUICKBOOKS _DRIVER _SQL _MYSQLI _PREFIX . QUICKBOOKS _DRIVER _SQL _MYSQLI _CONFIGTABLE ; case QUICKBOOKS _DRIVER _SQL _IDENTTABLE : return QUICKBOOKS _DRIVER _SQL _MYSQLI _PREFIX . QUICKBOOKS _DRIVER _SQL _MYSQLI _IDENTTABLE ; case QUICKBOOKS _DRIVER _SQL _NOTIFYTABLE : return QUICKBOOKS _DRIVER _SQL _MYSQLI _PREFIX . QUICKBOOKS _DRIVER _SQL _MYSQLI _NOTIFYTABLE ; case QUICKBOOKS _DRIVER _SQL _CONNECTIONTABLE : return QUICKBOOKS _DRIVER _SQL _MYSQLI _PREFIX . QUICKBOOKS _DRIVER _SQL _MYSQLI _CONNECTIONTABLE ; default : return QUICKBOOKS _DRIVER _SQL _MYSQLI _PREFIX . $ table ; } } 
public function set Deposit To Account Application ID ( $ value ) { return $ this - > set ( 'Deposit To Account Ref ' . QUICKBOOKS _API _APPLICATIONID , $ this - > encode Application ID ( QUICKBOOKS _OBJECT _ACCOUNT , QUICKBOOKS _LISTID , $ value ) ) ; } 
public function config ( ) { $ name = 'Code Igniter Quick Books Demo ' ; 
public function qbwc ( ) { $ user = $ this - > config - > item ( 'quickbooks _user ' ) ; $ pass = $ this - > config - > item ( 'quickbooks _pass ' ) ; 
public function _add Customer Request ( $ request ID , $ user , $ action , $ ID , $ extra , & $ err , $ last _action _time , $ last _actionident _time , $ version , $ locale ) { < ?qbxml version = " 2 . 0 " ? > <QBXML > <QBXMLMsgs Rq on Error = "stop On Error " > <Customer Add Rq request ID = " ' . $ request ID . ' " > <Customer Add > <Name >Consoli BYTE , LLC ( ' . mt _rand ( ) . ' ) < /Name > <Company Name >Consoli BYTE , LLC < /Company Name > <First Name >Keith < /First Name > <Last Name >Palmer < /Last Name > <Bill Address > <Addr 1 >Consoli BYTE , LLC < /Addr 1 > <Addr 2 > 1 3 4 Stonemill Road < /Addr 2 > <City >Mansfield < /City > <State >CT < /State > <Postal Code > 0 6 2 6 8 < /Postal Code > <Country >United States < /Country > < /Bill Address > <Phone > 8 6 0 - 6 3 4 - 1 6 0 2 < /Phone > <Alt Phone > 8 6 0 - 4 2 9 - 0 0 2 1 < /Alt Phone > <Fax > 8 6 0 - 4 2 9 - 5 1 8 3 < /Fax > <Email >Keith @Consoli BYTE .com < /Email > <Contact >Keith Palmer < /Contact > < /Customer Add > < /Customer Add Rq > < /QBXMLMsgs Rq > < /QBXML > ' ; return $ xml ; } 
public function _add Customer Response ( $ request ID , $ user , $ action , $ ID , $ extra , & $ err , $ last _action _time , $ last _actionident _time , $ xml , $ idents ) { 
public function _catchall Errors ( $ request ID , $ user , $ action , $ ID , $ extra , & $ err , $ xml , $ errnum , $ errmsg ) { return false ; } 
protected function _connect ( $ host , $ port , $ user , $ pass , $ db , $ new _link , $ client _flags ) { try { $ this - > _conn = new SQLite 3 ( $ db ) ; } catch ( \ Exception $ ex ) { die ( 'db : ' . $ db . 'ex : ' . $ ex - > get Message ( ) ) ; } return true ; } 
protected function _query ( $ sql , & $ errnum , & $ errmsg , $ offset = 0 , $ limit = null ) { if ( $ limit and strtoupper ( substr ( trim ( $ sql ) , 0 , 6 ) ) = = 'SELECT ' ) { if ( $ offset ) { $ sql . = " LIMIT " . ( int ) $ offset . " , " . ( int ) $ limit ; } else { $ sql . = " LIMIT " . ( int ) $ limit ; } } else if ( $ offset and strtoupper ( substr ( trim ( $ sql ) , 0 , 6 ) ) = = 'SELECT ' ) { 
protected function _map Table Name ( $ table ) { switch ( $ table ) { case QUICKBOOKS _DRIVER _SQL _LOGTABLE : return QUICKBOOKS _DRIVER _SQL _SQLITE 3 _PREFIX . QUICKBOOKS _DRIVER _SQL _SQLITE 3 _LOGTABLE ; case QUICKBOOKS _DRIVER _SQL _QUEUETABLE : return QUICKBOOKS _DRIVER _SQL _SQLITE 3 _PREFIX . QUICKBOOKS _DRIVER _SQL _SQLITE 3 _QUEUETABLE ; case QUICKBOOKS _DRIVER _SQL _RECURTABLE : return QUICKBOOKS _DRIVER _SQL _SQLITE 3 _PREFIX . QUICKBOOKS _DRIVER _SQL _SQLITE 3 _RECURTABLE ; case QUICKBOOKS _DRIVER _SQL _TICKETTABLE : return QUICKBOOKS _DRIVER _SQL _SQLITE 3 _PREFIX . QUICKBOOKS _DRIVER _SQL _SQLITE 3 _TICKETTABLE ; case QUICKBOOKS _DRIVER _SQL _USERTABLE : return QUICKBOOKS _DRIVER _SQL _SQLITE 3 _PREFIX . QUICKBOOKS _DRIVER _SQL _SQLITE 3 _USERTABLE ; case QUICKBOOKS _DRIVER _SQL _CONFIGTABLE : return QUICKBOOKS _DRIVER _SQL _SQLITE 3 _PREFIX . QUICKBOOKS _DRIVER _SQL _SQLITE 3 _CONFIGTABLE ; case QUICKBOOKS _DRIVER _SQL _IDENTTABLE : return QUICKBOOKS _DRIVER _SQL _SQLITE 3 _PREFIX . QUICKBOOKS _DRIVER _SQL _SQLITE 3 _IDENTTABLE ; case QUICKBOOKS _DRIVER _SQL _NOTIFYTABLE : return QUICKBOOKS _DRIVER _SQL _SQLITE 3 _PREFIX . QUICKBOOKS _DRIVER _SQL _SQLITE 3 _NOTIFYTABLE ; case QUICKBOOKS _DRIVER _SQL _CONNECTIONTABLE : return QUICKBOOKS _DRIVER _SQL _SQLITE 3 _PREFIX . QUICKBOOKS _DRIVER _SQL _SQLITE 3 _CONNECTIONTABLE ; default : return QUICKBOOKS _DRIVER _SQL _SQLITE 3 _PREFIX . $ table ; } } 
abstract public function _ _construct ( $ dsn , $ config ) ; final public function register Hooks ( $ hooks ) { if ( ! is _array ( $ hooks ) ) { $ hooks = array ( ) ; } foreach ( $ hooks as $ hook = > $ funcs ) { if ( ! is _array ( $ funcs ) ) { $ funcs = array ( $ funcs ) ; } $ this - > _hooks [ $ hook ] = $ funcs ; } } 
final public function queue Enqueue ( $ user , $ action , $ ident , $ replace = true , $ priority = 0 , $ extra = null , $ qbxml = null ) { if ( ! strlen ( $ ident ) ) { 
final public function queue Dequeue ( $ user , $ by _priority = false ) { $ hookdata = array ( 'username ' = > $ user , ) ; $ hookerr = ' ' ; $ this - > _call Hook ( QUICKBOOKS _DRIVER _HOOK _AUTHRESOLVE , null , $ hookerr , $ hookdata ) ; return $ this - > _queue Dequeue ( $ user , $ by _priority ) ; } 
final public function queue Processing ( $ user ) { $ hookdata = array ( 'username ' = > $ user , ) ; $ hookerr = ' ' ; $ this - > _call Hook ( QUICKBOOKS _DRIVER _HOOK _QUEUEPROCESSING , null , $ hookerr , $ hookdata ) ; return $ this - > _queue Processing ( $ user ) ; } 
final public function recur Enqueue ( $ user , $ run _every , $ action , $ ident , $ replace = true , $ priority = 0 , $ extra = null , $ qbxml = null ) { $ hookdata = array ( 'username ' = > $ user , 'interval ' = > $ run _every , 'action ' = > $ action , 'ident ' = > $ ident , 'replace ' = > $ replace , 'priority ' = > $ priority , 'extra ' = > $ extra , 'qbxml ' = > $ qbxml , ) ; $ hookerr = ' ' ; $ this - > _call Hook ( QUICKBOOKS _DRIVER _HOOK _AUTHRESOLVE , null , $ hookerr , $ hookdata ) ; return $ this - > _recur Enqueue ( $ user , $ run _every , $ action , $ ident , $ replace , $ priority , $ extra , $ qbxml ) ; } 
final public function recur Dequeue ( $ user , $ by _priority = false ) { $ hookdata = array ( 'username ' = > $ user , ) ; $ hookerr = ' ' ; $ this - > _call Hook ( QUICKBOOKS _DRIVER _HOOK _AUTHRESOLVE , null , $ hookerr , $ hookdata ) ; return $ this - > _recur Dequeue ( $ user , $ by _priority ) ; } 
final public function queue Remove ( $ user , $ action , $ ident ) { $ hookdata = array ( 'username ' = > $ user , 'action ' = > $ action , 'ident ' = > $ ident ) ; $ hookerr = ' ' ; $ this - > _call Hook ( QUICKBOOKS _DRIVER _HOOK _QUEUEREMOVE , null , $ hookerr , $ hookdata ) ; return $ this - > _queue Remove ( $ user , $ action , $ ident ) ; } 
final public function queue Status ( $ ticket , $ request ID , $ new _status , $ msg = ' ' ) { $ user = $ this - > _auth Resolve ( $ ticket ) ; $ hookdata = array ( 'username ' = > $ user , 
final public function queue Left ( $ user , $ queued = true ) { $ hookdata = array ( 'username ' = > $ user , 'queued ' = > $ queued , ) ; $ hookerr = ' ' ; $ this - > _call Hook ( QUICKBOOKS _DRIVER _HOOK _QUEUELEFT , null , $ hookerr , $ hookdata ) ; return $ this - > _queue Left ( $ user , $ queued ) ; } 
final public function queue Report ( $ user , $ date _from , $ date _to , $ offset = 0 , $ limit = null ) { $ offset = max ( 0 , ( int ) $ offset ) ; $ limit = min ( 9 9 9 9 9 9 9 9 9 , ( int ) $ limit ) ; $ hookdata = array ( 'offset ' = > $ offset , 'limit ' = > $ limit , 'from ' = > $ date _from , 'to ' = > $ date _to , ) ; $ hookerr = ' ' ; $ this - > _call Hook ( Quick Books _Driver : : HOOK _QUEUEREPORT , null , $ hookerr , $ hookdata ) ; return $ this - > _queue Report ( $ user , $ date _from , $ date _to , $ offset , $ limit ) ; } 
final public function queue Processed ( $ ticket ) { $ hookdata = array ( ) ; $ hookerr = ' ' ; $ this - > _call Hook ( QUICKBOOKS _DRIVER _HOOK _QUEUEPROCESSED , $ ticket , $ hookerr , $ hookdata ) ; return $ this - > _queue Processed ( $ ticket ) ; } 
final public function queue Exists ( $ user , $ action , $ ident ) { $ hookdata = array ( 'username ' = > $ user , 'action ' = > $ action , 'ident ' = > $ ident , ) ; $ hookerr = ' ' ; $ this - > _call Hook ( QUICKBOOKS _DRIVER _HOOK _QUEUEEXISTS , null , $ hookerr , $ hookdata ) ; return $ this - > _queue Exists ( $ user , $ action , $ ident ) ; } 
final public function error Log ( $ ticket , $ errno , $ errstr ) { $ hookdata = array ( 'errno ' = > $ errno , 'errstr ' = > $ errstr , ) ; $ hookerr = ' ' ; $ this - > _call Hook ( QUICKBOOKS _DRIVER _HOOK _AUTHRESOLVE , $ ticket , $ hookerr , array ( ) ) ; return $ this - > _error Log ( $ ticket , $ errno , $ errstr ) ; } 
final public function error Last ( $ ticket ) { $ hookerr = ' ' ; $ this - > _call Hook ( QUICKBOOKS _DRIVER _HOOK _AUTHRESOLVE , $ ticket , $ hookerr , array ( ) ) ; return $ this - > _error Last ( $ ticket ) ; } 
final public function auth Login ( $ username , $ password , & $ company _file , & $ wait _before _next _update , & $ min _run _every _n _seconds , $ override = false ) { $ hookdata = array ( 'username ' = > $ username , 'password ' = > $ password , 'override ' = > $ override , ) ; $ err = ' ' ; $ this - > _call Hook ( QUICKBOOKS _DRIVER _HOOK _AUTHLOGIN , null , $ err , $ hookdata ) ; return $ this - > _auth Login ( $ username , $ password , $ company _file , $ wait _before _next _update , $ min _run _every _n _seconds , $ override ) ; } 
final public function auth Resolve ( $ ticket ) { $ err = ' ' ; $ this - > _call Hook ( QUICKBOOKS _DRIVER _HOOK _AUTHRESOLVE , $ ticket , $ err , array ( ) ) ; return $ this - > _auth Resolve ( $ ticket ) ; } 
final public function auth Last ( $ username ) { $ ticket = null ; $ err = ' ' ; $ this - > _call Hook ( QUICKBOOKS _DRIVER _HOOK _AUTHLAST , $ ticket , $ err , array ( ) ) ; return $ this - > _auth Last ( $ username ) ; } 
final public function auth Check ( $ ticket ) { $ err = ' ' ; $ this - > _call Hook ( QUICKBOOKS _DRIVER _HOOK _AUTHCHECK , $ ticket , $ err , array ( ) ) ; return $ this - > _auth Check ( $ ticket ) ; } 
final public function auth Logout ( $ ticket ) { $ err = ' ' ; $ this - > _call Hook ( QUICKBOOKS _DRIVER _HOOK _AUTHLOGOUT , $ ticket , $ err , array ( ) ) ; return $ this - > _auth Logout ( $ ticket ) ; } 
final public function auth Create ( $ username , $ password , $ company _file = null , $ wait _before _next _update = null , $ min _run _every _n _seconds = null ) { $ hookdata = array ( 'username ' = > $ username , 'password ' = > $ password , 'qb _company _file ' = > $ company _file , 'qbwc _wait _before _next _update ' = > $ wait _before _next _update , 'qbwc _min _run _every _n _seconds ' = > $ min _run _every _n _seconds , ) ; $ err = ' ' ; $ this - > _call Hook ( QUICKBOOKS _DRIVER _HOOK _AUTHCREATE , null , $ err , $ hookdata ) ; return $ this - > _auth Create ( $ username , $ password , $ company _file , $ wait _before _next _update , $ min _run _every _n _seconds ) ; } 
final public function auth Enable ( $ username ) { $ hookdata = array ( 'username ' = > $ username , ) ; $ err = ' ' ; $ this - > _call Hook ( QUICKBOOKS _DRIVER _HOOK _AUTHENABLE , null , $ err , $ hookdata ) ; return $ this - > _auth Enable ( $ username ) ; } 
final public function auth Disable ( $ username ) { $ hookdata = array ( 'username ' = > $ username , ) ; $ err = ' ' ; $ this - > _call Hook ( QUICKBOOKS _DRIVER _HOOK _AUTHDISABLE , null , $ err , $ hookdata ) ; return $ this - > _auth Disable ( $ username ) ; } 
public function initialize ( $ options ) { $ hookdata = array ( 'options ' = > $ options , ) ; $ err = ' ' ; $ this - > _call Hook ( QUICKBOOKS _DRIVER _HOOK _INITIALIZE , null , $ err , $ hookdata ) ; return $ this - > _initialize ( $ options ) ; } 
public function initialized ( ) { $ hookdata = array ( ) ; $ err = ' ' ; $ this - > _call Hook ( QUICKBOOKS _DRIVER _HOOK _INITIALIZED , null , $ err , $ hookdata ) ; return $ this - > _initialized ( ) ; } 
final public function log ( $ msg , $ ticket = null , $ lvl = QUICKBOOKS _LOG _NORMAL ) { if ( is _null ( $ lvl ) or $ this - > _loglevel > = $ lvl ) { return $ this - > _log ( $ msg , $ ticket , $ lvl ) ; } return true ; } 
final protected function _call Hook ( $ hook , $ ticket , & $ err , $ hook _data ) { $ user = ' ' ; if ( $ ticket ) { $ user = ( string ) $ this - > _auth Resolve ( $ ticket ) ; } 
public function check OAuth ( $ token , $ encryption _key , $ user , $ tenant ) { if ( ! $ this - > _driver ) { return false ; } if ( $ arr = $ this - > _driver - > oauth Load ( $ encryption _key , $ user , $ tenant ) ) { return true ; } return false ; } 
public function connect OAuth ( $ provider , $ token , $ pem _key , $ encryption _key , $ app _username , $ app _tenant , $ auth _id _pseudonym , $ realm _id _pseudonym , $ realm , $ flavor ) { if ( ! $ this - > _driver ) { $ this - > _log ( 'Could not connect to OAuth , no DRIVER storage instance . ' ) ; return false ; } $ url = Quick Books _IPP _Federator : : URL _OAUTH ; 
protected function _defaults ( $ config ) { $ url = ' ? ' ; if ( isset ( $ _SERVER [ 'REQUEST _URI ' ] ) ) { $ url = $ _SERVER [ 'REQUEST _URI ' ] ; } $ defaults = array ( 'qb _company _file ' = > null , 
protected function _log ( $ msg , $ ticket , $ level = QUICKBOOKS _LOG _NORMAL ) { $ Driver = $ this - > _driver ; if ( $ this - > _config [ 'masking ' ] ) { $ msg = Quick Books _Utilities : : mask ( $ msg ) ; } if ( $ Driver ) { return $ Driver - > log ( $ msg , $ ticket , $ level ) ; } return false ; } 
protected function _handle Recurring Events ( $ ticket ) { if ( $ user = $ this - > _driver - > auth Resolve ( $ ticket ) ) { while ( $ next = $ this - > _driver - > recur Dequeue ( $ user , true ) ) { 
public function authenticate ( $ obj ) { if (strlen ( $override _dsn ) ) { $override _dsn = str _replace ( 'function : / / ' , ' ' , $override _dsn ) ; } * / $ company _file = null ; $ wait _before _next _update = null ; $ min _run _every _n _seconds = null ; $ customauth _company _file = null ; $ customauth _wait _before _next _update = null ; $ customauth _min _run _every _n _seconds = null ; if ( is _array ( $ override _dsn ) or strlen ( $ override _dsn ) ) 
public function send Request XML ( $ obj ) { if ( $next [ 'qb _action ' ] = = QUICKBOOKS _INTERACTIVE _MODE ) { $this - > _driver - >error Log ( $obj - >ticket , QUICKBOOKS _ERROR _OK , QUICKBOOKS _INTERACTIVE _MODE ) ; return new Quick Books _Result _Send Request XML ( ' ' ) ; } * / $ extra = ' ' ; if ( $ next [ 'extra ' ] ) { $ extra = unserialize ( $ next [ 'extra ' ] ) ; } $ err = ' ' ; $ xml = ' ' ; if ( $this - > _config [ 'convert _unix _newlines ' ] and false = = = strpos ( $xml , " \r " ) and false ! = = strpos ( $xml , " \n " ) ) { ; } * / if ( $ err ) 
protected function _extract Identifiers ( $ xml ) { $ fetch _tagdata = array ( 'List ID ' , 'Txn ID ' , 'Owner ID ' , 'Txn Line ID ' , 'Edit Sequence ' , 'Full Name ' , 'Name ' , 'Ref Number ' , ) ; $ fetch _attributes = array ( 'request ID ' , 'iterator ID ' , 'iterator Remaining Count ' , 'meta Data ' , 'ret Count ' , 'status Code ' , 'status Severity ' , 'status Message ' , 'new Message Set ID ' , 'message Set Status Code ' , ) ; $ list = array ( ) ; foreach ( $ fetch _tagdata as $ tag ) { if ( false ! = = ( $ start = strpos ( $ xml , ' < ' . $ tag . ' > ' ) ) and false ! = = ( $ end = strpos ( $ xml , ' < / ' . $ tag . ' > ' ) ) ) { $ list [ $ tag ] = substr ( $ xml , $ start + 2 + strlen ( $ tag ) , $ end - $ start - 2 - strlen ( $ tag ) ) ; } } foreach ( $ fetch _attributes as $ attribute ) { if ( false ! = = ( $ start = strpos ( $ xml , ' ' . $ attribute . ' = " ' ) ) and false ! = = ( $ end = strpos ( $ xml , ' " ' , $ start + strlen ( $ attribute ) + 3 ) ) ) { $ list [ $ attribute ] = substr ( $ xml , $ start + strlen ( $ attribute ) + 3 , $ end - $ start - strlen ( $ attribute ) - 3 ) ; } } return $ list ; } 
protected function _extract Status Code ( $ xml ) { if ( false ! = = ( $ start = strpos ( $ xml , ' status Code = " ' ) ) and false ! = = ( $ end = strpos ( $ xml , ' " ' , $ start + 1 3 ) ) ) { return substr ( $ xml , $ start + 1 3 , $ end - $ start - 1 3 ) ; } return QUICKBOOKS _ERROR _OK ; } 
protected function _extract Status Message ( $ xml ) { if ( false ! = = ( $ start = strpos ( $ xml , ' status Message = " ' ) ) and false ! = = ( $ end = strpos ( $ xml , ' " ' , $ start + 1 6 ) ) ) { return substr ( $ xml , $ start + 1 6 , $ end - $ start - 1 6 ) ; } return ' ' ; } 
protected function _call Mapped Function ( $ which , $ user , $ request ID , $ action , $ ident , $ extra , & $ err , $ last _action _time , $ last _actionident _time , $ xml _or _version = ' ' , $ qb _identifier _or _locale = array ( ) , $ qbxml = null ) { if ( $ which = = 0 ) { return Quick Books _Callbacks : : call Request Handler ( $ this - > _driver , $ this - > _map , $ request ID , $ action , $ user , $ ident , $ extra , $ err , $ last _action _time , $ last _actionident _time , $ xml _or _version , $ qb _identifier _or _locale , $ this - > _callback _config , $ qbxml ) ; } else if ( $ which = = 1 ) { return Quick Books _Callbacks : : call Response Handler ( $ this - > _driver , $ this - > _map , $ request ID , $ action , $ user , $ ident , $ extra , $ err , $ last _action _time , $ last _actionident _time , $ xml _or _version , $ qb _identifier _or _locale , $ this - > _callback _config , $ qbxml ) ; } $ err = 'Request for a mapped function could not be fulfilled , invalid $which parameter . ' ; return false ; } 
protected function _call Hook ( $ ticket , $ hook , $ request ID , $ action , $ ident , $ extra , & $ err , $ xml = ' ' , $ qb _identifiers = array ( ) , $ hook _data = array ( ) ) { $ user = ' ' ; if ( $ ticket ) { $ user = $ this - > _driver - > auth Resolve ( $ ticket ) ; } 
protected function _handle Error ( $ ticket , $ errnum , $ errmsg , $ request ID , $ action , $ ident , $ extra , & $ err , $ xml = ' ' , $ qb _identifiers = array ( ) ) { if ( $action and $ident ) { $this - > _driver - >queue Status ( $ticket , $action , $ident , QUICKBOOKS _STATUS _ERROR , $errnum . ' : ' . $errmsg ) ; } * / if ( $ request ID ) { $ this - > _driver - > queue Status ( $ ticket , $ request ID , QUICKBOOKS _STATUS _ERROR , $ errnum . ' : ' . $ errmsg ) ; } 
protected function _calculate Progress ( $ ticket ) { if ( $ this - > _driver - > auth Check ( $ ticket ) ) 
public function receive Response XML ( $ obj ) { if ( $current = $this - > _driver - >queue Fetch ( $user , $action , $ident , QUICKBOOKS _STATUS _PROCESSING ) ) { if ( $current [ 'extra ' ] ) { $extra = unserialize ( $current [ 'extra ' ] ) ; } } * / if ( $ current [ 'extra ' ] ) { $ extra = unserialize ( $ current [ 'extra ' ] ) ; } $ errmsg = null ; if ( $ obj - > message ) { $ errmsg = $ obj - > message ; } else if ( $ status = $ this - > _extract Status Message ( $ obj - > response ) ) { $ errmsg = $ status ; } $ errerr = ' ' ; $ continue = $ this - > _handle Error ( $ obj - > ticket , $ errnum , $ errmsg , $ request ID , $ action , $ ident , $ extra , $ errerr , $ obj - > response , array ( ) ) ; $action = ' ' ; $ident = ' ' ; $this - > _parse Request ID ( $request ID , $action , $ident ) ; * / $ action = $ current [ 'qb _action ' ] ; $ ident = $ current [ 'ident ' ] ; if ( $current = $this - > _driver - >queue Fetch ( $user , $action , $ident , QUICKBOOKS _STATUS _PROCESSING ) ) { if ( $current [ 'extra ' ] ) { $extra = unserialize ( $current [ 'extra ' ] ) ; } } * / if ( $ current [ 'extra ' ] ) { $ extra = unserialize ( $ current [ 'extra ' ] ) ; } if ( $this - > _config [ 'map _application _identifiers ' ] ) { $adds = Quick Books _Utilities : :list Actions ( ' *Add * ' ) ; $mods = Quick Books _Utilities : :list Actions ( ' *Mod * ' ) ; $qbkey = Quick Books _Utilities : :key For Action ( $action ) ; $type = Quick Books _Utilities : :action To Object ( $action ) ; $Edit Sequence = ' ' ; if (isset ( $identifiers [ 'Edit Sequence ' ] ) ) { $Edit Sequence = $identifiers [ 'Edit Sequence ' ] ; } if (in _array ( $action , $adds ) and isset ( $identifiers [ $qbkey ] ) and $type ) { $this - > _driver - >ident Map ( $user , $type , $ident , $identifiers [ $qbkey ] , $Edit Sequence ) ; } else if (in _array ( $action , $mods ) and isset ( $identifiers [ $qbkey ] ) and $type ) { $this - > _driver - >ident Map ( $user , $type , $ident , $identifiers [ $qbkey ] , $Edit Sequence ) ; } } * / $ err = null ; 
public function connection Error ( $ obj ) { 
public function get Last Error ( $ obj ) { 
public function close Connection ( $ obj ) { 
public function server Version ( $ obj ) { 
public function client Version ( $ obj ) { 
public function enqueue ( $ action , $ ident , $ priority = 0 , $ extra = null , $ user = null ) { $ Queue = new Quick Books _Web Connector _Queue ( $ this - > _dsn ) ; return $ Queue - > enqueue ( $ action , $ ident , $ priority , $ extra , $ user ) ; } 
public function find By Name ( $ Context , $ realm ID , $ name ) { $ IPP = $ Context - > IPP ( ) ; if ( $ IPP - > flavor ( ) = = Quick Books _IPP _IDS : : FLAVOR _DESKTOP ) { for ( $ i = 0 ; $ i < 9 9 9 ; $ i + + ) { $ list = $ this - > find All ( $ Context , $ realm ID , $ name , $ i , 5 0 ) ; foreach ( $ list as $ Item ) { if ( strtolower ( $ Item - > get Name ( ) ) = = strtolower ( $ name ) ) { return $ Item ; } } } return false ; } else { $ xml = null ; return parent : : _find By Name ( $ Context , $ realm ID , Quick Books _IPP _IDS : : RESOURCE _ITEM , $ name , $ xml ) ; } } 
protected function _parse Helper ( $ xml , & $ Root , & $ errnum , & $ errmsg , $ indent = 0 ) { $ errnum = Quick Books _XML : : ERROR _OK ; $ errmsg = ' ' ; $ arr = array ( ) ; $ xml = trim ( $ xml ) ; if ( ! strlen ( $ xml ) ) { return false ; } $ data = ' ' ; $ vstack = array ( ) ; $ dstack = array ( ) ; print ( 'now examinging : ' ) ; print ( ' - - - - - - - - - - - - - - ' ) ; print ( $xml ) ; print ( ' - - - - - - - - - - - ' ) ; print ( " \n \n \n " ) ; * / $ opentag _start = strpos ( $ xml , ' < ' ) ; $ opentag _end = strpos ( $ xml , ' > ' ) ; 
protected function _starts With ( $ str , $ startswith ) { $ length = strlen ( $ startswith ) ; return ( substr ( $ str , 0 , $ length ) ) = = $ startswith ; } 
public function query ( $ sql , $ look = true ) { if ( $ this - > _driver ) { if ( $ look ) { $ tmp = trim ( strtoupper ( $ sql ) ) ; if ( $ this - > _starts With ( $ sql , 'UPDATE ' ) ) { } else if ( $ this - > _starts With ( $ sql , 'INSERT INTO ' ) ) { } else if ( $ this - > _starts With ( $ sql , 'DELETE FROM ' ) ) { } } return $ this - > _driver - > query ( $ sql ) ; } return false ; } 
static public function import ( $ dir , $ autoload = true ) { $ dh = opendir ( QUICKBOOKS _BASEDIR . $ dir ) ; if ( $ dh ) { while ( false ! = = ( $ file = readdir ( $ dh ) ) ) { $ tmp = explode ( ' . ' , $ file ) ; if ( end ( $ tmp ) = = 'php ' and ! is _dir ( QUICKBOOKS _BASEDIR . $ dir . DIRECTORY _SEPARATOR . $ file ) ) { Quick Books _Loader : : load ( $ dir . DIRECTORY _SEPARATOR . $ file , $ autoload ) ; 
static public function extract Tag Contents ( $ tag , $ data ) { $ tag = trim ( $ tag , ' < > ' ) ; if ( false ! = = strpos ( $ data , ' < ' . $ tag . ' > ' ) and false ! = = strpos ( $ data , ' < / ' . $ tag . ' > ' ) ) { $ data = strstr ( $ data , ' < ' . $ tag . ' > ' ) ; $ end = strpos ( $ data , ' < / ' . $ tag . ' > ' ) ; return substr ( $ data , strlen ( $ tag ) + 2 , $ end - ( strlen ( $ tag ) + 2 ) ) ; } return null ; } 
static public function extract Tag Attributes ( $ tag _w _attrs , $ return _tag _first = false ) { $ tag = ' ' ; $ attributes = array ( ) ; $ tag _w _attrs = trim ( $ tag _w _attrs ) ; if ( false ! = = strpos ( $ tag _w _attrs , ' ' ) ) { $ tmp = explode ( ' ' , $ tag _w _attrs ) ; else if ( $attrs { $i } = = ' " ' and $expect _value ) { $in _value = true ; $expect _value = false ; } * / else if ( ( $ attrs { $ i } = = ' " ' or $ attrs { $ i } = = ' \ ' ' ) and $ expect _value ) { $ in _value = true ; $ expect _value = false ; } else if ( ( $ attrs { $ i } = = ' " ' or $ attrs { $ i } = = ' \ ' ' ) and $ in _value ) { $ attributes [ trim ( $ key ) ] = $ value ; $ key = ' ' ; $ value = ' ' ; $ in _value = false ; $ expect _key = true ; } else if ( $ attrs { $ i } = = ' ' and $ expect _key ) { $ expect _key = false ; $ in _key = true ; } else if ( $ in _key ) { $ key . = $ attrs { $ i } ; } else if ( $ in _value ) { $ value . = $ attrs { $ i } ; } } / * foreach ( $tmp as $attribute ) { if (false ! = = ( $pos = strpos ( $attribute , ' = ' ) ) ) { $key = trim (substr ( $attribute , 0 , $pos ) ) ; $value = trim (substr ( $attribute , $pos + 1 ) , ' " ' ) ; $attributes [ $key ] = $value ; } } * / } else { $ tag = $ tag _w _attrs ; $ attributes = array ( ) ; } 
static public function encode ( $ str , $ for _qbxml = true , $ double _encode = true ) { $ transform = array ( ' & ' = > ' &amp ; ' , ' < ' = > ' &lt ; ' , ' > ' = > ' &gt ; ' , 
static public function decode ( $ str , $ for _qbxml = true ) { $ transform = array ( ' &lt ; ' = > ' < ' , ' &gt ; ' = > ' > ' , ' &apos ; ' = > ' \ ' ' , ' &quot ; ' = > ' " ' , ' &amp ; ' = > ' & ' , 
public function check ( $ app _username , $ app _tenant ) { if ( $ arr = $ this - > load ( $ app _username , $ app _tenant ) ) { return true ; } return false ; } 
public function load ( $ app _username , $ app _tenant ) { if ( $ arr = $ this - > _driver - > oauth Load ( $ this - > _key , $ app _username , $ app _tenant ) and strlen ( $ arr [ 'oauth _access _token ' ] ) > 0 and strlen ( $ arr [ 'oauth _access _token _secret ' ] ) > 0 ) { $ arr [ 'oauth _consumer _key ' ] = $ this - > _consumer _key ; $ arr [ 'oauth _consumer _secret ' ] = $ this - > _consumer _secret ; return $ arr ; } return false ; } 
public function expiry ( $ app _username , $ app _tenant , $ within = 2 5 9 2 0 0 0 ) { $ lifetime = 1 5 5 5 2 0 0 0 ; if ( $ arr = $ this - > _driver - > oauth Load ( $ this - > _key , $ app _username , $ app _tenant ) and strlen ( $ arr [ 'oauth _access _token ' ] ) > 0 and strlen ( $ arr [ 'oauth _access _token _secret ' ] ) > 0 ) { $ expires = $ lifetime + strtotime ( $ arr [ 'access _datetime ' ] ) ; $ diff = $ expires - time ( ) ; if ( $ diff < 0 ) { 
public function reconnect ( $ app _username , $ app _tenant ) { if ( $ arr = $ this - > _driver - > oauth Load ( $ this - > _key , $ app _username , $ app _tenant ) and strlen ( $ arr [ 'oauth _access _token ' ] ) > 0 and strlen ( $ arr [ 'oauth _access _token _secret ' ] ) > 0 ) { $ arr [ 'oauth _consumer _key ' ] = $ this - > _consumer _key ; $ arr [ 'oauth _consumer _secret ' ] = $ this - > _consumer _secret ; $ retr = $ this - > _request ( Quick Books _IPP _OAuth : : METHOD _GET , Quick Books _IPP _Intuit Anywhere : : URL _CONNECT _RECONNECT , array ( ) , $ arr [ 'oauth _access _token ' ] , $ arr [ 'oauth _access _token _secret ' ] ) ; 
public function handle ( $ app _username , $ app _tenant ) { if ( $ this - > check ( $ app _username , $ app _tenant ) and $arr = mysql _fetch _array (mysql _query ( " SELECT * FROM quickbooks _oauth WHERE oauth _request _token = ' " . $ _REQUEST [ 'oauth _token ' ] . " ' " ) ) ; * / if ( $ arr = $ this - > _driver - > oauth Request Resolve ( $ _GET [ 'oauth _token ' ] ) ) { $ info = $ this - > _get Access Token ( $ arr [ 'oauth _request _token ' ] , $ arr [ 'oauth _request _token _secret ' ] , $ _GET [ 'oauth _verifier ' ] ) ; mysql _query ( " UPDATE quickbooks _oauth SET oauth _access _token = ' " . $info [ 'oauth _token ' ] . " ' , oauth _access _token _secret = ' " . $info [ 'oauth _token _secret ' ] . " ' , qb _realm = ' " . $ _REQUEST [ 'realm Id ' ] . " ' , qb _flavor = ' " . $ _REQUEST [ 'data Source ' ] . " ' WHERE quickbooks _oauth _id = " . $arr [ 'quickbooks _oauth _id ' ] ) ; * / $ this - > _driver - > oauth Access Write ( $ this - > _key , $ arr [ 'oauth _request _token ' ] , $ info [ 'oauth _token ' ] , $ info [ 'oauth _token _secret ' ] , $ _GET [ 'realm Id ' ] , $ _GET [ 'data Source ' ] ) ; 
public function widget Menu ( $ app _username , $ app _tenant ) { $ token = null ; $ secret = null ; if ( $ creds = $ this - > load ( $ app _username , $ app _tenant ) ) { return $ this - > _request ( Quick Books _IPP _OAuth : : METHOD _GET , Quick Books _IPP _Intuit Anywhere : : URL _APP _MENU , array ( ) , $ creds [ 'oauth _access _token ' ] , $ creds [ 'oauth _access _token _secret ' ] ) ; } return ' ' ; } 
static public function map Schema To SQLDefinition ( $ xml , & $ tables ) { $ Parser = new Quick Books _XML _Parser ( $ xml ) ; $ errnum = 0 ; $ errmsg = ' ' ; $ tmp = $ Parser - > parse ( $ errnum , $ errmsg ) ; $ tmp = $ tmp - > children ( ) ; $ base = current ( $ tmp ) ; $ tmp = $ base - > children ( ) ; $ rs = next ( $ tmp ) ; foreach ( $ rs - > children ( ) as $ qbxml ) { Quick Books _SQL _Schema : : _transform ( ' ' , $ qbxml , $ tables ) ; } ' *Full Name ' , ' *List ID ' , ' *Txn ID ' , ' *Entity Type ' , ' *Txn Type ' , ' *Line ID ' , * / foreach ( $ tables as $ table = > $ tabledef ) { $ uniques = array ( ) ; $ indexes = array ( ) ; foreach ( $ tabledef [ 1 ] as $ field = > $ fielddef ) { if ( $ field = = 'List ID ' or 
static protected function _transform ( $ curpath , $ node , & $ tables ) { print ( ' ' . $ curpath . ' node : ' . $ node - > name ( ) . " \n " ) ; $ table = ' ' ; $ field = ' ' ; $ this _sql = array ( ) ; $ other _sql = array ( ) ; Quick Books _SQL _Schema : : map To Schema ( $ curpath . ' ' . $ node - > name ( ) , QUICKBOOKS _SQL _SCHEMA _MAP _TO _SQL , $ this _sql , $ other _sql ) ; foreach ( array _merge ( array ( $ this _sql ) , $ other _sql ) as $ sql ) { $ table = $ sql [ 0 ] ; $ field = $ sql [ 1 ] ; if ( $ table ) { if ( ! isset ( $ tables [ $ table ] ) ) { $ tables [ $ table ] = array ( 0 = > $ table , 1 = > array ( ) , 
static public function map Primary Key ( $ path _or _tablefield , $ mode , & $ map , $ options = array ( ) ) { static $ xml _to _sql = array ( 'Account Ret ' = > array ( 'Account ' , 'List ID ' ) , 'Account Ret Tax Line Info Ret ' = > array ( 'Account _Tax Line Info ' , array ( 'Account _List ID ' , 'Tax Line Info _Tax Line ID ' ) ) , 'Account Ret Data Ext Ret ' = > array ( 'Data Ext ' , array ( 'Entity Type ' , 'Txn Type ' , 'Entity _List ID ' , 'Txn _Txn ID ' ) ) , 'Billing Rate Ret ' = > array ( 'Billing Rate ' , 'List ID ' ) , 'Billing Rate Ret Billing Rate Per Item Ret ' = > array ( 'Billing Rate _Billing Rate Per Item ' , array ( 'Billing Rate _List ID ' , 'Item _List ID ' ) ) , 'Bill Payment Check Ret ' = > array ( 'Bill Payment Check ' , 'Txn ID ' ) , 'Bill Payment Check Ret Applied To Txn Ret ' = > array ( 'Bill Payment Check _Applied To Txn ' , array ( 'To Txn ID ' , 'From Txn ID ' ) ) , 'Bill Payment Check Ret Data Ext Ret ' = > array ( 'Data Ext ' , array ( 'Entity Type ' , 'Txn Type ' , 'Entity _List ID ' , 'Txn _Txn ID ' ) ) , 'Bill Payment Credit Card Ret ' = > array ( 'Bill Payment Credit Card ' , 'Txn ID ' ) , 'Bill Payment Credit Card Ret Applied To Txn Ret ' = > array ( 'Bill Payment Credit Card _Applied To Txn ' , array ( 'To Txn ID ' , 'From Txn ID ' ) ) , 'Bill Payment Credit Card Ret Data Ext Ret ' = > array ( 'Data Ext ' , array ( 'Entity Type ' , 'Txn Type ' , 'Entity _List ID ' , 'Txn _Txn ID ' ) ) , 'Bill Ret ' = > array ( 'Bill ' , 'Txn ID ' ) , 'Bill Ret Linked Txn ' = > array ( 'Bill _Linked Txn ' , array ( 'To Txn ID ' , 'From Txn ID ' ) ) , 'Bill Ret Expense Line Ret ' = > array ( 'Bill _Expense Line ' , array ( 'Bill _Txn ID ' , 'Txn Line ID ' ) ) , 'Bill Ret Item Line Ret ' = > array ( 'Bill _Item Line ' , array ( 'Bill _Txn ID ' , 'Txn Line ID ' ) ) , 'Bill Ret Item Group Line Ret ' = > array ( 'Bill _Item Group Line ' , array ( 'Bill _Txn ID ' , 'Txn Line ID ' ) ) , 'Bill Ret Item Group Line Ret Item Line Ret ' = > array ( 'Bill _Item Group Line _Item Line ' , array ( 'Bill _Txn ID ' , 'Bill _Item Group Line _Txn Line ID ' , 'Txn Line ID ' ) ) , 'Bill Ret Data Ext Ret ' = > array ( 'Data Ext ' , array ( 'Entity Type ' , 'Txn Type ' , 'Entity _List ID ' , 'Txn _Txn ID ' ) ) , 'Bill To Pay Ret Bill To Pay ' = > array ( 'Bill To Pay ' , 'Txn ID ' ) , 'Bill To Pay Ret Credit To Apply ' = > array ( 'Credit To Apply ' , 'Txn ID ' ) , 'Build Assembly Ret ' = > array ( 'Build Assembly ' , 'Txn ID ' ) , 'Charge Ret ' = > array ( 'Charge ' , 'Txn ID ' ) , 'Charge Ret Data Ext Ret ' = > array ( 'Data Ext ' , array ( 'Entity Type ' , 'Txn Type ' , 'Entity _List ID ' , 'Txn _Txn ID ' ) ) , 'Check Ret ' = > array ( 'Check ' , 'Txn ID ' ) , 'Check Ret Expense Line Ret ' = > array ( 'Check _Expense Line ' , array ( 'Check _Txn ID ' , 'Txn Line ID ' ) ) , 'Check Ret Item Line Ret ' = > array ( 'Check _Item Line ' , array ( 'Check _Txn ID ' , 'Txn Line ID ' ) ) , 'Check Ret Item Group Line Ret ' = > array ( 'Check _Item Group Line ' , array ( 'Check _Txn ID ' , 'Txn Line ID ' ) ) , 'Check Ret Item Group Line Ret Item Line Ret ' = > array ( 'Check _Item Group Line _Item Line ' , array ( 'Check _Txn ID ' , 'Check _Item Group Line _Txn Line ID ' , 'Txn Line ID ' ) ) , 'Check Ret Data Ext Ret ' = > array ( 'Data Ext ' , array ( 'Entity Type ' , 'Txn Type ' , 'Entity _List ID ' , 'Txn _Txn ID ' ) ) , 'Check Ret Linked Txn ' = > array ( 'Check _Linked Txn ' , array ( 'To Txn ID ' , 'From Txn ID ' ) ) , 'Class Ret ' = > array ( 'Class ' , 'List ID ' ) , 'Company Ret ' = > array ( 'Company ' , 'Company Name ' ) , 'Company Ret Subscribed Services Services ' = > array ( 'Company _Subscribed Services _Services ' , array ( 'Company _Company Name ' , 'Name ' ) ) , 'Company Ret Data Ext Ret ' = > array ( 'Data Ext ' , array ( 'Entity Type ' , 'Txn Type ' , 'Entity _List ID ' , 'Txn _Txn ID ' ) ) , 'Host Ret ' = > array ( 'Host ' , 'Product Name ' ) , 'Preferences Ret ' = > array ( 'Preferences ' , 'qbsql _external _id ' ) , 'Credit Card Charge Ret ' = > array ( 'Credit Card Charge ' , 'Txn ID ' ) , 'Credit Card Charge Ret Expense Line Ret ' = > array ( 'Credit Card Charge _Expense Line ' , array ( 'Credit Card Charge _Txn ID ' , 'Txn Line ID ' ) ) , 'Credit Card Charge Ret Item Line Ret ' = > array ( 'Credit Card Charge _Item Line ' , array ( 'Credit Card Charge _Txn ID ' , 'Txn Line ID ' ) ) , 'Credit Card Charge Ret Item Group Line Ret ' = > array ( 'Credit Card Charge _Item Group Line ' , array ( 'Credit Card Charge _Txn ID ' , 'Txn Line ID ' ) ) , 'Credit Card Charge Ret Item Group Line Ret Item Line Ret ' = > array ( 'Credit Card Charge _Item Group Line _Item Line ' , array ( 'Credit Card Charge _Txn ID ' , 'Credit Card Charge _Item Group Line _Txn Line ID ' , 'Txn Line ID ' ) ) , 'Credit Card Charge Ret Data Ext Ret ' = > array ( 'Data Ext ' , array ( 'Entity Type ' , 'Txn Type ' , 'Entity _List ID ' , 'Txn _Txn ID ' ) ) , 'Credit Card Credit Ret ' = > array ( 'Credit Card Credit ' , 'Txn ID ' ) , 'Credit Card Credit Ret Expense Line Ret ' = > array ( 'Credit Card Credit _Expense Line ' , array ( 'Credit Card Credit _Txn ID ' , 'Txn Line ID ' ) ) , 'Credit Card Credit Ret Item Line Ret ' = > array ( 'Credit Card Credit _Item Line ' , array ( 'Credit Card Credit _Txn ID ' , 'Txn Line ID ' ) ) , 'Credit Card Credit Ret Item Group Line Ret ' = > array ( 'Credit Card Credit _Item Group Line ' , array ( 'Credit Card Credit _Txn ID ' , 'Txn Line ID ' ) ) , 'Credit Card Credit Ret Item Group Line Ret Item Line Ret ' = > array ( 'Credit Card Credit _Item Group Line _Item Line ' , array ( 'Credit Card Credit _Txn ID ' , 'Credit Card Credit _Item Group Line _Txn Line ID ' , 'Txn Line ID ' ) ) , 'Credit Card Credit Ret Data Ext Ret ' = > array ( 'Data Ext ' , array ( 'Entity Type ' , 'Txn Type ' , 'Entity _List ID ' , 'Txn _Txn ID ' ) ) , 'Credit Memo Ret ' = > array ( 'Credit Memo ' , 'Txn ID ' ) , 'Credit Memo Ret Credit Memo Line Ret ' = > array ( 'Credit Memo _Credit Memo Line ' , array ( 'Credit Memo _Txn ID ' , 'Txn Line ID ' ) ) , 'Credit Memo Ret Credit Memo Line Group Ret ' = > array ( 'Credit Memo _Credit Memo Line Group ' , array ( 'Credit Memo _Txn ID ' , 'Txn Line ID ' ) ) , 
static public function map To Schema ( $ path _or _tablefield , $ mode , & $ map , & $ others , $ options = array ( ) ) { static $ xml _to _sql = array ( 'Account Ret ' = > array ( 'Account ' , null ) , 'Account Ret Parent Ref ' = > array ( null , null ) , 'Account Ret Parent Ref * ' = > array ( 'Account ' , 'Parent _ * ' ) , 'Account Ret Tax Line Info Ret ' = > array ( 'Account _Tax Line Info ' , null ) , array ( 'Inventory Adjustment _Inventory Adjustment Line ' , 'Quantity Adjustment _New Quantity ' ) , array ( 'Inventory Adjustment _Inventory Adjustment Line ' , 'Quantity Adjustment _Quantity Difference ' ) , array ( 'Inventory Adjustment _Inventory Adjustment Line ' , 'Value Adjustment _New Quantity ' ) , array ( 'Inventory Adjustment _Inventory Adjustment Line ' , 'Value Adjustment _Quantity Difference ' ) , array ( 'Inventory Adjustment _Inventory Adjustment Line ' , 'Value Adjustment _New Value ' ) , array ( 'Inventory Adjustment _Inventory Adjustment Line ' , 'Value Adjustment _Value Difference ' ) , * / ) , 'Invoice Ret Invoice Line Ret ' = > array ( array ( 'Invoice _Invoice Line ' , 'Invoice _Txn ID ' ) , array ( 'Invoice _Invoice Line ' , 'Sort Order ' ) , ) , 'Invoice Ret Invoice Line Group Ret ' = > array ( array ( 'Invoice _Invoice Line Group ' , 'Invoice _Txn ID ' ) , array ( 'Invoice _Invoice Line Group ' , 'Sort Order ' ) , ) , 'Invoice Ret Invoice Line Group Ret Invoice Line Ret ' = > array ( array ( 'Invoice _Invoice Line Group _Invoice Line ' , 'Invoice _Txn ID ' ) , array ( 'Invoice _Invoice Line Group _Invoice Line ' , 'Invoice _Invoice Line Group _Txn Line ID ' ) , array ( 'Invoice _Invoice Line Group _Invoice Line ' , 'Sort Order ' ) , ) , 'Invoice Ret Linked Txn ' = > array ( array ( 'Invoice _Linked Txn ' , 'From Txn ID ' ) , array ( 'Invoice _Linked Txn ' , 'Invoice _Txn ID ' ) , array ( 'Invoice _Linked Txn ' , 'Link Type ' ) , ) , 'Item Group Ret Item Group Line ' = > array ( array ( 'Item Group _Item Group Line ' , 'Item Group _List ID ' ) , array ( 'Item Group _Item Group Line ' , 'Sort Order ' ) , ) , 'Item Inventory Assembly Ret Item Inventory Assembly Line ' = > array ( array ( 'Item Inventory Assembly _Item Inventory Assembly Line ' , 'Item Inventory Assembly _List ID ' ) , array ( 'Item Inventory Assembly _Item Inventory Assembly Line ' , 'Sort Order ' ) , ) , 'Item Receipt Ret Expense Line Ret ' = > array ( array ( 'Item Receipt _Expense Line ' , 'Item Receipt _Txn ID ' ) , array ( 'Item Receipt _Expense Line ' , 'Sort Order ' ) , ) , 'Item Receipt Ret Item Line Ret ' = > array ( array ( 'Item Receipt _Item Line ' , 'Item Receipt _Txn ID ' ) , array ( 'Item Receipt _Item Line ' , 'Sort Order ' ) , ) , 'Item Receipt Ret Item Group Line Ret ' = > array ( array ( 'Item Receipt _Item Group Line ' , 'Item Receipt _Txn ID ' ) , array ( 'Item Receipt _Item Group Line ' , 'Sort Order ' ) , ) , 'Item Receipt Ret Item Group Line Ret Item Line Ret ' = > array ( array ( 'Item Receipt _Item Group Line _Item Line ' , 'Item Receipt _Txn ID ' ) , array ( 'Item Receipt _Item Group Line _Item Line ' , 'Item Receipt _Item Group Line _Txn Line ID ' ) , array ( 'Item Receipt _Item Group Line _Item Line ' , 'Sort Order ' ) , ) , 'Item Receipt Ret Linked Txn ' = > array ( array ( 'Item Receipt _Linked Txn ' , 'From Txn ID ' ) , array ( 'Item Receipt _Linked Txn ' , 'Item Receipt _Txn ID ' ) , array ( 'Item Receipt _Linked Txn ' , 'Link Type ' ) , ) , 'Item Sales Tax Group Ret Item Sales Tax Ref ' = > array ( array ( 'Item Sales Tax Group _Item Sales Tax ' , 'Item Sales Tax Group _List ID ' ) , ) , 'Journal Entry Ret Journal Debit Line ' = > array ( array ( 'Journal Entry _Journal Debit Line ' , 'Journal Entry _Txn ID ' ) , array ( 'Journal Entry _Journal Debit Line ' , 'Sort Order ' ) , ) , 'Journal Entry Ret Journal Credit Line ' = > array ( array ( 'Journal Entry _Journal Credit Line ' , 'Journal Entry _Txn ID ' ) , array ( 'Journal Entry _Journal Credit Line ' , 'Sort Order ' ) , ) , 'Price Level Ret Price Level Per Item Ret ' = > array ( array ( 'Price Level _Price Level Per Item ' , 'Price Level _List ID ' ) , ) , 'Purchase Order Ret Purchase Order Line Ret ' = > array ( array ( 'Purchase Order _Purchase Order Line ' , 'Purchase Order _Txn ID ' ) , array ( 'Purchase Order _Purchase Order Line ' , 'Sort Order ' ) , ) , 'Purchase Order Ret Purchase Order Line Group Ret ' = > array ( array ( 'Purchase Order _Purchase Order Line Group ' , 'Purchase Order _Txn ID ' ) , array ( 'Purchase Order _Purchase Order Line Group ' , 'Sort Order ' ) , ) , 'Purchase Order Ret Purchase Order Line Group Ret Purchase Order Line Ret ' = > array ( array ( 'Purchase Order _Purchase Order Line Group _Purchase Order Line ' , 'Purchase Order _Txn ID ' ) , array ( 'Purchase Order _Purchase Order Line Group _Purchase Order Line ' , 'Purchase Order _Purchase Order Line Group _Txn Line ID ' ) , array ( 'Purchase Order _Purchase Order Line Group _Purchase Order Line ' , 'Sort Order ' ) , ) , 'Purchase Order Ret Linked Txn ' = > array ( array ( 'Purchase Order _Linked Txn ' , 'From Txn ID ' ) , array ( 'Purchase Order _Linked Txn ' , 'Purchase Order _Txn ID ' ) , array ( 'Purchase Order _Linked Txn ' , 'Link Type ' ) , ) , 'Receive Payment Ret Applied To Txn Ret ' = > array ( array ( 'Receive Payment _Applied To Txn ' , 'From Txn ID ' ) , array ( 'Receive Payment _Applied To Txn ' , 'Receive Payment _Txn ID ' ) , ) , 'Sales Order Ret Sales Order Line Ret ' = > array ( array ( 'Sales Order _Sales Order Line ' , 'Sales Order _Txn ID ' ) , array ( 'Sales Order _Sales Order Line ' , 'Sort Order ' ) , ) , 'Sales Order Ret Sales Order Line Group Ret ' = > array ( array ( 'Sales Order _Sales Order Line Group ' , 'Sales Order _Txn ID ' ) , array ( 'Sales Order _Sales Order Line Group ' , 'Sort Order ' ) , ) , 'Sales Order Ret Sales Order Line Group Ret Sales Order Line Ret ' = > array ( array ( 'Sales Order _Sales Order Line Group _Sales Order Line ' , 'Sales Order _Txn ID ' ) , array ( 'Sales Order _Sales Order Line Group _Sales Order Line ' , 'Sales Order _Sales Order Line Group _Txn Line ID ' ) , array ( 'Sales Order _Sales Order Line Group _Sales Order Line ' , 'Sort Order ' ) , ) , 'Sales Order Ret Linked Txn ' = > array ( array ( 'Sales Order _Linked Txn ' , 'From Txn ID ' ) , array ( 'Sales Order _Linked Txn ' , 'Sales Order _Txn ID ' ) , array ( 'Sales Order _Linked Txn ' , 'Link Type ' ) , ) , 'Sales Receipt Ret Sales Receipt Line Ret ' = > array ( array ( 'Sales Receipt _Sales Receipt Line ' , 'Sales Receipt _Txn ID ' ) , array ( 'Sales Receipt _Sales Receipt Line ' , 'Sort Order ' ) , ) , 'Sales Receipt Ret Sales Receipt Line Group Ret ' = > array ( array ( 'Sales Receipt _Sales Receipt Line Group ' , 'Sales Receipt _Txn ID ' ) , array ( 'Sales Receipt _Sales Receipt Line Group ' , 'Sort Order ' ) , ) , 'Sales Receipt Ret Sales Receipt Line Group Ret Sales Receipt Line Ret ' = > array ( array ( 'Sales Receipt _Sales Receipt Line Group _Sales Receipt Line ' , 'Sales Receipt _Txn ID ' ) , array ( 'Sales Receipt _Sales Receipt Line Group _Sales Receipt Line ' , 'Sales Receipt _Sales Receipt Line Group _Txn Line ID ' ) , array ( 'Sales Receipt _Sales Receipt Line Group _Sales Receipt Line ' , 'Sort Order ' ) , ) , 'Unit Of Measure Set Ret Related Unit ' = > array ( array ( 'Unit Of Measure Set _Related Unit ' , 'Unit Of Measure Set _List ID ' ) , ) , 'Unit Of Measure Set Ret Default Unit ' = > array ( array ( 'Unit Of Measure Set _Default Unit ' , 'Unit Of Measure Set _List ID ' ) , ) , 'Vendor Credit Ret Expense Line Ret ' = > array ( array ( 'Vendor Credit _Expense Line ' , 'Vendor Credit _Txn ID ' ) , array ( 'Vendor Credit _Expense Line ' , 'Sort Order ' ) , ) , 'Vendor Credit Ret Item Line Ret ' = > array ( array ( 'Vendor Credit _Item Line ' , 'Vendor Credit _Txn ID ' ) , array ( 'Vendor Credit _Item Line ' , 'Sort Order ' ) , ) , 'Vendor Credit Ret Item Group Line Ret ' = > array ( array ( 'Vendor Credit _Item Group Line ' , 'Vendor Credit _Txn ID ' ) , array ( 'Vendor Credit _Item Group Line ' , 'Sort Order ' ) , ) , 'Vendor Credit Ret Item Group Line Ret Item Line Ret ' = > array ( array ( 'Vendor Credit _Item Group Line _Item Line ' , 'Vendor Credit _Txn ID ' ) , array ( 'Vendor Credit _Item Group Line _Item Line ' , 'Vendor Credit _Item Group Line _Txn Line ID ' ) , array ( 'Vendor Credit _Item Group Line _Item Line ' , 'Sort Order ' ) , ) , 'Vendor Credit Ret Linked Txn ' = > array ( array ( 'Vendor Credit _Linked Txn ' , 'From Txn ID ' ) , array ( 'Vendor Credit _Linked Txn ' , 'Vendor Credit _Txn ID ' ) , array ( 'Vendor Credit _Linked Txn ' , 'Link Type ' ) , ) , 'Workers Comp Code Ret Rate History ' = > array ( array ( 'Workers Comp Code _Rate History ' , 'Workers Comp Code _List ID ' ) , ) , ) ; if ( $ mode = = QUICKBOOKS _SQL _SCHEMA _MAP _TO _SQL ) if ( $options [ 'uppercase _tables ' ] ) { $table _and _field [ 0 ] = strtoupper ( $table _and _field [ 0 ] ) ; } else if ( $options [ 'lowercase _tables ' ] ) { $table _and _field [ 0 ] = strtolower ( $table _and _field [ 0 ] ) ; } if ( $options [ 'uppercase _fields ' ] ) { $table _and _field [ 1 ] = strtoupper ( $table _and _field [ 1 ] ) ; } else if ( $options [ 'lowercase _fields ' ] ) { $table _and _field [ 1 ] = strtolower ( $table _and _field [ 1 ] ) ; } * / $ map = array ( $ table _and _field [ 0 ] , str _replace ( ' * ' , $ match , $ table _and _field [ 1 ] ) , ) ; Quick Books _SQL _Schema : : _apply Options ( $ map , QUICKBOOKS _SQL _SCHEMA _MAP _TO _SQL , $ options ) ; break ; } } } } else if ( $ pattern = = $ path ) { $ map = $ table _and _field ; Quick Books _SQL _Schema : : _apply Options ( $ map , QUICKBOOKS _SQL _SCHEMA _MAP _TO _SQL , $ options ) ; if ( isset ( $ xml _to _sql _others [ $ pattern ] ) ) { $ others = $ xml _to _sql _others [ $ pattern ] ; foreach ( $ others as $ key = > $ other ) { Quick Books _SQL _Schema : : _apply Options ( $ other , QUICKBOOKS _SQL _SCHEMA _MAP _TO _SQL , $ options ) ; $ others [ $ key ] = $ other ; } } break ; } } 
static public function map Field To SQLDefinition ( $ object _type , $ field , $ qb _type ) { { case 'invoice ' : switch ( $field ) { default : break ; } default : switch ( $field ) { case 'isactive ' : $default = true ; break ; default : break ; } break ; } * / 
static public function catchall ( $ request ID , $ user , $ action , $ ident , $ extra , & $ err , $ xml , $ errnum , $ errmsg , $ config ) { $ Driver = Quick Books _Driver _Singleton : : get Instance ( ) ; $ ignore = array ( QUICKBOOKS _IMPORT _DELETEDTXNS = > true , QUICKBOOKS _QUERY _DELETEDTXNS = > true , QUICKBOOKS _IMPORT _DELETEDLISTS = > true , QUICKBOOKS _QUERY _DELETEDLISTS = > true , QUICKBOOKS _VOID _TRANSACTION = > true , QUICKBOOKS _DELETE _TRANSACTION = > true , QUICKBOOKS _DELETE _LIST = > true , ) ; if ( isset ( $ ignore [ $ action ] ) ) { $Parser = new Quick Books _XML ( $xml ) ; $errnum Temp = 0 ; $errmsg Temp = ' ' ; $Doc = $Parser - >parse ( $errnum Temp , $errmsg Temp ) ; $Root = $Doc - >get Root ( ) ; $email Str = var _export ( $Root - >children ( ) , true ) ; $List = $Root - >get Child At ( 'QBXML QBXMLMsgs Rs ' .Quick Books _Utilities : :action To Response ( $action ) ) ; $Node = current ( $List - >children ( ) ) ; * / $ map = array ( ) ; $ others = array ( ) ; Quick Books _SQL _Schema : : map To Schema ( trim ( Quick Books _Utilities : : action To XMLElement ( $ action ) ) , QUICKBOOKS _SQL _SCHEMA _MAP _TO _SQL , $ map , $ others ) ; $ object = new Quick Books _SQL _Object ( $ map [ 0 ] , trim ( Quick Books _Utilities : : action To XMLElement ( $ action ) ) ) ; $ table = $ object - > table ( ) ; $ existing = null ; if ( $ table and is _numeric ( $ ident ) ) { $ multipart = array ( QUICKBOOKS _DRIVER _SQL _FIELD _ID = > $ ident ) ; $ existing = $ Driver - > get ( QUICKBOOKS _DRIVER _SQL _PREFIX _SQL . $ table , $ multipart ) ; } switch ( $ errnum ) { case 1 : UPDATE " . QUICKBOOKS _DRIVER _SQL _PREFIX _SQL . "receivepayment _appliedtotxn SET qbsql _to _skip = 1 WHERE Receive Payment _Txn ID = ' %s ' " , $ db _errnum , $ db _errmsg , null , null , array ( $ existing [ 'Txn ID ' ] ) ) ; return true ; } break ; case 3 2 5 0 : / / This feature is not enabled or not available in this version of Quick Books . / / Do nothing (this can be safely ignored ) return true ; case 3 2 6 0 : / / Insufficient permission level to perform this action . case 3 2 6 1 : / / The integrated application has no permission to ac . . . / / There 's nothing we can do about this , if they don 't grant the user permission , just skip it return true ; case 3 1 0 0 : / / Name of List Element is already in use . break ; case ' 0x 8 0 0 4 0 4 0D ' : / / The ticket parameter is invalid (how does this happen ! ? ! ) return true ; } / / This is our catch -all which marks the item as errored out if ( strstr ( $ xml , 'status Severity = "Info " ' ) = = = false ) / / If it 's NOT just an Info message . { $ multipart = array ( QUICKBOOKS _DRIVER _SQL _FIELD _ID = > $ ident ) ; $ object - > set ( QUICKBOOKS _DRIVER _SQL _FIELD _ERROR _NUMBER , $ errnum ) ; $ object - > set ( QUICKBOOKS _DRIVER _SQL _FIELD _ERROR _MESSAGE , $ errmsg ) ; 
public function get Time Created ( $ format = null ) { if ( ! is _null ( $ format ) ) { return date ( $ format , strtotime ( $ this - > get ( 'Time Created ' ) ) ) ; } return $ this - > get ( 'Time Created ' ) ; } 
public function get Time Modified ( $ format = null ) { if ( ! is _null ( $ format ) ) { return date ( $ format , strtotime ( $ this - > get ( 'Time Modified ' ) ) ) ; } return $ this - > get ( 'Time Modified ' ) ; } 
public function set ( $ key , $ value , $ cast = true ) { if ( is _array ( $ value ) ) { $ this - > _object [ $ key ] = $ value ; } else { 
public function get ( $ key , $ default = null ) { if ( isset ( $ this - > _object [ $ key ] ) ) { return $ this - > _object [ $ key ] ; } return $ default ; } 
public function get Full Name Type ( $ fullname _key , $ name _key , $ parent _key , $ default = null ) { $ fullname = $ this - > get ( $ fullname _key ) ; if ( ! $ fullname ) { $ name = $ this - > get ( $ name _key ) ; $ parent = $ this - > get ( $ parent _key ) ; if ( $ name and $ parent ) { $ fullname = $ parent . ' : ' . $ name ; } else { $ fullname = $ name ; } } return $ fullname ; } 
public function set Full Name Type ( $ fullname _key , $ name _key , $ parent _key , $ value ) { if ( false ! = = strpos ( $ value , ' : ' ) ) { if ( $ name _key and $ parent _key ) { 
public function set Boolean Type ( $ key , $ value ) { 
public function set Date Type ( $ key , $ date , $ dont _allow _ 1 9 6 9 1 2 3 1 = true ) { if ( $ date = = ' 1 9 6 9 - 1 2 - 3 1 ' and $ dont _allow _ 1 9 6 9 1 2 3 1 ) { return false ; } if ( ! strlen ( $ date ) or $ date = = ' 0 ' ) { return false ; } 
public function get Date Type ( $ key , $ format = 'Y -m -d ' ) { if ( ! strlen ( $ format ) ) { $ format = 'Y -m -d ' ; } if ( $ this - > exists ( $ key ) and $ this - > get ( $ key ) ) { return date ( $ format , strtotime ( $ this - > get ( $ key ) ) ) ; } return null ; } 
public function remove ( $ key ) { if ( isset ( $ this - > _object [ $ key ] ) ) { unset ( $ this - > _object [ $ key ] ) ; return true ; } return false ; } 
protected function _schema ( $ request ) { if ( strtolower ( substr ( $ request , - 2 , 2 ) ) ! = 'rq ' ) { $ request = $ request . 'Rq ' ; } $ class = 'Quick Books _QBXML _Schema _Object _ ' . $ request ; $ file = 'Quick Books /QBXML /Schema /Object / ' . $ request . ' .php ' ; include _once $ file ; if ( class _exists ( $ class ) ) { return new $ class ( ) ; } return false ; } 
public function as XML ( $ root = null , $ parent = null , $ object = null ) { if ( is _null ( $ root ) ) { $ root = $ this - > object ( ) ; } if ( is _null ( $ object ) ) { $ object = $ this - > _object ; } $ Node = new Quick Books _XML _Node ( $ root ) ; foreach ( $ object as $ key = > $ value ) { if ( is _array ( $ value ) ) { $ Node - > set Child Data At ( $ root . ' ' . $ key , ' ' , true ) ; foreach ( $ value as $ sub ) { 
public function as QBXML ( $ request , $ version = null , $ locale = null , $ root = null ) { $ todo _for _empty _elements = Quick Books _XML : : XML _DROP ; $ indent = " \t " ; 
static public function from XML ( $ XML , $ action _or _object = null ) { if ( ! $ action _or _object or $ action _or _object = = QUICKBOOKS _QUERY _ITEM ) { $ action _or _object = $ XML - > name ( ) ; } $ type = Quick Books _Utilities : : action To Object ( $ action _or _object ) ; $ exceptions = array ( QUICKBOOKS _OBJECT _SERVICEITEM = > 'Service Item ' , QUICKBOOKS _OBJECT _INVENTORYITEM = > 'Inventory Item ' , QUICKBOOKS _OBJECT _NONINVENTORYITEM = > 'Non Inventory Item ' , QUICKBOOKS _OBJECT _DISCOUNTITEM = > 'Discount Item ' , QUICKBOOKS _OBJECT _FIXEDASSETITEM = > 'Fixed Asset Item ' , QUICKBOOKS _OBJECT _GROUPITEM = > 'Group Item ' , QUICKBOOKS _OBJECT _OTHERCHARGEITEM = > 'Other Charge Item ' , QUICKBOOKS _OBJECT _SALESTAXITEM = > 'Sales Tax Item ' , QUICKBOOKS _OBJECT _SALESTAXGROUPITEM = > 'Sales Tax Group Item ' , QUICKBOOKS _OBJECT _SUBTOTALITEM = > 'Subtotal Item ' , QUICKBOOKS _OBJECT _INVENTORYASSEMBLYITEM = > 'Inventory Assembly Item ' , ) ; if ( isset ( $ exceptions [ $ type ] ) ) { $ type = $ exceptions [ $ type ] ; } 
static public function from QBXML ( $ qbxml , $ action _or _object = null ) { $ errnum = null ; $ errmsg = null ; $ Parser = new Quick Books _XML _Parser ( $ qbxml ) ; if ( $ Doc = $ Parser - > parse ( $ errnum , $ errmsg ) ) { $ XML = $ Doc - > get Root ( ) ; return Quick Books _QBXML _Object : : from XML ( $ XML , $ action _or _object ) ; } return false ; } 
protected function _initialized ( ) { $ required = array ( SELECT table _name AS name FROM INFORMATION _SCHEMA .Tables WHERE TABLE _TYPE = 'BASE TABLE ' " , $ errnum , $ errmsg ) ; while ( $ arr = $ this - > _fetch ( $ res ) ) { $ table = current ( $ arr ) ; if ( isset ( $ required [ $ table ] ) ) { $ required [ $ table ] = true ; } } foreach ( $ required as $ table = > $ exists ) { if ( ! $ exists ) { return false ; } } return true ; } 
protected function _connect ( $ host , $ port , $ user , $ pass , $ db , $ new _link , $ client _flags ) { mssql _min _message _severity ( QUICKBOOKS _DRIVER _SQL _MSSQL _MESSAGE _LEVEL ) ; mssql _min _error _severity ( QUICKBOOKS _DRIVER _SQL _MSSQL _ERROR _LEVEL ) ; if ( $ port ) { $ this - > _conn = mssql _connect ( $ host , $ user , $ pass , $ new _link ) or die ( 'host : ' . $ host . ' , user : ' . $ user . ' , pass : ' . $ pass . ' mysql _error ( ) : ' . mssql _get _last _message ( ) ) ; } else { $ this - > _conn = mssql _connect ( $ host . ' : ' . $ port , $ user , $ pass , $ new _link ) or die ( 'host : ' . $ host . ' , user : ' . $ user . ' , pass : ' . $ pass . ' mysql _error ( ) : ' . mssql _get _last _message ( ) ) ; } return mssql _select _db ( $ db , $ this - > _conn ) ; } 
protected function _fetch ( $ res ) { $ arr = mssql _fetch _assoc ( $ res ) ; 
protected function _query ( $ sql , & $ errnum , & $ errmsg , $ offset = 0 , $ limit = null ) { if ( $ limit ) { $ sql = str _replace ( array ( "SELECT " , "SELECT \n " , "SELECT \r " ) , 'SELECT TOP ' . ( int ) $ limit . ' ' . " \n " , $ sql ) ; if ( $ offset ) { } else { } } else if ( $ offset ) { 
public function last ( ) { $ errnum = 0 ; $ errmsg = null ; if ( $ res = $ this - > _query ( "SELECT SCOPE _IDENTITY ( ) AS last _insert _id " ) ) { $ arr = $ this - > _fetch ( $ res ) ; return $ arr [ 'last _insert _id ' ] ; } return 0 ; } 
protected function _generate Field Schema ( $ name , $ def ) { $ sql = ' ' ; switch ( $ def [ 0 ] ) { case QUICKBOOKS _DRIVER _SQL _SERIAL : $ sql = $ name . ' integer NOT NULL IDENTITY ( 1 , 1 ) ' ; { print ( 'LIST ID : ' ) ; print _r ( $def ) ; } * / if ( ! empty ( $ def [ 1 ] ) ) { $ sql . = ' ( ' . ( int ) $ def [ 1 ] . ' ) ' ; } if ( isset ( $ def [ 2 ] ) ) { if ( strtolower ( $ def [ 2 ] ) = = 'null ' ) { $ sql . = ' NULL ' ; } else if ( $ def [ 2 ] = = = false ) { $ sql . = ' NOT NULL ' ; } else { $ sql . = " NOT NULL DEFAULT ' " . $ def [ 2 ] . " ' " ; } } else { $ sql . = ' NOT NULL ' ; } return $ sql ; case QUICKBOOKS _DRIVER _SQL _CHAR : $ sql = $ name . ' CHAR ' ; if ( ! empty ( $ def [ 1 ] ) ) { $ sql . = ' ( ' . ( int ) $ def [ 1 ] . ' ) ' ; } if ( isset ( $ def [ 2 ] ) ) { if ( strtolower ( $ def [ 2 ] ) = = 'null ' ) { $ sql . = ' NULL ' ; } else { $ sql . = " NOT NULL DEFAULT ' " . $ def [ 2 ] . " ' " ; } } else { $ sql . = ' NOT NULL ' ; } return $ sql ; case QUICKBOOKS _DRIVER _SQL _TEXT : $ sql = $ name . ' TEXT ' ; if ( isset ( $ def [ 2 ] ) ) { if ( strtolower ( $ def [ 2 ] ) = = 'null ' ) { $ sql . = ' NULL ' ; } else { $ sql . = " NOT NULL DEFAULT ' " . $ def [ 2 ] . " ' " ; } } else { $ sql . = ' NOT NULL ' ; } return $ sql ; case QUICKBOOKS _DRIVER _SQL _INTEGER : $ sql = $ name . ' INTEGER ' ; if ( isset ( $ def [ 2 ] ) ) { if ( strtolower ( $ def [ 2 ] ) = = 'null ' ) { $ sql . = ' NULL ' ; } else { $ sql . = ' DEFAULT ' . ( int ) $ def [ 2 ] ; } } return $ sql ; case QUICKBOOKS _DRIVER _SQL _BOOLEAN : $ sql = $ name . ' tinyint ' ; if ( isset ( $ def [ 2 ] ) ) { if ( strtolower ( $ def [ 2 ] ) = = 'null ' ) { $ sql . = ' NULL ' ; } else if ( $ def [ 2 ] ) { $ sql . = ' DEFAULT 1 ' ; } else { $ sql . = ' DEFAULT 0 ' ; } } return $ sql ; default : return parent : : _generate Field Schema ( $ name , $ def ) ; } } 
protected function _map Table Name ( $ table ) { switch ( $ table ) { case QUICKBOOKS _DRIVER _SQL _LOGTABLE : return QUICKBOOKS _DRIVER _SQL _MSSQL _PREFIX . QUICKBOOKS _DRIVER _SQL _MSSQL _LOGTABLE ; case QUICKBOOKS _DRIVER _SQL _QUEUETABLE : return QUICKBOOKS _DRIVER _SQL _MSSQL _PREFIX . QUICKBOOKS _DRIVER _SQL _MSSQL _QUEUETABLE ; case QUICKBOOKS _DRIVER _SQL _RECURTABLE : return QUICKBOOKS _DRIVER _SQL _MSSQL _PREFIX . QUICKBOOKS _DRIVER _SQL _MSSQL _RECURTABLE ; case QUICKBOOKS _DRIVER _SQL _TICKETTABLE : return QUICKBOOKS _DRIVER _SQL _MSSQL _PREFIX . QUICKBOOKS _DRIVER _SQL _MSSQL _TICKETTABLE ; case QUICKBOOKS _DRIVER _SQL _USERTABLE : return QUICKBOOKS _DRIVER _SQL _MSSQL _PREFIX . QUICKBOOKS _DRIVER _SQL _MSSQL _USERTABLE ; case QUICKBOOKS _DRIVER _SQL _CONFIGTABLE : return QUICKBOOKS _DRIVER _SQL _MSSQL _PREFIX . QUICKBOOKS _DRIVER _SQL _MSSQL _CONFIGTABLE ; case QUICKBOOKS _DRIVER _SQL _IDENTTABLE : return QUICKBOOKS _DRIVER _SQL _MSSQL _PREFIX . QUICKBOOKS _DRIVER _SQL _MSSQL _IDENTTABLE ; case QUICKBOOKS _DRIVER _SQL _NOTIFYTABLE : return QUICKBOOKS _DRIVER _SQL _MSSQL _PREFIX . QUICKBOOKS _DRIVER _SQL _MSSQL _NOTIFYTABLE ; case QUICKBOOKS _DRIVER _SQL _CONNECTIONTABLE : return QUICKBOOKS _DRIVER _SQL _MSSQL _PREFIX . QUICKBOOKS _DRIVER _SQL _MSSQL _CONNECTIONTABLE ; case QUICKBOOKS _DRIVER _SQL _OAUTHTABLE : return QUICKBOOKS _DRIVER _SQL _MSSQL _PREFIX . QUICKBOOKS _DRIVER _SQL _MSSQL _OAUTHTABLE ; default : return $ table ; } } 
public function as List ( $ request ) { switch ( $ request ) { case 'Receive Payment Add Rq ' : if ( isset ( $ this - > _object [ 'Applied To Txn ' ] ) ) { $ this - > _object [ 'Applied To Txn Add ' ] = $ this - > _object [ 'Applied To Txn ' ] ; } break ; case 'Receive Payment Mod Rq ' : if ( isset ( $ this - > _object [ 'Applied To Txn ' ] ) ) { $ this - > _object [ 'Applied To Txn Mod ' ] = $ this - > _object [ 'Applied To Txn ' ] ; } break ; } return parent : : as List ( $ request ) ; } 
public function add ( $ Context , $ realm ID , $ Object ) { return parent : : _add ( $ Context , $ realm ID , Quick Books _IPP _IDS : : RESOURCE _DEPARTMENT , $ Object ) ; } 
public function get Name ( ) { if ( ! $ this - > exists ( 'Name ' ) ) { if ( ! is _null ( $ this - > get First Name ( ) ) | | ! is _null ( $ this - > get Last Name ( ) ) ) { $ this - > set Name As First Last ( ) ; } } return $ this - > get ( 'Name ' ) ; } 
public function set Full Name ( $ name ) { if ( is _null ( $ name ) ) { $ name = $ this - > get Name ( ) ; } $ this - > set ( 'Full Name ' , $ name ) ; } 
public function set Name As First Last ( ) { $ first = $ this - > get First Name ( ) ; $ last = $ this - > get Last Name ( ) ; if ( is _null ( $ first ) ) { $ first = ' ' ; } if ( is _null ( $ last ) ) { $ last = ' ' ; } return $ this - > set ( 'Name ' , $ first . ' ' . $ last ) ; } 
public function add ( $ Context , $ realm ID , $ Object ) { return parent : : _add ( $ Context , $ realm ID , Quick Books _IPP _IDS : : RESOURCE _ITEMCONSOLIDATED , $ Object ) ; } 
public function set Override Item Account Application ID ( $ value ) { return $ this - > set ( 'Override Item Account Ref ' . QUICKBOOKS _API _APPLICATIONID , $ this - > encode Application ID ( QUICKBOOKS _OBJECT _OVERRIDEITEMACCOUNT , QUICKBOOKS _LISTID , $ value ) ) ; } 
protected function _sql Defaults ( $ config ) { $ tmp = array ( 
public function set Payee Entity Application ID ( $ value ) { return $ this - > set ( 'Payee Entity Ref ' . QUICKBOOKS _API _APPLICATIONID , $ this - > encode Application ID ( QUICKBOOKS _OBJECT _VENDOR , QUICKBOOKS _LISTID , $ value ) ) ; } 
public function status ( $ user = null , $ levels = array ( ) ) { $ Driver = $ this - > _driver ; if ( ! $ user ) { $ user = $ Driver - > auth Default ( ) ; } if ( ! count ( $ levels ) ) { $ levels = array ( 6 0 * 6 0 * 1 2 = > array ( Quick Books _Status _Report : : STATUS _NOTICE , 'Notice : A connection has not been made in %d days , %d hours and %d minutes . ' ) , 6 0 * 6 0 * 2 4 = > array ( Quick Books _Status _Report : : STATUS _CAUTION , 'Caution : A connection has not been made in %d days , %d hours and %d minutes . ' ) , 6 0 * 6 0 * 3 6 = > array ( Quick Books _Status _Report : : STATUS _WARNING , 'Warning ! A connection has not been made in %d days , %d hours and %d minutes . ' ) , 6 0 * 6 0 * 4 8 = > array ( Quick Books _Status _Report : : STATUS _DANGER , 'DANGER ! A connection has not been made in %d days , %d hours and %d minutes ! Contact support to get this issue resolved ! ' ) , ) ; } if ( ! isset ( $ levels [ 0 ] ) ) { $ levels [ 0 ] = array ( Quick Books _Status _Report : : STATUS _OK , 'Status is OK . Last connection made %d days , %d hours , and %d minutes ago . ' ) ; } if ( ! isset ( $ levels [ - 1 ] ) ) { $ levels [ - 1 ] = array ( Quick Books _Status _Report : : STATUS _UNKNOWN , 'Status is unknown . ' ) ; } 
public function delete ( $ Context , $ realm ID , $ IDType ) { return parent : : _delete ( $ Context , $ realm ID , Quick Books _IPP _IDS : : RESOURCE _PURCHASEORDER , $ IDType ) ; } 
protected function _read ( $ mixed ) { if ( empty ( $ mixed ) ) { return ' ' ; } else if ( is _resource ( $ mixed ) and get _resource _type ( $ mixed ) = = 'stream ' ) { $ buffer = ' ' ; $ tmp = ' ' ; while ( $ tmp = fread ( $ mixed , 8 1 9 2 ) ) { $ buffer . = $ tmp ; } return $ buffer ; } else if ( substr ( trim ( $ mixed ) , 0 , 6 ) = = ' { "warn ' ) { 
public function load ( $ xml _or _file ) { $ xml _or _file = $ this - > _read ( $ xml _or _file ) ; $ this - > _xml = $ xml _or _file ; return $ this - > _backend - > load ( $ xml _or _file ) ; } 
public function parse ( & $ errnum , & $ errmsg ) { if ( ! strlen ( $ this - > _xml ) ) { $ errnum = Quick Books _XML : : ERROR _CONTENT ; $ errmsg = 'No XML content to parse . ' ; return false ; } 
public function as QBXML ( $ request , $ version = null , $ locale = null , $ root = null ) { return parent : : as QBXML ( $ request , $ version , $ locale , $ root ) ; } 
protected function _connect ( $ host , $ port , $ user , $ pass , $ db , $ new _link , $ client _flags = null ) { $ this - > _schema = null ; $ tmp = array ( ) ; if ( $ host ) { $ tmp [ ] = 'host = ' . $ host ; } if ( ( int ) $ port ) { $ tmp [ ] = 'port = ' . ( int ) $ port ; } if ( $ user ) { $ tmp [ ] = 'user = ' . $ user ; } if ( $ pass ) { $ tmp [ ] = 'password = ' . $ pass ; } if ( $ db ) { if ( false ! = = strpos ( $ db , ' . ' ) ) { $ explode = explode ( ' . ' , $ db ) ; 
protected function _fetch ( $ res , $ print = false ) { $ arr = pg _fetch _assoc ( $ res ) ; $ booleans = array ( QUICKBOOKS _DRIVER _SQL _FIELD _TO _SYNC , QUICKBOOKS _DRIVER _SQL _FIELD _TO _VOID , QUICKBOOKS _DRIVER _SQL _FIELD _TO _DELETE , QUICKBOOKS _DRIVER _SQL _FIELD _TO _SKIP , QUICKBOOKS _DRIVER _SQL _FIELD _FLAG _SKIPPED , QUICKBOOKS _DRIVER _SQL _FIELD _FLAG _DELETED , QUICKBOOKS _DRIVER _SQL _FIELD _FLAG _VOIDED ) ; if ( $ arr ) { foreach ( $ arr as $ key = > $ value ) { if ( in _array ( $ key , $ booleans ) ) { if ( $ value = = 'f ' ) { $ value = false ; } else if ( $ value = = 't ' ) { $ value = true ; } else { $ value = null ; } $ arr [ $ key ] = $ value ; } } } if ( is _array ( $ arr ) ) { reset ( $ arr ) ; } return $ arr ; } 
protected function _query ( $ sql , & $ errnum , & $ errmsg , $ offset = 0 , $ limit = null ) { if ( strtoupper ( substr ( trim ( $ sql ) , 0 , 6 ) ) ! = 'UPDATE ' ) { 
public function last ( ) { $ errnum = 0 ; $ errmsg = ' ' ; pg _attribute .attname , format _type (pg _attribute .atttypid , pg _attribute .atttypmod ) FROM pg _index , pg _class , pg _attribute WHERE pg _class .oid = ' " . $ this - > last _insert _table . " ' : :regclass AND indrelid = pg _class .oid AND pg _attribute .attrelid = pg _class .oid AND pg _attribute .attnum = any (pg _index .indkey ) AND indisprimary " ; $ res = $ this - > query ( $ sql , $ errnum , $ errmsg ) ; $ sequence = pg _fetch _result ( $ res , 0 , 0 ) ; / / get the last ID $ sql = "select currval (pg _get _serial _sequence ( ' " . $ this - > last _insert _table . " ' , ' " . $ sequence . " ' ) ) ; " ; $ res = $ this - > query ( $ sql , $ errnum , $ errmsg ) ; $ last _insert _id = pg _fetch _result ( $ res , 0 , 0 ) ; return $ last _insert _id ; } 
protected function _map Table Name ( $ table ) { switch ( $ table ) { case QUICKBOOKS _DRIVER _SQL _LOGTABLE : return QUICKBOOKS _DRIVER _SQL _PGSQL _PREFIX . QUICKBOOKS _DRIVER _SQL _PGSQL _LOGTABLE ; case QUICKBOOKS _DRIVER _SQL _QUEUETABLE : return QUICKBOOKS _DRIVER _SQL _PGSQL _PREFIX . QUICKBOOKS _DRIVER _SQL _PGSQL _QUEUETABLE ; case QUICKBOOKS _DRIVER _SQL _RECURTABLE : return QUICKBOOKS _DRIVER _SQL _PGSQL _PREFIX . QUICKBOOKS _DRIVER _SQL _PGSQL _RECURTABLE ; case QUICKBOOKS _DRIVER _SQL _TICKETTABLE : return QUICKBOOKS _DRIVER _SQL _PGSQL _PREFIX . QUICKBOOKS _DRIVER _SQL _PGSQL _TICKETTABLE ; case QUICKBOOKS _DRIVER _SQL _USERTABLE : return QUICKBOOKS _DRIVER _SQL _PGSQL _PREFIX . QUICKBOOKS _DRIVER _SQL _PGSQL _USERTABLE ; case QUICKBOOKS _DRIVER _SQL _CONFIGTABLE : return QUICKBOOKS _DRIVER _SQL _PGSQL _PREFIX . QUICKBOOKS _DRIVER _SQL _PGSQL _CONFIGTABLE ; case QUICKBOOKS _DRIVER _SQL _IDENTTABLE : return QUICKBOOKS _DRIVER _SQL _PGSQL _PREFIX . QUICKBOOKS _DRIVER _SQL _PGSQL _IDENTTABLE ; case QUICKBOOKS _DRIVER _SQL _NOTIFYTABLE : return QUICKBOOKS _DRIVER _SQL _PGSQL _PREFIX . QUICKBOOKS _DRIVER _SQL _PGSQL _NOTIFYTABLE ; case QUICKBOOKS _DRIVER _SQL _CONNECTIONTABLE : return QUICKBOOKS _DRIVER _SQL _PGSQL _PREFIX . QUICKBOOKS _DRIVER _SQL _PGSQL _CONNECTIONTABLE ; default : return QUICKBOOKS _DRIVER _SQL _PGSQL _PREFIX . $ table ; } } 
protected function _generate Field Schema ( $ name , $ def ) { switch ( $ def [ 0 ] ) { case QUICKBOOKS _DRIVER _SQL _INTEGER : $ sql = ' " ' . $ name . ' " INTEGER ' ; if ( isset ( $ def [ 2 ] ) ) { if ( strtolower ( $ def [ 2 ] ) = = 'null ' ) { $ sql . = ' DEFAULT NULL ' ; } else { $ sql . = ' DEFAULT ' . ( int ) $ def [ 2 ] ; } } break ; case QUICKBOOKS _DRIVER _SQL _DECIMAL : $ sql = ' " ' . $ name . ' " DECIMAL ' ; if ( ! empty ( $ def [ 1 ] ) ) { $ tmp = explode ( ' , ' , $ def [ 1 ] ) ; if ( count ( $ tmp ) = = 2 ) { $ sql . = ' ( ' . ( int ) $ tmp [ 0 ] . ' , ' . ( int ) $ tmp [ 1 ] . ' ) ' ; } } if ( isset ( $ def [ 2 ] ) ) { if ( strtolower ( $ def [ 2 ] ) = = 'null ' ) { $ sql . = ' NULL ' ; } else { if ( isset ( $ tmp ) and count ( $ tmp ) = = 2 ) { $ sql . = ' DEFAULT ' . sprintf ( ' % 0 1 . ' . ( int ) $ tmp [ 1 ] . 'f ' , ( float ) $ def [ 2 ] ) ; } else { $ sql . = ' DEFAULT ' . sprintf ( ' % 0 1 . 2f ' , ( float ) $ def [ 2 ] ) ; } } } if ( isset ( $ tmp ) ) { unset ( $ tmp ) ; } break ; case QUICKBOOKS _DRIVER _SQL _FLOAT : $ sql = ' " ' . $ name . ' " FLOAT ' ; if ( isset ( $ def [ 2 ] ) ) { if ( strtolower ( $ def [ 2 ] ) = = 'null ' ) { $ sql . = ' NULL ' ; } else { $ sql . = ' DEFAULT ' . sprintf ( ' % 0 1 . 2f ' , ( float ) $ def [ 2 ] ) ; } } break ; case QUICKBOOKS _DRIVER _SQL _BOOLEAN : $ sql = ' " ' . $ name . ' " BOOLEAN ' ; if ( isset ( $ def [ 2 ] ) ) { if ( strtolower ( $ def [ 2 ] ) = = 'null ' ) { $ sql . = ' DEFAULT NULL ' ; } else if ( $ def [ 2 ] ) { $ sql . = ' DEFAULT TRUE ' ; } else { $ sql . = ' DEFAULT FALSE ' ; } } else { $ sql . = ' NOT NULL ' ; } break ; case QUICKBOOKS _DRIVER _SQL _SERIAL : $ sql = ' " ' . $ name . ' " SERIAL NOT NULL ' ; $sql = $name . ' tinyint ( 1 ) ' ; if (isset ( $def [ 2 ] ) ) { if (strtolower ( $def [ 2 ] ) = = 'null ' ) { $sql . = ' DEFAULT NULL ' ; } else if ( $def [ 2 ] ) { $sql . = ' DEFAULT 1 ' ; } else { $sql . = ' DEFAULT 0 ' ; } } return $sql ; * / case QUICKBOOKS _DRIVER _SQL _VARCHAR : $ sql = ' " ' . $ name . ' " VARCHAR ' ; if ( ! empty ( $ def [ 1 ] ) ) { $ sql . = ' ( ' . ( int ) $ def [ 1 ] . ' ) ' ; } if ( isset ( $ def [ 2 ] ) ) { if ( strtolower ( $ def [ 2 ] ) = = 'null ' ) { $ sql . = ' DEFAULT NULL ' ; } else if ( $ def [ 2 ] = = = false ) { $ sql . = ' NOT NULL ' ; } else { $ sql . = " NOT NULL DEFAULT ' " . $ def [ 2 ] . " ' " ; } } else { $ sql . = ' NOT NULL ' ; } break ; case QUICKBOOKS _DRIVER _SQL _CHAR : $ sql = ' " ' . $ name . ' " CHAR ' ; if ( ! empty ( $ def [ 1 ] ) ) { $ sql . = ' ( ' . ( int ) $ def [ 1 ] . ' ) ' ; } if ( isset ( $ def [ 2 ] ) ) { if ( strtolower ( $ def [ 2 ] ) = = 'null ' ) { $ sql . = ' DEFAULT NULL ' ; } else { $ sql . = " NOT NULL DEFAULT ' " . $ def [ 2 ] . " ' " ; } } else { $ sql . = ' NOT NULL ' ; } break ; default : case QUICKBOOKS _DRIVER _SQL _TEXT : $ sql = ' " ' . $ name . ' " TEXT ' ; if ( isset ( $ def [ 2 ] ) ) { if ( strtolower ( $ def [ 2 ] ) = = 'null ' ) { $ sql . = ' DEFAULT NULL ' ; } else { $ sql . = " NOT NULL DEFAULT ' " . $ def [ 2 ] . " ' " ; } } else { $ sql . = ' NOT NULL ' ; } break ; } return $ sql ; } 
public function insert ( $ table , $ object , $ discov _and _resync = true ) { $ this - > last _insert _table = $ table ; return parent : : insert ( $ table , $ object , $ discov _and _resync ) ; } 
public function encrypt ( $ key , $ data , $ hex = false ) { if ( $ hex ) { $ key = pack ( 'H * ' , $ key ) ; } $ keys [ ] = ' ' ; $ boxs [ ] = ' ' ; $ cipher = ' ' ; $ key _length = strlen ( $ key ) ; $ data _length = strlen ( $ data ) ; for ( $ i = 0 ; $ i < 2 5 6 ; $ i + + ) { $ keys [ $ i ] = ord ( $ key [ $ i % $ key _length ] ) ; $ boxs [ $ i ] = $ i ; } $ j = 0 ; for ( $ i = 0 ; $ i < 2 5 6 ; $ i + + ) { $ j = ( $ j + $ boxs [ $ i ] + $ keys [ $ i ] ) % 2 5 6 ; $ tmp = $ boxs [ $ i ] ; $ boxs [ $ i ] = $ boxs [ $ j ] ; $ boxs [ $ j ] = $ tmp ; } $ a = 0 ; $ j = 0 ; for ( $ i = 0 ; $ i < $ data _length ; $ i + + ) { $ a = ( $ a + 1 ) % 2 5 6 ; $ j = ( $ j + $ boxs [ $ a ] ) % 2 5 6 ; $ tmp = $ boxs [ $ a ] ; $ boxs [ $ a ] = $ boxs [ $ j ] ; $ boxs [ $ j ] = $ tmp ; $ k = $ boxs [ ( ( $ boxs [ $ a ] + $ boxs [ $ j ] ) % 2 5 6 ) ] ; $ cipher . = chr ( ord ( $ data [ $ i ] ) ^ $ k ) ; } return $ cipher ; } 
public function delete ( $ Context , $ realm ID , $ IDType ) { return parent : : _delete ( $ Context , $ realm ID , Quick Books _IPP _IDS : : RESOURCE _TIMEACTIVITY , $ IDType ) ; } 
static public function e 1 _notfound ( $ request ID , $ user , $ action , $ ident , $ extra , & $ err , $ xml , $ errnum , $ errmsg , $ config ) { return Quick Books _Callbacks _API _Errors : : e 5 0 0 _notfound ( $ request ID , $ user , $ action , $ ident , $ extra , $ err , $ xml , $ errnum , $ errmsg , $ config ) ; } 
static public function e 5 0 0 _notfound ( $ request ID , $ user , $ action , $ ident , $ extra , & $ err , $ xml , $ errnum , $ errmsg , $ config ) { $extra [ 'callbacks ' ] , $method , $action , $ID , $err , $qbxml , $qbobject , $qbres * / 
protected function _ticket Resolve ( $ ticket ) { static $ cache = array ( ) ; if ( ! $ ticket ) { return 0 ; } $ errnum = 0 ; $ errmsg = ' ' ; if ( isset ( $ cache [ $ ticket ] ) ) { return $ cache [ $ ticket ] ; } else if ( $ arr = $ this - > _fetch ( $ this - > _query ( " SELECT quickbooks _ticket _id FROM " . $ this - > _map Table Name ( QUICKBOOKS _DRIVER _SQL _TICKETTABLE ) . " WHERE ticket = ' " . $ this - > _escape ( $ ticket ) . " ' " , $ errnum , $ errmsg , 0 , 1 ) ) ) { $ cache [ $ ticket ] = $ arr [ 'quickbooks _ticket _id ' ] ; return $ arr [ 'quickbooks _ticket _id ' ] ; } return 0 ; } 
protected function _config Write ( $ user , $ module , $ key , $ value , $ type , $ opts ) { $ errnum = 0 ; $ errmsg = ' ' ; if ( $ arr = $ this - > _fetch ( $ this - > _query ( " SELECT quickbooks _config _id FROM " . $ this - > _map Table Name ( QUICKBOOKS _DRIVER _SQL _CONFIGTABLE ) . " WHERE qb _username = ' " . $ this - > _escape ( $ user ) . " ' AND module = ' " . $ this - > _escape ( $ module ) . " ' AND cfgkey = ' " . $ this - > _escape ( $ key ) . " ' " , $ errnum , $ errmsg , 0 , 1 ) ) ) { $ this - > _query ( " UPDATE " . $ this - > _map Table Name ( QUICKBOOKS _DRIVER _SQL _CONFIGTABLE ) . " SET cfgval = ' " . $ this - > _escape ( $ value ) . " ' , mod _datetime = ' " . date ( 'Y -m -d H :i :s ' ) . " ' WHERE quickbooks _config _id = " . $ arr [ 'quickbooks _config _id ' ] , $ errnum , $ errmsg ) ; } else { return $ this - > _query ( " INSERT INTO " . $ this - > _map Table Name ( QUICKBOOKS _DRIVER _SQL _CONFIGTABLE ) . " ( qb _username , module , cfgkey , cfgval , cfgtype , cfgopts , write _datetime , mod _datetime ) VALUES ( ' " . $ this - > _escape ( $ user ) . " ' , ' " . $ this - > _escape ( $ module ) . " ' , ' " . $ this - > _escape ( $ key ) . " ' , ' " . $ this - > _escape ( $ value ) . " ' , ' " . $ this - > _escape ( $ type ) . " ' , ' " . $ this - > _escape ( serialize ( $ opts ) ) . " ' , ' " . date ( 'Y -m -d H :i :s ' ) . " ' , ' " . date ( 'Y -m -d H :i :s ' ) . " ' ) " , $ errnum , $ errmsg ) ; } } 
protected function _config Read ( $ user , $ module , $ key , & $ type , & $ opts ) { $ errnum = 0 ; $ errmsg = ' ' ; $ sql = " SELECT cfgval , cfgtype , cfgopts FROM " . $ this - > _map Table Name ( QUICKBOOKS _DRIVER _SQL _CONFIGTABLE ) . " WHERE qb _username = ' " . $ this - > _escape ( $ user ) . " ' AND module = ' " . $ this - > _escape ( $ module ) . " ' AND cfgkey = ' " . $ this - > _escape ( $ key ) . " ' " ; 
protected function _auth Create ( $ username , $ password , $ company _file = null , $ wait _before _next _update = null , $ min _run _every _n _seconds = null ) { $ errnum = 0 ; $ errmsg = ' ' ; if ( ! $ this - > _count ( $ this - > _query ( "SELECT qb _username FROM " . $ this - > _map Table Name ( QUICKBOOKS _DRIVER _SQL _USERTABLE ) . " WHERE qb _username = ' " . $ this - > _escape ( $ username ) . " ' " , $ errnum , $ errmsg , 0 , 1 ) ) ) { return $ this - > _query ( " INSERT INTO " . $ this - > _map Table Name ( QUICKBOOKS _DRIVER _SQL _USERTABLE ) . " ( qb _username , qb _password , qb _company _file , qbwc _wait _before _next _update , qbwc _min _run _every _n _seconds , status , write _datetime , touch _datetime ) VALUES ( ' " . $ this - > _escape ( $ username ) . " ' , ' " . $ this - > _escape ( $ this - > _hash ( $ password ) ) . " ' , ' " . $ this - > _escape ( $ company _file ) . " ' , " . ( int ) $ wait _before _next _update . " , " . ( int ) $ min _run _every _n _seconds . " , ' " . QUICKBOOKS _USER _ENABLED . " ' , ' " . date ( 'Y -m -d H :i :s ' ) . " ' , ' " . date ( 'Y -m -d H :i :s ' ) . " ' ) " , $ errnum , $ errmsg ) ; } return false ; } 
protected function _auth Enable ( $ username ) { $ errnum = 0 ; $ errmsg = ' ' ; return $ this - > _query ( " UPDATE " . $ this - > _map Table Name ( QUICKBOOKS _DRIVER _SQL _USERTABLE ) . " SET status = ' " . QUICKBOOKS _USER _ENABLED . " ' , touch _datetime = ' " . date ( 'Y -m -d H :i :s ' ) . " ' WHERE qb _username = ' " . $ this - > _escape ( $ username ) . " ' " ) ; } 
protected function _auth Disable ( $ username ) { $ errnum = 0 ; $ errmsg = ' ' ; return $ this - > _query ( " UPDATE " . $ this - > _map Table Name ( QUICKBOOKS _DRIVER _SQL _USERTABLE ) . " SET status = ' " . QUICKBOOKS _USER _DISABLED . " ' , touch _datetime = ' " . date ( 'Y -m -d H :i :s ' ) . " ' WHERE qb _username = ' " . $ this - > _escape ( $ username ) . " ' " ) ; } 
protected function _auth Default ( ) { $ errnum = 0 ; $ errmsg = ' ' ; if ( $ arr = $ this - > _fetch ( $ this - > _query ( " SELECT qb _username FROM " . $ this - > _map Table Name ( QUICKBOOKS _DRIVER _SQL _USERTABLE ) . " WHERE status = ' " . QUICKBOOKS _USER _ENABLED . " ' " , $ errnum , $ errmsg , 0 , 1 ) ) ) { return $ arr [ 'qb _username ' ] ; } return ' ' ; } 
protected function _auth Last ( $ username ) { $ errnum = 0 ; $ errmsg = ' ' ; if ( $ arr = $ this - > _fetch ( $ this - > _query ( " SELECT write _datetime , touch _datetime FROM " . $ this - > _map Table Name ( QUICKBOOKS _DRIVER _SQL _TICKETTABLE ) . " WHERE qb _username = ' " . $ this - > _escape ( $ username ) . " ' ORDER BY quickbooks _ticket _id DESC " , $ errnum , $ errmsg , 0 , 1 ) ) ) { return array ( $ arr [ 'write _datetime ' ] , $ arr [ 'touch _datetime ' ] , ) ; } return null ; } 
protected function _auth Login ( $ username , $ password , & $ company _file , & $ wait _before _next _update , & $ min _run _every _n _seconds , $ override = false ) { $ errnum = 0 ; $ errmsg = ' ' ; if ( $ override ) SELECT * FROM " . $ this - > _map Table Name ( QUICKBOOKS _DRIVER _SQL _USERTABLE ) . " WHERE qb _username = ' " . $ this - > _escape ( $ username ) . " ' AND ( qb _password = ' " . $ this - > _escape ( $ this - > _hash ( $ password ) ) . " ' OR qb _password = ' " . $ this - > _escape ( $ plain _text ) . " ' OR qb _password = ' " . $ this - > _escape ( $ plain _md 5 ) . " ' OR qb _password = ' " . $ this - > _escape ( $ plain _sha 1 ) . " ' ) AND status = ' " . QUICKBOOKS _USER _ENABLED . " ' " , $ errnum , $ errmsg , 0 , 1 ) ) ) { / / $ticket = md 5 ( (string ) microtime ( ) . $username . $this - > _map Table Name (QUICKBOOKS _DRIVER _SQL _SALT ) ) ; $ ticket = Quick Books _Web Connector _QWC : : GUID ( false ) ; $ this - > _query ( " INSERT INTO " . $ this - > _map Table Name ( QUICKBOOKS _DRIVER _SQL _TICKETTABLE ) . " ( qb _username , ticket , ipaddr , write _datetime , touch _datetime ) VALUES ( ' " . $ this - > _escape ( $ username ) . " ' , ' " . $ this - > _escape ( $ ticket ) . " ' , ' " . $ _SERVER [ 'REMOTE _ADDR ' ] . " ' , ' " . date ( 'Y -m -d H :i :s ' ) . " ' , ' " . date ( 'Y -m -d H :i :s ' ) . " ' ) " , $ errnum , $ errmsg ) ; $ this - > _query ( " UPDATE " . $ this - > _map Table Name ( QUICKBOOKS _DRIVER _SQL _USERTABLE ) . " SET touch _datetime = ' " . date ( 'Y -m -d H :i :s ' ) . " ' WHERE qb _username = ' " . $ this - > _escape ( $ username ) . " ' " , $ errnum , $ errmsg ) ; if ( isset ( $ arr ) and is _array ( $ arr ) ) 
protected function _auth Check ( $ ticket ) { $ errnum = 0 ; $ errmsg = ' ' ; if ( $ arr = $ this - > _fetch ( $ this - > _query ( " SELECT quickbooks _ticket _id FROM " . $ this - > _map Table Name ( QUICKBOOKS _DRIVER _SQL _TICKETTABLE ) . " WHERE ticket = ' " . $ this - > _escape ( $ ticket ) . " ' AND touch _datetime > ' " . date ( 'Y -m -d H :i :s ' , time ( ) - QUICKBOOKS _TIMEOUT ) . " ' " , $ errnum , $ errmsg , 0 , 1 ) ) ) { $ this - > _query ( " UPDATE " . $ this - > _map Table Name ( QUICKBOOKS _DRIVER _SQL _TICKETTABLE ) . " SET touch _datetime = ' " . date ( 'Y -m -d H :i :s ' ) . " ' WHERE quickbooks _ticket _id = " . $ arr [ 'quickbooks _ticket _id ' ] , $ errnum , $ errmsg ) ; return true ; } return false ; } 
protected function _error Log ( $ ticket , $ errnum , $ errmsg ) { if ( $ ticket _id = $ this - > _ticket Resolve ( $ ticket ) ) { $ db _errnum = 0 ; $ db _errmsg = ' ' ; return $ this - > _query ( " UPDATE " . $ this - > _map Table Name ( QUICKBOOKS _DRIVER _SQL _TICKETTABLE ) . " SET lasterror _num = ' " . $ this - > _escape ( $ errnum ) . " ' , lasterror _msg = ' " . $ this - > _escape ( substr ( $ errmsg , 0 , 2 5 5 ) ) . " ' WHERE quickbooks _ticket _id = " . ( int ) $ ticket _id , $ db _errnum , $ db _errmsg ) ; } return false ; } 
protected function _error Last ( $ ticket ) { $ errnum = 0 ; $ errmsg = ' ' ; if ( $ ticket _id = $ this - > _ticket Resolve ( $ ticket ) ) { if ( $ arr = $ this - > _fetch ( $ this - > _query ( "SELECT lasterror _num , lasterror _msg FROM " . $ this - > _map Table Name ( QUICKBOOKS _DRIVER _SQL _TICKETTABLE ) . " WHERE quickbooks _ticket _id = ' " . $ ticket _id . " ' " , $ errnum , $ errmsg , 0 , 1 ) ) ) { if ( $ arr [ 'lasterror _msg ' ] = = QUICKBOOKS _NOOP ) { return QUICKBOOKS _NOOP ; } return $ arr [ 'lasterror _num ' ] . ' : ' . $ arr [ 'lasterror _msg ' ] ; } } return 'Error fetching last error . ' ; } 
protected function _recur Enqueue ( $ user , $ run _every , $ action , $ ident , $ replace = true , $ priority = 0 , $ extra = null , $ qbxml = null ) { $ errnum = 0 ; $ errmsg = ' ' ; SELECT recur _lasttime FROM " . $ this - > _map Table Name ( QUICKBOOKS _DRIVER _SQL _RECURTABLE ) . " WHERE qb _username = ' " . $ this - > _escape ( $ user ) . " ' AND qb _action = ' " . $ this - > _escape ( $ action ) . " ' AND ident = ' " . $ this - > _escape ( $ ident ) . " ' " , $ errnum , $ errmsg ) ) ) { $ this - > _query ( " DELETE FROM " . $ this - > _map Table Name ( QUICKBOOKS _DRIVER _SQL _RECURTABLE ) . " WHERE qb _username = ' " . $ this - > _escape ( $ user ) . " ' AND qb _action = ' " . $ this - > _escape ( $ action ) . " ' AND ident = ' " . $ this - > _escape ( $ ident ) . " ' " , $ errnum , $ errmsg ) ; $ recur _lasttime = $ existing [ 'recur _lasttime ' ] ; } } if ( $ extra ) { $ extra = serialize ( $ extra ) ; } return $ this - > _query ( " INSERT INTO " . $ this - > _map Table Name ( QUICKBOOKS _DRIVER _SQL _RECURTABLE ) . " ( qb _username , qb _action , ident , extra , qbxml , priority , run _every , recur _lasttime , enqueue _datetime ) VALUES ( ' " . $ this - > _escape ( $ user ) . " ' , ' " . $ this - > _escape ( $ action ) . " ' , ' " . $ this - > _escape ( $ ident ) . " ' , ' " . $ this - > _escape ( $ extra ) . " ' , ' " . $ this - > _escape ( $ qbxml ) . " ' , " . ( int ) $ priority . " , " . ( int ) $ run _every . " , " . $ recur _lasttime . " , ' " . date ( 'Y -m -d H :i :s ' ) . " ' ) " , $ errnum , $ errmsg ) ; } 
protected function _recur Dequeue ( $ user , $ by _priority = false ) { $ errnum = 0 ; $ errmsg = ' ' ; $ sql = " SELECT * FROM " . $ this - > _map Table Name ( QUICKBOOKS _DRIVER _SQL _RECURTABLE ) . " WHERE qb _username = ' " . $ this - > _escape ( $ user ) . " ' AND recur _lasttime + run _every < = " . time ( ) ; if ( $ by _priority ) { $ sql . = ' ORDER BY priority DESC ' ; } if ( $ arr = $ this - > _fetch ( $ this - > _query ( $ sql . ' ' , $ errnum , $ errmsg , 0 , 1 ) ) ) { 
protected function _queue Remove ( $ user , $ action , $ ident ) { $ errnum = 0 ; $ errmsg = ' ' ; return $ this - > _query ( " UPDATE " . $ this - > _map Table Name ( QUICKBOOKS _DRIVER _SQL _QUEUETABLE ) . " SET qb _status = ' " . QUICKBOOKS _STATUS _REMOVED . " ' WHERE qb _username = ' " . $ this - > _escape ( $ user ) . " ' AND qb _action = ' " . $ this - > _escape ( $ action ) . " ' AND ident = ' " . $ this - > _escape ( $ ident ) . " ' AND qb _status = ' " . QUICKBOOKS _STATUS _QUEUED . " ' " , $ errnum , $ errmsg ) ; } 
protected function _queue Enqueue ( $ user , $ action , $ ident , $ replace = true , $ priority = 0 , $ extra = null , $ qbxml = null ) { $ errnum = 0 ; $ errmsg = ' ' ; if ( $ replace ) { $ this - > _query ( " DELETE FROM " . $ this - > _map Table Name ( QUICKBOOKS _DRIVER _SQL _QUEUETABLE ) . " WHERE qb _username = ' " . $ this - > _escape ( $ user ) . " ' AND qb _action = ' " . $ this - > _escape ( $ action ) . " ' AND ident = ' " . $ this - > _escape ( $ ident ) . " ' AND qb _status = ' " . QUICKBOOKS _STATUS _QUEUED . " ' " , $ errnum , $ errmsg ) ; } if ( $ extra ) { $ extra = serialize ( $ extra ) ; } return $ this - > _query ( " INSERT INTO " . $ this - > _map Table Name ( QUICKBOOKS _DRIVER _SQL _QUEUETABLE ) . " ( qb _username , qb _action , ident , extra , qbxml , priority , qb _status , enqueue _datetime ) VALUES ( ' " . $ this - > _escape ( $ user ) . " ' , ' " . $ this - > _escape ( $ action ) . " ' , ' " . $ this - > _escape ( $ ident ) . " ' , ' " . $ this - > _escape ( $ extra ) . " ' , ' " . $ this - > _escape ( $ qbxml ) . " ' , " . ( int ) $ priority . " , ' " . QUICKBOOKS _STATUS _QUEUED . " ' , ' " . date ( 'Y -m -d H :i :s ' ) . " ' ) " , $ errnum , $ errmsg ) ; } 
protected function _queue Processing ( $ user ) { $ errnum = 0 ; $ errmsg = ' ' ; SELECT quickbooks _queue _id , qb _action , ident , qb _status , dequeue _datetime FROM " . $ this - > _map Table Name ( QUICKBOOKS _DRIVER _SQL _QUEUETABLE ) . " WHERE dequeue _datetime IS NOT NULL ORDER BY dequeue _datetime DESC " ; $ res = $ this - > _query ( $ sql , $ errnum , $ errmsg , 0 , 1 ) ; if ( $ arr = $ this - > _fetch ( $ res ) and $ arr [ 'qb _status ' ] = = QUICKBOOKS _STATUS _PROCESSING and 
protected function _queue Dequeue ( $ user , $ by _priority = false ) { $ errnum = 0 ; $ errmsg = ' ' ; $ sql = " SELECT * FROM " . $ this - > _map Table Name ( QUICKBOOKS _DRIVER _SQL _QUEUETABLE ) . " WHERE qb _username = ' " . $ this - > _escape ( $ user ) . " ' AND qb _status = ' " . QUICKBOOKS _STATUS _QUEUED . " ' " ; if ( $ by _priority ) { $ sql . = ' ORDER BY priority DESC , ident ASC ' ; } return $ this - > _fetch ( $ this - > _query ( $ sql , $ errnum , $ errmsg , 0 , 1 ) ) ; } 
protected function _queue Left ( $ user , $ queued = true ) { $ errnum = 0 ; $ errmsg = ' ' ; SELECT COUNT ( * ) AS num _left FROM " . $ this - > _map Table Name ( QUICKBOOKS _DRIVER _SQL _QUEUETABLE ) . " WHERE qb _username = ' " . $ this - > _escape ( $ user ) . " ' " ; if ( $ queued ) { $ sql . = " AND qb _status = ' " . QUICKBOOKS _STATUS _QUEUED . " ' " ; } $ arr = $ this - > _fetch ( $ this - > _query ( $ sql , $ errnum , $ errmsg ) ) ; return $ arr [ 'num _left ' ] ; } 
protected function _queue Status ( $ ticket , $ request ID , $ new _status , $ msg = null ) { $ errnum = 0 ; $ errmsg = ' ' ; if ( $ ticket _id = $ this - > _ticket Resolve ( $ ticket ) ) { $ user = $ this - > auth Resolve ( $ ticket ) ; UPDATE " . $ this - > _map Table Name ( QUICKBOOKS _DRIVER _SQL _TICKETTABLE ) . " SET processed = processed + 1 , lasterror _num = NULL , lasterror _msg = NULL WHERE quickbooks _ticket _id = " . ( int ) $ ticket _id . " " , $ errnum , $ errmsg ) ; } if ( $ new _status = = QUICKBOOKS _STATUS _PROCESSING ) { / * $this - > _query ( " UPDATE " . $this - > _map Table Name (QUICKBOOKS _DRIVER _SQL _QUEUETABLE ) . " SET qb _status = ' " . $this - > _escape ( $new _status ) . " ' , msg = ' " . $this - > _escape ( $msg ) . " ' , quickbooks _ticket _id = " . (int ) $ticket _id . " , dequeue _datetime = ' " . date ( 'Y -m -d H :i :s ' ) . " ' WHERE qb _username = ' " . $this - > _escape ( $user ) . " ' AND qb _action = ' " . $this - > _escape ( $action ) . " ' AND ident = ' " . $this - > _escape ( $ident ) . " ' AND qb _status = ' " . QUICKBOOKS _STATUS _QUEUED . " ' " , $errnum , $errmsg , 0 , 1 ) ; * / $ this - > _query ( " UPDATE " . $ this - > _map Table Name ( QUICKBOOKS _DRIVER _SQL _QUEUETABLE ) . " SET qb _status = ' " . $ this - > _escape ( $ new _status ) . " ' , msg = ' " . $ this - > _escape ( $ msg ) . " ' , quickbooks _ticket _id = " . ( int ) $ ticket _id . " , dequeue _datetime = ' " . date ( 'Y -m -d H :i :s ' ) . " ' WHERE quickbooks _queue _id = " . ( int ) $ request ID . " AND qb _username = ' " . $ this - > _escape ( $ user ) . " ' AND qb _status = ' " . $ this - > _escape ( QUICKBOOKS _STATUS _QUEUED ) . " ' " , $ errnum , $ errmsg , null , null ) ; / /print ( 'running processing status query ! ' . $user . ' , ' . $action . ' , ' . $ident . ' , new : ' . $new _status ) ; / / If we 're currently processing , then no error is occuring . . . $ errnum = null ; $ errmsg = null ; $ this - > _query ( " UPDATE " . $ this - > _map Table Name ( QUICKBOOKS _DRIVER _SQL _TICKETTABLE ) . " SET lasterror _num = NULL , lasterror _msg = NULL WHERE quickbooks _ticket _id = " . ( int ) $ ticket _id , $ errnum , $ errmsg , null , null ) ; } else if ( $ new _status = = QUICKBOOKS _STATUS _SUCCESS ) { / / You can only update to a SUCCESS status if you 're currently / / in a PROCESSING status / * $sql = " UPDATE " . $this - > _map Table Name (QUICKBOOKS _DRIVER _SQL _QUEUETABLE ) . " SET qb _status = ' " . $this - > _escape ( $new _status ) . " ' , msg = ' " . $this - > _escape ( $msg ) . " ' WHERE quickbooks _ticket _id = " . (int ) $ticket _id . " AND qb _username = ' " . $this - > _escape ( $user ) . " ' AND qb _action = ' " . $this - > _escape ( $action ) . " ' AND ident = ' " . $this - > _escape ( $ident ) . " ' AND qb _status = ' " . QUICKBOOKS _STATUS _PROCESSING . " ' " ; * / $ sql = " UPDATE " . $ this - > _map Table Name ( QUICKBOOKS _DRIVER _SQL _QUEUETABLE ) . " SET qb _status = ' " . $ this - > _escape ( $ new _status ) . " ' , msg = ' " . $ this - > _escape ( $ msg ) . " ' WHERE quickbooks _ticket _id = " . ( int ) $ ticket _id . " AND qb _username = ' " . $ this - > _escape ( $ user ) . " ' AND quickbooks _queue _id = " . ( int ) $ request ID . " AND qb _status = ' " . QUICKBOOKS _STATUS _PROCESSING . " ' " ; $ this - > _query ( $ sql , $ errnum , $ errmsg , null , null ) ; } else { / / There are some statuses which *can not be updated * because / / they 're already removed from the queue . These are listed in / / the NOT IN section / * $sql = " UPDATE " . $this - > _map Table Name (QUICKBOOKS _DRIVER _SQL _QUEUETABLE ) . " SET qb _status = ' " . $this - > _escape ( $new _status ) . " ' , msg = ' " . $this - > _escape ( $msg ) . " ' WHERE quickbooks _ticket _id = " . (int ) $ticket _id . " AND qb _username = ' " . $this - > _escape ( $user ) . " ' AND qb _action = ' " . $this - > _escape ( $action ) . " ' AND ident = ' " . $this - > _escape ( $ident ) . " ' AND qb _status NOT IN ( ' " . QUICKBOOKS _STATUS _SUCCESS . " ' , ' " . QUICKBOOKS _STATUS _HANDLED . " ' , ' " . QUICKBOOKS _STATUS _CANCELLED . " ' , ' " . QUICKBOOKS _STATUS _REMOVED . " ' ) " ; * / $ sql = " UPDATE " . $ this - > _map Table Name ( QUICKBOOKS _DRIVER _SQL _QUEUETABLE ) . " SET qb _status = ' " . $ this - > _escape ( $ new _status ) . " ' , msg = ' " . $ this - > _escape ( $ msg ) . " ' WHERE quickbooks _ticket _id = " . ( int ) $ ticket _id . " AND qb _username = ' " . $ this - > _escape ( $ user ) . " ' AND quickbooks _queue _id = " . ( int ) $ request ID . " AND qb _status NOT IN ( ' " . QUICKBOOKS _STATUS _SUCCESS . " ' , ' " . QUICKBOOKS _STATUS _HANDLED . " ' , ' " . QUICKBOOKS _STATUS _CANCELLED . " ' , ' " . QUICKBOOKS _STATUS _REMOVED . " ' ) " ; $ this - > _query ( $ sql , $ errnum , $ errmsg , null , null ) ; / / If that got marked as a No Op , we should also remove the No Op / / status from the quickbooks _ticket table , or we can get stuck / / in an infinite loop (we 're all done , last request returns a / / no op , get last error is called , returns no op , send request / / is called and returns a no op because there 's nothing to do , / / get last error is called and retuns a no op , etc . etc . etc . / * if ( $new _status = = QUICKBOOKS _STATUS _NOOP ) { $errnum = null ; $errmsg = null ; $this - > _query ( " UPDATE " . $this - > _map Table Name (QUICKBOOKS _DRIVER _SQL _TICKETTABLE ) . " SET lasterror _num = NULL , lasterror _msg = NULL WHERE quickbooks _ticket _id = " . (int ) $ticket _id , $errnum , $errmsg , 0 , 1 ) ; } * / } return true ; } return false ; } 
protected function _queue Processed ( $ ticket ) { $ errnum = 0 ; $ errmsg = ' ' ; if ( $ arr = $ this - > _fetch ( $ this - > _query ( " SELECT processed FROM " . $ this - > _map Table Name ( QUICKBOOKS _DRIVER _SQL _TICKETTABLE ) . " WHERE ticket = ' " . $ this - > _escape ( $ ticket ) . " ' " , $ errnum , $ errmsg , 0 , 1 ) ) ) { return $ arr [ 'processed ' ] ; } return 0 ; } 
protected function _queue Exists ( $ user , $ action , $ ident ) { $ errnum = 0 ; $ errmsg = ' ' ; return $ this - > _count ( $ this - > _query ( " SELECT quickbooks _queue _id FROM " . $ this - > _map Table Name ( QUICKBOOKS _DRIVER _SQL _QUEUETABLE ) . " WHERE qb _username = ' " . $ this - > _escape ( $ user ) . " ' AND qb _action = ' " . $ this - > escape ( $ action ) . " ' AND ident = ' " . $ this - > escape ( $ ident ) . " ' AND qb _status = ' " . QUICKBOOKS _STATUS _QUEUED . " ' " , $ errnum , $ errmsg ) ) > 0 ; } 
protected function _truncate ( $ table , $ max _history ) { SELECT quickbooks _queue _id FROM " . $ this - > _map Table Name ( $ table ) . " WHERE qb _status IN ( ' " . QUICKBOOKS _STATUS _SUCCESS . " ' , ' " . QUICKBOOKS _STATUS _HANDLED . " ' , ' " . QUICKBOOKS _STATUS _CANCELLED . " ' , ' " . QUICKBOOKS _STATUS _NOOP . " ' ) ORDER BY quickbooks _queue _id ASC LIMIT " ; $ field = 'quickbooks _queue _id ' ; break ; case QUICKBOOKS _DRIVER _SQL _TICKETTABLE : $ sql = "SELECT quickbooks _ticket _id FROM " . $ this - > _map Table Name ( $ table ) . " ORDER BY quickbooks _ticket _id ASC LIMIT " ; $ field = 'quickbooks _ticket _id ' ; break ; } / / How big is the log file ? Should we auto -truncate it ? $ errnum = 0 ; $ errmsg = ' ' ; $ arr = $ this - > _fetch ( $ this - > _query ( "SELECT COUNT ( " . $ field . " ) AS counter FROM " . $ this - > _map Table Name ( $ table ) , $ errnum , $ errmsg ) ) ; if ( $ arr [ 'counter ' ] > $ max _history ) { / / Truncate the log to the size specified $ start = time ( ) ; $ cutoff = 3 ; / / 3 seconds max cutoff time to avoid timeouts $ limit = 1 0 0 ; $ list = array ( ) ; $ errnum = 0 ; $ errmsg = ' ' ; $ res = $ this - > _query ( $ sql . floor ( $ max _history / 2 ) , $ errnum , $ errmsg ) ; while ( $ arr = $ this - > _fetch ( $ res ) and time ( ) - $ start < $ cutoff ) { / / Delete it batches of $limit , keep under $cutoff seconds $ list [ ] = current ( $ arr ) ; if ( count ( $ list ) > $ limit ) { $ errnum = 0 ; $ errmsg = ' ' ; $ this - > _query ( "DELETE FROM " . $ this - > _map Table Name ( $ table ) . " WHERE " . $ field . " IN ( " . implode ( ' , ' , $ list ) . " ) " , $ errnum , $ errmsg ) ; $ list = array ( ) ; } } } return ; } 
protected function _log ( $ msg , $ ticket = null , $ log _level = QUICKBOOKS _LOG _NORMAL , $ cur _log _level = null ) { static $ batch = 0 ; INSERT INTO " . $ this - > _map Table Name ( QUICKBOOKS _DRIVER _SQL _LOGTABLE ) . " ( quickbooks _ticket _id , batch , msg , log _datetime ) VALUES ( " . $ ticket _id . " , " . $ batch . " , ' " . $ this - > _escape ( $ msg ) . " ' , ' " . date ( 'Y -m -d H :i :s ' ) . " ' ) " , $ errnum , $ errmsg ) ; } else { return $ this - > _query ( " INSERT INTO " . $ this - > _map Table Name ( QUICKBOOKS _DRIVER _SQL _LOGTABLE ) . " ( batch , msg , log _datetime ) VALUES ( " . $ batch . " , ' " . $ this - > _escape ( $ msg ) . " ' , ' " . date ( 'Y -m -d H :i :s ' ) . " ' ) " , $ errnum , $ errmsg ) ; } } 
public function query ( $ sql , & $ errnum , & $ errmsg , $ offset = 0 , $ limit = null , $ vars = array ( ) ) { if ( is _array ( $ vars ) and count ( $ vars ) ) { foreach ( $ vars as $ key = > $ value ) { $ vars [ $ key ] = $ this - > escape ( $ value ) ; } array _unshift ( $ vars , $ sql ) ; $ sql = call _user _func _array ( 'sprintf ' , $ vars ) ; } 
public function fields ( $ table , $ with _field _names _as _keys = false ) { static $ cache = array ( ) ; if ( isset ( $ cache [ $ table ] ) ) { return $ cache [ $ table ] ; } 
public function select ( $ table , $ restrict , $ order = array ( ) , $ offset = null , $ limit = null ) { $ list = array ( ) ; if ( count ( $ restrict ) ) { $ where = array ( ) ; foreach ( $ restrict as $ field = > $ value ) { $ where [ ] = $ field . " = ' " . $ this - > _escape ( $ value ) . " ' " ; } $ where = " WHERE " . implode ( ' AND ' , $ where ) . " " ; } else { $ where = " " ; } $ orderby = " " ; if ( is _array ( $ order ) and count ( $ order ) ) { $ orderby = array ( ) ; foreach ( $ order as $ field = > $ direction ) { $ orderby [ ] = " " . $ field . " " . $ direction ; } $ orderby = " ORDER BY " . implode ( ' , ' , $ orderby ) ; } $ errnum = 0 ; $ errmsg = ' ' ; if ( $ res = $ this - > _query ( "SELECT * FROM " . $ this - > _escape ( $ table ) . " " . $ where . " " . $ orderby , $ errnum , $ errmsg , $ offset , $ limit ) ) { while ( $ arr = $ this - > _fetch ( $ res ) ) { $ list [ ] = $ arr ; } } return $ list ; } 
public function update ( $ table , $ object , $ where = array ( ) , $ resync = true , $ discov = null , $ derive = true ) { $set [ ] = $field . ' = ' . (int ) $value ; } else { * / UPDATE " . $ this - > _escape ( $ table ) . " SET " . QUICKBOOKS _DRIVER _SQL _FIELD _DISCOVER . " = " . QUICKBOOKS _DRIVER _SQL _FIELD _RESYNC . " WHERE " . implode ( ' AND ' , $ wheres ) , $ errnum , $ errmsg ) ; } return $ return ; } 
public function insert ( $ table , $ object , $ discov _and _resync = true ) { $ sql = ' ' ; $ avail = $ this - > fields ( $ table , true ) ; foreach ( $object as $field = > $value ) { $fields [ ] = $field ; $values [ ] = " ' " . $this - > _escape ( $value ) . " ' " ; } * / if ( $table = = 'pricemodel _tierset ' ) { print _r ( $object ) ; print ( $sql ) ; exit ; } * / $ errnum = 0 ; $ errmsg = ' ' ; return $ this - > _query ( $ sql , $ errnum , $ errmsg ) ; } 
public function interactive ( $ priority = 0 , $ user = null ) { if ( $ this - > _driver ) { $ tmp = array _merge ( range ( 'a ' , 'z ' ) , range ( 0 , 9 ) ) ; shuffle ( $ tmp ) ; $ random = substr ( implode ( ' ' , $ tmp ) , 0 , 8 ) ; if ( ! $ user ) { $ user = $ this - > _user ; } return $ this - > _driver - > queue Enqueue ( QUICKBOOKS _INTERACTIVE _MODE , $ random , true , $ priority , $ user ) ; } return false ; } 
public function recurring ( $ run _every , $ action , $ ident = null , $ priority = 0 , $ extra = null , $ user = null , $ qbxml = null , $ replace = true ) { $ run _every = Quick Books _Utilities : : interval To Seconds ( $ run _every ) ; if ( ! strlen ( $ ident ) ) { $ tmp = array _merge ( array ( 'a ' , 'z ' ) , range ( 0 , 9 ) ) ; shuffle ( $ tmp ) ; $ ident = substr ( implode ( ' ' , $ tmp ) , 0 , 8 ) ; } if ( $ this - > _driver ) { 
public function enqueue ( $ action , $ ident = null , $ priority = 0 , $ extra = null , $ user = null , $ qbxml = null , $ replace = true ) { if ( ! strlen ( $ ident ) ) { if ( ! $user ) { $user = $this - > _driver - >auth Default ( ) ; } * / 
public function exists ( $ action , $ ident , $ user = null ) { if ( $ this - > _driver ) { 
public function size ( $ user = null ) { if ( $ this - > _driver ) { 
public function remove ( $ action , $ ident , $ user = null ) { if ( $ this - > _driver ) { 
public function set Address ( $ addr 1 , $ addr 2 = ' ' , $ addr 3 = ' ' , $ addr 4 = ' ' , $ addr 5 = ' ' , $ city = ' ' , $ state = ' ' , $ province = ' ' , $ postalcode = ' ' , $ country = ' ' , $ note = ' ' ) { for ( $ i = 1 ; $ i < = 5 ; $ i + + ) { $ this - > set ( 'Address Addr ' . $ i , $ { 'addr ' . $ i } ) ; } $ this - > set ( 'Address City ' , $ city ) ; $ this - > set ( 'Address State ' , $ state ) ; $ this - > set ( 'Address Province ' , $ province ) ; $ this - > set ( 'Address Postal Code ' , $ postalcode ) ; $ this - > set ( 'Address Country ' , $ country ) ; $ this - > set ( 'Address Note ' , $ note ) ; } 
public function get Address ( $ part = null , $ defaults = array ( ) ) { if ( ! is _null ( $ part ) ) { return $ this - > get ( 'Address ' . $ part ) ; } return $ this - > get Array ( 'Address * ' , $ defaults ) ; } 
public function authenticate ( $ username , $ password , $ token ) { $ this - > _username = $ username ; $ this - > _password = $ password ; $ this - > _token = $ token ; $ url = 'https : / /workplace .intuit .com /db /main ?act =API _Authenticate ' ; $ action = 'API _Authenticate ' ; $ xml = ' < ?xml version = " 1 . 0 " encoding = "UTF - 8 " ? > <qdbapi > <username > ' . $ username . ' < /username > <password > ' . $ password . ' < /password > <apptoken > ' . $ token . ' < /apptoken > < /qdbapi > ' ; $ Context = null ; $ response = $ this - > _request ( $ Context , Quick Books _IPP : : REQUEST _IPP , $ url , $ action , $ xml ) ; if ( ! $ this - > _has Errors ( $ response ) and $ ticket = Quick Books _XML : : extract Tag Contents ( 'ticket ' , $ response ) ) { $ this - > _ticket = $ ticket ; $ cookies = array ( 'scache ' , 'ptest ' , 'stest ' , 'luid ' , 'TICKET ' , 'qbn .ticket ' , 'qbn .tkt ' , 'qbn .authid ' , 'qbn .gauthid ' , 'qbn .agentid ' , 'iam Validation Time ' ) ; foreach ( $ cookies as $ cookie ) { if ( $ value = $ this - > _extract Cookie ( $ cookie , $ response ) ) { $ this - > _cookies [ $ cookie ] = $ value ; } } return new Quick Books _IPP _Context ( $ this , $ ticket , $ token ) ; } return false ; } 
public function context ( $ ticket = null , $ token = null , $ check _if _valid = true ) { $ Context = null ; if ( $ this - > _authmode = = Quick Books _IPP : : AUTHMODE _OAUTH ) { $ Context = new Quick Books _IPP _Context ( $ this , null , $ token ) ; 
public function auth Mode ( $ authmode = null , $ authuser = null , $ authcred = null , $ authsign = null , $ authkey = null ) { if ( $ authmode ) { $ this - > _authmode = $ authmode ; $ this - > _authuser = $ authuser ; $ this - > _authcred = $ authcred ; $ this - > _authsign = $ authsign ; $ this - > _authkey = $ authkey ; } return $ this - > _authmode ; } 
public function provision User ( $ Context , $ email , $ fname , $ lname , $ roleid = null , $ udata = null ) { $ url = 'https : / /workplace .intuit .com /db / ' . $ this - > _dbid ; $ action = 'API _Provision User ' ; $ xml = ' <qdbapi > <ticket > ' . $ Context - > ticket ( ) . ' < /ticket > <apptoken > ' . $ Context - > token ( ) . ' < /apptoken > ' ; if ( $ roleid ) { $ xml . = ' <roleid > ' . $ roleid . ' < /roleid > ' ; } $ xml . = ' <email > ' . $ email . ' < /email > <fname > ' . $ fname . ' < /fname > <lname > ' . $ lname . ' < /lname > ' ; if ( $ udata ) { $ xml . = ' <udata > ' . $ udata . ' < /udata > ' ; } $ xml . = ' < /qdbapi > ' ; $ response = $ this - > _request ( $ Context , Quick Books _IPP : : REQUEST _IPP , $ url , $ action , $ xml ) ; if ( $ this - > _has Errors ( $ response ) ) { return false ; } return true ; } 
public function IDS ( $ Context , $ realm , $ resource , $ optype , $ xml = ' ' , $ ID = null ) { $ IPP = $ Context - > IPP ( ) ; switch ( $ IPP - > version ( ) ) { case Quick Books _IPP _IDS : : VERSION _ 3 : default : return $ this - > _IDS _v 3 ( $ Context , $ realm , $ resource , $ optype , $ xml , $ ID ) ; } } 
public function find By Id ( $ Context , $ realm ID ) { $ xml = null ; 
public function set Vendor Application ID ( $ value ) { return $ this - > set ( 'Vendor Ref ' . QUICKBOOKS _API _APPLICATIONID , $ this - > encode Application ID ( QUICKBOOKS _OBJECT _VENDOR , QUICKBOOKS _LISTID , $ value ) ) ; } 
public function add ( $ Context , $ realm ID , $ Object ) { return parent : : _add ( $ Context , $ realm ID , Quick Books _IPP _IDS : : RESOURCE _VENDORCREDIT , $ Object ) ; } 
public function delete ( $ Context , $ realm ID , $ IDType ) { return parent : : _delete ( $ Context , $ realm ID , Quick Books _IPP _IDS : : RESOURCE _VENDORCREDIT , $ IDType ) ; } 
public function Get Errors ( ) { 
public function Get Logs ( ) { $ query = DB : : select ( ) - > from ( 'quickbooks _logs ' ) ; $ logentries = $ this - > _db - > query ( Database : : SELECT , $ query , FALSE ) - > as _array ( ) ; return $ logentries ; } 
public function Get Queue Breakdown ( ) { $ metrics = array ( ) ; 
protected function _request ( $ method ) { $ start = microtime ( true ) ; if ( ! function _exists ( 'curl _init ' ) ) { die ( 'You must have the PHP c URL extension (php .net /curl ) enabled to use this ( ' . QUICKBOOKS _PACKAGE _NAME . ' v ' . QUICKBOOKS _PACKAGE _VERSION . ' ) . ' ) ; } $ this - > _log ( 'Using CURL to send request ! ' , QUICKBOOKS _LOG _DEVELOP ) ; $ return = $ this - > _request Curl ( $ method , $ errnum , $ errmsg ) ; if ( $ errnum ) { $ this - > _set Error ( $ errnum , $ errmsg ) ; } 
public function sign On ( ) { $ this - > _set Error ( Quick Books _Merchant Service : : ERROR _OK ) ; $ xml = ' ' ; $ xml . = ' < ?xml version = " 1 . 0 " ? > ' . QUICKBOOKS _CRLF ; $ xml . = ' < ?qbmsxml version = " 4 . 1 " ? > ' . QUICKBOOKS _CRLF ; $ xml . = ' <QBMSXML > ' . QUICKBOOKS _CRLF ; $ xml . = ' <Signon Msgs Rq > ' . QUICKBOOKS _CRLF ; if ( $ this - > _certificate ) { $ this - > _log ( 'Signing on a HOSTED QBMS application . ' , QUICKBOOKS _LOG _DEBUG ) ; $ xml . = ' <Signon App Cert Rq > ' . QUICKBOOKS _CRLF ; $ xml . = ' <Client Date Time > ' . date ( 'Y -m -d \TH :i :s ' ) . ' < /Client Date Time > ' . QUICKBOOKS _CRLF ; $ xml . = ' <Application Login > ' . $ this - > _application _login . ' < /Application Login > ' . QUICKBOOKS _CRLF ; $ xml . = ' <Connection Ticket > ' . $ this - > _ticket _connection . ' < /Connection Ticket > ' . QUICKBOOKS _CRLF ; $ xml . = ' < /Signon App Cert Rq > ' . QUICKBOOKS _CRLF ; } else { $ this - > _log ( 'Signing on as a DESKTOP QBMS application . ' , QUICKBOOKS _LOG _DEBUG ) ; $ xml . = ' <Signon Desktop Rq > ' . QUICKBOOKS _CRLF ; $ xml . = ' <Client Date Time > ' . date ( 'Y -m -d \TH :i :s ' ) . ' < /Client Date Time > ' . QUICKBOOKS _CRLF ; $ xml . = ' <Application Login > ' . $ this - > _application _login . ' < /Application Login > ' . QUICKBOOKS _CRLF ; $ xml . = ' <Connection Ticket > ' . $ this - > _ticket _connection . ' < /Connection Ticket > ' . QUICKBOOKS _CRLF ; $ xml . = ' < /Signon Desktop Rq > ' . QUICKBOOKS _CRLF ; } $ xml . = ' < /Signon Msgs Rq > ' . QUICKBOOKS _CRLF ; $ xml . = ' < /QBMSXML > ' . QUICKBOOKS _CRLF ; $ errnum = Quick Books _Merchant Service : : ERROR _OK ; $ errmsg = ' ' ; $ response = $ this - > _request ( $ xml , $ errnum , $ errmsg ) ; if ( $ errnum ) { $ this - > _set Error ( Quick Books _Merchant Service : : ERROR _SOCKET , $ errnum . ' : ' . $ errmsg ) ; return false ; } $ code = $ this - > _extract Attribute ( 'status Code ' , $ response ) ; $ message = $ this - > _extract Attribute ( 'status Message ' , $ response ) ; $ severity = $ this - > _extract Attribute ( 'status Severity ' , $ response ) ; $ this - > _log ( 'Sign On (initial ) response : ' . $ severity . ' / ' . $ code . ' : ' . $ message , QUICKBOOKS _LOG _DEBUG ) ; if ( $ code ! = Quick Books _Merchant Service : : ERROR _OK ) { $ this - > _set Error ( $ code , $ message ) ; return false ; } if ( $ ticket = $ this - > _extract Tag Contents ( 'Session Ticket ' , $ response ) ) { $ this - > _ticket _session = $ ticket ; return true ; } $ this - > _set Error ( Quick Books _Merchant Service : : ERROR _INTERNAL , 'Could not locate Session Ticket in response . ' ) ; return false ; } 
protected function _trans Request ID ( $ type , $ Obj , $ amount , $ force _new _transaction = true ) { $ rand = ' ' ; if ( $ force _new _transaction ) { $ rand = mt _rand ( ) . microtime ( ) ; } return md 5 ( $ type . ' - ' . serialize ( $ Obj ) . ' - ' . $ amount . ' - ' . $ rand ) ; } 
protected function _do QBMS ( $ type , $ path , $ xml , $ Credit Card = null , $ Transaction = null ) { $ errnum = Quick Books _Merchant Service : : ERROR _OK ; $ errmsg = ' ' ; $ response = $ this - > _request ( $ xml , $ errnum , $ errmsg ) ; if ( $ errnum ) { $ this - > _set Error ( Quick Books _Merchant Service : : ERROR _SOCKET , $ errnum . ' : ' . $ errmsg ) ; return false ; } $ signon _code = $ this - > _extract Attribute ( 'status Code ' , $ response , 0 ) ; $ signon _message = ' ' ; $ signon _severity = $ this - > _extract Attribute ( 'status Severity ' , $ response , 0 ) ; if ( $ signon _code ! = Quick Books _Merchant Service : : ERROR _OK ) { $ signon _message = $ this - > _extract Attribute ( 'status Message ' , $ response , 0 ) ; } $ this - > _log ( 'Sign On (with session ) response : ' . $ signon _severity . ' / ' . $ signon _code . ' : ' . $ signon _message , QUICKBOOKS _LOG _DEBUG ) ; if ( $ signon _code ! = Quick Books _Merchant Service : : ERROR _OK ) { $ this - > _set Error ( $ signon _code , $ signon _message ) ; return false ; } $ qbms _code = $ this - > _extract Attribute ( 'status Code ' , $ response , 1 ) ; $ qbms _message = $ this - > _extract Attribute ( 'status Message ' , $ response , 0 ) ; 
public function refund ( $ Card , $ amount , $ salestax = null , $ comment = null , $ is _card _present = false , $ is _ecommerce = true , $ force _new _transaction = true ) { $ this - > _set Error ( Quick Books _Merchant Service : : ERROR _OK ) ; $ this - > _log ( 'refund ( ) ' , QUICKBOOKS _LOG _VERBOSE ) ; if ( ! $ this - > is Signed On ( ) ) { $ this - > sign On ( ) ; if ( $ this - > error Number ( ) ) { return false ; } } 
protected function _gateway ( ) { if ( $ this - > _test ) { $ this - > _log ( 'Using TEST gateway : ' . $ this - > _test _gateway , QUICKBOOKS _LOG _DEVELOP ) ; return $ this - > _test _gateway ; } $ this - > _log ( 'Using LIVE gateway : ' . $ this - > _live _gateway , QUICKBOOKS _LOG _DEVELOP ) ; return $ this - > _live _gateway ; } 
static public function initialize ( $ dsn = null , $ user = null , $ config = array ( ) , $ return _boolean = true ) { static $ instance ; if ( empty ( $ instance ) ) { if ( empty ( $ dsn ) ) { return false ; } $ instance = new Quick Books _Web Connector _Queue ( $ dsn , $ user , $ config ) ; } if ( $ return _boolean and $ instance ) { return true ; } return $ instance ; } 
protected function _adapter Factory ( $ adapter , $ wsdl , $ soap _options , $ loglevel ) { $ adapter = ucfirst ( strtolower ( $ adapter ) ) ; $ file = ' /Quick Books /Adapter /Server / ' . $ adapter . ' .php ' ; $ class = 'Quick Books _Adapter _Server _ ' . $ adapter ; Quick Books _Loader : : load ( $ file ) ; if ( class _exists ( $ class ) ) { return new $ class ( $ wsdl , $ soap _options ) ; } return null ; } 
final protected function _defaults ( $ arr ) { $ defaults = array ( 'error _handler ' = > ' ' , 'use _builtin _error _handler ' = > false , 'time _limit ' = > 0 , 'log _to _file ' = > null , 'log _to _syslog ' = > null , 'masking ' = > true , ) ; $ arr = array _merge ( $ defaults , $ arr ) ; return $ arr ; } 
protected function _merge ( $ arr 1 , $ arr 2 , $ array _of _arrays = false ) { if ( $ array _of _arrays ) { foreach ( $ arr 2 as $ key = > $ funcs ) { if ( ! is _array ( $ funcs ) ) { $ funcs = array ( $ funcs ) ; } if ( isset ( $ arr 1 [ $ key ] ) ) { if ( ! is _array ( $ arr 1 [ $ key ] ) ) { $ arr 1 [ $ key ] = array ( $ arr 1 [ $ key ] ) ; } $ arr 1 [ $ key ] = array _merge ( $ arr 1 [ $ key ] , $ funcs ) ; } else { $ arr 1 [ $ key ] = $ funcs ; } } return $ arr 1 ; } else { 
protected function _headers ( ) { if ( $ _SERVER [ 'REQUEST _METHOD ' ] = = 'POST ' ) { header ( 'Content -Type : text /xml ' ) ; } else if ( isset ( $ _GET [ 'wsdl ' ] ) or isset ( $ _GET [ 'WSDL ' ] ) ) { header ( 'Content -Type : text /xml ' ) ; } else { header ( 'Content -Type : text /plain ' ) ; } return true ; } 
public function handle ( $ return = false , $ debug = false ) { if (isset ( $this - > _hooks [QUICKBOOKS _SERVER _HOOK _PREHANDLE ] ) ) { foreach ( $this - > _hooks [QUICKBOOKS _SERVER _HOOK _PREHANDLE ] as $func ) { $func ( $input , $this - > _callback _config ) ; } } * / $ hook _data = array ( 'input ' = > $ input , ) ; $ err = ' ' ; $ this - > _call Hooks ( QUICKBOOKS _SERVER _HOOK _PREHANDLE , null , null , null , $ err , $ hook _data ) ; if (isset ( $this - > _hooks [QUICKBOOKS _SERVER _HOOK _POSTHANDLE ] ) ) { foreach ( $this - > _hooks [QUICKBOOKS _SERVER _HOOK _POSTHANDLE ] as $func ) { $func ( $output , $this - > _callback _config ) ; } } * / $ hook _data = array ( 'input ' = > $ input , 'output ' = > $ output , ) ; $ err = ' ' ; $ this - > _call Hooks ( QUICKBOOKS _SERVER _HOOK _POSTHANDLE , null , null , null , $ err , $ hook _data ) ; print ( " \n " ) ; print ( 'Registered hooks : ' . " \n " ) ; foreach ( $this - > _hooks as $hook = > $arr ) { if ( !is _array ( $arr ) ) { continue ; } print ( ' - ' . $hook . QUICKBOOKS _CRLF ) ; foreach ( $arr as $x ) { $y = current (explode ( " \n " , print _r ( $x , true ) ) ) ; print ( ' ' . $y . QUICKBOOKS _CRLF ) ; } } * / print ( " \n " ) ; print ( 'Detected input : ' . " \n " ) ; print ( $ input ) ; print ( " \n " ) ; print ( " \n " ) ; print ( 'Timestamp : ' . " \n " ) ; print ( ' - ' . date ( 'Y -m -d H :i :s ' ) . ' - - process ' . round ( microtime ( true ) - QUICKBOOKS _TIMESTAMP , 5 ) . " \n " ) ; } return ; } } 
public function set Entity Application ID ( $ value ) { return $ this - > set ( 'Entity Ref ' . QUICKBOOKS _API _APPLICATIONID , $ this - > encode Application ID ( QUICKBOOKS _OBJECT _ENTITY , QUICKBOOKS _LISTID , $ value ) ) ; } 
public function set Item Sales Tax Application ID ( $ value ) { return $ this - > set ( 'Item Sales Tax Ref ' . QUICKBOOKS _API _APPLICATIONID , $ this - > encode Application ID ( QUICKBOOKS _OBJECT _ITEMSALESTAX , QUICKBOOKS _LISTID , $ value ) ) ; } 
static public function e 0x 8 0 0 4 0 4 0 0 _foundanerror ( $ request ID , $ user , $ action , $ ident , $ extra , & $ err , $ xml , $ errnum , $ errmsg , $ config ) { if ( $ action = = QUICKBOOKS _QUERY _UNITOFMEASURESET ) { 
static function salt ( ) { $ tmp = array _merge ( range ( 'a ' , 'z ' ) , range ( 'A ' , 'Z ' ) , range ( 0 , 9 ) ) ; shuffle ( $ tmp ) ; $ salt = substr ( implode ( ' ' , $ tmp ) , 0 , 3 2 ) ; return $ salt ; } 
public function action _index ( ) { 
function _quickbooks _customer _mod _request ( $ request ID , $ user , $ action , $ ID , $ extra , & $ err , $ last _action _time , $ last _actionident _time , $ version , $ locale ) { Kohana : : $ log - > add ( Log : : NOTICE , " \n Customer Modification QBXML : \n " . $ qbxml ) ; } 
protected function _request Factory ( $ request ) { $ class = 'Quick Books _Web Connector _Request _ ' . ucfirst ( strtolower ( $ request ) ) ; $ file = ' /Quick Books /Web Connector /Request / ' . ucfirst ( strtolower ( $ request ) ) . ' .php ' ; 
public function handle ( $ raw _http _input ) { <SOAP -ENV :Envelope xmlns :SOAP -ENV = "http : / /schemas .xmlsoap .org /soap /envelope / " xmlns :ns 1 = "http : / /developer .intuit .com / " > <SOAP -ENV :Body > <ns 1 : ' . $ method . 'Response > ' ; $ vars = get _object _vars ( $ Response ) ; $ soap . = $ this - > _serialize ( $ vars ) ; $ soap . = ' < /ns 1 : ' . $ method . 'Response > < /SOAP -ENV :Body > < /SOAP -ENV :Envelope > ' ; print ( $ soap ) ; return true ; } else { $ soap = ' ' ; $ soap . = ' < ?xml version = " 1 . 0 " encoding = "UTF - 8 " ? > ' . QUICKBOOKS _CRLF ; $ soap . = ' <SOAP -ENV :Envelope xmlns :SOAP -ENV = "http : / /schemas .xmlsoap .org /soap /envelope / " > ' . QUICKBOOKS _CRLF ; $ soap . = ' <SOAP -ENV :Body > ' . QUICKBOOKS _CRLF ; $ soap . = ' <SOAP -ENV :Fault > ' . QUICKBOOKS _CRLF ; $ soap . = ' <faultcode >SOAP -ENV :Client < /faultcode > ' . QUICKBOOKS _CRLF ; $ soap . = ' <faultstring >Bad Request : ' . htmlspecialchars ( $ errnum ) . ' : ' . htmlspecialchars ( $ errmsg ) . ' < /faultstring > ' . QUICKBOOKS _CRLF ; $ soap . = ' < /SOAP -ENV :Fault > ' . QUICKBOOKS _CRLF ; $ soap . = ' < /SOAP -ENV :Body > ' . QUICKBOOKS _CRLF ; $ soap . = ' < /SOAP -ENV :Envelope > ' . QUICKBOOKS _CRLF ; print ( $ soap ) ; return false ; } } 
public function walk ( $ callback ) { 
public function charge ( $ Context , $ Object _or _token , $ amount , $ currency = 'USD ' , $ description = ' ' , array $ context = array ( ) ) { $ capture = true ; return $ this - > _charge Or Auth ( $ Context , $ Object _or _token , $ amount , $ currency , $ capture , $ description , $ context ) ; } 
public function authorize ( $ Context , $ Object _or _token , $ amount , $ currency = 'USD ' , $ description = ' ' , array $ context = array ( ) ) { $ capture = false ; return $ this - > _charge Or Auth ( $ Context , $ Object _or _token , $ amount , $ currency , $ capture , $ description , $ context ) ; } 
public function get Charge ( $ Context , $ id ) { $ resp = $ this - > _http ( $ Context , Quick Books _Payments : : URL _CHARGE . ' / ' . $ id , null ) ; $ data = json _decode ( $ resp , true ) ; $ ignore _declines = true ; if ( $ this - > _handle Error ( $ data , $ ignore _declines ) ) { return false ; } return new Quick Books _Payments _Transaction ( $ data ) ; } 
public function get Debit ( $ Context , $ id ) { $ resp = $ this - > _http ( $ Context , Quick Books _Payments : : URL _ECHECK . ' / ' . $ id , null ) ; $ data = json _decode ( $ resp , true ) ; $ ignore _declines = true ; if ( $ this - > _handle Error ( $ data , $ ignore _declines ) ) { return false ; } return new Quick Books _Payments _Transaction ( $ data ) ; } 
public function refund ( $ Context , $ id , $ amount , $ context = array ( ) ) { $ url = str _replace ( ' <id > ' , $ id , Quick Books _Payments : : URL _REFUND ) ; $ payload = array ( 'amount ' = > $ amount , 'context ' = > array ( 'mobile ' = > false , 'is Ecommerce ' = > false , 'recurring ' = > false , ) , ) ; $ resp = $ this - > _http ( $ Context , $ url , json _encode ( $ payload ) ) ; $ data = json _decode ( $ resp , true ) ; if ( $ this - > _handle Error ( $ data ) ) { return false ; } return new Quick Books _Payments _Transaction ( $ data ) ; } 
public function store Card ( $ Context , $ id , $ Object ) { $ id = str _replace ( array ( ' { ' , ' } ' , ' - ' ) , ' ' , $ id ) ; $ url = str _replace ( ' <id > ' , $ id , Quick Books _Payments : : URL _CARD ) ; if ( $ Object instanceof Quick Books _Payments _Credit Card ) { $ payload = $ Object - > to Array ( ) ; } else { $ this - > _set Error ( ) ; return false ; } $ resp = $ this - > _http ( $ Context , $ url , json _encode ( $ payload ) ) ; $ data = json _decode ( $ resp , true ) ; if ( $ this - > _handle Error ( $ data ) ) { return false ; } return Quick Books _Payments _Credit Card : : from Array ( $ data ) ; } 
public function store Card From Token ( $ Context , $ id , $ token ) { $ id = str _replace ( array ( ' { ' , ' } ' , ' - ' ) , ' ' , $ id ) ; $ url = str _replace ( ' <id > ' , $ id , Quick Books _Payments : : URL _CARD . ' /create From Token ' ) ; $ payload = array ( 'value ' = > $ token ) ; $ resp = $ this - > _http ( $ Context , $ url , json _encode ( $ payload ) ) ; $ data = json _decode ( $ resp , true ) ; if ( $ this - > _handle Error ( $ data ) ) { return false ; } return Quick Books _Payments _Credit Card : : from Array ( $ data ) ; } 
public function get Card ( $ Context , $ id , $ card _id ) { $ id = str _replace ( array ( ' { ' , ' } ' , ' - ' ) , ' ' , $ id ) ; $ url = str _replace ( ' <id > ' , $ id , Quick Books _Payments : : URL _CARD . ' / ' . $ card _id ) ; $ resp = $ this - > _http ( $ Context , $ url ) ; $ data = json _decode ( $ resp , true ) ; if ( $ this - > _handle Error ( $ data ) ) { return false ; } return Quick Books _Payments _Credit Card : : from Array ( $ data ) ; } 
public function get Cards ( $ Context , $ id ) { $ id = str _replace ( array ( ' { ' , ' } ' , ' - ' ) , ' ' , $ id ) ; $ url = str _replace ( ' <id > ' , $ id , Quick Books _Payments : : URL _CARD ) ; $ resp = $ this - > _http ( $ Context , $ url , null ) ; $ data = json _decode ( $ resp , true ) ; if ( $ this - > _handle Error ( $ data ) ) { return false ; } $ cards = array ( ) ; foreach ( $ data as $ card ) { $ cards [ ] = Quick Books _Payments _Credit Card : : from Array ( $ card ) ; } return $ cards ; } 
public function delete Card ( $ Context , $ id , $ card _id ) { $ id = str _replace ( array ( ' { ' , ' } ' , ' - ' ) , ' ' , $ id ) ; $ url = str _replace ( ' <id > ' , $ id , Quick Books _Payments : : URL _CARD . ' / ' . $ card _id ) ; $ resp = $ this - > _http ( $ Context , $ url , null , 'DELETE ' ) ; $ data = json _decode ( $ resp , true ) ; if ( $ this - > _handle Error ( $ data ) ) { return false ; } return true ; } 
protected function _handle Error ( $ data , $ ignore _declines = false ) { if ( ! $ data ) { 
protected function _set Error ( $ errnum , $ errmsg = ' ' , $ type = null , $ detail = null , $ infolink = null ) { $ this - > _last _errnum = $ errnum ; $ this - > _last _errmsg = $ errmsg ; $ this - > _last _errtype = $ type ; $ this - > _last _errdetail = $ detail ; $ this - > _last _errinfolink = $ infolink ; } 
protected function _http ( $ Context , $ url _path , $ raw _body = null , $ operation = null ) { if ( $ operation ! = = null ) { $ method = $ operation ; } else { $ method = 'GET ' ; if ( $ raw _body ) { $ method = 'POST ' ; } } $ url = $ this - > _get Base URL ( ) . $ url _path ; $ authcreds = $ Context - > authcreds ( ) ; $ params = array ( ) ; $ OAuth = new Quick Books _IPP _OAuth ( $ this - > _oauth _consumer _key , $ this - > _oauth _consumer _secret ) ; $ signed = $ OAuth - > sign ( $ method , $ url , $ authcreds [ 'oauth _access _token ' ] , $ authcreds [ 'oauth _access _token _secret ' ] , $ params ) ; 
protected static function _map To Quick Books ID ( $ func , $ user , $ type , $ ID ) { if ( strlen ( $ func ) ) { if ( false = = = strpos ( $ func , ' : : ' ) ) { return $ func ( $ type , $ ID ) ; } else { $ tmp = explode ( ' : : ' , $ func ) ; return call _user _func ( array ( $ tmp [ 0 ] , $ tmp [ 1 ] ) , $ type , $ ID ) ; } } else { $ editsequence = ' ' ; $ extra = null ; 
static protected function _map To Application ID ( $ func , $ user , $ type , $ List ID _or _Txn ID ) { if ( strlen ( $ func ) ) { if ( false = = = strpos ( $ func , ' : : ' ) ) { return $ func ( $ type , $ List ID _or _Txn ID ) ; } else { $ tmp = explode ( ' : : ' , $ func ) ; return call _user _func ( array ( $ tmp [ 0 ] , $ tmp [ 1 ] ) , $ type , $ List ID _or _Txn ID ) ; } } else { $ extra = null ; $ Driver = Quick Books _Driver _Singleton : : get Instance ( ) ; return $ Driver - > ident To Application ( $ user , $ type , $ List ID _or _Txn ID , $ extra ) ; } } 
public static function Ship Method Add Request ( $ request ID , $ user , $ action , $ ID , $ extra , & $ err , $ last _action _time , $ last _actionident _time , $ version , $ locale , $ config = array ( ) , $ qbxml = null ) { return Quick Books _Callbacks _API _Callbacks : : _do Add Request ( $ request ID , $ user , $ action , $ ID , $ extra , $ err , $ last _action _time , $ last _actionident _time , $ version , $ locale , $ config , $ qbxml ) ; } 
static public function on Authenticate ( $ request ID , $ user , $ hook , & $ err , $ hook _data , $ callback _config ) { $sql _query = array ( ) ; foreach (Quick Books _Utilities : :list Actions ( ' *QUERY * ' ) as $action ) { $sql _query [ $action ] = Quick Books _Utilities : :priority For Action ( $action ) ; } $sql _query = Quick Books _Callbacks _SQL _Callbacks : : _filter Actions ( $sql _query , $callback _config [ ' _only _query ' ] , $callback _config [ ' _dont _query ' ] , QUICKBOOKS _QUERY ) ; * / foreach ( $sql _audit as $action = > $priority ) { if ( !isset ( $sql _map [ $action ] ) ) { continue ; } $Driver - >queue Enqueue ( $user , $action , 1 , true , $priority ) ; } * / SELECT " . QUICKBOOKS _DRIVER _SQL _FIELD _ID . " , " . QUICKBOOKS _DRIVER _SQL _FIELD _ERROR _NUMBER . " FROM " . QUICKBOOKS _DRIVER _SQL _PREFIX _SQL . $ table _and _field [ 0 ] . " WHERE " . QUICKBOOKS _DRIVER _SQL _FIELD _DISCOVER . " IS NOT NULL AND " . QUICKBOOKS _DRIVER _SQL _FIELD _RESYNC . " IS NOT NULL AND " . QUICKBOOKS _DRIVER _SQL _FIELD _MODIFY . " > " . QUICKBOOKS _DRIVER _SQL _FIELD _RESYNC . " AND " . QUICKBOOKS _DRIVER _SQL _FIELD _TO _DELETE . " ! = 1 AND " . QUICKBOOKS _DRIVER _SQL _FIELD _FLAG _DELETED . " ! = 1 AND " . QUICKBOOKS _DRIVER _SQL _FIELD _TO _VOID . " ! = 1 AND " . QUICKBOOKS _DRIVER _SQL _FIELD _TO _SKIP . " ! = 1 AND " . QUICKBOOKS _DRIVER _SQL _FIELD _MODIFY . " < = ' " . $ NOW . " ' " ; $ errnum = 0 ; $ errmsg = ' ' ; $ res = $ Driver - > query ( $ sql , $ errnum , $ errmsg ) ; while ( $ arr = $ Driver - > fetch ( $ res ) ) { if ( strlen ( $ arr [ QUICKBOOKS _DRIVER _SQL _FIELD _ERROR _NUMBER ] ) ) { / / Do not sync this record until the error is resolved continue ; } / / Queue up this MOD request $ Driver - > queue Enqueue ( $ user , $ action , $ arr [ QUICKBOOKS _DRIVER _SQL _FIELD _ID ] , true , $ priority ) ; $ actions [ ] = $ action ; / / Mark the record as enqueued - let 's wait until the hashing is in for this / / $Driver - >query ( . . . , $errnum , $errmsg ) ; } } } } / /print ( ' 4 [ ' . (microtime (true ) - $start ) . ' ] ' . " \n \n " ) ; $start = microtime (true ) ; if ( $ mode = = Quick Books _Web Connector _Server _SQL : : MODE _WRITEONLY or $ mode = = Quick Books _Web Connector _Server _SQL : : MODE _READWRITE ) { / / Check if any *voided * objects need to be voided in Quick Books foreach ( $ sql _add as $ action = > $ priority ) { $ object = Quick Books _Utilities : : action To Object ( $ action ) ; $ dependency = null ; if ( $ object = = QUICKBOOKS _OBJECT _BILL ) { / / Bill VOID dependency is Purchase Order Mod because we want to be able to manually close POs (but need to VOID the bills first ) $ dependency = QUICKBOOKS _MOD _PURCHASEORDER ; } $ priority = Quick Books _Utilities : : priority For Action ( QUICKBOOKS _VOID _TRANSACTION , $ dependency ) ; $ table _and _field = array ( ) ; / / Convert to table and primary key , select qbsql id Quick Books _SQL _Schema : : map Primary Key ( $ object , QUICKBOOKS _SQL _SCHEMA _MAP _TO _SQL , $ table _and _field ) ; / / $Driver - >log ( 'Searching table : ' . print _r ( $table _and _field , true ) . ' for VOIDED records . ' , null , QUICKBOOKS _LOG _DEBUG ) ; if ( ! empty ( $ table _and _field [ 0 ] ) ) { $ sql = " SELECT " . QUICKBOOKS _DRIVER _SQL _FIELD _ID . " FROM " . QUICKBOOKS _DRIVER _SQL _PREFIX _SQL . $ table _and _field [ 0 ] . " WHERE " . QUICKBOOKS _DRIVER _SQL _FIELD _DISCOVER . " IS NOT NULL AND " . QUICKBOOKS _DRIVER _SQL _FIELD _TO _DELETE . " ! = 1 AND " . QUICKBOOKS _DRIVER _SQL _FIELD _FLAG _DELETED . " ! = 1 AND " . QUICKBOOKS _DRIVER _SQL _FIELD _TO _VOID . " = 1 AND " . QUICKBOOKS _DRIVER _SQL _FIELD _FLAG _VOIDED . " ! = 1 AND " . QUICKBOOKS _DRIVER _SQL _FIELD _MODIFY . " < = ' " . $ NOW . " ' " ; $ errnum = 0 ; $ errmsg = ' ' ; $ res = $ Driver - > query ( $ sql , $ errnum , $ errmsg ) ; $ extra = array ( 'object ' = > $ object , ) ; while ( $ arr = $ Driver - > fetch ( $ res ) ) { $ Driver - > queue Enqueue ( $ user , QUICKBOOKS _VOID _TRANSACTION , $ arr [ QUICKBOOKS _DRIVER _SQL _FIELD _ID ] , true , $ priority , $ extra ) ; } } } } / /print ( ' 5 [ ' . (microtime (true ) - $start ) . ' ] ' . " \n \n " ) ; $start = microtime (true ) ; if ( $ mode = = Quick Books _Web Connector _Server _SQL : : MODE _WRITEONLY or $ mode = = Quick Books _Web Connector _Server _SQL : : MODE _READWRITE ) { / / Check if any *deleted * objects need to be deleted from Quick Books foreach ( $ sql _add as $ action = > $ priority ) { break ; $ priority = 1 0 0 0 - $ priority ; $ object = Quick Books _Utilities : : action To Object ( $ action ) ; $ table _and _field = array ( ) ; / / Convert to table and primary key , select qbsql id Quick Books _SQL _Schema : : map Primary Key ( $ object , QUICKBOOKS _SQL _SCHEMA _MAP _TO _SQL , $ table _and _field ) ; / / Delete if it 's marked for deletion and it hasn 't been deleted already if ( ! empty ( $ table _and _field [ 0 ] ) ) { $ sql = " SELECT " . QUICKBOOKS _DRIVER _SQL _FIELD _ID . " FROM " . QUICKBOOKS _DRIVER _SQL _PREFIX _SQL . $ table _and _field [ 0 ] . " WHERE " . QUICKBOOKS _DRIVER _SQL _FIELD _TO _DELETE . " = 1 AND " . QUICKBOOKS _DRIVER _SQL _FIELD _FLAG _DELETED . " ! = 1 AND " . QUICKBOOKS _DRIVER _SQL _FIELD _MODIFY . " < = ' " . $ NOW . " ' " ; $ errnum = 0 ; $ errmsg = ' ' ; $ res = $ Driver - > query ( $ sql , $ errnum , $ errmsg ) ; $ key = Quick Books _Utilities : : key For Action ( $ action ) ; if ( $ key = = 'List ID ' ) { $ use Action = 'List Del ' ; } else { $ use Action = 'Txn Del ' ; } $ extra [ 'object Type ' ] = $ object ; while ( $ arr = $ Driver - > fetch ( $ res ) ) { $ Driver - > queue Enqueue ( $ user , $ use Action , $ extra [ 'object Type ' ] . $ arr [ QUICKBOOKS _DRIVER _SQL _FIELD _ID ] , true , $ priority , $ extra ) ; } } } } / /print ( ' 6 [ ' . (microtime (true ) - $start ) . ' ] ' . " \n \n " ) ; $start = microtime (true ) ; / * / / This makes sure that timestamps are set up for every action we 're doing (fixes a bug where timestamps never get recorded on initial sync without iterator ) foreach ( $actions as $action ) { $module = _ _CLASS _ _ ; $key _curr = Quick Books _Callbacks _SQL _Callbacks : : _key Sync Curr ( $action ) ; $key _prev = Quick Books _Callbacks _SQL _Callbacks : : _key Sync Prev ( $action ) ; $type = null ; $opts = null ; $curr _sync _datetime = $Driver - >config Read ( $user , $module , $key _curr , $type , $opts ) ; / / last sync started . . . $prev _sync _datetime = $Driver - >config Read ( $user , $module , $key _prev , $type , $opts ) ; / / last sync started . . . $datetime = Quick Books _Utilities : :datetime ( ' 1 9 8 3 - 0 1 - 0 2 ' ) ; if ( ! $curr _sync _datetime ) { $Driver - >config Write ( $user , $module , $key _curr , $datetime , null ) ; } if ( ! $prev _sync _datetime ) { $Driver - >config Write ( $user , $module , $key _prev , $datetime , null ) ; } } * / / /print ( " \n \n " . 'here [ ' . (microtime (true ) - $ _start ) . ' ] ' . " \n \n \n " ) ; return true ; } 
static protected function _filter Actions ( $ action _to _priority , $ only _do , $ dont _do , $ type ) { $ start = microtime ( true ) ; foreach ( $ action _to _priority as $ action = > $ priority ) { 
protected static function _required Version ( $ required , $ current , $ locale = QUICKBOOKS _LOCALE _US , $ action = null ) { if ( $ locale = = QUICKBOOKS _LOCALE _US ) { return $ current > = $ required ; } return true ; } 
protected static function _required Version For Element ( $ required , $ current , $ element , $ locale = QUICKBOOKS _LOCALE _US , $ action = null ) { if ( $ locale = QUICKBOOKS _LOCALE _US ) { if ( $ current > = $ required ) { return $ element ; } } return ' ' ; } 
protected static function _build Iterator ( $ extra , $ version = null , $ locale = null ) { $ xml = " " ; if ( $ locale = = QUICKBOOKS _LOCALE _CA or $ locale = = QUICKBOOKS _LOCALE _UK or $ locale = = QUICKBOOKS _LOCALE _AU ) { return ' ' ; } if ( is _array ( $ extra ) and ! empty ( $ extra [ 'iterator ID ' ] ) ) { $ xml . = ' iterator = "Continue " iterator ID = " ' . $ extra [ 'iterator ID ' ] . ' " ' ; } else { $ xml . = ' iterator = "Start " ' ; } $ xml . = ' > ' . " \n " ; $ xml . = " \t " . ' <Max Returned > ' ; if ( is _array ( $ extra ) and ! empty ( $ extra [ 'max Returned ' ] ) ) { $ xml . = $ extra [ 'max Returned ' ] ; } else { $ xml . = QUICKBOOKS _SERVER _SQL _ITERATOR _MAXRETURNED ; } $ xml . = ' < /Max Returned ' ; return $ xml ; } 
public static function Inventory Levels Response ( $ request ID , $ user , $ action , $ ID , $ extra , & $ err , $ last _action _time , $ last _actionident _time , $ xml , $ idents , $ callback _config = array ( ) ) { $ Driver = Quick Books _Driver _Singleton : : get Instance ( ) ; $ col _defs = array ( ) ; Inventory for "another inventory " : Array ( [Full Name ] = > another inventory [Blank ] = > another inventory [Item Desc ] = > [Item Vendor ] = > [Reorder Point ] = > 5 [Quantity On Hand ] = > 3 5 [Suggested Reorder ] = > false [Quantity On Order ] = > 0 [Earliest Receipt Date ] = > [Sales Per Week ] = > 0 ) * / $ Driver - > log ( 'Inventory for " ' . $ item [ 'Full Name ' ] . ' " : ' . print _r ( $ item , true ) , null , QUICKBOOKS _LOG _DEBUG ) ; UPDATE " . QUICKBOOKS _DRIVER _SQL _PREFIX _SQL . "iteminventory SET Quantity On Hand = " . ( float ) $ item [ 'Quantity On Hand ' ] . " , Quantity On Order = " . ( float ) $ item [ 'Quantity On Order ' ] . " , Quantity On Sales Order = " . ( float ) $ item [ 'Quantity On Sales Order ' ] . " , qbsql _resync _datetime = ' %s ' , qbsql _modify _timestamp = ' %s ' WHERE Full Name = ' %s ' AND qbsql _resync _datetime = qbsql _modify _timestamp " ; $ datetime = date ( 'Y -m -d H :i :s ' ) ; $ vars 1 = array ( $ datetime , $ datetime , $ item [ 'Full Name ' ] ) ; $ errnum = null ; $ errmsg = null ; $ Driver - > query ( $ sql 1 , $ errnum , $ errmsg , 0 , 1 , $ vars 1 ) ; / / $Driver - >log ( $sql 1 , null , QUICKBOOKS _LOG _DEBUG ) ; if ( ! $ Driver - > affected ( ) ) { $ sql 2 = " UPDATE " . QUICKBOOKS _DRIVER _SQL _PREFIX _SQL . "iteminventory SET Quantity On Hand = " . ( float ) $ item [ 'Quantity On Hand ' ] . " , Quantity On Order = " . ( float ) $ item [ 'Quantity On Order ' ] . " , Quantity On Sales Order = " . ( float ) $ item [ 'Quantity On Sales Order ' ] . " WHERE Full Name = ' %s ' " ; $ vars 2 = array ( $ item [ 'Full Name ' ] ) ; $ errnum = null ; $ errmsg = null ; $ Driver - > query ( $ sql 2 , $ errnum , $ errmsg , 0 , 1 , $ vars 2 ) ; 
public static function List Deleted Query Request ( $ request ID , $ user , $ action , $ ID , $ extra , & $ err , $ last _action _time , $ last _actionident _time , $ version , $ locale , $ config = array ( ) ) { $ xml = ' ' ; if ( ! Quick Books _Callbacks _SQL _Callbacks : : _required Version ( 2 . 0 , $ version , $ locale , QUICKBOOKS _DEL _LIST ) ) { return QUICKBOOKS _SKIP ; } $ xml . = ' < ?xml version = " 1 . 0 " encoding = "utf - 8 " ? > < ?qbxml version = " ' . Quick Books _Callbacks _SQL _Callbacks : : _version ( $ version , $ locale ) . ' " ? > <QBXML > <QBXMLMsgs Rq on Error = " ' . QUICKBOOKS _SERVER _SQL _ON _ERROR . ' " > <List Deleted Query Rq request ID = " ' . $ request ID . ' " > <List Del Type >Account < /List Del Type > <List Del Type >Billing Rate < /List Del Type > <List Del Type >Class < /List Del Type > <List Del Type >Customer < /List Del Type > <List Del Type >Customer Msg < /List Del Type > <List Del Type >Customer Type < /List Del Type > <List Del Type >Date Driven Terms < /List Del Type > <List Del Type >Employee < /List Del Type > <List Del Type >Item Discount < /List Del Type > <List Del Type >Item Fixed Asset < /List Del Type > <List Del Type >Item Group < /List Del Type > <List Del Type >Item Inventory < /List Del Type > <List Del Type >Item Inventory Assembly < /List Del Type > <List Del Type >Item Non Inventory < /List Del Type > <List Del Type >Item Other Charge < /List Del Type > <List Del Type >Item Payment < /List Del Type > <List Del Type >Item Sales Tax < /List Del Type > <List Del Type >Item Sales Tax Group < /List Del Type > <List Del Type >Item Service < /List Del Type > <List Del Type >Item Subtotal < /List Del Type > <List Del Type >Job Type < /List Del Type > <List Del Type >Other Name < /List Del Type > <List Del Type >Payment Method < /List Del Type > <List Del Type >Payroll Item Non Wage < /List Del Type > <List Del Type >Payroll Item Wage < /List Del Type > <List Del Type >Price Level < /List Del Type > <List Del Type >Sales Rep < /List Del Type > <List Del Type >Sales Tax Code < /List Del Type > <List Del Type >Ship Method < /List Del Type > <List Del Type >Standard Terms < /List Del Type > <List Del Type >To Do < /List Del Type > <List Del Type >Unit Of Measure Set < /List Del Type > <List Del Type >Vehicle < /List Del Type > <List Del Type >Vendor < /List Del Type > <List Del Type >Vendor Type < /List Del Type > ' . Quick Books _Callbacks _SQL _Callbacks : : _build Filter ( $ user , $ action , $ extra , true ) . ' < /List Deleted Query Rq > < /QBXMLMsgs Rq > < /QBXML > ' ; return $ xml ; } 
public static function List Deleted Query Response ( $ request ID , $ user , $ action , $ ID , $ extra , & $ err , $ last _action _time , $ last _actionident _time , $ xml , $ idents , $ config = array ( ) ) { $ Driver = Quick Books _Driver _Singleton : : get Instance ( ) ; $ Parser = new Quick Books _XML _Parser ( $ xml ) ; $ errnum = 0 ; $ errmsg = ' ' ; $ Doc = $ Parser - > parse ( $ errnum , $ errmsg ) ; $ Root = $ Doc - > get Root ( ) ; $ List = $ Root - > get Child At ( 'QBXML QBXMLMsgs Rs List Deleted Query Rs ' ) ; foreach ( $ List - > children ( ) as $ Node ) { $ map = array ( ) ; $ others = array ( ) ; Quick Books _SQL _Schema : : map To Schema ( trim ( Quick Books _Utilities : : object To XMLElement ( $ Node - > get Child Data At ( 'List Deleted Ret List Del Type ' ) ) ) , QUICKBOOKS _SQL _SCHEMA _MAP _TO _SQL , $ map , $ others ) ; if ( isset ( $ map [ 0 ] ) ) { $ table = $ map [ 0 ] ; $ data = array ( 'qbsql _flag _deleted ' = > 1 , ) ; $ multipart = array ( 'List ID ' = > $ Node - > get Child Data At ( 'List Deleted Ret List ID ' ) ) ; $ Driver - > update ( QUICKBOOKS _DRIVER _SQL _PREFIX _SQL . $ table , $ data , array ( $ multipart ) ) ; } } return true ; } 
public static function Txn Void Request ( $ request ID , $ user , $ action , $ ID , $ extra , & $ err , $ last _action _time , $ last _actionident _time , $ version , $ locale , $ config = array ( ) ) { $ Driver = Quick Books _Driver _Singleton : : get Instance ( ) ; if ( $ arr = $ Driver - > get ( QUICKBOOKS _DRIVER _SQL _PREFIX _SQL . strtolower ( $ extra [ 'object ' ] ) , array ( QUICKBOOKS _DRIVER _SQL _FIELD _ID = > $ ID ) ) ) { $ xml = ' ' ; $ xml . = ' < ?xml version = " 1 . 0 " encoding = "utf - 8 " ? > < ?qbxml version = " ' . Quick Books _Callbacks _SQL _Callbacks : : _version ( $ version , $ locale ) . ' " ? > <QBXML > <QBXMLMsgs Rq on Error = "stop On Error " > <Txn Void Rq request ID = " ' . $ request ID . ' " > <Txn Void Type > ' . $ extra [ 'object ' ] . ' < /Txn Void Type > <Txn ID > ' . $ arr [ 'Txn ID ' ] . ' < /Txn ID > < /Txn Void Rq > < /QBXMLMsgs Rq > < /QBXML > ' ; return $ xml ; } return ' ' ; } 
public static function Txn Void Response ( $ request ID , $ user , $ action , $ ID , $ extra , & $ err , $ last _action _time , $ last _actionident _time , $ xml , $ idents , $ config = array ( ) ) { $ Driver = Quick Books _Driver _Singleton : : get Instance ( ) ; 
public static function Customer Derive Request ( $ request ID , $ user , $ action , $ ID , $ extra , & $ err , $ last _action _time , $ last _actionident _time , $ version , $ locale , $ config = array ( ) ) { if ( ! empty ( $ extra [ 'List ID ' ] ) ) { $ xml = ' ' ; $ xml . = ' < ?xml version = " 1 . 0 " encoding = "utf - 8 " ? > < ?qbxml version = " ' . $ version . ' " ? > <QBXML > <QBXMLMsgs Rq on Error = " ' . QUICKBOOKS _SERVER _SQL _ON _ERROR . ' " > <Customer Query Rq request ID = " ' . $ request ID . ' " > <List ID > ' . $ extra [ 'List ID ' ] . ' < /List ID > < /Customer Query Rq > < /QBXMLMsgs Rq > < /QBXML > ' ; return $ xml ; } else if ( ! empty ( $ extra [ 'Full Name ' ] ) ) { $ xml = ' ' ; $ xml . = ' < ?xml version = " 1 . 0 " encoding = "utf - 8 " ? > < ?qbxml version = " ' . $ version . ' " ? > <QBXML > <QBXMLMsgs Rq on Error = " ' . QUICKBOOKS _SERVER _SQL _ON _ERROR . ' " > <Customer Query Rq request ID = " ' . $ request ID . ' " > <Full Name > ' . Quick Books _Cast : : cast ( QUICKBOOKS _OBJECT _CUSTOMER , 'Full Name ' , $ extra [ 'Full Name ' ] ) . ' < /Full Name > < /Customer Query Rq > < /QBXMLMsgs Rq > < /QBXML > ' ; return $ xml ; } $ err = ' ' . _ _METHOD _ _ . ' called without a proper $extra array : ' . print _r ( $ extra , true ) ; return ' ' ; 
public static function Customer Derive Response ( $ request ID , $ user , $ action , $ ID , $ extra , & $ err , $ last _action _time , $ last _actionident _time , $ xml , $ idents , $ config = array ( ) ) { return Quick Books _Callbacks _SQL _Callbacks : : _derive Response ( 'QBXML QBXMLMsgs Rs Customer Query Rs ' , QUICKBOOKS _OBJECT _CUSTOMER , $ request ID , $ user , $ action , $ ID , $ extra , $ err , $ last _action _time , $ last _actionident _time , $ xml , $ idents , $ config ) ; } 
public static function Invoice Derive Request ( $ request ID , $ user , $ action , $ ID , $ extra , & $ err , $ last _action _time , $ last _actionident _time , $ version , $ locale , $ config = array ( ) ) { < ?qbxml version = " ' . $ version . ' " ? > <QBXML > <QBXMLMsgs Rq on Error = " ' . QUICKBOOKS _SERVER _SQL _ON _ERROR . ' " > <Invoice Query Rq request ID = " ' . $ request ID . ' " > <Txn ID > ' . $ extra [ 'Txn ID ' ] . ' < /Txn ID > < /Invoice Query Rq > < /QBXMLMsgs Rq > < /QBXML > ' ; return $ xml ; } else if ( $ arr = $ Driver - > get ( QUICKBOOKS _DRIVER _SQL _PREFIX _SQL . 'invoice ' , array ( QUICKBOOKS _DRIVER _SQL _FIELD _ID = > $ ID ) ) ) { $ xml = ' ' ; $ xml . = ' < ?xml version = " 1 . 0 " encoding = "utf - 8 " ? > < ?qbxml version = " ' . $ version . ' " ? > <QBXML > <QBXMLMsgs Rq on Error = " ' . QUICKBOOKS _SERVER _SQL _ON _ERROR . ' " > <Invoice Query Rq request ID = " ' . $ request ID . ' " > <Txn ID > ' . $ arr [ 'Txn ID ' ] . ' < /Txn ID > < /Invoice Query Rq > < /QBXMLMsgs Rq > < /QBXML > ' ; return $ xml ; } $ err = ' ' . _ _METHOD _ _ . ' called without a proper $extra array : ' . print _r ( $ extra , true ) ; return ' ' ; 
public static function Invoice Derive Response ( $ request ID , $ user , $ action , $ ID , $ extra , & $ err , $ last _action _time , $ last _actionident _time , $ xml , $ idents , $ config = array ( ) ) { return Quick Books _Callbacks _SQL _Callbacks : : _derive Response ( 'QBXML QBXMLMsgs Rs Invoice Query Rs ' , QUICKBOOKS _OBJECT _INVOICE , $ request ID , $ user , $ action , $ ID , $ extra , $ err , $ last _action _time , $ last _actionident _time , $ xml , $ idents , $ config ) ; } 
public static function Sales Receipt Mod Request ( $ request ID , $ user , $ action , $ ID , $ extra , & $ err , $ last _action _time , $ last _actionident _time , $ version , $ locale , $ config = array ( ) ) { $ Driver = Quick Books _Driver _Singleton : : get Instance ( ) ; if ( $ Sales Receipt = $ Driver - > get ( QUICKBOOKS _DRIVER _SQL _PREFIX _SQL . 'salesreceipt ' , array ( QUICKBOOKS _DRIVER _SQL _FIELD _ID = > $ ID ) ) ) { return Quick Books _Callbacks _SQL _Callbacks : : _Add Request ( QUICKBOOKS _OBJECT _SALESRECEIPT , $ Sales Receipt , $ request ID , $ user , $ action , $ ID , $ extra , $ err , $ last _action _time , $ last _actionident _time , $ version , $ locale , $ config ) ; } return ' ' ; } 
public static function Job Type Add Request ( $ request ID , $ user , $ action , $ ID , $ extra , & $ err , $ last _action _time , $ last _actionident _time , $ version , $ locale , $ config = array ( ) ) { $ Driver = Quick Books _Driver _Singleton : : get Instance ( ) ; if ( $ Job Type = $ Driver - > get ( QUICKBOOKS _DRIVER _SQL _PREFIX _SQL . 'jobtype ' , array ( QUICKBOOKS _DRIVER _SQL _FIELD _ID = > $ ID ) ) ) { return Quick Books _Callbacks _SQL _Callbacks : : _Add Request ( QUICKBOOKS _OBJECT _JOBTYPE , $ Job Type , $ request ID , $ user , $ action , $ ID , $ extra , $ err , $ last _action _time , $ last _actionident _time , $ version , $ locale , $ config ) ; } return ' ' ; } 
protected static function _Add Request ( $ type , $ Object , $ request ID , $ user , $ action , $ ID , $ extra , & $ err , $ last _action _time , $ last _actionident _time , $ version , $ locale , $ config = array ( ) ) { ( strlen ( $Object - >get ( $begi . 'City ' ) ) or strlen ( $Object - >get ( $begi . 'State ' ) ) or strlen ( $Object - >get ( $begi . 'Country ' ) ) or strlen ( $Object - >get ( $begi . 'Postal Code ' ) ) ) ) { continue ; } * / ; < /QBXMLMsgs Rq > < /QBXML > ' ; return $ xml ; } 
protected static function _update Relatives ( $ table , $ user , $ action , $ ID , $ object , $ extra , $ callback _config = array ( ) , $ delete Data Ext = false , $ full Delete = false ) { $ update _relatives _map = array ( 'account ' = > array ( 'id _field ' = > 'List ID ' , 'relatives ' = > array ( 'invoice ' = > 'ARAccount _List ID ' ) ) , 'bill ' = > array ( 'id _field ' = > 'Txn ID ' , 'relatives ' = > array ( 'billpaymentcheck _appliedtotxn ' = > 'To Txn ID ' , 'billpaymentcreditcard _appliedtotxn ' = > 'To Txn ID ' , "billingrate " = > array ( "id _field " = > "List ID " , "relatives " = > array ( "billingrate _billingrateperitem " = > "Billing Rate _List ID " ) ) , "billpaymentcheck " = > array ( "id _field " = > "List ID " , "relatives " = > array ( "billpaymentcheck _appliedtotxn " = > "From Txn ID " , "dataext " = > "Entity _List ID " ) ) , "billpaymentcreditcard " = > array ( "id _field " = > "List ID " , "relatives " = > array ( "billpaymentcreditcard _appliedtotxn " = > "From Txn ID " , "dataext " = > "Entity _List ID " ) ) , "charge " = > array ( "id _field " = > "Txn ID " , "relatives " = > array ( "dataext " = > "Txn _Txn ID " ) ) , "check " = > array ( "id _field " = > "Txn ID " , "relatives " = > array ( "check _expenseline " = > "Check _Txn ID " , "check _itemgroupline " = > "Check _Txn ID " , "check _itemgroupline _itemline " = > "Check _Txn ID " , "check _itemline " = > "Check _Txn ID " , "check _linkedtxn " = > "From Txn ID " , "dataext " = > "Txn _Txn ID " ) ) , "company " = > array ( "id _field " = > "Company Name " , "relatives " = > array ( "company _subscribedservices _service " = > "Company _Company Name " ) ) , "creditcardcharge " = > array ( "id _field " = > "Txn ID " , "relatives " = > array ( "creditcardcharge _expenseline " = > "Credit Card Charge _Txn ID " , "creditcardcharge _itemgroupline " = > "Credit Card Charge _Txn ID " , "creditcardcharge _itemgroupline _itemline " = > "Credit Card Charge _Txn ID " , "creditcardcharge _itemline " = > "Credit Card Charge _Txn ID " , "dataext " = > "Txn _Txn ID " ) ) , "creditcardcredit " = > array ( "id _field " = > "Txn ID " , "relatives " = > array ( "creditcardcredit _expenseline " = > "Credit Card Credit _Txn ID " , "creditcardcredit _itemgroupline " = > "Credit Card Credit _Txn ID " , "creditcardcredit _itemgroupline _itemline " = > "Credit Card Credit _Txn ID " , "creditcardcredit _itemline " = > "Credit Card Credit _Txn ID " , "dataext " = > "Txn _Txn ID " ) ) , "creditmemo " = > array ( "id _field " = > "Txn ID " , "relatives " = > array ( "creditmemo _creditmemoline " = > "Credit Memo _Txn ID " , "creditmemo _creditmemolinegroup " = > "Credit Memo _Txn ID " , "creditmemo _creditmemolinegroup _creditmemoline " = > "Credit Memo _Txn ID " , "creditmemo _linkedtxn " = > "From Txn ID " , "dataext " = > "Txn _Txn ID " ) ) , "creditmemolinegroup " = > array ( "id _field " = > "Txn Line ID " , "relatives " = > array ( "dataext " = > "Txn _Txn ID " ) ) , "creditmemolinegroup _creditmemoline " = > array ( "id _field " = > "Txn Line ID " , "relatives " = > array ( "dataext " = > "Txn _Txn ID " ) ) , * / 'customer ' = > array ( 'id _field ' = > 'List ID ' , 'relatives ' = > array ( 'estimate ' = > 'Customer _List ID ' , 'salesorder ' = > 'Customer _List ID ' , 'purchaseorder _purchaseorderline ' = > 'Customer _List ID ' , 'invoice ' = > 'Customer _List ID ' , 'receivepayment ' = > 'Customer _List ID ' , 'purchaseorder ' = > 'Ship To Entity _List ID ' , 'salesreceipt ' = > 'Customer _List ID ' , ) ) , "employee " = > array ( "id _field " = > "List ID " , "relatives " = > array ( "salesrep " = > "Sales Rep Entity _List ID " ) ) , 'invoice ' = > array ( 'id _field ' = > 'Txn ID ' , 'relatives ' = > array ( 'estimate _linkedtxn ' = > 'To Txn ID ' , 'salesorder _linkedtxn ' = > 'To Txn ID ' , 'receivepayment _appliedtotxn ' = > 'To Txn ID ' , "invoice _invoiceline " = > array ( "id _field " = > "Txn Line ID " , "relatives " = > array ( "dataext " = > "Txn _Txn ID " ) ) , "invoice _invoicelinegroup " = > array ( "id _field " = > "Txn Line ID " , "relatives " = > array ( "dataext " = > "Txn _Txn ID " ) ) , "invoice _invoicelinegroup _invoiceline " = > array ( "id _field " = > "Txn Line ID " , "relatives " = > array ( "dataext " = > "Txn _Txn ID " ) ) , "itemgroup " = > array ( "id _field " = > "List ID " , "relatives " = > array ( "itemgroup _itemgroupline " = > "Item Group _List ID " , "dataext " = > "Entity _List ID " ) ) , * / "iteminventory " = > array ( "id _field " = > "List ID " , "relatives " = > array ( "estimate _estimateline " = > "Item _List ID " , "salesorder _salesorderline " = > "Item _List ID " , "purchaseorder _purchaseorderline " = > "Item _List ID " , "invoice _invoiceline " = > "Item _List ID " ) ) , "itemnoninventory " = > array ( "id _field " = > "List ID " , "relatives " = > array ( "estimate _estimateline " = > "Item _List ID " , "salesorder _salesorderline " = > "Item _List ID " , "purchaseorder _purchaseorderline " = > "Item _List ID " , "invoice _invoiceline " = > "Item _List ID " ) ) , "itemdiscount " = > array ( "id _field " = > "List ID " , "relatives " = > array ( "estimate _estimateline " = > "Item _List ID " , "salesorder _salesorderline " = > "Item _List ID " , "purchaseorder _purchaseorderline " = > "Item _List ID " , "invoice _invoiceline " = > "Item _List ID " ) ) , "itemfixedasset " = > array ( "id _field " = > "List ID " , "relatives " = > array ( "estimate _estimateline " = > "Item _List ID " , "salesorder _salesorderline " = > "Item _List ID " , "purchaseorder _purchaseorderline " = > "Item _List ID " , "invoice _invoiceline " = > "Item _List ID " ) ) , "itemothercharge " = > array ( "id _field " = > "List ID " , "relatives " = > array ( "estimate _estimateline " = > "Item _List ID " , "salesorder _salesorderline " = > "Item _List ID " , "purchaseorder _purchaseorderline " = > "Item _List ID " , "invoice _invoiceline " = > "Item _List ID " ) ) , "itempayment " = > array ( "id _field " = > "List ID " , "relatives " = > array ( "estimate _estimateline " = > "Item _List ID " , "salesorder _salesorderline " = > "Item _List ID " , "purchaseorder _purchaseorderline " = > "Item _List ID " , "invoice _invoiceline " = > "Item _List ID " ) ) , "itemsalestax " = > array ( "id _field " = > "List ID " , "relatives " = > array ( "estimate _estimateline " = > "Item _List ID " , "salesorder _salesorderline " = > "Item _List ID " , "purchaseorder _purchaseorderline " = > "Item _List ID " , "invoice _invoiceline " = > "Item _List ID " ) ) , "itemservice " = > array ( "id _field " = > "List ID " , "relatives " = > array ( "estimate _estimateline " = > "Item _List ID " , "salesorder _salesorderline " = > "Item _List ID " , "purchaseorder _purchaseorderline " = > "Item _List ID " , "invoice _invoiceline " = > "Item _List ID " ) ) , "itemsubtotal " = > array ( "id _field " = > "List ID " , "relatives " = > array ( "estimate _estimateline " = > "Item _List ID " , "salesorder _salesorderline " = > "Item _List ID " , "purchaseorder _purchaseorderline " = > "Item _List ID " , "invoice _invoiceline " = > "Item _List ID " ) ) , "purchaseorder " = > array ( "id _field " = > 'Txn ID ' , "relatives " = > array ( "purchaseorder _purchaseorderline " = > array ( "id _field " = > "Txn Line ID " , "relatives " = > array ( "dataext " = > "Txn _Txn ID " ) ) , "purchaseorder _purchaseorderlinegroup " = > array ( "id _field " = > "Txn Line ID " , "relatives " = > array ( "dataext " = > "Txn _Txn ID " ) ) , "purchaseorder _purchaseorderlinegroup _purchaseorderline " = > array ( "id _field " = > "Txn Line ID " , "relatives " = > array ( "dataext " = > "Txn _Txn ID " ) ) , "receievepayment " = > array ( "id _field " = > "Txn ID " , "relatives " = > array ( "receivepayment _appliedtotxn " = > "From Txn ID " , "dataext " = > "Txn _Txn ID " ) ) , "salesorder " = > array ( "id _field " = > "Txn ID " , "relatives " = > array ( "salesorder _salesorderline " = > "Sales Order _Txn ID " , "salesorder _salesorderlinegroup " = > "Sales Order _Txn ID " , "salesorder _salesorderlinegroup _salesorderline " = > "Sales Order _Txn ID " , "salesorder _linkedtxn " = > "From Txn ID " , "dataext " = > "Entity _List ID " ) ) , "salesorder _salesorderline " = > array ( "id _field " = > "Txn Line ID " , "relatives " = > array ( "dataext " = > "Txn _Txn ID " ) ) , "salesorder _salesorderlinegroup " = > array ( "id _field " = > "Txn Line ID " , "relatives " = > array ( "dataext " = > "Txn _Txn ID " ) ) , "salesorder _salesorderlinegroup _salesorderline " = > array ( "id _field " = > "Txn Line ID " , "relatives " = > array ( "dataext " = > "Txn _Txn ID " ) ) , "salesreceipt " = > array ( "id _field " = > "Txn ID " , "relatives " = > array ( "salesreceipt _salesreceiptline " = > "Sales Receipt _Txn ID " , "salesreceipt _salesreceiptlinegroup " = > "Sales Receipt _Txn ID " , "salesreceipt _salesreceiptlinegroup _salesreceiptline " = > "Sales Receipt _Txn ID " , "dataext " = > "Txn _Txn ID " ) ) , "salesreceipt _salesreceiptline " = > array ( "id _field " = > "Txn Line ID " , "relatives " = > array ( "dataext " = > "Txn _Txn ID " ) ) , "salereceipt _salesreceiptlinegroup " = > array ( "id _field " = > "Txn Line ID " , "relatives " = > array ( "dataext " = > "Txn _Txn ID " ) ) , "salesreceipt _salesreceiptlinegroup _salesreceiptline " = > array ( "id _field " = > "Txn Line ID " , "relatives " = > array ( "dataext " = > "Txn _Txn ID " ) ) , * / "salesrep " = > array ( "id _field " = > "List ID " , "relatives " = > array ( "estimate " = > "Sales Rep _List ID " , "salesorder " = > "Sales Rep _List ID " , "invoice " = > "Sales Rep _List ID " ) ) , "salestaxcode " = > array ( "id _field " = > "List ID " , "relatives " = > array ( "iteminventory " = > "Sales Tax Code _List ID " , "iteminventoryassembly " = > "Sales Tax Code _List ID " , "itemnoninventory " = > "Sales Tax Code _List ID " , "itemothercharge " = > "Sales Tax Code _List ID " , "itemservice " = > "Sales Tax Code _List ID " , "customer " = > "Sales Tax Code _List ID " , "estimate " = > "Customer Sales Tax Code _List ID " , "salesorder " = > "Customer Sales Tax Code _List ID " , "invoice " = > "Customer Sales Tax Code _List ID " ) ) , "vendor " = > array ( "id _field " = > "List ID " , "relatives " = > array ( "purchaseorder " = > "Vendor _List ID " ) ) , ) ; $ Driver = Quick Books _Driver _Singleton : : get Instance ( ) ; if ( ! isset ( $ update _relatives _map [ $ table ] ) ) { 
protected static function _build Filter ( $ user , $ action , $ extra , $ filter _wrap = false ) { $ Driver = Quick Books _Driver _Singleton : : get Instance ( ) ; $ xml = ' ' ; $ type = ' ' ; $ key _prev = Quick Books _Callbacks _SQL _Callbacks : : _key Sync Prev ( $ action ) ; $ key _curr = Quick Books _Callbacks _SQL _Callbacks : : _key Sync Curr ( $ action ) ; $ module = _ _CLASS _ _ ; 
public function flush Groups ( array $ groups ) { $ this - > ensure Cache Groups Exist ( $ groups ) ; foreach ( $ groups as $ group ) { $ this - > cache Manager - > flush Caches In Group ( $ group ) ; } } 
public function flush By Tags ( array $ tags , $ group = null ) { foreach ( $ tags as $ tag ) { if ( $ group = = = null ) { $ this - > cache Manager - > flush Caches By Tag ( $ tag ) ; } else { $ this - > cache Manager - > flush Caches In Group By Tag ( $ group , $ tag ) ; } } } 
public function flush By Tags And Groups ( array $ tags , array $ groups = null ) { if ( $ groups = = = null ) { $ this - > flush By Tags ( $ tags ) ; } else { $ this - > ensure Cache Groups Exist ( $ groups ) ; foreach ( $ groups as $ group ) { $ this - > flush By Tags ( $ tags , $ group ) ; } } } 
public function find ( string $ possible Name ) : string { $ all Commands = $ this - > get Names ( ) ; $ expr = preg _replace _callback ( ' { ( [ ^ : ] + | ) } ' , function ( $ matches ) { return preg _quote ( $ matches [ 1 ] , ' / ' ) . ' [ ^ : ] * ' ; } , $ possible Name ) ; $ commands = preg _grep ( ' { ^ ' . $ expr . ' } ' , $ all Commands ) ; if ( empty ( $ commands ) ) { $ commands = preg _grep ( ' { ^ ' . $ expr . ' }i ' , $ all Commands ) ; } 
public function run ( Script Event $ event ) : bool { $ composer = $ event - > get Composer ( ) ; $ composer Config = $ composer - > get Config ( ) ; $ base Path = realpath ( substr ( $ composer Config - > get ( 'vendor -dir ' ) , 0 , - strlen ( $ composer Config - > get ( 'vendor -dir ' , $ composer Config : : RELATIVE _PATHS ) ) ) ) ; $ command Configuration = [ ] ; foreach ( $ this - > extract Package Map From Composer ( $ composer ) as $ item ) { list ( $ package , $ install Path ) = $ item ; $ install Path = ( $ install Path ? : $ base Path ) ; $ package Name = $ package - > get Name ( ) ; $ package Type = $ package - > get Type ( ) ; if ( in _array ( $ package Type , [ 'metapackage ' , 'typo 3 -cms -extension ' , 'typo 3 -cms -framework ' ] , true ) ) { 
public function is Compatible ( $ extension Key , $ config Only = false ) { try { if ( $ config Only ) { return $ this - > can Load Ext Localconf File ( $ extension Key ) ; } return $ this - > can Load Ext Tables File ( $ extension Key ) ; } catch ( \ Throwable $ e ) { return false ; } } 
private function can Load Ext Localconf File ( $ extension Key ) { $ active Packages = $ this - > package Manager - > get Active Packages ( ) ; foreach ( $ active Packages as $ package ) { $ this - > load Ext Localconf For Extension ( $ package - > get Package Key ( ) ) ; if ( $ package - > get Package Key ( ) = = = $ extension Key ) { break ; } } return true ; } 
private function can Load Ext Tables File ( $ extension Key ) { $ active Packages = $ this - > package Manager - > get Active Packages ( ) ; foreach ( $ active Packages as $ package ) { 
private function load Ext Localconf For Extension ( $ extension Key ) { $ extension Info = $ GLOBALS [ 'TYPO 3 _LOADED _EXT ' ] [ $ extension Key ] ; 
private function load Ext Tables For Extension ( $ extension Key ) { $ extension Info = $ GLOBALS [ 'TYPO 3 _LOADED _EXT ' ] [ $ extension Key ] ; 
private function ensure Installation Is Possible ( array $ options ) { $ integrity Check = $ options [ 'integrity Check ' ] ? ? false ; if ( ! $ integrity Check ) { return ; } $ is Interactive = $ options [ 'interactive ' ] ? ? $ this - > output - > get Symfony Console Input ( ) - > is Interactive ( ) ; $ force Install = $ options [ 'force Install ' ] ? ? false ; $ local Conf File = PATH _typo 3conf . 'Local Configuration .php ' ; $ package States File = PATH _typo 3conf . 'Package States .php ' ; if ( ! $ force Install & & file _exists ( $ local Conf File ) ) { $ this - > output - > output Line ( ) ; $ this - > output - > output Line ( ' <error >TYPO 3 seems to be already set up ! < /error > ' ) ; $ proceed = $ is Interactive ; if ( $ is Interactive ) { $ this - > output - > output Line ( ) ; $ this - > output - > output Line ( ' <info >If you continue , your <code >typo 3conf /Local Configuration .php < /code > < /info > ' ) ; $ this - > output - > output Line ( ' <info >and <code >typo 3conf /Package States .php < /code > files will be deleted ! < /info > ' ) ; $ this - > output - > output Line ( ) ; $ proceed = $ this - > output - > ask Confirmation ( ' <info >Do you really want to proceed ? < /info > ( <comment >no < /comment > ) ' , false ) ; } if ( ! $ proceed ) { $ this - > output - > output Line ( ' <error >Installation aborted ! < /error > ' ) ; throw new Installation Failed Exception ( 'Installation aborted by user ' , 1 5 2 9 9 2 6 7 7 4 ) ; } } @ unlink ( $ local Conf File ) ; @ unlink ( $ package States File ) ; clearstatcache ( ) ; if ( file _exists ( $ local Conf File ) ) { $ this - > output - > output Line ( ) ; $ this - > output - > output Line ( ' <error >Unable to delete configuration file ! < /error > ' ) ; $ this - > output - > output Line ( ' <error >Installation aborted ! < /error > ' ) ; throw new Installation Failed Exception ( 'Installation aborted because of insufficient premissions ' , 1 5 2 9 9 2 6 8 1 0 ) ; } } 
private function execute Action With Arguments ( $ action Name , array $ arguments = [ ] , array $ options = [ ] ) { $ action Name = strtolower ( $ action Name ) ; 
public function run Command ( $ task = null , $ force = false , $ task Id = null ) { if ( $ task Id ! = = null ) { 
protected function execute Scheduled Tasks ( ) { 
protected function execute Single Task ( $ task Id , $ force Execution ) { 
public function get Safe Updates ( ) { $ sql Statements = $ this - > sql Reader - > get Create Table Statement Array ( $ this - > sql Reader - > get Tables Definition String ( ) ) ; $ add Create Change = $ this - > schema Migrator - > get Update Suggestions ( $ sql Statements ) ; 
public function get Destructive Updates ( ) { $ sql Statements = $ this - > sql Reader - > get Create Table Statement Array ( $ this - > sql Reader - > get Tables Definition String ( ) ) ; 
public function migrate ( array $ statements , array $ selected Statements ) { return $ this - > schema Migrator - > migrate ( $ this - > sql Reader - > get Create Table Statement Array ( $ this - > sql Reader - > get Tables Definition String ( ) ) , $ selected Statements ) ; } 
protected function render Reference ( Output Interface $ output ) : int { putenv ( 'TYPO 3 _CONSOLE _RENDERING _REFERENCE = 1 ' ) ; $ _SERVER [ 'PHP _SELF ' ] = Application : : COMMAND _NAME ; $ application = $ this - > get Application ( ) ; $ application Description = new Application Description ( $ application , null , true ) ; $ commands = $ application Description - > get Commands ( ) ; $ all Commands = [ ] ; foreach ( $ commands as $ command ) { if ( in _array ( $ command - > get Name ( ) , $ this - > skip Commands , true ) ) { continue ; } $ argument Descriptions = [ ] ; $ option Descriptions = [ ] ; $ command - > merge Application Definition ( false ) ; $ command Definition = $ command - > get Native Definition ( ) ; foreach ( $ command Definition - > get Arguments ( ) as $ argument ) { $ argument Descriptions [ $ argument - > get Name ( ) ] = $ this - > transform Markup ( $ argument - > get Description ( ) ) ; } foreach ( $ command Definition - > get Options ( ) as $ option ) { if ( $ application - > get Definition ( ) - > has Option ( $ option - > get Name ( ) ) ) { 
public function lock Command ( $ redirect Url = null ) { if ( @ is _file ( PATH _typo 3conf . 'LOCK _BACKEND ' ) ) { $ this - > output Line ( ' <warning >Backend is already locked . < /warning > ' ) ; $ this - > quit ( 0 ) ; } \ TYPO 3 \ CMS \ Core \ Utility \ General Utility : : write File ( PATH _typo 3conf . 'LOCK _BACKEND ' , ( string ) $ redirect Url ) ; if ( ! @ is _file ( PATH _typo 3conf . 'LOCK _BACKEND ' ) ) { $ this - > output Line ( ' <error >Could not create lock file \ 'typo 3conf /LOCK _BACKEND \ ' . < /error > ' ) ; $ this - > quit ( 2 ) ; } else { $ this - > output Line ( ' <info >Backend has been locked . Access is denied for every user until it is unlocked again . < /info > ' ) ; if ( $ redirect Url ! = = null ) { $ this - > output Line ( 'Any access to the backend will be redirected to : \ ' ' . $ redirect Url . ' \ ' ' ) ; } } } 
public function unlock Command ( ) { if ( ! @ is _file ( PATH _typo 3conf . 'LOCK _BACKEND ' ) ) { $ this - > output Line ( ' <warning >Backend is already unlocked . < /warning > ' ) ; $ this - > quit ( 0 ) ; } unlink ( PATH _typo 3conf . 'LOCK _BACKEND ' ) ; if ( @ is _file ( PATH _typo 3conf . 'LOCK _BACKEND ' ) ) { $ this - > output Line ( ' <error >Could not remove lock file \ 'typo 3conf /LOCK _BACKEND \ ' . < /error > ' ) ; $ this - > quit ( 2 ) ; } else { $ this - > output Line ( ' <info >Backend lock is removed . User can now access the backend again . < /info > ' ) ; } } 
public function lock For Editors Command ( ) { $ this - > ensure Config Value Modifiable ( ) ; $ locked For Editors = $ this - > configuration Service - > get Local ( 'BE /admin Only ' ) ! = = self : : LOCK _TYPE _UNLOCKED ; if ( ! $ locked For Editors ) { $ this - > configuration Service - > set Local ( 'BE /admin Only ' , self : : LOCK _TYPE _ADMIN ) ; $ this - > output Line ( ' <info >Locked backend for editor access . < /info > ' ) ; } else { $ this - > output Line ( ' <warning >The backend was already locked for editors , hence nothing was done . < /warning > ' ) ; } } 
public function unlock For Editors Command ( ) { $ this - > ensure Config Value Modifiable ( ) ; $ locked For Editors = $ this - > configuration Service - > get Local ( 'BE /admin Only ' ) ! = = self : : LOCK _TYPE _UNLOCKED ; if ( $ locked For Editors ) { $ this - > configuration Service - > set Local ( 'BE /admin Only ' , self : : LOCK _TYPE _UNLOCKED ) ; $ this - > output Line ( ' <info >Unlocked backend for editors . < /info > ' ) ; } else { $ this - > output Line ( ' <warning >The backend was not locked for editors . < /warning > ' ) ; } } 
public function create Admin Command ( string $ username , string $ password ) { $ given Username = $ username ; $ username = strtolower ( preg _replace ( ' / \ \s /i ' , ' ' , $ username ) ) ; if ( $ given Username ! = = $ username ) { $ this - > output Line ( ' <warning >Given username " %s " contains invalid characters . Using " %s " instead . < /warning > ' , [ $ given Username , $ username ] ) ; } if ( strlen ( $ username ) < 4 ) { $ this - > output Line ( ' <error >Username must be at least 4 characters . < /error > ' ) ; $ this - > quit ( 1 ) ; } if ( strlen ( $ password ) < 8 ) { $ this - > output Line ( ' <error >Password must be at least 8 characters . < /error > ' ) ; $ this - > quit ( 1 ) ; } $ connection Pool = General Utility : : make Instance ( Connection Pool : : class ) ; $ user Exists = $ connection Pool - > get Connection For Table ( 'be _users ' ) - > count ( 'uid ' , 'be _users ' , [ 'username ' = > $ username ] ) ; if ( $ user Exists ) { $ this - > output Line ( ' <error >A user with username " %s " already exists . < /error > ' , [ $ username ] ) ; $ this - > quit ( 1 ) ; } $ admin User Fields = [ 'username ' = > $ username , 'password ' = > $ this - > salt - > get Hashed Password ( $ password ) , 'admin ' = > 1 , 'tstamp ' = > $ GLOBALS [ 'EXEC _TIME ' ] , 'crdate ' = > $ GLOBALS [ 'EXEC _TIME ' ] , ] ; $ connection Pool - > get Connection For Table ( 'be _users ' ) - > insert ( 'be _users ' , $ admin User Fields ) ; $ this - > output Line ( ' <info >Created admin user with username " %s " . < /info > ' , [ $ username ] ) ; } 
protected function execute ( Input Interface $ input , Output Interface $ output ) { if ( $ this - > command = = = null ) { $ this - > command = $ this - > get Application ( ) - > find ( $ input - > get Argument ( 'command _name ' ) ) ; } if ( $ this - > command instanceof Command Controller Command & & $ this - > command - > is Late Command ( ) ) { $ output - > writeln ( ' <warning >Registering commands via $GLOBALS [ \ 'TYPO 3 _CONF _VARS \ ' ] [ \ 'SC _OPTIONS \ ' ] [ \ 'extbase \ ' ] [ \ 'command Controllers \ ' ] is deprecated and will be removed with 6 . 0 . Register Symfony commands in Configuration /Commands .php instead . < /warning > ' ) ; } $ helper = new Descriptor Helper ( ) ; 
public function list Wizards ( $ include Done = false ) { if ( empty ( $ this - > list Cache ) ) { $ available Upgrade Wizards = [ ] ; foreach ( $ this - > wizard Registry as $ identifier = > $ class Name ) { $ update Object = $ this - > factory - > create ( $ identifier ) ; $ short Identifier = $ this - > factory - > get Short Identifier ( $ identifier ) ; $ available Upgrade Wizards [ $ short Identifier ] = [ 'class Name ' = > $ class Name , 'title ' = > $ update Object - > get Title ( ) , 'done ' = > false , ] ; $ explanation = ' ' ; $ wizard Implements Interface = $ update Object instanceof Upgrade Wizard Interface & & ! $ update Object instanceof Abstract Update ; $ marked As Done = $ this - > registry - > get ( 'install Update ' , $ class Name , false ) | | $ this - > registry - > get ( 'install Update ' , $ identifier , false ) ; if ( $ wizard Implements Interface ) { $ explanation = $ update Object - > get Description ( ) ; $ wizard Claims Execution = $ update Object - > update Necessary ( ) ; } else { $ wizard Claims Execution = $ update Object - > check For Update ( $ explanation ) ; } if ( $ marked As Done | | ! $ wizard Claims Execution ) { $ available Upgrade Wizards [ $ short Identifier ] [ 'done ' ] = true ; } $ available Upgrade Wizards [ $ short Identifier ] [ 'explanation ' ] = html _entity _decode ( strip _tags ( $ explanation ) ) ; } $ this - > list Cache = $ available Upgrade Wizards ; } return array _filter ( $ this - > list Cache , function ( $ info ) use ( $ include Done ) { return $ include Done | | ! $ info [ 'done ' ] ; } ) ; } 
public function setup Command ( $ force = false , $ skip Integrity Check = false , $ skip Extension Setup = false , $ install Steps Config = null , $ database Driver = 'mysqli ' , $ database User Name = ' ' , $ database User Password = ' ' , $ database Host Name = ' 1 2 7 . 0 . 0 . 1 ' , $ database Port = ' 3 3 0 6 ' , $ database Socket = ' ' , $ database Name = null , $ use Existing Database = false , $ admin User Name = null , $ admin Password = null , $ site Name = 'New TYPO 3 Console site ' , $ web Server Config = 'none ' , $ site Setup Type = 'no ' , $ non Interactive = false ) { $ is Interactive = $ this - > output - > get Symfony Console Input ( ) - > is Interactive ( ) ; if ( $ non Interactive ) { 
public function generate Package States Command ( array $ framework Extensions = [ ] , array $ excluded Extensions = [ ] , $ activate Default = false ) { if ( $ activate Default & & Compatibility Scripts : : is Composer Mode ( ) ) { 
public function fix Folder Structure Command ( ) { $ folder Structure Factory = new Extension Factory ( $ this - > package Manager ) ; $ fixed Status Objects = $ folder Structure Factory - > get Structure ( ) - > fix ( ) ; if ( empty ( $ fixed Status Objects ) ) { $ this - > output Line ( ' <info >No action performed ! < /info > ' ) ; } else { $ this - > output Line ( ' <info >The following directory structure has been fixed : < /info > ' ) ; foreach ( $ fixed Status Objects as $ fixed Status Object ) { $ this - > output Line ( $ fixed Status Object - > get Title ( ) ) ; } } } 
public function extension Setup If Possible Command ( ) { $ command Dispatcher = Command Dispatcher : : create From Command Run ( ) ; try { $ this - > output Line ( $ command Dispatcher - > execute Command ( 'database :updateschema ' ) ) ; $ this - > output Line ( $ command Dispatcher - > execute Command ( 'cache :flush ' ) ) ; $ this - > output Line ( $ command Dispatcher - > execute Command ( 'extension :setupactive ' ) ) ; } catch ( Failed Sub Process Command Exception $ e ) { $ this - > output Line ( ' <warning >Extension setup skipped . < /warning > ' ) ; } } 
public function database Connect Command ( $ database User Name = ' ' , $ database User Password = ' ' , $ database Host Name = ' 1 2 7 . 0 . 0 . 1 ' , $ database Port = ' 3 3 0 6 ' , $ database Socket = ' ' , $ database Driver = 'mysqli ' ) { $ this - > execute Action With Arguments ( 'database Connect ' , [ 'host ' = > $ database Host Name , 'port ' = > $ database Port , 'username ' = > $ database User Name , 'password ' = > $ database User Password , 'socket ' = > $ database Socket , 'driver ' = > $ database Driver ] ) ; } 
public function database Select Command ( $ database Name , $ use Existing Database = false ) { $ select Type = $ use Existing Database ? 'existing ' : 'new ' ; $ this - > execute Action With Arguments ( 'database Select ' , [ 'type ' = > $ select Type , $ select Type = > $ database Name ] ) ; } 
private function execute Action With Arguments ( $ action Name , array $ arguments = [ ] , $ dry Run = false ) { $ this - > output Line ( serialize ( $ this - > install Step Action Executor - > execute Action With Arguments ( $ action Name , $ arguments , $ dry Run ) ) ) ; } 
public static function create From Composer Run ( . . . $ arguments ) : self { if ( isset ( $ arguments [ 0 ] ) & & $ arguments [ 0 ] instanceof Script Event ) { 
public static function create From Command Run ( array $ command Line = [ ] , array $ environment Vars = [ ] , Php Executable Finder $ php Finder = null ) : self { if ( ! isset ( $ _SERVER [ 'argv ' ] [ 0 ] ) & & strpos ( $ _SERVER [ 'argv ' ] [ 0 ] , Application : : COMMAND _NAME ) = = = false ) { throw new Runtime Exception ( 'Tried to create typo 3 command runner from wrong context ' , 1 4 8 4 9 4 5 0 6 5 ) ; } $ typo 3Command Path = $ _SERVER [ 'argv ' ] [ 0 ] ; return self : : create ( $ typo 3Command Path , $ command Line , $ environment Vars , $ php Finder ) ; } 
public static function create ( $ typo 3Command Path , array $ command Line = [ ] , array $ environment Vars = [ ] , Php Executable Finder $ php Finder = null ) : self { $ environment Vars [ 'TYPO 3 _CONSOLE _SUB _PROCESS ' ] = true ; $ php Finder = $ php Finder ? : new Php Executable Finder ( ) ; if ( ! ( $ php = $ php Finder - > find ( false ) ) ) { throw new Runtime Exception ( 'The "php " binary could not be found . ' , 1 4 8 5 1 2 8 6 1 5 ) ; } array _unshift ( $ command Line , $ typo 3Command Path ) ; $ php Arguments = $ php Finder - > find Arguments ( ) ; if ( getenv ( 'PHP _INI _PATH ' ) ) { $ php Arguments [ ] = ' -c ' ; $ php Arguments [ ] = getenv ( 'PHP _INI _PATH ' ) ; } 
public function execute Command ( $ command , array $ arguments = [ ] , array $ env Vars = [ ] , $ input = null ) : string { $ env Vars = array _replace ( $ this - > environment Vars , $ env Vars ) ; $ command Line = $ this - > command Line Prefix ; $ command Line [ ] = $ command ; foreach ( $ arguments as $ argument Name = > $ argument Value ) { if ( is _int ( $ argument Name ) ) { $ command Line [ ] = $ argument Value ; } else { $ command Line [ ] = $ this - > get Dashed Argument Name ( $ argument Name ) ; $ command Line [ ] = is _array ( $ argument Value ) ? implode ( ' , ' , $ argument Value ) : $ argument Value ; } } $ process = $ this - > get Process ( $ command Line , $ env Vars , $ input ) ; $ process - > run ( ) ; $ output = str _replace ( " \r \n " , " \n " , trim ( $ process - > get Output ( ) ) ) ; if ( ! $ process - > is Successful ( ) ) { throw Failed Sub Process Command Exception : : for Process ( $ command , $ process ) ; } return $ output ; } 
public function handle Exception ( \ Throwable $ exception ) { $ this - > exception Renderer - > render ( $ exception , $ this - > output - > get Error Output ( ) ) ; echo PHP _EOL ; exit ( 1 ) ; } 
public function create ( string $ identifier ) { $ upgrade Wizard = $ this - > object Manager - > get ( $ this - > get Class Name From Identifier ( $ identifier ) ) ; if ( $ upgrade Wizard instanceof Abstract Update ) { $ upgrade Wizard - > set Identifier ( $ identifier ) ; } if ( $ upgrade Wizard instanceof Chatty Interface ) { $ output = new Buffered Output ( ) ; $ upgrade Wizard - > set Output ( $ output ) ; } return $ upgrade Wizard ; } 
public static function expand Schema Update Types ( array $ schema Update Types ) { $ expanded Schema Update Types = [ ] ; $ schema Update Type Constants = array _values ( self : : get Constants ( ) ) ; 
protected function describe Input Argument ( Input Argument $ argument , array $ options = [ ] ) { $ total Width = isset ( $ options [ 'total _width ' ] ) ? $ options [ 'total _width ' ] : Helper : : strlen ( $ argument - > get Name ( ) ) ; $ spacing Width = $ total Width - strlen ( $ argument - > get Name ( ) ) ; 
protected function describe Input Option ( Input Option $ option , array $ options = [ ] ) { $ total Width = $ options [ 'total _width ' ] ? ? $ this - > calculate Total Width For Options ( [ $ option ] ) ; 
protected function describe Application ( Application $ application , array $ options = [ ] ) { $ described Namespace = isset ( $ options [ 'namespace ' ] ) ? $ options [ 'namespace ' ] : null ; $ description = new Application Description ( $ application , $ described Namespace ) ; if ( isset ( $ options [ 'raw _text ' ] ) & & $ options [ 'raw _text ' ] ) { $ width = $ this - > get Column Width ( $ description - > get Commands ( ) ) ; foreach ( $ description - > get Commands ( ) as $ command ) { $ this - > write Text ( sprintf ( " % - { $width }s %s " , $ command - > get Name ( ) , $ command - > get Description ( ) ) , $ options ) ; $ this - > write Text ( " \n " ) ; } } else { if ( ' ' ! = = $ help = $ application - > get Help ( ) ) { $ this - > write Text ( " $help \n \n " , $ options ) ; } $ this - > write Text ( " <comment >Usage : < /comment > \n " , $ options ) ; $ this - > write Text ( " command [options ] [arguments ] \n \n " , $ options ) ; $ this - > describe Input Definition ( new Input Definition ( $ application - > get Definition ( ) - > get Options ( ) ) , $ options ) ; $ this - > write Text ( " \n " ) ; $ this - > write Text ( " \n " ) ; $ commands = $ description - > get Commands ( ) ; if ( $ application instanceof \ Helhum \ Typo 3Console \ Mvc \ Cli \ Symfony \ Application ) { $ show Unavailable = $ options [ 'show _unavailable ' ] ? ? false ; $ commands = array _filter ( $ commands , function ( $ command ) use ( $ application , $ show Unavailable ) { return $ show Unavailable | | $ application - > is Command Available ( $ command ) ; } ) ; } $ namespaces = $ description - > get Namespaces ( ) ; if ( $ described Namespace & & $ namespaces ) { 
private function word Wrap ( string $ string To Wrap , int $ indent , $ max Width ) : string { $ wrapped = $ max Width = = = null ? $ string To Wrap : wordwrap ( $ string To Wrap , $ max Width , " \n " , true ) ; return preg _replace ( ' / \s * [ \r \n ] \s * / ' , " \n " . str _repeat ( ' ' , $ indent ) , $ wrapped ) ; } 
private function write Text ( $ content , array $ options = [ ] ) { $ this - > write ( isset ( $ options [ 'raw _text ' ] ) & & $ options [ 'raw _text ' ] ? strip _tags ( $ content ) : $ content , ! isset ( $ options [ 'raw _output ' ] ) | | ! $ options [ 'raw _output ' ] ) ; } 
private function get Column Width ( array $ commands ) { $ widths = [ ] ; foreach ( $ commands as $ command ) { if ( $ command instanceof Command ) { $ widths [ ] = Helper : : strlen ( $ command - > get Name ( ) ) ; foreach ( $ command - > get Aliases ( ) as $ alias ) { $ widths [ ] = Helper : : strlen ( $ alias ) ; } } else { $ widths [ ] = Helper : : strlen ( $ command ) ; } } return $ widths ? max ( $ widths ) + 2 : 0 ; } 
public function request Command ( $ request Url ) { 
protected function make Absolute ( $ url ) { $ parsed Url = parse _url ( $ url ) ; $ scheme = isset ( $ parsed Url [ 'scheme ' ] ) ? $ parsed Url [ 'scheme ' ] : 'http ' ; $ host = isset ( $ parsed Url [ 'host ' ] ) ? $ parsed Url [ 'host ' ] : 'localhost ' ; $ path = isset ( $ parsed Url [ 'path ' ] ) ? $ parsed Url [ 'path ' ] : ' / ' ; $ query = isset ( $ parsed Url [ 'query ' ] ) ? ' ? ' . $ parsed Url [ 'query ' ] : ' ' ; return $ scheme . ' : / / ' . $ host . ' / ' . ltrim ( $ path , ' / ' ) . $ query ; } 
public function render ( array $ upgrade Wizard Results , Console Output $ output ) { if ( empty ( $ upgrade Wizard Results ) ) { return ; } foreach ( $ upgrade Wizard Results as $ identifier = > $ result ) { $ output - > output Line ( ) ; if ( ! $ result - > has Performed ( ) ) { $ output - > output Line ( ' <warning >Skipped upgrade wizard " %s " because it was not scheduled for execution or marked as done . < /warning > ' , [ $ identifier ] ) ; } else { $ output - > output Line ( ' <em >Successfully executed upgrade wizard " %s " . < /em > ' , [ $ identifier ] ) ; } if ( ! empty ( $ messages = array _filter ( $ result - > get Messages ( ) ) ) ) { $ this - > print Messages ( $ messages , 'Messages ' , $ output ) ; } if ( ! empty ( $ queries = array _filter ( $ result - > get Sql Queries ( ) ) ) ) { $ this - > print Messages ( $ queries , 'SQL Queries executed ' , $ output ) ; } } } 
public function check Extension Constraints Command ( array $ extension Keys = [ ] , $ typo 3Version = TYPO 3 _version ) { if ( empty ( $ extension Keys ) ) { $ failed Package Messages = $ this - > upgrade Handling - > match All Extension Constraints ( $ typo 3Version ) ; } else { $ failed Package Messages = [ ] ; foreach ( $ extension Keys as $ extension Key ) { try { if ( ! empty ( $ result = $ this - > upgrade Handling - > match Extension Constraints ( $ extension Key , $ typo 3Version ) ) ) { $ failed Package Messages [ $ extension Key ] = $ result ; } } catch ( Unknown Package Exception $ e ) { $ this - > output Line ( ' <warning >Extension " %s " is not found in the system < /warning > ' , [ $ extension Key ] ) ; } } } foreach ( $ failed Package Messages as $ constraint Message ) { $ this - > output Line ( ' <error > %s < /error > ' , [ $ constraint Message ] ) ; } if ( empty ( $ failed Package Messages ) ) { $ this - > output Line ( ' <info >All third party extensions claim to be compatible with TYPO 3 version %s < /info > ' , [ $ typo 3Version ] ) ; } else { $ this - > quit ( 1 ) ; } } 
public function list Command ( $ all = false ) { $ verbose = $ this - > output - > get Symfony Console Output ( ) - > is Verbose ( ) ; $ messages = [ ] ; $ wizards = $ this - > upgrade Handling - > execute In Sub Process ( 'list Wizards ' , [ ] , $ messages ) ; $ list Renderer = new Upgrade Wizard List Renderer ( ) ; $ this - > output Line ( ' <comment >Wizards scheduled for execution : < /comment > ' ) ; $ list Renderer - > render ( $ wizards [ 'scheduled ' ] , $ this - > output , $ verbose ) ; if ( $ all ) { $ this - > output Line ( PHP _EOL . ' <comment >Wizards marked as done : < /comment > ' ) ; $ list Renderer - > render ( $ wizards [ 'done ' ] , $ this - > output , $ verbose ) ; } $ this - > output Line ( ) ; foreach ( $ messages as $ message ) { $ this - > output Line ( $ message ) ; } } 
public function wizard Command ( $ identifier , array $ arguments = [ ] , $ force = false ) { $ messages = [ ] ; $ result = $ this - > upgrade Handling - > execute In Sub Process ( 'execute Wizard ' , [ $ identifier , $ arguments , $ force ] , $ messages ) ; ( new Upgrade Wizard Result Renderer ( ) ) - > render ( [ $ identifier = > $ result ] , $ this - > output ) ; $ this - > output Line ( ) ; foreach ( $ messages as $ message ) { $ this - > output Line ( $ message ) ; } } 
public function all Command ( array $ arguments = [ ] ) { $ verbose = $ this - > output - > get Symfony Console Output ( ) - > is Verbose ( ) ; $ this - > output Line ( PHP _EOL . ' <i >Initiating TYPO 3 upgrade < /i > ' . PHP _EOL ) ; $ messages = [ ] ; $ results = $ this - > upgrade Handling - > execute All ( $ arguments , $ this - > output , $ messages ) ; $ this - > output Line ( PHP _EOL . PHP _EOL . ' <i >Successfully upgraded TYPO 3 to version %s < /i > ' , [ TYPO 3 _version ] ) ; if ( $ verbose ) { $ this - > output Line ( ) ; $ this - > output Line ( ' <comment >Upgrade report : < /comment > ' ) ; ( new Upgrade Wizard Result Renderer ( ) ) - > render ( $ results , $ this - > output ) ; } $ this - > output Line ( ) ; foreach ( $ messages as $ message ) { $ this - > output Line ( $ message ) ; } } 
public function sub Process Command ( $ upgrade Command , $ arguments ) { $ arguments = unserialize ( $ arguments , [ 'allowed _classes ' = > false ] ) ; $ result = $ this - > upgrade Handling - > $ upgrade Command ( . . . $ arguments ) ; $ this - > output ( serialize ( $ result ) ) ; } 
public function check Extension Compatibility Command ( $ extension Key , $ config Only = false ) { $ this - > output ( \ json _encode ( $ this - > upgrade Handling - > is Compatible ( $ extension Key , $ config Only ) ) ) ; } 
public function execute Silent Configuration Upgrades If Needed ( ) { if ( ! file _exists ( $ this - > configuration Manager - > get Local Configuration File Location ( ) ) ) { return ; } 
public function setup Extensions ( array $ packages ) { foreach ( $ packages as $ package ) { $ this - > extension Factory - > get Extension Structure ( $ package ) - > fix ( ) ; $ this - > call Installer ( 'import Initial Files ' , [ Path Utility : : strip Path Site Prefix ( $ package - > get Package Path ( ) ) , $ package - > get Package Key ( ) ] ) ; $ this - > extension Configuration - > save Default Configuration ( $ package - > get Package Key ( ) ) ; } $ this - > schema Service - > update Schema ( Schema Update Type : : expand Schema Update Types ( [ 'safe ' ] ) ) ; foreach ( $ packages as $ package ) { $ relative Extension Path = Path Utility : : strip Path Site Prefix ( $ package - > get Package Path ( ) ) ; $ extension Key = $ package - > get Package Key ( ) ; $ this - > call Installer ( 'import Static Sql File ' , [ $ relative Extension Path ] ) ; $ this - > call Installer ( 'import T 3DFile ' , [ $ relative Extension Path ] ) ; $ this - > call Installer ( 'emit After Extension Install Signal ' , [ $ extension Key ] ) ; } } 
public function get Structure ( ) { $ structure = $ this - > get Default Structure Definition ( ) ; $ structure [ 'children ' ] = $ this - > append Structure Definition ( $ structure [ 'children ' ] , $ this - > create Extension Structure Definition ( $ this - > package Manager - > get Active Packages ( ) ) ) ; return new Structure Facade ( new Root Node ( $ structure ) ) ; } 
public function get Extension Structure ( Package Interface $ package ) { $ structure = [ 'name ' = > substr ( PATH _site , 0 , - 1 ) , 'target Permission ' = > $ GLOBALS [ 'TYPO 3 _CONF _VARS ' ] [ 'SYS ' ] [ 'folder Create Mask ' ] , 'children ' = > $ this - > append Structure Definition ( [ ] , $ this - > create Extension Structure Definition ( [ $ package ] ) ) , ] ; return new Structure Facade ( new Root Node ( $ structure ) ) ; } 
private function create Extension Structure Definition ( array $ packages ) { $ structure Base = [ ] ; foreach ( $ packages as $ package ) { $ extension Configuration = $ this - > package Manager - > get Extension Configuration ( $ package ) ; if ( isset ( $ extension Configuration [ 'uploadfolder ' ] ) & & ( bool ) $ extension Configuration [ 'uploadfolder ' ] ) { $ structure Base [ ] = $ this - > get Extension Upload Directory ( $ package - > get Package Key ( ) ) ; } if ( ! empty ( $ extension Configuration [ 'create Dirs ' ] ) ) { foreach ( explode ( ' , ' , $ extension Configuration [ 'create Dirs ' ] ) as $ directory To Create ) { $ absolute Path = General Utility : : get File Abs File Name ( trim ( $ directory To Create ) ) ; 
private function get Directory Node By Path ( $ path ) { $ base Node = [ ] ; $ parts = explode ( ' / ' , $ path ) ; $ node = & $ base Node ; foreach ( $ parts as $ part ) { $ node [ 0 ] = [ 'name ' = > $ part , 'type ' = > Directory Node : : class , 'target Permission ' = > $ GLOBALS [ 'TYPO 3 _CONF _VARS ' ] [ 'SYS ' ] [ 'folder Create Mask ' ] , 'children ' = > [ ] , ] ; 
private function append Structure Definition ( array $ original , array $ additional ) { foreach ( $ additional as $ additional Structure ) { $ structure Key = false ; foreach ( $ original as $ key = > $ original Structure ) { if ( $ original Structure [ 'name ' ] = = = $ additional Structure [ 'name ' ] ) { $ structure Key = $ key ; } } if ( $ structure Key = = = false ) { 
public function generate Xsd ( $ view Helper Namespace , $ xsd Namespace ) { $ view Helper Namespace = rtrim ( $ view Helper Namespace , ' _ \ \ ' ) . $ this - > get Delimiter From Namespace ( $ view Helper Namespace ) ; $ class Names = $ this - > get Class Names In Namespace ( $ view Helper Namespace ) ; if ( count ( $ class Names ) = = = 0 ) { throw new Exception ( sprintf ( 'No View Helpers found in namespace " %s " ' , $ view Helper Namespace ) , 1 3 3 0 0 2 9 3 2 8 ) ; } return $ this - > generate Xsd From Class Names ( $ class Names , $ xsd Namespace ) ; } 
public function generate Xsd From Class Files ( array $ view Helper Paths , $ xsd Namespace ) { $ class Names = $ this - > get Class Names In Paths ( $ view Helper Paths ) ; if ( count ( $ class Names ) = = = 0 ) { throw new Exception ( sprintf ( 'No View Helpers found in paths " %s " ' , implode ( ' , ' , $ view Helper Paths ) ) , 1 4 6 4 9 8 2 2 4 9 ) ; } return $ this - > generate Xsd From Class Names ( $ class Names , $ xsd Namespace ) ; } 
protected function generate Xsd From Class Names ( array $ class Names , $ xsd Namespace ) { if ( count ( $ class Names ) = = = 0 ) { throw new Exception ( sprintf ( 'No View Helper classes given ' ) , 1 4 6 4 9 8 4 8 5 6 ) ; } $ xml Root Node = new \ Simple XMLElement ( ' < ?xml version = " 1 . 0 " encoding = "UTF - 8 " ? > <xsd :schema xmlns :xsd = "http : / /www .w 3 .org / 2 0 0 1 /XMLSchema " target Namespace = " ' . $ xsd Namespace . ' " > < /xsd :schema > ' ) ; foreach ( $ class Names as $ class Name ) { $ this - > generate Xml For Class Name ( $ class Name , $ xml Root Node ) ; } return $ xml Root Node - > as XML ( ) ; } 
protected function generate Xml For Class Name ( $ class Name , \ Simple XMLElement $ xml Root Node ) { $ reflection Class = new \ Reflection Class ( $ class Name ) ; $ tag Name = $ this - > get Tag Name For Class ( $ class Name ) ; $ xsd Element = $ xml Root Node - > add Child ( 'xsd :element ' ) ; $ xsd Element [ 'name ' ] = $ tag Name ; $ this - > doc Comment Parser - > parse Doc Comment ( $ reflection Class - > get Doc Comment ( ) ) ; $ this - > add Documentation ( $ this - > doc Comment Parser - > get Description ( ) , $ xsd Element ) ; $ xsd Complex Type = $ xsd Element - > add Child ( 'xsd :complex Type ' ) ; $ xsd Complex Type [ 'mixed ' ] = 'true ' ; $ xsd Sequence = $ xsd Complex Type - > add Child ( 'xsd :sequence ' ) ; $ xsd Any = $ xsd Sequence - > add Child ( 'xsd :any ' ) ; $ xsd Any [ 'min Occurs ' ] = ' 0 ' ; $ xsd Any [ 'max Occurs ' ] = 'unbounded ' ; $ this - > add Attributes ( $ class Name , $ xsd Complex Type ) ; } 
protected function add Attributes ( $ class Name , \ Simple XMLElement $ xsd Element ) { $ view Helper = $ this - > object Manager - > get ( $ class Name ) ; $ argument Definitions = $ view Helper - > prepare Arguments ( ) ; foreach ( $ argument Definitions as $ argument Definition ) { $ xsd Attribute = $ xsd Element - > add Child ( 'xsd :attribute ' ) ; $ xsd Attribute [ 'type ' ] = 'xsd :string ' ; $ xsd Attribute [ 'name ' ] = $ argument Definition - > get Name ( ) ; $ this - > add Documentation ( $ argument Definition - > get Description ( ) , $ xsd Attribute ) ; if ( $ argument Definition - > is Required ( ) ) { $ xsd Attribute [ 'use ' ] = 'required ' ; } } } 
protected function add Documentation ( $ documentation , \ Simple XMLElement $ xsd Parent Node ) { $ xsd Annotation = $ xsd Parent Node - > add Child ( 'xsd :annotation ' ) ; $ this - > add Child With CData ( $ xsd Annotation , 'xsd :documentation ' , $ documentation ) ; } 
protected function get Class Names In Paths ( array $ paths ) { $ view Helper Class Files = [ ] ; foreach ( $ paths as $ path ) { $ view Helper Class Files = array _merge ( $ view Helper Class Files , General Utility : : get All Files And Folders In Path ( [ ] , $ path , 'php ' ) ) ; } $ affected View Helper Class Names = [ ] ; foreach ( $ view Helper Class Files as $ file Path And Filename ) { try { $ potential View Helper Class Name = $ this - > get Class Name From File ( $ file Path And Filename ) ; } catch ( Parsing Exception $ e ) { continue ; } if ( strpos ( $ potential View Helper Class Name , 'View Helpers ' ) = = = false ) { continue ; } if ( is _subclass _of ( $ potential View Helper Class Name , \ TYPO 3 \ CMS \ Fluid \ Core \ View Helper \ Abstract View Helper : : class ) | | is _subclass _of ( $ potential View Helper Class Name , \ TYPO 3Fluid \ Fluid \ Core \ View Helper \ Abstract View Helper : : class ) ) { if ( ! class _exists ( $ potential View Helper Class Name ) ) { require $ file Path And Filename ; } $ class Reflection = new \ Reflection Class ( $ potential View Helper Class Name ) ; if ( $ class Reflection - > is Abstract ( ) = = = true ) { continue ; } $ affected View Helper Class Names [ ] = $ potential View Helper Class Name ; } } sort ( $ affected View Helper Class Names ) ; return $ affected View Helper Class Names ; } 
protected function get Class Names In Namespace ( $ namespace ) { $ package Key = $ this - > get Package Key From Namespace ( $ namespace ) ; $ view Helper Class File Paths [ ] = $ this - > package Manager - > get Package ( $ package Key ) - > get Package Path ( ) . 'Classes /View Helpers / ' ; if ( $ package Key = = = 'fluid ' ) { $ view Helper Class File Paths [ ] = realpath ( PATH _site . 'typo 3 / ' ) . ' / . . /vendor /typo 3fluid /fluid /src /View Helpers / ' ; } return $ this - > get Class Names In Paths ( $ view Helper Class File Paths ) ; } 
protected function get Tag Name For Class ( $ class Name ) { 
protected function add Child With CData ( \ Simple XMLElement $ parent Xml Node , $ child Node Name , $ child Node Value ) { $ parent Dom Node = dom _import _simplexml ( $ parent Xml Node ) ; $ dom Document = new \ DOMDocument ( ) ; $ child Node = $ dom Document - > append Child ( $ dom Document - > create Element ( $ child Node Name ) ) ; $ child Node - > append Child ( $ dom Document - > create CDATASection ( $ child Node Value ) ) ; $ child Node Target = $ parent Dom Node - > owner Document - > import Node ( $ child Node , true ) ; $ parent Dom Node - > append Child ( $ child Node Target ) ; return simplexml _import _dom ( $ child Node Target ) ; } 
public function process Request ( Request Interface $ request , Response Interface $ response ) { if ( ! $ request instanceof Request ) { throw new Unsupported Request Type Exception ( sprintf ( ' %s only supports command line requests – requests of type " %s " given . ' , s atic : : cl ass , g t _class ( $ r e quest ) ) , 1 0 0 7 8 7 0 9 6 ) ; } if ( $ response instanceof Response ) { $ output = $ this - > object Manager - > get ( Console Output : : class , $ response - > get Output ( ) , $ response - > get Input ( ) ) ; } $ this - > output = $ output ? ? $ this - > object Manager - > get ( Console Output : : class ) ; $ this - > request = $ request ; $ this - > request - > set Dispatched ( true ) ; $ this - > response = $ response ; $ this - > command Method Name = $ this - > resolve Command Method Name ( ) ; $ this - > initialize Command Method Arguments ( ) ; $ this - > map Request Arguments To Controller Arguments ( ) ; $ this - > call Command Method ( ) ; } 
protected function resolve Command Method Name ( ) { $ command Method Name = $ this - > request - > get Controller Command Name ( ) . 'Command ' ; if ( ! is _callable ( [ $ this , $ command Method Name ] ) ) { throw new No Such Command Exception ( sprintf ( 'A command method " %s ( ) " does not exist in controller " %s " . ' , $ command Method Name , get _class ( $ this ) ) , 1 3 0 0 9 0 2 1 4 3 ) ; } return $ command Method Name ; } 
protected function map Request Arguments To Controller Arguments ( ) { foreach ( $ this - > arguments as $ argument ) { $ argument Name = $ argument - > get Name ( ) ; if ( $ this - > request - > has Argument ( $ argument Name ) ) { $ argument - > set Value ( $ this - > request - > get Argument ( $ argument Name ) ) ; continue ; } if ( ! $ argument - > is Required ( ) ) { continue ; } $ argument Value = null ; $ command Argument Definition = $ this - > object Manager - > get ( Command Argument Definition : : class , $ argument Name , true , null ) ; while ( $ argument Value = = = null ) { $ argument Value = $ this - > output - > ask ( sprintf ( ' <comment >Please specify the required argument " %s " : < /comment > ' , $ command Argument Definition - > get Dashed Name ( ) ) ) ; } $ argument - > set Value ( $ argument Value ) ; } } 
protected function call Command Method ( ) { $ prepared Arguments = [ ] ; foreach ( $ this - > arguments as $ argument ) { $ prepared Arguments [ ] = $ argument - > get Value ( ) ; } $ command Result = $ this - > { $ this - > command Method Name } ( . . . $ prepared Arguments ) ; if ( $ command Result ! = = null ) { $ this - > output Line ( ( string ) $ command Result ) ; $ this - > output - > get Symfony Console Output ( ) - > get Error Output ( ) - > writeln ( ' <warning >Returning a string from a command method is deprecated . < /warning > ' ) ; $ this - > output - > get Symfony Console Output ( ) - > get Error Output ( ) - > writeln ( ' <warning >Please use $this - >output Line ( ) instead . < /warning > ' ) ; } } 
protected function output Formatted ( $ text = ' ' , array $ arguments = [ ] , $ left Padding = 0 ) { $ this - > output - > output Formatted ( $ text , $ arguments , $ left Padding ) ; } 
protected function create Default Logger ( $ minimum Level = Log Level : : DEBUG , $ options = [ ] ) { $ options [ 'output ' ] = $ this - > output - > get Symfony Console Output ( ) ; $ logger = new Logger ( get _class ( $ this ) ) ; $ logger - > add Writer ( $ minimum Level , new Console Writer ( $ options ) ) ; return $ logger ; } 
public function get Short Description ( ) : string { $ lines = explode ( LF , $ this - > command Reflection - > get Description ( ) ) ; return ! empty ( $ lines ) ? trim ( $ lines [ 0 ] ) : ' <no description available > ' ; } 
public function get Description ( ) : string { $ lines = explode ( LF , $ this - > command Reflection - > get Description ( ) ) ; array _shift ( $ lines ) ; $ description Lines = [ ] ; foreach ( $ lines as $ line ) { $ trimmed Line = trim ( $ line ) ; if ( $ description Lines ! = = [ ] | | $ trimmed Line ! = = ' ' ) { $ description Lines [ ] = $ trimmed Line ; } } return implode ( LF , $ description Lines ) ; } 
public function get Argument Definitions ( ) : array { if ( $ this - > argument Definitions ! = = null ) { return $ this - > argument Definitions ; } if ( ! $ this - > has Arguments ( ) ) { return $ this - > argument Definitions = [ ] ; } $ this - > argument Definitions = [ ] ; $ command Parameters = $ this - > command Reflection - > get Parameters ( ) ; $ command Parameter Tags = $ this - > command Reflection - > get Tags Values ( ) [ 'param ' ] ; $ i = 0 ; $ defined Arguments = $ this - > get Defined Arguments ( ) ; $ defined Options = $ this - > get Defined Options ( ) ; foreach ( $ command Parameters as $ command Parameter Name = > $ command Parameter Definition ) { $ description = ' ' ; if ( isset ( $ command Parameter Tags [ $ i ] ) ) { $ exploded Annotation = preg _split ( ' / \s + / ' , $ command Parameter Tags [ $ i ] , 3 ) ; $ description = ! empty ( $ exploded Annotation [ 2 ] ) ? $ exploded Annotation [ 2 ] : ' ' ; } $ data Type = $ command Parameter Definition [ 'type ' ] ? ? 'null ' ; if ( $ command Parameter Definition [ 'array ' ] ) { $ data Type = 'array ' ; } $ default = $ command Parameter Definition [ 'default Value ' ] ? ? null ; $ required = $ command Parameter Definition [ 'optional ' ] ! = = true ; $ is Argument = isset ( $ defined Arguments [ $ command Parameter Name ] ) | | ( $ required & & ! isset ( $ defined Options [ $ command Parameter Name ] ) ) ; $ argument Definition = new Command Argument Definition ( $ command Parameter Name , $ required , $ description , $ data Type , $ default , $ is Argument ) ; if ( $ is Argument ) { $ this - > arguments [ ] = $ argument Definition ; } else { $ this - > options [ ] = $ argument Definition ; } $ this - > argument Definitions [ ] = $ argument Definition ; $ i + + ; } return $ this - > argument Definitions ; } 
private function parse Definitions ( ) : array { $ definitions = [ ] ; $ reader = new Annotation Reader ( ) ; $ method = new \ Reflection Method ( $ this - > controller Class Name , $ this - > controller Command Method ) ; foreach ( $ reader - > get Method Annotations ( $ method ) as $ annotation ) { if ( $ annotation instanceof Option ) { $ definitions [ 'Option ' ] [ ] = $ annotation ; } if ( $ annotation instanceof Argument ) { $ definitions [ 'Argument ' ] [ ] = $ annotation ; } if ( $ annotation instanceof Validate ) { $ definitions [ 'Validate ' ] = $ annotation ; } } return $ definitions ; } 
public function get Synopsis ( $ short = false ) : string { $ key = $ short ? 'short ' : 'long ' ; if ( isset ( $ this - > synopsis [ $ key ] ) ) { return $ this - > synopsis [ $ key ] ; } $ elements = [ ] ; if ( $ short & & $ this - > has Options ( ) ) { $ elements [ ] = ' [options ] ' ; } elseif ( ! $ short ) { foreach ( $ this - > get Options ( ) as $ argument Definition ) { $ value = ' ' ; if ( $ argument Definition - > accepts Value ( ) ) { $ value = ' ' . strtoupper ( $ argument Definition - > get Option Name ( ) ) ; } $ elements [ ] = sprintf ( ' [ %s %s ] ' , $ argument Definition - > get Dashed Name ( ) , $ value ) ; } } if ( count ( $ elements ) & & $ this - > has Required Arguments ( ) ) { $ elements [ ] = ' [ - - ] ' ; } foreach ( $ this - > get Arguments ( ) as $ argument Definition ) { $ elements [ ] = ' < ' . $ argument Definition - > get Name ( ) . ' > ' ; } return $ this - > synopsis [ $ key ] = implode ( ' ' , $ elements ) ; } 
public function get Related Command Identifiers ( ) : array { if ( ! isset ( $ this - > command Reflection - > get Tags Values ( ) [ 'see ' ] ) ) { return [ ] ; } $ related Command Identifiers = [ ] ; foreach ( $ this - > command Reflection - > get Tags Values ( ) [ 'see ' ] as $ tag Value ) { if ( preg _match ( ' / ^ [ \ \w \ \ . _ ] + : [ \ \w ] + : [ \ \w ] + $ / ' , $ tag Value ) = = = 1 ) { $ related Command Identifiers [ ] = $ tag Value ; } } return $ related Command Identifiers ; } 
public function remove Step ( $ step Identifier ) { $ removed Occurrences = 0 ; foreach ( $ this - > steps as $ previous Step Identifier = > $ steps ) { foreach ( $ steps as $ index = > $ step ) { if ( $ step - > get Identifier ( ) = = = $ step Identifier ) { unset ( $ this - > steps [ $ previous Step Identifier ] [ $ index ] ) ; $ removed Occurrences + + ; } } } if ( $ removed Occurrences = = = 0 ) { throw new Exception ( sprintf ( 'Cannot remove sequence step with identifier " %s " because no such step exists in the given sequence . ' , $ step Identifier ) , 1 3 2 2 5 9 1 6 6 9 ) ; } } 
public function invoke ( Bootstrap $ bootstrap ) { if ( isset ( $ this - > steps [ 'start ' ] ) ) { foreach ( $ this - > steps [ 'start ' ] as $ step ) { $ this - > invoke Step ( $ step , $ bootstrap ) ; } } } 
protected function invoke Step ( Step $ step , Bootstrap $ bootstrap ) { $ identifier = $ step - > get Identifier ( ) ; try { $ step ( $ bootstrap ) ; } catch ( \ Throwable $ e ) { throw new Step Failed Exception ( $ step , $ e ) ; } if ( isset ( $ this - > steps [ $ identifier ] ) ) { foreach ( $ this - > steps [ $ identifier ] as $ following Step ) { $ this - > invoke Step ( $ following Step , $ bootstrap ) ; } } } 
public function activate Command ( array $ extension Keys ) { 
public function deactivate Command ( array $ extension Keys ) { 
public function setup Command ( array $ extension Keys ) { $ verbose = $ this - > output - > get Symfony Console Output ( ) - > is Verbose ( ) ; $ packages = [ ] ; foreach ( $ extension Keys as $ extension Key ) { $ packages [ ] = $ this - > package Manager - > get Package ( $ extension Key ) ; } $ this - > setup Extensions ( $ packages , $ verbose ) ; } 
private function setup Extensions ( array $ packages , $ verbose = false ) { $ extension Setup Result Renderer = new Extension Setup Result Renderer ( $ this - > signal Slot Dispatcher ) ; $ extension Setup = new Extension Setup ( new Extension Factory ( $ this - > package Manager ) , $ this - > get Extension Installer ( ) ) ; $ extension Setup - > setup Extensions ( $ packages ) ; $ extension Keys As String = implode ( ' " , " ' , array _map ( function ( Package Interface $ package ) { return $ package - > get Package Key ( ) ; } , $ packages ) ) ; if ( count ( $ packages ) = = = 1 ) { $ this - > output Line ( ' <info >Extension " %s " is now set up . < /info > ' , [ $ extension Keys As String ] ) ; } else { $ this - > output Line ( ' <info >Extensions " %s " are now set up . < /info > ' , [ $ extension Keys As String ] ) ; } if ( $ verbose ) { $ this - > output Line ( ) ; $ extension Setup Result Renderer - > render Schema Result ( $ this - > output ) ; $ extension Setup Result Renderer - > render Extension Data Import Result ( $ this - > output ) ; $ extension Setup Result Renderer - > render Extension File Import Result ( $ this - > output ) ; $ extension Setup Result Renderer - > render Imported Static Data Result ( $ this - > output ) ; } } 
public function setup Active Command ( ) { $ verbose = $ this - > output - > get Symfony Console Output ( ) - > is Verbose ( ) ; $ this - > setup Extensions ( $ this - > package Manager - > get Active Packages ( ) , $ verbose ) ; } 
public function remove Inactive Command ( $ force = false ) { $ this - > output Line ( ' <warning >This command is deprecated and will be removed with TYPO 3 Console 6 . 0 < /warning > ' ) ; if ( $ force ) { $ active Packages = $ this - > package Manager - > get Active Packages ( ) ; $ this - > package Manager - > scan Available Packages ( ) ; foreach ( $ this - > package Manager - > get Available Packages ( ) as $ package ) { if ( empty ( $ active Packages [ $ package - > get Package Key ( ) ] ) ) { $ this - > package Manager - > unregister Package ( $ package ) ; if ( is _dir ( $ package - > get Package Path ( ) ) ) { General Utility : : flush Directory ( $ package - > get Package Path ( ) ) ; $ removed Paths [ ] = Path Utility : : strip Path Site Prefix ( $ package - > get Package Path ( ) ) ; } } } $ this - > package Manager - > force Sort And Save Package States ( ) ; if ( ! empty ( $ removed Paths ) ) { $ this - > output Line ( ' <info >The following directories have been removed : < /info > ' . chr ( 1 0 ) . implode ( chr ( 1 0 ) , $ removed Paths ) ) ; } else { $ this - > output Line ( ' <info >Nothing was removed < /info > ' ) ; } } else { $ this - > output Line ( ' <warning >Operation not confirmed and has been skipped < /warning > ' ) ; $ this - > quit ( 1 ) ; } } 
public function list Command ( $ active = false , $ inactive = false , $ raw = false ) { $ extension Information = [ ] ; if ( ! $ active | | $ inactive ) { $ this - > emit Packages May Have Changed Signal ( ) ; $ packages = $ this - > package Manager - > get Available Packages ( ) ; } else { $ packages = $ this - > package Manager - > get Active Packages ( ) ; } foreach ( $ packages as $ package ) { if ( $ inactive & & $ this - > package Manager - > is Package Active ( $ package - > get Package Key ( ) ) ) { continue ; } $ meta Data = $ package - > get Package Meta Data ( ) ; $ extension Information [ ] = [ 'package _key ' = > $ package - > get Package Key ( ) , 'version ' = > $ meta Data - > get Version ( ) , 'description ' = > $ meta Data - > get Description ( ) , ] ; } if ( $ raw ) { $ this - > output Line ( ' %s ' , [ implode ( PHP _EOL , array _column ( $ extension Information , 'package _key ' ) ) ] ) ; } else { $ this - > output - > output Table ( $ extension Information , [ 'Extension key ' , 'Version ' , 'Description ' ] ) ; } } 
public function force Flush Database Cache Tables ( ) { 
public function handle Error ( $ error Level , $ error Message , $ error File , $ error Line ) { if ( error _reporting ( ) = = = 0 ) { return ; } $ error Levels = [ E _WARNING = > 'Warning ' , E _NOTICE = > 'Notice ' , E _USER _ERROR = > 'User Error ' , E _USER _WARNING = > 'User Warning ' , E _USER _NOTICE = > 'User Notice ' , E _STRICT = > 'Runtime Notice ' , E _RECOVERABLE _ERROR = > 'Catchable Fatal Error ' , ] ; if ( in _array ( $ error Level , ( array ) $ this - > exceptional Errors , true ) ) { throw new \ TYPO 3 \ CMS \ Core \ Error \ Exception ( $ error Levels [ $ error Level ] . ' : ' . $ error Message . ' in ' . $ error File . ' line ' . $ error Line , 1 ) ; } } 
public function execute Action With Arguments ( $ action Name , array $ arguments = [ ] , $ dry Run = false ) { return $ this - > execute Action ( $ this - > create Action With Name And Arguments ( $ action Name , $ arguments ) , $ dry Run ) ; } 
public static function register ( Event $ event , Script Dispatcher $ script Dispatcher ) { $ script Dispatcher - > add Installer Script ( new Populate Command Configuration ( ) , 7 0 ) ; if ( ! class _exists ( \ TYPO 3 \ CMS \ Core \ Composer \ Installer Scripts : : class ) & & ! class _exists ( \ Helhum \ Typo 3Composer Setup \ Composer \ Installer Scripts : : class ) & & $ event - > get Composer ( ) - > get Repository Manager ( ) - > get Local Repository ( ) - > find Package ( 'typo 3 /cms ' , new Empty Constraint ( ) ) ! = = null ) { 
public function convert From ( $ source , $ target Type , array $ converted Child Properties = [ ] , Property Mapping Configuration Interface $ configuration = null ) : array { if ( is _string ( $ source ) ) { if ( $ source = = = ' ' ) { return [ ] ; } return array _filter ( array _map ( 'trim ' , explode ( $ this - > get Configured String Delimiter ( $ configuration ) , $ source ) ) ) ; } return $ source ; } 
public function execute Silent Configuration Upgrades If Needed ( ) { if ( ! file _exists ( $ this - > configuration Manager - > get Local Configuration File Location ( ) ) ) { return ; } $ upgrade Service = $ this - > object Manager - > get ( Silent Configuration Upgrade Service : : class ) ; $ count = 0 ; do { try { $ count + + ; $ upgrade Service - > execute ( ) ; $ redirect = false ; } catch ( Redirect Exception $ e ) { $ redirect = true ; $ this - > configuration Manager - > export Configuration ( ) ; if ( $ count > 2 0 ) { throw new Runtime Exception ( 'Too many loops when silently upgrading configuration ' , 1 4 9 3 8 9 7 4 0 4 , $ e ) ; } } } while ( $ redirect = = = true ) ; } 
public function render ( Schema Update Result $ result , Console Output $ output , $ include Statements = false , $ max Statement Length = 6 0 ) { $ table Rows = [ ] ; foreach ( $ result - > get Performed Updates ( ) as $ type = > $ performed Updates ) { $ row = [ self : : $ schema Update Type Labels [ ( string ) $ type ] , count ( $ performed Updates ) ] ; if ( $ include Statements ) { $ row = [ self : : $ schema Update Type Labels [ ( string ) $ type ] , implode ( chr ( 1 0 ) . chr ( 1 0 ) , $ this - > get Truncated Queries ( $ performed Updates , $ max Statement Length ) ) ] ; } $ table Rows [ ] = $ row ; } $ table Header = [ 'Type ' , 'Updates ' ] ; if ( $ include Statements ) { $ table Header = [ 'Type ' , 'SQL Statements ' ] ; } if ( ! empty ( $ table Rows ) ) { $ output - > output Table ( $ table Rows , $ table Header ) ; } } 
public function render Errors ( Schema Update Result $ result , Console Output $ output , $ include Statements = false , $ max Statement Length = 9 0 ) { $ table Rows = [ ] ; $ message Length = $ include Statements ? ( int ) ( $ max Statement Length * . 3 ) : $ max Statement Length ; $ statement Length = ( int ) ( $ max Statement Length * 0 . 6 ) ; foreach ( $ result - > get Errors ( ) as $ type = > $ errors ) { $ type Label = self : : $ schema Update Type Labels [ ( string ) $ type ] ; foreach ( $ errors as $ error ) { $ row = [ $ type Label , implode ( PHP _EOL , $ this - > get Truncated Queries ( [ $ error [ 'message ' ] ] , $ message Length ) ) ] ; if ( $ include Statements ) { $ row = [ $ type Label , implode ( PHP _EOL , $ this - > get Truncated Queries ( [ $ error [ 'statement ' ] ] , $ statement Length ) ) , implode ( PHP _EOL , $ this - > get Truncated Queries ( [ $ error [ 'message ' ] ] , $ message Length ) ) ] ; } $ table Rows [ ] = $ row ; $ table Rows [ ] = $ include Statements ? [ ' ' , ' ' , ' ' ] : [ ' ' , ' ' ] ; $ type Label = ' ' ; } } $ table Header = [ 'Type ' , 'Message ' ] ; if ( $ include Statements ) { $ table Header = [ 'Type ' , 'SQL Statement ' , 'Message ' ] ; } $ output - > output Table ( $ table Rows , $ table Header ) ; } 
protected function get Truncated Queries ( array $ queries , int $ truncate At ) : array { foreach ( $ queries as & $ query ) { $ truncated Lines = [ ] ; foreach ( explode ( chr ( 1 0 ) , $ query ) as $ line ) { $ truncated Lines [ ] = wordwrap ( $ line , $ truncate At , chr ( 1 0 ) , true ) ; } $ query = implode ( chr ( 1 0 ) , $ truncated Lines ) ; } return $ queries ; } 
public function output ( $ text , array $ arguments = [ ] ) { if ( $ arguments ! = = [ ] ) { $ text = vsprintf ( $ text , $ arguments ) ; } if ( getenv ( 'TYPO 3 _CONSOLE _SUB _PROCESS ' ) ) { $ this - > output - > write ( $ text , false , Output Interface : : OUTPUT _RAW ) ; } else { $ this - > output - > write ( $ text ) ; } } 
public function output Table ( $ rows , $ headers = null ) { $ table = $ this - > get Table ( ) ; if ( $ headers ! = = null ) { $ table - > set Headers ( $ headers ) ; } $ table - > set Rows ( $ rows ) ; $ table - > render ( ) ; } 
public function select ( $ question , $ choices , $ default = null , $ multi Select = false , $ attempts = false ) { $ question = ( new Choice Question ( $ question , $ choices , $ default ) ) - > set Multiselect ( $ multi Select ) - > set Max Attempts ( $ attempts ) - > set Error Message ( 'Value " %s " is invalid ' ) ; return $ this - > get Question Helper ( ) - > ask ( $ this - > get Input ( ) , $ this - > output , $ question ) ; } 
public function ask ( $ question , $ default = null , array $ autocomplete = null ) { $ question = ( new Question ( $ question , $ default ) ) - > set Autocompleter Values ( $ autocomplete ) ; return $ this - > get Question Helper ( ) - > ask ( $ this - > get Input ( ) , $ this - > output , $ question ) ; } 
public function ask Confirmation ( $ question , $ default = true ) { $ question = new Confirmation Question ( $ question , $ default ) ; return $ this - > get Question Helper ( ) - > ask ( $ this - > get Input ( ) , $ this - > output , $ question ) ; } 
public function ask Hidden Response ( $ question , $ fallback = true ) { $ question = ( new Question ( $ question ) ) - > set Hidden ( true ) - > set Hidden Fallback ( $ fallback ) ; return $ this - > get Question Helper ( ) - > ask ( $ this - > get Input ( ) , $ this - > output , $ question ) ; } 
public function ask And Validate ( $ question , $ validator , $ attempts = false , $ default = null , array $ autocomplete = null ) { $ question = ( new Question ( $ question , $ default ) ) - > set Validator ( $ validator ) - > set Max Attempts ( $ attempts ) - > set Autocompleter Values ( $ autocomplete ) ; return $ this - > get Question Helper ( ) - > ask ( $ this - > get Input ( ) , $ this - > output , $ question ) ; } 
public function ask Hidden Response And Validate ( $ question , $ validator , $ attempts = false , $ fallback = true ) { $ question = ( new Question ( $ question ) ) - > set Validator ( $ validator ) - > set Max Attempts ( $ attempts ) - > set Hidden ( true ) - > set Hidden Fallback ( $ fallback ) ; return $ this - > get Question Helper ( ) - > ask ( $ this - > get Input ( ) , $ this - > output , $ question ) ; } 
protected function check Or Update Reference Index ( $ dry Run , Reference Index Integrity Delegate Interface $ delegate = null ) { $ processed Tables = [ ] ; $ error Count = 0 ; $ record Count = 0 ; $ this - > call Delegate For Event ( $ delegate , 'will Start Operation ' , [ $ this - > persistence Context - > count All Records Of All Tables ( ) ] ) ; 
protected function execute ( Input Interface $ input , Output Interface $ output ) { $ helper = new Descriptor Helper ( ) ; $ helper - > register ( 'txt ' , new Text Descriptor ( ) ) ; $ helper - > describe ( $ output , $ this - > get Application ( ) , [ 'format ' = > $ input - > get Option ( 'format ' ) , 'raw _text ' = > $ input - > get Option ( 'raw ' ) , 'show _unavailable ' = > $ input - > get Option ( 'all ' ) , 'namespace ' = > $ input - > get Argument ( 'namespace ' ) , 'screen _width ' = > ( new Terminal ( ) ) - > get Width ( ) - 4 , ] ) ; $ application = $ this - > get Application ( ) ; if ( ! $ application instanceof Application ) { return 0 ; } if ( ! $ input - > get Argument ( 'namespace ' ) & & ! $ application - > is Fully Capable ( ) & & ! $ input - > get Option ( 'all ' ) ) { $ output Helper = new Symfony Style ( $ input , $ output ) ; $ messages = [ ' ' , sprintf ( ' <comment >TYPO 3 %s . < /comment > ' , $ application - > has Errors ( ) ? 'has errors ' : 'is not fully set up ' ) , ' <comment >Command list is reduced to only show low level commands . < /comment > ' , sprintf ( ' <comment >Not listed commands will not work until %s . < /comment > ' , $ application - > has Errors ( ) ? 'the errors are fixed ' : 'TYPO 3 is set up ' ) , sprintf ( ' <comment >Run " %s - -all " to list all commands . < /comment > ' , $ _SERVER [ 'PHP _SELF ' ] ) , ] ; $ output Helper - > get Error Style ( ) - > writeln ( $ messages ) ; } return null ; } 
public function write Log ( \ TYPO 3 \ CMS \ Core \ Log \ Log Record $ record ) { $ this - > output - > write ( $ this - > wrap Message ( vsprintf ( $ record - > get Message ( ) , $ record - > get Data ( ) ) , $ record - > get Level ( ) ) , true ) ; return $ this ; } 
public function get Performed Update Types ( ) { $ types Count = [ ] ; foreach ( $ this - > performed Updates as $ type = > $ performed Updates ) { $ types Count [ $ type ] = count ( $ performed Updates ) ; } return $ types Count ; } 
public function add Performed Updates ( Schema Update Type $ schema Update Type , array $ updates ) { $ this - > performed Updates [ ( string ) $ schema Update Type ] = array _merge ( ( array ) $ this - > performed Updates [ ( string ) $ schema Update Type ] , $ updates ) ; } 
public function add Errors ( Schema Update Type $ schema Update Type , array $ errors , array $ statements = [ ] ) { $ collected Errors = [ ] ; foreach ( $ errors as $ id = > $ error ) { $ collected Errors [ ] = [ 'message ' = > $ error , 'statement ' = > $ statements [ $ id ] , ] ; } $ this - > errors [ ( string ) $ schema Update Type ] = array _merge ( ( array ) $ this - > errors [ ( string ) $ schema Update Type ] , $ collected Errors ) ; } 
public function remove Command ( array $ paths , $ force = false ) { foreach ( $ paths as $ path ) { if ( ! $ this - > configuration Service - > local Is Active ( $ path ) ) { $ this - > output Line ( ' <warning >It seems that configuration for path " %s " is overridden . < /warning > ' , [ $ path ] ) ; $ this - > output Line ( ' <warning >Removing the new value might have no effect . < /warning > ' ) ; } if ( ! $ force & & $ this - > configuration Service - > has Local ( $ path ) ) { $ really Delete = $ this - > output - > ask Confirmation ( 'Remove ' . $ path . ' from system configuration (TYPO 3 _CONF _VARS ) ? (yes / <b >no < /b > ) : ' , false ) ; if ( ! $ really Delete ) { continue ; } } $ removed = $ this - > configuration Service - > remove Local ( $ path ) ; if ( $ removed ) { $ this - > output Line ( ' <info >Removed " %s " from system configuration . < /info > ' , [ $ path ] ) ; } else { $ this - > output Line ( ' <warning >Path " %s " seems invalid or empty . Nothing done ! < /warning > ' , [ $ path ] ) ; } } } 
public function show Command ( $ path ) { $ has Active = $ this - > configuration Service - > has Active ( $ path ) ; $ has Local = $ this - > configuration Service - > has Local ( $ path ) ; if ( ! $ has Active & & ! $ has Local ) { $ this - > output Line ( ' <error >No configuration found for path " %s " < /error > ' , [ $ path ] ) ; $ this - > quit ( 1 ) ; } $ active = null ; if ( $ has Active ) { $ active = $ this - > configuration Service - > get Active ( $ path ) ; } if ( $ this - > configuration Service - > local Is Active ( $ path ) & & $ has Active ) { $ this - > output Line ( $ this - > console Renderer - > render ( $ active ) ) ; } else { $ local = null ; if ( $ has Local ) { $ local = $ this - > configuration Service - > get Local ( $ path ) ; } $ this - > output Line ( $ this - > console Renderer - > render Diff ( $ local , $ active ) ) ; } } 
public function show Active Command ( $ path , $ json = false ) { if ( ! $ this - > configuration Service - > has Active ( $ path ) ) { $ this - > output Line ( ' <error >No configuration found for path " %s " < /error > ' , [ $ path ] ) ; $ this - > quit ( 1 ) ; } $ active = $ this - > configuration Service - > get Active ( $ path ) ; $ this - > output Line ( $ this - > console Renderer - > render ( $ active , $ json ) ) ; } 
public function show Local Command ( $ path , $ json = false ) { if ( ! $ this - > configuration Service - > has Local ( $ path ) ) { $ this - > output Line ( ' <error >No configuration found for path " %s " < /error > ' , [ $ path ] ) ; $ this - > quit ( 1 ) ; } $ active = $ this - > configuration Service - > get Local ( $ path ) ; $ this - > output Line ( $ this - > console Renderer - > render ( $ active , $ json ) ) ; } 
public function set Command ( $ path , $ value , $ json = false ) { if ( ! $ this - > configuration Service - > local Is Active ( $ path ) ) { $ this - > output Line ( ' <warning >It seems that configuration for path " %s " is overridden . < /warning > ' , [ $ path ] ) ; $ this - > output Line ( ' <warning >Writing the new value might have no effect . < /warning > ' ) ; } $ encoded Value = $ value ; if ( $ json ) { $ encoded Value = @ json _decode ( $ value , true ) ; } if ( $ encoded Value = = = null & & strtolower ( $ value ) ! = = 'null ' ) { $ this - > output Line ( ' <error >Could not decode value " %s " as json . < /error > ' , [ $ value ] ) ; $ this - > quit ( 2 ) ; } $ set Was Allowed = $ this - > configuration Service - > set Local ( $ path , $ encoded Value ) ; $ is Applied = $ this - > configuration Service - > has Local ( $ path ) ; if ( ! $ set Was Allowed ) { $ this - > output Line ( ' <warning >Could not set value " %s " for configuration path " %s " . < /warning > ' , [ $ value , $ path ] ) ; $ this - > output Line ( ' <warning >Possible reasons : configuration path is not allowed , configuration is not writable or type of value does not match given type . < /warning > ' , [ $ value , $ path ] ) ; $ this - > quit ( 1 ) ; } if ( $ is Applied ) { $ this - > output Line ( ' <info >Successfully set value for path " %s " . < /info > ' , [ $ path ] ) ; } else { $ this - > output Line ( ' <warning >Value " %s " for configuration path " %s " seems not applied . < /warning > ' , [ $ value , $ path ] ) ; $ this - > output Line ( ' <warning >Possible reasons : changed value in Additional Configuration .php or extension ext _localconf .php < /warning > ' ) ; } } 
public function after Installation ( $ key Of Installed Extension ) { if ( self : : EXTKEY ! = = $ key Of Installed Extension ) { return ; } $ script Name = $ this - > is Windows Os ( ) ? 'Scripts / ' . Application : : COMMAND _NAME . ' .bat ' : Application : : COMMAND _NAME ; $ success = $ this - > safe Copy ( PATH _site . self : : BINARY _PATH . $ script Name , PATH _site . basename ( $ script Name ) ) ; if ( ! $ success ) { self : : add Flash Message ( sprintf ( self : : COPY _FAILED _MESSAGE , $ script Name ) , sprintf ( self : : COPY _FAILED _MESSAGE _TITLE , $ script Name , PATH _site ) , Abstract Message : : WARNING ) ; } else { self : : add Flash Message ( sprintf ( self : : COPY _SUCCESS _MESSAGE , $ script Name ) ) ; } } 
protected function add Flash Message ( $ message Body , $ message Title = ' ' , $ severity = Abstract Message : : OK , $ store In Session = true ) { if ( PHP _SAPI = = = 'cli ' ) { return ; } if ( ! is _string ( $ message Body ) ) { throw new \ Invalid Argument Exception ( 'The message body must be of type string , " ' . gettype ( $ message Body ) . ' " given . ' , 1 4 1 8 2 5 0 2 8 6 ) ; } $ flash Message = General Utility : : make Instance ( \ TYPO 3 \ CMS \ Core \ Messaging \ Flash Message : : class , $ message Body , $ message Title , $ severity , $ store In Session ) ; $ queue = General Utility : : make Instance ( \ TYPO 3 \ CMS \ Core \ Messaging \ Flash Message Queue : : class , self : : EM _FLASH _MESSAGE _QUEUE _ID ) ; $ queue - > enqueue ( $ flash Message ) ; } 
private function safe Copy ( $ full Source Path , $ full Target Path , $ relative Web Dir = ' ' ) { if ( file _exists ( $ full Target Path ) ) { if ( ! is _file ( $ full Target Path ) ) { require _ _DIR _ _ . \ ' /typo 3conf /ext /typo 3 _console /Scripts /typo 3 -console .php \ ' ; ' , $ proxy File Content ) ; $ success = file _put _contents ( $ full Target Path , $ proxy File Content ) ; } if ( $ success & & ! $ this - > is Windows Os ( ) ) { $ success = @ chmod ( $ full Target Path , 0 7 5 5 ) ; } if ( $ success ) { $ success = @ file _put _contents ( $ full Target Path , str _replace ( ' { $relative -web -dir } ' , $ relative Web Dir , file _get _contents ( $ full Target Path ) ) ) ; } return $ success ; } 
protected function create Deprecated Definition ( ) : array { return [ new Input Option ( 'force ' , null , Input Option : : VALUE _NONE , 'Cache is forcibly flushed (low level operations are performed ) ' ) , new Input Argument ( 'force ' , null , 'Cache is forcibly flushed (low level operations are performed ) ' , false ) , new Input Argument ( 'files Only ' , null , 'Only file caches are flushed ' , false ) , ] ; } 
public function generate Xsd Command ( $ php Namespace , $ xsd Namespace = null , $ target File = null ) { if ( $ xsd Namespace = = = null ) { $ php Namespace = rtrim ( $ php Namespace , ' _ \ \ ' ) ; if ( strpos ( $ php Namespace , ' \ \ ' ) = = = false ) { $ search = [ 'Tx _ ' , ' _ ' ] ; $ replace = [ ' ' , ' / ' ] ; } else { $ search = ' \ \ ' ; $ replace = ' / ' ; } $ xsd Namespace = sprintf ( 'http : / /typo 3 .org /ns / %s ' , str _replace ( $ search , $ replace , $ php Namespace ) ) ; } $ xsd Schema = ' ' ; try { $ xsd Schema = $ this - > xsd Generator - > generate Xsd ( $ php Namespace , $ xsd Namespace ) ; } catch ( Service \ Exception $ exception ) { $ this - > output Line ( 'An error occurred while trying to generate the XSD schema : ' ) ; $ this - > output Line ( ' %s ' , [ $ exception - > get Message ( ) ] ) ; $ this - > quit ( 1 ) ; } if ( $ target File = = = null ) { echo $ xsd Schema ; } else { file _put _contents ( $ target File , $ xsd Schema ) ; } } 
private static function initialize Package Management ( Bootstrap $ bootstrap ) { $ package Manager = Compatibility Scripts : : create Package Manager ( ) ; $ bootstrap - > set Early Instance ( Package Manager : : class , $ package Manager ) ; General Utility : : set Singleton Instance ( Package Manager : : class , $ package Manager ) ; Extension Management Utility : : set Package Manager ( $ package Manager ) ; $ package Manager - > init ( ) ; } 
public static function provide Clean Class Implementations ( ) { self : : override Implementation ( \ TYPO 3 \ CMS \ Extbase \ Command \ Help Command Controller : : class , \ Helhum \ Typo 3Console \ Command \ Help Command Controller : : class ) ; self : : override Implementation ( \ TYPO 3 \ CMS \ Extbase \ Mvc \ Cli \ Command : : class , \ Helhum \ Typo 3Console \ Mvc \ Cli \ Command : : class ) ; 
public static function override Implementation ( $ original Class Name , $ override Class Name ) { self : : register Implementation ( $ original Class Name , $ override Class Name ) ; $ GLOBALS [ 'TYPO 3 _CONF _VARS ' ] [ 'SYS ' ] [ 'Objects ' ] [ $ original Class Name ] [ 'class Name ' ] = $ override Class Name ; class _alias ( $ override Class Name , $ original Class Name ) ; } 
private static function register Implementation ( $ class Name , $ alternative Class Name ) { $ extbase Object Container = \ TYPO 3 \ CMS \ Core \ Utility \ General Utility : : make Instance ( \ TYPO 3 \ CMS \ Extbase \ Object \ Container \ Container : : class ) ; $ extbase Object Container - > register Implementation ( $ class Name , $ alternative Class Name ) ; } 
public function set Local ( $ path , $ value , $ target Type = ' ' ) { try { $ value = $ this - > convert To Target Type ( $ path , $ value , $ target Type ) ; return $ this - > configuration Manager - > set Local Configuration Value By Path ( $ path , $ value ) ; } catch ( Types Are Not Convertible Exception $ e ) { return false ; } } 
public function local Is Active ( $ path ) { if ( $ this - > has Local ( $ path ) ) { return $ this - > has Active ( $ path ) & & $ this - > get Local ( $ path ) = = = $ this - > get Active ( $ path ) ; } return ! $ this - > has Active ( $ path ) ; } 
public function convert To Target Type ( $ path , $ value , $ target Type = ' ' ) { $ target Type = $ target Type ? : $ this - > get Type ( $ path ) ; $ actual Type = gettype ( $ value ) ; if ( $ actual Type ! = = $ target Type & & $ target Type ! = = 'NULL ' ) { if ( $ this - > is Type Convertible ( $ target Type , $ actual Type ) ) { switch ( $ target Type ) { case 'integer ' : $ value = ( int ) $ value ; break ; case 'float ' : case 'double ' : $ value = ( float ) $ value ; break ; case 'boolean ' : $ value = ( bool ) $ value ; break ; case 'string ' : $ value = ( string ) $ value ; break ; default : 
private function get Type ( $ path ) { $ value = null ; if ( $ this - > has Active ( $ path ) ) { $ value = $ this - > get Active ( $ path ) ; } if ( $ this - > has Local ( $ path ) ) { $ value = $ this - > get Local ( $ path ) ; } if ( $ this - > has Default ( $ path ) ) { $ value = $ this - > get Default ( $ path ) ; } return gettype ( $ value ) ; } 
private function is Type Convertible ( $ target Type , $ actual Type ) { if ( in _array ( $ target Type , [ 'array ' , 'object ' , 'resource ' ] , true ) ) { return false ; } if ( in _array ( $ actual Type , [ 'array ' , 'object ' , 'resource ' ] , true ) ) { return false ; } return true ; } 
public function is Command Available ( Command $ command ) : bool { if ( ! $ this - > is Fully Capable ( ) & & in _array ( $ command - > get Name ( ) , [ 
protected function configure ( ) { $ this - > set Description ( $ this - > command Definition - > get Short Description ( ) ) ; $ this - > set Help ( $ this - > command Definition - > get Description ( ) ) ; $ strict = $ this - > command Definition - > should Validate Input Strict ( ) ; if ( ! $ strict ) { $ this - > ignore Validation Errors ( ) ; } $ this - > set Definition ( $ this - > command Definition - > get Input Definitions ( ) ) ; } 
public function set Application ( Base Application $ application = null ) { if ( $ application ! = = null & & ! $ application instanceof Application ) { throw new Runtime Exception ( 'Command controller commands only work with TYPO 3 Console Applications ' , 1 5 0 6 3 8 1 7 8 1 ) ; } $ this - > application = $ application ; parent : : set Application ( $ application ) ; } 
protected function execute ( Input Interface $ input , Output Interface $ output ) { 
private function ensure Required Environment ( ) { if ( ! in _array ( PHP _SAPI , [ 'cli ' , 'phpdbg ' ] , true ) | | ! isset ( $ _SERVER [ 'argc ' ] , $ _SERVER [ 'argv ' ] ) ) { echo 'The command line must be executed with a cli PHP binary ! The current PHP sapi type is " ' . PHP _SAPI . ' " . ' . PHP _EOL ; exit ( 1 ) ; } if ( ini _get ( 'memory _limit ' ) ! = = ' - 1 ' ) { @ ini _set ( 'memory _limit ' , ' - 1 ' ) ; } if ( ini _get ( 'max _execution _time ' ) ! = = ' 0 ' ) { @ ini _set ( 'max _execution _time ' , ' 0 ' ) ; } } 
public static function initialize Compatibility Layer ( Class Loader $ class Loader ) { $ typo 3Branch = ' 9 5 ' ; if ( method _exists ( Bootstrap : : class , 'set Cache Hash Options ' ) ) { $ typo 3Branch = ' 8 7 ' ; } if ( $ typo 3Branch = = = ' 9 5 ' ) { return ; } $ class Loader = self : : $ non Composer Compat Class Loader ? ? $ class Loader ; $ compatibility Namespace = 'Helhum \ \Typo 3Console \ \TYPO 3v ' . $ typo 3Branch . ' \ \ ' ; spl _autoload _register ( function ( $ class Name ) use ( $ class Loader , $ compatibility Namespace ) { if ( strpos ( $ class Name , 'Helhum \ \Typo 3Console \ \ ' ) ! = = 0 ) { 
public function initialize ( string $ run Level = null ) { if ( ! $ this - > initialized ) { self : : initialize Compatibility Layer ( $ this - > class Loader ) ; Scripts : : base Setup ( $ this - > bootstrap ) ; $ this - > initialized = true ; } if ( $ run Level ! = = null ) { $ this - > run Level - > run Sequence ( $ run Level ) ; } } 
public function handle ( Input Interface $ input ) : int { $ this - > initialize ( ) ; $ command Collection = new Command Collection ( $ this - > run Level , new Command Configuration ( General Utility : : make Instance ( Package Manager : : class ) ) ) ; $ application = new Application ( $ this - > run Level , Compatibility Scripts : : is Composer Mode ( ) ) ; $ application - > set Command Loader ( $ command Collection ) ; 
public function execute Action With Arguments ( $ action Name , array $ arguments = [ ] , $ dry Run = false ) { $ action Method = 'execute ' . ucfirst ( $ action Name ) . 'Action ' ; $ check Method = 'check ' . ucfirst ( $ action Name ) . 'Action ' ; $ messages = [ ] ; $ needs Execution = file _exists ( PATH _site . 'FIRST _INSTALL ' ) ; if ( is _callable ( [ $ this - > installer Controller , $ check Method ] ) ) { $ needs Execution = ! \ json _decode ( ( string ) $ this - > installer Controller - > $ check Method ( ) - > get Body ( ) , true ) [ 'success ' ] ; } if ( $ needs Execution & & ! $ dry Run ) { $ request = ( $ this - > request Factory ) ( $ arguments ) ; try { $ response = \ json _decode ( ( string ) $ this - > installer Controller - > $ action Method ( $ request ) - > get Body ( ) , true ) ; if ( ! $ response [ 'success ' ] ) { $ messages = $ response [ 'status ' ] ; } } catch ( \ Throwable $ e ) { $ messages = [ [ 'severity ' = > Abstract Message : : ERROR , 'message ' = > $ e - > get Message ( ) , ] , ] ; } $ this - > silent Configuration Upgrade - > execute Silent Configuration Upgrades If Needed ( ) ; $ needs Execution = false ; } return new Install Step Response ( $ needs Execution , $ messages ) ; } 
public function render ( \ Throwable $ exception , Output Interface $ output , Application $ application = null ) { if ( getenv ( 'TYPO 3 _CONSOLE _SUB _PROCESS ' ) ) { $ output - > write ( \ json _encode ( $ this - > serialize Exception ( $ exception ) ) , false , Output Interface : : VERBOSITY _QUIET ) ; return ; } $ output - > writeln ( ' ' , Output Interface : : VERBOSITY _QUIET ) ; do { $ this - > output Exception ( $ exception , $ output ) ; if ( $ output - > is Verbose ( ) ) { $ this - > output Code ( $ exception , $ output ) ; $ this - > output Command ( $ exception , $ output ) ; $ this - > output Trace ( $ exception , $ output ) ; $ output - > writeln ( ' ' ) ; } $ exception = $ exception - > get Previous ( ) ; if ( $ exception ) { $ output - > writeln ( ' <comment >Caused by : < /comment > ' , Output Interface : : VERBOSITY _QUIET ) ; } } while ( $ exception ) ; $ this - > output Synopsis ( $ output , $ application ) ; } 
private function output Exception ( \ Throwable $ exception , Output Interface $ output ) { $ exception Class = get _class ( $ exception ) ; if ( $ exception instanceof Sub Process Exception ) { $ exception Class = $ exception - > get Previous Exception Class ( ) ; } $ title = sprintf ( ' [ %s ] ' , $ exception Class ) ; $ message Length = Helper : : strlen ( $ title ) ; $ max Width = $ this - > terminal - > get Width ( ) ? $ this - > terminal - > get Width ( ) - 1 : PHP _INT _MAX ; $ lines = [ ] ; foreach ( preg _split ( ' / \r ? \n / ' , trim ( $ exception - > get Message ( ) ) ) as $ line ) { foreach ( $ this - > split String By Width ( $ line , $ max Width - 4 ) as $ split Line ) { $ lines [ ] = $ split Line ; $ message Length = max ( Helper : : strlen ( $ split Line ) , $ message Length ) ; } } $ messages = [ ] ; $ messages [ ] = $ empty Line = $ this - > pad Message ( ' ' , $ message Length ) ; $ messages [ ] = $ this - > pad Message ( $ title , $ message Length ) ; foreach ( $ lines as $ line ) { $ messages [ ] = $ this - > pad Message ( Output Formatter : : escape ( $ line ) , $ message Length ) ; } $ messages [ ] = $ empty Line ; $ messages [ ] = ' ' ; $ output - > writeln ( $ messages , Output Interface : : VERBOSITY _QUIET ) ; } 
private function output Trace ( \ Throwable $ exception , Output Interface $ output ) { $ output - > writeln ( ' <comment >Exception trace : < /comment > ' ) ; $ backtrace Steps = $ this - > get Trace ( $ exception ) ; foreach ( $ backtrace Steps as $ index = > $ step ) { $ trace Line = ' # ' . $ index . ' ' ; if ( isset ( $ backtrace Steps [ $ index ] [ 'class ' ] ) ) { $ trace Line . = $ backtrace Steps [ $ index ] [ 'class ' ] ; } if ( isset ( $ backtrace Steps [ $ index ] [ 'function ' ] ) ) { $ trace Line . = ( isset ( $ backtrace Steps [ $ index ] [ 'class ' ] ) ? $ backtrace Steps [ $ index ] [ 'type ' ] : ' ' ) . $ backtrace Steps [ $ index ] [ 'function ' ] . ' ( ) ' ; } $ output - > writeln ( sprintf ( ' <info > %s < /info > ' , $ trace Line ) ) ; if ( isset ( $ backtrace Steps [ $ index ] [ 'file ' ] ) ) { $ output - > writeln ( ' ' . $ this - > get Possible Shortened File Name ( $ backtrace Steps [ $ index ] [ 'file ' ] ) . ( isset ( $ backtrace Steps [ $ index ] [ 'line ' ] ) ? ' : ' . $ backtrace Steps [ $ index ] [ 'line ' ] : ' ' ) ) ; } } } 
private function get Possible Shortened File Name ( $ file Name ) : string { $ path Prefixes = [ ] ; if ( getenv ( 'TYPO 3 _PATH _COMPOSER _ROOT ' ) ) { $ path Prefixes = [ getenv ( 'TYPO 3 _PATH _COMPOSER _ROOT ' ) . ' / ' ] ; } $ path Prefixes [ ] = PATH _site ; $ file Name = str _replace ( $ path Prefixes , ' ' , $ file Name ) ; $ path Position = strpos ( $ file Name , 'typo 3conf /ext / ' ) ; $ path And Filename = ( $ path Position ! = = false ) ? substr ( $ file Name , $ path Position ) : $ file Name ; $ path Position = strpos ( $ path And Filename , 'typo 3 /sysext / ' ) ; return ( $ path Position ! = = false ) ? substr ( $ path And Filename , $ path Position ) : $ path And Filename ; } 
public function error Command ( \ TYPO 3 \ CMS \ Extbase \ Mvc \ Exception \ Command Exception $ exception ) { $ this - > output Line ( ' <error > %s < /error > ' , [ $ exception - > get Message ( ) ] ) ; if ( $ exception instanceof \ TYPO 3 \ CMS \ Extbase \ Mvc \ Exception \ Ambiguous Command Identifier Exception ) { $ this - > output Line ( 'Please specify the complete command identifier . Matched commands : ' ) ; foreach ( $ exception - > get Matching Commands ( ) as $ matching Command ) { $ this - > output Line ( ' %s ' , [ $ matching Command - > get Command Identifier ( ) ] ) ; } } $ this - > output Line ( ) ; $ this - > output Line ( 'See <info >list < /info > for an overview of all available commands ' ) ; $ this - > output Line ( 'or <info >help < /info > <command > for a detailed description of the corresponding command . ' ) ; $ this - > quit ( 1 ) ; } 
public function update Schema Command ( array $ schema Update Types = [ 'safe ' ] , $ dry Run = false ) { $ verbose = $ this - > output - > get Symfony Console Output ( ) - > is Verbose ( ) ; try { $ expanded Schema Update Types = Schema Update Type : : expand Schema Update Types ( $ schema Update Types ) ; } catch ( Invalid Enumeration Value Exception $ e ) { $ this - > output Line ( sprintf ( ' <error > %s < /error > ' , $ e - > get Message ( ) ) ) ; $ this - > quit ( 1 ) ; } $ result = $ this - > schema Service - > update Schema ( $ expanded Schema Update Types , $ dry Run ) ; if ( $ result - > has Performed Updates ( ) ) { $ this - > output - > output Line ( ' <info >The following database schema updates %s performed : < /info > ' , [ $ dry Run ? 'should be ' : 'were ' ] ) ; $ this - > schema Update Result Renderer - > render ( $ result , $ this - > output , $ verbose ) ; } else { $ this - > output - > output Line ( ' <info >No schema updates %s performed for update type %s : %s < /info > ' , [ $ dry Run ? 'must be ' : 'were ' , count ( $ expanded Schema Update Types ) > 1 ? 's ' : ' ' , PHP _EOL . ' " ' . implode ( ' " , " ' , $ expanded Schema Update Types ) . ' " ' , ] ) ; } if ( $ result - > has Errors ( ) ) { $ this - > output Line ( ) ; $ this - > output - > output Line ( ' <error >The following errors occurred : < /error > ' ) ; $ this - > schema Update Result Renderer - > render Errors ( $ result , $ this - > output , $ verbose ) ; $ this - > quit ( 1 ) ; } } 
public function import Command ( $ interactive = false , string $ connection = 'Default ' ) { $ available Connection Names = $ this - > connection Configuration - > get Available Connection Names ( 'mysql ' ) ; if ( empty ( $ available Connection Names ) | | ! in _array ( $ connection , $ available Connection Names , true ) ) { $ this - > output ( ' <error >No suitable My SQL connection found for import . < /error > ' ) ; $ this - > quit ( 2 ) ; } $ mysql Command = new Mysql Command ( $ this - > connection Configuration - > build ( $ connection ) , [ ] , $ this - > output - > get Symfony Console Output ( ) ) ; $ exit Code = $ mysql Command - > mysql ( $ interactive ? [ ] : [ ' - -skip -column -names ' ] , STDIN , null , $ interactive ) ; $ this - > quit ( $ exit Code ) ; } 
public function render ( array $ upgrade Wizard List , Console Output $ output , $ verbose = false ) { if ( empty ( $ upgrade Wizard List ) ) { $ output - > output Line ( ' <info >None < /info > ' ) ; return ; } $ table Header = [ 'Identifier ' , 'Title ' ] ; if ( $ verbose ) { $ table Header = [ 'Identifier ' , 'Description ' ] ; } $ table Rows = [ ] ; foreach ( $ upgrade Wizard List as $ identifier = > $ info ) { $ row = [ $ identifier , wordwrap ( $ info [ 'title ' ] , 4 0 ) , ] ; if ( $ verbose ) { $ row = [ $ identifier , wordwrap ( $ info [ 'explanation ' ] , 4 0 ) , ] ; } $ table Rows [ ] = $ row ; $ table Rows [ ] = new Table Separator ( ) ; } array _pop ( $ table Rows ) ; $ output - > output Table ( $ table Rows , $ table Header ) ; } 
public function execute In Sub Process ( $ command , array $ arguments = [ ] , array & $ messages = [ ] ) { $ messages = $ this - > ensure Upgrade Is Possible ( ) ; return @ unserialize ( $ this - > command Dispatcher - > execute Command ( 'upgrade :subprocess ' , [ $ command , serialize ( $ arguments ) ] ) ) ; } 
public function render Schema Result ( Console Output $ output , Schema Update Result Renderer $ schema Update Result Renderer = null ) { if ( ! isset ( $ this - > results [ 'render Schema Result ' ] ) ) { return ; } $ result = reset ( $ this - > results [ 'render Schema Result ' ] ) ; if ( $ result - > has Performed Updates ( ) ) { $ schema Update Result Renderer = $ schema Update Result Renderer ? : new Schema Update Result Renderer ( ) ; $ output - > output Line ( ' <info >The following database schema updates were performed : < /info > ' ) ; $ schema Update Result Renderer - > render ( $ result , $ output , true ) ; } else { $ output - > output Line ( ' <info >No schema updates were performed for update types : %s < /info > ' , [ PHP _EOL . ' " ' . implode ( ' " , " ' , Schema Update Type : : expand Schema Update Types ( [ 'safe ' ] ) ) . ' " ' , ] ) ; } } 
public function render Imported Static Data Result ( Console Output $ output ) { if ( ! isset ( $ this - > results [ 'render Imported Static Data Result ' ] ) ) { return ; } foreach ( $ this - > results [ 'render Imported Static Data Result ' ] as $ path To Static Sql File ) { 
public function render Extension File Import Result ( Console Output $ output ) { if ( ! isset ( $ this - > results [ 'render Extension File Import Result ' ] ) ) { return ; } foreach ( $ this - > results [ 'render Extension File Import Result ' ] as $ destination Absolute Path ) { $ output - > output Formatted ( ' <info >Files from extension was imported to path " %s " < /info > ' , [ Path Utility : : strip Path Site Prefix ( $ destination Absolute Path ) ] ) ; } } 
public function render Extension Data Import Result ( Console Output $ output ) { if ( ! isset ( $ this - > results [ 'render Extension Data Import Result ' ] ) ) { return ; } foreach ( $ this - > results [ 'render Extension Data Import Result ' ] as $ imported File ) { $ output - > output Formatted ( ' <info >Data from from file " %s " was imported < /info > ' , [ $ imported File ] ) ; } } 
public function update Reference Index Command ( $ dry Run = false , $ show Progress = false ) { $ verbose = $ this - > output - > get Symfony Console Output ( ) - > is Verbose ( ) ; $ this - > output Line ( ' <info > ' . ( $ dry Run ? 'Checking ' : 'Updating ' ) . ' reference index . This may take a while … < /info > ' ) ; $ operation = $ dry Run ? 'check Reference Index ' : 'update Reference Index ' ; list ( $ error Count , $ record Count , $ processed Tables ) = $ this - > persistence Integrity Service - > { $ operation } ( $ this - > create Reference Index Delegate With Options ( $ dry Run , $ verbose , $ show Progress ) ) ; if ( $ error Count > 0 ) { $ this - > output Line ( ' <info > %d errors were ' . ( $ dry Run ? 'found ' : 'fixed ' ) . ' , while ' . ( $ dry Run ? 'checking ' : 'updating ' ) . ' reference index for %d records from %d tables . < /info > ' , [ $ error Count , $ record Count , count ( $ processed Tables ) ] ) ; } else { $ this - > output Line ( ) ; $ this - > output Line ( ' <info >Index integrity was perfect ! < /info > ' ) ; } } 
public function update Schema ( array $ schema Update Types , $ dry Run = false ) { $ update Statements = [ Schema Update Type : : GROUP _SAFE = > $ this - > schema Update - > get Safe Updates ( ) , Schema Update Type : : GROUP _DESTRUCTIVE = > $ this - > schema Update - > get Destructive Updates ( ) , ] ; $ update Result = new Schema Update Result ( ) ; foreach ( $ schema Update Types as $ schema Update Type ) { foreach ( $ schema Update Type - > get Statement Types ( ) as $ statement Type = > $ statement Group ) { if ( isset ( $ update Statements [ $ statement Group ] [ $ statement Type ] ) ) { $ statements = $ update Statements [ $ statement Group ] [ $ statement Type ] ; if ( empty ( $ statements ) ) { continue ; } if ( $ dry Run ) { $ update Result - > add Performed Updates ( $ schema Update Type , $ statements ) ; } else { $ result = $ this - > schema Update - > migrate ( $ statements , 
public function get Maximum Available Run Level ( ) : string { if ( ! file _exists ( PATH _site . 'typo 3conf /Package States .php ' ) | | ! file _exists ( PATH _site . 'typo 3conf /Local Configuration .php ' ) ) { return self : : LEVEL _COMPILE ; } return $ this - > error ? self : : LEVEL _COMPILE : self : : LEVEL _FULL ; } 
private function build Sequence ( string $ run Level ) : Sequence { if ( is _callable ( [ $ this , $ run Level ] ) ) { return $ this - > { $ run Level } ( $ run Level ) ; } throw new Invalid Argument Exception ( 'Invalid run level " ' . $ run Level . ' " ' , 1 4 0 2 0 7 5 4 9 2 ) ; } 
private function build Essential Sequence ( string $ identifier ) : Sequence { $ sequence = new Sequence ( $ identifier ) ; $ this - > add Step ( $ sequence , 'helhum .typo 3console :coreconfiguration ' ) ; $ this - > add Step ( $ sequence , 'helhum .typo 3console :providecleanclassimplementations ' ) ; $ this - > add Step ( $ sequence , 'helhum .typo 3console :disabledcaching ' ) ; $ this - > add Step ( $ sequence , 'helhum .typo 3console :errorhandling ' ) ; return $ sequence ; } 
private function build Basic Runtime Sequence ( string $ identifier = self : : LEVEL _MINIMAL ) : Sequence { $ sequence = $ this - > build Essential Sequence ( $ identifier ) ; $ this - > add Step ( $ sequence , 'helhum .typo 3console :extensionconfiguration ' ) ; return $ sequence ; } 
private function build Extended Runtime Sequence ( ) : Sequence { $ sequence = $ this - > build Basic Runtime Sequence ( self : : LEVEL _FULL ) ; $ this - > add Step ( $ sequence , 'helhum .typo 3console :caching ' ) ; 
public function flush Groups Command ( array $ groups ) { try { $ this - > cache Service - > flush Groups ( $ groups ) ; $ this - > output Line ( 'Flushed all caches for group (s ) : " ' . implode ( ' " , " ' , $ groups ) . ' " . ' ) ; } catch ( No Such Cache Group Exception $ e ) { $ this - > output Line ( $ e - > get Message ( ) ) ; $ this - > quit ( 1 ) ; } } 
public function flush Tags Command ( array $ tags , array $ groups = null ) { try { $ this - > cache Service - > flush By Tags And Groups ( $ tags , $ groups ) ; if ( $ groups = = = null ) { $ this - > output Line ( 'Flushed caches by tags " ' . implode ( ' " , " ' , $ tags ) . ' " . ' ) ; } else { $ this - > output Line ( 'Flushed caches by tags " ' . implode ( ' " , " ' , $ tags ) . ' " in groups : " ' . implode ( ' " , " ' , $ groups ) . ' " . ' ) ; } } catch ( No Such Cache Group Exception $ e ) { $ this - > output Line ( $ e - > get Message ( ) ) ; $ this - > quit ( 1 ) ; } } 
public function list Groups Command ( ) { $ groups = $ this - > cache Service - > get Valid Cache Groups ( ) ; sort ( $ groups ) ; switch ( count ( $ groups ) ) { case 0 : $ this - > output Line ( 'No cache groups are registered . ' ) ; break ; case 1 : $ this - > output Line ( 'The following cache group is registered : " ' . implode ( ' " , " ' , $ groups ) . ' " . ' ) ; break ; default : $ this - > output Line ( 'The following cache groups are registered : " ' . implode ( ' " , " ' , $ groups ) . ' " . ' ) ; break ; } } 
public function create ( string $ name , array $ config ) : Dictionary { if ( ! isset ( $ config [ 'content ' ] ) ) { throw new Invalid Argument Exception ( sprintf ( 'The key content for dictionary %s must be set . ' , $ name ) ) ; } $ content = $ config [ 'content ' ] ; $ values = [ ] ; foreach ( $ content as $ value ) { $ built Value = $ this - > transformer - > transform ( $ value ) ; $ values [ $ built Value ] = $ built Value ; } return new Dictionary \ Simple ( $ name , $ values ) ; } 
public function create ( string $ name , array $ config ) : Dictionary { if ( ! isset ( $ config [ 'service ' ] ) ) { throw new Invalid Argument Exception ( sprintf ( 'The "service " config key must be set for the dictionary named " %s " . ' , $ name ) ) ; } $ service = $ this - > container - > get ( $ config [ 'service ' ] ) ; $ callable = [ $ service ] ; if ( isset ( $ config [ 'method ' ] ) ) { $ callable [ ] = $ config [ 'method ' ] ; } if ( false = = = \ is _callable ( $ callable ) ) { throw new Invalid Argument Exception ( sprintf ( 'You must provide a valid callable for the dictionary named " %s " . ' , $ name ) ) ; } return new Dictionary \ Invokable ( $ name , $ callable ) ; } 
public function create ( string $ name , array $ config ) : Dictionary { if ( ! isset ( $ config [ 'dictionaries ' ] ) ) { throw new Invalid Argument Exception ( sprintf ( 'Dictionary of type %s must contains a key "dictionaries " . ' , self : : TYPE ) ) ; } $ dictionaries = array _map ( function ( $ name ) { return $ this - > dictionaries [ $ name ] ; } , $ config [ 'dictionaries ' ] ) ; return new Dictionary \ Combined ( $ name , $ dictionaries ) ; } 
public function offset Get ( $ offset ) { if ( false = = = $ this - > offset Exists ( $ offset ) ) { throw new Dictionary Not Found Exception ( $ offset , array _keys ( $ this - > dictionaries ) ) ; } return $ this - > get ( $ offset ) ; } 
public function process ( Container Builder $ container ) : void { foreach ( $ container - > find Tagged Service Ids ( self : : TAG _FACTORY ) as $ id = > $ tags ) { $ container - > find Definition ( Aggregate : : class ) - > add Method Call ( 'add Factory ' , [ new Reference ( $ id ) ] ) ; } } 
public function create ( string $ name , array $ config ) : Dictionary { return $ this - > factory - > create ( $ name , $ config ) ; } 
public function create ( string $ name , array $ config ) : Dictionary { foreach ( $ this - > factories as $ factory ) { if ( $ factory - > supports ( $ config ) ) { return $ factory - > create ( $ name , $ config ) ; } } throw new Invalid Argument Exception ( sprintf ( 'The dictionary with named " %s " cannot be created . ' , $ name ) ) ; } 
public function supports ( array $ config ) : bool { foreach ( $ this - > factories as $ factory ) { if ( $ factory - > supports ( $ config ) ) { return true ; } } return false ; } 
public function configure Options ( Options Resolver $ resolver ) : void { $ dictionaries = $ this - > dictionaries ; $ choices = function ( Options $ options ) use ( $ dictionaries ) { $ name = $ options [ 'name ' ] ; $ choices = $ dictionaries [ $ name ] - > get Values ( ) ; return array _flip ( $ choices ) ; } ; $ resolver - > set Default ( 'choices ' , $ choices ) - > set Required ( [ 'name ' ] ) - > set Allowed Values ( 'name ' , array _keys ( iterator _to _array ( $ this - > dictionaries ) ) ) ; } 
public function offset Set ( $ offset , $ value ) : void { $ this - > hydrate ( ) ; $ this - > values [ $ offset ] = $ value ; } 
private function hydrate ( ) : void { if ( null ! = = $ this - > values ) { return ; } $ values = \ call _user _func _array ( $ this - > callable , $ this - > callable Args ) ; if ( false = = = \ is _array ( $ values ) ) { throw new Invalid Argument Exception ( 'Dictionary callable must return an array or an instance of Array Access . ' ) ; } $ this - > values = $ values ; } 
public function process ( Container Builder $ container ) : void { foreach ( $ container - > find Tagged Service Ids ( self : : TAG _DICTIONARY ) as $ id = > $ tags ) { $ container - > get Definition ( Collection : : class ) - > add Method Call ( 'add ' , [ new Reference ( $ id ) ] ) ; } } 
public function offset Set ( $ offset , $ value ) : void { $ this - > dictionary - > offset Set ( $ offset , $ value ) ; $ this - > trace ( ) ; } 
private function trace ( ) : void { $ this - > collector - > add Dictionary ( $ this - > dictionary - > get Name ( ) , $ this - > dictionary - > get Keys ( ) , array _values ( $ this - > dictionary - > get Values ( ) ) ) ; } 
public function create ( string $ name , array $ config ) : Dictionary { if ( false = = = $ this - > factory - > supports ( $ config ) ) { throw new Invalid Argument Exception ( sprintf ( 'The dictionary with named " %s " cannot be created . ' , $ name ) ) ; } $ extends = $ config [ 'extends ' ] ; unset ( $ config [ 'extends ' ] ) ; $ dictionaries = [ ] ; $ dictionaries [ ] = $ this - > dictionaries [ $ extends ] ; $ dictionaries [ ] = $ this - > factory - > create ( $ name , $ config ) ; return new Dictionary \ Combined ( $ name , $ dictionaries ) ; } 
public function get Config Tree Builder ( ) { $ builder = new Tree Builder ( ) ; $ builder - > root ( 'knp _dictionary ' ) - > children ( ) - > array Node ( 'dictionaries ' ) - > use Attribute As Key ( 'name ' ) - > prototype ( 'array ' ) - > before Normalization ( ) - > always ( ) - > then ( function ( $ values ) { if ( false = = = array _key _exists ( 'type ' , $ values ) ) { if ( false = = = array _key _exists ( 'content ' , $ values ) ) { return [ 'type ' = > 'value ' , 'content ' = > $ values ] ; } return array _merge ( $ values , [ 'type ' = > 'value ' ] ) ; } return $ values ; } ) - > end ( ) - > children ( ) - > scalar Node ( 'type ' ) - > default Value ( 'value ' ) - > end ( ) - > scalar Node ( 'extends ' ) - > end ( ) - > array Node ( 'dictionaries ' ) - > normalize Keys ( false ) - > prototype ( 'scalar ' ) - > end ( ) - > end ( ) - > array Node ( 'content ' ) - > normalize Keys ( false ) - > prototype ( 'scalar ' ) - > end ( ) - > end ( ) - > scalar Node ( 'service ' ) - > end ( ) - > scalar Node ( 'method ' ) - > end ( ) - > end ( ) - > end ( ) - > end ( ) - > end ( ) ; return $ builder ; } 
public function process ( Container Builder $ container ) : void { if ( false = = = $ container - > has ( Dictionary Data Collector : : class ) ) { return ; } foreach ( $ container - > find Tagged Service Ids ( Dictionary Registration Pass : : TAG _DICTIONARY ) as $ id = > $ tags ) { $ service Id = sprintf ( ' %s . %s .traceable ' , $ id , md 5 ( $ id ) ) ; $ dictionary = new Reference ( sprintf ( ' %s .inner ' , $ service Id ) ) ; $ traceable = new Definition ( Traceable : : class , [ $ dictionary , new Reference ( Dictionary Data Collector : : class ) ] ) ; $ traceable - > set Decorated Service ( $ id ) ; $ container - > set Definition ( $ service Id , $ traceable ) ; } } 
public function transform ( $ value ) { foreach ( $ this - > transformers as $ transformer ) { if ( $ transformer - > supports ( $ value ) ) { return $ transformer - > transform ( $ value ) ; } } return $ value ; } 
public function supports ( $ value ) : bool { foreach ( $ this - > transformers as $ transformer ) { if ( $ transformer - > supports ( $ value ) ) { return true ; } } return false ; } 
public function create ( string $ name , array $ config ) : Dictionary { if ( ! isset ( $ config [ 'service ' ] ) ) { throw new Invalid Argument Exception ( sprintf ( 'The "service " config key must be set for the dictionary named " %s " . ' , $ name ) ) ; } $ service = $ this - > container - > get ( $ config [ 'service ' ] ) ; if ( false = = = $ service instanceof Traversable ) { throw new Invalid Argument Exception ( sprintf ( 'You must provide a valid instance of Traversable for the dictionary named " %s " . ' , $ name ) ) ; } return new Dictionary \ Iterator ( $ name , $ callable ) ; } 
public function build ( Container Builder $ container ) : void { $ container - > add Compiler Pass ( new Compiler \ Dictionary Building Pass ( ) ) ; $ container - > add Compiler Pass ( new Compiler \ Dictionary Factory Building Pass ( ) ) ; $ container - > add Compiler Pass ( new Compiler \ Dictionary Registration Pass ( ) ) ; $ container - > add Compiler Pass ( new Compiler \ Dictionary Trace Pass ( ) ) ; } 
public function process ( Container Builder $ container ) : void { $ configuration = $ container - > get Parameter ( 'knp _dictionary .configuration ' ) ; foreach ( $ configuration [ 'dictionaries ' ] as $ name = > $ config ) { $ container - > set Definition ( sprintf ( 'knp _dictionary .dictionary . %s ' , $ name ) , $ this - > create Definition ( $ name , $ config ) ) ; } } 
public function validate ( $ value , Constraint $ constraint ) : void { if ( false = = = $ constraint instanceof Dictionary ) { throw new Unexpected Type Exception ( $ constraint , _ _NAMESPACE _ _ . ' \Dictionary ' ) ; } if ( null = = = $ value | | ' ' = = = $ value ) { return ; } $ dictionary = $ this - > dictionaries [ $ constraint - > name ] ; $ values = $ dictionary - > get Keys ( ) ; if ( false = = = \ in _array ( $ value , $ values ) ) { $ this - > context - > add Violation ( $ constraint - > message , [ ' { { key } } ' = > $ value , ' { { keys } } ' = > implode ( ' , ' , $ values ) ] ) ; } } 
public function supports ( $ value ) : bool { if ( false = = = \ is _string ( $ value ) ) { return false ; } $ matches = [ ] ; if ( 0 = = = preg _match ( $ this - > pattern , $ value , $ matches ) ) { return false ; } if ( false = = = class _exists ( $ matches [ 'class ' ] ) & & false = = = interface _exists ( $ matches [ 'class ' ] ) ) { return false ; } $ constants = ( new Reflection Class ( $ matches [ 'class ' ] ) ) - > get Constants ( ) ; return array _key _exists ( $ matches [ 'constant ' ] , $ constants ) ; } 
public function transform ( $ value ) { $ matches = [ ] ; preg _match ( $ this - > pattern , $ value , $ matches ) ; return ( new Reflection Class ( $ matches [ 'class ' ] ) ) - > get Constant ( $ matches [ 'constant ' ] ) ; } 
public function index Action ( Request $ request ) { $ query Parameters = $ request - > query - > all ( ) ; $ translator = $ this - > get ( 'translator ' ) ; $ is Json = $ request - > get ( 'json ' ) ? true : false ; if ( $ is Json ) { unset ( $ query Parameters [ 'json ' ] ) ; } $ file Manager = $ this - > new File Manager ( $ query Parameters ) ; 
public function rename File Action ( Request $ request , $ file Name ) { $ translator = $ this - > get ( 'translator ' ) ; $ query Parameters = $ request - > query - > all ( ) ; $ form Rename = $ this - > create Rename Form ( ) ; $ form Rename - > handle Request ( $ request ) ; if ( $ form Rename - > is Submitted ( ) & & $ form Rename - > is Valid ( ) ) { $ data = $ form Rename - > get Data ( ) ; $ extension = $ data [ 'extension ' ] ? ' . ' . $ data [ 'extension ' ] : ' ' ; $ newfile Name = $ data [ 'name ' ] . $ extension ; if ( $ newfile Name ! = = $ file Name & & isset ( $ data [ 'name ' ] ) ) { $ file Manager = $ this - > new File Manager ( $ query Parameters ) ; $ Newfile Path = $ file Manager - > get Current Path ( ) . DIRECTORY _SEPARATOR . $ newfile Name ; $ Oldfile Path = realpath ( $ file Manager - > get Current Path ( ) . DIRECTORY _SEPARATOR . $ file Name ) ; if ( 0 ! = = strpos ( $ Newfile Path , $ file Manager - > get Current Path ( ) ) ) { $ this - > add Flash ( 'danger ' , $ translator - > trans ( 'file .renamed .unauthorized ' ) ) ; } else { $ fs = new Filesystem ( ) ; try { $ fs - > rename ( $ Oldfile Path , $ Newfile Path ) ; $ this - > add Flash ( 'success ' , $ translator - > trans ( 'file .renamed .success ' ) ) ; 
public function upload File Action ( Request $ request ) { $ file Manager = $ this - > new File Manager ( $ request - > query - > all ( ) ) ; $ options = [ 'upload _dir ' = > $ file Manager - > get Current Path ( ) . DIRECTORY _SEPARATOR , 'upload _url ' = > $ file Manager - > get Image Path ( ) , 'accept _file _types ' = > $ file Manager - > get Regex ( ) , 'print _response ' = > false , ] ; if ( isset ( $ file Manager - > get Configuration ( ) [ 'upload ' ] ) ) { $ options + = $ file Manager - > get Configuration ( ) [ 'upload ' ] ; } $ this - > dispatch ( File Manager Events : : PRE _UPDATE , [ 'options ' = > & $ options ] ) ; $ upload Handler = new Upload Handler ( $ options ) ; $ response = $ upload Handler - > response ; foreach ( $ response [ 'files ' ] as $ file ) { if ( isset ( $ file - > error ) ) { $ file - > error = $ this - > get ( 'translator ' ) - > trans ( $ file - > error ) ; } if ( ! $ file Manager - > get Image Path ( ) ) { $ file - > url = $ this - > generate Url ( 'file _manager _file ' , array _merge ( $ file Manager - > get Query Parameters ( ) , [ 'file Name ' = > $ file - > url ] ) ) ; } } $ this - > dispatch ( File Manager Events : : POST _UPDATE , [ 'response ' = > & $ response ] ) ; return new Json Response ( $ response ) ; } 
public function binary File Response Action ( Request $ request , $ file Name ) { $ file Manager = $ this - > new File Manager ( $ request - > query - > all ( ) ) ; return new Binary File Response ( $ file Manager - > get Current Path ( ) . DIRECTORY _SEPARATOR . urldecode ( $ file Name ) ) ; } 
public function delete Action ( Request $ request ) { $ form = $ this - > create Delete Form ( ) ; $ form - > handle Request ( $ request ) ; $ query Parameters = $ request - > query - > all ( ) ; if ( $ form - > is Submitted ( ) & & $ form - > is Valid ( ) ) { 
private function retrieve Sub Directories ( File Manager $ file Manager , $ path , $ parent = DIRECTORY _SEPARATOR , $ base Folder Name = false ) { $ directories = new Finder ( ) ; $ directories - > in ( $ path ) - > ignore Unreadable Dirs ( ) - > directories ( ) - > depth ( 0 ) - > sort By Type ( ) - > filter ( function ( Spl File Info $ file ) { return $ file - > is Readable ( ) ; } ) ; if ( $ base Folder Name ) { $ directories - > name ( $ base Folder Name ) ; } $ directories List = null ; foreach ( $ directories as $ directory ) { $ file Name = $ base Folder Name ? ' ' : $ parent . $ directory - > get Filename ( ) ; $ query Parameters = $ file Manager - > get Query Parameters ( ) ; $ query Parameters [ 'route ' ] = $ file Name ; $ query Parameters Route = $ query Parameters ; unset ( $ query Parameters Route [ 'route ' ] ) ; $ files Number = $ this - > retrieve Files Number ( $ directory - > get Pathname ( ) , $ file Manager - > get Regex ( ) ) ; $ file Span = $ files Number > 0 ? " <span class = 'label label -default ' > { $files Number } < /span > " : ' ' ; $ directories List [ ] = [ 'text ' = > $ directory - > get Filename ( ) . $ file Span , 'icon ' = > 'far fa -folder -open ' , 'children ' = > $ this - > retrieve Sub Directories ( $ file Manager , $ directory - > get Pathname ( ) , $ file Name . DIRECTORY _SEPARATOR ) , 'a _attr ' = > [ 'href ' = > $ file Name ? $ this - > generate Url ( 'file _manager ' , $ query Parameters ) : $ this - > generate Url ( 'file _manager ' , $ query Parameters Route ) , ] , 'state ' = > [ 'selected ' = > $ file Manager - > get Current Route ( ) = = = $ file Name , 'opened ' = > true , ] , ] ; } return $ directories List ; } 
private function retrieve Files Number ( $ path , $ regex ) { $ files = new Finder ( ) ; $ files - > in ( $ path ) - > files ( ) - > depth ( 0 ) - > name ( $ regex ) ; return iterator _count ( $ files ) ; } 
private function get Base Path ( $ query Parameters ) { $ conf = $ query Parameters [ 'conf ' ] ; $ manager Conf = $ this - > get Parameter ( 'artgris _file _manager ' ) [ 'conf ' ] ; if ( isset ( $ manager Conf [ $ conf ] [ 'dir ' ] ) ) { return $ manager Conf [ $ conf ] ; } if ( isset ( $ manager Conf [ $ conf ] [ 'service ' ] ) ) { $ extra = isset ( $ query Parameters [ 'extra ' ] ) ? $ query Parameters [ 'extra ' ] : [ ] ; $ conf = $ this - > get ( $ manager Conf [ $ conf ] [ 'service ' ] ) - > get Conf ( $ extra ) ; return $ conf ; } throw new \ Runtime Exception ( 'Please define a "dir " or a "service " parameter in your config .yml ' ) ; } 
private function new File Manager ( $ query Parameters ) { if ( ! isset ( $ query Parameters [ 'conf ' ] ) ) { throw new \ Runtime Exception ( 'Please define a conf parameter in your route ' ) ; } $ web Dir = $ this - > get Parameter ( 'artgris _file _manager ' ) [ 'web _dir ' ] ; $ this - > file Manager = new File Manager ( $ query Parameters , $ this - > get Base Path ( $ query Parameters ) , $ this - > get Kernel Route ( ) , $ this - > get ( 'router ' ) , $ web Dir ) ; return $ this - > file Manager ; } 
public function get Config Tree Builder ( ) { $ tree Builder = new Tree Builder ( ) ; $ root Node = $ tree Builder - > root ( 'artgris _file _manager ' ) ; $ root Node - > children ( ) - > scalar Node ( 'web _dir ' ) - > default Value ( 'web ' ) - > end ( ) - > array Node ( 'conf ' ) - > prototype ( 'array ' ) - > children ( ) - > scalar Node ( 'dir ' ) - > end ( ) - > enum Node ( 'type ' ) - > values ( [ 'file ' , 'image ' , 'media ' ] ) - > end ( ) - > boolean Node ( 'tree ' ) - > end ( ) - > enum Node ( 'view ' ) - > values ( [ 'thumbnail ' , 'list ' ] ) - > default Value ( 'list ' ) - > end ( ) - > scalar Node ( 'regex ' ) - > end ( ) - > scalar Node ( 'service ' ) - > end ( ) - > scalar Node ( 'accept ' ) - > end ( ) - > array Node ( 'upload ' ) - > children ( ) - > integer Node ( 'min _file _size ' ) - > end ( ) - > integer Node ( 'max _file _size ' ) - > end ( ) - > integer Node ( 'max _width ' ) - > end ( ) - > integer Node ( 'max _height ' ) - > end ( ) - > integer Node ( 'min _width ' ) - > end ( ) - > integer Node ( 'min _height ' ) - > end ( ) - > integer Node ( 'image _library ' ) - > end ( ) - > array Node ( 'image _versions ' ) - > prototype ( 'array ' ) - > children ( ) - > boolean Node ( 'auto _orient ' ) - > end ( ) - > boolean Node ( 'crop ' ) - > end ( ) - > integer Node ( 'max _width ' ) - > end ( ) - > integer Node ( 'max _height ' ) - > end ( ) - > end ( ) - > end ( ) - > end ( ) - > boolean Node ( 'override ' ) - > default Value ( false ) - > end ( ) - > end ( ) - > end ( ) - > end ( ) - > end ( ) - > end ( ) - > end ( ) ; return $ tree Builder ; } 
public function get Parent ( ) { $ query Parent Parameters = $ this - > query Parameters ; $ parent Route = dirname ( $ this - > get Current Route ( ) ) ; if ( DIRECTORY _SEPARATOR ! = = $ parent Route ) { $ query Parent Parameters [ 'route ' ] = dirname ( $ this - > get Current Route ( ) ) ; } else { unset ( $ query Parent Parameters [ 'route ' ] ) ; } $ parent Route = $ this - > router - > generate ( 'file _manager ' , $ query Parent Parameters ) ; return $ this - > get Route ( ) ? $ parent Route : null ; } 
public function to JSON ( $ data , $ options = 0 ) { 
public function get Description ( ) { $ id = $ this - > get Transaction Id ( ) ; $ desc = parent : : get Description ( ) ; if ( empty ( $ id ) ) { return $ desc ; } elseif ( empty ( $ desc ) ) { return $ id ; } else { return " $id : $desc " ; } } 
public function is Successful ( ) { $ success = isset ( $ this - > data [ 'ACK ' ] ) & & in _array ( $ this - > data [ 'ACK ' ] , array ( 'Success ' , 'Success With Warning ' ) ) ; return ! $ this - > is Redirect ( ) & & $ success ; } 
public function get Transaction Reference ( ) { if ( $ this - > is Successful ( ) & & isset ( $ this - > data [ 'PAYMENTINFO _ 0 _TRANSACTIONID ' ] ) ) { return $ this - > data [ 'PAYMENTINFO _ 0 _TRANSACTIONID ' ] ; } return parent : : get Transaction Reference ( ) ; } 
public function get Token ( $ create If Needed = true ) { if ( $ create If Needed & & ! $ this - > has Token ( ) ) { $ response = $ this - > create Token ( ) - > send ( ) ; if ( $ response - > is Successful ( ) ) { $ data = $ response - > get Data ( ) ; if ( isset ( $ data [ 'access _token ' ] ) ) { $ this - > set Token ( $ data [ 'access _token ' ] ) ; $ this - > set Token Expires ( time ( ) + $ data [ 'expires _in ' ] ) ; } } } return $ this - > get Parameter ( 'token ' ) ; } 
public function has Token ( ) { $ token = $ this - > get Parameter ( 'token ' ) ; $ expires = $ this - > get Token Expires ( ) ; if ( ! empty ( $ expires ) & & ! is _numeric ( $ expires ) ) { $ expires = strtotime ( $ expires ) ; } return ! empty ( $ token ) & & time ( ) < $ expires ; } 
public function create Request ( $ class , array $ parameters = array ( ) ) { if ( ! $ this - > has Token ( ) & & $ class ! = ' \Omnipay \Pay Pal \Message \Rest Token Request ' ) { 
public function add ( $ item ) { if ( $ item instanceof Item Interface ) { $ this - > items [ ] = $ item ; } else { $ this - > items [ ] = new Pay Pal Item ( $ item ) ; } } 
public function set Start Time ( $ value ) { if ( $ value instanceof \ Date Time ) { $ value - > set Timezone ( new \ Date Time Zone ( 'UTC ' ) ) ; $ value = $ value - > format ( 'Y -m -d \TH :i :s \Z ' ) ; } return $ this - > set Parameter ( 'start Time ' , $ value ) ; } 
public function set End Time ( $ value ) { if ( $ value instanceof \ Date Time ) { $ value - > set Timezone ( new \ Date Time Zone ( 'UTC ' ) ) ; $ value = $ value - > format ( 'Y -m -d \TH :i :s \Z ' ) ; } return $ this - > set Parameter ( 'end Time ' , $ value ) ; } 
public function get All ( $ type ) { $ all = [ ] ; foreach ( $ this - > issues as $ version = > $ issues ) { if ( isset ( $ issues [ $ type ] ) ) { foreach ( $ issues [ $ type ] as $ issue _name = > $ issue _value ) { if ( is _int ( $ issue _name ) ) { if ( $ type ! = = 'functions _usage ' ) $ all [ $ issue _value ] = array ( $ issue _value , $ version ) ; else $ all [ ] = array ( $ issue _value , $ version ) ; } else $ all [ $ issue _name ] = array ( $ issue _value , $ version ) ; } } } return $ all ; } 
public function run ( ) { try { $ this - > set Target ( ) ; $ this - > set Max Size ( ) ; $ this - > set Exclude List ( ) ; $ this - > set Skip Checks ( ) ; $ this - > set File Extensions ( ) ; $ this - > scan Files ( ) ; $ this - > print Report ( ) ; $ this - > print Memory Usage ( ) ; if ( $ this - > has Issue ) exit ( 1 ) ; } catch ( Exception $ e ) { $ this - > exit With Error ( $ e - > get Message ( ) , 1 2 8 ) ; } } 
public function set Target ( ) { if ( empty ( $ this - > args [ ' - -target ' ] ) ) { $ this - > analyzer - > set Target Php Version ( Php Code Fixer : : get Latest Supported Target Version ( ) ) ; } else { $ this - > analyzer - > set Target Php Version ( $ this - > args [ ' - -target ' ] ) ; } } 
public function set Max Size ( ) { static $ size _units = [ 'kb ' , 'mb ' , 'gb ' ] ; if ( ! empty ( $ this - > args [ ' - -max -size ' ] ) ) { foreach ( $ size _units as $ unit ) { if ( stripos ( $ this - > args [ ' - -max -size ' ] , $ unit ) > 0 ) { $ max _size _value = ( int ) stristr ( $ this - > args [ ' - -max -size ' ] , $ unit , true ) ; $ max _size = $ max _size _value * pow ( 1 0 2 4 , array _search ( $ unit , $ size _units ) + 1 ) ; break ; } } if ( ! isset ( $ max _size ) ) { if ( ( int ) $ this - > args [ ' - -max -size ' ] > 0 ) $ max _size = ( int ) $ this - > args [ ' - -max -size ' ] ; } if ( isset ( $ max _size ) ) { $ this - > analyzer - > set File Size Limit ( $ max _size ) ; $ this - > echo Info Line ( 'Max file size set to : ' . $ this - > format Size ( ' % . 3F Ui ' , $ max _size ) ) ; } } } 
protected function set Exclude List ( ) { if ( ! empty ( $ this - > args [ ' - -exclude ' ] ) ) { $ this - > analyzer - > set Excluded Files List ( $ excluded = array _map ( function ( $ dir ) { return trim ( strtolower ( $ dir ) , ' / \ \ ' ) ; } , explode ( ' , ' , $ this - > args [ ' - -exclude ' ] ) ) ) ; $ this - > echo Info Line ( 'Excluding the following files / directories : ' . implode ( ' , ' , $ excluded ) ) ; } } 
protected function set Skip Checks ( ) { if ( ! empty ( $ this - > args [ ' - -skip -checks ' ] ) ) { $ this - > analyzer - > set Skipped Checks ( $ skipped _checks = array _map ( 'strtolower ' , explode ( ' , ' , $ this - > args [ ' - -skip -checks ' ] ) ) ) ; $ this - > echo Info Line ( 'Skipping checks containing any of the following values : ' . implode ( ' , ' , $ skipped _checks ) ) ; } } 
protected function set File Extensions ( ) { if ( ! empty ( $ this - > args [ ' - -file -extensions ' ] ) ) { $ exts = array _map ( 'strtolower ' , array _map ( 'trim ' , explode ( ' , ' , $ this - > args [ ' - -file -extensions ' ] ) ) ) ; if ( ! empty ( $ exts ) ) { $ this - > analyzer - > set File Extensions ( $ exts ) ; $ this - > echo Info Line ( 'File extensions set to : ' . implode ( ' , ' , $ exts ) ) ; } } } 
protected function scan Files ( ) { $ this - > analyzer - > initialize ( ) ; $ this - > reports = [ ] ; foreach ( $ this - > args [ 'FILES ' ] as $ file ) { if ( is _dir ( $ file ) ) { Terminal Info : : echo With Color ( 'Scanning ' . $ file . ' . . . ' . PHP _EOL , Terminal Info : : GRAY _TEXT ) ; $ this - > reports [ ] = $ this - > analyzer - > check Dir ( rtrim ( realpath ( $ file ) , DIRECTORY _SEPARATOR ) ) ; } else if ( is _file ( $ file ) ) { $ report = new Report ( 'File ' . basename ( $ file ) , dirname ( realpath ( $ file ) ) ) ; $ report = $ this - > analyzer - > check File ( realpath ( $ file ) , $ report ) ; if ( $ report instanceof Report ) { $ this - > reports [ ] = $ report ; } } } } 
protected function print Report ( ) { 
public function normalize And Truncate Path ( $ path , $ max Length ) { $ truncated = 1 ; $ path _parts = explode ( ' / ' , str _replace ( ' \ \ ' , ' / ' , $ path ) ) ; $ total _parts = count ( $ path _parts ) ; while ( strlen ( $ path ) > $ max Length ) { if ( ( $ truncated + 1 ) = = = $ total _parts ) break ; $ part _to _modify = $ total _parts - 1 - $ truncated ; $ chars _to _truncate = min ( strlen ( $ path _parts [ $ part _to _modify ] ) - 1 , strlen ( $ path ) - $ max Length ) ; if ( ( strlen ( $ path ) - $ max Length + 2 ) < strlen ( $ path _parts [ $ part _to _modify ] ) ) $ chars _to _truncate + = 2 ; $ path _parts [ $ part _to _modify ] = substr ( $ path _parts [ $ part _to _modify ] , 0 , - $ chars _to _truncate ) . ' . . ' ; $ path = implode ( ' / ' , $ path _parts ) ; $ truncated + + ; } return $ path ; } 
public function format Size ( $ format , $ bytes , $ unit = null ) { $ units = [ 'B ' , 'KB ' , 'MB ' , 'GB ' , 'TB ' , 'PB ' , 'EB ' , 'ZB ' , 'YB ' ] ; $ bytes = max ( $ bytes , 0 ) ; $ unit = strtoupper ( $ unit ) ; if ( substr ( $ format , - 1 ) = = = 'i ' ) { $ multiplier = 1 0 2 4 ; $ format = substr ( $ format , 0 , - 1 ) ; } else $ multiplier = 1 0 0 0 ; if ( $ unit = = = null | | ! in _array ( $ unit , $ units ) ) { $ pow = floor ( ( $ bytes ? log ( $ bytes ) : 0 ) / log ( $ multiplier ) ) ; $ pow = min ( $ pow , count ( $ units ) - 1 ) ; $ bytes / = pow ( $ multiplier , $ pow ) ; $ unit = $ units [ $ pow ] ; } else { $ pow = array _search ( $ unit , $ units ) ; $ bytes / = pow ( $ multiplier , $ pow ) ; } if ( $ multiplier = = 1 0 2 4 ) $ unit = ( strlen ( $ unit ) = = 2 ) ? substr ( $ unit , 0 , 1 ) . 'i B ' : $ unit ; if ( strpos ( $ format , 'u ' ) ! = = false ) $ format = str _replace ( 'u ' , strtolower ( $ unit ) , $ format ) ; else $ format = str _replace ( 'U ' , $ unit , $ format ) ; return sprintf ( $ format , $ bytes ) ; } 
public function exit With Error ( $ message , $ code = 1 2 8 ) { fwrite ( STDERR , Terminal Info : : colorize ( $ message , Terminal Info : : RED _BACKGROUND ) . PHP _EOL ) ; exit ( $ code ) ; } 
public function initialize ( ) { / / init issues bank $ this - > issues Bank = new Issues Bank ( ) ; foreach ( static : : $ available Versions as $ version ) { $ version _issues = include dirname ( dirname ( _ _FILE _ _ ) ) . ' /data / ' . $ version . ' .php ' ; foreach ( $ version _issues as $ issues _type = > $ issues _list ) { $ this - > issues Bank - > import ( $ version , $ issues _type , $ issues _list ) ; } if ( $ version = = $ this - > target Php Version ) break ; } } 
public static function make Function Call Tree ( array $ tokens ) { $ tree = [ ] ; $ braces _level = 0 ; $ i = 1 ; while ( isset ( $ tokens [ $ i ] ) ) { if ( $ tokens [ $ i ] = = ' ( ' ) $ braces _level + + ; else if ( $ tokens [ $ i ] = = ' ) ' ) $ braces _level - - ; else $ tree [ $ braces _level ] [ ] = $ tokens [ $ i ] ; $ i + + ; } return $ tree ; } 
public static function divide By Comma ( array $ tokens ) { $ delimited = [ ] ; $ comma = 0 ; foreach ( $ tokens as $ token ) { if ( $ token = = ' , ' ) $ comma + + ; else $ delimited [ $ comma ] [ ] = $ token ; } return $ delimited ; } 
public static function trim Spaces ( array $ tokens ) { $ trimmed = [ ] ; foreach ( $ tokens as $ token ) { if ( is _array ( $ token ) ) { if ( $ token [ 0 ] = = T _WHITESPACE ) continue ; else $ trimmed [ ] = self : : trim Spaces ( $ token ) ; } else $ trimmed [ ] = $ token ; } return $ trimmed ; } 
protected static function call Function Usage Checker ( $ checker , $ function Name , array $ call Tokens ) { require _once dirname ( dirname ( _ _FILE _ _ ) ) . ' /data / ' . $ checker . ' .php ' ; $ checker = _ _NAMESPACE _ _ . ' \ \ ' . $ checker ; $ result = $ checker ( $ call Tokens , $ function Name ) ; return $ result ; } 
public function add ( $ version , $ type , $ text , $ replacement , $ file , $ line ) { if ( $ this - > removable Path ! = = null & & strncasecmp ( $ file , $ this - > removable Path , strlen ( $ this - > removable Path ) ) = = = 0 ) $ file = substr ( $ file , strlen ( $ this - > removable Path ) ) ; $ this - > records [ $ version ] [ ] = [ $ type , $ text , $ replacement , $ file , $ line ] ; } 
static public function is Colors Capable ( ) { if ( self : : $ colors Capability = = = null ) { if ( ! static : : is Unix Platform ( ) ) self : : $ colors Capability = false ; else if ( ! static : : is Interactive ( ) ) self : : $ colors Capability = false ; else { $ tput _presence = static : : exec ( 'which tput ' ) ; if ( strlen ( trim ( $ tput _presence [ 0 ] ) ) = = = 0 ) self : : $ colors Capability = false ; else { $ tput _colors = static : : exec ( 'tput colors ' ) ; self : : $ colors Capability = ( int ) $ tput _colors [ 0 ] > 0 ; } } } return self : : $ colors Capability ; } 
static public function echo With Color ( $ text , $ color , $ background Color = null ) { if ( static : : is Colors Capable ( ) ) fwrite ( STDOUT , $ background Color . $ color . $ text . self : : RESET _COLOR ) ; else fwrite ( STDOUT , $ text ) ; } 
static protected function get Windows Terminal Size ( ) { $ output = self : : exec ( 'mode ' , $ return Code ) ; if ( $ return Code ! = = 0 ) return [ 2 5 , 8 0 ] ; foreach ( $ output as $ i = > $ line ) { if ( strpos ( $ line , ' CON ' ) ! = = false ) { $ sizes = [ $ output [ $ i + 2 ] , $ output [ $ i + 3 ] ] ; break ; } } if ( ! isset ( $ sizes ) ) return [ 2 5 , 8 0 ] ; return array _map ( function ( $ val ) { list ( , $ val ) = explode ( ' : ' , $ val ) ; return trim ( $ val ) ; } , $ sizes ) ; } 
public function get Property ( $ name ) { $ better Reflection Property = $ this - > better Reflection Class - > get Property ( $ name ) ; if ( $ better Reflection Property = = = null ) { throw new Core Reflection Exception ( sprintf ( 'Property " %s " does not exist ' , $ name ) ) ; } return new Reflection Property ( $ better Reflection Property ) ; } 
public function get Reflection Constants ( ) { return array _map ( static function ( Better Reflection Class Constant $ better Constant ) : Reflection Class Constant { return new Reflection Class Constant ( $ better Constant ) ; } , $ this - > better Reflection Class - > get Reflection Constants ( ) ) ; } 
public function get Interfaces ( ) { $ interfaces = $ this - > better Reflection Class - > get Interfaces ( ) ; $ wrapped Interfaces = [ ] ; foreach ( $ interfaces as $ key = > $ interface ) { $ wrapped Interfaces [ $ key ] = new self ( $ interface ) ; } return $ wrapped Interfaces ; } 
public function get Traits ( ) { $ traits = $ this - > better Reflection Class - > get Traits ( ) ; $ wrapped Traits = [ ] ; foreach ( $ traits as $ key = > $ trait ) { $ wrapped Traits [ $ key ] = new self ( $ trait ) ; } return $ wrapped Traits ; } 
public function get Parent Class ( ) { $ parent Class = $ this - > better Reflection Class - > get Parent Class ( ) ; if ( $ parent Class = = = null ) { return false ; } return new self ( $ parent Class ) ; } 
public function is Subclass Of ( $ class ) { $ real Parent Class Names = $ this - > better Reflection Class - > get Parent Class Names ( ) ; $ parent Class Names = array _combine ( array _map ( static function ( string $ parent Class Name ) : string { return strtolower ( $ parent Class Name ) ; } , $ real Parent Class Names ) , $ real Parent Class Names ) ; $ real Parent Class Name = $ parent Class Names [ strtolower ( $ class ) ] ? ? $ class ; return $ this - > better Reflection Class - > is Subclass Of ( $ real Parent Class Name ) | | $ this - > implements Interface ( $ class ) ; } 
public function get Static Property Value ( $ name , $ default = null ) { $ better Reflection Property = $ this - > better Reflection Class - > get Property ( $ name ) ; if ( $ better Reflection Property = = = null ) { if ( func _num _args ( ) = = = 2 ) { return $ default ; } throw new Core Reflection Exception ( sprintf ( 'Property " %s " does not exist ' , $ name ) ) ; } $ property = new Reflection Property ( $ better Reflection Property ) ; if ( ! $ property - > is Accessible ( ) ) { throw new Core Reflection Exception ( sprintf ( 'Property " %s " is not accessible ' , $ name ) ) ; } if ( ! $ property - > is Static ( ) ) { throw new Core Reflection Exception ( sprintf ( 'Property " %s " is not static ' , $ name ) ) ; } return $ property - > get Value ( ) ; } 
public function set Static Property Value ( $ name , $ value ) { $ better Reflection Property = $ this - > better Reflection Class - > get Property ( $ name ) ; if ( $ better Reflection Property = = = null ) { throw new Core Reflection Exception ( sprintf ( 'Property " %s " does not exist ' , $ name ) ) ; } $ property = new Reflection Property ( $ better Reflection Property ) ; if ( ! $ property - > is Accessible ( ) ) { throw new Core Reflection Exception ( sprintf ( 'Property " %s " is not accessible ' , $ name ) ) ; } if ( ! $ property - > is Static ( ) ) { throw new Core Reflection Exception ( sprintf ( 'Property " %s " is not static ' , $ name ) ) ; } $ property - > set Value ( $ value ) ; } 
public function implements Interface ( $ interface ) { $ real Interface Names = $ this - > better Reflection Class - > get Interface Names ( ) ; $ interface Names = array _combine ( array _map ( static function ( string $ interface Name ) : string { return strtolower ( $ interface Name ) ; } , $ real Interface Names ) , $ real Interface Names ) ; $ real Interface Name = $ interface Names [ strtolower ( $ interface ) ] ? ? $ interface ; return $ this - > better Reflection Class - > implements Interface ( $ real Interface Name ) ; } 
protected function create Located Source ( Identifier $ identifier ) : ? Located Source { $ potentially Located File = $ this - > attempt Autoload For Identifier ( $ identifier ) ; if ( ! ( $ potentially Located File & & file _exists ( $ potentially Located File ) ) ) { return null ; } return new Located Source ( file _get _contents ( $ potentially Located File ) , $ potentially Located File ) ; } 
private function attempt Autoload For Identifier ( Identifier $ identifier ) : ? string { if ( $ identifier - > is Class ( ) ) { return $ this - > locate Class By Name ( $ identifier - > get Name ( ) ) ; } if ( $ identifier - > is Function ( ) ) { return $ this - > locate Function By Name ( $ identifier - > get Name ( ) ) ; } return null ; } 
private function locate Class By Name ( string $ class Name ) : ? string { if ( class _exists ( $ class Name , false ) | | interface _exists ( $ class Name , false ) | | trait _exists ( $ class Name , false ) ) { $ filename = ( new Reflection Class ( $ class Name ) ) - > get File Name ( ) ; if ( ! is _string ( $ filename ) ) { return null ; } return $ filename ; } self : : $ autoload Located File = null ; self : : $ current Ast Locator = $ this - > ast Locator ; 
private function locate Function By Name ( string $ function Name ) : ? string { if ( ! function _exists ( $ function Name ) ) { return null ; } $ reflection = new Reflection Function ( $ function Name ) ; $ reflection File Name = $ reflection - > get File Name ( ) ; if ( ! is _string ( $ reflection File Name ) ) { return null ; } return $ reflection File Name ; } 
public function stream _open ( $ path , $ mode , $ options , & $ opened _path ) : bool { self : : $ autoload Located File = $ path ; return false ; } 
public function url _stat ( $ path , $ flags ) { stream _wrapper _restore ( 'file ' ) ; if ( $ flags & STREAM _URL _STAT _QUIET ) { set _error _handler ( static function ( ) { 
public function locate Identifier ( Reflector $ reflector , Identifier $ identifier ) : ? Reflection { $ located Source = $ this - > create Located Source ( $ identifier ) ; if ( ! $ located Source ) { return null ; } try { return $ this - > ast Locator - > find Reflection ( $ reflector , $ located Source , $ identifier ) ; } catch ( Identifier Not Found $ exception ) { return null ; } } 
final public function locate Identifiers By Type ( Reflector $ reflector , Identifier Type $ identifier Type ) : array { $ located Source = $ this - > create Located Source ( new Identifier ( Identifier : : WILDCARD , $ identifier Type ) ) ; if ( ! $ located Source ) { return [ ] ; } return $ this - > ast Locator - > find Reflections Of Type ( $ reflector , $ located Source , $ identifier Type ) ; } 
private function compile Const Fetch ( Node \ Expr \ Const Fetch $ const Node , Compiler Context $ context ) { $ first Name = reset ( $ const Node - > name - > parts ) ; switch ( $ first Name ) { case 'null ' : return null ; case 'false ' : return false ; case 'true ' : return true ; default : if ( ! defined ( $ first Name ) ) { throw Exception \ Unable To Compile Node : : because Of Not Found Constant Reference ( $ context , $ const Node ) ; } return constant ( $ first Name ) ; } } 
private function compile Class Const Fetch ( Node \ Expr \ Class Const Fetch $ node , Compiler Context $ context ) { $ node Name = $ node - > name - > name ; $ class Name = $ node - > class - > to String ( ) ; if ( $ node Name = = = 'class ' ) { return $ class Name ; } $ class Info = null ; if ( $ class Name = = = 'self ' | | $ class Name = = = 'static ' ) { $ class Info = $ this - > get Constant Declaring Class ( $ node Name , $ context - > get Self ( ) ) ; } if ( $ class Info = = = null ) { $ class Info = $ context - > get Reflector ( ) - > reflect ( $ class Name ) ; } $ reflection Constant = $ class Info - > get Reflection Constant ( $ node Name ) ; if ( ! $ reflection Constant instanceof Reflection Class Constant ) { throw Exception \ Unable To Compile Node : : because Of Not Found Class Constant Reference ( $ context , $ class Info , $ node ) ; } return $ this - > _ _invoke ( $ reflection Constant - > get Ast ( ) - > consts [ $ reflection Constant - > get Position In Ast ( ) ] - > value , new Compiler Context ( $ context - > get Reflector ( ) , $ class Info ) ) ; } 
private function compile Dir Constant ( Compiler Context $ context ) : string { return File Helper : : normalize Windows Path ( dirname ( realpath ( $ context - > get File Name ( ) ) ) ) ; } 
private function compute Reflections ( string $ filename ) : array { $ single File Source Locator = new Single File Source Locator ( $ filename , $ this - > ast Locator ) ; $ reflector = new Class Reflector ( new Aggregate Source Locator ( [ $ single File Source Locator , $ this - > source Locator ] ) ) ; return array _merge ( $ single File Source Locator - > locate Identifiers By Type ( $ reflector , new Identifier Type ( Identifier Type : : IDENTIFIER _CLASS ) ) , $ single File Source Locator - > locate Identifiers By Type ( $ reflector , new Identifier Type ( Identifier Type : : IDENTIFIER _FUNCTION ) ) ) ; } 
private function contains Line ( $ reflection , int $ line Number ) : bool { if ( ! method _exists ( $ reflection , 'get Start Line ' ) ) { throw new Invalid Argument Exception ( 'Reflection does not have get Start Line method ' ) ; } if ( ! method _exists ( $ reflection , 'get End Line ' ) ) { throw new Invalid Argument Exception ( 'Reflection does not have get End Line method ' ) ; } return $ line Number > = $ reflection - > get Start Line ( ) & & $ line Number < = $ reflection - > get End Line ( ) ; } 
public function reflect ( string $ class Name ) : Reflection { $ identifier = new Identifier ( $ class Name , new Identifier Type ( Identifier Type : : IDENTIFIER _CLASS ) ) ; $ class Info = $ this - > source Locator - > locate Identifier ( $ this , $ identifier ) ; if ( $ class Info = = = null ) { throw Exception \ Identifier Not Found : : from Identifier ( $ identifier ) ; } return $ class Info ; } 
public function get All Classes ( ) : array { $ all Classes = $ this - > source Locator - > locate Identifiers By Type ( $ this , new Identifier Type ( Identifier Type : : IDENTIFIER _CLASS ) ) ; return $ all Classes ; } 
public static function create From Name ( string $ class Name , string $ property Name ) : self { return Reflection Class : : create From Name ( $ class Name ) - > get Property ( $ property Name ) ; } 
public static function create From Instance ( $ instance , string $ property Name ) : self { return Reflection Class : : create From Instance ( $ instance ) - > get Property ( $ property Name ) ; } 
public static function create From Node ( Reflector $ reflector , Property Node $ node , int $ position In Node , ? Namespace _ $ declaring Namespace , Reflection Class $ declaring Class , Reflection Class $ implementing Class , bool $ declared At Compile Time = true ) : self { $ prop = new self ( ) ; $ prop - > reflector = $ reflector ; $ prop - > node = $ node ; $ prop - > position In Node = $ position In Node ; $ prop - > declaring Namespace = $ declaring Namespace ; $ prop - > declaring Class = $ declaring Class ; $ prop - > implementing Class = $ implementing Class ; $ prop - > declared At Compile Time = $ declared At Compile Time ; return $ prop ; } 
public function set Visibility ( int $ new Visibility ) : void { $ this - > node - > flags & = ~ Class _ : : MODIFIER _PRIVATE & ~ Class _ : : MODIFIER _PROTECTED & ~ Class _ : : MODIFIER _PUBLIC ; switch ( $ new Visibility ) { case Core Reflection Property : : IS _PRIVATE : $ this - > node - > flags | = Class _ : : MODIFIER _PRIVATE ; break ; case Core Reflection Property : : IS _PROTECTED : $ this - > node - > flags | = Class _ : : MODIFIER _PROTECTED ; break ; case Core Reflection Property : : IS _PUBLIC : $ this - > node - > flags | = Class _ : : MODIFIER _PUBLIC ; break ; default : throw new Invalid Argument Exception ( 'Visibility should be \Reflection Property : :IS _PRIVATE , : :IS _PROTECTED or : :IS _PUBLIC constants ' ) ; } } 
public function get Modifiers ( ) : int { $ val = 0 ; $ val + = $ this - > is Static ( ) ? Core Reflection Property : : IS _STATIC : 0 ; $ val + = $ this - > is Public ( ) ? Core Reflection Property : : IS _PUBLIC : 0 ; $ val + = $ this - > is Protected ( ) ? Core Reflection Property : : IS _PROTECTED : 0 ; $ val + = $ this - > is Private ( ) ? Core Reflection Property : : IS _PRIVATE : 0 ; return $ val ; } 
public function get Doc Block Type Strings ( ) : array { $ string Types = [ ] ; foreach ( $ this - > get Doc Block Types ( ) as $ type ) { $ string Types [ ] = ( string ) $ type ; } return $ string Types ; } 
public function get Default Value ( ) { $ default Value Node = $ this - > node - > props [ $ this - > position In Node ] - > default ; if ( $ default Value Node = = = null ) { return null ; } return ( new Compile Node To Value ( ) ) - > _ _invoke ( $ default Value Node , new Compiler Context ( $ this - > reflector , $ this - > get Declaring Class ( ) ) ) ; } 
public function get Value ( $ object = null ) { $ declaring Class Name = $ this - > get Declaring Class ( ) - > get Name ( ) ; if ( $ this - > is Static ( ) ) { $ this - > assert Class Exist ( $ declaring Class Name ) ; return Closure : : bind ( function ( string $ declaring Class Name , string $ property Name ) { return $ declaring Class Name : : $ { $ property Name } ; } , null , $ declaring Class Name ) - > _ _invoke ( $ declaring Class Name , $ this - > get Name ( ) ) ; } $ instance = $ this - > assert Object ( $ object ) ; return Closure : : bind ( function ( $ instance , string $ property Name ) { return $ instance - > { $ property Name } ; } , $ instance , $ declaring Class Name ) - > _ _invoke ( $ instance , $ this - > get Name ( ) ) ; } 
public function set Value ( $ object , $ value = null ) : void { $ declaring Class Name = $ this - > get Declaring Class ( ) - > get Name ( ) ; if ( $ this - > is Static ( ) ) { $ this - > assert Class Exist ( $ declaring Class Name ) ; Closure : : bind ( function ( string $ declaring Class Name , string $ property Name , $ value ) : void { $ declaring Class Name : : $ { $ property Name } = $ value ; } , null , $ declaring Class Name ) - > _ _invoke ( $ declaring Class Name , $ this - > get Name ( ) , func _num _args ( ) = = = 2 ? $ value : $ object ) ; return ; } $ instance = $ this - > assert Object ( $ object ) ; Closure : : bind ( function ( $ instance , string $ property Name , $ value ) : void { $ instance - > { $ property Name } = $ value ; } , $ instance , $ declaring Class Name ) - > _ _invoke ( $ instance , $ this - > get Name ( ) , $ value ) ; } 
private function assert Object ( $ object ) { if ( $ object = = = null ) { throw No Object Provided : : create ( ) ; } if ( ! is _object ( $ object ) ) { throw Not An Object : : from Non Object ( $ object ) ; } $ declaring Class Name = $ this - > get Declaring Class ( ) - > get Name ( ) ; if ( get _class ( $ object ) ! = = $ declaring Class Name ) { throw Object Not Instance Of Class : : from Class Name ( $ declaring Class Name ) ; } return $ object ; } 
public function locate Identifiers By Type ( Reflector $ reflector , Identifier Type $ identifier Type ) : array { return array _filter ( [ $ this - > get Reflection Class ( $ reflector , $ identifier Type ) ] ) ; } 
public function resolve Possible File Paths ( Identifier $ identifier ) : array { if ( ! $ identifier - > is Class ( ) ) { return [ ] ; } $ class Name = $ identifier - > get Name ( ) ; foreach ( $ this - > mappings as $ prefix = > $ paths ) { if ( strpos ( $ class Name , $ prefix ) = = = 0 ) { return array _map ( static function ( string $ path ) use ( $ class Name ) : string { return rtrim ( $ path , ' / ' ) . ' / ' . str _replace ( [ ' \ \ ' , ' _ ' ] , ' / ' , $ class Name ) . ' .php ' ; } , $ paths ) ; } } return [ ] ; } 
private static function assert Valid Mapping ( array $ mappings ) : void { foreach ( $ mappings as $ prefix = > $ paths ) { if ( $ prefix = = = ' ' ) { throw Invalid Prefix Mapping : : empty Prefix Given ( ) ; } if ( $ paths = = = [ ] ) { throw Invalid Prefix Mapping : : empty Prefix Mapping Given ( $ prefix ) ; } foreach ( $ paths as $ path ) { if ( ! is _dir ( $ path ) ) { throw Invalid Prefix Mapping : : prefix Mapping Is Not ADirectory ( $ prefix , $ path ) ; } } } } 
public static function create From Node ( Reflector $ reflector , Function Node $ node , Located Source $ located Source , ? Namespace Node $ namespace Node = null ) : self { $ function = new self ( ) ; $ function - > populate Function Abstract ( $ reflector , $ node , $ located Source , $ namespace Node ) ; return $ function ; } 
public function invoke Args ( array $ args = [ ] ) { $ this - > assert Is No Closure ( ) ; $ function Name = $ this - > get Name ( ) ; $ this - > assert Function Exist ( $ function Name ) ; return $ function Name ( . . . $ args ) ; } 
protected function create Located Source ( Identifier $ identifier ) : ? Located Source { if ( $ identifier - > get Type ( ) - > get Name ( ) ! = = Identifier Type : : IDENTIFIER _CLASS ) { return null ; } $ filename = $ this - > class Loader - > find File ( $ identifier - > get Name ( ) ) ; if ( ! $ filename ) { return null ; } return new Located Source ( file _get _contents ( $ filename ) , $ filename ) ; } 
public function find Reflections Of Type ( Reflector $ reflector , Located Source $ located Source , Identifier Type $ identifier Type ) : array { try { return $ this - > find Reflections In Tree - > _ _invoke ( $ reflector , $ this - > parser - > parse ( $ located Source - > get Source ( ) ) , $ identifier Type , $ located Source ) ; } catch ( Throwable $ exception ) { throw Exception \ Parse To Ast Failure : : from Located Source ( $ located Source , $ exception ) ; } } 
private function find In Array ( array $ reflections , Identifier $ identifier ) : Reflection { $ identifier Name = strtolower ( $ identifier - > get Name ( ) ) ; foreach ( $ reflections as $ reflection ) { if ( strtolower ( $ reflection - > get Name ( ) ) = = = $ identifier Name ) { return $ reflection ; } } throw Identifier Not Found : : from Identifier ( $ identifier ) ; } 
protected function create Located Source ( Identifier $ identifier ) : ? Located Source { return new Located Source ( file _get _contents ( $ this - > file Name ) , $ this - > file Name ) ; } 
public function locate Identifier ( Reflector $ reflector , Identifier $ identifier ) : ? Reflection { return $ this - > aggregate Source Locator - > locate Identifier ( $ reflector , $ identifier ) ; } 
public function locate Identifiers By Type ( Reflector $ reflector , Identifier Type $ identifier Type ) : array { return $ this - > aggregate Source Locator - > locate Identifiers By Type ( $ reflector , $ identifier Type ) ; } 
public static function create From Class Name And Method ( string $ class Name , string $ method Name , string $ parameter Name ) : self { return Reflection Class : : create From Name ( $ class Name ) - > get Method ( $ method Name ) - > get Parameter ( $ parameter Name ) ; } 
public static function create From Class Instance And Method ( $ instance , string $ method Name , string $ parameter Name ) : self { return Reflection Class : : create From Instance ( $ instance ) - > get Method ( $ method Name ) - > get Parameter ( $ parameter Name ) ; } 
public static function create From Closure ( Closure $ closure , string $ parameter Name ) : Reflection Parameter { return Reflection Function : : create From Closure ( $ closure ) - > get Parameter ( $ parameter Name ) ; } 
public static function create From Spec ( $ spec , string $ parameter Name ) : self { if ( is _array ( $ spec ) & & count ( $ spec ) = = = 2 & & is _string ( $ spec [ 1 ] ) ) { if ( is _object ( $ spec [ 0 ] ) ) { return self : : create From Class Instance And Method ( $ spec [ 0 ] , $ spec [ 1 ] , $ parameter Name ) ; } return self : : create From Class Name And Method ( $ spec [ 0 ] , $ spec [ 1 ] , $ parameter Name ) ; } if ( is _string ( $ spec ) ) { return Reflection Function : : create From Name ( $ spec ) - > get Parameter ( $ parameter Name ) ; } if ( $ spec instanceof Closure ) { return self : : create From Closure ( $ spec , $ parameter Name ) ; } throw new Invalid Argument Exception ( 'Could not create reflection from the spec given ' ) ; } 
public static function create From Node ( Reflector $ reflector , Param Node $ node , ? Namespace _ $ declaring Namespace , Reflection Function Abstract $ function , int $ parameter Index ) : self { $ param = new self ( ) ; $ param - > reflector = $ reflector ; $ param - > node = $ node ; $ param - > declaring Namespace = $ declaring Namespace ; $ param - > function = $ function ; $ param - > parameter Index = $ parameter Index ; return $ param ; } 
public function allows Null ( ) : bool { if ( ! $ this - > has Type ( ) ) { return true ; } if ( $ this - > node - > type instanceof Nullable Type ) { return true ; } if ( ! $ this - > is Default Value Available ( ) ) { return false ; } return $ this - > get Default Value ( ) = = = null ; } 
public function get Type ( ) : ? Reflection Type { $ type = $ this - > node - > type ; if ( $ type = = = null ) { return null ; } if ( $ type instanceof Nullable Type ) { $ type = $ type - > type ; } return Reflection Type : : create From Type And Reflector ( ( string ) $ type , $ this - > allows Null ( ) , $ this - > reflector ) ; } 
public function set Type ( string $ new Parameter Type ) : void { $ this - > node - > type = new Node \ Name ( $ new Parameter Type ) ; } 
public function get Class ( ) : ? Reflection Class { $ class Name = $ this - > get Class Name ( ) ; if ( $ class Name = = = null ) { return null ; } if ( ! $ this - > reflector instanceof Class Reflector ) { throw new Runtime Exception ( sprintf ( 'Unable to reflect class type because we were not given a " %s " , but a " %s " instead ' , Class Reflector : : class , get _class ( $ this - > reflector ) ) ) ; } return $ this - > reflector - > reflect ( $ class Name ) ; } 
public function invoke ( $ args = null ) { try { return $ this - > better Reflection Function - > invoke ( . . . func _get _args ( ) ) ; } catch ( Throwable $ e ) { throw new Core Reflection Exception ( $ e - > get Message ( ) , 0 , $ e ) ; } } 
public function invoke Args ( array $ args ) { try { return $ this - > better Reflection Function - > invoke Args ( $ args ) ; } catch ( Throwable $ e ) { throw new Core Reflection Exception ( $ e - > get Message ( ) , 0 , $ e ) ; } } 
public function is Builtin ( ) : bool { $ type = ( string ) $ this - > better Reflection Type ; if ( $ type = = = 'self ' | | $ type = = = 'parent ' ) { return false ; } return $ this - > better Reflection Type - > is Builtin ( ) ; } 
protected function create Located Source ( Identifier $ identifier ) : ? Located Source { return $ this - > get Class Source ( $ identifier ) ? ? $ this - > get Function Source ( $ identifier ) ; } 
public function get Parameters ( ) { $ parameters = $ this - > better Reflection Method - > get Parameters ( ) ; $ wrapped Parameters = [ ] ; foreach ( $ parameters as $ key = > $ parameter ) { $ wrapped Parameters [ $ key ] = new Reflection Parameter ( $ parameter ) ; } return $ wrapped Parameters ; } 
public function get Closure ( $ object = null ) { try { return $ this - > better Reflection Method - > get Closure ( $ object ) ; } catch ( No Object Provided | Not An Object $ e ) { return null ; } catch ( Throwable $ e ) { throw new Core Reflection Exception ( $ e - > get Message ( ) , 0 , $ e ) ; } } 
public function invoke ( $ object = null , $ args = null ) { if ( ! $ this - > is Accessible ( ) ) { throw new Core Reflection Exception ( 'Method not accessible ' ) ; } try { return $ this - > better Reflection Method - > invoke ( . . . func _get _args ( ) ) ; } catch ( No Object Provided | Not An Object $ e ) { return null ; } catch ( Throwable $ e ) { throw new Core Reflection Exception ( $ e - > get Message ( ) , 0 , $ e ) ; } } 
public function invoke Args ( $ object = null , array $ args = [ ] ) { if ( ! $ this - > is Accessible ( ) ) { throw new Core Reflection Exception ( 'Method not accessible ' ) ; } try { return $ this - > better Reflection Method - > invoke Args ( $ object , $ args ) ; } catch ( No Object Provided | Not An Object $ e ) { return null ; } catch ( Throwable $ e ) { throw new Core Reflection Exception ( $ e - > get Message ( ) , 0 , $ e ) ; } } 
public function resolve Possible File Paths ( Identifier $ identifier ) : array { if ( ! $ identifier - > is Class ( ) ) { return [ ] ; } $ class Name = $ identifier - > get Name ( ) ; $ matching Prefixes = $ this - > matching Prefixes ( $ class Name ) ; return array _values ( array _filter ( array _merge ( [ ] , . . . array _map ( static function ( array $ paths , string $ prefix ) use ( $ class Name ) : array { $ sub Path = ltrim ( str _replace ( ' \ \ ' , ' / ' , substr ( $ class Name , strlen ( $ prefix ) ) ) , ' / ' ) ; if ( $ sub Path = = = ' ' ) { return [ ] ; } return array _map ( static function ( string $ path ) use ( $ sub Path ) : string { return rtrim ( $ path , ' / ' ) . ' / ' . $ sub Path . ' .php ' ; } , $ paths ) ; } , $ matching Prefixes , array _keys ( $ matching Prefixes ) ) ) ) ) ; } 
protected function create Located Source ( Identifier $ identifier ) : ? Located Source { $ class Reflection = $ this - > get Internal Reflection Class ( $ identifier ) ; if ( $ class Reflection = = = null ) { return null ; } $ stub = $ this - > stubber - > generate Class Stub ( $ class Reflection ) ; if ( $ stub = = = null ) { return null ; } return new Evaled Located Source ( $ stub ) ; } 
public function reflect ( string $ function Name ) : Reflection { $ identifier = new Identifier ( $ function Name , new Identifier Type ( Identifier Type : : IDENTIFIER _FUNCTION ) ) ; $ function Info = $ this - > source Locator - > locate Identifier ( $ this - > class Reflector , $ identifier ) ; if ( $ function Info = = = null ) { throw Exception \ Identifier Not Found : : from Identifier ( $ identifier ) ; } return $ function Info ; } 
public function get All Functions ( ) : array { $ all Functions = $ this - > source Locator - > locate Identifiers By Type ( $ this , new Identifier Type ( Identifier Type : : IDENTIFIER _FUNCTION ) ) ; return $ all Functions ; } 
public function locate Identifier ( Reflector $ reflector , Identifier $ identifier ) : ? Reflection { return $ this - > get Aggregated Source Locator ( ) - > locate Identifier ( $ reflector , $ identifier ) ; } 
public function locate Identifiers By Type ( Reflector $ reflector , Identifier Type $ identifier Type ) : array { return $ this - > get Aggregated Source Locator ( ) - > locate Identifiers By Type ( $ reflector , $ identifier Type ) ; } 
public static function create From Node ( Reflector $ reflector , Method Node $ node , ? Namespace _ $ namespace , Reflection Class $ declaring Class , Reflection Class $ implementing Class ) : self { $ method = new self ( ) ; $ method - > declaring Class = $ declaring Class ; $ method - > implementing Class = $ implementing Class ; $ method - > method Node = $ node ; $ method - > populate Function Abstract ( $ reflector , $ node , $ declaring Class - > get Located Source ( ) , $ namespace ) ; return $ method ; } 
public static function create From Name ( string $ class Name , string $ method Name ) : self { return Reflection Class : : create From Name ( $ class Name ) - > get Method ( $ method Name ) ; } 
public static function create From Instance ( $ instance , string $ method Name ) : self { return Reflection Class : : create From Instance ( $ instance ) - > get Method ( $ method Name ) ; } 
public function get Prototype ( ) : self { $ current Class = $ this - > get Declaring Class ( ) ; while ( $ current Class ) { foreach ( $ current Class - > get Immediate Interfaces ( ) as $ interface ) { if ( $ interface - > has Method ( $ this - > get Name ( ) ) ) { return $ interface - > get Method ( $ this - > get Name ( ) ) ; } } $ current Class = $ current Class - > get Parent Class ( ) ; if ( $ current Class = = = null | | ! $ current Class - > has Method ( $ this - > get Name ( ) ) ) { break ; } $ prototype = $ current Class - > get Method ( $ this - > get Name ( ) ) - > find Prototype ( ) ; if ( $ prototype ! = = null ) { return $ prototype ; } } throw new Exception \ Method Prototype Not Found ( sprintf ( 'Method %s : : %s does not have a prototype ' , $ this - > get Declaring Class ( ) - > get Name ( ) , $ this - > get Name ( ) ) ) ; } 
public function get Modifiers ( ) : int { $ val = 0 ; $ val + = $ this - > is Static ( ) ? Core Reflection Method : : IS _STATIC : 0 ; $ val + = $ this - > is Public ( ) ? Core Reflection Method : : IS _PUBLIC : 0 ; $ val + = $ this - > is Protected ( ) ? Core Reflection Method : : IS _PROTECTED : 0 ; $ val + = $ this - > is Private ( ) ? Core Reflection Method : : IS _PRIVATE : 0 ; $ val + = $ this - > is Abstract ( ) ? Core Reflection Method : : IS _ABSTRACT : 0 ; $ val + = $ this - > is Final ( ) ? Core Reflection Method : : IS _FINAL : 0 ; return $ val ; } 
public function is Constructor ( ) : bool { if ( strtolower ( $ this - > get Name ( ) ) = = = ' _ _construct ' ) { return true ; } $ declaring Class = $ this - > get Declaring Class ( ) ; if ( $ declaring Class - > in Namespace ( ) ) { return false ; } return strtolower ( $ this - > get Name ( ) ) = = = strtolower ( $ declaring Class - > get Short Name ( ) ) ; } 
public function get Closure ( $ object = null ) : Closure { $ declaring Class Name = $ this - > get Declaring Class ( ) - > get Name ( ) ; if ( $ this - > is Static ( ) ) { $ this - > assert Class Exist ( $ declaring Class Name ) ; return function ( . . . $ args ) { return $ this - > call Static Method ( $ args ) ; } ; } $ instance = $ this - > assert Object ( $ object ) ; return function ( . . . $ args ) use ( $ instance ) { return $ this - > call Object Method ( $ instance , $ args ) ; } ; } 
public function invoke Args ( $ object = null , array $ args = [ ] ) { $ declaring Class Name = $ this - > get Declaring Class ( ) - > get Name ( ) ; if ( $ this - > is Static ( ) ) { $ this - > assert Class Exist ( $ declaring Class Name ) ; return $ this - > call Static Method ( $ args ) ; } return $ this - > call Object Method ( $ this - > assert Object ( $ object ) , $ args ) ; } 
private function call Static Method ( array $ args ) { $ declaring Class Name = $ this - > get Declaring Class ( ) - > get Name ( ) ; return Closure : : bind ( function ( string $ declaring Class Name , string $ method Name , array $ method Args ) { return $ declaring Class Name : : { $ method Name } ( . . . $ method Args ) ; } , null , $ declaring Class Name ) - > _ _invoke ( $ declaring Class Name , $ this - > get Name ( ) , $ args ) ; } 
private function call Object Method ( $ object , array $ args ) { return Closure : : bind ( function ( $ object , string $ method Name , array $ method Args ) { return $ object - > { $ method Name } ( . . . $ method Args ) ; } , $ object , $ this - > get Declaring Class ( ) - > get Name ( ) ) - > _ _invoke ( $ object , $ this - > get Name ( ) , $ args ) ; } 
public function get Declaring Class ( ) { $ declaring Class = $ this - > better Reflection Parameter - > get Declaring Class ( ) ; if ( $ declaring Class = = = null ) { return null ; } return new Reflection Class ( $ declaring Class ) ; } 
private function prefix With Package Path ( array $ paths , string $ trimmed Installation Path , array $ package ) : array { $ prefix = $ this - > package Prefix Path ( $ trimmed Installation Path , $ package ) ; return array _map ( function ( array $ paths ) use ( $ prefix ) : array { return $ this - > prefix Paths ( $ paths , $ prefix ) ; } , $ paths ) ; } 
private function prefix Paths ( array $ paths , string $ prefix ) : array { return array _map ( static function ( string $ path ) use ( $ prefix ) { return $ prefix . $ path ; } , $ paths ) ; } 
public static function export ( ? string $ class Name ) : string { if ( $ class Name = = = null ) { throw new Invalid Argument Exception ( 'Class name must be provided ' ) ; } return self : : create From Name ( $ class Name ) - > _ _to String ( ) ; } 
public static function create From Node ( Reflector $ reflector , Class Like Node $ node , Located Source $ located Source , ? Namespace Node $ namespace = null ) : self { $ class = new self ( ) ; $ class - > reflector = $ reflector ; $ class - > located Source = $ located Source ; $ class - > node = $ node ; if ( $ namespace ! = = null ) { $ class - > declaring Namespace = $ namespace ; } return $ class ; } 
public function get Short Name ( ) : string { if ( ! $ this - > is Anonymous ( ) ) { return $ this - > node - > name - > name ; } $ file Name = $ this - > get File Name ( ) ; if ( $ file Name = = = null ) { $ file Name = sha 1 ( $ this - > located Source - > get Source ( ) ) ; } return sprintf ( ' %s %c %s ( %d ) ' , self : : ANONYMOUS _CLASS _NAME _PREFIX , " \ 0 " , $ file Name , $ this - > get Start Line ( ) ) ; } 
public function get Name ( ) : string { if ( ! $ this - > in Namespace ( ) ) { return $ this - > get Short Name ( ) ; } return $ this - > node - > namespaced Name - > to String ( ) ; } 
private function get All Methods ( ) : array { return array _merge ( [ ] , array _map ( function ( Class Method $ method Node ) : Reflection Method { return Reflection Method : : create From Node ( $ this - > reflector , $ method Node , $ this - > declaring Namespace , $ this , $ this ) ; } , $ this - > node - > get Methods ( ) ) , . . . array _map ( function ( Reflection Class $ trait ) : array { return array _map ( function ( Reflection Method $ method ) use ( $ trait ) : Reflection Method { $ method Ast = $ method - > get Ast ( ) ; return Reflection Method : : create From Node ( $ this - > reflector , $ method Ast , $ this - > declaring Namespace , $ trait , $ this ) ; } , $ trait - > get Methods ( ) ) ; } , $ this - > get Traits ( ) ) , . . . array _map ( static function ( Reflection Class $ ancestor ) : array { return $ ancestor - > get Methods ( ) ; } , array _values ( array _merge ( array _filter ( [ $ this - > get Parent Class ( ) ] ) , $ this - > get Interfaces ( ) ) ) ) ) ; } 
private function get Methods Indexed By Name ( ) : array { if ( $ this - > cached Methods ! = = null ) { return $ this - > cached Methods ; } $ this - > cached Methods = [ ] ; $ trait Aliases = $ this - > get Trait Aliases ( ) ; foreach ( $ this - > get All Methods ( ) as $ method ) { $ method Name = $ method - > get Name ( ) ; $ method Name With Class Name = sprintf ( ' %s : : %s ' , $ method - > get Declaring Class ( ) - > get Name ( ) , $ method Name ) ; foreach ( $ trait Aliases as $ method Alias = > $ trait Method Name With Trait Name ) { if ( $ method Name With Class Name ! = = $ trait Method Name With Trait Name ) { continue ; } if ( isset ( $ this - > cached Methods [ $ method Alias ] ) ) { continue ; } $ this - > cached Methods [ $ method Alias ] = $ method ; } if ( isset ( $ this - > cached Methods [ $ method Name ] ) ) { continue ; } $ this - > cached Methods [ $ method Name ] = $ method ; } return $ this - > cached Methods ; } 
public function get Methods ( ? int $ filter = null ) : array { if ( $ filter = = = null ) { return array _values ( $ this - > get Methods Indexed By Name ( ) ) ; } return array _values ( array _filter ( $ this - > get Methods Indexed By Name ( ) , static function ( Reflection Method $ method ) use ( $ filter ) : bool { return ( bool ) ( $ filter & $ method - > get Modifiers ( ) ) ; } ) ) ; } 
public function get Immediate Methods ( ? int $ filter = null ) : array { $ methods = array _map ( function ( Class Method $ method Node ) : Reflection Method { return Reflection Method : : create From Node ( $ this - > reflector , $ method Node , $ this - > declaring Namespace , $ this , $ this ) ; } , $ this - > node - > get Methods ( ) ) ; $ methods By Name = [ ] ; foreach ( $ methods as $ method ) { if ( $ filter ! = = null & & ! ( $ filter & $ method - > get Modifiers ( ) ) ) { continue ; } $ methods By Name [ $ method - > get Name ( ) ] = $ method ; } return $ methods By Name ; } 
public function get Method ( string $ method Name ) : Reflection Method { $ methods = $ this - > get Methods Indexed By Name ( ) ; if ( ! isset ( $ methods [ $ method Name ] ) ) { throw new Out Of Bounds Exception ( 'Could not find method : ' . $ method Name ) ; } return $ methods [ $ method Name ] ; } 
public function has Method ( string $ method Name ) : bool { try { $ this - > get Method ( $ method Name ) ; return true ; } catch ( Out Of Bounds Exception $ exception ) { return false ; } } 
public function get Constant ( string $ name ) { $ reflection Constant = $ this - > get Reflection Constant ( $ name ) ; if ( ! $ reflection Constant ) { return null ; } return $ reflection Constant - > get Value ( ) ; } 
public function get Immediate Reflection Constants ( ) : array { if ( $ this - > cached Reflection Constants ! = = null ) { return $ this - > cached Reflection Constants ; } $ constants = array _merge ( [ ] , . . . array _map ( function ( Const Node $ const Node ) : array { $ constants = [ ] ; foreach ( $ const Node - > consts as $ constant Position In Node = > $ constant Node ) { $ constants [ ] = Reflection Class Constant : : create From Node ( $ this - > reflector , $ const Node , $ constant Position In Node , $ this ) ; } return $ constants ; } , array _filter ( $ this - > node - > stmts , static function ( Node \ Stmt $ stmt ) : bool { return $ stmt instanceof Const Node ; } ) ) ) ; return $ this - > cached Reflection Constants = array _combine ( array _map ( static function ( Reflection Class Constant $ constant ) : string { return $ constant - > get Name ( ) ; } , $ constants ) , $ constants ) ; } 
public function get Reflection Constants ( ) : array { 
public function get Constructor ( ) : Reflection Method { $ constructors = array _filter ( $ this - > get Methods ( ) , static function ( Reflection Method $ method ) : bool { return $ method - > is Constructor ( ) ; } ) ; if ( ! isset ( $ constructors [ 0 ] ) ) { throw new Out Of Bounds Exception ( 'Could not find method : _ _construct ' ) ; } return $ constructors [ 0 ] ; } 
public function get Immediate Properties ( ? int $ filter = null ) : array { if ( $ this - > cached Immediate Properties = = = null ) { $ properties = [ ] ; foreach ( $ this - > node - > stmts as $ stmt ) { if ( ! ( $ stmt instanceof Property Node ) ) { continue ; } foreach ( $ stmt - > props as $ property Position In Node = > $ property Node ) { $ prop = Reflection Property : : create From Node ( $ this - > reflector , $ stmt , $ property Position In Node , $ this - > declaring Namespace , $ this , $ this ) ; $ properties [ $ prop - > get Name ( ) ] = $ prop ; } } $ this - > cached Immediate Properties = $ properties ; } if ( $ filter = = = null ) { return $ this - > cached Immediate Properties ; } return array _filter ( $ this - > cached Immediate Properties , static function ( Reflection Property $ property ) use ( $ filter ) : bool { return ( bool ) ( $ filter & $ property - > get Modifiers ( ) ) ; } ) ; } 
public function get Properties ( ? int $ filter = null ) : array { if ( $ this - > cached Properties = = = null ) { 
public function get Property ( string $ name ) : ? Reflection Property { $ properties = $ this - > get Properties ( ) ; if ( ! isset ( $ properties [ $ name ] ) ) { return null ; } return $ properties [ $ name ] ; } 
public function get Parent Class ( ) : ? Reflection Class { if ( ! ( $ this - > node instanceof Class Node ) | | $ this - > node - > extends = = = null ) { return null ; } 
public function get Parent Class Names ( ) : array { return array _map ( static function ( self $ parent Class ) : string { return $ parent Class - > get Name ( ) ; } , array _slice ( array _reverse ( $ this - > get Inheritance Class Hierarchy ( ) ) , 1 ) ) ; } 
public function get Modifiers ( ) : int { $ val = 0 ; $ val + = $ this - > is Abstract ( ) ? Core Reflection Class : : IS _EXPLICIT _ABSTRACT : 0 ; $ val + = $ this - > is Final ( ) ? Core Reflection Class : : IS _FINAL : 0 ; return $ val ; } 
public function get Traits ( ) : array { return array _map ( function ( Node \ Name $ imported Trait ) : Reflection Class { return $ this - > reflect Class For Named Node ( $ imported Trait ) ; } , array _merge ( [ ] , . . . array _map ( static function ( Trait Use $ trait Use ) : array { return $ trait Use - > traits ; } , array _filter ( $ this - > node - > stmts , static function ( Node $ node ) : bool { return $ node instanceof Trait Use ; } ) ) ) ) ; } 
private function reflect Class For Named Node ( Node \ Name $ node ) : self { 
public function get Trait Aliases ( ) : array { $ trait Usages = array _filter ( $ this - > node - > stmts , static function ( Node $ node ) : bool { return $ node instanceof Trait Use ; } ) ; $ resolved Aliases = [ ] ; foreach ( $ trait Usages as $ trait Usage ) { $ trait Names = $ trait Usage - > traits ; $ adaptations = $ trait Usage - > adaptations ; foreach ( $ adaptations as $ adaptation ) { $ used Trait = $ adaptation - > trait ; if ( $ used Trait = = = null ) { $ used Trait = $ trait Names [ 0 ] ; } if ( ! ( $ adaptation instanceof Node \ Stmt \ Trait Use Adaptation \ Alias ) ) { continue ; } if ( ! $ adaptation - > new Name ) { continue ; } $ resolved Aliases [ $ adaptation - > new Name - > name ] = sprintf ( ' %s : : %s ' , $ used Trait - > to String ( ) , $ adaptation - > method - > to String ( ) ) ; } } return $ resolved Aliases ; } 
public function is Instance ( $ object ) : bool { if ( ! is _object ( $ object ) ) { throw Not An Object : : from Non Object ( $ object ) ; } $ class Name = $ this - > get Name ( ) ; 
public function is Subclass Of ( string $ class Name ) : bool { return in _array ( ltrim ( $ class Name , ' \ \ ' ) , array _map ( static function ( self $ reflection Class ) : string { return $ reflection Class - > get Name ( ) ; } , array _slice ( array _reverse ( $ this - > get Inheritance Class Hierarchy ( ) ) , 1 ) ) , true ) ; } 
public function implements Interface ( string $ interface Name ) : bool { return in _array ( ltrim ( $ interface Name , ' \ \ ' ) , $ this - > get Interface Names ( ) , true ) ; } 
public function is Instantiable ( ) : bool { 
public function is Cloneable ( ) : bool { if ( ! $ this - > is Instantiable ( ) ) { return false ; } if ( ! $ this - > has Method ( ' _ _clone ' ) ) { return true ; } return $ this - > get Method ( ' _ _clone ' ) - > is Public ( ) ; } 
private function get Interfaces Hierarchy ( ) : array { if ( ! $ this - > is Interface ( ) ) { throw Not An Interface Reflection : : from Reflection Class ( $ this ) ; } $ node = $ this - > node ; return array _merge ( [ $ this - > get Name ( ) = > $ this ] , . . . array _map ( function ( Node \ Name $ interface Name ) : array { return $ this - > reflect Class For Named Node ( $ interface Name ) - > get Interfaces Hierarchy ( ) ; } , $ node - > extends ) ) ; } 
public function get Static Property Value ( string $ property Name ) { $ property = $ this - > get Property ( $ property Name ) ; if ( ! $ property | | ! $ property - > is Static ( ) ) { throw Property Does Not Exist : : from Name ( $ property Name ) ; } return $ property - > get Value ( ) ; } 
public function set Static Property Value ( string $ property Name , $ value ) : void { $ property = $ this - > get Property ( $ property Name ) ; if ( ! $ property | | ! $ property - > is Static ( ) ) { throw Property Does Not Exist : : from Name ( $ property Name ) ; } $ property - > set Value ( $ value ) ; } 
public function set Final ( bool $ is Final ) : void { if ( ! $ this - > node instanceof Class Node ) { throw Not AClass Reflection : : from Reflection Class ( $ this ) ; } if ( $ is Final = = = true ) { $ this - > node - > flags | = Class Node : : MODIFIER _FINAL ; return ; } $ this - > node - > flags & = ~ Class Node : : MODIFIER _FINAL ; } 
public function remove Method ( string $ method Name ) : bool { $ lower Name = strtolower ( $ method Name ) ; foreach ( $ this - > node - > stmts as $ key = > $ stmt ) { if ( $ stmt instanceof Class Method & & $ lower Name = = = $ stmt - > name - > to Lower String ( ) ) { unset ( $ this - > node - > stmts [ $ key ] , $ this - > cached Methods ) ; return true ; } } return false ; } 
public function add Method ( string $ method Name ) : void { $ this - > node - > stmts [ ] = new Class Method ( $ method Name ) ; unset ( $ this - > cached Methods ) ; } 
public function add Property ( string $ property Name , int $ visibility = Core Reflection Property : : IS _PUBLIC , bool $ static = false ) : void { $ type = 0 ; switch ( $ visibility ) { case Core Reflection Property : : IS _PRIVATE : $ type | = Class Node : : MODIFIER _PRIVATE ; break ; case Core Reflection Property : : IS _PROTECTED : $ type | = Class Node : : MODIFIER _PROTECTED ; break ; default : $ type | = Class Node : : MODIFIER _PUBLIC ; break ; } if ( $ static ) { $ type | = Class Node : : MODIFIER _STATIC ; } $ this - > node - > stmts [ ] = new Property Node ( $ type , [ new Node \ Stmt \ Property Property ( $ property Name ) ] ) ; $ this - > cached Properties = null ; $ this - > cached Immediate Properties = null ; } 
public function remove Property ( string $ property Name ) : bool { $ lower Name = strtolower ( $ property Name ) ; foreach ( $ this - > node - > stmts as $ key = > $ stmt ) { if ( ! ( $ stmt instanceof Property Node ) ) { continue ; } $ property Names = array _map ( static function ( Node \ Stmt \ Property Property $ property Property ) : string { return $ property Property - > name - > to Lower String ( ) ; } , $ stmt - > props ) ; if ( in _array ( $ lower Name , $ property Names , true ) ) { $ this - > cached Properties = null ; $ this - > cached Immediate Properties = null ; unset ( $ this - > node - > stmts [ $ key ] ) ; return true ; } } return false ; } 
public function is Matching Reflector ( Reflection $ reflector ) : bool { if ( $ this - > name = = = self : : IDENTIFIER _CLASS ) { return $ reflector instanceof Reflection Class ; } if ( $ this - > name = = = self : : IDENTIFIER _FUNCTION ) { return $ reflector instanceof Reflection Function ; } return false ; } 
public function parse ( string $ code , ? Error Handler $ error Handler = null ) : ? array { 
public function locate Identifier ( Reflector $ reflector , Identifier $ identifier ) : ? Reflection { foreach ( $ this - > source Locators as $ source Locator ) { $ located = $ source Locator - > locate Identifier ( $ reflector , $ identifier ) ; if ( $ located ) { return $ located ; } } return null ; } 
public function locate Identifiers By Type ( Reflector $ reflector , Identifier Type $ identifier Type ) : array { return array _merge ( [ ] , . . . array _map ( static function ( Source Locator $ source Locator ) use ( $ reflector , $ identifier Type ) { return $ source Locator - > locate Identifiers By Type ( $ reflector , $ identifier Type ) ; } , $ this - > source Locators ) ) ; } 
public function generate Class Stub ( Core Reflection Class $ class Reflection ) : ? string { if ( $ class Reflection - > is User Defined ( ) ) { return null ; } $ stub = $ this - > get Stub ( $ class Reflection - > get Extension Name ( ) , $ this - > get Class Node Visitor ( $ class Reflection ) ) ; if ( $ class Reflection - > get Name ( ) = = = Traversable : : class ) { 
public function generate Function Stub ( Core Reflection Function $ function Reflection ) : ? string { if ( $ function Reflection - > is User Defined ( ) ) { return null ; } return $ this - > get Stub ( $ function Reflection - > get Extension Name ( ) , $ this - > get Function Node Visitor ( $ function Reflection ) ) ; } 
public static function export ( $ instance = null ) : string { if ( $ instance = = = null ) { throw new Invalid Argument Exception ( 'Class instance must be provided ' ) ; } return self : : create From Instance ( $ instance ) - > _ _to String ( ) ; } 
public static function create From Instance ( $ object ) : Reflection Class { if ( ! is _object ( $ object ) ) { throw new Invalid Argument Exception ( 'Can only create from an instance of an object ' ) ; } $ class Name = get _class ( $ object ) ; if ( strpos ( $ class Name , Reflection Class : : ANONYMOUS _CLASS _NAME _PREFIX ) = = = 0 ) { $ reflector = new Class Reflector ( new Anonymous Class Object Source Locator ( $ object , ( new Better Reflection ( ) ) - > php Parser ( ) ) ) ; } else { $ reflector = ( new Better Reflection ( ) ) - > class Reflector ( ) ; } return new self ( $ reflector , $ reflector - > reflect ( $ class Name ) , $ object ) ; } 
private function get Runtime Properties ( ? int $ filter = null ) : array { if ( ! $ this - > reflection Class - > is Instance ( $ this - > object ) ) { throw new Invalid Argument Exception ( 'Cannot reflect runtime properties of a separate class ' ) ; } 
private function create Property Node From Reflection ( Core Reflection Property $ property , $ instance ) : Property Node { $ builder = new Property Node Builder ( $ property - > get Name ( ) ) ; $ builder - > set Default ( $ property - > get Value ( $ instance ) ) ; if ( $ property - > is Public ( ) ) { $ builder - > make Public ( ) ; } return $ builder - > get Node ( ) ; } 
public function get Properties ( ? int $ filter = null ) : array { return array _merge ( $ this - > reflection Class - > get Properties ( $ filter ) , $ this - > get Runtime Properties ( $ filter ) ) ; } 
public function get Immediate Properties ( ? int $ filter = null ) : array { return array _merge ( $ this - > reflection Class - > get Immediate Properties ( $ filter ) , $ this - > get Runtime Properties ( $ filter ) ) ; } 
public function get Property ( string $ name ) : ? Reflection Property { $ runtime Properties = $ this - > get Runtime Properties ( ) ; if ( isset ( $ runtime Properties [ $ name ] ) ) { return $ runtime Properties [ $ name ] ; } return $ this - > reflection Class - > get Property ( $ name ) ; } 
public function has Property ( string $ name ) : bool { $ runtime Properties = $ this - > get Runtime Properties ( ) ; return isset ( $ runtime Properties [ $ name ] ) | | $ this - > reflection Class - > has Property ( $ name ) ; } 
public function set Static Property Value ( string $ property Name , $ value ) : void { $ this - > reflection Class - > set Static Property Value ( $ property Name , $ value ) ; } 
public function add Property ( string $ method Name , int $ visibility = Core Reflection Property : : IS _PUBLIC , bool $ static = false ) : void { $ this - > reflection Class - > add Property ( $ method Name , $ visibility , $ static ) ; } 
public function get Methods ( $ filter = null ) { $ methods = $ this - > better Reflection Object - > get Methods ( ) ; $ wrapped Methods = [ ] ; foreach ( $ methods as $ key = > $ method ) { $ wrapped Methods [ $ key ] = new Reflection Method ( $ method ) ; } return $ wrapped Methods ; } 
public function get Property ( $ name ) { $ property = $ this - > better Reflection Object - > get Property ( $ name ) ; if ( $ property = = = null ) { throw new Core Reflection Exception ( sprintf ( 'Property " %s " does not exist ' , $ name ) ) ; } return new Reflection Property ( $ property ) ; } 
public function get Properties ( $ filter = null ) { $ properties = $ this - > better Reflection Object - > get Properties ( ) ; $ wrapped Properties = [ ] ; foreach ( $ properties as $ key = > $ property ) { $ wrapped Properties [ $ key ] = new Reflection Property ( $ property ) ; } return $ wrapped Properties ; } 
public function get Interfaces ( ) { $ interfaces = $ this - > better Reflection Object - > get Interfaces ( ) ; $ wrapped Interfaces = [ ] ; foreach ( $ interfaces as $ key = > $ interface ) { $ wrapped Interfaces [ $ key ] = new Reflection Class ( $ interface ) ; } return $ wrapped Interfaces ; } 
public function get Traits ( ) { $ traits = $ this - > better Reflection Object - > get Traits ( ) ; $ wrapped Traits = [ ] ; foreach ( $ traits as $ key = > $ trait ) { $ wrapped Traits [ $ key ] = new Reflection Class ( $ trait ) ; } return $ wrapped Traits ; } 
public function get Parent Class ( ) { $ parent Class = $ this - > better Reflection Object - > get Parent Class ( ) ; if ( $ parent Class = = = null ) { return false ; } return new Reflection Class ( $ parent Class ) ; } 
public function is Subclass Of ( $ class ) { $ real Parent Class Names = $ this - > better Reflection Object - > get Parent Class Names ( ) ; $ parent Class Names = array _combine ( array _map ( static function ( string $ parent Class Name ) : string { return strtolower ( $ parent Class Name ) ; } , $ real Parent Class Names ) , $ real Parent Class Names ) ; $ real Parent Class Name = $ parent Class Names [ strtolower ( $ class ) ] ? ? $ class ; return $ this - > better Reflection Object - > is Subclass Of ( $ real Parent Class Name ) ; } 
protected function populate Function Abstract ( Reflector $ reflector , Node \ Function Like $ node , Located Source $ located Source , ? Namespace Node $ declaring Namespace = null ) : void { $ this - > reflector = $ reflector ; $ this - > node = $ node ; $ this - > located Source = $ located Source ; $ this - > declaring Namespace = $ declaring Namespace ; $ this - > set Node Optional Flag ( ) ; } 
private function set Node Optional Flag ( ) : void { $ overall Optional Flag = true ; $ last Param Index = count ( $ this - > node - > params ) - 1 ; for ( $ i = $ last Param Index ; $ i > = 0 ; $ i - - ) { $ has Default = ( $ this - > node - > params [ $ i ] - > default ! = = null ) ; 
public function get Name ( ) : string { if ( ! $ this - > in Namespace ( ) ) { return $ this - > get Short Name ( ) ; } return $ this - > get Namespace Name ( ) . ' \ \ ' . $ this - > get Short Name ( ) ; } 
public function get Short Name ( ) : string { if ( $ this - > node instanceof Node \ Expr \ Closure ) { return self : : CLOSURE _NAME ; } return $ this - > node - > name - > name ; } 
public function get Number Of Required Parameters ( ) : int { return count ( array _filter ( $ this - > get Parameters ( ) , static function ( Reflection Parameter $ p ) : bool { return ! $ p - > is Optional ( ) ; } ) ) ; } 
public function get Parameters ( ) : array { $ parameters = [ ] ; foreach ( $ this - > node - > params as $ param Index = > $ param Node ) { $ parameters [ ] = Reflection Parameter : : create From Node ( $ this - > reflector , $ param Node , $ this - > declaring Namespace , $ this , $ param Index ) ; } return $ parameters ; } 
public function get Parameter ( string $ parameter Name ) : ? Reflection Parameter { foreach ( $ this - > get Parameters ( ) as $ parameter ) { if ( $ parameter - > get Name ( ) = = = $ parameter Name ) { return $ parameter ; } } return null ; } 
public function is Variadic ( ) : bool { $ parameters = $ this - > get Parameters ( ) ; foreach ( $ parameters as $ parameter ) { if ( $ parameter - > is Variadic ( ) ) { return true ; } } return false ; } 
private function node Is Or Contains Yield ( Node $ node ) : bool { if ( $ node instanceof Yield Node ) { return true ; } foreach ( $ node - > get Sub Node Names ( ) as $ node Name ) { $ node Property = $ node - > $ node Name ; if ( $ node Property instanceof Node & & $ this - > node Is Or Contains Yield ( $ node Property ) ) { return true ; } if ( ! is _array ( $ node Property ) ) { continue ; } foreach ( $ node Property as $ node Property Array Item ) { if ( $ node Property Array Item instanceof Node & & $ this - > node Is Or Contains Yield ( $ node Property Array Item ) ) { return true ; } } } return false ; } 
public function is Generator ( ) : bool { if ( $ this - > node = = = null ) { return false ; } return $ this - > node Is Or Contains Yield ( $ this - > node ) ; } 
public function get Return Type ( ) : ? Reflection Type { $ return Type = $ this - > node - > get Return Type ( ) ; if ( $ return Type = = = null ) { return null ; } if ( $ return Type instanceof Nullable Type ) { return Reflection Type : : create From Type And Reflector ( ( string ) $ return Type - > type , true , $ this - > reflector ) ; } return Reflection Type : : create From Type And Reflector ( ( string ) $ return Type , false , $ this - > reflector ) ; } 
public function set Return Type ( string $ new Return Type ) : void { $ this - > node - > return Type = new Node \ Name ( $ new Return Type ) ; } 
public function get Body Code ( ? Pretty Printer Abstract $ printer = null ) : string { if ( $ printer = = = null ) { $ printer = new Standard Pretty Printer ( ) ; } return $ printer - > pretty Print ( $ this - > get Body Ast ( ) ) ; } 
public function set Body From Closure ( Closure $ new Body ) : void { $ closure Reflection = ( new Closure Source Locator ( $ new Body , $ this - > load Static Parser ( ) ) ) - > locate Identifier ( $ this - > reflector , new Identifier ( self : : CLOSURE _NAME , new Identifier Type ( Identifier Type : : IDENTIFIER _FUNCTION ) ) ) ; $ function Node = $ closure Reflection - > get Node ( ) ; $ this - > node - > stmts = $ function Node - > stmts ; } 
public function set Body From String ( string $ new Body ) : void { $ this - > node - > stmts = $ this - > load Static Parser ( ) - > parse ( ' < ?php ' . $ new Body ) ; } 
public function set Body From Ast ( array $ nodes ) : void { 
public function add Parameter ( string $ parameter Name ) : void { $ this - > node - > params [ ] = new Param Node ( new Node \ Expr \ Variable ( $ parameter Name ) ) ; } 
public function remove Parameter ( string $ parameter Name ) : void { $ lower Name = strtolower ( $ parameter Name ) ; foreach ( $ this - > node - > params as $ key = > $ param Node ) { if ( $ param Node - > var instanceof Node \ Expr \ Error ) { throw new Logic Exception ( 'Php Parser left an "Error " node in the parameters AST , this should NOT happen ' ) ; } if ( ! is _string ( $ param Node - > var - > name ) | | strtolower ( $ param Node - > var - > name ) ! = = $ lower Name ) { continue ; } unset ( $ this - > node - > params [ $ key ] ) ; } } 
public function get Return Statements Ast ( ) : array { $ visitor = new Return Node Visitor ( ) ; $ traverser = new Node Traverser ( ) ; $ traverser - > add Visitor ( $ visitor ) ; $ traverser - > traverse ( $ this - > node - > get Stmts ( ) ) ; return $ visitor - > get Return Nodes ( ) ; } 
public function get Value ( $ object = null ) { if ( ! $ this - > is Accessible ( ) ) { throw new Core Reflection Exception ( 'Property not accessible ' ) ; } try { return $ this - > better Reflection Property - > get Value ( $ object ) ; } catch ( No Object Provided | Not An Object $ e ) { return null ; } catch ( Throwable $ e ) { throw new Core Reflection Exception ( $ e - > get Message ( ) , 0 , $ e ) ; } } 
public function set Value ( $ object , $ value = null ) { if ( ! $ this - > is Accessible ( ) ) { throw new Core Reflection Exception ( 'Property not accessible ' ) ; } try { $ this - > better Reflection Property - > set Value ( $ object , $ value ) ; } catch ( No Object Provided | Not An Object $ e ) { return null ; } catch ( Throwable $ e ) { throw new Core Reflection Exception ( $ e - > get Message ( ) , 0 , $ e ) ; } } 
public function locate Identifier ( Reflector $ reflector , Identifier $ identifier ) : ? Reflection { foreach ( $ this - > mapping - > resolve Possible File Paths ( $ identifier ) as $ file ) { if ( ! file _exists ( $ file ) ) { continue ; } try { return $ this - > ast Locator - > find Reflection ( $ reflector , new Located Source ( file _get _contents ( $ file ) , $ file ) , $ identifier ) ; } catch ( Identifier Not Found $ exception ) { 
public function locate Identifiers By Type ( Reflector $ reflector , Identifier Type $ identifier Type ) : array { return ( new Directories Source Locator ( $ this - > mapping - > directories ( ) , $ this - > ast Locator ) ) - > locate Identifiers By Type ( $ reflector , $ identifier Type ) ; } 
private function prefix With Installation Path ( array $ paths , string $ trimmed Installation Path ) : array { return array _map ( function ( array $ paths ) use ( $ trimmed Installation Path ) : array { return $ this - > prefix Paths ( $ paths , $ trimmed Installation Path ) ; } , $ paths ) ; } 
public function generate Class Stub ( Core Reflection Class $ class Reflection ) : ? string { foreach ( $ this - > source Stubbers as $ source Stubber ) { $ stub = $ source Stubber - > generate Class Stub ( $ class Reflection ) ; if ( $ stub ! = = null ) { return $ stub ; } } return null ; } 
public function generate Function Stub ( Core Reflection Function $ function Reflection ) : ? string { foreach ( $ this - > source Stubbers as $ source Stubber ) { $ stub = $ source Stubber - > generate Function Stub ( $ function Reflection ) ; if ( $ stub ! = = null ) { return $ stub ; } } return null ; } 
public function locate Identifier ( Reflector $ reflector , Identifier $ identifier ) : ? Reflection { return $ this - > get Reflection Function ( $ reflector , $ identifier - > get Type ( ) ) ; } 
public function locate Identifiers By Type ( Reflector $ reflector , Identifier Type $ identifier Type ) : array { return array _filter ( [ $ this - > get Reflection Function ( $ reflector , $ identifier Type ) ] ) ; } 
public static function create From Node ( Reflector $ reflector , Class Const $ node , int $ position In Node , Reflection Class $ owner ) : self { $ ref = new self ( ) ; $ ref - > node = $ node ; $ ref - > position In Node = $ position In Node ; $ ref - > owner = $ owner ; $ ref - > reflector = $ reflector ; return $ ref ; } 
public function get Value ( ) { if ( $ this - > value Was Cached ! = = false ) { return $ this - > value ; } $ this - > value = ( new Compile Node To Value ( ) ) - > _ _invoke ( $ this - > node - > consts [ $ this - > position In Node ] - > value , new Compiler Context ( $ this - > reflector , $ this - > get Declaring Class ( ) ) ) ; $ this - > value Was Cached = true ; return $ this - > value ; } 
public function get Modifiers ( ) : int { $ val = 0 ; $ val + = $ this - > is Public ( ) ? Reflection Property : : IS _PUBLIC : 0 ; $ val + = $ this - > is Protected ( ) ? Reflection Property : : IS _PROTECTED : 0 ; $ val + = $ this - > is Private ( ) ? Reflection Property : : IS _PRIVATE : 0 ; return $ val ; } 
public function generate Constant Annotations ( string $ class Name , string $ constant Name ) : array { $ resource = $ this - > classes [ $ class Name ] [ 'constants ' ] [ $ constant Name ] [ 'resource ' ] ; $ annotations = $ this - > format Doc ( ( string ) $ resource - > get ( 'rdfs :comment ' ) , true ) ; $ annotations [ 0 ] = sprintf ( ' @var string %s ' , $ annotations [ 0 ] ) ; return $ annotations ; } 
public function generate Field Annotations ( string $ class Name , string $ field Name ) : array { $ field = $ this - > classes [ $ class Name ] [ 'fields ' ] [ $ field Name ] ; $ comment = $ field [ 'resource ' ] ? $ field [ 'resource ' ] - > get ( 'rdfs :comment ' ) : ' ' ; $ annotations = $ this - > format Doc ( ( string ) $ comment , true ) ; $ annotations [ 0 ] = sprintf ( ' @var %s %s ' , $ this - > to Php Doc Type ( $ field ) , $ annotations [ 0 ] ) ; $ annotations [ ] = ' ' ; return $ annotations ; } 
public function generate Getter Annotations ( string $ class Name , string $ field Name ) : array { if ( ! $ this - > is Doc Useful ( $ class Name , $ field Name ) ) { return [ ] ; } return [ sprintf ( ' @return %s ' , $ this - > to Php Doc Type ( $ this - > classes [ $ class Name ] [ 'fields ' ] [ $ field Name ] ) ) ] ; } 
public function generate Setter Annotations ( string $ class Name , string $ field Name ) : array { if ( ! $ this - > is Doc Useful ( $ class Name , $ field Name ) ) { return [ ] ; } $ field = $ this - > classes [ $ class Name ] [ 'fields ' ] [ $ field Name ] ; return [ sprintf ( ' @param %s $ %s ' , $ this - > to Php Doc Type ( $ this - > classes [ $ class Name ] [ 'fields ' ] [ $ field Name ] ) , $ field [ 'name ' ] ) ] ; } 
public function generate Remover Annotations ( string $ class Name , string $ field Name ) : array { if ( ! $ this - > is Doc Useful ( $ class Name , $ field Name , true ) ) { return [ ] ; } return [ sprintf ( ' @param %s $ %s ' , $ this - > to Php Type ( $ this - > classes [ $ class Name ] [ 'fields ' ] [ $ field Name ] , true ) , Inflector : : singularize ( $ field Name ) ) ] ; } 
private function generate Doc ( string $ class Name , bool $ interface = false ) : array { $ resource = $ this - > classes [ $ class Name ] [ 'resource ' ] ; $ annotations = [ ] ; if ( ! $ interface & & isset ( $ this - > classes [ $ class Name ] [ 'interface Name ' ] ) ) { $ annotations [ ] = ' { @inheritdoc } ' ; $ annotations [ ] = ' ' ; } else { $ annotations = $ this - > format Doc ( ( string ) $ resource - > get ( 'rdfs :comment ' ) ) ; $ annotations [ ] = ' ' ; $ annotations [ ] = sprintf ( ' @see %s %s ' , $ resource - > get Uri ( ) , 'Documentation on Schema .org ' ) ; } if ( $ this - > config [ 'author ' ] ) { $ annotations [ ] = sprintf ( ' @author %s ' , $ this - > config [ 'author ' ] ) ; } return $ annotations ; } 
private function format Doc ( string $ doc , bool $ indent = false ) : array { $ doc = explode ( " \n " , $ this - > html To Markdown - > convert ( $ doc ) ) ; if ( $ indent ) { $ count = count ( $ doc ) ; for ( $ i = 1 ; $ i < $ count ; + + $ i ) { $ doc [ $ i ] = self : : INDENT . $ doc [ $ i ] ; } } return $ doc ; } 
public function extract ( ) : array { $ properties = [ ] ; foreach ( $ this - > graphs as $ graph ) { foreach ( $ graph - > all Of Type ( 'rdf :Property ' ) as $ property ) { $ properties [ $ property - > local Name ( ) ] = $ this - > extract For Property ( $ property ) ; } } return $ properties ; } 
private function extract For Property ( \ Easy Rdf _Resource $ property ) : string { $ local Name = $ property - > local Name ( ) ; $ from Good Relations = $ this - > good Relations Bridge - > extract Cardinality ( $ local Name ) ; if ( false ! = = $ from Good Relations ) { return $ from Good Relations ; } $ comment = $ property - > get ( 'rdfs :comment ' ) - > get Value ( ) ; if ( 
public function generate ( array $ config ) : void { $ base Class = [ 'constants ' = > [ ] , 'fields ' = > [ ] , 'uses ' = > [ ] , 'has Constructor ' = > false , 'parent Has Constructor ' = > false , 'has Child ' = > false , 'abstract ' = > false , ] ; $ types To Generate = [ ] ; if ( ! $ config [ 'types ' ] ) { foreach ( $ this - > graphs as $ graph ) { $ types To Generate = $ graph - > all Of Type ( 'rdfs :Class ' ) ; } } else { foreach ( $ config [ 'types ' ] as $ type Name = > $ type Config ) { $ resource = null ; foreach ( $ this - > graphs as $ graph ) { $ resources = $ graph - > resources ( ) ; if ( isset ( $ resources [ $ type Config [ 'vocabulary Namespace ' ] . $ type Name ] ) ) { $ resource = $ graph - > resource ( $ type Config [ 'vocabulary Namespace ' ] . $ type Name , 'rdfs :Class ' ) ; break ; } } if ( $ resource ) { $ types To Generate [ $ type Name ] = $ resource ; } elseif ( empty ( $ graph ) ) { $ this - > logger - > warning ( 'Type " {type Name } " cannot be found and there is no graph to generate entity . ' ) ; } else { $ this - > logger - > warning ( 'Type " {type Name } " cannot be found . Using " {guess From } " type to generate entity . ' , [ 'type Name ' = > $ type Name , 'guess From ' = > $ type Config [ 'guess From ' ] ] ) ; $ type = $ graph - > resource ( $ type Config [ 'vocabulary Namespace ' ] . $ type Config [ 'guess From ' ] , 'rdfs :Class ' ) ; $ types To Generate [ $ type Name ] = $ type ; } } } $ classes = [ ] ; $ properties Map = $ this - > create Properties Map ( $ types To Generate ) ; foreach ( $ types To Generate as $ type Name = > $ type ) { $ type Name = is _string ( $ type Name ) ? $ type Name : $ type - > local Name ( ) ; $ type Config = $ config [ 'types ' ] [ $ type Name ] ? ? null ; $ class = $ base Class ; $ comment = $ type - > get ( 'rdfs :comment ' ) ; $ class [ 'name ' ] = $ type Name ; $ class [ 'label ' ] = $ comment ? $ comment - > get Value ( ) : ' ' ; $ class [ 'resource ' ] = $ type ; $ class [ 'config ' ] = $ type Config ; $ class [ 'is Enum ' ] = $ this - > is Enum ( $ type ) ; if ( $ class [ 'is Enum ' ] ) { $ class [ 'namespace ' ] = $ type Config [ 'namespace ' ] ? ? $ config [ 'namespaces ' ] [ 'enum ' ] ; $ class [ 'parent ' ] = 'Enum ' ; $ class [ 'uses ' ] [ ] = Enum : : class ; 
private function is Enum ( \ Easy Rdf _Resource $ type ) : bool { $ sub Class Of = $ type - > get ( 'rdfs :sub Class Of ' ) ; return $ sub Class Of & & self : : SCHEMA _ORG _ENUMERATION = = = $ sub Class Of - > get Uri ( ) ; } 
private function get Parent Classes ( \ Easy Rdf _Resource $ resource , array $ parent Classes = [ ] ) { if ( [ ] = = = $ parent Classes ) { return $ this - > get Parent Classes ( $ resource , [ $ resource - > get Uri ( ) ] ) ; } $ subclasses = $ resource - > all ( 'rdfs :sub Class Of ' ) ; if ( empty ( $ subclasses ) ) { return $ parent Classes ; } $ parent Class = $ subclasses [ 0 ] ; $ parent Classes [ ] = $ parent Class - > get Uri ( ) ; foreach ( $ this - > graphs as $ graph ) { foreach ( $ graph - > all Of Type ( 'rdfs :Class ' ) as $ type ) { if ( $ type - > get Uri ( ) = = = $ parent Class - > get Uri ( ) ) { $ parent Classes = $ this - > get Parent Classes ( $ type , $ parent Classes ) ; break 2 ; } } } return $ parent Classes ; } 
private function create Properties Map ( array $ types ) { $ types As String = [ ] ; $ map = [ ] ; foreach ( $ types as $ type ) { 
private function generate Field ( array $ config , array $ class , \ Easy Rdf _Resource $ type , $ type Name , $ property Name , \ Easy Rdf _Resource $ property = null ) { $ type Config = $ config [ 'types ' ] [ $ type Name ] ? ? null ; $ types Defined = ! empty ( $ config [ 'types ' ] ) ; 
private function namespace To Dir ( array $ config , string $ namespace ) : string { if ( null ! = = ( $ prefix = $ config [ 'namespaces ' ] [ 'prefix ' ] ? ? null ) & & 0 = = = strpos ( $ namespace , $ prefix ) ) { $ namespace = substr ( $ namespace , strlen ( $ prefix ) ) ; } return sprintf ( ' %s / %s / ' , $ config [ 'output ' ] , strtr ( $ namespace , ' \ \ ' , ' / ' ) ) ; } 
private function fix Cs ( array $ files ) : void { $ file Infos = [ ] ; foreach ( $ files as $ file ) { $ file Infos [ ] = new \ Spl File Info ( $ file ) ; } $ fixers = ( new Fixer Factory ( ) ) - > register Built In Fixers ( ) - > use Rule Set ( new Rule Set ( [ ' @Symfony ' = > true , 'array _syntax ' = > [ 'syntax ' = > 'short ' ] , 'phpdoc _order ' = > true , 'declare _strict _types ' = > true , ] ) ) - > get Fixers ( ) ; $ runner = new Runner ( new \ Array Iterator ( $ file Infos ) , $ fixers , new Null Differ ( ) , null , new Errors Manager ( ) , new Linter ( ) , false , new Null Cache Manager ( ) ) ; $ runner - > fix ( ) ; } 
public function exist ( string $ id ) : bool { foreach ( $ this - > relations as $ relation ) { $ result = $ relation - > xpath ( sprintf ( ' / / * [ @rdf :about = " %s " ] ' , $ this - > get Property Url ( $ id ) ) ) ; if ( ! empty ( $ result ) ) { return true ; } } return false ; } 
public function extract Cardinality ( string $ id ) { foreach ( $ this - > relations as $ relation ) { $ result = $ relation - > xpath ( sprintf ( ' / / * [ @rdf :about = " %s " ] /rdfs :label ' , $ this - > get Property Url ( $ id ) ) ) ; if ( count ( $ result ) ) { preg _match ( ' / \ ( . \ . \ . . \ ) / ' , $ result [ 0 ] - > as XML ( ) , $ matches ) ; return $ matches [ 0 ] ; } } return false ; } 
private function get Property Url ( string $ id ) : string { $ property Id = $ this - > datatype Properties Table [ $ id ] ? ? $ this - > object Properties Table [ $ id ] ? ? $ id ; return self : : GOOD _RELATIONS _NAMESPACE . $ property Id ; } 
protected function configure ( ) : void { if ( file _exists ( 'composer .json ' ) & & is _file ( 'composer .json ' ) & & is _readable ( 'composer .json ' ) ) { $ composer = json _decode ( file _get _contents ( 'composer .json ' ) , true ) ; foreach ( $ composer [ 'autoload ' ] [ 'psr - 4 ' ] ? ? [ ] as $ prefix = > $ output ) { if ( ' ' = = = $ prefix ) { continue ; } $ this - > namespace Prefix = $ prefix ; $ this - > default Output = $ output ; break ; } } $ this - > set Name ( 'generate -types ' ) - > set Description ( 'Generate types ' ) - > add Argument ( 'output ' , $ this - > default Output ? Input Argument : : OPTIONAL : Input Argument : : REQUIRED , 'The output directory ' , $ this - > default Output ) - > add Argument ( 'config ' , Input Argument : : OPTIONAL , 'The config file to use (default to "schema .yaml " in the current directory , will generate all types if no config file exists ) ' ) ; } 
protected function execute ( Input Interface $ input , Output Interface $ output ) : void { $ default Output = $ this - > default Output ? realpath ( $ this - > default Output ) : null ; $ output Dir = $ input - > get Argument ( 'output ' ) ; $ config Argument = $ input - > get Argument ( 'config ' ) ; if ( $ dir = realpath ( $ input - > get Argument ( 'output ' ) ) ) { if ( ! is _dir ( $ dir ) ) { if ( ! $ this - > default Output ) { throw new \ Invalid Argument Exception ( sprintf ( 'The file " %s " is not a directory . ' , $ dir ) ) ; } $ dir = $ default Output ; $ config Argument = $ output Dir ; } if ( ! is _writable ( $ dir ) ) { throw new \ Invalid Argument Exception ( sprintf ( 'The " %s " directory is not writable . ' , $ dir ) ) ; } $ output Dir = $ dir ; } elseif ( ! @ mkdir ( $ output Dir , 0 7 7 7 , true ) ) { throw new \ Invalid Argument Exception ( sprintf ( 'Cannot create the " %s " directory . Check that the parent directory is writable . ' , $ output Dir ) ) ; } else { $ output Dir = realpath ( $ output Dir ) ; } if ( $ config Argument ) { if ( ! file _exists ( $ config Argument ) ) { throw new \ Invalid Argument Exception ( sprintf ( 'The file " %s " doesn \ 't exist . ' , $ config Argument ) ) ; } if ( ! is _file ( $ config Argument ) ) { throw new \ Invalid Argument Exception ( sprintf ( ' " %s " isn \ 't a file . ' , $ config Argument ) ) ; } if ( ! is _readable ( $ config Argument ) ) { throw new \ Invalid Argument Exception ( sprintf ( 'The file " %s " isn \ 't readable . ' , $ config Argument ) ) ; } $ parser = new Parser ( ) ; $ config = $ parser - > parse ( file _get _contents ( $ config Argument ) ) ; unset ( $ parser ) ; } elseif ( is _readable ( self : : DEFAULT _CONFIG _FILE ) ) { $ parser = new Parser ( ) ; $ config = $ parser - > parse ( file _get _contents ( self : : DEFAULT _CONFIG _FILE ) ) ; unset ( $ parser ) ; } else { $ config = [ ] ; } $ processor = new Processor ( ) ; $ configuration = new Types Generator Configuration ( $ dir = = = $ default Output ? $ this - > namespace Prefix : null ) ; $ processed Configuration = $ processor - > process Configuration ( $ configuration , [ $ config ] ) ; $ processed Configuration [ 'output ' ] = $ output Dir ; if ( ! $ processed Configuration [ 'output ' ] ) { throw new \ Runtime Exception ( 'The specified output is invalid ' ) ; } $ graphs = [ ] ; foreach ( $ processed Configuration [ 'rdfa ' ] as $ rdfa ) { $ graph = new \ Easy Rdf _Graph ( ) ; if ( 'http : 
protected function to Php Type ( array $ field , bool $ adder Or Remover = false ) : string { $ range = $ field [ 'range ' ] ; if ( $ field [ 'is Enum ' ] ) { if ( $ field [ 'is Array ' ] ) { return 'string [ ] ' ; } return 'string ' ; } $ data = false ; switch ( $ range ) { case 'Boolean ' : $ data = 'bool ' ; break ; case 'Date ' : case 'Date Time ' : case 'Time ' : $ data = ' \ \ ' . \ Date Time Interface : : class ; break ; case 'Number ' : case 'Float ' : $ data = 'float ' ; break ; case 'Integer ' : $ data = 'integer ' ; break ; case 'Text ' : case 'URL ' : $ data = 'string ' ; break ; } if ( false ! = = $ data ) { if ( $ field [ 'is Array ' ] ) { return sprintf ( ' %s [ ] ' , $ data ) ; } return $ data ; } if ( isset ( $ this - > classes [ $ field [ 'range ' ] ] [ 'interface Name ' ] ) ) { $ range = $ this - > classes [ $ field [ 'range ' ] ] [ 'interface Name ' ] ; } if ( $ field [ 'is Array ' ] & & ! $ adder Or Remover ) { if ( $ this - > config [ 'doctrine ' ] [ 'use Collection ' ] ) { return sprintf ( 'Collection < %s > ' , $ range ) ; } return sprintf ( ' %s [ ] ' , $ range ) ; } return $ range ; } 
protected function execute ( Input Interface $ input , Output Interface $ output ) : void { $ configuration = new Types Generator Configuration ( ) ; $ dumper = new Yaml Reference Dumper ( ) ; $ output - > writeln ( $ dumper - > dump ( $ configuration ) ) ; } 
public function generate Field Annotations ( string $ class Name , string $ field Name ) : array { $ field = $ this - > classes [ $ class Name ] [ 'fields ' ] [ $ field Name ] ; if ( $ field [ 'is Id ' ] ) { return $ this - > generate Id Annotations ( ) ; } $ annotations = [ ] ; if ( $ field [ 'is Enum ' ] ) { $ type = $ field [ 'is Array ' ] ? 'simple _array ' : 'string ' ; } else { switch ( $ field [ 'range ' ] ) { case 'Boolean ' : $ type = 'boolean ' ; break ; case 'Date ' : case 'Date Time ' : $ type = 'date ' ; break ; case 'Time ' : $ type = 'time ' ; break ; case 'Number ' : case 'Float ' : $ type = 'float ' ; break ; case 'Integer ' : $ type = 'integer ' ; break ; case 'Text ' : case 'URL ' : $ type = 'string ' ; break ; } } if ( isset ( $ type ) ) { $ annotation = ' @Mongo DB \Field ' ; if ( $ field [ 'is Array ' ] ) { $ type = 'collection ' ; } $ annotation . = sprintf ( ' (type = " %s " ) ' , $ type ) ; $ annotations [ ] = $ annotation ; } else { if ( Cardinalities Extractor : : CARDINALITY _ 0 _ 1 = = = $ field [ 'cardinality ' ] | | Cardinalities Extractor : : CARDINALITY _ 1 _ 1 = = = $ field [ 'cardinality ' ] | | Cardinalities Extractor : : CARDINALITY _N _ 0 = = = $ field [ 'cardinality ' ] | | Cardinalities Extractor : : CARDINALITY _N _ 1 = = = $ field [ 'cardinality ' ] ) { $ annotations [ ] = sprintf ( ' @Mongo DB \Reference One (target Document = " %s " , simple =true ) ) ' , $ this - > get Relation Name ( $ field [ 'range ' ] ) ) ; } elseif ( Cardinalities Extractor : : CARDINALITY _ 0 _N = = = $ field [ 'cardinality ' ] | | Cardinalities Extractor : : CARDINALITY _ 1 _N = = = $ field [ 'cardinality ' ] | | Cardinalities Extractor : : CARDINALITY _N _N = = = $ field [ 'cardinality ' ] ) { $ annotations [ ] = sprintf ( ' @Mongo DB \Reference Many (target Document = " %s " , simple =true ) ' , $ this - > get Relation Name ( $ field [ 'range ' ] ) ) ; } } return $ annotations ; } 
public function generate Class Annotations ( string $ class Name ) : array { $ resource = $ this - > classes [ $ class Name ] [ 'resource ' ] ; return [ sprintf ( ' @Api Resource (iri = " %s " ) ' , $ resource - > get Uri ( ) ) ] ; } 
public function generate Field Annotations ( string $ class Name , string $ field Name ) : array { return $ this - > classes [ $ class Name ] [ 'fields ' ] [ $ field Name ] [ 'is Custom ' ] ? [ ] : [ sprintf ( ' @Api Property (iri = "http : / /schema .org / %s " ) ' , $ field Name ) ] ; } 
public function generate Class Annotations ( string $ class Name ) : array { $ class = $ this - > classes [ $ class Name ] ; if ( $ class [ 'is Enum ' ] ) { return [ ] ; } if ( isset ( $ this - > config [ 'types ' ] [ $ class [ 'resource ' ] - > local Name ( ) ] [ 'doctrine ' ] [ 'inheritance Mapping ' ] ) ) { $ inheritance Mapping = $ this - > config [ 'types ' ] [ $ class [ 'resource ' ] - > local Name ( ) ] [ 'doctrine ' ] [ 'inheritance Mapping ' ] ; } else { $ inheritance Mapping = ' @ORM \Entity ' ; if ( $ class [ 'abstract ' ] ) { $ inheritance Mapping = ' @ORM \Mapped Superclass ' ; } if ( $ class [ 'embeddable ' ] ) { $ inheritance Mapping = ' @ORM \Embeddable ' ; } } return [ ' ' , $ inheritance Mapping ] ; } 
public function generate Field Annotations ( string $ class Name , string $ field Name ) : array { $ field = $ this - > classes [ $ class Name ] [ 'fields ' ] [ $ field Name ] ; if ( $ field [ 'is Id ' ] ) { return $ this - > generate Id Annotations ( ) ; } $ annotations = [ ] ; $ field [ 'relation Table Name ' ] = null ; if ( isset ( $ this - > config [ 'types ' ] [ $ class Name ] [ 'properties ' ] [ $ field Name ] ) ) { $ field [ 'relation Table Name ' ] = $ this - > config [ 'types ' ] [ $ class Name ] [ 'properties ' ] [ $ field Name ] [ 'relation Table Name ' ] ; } if ( $ field [ 'is Enum ' ] ) { $ type = $ field [ 'is Array ' ] ? 'simple _array ' : 'string ' ; } else { switch ( $ field [ 'range ' ] ) { case 'Boolean ' : $ type = 'boolean ' ; break ; case 'Date ' : $ type = 'date ' ; break ; case 'Date Time ' : $ type = 'datetime ' ; break ; case 'Time ' : $ type = 'time ' ; break ; case 'Number ' : case 'Float ' : $ type = 'float ' ; break ; case 'Integer ' : $ type = 'integer ' ; break ; case 'Text ' : case 'URL ' : $ type = 'text ' ; break ; } } if ( isset ( $ type ) ) { $ annotation = ' @ORM \Column ' ; $ is Column Has Properties = false ; if ( $ field [ 'orm Column ' ] ) { $ annotation . = sprintf ( ' ( %s ) ' , $ field [ 'orm Column ' ] ) ; } else { if ( 'string ' ! = = $ type | | $ field [ 'is Nullable ' ] | | $ field [ 'is Unique ' ] ) { $ is Column Has Properties = true ; } if ( $ field [ 'is Array ' ] ) { $ type = 'simple _array ' ; } if ( $ is Column Has Properties ) { $ annotation . = ' ( ' ; } if ( 'string ' ! = = $ type ) { $ annotation . = sprintf ( 'type = " %s " ' , $ type ) ; } if ( 'string ' ! = = $ type & & $ field [ 'is Nullable ' ] ) { $ annotation . = ' , ' ; } if ( $ field [ 'is Nullable ' ] ) { $ annotation . = 'nullable =true ' ; } if ( $ field [ 'is Unique ' ] & & $ field [ 'is Nullable ' ] ) { $ annotation . = ' , ' ; } if ( $ field [ 'is Unique ' ] ) { $ annotation . = 'unique =true ' ; } if ( $ is Column Has Properties ) { $ annotation . = ' ) ' ; } } $ annotations [ ] = $ annotation ; } elseif ( $ field [ 'is Embedded ' ] ) { $ column Prefix = $ field [ 'column Prefix ' ] ? ' , column Prefix =true ' : ' , column Prefix =false ' ; $ annotations [ ] = sprintf ( ' @ORM \Embedded (class = " %s " %s ) ' , $ this - > get Relation Name ( $ field [ 'range ' ] ) , $ column Prefix ) ; } else { switch ( $ field [ 'cardinality ' ] ) { case Cardinalities Extractor : : CARDINALITY _ 0 _ 1 : $ annotations [ ] = sprintf ( ' @ORM \One To One (target Entity = " %s " ) ' , $ this - > get Relation Name ( $ field [ 'range ' ] ) ) ; break ; case Cardinalities Extractor : : CARDINALITY _ 1 _ 1 : $ annotations [ ] = sprintf ( ' @ORM \One To One (target Entity = " %s " ) ' , $ this - > get Relation Name ( $ field [ 'range ' ] ) ) ; $ annotations [ ] = ' @ORM \Join Column (nullable =false ) ' ; break ; case Cardinalities Extractor : : CARDINALITY _UNKNOWN : case Cardinalities Extractor : : CARDINALITY _N _ 0 : $ annotations [ ] = sprintf ( ' @ORM \Many To One (target Entity = " %s " ) ' , $ this - > get Relation Name ( $ field [ 'range ' ] ) ) ; break ; case Cardinalities Extractor : : CARDINALITY _N _ 1 : $ annotations [ ] = sprintf ( ' @ORM \Many To One (target Entity = " %s " ) ' , $ this - > get Relation Name ( $ field [ 'range ' ] ) ) ; $ annotations [ ] = ' @ORM \Join Column (nullable =false ) ' ; break ; case Cardinalities Extractor : : CARDINALITY _ 0 _N : $ annotations [ ] = sprintf ( ' @ORM \Many To Many (target Entity = " %s " ) ' , $ this - > get Relation Name ( $ field [ 'range ' ] ) ) ; $ name = $ field [ 'relation Table Name ' ] ? sprintf ( 'name = " %s " , ' , $ field [ 'relation Table Name ' ] ) : ' ' ; $ annotations [ ] = ' @ORM \Join Table ( ' . $ name . 'inverse Join Columns = { @ORM \Join Column (unique =true ) } ) ' ; break ; case Cardinalities Extractor : : CARDINALITY _ 1 _N : $ annotations [ ] = sprintf ( ' @ORM \Many To Many (target Entity = " %s " ) ' , $ this - > get Relation Name ( $ field [ 'range ' ] ) ) ; $ name = $ field [ 'relation Table Name ' ] ? sprintf ( 'name = " %s " , ' , $ field [ 'relation Table Name ' ] ) : ' ' ; $ annotations [ ] = ' @ORM \Join Table ( ' . $ name . 'inverse Join Columns = { @ORM \Join Column (nullable =false , unique =true ) } ) ' ; break ; case Cardinalities Extractor : : CARDINALITY _N _N : $ annotations [ ] = sprintf ( ' @ORM \Many To Many (target Entity = " %s " ) ' , $ this - > get Relation Name ( $ field [ 'range ' ] ) ) ; if ( $ field [ 'relation Table Name ' ] ) { $ annotations [ ] = sprintf ( ' @ORM \Join Table (name = " %s " ) ' , $ field [ 'relation Table Name ' ] ) ; } break ; } } return $ annotations ; } 
public function generate Uses ( string $ class Name ) : array { $ resource = $ this - > classes [ $ class Name ] [ 'resource ' ] ; $ sub Class Of = $ resource - > get ( 'rdfs :sub Class Of ' ) ; $ type Is Enum = $ sub Class Of & & Types Generator : : SCHEMA _ORG _ENUMERATION = = = $ sub Class Of - > get Uri ( ) ; return $ type Is Enum ? [ ] : [ 'Doctrine \ORM \Mapping as ORM ' ] ; } 
private function get Relation Name ( string $ range ) : string { $ class = $ this - > classes [ $ range ] ; if ( isset ( $ class [ 'interface Name ' ] ) ) { return $ class [ 'interface Name ' ] ; } if ( isset ( $ this - > config [ 'types ' ] [ $ class [ 'name ' ] ] [ 'namespaces ' ] [ 'class ' ] ) ) { return sprintf ( ' %s \ \ %s ' , $ this - > config [ 'types ' ] [ $ class [ 'name ' ] ] [ 'namespaces ' ] [ 'class ' ] , $ class [ 'name ' ] ) ; } if ( isset ( $ this - > config [ 'namespaces ' ] [ 'entity ' ] ) ) { return sprintf ( ' %s \ \ %s ' , $ this - > config [ 'namespaces ' ] [ 'entity ' ] , $ class [ 'name ' ] ) ; } return $ class [ 'name ' ] ; } 
protected function configure ( ) : void { $ this - > set Name ( 'extract -cardinalities ' ) - > set Description ( 'Extract properties \ ' cardinality ' ) - > add Option ( 'schemaorg -file ' , 's ' , Input Option : : VALUE _REQUIRED , 'The path or URL of the Schema .org RDFa file to use . ' , Types Generator Configuration : : SCHEMA _ORG _RDFA _URL ) - > add Option ( 'goodrelations -file ' , 'g ' , Input Option : : VALUE _REQUIRED , 'The path or URL of the Good Relations OWL file to use . ' , Types Generator Configuration : : GOOD _RELATIONS _OWL _URL ) ; } 
protected function execute ( Input Interface $ input , Output Interface $ output ) : void { $ schema Org File = $ input - > get Option ( 'schemaorg -file ' ) ; $ relations = [ ] ; $ schema Org = new \ Easy Rdf _Graph ( ) ; if ( 'http : / / ' = = = substr ( $ schema Org File , 0 , 7 ) | | 'https : / / ' = = = substr ( $ schema Org File , 0 , 8 ) ) { $ schema Org - > load ( $ input - > get Option ( 'schemaorg -file ' ) , 'rdfa ' ) ; } else { $ schema Org - > parse File ( $ input - > get Option ( 'schemaorg -file ' ) , 'rdfa ' ) ; } $ relations [ ] = $ schema Org ; $ good Relations = [ new \ Simple XMLElement ( $ input - > get Option ( 'goodrelations -file ' ) , 0 , true ) ] ; $ good Relations Bridge = new Good Relations Bridge ( $ good Relations ) ; $ cardinalities Extractor = new Cardinalities Extractor ( $ relations , $ good Relations Bridge ) ; $ result = $ cardinalities Extractor - > extract ( ) ; $ output - > writeln ( json _encode ( $ result , JSON _PRETTY _PRINT ) ) ; } 
public function generate Field Annotations ( string $ class Name , string $ field Name ) : array { $ field = $ this - > classes [ $ class Name ] [ 'fields ' ] [ $ field Name ] ; if ( $ field [ 'is Id ' ] ) { if ( 'uuid ' = = = $ this - > config [ 'id ' ] [ 'generation Strategy ' ] ) { return [ ' @Assert \Uuid ' ] ; } return [ ] ; } $ asserts = [ ] ; if ( ! $ field [ 'is Array ' ] ) { switch ( $ field [ 'range ' ] ) { case 'URL ' : $ asserts [ ] = ' @Assert \Url ' ; break ; case 'Date ' : $ asserts [ ] = ' @Assert \Date ' ; break ; case 'Date Time ' : $ asserts [ ] = ' @Assert \Date Time ' ; break ; case 'Time ' : $ asserts [ ] = ' @Assert \Time ' ; break ; } if ( isset ( $ field [ 'resource ' ] ) & & 'email ' = = = $ field [ 'resource ' ] - > local Name ( ) ) { $ asserts [ ] = ' @Assert \Email ' ; } if ( ! $ asserts & & $ this - > config [ 'validator ' ] [ 'assert Type ' ] ) { $ php Type = $ this - > to Php Type ( $ field ) ; if ( in _array ( $ php Type , [ 'boolean ' , 'float ' , 'integer ' , 'string ' ] , true ) ) { $ asserts [ ] = sprintf ( ' @Assert \Type (type = " %s " ) ' , $ php Type ) ; } } } if ( ! $ field [ 'is Nullable ' ] ) { $ asserts [ ] = ' @Assert \Not Null ' ; } if ( $ field [ 'is Enum ' ] ) { $ assert = sprintf ( ' @Assert \Choice (callback = { " %s " , "to Array " } ' , $ field [ 'range ' ] ) ; if ( $ field [ 'is Array ' ] ) { $ assert . = ' , multiple =true ' ; } $ assert . = ' ) ' ; $ asserts [ ] = $ assert ; } return $ asserts ; } 
public function generate Uses ( string $ class Name ) : array { if ( $ this - > classes [ $ class Name ] [ 'is Enum ' ] ) { return [ ] ; } $ uses = [ ] ; $ uses [ ] = 'Symfony \Component \Validator \Constraints as Assert ' ; $ uses [ ] = Unique Entity : : class ; foreach ( $ this - > classes [ $ class Name ] [ 'fields ' ] as $ field ) { if ( $ field [ 'is Enum ' ] ) { $ enum Class = $ this - > classes [ $ field [ 'range ' ] ] ; $ enum Namespace = isset ( $ enum Class [ 'namespaces ' ] [ 'class ' ] ) & & $ enum Class [ 'namespaces ' ] [ 'class ' ] ? $ enum Class [ 'namespaces ' ] [ 'class ' ] : $ this - > config [ 'namespaces ' ] [ 'enum ' ] ; $ use = sprintf ( ' %s \ %s ' , $ enum Namespace , $ field [ 'range ' ] ) ; if ( ! in _array ( $ use , $ uses , true ) ) { $ uses [ ] = $ use ; } } } return $ uses ; } 
public function generate Class Annotations ( string $ class Name ) : array { if ( $ this - > classes [ $ class Name ] [ 'is Enum ' ] ) { return [ ] ; } $ annotation = [ ] ; $ unique Fields = [ ] ; foreach ( $ this - > classes [ $ class Name ] [ 'fields ' ] as $ field ) { if ( false = = = $ field [ 'is Unique ' ] ) { continue ; } $ unique Fields [ ] = $ field [ 'name ' ] ; } if ( ! $ unique Fields ) { return [ ] ; } if ( 1 = = = count ( $ unique Fields ) ) { $ annotation [ ] = sprintf ( ' @Unique Entity ( " %s " ) ' , $ unique Fields [ 0 ] ) ; } else { $ annotation [ ] = sprintf ( ' @Unique Entity (fields = { " %s " } ) ' , implode ( ' " , " ' , $ unique Fields ) ) ; } return $ annotation ; } 
public function generate Field Annotations ( string $ class Name , string $ field Name ) : array { if ( null = = = $ field = $ this - > config [ 'types ' ] [ $ class Name ] [ 'properties ' ] ? ? null ) { return [ ] ; } if ( false = = = $ this - > classes [ $ class Name ] [ 'fields ' ] [ $ field Name ] [ 'is Id ' ] & & $ groups = $ field [ $ field Name ] [ 'groups ' ] ? ? false ) { return [ sprintf ( ' @Groups ( { " %s " } ) ' , implode ( ' " , " ' , $ groups ) ) ] ; } return [ ] ; } 
public function get Config Tree Builder ( ) : Tree Builder { $ namespace Prefix = $ this - > default Prefix ? ? 'App Bundle \ \ ' ; $ tree Builder = new Tree Builder ( ) ; $ root Node = $ tree Builder - > root ( 'config ' ) ; $ root Node - > children ( ) - > array Node ( 'rdfa ' ) - > info ( 'RDFa files ' ) - > default Value ( [ [ 'uri ' = > self : : SCHEMA _ORG _RDFA _URL , 'format ' = > 'rdfa ' ] ] ) - > before Normalization ( ) - > if Array ( ) - > then ( function ( array $ v ) { return array _map ( function ( $ rdfa ) { return is _scalar ( $ rdfa ) ? [ 'uri ' = > $ rdfa , 'format ' = > null ] : $ rdfa ; } , $ v ) ; } ) - > end ( ) - > array Prototype ( ) - > children ( ) - > scalar Node ( 'uri ' ) - > default Value ( self : : SCHEMA _ORG _RDFA _URL ) - > info ( 'RDFa URI to use ' ) - > example ( 'https : / /schema .org /docs /schema _org _rdfa .html ' ) - > end ( ) - > scalar Node ( 'format ' ) - > default Null ( ) - > info ( 'RDFa URI data format ' ) - > example ( 'rdfxml ' ) - > end ( ) - > end ( ) - > end ( ) - > end ( ) - > array Node ( 'relations ' ) - > info ( 'OWL relation files to use ' ) - > example ( 'https : / /purl .org /goodrelations /v 1 .owl ' ) - > default Value ( [ self : : GOOD _RELATIONS _OWL _URL ] ) - > prototype ( 'scalar ' ) - > end ( ) - > end ( ) - > boolean Node ( 'debug ' ) - > default False ( ) - > info ( 'Debug mode ' ) - > end ( ) - > array Node ( 'id ' ) - > add Defaults If Not Set ( ) - > info ( 'IDs configuration ' ) - > children ( ) - > boolean Node ( 'generate ' ) - > default True ( ) - > info ( 'Automatically add an id field to entities ' ) - > end ( ) - > enum Node ( 'generation Strategy ' ) - > default Value ( 'auto ' ) - > values ( [ 'auto ' , 'none ' , 'uuid ' , 'mongoid ' ] ) - > info ( 'The ID generation strategy to use ( "none " to not let the database generate IDs ) . ' ) - > end ( ) - > boolean Node ( 'writable ' ) - > default False ( ) - > info ( 'Is the ID writable ? Only applicable if "generation Strategy " is "uuid " . ' ) - > end ( ) - > end ( ) - > end ( ) - > boolean Node ( 'use Interface ' ) - > default False ( ) - > info ( 'Generate interfaces and use Doctrine \ 's Resolve Target Entity feature ' ) - > end ( ) - > boolean Node ( 'check Is Good Relations ' ) - > default False ( ) - > info ( 'Emit a warning if a property is not derived from Good Relations ' ) - > end ( ) - > scalar Node ( 'header ' ) - > default False ( ) - > info ( 'A license or any text to use as header of generated files ' ) - > example ( ' 
private function create New File ( ) { $ this - > file Count + + ; $ file Path = $ this - > get Current File Path ( ) ; $ this - > written File Paths [ ] = $ file Path ; if ( file _exists ( $ file Path ) ) { $ file Path = realpath ( $ file Path ) ; if ( is _writable ( $ file Path ) ) { unlink ( $ file Path ) ; } else { throw new \ Runtime Exception ( "File \ " $file Path \ " is not writable . " ) ; } } if ( $ this - > use Gzip ) { if ( function _exists ( 'deflate _init ' ) & & function _exists ( 'deflate _add ' ) ) { $ this - > writer Backend = new Deflate Writer ( $ file Path ) ; } else { $ this - > writer Backend = new Temp File GZIPWriter ( $ file Path ) ; } } else { $ this - > writer Backend = new Plain File Writer ( $ file Path ) ; } $ this - > writer = new XMLWriter ( ) ; $ this - > writer - > open Memory ( ) ; $ this - > writer - > start Document ( ' 1 . 0 ' , 'UTF - 8 ' ) ; $ this - > writer - > set Indent ( $ this - > use Indent ) ; $ this - > writer - > start Element ( 'urlset ' ) ; $ this - > writer - > write Attribute ( 'xmlns ' , 'http : / /www .sitemaps .org /schemas /sitemap / 0 . 9 ' ) ; if ( $ this - > use Xhtml ) { $ this - > writer - > write Attribute ( 'xmlns :xhtml ' , 'http : / /www .w 3 .org / 1 9 9 9 /xhtml ' ) ; } $ this - > writer - > text ( " \n " ) ; $ this - > flush ( true ) ; } 
private function finish File ( ) { if ( $ this - > writer ! = = null ) { $ this - > writer - > end Element ( ) ; $ this - > writer - > end Document ( ) ; $ this - > urls Count = 0 ; $ this - > flush ( 0 ) ; $ this - > writer Backend - > finish ( ) ; $ this - > writer Backend = null ; $ this - > byte Count = 0 ; } } 
private function flush ( $ foot Size = 1 0 ) { $ data = $ this - > writer - > flush ( true ) ; $ data Size = mb _strlen ( $ data , ' 8bit ' ) ; if ( $ this - > byte Count + $ data Size + $ foot Size > $ this - > max Bytes ) { if ( $ this - > urls Count < = 1 ) { throw new \ Overflow Exception ( 'The buffer size is too big for the defined file size limit ' ) ; } $ this - > finish File ( ) ; $ this - > create New File ( ) ; } $ this - > writer Backend - > append ( $ data ) ; $ this - > byte Count + = $ data Size ; } 
public function add Item ( $ location , $ last Modified = null , $ change Frequency = null , $ priority = null ) { if ( $ this - > urls Count > = $ this - > max Urls ) { $ this - > finish File ( ) ; } if ( $ this - > writer Backend = = = null ) { $ this - > create New File ( ) ; } if ( is _array ( $ location ) ) { $ this - > add Multi Language Item ( $ location , $ last Modified , $ change Frequency , $ priority ) ; } else { $ this - > add Single Language Item ( $ location , $ last Modified , $ change Frequency , $ priority ) ; } $ this - > urls Count + + ; if ( $ this - > urls Count % $ this - > buffer Size = = = 0 ) { $ this - > flush ( ) ; } } 
private function add Single Language Item ( $ location , $ last Modified , $ change Frequency , $ priority ) { $ this - > validate Location ( $ location ) ; $ this - > writer - > start Element ( 'url ' ) ; $ this - > writer - > write Element ( 'loc ' , $ location ) ; if ( $ last Modified ! = = null ) { $ this - > writer - > write Element ( 'lastmod ' , date ( 'c ' , $ last Modified ) ) ; } if ( $ change Frequency ! = = null ) { if ( ! in _array ( $ change Frequency , $ this - > valid Frequencies , true ) ) { throw new \ Invalid Argument Exception ( 'Please specify valid change Frequency . Valid values are : ' . implode ( ' , ' , $ this - > valid Frequencies ) . "You have specified : { $change Frequency } . " ) ; } $ this - > writer - > write Element ( 'changefreq ' , $ change Frequency ) ; } if ( $ priority ! = = null ) { if ( ! is _numeric ( $ priority ) | | $ priority < 0 | | $ priority > 1 ) { throw new \ Invalid Argument Exception ( "Please specify valid priority . Valid values range from 0 . 0 to 1 . 0 . You have specified : { $priority } . " ) ; } $ this - > writer - > write Element ( 'priority ' , number _format ( $ priority , 1 , ' . ' , ' , ' ) ) ; } $ this - > writer - > end Element ( ) ; } 
private function add Multi Language Item ( $ locations , $ last Modified , $ change Frequency , $ priority ) { foreach ( $ locations as $ language = > $ url ) { $ this - > validate Location ( $ url ) ; $ this - > writer - > start Element ( 'url ' ) ; $ this - > writer - > write Element ( 'loc ' , $ url ) ; if ( $ last Modified ! = = null ) { $ this - > writer - > write Element ( 'lastmod ' , date ( 'c ' , $ last Modified ) ) ; } if ( $ change Frequency ! = = null ) { if ( ! in _array ( $ change Frequency , $ this - > valid Frequencies , true ) ) { throw new \ Invalid Argument Exception ( 'Please specify valid change Frequency . Valid values are : ' . implode ( ' , ' , $ this - > valid Frequencies ) . "You have specified : { $change Frequency } . " ) ; } $ this - > writer - > write Element ( 'changefreq ' , $ change Frequency ) ; } if ( $ priority ! = = null ) { if ( ! is _numeric ( $ priority ) | | $ priority < 0 | | $ priority > 1 ) { throw new \ Invalid Argument Exception ( "Please specify valid priority . Valid values range from 0 . 0 to 1 . 0 . You have specified : { $priority } . " ) ; } $ this - > writer - > write Element ( 'priority ' , number _format ( $ priority , 1 , ' . ' , ' , ' ) ) ; } foreach ( $ locations as $ hreflang = > $ href ) { $ this - > writer - > start Element ( 'xhtml :link ' ) ; $ this - > writer - > start Attribute ( 'rel ' ) ; $ this - > writer - > text ( 'alternate ' ) ; $ this - > writer - > end Attribute ( ) ; $ this - > writer - > start Attribute ( 'hreflang ' ) ; $ this - > writer - > text ( $ hreflang ) ; $ this - > writer - > end Attribute ( ) ; $ this - > writer - > start Attribute ( 'href ' ) ; $ this - > writer - > text ( $ href ) ; $ this - > writer - > end Attribute ( ) ; $ this - > writer - > end Element ( ) ; } $ this - > writer - > end Element ( ) ; } } 
public function get Sitemap Urls ( $ base Url ) { $ urls = array ( ) ; foreach ( $ this - > written File Paths as $ file ) { $ urls [ ] = $ base Url . pathinfo ( $ file , PATHINFO _BASENAME ) ; } return $ urls ; } 
public function set Use Gzip ( $ value ) { if ( $ value & & ! extension _loaded ( 'zlib ' ) ) { throw new \ Runtime Exception ( 'Zlib extension must be enabled to gzip the sitemap . ' ) ; } if ( $ this - > writer Backend ! = = null & & $ value ! = $ this - > use Gzip ) { throw new \ Runtime Exception ( 'Cannot change the gzip value once items have been added to the sitemap . ' ) ; } $ this - > use Gzip = $ value ; } 
private function create New File ( ) { $ this - > writer = new XMLWriter ( ) ; $ this - > writer - > open Memory ( ) ; $ this - > writer - > start Document ( ' 1 . 0 ' , 'UTF - 8 ' ) ; $ this - > writer - > set Indent ( true ) ; $ this - > writer - > start Element ( 'sitemapindex ' ) ; $ this - > writer - > write Attribute ( 'xmlns ' , 'http : / /www .sitemaps .org /schemas /sitemap / 0 . 9 ' ) ; } 
public function add Sitemap ( $ location , $ last Modified = null ) { if ( false = = = filter _var ( $ location , FILTER _VALIDATE _URL ) ) { throw new \ Invalid Argument Exception ( "The location must be a valid URL . You have specified : { $location } . " ) ; } if ( $ this - > writer = = = null ) { $ this - > create New File ( ) ; } $ this - > writer - > start Element ( 'sitemap ' ) ; $ this - > writer - > write Element ( 'loc ' , $ location ) ; if ( $ last Modified ! = = null ) { $ this - > writer - > write Element ( 'lastmod ' , date ( 'c ' , $ last Modified ) ) ; } $ this - > writer - > end Element ( ) ; } 
public function write ( ) { if ( $ this - > writer instanceof XMLWriter ) { $ this - > writer - > end Element ( ) ; $ this - > writer - > end Document ( ) ; $ file Path = $ this - > get File Path ( ) ; if ( $ this - > use Gzip ) { $ file Path = 'compress .zlib : / / ' . $ file Path ; } file _put _contents ( $ file Path , $ this - > writer - > flush ( ) ) ; } } 
private function write ( $ data , $ flush Mode ) { assert ( $ this - > file ! = = null ) ; $ compressed Chunk = deflate _add ( $ this - > deflate Context , $ data , $ flush Mode ) ; fwrite ( $ this - > file , $ compressed Chunk ) ; } 
public function finish ( ) { $ this - > write ( ' ' , ZLIB _FINISH ) ; $ this - > file = null ; $ this - > deflate Context = null ; } 
public function append ( $ data ) { assert ( $ this - > temp File ! = = null ) ; fwrite ( $ this - > temp File , $ data ) ; } 
public function finish ( ) { assert ( $ this - > temp File ! = = null ) ; $ file = fopen ( 'compress .zlib : / / ' . $ this - > filename , 'wb ' ) ; rewind ( $ this - > temp File ) ; stream _copy _to _stream ( $ this - > temp File , $ file ) ; fclose ( $ file ) ; fclose ( $ this - > temp File ) ; $ this - > temp File = null ; } 
public function set Expiration Date ( $ date ) { if ( is _int ( $ date ) | | ctype _digit ( strval ( $ date ) ) ) { $ expiration Date = intval ( $ date ) ; } else { $ expiration Date = strtotime ( $ date ) ; } if ( $ expiration Date = = = false ) { throw new Invalid Argument Exception ( sprintf ( 'Invalid expiration date format : " %s " . Please use a ' . 'format compatible with PHP \ 's strtotime ( ) . ' , $ date ) ) ; } if ( $ expiration Date ! = = 0 & & $ expiration Date < time ( ) + 8 6 4 0 0 ) { throw new Invalid Argument Exception ( 'Expiration date must be at least a day in the future . ' ) ; } / / Gnu PG suffers from the 2 0 3 8 bug if ( $ expiration Date > 2 1 4 7 4 8 3 6 4 7 ) { throw new Invalid Argument Exception ( 'Expiration date must not be greater than 2 0 3 8 - 0 1 - 1 9T 0 3 : 1 4 : 0 7 . ' ) ; } $ this - > expiration Date = $ expiration Date ; return $ this ; } 
public function set Key Params ( $ algorithm , $ size = 0 , $ usage = 0 ) { $ algorithm = intval ( $ algorithm ) ; if ( $ algorithm = = = Crypt _GPG _Sub Key : : ALGORITHM _ELGAMAL _ENC ) { throw new Crypt _GPG _Invalid Key Params Exception ( 'Primary key algorithm must be capable of signing . The ' . 'Elgamal algorithm can only encrypt . ' , 0 , $ algorithm , $ size , $ usage ) ; } if ( $ size ! = 0 ) { $ size = intval ( $ size ) ; } if ( $ usage ! = 0 ) { $ usage = intval ( $ usage ) ; } $ usage Encrypt = Crypt _GPG _Sub Key : : USAGE _ENCRYPT ; if ( $ algorithm = = = Crypt _GPG _Sub Key : : ALGORITHM _DSA & & ( $ usage & $ usage Encrypt ) = = = $ usage Encrypt ) { throw new Crypt _GPG _Invalid Key Params Exception ( 'The DSA algorithm is not capable of encrypting . Please ' . 'specify a different algorithm or do not include encryption ' . 'as a usage for the primary key . ' , 0 , $ algorithm , $ size , $ usage ) ; } $ this - > key Algorithm = $ algorithm ; if ( $ size ! = 0 ) { $ this - > key Size = $ size ; } if ( $ usage ! = 0 ) { $ this - > key Usage = $ usage ; } return $ this ; } 
public function set Sub Key Params ( $ algorithm , $ size = ' ' , $ usage = 0 ) { $ algorithm = intval ( $ algorithm ) ; if ( $ size ! = 0 ) { $ size = intval ( $ size ) ; } if ( $ usage ! = 0 ) { $ usage = intval ( $ usage ) ; } $ usage Sign = Crypt _GPG _Sub Key : : USAGE _SIGN ; if ( $ algorithm = = = Crypt _GPG _Sub Key : : ALGORITHM _ELGAMAL _ENC & & ( $ usage & $ usage Sign ) = = = $ usage Sign ) { throw new Crypt _GPG _Invalid Key Params Exception ( 'The Elgamal algorithm is not capable of signing . Please ' . 'specify a different algorithm or do not include signing ' . 'as a usage for the sub -key . ' , 0 , $ algorithm , $ size , $ usage ) ; } $ usage Encrypt = Crypt _GPG _Sub Key : : USAGE _ENCRYPT ; if ( $ algorithm = = = Crypt _GPG _Sub Key : : ALGORITHM _DSA & & ( $ usage & $ usage Encrypt ) = = = $ usage Encrypt ) { throw new Crypt _GPG _Invalid Key Params Exception ( 'The DSA algorithm is not capable of encrypting . Please ' . 'specify a different algorithm or do not include encryption ' . 'as a usage for the sub -key . ' , 0 , $ algorithm , $ size , $ usage ) ; } $ this - > sub Key Algorithm = $ algorithm ; if ( $ size ! = 0 ) { $ this - > sub Key Size = $ size ; } if ( $ usage ! = 0 ) { $ this - > sub Key Usage = $ usage ; } return $ this ; } 
public function generate Key ( $ name , $ email = ' ' , $ comment = ' ' ) { $ handle = uniqid ( 'key ' , true ) ; $ user Id = $ this - > get User Id ( $ name , $ email , $ comment ) ; $ key Params = array ( 'Key -Type ' = > $ this - > key Algorithm , 'Key -Length ' = > $ this - > key Size , 'Key -Usage ' = > $ this - > get Usage ( $ this - > key Usage ) , 'Subkey -Type ' = > $ this - > sub Key Algorithm , 'Subkey -Length ' = > $ this - > sub Key Size , 'Subkey -Usage ' = > $ this - > get Usage ( $ this - > sub Key Usage ) , 'Name -Real ' = > $ user Id - > get Name ( ) , 'Handle ' = > $ handle , ) ; if ( $ this - > expiration Date ! = 0 ) { 
protected function get Usage ( $ usage ) { $ map = array ( Crypt _GPG _Sub Key : : USAGE _ENCRYPT = > 'encrypt ' , Crypt _GPG _Sub Key : : USAGE _SIGN = > 'sign ' , Crypt _GPG _Sub Key : : USAGE _CERTIFY = > 'cert ' , Crypt _GPG _Sub Key : : USAGE _AUTHENTICATION = > 'auth ' , ) ; 
protected function get User Id ( $ name , $ email = ' ' , $ comment = ' ' ) { if ( $ name instanceof Crypt _GPG _User Id ) { $ user Id = $ name ; } else { $ user Id = new Crypt _GPG _User Id ( ) ; $ user Id - > set Name ( $ name ) - > set Email ( $ email ) - > set Comment ( $ comment ) ; } return $ user Id ; } 
public static function parse ( $ string ) { $ user Id = new Crypt _GPG _User Id ( ) ; $ name = ' ' ; $ email = ' ' ; $ comment = ' ' ; 
public function is Running ( ) { $ running = false ; if ( function _exists ( 'posix _getpgid ' ) ) { $ running = false ! = = posix _getpgid ( $ this - > pid ) ; } elseif ( PHP _OS = = = 'WINNT ' ) { $ command = 'tasklist /fo csv /nh /fi ' . escapeshellarg ( 'PID eq ' . $ this - > pid ) ; $ result = exec ( $ command ) ; $ parts = explode ( ' , ' , $ result ) ; $ running = ( count ( $ parts ) > 1 & & trim ( $ parts [ 1 ] , ' " ' ) = = $ this - > pid ) ; } else { $ result = exec ( 'ps -p ' . escapeshellarg ( $ this - > pid ) . ' -o pid = ' ) ; $ running = ( trim ( $ result ) = = $ this - > pid ) ; } return $ running ; } 
public function terminate ( ) { if ( function _exists ( 'posix _kill ' ) ) { posix _kill ( $ this - > pid , 1 5 ) ; } elseif ( PHP _OS = = = 'WINNT ' ) { exec ( 'taskkill /PID ' . escapeshellarg ( $ this - > pid ) ) ; } else { exec ( 'kill - 1 5 ' . escapeshellarg ( $ this - > pid ) ) ; } } 
public function set Operation ( $ operation ) { $ op = null ; $ op Arg = null ; 
public function handle Status ( $ line ) { $ tokens = explode ( ' ' , $ line ) ; switch ( $ tokens [ 0 ] ) { case 'NODATA ' : $ this - > error Code = Crypt _GPG : : ERROR _NO _DATA ; break ; case 'DECRYPTION _OKAY ' : 
public function handle Error ( $ line ) { if ( stripos ( $ line , 'gpg : WARNING : ' ) ! = = false ) { $ this - > data [ 'Warnings ' ] [ ] = substr ( $ line , 1 4 ) ; } if ( $ this - > error Code ! = = Crypt _GPG : : ERROR _NONE ) { return ; } $ pattern = ' /no valid Open PGP data found / ' ; if ( preg _match ( $ pattern , $ line ) = = = 1 ) { $ this - > error Code = Crypt _GPG : : ERROR _NO _DATA ; return ; } $ pattern = ' /No secret key |secret key not available / ' ; if ( preg _match ( $ pattern , $ line ) = = = 1 ) { $ this - > error Code = Crypt _GPG : : ERROR _KEY _NOT _FOUND ; return ; } $ pattern = ' /No public key |public key not found / ' ; if ( preg _match ( $ pattern , $ line ) = = = 1 ) { $ this - > error Code = Crypt _GPG : : ERROR _KEY _NOT _FOUND ; return ; } $ pattern = ' /can \ 't ( ? :access |open ) ` ( . * ? ) \ ' / ' ; if ( preg _match ( $ pattern , $ line , $ matches ) = = = 1 ) { $ this - > data [ 'Error Filename ' ] = $ matches [ 1 ] ; $ this - > error Code = Crypt _GPG : : ERROR _FILE _PERMISSIONS ; return ; } 
public function throw Exception ( $ exitcode = 0 ) { if ( $ exitcode > 0 & & $ this - > error Code = = = Crypt _GPG : : ERROR _NONE ) { $ this - > error Code = $ this - > set Error Code ( $ exitcode ) ; } if ( $ this - > error Code = = = Crypt _GPG : : ERROR _NONE ) { return ; } $ code = $ this - > error Code ; $ note = "Please use the 'debug ' option when creating the Crypt _GPG " . "object , and file a bug report at " . Crypt _GPG : : BUG _URI ; switch ( $ this - > operation ) { case 'version ' : throw new Crypt _GPG _Exception ( 'Unknown error getting Gnu PG version information . ' . $ note , $ code ) ; case 'list -secret -keys ' : case 'list -public -keys ' : case 'list -keys ' : switch ( $ code ) { case Crypt _GPG : : ERROR _KEY _NOT _FOUND : 
protected function set Error Code ( $ exitcode ) { if ( $ this - > need Passphrase > 0 ) { return Crypt _GPG : : ERROR _MISSING _PASSPHRASE ; } if ( $ this - > operation = = 'import ' ) { return Crypt _GPG : : ERROR _NONE ; } if ( $ this - > operation = = 'decrypt ' & & ! empty ( $ this - > data [ 'Decryption Okay ' ] ) ) { if ( ! empty ( $ this - > data [ 'Ignore Verify Errors ' ] ) ) { return Crypt _GPG : : ERROR _NONE ; } if ( ! empty ( $ this - > data [ 'Missing Keys ' ] ) ) { return Crypt _GPG : : ERROR _KEY _NOT _FOUND ; } } return Crypt _GPG : : ERROR _UNKNOWN ; } 
public function set Data ( $ name , $ value ) { switch ( $ name ) { case 'Handle ' : $ this - > data [ $ name ] = strval ( $ value ) ; break ; case 'Ignore Verify Errors ' : $ this - > data [ $ name ] = ( bool ) $ value ; break ; } } 
protected function bad Pass Exception ( $ code , $ message ) { $ bad Passphrases = array _diff _key ( isset ( $ this - > data [ 'Bad Passphrases ' ] ) ? $ this - > data [ 'Bad Passphrases ' ] : array ( ) , isset ( $ this - > data [ 'Missing Passphrases ' ] ) ? $ this - > data [ 'Missing Passphrases ' ] : array ( ) ) ; $ missing Passphrases = array _intersect _key ( isset ( $ this - > data [ 'Bad Passphrases ' ] ) ? $ this - > data [ 'Bad Passphrases ' ] : array ( ) , isset ( $ this - > data [ 'Missing Passphrases ' ] ) ? $ this - > data [ 'Missing Passphrases ' ] : array ( ) ) ; if ( count ( $ bad Passphrases ) > 0 ) { $ message . = ' Incorrect passphrase provided for keys : " ' . implode ( ' " , " ' , $ bad Passphrases ) . ' " . ' ; } if ( count ( $ missing Passphrases ) > 0 ) { $ message . = ' No passphrase provided for keys : " ' . implode ( ' " , " ' , $ missing Passphrases ) . ' " . ' ; } return new Crypt _GPG _Bad Passphrase Exception ( $ message , $ code , $ bad Passphrases , $ missing Passphrases ) ; } 
protected function get Pin ( $ key ) { $ passphrase = ' ' ; $ key Id Length = mb _strlen ( $ key , ' 8bit ' ) ; if ( $ key Id Length & & ! empty ( $ _ENV [ 'PINENTRY _USER _DATA ' ] ) ) { $ passphrases = json _decode ( $ _ENV [ 'PINENTRY _USER _DATA ' ] , true ) ; foreach ( $ passphrases as $ _key Id = > $ pass ) { $ key Id = $ key ; $ _key Id Length = mb _strlen ( $ _key Id , ' 8bit ' ) ; 
public function get Hash Algorithm Name ( ) { if ( ! isset ( self : : $ hash Algorithm Names [ $ this - > hash Algorithm ] ) ) { return null ; } return self : : $ hash Algorithm Names [ $ this - > hash Algorithm ] ; } 
public function set Can Sign ( $ can Sign ) { if ( $ can Sign ) { $ this - > _usage | = self : : USAGE _SIGN ; } else { $ this - > _usage & = ~ self : : USAGE _SIGN ; } return $ this ; } 
public function set Can Encrypt ( $ can Encrypt ) { if ( $ can Encrypt ) { $ this - > _usage | = self : : USAGE _ENCRYPT ; } else { $ this - > _usage & = ~ self : : USAGE _ENCRYPT ; } return $ this ; } 
public static function parse ( $ string ) { $ tokens = explode ( ' : ' , $ string ) ; $ sub Key = new Crypt _GPG _Sub Key ( ) ; $ sub Key - > set Id ( $ tokens [ 4 ] ) ; $ sub Key - > set Length ( $ tokens [ 2 ] ) ; $ sub Key - > set Algorithm ( $ tokens [ 3 ] ) ; $ sub Key - > set Creation Date ( self : : _parse Date ( $ tokens [ 5 ] ) ) ; $ sub Key - > set Expiration Date ( self : : _parse Date ( $ tokens [ 6 ] ) ) ; if ( $ tokens [ 1 ] = = 'r ' ) { $ sub Key - > set Revoked ( true ) ; } $ usage = 0 ; $ usage _map = array ( 'a ' = > self : : USAGE _AUTHENTICATION , 'c ' = > self : : USAGE _CERTIFY , 'e ' = > self : : USAGE _ENCRYPT , 's ' = > self : : USAGE _SIGN , ) ; foreach ( $ usage _map as $ key = > $ flag ) { if ( strpos ( $ tokens [ 1 1 ] , $ key ) ! = = false ) { $ usage | = $ flag ; } } $ sub Key - > set Usage ( $ usage ) ; return $ sub Key ; } 
private static function _parse Date ( $ string ) { if ( $ string = = ' ' ) { $ timestamp = 0 ; } else { 
public function delete Public Key ( $ key Id ) { $ fingerprint = $ this - > get Fingerprint ( $ key Id ) ; if ( $ fingerprint = = = null ) { throw new Crypt _GPG _Key Not Found Exception ( 'Public key not found : ' . $ key Id , self : : ERROR _KEY _NOT _FOUND , $ key Id ) ; } $ operation = ' - -delete -key ' . escapeshellarg ( $ fingerprint ) ; $ arguments = array ( ' - -batch ' , ' - -yes ' ) ; $ this - > engine - > reset ( ) ; $ this - > engine - > set Operation ( $ operation , $ arguments ) ; $ this - > engine - > run ( ) ; } 
public function get Fingerprint ( $ key Id , $ format = self : : FORMAT _NONE ) { $ output = ' ' ; $ operation = ' - -list -keys ' . escapeshellarg ( $ key Id ) ; $ arguments = array ( ' - -with -colons ' , ' - -with -fingerprint ' ) ; $ this - > engine - > reset ( ) ; $ this - > engine - > set Output ( $ output ) ; $ this - > engine - > set Operation ( $ operation , $ arguments ) ; $ this - > engine - > run ( ) ; $ fingerprint = null ; foreach ( explode ( PHP _EOL , $ output ) as $ line ) { if ( mb _substr ( $ line , 0 , 3 , ' 8bit ' ) = = 'fpr ' ) { $ line Exp = explode ( ' : ' , $ line ) ; $ fingerprint = $ line Exp [ 9 ] ; switch ( $ format ) { case self : : FORMAT _CANONICAL : $ fingerprint Exp = str _split ( $ fingerprint , 4 ) ; $ format = ' %s %s %s %s %s %s %s %s %s %s ' ; $ fingerprint = vsprintf ( $ format , $ fingerprint Exp ) ; break ; case self : : FORMAT _X 5 0 9 : $ fingerprint Exp = str _split ( $ fingerprint , 2 ) ; $ fingerprint = implode ( ' : ' , $ fingerprint Exp ) ; break ; } break ; } } return $ fingerprint ; } 
public function encrypt ( $ data , $ armor = self : : ARMOR _ASCII ) { return $ this - > _encrypt ( $ data , false , null , $ armor ) ; } 
public function encrypt File ( $ filename , $ encrypted File = null , $ armor = self : : ARMOR _ASCII ) { return $ this - > _encrypt ( $ filename , true , $ encrypted File , $ armor ) ; } 
public function encrypt And Sign ( $ data , $ armor = self : : ARMOR _ASCII ) { return $ this - > _encrypt And Sign ( $ data , false , null , $ armor ) ; } 
public function encrypt And Sign File ( $ filename , $ signed File = null , $ armor = self : : ARMOR _ASCII ) { return $ this - > _encrypt And Sign ( $ filename , true , $ signed File , $ armor ) ; } 
public function decrypt And Verify ( $ encrypted Data , $ ignore Verify Errors = false ) { return $ this - > _decrypt And Verify ( $ encrypted Data , false , null , $ ignore Verify Errors ) ; } 
public function decrypt And Verify File ( $ encrypted File , $ decrypted File = null , $ ignore Verify Errors = false ) { return $ this - > _decrypt And Verify ( $ encrypted File , true , $ decrypted File , $ ignore Verify Errors ) ; } 
public function sign ( $ data , $ mode = self : : SIGN _MODE _NORMAL , $ armor = self : : ARMOR _ASCII , $ textmode = self : : TEXT _RAW ) { return $ this - > _sign ( $ data , false , null , $ mode , $ armor , $ textmode ) ; } 
public function sign File ( $ filename , $ signed File = null , $ mode = self : : SIGN _MODE _NORMAL , $ armor = self : : ARMOR _ASCII , $ textmode = self : : TEXT _RAW ) { return $ this - > _sign ( $ filename , true , $ signed File , $ mode , $ armor , $ textmode ) ; } 
public function add Decrypt Key ( $ key , $ passphrase = null ) { $ this - > _add Key ( $ this - > decrypt Keys , false , false , $ key , $ passphrase ) ; return $ this ; } 
public function add Encrypt Key ( $ key ) { $ this - > _add Key ( $ this - > encrypt Keys , true , false , $ key ) ; return $ this ; } 
public function add Sign Key ( $ key , $ passphrase = null ) { $ this - > _add Key ( $ this - > sign Keys , false , true , $ key , $ passphrase ) ; return $ this ; } 
protected function _add Key ( array & $ array , $ encrypt , $ sign , $ key , $ passphrase = null ) { $ sub Keys = array ( ) ; if ( is _scalar ( $ key ) ) { $ keys = $ this - > get Keys ( $ key ) ; if ( count ( $ keys ) = = 0 ) { throw new Crypt _GPG _Key Not Found Exception ( 'Key not found : ' . $ key , self : : ERROR _KEY _NOT _FOUND , $ key ) ; } $ key = $ keys [ 0 ] ; } if ( $ key instanceof Crypt _GPG _Key ) { if ( $ encrypt & & ! $ key - > can Encrypt ( ) ) { throw new Invalid Argument Exception ( 'Key " ' . $ key . ' " cannot encrypt . ' ) ; } if ( $ sign & & ! $ key - > can Sign ( ) ) { throw new Invalid Argument Exception ( 'Key " ' . $ key . ' " cannot sign . ' ) ; } foreach ( $ key - > get Sub Keys ( ) as $ sub Key ) { $ can Encrypt = $ sub Key - > can Encrypt ( ) ; $ can Sign = $ sub Key - > can Sign ( ) ; if ( ( $ encrypt & & $ sign & & $ can Encrypt & & $ can Sign ) | | ( $ encrypt & & ! $ sign & & $ can Encrypt ) | | ( ! $ encrypt & & $ sign & & $ can Sign ) | | ( ! $ encrypt & & ! $ sign ) ) { 
protected function _import Key ( $ key , $ is File ) { $ result = array ( ) ; $ arguments = array ( ) ; $ input = $ this - > _prepare Input ( $ key , $ is File , false ) ; $ version = $ this - > engine - > get Version ( ) ; if ( version _compare ( $ version , ' 1 . 0 . 5 ' , 'ge ' ) & & version _compare ( $ version , ' 1 . 0 . 7 ' , 'lt ' ) ) { $ arguments [ ] = ' - -allow -secret -key -import ' ; } if ( empty ( $ this - > passphrases ) ) { $ arguments [ ] = ' - -batch ' ; } $ this - > engine - > reset ( ) ; $ this - > engine - > set Pins ( $ this - > passphrases ) ; $ this - > engine - > set Operation ( ' - -import ' , $ arguments ) ; $ this - > engine - > set Input ( $ input ) ; $ this - > engine - > run ( ) ; return $ this - > engine - > get Process Data ( 'Import ' ) ; } 
protected function _export Key ( $ key Id , $ armor = true , $ private = false ) { $ fingerprint = $ this - > get Fingerprint ( $ key Id ) ; if ( $ fingerprint = = = null ) { throw new Crypt _GPG _Key Not Found Exception ( 'Key not found : ' . $ key Id , self : : ERROR _KEY _NOT _FOUND , $ key Id ) ; } $ key Data = ' ' ; $ operation = $ private ? ' - -export -secret -keys ' : ' - -export ' ; $ operation . = ' ' . escapeshellarg ( $ fingerprint ) ; $ arguments = $ armor ? array ( ' - -armor ' ) : array ( ) ; $ this - > engine - > reset ( ) ; $ this - > engine - > set Pins ( $ this - > passphrases ) ; $ this - > engine - > set Output ( $ key Data ) ; $ this - > engine - > set Operation ( $ operation , $ arguments ) ; $ this - > engine - > run ( ) ; return $ key Data ; } 
protected function _encrypt ( $ data , $ is File , $ output File , $ armor ) { if ( ! $ this - > has Encrypt Keys ( ) ) { throw new Crypt _GPG _Key Not Found Exception ( 'No encryption keys specified . ' ) ; } $ input = $ this - > _prepare Input ( $ data , $ is File ) ; $ output = $ this - > _prepare Output ( $ output File , $ input ) ; $ arguments = $ armor ? array ( ' - -armor ' ) : array ( ) ; foreach ( $ this - > encrypt Keys as $ key ) { $ arguments [ ] = ' - -recipient ' . escapeshellarg ( $ key [ 'fingerprint ' ] ) ; } $ this - > engine - > reset ( ) ; $ this - > engine - > set Input ( $ input ) ; $ this - > engine - > set Output ( $ output ) ; $ this - > engine - > set Operation ( ' - -encrypt ' , $ arguments ) ; $ this - > engine - > run ( ) ; if ( $ output File = = = null ) { return $ output ; } } 
protected function _decrypt ( $ data , $ is File , $ output File ) { $ input = $ this - > _prepare Input ( $ data , $ is File , false ) ; $ output = $ this - > _prepare Output ( $ output File , $ input ) ; $ this - > engine - > reset ( ) ; $ this - > engine - > set Pins ( $ this - > decrypt Keys ) ; $ this - > engine - > set Operation ( ' - -decrypt - -skip -verify ' ) ; $ this - > engine - > set Input ( $ input ) ; $ this - > engine - > set Output ( $ output ) ; $ this - > engine - > run ( ) ; if ( $ output File = = = null ) { return $ output ; } } 
protected function _sign ( $ data , $ is File , $ output File , $ mode , $ armor , $ textmode ) { if ( ! $ this - > has Sign Keys ( ) ) { throw new Crypt _GPG _Key Not Found Exception ( 'No signing keys specified . ' ) ; } $ input = $ this - > _prepare Input ( $ data , $ is File ) ; $ output = $ this - > _prepare Output ( $ output File , $ input ) ; switch ( $ mode ) { case self : : SIGN _MODE _DETACHED : $ operation = ' - -detach -sign ' ; break ; case self : : SIGN _MODE _CLEAR : $ operation = ' - -clearsign ' ; break ; case self : : SIGN _MODE _NORMAL : default : $ operation = ' - -sign ' ; break ; } $ arguments = array ( ) ; if ( $ armor ) { $ arguments [ ] = ' - -armor ' ; } if ( $ textmode ) { $ arguments [ ] = ' - -textmode ' ; } foreach ( $ this - > sign Keys as $ key ) { $ arguments [ ] = ' - -local -user ' . escapeshellarg ( $ key [ 'fingerprint ' ] ) ; } $ this - > engine - > reset ( ) ; $ this - > engine - > set Pins ( $ this - > sign Keys ) ; $ this - > engine - > set Input ( $ input ) ; $ this - > engine - > set Output ( $ output ) ; $ this - > engine - > set Operation ( $ operation , $ arguments ) ; $ this - > engine - > run ( ) ; if ( $ output File = = = null ) { return $ output ; } } 
protected function _verify ( $ data , $ is File , $ signature ) { if ( $ signature = = ' ' ) { $ operation = ' - -verify ' ; $ arguments = array ( ) ; } else { 
protected function _decrypt And Verify ( $ data , $ is File , $ output File , $ ignore Verify Errors = false ) { $ input = $ this - > _prepare Input ( $ data , $ is File , false ) ; $ output = $ this - > _prepare Output ( $ output File , $ input ) ; $ this - > engine - > reset ( ) ; $ this - > engine - > set Pins ( $ this - > decrypt Keys ) ; $ this - > engine - > set Input ( $ input ) ; $ this - > engine - > set Output ( $ output ) ; $ this - > engine - > set Operation ( ' - -decrypt ' ) ; $ this - > engine - > set Process Data ( 'Ignore Verify Errors ' , $ ignore Verify Errors ) ; $ this - > engine - > run ( ) ; $ return = array ( 'data ' = > null , 'signatures ' = > $ this - > engine - > get Process Data ( 'Signatures ' ) ) ; if ( $ output File = = = null ) { $ return [ 'data ' ] = $ output ; } return $ return ; } 
protected function _prepare Input ( $ data , $ is File = false , $ allow Empty = true ) { if ( $ is File ) { $ input = @ fopen ( $ data , 'rb ' ) ; if ( $ input = = = false ) { throw new Crypt _GPG _File Exception ( 'Could not open input file " ' . $ data . ' " ' , 0 , $ data ) ; } } else { $ input = strval ( $ data ) ; if ( ! $ allow Empty & & $ input = = = ' ' ) { throw new Crypt _GPG _No Data Exception ( 'No valid input data found . ' , self : : ERROR _NO _DATA ) ; } } return $ input ; } 
protected function _prepare Output ( $ output File , $ input = null ) { if ( $ output File = = = null ) { $ output = ' ' ; } else { $ output = @ fopen ( $ output File , 'wb ' ) ; if ( $ output = = = false ) { if ( is _resource ( $ input ) ) { fclose ( $ input ) ; } throw new Crypt _GPG _File Exception ( 'Could not open output file " ' . $ output File . ' " ' , 0 , $ output File ) ; } } return $ output ; } 
protected function _get Keys ( $ key Id = ' ' ) { 
public function send Command ( $ command ) { if ( array _key _exists ( self : : FD _COMMAND , $ this - > _open Pipes ) ) { $ this - > _command Buffer . = $ command . PHP _EOL ; } } 
public function reset ( ) { $ this - > _operation = ' ' ; $ this - > _arguments = array ( ) ; $ this - > _input = null ; $ this - > _message = null ; $ this - > _output = ' ' ; $ this - > _command Buffer = ' ' ; $ this - > _status Handlers = array ( ) ; $ this - > _error Handlers = array ( ) ; if ( $ this - > _debug ) { $ this - > add Status Handler ( array ( $ this , ' _handle Debug Status ' ) ) ; $ this - > add Error Handler ( array ( $ this , ' _handle Debug Error ' ) ) ; } $ this - > _process Handler = new Crypt _GPG _Process Handler ( $ this ) ; $ this - > add Status Handler ( array ( $ this - > _process Handler , 'handle Status ' ) ) ; $ this - > add Error Handler ( array ( $ this - > _process Handler , 'handle Error ' ) ) ; } 
public function run ( ) { if ( $ this - > _operation = = = ' ' ) { throw new Crypt _GPG _Invalid Operation Exception ( 'No GPG operation specified . Use Crypt _GPG _Engine : :set Operation ( ) ' . 'before calling Crypt _GPG _Engine : :run ( ) . ' ) ; } $ this - > _open Subprocess ( ) ; $ this - > _process ( ) ; $ this - > _close Subprocess ( ) ; } 
public function set Operation ( $ operation , array $ arguments = array ( ) ) { $ this - > _operation = $ operation ; $ this - > _arguments = $ arguments ; $ this - > _process Handler - > set Operation ( $ operation ) ; } 
public function set Pins ( array $ keys ) { $ env Keys = array ( ) ; foreach ( $ keys as $ key Id = > $ key ) { $ env Keys [ $ key Id ] = is _array ( $ key ) ? $ key [ 'passphrase ' ] : $ key ; } $ _ENV [ 'PINENTRY _USER _DATA ' ] = json _encode ( $ env Keys ) ; } 
public function get Version ( ) { if ( $ this - > _version = = ' ' ) { $ options = array ( 'homedir ' = > $ this - > _homedir , 'binary ' = > $ this - > _binary , 'debug ' = > $ this - > _debug , 'agent ' = > $ this - > _agent , ) ; $ engine = new self ( $ options ) ; $ info = ' ' ; 
public function get Process Data ( $ name ) { if ( $ this - > _process Handler ) { switch ( $ name ) { case 'Signature Info ' : if ( $ data = $ this - > _process Handler - > get Data ( 'Sig Created ' ) ) { return new Crypt _GPG _Signature Creation Info ( $ data ) ; } break ; case 'Signatures ' : case 'Warnings ' : return ( array ) $ this - > _process Handler - > get Data ( $ name ) ; default : return $ this - > _process Handler - > get Data ( $ name ) ; } } } 
public function set Process Data ( $ name , $ value ) { if ( $ this - > _process Handler ) { $ this - > _process Handler - > set Data ( $ name , $ value ) ; } } 
private function _process ( ) { $ this - > _debug ( 'BEGIN PROCESSING ' ) ; $ this - > _command Buffer = ' ' ; 
private function _open Subprocess ( ) { $ version = $ this - > get Version ( ) ; 
private function _close Subprocess ( ) { 
private function _close Agent Launch Process ( ) { if ( is _resource ( $ this - > _agent Process ) ) { $ this - > _debug ( 'CLOSING GPG -AGENT LAUNCH PROCESS ' ) ; 
private function _close Pipe ( $ pipe Number ) { $ pipe Number = intval ( $ pipe Number ) ; if ( array _key _exists ( $ pipe Number , $ this - > _open Pipes ) ) { fflush ( $ this - > _open Pipes [ $ pipe Number ] ) ; fclose ( $ this - > _open Pipes [ $ pipe Number ] ) ; unset ( $ this - > _open Pipes [ $ pipe Number ] ) ; } } 
private function _close Idle Agents ( ) { if ( $ this - > _gpgconf ) { 
private function _find Binary ( $ name ) { $ binary = ' ' ; if ( $ this - > _is Darwin ) { $ locations = array ( ' /opt /local /bin / ' , 
private function _get Pin Entry ( ) { 
private function _debug ( $ text ) { if ( $ this - > _debug ) { if ( php _sapi _name ( ) = = = 'cli ' ) { foreach ( explode ( PHP _EOL , $ text ) as $ line ) { echo "Crypt _GPG DEBUG : " , $ line , PHP _EOL ; } } else if ( is _callable ( $ this - > _debug ) ) { call _user _func ( $ this - > _debug , $ text ) ; } else { 
public function get Primary Key ( ) { $ primary _key = null ; if ( count ( $ this - > _sub Keys ) > 0 ) { $ primary _key = $ this - > _sub Keys [ 0 ] ; } return $ primary _key ; } 
public function can Sign ( ) { $ can Sign = false ; foreach ( $ this - > _sub Keys as $ sub Key ) { if ( $ sub Key - > can Sign ( ) ) { $ can Sign = true ; break ; } } return $ can Sign ; } 
public function can Encrypt ( ) { $ can Encrypt = false ; foreach ( $ this - > _sub Keys as $ sub Key ) { if ( $ sub Key - > can Encrypt ( ) ) { $ can Encrypt = true ; break ; } } return $ can Encrypt ; } 
public function set Log Filename ( $ filename ) { if ( is _resource ( $ this - > log File ) ) { fflush ( $ this - > log File ) ; fclose ( $ this - > log File ) ; $ this - > log File = null ; } if ( $ filename ! = ' ' ) { if ( ( $ this - > log File = fopen ( $ filename , 'w ' ) ) = = = false ) { $ this - > log ( 'Unable to open log file " ' . $ filename . ' " ' . 'for writing . ' . PHP _EOL , self : : VERBOSITY _ERRORS ) ; exit ( 1 ) ; } else { stream _set _write _buffer ( $ this - > log File , 0 ) ; } } return $ this ; } 
protected function log ( $ data , $ level ) { if ( $ this - > verbosity > = $ level ) { if ( is _resource ( $ this - > log File ) ) { fwrite ( $ this - > log File , $ data ) ; fflush ( $ this - > log File ) ; } else { $ this - > parser - > outputter - > stderr ( $ data ) ; } } return $ this ; } 
protected function connect ( ) { 
protected function parse Command ( $ line ) { $ this - > log ( ' < - ' . $ line . PHP _EOL , self : : VERBOSITY _ALL ) ; $ parts = explode ( ' ' , $ line , 2 ) ; $ command = $ parts [ 0 ] ; if ( count ( $ parts ) = = = 2 ) { $ data = $ parts [ 1 ] ; } else { $ data = null ; } switch ( $ command ) { case 'SETDESC ' : return $ this - > send Set Description ( $ data ) ; case 'MESSAGE ' : return $ this - > send Message ( ) ; case 'CONFIRM ' : return $ this - > send Confirm ( ) ; case 'GETINFO ' : return $ this - > send Get Info ( $ data ) ; case 'GETPIN ' : return $ this - > send Get Pin ( $ data ) ; case 'RESET ' : return $ this - > send Reset ( ) ; case 'BYE ' : return $ this - > send Bye ( ) ; default : return $ this - > send Not Implemented OK ( ) ; } } 
protected function init Pins From ENV ( ) { if ( ( $ user Data = getenv ( 'PINENTRY _USER _DATA ' ) ) ! = = false ) { $ pins = json _decode ( $ user Data , true ) ; if ( $ pins = = = null ) { $ this - > log ( ' - - failed to parse user data ' . PHP _EOL , self : : VERBOSITY _ERRORS ) ; } else { $ this - > pins = $ pins ; $ this - > log ( ' - - got user data [not showing passphrases ] ' . PHP _EOL , self : : VERBOSITY _ALL ) ; } } return $ this ; } 
protected function disconnect ( ) { $ this - > log ( ' - - disconnecting ' . PHP _EOL , self : : VERBOSITY _ALL ) ; fflush ( $ this - > stdout ) ; fclose ( $ this - > stdout ) ; fclose ( $ this - > stdin ) ; $ this - > stdin = null ; $ this - > stdout = null ; $ this - > log ( ' - - disconnected ' . PHP _EOL , self : : VERBOSITY _ALL ) ; if ( is _resource ( $ this - > log File ) ) { fflush ( $ this - > log File ) ; fclose ( $ this - > log File ) ; $ this - > log File = null ; } return $ this ; } 
protected function send Set Description ( $ text ) { $ text = rawurldecode ( $ text ) ; $ matches = array ( ) ; 
protected function send Get Pin ( ) { $ found Pin = ' ' ; if ( is _array ( $ this - > current Pin ) ) { $ key Id Length = mb _strlen ( $ this - > current Pin [ 'key Id ' ] , ' 8bit ' ) ; 
protected function send Get Info ( $ data ) { $ parts = explode ( ' ' , $ data , 2 ) ; $ command = reset ( $ parts ) ; switch ( $ command ) { case 'pid ' : return $ this - > send Get Info PID ( ) ; default : return $ this - > send ( $ this - > get OK ( ) ) ; } return $ this ; } 
protected function get Data ( $ data ) { 
protected function get Word Wrapped Data ( $ data , $ prefix ) { $ lines = array ( ) ; do { if ( mb _strlen ( $ data , ' 8bit ' ) > 9 9 7 ) { $ line = $ prefix . ' ' . mb _strcut ( $ data , 0 , 9 9 6 , 'utf - 8 ' ) . " \ \ \n " ; $ lines [ ] = $ line ; $ line Length = mb _strlen ( $ line , ' 8bit ' ) - 1 ; $ data Length = mb _substr ( $ data , ' 8bit ' ) ; $ data = mb _substr ( $ data , $ line Length , $ data Length - $ line Length , ' 8bit ' ) ; } else { $ lines [ ] = $ prefix . ' ' . $ data . " \n " ; $ data = ' ' ; } } while ( $ data ! = ' ' ) ; return implode ( ' ' , $ lines ) ; } 
protected function send ( $ data ) { $ this - > log ( ' - > ' . $ data , self : : VERBOSITY _ALL ) ; fwrite ( $ this - > stdout , $ data ) ; fflush ( $ this - > stdout ) ; return $ this ; } 
public function save Gettext Functions ( Translations $ translations , array $ options ) { $ functions = $ options [ 'functions ' ] ; $ file = $ options [ 'file ' ] ; foreach ( $ this - > get Functions ( $ options [ 'constants ' ] ) as $ function ) { list ( $ name , $ line , $ args ) = $ function ; if ( ! isset ( $ functions [ $ name ] ) ) { continue ; } $ context = null ; $ plural = null ; switch ( $ functions [ $ name ] ) { case 'text _domain ' : case 'gettext ' : list ( $ original , $ domain ) = array _pad ( $ args , 2 , null ) ; break ; case 'text _context _domain ' : list ( $ original , $ context , $ domain ) = array _pad ( $ args , 3 , null ) ; break ; case 'single _plural _number _domain ' : list ( $ original , $ plural , $ number , $ domain ) = array _pad ( $ args , 4 , null ) ; break ; case 'single _plural _number _context _domain ' : list ( $ original , $ plural , $ number , $ context , $ domain ) = array _pad ( $ args , 5 , null ) ; break ; case 'single _plural _domain ' : list ( $ original , $ plural , $ domain ) = array _pad ( $ args , 3 , null ) ; break ; case 'single _plural _context _domain ' : list ( $ original , $ plural , $ context , $ domain ) = array _pad ( $ args , 4 , null ) ; break ; default : 
public static function to String ( Translations $ translations , array $ options = [ ] ) { $ options + = static : : $ options ; $ domain = $ translations - > get Domain ( ) ? : 'messages ' ; $ messages = static : : build Messages ( $ translations ) ; $ configuration = [ ' ' = > [ 'domain ' = > $ domain , 'lang ' = > $ translations - > get Language ( ) ? : 'en ' , 'plural -forms ' = > $ translations - > get Header ( 'Plural -Forms ' ) ? : 'nplurals = 2 ; plural = (n ! = 1 ) ; ' , ] , ] ; $ data = [ 'translation -revision -date ' = > $ translations - > get Header ( 'PO -Revision -Date ' ) , 'generator ' = > 'WP -CLI / ' . WP _CLI _VERSION , 'source ' = > $ options [ 'source ' ] , 'domain ' = > $ domain , 'locale _data ' = > [ $ domain = > $ configuration + $ messages , ] , ] ; return json _encode ( $ data , $ options [ 'json ' ] ) ; } 
public static function build Messages ( Translations $ translations ) { $ plural _forms = $ translations - > get Plural Forms ( ) ; $ number _of _plurals = is _array ( $ plural _forms ) ? ( $ plural _forms [ 0 ] - 1 ) : null ; $ messages = [ ] ; $ context _glue = chr ( 4 ) ; foreach ( $ translations as $ translation ) { if ( $ translation - > is Disabled ( ) ) { continue ; } $ key = $ translation - > get Original ( ) ; if ( $ translation - > has Context ( ) ) { $ key = $ translation - > get Context ( ) . $ context _glue . $ key ; } if ( $ translation - > has Plural Translations ( true ) ) { $ message = $ translation - > get Plural Translations ( $ number _of _plurals ) ; array _unshift ( $ message , $ translation - > get Translation ( ) ) ; } else { $ message = [ $ translation - > get Translation ( ) ] ; } $ messages [ $ key ] = $ message ; } return $ messages ; } 
public static function from String ( $ string , Translations $ translations , array $ options = [ ] ) { if ( ! array _key _exists ( 'file ' , $ options ) | | substr ( $ options [ 'file ' ] , - 7 ) ! = = ' .js .map ' ) { return ; } $ options [ 'file ' ] = substr ( $ options [ 'file ' ] , 0 , - 7 ) . ' .js ' ; try { $ options + = static : : $ options ; $ map _object = json _decode ( $ string ) ; if ( ! isset ( $ map _object - > sources Content ) | | ! is _array ( $ map _object - > sources Content ) ) { return ; } $ string = implode ( " \n " , $ map _object - > sources Content ) ; $ functions = new Js Functions Scanner ( $ string ) ; $ functions - > enable Comments Extraction ( $ options [ 'extract Comments ' ] ) ; $ functions - > save Gettext Functions ( $ translations , $ options ) ; } catch ( Peast Exception $ e ) { WP _CLI : : debug ( sprintf ( 'Could not parse file % 1 $s .map : % 2 $s (line % 3 $d , column % 4 $d in the concatenated sources Content ) ' , $ options [ 'file ' ] , $ e - > get Message ( ) , $ e - > get Position ( ) - > get Line ( ) , $ e - > get Position ( ) - > get Column ( ) ) ) ; } } 
public static function from String ( $ string , Translations $ translations , array $ options = [ ] ) { try { $ options + = static : : $ options ; $ functions = new Js Functions Scanner ( $ string ) ; $ functions - > enable Comments Extraction ( $ options [ 'extract Comments ' ] ) ; $ functions - > save Gettext Functions ( $ translations , $ options ) ; } catch ( Peast Exception $ e ) { WP _CLI : : debug ( sprintf ( 'Could not parse file % 1 $s : % 2 $s (line % 3 $d , column % 4 $d ) ' , $ options [ 'file ' ] , $ e - > get Message ( ) , $ e - > get Position ( ) - > get Line ( ) , $ e - > get Position ( ) - > get Column ( ) ) ) ; } } 
public static function set Comment Before Headers ( $ comment ) { $ comments = explode ( " \n " , $ comment ) ; foreach ( $ comments as $ line ) { if ( ' ' ! = = trim ( $ line ) ) { static : : $ comments _before _headers [ ] = ' # ' . $ line ; } } } 
public static function to String ( Translations $ translations , array $ options = [ ] ) { $ lines = static : : $ comments _before _headers ; $ lines [ ] = 'msgid " " ' ; $ lines [ ] = 'msgstr " " ' ; $ plural _form = $ translations - > get Plural Forms ( ) ; $ plural _size = is _array ( $ plural _form ) ? ( $ plural _form [ 0 ] - 1 ) : 1 ; foreach ( $ translations - > get Headers ( ) as $ name = > $ value ) { $ lines [ ] = sprintf ( ' " %s : %s \ \n " ' , $ name , $ value ) ; } $ lines [ ] = ' ' ; foreach ( $ translations as $ translation ) { if ( $ translation - > has Comments ( ) ) { foreach ( $ translation - > get Comments ( ) as $ comment ) { $ lines [ ] = ' # ' . $ comment ; } } if ( $ translation - > has Extracted Comments ( ) ) { foreach ( $ translation - > get Extracted Comments ( ) as $ comment ) { $ lines [ ] = ' # . ' . $ comment ; } } foreach ( $ translation - > get References ( ) as $ reference ) { $ lines [ ] = ' # : ' . $ reference [ 0 ] . ( null ! = = $ reference [ 1 ] ? ' : ' . $ reference [ 1 ] : ' ' ) ; } if ( $ translation - > has Flags ( ) ) { $ lines [ ] = ' # , ' . implode ( ' , ' , $ translation - > get Flags ( ) ) ; } $ prefix = $ translation - > is Disabled ( ) ? ' # ~ ' : ' ' ; if ( $ translation - > has Context ( ) ) { $ lines [ ] = $ prefix . 'msgctxt ' . self : : convert String ( $ translation - > get Context ( ) ) ; } self : : add Lines ( $ lines , $ prefix . 'msgid ' , $ translation - > get Original ( ) ) ; if ( $ translation - > has Plural ( ) ) { self : : add Lines ( $ lines , $ prefix . 'msgid _plural ' , $ translation - > get Plural ( ) ) ; for ( $ i = 0 ; $ i < = $ plural _size ; $ i + + ) { self : : add Lines ( $ lines , $ prefix . 'msgstr [ ' . $ i . ' ] ' , ' ' ) ; } } else { self : : add Lines ( $ lines , $ prefix . 'msgstr ' , $ translation - > get Translation ( ) ) ; } $ lines [ ] = ' ' ; } return implode ( " \n " , $ lines ) ; } 
private static function add Lines ( array & $ lines , $ name , $ value ) { $ newlines = self : : multiline Quote ( $ value ) ; if ( count ( $ newlines ) = = = 1 ) { $ lines [ ] = $ name . ' ' . $ newlines [ 0 ] ; } else { $ lines [ ] = $ name . ' " " ' ; foreach ( $ newlines as $ line ) { $ lines [ ] = $ line ; } } } 
public function handle _arguments ( $ args , $ assoc _args ) { $ array _arguments = array ( 'headers ' ) ; $ assoc _args = Utils \ parse _shell _arrays ( $ assoc _args , $ array _arguments ) ; $ this - > source = realpath ( $ args [ 0 ] ) ; $ this - > slug = Utils \ get _flag _value ( $ assoc _args , 'slug ' , Utils \ basename ( $ this - > source ) ) ; $ this - > skip _js = Utils \ get _flag _value ( $ assoc _args , 'skip -js ' , $ this - > skip _js ) ; $ this - > skip _audit = Utils \ get _flag _value ( $ assoc _args , 'skip -audit ' , $ this - > skip _audit ) ; $ this - > headers = Utils \ get _flag _value ( $ assoc _args , 'headers ' , $ this - > headers ) ; $ this - > file _comment = Utils \ get _flag _value ( $ assoc _args , 'file -comment ' ) ; $ this - > package _name = Utils \ get _flag _value ( $ assoc _args , 'package -name ' ) ; $ ignore _domain = Utils \ get _flag _value ( $ assoc _args , 'ignore -domain ' , false ) ; if ( ! $ this - > source | | ! is _dir ( $ this - > source ) ) { WP _CLI : : error ( 'Not a valid source directory ! ' ) ; } $ this - > main _file _data = $ this - > get _main _file _data ( ) ; if ( $ ignore _domain ) { WP _CLI : : debug ( 'Extracting all strings regardless of text domain ' , 'make -pot ' ) ; } if ( ! $ ignore _domain ) { $ this - > domain = $ this - > slug ; if ( ! empty ( $ this - > main _file _data [ 'Text Domain ' ] ) ) { $ this - > domain = $ this - > main _file _data [ 'Text Domain ' ] ; } $ this - > domain = Utils \ get _flag _value ( $ assoc _args , 'domain ' , $ this - > domain ) ; WP _CLI : : debug ( sprintf ( 'Extracting all strings with text domain " %s " ' , $ this - > domain ) , 'make -pot ' ) ; } 
protected function get _main _file _data ( ) { $ files = new Iterator Iterator ( new Directory Iterator ( $ this - > source ) ) ; foreach ( $ files as $ file ) { 
protected function extract _strings ( ) { $ translations = new Translations ( ) ; 
protected function audit _strings ( $ translations ) { foreach ( $ translations as $ translation ) { $ references = $ translation - > get References ( ) ; 
protected function get _file _comment ( ) { if ( ' ' = = = $ this - > file _comment ) { return ' ' ; } if ( isset ( $ this - > file _comment ) ) { return implode ( " \n " , explode ( ' \n ' , $ this - > file _comment ) ) ; } if ( isset ( $ this - > main _file _data [ 'Theme Name ' ] ) ) { if ( isset ( $ this - > main _file _data [ 'License ' ] ) ) { return sprintf ( "Copyright (C ) % 1 \ $s % 2 \ $s \n This file is distributed under the % 3 \ $s . " , date ( 'Y ' ) , $ this - > main _file _data [ 'Author ' ] , $ this - > main _file _data [ 'License ' ] ) ; } return sprintf ( "Copyright (C ) % 1 \ $s % 2 \ $s \n This file is distributed under the same license as the % 3 \ $s theme . " , date ( 'Y ' ) , $ this - > main _file _data [ 'Author ' ] , $ this - > main _file _data [ 'Theme Name ' ] ) ; } if ( isset ( $ this - > main _file _data [ 'Plugin Name ' ] ) ) { if ( isset ( $ this - > main _file _data [ 'License ' ] ) ) { return sprintf ( "Copyright (C ) % 1 \ $s % 2 \ $s \n This file is distributed under the % 3 \ $s . " , date ( 'Y ' ) , $ this - > main _file _data [ 'Author ' ] , $ this - > main _file _data [ 'License ' ] ) ; } return sprintf ( "Copyright (C ) % 1 \ $s % 2 \ $s \n This file is distributed under the same license as the % 3 \ $s plugin . " , date ( 'Y ' ) , $ this - > main _file _data [ 'Author ' ] , $ this - > main _file _data [ 'Plugin Name ' ] ) ; } return ' ' ; } 
protected function set _default _headers ( $ translations ) { $ name = null ; $ version = $ this - > get _wp _version ( ) ; $ bugs _address = null ; if ( ! $ version & & isset ( $ this - > main _file _data [ 'Version ' ] ) ) { $ version = $ this - > main _file _data [ 'Version ' ] ; } if ( isset ( $ this - > main _file _data [ 'Theme Name ' ] ) ) { $ name = $ this - > main _file _data [ 'Theme Name ' ] ; $ bugs _address = sprintf ( 'https : / /wordpress .org /support /theme / %s ' , $ this - > slug ) ; } elseif ( isset ( $ this - > main _file _data [ 'Plugin Name ' ] ) ) { $ name = $ this - > main _file _data [ 'Plugin Name ' ] ; $ bugs _address = sprintf ( 'https : / /wordpress .org /support /plugin / %s ' , $ this - > slug ) ; } if ( null ! = = $ this - > package _name ) { $ name = $ this - > package _name ; } if ( null ! = = $ name ) { $ translations - > set Header ( 'Project -Id -Version ' , $ name . ( $ version ? ' ' . $ version : ' ' ) ) ; } if ( null ! = = $ bugs _address ) { $ translations - > set Header ( 'Report -Msgid -Bugs -To ' , $ bugs _address ) ; } $ translations - > set Header ( 'Last -Translator ' , 'FULL NAME <EMAIL @ADDRESS > ' ) ; $ translations - > set Header ( 'Language -Team ' , 'LANGUAGE <LL @li .org > ' ) ; $ translations - > set Header ( 'X -Generator ' , 'WP -CLI ' . WP _CLI _VERSION ) ; foreach ( $ this - > headers as $ key = > $ value ) { $ translations - > set Header ( $ key , $ value ) ; } } 
private function get _wp _version ( ) { $ version _php = $ this - > source . ' /wp -includes /version .php ' ; if ( ! file _exists ( $ version _php ) | | ! is _readable ( $ version _php ) ) { return false ; } return preg _match ( ' / \ $wp _version \s * = \s * \ ' ( . * ? ) \ ' ; / ' , file _get _contents ( $ version _php ) , $ matches ) ? $ matches [ 1 ] : false ; } 
protected static function get _file _data ( $ file , $ headers ) { 
public static function get _file _data _from _string ( $ string , $ headers ) { foreach ( $ headers as $ field = > $ regex ) { if ( preg _match ( ' / ^ [ \t \ / * # @ ] * ' . preg _quote ( $ regex , ' / ' ) . ' : ( . * ) $ /mi ' , $ string , $ match ) & & $ match [ 1 ] ) { $ headers [ $ field ] = static : : _cleanup _header _comment ( $ match [ 1 ] ) ; } else { $ headers [ $ field ] = ' ' ; } } return $ headers ; } 
public function save Gettext Functions ( Translations $ translations , array $ options ) { * Traverse through JS code to find and extract gettext functions . * * Make sure translator comments in front of variable declarations * and inside nested call expressions are available when parsing the function call . * / $ traverser - > add Function ( function ( $ node ) use ( & $ translations , $ options , & $ all _comments ) { $ functions = $ options [ 'functions ' ] ; $ file = $ options [ 'file ' ] ; foreach ( $ node - > get Leading Comments ( ) as $ comment ) { $ all _comments [ ] = $ comment ; } if ( 'Call Expression ' ! = = $ node - > get Type ( ) ) { return ; } $ callee = $ this - > resolve Expression Callee ( $ node ) ; if ( ! $ callee | | ! isset ( $ functions [ $ callee [ 'name ' ] ] ) ) { return ; } foreach ( $ node - > get Arguments ( ) as $ argument ) { 
private function resolve Expression Callee ( Node \ Call Expression $ node ) { $ callee = $ node - > get Callee ( ) ; 
private function comment Precedes Node ( Node \ Comment $ comment , Node \ Node $ node ) { 
public static function from File ( $ file , Translations $ translations , array $ options = [ ] ) { foreach ( static : : get Files ( $ file ) as $ f ) { 
public static function from Directory ( $ dir , Translations $ translations , array $ options = [ ] ) { $ dir = Utils \ normalize _path ( $ dir ) ; static : : $ dir = $ dir ; $ include = isset ( $ options [ 'include ' ] ) ? $ options [ 'include ' ] : [ ] ; $ exclude = isset ( $ options [ 'exclude ' ] ) ? $ options [ 'exclude ' ] : [ ] ; $ files = static : : get Files From Directory ( $ dir , $ include , $ exclude , $ options [ 'extensions ' ] ) ; if ( ! empty ( $ files ) ) { static : : from File ( $ files , $ translations , $ options ) ; } static : : $ dir = ' ' ; } 
protected static function calculate Match Score ( Spl File Info $ file , array $ matchers = [ ] ) { if ( empty ( $ matchers ) ) { return 0 ; } if ( in _array ( $ file - > get Basename ( ) , $ matchers , true ) ) { return 1 0 ; } 
protected static function contains Matching Children ( Spl File Info $ dir , array $ matchers = [ ] ) { if ( empty ( $ matchers ) ) { return false ; } $ root _relative _path = str _replace ( static : : $ dir , ' ' , $ dir - > get Pathname ( ) ) ; foreach ( $ matchers as $ path _or _file ) { 
public static function get Files From Directory ( $ dir , array $ include = [ ] , array $ exclude = [ ] , $ extensions = [ ] ) { $ filtered _files = [ ] ; $ files = new Recursive Iterator Iterator ( new Recursive Callback Filter Iterator ( new Recursive Directory Iterator ( $ dir , Recursive Directory Iterator : : SKIP _DOTS | Recursive Directory Iterator : : UNIX _PATHS ) , function ( $ file , $ key , $ iterator ) use ( $ include , $ exclude , $ extensions ) { 
protected function make _json ( $ source _file , $ destination ) { $ mapping = [ ] ; $ translations = new Translations ( ) ; $ result = [ ] ; Po Extractor : : from File ( $ source _file , $ translations ) ; $ base _file _name = basename ( $ source _file , ' .po ' ) ; foreach ( $ translations as $ index = > $ translation ) { 
protected function build _json _files ( $ mapping , $ base _file _name , $ destination ) { $ result = [ ] ; foreach ( $ mapping as $ file = > $ translations ) { $ hash = md 5 ( $ file ) ; $ destination _file = " $ {destination } / { $base _file _name } - { $hash } .json " ; $ success = Jed Generator : : to File ( $ translations , $ destination _file , [ 'json ' = > $ this - > json _options , 'source ' = > $ file , ] ) ; if ( ! $ success ) { WP _CLI : : warning ( sprintf ( 'Could not create file %s ' , basename ( $ destination _file , ' .json ' ) ) ) ; continue ; } $ result [ ] = $ destination _file ; } return $ result ; } 
protected function remove _js _strings _from _po _file ( $ source _file ) { $ translations = new Translations ( ) ; Po Extractor : : from File ( $ source _file , $ translations ) ; foreach ( $ translations - > get Array Copy ( ) as $ translation ) { if ( ! $ translation - > has References ( ) ) { continue ; } foreach ( $ translation - > get References ( ) as $ reference ) { $ file = $ reference [ 0 ] ; if ( substr ( $ file , - 3 ) ! = = ' .js ' ) { continue 2 ; } } unset ( $ translations [ $ translation - > get Id ( ) ] ) ; } return Po Generator : : to File ( $ translations , $ source _file ) ; } 
public function block Form ( $ form , Form State Interface $ form _state ) { $ form [ 'button _text ' ] = [ ' #type ' = > 'textfield ' , ' #title ' = > t ( 'Button text ' ) , ' #default _value ' = > $ this - > configuration [ 'button _text ' ] ? ? 'Reset Filters ' , ] ; $ form [ 'button _class ' ] = [ ' #type ' = > 'textfield ' , ' #title ' = > t ( 'Button class ' ) , ' #default _value ' = > $ this - > configuration [ 'button _class ' ] ? ? 'btn btn -outline -primary btn -sm btn -reset ' , ] ; $ form [ 'button _target ' ] = [ ' #type ' = > 'textfield ' , ' #title ' = > t ( 'Button target ' ) , ' #default _value ' = > $ this - > configuration [ 'button _target ' ] ? ? ' /products ' , ] ; $ form [ 'button _icon _class ' ] = [ ' #type ' = > 'textfield ' , ' #title ' = > t ( 'Button icon class ' ) , ' #default _value ' = > $ this - > configuration [ 'button _icon _class ' ] ? ? 'fas fa -times ' , ] ; return $ form ; } 
public function block Submit ( $ form , Form State Interface $ form State ) { $ this - > configuration [ 'button _text ' ] = $ form State - > get Value ( 'button _text ' ) ; $ this - > configuration [ 'button _class ' ] = $ form State - > get Value ( 'button _class ' ) ; $ this - > configuration [ 'button _target ' ] = ' / ' . ltrim ( $ form State - > get Value ( 'button _target ' ) , ' / ' ) ; $ this - > configuration [ 'button _icon _class ' ] = $ form State - > get Value ( 'button _icon _class ' ) ; } 
public function build ( ) { if ( ! isset ( $ _REQUEST [ 'f ' ] ) ) { return [ ' #markup ' = > ' ' , ' #cache ' = > [ 'contexts ' = > [ 'url .query _args :f ' ] , ] , ] ; } $ link _content _markups = [ ] ; if ( ! empty ( $ this - > configuration [ 'button _icon _class ' ] ) ) { $ link _content _markups [ ] = [ ' #type ' = > 'html _tag ' , ' #tag ' = > 'span ' , ' #attributes ' = > [ 'class ' = > $ this - > configuration [ 'button _icon _class ' ] , ] , ] ; } $ link _content _markups [ ] = [ ' #markup ' = > $ this - > t ( $ this - > configuration [ 'button _text ' ] ) , ] ; return [ [ ' #type ' = > 'link ' , ' #title ' = > $ link _content _markups , ' #attributes ' = > [ 'class ' = > $ this - > configuration [ 'button _class ' ] , 'target ' = > ' _self ' , ] , ' #url ' = > URL : : from User Input ( $ this - > configuration [ 'button _target ' ] ) , ' #cache ' = > [ 'contexts ' = > [ 'url .query _args :f ' ] , ] , ] , ] ; } 
public function build Form ( array $ form , Form State Interface $ form _state ) { if ( empty ( $ this - > paragraph ) ) { return $ form ; } $ form [ 'name ' ] = [ ' #type ' = > 'textfield ' , ' #title _display ' = > 'invisible ' , ' #title ' = > $ this - > t ( 'Name ' ) , ' #required ' = > TRUE , ' #attributes ' = > [ 'placeholder ' = > $ this - > t ( 'Enter your name ' ) ] , ] ; $ form [ 'mail ' ] = [ ' #type ' = > 'email ' , ' #title _display ' = > 'invisible ' , ' #title ' = > $ this - > t ( 'E -mail ' ) , ' #required ' = > TRUE , ' #attributes ' = > [ 'placeholder ' = > $ this - > t ( 'Enter you email to get download link ' ) ] , ] ; $ file = $ this - > paragraph - > get ( 'field _file _download ' ) - > get Value ( ) ; $ form [ 'file _id ' ] = [ ' #type ' = > 'value ' , ' #value ' = > $ file [ 0 ] [ 'target _id ' ] ] ; $ form [ 'submit ' ] = [ ' #type ' = > 'submit ' , ' #value ' = > $ this - > paragraph - > get ( 'field _d _p _sf _download _button ' ) - > value , ] ; 
public function submit Form ( array & $ form , Form State Interface $ form _state ) { 
public function block Submit ( $ form , Form State Interface $ form State ) { $ this - > configuration [ 'button _text ' ] = $ form State - > get Value ( 'button _text ' ) ; $ this - > configuration [ 'button _class ' ] = $ form State - > get Value ( 'button _class ' ) ; } 
public function mark Updates Successful ( array $ names , $ check List Points = TRUE ) { if ( $ this - > update Checklist = = = FALSE ) { return ; } $ this - > set Successful By Hook ( $ names , TRUE ) ; if ( $ check List Points ) { $ this - > check List Points ( $ names ) ; } } 
public function mark All Updates ( $ status = TRUE ) { if ( $ this - > update Checklist = = = FALSE ) { return ; } $ keys = [ ] ; foreach ( $ this - > update Checklist - > items as $ version Items ) { foreach ( $ version Items as $ key = > $ item ) { if ( is _array ( $ item ) ) { $ keys [ ] = $ key ; } } } $ this - > set Successful By Hook ( $ keys , $ status ) ; $ this - > check All List Points ( $ status ) ; } 
protected function set Successful By Hook ( array $ keys , $ status = TRUE ) { foreach ( $ keys as $ key ) { if ( $ update = Update : : load ( $ key ) ) { $ update - > set Successful By Hook ( $ status ) - > save ( ) ; } else { Update : : create ( [ 'id ' = > $ key , 'successful _by _hook ' = > $ status , ] ) - > save ( ) ; } } } 
protected function check List Points ( array $ names ) { $ droopler Update Config = $ this - > config Factory - > get Editable ( 'checklistapi .progress .d _update ' ) ; $ user = $ this - > account - > id ( ) ; $ time = time ( ) ; foreach ( $ names as $ name ) { if ( $ droopler Update Config & & ! $ droopler Update Config - > get ( Checklistapi Checklist : : PROGRESS _CONFIG _KEY . " . #items . $name " ) ) { $ droopler Update Config - > set ( Checklistapi Checklist : : PROGRESS _CONFIG _KEY . " . #items . $name " , [ ' #completed ' = > time ( ) , ' #uid ' = > $ user , ] ) ; } } $ droopler Update Config - > set ( Checklistapi Checklist : : PROGRESS _CONFIG _KEY . ' . #completed _items ' , count ( $ droopler Update Config - > get ( Checklistapi Checklist : : PROGRESS _CONFIG _KEY . " . #items " ) ) ) - > set ( Checklistapi Checklist : : PROGRESS _CONFIG _KEY . ' . #changed ' , $ time ) - > set ( Checklistapi Checklist : : PROGRESS _CONFIG _KEY . ' . #changed _by ' , $ user ) - > save ( ) ; } 
protected function check All List Points ( $ status = TRUE ) { $ droopler Update Config = $ this - > config Factory - > get Editable ( 'checklistapi .progress .d _update ' ) ; $ user = $ this - > account - > id ( ) ; $ time = time ( ) ; $ droopler Update Config - > set ( Checklistapi Checklist : : PROGRESS _CONFIG _KEY . ' . #changed ' , $ time ) - > set ( Checklistapi Checklist : : PROGRESS _CONFIG _KEY . ' . #changed _by ' , $ user ) ; $ exclude = [ ' #title ' , ' #description ' , ' #weight ' , ] ; foreach ( $ this - > update Checklist - > items as $ version Items ) { foreach ( $ version Items as $ item Name = > $ item ) { if ( ! in _array ( $ item Name , $ exclude ) ) { if ( $ status ) { $ droopler Update Config - > set ( Checklistapi Checklist : : PROGRESS _CONFIG _KEY . " . #items . $item Name " , [ ' #completed ' = > $ time , ' #uid ' = > $ user , ] ) ; } else { $ droopler Update Config - > clear ( Checklistapi Checklist : : PROGRESS _CONFIG _KEY . " . #items . $item Name " ) ; } } } } $ droopler Update Config - > set ( Checklistapi Checklist : : PROGRESS _CONFIG _KEY . ' . #completed _items ' , count ( $ droopler Update Config - > get ( Checklistapi Checklist : : PROGRESS _CONFIG _KEY . " . #items " ) ) ) - > save ( ) ; } 
public function save Progress ( array $ values ) { $ user = \ Drupal : : current User ( ) ; $ time = time ( ) ; $ num _changed _items = 0 ; $ progress = [ ' #changed ' = > $ time , ' #changed _by ' = > $ user - > id ( ) , ' #completed _items ' = > 0 , ' #items ' = > [ ] , ] ; $ status = [ 'positive ' = > [ ] , 'negative ' = > [ ] , ] ; $ droopler Update Config = $ this - > config Factory - > get Editable ( 'checklistapi .progress .d _update ' ) ; $ saved Progress = $ droopler Update Config - > get ( Checklistapi Checklist : : PROGRESS _CONFIG _KEY ) ; foreach ( $ values as $ group _key = > $ group ) { foreach ( $ group as $ item _key = > $ item ) { $ old _item = ( ! empty ( $ saved Progress [ ' #items ' ] [ $ item _key ] ) ) ? $ saved Progress [ ' #items ' ] [ $ item _key ] : 0 ; if ( $ item ) { 
public function get Changed Time Across Translations ( ) { $ changed = $ this - > get Untranslated ( ) - > get Changed Time ( ) ; foreach ( $ this - > get Translation Languages ( FALSE ) as $ language ) { $ translation _changed = $ this - > get Translation ( $ language - > get Id ( ) ) - > get Changed Time ( ) ; $ changed = max ( $ translation _changed , $ changed ) ; } return $ changed ; } 
public function render ( ) { $ output = ' <h 3 > ' . t ( 'Droopler is a Drupal 8 profile designed to kickstart a new webpage in a few minutes ' ) . ' < /h 3 > ' ; $ output . = ' <p > ' . t ( 'More info about Droopler - <a href = " :link " >See official Droopler website < /a > . ' , [ ' :link ' = > 'https : / /droopler .com / ' ] ) . ' < /p > ' ; $ output . = ' <h 3 > ' . t ( 'Support ' ) . ' < /h 3 > ' ; $ output . = ' <p > ' . t ( 'Do You need support with Droopler ? - <a href = " :link " >Droptica .com < /a > . ' , [ ' :link ' = > 'https : / /droptica .com ' ] ) . ' < /p > ' ; $ output . = ' <h 3 > ' . t ( 'Github ' ) . ' < /h 3 > ' ; $ output . = ' <p > ' . t ( ' <a href = " :link " >https : / /github .com /droptica /droopler _project < /a > - Boilerplate for new projects based on Droopler . If you wish to use Droopler - fork (or download ) this repository . It contains a minimum set of code to start your new website . ' , [ ' :link ' = > 'https : / /github .com /droptica /droopler _project ' ] ) . ' < /p > ' ; $ output . = ' <p > ' . t ( ' <a href = " :link " >https : / /github .com /droptica /droopler < /a > - This is Drupal installation profile . ' , [ ' :link ' = > 'https : / /github .com /droptica /droopler ' ] ) . ' < /p > ' ; return [ ' #type ' = > 'markup ' , ' #markup ' = > ' <div class = "container " > ' . $ output . ' < /div > ' , ] ; } 
public function generate Hash From Database ( $ config Name ) { $ config = \ Drupal : : config ( $ config Name ) - > get Raw Data ( ) ; if ( empty ( $ config ) ) { return FALSE ; } unset ( $ config [ 'uuid ' ] ) ; unset ( $ config [ 'lang ' ] ) ; unset ( $ config [ 'langcode ' ] ) ; $ config String = serialize ( $ config ) ; return md 5 ( $ config String ) ; } 
public function compare ( $ config Name , $ hash = NULL ) { if ( empty ( $ hash ) ) { return TRUE ; } else { return $ this - > generate Hash From Database ( $ config Name ) = = $ hash ; } } 
public function import Config ( $ module , $ name , $ hash ) { $ config Path = drupal _get _path ( 'module ' , $ module ) . ' /config /install ' ; $ source = new File Storage ( $ config Path ) ; $ data = $ source - > read ( $ name ) ; if ( ! $ data | | ! $ this - > config Manager - > compare ( $ name , $ hash ) ) { return false ; } return $ this - > config Storage - > write ( $ name , $ data ) ; } 
public function import Configs ( array $ configs ) { $ status = [ ] ; foreach ( $ configs as $ module = > $ config ) { foreach ( $ config as $ config Name = > $ config Hash ) { $ status [ ] = $ this - > import Config ( $ module , $ config Name , $ config Hash ) ; } } return ! in _array ( false , $ status ) ; } 
public function install Modules ( array $ modules , $ enable Dependencies = TRUE ) { if ( empty ( $ modules ) | | ! is _array ( $ modules ) ) { return FALSE ; } $ module Data = system _rebuild _module _data ( ) ; $ modules = array _combine ( $ modules , $ modules ) ; if ( $ missing _modules = array _diff _key ( $ modules , $ module Data ) ) { return FALSE ; } return $ this - > module Installer - > install ( $ modules , $ enable Dependencies ) ; } 
public function check Link ( $ link _hash , $ paragraph _id ) { 
private function get Subscribe File Entity ( $ field _name , $ field _value ) { $ subscribe _file _entity = \ Drupal : : entity Type Manager ( ) - > get Storage ( 'Subscribe File Entity ' ) - > load By Properties ( [ $ field _name = > $ field _value ] ) ; if ( empty ( $ subscribe _file _entity ) ) { throw new Not Found Http Exception ( ) ; } return reset ( $ subscribe _file _entity ) ; } 
private function check Link Active ( $ entity ) { $ created = $ entity - > get ( 'created ' ) - > get ( 0 ) - > get Value ( ) ; if ( time ( ) > $ created [ 'value ' ] + 8 6 4 0 0 ) { $ this - > go Home With Message ( t ( 'Link is not active , please add your email again ' ) ) ; } } 
private function go Home With Message ( $ message ) { drupal _set _message ( $ message ) ; $ url = Url : : from Route ( ' <front > ' ) ; $ response = new Redirect Response ( $ url - > to String ( ) ) ; $ response - > send ( ) ; } 
public function get File ( $ file _hash ) { $ entity = $ this - > get Subscribe File Entity ( 'file _hash ' , $ file _hash ) ; $ this - > check Link Active ( $ entity ) ; $ file = File : : load ( $ entity - > get ( 'fid ' ) - > get Value ( ) [ 0 ] [ 'value ' ] ) ; $ uri = $ file - > get File Uri ( ) ; $ response = new Binary File Response ( $ uri ) ; $ response - > set Content Disposition ( Response Header Bag : : DISPOSITION _ATTACHMENT ) ; return $ response ; } 
public function process ( Container Builder $ container ) { if ( ! $ container - > has Definition ( 'apy _grid .registry ' ) ) { return ; } $ definition = $ container - > get Definition ( 'apy _grid .registry ' ) ; $ types = $ container - > find Tagged Service Ids ( 'apy _grid .type ' ) ; foreach ( $ types as $ id = > $ tag ) { $ definition - > add Method Call ( 'add Type ' , [ new Reference ( $ id ) ] ) ; } $ columns = $ container - > find Tagged Service Ids ( 'apy _grid .column ' ) ; foreach ( $ columns as $ id = > $ tag ) { $ definition - > add Method Call ( 'add Column ' , [ new Reference ( $ id ) ] ) ; } } 
public function get Columns From Mapping ( $ column Extensions ) { $ columns = new \ Spl Object Storage ( ) ; foreach ( $ this - > get Fields ( ) as $ value ) { $ params = $ this - > get Field Mapping ( $ value ) ; $ type = $ this - > get Field Mapping Type ( $ value ) ; if ( $ column Extensions - > has Extension For Column Type ( $ type ) ) { $ column = clone $ column Extensions - > get Extension For Column Type ( $ type ) ; $ column - > _ _initialize ( $ params ) ; $ columns - > attach ( $ column ) ; } else { throw new \ Exception ( sprintf ( 'No suitable Column Extension found for column type : %s ' , $ type ) ) ; } } return $ columns ; } 
public function prepare Row ( $ row ) { if ( is _callable ( $ this - > prepare Row Callback ) ) { return call _user _func ( $ this - > prepare Row Callback , $ row ) ; } return $ row ; } 
protected function get Items From Data ( $ columns ) { $ items = [ ] ; foreach ( $ this - > data as $ key = > $ item ) { foreach ( $ columns as $ column ) { $ field Name = $ column - > get Field ( ) ; $ field Value = ' ' ; if ( $ this instanceof Entity ) { 
public function execute From Data ( $ columns , $ page = 0 , $ limit = 0 , $ max Results = null ) { 
public function get Total Count From Data ( $ max Results = null ) { return $ max Results = = = null ? $ this - > count : min ( $ this - > count , $ max Results ) ; } 
protected function prepare String For Like Compare ( $ input , $ type = null ) { if ( $ type = = = 'array ' ) { $ output String = str _replace ( ' : {i : 0 ; ' , ' : { ' , serialize ( $ input ) ) ; } else { $ output String = $ this - > remove Accents ( $ input ) ; } return $ output String ; } 
public function get Config Tree Builder ( ) { $ tree Builder = new Tree Builder ( ) ; $ root Node = $ tree Builder - > root ( 'apy _data _grid ' ) ; $ root Node - > children ( ) - > array Node ( 'limits ' ) - > perform No Deep Merging ( ) - > before Normalization ( ) - > if True ( function ( $ v ) { return ! is _array ( $ v ) ; } ) - > then ( function ( $ v ) { return [ $ v ] ; } ) - > end ( ) - > default Value ( [ 2 0 = > ' 2 0 ' , 5 0 = > ' 5 0 ' , 1 0 0 = > ' 1 0 0 ' ] ) - > prototype ( 'scalar ' ) - > end ( ) - > end ( ) - > boolean Node ( 'persistence ' ) - > default False ( ) - > end ( ) - > scalar Node ( 'theme ' ) - > default Value ( 'APYData Grid Bundle : :blocks .html .twig ' ) - > end ( ) - > scalar Node ( 'no _data _message ' ) - > default Value ( 'No data ' ) - > end ( ) - > scalar Node ( 'no _result _message ' ) - > default Value ( 'No result ' ) - > end ( ) - > scalar Node ( 'actions _columns _size ' ) - > default Value ( - 1 ) - > end ( ) - > scalar Node ( 'actions _columns _title ' ) - > default Value ( 'Actions ' ) - > end ( ) - > scalar Node ( 'actions _columns _separator ' ) - > default Value ( ' <br / > ' ) - > end ( ) 
public function get Primary Field Value ( ) { if ( null = = = $ this - > primary Field ) { throw new \ Invalid Argument Exception ( 'Primary column must be defined ' ) ; } if ( is _array ( $ this - > primary Field ) ) { return array _intersect _key ( $ this - > fields , array _flip ( $ this - > primary Field ) ) ; } if ( ! isset ( $ this - > fields [ $ this - > primary Field ] ) ) { throw new \ Invalid Argument Exception ( 'Primary field not added to fields ' ) ; } return $ this - > fields [ $ this - > primary Field ] ; } 
public function execute ( $ columns , $ page = 0 , $ limit = 0 , $ max Results = null , $ grid Data Junction = Column : : DATA _CONJUNCTION ) { return $ this - > execute From Data ( $ columns , $ page , $ limit , $ max Results ) ; } 
public function set Data ( $ data ) { $ this - > data = $ data ; if ( ! is _array ( $ this - > data ) | | empty ( $ this - > data ) ) { throw new \ Invalid Argument Exception ( 'Data should be an array with content ' ) ; } 
public function create ( $ type = null , Source $ source = null , array $ options = [ ] ) { return $ this - > create Builder ( $ type , $ source , $ options ) - > get Grid ( ) ; } 
public function create Builder ( $ type = 'grid ' , Source $ source = null , array $ options = [ ] ) { $ type = $ this - > resolve Type ( $ type ) ; $ options = $ this - > resolve Options ( $ type , $ source , $ options ) ; $ builder = new Grid Builder ( $ this - > container , $ this , $ type - > get Name ( ) , $ options ) ; $ builder - > set Type ( $ type ) ; $ type - > build Grid ( $ builder , $ options ) ; return $ builder ; } 
public function create Column ( $ name , $ type , array $ options = [ ] ) { if ( ! $ type instanceof Column ) { if ( ! is _string ( $ type ) ) { throw new Unexpected Type Exception ( $ type , 'string , APY \Data Grid Bundle \Grid \Column \Column ' ) ; } $ column = clone $ this - > registry - > get Column ( $ type ) ; $ column - > _ _initialize ( array _merge ( [ 'id ' = > $ name , 'title ' = > $ name , 'field ' = > $ name , 'source ' = > true , ] , $ options ) ) ; } else { $ column = $ type ; $ column - > set Id ( $ name ) ; } return $ column ; } 
private function resolve Type ( $ type ) { if ( ! $ type instanceof Grid Type Interface ) { if ( ! is _string ( $ type ) ) { throw new Unexpected Type Exception ( $ type , 'string , APY \Data Grid Bundle \Grid \Grid Type Interface ' ) ; } $ type = $ this - > registry - > get Type ( $ type ) ; } return $ type ; } 
private function resolve Options ( Grid Type Interface $ type , Source $ source = null , array $ options = [ ] ) { $ resolver = new Options Resolver ( ) ; $ type - > configure Options ( $ resolver ) ; if ( null ! = = $ source & & ! isset ( $ options [ 'source ' ] ) ) { $ options [ 'source ' ] = $ source ; } $ options = $ resolver - > resolve ( $ options ) ; return $ options ; } 
public function execute ( $ columns , $ page = 0 , $ limit = 0 , $ max Results = null , $ grid Data Junction = Column : : DATA _CONJUNCTION ) { $ this - > query = $ this - > get Query Builder ( ) ; $ valid Columns = [ ] ; foreach ( $ columns as $ column ) { 
protected function add Referenced Fields ( Row $ row , $ resource ) { foreach ( $ this - > referenced Columns as $ parent = > $ sub Columns ) { $ node = $ this - > get Class Properties ( $ resource ) ; if ( isset ( $ node [ strtolower ( $ parent ) ] ) ) { $ node = $ node [ strtolower ( $ parent ) ] ; foreach ( $ sub Columns as $ field ) { $ getter = 'get ' . ucfirst ( $ field ) ; if ( method _exists ( $ node , $ getter ) ) { $ row - > set Field ( $ parent . ' . ' . $ field , $ node - > $ getter ( ) ) ; } else { throw new \ Exception ( sprintf ( 'Method %s for Document %s not exists ' , $ getter , $ this - > referenced Mappings [ $ parent ] ) ) ; } } } } return $ row ; } 
public function get Fields Metadata ( $ class , $ group = 'default ' ) { $ result = [ ] ; foreach ( $ this - > odm Metadata - > get Reflection Properties ( ) as $ property ) { $ name = $ property - > get Name ( ) ; $ mapping = $ this - > odm Metadata - > get Field Mapping ( $ name ) ; $ values = [ 'title ' = > $ name , 'source ' = > true ] ; if ( isset ( $ mapping [ 'field Name ' ] ) ) { $ values [ 'field ' ] = $ mapping [ 'field Name ' ] ; $ values [ 'id ' ] = $ mapping [ 'field Name ' ] ; } if ( isset ( $ mapping [ 'id ' ] ) & & $ mapping [ 'id ' ] = = 'id ' ) { $ values [ 'primary ' ] = true ; } switch ( $ mapping [ 'type ' ] ) { case 'id ' : case 'string ' : case 'bin _custom ' : case 'bin _func ' : case 'bin _md 5 ' : case 'bin ' : case 'bin _uuid ' : case 'file ' : case 'key ' : case 'increment ' : $ values [ 'type ' ] = 'text ' ; break ; case 'int ' : case 'float ' : $ values [ 'type ' ] = 'number ' ; break ; case 'boolean ' : $ values [ 'type ' ] = 'boolean ' ; break ; case 'date ' : case 'timestamp ' : $ values [ 'type ' ] = 'date ' ; break ; case 'collection ' : $ values [ 'type ' ] = 'array ' ; break ; case 'one ' : $ values [ 'type ' ] = 'array ' ; if ( isset ( $ mapping [ 'reference ' ] ) & & $ mapping [ 'reference ' ] = = = true ) { $ this - > referenced Mappings [ $ name ] = $ mapping [ 'target Document ' ] ; } break ; case 'many ' : $ values [ 'type ' ] = 'array ' ; break ; default : $ values [ 'type ' ] = 'text ' ; } $ result [ $ name ] = $ values ; } return $ result ; } 
public function add ( $ name , $ type , array $ options = [ ] ) { if ( ! $ type instanceof Column ) { if ( ! is _string ( $ type ) ) { throw new Unexpected Type Exception ( $ type , 'string , APY \Data Grid Bundle \Grid \Column \Column ' ) ; } $ type = $ this - > factory - > create Column ( $ name , $ type , $ options ) ; } $ this - > columns [ $ name ] = $ type ; return $ this ; } 
public function get ( $ name ) { if ( ! $ this - > has ( $ name ) ) { throw new Invalid Argument Exception ( sprintf ( 'The column with the name " %s " does not exist . ' , $ name ) ) ; } $ column = $ this - > columns [ $ name ] ; return $ column ; } 
public function get Grid ( ) { $ config = $ this - > get Grid Config ( ) ; $ grid = new Grid ( $ this - > container , $ config - > get Name ( ) , $ config ) ; foreach ( $ this - > columns as $ column ) { $ grid - > add Column ( $ column ) ; } if ( ! empty ( $ this - > actions ) ) { foreach ( $ this - > actions as $ column Id = > $ actions ) { foreach ( $ actions as $ action ) { $ grid - > add Row Action ( $ action ) ; } } } $ grid - > initialize ( ) ; return $ grid ; } 
public function get Grid ( Twig _Environment $ environment , $ grid , $ theme = null , $ id = ' ' , array $ params = [ ] , $ withjs = true ) { $ this - > init Grid ( $ grid , $ theme , $ id , $ params ) ; 
public function get Grid Html ( Twig _Environment $ environment , $ grid , $ theme = null , $ id = ' ' , array $ params = [ ] ) { return $ this - > get Grid ( $ environment , $ grid , $ theme , $ id , $ params , false ) ; } 
public function get Grid _ ( Twig _Environment $ environment , $ name , $ grid ) { return $ this - > render Block ( $ environment , 'grid _ ' . $ name , [ 'grid ' = > $ grid ] ) ; } 
public function get Grid Pager ( Twig _Environment $ environment , $ grid ) { return $ this - > render Block ( $ environment , 'grid _pager ' , [ 'grid ' = > $ grid , 'pagerfanta ' = > $ this - > pager Fanta Defs [ 'enable ' ] ] ) ; } 
public function get Grid Cell ( Twig _Environment $ environment , $ column , $ row , $ grid ) { $ value = $ column - > render Cell ( $ row - > get Field ( $ column - > get Id ( ) ) , $ row , $ this - > router ) ; $ id = $ this - > names [ $ grid - > get Hash ( ) ] ; if ( ( $ id ! = ' ' & & ( $ this - > has Block ( $ environment , $ block = 'grid _ ' . $ id . ' _column _ ' . $ column - > get Render Block Id ( ) . ' _cell ' ) | | $ this - > has Block ( $ environment , $ block = 'grid _ ' . $ id . ' _column _ ' . $ column - > get Type ( ) . ' _cell ' ) | | $ this - > has Block ( $ environment , $ block = 'grid _ ' . $ id . ' _column _ ' . $ column - > get Parent Type ( ) . ' _cell ' ) | | $ this - > has Block ( $ environment , $ block = 'grid _ ' . $ id . ' _column _id _ ' . $ column - > get Render Block Id ( ) . ' _cell ' ) | | $ this - > has Block ( $ environment , $ block = 'grid _ ' . $ id . ' _column _type _ ' . $ column - > get Type ( ) . ' _cell ' ) | | $ this - > has Block ( $ environment , $ block = 'grid _ ' . $ id . ' _column _type _ ' . $ column - > get Parent Type ( ) . ' _cell ' ) ) ) | | $ this - > has Block ( $ environment , $ block = 'grid _column _ ' . $ column - > get Render Block Id ( ) . ' _cell ' ) | | $ this - > has Block ( $ environment , $ block = 'grid _column _ ' . $ column - > get Type ( ) . ' _cell ' ) | | $ this - > has Block ( $ environment , $ block = 'grid _column _ ' . $ column - > get Parent Type ( ) . ' _cell ' ) | | $ this - > has Block ( $ environment , $ block = 'grid _column _id _ ' . $ column - > get Render Block Id ( ) . ' _cell ' ) | | $ this - > has Block ( $ environment , $ block = 'grid _column _type _ ' . $ column - > get Type ( ) . ' _cell ' ) | | $ this - > has Block ( $ environment , $ block = 'grid _column _type _ ' . $ column - > get Parent Type ( ) . ' _cell ' ) ) { return $ this - > render Block ( $ environment , $ block , [ 'grid ' = > $ grid , 'column ' = > $ column , 'row ' = > $ row , 'value ' = > $ value ] ) ; } return $ this - > render Block ( $ environment , 'grid _column _cell ' , [ 'grid ' = > $ grid , 'column ' = > $ column , 'row ' = > $ row , 'value ' = > $ value ] ) ; } 
public function get Grid Filter ( Twig _Environment $ environment , $ column , $ grid , $ submit On Change = true ) { $ id = $ this - > names [ $ grid - > get Hash ( ) ] ; if ( ( $ id ! = ' ' & & ( $ this - > has Block ( $ environment , $ block = 'grid _ ' . $ id . ' _column _ ' . $ column - > get Render Block Id ( ) . ' _filter ' ) | | $ this - > has Block ( $ environment , $ block = 'grid _ ' . $ id . ' _column _id _ ' . $ column - > get Render Block Id ( ) . ' _filter ' ) | | $ this - > has Block ( $ environment , $ block = 'grid _ ' . $ id . ' _column _type _ ' . $ column - > get Type ( ) . ' _filter ' ) | | $ this - > has Block ( $ environment , $ block = 'grid _ ' . $ id . ' _column _type _ ' . $ column - > get Parent Type ( ) . ' _filter ' ) ) | | $ this - > has Block ( $ environment , $ block = 'grid _ ' . $ id . ' _column _filter _type _ ' . $ column - > get Filter Type ( ) ) ) | | $ this - > has Block ( $ environment , $ block = 'grid _column _ ' . $ column - > get Render Block Id ( ) . ' _filter ' ) | | $ this - > has Block ( $ environment , $ block = 'grid _column _id _ ' . $ column - > get Render Block Id ( ) . ' _filter ' ) | | $ this - > has Block ( $ environment , $ block = 'grid _column _type _ ' . $ column - > get Type ( ) . ' _filter ' ) | | $ this - > has Block ( $ environment , $ block = 'grid _column _type _ ' . $ column - > get Parent Type ( ) . ' _filter ' ) | | $ this - > has Block ( $ environment , $ block = 'grid _column _filter _type _ ' . $ column - > get Filter Type ( ) ) ) { return $ this - > render Block ( $ environment , $ block , [ 'grid ' = > $ grid , 'column ' = > $ column , 'submit On Change ' = > $ submit On Change & & $ column - > is Filter Submit On Change ( ) ] ) ; } return ' ' ; } 
public function get Grid Column Operator ( Twig _Environment $ environment , $ column , $ grid , $ operator , $ submit On Change = true ) { return $ this - > render Block ( $ environment , 'grid _column _operator ' , [ 'grid ' = > $ grid , 'column ' = > $ column , 'submit On Change ' = > $ submit On Change , 'op ' = > $ operator ] ) ; } 
public function get Grid Url ( $ section , $ grid , $ param = null ) { $ prefix = $ grid - > get Route Url ( ) . ( strpos ( $ grid - > get Route Url ( ) , ' ? ' ) ? ' & ' : ' ? ' ) . $ grid - > get Hash ( ) . ' [ ' ; switch ( $ section ) { case 'order ' : if ( $ param - > is Sorted ( ) ) { return $ prefix . Grid : : REQUEST _QUERY _ORDER . ' ] = ' . $ param - > get Id ( ) . ' | ' . ( $ param - > get Order ( ) = = 'asc ' ? 'desc ' : 'asc ' ) ; } else { return $ prefix . Grid : : REQUEST _QUERY _ORDER . ' ] = ' . $ param - > get Id ( ) . ' |asc ' ; } case 'page ' : return $ prefix . Grid : : REQUEST _QUERY _PAGE . ' ] = ' . $ param ; case 'limit ' : return $ prefix . Grid : : REQUEST _QUERY _LIMIT . ' ] = ' ; case 'reset ' : return $ prefix . Grid : : REQUEST _QUERY _RESET . ' ] = ' ; case 'export ' : return $ prefix . Grid : : REQUEST _QUERY _EXPORT . ' ] = ' . $ param ; } } 
public function get Grid Search ( \ Twig _Environment $ environment , $ grid , $ theme = null , $ id = ' ' , array $ params = [ ] ) { $ this - > init Grid ( $ grid , $ theme , $ id , $ params ) ; return $ this - > render Block ( $ environment , 'grid _search ' , [ 'grid ' = > $ grid ] ) ; } 
protected function render Block ( Twig _Environment $ environment , $ name , $ parameters ) { foreach ( $ this - > get Templates ( $ environment ) as $ template ) { if ( $ template - > has Block ( $ name , [ ] ) ) { return $ template - > render Block ( $ name , array _merge ( $ environment - > get Globals ( ) , $ parameters , $ this - > params ) ) ; } } throw new \ Invalid Argument Exception ( sprintf ( 'Block " %s " doesn \ 't exist in grid template " %s " . ' , $ name , $ this - > theme ) ) ; } 
protected function has Block ( Twig _Environment $ environment , $ name ) { foreach ( $ this - > get Templates ( $ environment ) as $ template ) { if ( $ template - > has Block ( $ name , [ ] ) ) { return true ; } } return false ; } 
protected function get Templates ( Twig _Environment $ environment ) { if ( empty ( $ this - > templates ) ) { if ( $ this - > theme instanceof Twig _Template ) { $ this - > templates [ ] = $ this - > theme ; $ this - > templates [ ] = $ environment - > load Template ( $ this - > default Template ) ; } elseif ( is _string ( $ this - > theme ) ) { $ this - > templates = $ this - > get Templates From String ( $ environment , $ this - > theme ) ; } elseif ( $ this - > theme = = = null ) { $ this - > templates = $ this - > get Templates From String ( $ environment , $ this - > default Template ) ; } else { throw new \ Exception ( 'Unable to load template ' ) ; } } return $ this - > templates ; } 
protected function get Templates From String ( Twig _Environment $ environment , $ theme ) { $ this - > templates = [ ] ; $ template = $ environment - > load Template ( $ theme ) ; while ( $ template instanceof \ Twig _Template ) { $ this - > templates [ ] = $ template ; $ template = $ template - > get Parent ( [ ] ) ; } return $ this - > templates ; } 
public function walk Select Statement ( Select Statement $ AST ) { $ root Components = [ ] ; foreach ( $ this - > _get Query Components ( ) as $ dql Alias = > $ q Comp ) { if ( array _key _exists ( 'parent ' , $ q Comp ) & & $ q Comp [ 'parent ' ] = = = null & & $ q Comp [ 'nesting Level ' ] = = 0 ) { $ root Components [ ] = [ $ dql Alias = > $ q Comp ] ; } } if ( count ( $ root Components ) > 1 ) { throw new \ Runtime Exception ( 'Cannot count query which selects two FROM components , cannot make distinction ' ) ; } $ root = reset ( $ root Components ) ; $ parent Name = key ( $ root ) ; $ parent = current ( $ root ) ; $ path Expression = new Path Expression ( Path Expression : : TYPE _STATE _FIELD | Path Expression : : TYPE _SINGLE _VALUED _ASSOCIATION , $ parent Name , $ parent [ 'metadata ' ] - > get Single Identifier Field Name ( ) ) ; $ path Expression - > type = Path Expression : : TYPE _STATE _FIELD ; 
public function initialize ( ) { $ config = $ this - > config ; if ( ! $ config ) { return $ this ; } $ this - > set Persistence ( $ config - > is Persisted ( ) ) ; 
public function handle Request ( Request $ request ) { if ( null = = = $ this - > source ) { throw new \ Logic Exception ( self : : SOURCE _NOT _SETTED _EX _MSG ) ; } $ this - > request = $ request ; $ this - > session = $ request - > get Session ( ) ; $ this - > create Hash ( ) ; $ this - > request Data = $ request - > get ( $ this - > hash ) ; $ this - > process Persistence ( ) ; $ this - > session Data = ( array ) $ this - > session - > get ( $ this - > hash ) ; $ this - > process Lazy Parameters ( ) ; if ( ! empty ( $ this - > request Data ) ) { $ this - > process Request Data ( ) ; } if ( $ this - > new Session ) { $ this - > set Default Session Data ( ) ; } $ this - > process Permanent Filters ( ) ; $ this - > process Session Data ( ) ; $ this - > prepare ( ) ; return $ this ; } 
public function set Source ( Source $ source ) { if ( $ this - > source ! = = null ) { throw new \ Invalid Argument Exception ( self : : SOURCE _ALREADY _SETTED _EX _MSG ) ; } $ this - > source = $ source ; $ this - > source - > initialise ( $ this - > container ) ; 
public function is Ready For Redirect ( ) { if ( $ this - > source = = = null ) { throw new \ Exception ( self : : SOURCE _NOT _SETTED _EX _MSG ) ; } if ( $ this - > redirect ! = = null ) { return $ this - > redirect ; } $ this - > create Hash ( ) ; $ this - > request Data = ( array ) $ this - > request - > get ( $ this - > hash ) ; $ this - > process Persistence ( ) ; $ this - > session Data = ( array ) $ this - > session - > get ( $ this - > hash ) ; $ this - > process Lazy Parameters ( ) ; 
protected function process Request Data ( ) { $ this - > process Mass Actions ( $ this - > get From Request ( self : : REQUEST _QUERY _MASS _ACTION ) ) ; if ( $ this - > process Exports ( $ this - > get From Request ( self : : REQUEST _QUERY _EXPORT ) ) | | $ this - > process Tweaks ( $ this - > get From Request ( self : : REQUEST _QUERY _TWEAK ) ) ) { return ; } $ filtering = $ this - > process Request Filters ( ) ; $ this - > process Page ( $ this - > get From Request ( self : : REQUEST _QUERY _PAGE ) , $ filtering ) ; $ this - > process Order ( $ this - > get From Request ( self : : REQUEST _QUERY _ORDER ) ) ; $ this - > process Limit ( $ this - > get From Request ( self : : REQUEST _QUERY _LIMIT ) ) ; $ this - > save Session ( ) ; } 
protected function process Mass Actions ( $ action Id ) { if ( $ action Id > - 1 & & ' ' ! = = $ action Id ) { if ( array _key _exists ( $ action Id , $ this - > mass Actions ) ) { $ action = $ this - > mass Actions [ $ action Id ] ; $ action All Keys = ( boolean ) $ this - > get From Request ( self : : REQUEST _QUERY _MASS _ACTION _ALL _KEYS _SELECTED ) ; $ action Keys = $ action All Keys = = = false ? array _keys ( ( array ) $ this - > get From Request ( Mass Action Column : : ID ) ) : [ ] ; $ this - > process Session Data ( ) ; if ( $ action All Keys ) { $ this - > page = 0 ; $ this - > limit = 0 ; } $ this - > prepare ( ) ; if ( $ action All Keys = = = true ) { foreach ( $ this - > rows as $ row ) { $ action Keys [ ] = $ row - > get Primary Field Value ( ) ; } } if ( is _callable ( $ action - > get Callback ( ) ) ) { $ this - > mass Action Response = call _user _func ( $ action - > get Callback ( ) , $ action Keys , $ action All Keys , $ this - > session , $ action - > get Parameters ( ) ) ; } elseif ( strpos ( $ action - > get Callback ( ) , ' : ' ) ! = = false ) { $ path = array _merge ( [ 'primary Keys ' = > $ action Keys , 'all Primary Keys ' = > $ action All Keys , ' _controller ' = > $ action - > get Callback ( ) , ] , $ action - > get Parameters ( ) ) ; $ sub Request = $ this - > request - > duplicate ( [ ] , null , $ path ) ; $ this - > mass Action Response = $ this - > container - > get ( 'http _kernel ' ) - > handle ( $ sub Request , \ Symfony \ Component \ Http Kernel \ Http Kernel Interface : : SUB _REQUEST ) ; } else { throw new \ Runtime Exception ( sprintf ( self : : MASS _ACTION _CALLBACK _NOT _VALID _EX _MSG , $ action - > get Callback ( ) ) ) ; } } else { throw new \ Out Of Bounds Exception ( sprintf ( self : : MASS _ACTION _NOT _DEFINED _EX _MSG , $ action Id ) ) ; } } } 
protected function process Exports ( $ export Id ) { if ( $ export Id > - 1 & & ' ' ! = = $ export Id ) { if ( array _key _exists ( $ export Id , $ this - > exports ) ) { $ this - > is Ready For Export = true ; $ this - > process Session Data ( ) ; $ this - > page = 0 ; $ this - > limit = 0 ; $ this - > prepare ( ) ; $ export = $ this - > exports [ $ export Id ] ; if ( $ export instanceof Container Aware Interface ) { $ export - > set Container ( $ this - > container ) ; } $ export - > compute Data ( $ this ) ; $ this - > export Response = $ export - > get Response ( ) ; return true ; } else { throw new \ Out Of Bounds Exception ( sprintf ( self : : EXPORT _NOT _DEFINED _EX _MSG , $ export Id ) ) ; } } return false ; } 
protected function process Tweaks ( $ tweak Id ) { if ( $ tweak Id ! = = null ) { if ( array _key _exists ( $ tweak Id , $ this - > tweaks ) ) { $ tweak = $ this - > tweaks [ $ tweak Id ] ; $ save As Active = false ; if ( isset ( $ tweak [ 'reset ' ] ) ) { $ this - > session Data = [ ] ; $ this - > session - > remove ( $ this - > hash ) ; } if ( isset ( $ tweak [ 'filters ' ] ) ) { $ this - > default Filters = [ ] ; $ this - > set Default Filters ( $ tweak [ 'filters ' ] ) ; $ this - > process Default Filters ( ) ; $ save As Active = true ; } if ( isset ( $ tweak [ 'order ' ] ) ) { $ this - > process Order ( $ tweak [ 'order ' ] ) ; $ save As Active = true ; } if ( isset ( $ tweak [ 'mass Action ' ] ) ) { $ this - > process Mass Actions ( $ tweak [ 'mass Action ' ] ) ; } if ( isset ( $ tweak [ 'page ' ] ) ) { $ this - > process Page ( $ tweak [ 'page ' ] ) ; $ save As Active = true ; } if ( isset ( $ tweak [ 'limit ' ] ) ) { $ this - > process Limit ( $ tweak [ 'limit ' ] ) ; $ save As Active = true ; } if ( isset ( $ tweak [ 'export ' ] ) ) { $ this - > process Exports ( $ tweak [ 'export ' ] ) ; } if ( $ save As Active ) { $ active Tweaks = $ this - > get Active Tweaks ( ) ; $ active Tweaks [ $ tweak [ 'group ' ] ] = $ tweak Id ; $ this - > set ( 'tweaks ' , $ active Tweaks ) ; } if ( isset ( $ tweak [ 'remove Active Tweaks Groups ' ] ) ) { $ remove Active Tweaks Groups = ( array ) $ tweak [ 'remove Active Tweaks Groups ' ] ; $ active Tweaks = $ this - > get Active Tweaks ( ) ; foreach ( $ remove Active Tweaks Groups as $ id ) { if ( isset ( $ active Tweaks [ $ id ] ) ) { unset ( $ active Tweaks [ $ id ] ) ; } } $ this - > set ( 'tweaks ' , $ active Tweaks ) ; } if ( isset ( $ tweak [ 'remove Active Tweaks ' ] ) ) { $ remove Active Tweaks = ( array ) $ tweak [ 'remove Active Tweaks ' ] ; $ active Tweaks = $ this - > get Active Tweaks ( ) ; foreach ( $ remove Active Tweaks as $ id ) { if ( array _key _exists ( $ id , $ this - > tweaks ) ) { if ( isset ( $ active Tweaks [ $ this - > tweaks [ $ id ] [ 'group ' ] ] ) ) { unset ( $ active Tweaks [ $ this - > tweaks [ $ id ] [ 'group ' ] ] ) ; } } } $ this - > set ( 'tweaks ' , $ active Tweaks ) ; } if ( isset ( $ tweak [ 'add Active Tweaks ' ] ) ) { $ add Active Tweaks = ( array ) $ tweak [ 'add Active Tweaks ' ] ; $ active Tweaks = $ this - > get Active Tweaks ( ) ; foreach ( $ add Active Tweaks as $ id ) { if ( array _key _exists ( $ id , $ this - > tweaks ) ) { $ active Tweaks [ $ this - > tweaks [ $ id ] [ 'group ' ] ] = $ id ; } } $ this - > set ( 'tweaks ' , $ active Tweaks ) ; } $ this - > save Session ( ) ; return true ; } else { throw new \ Out Of Bounds Exception ( sprintf ( self : : TWEAK _NOT _DEFINED _EX _MSG , $ tweak Id ) ) ; } } return false ; } 
protected function process Filters ( $ permanent = true ) { foreach ( ( $ permanent ? $ this - > permanent Filters : $ this - > default Filters ) as $ column Id = > $ value ) { $ column = $ this - > columns - > get Column By Id ( $ column Id ) ; if ( $ permanent ) { 
protected function process Session Data ( ) { 
protected function prepare ( ) { if ( $ this - > prepared ) { return $ this ; } if ( $ this - > source - > is Data Loaded ( ) ) { $ this - > rows = $ this - > source - > execute From Data ( $ this - > columns - > get Iterator ( true ) , $ this - > page , $ this - > limit , $ this - > max Results ) ; } else { $ this - > rows = $ this - > source - > execute ( $ this - > columns - > get Iterator ( true ) , $ this - > page , $ this - > limit , $ this - > max Results , $ this - > data Junction ) ; } if ( ! $ this - > rows instanceof Rows ) { throw new \ Exception ( self : : NO _ROWS _RETURNED _EX _MSG ) ; } if ( count ( $ this - > rows ) = = 0 & & $ this - > page > 0 ) { $ this - > page = 0 ; $ this - > prepare ( ) ; return $ this ; } 
protected function set ( $ key , $ data ) { 
public function get Column ( $ column Id ) { foreach ( $ this - > lazy Add Column as $ column ) { if ( $ column [ 'column ' ] - > get Id ( ) = = $ column Id ) { return $ column [ 'column ' ] ; } } return $ this - > columns - > get Column By Id ( $ column Id ) ; } 
public function has Column ( $ column Id ) { foreach ( $ this - > lazy Add Column as $ column ) { if ( $ column [ 'column ' ] - > get Id ( ) = = $ column Id ) { return true ; } } return $ this - > columns - > has Column By Id ( $ column Id ) ; } 
public function set Columns Order ( array $ column Ids , $ keep Other Columns = true ) { $ this - > columns - > set Columns Order ( $ column Ids , $ keep Other Columns ) ; return $ this ; } 
public function add Mass Action ( Mass Action Interface $ action ) { if ( $ action - > get Role ( ) = = = null | | $ this - > security Context - > is Granted ( $ action - > get Role ( ) ) ) { $ this - > mass Actions [ ] = $ action ; } return $ this ; } 
public function add Tweak ( $ title , array $ tweak , $ id = null , $ group = null ) { if ( $ id ! = = null & & ! preg _match ( ' / ^ [ 0 - 9a -z A -Z _ \ + - ] + $ / ' , $ id ) ) { throw new \ Invalid Argument Exception ( sprintf ( self : : TWEAK _MALFORMED _ID _EX _MSG , $ id ) ) ; } $ tweak = array _merge ( [ 'id ' = > $ id , 'title ' = > $ title , 'group ' = > $ group ] , $ tweak ) ; if ( isset ( $ id ) ) { $ this - > tweaks [ $ id ] = $ tweak ; } else { $ this - > tweaks [ ] = $ tweak ; } return $ this ; } 
public function get Tweaks ( ) { $ separator = strpos ( $ this - > get Route Url ( ) , ' ? ' ) ? ' & ' : ' ? ' ; $ url = $ this - > get Route Url ( ) . $ separator . $ this - > get Hash ( ) . ' [ ' . self : : REQUEST _QUERY _TWEAK . ' ] = ' ; foreach ( $ this - > tweaks as $ id = > $ tweak ) { $ this - > tweaks [ $ id ] = array _merge ( $ tweak , [ 'url ' = > $ url . $ id ] ) ; } return $ this - > tweaks ; } 
public function get Tweak ( $ id ) { $ tweaks = $ this - > get Tweaks ( ) ; if ( isset ( $ tweaks [ $ id ] ) ) { return $ tweaks [ $ id ] ; } throw new \ Invalid Argument Exception ( sprintf ( self : : NOT _VALID _TWEAK _ID _EX _MSG , $ id ) ) ; } 
public function get Tweaks Group ( $ group ) { $ tweaks Group = $ this - > get Tweaks ( ) ; foreach ( $ tweaks Group as $ id = > $ tweak ) { if ( $ tweak [ 'group ' ] ! = $ group ) { unset ( $ tweaks Group [ $ id ] ) ; } } return $ tweaks Group ; } 
public function add Row Action ( Row Action Interface $ action ) { if ( $ action - > get Role ( ) = = = null | | $ this - > security Context - > is Granted ( $ action - > get Role ( ) ) ) { $ this - > row Actions [ $ action - > get Column ( ) ] [ ] = $ action ; } return $ this ; } 
public function set Template ( $ template ) { if ( $ template ! = = null ) { if ( $ template instanceof \ Twig _Template ) { $ template = ' _ _SELF _ _ ' . $ template - > get Template Name ( ) ; } elseif ( ! is _string ( $ template ) ) { throw new \ Exception ( self : : TWIG _TEMPLATE _LOAD _EX _MSG ) ; } $ this - > set ( self : : REQUEST _QUERY _TEMPLATE , $ template ) ; $ this - > save Session ( ) ; } return $ this ; } 
public function add Export ( Export Interface $ export ) { if ( $ export - > get Role ( ) = = = null | | $ this - > security Context - > is Granted ( $ export - > get Role ( ) ) ) { $ this - > exports [ ] = $ export ; } return $ this ; } 
public function get Route Url ( ) { if ( $ this - > route Url = = = null ) { $ this - > route Url = $ this - > router - > generate ( $ this - > request - > get ( ' _route ' ) , $ this - > get Route Parameters ( ) ) ; } return $ this - > route Url ; } 
protected function set Filters ( array $ filters , $ permanent = true ) { foreach ( $ filters as $ column Id = > $ value ) { if ( $ permanent ) { $ this - > permanent Filters [ $ column Id ] = $ value ; } else { $ this - > default Filters [ $ column Id ] = $ value ; } } return $ this ; } 
public function set Limits ( $ limits ) { if ( is _array ( $ limits ) ) { if ( ( int ) key ( $ limits ) = = = 0 ) { $ this - > limits = array _combine ( $ limits , $ limits ) ; } else { $ this - > limits = $ limits ; } } elseif ( is _int ( $ limits ) ) { $ this - > limits = [ $ limits = > ( string ) $ limits ] ; } else { throw new \ Invalid Argument Exception ( self : : NOT _VALID _LIMIT _EX _MSG ) ; } return $ this ; } 
public function set Page ( $ page ) { if ( ( int ) $ page > = 0 ) { $ this - > page = ( int ) $ page ; } else { throw new \ Invalid Argument Exception ( self : : PAGE _NOT _VALID _EX _MSG ) ; } return $ this ; } 
public function get Page Count ( ) { $ page Count = 1 ; if ( $ this - > get Limit ( ) > 0 ) { $ page Count = ceil ( $ this - > get Total Count ( ) / $ this - > get Limit ( ) ) ; } 
public function set Max Results ( $ max Results = null ) { if ( ( is _int ( $ max Results ) & & $ max Results < 0 ) & & $ max Results ! = = null ) { throw new \ Invalid Argument Exception ( self : : NOT _VALID _MAX _RESULT _EX _MSG ) ; } $ this - > max Results = $ max Results ; return $ this ; } 
public function is Title Section Visible ( ) { if ( $ this - > show Titles = = = true ) { foreach ( $ this - > columns as $ column ) { if ( $ column - > get Title ( ) ! = ' ' ) { return true ; } } } return false ; } 
public function is Filter Section Visible ( ) { if ( $ this - > show Filters = = = true ) { foreach ( $ this - > columns as $ column ) { if ( $ column - > is Filterable ( ) & & $ column - > get Type ( ) ! = 'massaction ' & & $ column - > get Type ( ) ! = 'actions ' ) { return true ; } } } return false ; } 
public function is Pager Section Visible ( ) { $ limits = $ this - > get Limits ( ) ; if ( empty ( $ limits ) ) { return false ; } 
public function show Columns ( $ column Ids ) { foreach ( ( array ) $ column Ids as $ column Id ) { $ this - > lazy Hide Show Columns [ $ column Id ] = true ; } return $ this ; } 
public function hide Columns ( $ column Ids ) { foreach ( ( array ) $ column Ids as $ column Id ) { $ this - > lazy Hide Show Columns [ $ column Id ] = false ; } return $ this ; } 
public function get Grid Response ( $ param 1 = null , $ param 2 = null , Response $ response = null ) { $ is Ready For Redirect = $ this - > is Ready For Redirect ( ) ; if ( $ this - > is Ready For Export ( ) ) { return $ this - > get Export Response ( ) ; } if ( $ this - > is Mass Action Redirect ( ) ) { return $ this - > get Mass Action Response ( ) ; } if ( $ is Ready For Redirect ) { return new Redirect Response ( $ this - > get Route Url ( ) ) ; } else { if ( is _array ( $ param 1 ) | | $ param 1 = = = null ) { $ parameters = ( array ) $ param 1 ; $ view = $ param 2 ; } else { $ parameters = ( array ) $ param 2 ; $ view = $ param 1 ; } $ parameters = array _merge ( [ 'grid ' = > $ this ] , $ parameters ) ; if ( $ view = = = null ) { return $ parameters ; } else { return $ this - > container - > get ( 'templating ' ) - > render Response ( $ view , $ parameters , $ response ) ; } } } 
public function get Raw Data ( $ column Names = null , $ named Indexes = true ) { if ( $ column Names = = = null ) { foreach ( $ this - > get Columns ( ) as $ column ) { $ column Names [ ] = $ column - > get Id ( ) ; } } $ column Names = ( array ) $ column Names ; $ result = [ ] ; foreach ( $ this - > rows as $ row ) { $ result Row = [ ] ; foreach ( $ column Names as $ column Name ) { if ( $ named Indexes ) { $ result Row [ $ column Name ] = $ row - > get Field ( $ column Name ) ; } else { $ result Row [ ] = $ row - > get Field ( $ column Name ) ; } } $ result [ ] = $ result Row ; } return $ result ; } 
public function get Filters ( ) { if ( $ this - > hash = = = null ) { throw new \ Exception ( self : : GET _FILTERS _NO _REQUEST _HANDLED _EX _MSG ) ; } if ( $ this - > session Filters = = = null ) { $ this - > session Filters = [ ] ; $ session = $ this - > session Data ; $ request Queries = [ self : : REQUEST _QUERY _MASS _ACTION _ALL _KEYS _SELECTED , self : : REQUEST _QUERY _MASS _ACTION , self : : REQUEST _QUERY _EXPORT , self : : REQUEST _QUERY _PAGE , self : : REQUEST _QUERY _LIMIT , self : : REQUEST _QUERY _ORDER , self : : REQUEST _QUERY _TEMPLATE , self : : REQUEST _QUERY _RESET , Mass Action Column : : ID , ] ; foreach ( $ request Queries as $ request _query ) { unset ( $ session [ $ request _query ] ) ; } foreach ( $ session as $ column Id = > $ session Filter ) { if ( isset ( $ session Filter [ 'operator ' ] ) ) { $ operator = $ session Filter [ 'operator ' ] ; unset ( $ session Filter [ 'operator ' ] ) ; } else { $ operator = $ this - > get Column ( $ column Id ) - > get Default Operator ( ) ; } if ( ! isset ( $ session Filter [ 'to ' ] ) & & isset ( $ session Filter [ 'from ' ] ) ) { $ session Filter = $ session Filter [ 'from ' ] ; } $ this - > session Filters [ $ column Id ] = new Filter ( $ operator , $ session Filter ) ; } } return $ this - > session Filters ; } 
public function get Filter ( $ column Id ) { if ( $ this - > hash = = = null ) { throw new \ Exception ( self : : GET _FILTERS _NO _REQUEST _HANDLED _EX _MSG ) ; } $ session Filters = $ this - > get Filters ( ) ; return isset ( $ session Filters [ $ column Id ] ) ? $ session Filters [ $ column Id ] : null ; } 
public function has Filter ( $ column Id ) { if ( $ this - > hash = = = null ) { throw new \ Exception ( self : : HAS _FILTER _NO _REQUEST _HANDLED _EX _MSG ) ; } return $ this - > get Filter ( $ column Id ) ! = = null ; } 
protected function get Translation Field Name With Parents ( $ column ) { $ name = $ column - > get Field ( ) ; if ( $ column - > get Is Manual Field ( ) ) { return $ column - > get Field ( ) ; } if ( strpos ( $ name , ' . ' ) ! = = false ) { $ previous Parent = ' ' ; $ elements = explode ( ' . ' , $ name ) ; while ( $ element = array _shift ( $ elements ) ) { if ( count ( $ elements ) > 0 ) { $ previous Parent . = ' _ ' . $ element ; } } } elseif ( strpos ( $ name , ' : ' ) ! = = false ) { $ previous Parent = $ this - > get Table Alias ( ) ; } else { return $ this - > get Table Alias ( ) . ' . ' . $ name ; } $ matches = array ( ) ; if ( $ column - > has DQLFunction ( $ matches ) ) { return $ previous Parent . ' . ' . $ matches [ 'field ' ] ; } return $ column - > get Field ( ) ; } 
protected function get Group By Field Name ( $ field Name ) { if ( strpos ( $ field Name , ' . ' ) ! = = false ) { $ previous Parent = ' ' ; $ elements = explode ( ' . ' , $ field Name ) ; while ( $ element = array _shift ( $ elements ) ) { if ( count ( $ elements ) > 0 ) { $ previous Parent . = ' _ ' . $ element ; } else { $ name = $ previous Parent . ' . ' . $ element ; } } } else { if ( ( $ pos = strpos ( $ field Name , ' : ' ) ) ! = = false ) { $ field Name = substr ( $ field Name , 0 , $ pos ) ; } return $ this - > get Table Alias ( ) . ' . ' . $ field Name ; } return $ name ; } 
public function init Query Builder ( Query Builder $ query Builder ) { $ this - > query Builder = clone $ query Builder ; 
public function execute ( $ columns , $ page = 0 , $ limit = 0 , $ max Results = null , $ grid Data Junction = Column : : DATA _CONJUNCTION ) { $ this - > query = $ this - > get Query Builder ( ) ; $ this - > query Selectfrom Source = clone $ this - > query ; $ bind Index = 1 2 3 ; $ serialize Columns = [ ] ; $ where = $ grid Data Junction = = = Column : : DATA _CONJUNCTION ? $ this - > query - > expr ( ) - > andx ( ) : $ this - > query - > expr ( ) - > orx ( ) ; $ columns By Id = [ ] ; foreach ( $ columns as $ column ) { $ columns By Id [ $ column - > get Id ( ) ] = $ column ; } foreach ( $ columns as $ column ) { 
public function render Cell ( $ value , $ row , $ router ) { if ( is _callable ( $ this - > callback ) ) { return call _user _func ( $ this - > callback , $ value , $ row , $ router ) ; } $ value = is _bool ( $ value ) ? ( int ) $ value : $ value ; if ( array _key _exists ( ( string ) $ value , $ this - > values ) ) { $ value = $ this - > values [ $ value ] ; } return $ value ; } 
public function is Visible ( $ is Exported = false ) { $ visible = $ is Exported & & $ this - > export ! = = null ? $ this - > export : $ this - > visible ; if ( $ visible & & $ this - > authorization Checker ! = = null & & $ this - > get Role ( ) ! = = null ) { return $ this - > authorization Checker - > is Granted ( $ this - > get Role ( ) ) ; } return $ visible ; } 
public function set Order ( $ order ) { if ( $ order ! = = null ) { $ this - > order = $ order ; $ this - > is Sorted = true ; } return $ this ; } 
public function set Size ( $ size ) { if ( $ size < - 1 ) { throw new \ Invalid Argument Exception ( sprintf ( 'Unsupported column size %s , use positive value or - 1 for auto resize ' , $ size ) ) ; } $ this - > size = $ size ; return $ this ; } 
public function set Data ( $ data ) { $ this - > data = [ 'operator ' = > $ this - > get Default Operator ( ) , 'from ' = > static : : DEFAULT _VALUE , 'to ' = > static : : DEFAULT _VALUE ] ; $ has Value = false ; if ( isset ( $ data [ 'from ' ] ) & & $ this - > is Query Valid ( $ data [ 'from ' ] ) ) { $ this - > data [ 'from ' ] = $ data [ 'from ' ] ; $ has Value = true ; } if ( isset ( $ data [ 'to ' ] ) & & $ this - > is Query Valid ( $ data [ 'to ' ] ) ) { $ this - > data [ 'to ' ] = $ data [ 'to ' ] ; $ has Value = true ; } $ is Null Operator = ( isset ( $ data [ 'operator ' ] ) & & ( $ data [ 'operator ' ] = = = self : : OPERATOR _ISNULL | | $ data [ 'operator ' ] = = = self : : OPERATOR _ISNOTNULL ) ) ; if ( ( $ has Value | | $ is Null Operator ) & & isset ( $ data [ 'operator ' ] ) & & $ this - > has Operator ( $ data [ 'operator ' ] ) ) { $ this - > data [ 'operator ' ] = $ data [ 'operator ' ] ; } return $ this ; } 
public function get Data ( ) { $ result = [ ] ; $ has Value = false ; if ( $ this - > data [ 'from ' ] ! = $ this : : DEFAULT _VALUE ) { $ result [ 'from ' ] = $ this - > data [ 'from ' ] ; $ has Value = true ; } if ( $ this - > data [ 'to ' ] ! = $ this : : DEFAULT _VALUE ) { $ result [ 'to ' ] = $ this - > data [ 'to ' ] ; $ has Value = true ; } $ is Null Operator = ( isset ( $ this - > data [ 'operator ' ] ) & & ( $ this - > data [ 'operator ' ] = = = self : : OPERATOR _ISNULL | | $ this - > data [ 'operator ' ] = = = self : : OPERATOR _ISNOTNULL ) ) ; if ( $ has Value | | $ is Null Operator ) { $ result [ 'operator ' ] = $ this - > data [ 'operator ' ] ; } return $ result ; } 
public function set Align ( $ align ) { if ( ! in _array ( $ align , self : : $ aligns ) ) { throw new \ Invalid Argument Exception ( sprintf ( 'Unsupported align %s , just left , right and center are supported ' , $ align ) ) ; } $ this - > align = $ align ; return $ this ; } 
public function get Operators ( ) { 
public function add Column ( Column $ column , $ position = 0 ) { $ column - > set Authorization Checker ( $ this - > authorization Checker ) ; if ( $ position = = 0 ) { $ this - > columns [ ] = $ column ; } else { if ( $ position > 0 ) { - - $ position ; } else { $ position = max ( 0 , count ( $ this - > columns ) + $ position ) ; } $ head = array _slice ( $ this - > columns , 0 , $ position ) ; $ tail = array _slice ( $ this - > columns , $ position ) ; $ this - > columns = array _merge ( $ head , [ $ column ] , $ tail ) ; } return $ this ; } 
public function get Column By Id ( $ column Id ) { if ( ( $ column = $ this - > has Column By Id ( $ column Id , true ) ) = = = false ) { throw new \ Invalid Argument Exception ( sprintf ( self : : MISSING _COLUMN _EX _MSG , $ column Id ) ) ; } return $ column ; } 
public function has Column By Id ( $ column Id , $ return Column = false ) { foreach ( $ this - > columns as $ column ) { if ( $ column - > get Id ( ) = = $ column Id ) { return $ return Column ? $ column : true ; } } return false ; } 
public function set Columns Order ( array $ column Ids , $ keep Other Columns = true ) { $ reordered Columns = [ ] ; $ columns Indexed By Ids = [ ] ; foreach ( $ this - > columns as $ column ) { $ columns Indexed By Ids [ $ column - > get Id ( ) ] = $ column ; } foreach ( $ column Ids as $ column Id ) { if ( isset ( $ columns Indexed By Ids [ $ column Id ] ) ) { $ reordered Columns [ ] = $ columns Indexed By Ids [ $ column Id ] ; unset ( $ columns Indexed By Ids [ $ column Id ] ) ; } } if ( $ keep Other Columns ) { $ this - > columns = array _merge ( $ reordered Columns , array _values ( $ columns Indexed By Ids ) ) ; } else { $ this - > columns = $ reordered Columns ; } return $ this ; } 
public function create Grid ( $ id = null ) { $ grid = $ this - > container - > get ( 'grid ' ) ; if ( $ id ! = = null ) { $ grid - > set Id ( $ id ) ; } $ this - > grids - > attach ( $ grid ) ; return $ grid ; } 
public function get Grid Manager Response ( $ param 1 = null , $ param 2 = null , Response $ response = null ) { $ is Ready For Redirect = $ this - > is Ready For Redirect ( ) ; if ( $ this - > is Ready For Export ( ) ) { return $ this - > export Grid - > get Export Response ( ) ; } if ( $ this - > is Mass Action Redirect ( ) ) { return $ this - > mass Action Grid - > get Mass Action Response ( ) ; } if ( $ is Ready For Redirect ) { return new Redirect Response ( $ this - > get Route Url ( ) ) ; } else { if ( is _array ( $ param 1 ) | | $ param 1 = = = null ) { $ parameters = ( array ) $ param 1 ; $ view = $ param 2 ; } else { $ parameters = ( array ) $ param 2 ; $ view = $ param 1 ; } $ i = 1 ; $ this - > grids - > rewind ( ) ; while ( $ this - > grids - > valid ( ) ) { $ parameters = array _merge ( [ 'grid ' . $ i = > $ this - > grids - > current ( ) ] , $ parameters ) ; $ this - > grids - > next ( ) ; + + $ i ; } if ( $ view = = = null ) { return $ parameters ; } return $ this - > container - > get ( 'templating ' ) - > render Response ( $ view , $ parameters , $ response ) ; } } 
public function build Grid ( Grid Builder $ builder , array $ options = [ ] ) { $ builder - > set Route ( $ options [ 'route ' ] ) - > set Route Parameters ( $ options [ 'route _parameters ' ] ) - > set Persistence ( $ options [ 'persistence ' ] ) - > set Page ( $ options [ 'page ' ] ) - > set Max Results ( $ options [ 'max _results ' ] ) - > set Max Per Page ( $ options [ 'max _per _page ' ] ) - > set Filterable ( $ options [ 'filterable ' ] ) - > set Sortable ( $ options [ 'sortable ' ] ) - > set Sort By ( $ options [ 'sort _by ' ] ) - > set Order ( $ options [ 'order ' ] ) - > set Group By ( $ options [ 'group _by ' ] ) ; if ( ! empty ( $ options [ 'source ' ] ) ) { $ builder - > set Source ( $ options [ 'source ' ] ) ; } } 
public function configure Options ( Options Resolver $ resolver ) { $ resolver - > set Defaults ( [ 'source ' = > null , 'group _by ' = > null , 'sort _by ' = > null , 'order ' = > 'asc ' , 'page ' = > 1 , 'route ' = > ' ' , 'route _parameters ' = > [ ] , 'persistence ' = > false , 'max _per _page ' = > 1 0 , 'max _results ' = > null , 'filterable ' = > true , 'sortable ' = > true , ] ) ; $ allowed Types = [ 'source ' = > [ 'null ' , 'APY \Data Grid Bundle \Grid \Source \Source ' ] , 'group _by ' = > [ 'null ' , 'string ' , 'array ' ] , 'route _parameters ' = > 'array ' , 'persistence ' = > 'bool ' , 'filterable ' = > 'bool ' , 'sortable ' = > 'bool ' , ] ; $ allowed Values = [ 'order ' = > [ 'asc ' , 'desc ' ] , ] ; if ( method _exists ( $ resolver , 'set Default ' ) ) { 
protected function get Datetime ( $ data , \ Date Time Zone $ timezone ) { if ( $ data instanceof \ Date Time | | $ data instanceof \ Date Time Immutable ) { return $ data - > set Timezone ( $ timezone ) ; } 
public function add Route Parameters ( $ route Parameters ) { $ route Parameters = ( array ) $ route Parameters ; foreach ( $ route Parameters as $ key = > $ route Parameter ) { if ( is _int ( $ key ) ) { $ this - > route Parameters [ ] = $ route Parameter ; } else { $ this - > route Parameters [ $ key ] = $ route Parameter ; } } return $ this ; } 
public function get Route Parameters Mapping ( $ name ) { return isset ( $ this - > route Parameters Mapping [ $ name ] ) ? $ this - > route Parameters Mapping [ $ name ] : null ; } 
public function render ( $ row ) { foreach ( $ this - > callbacks as $ callback ) { if ( is _callable ( $ callback ) ) { if ( null = = = call _user _func ( $ callback , $ this , $ row ) ) { return ; } } } return $ this ; } 
public function add Type ( Grid Type Interface $ type ) { $ name = $ type - > get Name ( ) ; if ( $ this - > has Type ( $ name ) ) { throw new Type Already Exists Exception ( $ name ) ; } $ this - > types [ $ name ] = $ type ; return $ this ; } 
public function get Type ( $ name ) { if ( ! $ this - > has Type ( $ name ) ) { throw new Type Not Found Exception ( $ name ) ; } $ type = $ this - > types [ $ name ] ; return $ type ; } 
public function add Column ( Column $ column ) { $ type = $ column - > get Type ( ) ; if ( $ this - > has Column ( $ type ) ) { throw new Column Already Exists Exception ( $ type ) ; } $ this - > columns [ $ type ] = $ column ; return $ this ; } 
public function get Column ( $ type ) { if ( ! $ this - > has Column ( $ type ) ) { throw new Column Not Found Exception ( $ type ) ; } $ column = $ this - > columns [ $ type ] ; return $ column ; } 
public function set Container ( Container Interface $ container = null ) { $ this - > container = $ container ; $ this - > twig = $ this - > container - > get ( 'twig ' ) ; return $ this ; } 
public function get Response ( ) { 
protected function get Grid Data ( $ grid ) { $ result = [ ] ; $ this - > grid = $ grid ; if ( $ this - > grid - > is Title Section Visible ( ) ) { $ result [ 'titles ' ] = $ this - > get Grid Titles ( ) ; } $ result [ 'rows ' ] = $ this - > get Grid Rows ( ) ; return $ result ; } 
protected function get Flat Grid Data ( $ grid ) { $ data = $ this - > get Grid Data ( $ grid ) ; $ flat Data = [ ] ; if ( isset ( $ data [ 'titles ' ] ) ) { $ flat Data [ ] = $ data [ 'titles ' ] ; } return array _merge ( $ flat Data , $ data [ 'rows ' ] ) ; } 
protected function render Block ( $ name , $ parameters ) { foreach ( $ this - > get Templates ( ) as $ template ) { if ( $ template - > has Block ( $ name , [ ] ) ) { return $ template - > render Block ( $ name , array _merge ( $ parameters , $ this - > params ) ) ; } } throw new \ Invalid Argument Exception ( sprintf ( 'Block " %s " doesn \ 't exist in grid template " %s " . ' , $ name , 'ee ' ) ) ; } 
protected function get Templates ( ) { if ( empty ( $ this - > templates ) ) { $ this - > set Template ( $ this - > grid - > get Template ( ) ) ; } return $ this - > templates ; } 
public function set Template ( $ template ) { if ( is _string ( $ template ) ) { if ( substr ( $ template , 0 , 8 ) = = = ' _ _SELF _ _ ' ) { $ this - > templates = $ this - > get Templates From String ( substr ( $ template , 8 ) ) ; $ this - > templates [ ] = $ this - > twig - > load Template ( static : : DEFAULT _TEMPLATE ) ; } else { $ this - > templates = $ this - > get Templates From String ( $ template ) ; } } elseif ( $ this - > templates = = = null ) { $ this - > templates [ ] = $ this - > twig - > load Template ( static : : DEFAULT _TEMPLATE ) ; } else { throw new \ Exception ( 'Unable to load template ' ) ; } return $ this ; } 
public function get Parameter ( $ name ) { if ( ! $ this - > has Parameter ( $ name ) ) { throw new \ Invalid Argument Exception ( sprintf ( 'The parameter " %s " must be defined . ' , $ name ) ) ; } return $ this - > parameters [ $ name ] ; } 
public function get Actions To Render ( $ row ) { $ list = $ this - > row Actions ; foreach ( $ list as $ i = > $ a ) { $ action = clone $ a ; $ list [ $ i ] = $ action - > render ( $ row ) ; if ( null = = = $ list [ $ i ] ) { unset ( $ list [ $ i ] ) ; } } return $ list ; } 
public function process ( Container Builder $ container ) { if ( ! $ container - > has Definition ( 'jms _translation .extractor .file _extractor ' ) ) { return ; } $ extractor = new Definition ( 'APY \Data Grid Bundle \Translation \Column Title Annotation Translation Extractor ' ) ; $ extractor - > set Public ( false ) - > add Tag ( 'jms _translation .file _visitor ' ) ; $ container - > set Definition ( 'grid .translation _extractor ' , $ extractor ) ; } 
public function add ( $ object ) { if ( $ object instanceof Item ) { if ( $ object - > rule Name & & $ this - > get Rule ( $ object - > rule Name ) = = = null ) { $ rule = $ this - > create Rule ( $ object - > rule Name ) ; $ this - > add Rule ( $ rule ) ; } return $ this - > add Item ( $ object ) ; } elseif ( $ object instanceof Rule ) { return $ this - > add Rule ( $ object ) ; } throw new Invalid Argument Exception ( 'Adding unsupported object type . ' ) ; } 
public function up ( ) { $ this - > create Index ( $ this - > index , $ this - > auth Manager - > assignment Table , $ this - > column ) ; } 
protected function check Access Recursive ( $ user , $ item Name , $ params , $ assignments ) { if ( ( $ item = $ this - > get Item ( $ item Name ) ) = = = null ) { return false ; } $ this - > debug ( $ item instanceof Role ? "Checking role : $item Name " : "Checking permission : $item Name " , _ _METHOD _ _ ) ; if ( ! $ this - > execute Rule ( $ user , $ item , $ params ) ) { return false ; } if ( isset ( $ assignments [ $ item Name ] ) | | in _array ( $ item Name , $ this - > default Roles ) ) { return true ; } $ query = new Query ( ) ; $ parents = $ query - > select ( [ 'parent ' ] ) - > from ( $ this - > item Child Table ) - > where ( [ 'child ' = > $ item Name ] ) - > column ( $ this - > db ) ; foreach ( $ parents as $ parent ) { if ( $ this - > check Access Recursive ( $ user , $ parent , $ params , $ assignments ) ) { return true ; } } return false ; } 
public function get Rule ( $ name ) { if ( $ this - > rules ! = = null ) { return isset ( $ this - > rules [ $ name ] ) ? $ this - > rules [ $ name ] : null ; } $ row = ( new Query ( ) ) - > select ( [ 'data ' ] ) - > from ( $ this - > rule Table ) - > where ( [ 'name ' = > $ name ] ) - > one ( $ this - > db ) ; if ( $ row = = = false ) { return ; } $ data = $ row [ 'data ' ] ; if ( is _resource ( $ data ) ) { $ data = stream _get _contents ( $ data ) ; } return unserialize ( $ data ) ; } 
public function reassign ( $ session Id , $ user Id ) { if ( get _class ( $ this - > get Storage ( ) ) = = = 'yii 2mod \cart \storage \Database Storage ' ) { if ( ! empty ( $ this - > items ) ) { $ storage = $ this - > get Storage ( ) ; $ storage - > reassign ( $ session Id , $ user Id ) ; self : : init ( ) ; } } } 
public function clear ( $ save = true ) : self { $ this - > items = [ ] ; $ save & & $ this - > storage - > save ( $ this ) ; return $ this ; } 
public function add ( Cart Item Interface $ element , $ save = true ) : self { $ this - > add Item ( $ element ) ; $ save & & $ this - > storage - > save ( $ this ) ; return $ this ; } 
public function remove ( $ unique Id , $ save = true ) : self { if ( ! isset ( $ this - > items [ $ unique Id ] ) ) { throw new Invalid Param Exception ( 'Item not found ' ) ; } unset ( $ this - > items [ $ unique Id ] ) ; $ save & & $ this - > storage - > save ( $ this ) ; return $ this ; } 
public function get Items ( $ item Type = null ) : array { $ items = $ this - > items ; if ( ! is _null ( $ item Type ) ) { $ items = array _filter ( $ items , function ( $ item ) use ( $ item Type ) { return is _a ( $ item , $ item Type ) ; } ) ; } return $ items ; } 
public function get Attribute Total ( $ attribute , $ item Type = null ) : int { $ sum = 0 ; foreach ( $ this - > get Items ( $ item Type ) as $ model ) { $ sum + = $ model - > { $ attribute } ; } return $ sum ; } 
public function load ( Cart $ cart ) { $ items = [ ] ; $ identifier = $ this - > get Identifier ( Yii : : $ app - > session - > get Id ( ) ) ; $ query = new Query ( ) ; $ query - > select ( $ this - > data Field ) - > from ( $ this - > table ) - > where ( [ $ this - > id Field = > $ identifier ] ) ; if ( $ data = $ query - > create Command ( $ this - > _db ) - > query Scalar ( ) ) { $ items = unserialize ( $ data ) ; } return $ items ; } 
protected function get Identifier ( $ default ) { $ id = $ default ; if ( $ this - > _user instanceof User & & ! $ this - > _user - > get Is Guest ( ) ) { $ id = $ this - > _user - > get Id ( ) ; } return $ id ; } 
public function reassign ( $ source Id , $ destination Id ) { $ command = $ this - > _db - > create Command ( ) ; $ command - > delete ( $ this - > table , [ $ this - > id Field = > $ destination Id ] ) - > execute ( ) ; $ command - > update ( $ this - > table , [ $ this - > id Field = > $ destination Id ] , [ $ this - > id Field = > $ source Id ] ) - > execute ( ) ; } 
private function set Headers ( ) { $ plugin Agent = $ this - > additional Plugin Headers ( ) ; $ user Agent = array ( 'bindings _version ' = > Conekta : : VERSION , 'lang ' = > 'php ' , 'lang _version ' = > phpversion ( ) , 'publisher ' = > 'conekta ' , 'uname ' = > php _uname ( ) , ) ; if ( array _filter ( $ plugin Agent ) ) { $ user Agent = array _merge ( $ user Agent , $ plugin Agent ) ; } $ headers = array ( 'Accept : application /vnd .conekta -v ' . Conekta : : $ api Version . ' +json ' , 'Accept -Language : ' . Conekta : : $ locale , 'X -Conekta -Client -User -Agent : ' . json _encode ( $ user Agent ) , 'User -Agent : Conekta /v 1 Php Bindings / ' . Conekta : : VERSION , 'Authorization : Basic ' . base 6 4 _encode ( $ this - > api Key . ' : ' ) , 'Content -Type : application /json ' ) ; return $ headers ; } 
public function request ( $ method , $ url , $ params = null ) { $ json Params = json _encode ( $ params ) ; $ headers = $ this - > set Headers ( ) ; $ curl = curl _init ( ) ; $ method = strtolower ( $ method ) ; $ opts = array ( ) ; switch ( $ method ) { case 'get ' : $ opts [ CURLOPT _HTTPGET ] = 1 ; $ url = $ this - > build Query Params Url ( $ url , $ params ) ; break ; case 'post ' : $ opts [ CURLOPT _POST ] = 1 ; $ opts [ CURLOPT _POSTFIELDS ] = $ json Params ; break ; case 'put ' : $ opts [ CURLOPT _RETURNTRANSFER ] = 1 ; $ opts [ CURLOPT _CUSTOMREQUEST ] = 'PUT ' ; $ opts [ CURLOPT _POSTFIELDS ] = $ json Params ; break ; case 'delete ' : $ opts [ CURLOPT _CUSTOMREQUEST ] = 'DELETE ' ; $ url = $ this - > build Segment Params Url ( $ url , $ params ) ; break ; default : throw new \ Exception ( 'Wrong method ' ) ; } $ url = $ this - > api Url ( $ url ) ; $ opts [ CURLOPT _URL ] = $ url ; $ opts [ CURLOPT _RETURNTRANSFER ] = true ; $ opts [ CURLOPT _CONNECTTIMEOUT ] = 3 0 ; $ opts [ CURLOPT _TIMEOUT ] = 8 0 ; $ opts [ CURLOPT _RETURNTRANSFER ] = true ; $ opts [ CURLOPT _HTTPHEADER ] = $ headers ; $ opts [ CURLOPT _SSLVERSION ] = 6 ; $ opts [ CURLOPT _CAINFO ] = dirname ( _ _FILE _ _ ) . ' / . . /ssl _data /ca _bundle .crt ' ; curl _setopt _array ( $ curl , $ opts ) ; $ response = curl _exec ( $ curl ) ; $ response Code = curl _getinfo ( $ curl , CURLINFO _HTTP _CODE ) ; curl _close ( $ curl ) ; $ json Response = json _decode ( $ response , true ) ; if ( $ response Code ! = 2 0 0 ) { throw Handler : : error Handler ( $ json Response , $ response Code ) ; } return $ json Response ; } 
private function build Query Params Url ( $ url , $ params ) { if ( ! is _null ( $ params ) ) { $ params = http _build _query ( $ params ) ; $ url = $ url . ' ? ' . $ params ; } return $ url ; } 
private function build Segment Params Url ( $ url , $ params ) { if ( ! is _array ( $ params ) ) { $ url = $ url . urlencode ( $ params ) ; } return $ url ; } 
public function login ( $ connection = null , $ state = null , $ additional _params = [ 'scope ' = > 'openid profile email ' ] , $ response _type = 'code ' ) { $ additional _params [ 'response _type ' ] = $ response _type ; $ this - > auth 0 - > login ( $ state , $ connection , $ additional _params ) ; } 
public function get User ( ) { 
public function remember User ( $ value = null ) { if ( $ value ! = = null ) { $ this - > remember User = $ value ; } return $ this - > remember User ; } 
public function decode JWT ( $ enc User ) { try { $ cache = \ App : : make ( ' \Auth 0 \SDK \Helpers \Cache \Cache Handler ' ) ; } catch ( Binding Resolution Exception $ e ) { $ cache = null ; } $ secret _base 6 4 _encoded = config ( 'laravel -auth 0 .secret _base 6 4 _encoded ' ) ; if ( is _null ( $ secret _base 6 4 _encoded ) ) { $ secret _base 6 4 _encoded = true ; } $ verifier = new JWTVerifier ( [ 'valid _audiences ' = > [ config ( 'laravel -auth 0 .client _id ' ) , config ( 'laravel -auth 0 .api _identifier ' ) ] , 'supported _algs ' = > config ( 'laravel -auth 0 .supported _algs ' , [ 'HS 2 5 6 ' ] ) , 'client _secret ' = > config ( 'laravel -auth 0 .client _secret ' ) , 'authorized _iss ' = > config ( 'laravel -auth 0 .authorized _issuers ' ) , 'secret _base 6 4 _encoded ' = > $ secret _base 6 4 _encoded , 'cache ' = > $ cache , 'guzzle _options ' = > config ( 'laravel -auth 0 .guzzle _options ' ) , ] ) ; $ this - > apiuser = $ verifier - > verify And Decode ( $ enc User ) ; return $ this - > apiuser ; } 
public function callback ( ) { 
public function set ( $ key , $ value ) { $ key _name = $ this - > get Session Key Name ( $ key ) ; Session : : put ( $ key _name , $ value ) ; } 
public function get ( $ key , $ default = null ) { $ key _name = $ this - > get Session Key Name ( $ key ) ; return Session : : get ( $ key _name , $ default ) ; } 
public function retrieve By Credentials ( array $ credentials ) { if ( ! isset ( $ credentials [ 'api _token ' ] ) ) { return false ; } $ enc User = $ credentials [ 'api _token ' ] ; try { $ decoded JWT = $ this - > auth 0 - > decode JWT ( $ enc User ) ; } catch ( Core Exception $ e ) { return null ; } catch ( Invalid Token Exception $ e ) { return null ; } return $ this - > user Repository - > get User By Decoded JWT ( $ decoded JWT ) ; } 
public function boot ( ) { \ Auth : : provider ( 'auth 0 ' , function ( $ app , array $ config ) { return $ app - > make ( Auth 0User Provider : : class ) ; } ) ; $ this - > publishes ( [ _ _DIR _ _ . ' / . . / . . /config /config .php ' = > config _path ( 'laravel -auth 0 .php ' ) , ] ) ; $ laravel = app ( ) ; $ old Info Headers = Api Client : : get Info Headers Data ( ) ; if ( $ old Info Headers ) { $ info Headers = Information Headers : : Extend ( $ old Info Headers ) ; $ info Headers - > set Environment ( 'Laravel ' , $ laravel : : VERSION ) ; $ info Headers - > set Package ( 'laravel -auth 0 ' , self : : SDK _VERSION ) ; Api Client : : set Info Headers Data ( $ info Headers ) ; } } 
public function register ( ) { 
public function get User By Identifier ( $ identifier ) { 
public static function is Mutable ( $ name , $ gender = null ) { $ name = S : : lower ( $ name ) ; if ( in _array ( $ name , static : : $ immutable Names , true ) ) { return false ; } if ( $ gender = = = null ) { $ gender = static : : detect Gender ( $ name ) ; } 
public static function get Case ( $ number , $ case , $ gender = self : : MALE ) { $ case = static : : canonize Case ( $ case ) ; $ forms = static : : get Cases ( $ number , $ gender ) ; return $ forms [ $ case ] ; } 
public static function is Mutable ( $ name ) { $ name = S : : lower ( $ name ) ; 
public static function get Cases ( $ name ) { $ name = S : : lower ( $ name ) ; 
public static function get Cases ( $ number , $ gender = self : : MALE ) { 
public static function length ( $ string ) { if ( function _exists ( 'mb _strlen ' ) ) { return mb _strlen ( $ string , static : : get Encoding ( ) ) ; } if ( function _exists ( 'iconv _strlen ' ) ) { return iconv _strlen ( $ string , static : : get Encoding ( ) ) ; } return false ; } 
public static function slice ( $ string , $ start , $ end = null ) { if ( $ end ! = = null ) { $ end - = $ start ; } if ( function _exists ( 'mb _substr ' ) ) { return mb _substr ( $ string , $ start , $ end , static : : get Encoding ( ) ) ; } if ( function _exists ( 'iconv _substr ' ) ) { return iconv _substr ( $ string , $ start , $ end ? : iconv _strlen ( $ string ) , static : : get Encoding ( ) ) ; } return false ; } 
public static function lower ( $ string ) { if ( function _exists ( 'mb _strtolower ' ) ) { return mb _strtolower ( $ string , static : : get Encoding ( ) ) ; } return static : : replace By Map ( $ string , static : : $ cyrillic Alphabet [ 0 ] , static : : $ cyrillic Alphabet [ 1 ] ) ; } 
public static function upper ( $ string ) { if ( function _exists ( 'mb _strtoupper ' ) ) { return mb _strtoupper ( $ string , static : : get Encoding ( ) ) ; } return static : : replace By Map ( $ string , static : : $ cyrillic Alphabet [ 1 ] , static : : $ cyrillic Alphabet [ 0 ] ) ; } 
public static function name ( $ string ) { if ( strpos ( $ string , ' - ' ) ! = = false ) { return implode ( ' - ' , array _map ( [ _ _CLASS _ _ , _ _FUNCTION _ _ ] , explode ( ' - ' , $ string ) ) ) ; } return static : : upper ( static : : slice ( $ string , 0 , 1 ) ) . static : : lower ( static : : slice ( $ string , 1 ) ) ; } 
public static function count Chars ( $ string , array $ chars ) { if ( function _exists ( 'mb _split ' ) ) { return count ( mb _split ( ' ( ' . implode ( ' | ' , $ chars ) . ' ) ' , $ string ) ) - 1 ; } $ counter = 0 ; foreach ( $ chars as $ char ) { $ counter + = substr _count ( $ string , $ char ) ; } return $ counter ; } 
public static function is Mutable ( $ word , $ animateness = false ) { $ word = S : : lower ( $ word ) ; if ( in _array ( S : : slice ( $ word , - 1 ) , [ ' у ' , и ' , ' ' , ' о , ' ю ' , tr u e | | i _a ray ( $wor d , sta t c : : $im mu t able Words , tru e ) { return false ; } return true ; } 
public static function detect Gender ( $ word ) { $ word = S : : lower ( $ word ) ; $ last = S : : slice ( $ word , - 1 ) ; 
public static function get Declension ( $ word , $ animateness = false ) { $ word = S : : lower ( $ word ) ; $ last = S : : slice ( $ word , - 1 ) ; if ( isset ( static : : $ abnormal Exceptions [ $ word ] ) | | in _array ( $ word , static : : $ abnormal Exceptions , true ) ) { return 2 ; } if ( in _array ( $ last , [ ' а ' , я ' ] , t ue ) & S : sl ice ( $ w o rd , - ) ! ' я ' ) { return 1 ; } elseif ( static : : is Consonant ( $ last ) | | in _array ( $ last , [ ' о ' , е ' , ' ' ] , t r e ) | | ( $ last = = ' ь ' & tatic : :i s Consonant ( S : :s lice ( $ w ord , 2 , 1 ) ) & s tatic : :i s Hissing Consonant ( S : :s lice ( $ w ord , 2 , 1 ) ) & & ( in _array ( $ word , static : : $ masculine With Soft , true ) ) | | in _array ( $ word , static : : $ masculine With Soft And Run Away Vowels , true ) ) ) { return 2 ; } else { return 3 ; } } 
public static function get Cases ( $ word , $ animateness = false ) { $ word = S : : lower ( $ word ) ; 
public static function declinate First Declension ( $ word ) { $ word = S : : lower ( $ word ) ; $ prefix = S : : slice ( $ word , 0 , - 1 ) ; $ last = S : : slice ( $ word , - 1 ) ; $ soft _last = static : : check Last Consonant Softness ( $ word ) ; $ forms = [ Cases : : IMENIT = > $ word , ] ; 
public static function declinate Second Declension ( $ word , $ animateness = false ) { $ word = S : : lower ( $ word ) ; $ last = S : : slice ( $ word , - 1 ) ; $ soft _last = $ last = = ' й ' | i n _array ( $ l ast , ' ь ' , ' ' , ' ё , ' ю ' ' я ' ] tru e ) & & ( ( static : : is Consonant ( S : : slice ( $ word , - 2 , - 1 ) ) & & ! static : : is Hissing Consonant ( S : : slice ( $ word , - 2 , - 1 ) ) ) | | S : : slice ( $ word , - 2 , - 1 ) = = ' и ' ) ) ; $ prefix = static : : get Prefix Of Second Declension ( $ word , $ last ) ; $ forms = [ Cases : : IMENIT = > $ word , ] ; / / RODIT $ forms [ Cases : : RODIT ] = static : : choose Vowel After Consonant ( $ last , $ soft _last , $ prefix . ' я ' , p refix . ' а ' ) ; / / DAT $ forms [ Cases : : DAT ] = static : : choose Vowel After Consonant ( $ last , $ soft _last , $ prefix . ' ю ' , p refix . ' у ' ) ; / / VINIT if ( in _array ( $ last , [ ' о ' , е ' , ' ' ] , t r e ) ) { $ forms [ Cases : : VINIT ] = $ word ; } else { $ forms [ Cases : : VINIT ] = static : : get Vinit Case By Animateness ( $ forms , $ animateness ) ; } 
public static function declinate Third Declension ( $ word ) { $ word = S : : lower ( $ word ) ; $ prefix = S : : slice ( $ word , 0 , - 1 ) ; return [ Cases : : IMENIT = > $ word , Cases : : RODIT = > $ prefix . ' и ' , Cases : : DAT = > $ prefix . ' и ' , Cases : : VINIT = > $ word , Cases : : TVORIT = > $ prefix . ' ь ю ' , Cases : : PREDLOJ = > $ prefix . ' и ' , ] ; } 
public static function declinate Adjective ( $ word , $ animateness ) { $ prefix = S : : slice ( $ word , 0 , - 2 ) ; switch ( S : : slice ( $ word , - 2 ) ) { 
public static function get Case ( $ word , $ case , $ animateness = false ) { $ case = static : : canonize Case ( $ case ) ; $ forms = static : : get Cases ( $ word , $ animateness ) ; return $ forms [ $ case ] ; } 
public static function pluralize ( $ word , $ count = 2 , $ animateness = false , $ case = null ) { 
protected static function declinate Substative ( $ word , $ animateness ) { $ prefix = S : : slice ( $ word , 0 , - 1 ) ; $ last = S : : slice ( $ word , - 1 ) ; $ runaway _vowels _list = static : : get Run Away Vowels List ( ) ; if ( isset ( $ runaway _vowels _list [ $ word ] ) ) { $ vowel _offset = $ runaway _vowels _list [ $ word ] ; $ word = S : : slice ( $ word , 0 , $ vowel _offset ) . S : : slice ( $ word , $ vowel _offset + 1 ) ; } if ( ( $ declension = Noun Declension : : get Declension ( $ word ) ) = = Noun Declension : : SECOND _DECLENSION ) { $ soft _last = $ last = = ' й ' | i n _array ( $ l ast , ' ь ' , ' ' , ' ё , ' ю ' ' я ' ] tru e ) & & ( ( static : : is Consonant ( S : : slice ( $ word , - 2 , - 1 ) ) & & ! static : : is Hissing Consonant ( S : : slice ( $ word , - 2 , - 1 ) ) ) | | S : : slice ( $ word , - 2 , - 1 ) = = ' и ' ) ) ; $ prefix = Noun Declension : : get Prefix Of Second Declension ( $ word , $ last ) ; } elseif ( $ declension = = Noun Declension : : FIRST _DECLENSION ) { $ soft _last = static : : check Last Consonant Softness ( $ word ) ; } else { $ soft _last = in _array ( S : : slice ( $ word , - 2 ) , [ ' ч ь ' , ' ь ' , ' т ь , ' н ь ' ] true ) ; } $ forms = [ ] ; if ( in _array ( $ last , [ ' ч ' , г ' ] , f lse ) | i _array (S : : sl ice ( $ w o rd , - ) , [ ч ь ' , ' с ь , ' т ь ' , ' н ь ' ] , rue ) | | ( static : : is Vowel ( $ last ) & & in _array ( S : : slice ( $ word , - 2 , - 1 ) , [ ' ч ' , к ' ] , t ue ) ) ) { / before ч , ч ь , с ь , ч +vowel , к +vowel $ forms [ Cases : : IMENIT ] = $ prefix . ' и ' ; } elseif ( in _array ( $ last , [ ' н ' , ц ' , ' ' , ' т ] , t r u ) ) { $ forms [ Cases : : IMENIT ] = $ prefix . ' ы ' ; } else { $ forms [ Cases : : IMENIT ] = static : : choose Vowel After Consonant ( $ last , $ soft _last , $ prefix . ' я ' , p refix . ' а ' ) ; } 
protected static function declinate Adjective ( $ word , $ animateness ) { $ prefix = S : : slice ( $ word , 0 , - 2 ) ; $ vowel = static : : is Hissing Consonant ( S : : slice ( $ prefix , - 1 ) ) ? ' и ' ы ' ; return [ Cases : : IMENIT = > $ prefix . $ vowel . ' е ' , Cases : : RODIT = > $ prefix . $ vowel . ' х ' , Cases : : DAT = > $ prefix . $ vowel . ' м ' , Cases : : VINIT = > $ prefix . $ vowel . ( $ animateness ? ' х ' е ' ) , Cases : : TVORIT = > $ prefix . $ vowel . ' м и ' , Cases : : PREDLOJ = > $ prefix . $ vowel . ' х ' , ] ; } 
public static function compose Cases From Words ( array $ words , $ delimiter = ' ' ) { $ cases = [ ] ; foreach ( Cases Helper : : get All Cases ( ) as $ case ) { $ composed _case = [ ] ; foreach ( $ words as $ word Cases ) { $ composed _case [ ] = $ word Cases [ $ case ] ; } $ cases [ $ case ] = implode ( $ delimiter , $ composed _case ) ; } return $ cases ; } 
public static function spell Unit ( $ count , $ unit ) { if ( ! isset ( static : : $ units [ $ unit ] ) ) { throw new Invalid Argument Exception ( 'Unknown time unit : ' . $ unit ) ; } return pluralize ( $ count , static : : $ units [ $ unit ] ) ; } 
public static function is Paired ( $ consonant ) { $ consonant = S : : lower ( $ consonant ) ; return array _key _exists ( $ consonant , static : : $ pairs ) | | ( array _search ( $ consonant , static : : $ pairs ) ! = = false ) ; } 
public static function check Last Consonant Softness ( $ word ) { if ( ( $ substring = S : : find Last Position For One Of Chars ( S : : lower ( $ word ) , static : : $ consonants ) ) ! = = false ) { if ( in _array ( S : : slice ( $ substring , 0 , 1 ) , [ ' й ' , ч ' , ' ' ] , t r e ) ) { / always soft consonants return true ; } elseif ( S : : length ( $ substring ) > 1 & & in _array ( S : : slice ( $ substring , 1 , 2 ) , [ ' е ' , ё ' , ' ' , ' ю , ' я ' ' ь ' ] tru e ) { / / o sonants are soft if they are trailed with these vowels return true ; } } return false ; } 
public static function choose Preposition By First Letter ( $ word , $ preposition With Vowel , $ preposition ) { if ( in _array ( S : : lower ( S : : slice ( $ word , 0 , 1 ) ) , [ ' а ' , о ' , ' ' , ' у , ' э ' , tr u e ) { return $ preposition With Vowel ; } else { return $ preposition ; } } 
public static function choose Vowel After Consonant ( $ last , $ soft Last , $ after Soft , $ after Hard ) { if ( ( Russian Language : : is Hissing Consonant ( $ last ) & & ! in _array ( $ last , [ ' ж ' , ч ' ] , t ue ) ) | / static : :is Velar Consonant ( $last ) | | * / $ o ft Last ) { return $ after Soft ; } else { return $ after Hard ; } } 
public static function in ( $ word ) { $ normalized = trim ( S : : lower ( $ word ) ) ; if ( in _array ( S : : slice ( $ normalized , 0 , 1 ) , [ ' в ' , ф ' ] , t ue ) ) return ' в о ' . $ w o rd ; return ' в ' . $ w ord ; } 
public static function with ( $ word ) { $ normalized = trim ( S : : lower ( $ word ) ) ; if ( in _array ( S : : slice ( $ normalized , 0 , 1 ) , [ 'c ' , ' з ' , ш ' , ' ' ] , t r e ) & & st tic : :i s C onsonant (S : : s li ce ( $n o r malized , 1 , 2 ) | | S : s li ce ( $n o r malized , 0 , 1 ) = = ' щ ) return ' с о ' . $ w o rd ; return ' с ' . $ w ord ; } 
public static function about ( $ word ) { $ normalized = trim ( S : : lower ( $ word ) ) ; if ( static : : is Vowel ( S : : slice ( $ normalized , 0 , 1 ) ) & & ! in _array ( S : : slice ( $ normalized , 0 , 1 ) , [ ' е ' , ё ' , ' ' , ' я ] , t r u ) ) return ' о б ' . $ w o rd ; if ( in _array ( S : : slice ( $ normalized , 0 , 3 ) , [ ' в с е ' , ' в ё ' , ' в с ю ' ' ч т о ' , ' н е ' ] , tr u ) ) return ' о б о ' . $w o r d ; return ' о ' . $ w ord ; } 
public static function choose Ending By Sonority ( $ word , $ if Sonorous , $ if Deaf ) { $ last = S : : slice ( $ word , - 1 ) ; if ( static : : is Sonorous Consonant ( $ last ) ) return $ if Sonorous ; if ( static : : is Deaf Consonant ( $ last ) ) return $ if Deaf ; throw new \ Exception ( 'Not implemented ' ) ; } 
private function remove Default Arguments ( Invocation \ Static Invocation $ invocation ) { $ remover = function ( ) { Mock Function Generator : : remove Default Arguments ( $ this - > parameters ) ; } ; $ remover - > bind To ( $ invocation , Invocation \ Static Invocation : : class ) ( ) ; } 
public function get Function Mock ( $ namespace , $ name ) { $ delegate Builder = new Mock Delegate Function Builder ( ) ; $ delegate Builder - > build ( $ name ) ; $ mock = $ this - > get Mock Builder ( $ delegate Builder - > get Fully Qualified Class Name ( ) ) - > get Mock For Abstract Class ( ) ; $ mock - > _ _phpunit _get Invocation Mocker ( ) - > add Matcher ( new Default Argument Remover ( ) ) ; $ function Mock Builder = new Mock Builder ( ) ; $ function Mock Builder - > set Namespace ( $ namespace ) - > set Name ( $ name ) - > set Function Provider ( $ mock ) ; $ function Mock = $ function Mock Builder - > build ( ) ; $ function Mock - > enable ( ) ; $ this - > register For Tear Down ( $ function Mock ) ; $ proxy = new Mock Object Proxy ( $ mock ) ; return $ proxy ; } 
public function register For Tear Down ( Deactivatable $ deactivatable ) { $ result = $ this - > get Test Result Object ( ) ; $ result - > add Listener ( new Mock Disabler ( $ deactivatable ) ) ; } 
public static function define Function Mock ( $ namespace , $ name ) { $ function Mock Builder = new Mock Builder ( ) ; $ function Mock Builder - > set Namespace ( $ namespace ) - > set Name ( $ name ) - > set Function ( function ( ) { } ) - > build ( ) - > define ( ) ; } 
public function start ( ) { try { $ this - > server = Io Server : : factory ( new Http Server ( new Ws Server ( $ this ) ) , $ this - > port ) ; $ this - > trigger ( self : : EVENT _WEBSOCKET _OPEN ) ; $ this - > clients = new \ Spl Object Storage ( ) ; $ this - > server - > run ( ) ; return true ; } catch ( \ Exception $ e ) { $ error Event = new Exception Event ( [ 'exception ' = > $ e ] ) ; $ this - > trigger ( self : : EVENT _WEBSOCKET _OPEN _ERROR , $ error Event ) ; return false ; } } 
function on Open ( Connection Interface $ conn ) { $ this - > trigger ( self : : EVENT _CLIENT _CONNECTED , new WSClient Event ( [ 'client ' = > $ conn ] ) ) ; $ this - > clients - > attach ( $ conn ) ; } 
function on Close ( Connection Interface $ conn ) { $ this - > trigger ( self : : EVENT _CLIENT _DISCONNECTED , new WSClient Event ( [ 'client ' = > $ conn ] ) ) ; $ this - > clients - > detach ( $ conn ) ; } 
function on Error ( Connection Interface $ conn , \ Exception $ e ) { $ this - > trigger ( self : : EVENT _CLIENT _ERROR , new WSClient Error Event ( [ 'client ' = > $ conn , 'exception ' = > $ e ] ) ) ; if ( $ this - > close Connection On Error ) { $ conn - > close ( ) ; } } 
function on Message ( Connection Interface $ from , $ msg ) { $ this - > trigger ( self : : EVENT _CLIENT _MESSAGE , new WSClient Message Event ( [ 'client ' = > $ from , 'message ' = > $ msg ] ) ) ; if ( $ this - > run Client Commands ) { $ command = $ this - > get Command ( $ from , $ msg ) ; if ( $ command & & method _exists ( $ this , 'command ' . ucfirst ( $ command ) ) ) { $ this - > trigger ( self : : EVENT _CLIENT _RUN _COMMAND , new WSClient Command Event ( [ 'client ' = > $ from , 'command ' = > $ command ] ) ) ; $ result = call _user _func ( [ $ this , 'command ' . ucfirst ( $ command ) ] , $ from , $ msg ) ; $ this - > trigger ( self : : EVENT _CLIENT _END _COMMAND , new WSClient Command Event ( [ 'client ' = > $ from , 'command ' = > $ command , 'result ' = > $ result ] ) ) ; } } } 
public static function flag ( $ code = 'default ' ) { if ( $ code = = 'default ' ) { $ code = app ( ) - > get Locale ( ) ; } $ name = self : : get Name ( $ code ) ; $ code = self : : country ( $ code ) ; return view ( 'vendor .language .flag ' , compact ( 'code ' , 'name ' ) ) ; } 
public static function country ( $ locale = 'default ' ) { if ( $ locale = = 'default ' ) { $ locale = app ( ) - > get Locale ( ) ; } if ( config ( 'language .mode .code ' , 'short ' ) = = 'short ' ) { $ code = strtolower ( substr ( self : : get Long Code ( $ locale ) , 3 ) ) ; } else { $ code = strtolower ( substr ( $ locale , 3 ) ) ; } return $ code ; } 
public static function allowed ( $ locale = null ) { if ( $ locale ) { return in _array ( $ locale , array _keys ( self : : allowed ( ) ) ) ; } if ( config ( 'language .allowed ' ) ) { return self : : names ( array _merge ( config ( 'language .allowed ' ) , [ config ( 'app .locale ' ) ] ) ) ; } else { return self : : names ( [ config ( 'app .locale ' ) ] ) ; } } 
public static function names ( $ codes ) { 
public static function codes ( $ langs ) { 
public static function get Code ( $ name = 'default ' ) { if ( $ name = = 'default ' ) { $ name = self : : get Name ( ) ; } return self : : codes ( [ $ name ] ) [ $ name ] ; } 
public static function get Long Code ( $ short = 'default ' ) { if ( $ short = = 'default ' ) { $ short = app ( ) - > get Locale ( ) ; } $ long = 'en -GB ' ; 
public static function get Name ( $ code = 'default ' ) { if ( $ code = = 'default ' ) { $ code = app ( ) - > get Locale ( ) ; } return self : : names ( [ $ code ] ) [ $ code ] ; } 
public function boot ( Router $ router ) { if ( ! $ this - > app - > routes Are Cached ( ) ) { require _ _DIR _ _ . ' /Routes /web .php ' ; } $ this - > publishes ( [ _ _DIR _ _ . ' /Config /language .php ' = > config _path ( 'language .php ' ) , _ _DIR _ _ . ' /Migrations / 2 0 2 0 _ 0 1 _ 0 1 _ 0 0 0 0 0 0 _add _locale _column .php ' = > database _path ( 'migrations / 2 0 2 0 _ 0 1 _ 0 1 _ 0 0 0 0 0 0 _add _locale _column .php ' ) , _ _DIR _ _ . ' /Resources /views /flag .blade .php ' = > resource _path ( 'views /vendor /language /flag .blade .php ' ) , _ _DIR _ _ . ' /Resources /views /flags .blade .php ' = > resource _path ( 'views /vendor /language /flags .blade .php ' ) , ] , 'language ' ) ; $ router - > alias Middleware ( 'language ' , config ( 'language .middleware ' ) ) ; $ this - > app - > register ( Identify Service Provider : : class ) ; $ this - > app - > singleton ( 'language ' , function ( $ app ) { return new Language ( $ app ) ; } ) ; } 
private function set Locale ( $ locale , $ request ) { 
public function home ( $ locale , Request $ request ) { $ this - > set Locale ( $ locale , $ request ) ; $ url = config ( 'language .url ' ) ? url ( ' / ' . $ locale ) : url ( ' / ' ) ; return redirect ( $ url ) ; } 
public function back ( $ locale , Request $ request ) { $ this - > set Locale ( $ locale , $ request ) ; $ session = $ request - > session ( ) ; if ( config ( 'language .url ' ) ) { $ previous _url = substr ( str _replace ( env ( 'APP _URL ' ) , ' ' , $ session - > previous Url ( ) ) , 7 ) ; if ( strlen ( $ previous _url ) = = 3 ) { $ previous _url = substr ( $ previous _url , 3 ) ; } else { $ previous _url = substr ( $ previous _url , strrpos ( $ previous _url , ' / ' ) + 1 ) ; } $ url = rtrim ( env ( 'APP _URL ' ) , ' / ' ) . ' / ' . $ locale . ' / ' . ltrim ( $ previous _url , ' / ' ) ; $ session - > set Previous Url ( $ url ) ; } return redirect ( $ session - > previous Url ( ) ) ; } 
private function set Locale ( $ locale ) { 
public function handle ( $ request , Closure $ next ) { if ( $ request - > has ( 'lang ' ) ) { $ this - > set Locale ( $ request - > get ( 'lang ' ) ) ; } elseif ( auth ( ) - > check ( ) ) { $ this - > set User Locale ( ) ; } else { $ this - > set System Locale ( $ request ) ; } return $ next ( $ request ) ; } 
public function index Where ( $ callable ) { foreach ( $ this - > elements as $ i = > $ element ) { if ( call _user _func ( $ callable , $ element ) = = = true ) { return $ i ; } } return - 1 ; } 
public function get ( $ index ) { if ( ! isset ( $ this - > elements [ $ index ] ) ) { throw new Out Of Bounds Exception ( sprintf ( 'The index " %s " does not exist in this sequence . ' , $ index ) ) ; } return $ this - > elements [ $ index ] ; } 
public function remove ( $ index ) { if ( ! isset ( $ this - > elements [ $ index ] ) ) { throw new Out Of Bounds Exception ( sprintf ( 'The index " %d " is not in the interval [ 0 , %d ) . ' , $ index , count ( $ this - > elements ) ) ) ; } $ element = $ this - > elements [ $ index ] ; unset ( $ this - > elements [ $ index ] ) ; $ this - > elements = array _values ( $ this - > elements ) ; return $ element ; } 
public function update ( $ index , $ value ) { if ( ! isset ( $ this - > elements [ $ index ] ) ) { throw new \ Invalid Argument Exception ( sprintf ( 'There is no element at index " %d " . ' , $ index ) ) ; } $ this - > elements [ $ index ] = $ value ; } 
public function take While ( $ callable ) { $ new Elements = array ( ) ; for ( $ i = 0 , $ c = count ( $ this - > elements ) ; $ i < $ c ; $ i + + ) { if ( call _user _func ( $ callable , $ this - > elements [ $ i ] ) ! = = true ) { break ; } $ new Elements [ ] = $ this - > elements [ $ i ] ; } return $ this - > create New ( $ new Elements ) ; } 
public function set Server ( $ host , $ port , $ secure = null ) { $ this - > host = $ host ; $ this - > port = $ port ; $ this - > secure = $ secure ; if ( ! $ this - > ehlo ) $ this - > ehlo = $ host ; $ this - > logger & & $ this - > logger - > debug ( "Set : the server " ) ; return $ this ; } 
public function set Auth ( $ username , $ password ) { $ this - > username = $ username ; $ this - > password = $ password ; $ this - > logger & & $ this - > logger - > debug ( "Set : the auth login " ) ; return $ this ; } 
public function set OAuth ( $ access Token ) { $ this - > oauth Token = $ access Token ; $ this - > logger & & $ this - > logger - > debug ( "Set : the auth oauthbearer " ) ; return $ this ; } 
public function send ( Message $ message ) { $ this - > logger & & $ this - > logger - > debug ( 'Set : a message will be sent ' ) ; $ this - > message = $ message ; $ this - > connect ( ) - > ehlo ( ) ; if ( $ this - > secure = = = 'tls ' | | $ this - > secure = = = 'tlsv 1 . 0 ' | | $ this - > secure = = = 'tlsv 1 . 1 ' | $ this - > secure = = = 'tlsv 1 . 2 ' ) { $ this - > starttls ( ) - > ehlo ( ) ; } if ( $ this - > username ! = = null | | $ this - > password ! = = null ) { $ this - > auth Login ( ) ; } elseif ( $ this - > oauth Token ! = = null ) { $ this - > auth OAuth Bearer ( ) ; } $ this - > mail From ( ) - > rcpt To ( ) - > data ( ) - > quit ( ) ; return fclose ( $ this - > smtp ) ; } 
protected function connect ( ) { $ this - > logger & & $ this - > logger - > debug ( "Connecting to { $this - >host } at { $this - >port } " ) ; $ host = ( $ this - > secure = = 'ssl ' ) ? 'ssl : / / ' . $ this - > host : $ this - > host ; $ this - > smtp = @ fsockopen ( $ host , $ this - > port ) ; 
protected function starttls ( ) { $ in = "STARTTLS " . $ this - > CRLF ; $ code = $ this - > push Stack ( $ in ) ; if ( $ code ! = = ' 2 2 0 ' ) { throw new Code Exception ( ' 2 2 0 ' , $ code , array _pop ( $ this - > result Stack ) ) ; } if ( $ this - > secure ! = = 'tls ' & & version _compare ( phpversion ( ) , ' 5 . 6 . 0 ' , ' < ' ) ) { throw new Crypto Exception ( 'Crypto type expected PHP 5 . 6 or greater ' ) ; } switch ( $ this - > secure ) { case 'tlsv 1 . 0 ' : $ crypto _type = STREAM _CRYPTO _METHOD _TLSv 1 _ 0 _CLIENT ; break ; case 'tlsv 1 . 1 ' : $ crypto _type = STREAM _CRYPTO _METHOD _TLSv 1 _ 1 _CLIENT ; break ; case 'tlsv 1 . 2 ' : $ crypto _type = STREAM _CRYPTO _METHOD _TLSv 1 _ 2 _CLIENT ; break ; default : $ crypto _type = STREAM _CRYPTO _METHOD _TLS _CLIENT ; break ; } if ( ! \ stream _socket _enable _crypto ( $ this - > smtp , true , $ crypto _type ) ) { throw new Crypto Exception ( "Start TLS failed to enable crypto " ) ; } return $ this ; } 
protected function auth Login ( ) { $ in = "AUTH LOGIN " . $ this - > CRLF ; $ code = $ this - > push Stack ( $ in ) ; if ( $ code ! = = ' 3 3 4 ' ) { throw new Code Exception ( ' 3 3 4 ' , $ code , array _pop ( $ this - > result Stack ) ) ; } $ in = base 6 4 _encode ( $ this - > username ) . $ this - > CRLF ; $ code = $ this - > push Stack ( $ in ) ; if ( $ code ! = = ' 3 3 4 ' ) { throw new Code Exception ( ' 3 3 4 ' , $ code , array _pop ( $ this - > result Stack ) ) ; } $ in = base 6 4 _encode ( $ this - > password ) . $ this - > CRLF ; $ code = $ this - > push Stack ( $ in ) ; if ( $ code ! = = ' 2 3 5 ' ) { throw new Code Exception ( ' 2 3 5 ' , $ code , array _pop ( $ this - > result Stack ) ) ; } return $ this ; } 
protected function auth OAuth Bearer ( ) { $ auth Str = sprintf ( "n ,a = %s , %shost = %s %sport = %s %sauth =Bearer %s %s %s " , $ this - > message - > get From Email ( ) , chr ( 1 ) , $ this - > host , chr ( 1 ) , $ this - > port , chr ( 1 ) , $ this - > oauth Token , chr ( 1 ) , chr ( 1 ) ) ; $ auth Str = base 6 4 _encode ( $ auth Str ) ; $ in = "AUTH OAUTHBEARER $auth Str " . $ this - > CRLF ; $ code = $ this - > push Stack ( $ in ) ; if ( $ code ! = = ' 2 3 5 ' ) { throw new Code Exception ( ' 2 3 5 ' , $ code , array _pop ( $ this - > result Stack ) ) ; } return $ this ; } 
protected function auth XOAuth 2 ( ) { $ auth Str = sprintf ( "user = %s %sauth =Bearer %s %s %s " , $ this - > message - > get From Email ( ) , chr ( 1 ) , $ this - > oauth Token , chr ( 1 ) , chr ( 1 ) ) ; $ auth Str = base 6 4 _encode ( $ auth Str ) ; $ in = "AUTH XOAUTH 2 $auth Str " . $ this - > CRLF ; $ code = $ this - > push Stack ( $ in ) ; if ( $ code ! = = ' 2 3 5 ' ) { throw new Code Exception ( ' 2 3 5 ' , $ code , array _pop ( $ this - > result Stack ) ) ; } return $ this ; } 
protected function rcpt To ( ) { $ to = array _merge ( $ this - > message - > get To ( ) , $ this - > message - > get Cc ( ) , $ this - > message - > get Bcc ( ) ) ; foreach ( $ to as $ to Email = > $ _ ) { $ in = "RCPT TO : < " . $ to Email . " > " . $ this - > CRLF ; $ code = $ this - > push Stack ( $ in ) ; if ( $ code ! = = ' 2 5 0 ' ) { throw new Code Exception ( ' 2 5 0 ' , $ code , array _pop ( $ this - > result Stack ) ) ; } } return $ this ; } 
protected function data ( ) { $ in = "DATA " . $ this - > CRLF ; $ code = $ this - > push Stack ( $ in ) ; if ( $ code ! = = ' 3 5 4 ' ) { throw new Code Exception ( ' 3 5 4 ' , $ code , array _pop ( $ this - > result Stack ) ) ; } $ in = $ this - > message - > to String ( ) ; $ code = $ this - > push Stack ( $ in ) ; if ( $ code ! = = ' 2 5 0 ' ) { throw new Code Exception ( ' 2 5 0 ' , $ code , array _pop ( $ this - > result Stack ) ) ; } return $ this ; } 
protected function quit ( ) { $ in = "QUIT " . $ this - > CRLF ; $ code = $ this - > push Stack ( $ in ) ; if ( $ code ! = = ' 2 2 1 ' ) { throw new Code Exception ( ' 2 2 1 ' , $ code , array _pop ( $ this - > result Stack ) ) ; } return $ this ; } 
protected function get Code ( ) { while ( $ str = fgets ( $ this - > smtp , 5 1 5 ) ) { $ this - > logger & & $ this - > logger - > debug ( "Got : " . $ str ) ; $ this - > result Stack [ ] = $ str ; if ( substr ( $ str , 3 , 1 ) = = " " ) { $ code = substr ( $ str , 0 , 3 ) ; return $ code ; } } throw new SMTPException ( "SMTP Server did not respond with anything I recognized " ) ; } 
public function set Server ( $ host , $ port , $ secure = null ) { $ this - > smtp - > set Server ( $ host , $ port , $ secure ) ; return $ this ; } 
public function set From ( $ name , $ email ) { $ this - > from Name = $ name ; $ this - > from Email = $ email ; return $ this ; } 
public function set Fake From ( $ name , $ email ) { $ this - > fake From Name = $ name ; $ this - > fake From Email = $ email ; return $ this ; } 
protected function create Header ( ) { $ this - > header [ 'Date ' ] = date ( 'r ' ) ; $ from Name = " " ; $ from Email = $ this - > from Email ; if ( ! empty ( $ this - > from Name ) ) { $ from Name = sprintf ( " = ?utf - 8 ?B ? %s ? = " , base 6 4 _encode ( $ this - > from Name ) ) ; } if ( ! empty ( $ this - > fake From Email ) ) { if ( ! empty ( $ this - > fake From Name ) ) { $ from Name = sprintf ( " = ?utf - 8 ?B ? %s ? = " , base 6 4 _encode ( $ this - > fake From Name ) ) ; } $ from Email = $ this - > fake From Email ; } $ this - > header [ 'Return -Path ' ] = $ from Email ; $ this - > header [ 'From ' ] = $ from Name . " < " . $ from Email . " > " ; $ this - > header [ 'To ' ] = ' ' ; foreach ( $ this - > to as $ to Email = > $ to Name ) { if ( ! empty ( $ to Name ) ) { $ to Name = sprintf ( " = ?utf - 8 ?B ? %s ? = " , base 6 4 _encode ( $ to Name ) ) ; } $ this - > header [ 'To ' ] . = $ to Name . " < " . $ to Email . " > , " ; } $ this - > header [ 'To ' ] = substr ( $ this - > header [ 'To ' ] , 0 , - 2 ) ; $ this - > header [ 'Cc ' ] = ' ' ; foreach ( $ this - > cc as $ to Email = > $ to Name ) { if ( ! empty ( $ to Name ) ) { $ to Name = sprintf ( " = ?utf - 8 ?B ? %s ? = " , base 6 4 _encode ( $ to Name ) ) ; } $ this - > header [ 'Cc ' ] . = $ to Name . " < " . $ to Email . " > , " ; } $ this - > header [ 'Cc ' ] = substr ( $ this - > header [ 'Cc ' ] , 0 , - 2 ) ; $ this - > header [ 'Bcc ' ] = ' ' ; foreach ( $ this - > bcc as $ to Email = > $ to Name ) { if ( ! empty ( $ to Name ) ) { $ to Name = sprintf ( " = ?utf - 8 ?B ? %s ? = " , base 6 4 _encode ( $ to Name ) ) ; } $ this - > header [ 'Bcc ' ] . = $ to Name . " < " . $ to Email . " > , " ; } $ this - > header [ 'Bcc ' ] = substr ( $ this - > header [ 'Bcc ' ] , 0 , - 2 ) ; $ reply To Name = " " ; if ( ! empty ( $ this - > reply To Email ) ) { if ( ! empty ( $ this - > reply To Name ) ) { $ reply To Name = sprintf ( " = ?utf - 8 ?B ? %s ? = " , base 6 4 _encode ( $ this - > reply To Name ) ) ; } $ this - > header [ 'Reply -To ' ] = $ reply To Name . " < " . $ this - > reply To Email . " > " ; } if ( empty ( $ this - > subject ) ) { $ subject = ' ' ; } else { $ subject = sprintf ( " = ?utf - 8 ?B ? %s ? = " , base 6 4 _encode ( $ this - > subject ) ) ; } $ this - > header [ 'Subject ' ] = $ subject ; $ this - > header [ 'Message -ID ' ] = ' < ' . md 5 ( uniqid ( ) ) . ' @ ' . $ this - > from Email . ' > ' ; $ this - > header [ 'X -Priority ' ] = ' 3 ' ; $ this - > header [ 'X -Mailer ' ] = 'Mailer (https : / /github .com /txthinking /Mailer ) ' ; $ this - > header [ 'MIME -Version ' ] = ' 1 . 0 ' ; if ( ! empty ( $ this - > attachment ) ) { $ this - > boundary Mixed = md 5 ( md 5 ( time ( ) . 'Tx Mailer ' ) . uniqid ( ) ) ; $ this - > header [ 'Content -Type ' ] = "multipart /mixed ; \r \n \tboundary = \ " " . $ this - > boundary Mixed . " \ " " ; } $ this - > boundary Alternative = md 5 ( md 5 ( time ( ) . 'TXMailer ' ) . uniqid ( ) ) ; return $ this ; } 
protected function create Body ( ) { $ in = " " ; $ in . = "Content -Type : multipart /alternative ; boundary = \ " $this - >boundary Alternative \ " " . $ this - > CRLF ; $ in . = $ this - > CRLF ; $ in . = " - - " . $ this - > boundary Alternative . $ this - > CRLF ; $ in . = "Content -Type : text /plain ; charset = \ " " . $ this - > charset . " \ " " . $ this - > CRLF ; $ in . = "Content -Transfer -Encoding : base 6 4 " . $ this - > CRLF ; $ in . = $ this - > CRLF ; $ in . = chunk _split ( base 6 4 _encode ( $ this - > body ) ) . $ this - > CRLF ; $ in . = $ this - > CRLF ; $ in . = " - - " . $ this - > boundary Alternative . $ this - > CRLF ; $ in . = "Content -Type : text /html ; charset = \ " " . $ this - > charset . " \ " " . $ this - > CRLF ; $ in . = "Content -Transfer -Encoding : base 6 4 " . $ this - > CRLF ; $ in . = $ this - > CRLF ; $ in . = chunk _split ( base 6 4 _encode ( $ this - > body ) ) . $ this - > CRLF ; $ in . = $ this - > CRLF ; $ in . = " - - " . $ this - > boundary Alternative . " - - " . $ this - > CRLF ; return $ in ; } 
protected function create Body With Attachment ( ) { $ in = " " ; $ in . = $ this - > CRLF ; $ in . = $ this - > CRLF ; $ in . = ' - - ' . $ this - > boundary Mixed . $ this - > CRLF ; $ in . = "Content -Type : multipart /alternative ; boundary = \ " $this - >boundary Alternative \ " " . $ this - > CRLF ; $ in . = $ this - > CRLF ; $ in . = " - - " . $ this - > boundary Alternative . $ this - > CRLF ; $ in . = "Content -Type : text /plain ; charset = \ " " . $ this - > charset . " \ " " . $ this - > CRLF ; $ in . = "Content -Transfer -Encoding : base 6 4 " . $ this - > CRLF ; $ in . = $ this - > CRLF ; $ in . = chunk _split ( base 6 4 _encode ( $ this - > body ) ) . $ this - > CRLF ; $ in . = $ this - > CRLF ; $ in . = " - - " . $ this - > boundary Alternative . $ this - > CRLF ; $ in . = "Content -Type : text /html ; charset = \ " " . $ this - > charset . " \ " " . $ this - > CRLF ; $ in . = "Content -Transfer -Encoding : base 6 4 " . $ this - > CRLF ; $ in . = $ this - > CRLF ; $ in . = chunk _split ( base 6 4 _encode ( $ this - > body ) ) . $ this - > CRLF ; $ in . = $ this - > CRLF ; $ in . = " - - " . $ this - > boundary Alternative . " - - " . $ this - > CRLF ; foreach ( $ this - > attachment as $ name = > $ path ) { $ in . = $ this - > CRLF ; $ in . = ' - - ' . $ this - > boundary Mixed . $ this - > CRLF ; $ in . = "Content -Type : application /octet -stream ; name = \ " " . $ name . " \ " " . $ this - > CRLF ; $ in . = "Content -Transfer -Encoding : base 6 4 " . $ this - > CRLF ; $ in . = "Content -Disposition : attachment ; filename = \ " " . $ name . " \ " " . $ this - > CRLF ; $ in . = $ this - > CRLF ; $ in . = chunk _split ( base 6 4 _encode ( file _get _contents ( $ path ) ) ) . $ this - > CRLF ; } $ in . = $ this - > CRLF ; $ in . = $ this - > CRLF ; $ in . = ' - - ' . $ this - > boundary Mixed . ' - - ' . $ this - > CRLF ; return $ in ; } 
public function find File ( $ class ) { $ file = wincache _ucache _get ( $ this - > prefix . $ class , $ success ) ; if ( ! $ success ) { wincache _ucache _set ( $ this - > prefix . $ class , $ file = $ this - > decorated - > find File ( $ class ) ? : null , 0 ) ; } return $ file ; } 
public function find File ( $ class ) { $ file = apcu _fetch ( $ this - > prefix . $ class , $ success ) ; if ( ! $ success ) { apcu _store ( $ this - > prefix . $ class , $ file = $ this - > decorated - > find File ( $ class ) ? : null ) ; } return $ file ; } 
public static function load ( $ classes , $ cache Dir , $ name , $ auto Reload , $ adaptive = false , $ extension = ' .php ' ) { 
public static function inline ( $ classes , $ cache , array $ excluded ) { $ declared = array ( ) ; foreach ( self : : get Ordered Classes ( $ excluded ) as $ class ) { $ declared [ $ class - > get Name ( ) ] = true ; } ' ( ? : ^ < \ ?php \s .declare . \ ( .strict _types . = . 1 . \ ) . ; | \b _ _halt _compiler . \ ( . \ ) | \b _ _ ( ? :DIR |FILE ) _ _ \b ) 'isx REGEX ; $ dont Inline Regex = str _replace ( ' . ' , $ spaces Regex , $ dont Inline Regex ) ; $ cache Dir = explode ( ' / ' , str _replace ( DIRECTORY _SEPARATOR , ' / ' , $ cache Dir ) ) ; $ files = array ( ) ; $ content = ' ' ; foreach ( self : : get Ordered Classes ( $ classes ) as $ class ) { if ( isset ( $ declared [ $ class - > get Name ( ) ] ) ) { continue ; } $ declared [ $ class - > get Name ( ) ] = true ; $ files [ $ class - > get Name ( ) ] = $ file = $ class - > get File Name ( ) ; $ c = file _get _contents ( $ file ) ; if ( preg _match ( $ dont Inline Regex , $ c ) ) { $ file = explode ( ' / ' , str _replace ( DIRECTORY _SEPARATOR , ' / ' , $ file ) ) ; for ( $ i = 0 ; isset ( $ file [ $ i ] , $ cache Dir [ $ i ] ) ; + + $ i ) { if ( $ file [ $ i ] ! = = $ cache Dir [ $ i ] ) { break ; } } if ( 1 > = $ i ) { $ file = var _export ( implode ( ' / ' , $ file ) , true ) ; } else { $ file = array _slice ( $ file , $ i ) ; $ file = str _repeat ( ' . . / ' , count ( $ cache Dir ) - $ i ) . implode ( ' / ' , $ file ) ; $ file = ' _ _DIR _ _ . ' . var _export ( ' / ' . $ file , true ) ; } $ c = " \nnamespace {require $file ; } " ; } else { $ c = preg _replace ( array ( ' / ^ \s * < \ ?php / ' , ' / \ ? > \s * $ / ' ) , ' ' , $ c ) ; 
public static function fix Namespace Declarations ( $ source ) { if ( ! function _exists ( 'token _get _all ' ) | | ! self : : $ use Tokenizer ) { if ( preg _match ( ' / ( ^ | \s )namespace ( . * ? ) \s * ; / ' , $ source ) ) { $ source = preg _replace ( ' / ( ^ | \s )namespace ( . * ? ) \s * ; / ' , " $ 1namespace $ 2 \n { " , $ source ) . " } \n " ; } return $ source ; } $ raw Chunk = ' ' ; $ output = ' ' ; $ in Namespace = false ; $ tokens = token _get _all ( $ source ) ; for ( $ i = 0 ; isset ( $ tokens [ $ i ] ) ; + + $ i ) { $ token = $ tokens [ $ i ] ; if ( ! isset ( $ token [ 1 ] ) | | 'b " ' = = = $ token ) { $ raw Chunk . = $ token ; } elseif ( in _array ( $ token [ 0 ] , array ( T _COMMENT , T _DOC _COMMENT ) ) ) { 
private static function write Cache File ( $ file , $ content ) { $ dir = dirname ( $ file ) ; if ( ! is _writable ( $ dir ) ) { throw new \ Runtime Exception ( sprintf ( 'Cache directory " %s " is not writable . ' , $ dir ) ) ; } $ tmp File = tempnam ( $ dir , basename ( $ file ) ) ; if ( false ! = = @ file _put _contents ( $ tmp File , $ content ) & & @ rename ( $ tmp File , $ file ) ) { @ chmod ( $ file , 0 6 6 6 & ~ umask ( ) ) ; return ; } throw new \ Runtime Exception ( sprintf ( 'Failed to write cache file " %s " . ' , $ file ) ) ; } 
private static function get Ordered Classes ( array $ classes ) { $ map = array ( ) ; self : : $ seen = array ( ) ; foreach ( $ classes as $ class ) { try { $ reflection Class = new \ Reflection Class ( $ class ) ; } catch ( \ Reflection Exception $ e ) { throw new \ Invalid Argument Exception ( sprintf ( 'Unable to load class " %s " ' , $ class ) ) ; } $ map = array _merge ( $ map , self : : get Class Hierarchy ( $ reflection Class ) ) ; } return $ map ; } 
public function add Prefixes ( array $ prefixes ) { foreach ( $ prefixes as $ prefix = > $ path ) { $ this - > add Prefix ( $ prefix , $ path ) ; } } 
public function add Prefix ( $ prefix , $ paths ) { if ( ! $ prefix ) { foreach ( ( array ) $ paths as $ path ) { $ this - > fallback Dirs [ ] = $ path ; } return ; } if ( isset ( $ this - > prefixes [ $ prefix ] ) ) { if ( is _array ( $ paths ) ) { $ this - > prefixes [ $ prefix ] = array _unique ( array _merge ( $ this - > prefixes [ $ prefix ] , $ paths ) ) ; } elseif ( ! in _array ( $ paths , $ this - > prefixes [ $ prefix ] ) ) { $ this - > prefixes [ $ prefix ] [ ] = $ paths ; } } else { $ this - > prefixes [ $ prefix ] = array _unique ( ( array ) $ paths ) ; } } 
public function find File ( $ class ) { if ( xcache _isset ( $ this - > prefix . $ class ) ) { $ file = xcache _get ( $ this - > prefix . $ class ) ; } else { $ file = $ this - > decorated - > find File ( $ class ) ? : null ; xcache _set ( $ this - > prefix . $ class , $ file ) ; } return $ file ; } 
public function parse ( $ text ) { $ this - > prepare ( ) ; if ( ltrim ( $ text ) = = = ' ' ) { return ' ' ; } $ text = str _replace ( [ " \r \n " , " \n \r " , " \r " ] , " \n " , $ text ) ; $ this - > prepare Markers ( $ text ) ; $ absy = $ this - > parse Blocks ( explode ( " \n " , $ text ) ) ; $ markup = $ this - > render Absy ( $ absy ) ; $ this - > cleanup ( ) ; return $ markup ; } 
public function parse Paragraph ( $ text ) { $ this - > prepare ( ) ; if ( ltrim ( $ text ) = = = ' ' ) { return ' ' ; } $ text = str _replace ( [ " \r \n " , " \n \r " , " \r " ] , " \n " , $ text ) ; $ this - > prepare Markers ( $ text ) ; $ absy = $ this - > parse Inline ( $ text ) ; $ markup = $ this - > render Absy ( $ absy ) ; $ this - > cleanup ( ) ; return $ markup ; } 
protected function detect Line Type ( $ lines , $ current ) { $ line = $ lines [ $ current ] ; $ block Types = $ this - > block Types ( ) ; foreach ( $ block Types as $ block Type ) { if ( $ this - > { 'identify ' . $ block Type } ( $ line , $ lines , $ current ) ) { return $ block Type ; } } 
protected function parse Blocks ( $ lines ) { if ( $ this - > _depth > = $ this - > maximum Nesting Level ) { 
protected function parse Block ( $ lines , $ current ) { 
protected function consume Paragraph ( $ lines , $ current ) { 
protected function inline Markers ( ) { $ markers = [ ] ; 
protected function prepare Markers ( $ text ) { $ this - > _inline Markers = [ ] ; foreach ( $ this - > inline Markers ( ) as $ marker = > $ method ) { if ( strpos ( $ text , $ marker ) ! = = false ) { $ m = $ marker [ 0 ] ; 
protected function parse Inline ( $ text ) { if ( $ this - > _depth > = $ this - > maximum Nesting Level ) { 
protected function parse Emph Strong ( $ text ) { $ marker = $ text [ 0 ] ; if ( ! isset ( $ text [ 1 ] ) ) { return [ [ 'text ' , $ text [ 0 ] ] , 1 ] ; } if ( $ marker = = $ text [ 1 ] ) { 
protected function identify Html ( $ line , $ lines , $ current ) { if ( $ line [ 0 ] ! = = ' < ' | | isset ( $ line [ 1 ] ) & & $ line [ 1 ] = = ' ' ) { return false ; 
protected function consume Html ( $ lines , $ current ) { $ content = [ ] ; if ( strncmp ( $ lines [ $ current ] , ' < ! - - ' , 4 ) = = = 0 ) { 
protected function parse Inline Html ( $ text ) { if ( strpos ( $ text , ' > ' ) ! = = false ) { if ( preg _match ( ' ~ ^ < / ? ( \w + \d ? ) ( . * ? ) ? > ~s ' , $ text , $ matches ) ) { 
protected function identify Fenced Code ( $ line ) { return ( $ line [ 0 ] = = = ' ` ' & & strncmp ( $ line , ' ` ` ` ' , 3 ) = = = 0 ) | | ( $ line [ 0 ] = = = ' ~ ' & & strncmp ( $ line , ' ~ ~ ~ ' , 3 ) = = = 0 ) | | ( isset ( $ line [ 3 ] ) & & ( ( $ line [ 3 ] = = = ' ` ' & & strncmp ( ltrim ( $ line ) , ' ` ` ` ' , 3 ) = = = 0 ) | | ( $ line [ 3 ] = = = ' ~ ' & & strncmp ( ltrim ( $ line ) , ' ~ ~ ~ ' , 3 ) = = = 0 ) ) ) ; } 
protected function consume Fenced Code ( $ lines , $ current ) { $ line = ltrim ( $ lines [ $ current ] ) ; $ fence = substr ( $ line , 0 , $ pos = strrpos ( $ line , $ line [ 0 ] ) + 1 ) ; $ language = rtrim ( substr ( $ line , $ pos ) ) ; 
protected function identify Headline ( $ line , $ lines , $ current ) { return ( 
protected function consume Headline ( $ lines , $ current ) { if ( $ lines [ $ current ] [ 0 ] = = = ' # ' ) { 
protected function replace Escape ( $ text ) { $ strtr = [ ] ; foreach ( $ this - > escape Characters as $ char ) { $ strtr [ " \ \ $char " ] = $ char ; } return strtr ( $ text , $ strtr ) ; } 
protected function parse Link ( $ markdown ) { if ( ! in _array ( 'parse Link ' , array _slice ( $ this - > context , 1 ) ) & & ( $ parts = $ this - > parse Link Or Image ( $ markdown ) ) ! = = false ) { list ( $ text , $ url , $ title , $ offset , $ key ) = $ parts ; return [ [ 'link ' , 'text ' = > $ this - > parse Inline ( $ text ) , 'url ' = > $ url , 'title ' = > $ title , 'refkey ' = > $ key , 'orig ' = > substr ( $ markdown , 0 , $ offset ) , ] , $ offset ] ; } else { 
protected function parse Image ( $ markdown ) { if ( ( $ parts = $ this - > parse Link Or Image ( substr ( $ markdown , 1 ) ) ) ! = = false ) { list ( $ text , $ url , $ title , $ offset , $ key ) = $ parts ; return [ [ 'image ' , 'text ' = > $ text , 'url ' = > $ url , 'title ' = > $ title , 'refkey ' = > $ key , 'orig ' = > substr ( $ markdown , 0 , $ offset + 1 ) , ] , $ offset + 1 ] ; } else { 
protected function parse Lt ( $ text ) { if ( strpos ( $ text , ' > ' ) ! = = false ) { if ( ! in _array ( 'parse Link ' , $ this - > context ) ) { 
protected function parse Inline Code ( $ text ) { if ( preg _match ( ' / ^ ( ` ` + ) \s ( . + ? ) \s \ 1 /s ' , $ text , $ matches ) ) { 
protected function consume Paragraph ( $ lines , $ current ) { 
protected function render Text ( $ text ) { if ( $ this - > enable Newlines ) { $ br = $ this - > html 5 ? " <br > \n " : " <br / > \n " ; return strtr ( $ text [ 1 ] , [ " \n " = > $ br , " \n " = > $ br ] ) ; } else { return parent : : render Text ( $ text ) ; } } 
protected function consume Paragraph ( $ lines , $ current ) { 
protected function consume Code ( $ lines , $ current ) { 
protected function identify Ul ( $ line ) { $ l = $ line [ 0 ] ; return ( $ l = = = ' - ' | | $ l = = = ' + ' | | $ l = = = ' * ' ) & & ( isset ( $ line [ 1 ] ) & & ( ( $ l 1 = $ line [ 1 ] ) = = = ' ' | | $ l 1 = = = " \t " ) ) | | ( $ l = = = ' ' & & preg _match ( ' / ^ { 0 , 3 } [ \ - \ + \ * ] [ \t ] / ' , $ line ) ) ; } 
protected function render List ( $ block ) { $ type = $ block [ 'list ' ] ; if ( ! empty ( $ block [ 'attr ' ] ) ) { $ output = " < $type " . $ this - > generate Html Attributes ( $ block [ 'attr ' ] ) . " > \n " ; } else { $ output = " < $type > \n " ; } foreach ( $ block [ 'items ' ] as $ item = > $ item Lines ) { $ output . = ' <li > ' . $ this - > render Absy ( $ item Lines ) . " < /li > \n " ; } return $ output . " < / $type > \n " ; } 
private function generate Html Attributes ( $ attributes ) { foreach ( $ attributes as $ name = > $ value ) { $ attributes [ $ name ] = " $name = \ " $value \ " " ; } return implode ( ' ' , $ attributes ) ; } 
protected function consume Quote ( $ lines , $ current ) { 
protected function consume Reference ( $ lines , $ current ) { while ( isset ( $ lines [ $ current ] ) & & preg _match ( ' / ^ { 0 , 3 } \ [ ( . + ? ) \ ] : \s * ( . + ? ) ( ? : \s + [ \ ( \ ' " ] ( . + ? ) [ \ ) \ ' " ] ) ? \s * ( ' . $ this - > _special Attributes Regex . ' ) ? \s * $ / ' , $ lines [ $ current ] , $ matches ) ) { $ label = strtolower ( $ matches [ 1 ] ) ; $ this - > references [ $ label ] = [ 'url ' = > $ this - > replace Escape ( $ matches [ 2 ] ) , ] ; if ( isset ( $ matches [ 3 ] ) ) { $ this - > references [ $ label ] [ 'title ' ] = $ matches [ 3 ] ; } else { / / title may be on the next line if ( isset ( $ lines [ $ current + 1 ] ) & & preg _match ( ' / ^ \s + [ \ ( \ ' " ] ( . + ? ) [ \ ) \ ' " ] \s * $ / ' , $ lines [ $ current + 1 ] , $ matches ) ) { $ this - > references [ $ label ] [ 'title ' ] = $ matches [ 1 ] ; $ current + + ; } } if ( isset ( $ matches [ 5 ] ) ) { $ this - > references [ $ label ] [ 'attributes ' ] = $ matches [ 5 ] ; } $ current + + ; } return [ false , - - $ current ] ; } 
protected function consume Fenced Code ( $ lines , $ current ) { 
protected function render Headline ( $ block ) { foreach ( $ block [ 'content ' ] as $ i = > $ element ) { if ( $ element [ 0 ] = = = 'special Attributes ' ) { unset ( $ block [ 'content ' ] [ $ i ] ) ; $ block [ 'attributes ' ] = $ element [ 1 ] ; } } $ tag = 'h ' . $ block [ 'level ' ] ; $ attributes = $ this - > render Attributes ( $ block ) ; return " < $tag $attributes > " . rtrim ( $ this - > render Absy ( $ block [ 'content ' ] ) , " # \t " ) . " < / $tag > \n " ; } 
protected function parse Strike ( $ markdown ) { if ( preg _match ( ' / ^ ~ ~ ( . + ? ) ~ ~ / ' , $ markdown , $ matches ) ) { return [ [ 'strike ' , $ this - > parse Inline ( $ matches [ 1 ] ) ] , strlen ( $ matches [ 0 ] ) ] ; } return [ [ 'text ' , $ markdown [ 0 ] . $ markdown [ 1 ] ] , 2 ] ; } 
protected function identify Table ( $ line , $ lines , $ current ) { return strpos ( $ line , ' | ' ) ! = = false & & isset ( $ lines [ $ current + 1 ] ) & & preg _match ( ' ~ ^ \ \s * \ \ | ? ( \ \s * : ? - [ \ \ - \ \s ] * : ? \ \s * \ \ | ? ) * \ \s * $ ~ ' , $ lines [ $ current + 1 ] ) & & strpos ( $ lines [ $ current + 1 ] , ' | ' ) ! = = false & & isset ( $ lines [ $ current + 2 ] ) & & trim ( $ lines [ $ current + 1 ] ) ! = = ' ' ; } 
protected function consume Table ( $ lines , $ current ) { 
protected function render Table ( $ block ) { $ head = ' ' ; $ body = ' ' ; $ cols = $ block [ 'cols ' ] ; $ first = true ; foreach ( $ block [ 'rows ' ] as $ row ) { $ cell Tag = $ first ? 'th ' : 'td ' ; $ tds = ' ' ; foreach ( $ row as $ c = > $ cell ) { $ align = empty ( $ cols [ $ c ] ) ? ' ' : ' align = " ' . $ cols [ $ c ] . ' " ' ; $ tds . = " < $cell Tag $align > " . trim ( $ this - > render Absy ( $ cell ) ) . " < / $cell Tag > " ; } if ( $ first ) { $ head . = " <tr > $tds < /tr > \n " ; } else { $ body . = " <tr > $tds < /tr > \n " ; } $ first = false ; } return $ this - > compose Table ( $ head , $ body ) ; } 
protected function parse Url ( $ markdown ) { $ pattern = < < <REGEXP / ( ? (R ) # in case of recursion match parentheses \ ( ( ( ? > [ ^ \s ( ) ] + ) | ( ?R ) ) * \ ) | # else match a link with title ^ (https ? |ftp ) : \ / \ / ( ( [ ^ \s < > ( ) ] + ) | ( ?R ) ) + ( ? < ! [ \ . , : ; \ ' " ! \ ? \s ] ) ) /x REGEXP ; if ( ! in _array ( 'parse Link ' , $ this - > context ) & & preg _match ( $ pattern , $ markdown , $ matches ) ) { return [ [ 'auto Url ' , $ matches [ 0 ] ] , strlen ( $ matches [ 0 ] ) ] ; } return [ [ 'text ' , substr ( $ markdown , 0 , 4 ) ] , 4 ] ; } 
protected function do Execute ( Profile Context $ context ) { Message Context Helper : : as Saml Message ( $ context - > get Outbound Context ( ) ) - > set Version ( $ this - > version ) ; $ this - > logger - > debug ( sprintf ( 'Message Version set to " %s " ' , $ this - > version ) , Log Helper : : get Action Context ( $ context , $ this ) ) ; } 
private function get Trust Options ( Entity Descriptor $ idp Ed ) { $ trust Options = $ this - > container - > get Party Container ( ) - > get Trust Options Store ( ) - > get ( $ this - > idp Entity Id ) ? : new Trust Options ( ) ; $ want Authn Requests Signed = $ idp Ed - > get First Idp Sso Descriptor ( ) - > get Want Authn Requests Signed ( ) ; if ( null ! = = $ want Authn Requests Signed ) { $ trust Options - > set Sign Authn Request ( $ want Authn Requests Signed ) ; } return $ trust Options ; } 
public function execute ( Context Interface $ context ) { if ( $ context instanceof Profile Context ) { $ this - > do Execute ( $ context ) ; } else { $ message = sprintf ( 'Expected Profile Context but got %s ' , get _class ( $ context ) ) ; $ this - > logger - > emergency ( $ message , array ( 'context ' = > $ context ) ) ; throw new Light Saml Context Exception ( $ context , $ message ) ; } } 
public function resolve ( Criteria Set $ criteria Set , array $ candidates ) { if ( false = = = $ criteria Set - > has ( Location Criteria : : class ) ) { return $ candidates ; } $ result = array ( ) ; foreach ( $ criteria Set - > get ( Location Criteria : : class ) as $ location Criteria ) { foreach ( $ candidates as $ endpoint Reference ) { if ( $ endpoint Reference - > get Endpoint ( ) - > get Location ( ) = = $ location Criteria - > get Location ( ) ) { $ result [ ] = $ endpoint Reference ; } } } return $ result ; } 
public function set Use ( $ use ) { $ use = trim ( $ use ) ; if ( false ! = $ use & & self : : USE _ENCRYPTION ! = $ use & & self : : USE _SIGNING ! = $ use ) { throw new \ Invalid Argument Exception ( sprintf ( "Invalid use value ' %s ' " , $ use ) ) ; } $ this - > use = $ use ; return $ this ; } 
public function serialize ( \ DOMNode $ parent , Serialization Context $ context ) { $ result = $ this - > create Element ( 'Key Descriptor ' , Saml Constants : : NS _METADATA , $ parent , $ context ) ; $ this - > attributes To Xml ( array ( 'use ' ) , $ result ) ; $ key Info = $ this - > create Element ( 'ds :Key Info ' , Saml Constants : : NS _XMLDSIG , $ result , $ context ) ; $ x Data = $ this - > create Element ( 'ds :X 5 0 9Data ' , Saml Constants : : NS _XMLDSIG , $ key Info , $ context ) ; $ x Cert = $ this - > create Element ( 'ds :X 5 0 9Certificate ' , Saml Constants : : NS _XMLDSIG , $ x Data , $ context ) ; $ x Cert - > node Value = $ this - > get Certificate ( ) - > get Data ( ) ; } 
public function execute ( Context Interface $ context ) { try { $ this - > main Action - > execute ( $ context ) ; } catch ( \ Exception $ ex ) { $ exception Context = $ context - > get Sub Context ( Profile Contexts : : EXCEPTION , Exception Context : : class ) ; $ exception Context - > add Exception ( $ ex ) ; $ this - > error Action - > execute ( $ context ) ; } } 
public function decrypt Multi ( array $ input Keys ) { $ last Exception = null ; foreach ( $ input Keys as $ key ) { if ( $ key instanceof Credential Interface ) { $ key = $ key - > get Private Key ( ) ; } if ( false = = $ key instanceof XMLSecurity Key ) { throw new \ Invalid Argument Exception ( 'Expected XMLSecurity Key ' ) ; } try { return $ this - > decrypt ( $ key ) ; } catch ( \ Exception $ ex ) { $ last Exception = $ ex ; } } if ( $ last Exception ) { throw $ last Exception ; } throw new Light Saml Security Exception ( 'No key provided for decryption ' ) ; } 
public function decrypt ( XMLSecurity Key $ input Key ) { $ this - > symmetric Key = $ this - > load Symmetric Key ( ) ; $ this - > symmetric Key Info = $ this - > load Symmetric Key Info ( $ this - > symmetric Key ) ; if ( $ this - > symmetric Key Info - > is Encrypted ) { $ this - > decrypt Symmetric Key ( $ input Key ) ; } else { $ this - > symmetric Key = $ input Key ; } $ decrypted = $ this - > decrypt Cipher ( ) ; $ result = $ this - > build Xml Element ( $ decrypted ) ; return $ result ; } 
protected function build Xml Element ( $ decrypted ) { $ xml = sprintf ( ' <root xmlns :saml = "urn :oasis :names :tc :SAML : 2 . 0 :assertion " xmlns :xsi = "http : / /www .w 3 .org / 2 0 0 1 /XMLSchema -instance " > %s < /root > ' , $ decrypted ) ; $ new Doc = new \ DOMDocument ( ) ; if ( false = = @ $ new Doc - > load XML ( $ xml ) ) { throw new Light Saml Xml Exception ( 'Failed to parse decrypted XML . Maybe the wrong sharedkey was used ? ' ) ; } $ decrypted Element = $ new Doc - > first Child - > first Child ; if ( null = = $ decrypted Element ) { throw new Light Saml Security Exception ( 'Missing encrypted element . ' ) ; } if ( false = = $ decrypted Element instanceof \ DOMElement ) { throw new Light Saml Xml Exception ( 'Decrypted element was not actually a DOMElement . ' ) ; } return $ decrypted Element ; } 
protected function decrypt Cipher ( ) { $ decrypted = $ this - > xml Enc - > decrypt Node ( $ this - > symmetric Key , false ) ; if ( false = = is _string ( $ decrypted ) ) { throw new \ Logic Exception ( 'Expected decrypted string ' ) ; } return $ decrypted ; } 
protected function decrypt Symmetric Key ( XMLSecurity Key $ input Key ) { $ enc Key = $ this - > symmetric Key Info - > encrypted Ctx ; $ this - > symmetric Key Info - > key = $ input Key - > key ; $ key Size = $ this - > symmetric Key - > get Symmetric Key Size ( ) ; if ( null = = = $ key Size ) { 
protected function load Symmetric Key Info ( XMLSecurity Key $ symmetric Key ) { $ symmetric Key Info = $ this - > xml Enc - > locate Key Info ( $ symmetric Key ) ; if ( false = = $ symmetric Key Info ) { throw new Light Saml Xml Exception ( 'Could not locate <dsig :Key Info > for the encrypted key ' ) ; } return $ symmetric Key Info ; } 
protected function do Execute ( Profile Context $ context ) { $ message = Message Context Helper : : as Saml Message ( $ context - > get Inbound Context ( ) ) ; if ( false = = $ message - > get Issuer ( ) ) { $ message = 'Inbound message must have Issuer element ' ; $ this - > logger - > emergency ( $ message , Log Helper : : get Action Error Context ( $ context , $ this ) ) ; throw new Light Saml Context Exception ( $ context , $ message ) ; } if ( $ this - > allowed Format & & $ message - > get Issuer ( ) - > get Value ( ) & & $ message - > get Issuer ( ) - > get Format ( ) & & $ message - > get Issuer ( ) - > get Format ( ) ! = $ this - > allowed Format ) { $ message = sprintf ( "Response Issuer Format if set must have value ' %s ' but it was ' %s ' " , $ this - > allowed Format , $ message - > get Issuer ( ) - > get Format ( ) ) ; $ this - > logger - > emergency ( $ message , Log Helper : : get Action Error Context ( $ context , $ this ) ) ; throw new Light Saml Context Exception ( $ context , $ message ) ; } try { $ this - > name Id Validator - > validate Name Id ( $ message - > get Issuer ( ) ) ; } catch ( Light Saml Validation Exception $ ex ) { throw new Light Saml Context Exception ( $ context , $ ex - > get Message ( ) , 0 , $ ex ) ; } } 
public function validate Subject ( Subject $ subject ) { if ( false = = $ subject - > get Name ID ( ) & & false = = $ subject - > get All Subject Confirmations ( ) ) { throw new Light Saml Validation Exception ( 'Subject MUST contain either an identifier or a subject confirmation ' ) ; } if ( $ subject - > get Name ID ( ) ) { $ this - > name Id Validator - > validate Name Id ( $ subject - > get Name ID ( ) ) ; } foreach ( $ subject - > get All Subject Confirmations ( ) as $ subject Confirmation ) { $ this - > validate Subject Confirmation ( $ subject Confirmation ) ; } } 
protected function validate Subject Confirmation ( Subject Confirmation $ subject Confirmation ) { if ( false = = Helper : : validate Required String ( $ subject Confirmation - > get Method ( ) ) ) { throw new Light Saml Validation Exception ( 'Method attribute of Subject Confirmation MUST contain at least one non -whitespace character ' ) ; } if ( false = = Helper : : validate Well Formed Uri String ( $ subject Confirmation - > get Method ( ) ) ) { throw new Light Saml Validation Exception ( 'Subject Confirmation element has Method attribute which is not a wellformed absolute uri . ' ) ; } if ( $ subject Confirmation - > get Name ID ( ) ) { $ this - > name Id Validator - > validate Name Id ( $ subject Confirmation - > get Name ID ( ) ) ; } if ( $ subject Confirmation - > get Subject Confirmation Data ( ) ) { $ this - > validate Subject Confirmation Data ( $ subject Confirmation - > get Subject Confirmation Data ( ) ) ; } } 
public function load Pem ( $ data ) { $ pattern = ' / ^ - - - - -BEGIN CERTIFICATE - - - - - ( [ ^ - ] * ) ^ - - - - -END CERTIFICATE - - - - - /m ' ; if ( false = = preg _match ( $ pattern , $ data , $ matches ) ) { throw new \ Invalid Argument Exception ( 'Invalid PEM encoded certificate ' ) ; } $ this - > data = preg _replace ( ' / \s + / ' , ' ' , $ matches [ 1 ] ) ; $ this - > parse ( ) ; return $ this ; } 
public function load From File ( $ filename ) { if ( ! is _file ( $ filename ) ) { throw new \ Invalid Argument Exception ( sprintf ( "File not found ' %s ' " , $ filename ) ) ; } $ content = file _get _contents ( $ filename ) ; $ this - > load Pem ( $ content ) ; return $ this ; } 
public function validate ( XMLSecurity Key $ key ) { if ( null = = $ this - > signature ) { return false ; } if ( false = = $ this - > signature - > validate Reference ( ) ) { throw new Light Saml Security Exception ( 'Digest validation failed ' ) ; } $ key = $ this - > cast Key If Necessary ( $ key ) ; if ( false = = $ this - > signature - > verify ( $ key ) ) { throw new Light Saml Security Exception ( 'Unable to verify Signature ' ) ; } return true ; } 
public function get Algorithm ( ) { $ xpath = new \ DOMXPath ( $ this - > signature - > sig Node instanceof \ DOMDocument ? $ this - > signature - > sig Node : $ this - > signature - > sig Node - > owner Document ) ; $ xpath - > register Namespace ( 'ds ' , XMLSecurity DSig : : XMLDSIGNS ) ; $ list = $ xpath - > query ( ' . /ds :Signed Info /ds :Signature Method ' , $ this - > signature - > sig Node ) ; if ( ! $ list | | 0 = = $ list - > length ) { throw new Light Saml Xml Exception ( 'Missing Signature Method element ' ) ; } $ sig Method = $ list - > item ( 0 ) ; if ( ! $ sig Method - > has Attribute ( 'Algorithm ' ) ) { throw new Light Saml Xml Exception ( 'Missing Algorithm -attribute on Signature Method element . ' ) ; } $ algorithm = $ sig Method - > get Attribute ( 'Algorithm ' ) ; return $ algorithm ; } 
public function deserialize ( \ DOMNode $ node , Deserialization Context $ context ) { $ this - > check Xml Node Name ( $ node , 'Signature ' , Saml Constants : : NS _XMLDSIG ) ; $ this - > signature = new XMLSecurity DSig ( ) ; $ this - > signature - > id Keys [ ] = $ this - > get IDName ( ) ; $ this - > signature - > sig Node = $ node ; $ this - > signature - > canonicalize Signed Info ( ) ; $ this - > key = null ; $ key = new XMLSecurity Key ( XMLSecurity Key : : RSA _SHA 1 , array ( 'type ' = > 'public ' ) ) ; XMLSec Enc : : static Locate Key Info ( $ key , $ node ) ; if ( $ key - > name | | $ key - > key ) { $ this - > key = $ key ; } $ this - > certificates = array ( ) ; $ list = $ context - > get Xpath ( ) - > query ( ' . /ds :Key Info /ds :X 5 0 9Data /ds :X 5 0 9Certificate ' , $ node ) ; foreach ( $ list as $ cert Node ) { $ cert Data = trim ( $ cert Node - > text Content ) ; $ cert Data = str _replace ( array ( " \r " , " \n " , " \t " , ' ' ) , ' ' , $ cert Data ) ; $ this - > certificates [ ] = $ cert Data ; } } 
public function validate Multi ( array $ credential Candidates ) { $ last Exception = null ; foreach ( $ credential Candidates as $ credential ) { if ( false = = $ credential instanceof Credential Interface ) { throw new \ Invalid Argument Exception ( 'Expected Credential Interface ' ) ; } if ( null = = $ credential - > get Public Key ( ) ) { continue ; } try { $ result = $ this - > validate ( $ credential - > get Public Key ( ) ) ; if ( false = = = $ result ) { return null ; } return $ credential ; } catch ( Light Saml Security Exception $ ex ) { $ last Exception = $ ex ; } } if ( $ last Exception ) { throw $ last Exception ; } else { throw new Light Saml Security Exception ( 'No public key available for signature verification ' ) ; } } 
protected function cast Key If Necessary ( XMLSecurity Key $ key ) { $ algorithm = $ this - > get Algorithm ( ) ; if ( ! in _array ( $ algorithm , [ XMLSecurity Key : : RSA _SHA 1 , XMLSecurity Key : : RSA _SHA 2 5 6 , XMLSecurity Key : : RSA _SHA 3 8 4 , XMLSecurity Key : : RSA _SHA 5 1 2 , ] ) ) { throw new Light Saml Security Exception ( sprintf ( 'Unsupported signing algorithm : " %s " ' , $ algorithm ) ) ; } if ( $ algorithm ! = $ key - > type ) { $ key = Key Helper : : cast Key ( $ key , $ algorithm ) ; } return $ key ; } 
public function resolve ( Criteria Set $ criteria Set , array $ arr Credentials = array ( ) ) { if ( false = = $ criteria Set - > has ( Credential Name Criteria : : class ) ) { return $ arr Credentials ; } $ result = array ( ) ; foreach ( $ criteria Set - > get ( Credential Name Criteria : : class ) as $ criteria ) { foreach ( $ arr Credentials as $ credential ) { $ arr Credential Names = $ credential - > get Key Names ( ) ; $ criteria Name = $ criteria - > get Name ( ) ; foreach ( $ arr Credential Names as $ credential Name ) { if ( $ credential Name = = $ criteria Name ) { $ result [ ] = $ credential ; break ; } } } } return $ result ; } 
public function resolve ( Criteria Set $ criteria Set , array $ arr Credentials = array ( ) ) { $ result = array ( ) ; foreach ( $ criteria Set - > get ( Entity Id Criteria : : class ) as $ criteria ) { $ result = array _merge ( $ result , $ this - > credential Store - > get By Entity Id ( $ criteria - > get Entity Id ( ) ) ) ; } return $ result ; } 
public function resolve ( Criteria Set $ criteria Set , array $ candidates ) { if ( false = = = $ criteria Set - > has ( Service Type Criteria : : class ) ) { return $ candidates ; } $ result = array ( ) ; foreach ( $ criteria Set - > get ( Service Type Criteria : : class ) as $ service Type Criteria ) { foreach ( $ candidates as $ endpoint Reference ) { $ type = $ service Type Criteria - > get Service Type ( ) ; if ( $ endpoint Reference - > get Endpoint ( ) instanceof $ type ) { $ result [ ] = $ endpoint Reference ; } } } return $ result ; } 
public static function as Saml Message ( Message Context $ context ) { $ message = $ context - > get Message ( ) ; if ( $ message ) { return $ message ; } throw new Light Saml Context Exception ( $ context , 'Missing Saml Message ' ) ; } 
public static function as Authn Request ( Message Context $ context ) { $ message = $ context - > get Message ( ) ; if ( $ message instanceof Authn Request ) { return $ message ; } throw new Light Saml Context Exception ( $ context , 'Expected Authn Request ' ) ; } 
public static function as Abstract Request ( Message Context $ context ) { $ message = $ context - > get Message ( ) ; if ( $ message instanceof Abstract Request ) { return $ message ; } throw new Light Saml Context Exception ( $ context , 'Expected Abstract Request ' ) ; } 
public static function as Response ( Message Context $ context ) { $ message = $ context - > get Message ( ) ; if ( $ message instanceof Response ) { return $ message ; } throw new Light Saml Context Exception ( $ context , 'Expected Response ' ) ; } 
public static function as Status Response ( Message Context $ context ) { $ message = $ context - > get Message ( ) ; if ( $ message instanceof Status Response ) { return $ message ; } throw new Light Saml Context Exception ( $ context , 'Expected Status Response ' ) ; } 
public static function as Logout Request ( Message Context $ context ) { $ message = $ context - > get Message ( ) ; if ( $ message instanceof Logout Request ) { return $ message ; } throw new Light Saml Context Exception ( $ context , 'Expected Logout Request ' ) ; } 
public static function as Logout Response ( Message Context $ context ) { $ message = $ context - > get Message ( ) ; if ( $ message instanceof Logout Response ) { return $ message ; } throw new Light Saml Context Exception ( $ context , 'Expected Logout Response ' ) ; } 
protected function do Execute ( Profile Context $ context ) { $ this - > flush ( $ context - > get Inbound Context ( ) - > get Sub Context ( Profile Contexts : : REQUEST _STATE , null ) ) ; foreach ( $ context as $ child ) { if ( $ child instanceof Assertion Context ) { $ this - > flush ( $ child - > get Sub Context ( Profile Contexts : : REQUEST _STATE , null ) ) ; } } } 
protected function get Party Entity Descriptor ( Profile Context $ context , Entity Descriptor Store Interface $ entity Descriptor Provider , $ entity Id ) { $ party Entity Descriptor = $ entity Descriptor Provider - > get ( $ entity Id ) ; if ( null = = = $ party Entity Descriptor ) { $ message = sprintf ( "Unknown issuer ' %s ' " , $ entity Id ) ; $ this - > logger - > emergency ( $ message , Log Helper : : get Action Error Context ( $ context , $ this ) ) ; throw new Light Saml Context Exception ( $ context , $ message ) ; } return $ party Entity Descriptor ; } 
public function get Other Party Id ( $ party Id ) { if ( $ party Id = = $ this - > idp Entity Id ) { return $ this - > sp Entity Id ; } elseif ( $ party Id = = $ this - > sp Entity Id ) { return $ this - > idp Entity Id ; } throw new Light Saml Exception ( sprintf ( 'Party " %s " is not included in sso session between " %s " and " %s " ' , $ party Id , $ this - > idp Entity Id , $ this - > sp Entity Id ) ) ; } 
public function unserialize ( $ serialized ) { $ data = unserialize ( $ serialized ) ; 
protected function do Execute ( Assertion Context $ context ) { if ( $ context - > get Assertion ( ) - > get All Authn Statements ( ) & & $ context - > get Assertion ( ) - > has Bearer Subject ( ) ) { $ this - > validate Bearer Assertion ( $ context ) ; } } 
public function serialize ( \ DOMNode $ parent , Serialization Context $ context ) { if ( ! $ this - > lang ) { throw new Light Saml Xml Exception ( 'Lang is required ' ) ; } $ result = $ this - > create Element ( 'Organization ' , Saml Constants : : NS _METADATA , $ parent , $ context ) ; $ elements = array ( 'Organization Name ' , 'Organization Display Name ' , 'Organization URL ' ) ; $ this - > single Elements To Xml ( $ elements , $ result , $ context , Saml Constants : : NS _METADATA ) ; foreach ( $ result - > child Nodes as $ node ) { if ( $ node instanceof \ DOMElement ) { if ( in _array ( $ node - > tag Name , $ elements ) ) { $ node - > set Attribute ( 'xml :lang ' , $ this - > lang ) ; } } } } 
protected function supports Session ( Assertion $ assertion ) { return $ assertion - > has Bearer Subject ( ) & & null ! = $ assertion - > get Subject ( ) & & null ! = $ assertion - > get Subject ( ) - > get Name ID ( ) ; } 
protected function create Session ( Sso State $ sso State , Assertion $ assertion , \ Date Time $ now , $ own Entity Id , $ party Entity Id ) { $ sso Session = new Sso Session State ( ) ; $ sso Session - > set Idp Entity Id ( $ party Entity Id ) - > set Sp Entity Id ( $ own Entity Id ) - > set Name Id ( $ assertion - > get Subject ( ) - > get Name ID ( ) - > get Value ( ) ) - > set Name Id Format ( $ assertion - > get Subject ( ) - > get Name ID ( ) - > get Format ( ) ) - > set Session Index ( $ assertion - > get First Authn Statement ( ) - > get Session Index ( ) ) - > set Session Instant ( $ assertion - > get First Authn Statement ( ) - > get Authn Instant Date Time ( ) ) - > set First Auth On ( $ now ) - > set Last Auth On ( $ now ) ; $ sso State - > add Sso Session ( $ sso Session ) ; return $ sso Session ; } 
protected function filter Sessions ( Sso State $ sso State , Assertion $ assertion , $ own Entity Id , $ party Entity Id ) { return $ sso State - > filter ( $ party Entity Id , $ own Entity Id , $ assertion - > get Subject ( ) - > get Name ID ( ) - > get Value ( ) , $ assertion - > get Subject ( ) - > get Name ID ( ) - > get Format ( ) , $ assertion - > get First Authn Statement ( ) - > get Session Index ( ) ) ; } 
protected function validate Bearer Assertion ( Assertion Context $ context ) { if ( null = = $ context - > get Assertion ( ) - > get Id ( ) ) { $ message = 'Bearer Assertion must have ID attribute ' ; $ this - > logger - > error ( $ message , Log Helper : : get Action Error Context ( $ context , $ this ) ) ; throw new Light Saml Context Exception ( $ context , $ message ) ; } if ( null = = $ context - > get Assertion ( ) - > get Issuer ( ) ) { $ message = 'Bearer Assertion must have Issuer element ' ; $ this - > logger - > error ( $ message , Log Helper : : get Action Error Context ( $ context , $ this ) ) ; throw new Light Saml Context Exception ( $ context , $ message ) ; } if ( $ this - > id Store - > has ( $ context - > get Assertion ( ) - > get Issuer ( ) - > get Value ( ) , $ context - > get Assertion ( ) - > get Id ( ) ) ) { $ message = sprintf ( "Repeated assertion id ' %s ' of issuer ' %s ' " , $ context - > get Assertion ( ) - > get Id ( ) , $ context - > get Assertion ( ) - > get Issuer ( ) - > get Value ( ) ) ; $ this - > logger - > error ( $ message , Log Helper : : get Action Error Context ( $ context , $ this , [ 'id ' = > $ context - > get Assertion ( ) - > get Id ( ) , 'issuer ' = > $ context - > get Assertion ( ) - > get Issuer ( ) - > get Value ( ) , ] ) ) ; throw new Light Saml Context Exception ( $ context , $ message ) ; } $ this - > id Store - > set ( $ context - > get Assertion ( ) - > get Issuer ( ) - > get Value ( ) , $ context - > get Assertion ( ) - > get Id ( ) , $ this - > get Id Expiry Time ( $ context ) ) ; } 
protected function get Id Expiry Time ( Assertion Context $ context ) { $ result = null ; $ bearer Confirmations = $ context - > get Assertion ( ) - > get Subject ( ) - > get Bearer Confirmations ( ) ; if ( null = = $ bearer Confirmations ) { throw new \ Logic Exception ( 'Bearer assertion must have bearer subject confirmations ' ) ; } foreach ( $ bearer Confirmations as $ subject Confirmation ) { if ( null = = $ subject Confirmation - > get Subject Confirmation Data ( ) ) { $ message = 'Bearer Subject Confirmation must have Subject Confirmation Data element ' ; $ this - > logger - > error ( $ message , Log Helper : : get Action Error Context ( $ context , $ this ) ) ; throw new Light Saml Context Exception ( $ context , $ message ) ; } $ dt = $ subject Confirmation - > get Subject Confirmation Data ( ) - > get Not On Or After Date Time ( ) ; if ( null = = $ dt ) { $ message = 'Bearer Subject Confirmation must have Not On Or After attribute ' ; $ this - > logger - > error ( $ message , Log Helper : : get Action Error Context ( $ context , $ this ) ) ; throw new Light Saml Context Exception ( $ context , $ message ) ; } if ( null = = $ result | | $ result - > get Timestamp ( ) < $ dt - > get Timestamp ( ) ) { $ result = $ dt ; } } if ( null = = $ result ) { $ message = 'Unable to find Not On Or After attribute in bearer assertion ' ; $ this - > logger - > error ( $ message , Log Helper : : get Action Error Context ( $ context , $ this ) ) ; throw new Light Saml Context Exception ( $ context , $ message ) ; } return $ result ; } 
public function do Execute ( Profile Context $ context ) { $ binding = $ this - > binding Factory - > create ( $ context - > get Endpoint ( ) - > get Binding ( ) ) ; $ outbound Context = $ context - > get Outbound Context ( ) ; $ context - > get Http Response Context ( ) - > set Response ( $ binding - > send ( $ outbound Context ) ) ; $ this - > logger - > info ( 'Sending message ' , Log Helper : : get Action Context ( $ context , $ this , array ( 'message ' = > $ outbound Context - > get Serialization Context ( ) - > get Document ( ) - > save XML ( ) , ) ) ) ; } 
public function set Allow Create ( $ allow Create ) { if ( null = = = $ allow Create ) { $ this - > allow Create = null ; } elseif ( is _string ( $ allow Create ) | | is _int ( $ allow Create ) ) { $ this - > allow Create = 0 = = strcasecmp ( $ allow Create , 'true ' ) | | true = = = $ allow Create | | 1 = = $ allow Create ; } else { $ this - > allow Create = ( bool ) $ allow Create ; } return $ this ; } 
public function serialize ( \ DOMNode $ parent , Serialization Context $ context ) { $ result = $ this - > create Element ( 'Name IDPolicy ' , Saml Constants : : NS _PROTOCOL , $ parent , $ context ) ; $ this - > attributes To Xml ( array ( 'Format ' , 'SPName Qualifier ' , 'Allow Create ' ) , $ result ) ; } 
protected function do Execute ( Profile Context $ context ) { $ endpoint = $ context - > get Endpoint ( ) ; Message Context Helper : : as Saml Message ( $ context - > get Outbound Context ( ) ) - > set Destination ( $ endpoint - > get Location ( ) ) ; $ this - > logger - > debug ( sprintf ( 'Destination set to " %s " ' , $ endpoint - > get Location ( ) ) , Log Helper : : get Action Context ( $ context , $ this ) ) ; } 
public function add If None ( Criteria Interface $ criteria ) { if ( false = = $ this - > has ( get _class ( $ criteria ) ) ) { $ this - > add ( $ criteria ) ; } return $ this ; } 
public function add All ( Criteria Set $ criteria Set ) { foreach ( $ criteria Set - > all ( ) as $ criteria ) { $ this - > add ( $ criteria ) ; } return $ this ; } 
public function add If ( $ condition , $ callback ) { if ( $ condition ) { $ criteria = call _user _func ( $ callback ) ; if ( $ criteria ) { $ this - > add ( $ criteria ) ; } } return $ this ; } 
public function get ( $ class ) { $ result = array ( ) ; foreach ( $ this - > criterions as $ criteria ) { if ( $ criteria instanceof $ class ) { $ result [ ] = $ criteria ; } } return $ result ; } 
public static function create Public Key ( X 5 0 9Certificate $ certificate ) { if ( null = = $ certificate - > get Signature Algorithm ( ) ) { throw new Light Saml Security Exception ( 'Unrecognized certificate signature algorithm ' ) ; } $ key = new XMLSecurity Key ( $ certificate - > get Signature Algorithm ( ) , array ( 'type ' = > 'public ' ) ) ; $ key - > load Key ( $ certificate - > to Pem ( ) , false , true ) ; return $ key ; } 
public static function cast Key ( XMLSecurity Key $ key , $ algorithm ) { if ( false = = is _string ( $ algorithm ) ) { throw new \ Invalid Argument Exception ( 'Algorithm must be string ' ) ; } 
public function decrypt Multi Assertion ( array $ input Keys , Deserialization Context $ deserialization Context ) { $ dom = $ this - > decrypt Multi ( $ input Keys ) ; return $ this - > get Assertion From Dom ( $ dom , $ deserialization Context ) ; } 
public function decrypt Assertion ( $ credential , Deserialization Context $ deserialization Context ) { $ dom = $ this - > decrypt ( $ credential ) ; return $ this - > get Assertion From Dom ( $ dom , $ deserialization Context ) ; } 
protected function get Assertion From Dom ( \ DOMElement $ dom , Deserialization Context $ deserialization Context ) { $ deserialization Context - > set Document ( $ dom - > owner Document ) ; $ assertion = new Assertion ( ) ; $ assertion - > deserialize ( $ dom , $ deserialization Context ) ; return $ assertion ; } 
private function validate ( $ xml , $ schema ) { $ result = [ ] ; libxml _clear _errors ( ) ; $ doc = new \ DOMDocument ( ) ; set _error _handler ( function ( $ errno , $ errstr , $ errfile , $ errline , array $ errcontext ) use ( & $ result ) { $ error = new Xsd Error ( Xsd Error : : FATAL , $ errno , $ errstr , 0 , 0 ) ; $ result [ ] = $ error ; } ) ; $ schema File = _ _DIR _ _ . ' / . . / . . / . . / . . / . . /xsd / ' . $ schema ; if ( ! is _file ( $ schema File ) ) { throw new Light Saml Xml Exception ( 'Invalid schema specified ' ) ; } $ ok = @ $ doc - > load XML ( $ xml ) ; if ( ! $ ok ) { restore _error _handler ( ) ; return [ new Xsd Error ( Xsd Error : : FATAL , 0 , 'Invalid XML ' , 0 , 0 ) , ] ; } @ $ doc - > schema Validate ( $ schema File ) ; $ errors = libxml _get _errors ( ) ; foreach ( $ errors as $ error ) { $ err = Xsd Error : : from Lib XMLError ( $ error ) ; $ result [ ] = $ err ; } restore _error _handler ( ) ; return $ result ; } 
public static function get Timestamp From Value ( $ value ) { if ( is _string ( $ value ) ) { return self : : parse SAMLTime ( $ value ) ; } elseif ( $ value instanceof \ Date Time ) { return $ value - > get Timestamp ( ) ; } elseif ( is _int ( $ value ) ) { return $ value ; } else { throw new \ Invalid Argument Exception ( ) ; } } 
public static function parse SAMLTime ( $ time ) { $ matches = [ ] ; if ( 0 = = preg _match ( ' / ^ ( \ \d \ \d \ \d \ \d ) - ( \ \d \ \d ) - ( \ \d \ \d )T ( \ \d \ \d ) : ( \ \d \ \d ) : ( \ \d \ \d ) ( ? : \ \ . \ \d + ) ? (Z | [ + - ] \ \d \ \d : \ \d \ \d ) $ /D ' , $ time , $ matches ) ) { throw new \ Invalid Argument Exception ( 'Invalid SAML 2 timestamp : ' . $ time ) ; } return strtotime ( $ time ) ; } 
public static function validate Well Formed Uri String ( $ value ) { $ value = trim ( $ value ) ; if ( ' ' = = $ value | | strlen ( $ value ) > 6 5 5 2 0 ) { return false ; } if ( preg _match ( ' | \s | ' , $ value ) ) { return false ; } $ parts = parse _url ( $ value ) ; if ( isset ( $ parts [ 'scheme ' ] ) ) { if ( $ parts [ 'scheme ' ] ! = rawurlencode ( $ parts [ 'scheme ' ] ) ) { return false ; } } else { return false ; } return true ; } 
public function add Single Sign On Service ( Single Sign On Service $ single Sign On Service ) { if ( false = = is _array ( $ this - > single Sign On Services ) ) { $ this - > single Sign On Services = array ( ) ; } $ this - > single Sign On Services [ ] = $ single Sign On Service ; return $ this ; } 
public function get All Single Sign On Services By Url ( $ url ) { $ result = array ( ) ; foreach ( $ this - > get All Single Sign On Services ( ) as $ svc ) { if ( $ svc - > get Location ( ) = = $ url ) { $ result [ ] = $ svc ; } } return $ result ; } 
public function get All Single Sign On Services By Binding ( $ binding ) { $ result = array ( ) ; foreach ( $ this - > get All Single Sign On Services ( ) as $ svc ) { if ( $ svc - > get Binding ( ) = = $ binding ) { $ result [ ] = $ svc ; } } return $ result ; } 
public function get First Single Sign On Service ( $ binding = null ) { foreach ( $ this - > get All Single Sign On Services ( ) as $ svc ) { if ( null = = $ binding | | $ svc - > get Binding ( ) = = $ binding ) { return $ svc ; } } return null ; } 
public function add Attribute ( Attribute $ attribute ) { if ( false = = is _array ( $ this - > attributes ) ) { $ this - > attributes = array ( ) ; } $ this - > attributes [ ] = $ attribute ; return $ this ; } 
public function resolve ( Criteria Set $ criteria Set , array $ arr Credentials = array ( ) ) { if ( false = = $ criteria Set - > has ( X 5 0 9Credential Criteria : : class ) ) { return $ arr Credentials ; } $ result = array ( ) ; foreach ( $ arr Credentials as $ credential ) { if ( $ credential instanceof X 5 0 9Credential Interface ) { $ result [ ] = $ credential ; } } return $ result ; } 
protected function get Criteria Set ( Profile Context $ context , $ location ) { $ result = parent : : get Criteria Set ( $ context , $ location ) ; $ result - > add ( new Service Type Criteria ( Assertion Consumer Service : : class ) ) ; return $ result ; } 
public function serialize ( ) { $ nonce = $ this - > get Nonce ( ) ; return serialize ( array ( $ this - > id , $ nonce , $ this - > parameters - > serialize ( ) ) ) ; } 
public function unserialize ( $ serialized ) { $ nonce = null ; $ this - > parameters = new Parameter Bag ( ) ; list ( $ this - > id , $ nonce , $ parameters ) = unserialize ( $ serialized ) ; $ this - > parameters - > unserialize ( $ parameters ) ; } 
public function execute ( Context Interface $ context ) { $ this - > before Action ( $ context ) ; $ this - > action - > execute ( $ context ) ; $ this - > after Action ( $ context ) ; } 
public function resolve ( Criteria Set $ criteria Set , array $ candidates ) { $ result = $ candidates ; foreach ( $ this - > resolvers as $ resolver ) { $ result = $ resolver - > resolve ( $ criteria Set , $ result ) ; } return $ result ; } 
public function get ( $ entity Id ) { if ( null = = $ this - > object ) { $ this - > load ( ) ; } if ( $ this - > object instanceof Entity Descriptor ) { if ( $ this - > object - > get Entity ID ( ) = = $ entity Id ) { return $ this - > object ; } else { return null ; } } else { return $ this - > object - > get By Entity Id ( $ entity Id ) ; } } 
public function debug Print Tree ( $ depth = 0 ) { $ arr = array ( ) ; if ( $ this - > assertion Action instanceof Debug Print Tree Action Interface ) { $ arr = array _merge ( $ arr , $ this - > assertion Action - > debug Print Tree ( ) ) ; } else { $ arr [ get _class ( $ this - > assertion Action ) ] = array ( ) ; } $ result = array ( static : : class = > $ arr , ) ; return $ result ; } 
public function validate Time Restrictions ( Assertion $ assertion , $ now , $ allowed Seconds Skew ) { if ( $ allowed Seconds Skew < 0 ) { $ allowed Seconds Skew = - 1 * $ allowed Seconds Skew ; } $ this - > validate Conditions ( $ assertion , $ now , $ allowed Seconds Skew ) ; $ this - > validate Authn Statements ( $ assertion , $ now , $ allowed Seconds Skew ) ; $ this - > validate Subject ( $ assertion , $ now , $ allowed Seconds Skew ) ; } 
public function resolve ( Criteria Set $ criteria Set , array $ arr Credentials = array ( ) ) { if ( false = = $ criteria Set - > has ( Public Key Thumbprint Criteria : : class ) ) { return $ arr Credentials ; } $ result = array ( ) ; foreach ( $ criteria Set - > get ( Public Key Thumbprint Criteria : : class ) as $ criteria ) { foreach ( $ arr Credentials as $ credential ) { if ( $ credential - > get Public Key ( ) & & $ credential - > get Public Key ( ) - > get X 5 0 9Thumbprint ( ) = = $ criteria - > get Thumbprint ( ) ) { $ result [ ] = $ credential ; } } } return $ result ; } 
public function get Binding By Request ( Request $ request ) { $ binding Type = $ this - > detect Binding Type ( $ request ) ; return $ this - > create ( $ binding Type ) ; } 
public function create ( $ binding Type ) { $ result = null ; switch ( $ binding Type ) { case Saml Constants : : BINDING _SAML 2 _HTTP _REDIRECT : $ result = new Http Redirect Binding ( ) ; break ; case Saml Constants : : BINDING _SAML 2 _HTTP _POST : $ result = new Http Post Binding ( ) ; break ; case Saml Constants : : BINDING _SAML 2 _HTTP _ARTIFACT : throw new \ Logic Exception ( 'Artifact binding not implemented ' ) ; case Saml Constants : : BINDING _SAML 2 _SOAP : throw new \ Logic Exception ( 'SOAP binding not implemented ' ) ; } if ( $ result ) { $ result - > set Event Dispatcher ( $ this - > event Dispatcher ) ; return $ result ; } throw new Light Saml Binding Exception ( sprintf ( "Unknown binding type ' %s ' " , $ binding Type ) ) ; } 
public function detect Binding Type ( Request $ request ) { $ request Method = trim ( strtoupper ( $ request - > get Method ( ) ) ) ; if ( 'GET ' = = $ request Method ) { return $ this - > process GET ( $ request ) ; } elseif ( 'POST ' = = $ request Method ) { return $ this - > process POST ( $ request ) ; } return null ; } 
protected function process GET ( Request $ request ) { $ get = $ request - > query - > all ( ) ; if ( array _key _exists ( 'SAMLRequest ' , $ get ) | | array _key _exists ( 'SAMLResponse ' , $ get ) ) { return Saml Constants : : BINDING _SAML 2 _HTTP _REDIRECT ; } elseif ( array _key _exists ( 'SAMLart ' , $ get ) ) { return Saml Constants : : BINDING _SAML 2 _HTTP _ARTIFACT ; } return null ; } 
protected function process POST ( Request $ request ) { $ post = $ request - > request - > all ( ) ; if ( array _key _exists ( 'SAMLRequest ' , $ post ) | | array _key _exists ( 'SAMLResponse ' , $ post ) ) { return Saml Constants : : BINDING _SAML 2 _HTTP _POST ; } elseif ( array _key _exists ( 'SAMLart ' , $ post ) ) { return Saml Constants : : BINDING _SAML 2 _HTTP _ARTIFACT ; } else { if ( $ content Type = $ request - > headers - > get ( 'CONTENT _TYPE ' ) ) { 
public function get ( $ entity Id ) { return isset ( $ this - > options [ $ entity Id ] ) ? $ this - > options [ $ entity Id ] : null ; } 
public function send ( Message Context $ context , $ destination = null ) { $ message = Message Context Helper : : as Saml Message ( $ context ) ; $ destination = $ message - > get Destination ( ) ? $ message - > get Destination ( ) : $ destination ; $ serialization Context = $ context - > get Serialization Context ( ) ; $ message - > serialize ( $ serialization Context - > get Document ( ) , $ serialization Context ) ; $ msg Str = $ serialization Context - > get Document ( ) - > save XML ( ) ; $ this - > dispatch Send ( $ msg Str ) ; $ msg Str = base 6 4 _encode ( $ msg Str ) ; $ type = $ message instanceof Abstract Request ? 'SAMLRequest ' : 'SAMLResponse ' ; $ data = array ( $ type = > $ msg Str ) ; if ( $ message - > get Relay State ( ) ) { $ data [ 'Relay State ' ] = $ message - > get Relay State ( ) ; } $ result = new Saml Post Response ( $ destination , $ data ) ; $ result - > render Content ( ) ; return $ result ; } 
protected function validate In Response To ( $ in Response To , Assertion Context $ context ) { $ request State = $ this - > request Store - > get ( $ in Response To ) ; if ( null = = $ request State ) { $ message = sprintf ( "Unknown In Response To ' %s ' " , $ in Response To ) ; $ this - > logger - > emergency ( $ message , Log Helper : : get Action Error Context ( $ context , $ this ) ) ; throw new Light Saml Context Exception ( $ context , $ message ) ; } return $ request State ; } 
public function add ( Credential Interface $ credential ) { $ this - > check Entity Id Existence ( $ credential - > get Entity Id ( ) ) ; $ this - > credentials [ $ credential - > get Entity Id ( ) ] [ ] = $ credential ; return $ this ; } 
public function resolve ( Criteria Set $ criteria Set , array $ arr Credentials = array ( ) ) { if ( false = = $ criteria Set - > has ( Metadata Criteria : : class ) ) { return $ arr Credentials ; } $ result = array ( ) ; foreach ( $ criteria Set - > get ( Metadata Criteria : : class ) as $ criteria ) { foreach ( $ arr Credentials as $ credential ) { $ metadata Context = $ credential - > get Credential Context ( ) - > get ( Metadata Credential Context : : class ) ; if ( false = = $ metadata Context | | Metadata Criteria : : TYPE _IDP = = $ criteria - > get Metadata Type ( ) & & $ metadata Context - > get Role Descriptor ( ) instanceof Idp Sso Descriptor | | Metadata Criteria : : TYPE _SP = = $ criteria - > get Metadata Type ( ) & & $ metadata Context - > get Role Descriptor ( ) instanceof Sp Sso Descriptor ) { $ result [ ] = $ credential ; } } } return $ result ; } 
public function add Audience ( $ audience ) { if ( false = = is _array ( $ this - > audience ) ) { $ this - > audience = array ( ) ; } $ this - > audience [ ] = ( string ) $ audience ; return $ this ; } 
public function set Count ( $ count ) { $ this - > count = null ! = = $ count ? intval ( $ count ) : null ; return $ this ; } 
public function set Sso Sessions ( array $ sso Sessions ) { $ this - > sso Sessions = array ( ) ; foreach ( $ sso Sessions as $ sso Session ) { $ this - > add Sso Session ( $ sso Session ) ; } return $ this ; } 
public function filter ( $ idp Entity Id , $ sp Entity Id , $ name Id , $ name Id Format , $ session Index ) { $ result = array ( ) ; foreach ( $ this - > sso Sessions as $ sso Session ) { if ( ( ! $ idp Entity Id | | $ sso Session - > get Idp Entity Id ( ) = = = $ idp Entity Id ) & & ( ! $ sp Entity Id | | $ sso Session - > get Sp Entity Id ( ) = = = $ sp Entity Id ) & & ( ! $ name Id | | $ sso Session - > get Name Id ( ) = = = $ name Id ) & & ( ! $ name Id Format | | $ sso Session - > get Name Id Format ( ) = = = $ name Id Format ) & & ( ! $ session Index | | $ sso Session - > get Session Index ( ) = = = $ session Index ) ) { $ result [ ] = $ sso Session ; } } return $ result ; } 
public function modify ( $ callback ) { $ this - > sso Sessions = array _values ( array _filter ( $ this - > sso Sessions , $ callback ) ) ; return $ this ; } 
public function unserialize ( $ serialized ) { $ data = unserialize ( $ serialized ) ; 
public function map ( $ callable ) { foreach ( $ this - > children as $ k = > $ action ) { $ new Action = call _user _func ( $ callable , $ action ) ; if ( $ new Action ) { $ this - > children [ $ k ] = $ new Action ; } } } 
public function execute ( Context Interface $ context ) { foreach ( $ this - > children as $ action ) { $ action - > execute ( $ context ) ; } } 
public function add ( Action Interface $ action , $ priority = false ) { if ( false = = = $ priority ) { + + $ this - > biggest Priority ; $ priority = $ this - > biggest Priority ; } elseif ( false = = = is _int ( $ priority ) ) { throw new \ Invalid Argument Exception ( 'Expected integer value for priority ' ) ; } elseif ( $ priority > $ this - > biggest Priority ) { $ this - > biggest Priority = $ priority ; } if ( false = = = isset ( $ this - > actions [ $ priority ] ) ) { $ this - > actions [ $ priority ] = array ( ) ; } $ this - > actions [ $ priority ] [ ] = $ action ; return $ this ; } 
public function execute ( Context Interface $ context ) { $ this - > event Dispatcher - > dispatch ( $ this - > event , new Generic Event ( $ context ) ) ; } 
public static function load Xml ( $ xml ) { $ context = new Deserialization Context ( ) ; $ context - > get Document ( ) - > load XML ( $ xml ) ; $ ed = new self ( ) ; $ ed - > deserialize ( $ context - > get Document ( ) , $ context ) ; return $ ed ; } 
public function set Valid Until ( $ valid Until ) { $ value = Helper : : get Timestamp From Value ( $ valid Until ) ; if ( $ value < 0 ) { throw new \ Invalid Argument Exception ( 'Invalid valid Until ' ) ; } $ this - > valid Until = $ value ; return $ this ; } 
public function add Item ( $ item ) { if ( false = = $ item instanceof self & & false = = $ item instanceof Entity Descriptor ) { throw new \ Invalid Argument Exception ( 'Expected Entities Descriptor or Entity Descriptor ' ) ; } if ( $ item = = = $ this ) { throw new \ Invalid Argument Exception ( 'Circular reference detected ' ) ; } if ( $ item instanceof self ) { if ( $ item - > contains Item ( $ this ) ) { throw new \ Invalid Argument Exception ( 'Circular reference detected ' ) ; } } $ this - > items [ ] = $ item ; return $ this ; } 
public function contains Item ( $ item ) { if ( false = = $ item instanceof self & & false = = $ item instanceof Entity Descriptor ) { throw new \ Invalid Argument Exception ( 'Expected Entities Descriptor or Entity Descriptor ' ) ; } foreach ( $ this - > items as $ i ) { if ( $ i = = = $ item ) { return true ; } if ( $ i instanceof self ) { if ( $ i - > contains Item ( $ item ) ) { return true ; } } } return false ; } 
public function get By Entity Id ( $ entity Id ) { foreach ( $ this - > get All Entity Descriptors ( ) as $ entity Descriptor ) { if ( $ entity Descriptor - > get Entity ID ( ) = = $ entity Id ) { return $ entity Descriptor ; } } return null ; } 
public function serialize ( \ DOMNode $ parent , Serialization Context $ context ) { $ result = $ this - > create Element ( 'Entities Descriptor ' , Saml Constants : : NS _METADATA , $ parent , $ context ) ; $ this - > attributes To Xml ( array ( 'valid Until ' , 'cache Duration ' , 'ID ' , 'Name ' ) , $ result ) ; $ this - > single Elements To Xml ( array ( 'Signature ' ) , $ result , $ context ) ; $ this - > many Elements To Xml ( $ this - > get All Items ( ) , $ result , $ context ) ; } 
protected function do Execute ( Assertion Context $ context ) { $ signature = $ context - > get Assertion ( ) - > get Signature ( ) ; if ( null = = = $ signature ) { if ( $ this - > require Signature ) { $ message = 'Assertions must be signed ' ; $ this - > logger - > critical ( $ message , Log Helper : : get Action Error Context ( $ context , $ this ) ) ; throw new Light Saml Context Exception ( $ context , $ message ) ; } else { $ this - > logger - > debug ( 'Assertion is not signed ' , Log Helper : : get Action Context ( $ context , $ this ) ) ; return ; } } if ( $ signature instanceof Abstract Signature Reader ) { $ metadata Type = Profile Context : : ROLE _IDP = = = $ context - > get Profile Context ( ) - > get Own Role ( ) ? Metadata Criteria : : TYPE _SP : Metadata Criteria : : TYPE _IDP ; $ credential = $ this - > signature Validator - > validate ( $ signature , $ context - > get Assertion ( ) - > get Issuer ( ) - > get Value ( ) , $ metadata Type ) ; if ( $ credential ) { $ key Names = $ credential - > get Key Names ( ) ; $ this - > logger - > debug ( sprintf ( 'Assertion signature validated with key " %s " ' , implode ( ' , ' , $ key Names ) ) , Log Helper : : get Action Context ( $ context , $ this , array ( 'credential ' = > $ credential , ) ) ) ; } else { $ this - > logger - > warning ( 'Assertion signature verification was not performed ' , Log Helper : : get Action Context ( $ context , $ this ) ) ; } } else { $ message = 'Expected Abstract Signature Reader ' ; $ this - > logger - > critical ( $ message , Log Helper : : get Action Error Context ( $ context , $ this ) ) ; throw new Light Saml Model Exception ( $ message ) ; } } 
public function resolve ( Criteria Set $ criteria Set , array $ arr Credentials = array ( ) ) { if ( false = = $ criteria Set - > has ( Private Key Criteria : : class ) ) { return $ arr Credentials ; } $ result = array ( ) ; foreach ( $ arr Credentials as $ credential ) { if ( $ credential - > get Private Key ( ) ) { $ result [ ] = $ credential ; } } return $ result ; } 
public function get Sub Context ( $ name , $ class = null ) { if ( isset ( $ this - > sub Contexts [ $ name ] ) ) { return $ this - > sub Contexts [ $ name ] ; } if ( $ class ) { $ result = $ this - > create Sub Context ( $ class ) ; $ this - > add Sub Context ( $ name , $ result ) ; return $ result ; } return null ; } 
public function add Sub Context ( $ name , $ sub Context ) { if ( false = = = is _object ( $ sub Context ) ) { throw new \ Invalid Argument Exception ( 'Expected object or Context Interface ' ) ; } $ existing = isset ( $ this - > sub Contexts [ $ name ] ) ? $ this - > sub Contexts [ $ name ] : null ; if ( $ existing = = = $ sub Context ) { return $ this ; } $ this - > sub Contexts [ $ name ] = $ sub Context ; if ( $ sub Context instanceof Context Interface ) { $ sub Context - > set Parent ( $ this ) ; } if ( $ existing instanceof Context Interface ) { $ existing - > set Parent ( null ) ; } return $ this ; } 
public function remove Sub Context ( $ name ) { $ sub Context = $ this - > get Sub Context ( $ name , false ) ; if ( $ sub Context ) { $ sub Context - > set Parent ( null ) ; unset ( $ this - > sub Contexts [ $ name ] ) ; } return $ this ; } 
public function debug Print Tree ( $ own Name = 'root ' ) { $ result = array ( $ own Name = > static : : class , ) ; if ( $ this - > sub Contexts ) { $ arr = array ( ) ; foreach ( $ this - > sub Contexts as $ name = > $ sub Context ) { if ( $ sub Context instanceof Context Interface ) { $ arr = array _merge ( $ arr , $ sub Context - > debug Print Tree ( $ name ) ) ; } else { $ arr = array _merge ( $ arr , array ( $ name = > get _class ( $ sub Context ) ) ) ; } } $ result [ $ own Name . ' _ _children ' ] = $ arr ; } return $ result ; } 
public function get Path ( $ path ) { if ( is _string ( $ path ) ) { $ path = explode ( ' / ' , $ path ) ; } elseif ( false = = = is _array ( $ path ) ) { throw new \ Invalid Argument Exception ( 'Expected string or array ' ) ; } $ name = array _shift ( $ path ) ; $ sub Context = $ this - > get Sub Context ( $ name ) ; if ( null = = $ sub Context ) { return null ; } if ( empty ( $ path ) ) { return $ sub Context ; } else { return $ sub Context - > get Path ( $ path ) ; } } 
public static function get Encrypted Assertion Reader ( Assertion Context $ context ) { $ result = $ context - > get Encrypted Assertion ( ) ; if ( $ result instanceof Encrypted Assertion Reader ) { return $ result ; } throw new Light Saml Context Exception ( $ context , 'Expected Encrypted Assertion Reader ' ) ; } 
protected function do Execute ( Assertion Context $ context ) { if ( null = = = $ context - > get Assertion ( ) - > get Issuer ( ) ) { $ message = 'Assertion element must have an issuer element ' ; $ this - > logger - > error ( $ message , Log Helper : : get Action Error Context ( $ context , $ this ) ) ; throw new Light Saml Context Exception ( $ context , $ message ) ; } if ( false = = $ this - > idp Entity Descriptor Provider - > has ( $ context - > get Assertion ( ) - > get Issuer ( ) - > get Value ( ) ) ) { $ message = sprintf ( "Unknown issuer ' %s ' " , $ context - > get Assertion ( ) - > get Issuer ( ) - > get Value ( ) ) ; $ this - > logger - > error ( $ message , Log Helper : : get Action Error Context ( $ context , $ this , [ 'message Issuer ' = > $ context - > get Assertion ( ) - > get Issuer ( ) - > get Value ( ) , ] ) ) ; throw new Light Saml Context Exception ( $ context , $ message ) ; } $ this - > logger - > debug ( sprintf ( 'Known assertion issuer : " %s " ' , $ context - > get Assertion ( ) - > get Issuer ( ) - > get Value ( ) ) , Log Helper : : get Action Context ( $ context , $ this ) ) ; } 
public function resolve ( Criteria Set $ criteria Set , array $ candidates ) { if ( false = = = $ criteria Set - > has ( Descriptor Type Criteria : : class ) ) { return $ candidates ; } $ result = array ( ) ; foreach ( $ criteria Set - > get ( Descriptor Type Criteria : : class ) as $ descriptor Type Criteria ) { foreach ( $ candidates as $ endpoint Reference ) { $ type = $ descriptor Type Criteria - > get Descriptor Type ( ) ; if ( $ endpoint Reference - > get Descriptor ( ) instanceof $ type ) { $ result [ ] = $ endpoint Reference ; } } } return $ result ; } 
protected function do Execute ( Profile Context $ context ) { $ message = Message Context Helper : : as Saml Message ( $ context - > get Inbound Context ( ) ) ; $ destination = $ message - > get Destination ( ) ; if ( null = = $ destination ) { return ; } $ criteria Set = $ this - > get Criteria Set ( $ context , $ destination ) ; $ endpoints = $ this - > endpoint Resolver - > resolve ( $ criteria Set , $ context - > get Own Entity Descriptor ( ) - > get All Endpoints ( ) ) ; if ( $ endpoints ) { return ; } $ message = sprintf ( 'Invalid inbound message destination " %s " ' , $ destination ) ; $ this - > logger - > emergency ( $ message , Log Helper : : get Action Error Context ( $ context , $ this ) ) ; throw new Light Saml Context Exception ( $ context , $ message ) ; } 
protected function get Criteria Set ( Profile Context $ context , $ location ) { $ criteria Set = new Criteria Set ( [ new Descriptor Type Criteria ( Profile Context : : ROLE _IDP = = = $ context - > get Own Role ( ) ? Idp Sso Descriptor : : class : Sp Sso Descriptor : : class ) , new Location Criteria ( $ location ) , ] ) ; return $ criteria Set ; } 
public function get Bearer Assertions ( ) { $ result = array ( ) ; if ( $ this - > get All Assertions ( ) ) { foreach ( $ this - > get All Assertions ( ) as $ assertion ) { if ( $ assertion - > has Bearer Subject ( ) ) { $ result [ ] = $ assertion ; } } 
public function remove Assertion ( Assertion $ removed Assertion ) { $ arr = array ( ) ; $ has That Assertion = false ; foreach ( $ this - > get All Assertions ( ) as $ assertion ) { if ( $ assertion ! = = $ removed Assertion ) { $ arr [ ] = $ assertion ; } else { $ has That Assertion = true ; } } if ( false = = = $ has That Assertion ) { throw new \ Invalid Argument Exception ( 'Response does not have assertion specified to be removed ' ) ; } return $ this ; } 
public function has Audience ( $ value ) { if ( is _array ( $ this - > audience ) ) { foreach ( $ this - > audience as $ a ) { if ( $ a = = $ value ) { return true ; } } } return false ; } 
public static function from Lib XMLError ( \ Lib XMLError $ error ) { return new self ( isset ( self : : $ level Map [ $ error - > level ] ) ? self : : $ level Map [ $ error - > level ] : 'Unknown ' , $ error - > code , $ error - > message , $ error - > line , $ error - > column ) ; } 
public function add Assertion Consumer Service ( Assertion Consumer Service $ assertion Consumer Service ) { if ( false = = is _array ( $ this - > assertion Consumer Services ) ) { $ this - > assertion Consumer Services = array ( ) ; } if ( null = = = $ assertion Consumer Service - > get Index ( ) ) { $ assertion Consumer Service - > set Index ( count ( $ this - > assertion Consumer Services ) ) ; } $ this - > assertion Consumer Services [ ] = $ assertion Consumer Service ; return $ this ; } 
public function get All Assertion Consumer Services By Binding ( $ binding ) { $ result = array ( ) ; foreach ( $ this - > get All Assertion Consumer Services ( ) as $ svc ) { if ( $ svc - > get Binding ( ) = = $ binding ) { $ result [ ] = $ svc ; } } return $ result ; } 
public function get All Assertion Consumer Services By Url ( $ url ) { $ result = array ( ) ; foreach ( $ this - > get All Assertion Consumer Services ( ) as $ svc ) { if ( $ svc - > get Location ( ) = = $ url ) { $ result [ ] = $ svc ; } } return $ result ; } 
public function get Assertion Consumer Services By Index ( $ index ) { foreach ( $ this - > get All Assertion Consumer Services ( ) as $ svc ) { if ( $ svc - > get Index ( ) = = $ index ) { return $ svc ; } } return null ; } 
public function get First Assertion Consumer Service ( $ binding = null ) { foreach ( $ this - > get All Assertion Consumer Services ( ) as $ svc ) { if ( null = = $ binding | | $ svc - > get Binding ( ) = = $ binding ) { return $ svc ; } } return null ; } 
public function set ( Request State $ state ) { $ arr = $ this - > get Array ( ) ; $ arr [ $ state - > get Id ( ) ] = $ state ; $ this - > set Array ( $ arr ) ; return $ this ; } 
public function get ( $ id ) { $ result = null ; $ arr = $ this - > get Array ( ) ; if ( false = = is _array ( $ arr ) ) { $ arr = array ( ) ; $ this - > set Array ( $ arr ) ; } if ( isset ( $ arr [ $ id ] ) ) { $ result = $ arr [ $ id ] ; } if ( $ result instanceof Request State ) { return $ result ; } return null ; } 
public function remove ( $ id ) { $ arr = $ this - > get Array ( ) ; $ result = isset ( $ arr [ $ id ] ) ; unset ( $ arr [ $ id ] ) ; $ this - > set Array ( $ arr ) ; return $ result ; } 
public function set ( Sso State $ sso State ) { $ sso State - > set Local Session Id ( $ this - > session - > get Id ( ) ) ; $ this - > session - > set ( $ this - > key , $ sso State ) ; } 
protected function do Execute ( Assertion Context $ context ) { $ this - > assertion Time Validator - > validate Time Restrictions ( $ context - > get Assertion ( ) , $ this - > time Provider - > get Timestamp ( ) , $ this - > allowed Seconds Skew ) ; } 
public function get All Single Logout Services By Binding ( $ binding ) { $ result = array ( ) ; foreach ( $ this - > get All Single Logout Services ( ) as $ svc ) { if ( $ binding = = $ svc - > get Binding ( ) ) { $ result [ ] = $ svc ; } } return $ result ; } 
public function get First Single Logout Service ( $ binding = null ) { foreach ( $ this - > get All Single Logout Services ( ) as $ svc ) { if ( null = = $ binding | | $ binding = = $ svc - > get Binding ( ) ) { return $ svc ; } } return null ; } 
public function has Name IDFormat ( $ name Id Format ) { if ( $ this - > name IDFormats ) { foreach ( $ this - > name IDFormats as $ format ) { if ( $ format = = $ name Id Format ) { return true ; } } } return false ; } 
public function add Key Name ( $ key Name ) { $ key Name = trim ( $ key Name ) ; if ( $ key Name ) { $ this - > key Names [ ] = $ key Name ; } return $ this ; } 
public function resolve ( Criteria Set $ criteria Set , array $ candidates ) { if ( false = = = $ criteria Set - > has ( Index Criteria : : class ) ) { return $ candidates ; } $ result = array ( ) ; foreach ( $ criteria Set - > get ( Index Criteria : : class ) as $ index Criteria ) { foreach ( $ candidates as $ endpoint Reference ) { $ endpoint = $ endpoint Reference - > get Endpoint ( ) ; if ( $ endpoint instanceof Indexed Endpoint ) { if ( $ endpoint - > get Index ( ) = = $ index Criteria - > get Index ( ) ) { $ result [ ] = $ endpoint Reference ; } } } } return $ result ; } 
public function add Exception ( \ Exception $ exception ) { if ( $ this - > exception ) { if ( null = = $ this - > next Exception Context ) { $ this - > next Exception Context = new self ( $ exception ) ; return $ this - > next Exception Context ; } else { return $ this - > next Exception Context - > add Exception ( $ exception ) ; } } else { $ this - > exception = $ exception ; } return $ this ; } 
public function validate Name Id ( Abstract Name ID $ name Id ) { if ( false = = $ name Id - > get Format ( ) ) { return ; } $ this - > validate Format ( $ name Id ) ; $ validator Method = isset ( self : : $ format Validators [ $ name Id - > get Format ( ) ] ) ? self : : $ format Validators [ $ name Id - > get Format ( ) ] : null ; if ( $ validator Method ) { $ this - > { $ validator Method } ( $ name Id ) ; } } 
public function set Attributes ( array $ attributes ) { $ this - > attributes = [ ] ; foreach ( $ attributes as $ attribute ) { $ this - > add ( $ attribute ) ; } return $ this ; } 
public function add Extra Credential ( Credential Interface $ credential ) { if ( null = = = $ credential - > get Entity Id ( ) ) { throw new \ Invalid Argument Exception ( 'Extra credential must have entity ID ' ) ; } $ this - > extra Credentials [ ] = $ credential ; return $ this ; } 
public function set ( $ entity Id , $ id , \ Date Time $ expiry Time ) { if ( false = = isset ( $ this - > store [ $ entity Id ] ) ) { $ this - > store [ $ entity Id ] = array ( ) ; } $ this - > store [ $ entity Id ] [ $ id ] = $ expiry Time ; } 
public function resolve ( Criteria Set $ criteria Set , array $ candidates ) { if ( false = = = $ criteria Set - > has ( Binding Criteria : : class ) ) { return $ candidates ; } $ arr Ordered = array ( ) ; foreach ( $ criteria Set - > get ( Binding Criteria : : class ) as $ binding Criteria ) { foreach ( $ candidates as $ endpoint Reference ) { $ preference = $ binding Criteria - > get Preference ( $ endpoint Reference - > get Endpoint ( ) - > get Binding ( ) ) ; if ( null ! = = $ preference ) { $ arr Ordered [ $ preference ] [ ] = $ endpoint Reference ; } } } ksort ( $ arr Ordered ) ; $ result = array ( ) ; foreach ( $ arr Ordered as $ arr ) { foreach ( $ arr as $ endpoint Reference ) { $ result [ ] = $ endpoint Reference ; } } return $ result ; } 
public function get Signature ( Abstract Profile Context $ context ) { $ credential = $ this - > get Signing Credential ( $ context ) ; if ( null = = $ credential ) { throw new Light Saml Context Exception ( $ context , 'Unable to find signing credential ' ) ; } $ trust Options = $ context - > get Profile Context ( ) - > get Trust Options ( ) ; $ signature = new Signature Writer ( $ credential - > get Certificate ( ) , $ credential - > get Private Key ( ) , $ trust Options - > get Signature Digest Algorithm ( ) ) ; return $ signature ; } 
private function get Signing Credential ( Abstract Profile Context $ context ) { $ profile Context = $ context - > get Profile Context ( ) ; $ entity Descriptor = $ profile Context - > get Own Entity Descriptor ( ) ; $ query = $ this - > credential Resolver - > query ( ) ; $ query - > add ( new Entity Id Criteria ( $ entity Descriptor - > get Entity ID ( ) ) ) - > add ( new Usage Criteria ( Usage Type : : SIGNING ) ) - > add ( new X 5 0 9Credential Criteria ( ) ) - > add If ( Profile Context : : ROLE _IDP = = = $ profile Context - > get Own Role ( ) , function ( ) { return new Metadata Criteria ( Metadata Criteria : : TYPE _IDP , Saml Constants : : VERSION _ 2 0 ) ; } ) - > add If ( Profile Context : : ROLE _SP = = = $ profile Context - > get Own Role ( ) , function ( ) { return new Metadata Criteria ( Metadata Criteria : : TYPE _SP , Saml Constants : : VERSION _ 2 0 ) ; } ) ; $ query - > resolve ( ) ; $ result = $ query - > first Credential ( ) ; if ( $ result & & false = = = $ result instanceof X 5 0 9Credential Interface ) { throw new \ Logic Exception ( sprintf ( 'Expected X 5 0 9Credential Interface but got %s ' , get _class ( $ result ) ) ) ; } return $ result ; } 
public function set Sso Session State ( Sso Session State $ sso Session State ) { $ this - > sso Session State = $ sso Session State ; $ this - > all Sso Sessions Terminated = false ; return $ this ; } 
public function add Attribute Value ( $ attribute Value ) { if ( false = = is _array ( $ this - > attribute Value ) ) { $ this - > attribute Value = array ( ) ; } $ this - > attribute Value [ ] = $ attribute Value ; return $ this ; } 
public function set Attribute Value ( $ attribute Value ) { if ( false = = is _array ( $ attribute Value ) ) { $ attribute Value = array ( $ attribute Value ) ; } $ this - > attribute Value = $ attribute Value ; return $ this ; } 
public function equals ( $ name Id , $ format ) { if ( false = = $ this - > get Subject ( ) ) { return false ; } if ( false = = $ this - > get Subject ( ) - > get Name ID ( ) ) { return false ; } if ( $ this - > get Subject ( ) - > get Name ID ( ) - > get Value ( ) ! = $ name Id ) { return false ; } if ( $ this - > get Subject ( ) - > get Name ID ( ) - > get Format ( ) ! = $ format ) { return false ; } return true ; } 
public function has Session Index ( $ session Index ) { if ( null = = $ this - > get All Authn Statements ( ) ) { return false ; } foreach ( $ this - > get All Authn Statements ( ) as $ authn Statement ) { if ( $ authn Statement - > get Session Index ( ) = = $ session Index ) { return true ; } } return false ; } 
public function serialize ( \ DOMNode $ parent , Serialization Context $ context ) { $ this - > prepare For Xml ( ) ; $ result = $ this - > create Element ( 'Assertion ' , Saml Constants : : NS _ASSERTION , $ parent , $ context ) ; $ this - > attributes To Xml ( array ( 'ID ' , 'Version ' , 'Issue Instant ' ) , $ result ) ; $ this - > single Elements To Xml ( array ( 'Issuer ' , 'Subject ' , 'Conditions ' ) , $ result , $ context ) ; foreach ( $ this - > items as $ item ) { $ item - > serialize ( $ result , $ context ) ; } 
public function get Bearer Confirmations ( ) { $ result = array ( ) ; if ( $ this - > get All Subject Confirmations ( ) ) { foreach ( $ this - > get All Subject Confirmations ( ) as $ confirmation ) { if ( Saml Constants : : CONFIRMATION _METHOD _BEARER = = $ confirmation - > get Method ( ) ) { $ result [ ] = $ confirmation ; break ; } } } return $ result ; } 
public function serialize ( \ DOMNode $ parent , Serialization Context $ context ) { $ result = $ this - > create Element ( 'Subject ' , Saml Constants : : NS _ASSERTION , $ parent , $ context ) ; $ this - > single Elements To Xml ( array ( 'Name ID ' ) , $ result , $ context ) ; $ this - > many Elements To Xml ( $ this - > get All Subject Confirmations ( ) , $ result , $ context , null ) ; } 
protected function do Execute ( Profile Context $ context ) { $ binding Type = $ this - > binding Factory - > detect Binding Type ( $ context - > get Http Request ( ) ) ; if ( null = = $ binding Type ) { $ message = 'Unable to resolve binding type , invalid or unsupported http request ' ; $ this - > logger - > critical ( $ message , Log Helper : : get Action Error Context ( $ context , $ this ) ) ; throw new Light Saml Binding Exception ( $ message ) ; } $ this - > logger - > debug ( sprintf ( 'Detected binding type : %s ' , $ binding Type ) , Log Helper : : get Action Context ( $ context , $ this ) ) ; $ binding = $ this - > binding Factory - > create ( $ binding Type ) ; $ binding - > receive ( $ context - > get Http Request ( ) , $ context - > get Inbound Context ( ) ) ; $ context - > get Inbound Context ( ) - > set Binding Type ( $ binding Type ) ; $ this - > logger - > info ( 'Received message ' , Log Helper : : get Action Context ( $ context , $ this , array ( 'message ' = > $ context - > get Inbound Context ( ) - > get Deserialization Context ( ) - > get Document ( ) - > save XML ( ) , ) ) ) ; } 
public function add ( $ entity Descriptor ) { if ( $ entity Descriptor instanceof Entity Descriptor ) { if ( false = = $ entity Descriptor - > get Entity ID ( ) ) { throw new \ Invalid Argument Exception ( 'Entity Descriptor must have entity Id set ' ) ; } $ this - > descriptors [ $ entity Descriptor - > get Entity ID ( ) ] = $ entity Descriptor ; } elseif ( $ entity Descriptor instanceof Entities Descriptor ) { foreach ( $ entity Descriptor - > get All Items ( ) as $ item ) { $ this - > add ( $ item ) ; } } else { throw new \ Invalid Argument Exception ( 'Expected Entity Descriptor or Entities Descriptor ' ) ; } return $ this ; } 
public function get ( $ entity Id ) { if ( isset ( $ this - > descriptors [ $ entity Id ] ) ) { return $ this - > descriptors [ $ entity Id ] ; } return null ; } 
protected function do Execute ( Profile Context $ context ) { Message Context Helper : : as Saml Message ( $ context - > get Outbound Context ( ) ) - > set Issue Instant ( $ this - > time Provider - > get Timestamp ( ) ) ; $ this - > logger - > info ( sprintf ( 'Message Issue Instant set to " %s " ' , Message Context Helper : : as Saml Message ( $ context - > get Outbound Context ( ) ) - > get Issue Instant String ( ) ) , Log Helper : : get Action Context ( $ context , $ this ) ) ; } 
public function resolve ( Criteria Set $ criteria Set , array $ arr Credentials = array ( ) ) { if ( false = = $ criteria Set - > has ( Usage Criteria : : class ) ) { return $ arr Credentials ; } $ result = array ( ) ; foreach ( $ criteria Set - > get ( Usage Criteria : : class ) as $ criteria ) { foreach ( $ arr Credentials as $ credential ) { if ( false = = $ credential - > get Usage Type ( ) | | $ criteria - > get Usage ( ) = = $ credential - > get Usage Type ( ) ) { $ result [ ] = $ credential ; } } } return $ result ; } 
protected function create Root Element ( \ DOMNode $ parent , Serialization Context $ context ) { return $ this - > create Element ( 'saml :Encrypted Assertion ' , Saml Constants : : NS _ASSERTION , $ parent , $ context ) ; } 
public function get By Entity Id ( $ entity Id ) { if ( $ entity Id ! = $ this - > entity Id ) { return [ ] ; } if ( null = = $ this - > credential ) { $ certificate = X 5 0 9Certificate : : from File ( $ this - > certificate Path ) ; $ this - > credential = new X 5 0 9Credential ( $ certificate , Key Helper : : create Private Key ( $ this - > key Path , $ this - > password , true , $ certificate - > get Signature Algorithm ( ) ) ) ; $ this - > credential - > set Entity Id ( $ this - > entity Id ) ; } return [ $ this - > credential ] ; } 
public function resolve ( Criteria Set $ criteria Set , array $ arr Credentials = array ( ) ) { if ( false = = $ criteria Set - > has ( Algorithm Criteria : : class ) ) { return $ arr Credentials ; } $ result = array ( ) ; foreach ( $ criteria Set - > get ( Algorithm Criteria : : class ) as $ criteria ) { foreach ( $ arr Credentials as $ credential ) { if ( ( $ credential - > get Private Key ( ) & & $ credential - > get Private Key ( ) - > get Algorith ( ) = = $ criteria - > get Algorithm ( ) ) | | ( $ credential - > get Public Key ( ) & & $ credential - > get Public Key ( ) - > get Algorith ( ) = = $ criteria - > get Algorithm ( ) ) ) { $ result [ ] = $ credential ; } } } return $ result ; } 
public function serialize ( \ DOMNode $ parent , Serialization Context $ context ) { $ result = $ this - > create Element ( 'Conditions ' , Saml Constants : : NS _ASSERTION , $ parent , $ context ) ; $ this - > attributes To Xml ( array ( 'Not Before ' , 'Not On Or After ' ) , $ result ) ; foreach ( $ this - > items as $ item ) { $ item - > serialize ( $ result , $ context ) ; } } 
public static function from File ( $ path ) { $ deserializaton Context = new Deserialization Context ( ) ; $ xml = file _get _contents ( $ path ) ; return self : : from XML ( $ xml , $ deserializaton Context ) ; } 
public static function from XML ( $ xml , Deserialization Context $ context ) { if ( false = = is _string ( $ xml ) ) { throw new \ Invalid Argument Exception ( 'Expecting string ' ) ; } $ context - > get Document ( ) - > load XML ( $ xml ) ; $ node = $ context - > get Document ( ) - > first Child ; while ( $ node & & $ node instanceof \ DOMComment ) { $ node = $ node - > next Sibling ; } if ( null = = = $ node ) { throw new Light Saml Xml Exception ( 'Empty XML ' ) ; } if ( Saml Constants : : NS _METADATA ! = = $ node - > namespace URI ) { throw new Light Saml Xml Exception ( sprintf ( "Invalid namespace ' %s ' of the root XML element , expected ' %s ' " , $ node - > namespace URI , Saml Constants : : NS _METADATA ) ) ; } $ map = array ( 'Entity Descriptor ' = > ' \Light Saml \Model \Metadata \Entity Descriptor ' , 'Entities Descriptor ' = > ' \Light Saml \Model \Metadata \Entities Descriptor ' , ) ; $ root Element Name = $ node - > local Name ; if ( array _key _exists ( $ root Element Name , $ map ) ) { if ( $ class = $ map [ $ root Element Name ] ) { $ result = new $ class ( ) ; } else { throw new \ Logic Exception ( 'Deserialization of %s root element is not implemented ' ) ; } } else { throw new Light Saml Xml Exception ( sprintf ( "Unknown SAML metadata ' %s ' " , $ root Element Name ) ) ; } $ result - > deserialize ( $ node , $ context ) ; return $ result ; } 
protected function do Execute ( Profile Context $ context ) { $ own Entity Descriptor = $ context - > get Own Entity Descriptor ( ) ; $ issuer = new Issuer ( $ own Entity Descriptor - > get Entity ID ( ) ) ; $ issuer - > set Format ( Saml Constants : : NAME _ID _FORMAT _ENTITY ) ; Message Context Helper : : as Saml Message ( $ context - > get Outbound Context ( ) ) - > set Issuer ( $ issuer ) ; $ this - > logger - > debug ( sprintf ( 'Issuer set to " %s " ' , $ own Entity Descriptor - > get Entity ID ( ) ) , Log Helper : : get Action Context ( $ context , $ this ) ) ; } 
public function get ( $ entity Id ) { foreach ( $ this - > children as $ store ) { $ result = $ store - > get ( $ entity Id ) ; if ( $ result ) { return $ result ; } } return null ; } 
public function has ( $ entity Id ) { foreach ( $ this - > children as $ store ) { if ( $ store - > has ( $ entity Id ) ) { return true ; } } return false ; } 
protected function get Criteria Set ( Profile Context $ context ) { $ criteria Set = new Criteria Set ( ) ; $ bindings = $ this - > get Bindings ( $ context ) ; if ( $ bindings ) { $ criteria Set - > add ( new Binding Criteria ( $ bindings ) ) ; } $ descriptor Type = $ this - > get Descriptor Type ( $ context ) ; if ( $ descriptor Type ) { $ criteria Set - > add ( new Descriptor Type Criteria ( $ descriptor Type ) ) ; } $ service Type = $ this - > get Service Type ( $ context ) ; if ( $ service Type ) { $ criteria Set - > add ( new Service Type Criteria ( $ service Type ) ) ; } return $ criteria Set ; } 
public function add Own Credential ( Credential Interface $ credential ) { if ( null = = $ credential - > get Private Key ( ) ) { throw new Light Saml Build Exception ( 'Own credential must have private key ' ) ; } $ this - > own Credentials [ ] = $ credential ; return $ this ; } 
public function validate Assertion ( Assertion $ assertion ) { $ this - > validate Assertion Attributes ( $ assertion ) ; $ this - > validate Subject ( $ assertion ) ; $ this - > validate Conditions ( $ assertion ) ; $ this - > validate Statements ( $ assertion ) ; } 
protected function validate Assertion Attributes ( Assertion $ assertion ) { if ( false = = Helper : : validate Required String ( $ assertion - > get Version ( ) ) ) { throw new Light Saml Validation Exception ( 'Assertion element must have the Version attribute set . ' ) ; } if ( Saml Constants : : VERSION _ 2 0 ! = $ assertion - > get Version ( ) ) { throw new Light Saml Validation Exception ( 'Assertion element must have the Version attribute value equal to 2 . 0 . ' ) ; } if ( false = = Helper : : validate Required String ( $ assertion - > get Id ( ) ) ) { throw new Light Saml Validation Exception ( 'Assertion element must have the ID attribute set . ' ) ; } if ( false = = Helper : : validate Id String ( $ assertion - > get Id ( ) ) ) { throw new Light Saml Validation Exception ( 'Assertion element must have an ID attribute with at least 1 6 characters (the equivalent of 1 2 8 bits ) . ' ) ; } if ( false = = $ assertion - > get Issue Instant Timestamp ( ) ) { throw new Light Saml Validation Exception ( 'Assertion element must have the Issue Instant attribute set . ' ) ; } if ( false = = $ assertion - > get Issuer ( ) ) { throw new Light Saml Validation Exception ( 'Assertion element must have an issuer element . ' ) ; } $ this - > name Id Validator - > validate Name Id ( $ assertion - > get Issuer ( ) ) ; } 
protected function validate Subject ( Assertion $ assertion ) { if ( false = = $ assertion - > get Subject ( ) ) { if ( false = = $ assertion - > get All Items ( ) ) { throw new Light Saml Validation Exception ( 'Assertion with no Statements must have a subject . ' ) ; } foreach ( $ assertion - > get All Items ( ) as $ item ) { if ( $ item instanceof Authn Statement | | $ item instanceof Attribute Statement ) { throw new Light Saml Validation Exception ( 'Authn Statement , Authz Decision Statement and Attribute Statement require a subject . ' ) ; } } } else { $ this - > subject Validator - > validate Subject ( $ assertion - > get Subject ( ) ) ; } } 
protected function validate Proxy Restriction ( Proxy Restriction $ item ) { if ( null = = = $ item - > get Count ( ) | | ' ' = = = $ item - > get Count ( ) | | intval ( $ item - > get Count ( ) ) ! = $ item - > get Count ( ) | | $ item - > get Count ( ) < 0 ) { throw new Light Saml Validation Exception ( 'Count attribute of Proxy Restriction MUST BE a non -negative integer ' ) ; } if ( $ item - > get All Audience ( ) ) { foreach ( $ item - > get All Audience ( ) as $ audience ) { if ( false = = Helper : : validate Well Formed Uri String ( $ audience ) ) { throw new Light Saml Validation Exception ( 'Proxy Restriction Audience MUST BE a wellformed uri ' ) ; } } } } 
protected function validate Audience Restriction ( Audience Restriction $ item ) { if ( false = = $ item - > get All Audience ( ) ) { return ; } foreach ( $ item - > get All Audience ( ) as $ audience ) { if ( false = = Helper : : validate Well Formed Uri String ( $ audience ) ) { throw new Light Saml Validation Exception ( 'Audience Restriction MUST BE a wellformed uri ' ) ; } } } 
public function validate ( XMLSecurity Key $ key ) { if ( null = = $ this - > get Signature ( ) ) { return false ; } $ key = $ this - > cast Key If Necessary ( $ key ) ; $ signature = base 6 4 _decode ( $ this - > get Signature ( ) ) ; if ( false = = $ key - > verify Signature ( $ this - > get Data ( ) , $ signature ) ) { throw new Light Saml Security Exception ( 'Unable to validate signature on query string ' ) ; } return true ; } 
public function serialize ( \ DOMNode $ parent , Serialization Context $ context ) { $ this - > prepare For Xml ( ) ; if ( Saml Constants : : NS _ASSERTION = = $ parent - > namespace URI ) { $ result = $ this - > create Element ( $ this - > get Element Name ( ) , Saml Constants : : NS _ASSERTION , $ parent , $ context ) ; } else { $ result = $ this - > create Element ( 'saml : ' . $ this - > get Element Name ( ) , Saml Constants : : NS _ASSERTION , $ parent , $ context ) ; } $ this - > attributes To Xml ( array ( 'Format ' , 'Name Qualifier ' , 'SPName Qualifier ' , 'SPProvided ID ' ) , $ result ) ; $ result - > node Value = $ this - > get Value ( ) ; } 
public function add Contact Person ( Contact Person $ contact Person ) { if ( false = = is _array ( $ this - > contact Persons ) ) { $ this - > contact Persons = array ( ) ; } $ this - > contact Persons [ ] = $ contact Person ; return $ this ; } 
public function add Key Descriptor ( Key Descriptor $ key Descriptor ) { if ( false = = is _array ( $ this - > key Descriptors ) ) { $ this - > key Descriptors = array ( ) ; } $ this - > key Descriptors [ ] = $ key Descriptor ; return $ this ; } 
public function get All Key Descriptors By Use ( $ use ) { $ result = array ( ) ; foreach ( $ this - > get All Key Descriptors ( ) as $ kd ) { if ( $ kd - > get Use ( ) = = $ use ) { $ result [ ] = $ kd ; } } return $ result ; } 
public function get First Key Descriptor ( $ use = null ) { if ( $ this - > get All Key Descriptors ( ) ) { foreach ( $ this - > get All Key Descriptors ( ) as $ kd ) { if ( null = = $ use | | $ kd - > get Use ( ) = = $ use ) { return $ kd ; } } } return ; } 
public function add Organization ( Organization $ organization ) { if ( false = = is _array ( $ this - > organizations ) ) { $ this - > organizations = array ( ) ; } $ this - > organizations [ ] = $ organization ; return $ this ; } 
public function add Signature ( Signature $ signature ) { if ( false = = is _array ( $ this - > signatures ) ) { $ this - > signatures = array ( ) ; } $ this - > signatures [ ] = $ signature ; return $ this ; } 
public function serialize ( \ DOMNode $ parent , Serialization Context $ context ) { $ this - > attributes To Xml ( array ( 'protocol Support Enumeration ' , 'ID ' , 'valid Until ' , 'cache Duration ' , 'error URL ' ) , $ parent ) ; $ this - > many Elements To Xml ( $ this - > get All Signatures ( ) , $ parent , $ context , null ) ; $ this - > many Elements To Xml ( $ this - > get All Key Descriptors ( ) , $ parent , $ context , null ) ; $ this - > many Elements To Xml ( $ this - > get All Organizations ( ) , $ parent , $ context , null ) ; $ this - > many Elements To Xml ( $ this - > get All Contact Persons ( ) , $ parent , $ context , null ) ; } 
public function validate Statement ( Abstract Statement $ statement ) { if ( $ statement instanceof Authn Statement ) { $ this - > validate Authn Statement ( $ statement ) ; } elseif ( $ statement instanceof Attribute Statement ) { $ this - > validate Attribute Statement ( $ statement ) ; } else { throw new Light Saml Validation Exception ( sprintf ( "Unsupported Statement type ' %s ' " , get _class ( $ statement ) ) ) ; } } 
public function get ( $ class ) { foreach ( $ this - > contexts as $ context ) { if ( get _class ( $ context ) = = $ class | | is _subclass _of ( $ context , $ class ) ) { return $ context ; } } return null ; } 
public function set Is Passive ( $ is Passive ) { $ this - > is Passive = 0 = = strcasecmp ( $ is Passive , 'true ' ) | | true = = = $ is Passive | | 1 = = $ is Passive ; return $ this ; } 
public function set Force Authn ( $ force Authn ) { $ this - > force Authn = 0 = = strcasecmp ( $ force Authn , 'true ' ) | | true = = = $ force Authn | | 1 = = $ force Authn ; return $ this ; } 
public function set Attribute Consuming Service Index ( $ attribute Consuming Service Index ) { $ this - > attribute Consuming Service Index = null ! = = $ attribute Consuming Service Index ? intval ( ( ( string ) $ attribute Consuming Service Index ) ) : null ; return $ this ; } 
public function set Assertion Consumer Service Index ( $ assertion Consumer Service Index ) { $ this - > assertion Consumer Service Index = null ! = = $ assertion Consumer Service Index ? intval ( ( string ) $ assertion Consumer Service Index ) : null ; return $ this ; } 
public function serialize ( \ DOMNode $ parent , Serialization Context $ context ) { $ result = $ this - > create Element ( 'Authn Request ' , Saml Constants : : NS _PROTOCOL , $ parent , $ context ) ; parent : : serialize ( $ result , $ context ) ; $ this - > attributes To Xml ( array ( 'Force Authn ' , 'Is Passive ' , 'Protocol Binding ' , 'Assertion Consumer Service Index ' , 'Assertion Consumer Service URL ' , 'Attribute Consuming Service Index ' , 'Provider Name ' , ) , $ result ) ; $ this - > single Elements To Xml ( array ( 'Subject ' , 'Name IDPolicy ' , 'Conditions ' ) , $ result , $ context ) ; 
private function should Sign Message ( Profile Context $ context ) { $ message = $ context - > get Outbound Message ( ) ; if ( $ message instanceof Logout Request ) { return true ; } $ trust Options = $ context - > get Trust Options ( ) ; if ( $ message instanceof Authn Request ) { return $ trust Options - > get Sign Authn Request ( ) ; } elseif ( $ message instanceof Response ) { return $ trust Options - > get Sign Response ( ) ; } throw new \ Logic Exception ( sprintf ( 'Unexpected message type " %s " ' , get _class ( $ message ) ) ) ; } 
public function get Preference ( $ binding ) { return isset ( $ this - > bindings [ $ binding ] ) ? $ this - > bindings [ $ binding ] : null ; } 
public static function create ( Signing Options $ options ) { $ writer = new self ( $ options - > get Certificate ( ) , $ options - > get Private Key ( ) ) ; $ writer - > signing Options = $ options ; return $ writer ; } 
public static function create By Key And Certificate ( X 5 0 9Certificate $ certificate , XMLSecurity Key $ xml Security Key ) { $ signing Options = new Signing Options ( $ xml Security Key , $ certificate ) ; return self : : create ( $ signing Options ) ; } 
public function send ( Message Context $ context , $ destination = null ) { $ destination = $ context - > get Message ( ) - > get Destination ( ) ? $ context - > get Message ( ) - > get Destination ( ) : $ destination ; $ url = $ this - > get Redirect URL ( $ context , $ destination ) ; return new Redirect Response ( $ url ) ; } 
protected function process Data ( array $ data , Message Context $ context ) { $ msg = $ this - > get Message String From Data ( $ data ) ; $ encoding = $ this - > get Encoding From Data ( $ data ) ; $ msg = $ this - > decode Message String ( $ msg , $ encoding ) ; $ this - > dispatch Receive ( $ msg ) ; $ deserialization Context = $ context - > get Deserialization Context ( ) ; $ message = Saml Message : : from XML ( $ msg , $ deserialization Context ) ; $ this - > load Relay State ( $ message , $ data ) ; $ this - > load Signature ( $ message , $ data ) ; $ context - > set Message ( $ message ) ; } 
protected function decode Message String ( $ msg , $ encoding ) { $ msg = base 6 4 _decode ( $ msg ) ; switch ( $ encoding ) { case Saml Constants : : ENCODING _DEFLATE : return gzinflate ( $ msg ) ; break ; default : throw new Light Saml Binding Exception ( sprintf ( "Unknown encoding ' %s ' " , $ encoding ) ) ; } } 
protected function get Redirect URL ( Message Context $ context , $ destination ) { $ message = Message Context Helper : : as Saml Message ( $ context ) ; $ signature = $ message - > get Signature ( ) ; if ( $ signature & & false = = $ signature instanceof Signature Writer ) { throw new Light Saml Binding Exception ( 'Signature must be Signature Writer ' ) ; } $ xml = $ this - > get Message Encoded Xml ( $ message , $ context ) ; $ msg = $ this - > add Message To Url ( $ message , $ xml ) ; $ this - > add Relay State To Url ( $ msg , $ message ) ; $ this - > add Signature To Url ( $ msg , $ signature ) ; return $ this - > get Destination Url ( $ msg , $ message , $ destination ) ; } 
protected function get Message Encoded Xml ( Saml Message $ message , Message Context $ context ) { $ message - > set Signature ( null ) ; $ serialization Context = $ context - > get Serialization Context ( ) ; $ message - > serialize ( $ serialization Context - > get Document ( ) , $ serialization Context ) ; $ xml = $ serialization Context - > get Document ( ) - > save XML ( ) ; $ this - > dispatch Send ( $ xml ) ; $ xml = gzdeflate ( $ xml ) ; $ xml = base 6 4 _encode ( $ xml ) ; return $ xml ; } 
protected function add Message To Url ( Saml Message $ message , $ xml ) { if ( $ message instanceof Abstract Request ) { $ msg = 'SAMLRequest = ' ; } else { $ msg = 'SAMLResponse = ' ; } $ msg . = urlencode ( $ xml ) ; return $ msg ; } 
protected function get Destination Url ( $ msg , Saml Message $ message , $ destination ) { $ destination = $ message - > get Destination ( ) ? $ message - > get Destination ( ) : $ destination ; if ( false = = = strpos ( $ destination , ' ? ' ) ) { $ destination . = ' ? ' . $ msg ; } else { $ destination . = ' & ' . $ msg ; } return $ destination ; } 
protected function parse Query ( Request $ request ) { $ sig Query = $ relay State = $ sig Alg = ' ' ; $ data = $ this - > parse Query String ( $ request - > server - > get ( 'QUERY _STRING ' ) , false ) ; $ result = array ( ) ; foreach ( $ data as $ name = > $ value ) { $ result [ $ name ] = urldecode ( $ value ) ; switch ( $ name ) { case 'SAMLRequest ' : case 'SAMLResponse ' : $ sig Query = $ name . ' = ' . $ value ; break ; case 'Relay State ' : $ relay State = ' &Relay State = ' . $ value ; break ; case 'Sig Alg ' : $ sig Alg = ' &Sig Alg = ' . $ value ; break ; } } $ result [ 'Signed Query ' ] = $ sig Query . $ relay State . $ sig Alg ; return $ result ; } 
private function build Own Entity Descriptor Provider ( \ Light Saml \ Credential \ X 5 0 9Certificate $ certificate ) { return new \ Light Saml \ Builder \ Entity Descriptor \ Simple Entity Descriptor Builder ( self : : OWN _ENTITY _ID , 'https : / /localhost /lightsaml /light SAML /web /sp /acs .php ' , null , $ certificate ) ; } 
public function validate ( Abstract Signature Reader $ signature , $ issuer , $ metadata Type ) { $ query = $ this - > credential Resolver - > query ( ) ; $ query - > add ( new Entity Id Criteria ( $ issuer ) ) - > add ( new Metadata Criteria ( $ metadata Type , Saml Constants : : VERSION _ 2 0 ) ) - > add ( new Usage Criteria ( Usage Type : : SIGNING ) ) ; if ( $ signature - > get Key ( ) & & $ signature - > get Key ( ) - > get X 5 0 9Thumbprint ( ) ) { $ query - > add ( new Public Key Thumbprint Criteria ( $ signature - > get Key ( ) - > get X 5 0 9Thumbprint ( ) ) ) ; } $ query - > resolve ( ) ; $ credential Candidates = $ query - > all Credentials ( ) ; if ( empty ( $ credential Candidates ) ) { throw new Light Saml Security Exception ( 'No credentials resolved for signature verification ' ) ; } $ credential = $ signature - > validate Multi ( $ credential Candidates ) ; return $ credential ; } 
public function get By Entity Id ( $ entity Id ) { $ entity Descriptor = $ this - > entity Descriptor Provider - > get ( $ entity Id ) ; if ( false = = $ entity Descriptor ) { return array ( ) ; } return $ this - > extract Credentials ( $ entity Descriptor ) ; } 
protected function extract Credentials ( Entity Descriptor $ entity Descriptor ) { $ result = array ( ) ; foreach ( $ entity Descriptor - > get All Idp Sso Descriptors ( ) as $ idp Descriptor ) { $ this - > handle Descriptor ( $ idp Descriptor , $ entity Descriptor , $ result ) ; } foreach ( $ entity Descriptor - > get All Sp Sso Descriptors ( ) as $ sp Descriptor ) { $ this - > handle Descriptor ( $ sp Descriptor , $ entity Descriptor , $ result ) ; } return $ result ; } 
public function build From Own Credential Store ( Entity Descriptor Store Interface $ idp Entity Descriptor Store , Entity Descriptor Store Interface $ sp Entity Descriptor Store , $ own Entity Id , Credential Store Interface $ own Credential Store , array $ extra Credentials = null ) { return $ this - > build ( $ idp Entity Descriptor Store , $ sp Entity Descriptor Store , $ own Credential Store - > get By Entity Id ( $ own Entity Id ) , $ extra Credentials ) ; } 
public function build ( Entity Descriptor Store Interface $ idp Entity Descriptor Store , Entity Descriptor Store Interface $ sp Entity Descriptor Store , array $ own Credentials , array $ extra Credentials = null ) { if ( empty ( $ own Credentials ) ) { throw new Light Saml Build Exception ( 'There are no own credentials ' ) ; } $ store = new Composite Credential Store ( ) ; $ store - > add ( new Metadata Credential Store ( $ idp Entity Descriptor Store ) ) ; $ store - > add ( new Metadata Credential Store ( $ sp Entity Descriptor Store ) ) ; $ own Credentials Store = new Static Credential Store ( ) ; foreach ( $ own Credentials as $ credential ) { $ own Credentials Store - > add ( $ credential ) ; } $ store - > add ( $ own Credentials Store ) ; $ extra Credentials Store = new Static Credential Store ( ) ; $ store - > add ( $ extra Credentials Store ) ; foreach ( $ this - > extra Credentials as $ credential ) { $ extra Credentials Store - > add ( $ credential ) ; } if ( $ extra Credentials ) { foreach ( $ extra Credentials as $ credential ) { $ extra Credentials Store - > add ( $ credential ) ; } } return $ store ; } 
public static function is Protocol Valid ( $ value ) { static $ arr = array ( self : : PROTOCOL _SAML 2 , self : : PROTOCOL _SAML 1 , self : : PROTOCOL _SAML 1 1 , self : : PROTOCOL _SHIB 1 , self : : PROTOCOL _WS _FED , ) ; return in _array ( $ value , $ arr ) ; } 
public static function is Ns Valid ( $ value ) { static $ arr = array ( self : : NS _PROTOCOL , self : : NS _METADATA , self : : NS _ASSERTION , self : : NS _XMLDSIG , ) ; return in _array ( $ value , $ arr ) ; } 
public static function is Name Id Format Valid ( $ value ) { static $ arr = array ( self : : NAME _ID _FORMAT _NONE , self : : NAME _ID _FORMAT _ENTITY , self : : NAME _ID _FORMAT _PERSISTENT , self : : NAME _ID _FORMAT _TRANSIENT , self : : NAME _ID _FORMAT _EMAIL , self : : NAME _ID _FORMAT _SHIB _NAME _ID , self : : NAME _ID _FORMAT _X 5 0 9 _SUBJECT _NAME , self : : NAME _ID _FORMAT _WINDOWS , self : : NAME _ID _FORMAT _KERBEROS , self : : NAME _ID _FORMAT _UNSPECIFIED , ) ; return in _array ( $ value , $ arr ) ; } 
public static function is Binding Valid ( $ value ) { static $ arr = array ( self : : BINDING _SAML 2 _HTTP _REDIRECT , self : : BINDING _SAML 2 _HTTP _POST , self : : BINDING _SAML 2 _HTTP _ARTIFACT , self : : BINDING _SAML 2 _SOAP , self : : BINDING _SAML 2 _HTTP _POST _SIMPLE _SIGN , self : : BINDING _SHIB 1 _AUTHN _REQUEST , self : : BINDING _SAML 1 _BROWSER _POST , self : : BINDING _SAML 1 _ARTIFACT 1 , self : : BINDING _WS _FED _WEB _SVC , ) ; return in _array ( $ value , $ arr ) ; } 
public static function is Status Valid ( $ value ) { static $ arr = array ( self : : STATUS _SUCCESS , self : : STATUS _REQUESTER , self : : STATUS _RESPONDER , self : : STATUS _VERSION _MISMATCH , self : : STATUS _NO _PASSIVE , self : : STATUS _PARTIAL _LOGOUT , self : : STATUS _PROXY _COUNT _EXCEEDED , self : : STATUS _INVALID _NAME _ID _POLICY , self : : STATUS _UNSUPPORTED _BINDING , ) ; return in _array ( $ value , $ arr ) ; } 
public static function is Confirmation Method Valid ( $ value ) { static $ arr = array ( self : : CONFIRMATION _METHOD _BEARER , self : : CONFIRMATION _METHOD _HOK , self : : CONFIRMATION _METHOD _SENDER _VOUCHES , ) ; return in _array ( $ value , $ arr ) ; } 
public static function is Authn Context Valid ( $ value ) { static $ arr = array ( self : : AUTHN _CONTEXT _PASSWORD , self : : AUTHN _CONTEXT _UNSPECIFIED , self : : AUTHN _CONTEXT _PASSWORD _PROTECTED _TRANSPORT , self : : AUTHN _CONTEXT _WINDOWS , ) ; return in _array ( $ value , $ arr ) ; } 
public static function is Logout Reason Valid ( $ value ) { static $ arr = array ( self : : LOGOUT _REASON _USER , self : : LOGOUT _REASON _ADMIN , self : : LOGOUT _REASON _GLOBAL _TIMEOUT , self : : LOGOUT _REASON _SP _TIMEOUT , ) ; return in _array ( $ value , $ arr ) ; } 
public function set ID ( $ id ) { $ this - > id = null ! = = $ id ? ( string ) $ id : null ; return $ this ; } 
public function add Item ( $ item ) { if ( false = = $ item instanceof Idp Sso Descriptor & & false = = $ item instanceof Sp Sso Descriptor ) { throw new \ Invalid Argument Exception ( 'Entity Descriptor item must be Idp Sso Descriptor or Sp Sso Descriptor ' ) ; } if ( false = = is _array ( $ this - > items ) ) { $ this - > items = array ( ) ; } $ this - > items [ ] = $ item ; return $ this ; } 
public function serialize ( \ DOMNode $ parent , Serialization Context $ context ) { $ result = $ this - > create Element ( 'Entity Descriptor ' , Saml Constants : : NS _METADATA , $ parent , $ context ) ; $ this - > attributes To Xml ( array ( 'entity ID ' , 'valid Until ' , 'cache Duration ' , 'ID ' ) , $ result ) ; $ this - > many Elements To Xml ( $ this - > get All Items ( ) , $ result , $ context , null ) ; if ( $ this - > organizations ) { $ this - > many Elements To Xml ( $ this - > organizations , $ result , $ context , null ) ; } if ( $ this - > contact Persons ) { $ this - > many Elements To Xml ( $ this - > contact Persons , $ result , $ context , null ) ; } $ this - > single Elements To Xml ( array ( 'Signature ' ) , $ result , $ context ) ; } 
public function get By Entity Id ( $ entity Id ) { $ result = array ( ) ; foreach ( $ this - > stores as $ store ) { $ result = array _merge ( $ result , $ store - > get By Entity Id ( $ entity Id ) ) ; } return $ result ; } 
protected function create Element ( $ name , $ namespace , \ DOMNode $ parent , Serialization Context $ context ) { if ( $ namespace ) { $ result = $ context - > get Document ( ) - > create Element NS ( $ namespace , $ name ) ; } else { $ result = $ context - > get Document ( ) - > create Element ( $ name ) ; } $ parent - > append Child ( $ result ) ; return $ result ; } 
private function one Element To Xml ( $ name , \ DOMNode $ parent , Serialization Context $ context , $ namespace = null ) { $ value = $ this - > get Property Value ( $ name ) ; if ( null = = $ value ) { return ; } if ( $ value instanceof Saml Element Interface ) { $ value - > serialize ( $ parent , $ context ) ; } elseif ( is _string ( $ value ) ) { if ( $ namespace ) { $ node = $ context - > get Document ( ) - > create Element NS ( $ namespace , $ name , $ value ) ; } else { $ node = $ context - > get Document ( ) - > create Element ( $ name , $ value ) ; } $ parent - > append Child ( $ node ) ; } else { throw new \ Logic Exception ( sprintf ( "Element ' %s ' must implement Saml Element Interface or be a string " , $ name ) ) ; } } 
protected function many Elements To Xml ( $ value , \ DOMNode $ node , Serialization Context $ context , $ node Name = null , $ namespace Uri = null ) { if ( false = = $ value ) { return ; } if ( false = = is _array ( $ value ) ) { throw new \ Logic Exception ( 'value must be array or null ' ) ; } foreach ( $ value as $ object ) { if ( $ object instanceof Saml Element Interface ) { if ( $ node Name ) { throw new \ Logic Exception ( 'node Name should not be specified when serializing array of Saml Element Interface ' ) ; } $ object - > serialize ( $ node , $ context ) ; } elseif ( $ node Name ) { if ( $ namespace Uri ) { $ child = $ context - > get Document ( ) - > create Element NS ( $ namespace Uri , $ node Name , ( string ) $ object ) ; } else { $ child = $ context - > get Document ( ) - > create Element ( $ node Name , ( string ) $ object ) ; } $ node - > append Child ( $ child ) ; } else { throw new \ Logic Exception ( 'Can handle only array of Abstract Saml Model or strings with node Name parameter specified ' ) ; } } } 
protected function many Elements From Xml ( \ DOMElement $ node , Deserialization Context $ context , $ node Name , $ namespace Prefix , $ class , $ method Name ) { if ( $ namespace Prefix ) { $ query = sprintf ( ' %s : %s ' , $ namespace Prefix , $ node Name ) ; } else { $ query = sprintf ( ' %s ' , $ node Name ) ; } foreach ( $ context - > get Xpath ( ) - > query ( $ query , $ node ) as $ xml ) { if ( $ class ) { $ object = new $ class ( ) ; if ( false = = $ object instanceof Saml Element Interface ) { throw new \ Logic Exception ( sprintf ( "Node ' %s ' class ' %s ' must implement Saml Element Interface " , $ node Name , $ class ) ) ; } $ object - > deserialize ( $ xml , $ context ) ; $ this - > { $ method Name } ( $ object ) ; } else { $ object = $ xml - > text Content ; $ this - > { $ method Name } ( $ object ) ; } } } 
protected function single Attribute To Xml ( $ name , \ DOMElement $ element ) { $ value = $ this - > get Property Value ( $ name ) ; if ( null ! = = $ value & & ' ' ! = = $ value ) { if ( is _bool ( $ value ) ) { $ element - > set Attribute ( $ name , $ value ? 'true ' : 'false ' ) ; } else { $ element - > set Attribute ( $ name , $ value ) ; } return true ; } return false ; } 
protected function one Element From Xml ( \ DOMElement $ node , Deserialization Context $ context , $ element Name , $ class , $ namespace Prefix ) { if ( $ namespace Prefix ) { $ query = sprintf ( ' . / %s : %s ' , $ namespace Prefix , $ element Name ) ; } else { $ query = sprintf ( ' . / %s ' , $ element Name ) ; } $ arr = $ context - > get Xpath ( ) - > query ( $ query , $ node ) ; $ value = $ arr - > length > 0 ? $ arr - > item ( 0 ) : null ; if ( $ value ) { $ setter = 'set ' . $ element Name ; if ( false = = method _exists ( $ this , $ setter ) ) { throw new \ Logic Exception ( sprintf ( "Unable to find setter for element ' %s ' in class ' %s ' " , $ element Name , get _class ( $ this ) ) ) ; } if ( $ class ) { $ object = new $ class ( ) ; if ( false = = $ object instanceof \ Light Saml \ Model \ Saml Element Interface ) { throw new \ Logic Exception ( sprintf ( "Specified class ' %s ' for element ' %s ' must implement Saml Element Interface " , $ class , $ element Name ) ) ; } $ object - > deserialize ( $ value , $ context ) ; } else { $ object = $ value - > text Content ; } $ this - > { $ setter } ( $ object ) ; } } 
private function get Property Value ( $ name ) { if ( false ! = = ( $ pos = strpos ( $ name , ' : ' ) ) ) { $ name = substr ( $ name , $ pos + 1 ) ; } $ getter = 'get ' . $ name . 'String ' ; if ( false = = method _exists ( $ this , $ getter ) ) { $ getter = 'get ' . $ name ; } if ( false = = method _exists ( $ this , $ getter ) ) { throw new \ Logic Exception ( sprintf ( "Unable to find getter method for ' %s ' on ' %s ' " , $ name , get _class ( $ this ) ) ) ; } $ value = $ this - > { $ getter } ( ) ; return $ value ; } 
public function encrypt ( Abstract Saml Model $ object , XMLSecurity Key $ key ) { $ old Key = $ key ; $ key = new XMLSecurity Key ( $ this - > key Transport Encryption , [ 'type ' = > 'public ' ] ) ; $ key - > load Key ( $ old Key - > key ) ; $ serialization Context = new Serialization Context ( ) ; $ object - > serialize ( $ serialization Context - > get Document ( ) , $ serialization Context ) ; $ enc = new XMLSec Enc ( ) ; $ enc - > set Node ( $ serialization Context - > get Document ( ) - > first Child ) ; $ enc - > type = XMLSec Enc : : Element ; switch ( $ key - > type ) { case XMLSecurity Key : : TRIPLEDES _CBC : case XMLSecurity Key : : AES 1 2 8 _CBC : case XMLSecurity Key : : AES 1 9 2 _CBC : case XMLSecurity Key : : AES 2 5 6 _CBC : $ symmetric Key = $ key ; break ; case XMLSecurity Key : : RSA _ 1 _ 5 : case XMLSecurity Key : : RSA _SHA 1 : case XMLSecurity Key : : RSA _SHA 2 5 6 : case XMLSecurity Key : : RSA _SHA 3 8 4 : case XMLSecurity Key : : RSA _SHA 5 1 2 : case XMLSecurity Key : : RSA _OAEP _MGF 1P : $ symmetric Key = new XMLSecurity Key ( $ this - > block Encryption Algorithm ) ; $ symmetric Key - > generate Session Key ( ) ; $ enc - > encrypt Key ( $ key , $ symmetric Key ) ; break ; default : throw new Light Saml Exception ( sprintf ( 'Unknown key type for encryption : " %s " ' , $ key - > type ) ) ; } $ this - > encrypted Element = $ enc - > encrypt Node ( $ symmetric Key ) ; return $ serialization Context ; } 
public function serialize ( \ DOMNode $ parent , Serialization Context $ context ) { if ( null = = = $ this - > encrypted Element ) { throw new Light Saml Exception ( 'Encrypted element missing ' ) ; } $ root = $ this - > create Root Element ( $ parent , $ context ) ; $ root - > append Child ( $ context - > get Document ( ) - > import Node ( $ this - > encrypted Element , true ) ) ; } 
public static function get Action Context ( Context Interface $ context , Action Interface $ action , array $ extra Data = null ) { return self : : get Context ( $ context , $ action , $ extra Data , false ) ; } 
public static function get Action Error Context ( Context Interface $ context , Action Interface $ action , array $ extra Data = null ) { return self : : get Context ( $ context , $ action , $ extra Data , true ) ; } 
private static function get Context ( Context Interface $ context , Action Interface $ action = null , array $ extra Data = null , $ log Whole Context = false ) { $ top Context = $ context - > get Top Parent ( ) ; $ result = array ( ) ; if ( $ top Context instanceof Profile Context ) { $ result [ 'profile _id ' ] = $ top Context - > get Profile Id ( ) ; $ result [ 'own _role ' ] = $ top Context - > get Own Role ( ) ; } if ( $ action ) { $ result [ 'action ' ] = get _class ( $ action ) ; } $ result [ 'top _context _id ' ] = spl _object _hash ( $ top Context ) ; if ( $ log Whole Context ) { $ result [ 'top _context ' ] = $ top Context ; } if ( $ extra Data ) { $ result = array _merge ( $ result , $ extra Data ) ; } return $ result ; } 
public static function create Element ( DOMDocument $ document , $ name , array $ attributes = [ ] ) : DOMElement { $ element = $ document - > create Element ( $ name ) ; foreach ( $ attributes as $ attrib Name = > $ attrib Value ) { $ element - > set Attribute ( $ attrib Name , $ attrib Value ) ; } return $ element ; } 
public static function create Element With Text ( DOMDocument $ document , string $ name , string $ text , array $ attributes = [ ] ) : DOMElement { $ element = self : : create Element ( $ document , $ name , $ attributes ) ; $ wrapped Text = $ document - > create CDATASection ( $ text ) ; $ element - > append Child ( $ wrapped Text ) ; return $ element ; } 
private static function validate Images ( array $ images ) : bool { $ valid = false ; foreach ( $ images as $ image ) { if ( $ image - > get Type ( ) = = = Image : : TYPE _DEFAULT ) { $ valid = true ; break ; } } if ( ! $ valid ) { throw new Base Image Missing Exception ( ) ; } return $ valid ; } 
public static function check For Empty Value ( string $ value Name , $ value ) : string { $ value = trim ( $ value ) ; if ( $ value = = = ' ' ) { throw new Empty Value Not Allowed Exception ( $ value Name ) ; } return $ value ; } 
public static function validate Url ( string $ url ) : string { if ( ! filter _var ( $ url , FILTER _VALIDATE _URL ) | | ! preg _match ( ' /http [s ] ? : \ / \ / . * / ' , $ url ) ) { throw new Invalid Url Exception ( ) ; } return $ url ; } 
public static function check For Illegal Csv Property Keys ( string $ property Key ) : void { if ( strpos ( $ property Key , " \t " ) ! = = false | | strpos ( $ property Key , " \n " ) ! = = false ) { throw new Bad Property Key Exception ( $ property Key ) ; } } 
public static function create ( int $ type , int $ items Per Page = 2 0 , array $ csv Properties = [ ] ) : Exporter { if ( $ items Per Page < 1 ) { throw new Invalid Argument Exception ( 'At least one item must be exported per page . ' ) ; } switch ( $ type ) { case self : : TYPE _XML : $ exporter = new XMLExporter ( $ items Per Page ) ; break ; case self : : TYPE _CSV : $ exporter = new CSVExporter ( $ items Per Page , $ csv Properties ) ; break ; default : throw new Invalid Argument Exception ( 'Unsupported exporter type . ' ) ; } return $ exporter ; } 
public function add Value ( string $ value , ? string $ usergroup = null ) : void { if ( array _key _exists ( $ usergroup , $ this - > get All Values ( ) ) ) { throw new Duplicate Value For Usergroup Exception ( $ this - > get Key ( ) , $ usergroup ) ; } $ this - > values [ $ usergroup ] = Data Helper : : check For Empty Value ( 'property Value ' , $ value ) ; } 
private function validate With Schema ( DOMDocument $ document ) : void { $ validation Errors = [ ] ; set _error _handler ( function ( $ errno , $ errstr ) use ( & $ validation Errors ) { array _push ( $ validation Errors , $ errstr ) ; } ) ; $ is Valid = $ document - > schema Validate ( Constant : : $ XSD _SCHEMA _PATH ) ; restore _error _handler ( ) ; if ( ! $ is Valid ) { throw new XMLSchema Violation Exception ( $ validation Errors ) ; } } 
public function add Name ( string $ name , string $ usergroup = ' ' ) : void { $ this - > name - > set Value ( $ name , $ usergroup ) ; } 
public function add Summary ( string $ summary , string $ usergroup = ' ' ) : void { $ this - > summary - > set Value ( $ summary , $ usergroup ) ; } 
public function add Description ( string $ description , string $ usergroup = ' ' ) : void { $ this - > description - > set Value ( $ description , $ usergroup ) ; } 
public function add Price ( $ price , $ usergroup = ' ' ) : void { if ( $ this - > price = = = null ) { $ this - > price = new Price ( ) ; } $ this - > price - > set Value ( $ price , $ usergroup ) ; } 
public function add Bonus ( float $ bonus , string $ usergroup = ' ' ) : void { $ this - > bonus - > set Value ( $ bonus , $ usergroup ) ; } 
public function add Sales Frequency ( int $ sales Frequency , string $ usergroup = ' ' ) : void { $ this - > sales Frequency - > set Value ( $ sales Frequency , $ usergroup ) ; } 
public function add Date Added ( Date Time $ date Added , string $ usergroup = ' ' ) : void { $ this - > date Added - > set Date Value ( $ date Added , $ usergroup ) ; } 
public function add Sort ( int $ sort , string $ usergroup = ' ' ) : void { $ this - > sort - > set Value ( $ sort , $ usergroup ) ; } 
protected function validate ( $ value ) { $ value = trim ( $ value ) ; if ( $ value = = = ' ' ) { throw new Empty Value Not Allowed Exception ( $ this - > get Value Name ( ) ) ; } return $ value ; } 
public function get ( $ name ) { if ( ! $ this - > has ( $ name ) ) { throw new Invalid Argument Exception ( sprintf ( 'Hook named " %s " is not present ' , $ name ) ) ; } return file _get _contents ( $ this - > get Path ( $ name ) ) ; } 
public function set Symlink ( $ name , $ file ) { if ( $ this - > has ( $ name ) ) { throw new Logic Exception ( sprintf ( 'A hook " %s " is already defined ' , $ name ) ) ; } $ path = $ this - > get Path ( $ name ) ; if ( false = = = symlink ( $ file , $ path ) ) { throw new Runtime Exception ( sprintf ( 'Unable to create hook " %s " ' , $ name , $ path ) ) ; } } 
public function set ( $ name , $ content ) { if ( $ this - > has ( $ name ) ) { throw new Logic Exception ( sprintf ( 'A hook " %s " is already defined ' , $ name ) ) ; } $ path = $ this - > get Path ( $ name ) ; file _put _contents ( $ path , $ content ) ; chmod ( $ path , 0 7 7 7 ) ; } 
public function remove ( $ name ) { if ( ! $ this - > has ( $ name ) ) { throw new Logic Exception ( sprintf ( 'The hook " %s " was not found ' , $ name ) ) ; } unlink ( $ this - > get Path ( $ name ) ) ; } 
public function count Commits ( ) { if ( null ! = = $ this - > revisions & & count ( $ this - > revisions ) ) { $ output = $ this - > repository - > run ( 'rev -list ' , array _merge ( array ( ' - -count ' ) , $ this - > revisions - > get As Text Array ( ) , array ( ' - - ' ) , $ this - > paths ) ) ; } else { $ output = $ this - > repository - > run ( 'rev -list ' , array _merge ( array ( ' - -count ' , ' - -all ' , ' - - ' ) , $ this - > paths ) ) ; } return ( int ) $ output ; } 
private function init Dir ( $ git Dir , $ working Dir = null ) { $ real Git Dir = realpath ( $ git Dir ) ; if ( false = = = $ real Git Dir ) { throw new Invalid Argument Exception ( sprintf ( 'Directory " %s " does not exist or is not a directory ' , $ git Dir ) ) ; } elseif ( ! is _dir ( $ real Git Dir ) ) { throw new Invalid Argument Exception ( sprintf ( 'Directory " %s " does not exist or is not a directory ' , $ real Git Dir ) ) ; } elseif ( null = = = $ working Dir & & is _dir ( $ real Git Dir . ' / .git ' ) ) { $ working Dir = $ real Git Dir ; $ real Git Dir = $ real Git Dir . ' / .git ' ; } $ this - > git Dir = $ real Git Dir ; $ this - > working Dir = $ working Dir ; } 
public function get Head ( ) { $ file = $ this - > git Dir . ' /HEAD ' ; if ( ! file _exists ( $ file ) ) { $ message = sprintf ( 'Unable to find HEAD file ( " %s " ) ' , $ file ) ; if ( null ! = = $ this - > logger ) { $ this - > logger - > error ( $ message ) ; } if ( true = = = $ this - > debug ) { throw new Runtime Exception ( $ message ) ; } } $ content = trim ( file _get _contents ( $ file ) ) ; if ( null ! = = $ this - > logger ) { $ this - > logger - > debug ( 'HEAD file read : ' . $ content ) ; } if ( preg _match ( ' / ^ref : ( . + ) $ / ' , $ content , $ vars ) ) { return $ this - > get References ( ) - > get ( $ vars [ 1 ] ) ; } elseif ( preg _match ( ' / ^ [ 0 - 9a -f ] { 4 0 } $ / ' , $ content ) ) { return $ this - > get Commit ( $ content ) ; } $ message = sprintf ( 'Unexpected HEAD file content (file : %s ) . Content of file : %s ' , $ file , $ content ) ; if ( null ! = = $ this - > logger ) { $ this - > logger - > error ( $ message ) ; } if ( true = = = $ this - > debug ) { throw new Runtime Exception ( $ message ) ; } } 
public function get References ( ) { if ( null = = = $ this - > reference Bag ) { $ this - > reference Bag = new Reference Bag ( $ this ) ; } return $ this - > reference Bag ; } 
public function get Commit ( $ hash ) { if ( ! isset ( $ this - > objects [ $ hash ] ) ) { $ this - > objects [ $ hash ] = new Commit ( $ this , $ hash ) ; } return $ this - > objects [ $ hash ] ; } 
public function get Tree ( $ hash ) { if ( ! isset ( $ this - > objects [ $ hash ] ) ) { $ this - > objects [ $ hash ] = new Tree ( $ this , $ hash ) ; } return $ this - > objects [ $ hash ] ; } 
public function get Blob ( $ hash ) { if ( ! isset ( $ this - > objects [ $ hash ] ) ) { $ this - > objects [ $ hash ] = new Blob ( $ this , $ hash ) ; } return $ this - > objects [ $ hash ] ; } 
public function get Log ( $ revisions = null , $ paths = null , $ offset = null , $ limit = null ) { return new Log ( $ this , $ revisions , $ paths , $ offset , $ limit ) ; } 
public function get Size ( ) { $ commandline Arguments = array ( 'du ' , ' -skc ' , $ this - > git Dir ) ; $ commandline = $ this - > normalize Commandline Arguments ( $ commandline Arguments ) ; $ process = new Process ( $ commandline ) ; $ process - > run ( ) ; if ( ! preg _match ( ' / ( \d + ) \s +total $ / ' , trim ( $ process - > get Output ( ) ) , $ vars ) ) { $ message = sprintf ( "Unable to parse process output \ncommand : %s \noutput : %s " , $ process - > get Command Line ( ) , $ process - > get Output ( ) ) ; if ( null ! = = $ this - > logger ) { $ this - > logger - > error ( $ message ) ; } if ( true = = = $ this - > debug ) { throw new Runtime Exception ( 'unable to parse repository size output ' ) ; } return ; } return $ vars [ 1 ] ; } 
public function shell ( $ command , array $ env = array ( ) ) { $ argument = sprintf ( ' %s \ ' %s \ ' ' , $ command , $ this - > git Dir ) ; $ prefix = ' ' ; foreach ( $ env as $ name = > $ value ) { $ prefix . = sprintf ( 'export %s = %s ; ' , escapeshellarg ( $ name ) , escapeshellarg ( $ value ) ) ; } proc _open ( $ prefix . 'git shell -c ' . escapeshellarg ( $ argument ) , array ( STDIN , STDOUT , STDERR ) , $ pipes ) ; } 
public function get Description ( ) { $ file = $ this - > git Dir . ' /description ' ; $ exists = is _file ( $ file ) ; if ( null ! = = $ this - > logger & & true = = = $ this - > debug ) { if ( false = = = $ exists ) { $ this - > logger - > debug ( sprintf ( 'no description file in repository ( " %s " ) ' , $ file ) ) ; } else { $ this - > logger - > debug ( sprintf ( 'reading description file in repository ( " %s " ) ' , $ file ) ) ; } } if ( false = = = $ exists ) { return static : : DEFAULT _DESCRIPTION ; } return file _get _contents ( $ this - > git Dir . ' /description ' ) ; } 
public function set Description ( $ description ) { $ file = $ this - > git Dir . ' /description ' ; if ( null ! = = $ this - > logger & & true = = = $ this - > debug ) { $ this - > logger - > debug ( sprintf ( 'change description file content to " %s " (file : %s ) ' , $ description , $ file ) ) ; } file _put _contents ( $ file , $ description ) ; return $ this ; } 
public function run ( $ command , $ args = array ( ) ) { $ process = $ this - > get Process ( $ command , $ args ) ; if ( $ this - > logger ) { $ this - > logger - > info ( sprintf ( 'run command : %s " %s " ' , $ command , implode ( ' ' , $ args ) ) ) ; $ before = microtime ( true ) ; } $ process - > run ( ) ; $ output = $ process - > get Output ( ) ; if ( $ this - > logger & & $ this - > debug ) { $ duration = microtime ( true ) - $ before ; $ this - > logger - > debug ( sprintf ( 'last command ( %s ) duration : %sms ' , $ command , sprintf ( ' % . 2f ' , $ duration * 1 0 0 0 ) ) ) ; $ this - > logger - > debug ( sprintf ( 'last command ( %s ) return code : %s ' , $ command , $ process - > get Exit Code ( ) ) ) ; $ this - > logger - > debug ( sprintf ( 'last command ( %s ) output : %s ' , $ command , $ output ) ) ; } if ( ! $ process - > is Successful ( ) ) { $ error = sprintf ( "error while running %s \n output : \ " %s \ " " , $ command , $ process - > get Error Output ( ) ) ; if ( $ this - > logger ) { $ this - > logger - > error ( $ error ) ; } if ( $ this - > debug ) { throw new Process Exception ( $ process ) ; } return ; } return $ output ; } 
public function clone To ( $ path , $ bare = true , array $ options = array ( ) ) { return Admin : : clone To ( $ path , $ this - > git Dir , $ bare , $ options ) ; } 
private function get Process ( $ command , $ args = array ( ) ) { $ base = array ( $ this - > command , ' - -git -dir ' , $ this - > git Dir ) ; if ( $ this - > working Dir ) { $ base = array _merge ( $ base , array ( ' - -work -tree ' , $ this - > working Dir ) ) ; } $ base [ ] = $ command ; $ commandline Arguments = array _merge ( $ base , $ args ) ; $ commandline = $ this - > normalize Commandline Arguments ( $ commandline Arguments ) ; $ process = new Process ( $ commandline ) ; $ process - > set Env ( $ this - > environment Variables ) ; $ process - > set Timeout ( $ this - > process Timeout ) ; $ process - > set Idle Timeout ( $ this - > process Timeout ) ; return $ process ; } 
public function get Parents ( ) { $ result = array ( ) ; foreach ( $ this - > get Data ( 'parent Hashes ' ) as $ parent Hash ) { $ result [ ] = $ this - > repository - > get Commit ( $ parent Hash ) ; } return $ result ; } 
public function get Short Message ( $ length = 5 0 , $ preserve = false , $ separator = ' . . . ' ) { $ message = $ this - > get Data ( 'subject Message ' ) ; if ( String Helper : : strlen ( $ message ) > $ length ) { if ( $ preserve & & false ! = = ( $ breakpoint = String Helper : : strpos ( $ message , ' ' , $ length ) ) ) { $ length = $ breakpoint ; } return rtrim ( String Helper : : substr ( $ message , 0 , $ length ) ) . $ separator ; } return $ message ; } 
public function get Including Branches ( $ local = true , $ remote = true ) { $ arguments = array ( ' - -contains ' , $ this - > revision ) ; if ( $ local & & $ remote ) { $ arguments [ ] = ' -a ' ; } elseif ( ! $ local & & $ remote ) { $ arguments [ ] = ' -r ' ; } elseif ( ! $ local & & ! $ remote ) { throw new Invalid Argument Exception ( 'You should a least set one argument to true ' ) ; } try { $ result = $ this - > repository - > run ( 'branch ' , $ arguments ) ; } catch ( Process Exception $ e ) { return array ( ) ; } if ( ! $ result ) { return array ( ) ; } $ branches Name = explode ( " \n " , trim ( str _replace ( ' * ' , ' ' , $ result ) ) ) ; $ branches Name = array _filter ( $ branches Name , function ( $ v ) { return false = = = String Helper : : strpos ( $ v , ' - > ' ) ; } ) ; $ branches Name = array _map ( 'trim ' , $ branches Name ) ; $ references = $ this - > repository - > get References ( ) ; $ branches = array ( ) ; foreach ( $ branches Name as $ branch Name ) { if ( false = = = $ local ) { $ branches [ ] = $ references - > get Remote Branch ( $ branch Name ) ; } elseif ( 0 = = = String Helper : : strrpos ( $ branch Name , 'remotes / ' ) ) { $ branches [ ] = $ references - > get Remote Branch ( str _replace ( 'remotes / ' , ' ' , $ branch Name ) ) ; } else { $ branches [ ] = $ references - > get Branch ( $ branch Name ) ; } } return $ branches ; } 
public static function init ( $ path , $ bare = true , array $ options = array ( ) ) { $ process = static : : get Process ( 'init ' , array _merge ( array ( ' -q ' ) , $ bare ? array ( ' - -bare ' ) : array ( ) , array ( $ path ) ) , $ options ) ; $ process - > run ( ) ; if ( ! $ process - > is Success Ful ( ) ) { throw new Runtime Exception ( sprintf ( "Error on repository initialization , command wasn 't successful ( %s ) . Error output : \n %s " , $ process - > get Command Line ( ) , $ process - > get Error Output ( ) ) ) ; } return new Repository ( $ path , $ options ) ; } 
public static function is Valid Repository ( $ url , array $ options = array ( ) ) { $ process = static : : get Process ( 'ls -remote ' , array ( $ url ) , $ options ) ; $ process - > run ( ) ; return $ process - > is Success Ful ( ) ; } 
public static function clone To ( $ path , $ url , $ bare = true , array $ options = array ( ) ) { $ args = $ bare ? array ( ' - -bare ' ) : array ( ) ; return static : : clone Repository ( $ path , $ url , $ args , $ options ) ; } 
public static function clone Branch To ( $ path , $ url , $ branch , $ bare = true , $ options = array ( ) ) { $ args = array ( ' - -branch ' , $ branch ) ; if ( $ bare ) { $ args [ ] = ' - -bare ' ; } return static : : clone Repository ( $ path , $ url , $ args , $ options ) ; } 
public static function clone Repository ( $ path , $ url , array $ args = array ( ) , array $ options = array ( ) ) { $ process = static : : get Process ( 'clone ' , array _merge ( array ( ' -q ' ) , $ args , array ( $ url , $ path ) ) , $ options ) ; $ process - > run ( ) ; if ( ! $ process - > is Success Ful ( ) ) { throw new Runtime Exception ( sprintf ( 'Error while initializing repository : %s ' , $ process - > get Error Output ( ) ) ) ; } return new Repository ( $ path , $ options ) ; } 
private static function get Process ( $ command , array $ args = array ( ) , array $ options = array ( ) ) { $ is _windows = defined ( 'PHP _WINDOWS _VERSION _BUILD ' ) ; $ options = array _merge ( array ( 'environment _variables ' = > $ is _windows ? array ( 'PATH ' = > getenv ( 'PATH ' ) ) : array ( ) , 'command ' = > 'git ' , 'process _timeout ' = > 3 6 0 0 , ) , $ options ) ; $ commandline = array _merge ( array ( $ options [ 'command ' ] , $ command ) , $ args ) ; 
public function get Grouped Lines ( ) { $ result = array ( ) ; $ commit = null ; $ current = array ( ) ; foreach ( $ this - > get Lines ( ) as $ line Number = > $ line ) { if ( $ commit ! = = $ line - > get Commit ( ) ) { if ( count ( $ current ) ) { $ result [ ] = array ( $ commit , $ current ) ; } $ commit = $ line - > get Commit ( ) ; $ current = array ( ) ; } $ current [ $ line Number ] = $ line ; } if ( count ( $ current ) ) { $ result [ ] = array ( $ commit , $ current ) ; } return $ result ; } 
public function get Lines ( ) { if ( null ! = = $ this - > lines ) { return $ this - > lines ; } $ args = array ( ' -p ' ) ; if ( null ! = = $ this - > line Range ) { $ args [ ] = ' -L ' ; $ args [ ] = $ this - > line Range ; } $ args [ ] = $ this - > revision - > get Revision ( ) ; $ args [ ] = ' - - ' ; $ args [ ] = $ this - > file ; $ parser = new Blame Parser ( $ this - > repository ) ; $ parser - > parse ( $ this - > repository - > run ( 'blame ' , $ args ) ) ; $ this - > lines = $ parser - > lines ; return $ this - > lines ; } 
public function get ( $ fullname ) { $ this - > initialize ( ) ; if ( ! isset ( $ this - > references [ $ fullname ] ) ) { throw new Reference Not Found Exception ( $ fullname ) ; } return $ this - > references [ $ fullname ] ; } 
public function get Branches ( ) { $ this - > initialize ( ) ; $ result = array ( ) ; foreach ( $ this - > references as $ reference ) { if ( $ reference instanceof Reference \ Branch ) { $ result [ ] = $ reference ; } } return $ result ; } 
public function get Local Branches ( ) { $ result = array ( ) ; foreach ( $ this - > get Branches ( ) as $ branch ) { if ( $ branch - > is Local ( ) ) { $ result [ ] = $ branch ; } } return $ result ; } 
public function get Remote Branches ( ) { $ result = array ( ) ; foreach ( $ this - > get Branches ( ) as $ branch ) { if ( $ branch - > is Remote ( ) ) { $ result [ ] = $ branch ; } } return $ result ; } 
public function get Content ( ) { if ( null = = = $ this - > content ) { $ this - > content = $ this - > repository - > run ( 'cat -file ' , array ( ' -p ' , $ this - > hash ) ) ; } return $ this - > content ; } 
public function get Mimetype ( ) { if ( null = = = $ this - > mimetype ) { $ finfo = new \ finfo ( FILEINFO _MIME ) ; $ this - > mimetype = $ finfo - > buffer ( $ this - > get Content ( ) ) ; } return $ this - > mimetype ; } 
public function to Array ( ) { return array ( 'raw Diff ' = > $ this - > raw Diff , 'files ' = > array _map ( function ( File $ file ) { return $ file - > to Array ( ) ; } , $ this - > files ) , ) ; } 
public function parse ( $ text ) { $ text = str _replace ( array ( " \r \n " , " \r " ) , " \n " , $ text ) ; foreach ( $ this - > quote Headers Regex as $ regex ) { if ( preg _match ( $ regex , $ text , $ matches ) ) { $ text = str _replace ( $ matches [ 1 ] , str _replace ( " \n " , ' ' , $ matches [ 1 ] ) , $ text ) ; } } $ fragment = null ; $ text _array = explode ( " \n " , $ text ) ; while ( ( $ line = array _pop ( $ text _array ) ) ! = = NULL ) { $ line = ltrim ( $ line , " \n " ) ; if ( ! $ this - > is Signature ( $ line ) ) { $ line = rtrim ( $ line ) ; } if ( $ fragment ) { $ first = reset ( $ fragment - > lines ) ; if ( $ this - > is Signature ( $ first ) ) { $ fragment - > is Signature = true ; $ this - > add Fragment ( $ fragment ) ; $ fragment = null ; } elseif ( empty ( $ line ) & & $ this - > is Quote Header ( $ first ) ) { $ fragment - > is Quoted = true ; $ this - > add Fragment ( $ fragment ) ; $ fragment = null ; } } $ is Quoted = $ this - > is Quote ( $ line ) ; if ( null = = = $ fragment | | ! $ this - > is Fragment Line ( $ fragment , $ line , $ is Quoted ) ) { if ( $ fragment ) { $ this - > add Fragment ( $ fragment ) ; } $ fragment = new Fragment DTO ( ) ; $ fragment - > is Quoted = $ is Quoted ; } array _unshift ( $ fragment - > lines , $ line ) ; } if ( $ fragment ) { $ this - > add Fragment ( $ fragment ) ; } $ email = $ this - > create Email ( $ this - > fragments ) ; $ this - > fragments = array ( ) ; return $ email ; } 
protected function create Email ( array $ fragment DTOs ) { $ fragments = array ( ) ; foreach ( $ fragment DTOs as $ fragment ) { $ fragments [ ] = new Fragment ( preg _replace ( " / ^ \n / " , ' ' , implode ( " \n " , $ fragment - > lines ) ) , $ fragment - > is Hidden , $ fragment - > is Signature , $ fragment - > is Quoted ) ; } return new Email ( $ fragments ) ; } 
public function order By ( $ column , $ direction = Order By : : ASC , $ table = null ) { return $ this - > select - > order By ( $ column , $ direction , $ table ) ; } 
public function set Function As Column ( $ func Name , array $ arguments , $ alias ) { $ this - > column Funcs [ $ alias ] = [ 'func ' = > $ func Name , 'args ' = > $ arguments ] ; return $ this ; } 
public function count ( $ column Name = ' * ' , $ alias = ' ' ) { $ table = $ this - > select - > get Table ( ) ; $ count = 'COUNT ( ' ; $ count . = ( $ column Name ! = = ' * ' ) ? " $table . { $column Name } " : ' * ' ; $ count . = ' ) ' ; if ( isset ( $ alias ) & & \ strlen ( $ alias ) > 0 ) { $ count . = ' AS " ' . $ alias . ' " ' ; } $ this - > columns = array ( $ count ) ; $ this - > is Count = true ; return $ this ; } 
public function get Columns ( ) { if ( \ is _null ( $ this - > select - > get Table ( ) ) ) { throw new Query Exception ( 'No table specified for the Select instance ' ) ; } return Syntax Factory : : create Columns ( $ this - > columns , $ this - > select - > get Table ( ) ) ; } 
public function write ( Minus $ minus ) { $ first = $ this - > writer - > write ( $ minus - > get First ( ) ) ; $ second = $ this - > writer - > write ( $ minus - > get Second ( ) ) ; return $ first . " \n " . Minus : : MINUS . " \n " . $ second ; } 
public function select To Column ( $ alias , Select $ select ) { $ select As Column = $ this - > write ( $ select ) ; if ( ! empty ( $ select As Column ) ) { $ select As Column = ' ( ' . $ select As Column . ' ) ' ; } $ column = array ( $ alias = > $ select As Column ) ; return Syntax Factory : : create Column ( $ column , null ) ; } 
public function write ( Select $ select ) { if ( $ select - > is Join Select ( ) ) { return $ this - > writer - > write Join ( $ select ) ; } return $ this - > write Select Query ( $ select ) ; } 
protected function write Select Query ( Select $ select ) { $ parts = [ 'SELECT ' ] ; if ( $ select - > is Distinct ( ) ) { $ parts [ ] = 'DISTINCT ' ; } $ this - > write Select Columns ( $ select , $ parts ) ; $ this - > write Select From ( $ select , $ parts ) ; $ this - > write Select Joins ( $ select , $ parts ) ; $ this - > write Select Where ( $ select , $ parts ) ; $ this - > write Select Group By ( $ select , $ parts ) ; $ this - > write Select Having ( $ select , $ parts ) ; $ this - > write Select Order By ( $ select , $ parts ) ; $ this - > write Select Limit ( $ select , $ parts ) ; return Abstract Base Writer : : write Query Comment ( $ select ) . implode ( ' ' , \ array _filter ( $ parts ) ) ; } 
public function write Select Columns ( Select $ select , array & $ parts ) { if ( $ select - > is Count ( ) = = = false ) { $ columns = $ this - > write Column Alias ( $ select - > get All Columns ( ) , $ this - > column Writer - > write Selects As Columns ( $ select ) , $ this - > column Writer - > write Value As Columns ( $ select ) , $ this - > column Writer - > write Func As Columns ( $ select ) ) ; $ parts = \ array _merge ( $ parts , [ implode ( ' , ' , $ columns ) ] ) ; return $ this ; } $ columns = $ select - > get Columns ( ) ; $ column = \ array _pop ( $ columns ) ; $ column List = $ column - > get Name ( ) ; $ parts = \ array _merge ( $ parts , [ $ column List ] ) ; return $ this ; } 
protected function write Column Alias ( $ table Columns , $ select As Columns , $ value As Columns , $ func As Columns ) { $ columns = \ array _merge ( $ table Columns , $ select As Columns , $ value As Columns , $ func As Columns ) ; \ array _walk ( $ columns , function ( & $ column ) { $ column = $ this - > column Writer - > write Column With Alias ( $ column ) ; } ) ; return $ columns ; } 
public function write Select From ( Select $ select , array & $ parts ) { $ parts = \ array _merge ( $ parts , [ 'FROM ' . $ this - > writer - > write Table With Alias ( $ select - > get Table ( ) ) ] ) ; return $ this ; } 
public function write Select Joins ( Select $ select , array & $ parts ) { $ parts = \ array _merge ( $ parts , [ $ this - > write Select Aggrupation ( $ select , $ this - > writer , 'get All Joins ' , 'write Join ' , ' ' ) ] ) ; return $ this ; } 
protected function write Select Aggrupation ( Select $ select , $ writer , $ get Method , $ write Method , $ glue , $ prepend = ' ' ) { $ str = ' ' ; $ joins = $ select - > $ get Method ( ) ; if ( ! empty ( $ joins ) ) { \ array _walk ( $ joins , function ( & $ join ) use ( $ writer , $ write Method ) { $ join = $ writer - > $ write Method ( $ join ) ; } ) ; $ str = $ prepend . implode ( $ glue , $ joins ) ; } return $ str ; } 
public function write Select Where ( Select $ select , array & $ parts ) { $ str = ' ' ; $ wheres = $ this - > write Select Wheres ( $ select - > get All Wheres ( ) ) ; $ wheres = \ array _filter ( $ wheres ) ; if ( \ count ( $ wheres ) > 0 ) { $ str = 'WHERE ' ; $ separator = ' ' . $ this - > writer - > write Conjunction ( $ select - > get Where Operator ( ) ) . ' ' ; $ str . = \ implode ( $ separator , $ wheres ) ; } $ parts = \ array _merge ( $ parts , [ $ str ] ) ; return $ this ; } 
protected function write Select Wheres ( array $ wheres ) { $ where Writer = Writer Factory : : create Where Writer ( $ this - > writer , $ this - > placeholder Writer ) ; \ array _walk ( $ wheres , function ( & $ where ) use ( & $ where Writer ) { $ where = $ where Writer - > write Where ( $ where ) ; } ) ; return $ wheres ; } 
public function write Select Group By ( Select $ select , array & $ parts ) { $ group By = $ this - > write Select Aggrupation ( $ select , $ this - > column Writer , 'get Group By ' , 'write Column ' , ' , ' , 'GROUP BY ' ) ; $ parts = \ array _merge ( $ parts , [ $ group By ] ) ; return $ this ; } 
public function write Select Having ( Select $ select , array & $ parts ) { $ str = ' ' ; $ having Array = $ select - > get All Havings ( ) ; if ( \ count ( $ having Array ) > 0 ) { $ placeholder = $ this - > placeholder Writer ; $ writer = $ this - > writer ; $ str = 'HAVING ' ; $ separator = ' ' . $ select - > get Having Operator ( ) . ' ' ; $ having Array = $ this - > get Having Conditions ( $ having Array , $ select , $ writer , $ placeholder ) ; $ str . = \ implode ( $ separator , $ having Array ) ; } $ parts = \ array _merge ( $ parts , [ $ str ] ) ; return $ this ; } 
protected function get Having Conditions ( array & $ having Array , Select $ select , Generic Builder $ writer , Placeholder Writer $ placeholder ) { \ array _walk ( $ having Array , function ( & $ having ) use ( $ select , $ writer , $ placeholder ) { $ where Writer = Writer Factory : : create Where Writer ( $ writer , $ placeholder ) ; $ clauses = $ where Writer - > write Where Clauses ( $ having ) ; $ having = \ implode ( $ this - > writer - > write Conjunction ( $ select - > get Having Operator ( ) ) , $ clauses ) ; } ) ; return $ having Array ; } 
protected function write Select Order By ( Select $ select , array & $ parts ) { $ str = ' ' ; if ( \ count ( $ select - > get All Order By ( ) ) ) { $ order By Array = $ select - > get All Order By ( ) ; \ array _walk ( $ order By Array , function ( & $ order By ) { $ order By = $ this - > write Order By ( $ order By ) ; } ) ; $ str = 'ORDER BY ' ; $ str . = \ implode ( ' , ' , $ order By Array ) ; } $ parts = \ array _merge ( $ parts , [ $ str ] ) ; return $ this ; } 
public function write Order By ( Order By $ order By ) { $ column = $ this - > column Writer - > write Column ( $ order By - > get Column ( ) ) ; return $ column . ' ' . $ order By - > get Direction ( ) ; } 
protected function write Select Limit ( Select $ select , array & $ parts ) { $ mask = $ this - > get Starting Limit ( $ select ) . $ this - > get Limit Count ( $ select ) ; $ limit = ' ' ; if ( $ mask ! = = ' 0 0 ' ) { $ start = $ this - > placeholder Writer - > add ( $ select - > get Limit Start ( ) ) ; $ count = $ this - > placeholder Writer - > add ( $ select - > get Limit Count ( ) ) ; $ limit = "LIMIT { $start } , { $count } " ; } $ parts = \ array _merge ( $ parts , [ $ limit ] ) ; return $ this ; } 
public function write ( Insert $ insert ) { $ columns = $ insert - > get Columns ( ) ; if ( empty ( $ columns ) ) { throw new Query Exception ( 'No columns were defined for the current schema . ' ) ; } $ columns = $ this - > write Query Columns ( $ columns ) ; $ values = $ this - > write Query Values ( $ insert - > get Values ( ) ) ; $ table = $ this - > writer - > write Table ( $ insert - > get Table ( ) ) ; $ comment = Abstract Base Writer : : write Query Comment ( $ insert ) ; return $ comment . "INSERT INTO { $table } ( $columns ) VALUES ( $values ) " ; } 
protected function write Comma Separated Values ( $ collection , $ writer , $ method ) { \ array _walk ( $ collection , function ( & $ data ) use ( $ writer , $ method ) { $ data = $ writer - > $ method ( $ data ) ; } ) ; return \ implode ( ' , ' , $ collection ) ; } 
public function write Column Name ( Column $ column ) { if ( $ column - > is All ( ) ) { return ' * ' ; } if ( false ! = = strpos ( $ column - > get Name ( ) , ' ( ' ) ) { return parent : : write Column Name ( $ column ) ; } return $ this - > wrapper ( parent : : write Column Name ( $ column ) ) ; } 
public function conjunction ( $ operator ) { if ( false = = = \ in _array ( $ operator , [ self : : CONJUNCTION _AND , self : : CONJUNCTION _OR , self : : CONJUNCTION _OR _NOT , self : : CONJUNCTION _AND _NOT ] ) ) { throw new Query Exception ( "Invalid conjunction specified , must be one of AND or OR , but ' " . $ operator . " ' was found . " ) ; } $ this - > conjunction = $ operator ; return $ this ; } 
public function sub Where ( $ operator = 'OR ' ) { $ filter = Query Factory : : create Where ( $ this - > query ) ; $ filter - > conjunction ( $ operator ) ; $ filter - > set Table ( $ this - > get Table ( ) ) ; $ this - > sub Wheres [ ] = $ filter ; return $ filter ; } 
protected function compare ( $ column , $ value , $ operator ) { $ column = $ this - > prepare Column ( $ column ) ; $ this - > comparisons [ ] = [ 'subject ' = > $ column , 'conjunction ' = > $ operator , 'target ' = > $ value , ] ; return $ this ; } 
protected function prepare Column ( $ column ) { 
protected function generic Match ( array & $ columns , array & $ values , $ mode ) { $ this - > match [ ] = [ 'columns ' = > $ columns , 'values ' = > $ values , 'mode ' = > $ mode , ] ; return $ this ; } 
public function between ( $ column , $ a , $ b ) { $ column = $ this - > prepare Column ( $ column ) ; $ this - > betweens [ ] = [ 'subject ' = > $ column , 'a ' = > $ a , 'b ' = > $ b ] ; return $ this ; } 
public function not Between ( $ column , $ a , $ b ) { $ column = $ this - > prepare Column ( $ column ) ; $ this - > not Betweens [ ] = [ 'subject ' = > $ column , 'a ' = > $ a , 'b ' = > $ b ] ; return $ this ; } 
public function is Null ( $ column ) { $ column = $ this - > prepare Column ( $ column ) ; $ this - > is Null [ ] = [ 'subject ' = > $ column ] ; return $ this ; } 
public function is Not Null ( $ column ) { $ column = $ this - > prepare Column ( $ column ) ; $ this - > is Not Null [ ] = [ 'subject ' = > $ column ] ; return $ this ; } 
public function add Bit Clause ( $ column , $ value ) { $ column = $ this - > prepare Column ( $ column ) ; $ this - > booleans [ ] = [ 'subject ' = > $ column , 'value ' = > $ value ] ; return $ this ; } 
public function write ( Update $ update ) { $ values = $ update - > get Values ( ) ; if ( empty ( $ values ) ) { throw new Query Exception ( 'No values to update in Update query . ' ) ; } $ parts = array ( 'UPDATE ' . $ this - > writer - > write Table ( $ update - > get Table ( ) ) . ' SET ' , $ this - > write Update Values ( $ update ) , ) ; Abstract Base Writer : : write Where Condition ( $ update , $ this - > writer , $ this - > placeholder Writer , $ parts ) ; Abstract Base Writer : : write Limit Condition ( $ update , $ this - > placeholder Writer , $ parts ) ; $ comment = Abstract Base Writer : : write Query Comment ( $ update ) ; return $ comment . implode ( ' ' , $ parts ) ; } 
protected function write Update Values ( Update $ update ) { $ assigns = [ ] ; foreach ( $ update - > get Values ( ) as $ column = > $ value ) { $ new Column = array ( $ column ) ; $ column = $ this - > column Writer - > write Column ( Syntax Factory : : create Column ( $ new Column , $ update - > get Table ( ) ) ) ; $ value = $ this - > writer - > write Placeholder Value ( $ value ) ; $ assigns [ ] = " $column = $value " ; } return \ implode ( ' , ' , $ assigns ) ; } 
public function write Where ( Where $ where ) { $ clauses = $ this - > write Where Clauses ( $ where ) ; $ clauses = \ array _filter ( $ clauses ) ; if ( empty ( $ clauses ) ) { return ' ' ; } return \ implode ( $ this - > writer - > write Conjunction ( $ where - > get Conjunction ( ) ) , $ clauses ) ; } 
public function write Where Clauses ( Where $ where ) { $ where Array = [ ] ; $ this - > write Where Matches ( $ where , $ where Array ) ; $ this - > write Where Ins ( $ where , $ where Array ) ; $ this - > write Where Not Ins ( $ where , $ where Array ) ; $ this - > write Where Betweens ( $ where , $ where Array ) ; $ this - > write Where Not Betweens ( $ where , $ where Array ) ; $ this - > write Where Comparisons ( $ where , $ where Array ) ; $ this - > write Where Is Nulls ( $ where , $ where Array ) ; $ this - > write Where Is Not Nulls ( $ where , $ where Array ) ; $ this - > write Where Booleans ( $ where , $ where Array ) ; $ this - > write Exists ( $ where , $ where Array ) ; $ this - > write Not Exists ( $ where , $ where Array ) ; $ this - > write Sub Wheres ( $ where , $ where Array ) ; return $ where Array ; } 
protected function write Where Matches ( Where $ where , array & $ where Array ) { $ matches = [ ] ; foreach ( $ where - > get Matches ( ) as $ values ) { $ columns = Syntax Factory : : create Columns ( $ values [ 'columns ' ] , $ where - > get Table ( ) ) ; $ column Names = $ this - > get Column Names ( $ columns ) ; $ column Values = array ( \ implode ( ' ' , $ values [ 'values ' ] ) ) ; $ column Values = \ implode ( ' , ' , $ this - > writer - > write Values ( $ column Values ) ) ; $ matches [ ] = \ str _replace ( [ ' { {column Names } } ' , ' { {column Values } } ' ] , [ $ column Names , $ column Values ] , $ this - > match Mode [ $ values [ 'mode ' ] ] ) ; } $ where Array = \ array _merge ( $ where Array , $ matches ) ; } 
protected function get Column Names ( $ columns ) { $ column Names = [ ] ; foreach ( $ columns as & $ column ) { $ column Names [ ] = $ this - > column Writer - > write Column ( $ column ) ; } return \ implode ( ' , ' , $ column Names ) ; } 
protected function write Where Ins ( Where $ where , array & $ where Array ) { $ where Array = \ array _merge ( $ where Array , $ this - > write Where In ( $ where , 'get Ins ' , 'IN ' ) ) ; } 
protected function write Where In ( Where $ where , $ method , $ operation ) { $ collection = [ ] ; foreach ( $ where - > $ method ( ) as $ column = > $ values ) { $ new Column = array ( $ column ) ; $ column = Syntax Factory : : create Column ( $ new Column , $ where - > get Table ( ) ) ; $ column = $ this - > column Writer - > write Column ( $ column ) ; $ values = $ this - > writer - > write Values ( $ values ) ; $ values = \ implode ( ' , ' , $ values ) ; $ collection [ ] = " ( { $column } $operation ( { $values } ) ) " ; } return $ collection ; } 
protected function write Where Not Ins ( Where $ where , array & $ where Array ) { $ where Array = \ array _merge ( $ where Array , $ this - > write Where In ( $ where , 'get Not Ins ' , 'NOT IN ' ) ) ; } 
protected function write Where Betweens ( Where $ where , array & $ where Array ) { $ between = $ where - > get Betweens ( ) ; \ array _walk ( $ between , function ( & $ between ) { $ between = ' ( ' . $ this - > column Writer - > write Column ( $ between [ 'subject ' ] ) . ' BETWEEN ' . $ this - > writer - > write Placeholder Value ( $ between [ 'a ' ] ) . ' AND ' . $ this - > writer - > write Placeholder Value ( $ between [ 'b ' ] ) . ' ) ' ; } ) ; $ where Array = \ array _merge ( $ where Array , $ between ) ; } 
protected function write Where Not Betweens ( Where $ where , array & $ where Array ) { $ between = $ where - > get Not Betweens ( ) ; \ array _walk ( $ between , function ( & $ between ) { $ between = ' ( ' . $ this - > column Writer - > write Column ( $ between [ 'subject ' ] ) . ' NOT BETWEEN ' . $ this - > writer - > write Placeholder Value ( $ between [ 'a ' ] ) . ' AND ' . $ this - > writer - > write Placeholder Value ( $ between [ 'b ' ] ) . ' ) ' ; } ) ; $ where Array = \ array _merge ( $ where Array , $ between ) ; } 
protected function write Where Comparisons ( Where $ where , array & $ where Array ) { $ comparisons = $ where - > get Comparisons ( ) ; \ array _walk ( $ comparisons , function ( & $ comparison ) { if ( ! is _array ( $ comparison ) ) { return ; } $ str = $ this - > write Where Partial Condition ( $ comparison [ 'subject ' ] ) ; $ str . = $ this - > writer - > write Conjunction ( $ comparison [ 'conjunction ' ] ) ; $ str . = $ this - > write Where Partial Condition ( $ comparison [ 'target ' ] ) ; $ comparison = " ( $str ) " ; } ) ; $ where Array = \ array _merge ( $ where Array , $ comparisons ) ; } 
protected function write Where Partial Condition ( & $ subject ) { if ( $ subject instanceof Column ) { $ str = $ this - > column Writer - > write Column ( $ subject ) ; } elseif ( $ subject instanceof Select ) { $ select Writer = Writer Factory : : create Select Writer ( $ this - > writer , $ this - > placeholder Writer ) ; $ str = ' ( ' . $ select Writer - > write ( $ subject ) . ' ) ' ; } else { $ str = $ this - > writer - > write Placeholder Value ( $ subject ) ; } return $ str ; } 
protected function write Where Is Nulls ( Where $ where , array & $ where Array ) { $ where Array = \ array _merge ( $ where Array , $ this - > write Where Is Nullable ( $ where , 'get Null ' , 'write Is Null ' ) ) ; } 
protected function write Where Is Nullable ( Where $ where , $ get Method , $ write Method ) { $ collection = $ where - > $ get Method ( ) ; \ array _walk ( $ collection , function ( & $ collection ) use ( $ write Method ) { $ collection = ' ( ' . $ this - > column Writer - > write Column ( $ collection [ 'subject ' ] ) . $ this - > writer - > $ write Method ( ) . ' ) ' ; } ) ; return $ collection ; } 
protected function write Where Is Not Nulls ( Where $ where , array & $ where Array ) { $ where Array = \ array _merge ( $ where Array , $ this - > write Where Is Nullable ( $ where , 'get Not Null ' , 'write Is Not Null ' ) ) ; } 
protected function write Where Booleans ( Where $ where , array & $ where Array ) { $ booleans = $ where - > get Booleans ( ) ; $ placeholder Writer = $ this - > placeholder Writer ; \ array _walk ( $ booleans , function ( & $ boolean ) use ( & $ placeholder Writer ) { $ column = $ this - > column Writer - > write Column ( $ boolean [ 'subject ' ] ) ; $ value = $ this - > placeholder Writer - > add ( $ boolean [ 'value ' ] ) ; $ boolean = ' (ISNULL ( ' . $ column . ' , 0 ) = ' . $ value . ' ) ' ; } ) ; $ where Array = \ array _merge ( $ where Array , $ booleans ) ; } 
protected function write Exists ( Where $ where , array & $ where Array ) { $ where Array = \ array _merge ( $ where Array , $ this - > write Existence ( $ where , 'get Exists ' , 'EXISTS ' ) ) ; } 
protected function write Existence ( Where $ where , $ method , $ operation ) { $ exists = [ ] ; foreach ( $ where - > $ method ( ) as $ select ) { $ exists [ ] = " $operation ( " . $ this - > writer - > write ( $ select , false ) . ' ) ' ; } return $ exists ; } 
protected function write Not Exists ( Where $ where , array & $ where Array ) { $ where Array = \ array _merge ( $ where Array , $ this - > write Existence ( $ where , 'get Not Exists ' , 'NOT EXISTS ' ) ) ; } 
protected function write Sub Wheres ( Where $ where , array & $ where Array ) { $ sub Wheres = $ where - > get Sub Wheres ( ) ; \ array _walk ( $ sub Wheres , function ( & $ sub Where ) { $ sub Where = " ( { $this - >write Where ( $sub Where ) } ) " ; } ) ; $ where Array = \ array _merge ( $ where Array , $ sub Wheres ) ; } 
public function left Join ( $ table , $ self Column = null , $ ref Column = null , $ columns = [ ] ) { return $ this - > join Query - > left Join ( $ table , $ self Column , $ ref Column , $ columns ) ; } 
public function join ( $ table , $ self Column = null , $ ref Column = null , $ columns = [ ] , $ join Type = null ) { return $ this - > join Query - > join ( $ table , $ self Column , $ ref Column , $ columns , $ join Type ) ; } 
public function add Join ( Select $ select , $ self Column , $ ref Column ) { return $ this - > join Query - > add Join ( $ select , $ self Column , $ ref Column ) ; } 
public function right Join ( $ table , $ self Column = null , $ ref Column = null , $ columns = [ ] ) { return $ this - > join Query - > right Join ( $ table , $ self Column , $ ref Column , $ columns ) ; } 
public function cross Join ( $ table , $ self Column = null , $ ref Column = null , $ columns = [ ] ) { return $ this - > join Query - > cross Join ( $ table , $ self Column , $ ref Column , $ columns ) ; } 
public function inner Join ( $ table , $ self Column = null , $ ref Column = null , $ columns = [ ] ) { return $ this - > join Query - > inner Join ( $ table , $ self Column , $ ref Column , $ columns ) ; } 
public function set Function As Column ( $ func Name , array $ arguments , $ alias ) { return $ this - > column Query - > set Function As Column ( $ func Name , $ arguments , $ alias ) ; } 
protected function get All Operation ( $ data , $ operation ) { $ collection = [ ] ; if ( ! is _null ( $ data ) ) { $ collection [ ] = $ data ; } foreach ( $ this - > join Query - > get Joins ( ) as $ join ) { $ collection = \ array _merge ( $ collection , $ join - > $ operation ( ) ) ; } return $ collection ; } 
public function limit ( $ start , $ count = 0 ) { $ this - > limit Start = $ start ; $ this - > limit Count = $ count ; return $ this ; } 
public function having ( $ having Operator = 'AND ' ) { if ( ! isset ( $ this - > having ) ) { $ this - > having = Query Factory : : create Where ( $ this ) ; } if ( ! in _array ( $ having Operator , array ( Where : : CONJUNCTION _AND , Where : : CONJUNCTION _OR ) ) ) { throw new Query Exception ( "Invalid conjunction specified , must be one of AND or OR , but ' " . $ having Operator . " ' was found . " ) ; } $ this - > having Operator = $ having Operator ; return $ this - > having ; } 
public function order By ( $ column , $ direction = Order By : : ASC , $ table = null ) { $ current = parent : : order By ( $ column , $ direction , $ table ) ; if ( $ this - > get Parent Query ( ) ! = null ) { $ this - > get Parent Query ( ) - > order By ( $ column , $ direction , \ is _null ( $ table ) ? $ this - > get Table ( ) : $ table ) ; } return $ current ; } 
public function write Selects As Columns ( Select $ select ) { $ select As Columns = $ select - > get Column Selects ( ) ; if ( ! empty ( $ select As Columns ) ) { $ select Writer = Writer Factory : : create Select Writer ( $ this - > writer , $ this - > placeholder Writer ) ; $ select As Columns = $ this - > select Column To Query ( $ select As Columns , $ select Writer ) ; } return $ select As Columns ; } 
protected function select Column To Query ( array & $ select As Columns , Select Writer $ select Writer ) { \ array _walk ( $ select As Columns , function ( & $ column ) use ( & $ select Writer ) { $ keys = \ array _keys ( $ column ) ; $ key = \ array _pop ( $ keys ) ; $ values = \ array _values ( $ column ) ; $ value = $ values [ 0 ] ; if ( \ is _numeric ( $ key ) ) { $ key = $ this - > writer - > write Table Name ( $ value - > get Table ( ) ) ; } $ column = $ select Writer - > select To Column ( $ key , $ value ) ; } ) ; return $ select As Columns ; } 
public function write Value As Columns ( Select $ select ) { $ value As Columns = $ select - > get Column Values ( ) ; $ new Columns = [ ] ; if ( ! empty ( $ value As Columns ) ) { foreach ( $ value As Columns as $ alias = > $ value ) { $ value = $ this - > writer - > write Placeholder Value ( $ value ) ; $ new Value Column = array ( $ alias = > $ value ) ; $ new Columns [ ] = Syntax Factory : : create Column ( $ new Value Column , null ) ; } } return $ new Columns ; } 
public function write Func As Columns ( Select $ select ) { $ func As Columns = $ select - > get Column Funcs ( ) ; $ new Columns = [ ] ; if ( ! empty ( $ func As Columns ) ) { foreach ( $ func As Columns as $ alias = > $ value ) { $ func Name = $ value [ 'func ' ] ; $ func Args = ( ! empty ( $ value [ 'args ' ] ) ) ? ' ( ' . implode ( ' , ' , $ value [ 'args ' ] ) . ' ) ' : ' ' ; $ new Func Column = array ( $ alias = > $ func Name . $ func Args ) ; $ new Columns [ ] = Syntax Factory : : create Column ( $ new Func Column , null ) ; } } return $ new Columns ; } 
public function write Column With Alias ( Column $ column ) { if ( ( $ alias = $ column - > get Alias ( ) ) & & ! $ column - > is All ( ) ) { return $ this - > write Column ( $ column ) . ' AS ' . $ this - > writer - > write Column Alias ( $ alias ) ; } return $ this - > write Column ( $ column ) ; } 
public function write Column ( Column $ column ) { $ alias = $ column - > get Table ( ) - > get Alias ( ) ; $ table = ( $ alias ) ? $ this - > writer - > write Table Alias ( $ alias ) : $ this - > writer - > write Table ( $ column - > get Table ( ) ) ; $ column String = ( empty ( $ table ) ) ? ' ' : " { $table } . " ; $ column String . = $ this - > writer - > write Column Name ( $ column ) ; return $ column String ; } 
public function write ( Delete $ delete ) { $ table = $ this - > writer - > write Table ( $ delete - > get Table ( ) ) ; $ parts = array ( "DELETE FROM { $table } " ) ; Abstract Base Writer : : write Where Condition ( $ delete , $ this - > writer , $ this - > placeholder Writer , $ parts ) ; Abstract Base Writer : : write Limit Condition ( $ delete , $ this - > placeholder Writer , $ parts ) ; $ comment = Abstract Base Writer : : write Query Comment ( $ delete ) ; return $ comment . implode ( ' ' , $ parts ) ; } 
public function select ( $ table = null , array $ columns = null ) { return $ this - > inject Builder ( Query Factory : : create Select ( $ table , $ columns ) ) ; } 
public function insert ( $ table = null , array $ values = null ) { return $ this - > inject Builder ( Query Factory : : create Insert ( $ table , $ values ) ) ; } 
public function update ( $ table = null , array $ values = null ) { return $ this - > inject Builder ( Query Factory : : create Update ( $ table , $ values ) ) ; } 
public function write Formatted ( Query Interface $ query ) { if ( null = = = $ this - > sql Formatter ) { $ this - > sql Formatter = ( new \ Reflection Class ( $ this - > sql Formatter Class ) ) - > new Instance ( ) ; } return $ this - > sql Formatter - > format ( $ this - > write ( $ query ) ) ; } 
public function write ( Query Interface $ query , $ reset Placeholders = true ) { if ( $ reset Placeholders ) { $ this - > placeholder Writer - > reset ( ) ; } $ query Part = $ query - > part Name ( ) ; if ( false = = = empty ( $ this - > query Writer Array [ $ query Part ] ) ) { $ this - > create Query Object ( $ query Part ) ; return $ this - > query Writer Instances [ $ query Part ] - > write ( $ query ) ; } throw new \ Runtime Exception ( 'Query builder part not defined . ' ) ; } 
public function write Join ( Select $ select ) { if ( null = = = $ this - > where Writer ) { $ this - > where Writer = Writer Factory : : create Where Writer ( $ this , $ this - > placeholder Writer ) ; } $ sql = ( $ select - > get Join Type ( ) ) ? " { $select - >get Join Type ( ) } " : ' ' ; $ sql . = 'JOIN ' ; $ sql . = $ this - > write Table With Alias ( $ select - > get Table ( ) ) ; $ sql . = ' ON ' ; $ sql . = $ this - > where Writer - > write Where ( $ select - > get Join Condition ( ) ) ; return $ sql ; } 
public function write Table With Alias ( Table $ table ) { $ alias = ( $ table - > get Alias ( ) ) ? " AS { $this - >write Table Alias ( $table - >get Alias ( ) ) } " : ' ' ; $ schema = ( $ table - > get Schema ( ) ) ? " { $table - >get Schema ( ) } . " : ' ' ; return $ schema . $ this - > write Table Name ( $ table ) . $ alias ; } 
public function write Table ( Table $ table ) { $ schema = ( $ table - > get Schema ( ) ) ? " { $table - >get Schema ( ) } . " : ' ' ; return $ schema . $ this - > write Table Name ( $ table ) ; } 
public function write Values ( array & $ values ) { \ array _walk ( $ values , function ( & $ value ) { $ value = $ this - > write Placeholder Value ( $ value ) ; } ) ; return $ values ; } 
public function write Column Name ( Column $ column ) { $ name = $ column - > get Name ( ) ; if ( $ name = = = Column : : ALL ) { return $ this - > write Column All ( ) ; } return $ name ; } 
public static function create Columns ( array & $ arguments , $ table = null ) { $ created Columns = [ ] ; foreach ( $ arguments as $ index = > $ column ) { if ( ! is _object ( $ column ) ) { $ new Column = array ( $ column ) ; $ column = self : : create Column ( $ new Column , $ table ) ; if ( ! is _numeric ( $ index ) ) { $ column - > set Alias ( $ index ) ; } $ created Columns [ ] = $ column ; } else if ( $ column instanceof Column ) { $ created Columns [ ] = $ column ; } } return \ array _filter ( $ created Columns ) ; } 
public static function create Column ( array & $ argument , $ table = null ) { $ column Name = \ array _values ( $ argument ) ; $ column Name = $ column Name [ 0 ] ; $ column Alias = \ array _keys ( $ argument ) ; $ column Alias = $ column Alias [ 0 ] ; if ( \ is _numeric ( $ column Alias ) | | \ strpos ( $ column Name , ' * ' ) ! = = false ) { $ column Alias = null ; } return new Column ( $ column Name , ( string ) $ table , $ column Alias ) ; } 
public static function create Table ( $ table ) { $ table Name = $ table ; if ( \ is _array ( $ table ) ) { $ table Name = \ current ( $ table ) ; $ table Alias = \ key ( $ table ) ; } $ new Table = new Table ( $ table Name ) ; if ( isset ( $ table Alias ) & & ! is _numeric ( $ table Alias ) ) { $ new Table - > set Alias ( $ table Alias ) ; } return $ new Table ; } 
public function set Values ( array $ values ) { $ this - > values = \ array _filter ( $ values , function ( $ value ) { if ( is _int ( $ value ) ) { return true ; } return $ value ; } ) ; return $ this ; } 
public function get Sql ( $ formatted = false ) { if ( $ formatted ) { return $ this - > get Builder ( ) - > write Formatted ( $ this ) ; } return $ this - > get Builder ( ) - > write ( $ this ) ; } 
public function where ( $ where Operator = 'AND ' ) { if ( ! isset ( $ this - > where ) ) { $ this - > where = $ this - > filter ( ) ; } $ this - > where - > conjunction ( $ where Operator ) ; return $ this - > where ; } 
public function order By ( $ column , $ direction = Order By : : ASC , $ table = null ) { $ new Column = array ( $ column ) ; $ column = Syntax Factory : : create Column ( $ new Column , \ is _null ( $ table ) ? $ this - > get Table ( ) : $ table ) ; $ this - > order By [ ] = new Order By ( $ column , $ direction ) ; return $ this ; } 
public function set Comment ( $ comment ) { 
public function add ( $ value ) { $ placeholder Key = ' :v ' . $ this - > counter ; $ this - > placeholders [ $ placeholder Key ] = $ this - > set Valid Sql Value ( $ value ) ; + + $ this - > counter ; return $ placeholder Key ; } 
protected function set Valid Sql Value ( $ value ) { $ value = $ this - > write Null Sql String ( $ value ) ; $ value = $ this - > write String As Sql String ( $ value ) ; $ value = $ this - > write Boolean Sql String ( $ value ) ; return $ value ; } 
protected function write Null Sql String ( $ value ) { if ( \ is _null ( $ value ) | | ( \ is _string ( $ value ) & & empty ( $ value ) ) ) { $ value = $ this - > write Null ( ) ; } return $ value ; } 
protected function abstract Write ( Query Part Interface $ set Class , $ set Operation , $ glue ) { $ selects = [ ] ; foreach ( $ set Class - > $ set Operation ( ) as $ select ) { $ selects [ ] = $ this - > writer - > write ( $ select , false ) ; } return \ implode ( " \n " . $ glue . " \n " , $ selects ) ; } 
public function set Table ( $ table ) { $ new Table = array ( $ table ) ; $ this - > table = Syntax Factory : : create Table ( $ new Table ) ; return $ this ; } 
public function set Alias ( $ alias ) { if ( 0 = = \ strlen ( $ alias ) ) { $ this - > alias = null ; return $ this ; } if ( $ this - > is All ( ) ) { throw new Query Exception ( "Can 't use alias because column name is ALL ( * ) " ) ; } $ this - > alias = ( string ) $ alias ; return $ this ; } 
public function join ( $ table , $ self Column = null , $ ref Column = null , $ columns = [ ] , $ join Type = null ) { if ( ! isset ( $ this - > joins [ $ table ] ) ) { $ select = Query Factory : : create Select ( $ table ) ; $ select - > set Columns ( $ columns ) ; $ select - > set Join Type ( $ join Type ) ; $ select - > set Parent Query ( $ this - > select ) ; $ this - > add Join ( $ select , $ self Column , $ ref Column ) ; } return $ this - > joins [ $ table ] ; } 
public function add Join ( Select $ select , $ self Column , $ ref Column ) { $ select - > is Join ( true ) ; $ table = $ select - > get Table ( ) - > get Name ( ) ; if ( ! isset ( $ this - > joins [ $ table ] ) ) { if ( ! $ self Column instanceof Column ) { $ new Column = array ( $ self Column ) ; $ self Column = Syntax Factory : : create Column ( $ new Column , $ this - > select - > get Table ( ) ) ; } $ select - > join Condition ( ) - > equals ( $ ref Column , $ self Column ) ; $ this - > joins [ $ table ] = $ select ; } return $ this - > joins [ $ table ] ; } 
public function cross Join ( $ table , $ self Column = null , $ ref Column = null , $ columns = [ ] ) { return $ this - > join ( $ table , $ self Column , $ ref Column , $ columns , self : : JOIN _CROSS ) ; } 
public function join Condition ( ) { if ( ! isset ( $ this - > join Condition ) ) { $ this - > join Condition = Query Factory : : create Where ( $ this - > select ) ; } return $ this - > join Condition ; } 
public function get ( $ columns = [ ' * ' ] ) { $ builder = $ this - > apply Scopes ( ) ; $ closure = function ( ) use ( $ builder , $ columns ) { 
public function pluck ( $ column , $ key = null ) : Collection { $ builder = $ this - > to Base ( ) ; $ closure = function ( ) use ( $ builder , $ column , $ key ) { $ results = $ builder - > pluck ( $ column , $ key ) ; 
public static function boot Cacheable Eloquent ( ) : void { static : : updated ( function ( Model $ cached Model ) { ! $ cached Model - > is Cache Clear Enabled ( ) | | $ cached Model : : forget Cache ( ) ; } ) ; static : : created ( function ( Model $ cached Model ) { ! $ cached Model - > is Cache Clear Enabled ( ) | | $ cached Model : : forget Cache ( ) ; } ) ; static : : deleted ( function ( Model $ cached Model ) { ! $ cached Model - > is Cache Clear Enabled ( ) | | $ cached Model : : forget Cache ( ) ; } ) ; } 
protected static function store Cache Key ( string $ model Name , string $ cache Key ) : void { $ keys File = storage _path ( 'framework /cache /data /rinvex .cacheable .json ' ) ; $ cache Keys = static : : get Cache Keys ( $ keys File ) ; if ( ! isset ( $ cache Keys [ $ model Name ] ) | | ! in _array ( $ cache Key , $ cache Keys [ $ model Name ] ) ) { $ cache Keys [ $ model Name ] [ ] = $ cache Key ; file _put _contents ( $ keys File , json _encode ( $ cache Keys ) ) ; } } 
protected static function get Cache Keys ( $ file ) : array { if ( ! file _exists ( $ file ) ) { $ dir = dirname ( $ file ) ; is _dir ( $ dir ) | | mkdir ( $ dir ) ; file _put _contents ( $ file , null ) ; } return json _decode ( file _get _contents ( $ file ) , true ) ? : [ ] ; } 
protected static function flush Cache Keys ( string $ model Name ) : array { $ flushed Keys = [ ] ; $ keys File = storage _path ( 'framework /cache /data /rinvex .cacheable .json ' ) ; $ cache Keys = static : : get Cache Keys ( $ keys File ) ; if ( isset ( $ cache Keys [ $ model Name ] ) ) { $ flushed Keys = $ cache Keys [ $ model Name ] ; unset ( $ cache Keys [ $ model Name ] ) ; file _put _contents ( $ keys File , json _encode ( $ cache Keys ) ) ; } return $ flushed Keys ; } 
public static function forget Cache ( ) { static : : fire Cache Flush Event ( 'cache .flushing ' ) ; 
protected static function fire Cache Flush Event ( $ event , $ halt = true ) { if ( ! isset ( static : : $ dispatcher ) ) { return true ; } 
public function reset Cache Config ( ) { ! $ this - > cache Driver | | $ this - > cache Driver = null ; ! $ this - > cache Lifetime | | $ this - > cache Lifetime = - 1 ; return $ this ; } 
protected function generate Cache Key ( $ builder , array $ columns ) : string { $ query = $ builder instanceof Builder ? $ builder - > get Query ( ) : $ builder ; $ vars = [ 'aggregate ' = > $ query - > aggregate , 'columns ' = > $ query - > columns , 'distinct ' = > $ query - > distinct , 'from ' = > $ query - > from , 'joins ' = > $ query - > joins , 'wheres ' = > $ query - > wheres , 'groups ' = > $ query - > groups , 'havings ' = > $ query - > havings , 'orders ' = > $ query - > orders , 'limit ' = > $ query - > limit , 'offset ' = > $ query - > offset , 'unions ' = > $ query - > unions , 'union Limit ' = > $ query - > union Limit , 'union Offset ' = > $ query - > union Offset , 'union Orders ' = > $ query - > union Orders , 'lock ' = > $ query - > lock , ] ; return md 5 ( json _encode ( [ $ vars , $ columns , static : : class , $ this - > get Cache Driver ( ) , $ this - > get Cache Lifetime ( ) , $ builder instanceof Builder ? $ builder - > get Eager Loads ( ) : null , $ builder - > get Bindings ( ) , $ builder - > to Sql ( ) , ] ) ) ; } 
public function cache Query ( $ builder , array $ columns , Closure $ closure ) { $ model Name = $ this - > get Morph Class ( ) ; $ lifetime = $ this - > get Cache Lifetime ( ) ; $ cache Key = $ this - > generate Cache Key ( $ builder , $ columns ) ; 
public static function validate ( Hpp Request $ hpp Request ) { self : : Initialise ( ) ; $ violations = self : : $ validator - > validate ( $ hpp Request ) ; if ( $ violations - > count ( ) > 0 ) { $ validation Messages = array ( ) ; foreach ( $ violations as $ violation ) { $ validation Messages [ ] = $ violation - > get Message ( ) ; } $ message = "Hpp Request failed validation with the following errors : " ; foreach ( $ validation Messages as $ validation Message ) { $ message . = $ validation Message . ' . ' ; } self : : $ logger - > info ( $ message ) ; throw new Realex Validation Exception ( "Hpp Request failed validation " , $ validation Messages ) ; } } 
public static function validate Response ( Hpp Response $ hpp Response , $ secret ) { self : : Initialise ( ) ; if ( ! $ hpp Response - > is Hash Valid ( $ secret ) ) { self : : $ logger - > error ( "Hpp Response contains an invalid security hash . " ) ; throw new Realex Validation Exception ( "Hpp Response contains an invalid security hash " , array ( "Hpp Response contains an invalid security hash " ) ) ; } } 
public function validate ( $ hpp Request , Constraint $ constraint ) { foreach ( $ hpp Request - > get Supplementary Data ( ) as $ supplementary Data ) { if ( strlen ( $ supplementary Data ) > $ this - > max Length ) { $ this - > context - > build Violation ( $ constraint - > message ) - > at Path ( 'supplementary Data ' ) - > add Violation ( ) ; } } } 
public function request To Json ( Hpp Request $ hpp Request , $ encoded = true ) { $ this - > logger - > info ( "Converting Hpp Request to JSON . " ) ; $ json = null ; 
public function request From Json ( $ json , $ encoded = true ) { $ this - > logger - > info ( "Converting JSON to Hpp Request . " ) ; 
public function response To Json ( Hpp Response $ hpp Response ) { $ this - > logger - > info ( "Converting Hpp Response to JSON . " ) ; $ json = null ; 
public function response From Json ( $ json , $ encoded = true ) { $ this - > logger - > info ( "Converting JSON to Hpp Response . " ) ; 
public function add Auto Settle Flag ( $ auto Settle Flag ) { if ( is _bool ( $ auto Settle Flag ) ) { $ this - > auto Settle Flag = $ auto Settle Flag ? Flag : : TRUE : Flag : : FALSE ; } else { $ this - > auto Settle Flag = $ auto Settle Flag ; } return $ this ; } 
public function add Return Tss ( $ return Tss ) { if ( is _bool ( $ return Tss ) ) { $ this - > return Tss = $ return Tss ? Flag : : TRUE : Flag : : FALSE ; } else { $ this - > return Tss = $ return Tss ; } return $ this ; } 
public function add Validate Card Only ( $ validate Card Only ) { if ( is _bool ( $ validate Card Only ) ) { $ this - > validate Card Only = $ validate Card Only ? Flag : : TRUE : Flag : : FALSE ; } else { $ this - > validate Card Only = $ validate Card Only ; } return $ this ; } 
public function add Dcc Enable ( $ dcc Enable ) { if ( is _bool ( $ dcc Enable ) ) { $ this - > dcc Enable = $ dcc Enable ? Flag : : TRUE : Flag : : FALSE ; } else { $ this - > dcc Enable = $ dcc Enable ; } return $ this ; } 
public function add Card Storage Enable ( $ card Storage Enable ) { if ( is _bool ( $ card Storage Enable ) ) { $ this - > card Storage Enable = $ card Storage Enable ? Flag : : TRUE : Flag : : FALSE ; } else { $ this - > card Storage Enable = $ card Storage Enable ; } return $ this ; } 
public function add Offer Save Card ( $ offer Save Card ) { if ( is _bool ( $ offer Save Card ) ) { $ this - > offer Save Card = $ offer Save Card ? Flag : : TRUE : Flag : : FALSE ; } else { $ this - > offer Save Card = $ offer Save Card ; } return $ this ; } 
public function add Payer Exists ( $ payer Exists ) { if ( is _bool ( $ payer Exists ) ) { $ this - > payer Exists = $ payer Exists ? Flag : : TRUE : Flag : : FALSE ; } else { $ this - > payer Exists = $ payer Exists ; } return $ this ; } 
public function add Hpp Version ( $ hpp Version ) { if ( is _bool ( $ hpp Version ) ) { $ this - > card Storage Enable = $ hpp Version ? Flag : : TRUE : Flag : : FALSE ; } else { $ this - > hpp Version = $ hpp Version ; } return $ this ; } 
public function generate Defaults ( $ secret ) { 
public function hash ( $ secret ) { 
public function encode ( $ char Set ) { $ this - > account = base 6 4 _encode ( $ this - > account ) ; $ this - > amount = base 6 4 _encode ( $ this - > amount ) ; $ this - > auto Settle Flag = base 6 4 _encode ( $ this - > auto Settle Flag ) ; $ this - > billing Code = base 6 4 _encode ( $ this - > billing Code ) ; $ this - > billing Country = base 6 4 _encode ( $ this - > billing Country ) ; $ this - > card Payment Button Text = base 6 4 _encode ( $ this - > card Payment Button Text ) ; $ this - > card Storage Enable = base 6 4 _encode ( $ this - > card Storage Enable ) ; $ this - > comment One = base 6 4 _encode ( $ this - > comment One ) ; $ this - > comment Two = base 6 4 _encode ( $ this - > comment Two ) ; $ this - > currency = base 6 4 _encode ( $ this - > currency ) ; $ this - > customer Number = base 6 4 _encode ( $ this - > customer Number ) ; $ this - > hash = base 6 4 _encode ( $ this - > hash ) ; $ this - > language = base 6 4 _encode ( $ this - > language ) ; $ this - > merchant Id = base 6 4 _encode ( $ this - > merchant Id ) ; $ this - > offer Save Card = base 6 4 _encode ( $ this - > offer Save Card ) ; $ this - > order Id = base 6 4 _encode ( $ this - > order Id ) ; $ this - > payer Exists = base 6 4 _encode ( $ this - > payer Exists ) ; $ this - > payer Reference = base 6 4 _encode ( $ this - > payer Reference ) ; $ this - > payment Reference = base 6 4 _encode ( $ this - > payment Reference ) ; $ this - > product Id = base 6 4 _encode ( $ this - > product Id ) ; $ this - > return Tss = base 6 4 _encode ( $ this - > return Tss ) ; $ this - > shipping Code = base 6 4 _encode ( $ this - > shipping Code ) ; $ this - > shipping Country = base 6 4 _encode ( $ this - > shipping Country ) ; $ this - > time Stamp = base 6 4 _encode ( $ this - > time Stamp ) ; $ this - > variable Reference = base 6 4 _encode ( $ this - > variable Reference ) ; $ this - > validate Card Only = base 6 4 _encode ( $ this - > validate Card Only ) ; $ this - > dcc Enable = base 6 4 _encode ( $ this - > dcc Enable ) ; $ this - > hpp Version = base 6 4 _encode ( $ this - > hpp Version ) ; $ this - > hpp Select Stored Card = base 6 4 _encode ( $ this - > hpp Select Stored Card ) ; $ this - > post Response = base 6 4 _encode ( $ this - > post Response ) ; $ this - > post Dimensions = base 6 4 _encode ( $ this - > post Dimensions ) ; if ( is _array ( $ this - > supplementary Data ) ) { foreach ( $ this - > supplementary Data as $ key = > $ value ) { $ this - > supplementary Data [ $ key ] = base 6 4 _encode ( $ value ) ; } } return $ this ; } 
public function decode ( $ char Set ) { $ this - > account = base 6 4 _decode ( $ this - > account ) ; $ this - > amount = base 6 4 _decode ( $ this - > amount ) ; $ this - > auto Settle Flag = base 6 4 _decode ( $ this - > auto Settle Flag ) ; $ this - > billing Code = base 6 4 _decode ( $ this - > billing Code ) ; $ this - > billing Country = base 6 4 _decode ( $ this - > billing Country ) ; $ this - > card Payment Button Text = base 6 4 _decode ( $ this - > card Payment Button Text ) ; $ this - > card Storage Enable = base 6 4 _decode ( $ this - > card Storage Enable ) ; $ this - > comment One = base 6 4 _decode ( $ this - > comment One ) ; $ this - > comment Two = base 6 4 _decode ( $ this - > comment Two ) ; $ this - > currency = base 6 4 _decode ( $ this - > currency ) ; $ this - > customer Number = base 6 4 _decode ( $ this - > customer Number ) ; $ this - > hash = base 6 4 _decode ( $ this - > hash ) ; $ this - > language = base 6 4 _decode ( $ this - > language ) ; $ this - > merchant Id = base 6 4 _decode ( $ this - > merchant Id ) ; $ this - > offer Save Card = base 6 4 _decode ( $ this - > offer Save Card ) ; $ this - > order Id = base 6 4 _decode ( $ this - > order Id ) ; $ this - > payer Exists = base 6 4 _decode ( $ this - > payer Exists ) ; $ this - > payer Reference = base 6 4 _decode ( $ this - > payer Reference ) ; $ this - > payment Reference = base 6 4 _decode ( $ this - > payment Reference ) ; $ this - > product Id = base 6 4 _decode ( $ this - > product Id ) ; $ this - > return Tss = base 6 4 _decode ( $ this - > return Tss ) ; $ this - > shipping Code = base 6 4 _decode ( $ this - > shipping Code ) ; $ this - > shipping Country = base 6 4 _decode ( $ this - > shipping Country ) ; $ this - > time Stamp = base 6 4 _decode ( $ this - > time Stamp ) ; $ this - > variable Reference = base 6 4 _decode ( $ this - > variable Reference ) ; $ this - > validate Card Only = base 6 4 _decode ( $ this - > validate Card Only ) ; $ this - > dcc Enable = base 6 4 _decode ( $ this - > dcc Enable ) ; $ this - > hpp Version = base 6 4 _decode ( $ this - > hpp Version ) ; $ this - > hpp Select Stored Card = base 6 4 _decode ( $ this - > hpp Select Stored Card ) ; $ this - > post Response = base 6 4 _decode ( $ this - > post Response ) ; $ this - > post Dimensions = base 6 4 _decode ( $ this - > post Dimensions ) ; if ( is _array ( $ this - > supplementary Data ) ) { foreach ( $ this - > supplementary Data as $ key = > $ value ) { $ this - > supplementary Data [ $ key ] = base 6 4 _decode ( $ value ) ; } } return $ this ; } 
public function format Request ( $ char Set ) { $ this - > account = $ this - > null To Empty String ( $ this - > account ) ; $ this - > amount = $ this - > null To Empty String ( $ this - > amount ) ; $ this - > auto Settle Flag = $ this - > null To Empty String ( $ this - > auto Settle Flag ) ; $ this - > billing Code = $ this - > null To Empty String ( $ this - > billing Code ) ; $ this - > billing Country = $ this - > null To Empty String ( $ this - > billing Country ) ; $ this - > card Payment Button Text = $ this - > null To Empty String ( $ this - > card Payment Button Text ) ; $ this - > card Storage Enable = $ this - > null To Empty String ( $ this - > card Storage Enable ) ; $ this - > comment One = $ this - > null To Empty String ( $ this - > comment One ) ; $ this - > comment Two = $ this - > null To Empty String ( $ this - > comment Two ) ; $ this - > currency = $ this - > null To Empty String ( $ this - > currency ) ; $ this - > customer Number = $ this - > null To Empty String ( $ this - > customer Number ) ; $ this - > hash = $ this - > null To Empty String ( $ this - > hash ) ; $ this - > language = $ this - > null To Empty String ( $ this - > language ) ; $ this - > merchant Id = $ this - > null To Empty String ( $ this - > merchant Id ) ; $ this - > offer Save Card = $ this - > null To Empty String ( $ this - > offer Save Card ) ; $ this - > order Id = $ this - > null To Empty String ( $ this - > order Id ) ; $ this - > payer Exists = $ this - > null To Empty String ( $ this - > payer Exists ) ; $ this - > payer Reference = $ this - > null To Empty String ( $ this - > payer Reference ) ; $ this - > payment Reference = $ this - > null To Empty String ( $ this - > payment Reference ) ; $ this - > product Id = $ this - > null To Empty String ( $ this - > product Id ) ; $ this - > return Tss = $ this - > null To Empty String ( $ this - > return Tss ) ; $ this - > shipping Code = $ this - > null To Empty String ( $ this - > shipping Code ) ; $ this - > shipping Country = $ this - > null To Empty String ( $ this - > shipping Country ) ; $ this - > time Stamp = $ this - > null To Empty String ( $ this - > time Stamp ) ; $ this - > variable Reference = $ this - > null To Empty String ( $ this - > variable Reference ) ; $ this - > validate Card Only = $ this - > null To Empty String ( $ this - > validate Card Only ) ; $ this - > dcc Enable = $ this - > null To Empty String ( $ this - > dcc Enable ) ; $ this - > hpp Version = $ this - > null To Empty String ( $ this - > hpp Version ) ; $ this - > hpp Select Stored Card = $ this - > null To Empty String ( $ this - > hpp Select Stored Card ) ; $ this - > post Response = $ this - > null To Empty String ( $ this - > post Response ) ; $ this - > post Dimensions = $ this - > null To Empty String ( $ this - > post Dimensions ) ; if ( is _array ( $ this - > supplementary Data ) ) { foreach ( $ this - > supplementary Data as $ key = > $ value ) { $ this - > supplementary Data [ $ key ] = $ this - > null To Empty String ( $ value ) ; } } return $ this ; } 
public function validate ( $ hpp Request , Constraint $ constraint ) { 
public function validate ( $ hpp Request , Constraint $ constraint ) { foreach ( $ hpp Request - > get Supplementary Data ( ) as $ supplementary Data ) { if ( ! preg _match ( $ constraint - > pattern , $ supplementary Data ) ) { $ this - > context - > build Violation ( $ constraint - > message ) - > at Path ( 'supplementary Data ' ) - > add Violation ( ) ; } } } 
public static function Get Logger ( $ class Name ) { if ( ! self : : Is Initialised ( ) ) { self : : Initialise ( ) ; } $ logger = Logger : : get Logger ( $ class Name ) ; return $ logger ; } 
public static function generate Hash ( $ to Hash , $ secret ) { 
public static function to Json ( $ hpp Object ) { self : : Initialise ( ) ; $ mapper = self : : $ mappers [ get _class ( $ hpp Object ) ] ; return $ mapper - > Write Value As String ( $ hpp Object ) ; } 
public static function from Json Hpp Request ( $ json ) { self : : Initialise ( ) ; $ mapper = self : : $ mappers [ Hpp Request : : Get Class Name ( ) ] ; return $ mapper - > Read Value ( $ json ) ; } 
public static function from Json Hpp Response ( $ json ) { self : : Initialise ( ) ; $ mapper = self : : $ mappers [ Hpp Response : : Get Class Name ( ) ] ; return $ mapper - > Read Value ( $ json ) ; } 
public function generate Hash ( $ secret ) { 
public function encode ( $ charset ) { $ this - > merchant Id = base 6 4 _encode ( $ this - > merchant Id ) ; $ this - > account = base 6 4 _encode ( $ this - > account ) ; $ this - > amount = base 6 4 _encode ( $ this - > amount ) ; $ this - > auth Code = base 6 4 _encode ( $ this - > auth Code ) ; $ this - > batch Id = base 6 4 _encode ( $ this - > batch Id ) ; $ this - > cavv = base 6 4 _encode ( $ this - > cavv ) ; $ this - > cvn Result = base 6 4 _encode ( $ this - > cvn Result ) ; $ this - > eci = base 6 4 _encode ( $ this - > eci ) ; $ this - > comment One = base 6 4 _encode ( $ this - > comment One ) ; $ this - > comment Two = base 6 4 _encode ( $ this - > comment Two ) ; $ this - > message = base 6 4 _encode ( $ this - > message ) ; $ this - > pas Ref = base 6 4 _encode ( $ this - > pas Ref ) ; $ this - > hash = base 6 4 _encode ( $ this - > hash ) ; $ this - > result = base 6 4 _encode ( $ this - > result ) ; $ this - > xid = base 6 4 _encode ( $ this - > xid ) ; $ this - > order Id = base 6 4 _encode ( $ this - > order Id ) ; $ this - > time Stamp = base 6 4 _encode ( $ this - > time Stamp ) ; $ this - > AVSAddress Result = base 6 4 _encode ( $ this - > AVSAddress Result ) ; $ this - > AVSPost Code Result = base 6 4 _encode ( $ this - > AVSPost Code Result ) ; if ( is _array ( $ this - > tss ) ) { foreach ( $ this - > tss as $ key = > $ value ) { $ this - > tss [ $ key ] = base 6 4 _encode ( $ value ) ; } } if ( is _array ( $ this - > supplementary Data ) ) { foreach ( $ this - > supplementary Data as $ key = > $ value ) { $ this - > supplementary Data [ $ key ] = base 6 4 _encode ( $ value ) ; } } return $ this ; } 
public function decode ( $ charset ) { $ this - > merchant Id = base 6 4 _decode ( $ this - > merchant Id ) ; $ this - > account = base 6 4 _decode ( $ this - > account ) ; $ this - > amount = base 6 4 _decode ( $ this - > amount ) ; $ this - > auth Code = base 6 4 _decode ( $ this - > auth Code ) ; $ this - > batch Id = base 6 4 _decode ( $ this - > batch Id ) ; $ this - > cavv = base 6 4 _decode ( $ this - > cavv ) ; $ this - > cvn Result = base 6 4 _decode ( $ this - > cvn Result ) ; $ this - > eci = base 6 4 _decode ( $ this - > eci ) ; $ this - > comment One = base 6 4 _decode ( $ this - > comment One ) ; $ this - > comment Two = base 6 4 _decode ( $ this - > comment Two ) ; $ this - > message = base 6 4 _decode ( $ this - > message ) ; $ this - > pas Ref = base 6 4 _decode ( $ this - > pas Ref ) ; $ this - > hash = base 6 4 _decode ( $ this - > hash ) ; $ this - > result = base 6 4 _decode ( $ this - > result ) ; $ this - > xid = base 6 4 _decode ( $ this - > xid ) ; $ this - > order Id = base 6 4 _decode ( $ this - > order Id ) ; $ this - > time Stamp = base 6 4 _decode ( $ this - > time Stamp ) ; $ this - > AVSAddress Result = base 6 4 _decode ( $ this - > AVSAddress Result ) ; $ this - > AVSPost Code Result = base 6 4 _decode ( $ this - > AVSPost Code Result ) ; if ( is _array ( $ this - > tss ) ) { foreach ( $ this - > tss as $ key = > $ value ) { $ this - > tss [ $ key ] = base 6 4 _decode ( $ value ) ; } } if ( is _array ( $ this - > supplementary Data ) ) { foreach ( $ this - > supplementary Data as $ key = > $ value ) { $ this - > supplementary Data [ $ key ] = base 6 4 _decode ( $ value ) ; } } return $ this ; } 
public function is Valid Value ( $ value ) { if ( is _null ( $ value ) ) return true ; foreach ( $ this - > get Config ( ) - > get ( 'values ' ) as $ item ) { if ( $ value = = = $ item [ 'name ' ] | | $ value = = = $ item [ 'value ' ] ) { return true ; } } return false ; } 
public function add Directives ( $ directives ) { if ( ! is _array ( $ directives ) ) { throw new \ Exception ( 'add Directives accept only array of directives ' ) ; } foreach ( $ directives as $ directive ) { $ this - > add Directive ( $ directive ) ; } return $ this ; } 
public function add Directive ( Directive Interface $ directive ) { $ directive Name = $ this - > get Directive Name ( $ directive ) ; if ( $ this - > is Directive Name Registered ( $ directive Name ) ) return $ this ; $ this - > directives List [ $ directive Name ] = $ directive ; return $ this ; } 
public function get Field ( Abstract Object Type $ type , $ field Name ) { $ type Name = $ type - > get Name ( ) ; if ( ! array _key _exists ( $ type Name , $ this - > type Field Lookup Table ) ) { $ this - > type Field Lookup Table [ $ type Name ] = [ ] ; } if ( ! array _key _exists ( $ field Name , $ this - > type Field Lookup Table [ $ type Name ] ) ) { $ this - > type Field Lookup Table [ $ type Name ] [ $ field Name ] = $ type - > get Field ( $ field Name ) ; } return $ this - > type Field Lookup Table [ $ type Name ] [ $ field Name ] ; } 
protected function valid List ( $ value , $ return Value = false ) { $ item Type = $ this - > config - > get ( 'item Type ' ) ; if ( $ value & & $ item Type - > is Input Type ( ) ) { foreach ( $ value as $ item ) { if ( ! $ item Type - > is Valid Value ( $ item ) ) { return $ return Value ? $ item : false ; } } } return true ; } 
public function reduce Query ( Execution Context Interface $ execution Context , array $ reducers ) { $ this - > execution Context = $ execution Context ; $ schema = $ execution Context - > get Schema ( ) ; foreach ( $ reducers as $ reducer ) { foreach ( $ execution Context - > get Request ( ) - > get All Operations ( ) as $ operation ) { $ this - > do Visit ( $ operation , $ operation instanceof Mutation ? $ schema - > get Mutation Type ( ) : $ schema - > get Query Type ( ) , $ reducer ) ; } } } 
protected function do Visit ( Query $ query , $ current Level Schema , $ reducer ) { if ( ! ( $ current Level Schema instanceof Abstract Object Type ) | | ! $ current Level Schema - > has Field ( $ query - > get Name ( ) ) ) { return ; } if ( $ operation Field = $ current Level Schema - > get Field ( $ query - > get Name ( ) ) ) { $ coroutine = $ this - > walk Query ( $ query , $ operation Field ) ; if ( $ results = $ coroutine - > current ( ) ) { $ query Cost = 0 ; while ( $ results ) { * @var Query |Field Ast $query Field * @var Field $ast Field * / $ cost = $ reducer - > visit ( $ query Field - > get Key Value Arguments ( ) , $ ast Field - > get Config ( ) , $ child Cost ) ; $ query Cost + = $ cost ; $ results = $ coroutine - > send ( $ cost ) ; } } } } 
protected function walk Query ( $ query Node , Field Interface $ current Level AST ) { $ children Score = 0 ; if ( ! ( $ query Node instanceof Field Ast ) ) { foreach ( $ query Node - > get Fields ( ) as $ query Field ) { if ( $ query Field instanceof Fragment Interface ) { if ( $ query Field instanceof Fragment Reference ) { $ query Field = $ this - > execution Context - > get Request ( ) - > get Fragment ( $ query Field - > get Name ( ) ) ; } 
public static function get Scalar Type ( $ type ) { if ( Type Service : : is Scalar Type ( $ type ) ) { if ( is _object ( $ type ) ) { return $ type ; } if ( empty ( self : : $ objects Hash [ $ type ] ) ) { $ name = ucfirst ( $ type ) ; $ name = $ name = = 'Datetime ' ? 'Date Time ' : $ name ; $ name = $ name = = 'Datetimetz ' ? 'Date Time Tz ' : $ name ; $ class Name = 'Youshido \Graph QL \Type \Scalar \ \ ' . $ name . 'Type ' ; self : : $ objects Hash [ $ type ] = new $ class Name ( ) ; } return self : : $ objects Hash [ $ type ] ; } else { throw new Configuration Exception ( 'Configuration problem with type ' . $ type ) ; } } 
protected function scan ( ) { if ( $ this - > pos > = strlen ( $ this - > source ) ) { return new Token ( Token : : TYPE _END , $ this - > get Line ( ) , $ this - > get Column ( ) ) ; } $ ch = $ this - > source [ $ this - > pos ] ; switch ( $ ch ) { case Token : : TYPE _LPAREN : + + $ this - > pos ; return new Token ( Token : : TYPE _LPAREN , $ this - > get Line ( ) , $ this - > get Column ( ) ) ; case Token : : TYPE _RPAREN : + + $ this - > pos ; return new Token ( Token : : TYPE _RPAREN , $ this - > get Line ( ) , $ this - > get Column ( ) ) ; case Token : : TYPE _LBRACE : + + $ this - > pos ; return new Token ( Token : : TYPE _LBRACE , $ this - > get Line ( ) , $ this - > get Column ( ) ) ; case Token : : TYPE _RBRACE : + + $ this - > pos ; return new Token ( Token : : TYPE _RBRACE , $ this - > get Line ( ) , $ this - > get Column ( ) ) ; case Token : : TYPE _COMMA : + + $ this - > pos ; return new Token ( Token : : TYPE _COMMA , $ this - > get Line ( ) , $ this - > get Column ( ) ) ; case Token : : TYPE _LSQUARE _BRACE : + + $ this - > pos ; return new Token ( Token : : TYPE _LSQUARE _BRACE , $ this - > get Line ( ) , $ this - > get Column ( ) ) ; case Token : : TYPE _RSQUARE _BRACE : + + $ this - > pos ; return new Token ( Token : : TYPE _RSQUARE _BRACE , $ this - > get Line ( ) , $ this - > get Column ( ) ) ; case Token : : TYPE _REQUIRED : + + $ this - > pos ; return new Token ( Token : : TYPE _REQUIRED , $ this - > get Line ( ) , $ this - > get Column ( ) ) ; case Token : : TYPE _AT : + + $ this - > pos ; return new Token ( Token : : TYPE _AT , $ this - > get Line ( ) , $ this - > get Column ( ) ) ; case Token : : TYPE _COLON : + + $ this - > pos ; return new Token ( Token : : TYPE _COLON , $ this - > get Line ( ) , $ this - > get Column ( ) ) ; case Token : : TYPE _EQUAL : + + $ this - > pos ; return new Token ( Token : : TYPE _EQUAL , $ this - > get Line ( ) , $ this - > get Column ( ) ) ; case Token : : TYPE _POINT : if ( $ this - > check Fragment ( ) ) { return new Token ( Token : : TYPE _FRAGMENT _REFERENCE , $ this - > get Line ( ) , $ this - > get Column ( ) ) ; } return new Token ( Token : : TYPE _POINT , $ this - > get Line ( ) , $ this - > get Column ( ) ) ; case Token : : TYPE _VARIABLE : + + $ this - > pos ; return new Token ( Token : : TYPE _VARIABLE , $ this - > get Line ( ) , $ this - > get Column ( ) ) ; } if ( $ ch = = = ' _ ' | | ( 'a ' < = $ ch & & $ ch < = 'z ' ) | | ( 'A ' < = $ ch & & $ ch < = 'Z ' ) ) { return $ this - > scan Word ( ) ; } if ( $ ch = = = ' - ' | | ( ' 0 ' < = $ ch & & $ ch < = ' 9 ' ) ) { return $ this - > scan Number ( ) ; } if ( $ ch = = = ' " ' ) { return $ this - > scan String ( ) ; } throw $ this - > create Exception ( 'Can \t recognize token type ' ) ; } 
protected function scan String ( ) { $ len = strlen ( $ this - > source ) ; $ this - > pos + + ; $ value = ' ' ; while ( $ this - > pos < $ len ) { $ ch = $ this - > source [ $ this - > pos ] ; if ( $ ch = = = ' " ' ) { $ token = new Token ( Token : : TYPE _STRING , $ this - > get Line ( ) , $ this - > get Column ( ) , $ value ) ; $ this - > pos + + ; return $ token ; } if ( $ ch = = = ' \ \ ' & & ( $ this - > pos < ( $ len - 1 ) ) ) { $ this - > pos + + ; $ ch = $ this - > source [ $ this - > pos ] ; switch ( $ ch ) { case ' " ' : case ' \ \ ' : case ' / ' : break ; case 'b ' : $ ch = sprintf ( " %c " , 8 ) ; break ; case 'f ' : $ ch = " \f " ; break ; case 'n ' : $ ch = " \n " ; break ; case 'r ' : $ ch = " \r " ; break ; case 'u ' : $ codepoint = substr ( $ this - > source , $ this - > pos + 1 , 4 ) ; if ( ! preg _match ( ' / [ 0 - 9A -Fa -f ] { 4 } / ' , $ codepoint ) ) { throw $ this - > create Exception ( sprintf ( 'Invalid string unicode escape sequece " %s " ' , $ codepoint ) ) ; } $ ch = html _entity _decode ( " & #x { $codepoint } ; " , ENT _QUOTES , 'UTF - 8 ' ) ; $ this - > pos + = 4 ; break ; default : throw $ this - > create Exception ( sprintf ( 'Unexpected string escaped character " %s " ' , $ ch ) ) ; break ; } } $ value . = $ ch ; $ this - > pos + + ; } throw $ this - > create Unexpected Token Type Exception ( Token : : TYPE _END ) ; } 
private function get Field Config Rules ( ) { return [ 'name ' = > [ 'type ' = > Type Service : : TYPE _STRING , 'required ' = > true ] , 'type ' = > [ 'type ' = > Type Service : : TYPE _ANY , 'required ' = > true ] , 'args ' = > [ 'type ' = > Type Service : : TYPE _ARRAY ] , 'description ' = > [ 'type ' = > Type Service : : TYPE _STRING ] , 'resolve ' = > [ 'type ' = > Type Service : : TYPE _CALLABLE ] , 'is Deprecated ' = > [ 'type ' = > Type Service : : TYPE _BOOLEAN ] , 'deprecation Reason ' = > [ 'type ' = > Type Service : : TYPE _STRING ] , 'cost ' = > [ 'type ' = > Type Service : : TYPE _ANY ] ] ; } 
public function get Field AST ( $ field Name ) { $ field = null ; foreach ( $ this - > get Field ASTList ( ) as $ field AST ) { if ( $ field AST - > get Name ( ) = = = $ field Name ) { $ field = $ field AST ; break ; } } return $ field ; } 
public function resolve Default Value ( $ value ) { $ resolved Value = $ value - > get Config ( ) - > get Default Value ( ) ; return $ resolved Value = = = null ? $ resolved Value : str _replace ( ' " ' , ' ' , json _encode ( $ resolved Value ) ) ; } 
public function get Fragment ( $ name ) { foreach ( $ this - > fragments as $ fragment ) { if ( $ fragment - > get Name ( ) = = $ name ) { return $ fragment ; } } return null ; } 
public function set Variables ( $ variables ) { if ( ! is _array ( $ variables ) ) { $ variables = json _decode ( $ variables , true ) ; } $ this - > variables = $ variables ; foreach ( $ this - > variable References as $ reference ) { if ( ! $ reference - > get Variable ( ) ) continue ; $ variable Name = $ reference - > get Variable ( ) - > get Name ( ) ; if ( ! array _key _exists ( $ variable Name , $ variables ) ) continue ; $ reference - > get Variable ( ) - > set Value ( $ variables [ $ variable Name ] ) ; $ reference - > set Value ( $ variables [ $ variable Name ] ) ; } return $ this ; } 
public function resolve Locations ( Directive Interface $ value ) { $ directive Config = $ value - > get Config ( ) ; $ locations = $ directive Config - > get Locations ( ) ; return $ locations ; } 
public static function edge Definition ( Abstract Type $ type , $ name = null , $ config = [ ] ) { $ name = $ name ? : $ type - > get Name ( ) ; $ edge Fields = ! empty ( $ config [ 'edge Fields ' ] ) ? $ config [ 'edge Fields ' ] : [ ] ; $ edge Type = new Object Type ( [ 'name ' = > $ name . 'Edge ' , 'description ' = > 'An edge in a connection . ' , 'fields ' = > array _merge ( [ 'node ' = > [ 'type ' = > $ type , 'description ' = > 'The item at the end of the edge ' , 'resolve ' = > [ _ _CLASS _ _ , 'get Node ' ] , ] , 'cursor ' = > [ 'type ' = > Type Map : : TYPE _STRING , 'description ' = > 'A cursor for use in pagination ' ] ] , $ edge Fields ) ] ) ; return $ edge Type ; } 
public static function connection Definition ( Abstract Type $ type , $ name = null , $ config = [ ] ) { $ name = $ name ? : $ type - > get Name ( ) ; $ connection Fields = ! empty ( $ config [ 'connection Fields ' ] ) ? $ config [ 'connection Fields ' ] : [ ] ; $ connection Type = new Object Type ( [ 'name ' = > $ name . 'Connection ' , 'description ' = > 'A connection to a list of items . ' , 'fields ' = > array _merge ( [ 'total Count ' = > [ 'type ' = > new Non Null Type ( new Int Type ( ) ) , 'description ' = > 'How many nodes . ' , 'resolve ' = > [ _ _CLASS _ _ , 'get Total Count ' ] , ] , 'page Info ' = > [ 'type ' = > new Non Null Type ( new Page Info Type ( ) ) , 'description ' = > 'Information to aid in pagination . ' , 'resolve ' = > [ _ _CLASS _ _ , 'get Page Info ' ] , ] , 'edges ' = > [ 'type ' = > new List Type ( self : : edge Definition ( $ type , $ name , $ config ) ) , 'description ' = > 'A list of edges . ' , 'resolve ' = > [ _ _CLASS _ _ , 'get Edges ' ] , ] ] , $ connection Fields ) ] ) ; return $ connection Type ; } 
public static function unpack Deferred Results ( $ result ) { while ( $ result instanceof Deferred Result ) { $ result = $ result - > result ; } if ( is _array ( $ result ) ) { foreach ( $ result as $ key = > $ value ) { $ result [ $ key ] = static : : unpack Deferred Results ( $ value ) ; } } return $ result ; } 
protected function deferred Resolve ( $ resolved Value , Field Interface $ field , callable $ callback ) { if ( $ resolved Value instanceof Deferred Resolver Interface ) { $ deferred Result = new Deferred Result ( $ resolved Value , function ( $ resolved Value ) use ( $ field , $ callback ) { 
public static function cursor To Key ( $ cursor ) { if ( $ decoded = base 6 4 _decode ( $ cursor ) ) { return substr ( $ decoded , strlen ( self : : PREFIX ) ) ; } return null ; } 
public static function cursor To Offset With Default ( $ cursor , $ default , $ array = [ ] ) { if ( ! is _string ( $ cursor ) ) { return $ default ; } $ key = self : : cursor To Key ( $ cursor ) ; if ( empty ( $ array ) ) { $ offset = $ key ; } else { $ offset = array _search ( $ key , array _keys ( $ array ) ) ; } return is _null ( $ offset ) ? $ default : ( int ) $ offset ; } 
public function get Value ( ) { if ( null = = = $ this - > value ) { if ( $ this - > has Default Value ( ) ) { return $ this - > default Value ; } throw new \ Logic Exception ( 'Value is not set for variable " ' . $ this - > name . ' " ' ) ; } return $ this - > value ; } 
public function get Directive ( $ name ) { $ directive = null ; if ( isset ( $ this - > directives [ $ name ] ) ) { $ directive = $ this - > directives [ $ name ] ; } return $ directive ; } 
protected function parse Value ( ) { switch ( $ this - > look Ahead - > get Type ( ) ) { case Token : : TYPE _LSQUARE _BRACE : return $ this - > parse List ( ) ; case Token : : TYPE _LBRACE : return $ this - > parse Object ( ) ; case Token : : TYPE _VARIABLE : return $ this - > parse Variable Reference ( ) ; case Token : : TYPE _NUMBER : case Token : : TYPE _STRING : case Token : : TYPE _IDENTIFIER : case Token : : TYPE _NULL : case Token : : TYPE _TRUE : case Token : : TYPE _FALSE : $ token = $ this - > lex ( ) ; return new Literal ( $ token - > get Data ( ) , new Location ( $ token - > get Line ( ) , $ token - > get Column ( ) ) ) ; } throw $ this - > create Unexpected Exception ( $ this - > look Ahead ) ; } 
public static function build Mutation ( $ name , array $ args , $ output , callable $ resolve Function ) { if ( ! is _array ( $ output ) | | ( is _object ( $ output ) & & ! ( $ output instanceof Abstract Object Type ) ) ) { throw new \ Exception ( 'Output can be instance of Abstract Object Type or array of fields ' ) ; } return new Field ( [ 'name ' = > $ name , 'args ' = > [ new Input Field ( [ 'name ' = > 'input ' , 'type ' = > new Non Null Type ( new Input Object Type ( [ 'name ' = > ucfirst ( $ name ) . 'Input ' , 'fields ' = > array _merge ( $ args , [ new Input Field ( [ 'name ' = > 'client Mutation Id ' , 'type ' = > new Non Null Type ( new String Type ( ) ) ] ) ] ) ] ) ) ] ) ] , 'type ' = > new Object Type ( [ 'fields ' = > is _object ( $ output ) ? $ output : array _merge ( $ output , [ new Field ( [ 'name ' = > 'client Mutation Id ' , 'type ' = > new Non Null Type ( new String Type ( ) ) ] ) ] ) , 'name ' = > ucfirst ( $ name ) . 'Payload ' ] ) , 'resolve ' = > function ( $ value , $ args , Resolve Info $ info ) use ( $ resolve Function ) { $ resolve Value = $ resolve Function ( $ value , $ args [ 'input ' ] , $ args , $ info ) ; if ( is _object ( $ resolve Value ) ) { $ resolve Value - > client Mutation Id = $ args [ 'input ' ] [ 'client Mutation Id ' ] ; } elseif ( is _array ( $ resolve Value ) ) { $ resolve Value [ 'client Mutation Id ' ] = $ args [ 'input ' ] [ 'client Mutation Id ' ] ; } return $ resolve Value ; } ] ) ; } 
public function visit ( array $ args , Field Config $ field Config , $ child Score = 0 ) { $ cost = $ field Config - > get ( 'cost ' , null ) ; if ( is _callable ( $ cost ) ) { $ cost = $ cost ( $ args , $ field Config , $ child Score ) ; } $ cost = is _null ( $ cost ) ? $ this - > default Score : $ cost ; $ this - > memo + = $ cost ; if ( $ this - > memo > $ this - > max Score ) { throw new \ Exception ( 'query exceeded max allowed complexity of ' . $ this - > max Score ) ; } return $ cost ; } 
public function get ( $ key , $ default Value = null ) { return $ this - > has ( $ key ) ? $ this - > data [ $ key ] : $ default Value ; } 
public function validate ( Abstract Schema $ schema ) { if ( ! $ schema - > get Query Type ( ) - > has Fields ( ) ) { throw new Configuration Exception ( 'Schema has to have fields ' ) ; } $ this - > config Validator = Config Validator : : get Instance ( ) ; foreach ( $ schema - > get Query Type ( ) - > get Config ( ) - > get Fields ( ) as $ field ) { $ this - > config Validator - > assert Valid Config ( $ field - > get Config ( ) ) ; if ( $ field - > get Type ( ) instanceof Abstract Object Type ) { $ this - > assert Interface Implementation Correct ( $ field - > get Type ( ) ) ; } } } 
protected function assert Interface Implementation Correct ( Abstract Object Type $ type ) { if ( ! $ type - > get Interfaces ( ) ) { return ; } foreach ( $ type - > get Interfaces ( ) as $ interface ) { foreach ( $ interface - > get Config ( ) - > get Fields ( ) as $ int Field ) { $ this - > assert Fields Identical ( $ int Field , $ type - > get Config ( ) - > get Field ( $ int Field - > get Name ( ) ) , $ interface ) ; } } } 
protected function assert Fields Identical ( $ int Field , $ obj Field , Abstract Interface Type $ interface ) { $ is Valid = true ; if ( $ int Field - > get Type ( ) - > is Composite Type ( ) ! = = $ obj Field - > get Type ( ) - > is Composite Type ( ) ) { $ is Valid = false ; } if ( $ int Field - > get Type ( ) - > get Named Type ( ) - > get Name ( ) ! = $ obj Field - > get Type ( ) - > get Named Type ( ) - > get Name ( ) ) { $ is Valid = false ; } if ( ! $ is Valid ) { throw new Configuration Exception ( sprintf ( 'Implementation of %s is invalid for the field %s ' , $ interface - > get Name ( ) , $ obj Field - > get Name ( ) ) ) ; } } 
private function get Replacements And Clear ( Tokens $ tokens , array $ indices , int $ direction ) : array { return \ array _map ( static function ( int $ index ) use ( $ tokens , $ direction ) : Token { $ clone = $ tokens [ $ index ] ; if ( $ tokens [ $ index + $ direction ] - > is Whitespace ( ) ) { $ tokens - > clear At ( $ index + $ direction ) ; } $ tokens - > clear At ( $ index ) ; return $ clone ; } , $ indices ) ; } 
public function on Open ( Swoole Websocket Server $ server , Swoole Http Request $ swoole Request ) : void { $ this - > log ( sprintf ( 'Server : handshake success with fd %s ' , $ swoole Request - > fd ) ) ; $ this - > set Client Path Info ( $ swoole Request - > fd , $ swoole Request - > server [ 'path _info ' ] ) ; $ request = $ this - > normalize Request ( $ swoole Request ) ; $ request - > set Path Info ( $ this - > normalize Path Info ( $ request - > get Path Info ( ) , self : : OPEN ) ) ; $ this - > set Pre Request Matched ( $ request , [ $ server , $ request , $ swoole Request - > fd ] ) ; $ response = $ this - > dispatch Router ( $ request ) ; } 
public function on Message ( Swoole Websocket Server $ server , Swoole Websocket Frame $ frame ) : void { $ this - > log ( sprintf ( 'Receive from fd %d : %s ,opcode : %d ,fin : %d ' , $ frame - > fd , $ frame - > data , $ frame - > opcode , $ frame - > finish ) ) ; if ( false = = = ( $ path Info = $ this - > get Client Path Info ( $ frame - > fd ) ) ) { return ; } $ request = $ this - > create Request With Path Info ( $ path Info , self : : MESSAGE ) ; $ this - > set Pre Request Matched ( $ request , [ $ server , $ frame , $ frame - > fd ] ) ; $ response = $ this - > dispatch Router ( $ request ) ; } 
public function on Websocket Close ( Swoole Websocket Server $ server , int $ fd , int $ reactor Id ) : void { $ this - > log ( sprintf ( 'Server close , fd %d , reactor Id %d . ' , $ fd , $ reactor Id ) ) ; $ client Info = $ this - > server - > get Client Info ( $ fd ) ; if ( $ client Info [ 'websocket _status ' ] < = 0 ) { return ; } 
protected function set Pre Request Matched ( IRequest $ request , array $ data ) : void { $ this - > container - > make ( IRouter : : class ) - > set Pre Request Matched ( $ request , [ IRouter : : VARS = > $ data ] ) ; } 
protected function create Request With Path Info ( string $ path Info , string $ type ) : IRequest { $ request = new Request ( ) ; $ request - > set Path Info ( $ this - > normalize Path Info ( $ path Info , $ type ) ) ; return $ request ; } 
protected function create Server ( ) : void { $ this - > server = new Swoole Websocket Server ( $ this - > option [ 'host ' ] , ( int ) ( $ this - > option [ 'port ' ] ) ) ; $ this - > init Server ( ) ; } 
protected function get Client Path Info ( int $ fd ) { $ key = self : : PATHINFO . $ fd ; $ path Info = $ this - > container - > make ( $ key ) ; if ( $ key = = = $ path Info ) { return false ; } return $ path Info ; } 
protected function set Client Path Info ( int $ fd , string $ path Info ) : void { $ this - > container - > instance ( self : : PATHINFO . $ fd , $ path Info ) ; } 
public function make Connect ( ) { if ( empty ( $ this - > option [ 'path ' ] ) ) { throw new Invalid Argument Exception ( 'The local requires path option . ' ) ; } return new Adapter Local ( $ this - > option [ 'path ' ] , $ this - > option [ 'write _flags ' ] , $ this - > option [ 'link _handling ' ] , $ this - > option [ 'permissions ' ] ) ; } 
public function handle ( IApp $ app , IOption $ option ) : void { $ this - > app = $ app ; $ this - > parser = $ this - > create Parser ( ) ; $ this - > html = $ this - > get Html View ( ) ; $ this - > line ( 'Start to cache view . ' ) ; foreach ( $ this - > paths ( ) as $ path ) { $ this - > compiles ( $ this - > find Files ( [ $ path ] ) , $ path ) ; } $ this - > info ( 'View files cache successed . ' ) ; } 
protected function compiles ( Finder $ finder , string $ path ) : void { if ( 0 = = = count ( $ finder ) ) { $ this - > comment ( sprintf ( 'Compile files not found in path ` %s ` and skipped . ' , $ path ) ) ; return ; } $ this - > info ( sprintf ( 'Start to compiles path ` %s ` ' , $ path ) ) ; $ progress Bar = new Progress Bar ( new Console Output ( ) , count ( $ finder ) ) ; $ progress Bar - > set Format ( ' [View :cache ] %current % / %max % [ %bar % ] %percent : 3s % % %elapsed : 6s % / %estimated : - 6s % %memory : 6s % ' ) ; foreach ( $ finder as $ file ) { $ progress Bar - > advance ( ) ; $ this - > parser - > do Compile ( $ file - > get Real Path ( ) , $ this - > html - > get Cache Path ( $ file - > get Real Path ( ) ) ) ; } $ progress Bar - > finish ( ) ; $ this - > line ( ' ' ) ; } 
protected function composer Paths ( ) : array { $ path = $ this - > app - > path ( ) . ' /composer .json ' ; if ( ! is _file ( $ path ) ) { return [ ] ; } $ options = $ this - > get File Content ( $ path ) ; $ paths = ! empty ( $ options [ 'extra ' ] [ 'leevel -console ' ] [ 'view -cache ' ] [ 'paths ' ] ) ? $ options [ 'extra ' ] [ 'leevel -console ' ] [ 'view -cache ' ] [ 'paths ' ] : [ ] ; $ path = $ this - > app - > path ( ) ; $ paths = array _map ( function ( string $ value ) use ( $ path ) { if ( ! is _file ( $ value ) ) { $ value = $ path . ' / ' . $ value ; } if ( ! is _dir ( $ value ) ) { throw new Runtime Exception ( sprintf ( 'View dir %s is not exist . ' , $ value ) ) ; } return $ value ; } , $ paths ) ; return $ paths ; } 
public function status ( IServer $ server ) : void { 
public function header ( ) : array { return [ 'X -Rate Limit -Time ' = > $ this - > time , 
protected function save Data ( int $ count ) : void { $ this - > cache - > set ( $ this - > get Key ( ) , $ this - > get Implode Data ( $ this - > end Time ( ) , $ count ) ) ; } 
protected function get Data ( ) : array { if ( ( $ data = $ this - > cache - > get ( $ this - > get Key ( ) ) ) ) { $ data = $ this - > get Explode Data ( $ data ) ; } else { $ data = [ $ this - > get Init End Time ( ) , $ this - > get Init Count ( ) , ] ; } return $ data ; } 
protected function get Explode Data ( string $ data ) : array { return array _map ( function ( $ v ) { return ( int ) ( $ v ) ; } , explode ( static : : SEPARATE , $ data ) ) ; } 
public static function dump ( $ var , . . . $ more Vars ) { Var Dumper : : dump ( $ var ) ; foreach ( $ more Vars as $ var ) { Var Dumper : : dump ( $ var ) ; } if ( 1 < func _num _args ( ) ) { return func _get _args ( ) ; } return $ var ; } 
public static function dump Road Runner ( $ var , . . . $ more Vars ) { static $ dumper ; if ( null = = = $ dumper ) { $ dumper = new Debug \ Dumper ( ) ; $ dumper - > set Renderer ( Debug \ Dumper : : ERROR _LOG , new Debug \ Renderer \ Console Renderer ( ) ) ; } $ dumper - > dump ( $ var , Debug \ Dumper : : ERROR _LOG ) ; foreach ( $ more Vars as $ var ) { $ dumper - > dump ( $ var ) ; } if ( 1 < func _num _args ( ) ) { return func _get _args ( ) ; } return $ var ; } 
public function handle ( IApp $ app , IOption $ option ) : void { $ input = [ 'path ' = > $ this - > path ( ) , 'testsdir ' = > $ app - > path ( 'vendor /hunzhiwange /framework /tests ' ) , 'outputdir ' = > $ option - > get ( 'console \ \framework _doc _outputdir ' ) , ] ; $ this - > call ( 'make :doc ' , $ input ) ; } 
public function set ( string $ name , $ data , ? int $ expire = null ) : void { if ( $ expire ) { $ this - > handle - > setex ( $ name , $ expire , $ data ) ; } else { $ this - > handle - > set ( $ name , $ data ) ; } } 
public function make Transport ( ) { $ transport = new Swift _Smtp Transport ( $ this - > option [ 'host ' ] , $ this - > option [ 'port ' ] ) ; if ( null ! = = $ this - > option [ 'encryption ' ] ) { $ transport - > set Encryption ( $ this - > option [ 'encryption ' ] ) ; } if ( null ! = = $ this - > option [ 'username ' ] ) { $ transport - > set Username ( $ this - > option [ 'username ' ] ) ; $ transport - > set Password ( $ this - > option [ 'password ' ] ) ; } return $ transport ; } 
public function match Pre Load ( array $ entitys , Collection $ result , string $ relation ) : array { return $ this - > match Pre Load One Or Many ( $ entitys , $ result , $ relation , 'one ' ) ; } 
public function handle ( IApp $ app ) : void { $ this - > app = $ app ; $ this - > line ( 'Start to cache autoload . ' ) ; if ( false = = = $ this - > ignore ( ) ) { $ this - > line ( 'Exec composer dump -autoload -o . ' ) ; exec ( $ this - > normalize Composer Command ( ) ) ; } $ data = $ this - > data ( ) ; $ cache Path = $ this - > autoload Cached Path ( ) ; $ this - > write Cache ( $ cache Path , $ data ) ; $ this - > info ( sprintf ( 'Autoload file %s cache successed . ' , $ cache Path ) ) ; } 
protected function data ( ) : string { $ data = [ ] ; $ data [ ] = $ this - > replace Include File ( file _get _contents ( $ this - > app - > path ( 'vendor /composer /Class Loader .php ' ) ) ) ; $ data [ ] = $ this - > replace Composer Path ( $ this - > data Init ( ) ) ; $ data [ ] = $ this - > data Helper ( ) ; $ data [ ] = $ this - > data Loader ( ) ; unlink ( $ this - > app - > path ( 'vendor /composer /Composer Static Init .php ' ) ) ; return implode ( PHP _EOL . PHP _EOL , $ data ) . PHP _EOL ; } 
protected function data Init ( ) : string { list ( $ lengths , $ prefixs ) = $ this - > prefixes Psr 4 ( ) ; return ' / * * * Define the root path . * / define ( \ 'LEEVEL _COMPOSER \ ' , _ _DIR _ _ . \ ' /composer \ ' ) ; / * * * generated by `php leevel autoload ` . * / class Composer Static Init { public static $files = ' . var _export ( $ this - > files ( ) , true ) . ' ; public static $prefix Lengths Psr 4 = ' . var _export ( $ lengths , true ) . ' ; public static $prefix Dirs Psr 4 = ' . var _export ( $ prefixs , true ) . ' ; public static $prefixes Psr 0 = [ ] ; public static $class Map = ' . var _export ( $ this - > class Map ( ) , true ) . ' ; public static function get Initializer (Class Loader $loader ) { return \Closure : :bind (function ( ) use ( $loader ) { $loader - >prefix Lengths Psr 4 = Composer Static Init : : $prefix Lengths Psr 4 ; $loader - >prefix Dirs Psr 4 = Composer Static Init : : $prefix Dirs Psr 4 ; $loader - >prefixes Psr 0 = Composer Static Init : : $prefixes Psr 0 ; $loader - >class Map = Composer Static Init : : $class Map ; } , null , Class Loader : :class ) ; } } ' ; } 
protected function data Helper ( ) : string { $ autoload Files = [ ] ; foreach ( $ this - > files ( ) as $ file ) { foreach ( $ this - > app Helpers ( ) as $ white File ) { if ( false ! = = strpos ( $ file , $ white File ) ) { $ autoload Files [ ] = "require _once ' " . $ this - > replace Composer Path ( $ file ) . " ' ; " ; } } } $ autoload Files = $ this - > replace Composer Path ( implode ( PHP _EOL , $ autoload Files ) ) ; return < < <eot foreach (Composer Static Init : : \ $files as \ $file Identifier = > \ $ _ ) { \ $GLOBALS [ ' _ _composer _autoload _files ' ] [ \ $file Identifier ] = true ; } { $autoload Files } eot ; } 
protected function prefixes Psr 4 ( ) : array { $ lengths = $ prefixs = [ ] ; $ composer Static Class = $ this - > composer Static Class ( ) ; $ prefixes Psr 4 = $ composer Static Class : : $ prefix Dirs Psr 4 ; foreach ( $ this - > optimize Namespaces ( ) as $ prefix ) { $ first = $ prefix [ 0 ] ; $ prefix . = ' \ \ ' ; $ lengths [ $ first ] [ $ prefix ] = strlen ( $ prefix ) ; if ( isset ( $ prefixes Psr 4 [ $ prefix ] ) ) { $ prefixs [ $ prefix ] = $ prefixes Psr 4 [ $ prefix ] ; } } return [ $ lengths , $ prefixs ] ; } 
protected function class Map ( ) : array { $ result = [ ] ; $ optimize Namespaces = $ this - > optimize Namespaces ( ) ; $ composer Static Class = $ this - > composer Static Class ( ) ; $ class Map = $ composer Static Class : : $ class Map ; foreach ( $ class Map as $ key = > $ value ) { list ( $ namespace ) = explode ( ' \ \ ' , $ key ) ; if ( in _array ( $ namespace , $ optimize Namespaces , true ) ) { $ result [ $ key ] = $ value ; } } return $ result ; } 
protected function composer Static Class ( ) : string { static $ static Class ; if ( $ static Class ) { return $ static Class ; } $ content = file _get _contents ( $ this - > app - > path ( 'vendor /autoload .php ' ) ) ; if ( preg _match ( ' /Composer Autoloader Init ( \S { 3 2 } ) : :get Loader / ' , $ content , $ matches ) ) { $ static Content = file _get _contents ( $ this - > app - > path ( 'vendor /composer /autoload _static .php ' ) ) ; file _put _contents ( $ static Path = $ this - > app - > path ( 'vendor /composer /Composer Static Init .php ' ) , str _replace ( 'Composer Static Init ' . $ matches [ 1 ] , 'Composer Static Init ' , $ static Content ) ) ; $ this - > composer Hash = $ matches [ 1 ] ; include $ static Path ; return $ static Class = ' \ \Composer \ \Autoload \ \Composer Static Init ' ; } throw new Invalid Argument Exception ( 'Composer autoload is invalid . ' ) ; } 
protected function app Namespaces ( ) : array { $ path = $ this - > app - > path ( ) . ' /composer .json ' ; if ( ! is _file ( $ path ) ) { return [ ] ; } $ options = $ this - > get File Content ( $ path ) ; $ app Namespaces = $ options [ 'autoload ' ] [ 'psr - 4 ' ] ? ? [ ] ; if ( $ app Namespaces ) { $ app Namespaces = array _map ( function ( string $ value ) { return rtrim ( $ value , ' \ \ ' ) ; } , array _keys ( $ app Namespaces ) ) ; } $ extra Namespaces = $ options [ 'extra ' ] [ 'leevel -console ' ] [ 'autoload ' ] [ 'namespaces ' ] ? ? [ ] ; return array _merge ( $ app Namespaces , $ extra Namespaces ) ; } 
protected function app Helpers ( ) : array { $ path = $ this - > app - > path ( ) . ' /composer .json ' ; if ( ! is _file ( $ path ) ) { return [ ] ; } $ options = $ this - > get File Content ( $ path ) ; return $ options [ 'extra ' ] [ 'leevel -console ' ] [ 'autoload ' ] [ 'files ' ] ? ? [ ] ; } 
public function handle ( IRouter $ router ) : void { 
protected function normalize Action ( string $ action ) : string { if ( false ! = = strpos ( $ action , ' - ' ) ) { $ action = str _replace ( ' - ' , ' _ ' , $ action ) ; } if ( false ! = = strpos ( $ action , ' _ ' ) ) { $ action = ' _ ' . str _replace ( ' _ ' , ' ' , $ action ) ; $ action = ltrim ( str _replace ( ' ' , ' ' , ucwords ( $ action ) ) , ' _ ' ) ; } return $ action ; } 
public function send ( array $ passed ) : IPipeline { foreach ( $ passed as $ item ) { $ this - > passed [ ] = $ item ; } return $ this ; } 
public function through ( array $ stage ) : IPipeline { foreach ( $ stage as $ item ) { $ this - > stage [ ] = $ item ; } return $ this ; } 
public function then ( Closure $ end = null ) { $ stage = $ this - > stage ; if ( $ end ) { $ stage [ ] = $ end ; } $ this - > generator = $ this - > stage Generator ( $ stage ) ; return $ this - > traverse Generator ( . . . $ this - > passed ) ; } 
protected function traverse Generator ( . . . $ args ) { if ( ! $ this - > generator - > valid ( ) | | $ this - > generator - > next ( ) | | ! $ this - > generator - > valid ( ) ) { return ; } array _unshift ( $ args , function ( . . . $ args ) { return $ this - > traverse Generator ( . . . $ args ) ; } ) ; $ current = $ this - > generator - > current ( ) ; 
protected function stage Generator ( array $ stage ) : Generator { array _unshift ( $ stage , null ) ; foreach ( $ stage as $ item ) { yield $ this - > stage Callback ( $ item ) ; } } 
protected function stage Callback ( $ stages ) { if ( null = = = $ stages ) { return ; } if ( is _callable ( $ stages ) ) { return $ stages ; } list ( $ stage , $ params ) = $ this - > parse ( $ stages ) ; if ( false ! = = strpos ( $ stage , ' @ ' ) ) { list ( $ stage , $ method ) = explode ( ' @ ' , $ stage ) ; } else { $ method = 'handle ' ; } if ( ! is _object ( $ stage = $ this - > container - > make ( $ stage ) ) ) { throw new Invalid Argument Exception ( 'Stage is invalid . ' ) ; } return [ $ stage , $ method , $ params ] ; } 
protected function parse ( string $ stage ) : array { list ( $ name , $ args ) = array _pad ( explode ( ' : ' , $ stage , 2 ) , 2 , [ ] ) ; if ( is _string ( $ args ) ) { $ args = explode ( ' , ' , $ args ) ; } $ args = array _map ( function ( string $ item ) { return ctype _digit ( $ item ) ? ( int ) $ item : $ item ; } , $ args ) ; return [ $ name , $ args ] ; } 
public function pdo ( $ master = false ) { if ( is _bool ( $ master ) ) { if ( false = = = $ master ) { return $ this - > read Connect ( ) ; } return $ this - > write Connect ( ) ; } return $ this - > connects [ $ master ] ? ? null ; } 
public function query ( string $ sql , array $ bind Params = [ ] , $ master = false , ? int $ fetch Style = null , $ fetch Argument = null , array $ ctor Args = [ ] ) { $ this - > init Select ( ) ; $ this - > set Last Sql ( $ sql , $ bind Params ) ; if ( ! in _array ( ( $ sql Type = $ this - > normalize Sql Type ( $ sql ) ) , [ 'select ' , 'procedure ' , ] , true ) ) { throw new Invalid Argument Exception ( 'The query method only allows select and procedure SQL statements . ' ) ; } $ this - > pdo Statement = $ this - > pdo ( $ master ) - > prepare ( $ sql ) ; $ this - > bind Params ( $ bind Params ) ; try { $ this - > pdo Statement - > execute ( ) ; $ this - > reconnect Retry = 0 ; } catch ( PDOException $ e ) { if ( $ this - > need Reconnect ( $ e ) ) { $ this - > reconnect Retry + + ; $ this - > close ( ) ; return self : : query ( $ sql , $ bind Params , $ master , $ fetch Style , $ fetch Argument , $ ctor Args ) ; } throw $ e ; } $ this - > num Rows = $ this - > pdo Statement - > row Count ( ) ; return $ this - > fetch Result ( $ fetch Style , $ fetch Argument , $ ctor Args , 'procedure ' = = = $ sql Type ) ; } 
public function execute ( string $ sql , array $ bind Params = [ ] ) { $ this - > init Select ( ) ; $ this - > set Last Sql ( $ sql , $ bind Params ) ; if ( in _array ( ( $ sql Type = $ this - > normalize Sql Type ( $ sql ) ) , [ 'select ' , 'procedure ' , ] , true ) ) { throw new Invalid Argument Exception ( 'The query method not allows select and procedure SQL statements . ' ) ; } $ this - > pdo Statement = $ this - > pdo ( true ) - > prepare ( $ sql ) ; $ this - > bind Params ( $ bind Params ) ; try { $ this - > pdo Statement - > execute ( ) ; $ this - > reconnect Retry = 0 ; } catch ( PDOException $ e ) { if ( $ this - > need Reconnect ( $ e ) ) { $ this - > reconnect Retry + + ; $ this - > close ( ) ; return self : : execute ( $ sql , $ bind Params ) ; } $ this - > pdo Exception ( $ e ) ; } $ this - > num Rows = $ this - > pdo Statement - > row Count ( ) ; if ( in _array ( $ sql Type , [ 'insert ' , 'replace ' , ] , true ) ) { return $ this - > last Insert Id ( ) ; } return $ this - > num Rows ; } 
public function transaction ( Closure $ action ) { $ this - > begin Transaction ( ) ; try { $ result = call _user _func _array ( $ action , [ $ this , ] ) ; $ this - > commit ( ) ; return $ result ; } catch ( Throwable $ e ) { $ this - > roll Back ( ) ; throw $ e ; } } 
public function begin Transaction ( ) : void { $ this - > transaction Level + + ; if ( 1 = = = $ this - > transaction Level ) { try { 
public function commit ( ) : void { if ( 0 = = = $ this - > transaction Level ) { throw new Invalid Argument Exception ( 'There was no active transaction . ' ) ; } if ( $ this - > is Rollback Only ) { throw new Invalid Argument Exception ( 'Commit failed for rollback only . ' ) ; } if ( 1 = = = $ this - > transaction Level ) { $ this - > pdo ( true ) - > commit ( ) ; } elseif ( $ this - > transaction Level > 1 & & $ this - > has Savepoints ( ) ) { $ this - > release Savepoint ( $ this - > get Savepoint Name ( ) ) ; } $ this - > transaction Level = max ( 0 , $ this - > transaction Level - 1 ) ; } 
public function roll Back ( ) : void { if ( 0 = = = $ this - > transaction Level ) { throw new Invalid Argument Exception ( 'There was no active transaction . ' ) ; } if ( 1 = = = $ this - > transaction Level ) { $ this - > transaction Level = 0 ; $ this - > pdo ( true ) - > roll Back ( ) ; $ this - > is Rollback Only = false ; } elseif ( $ this - > transaction Level > 1 & & $ this - > has Savepoints ( ) ) { $ this - > rollback Savepoint ( $ this - > get Savepoint Name ( ) ) ; $ this - > transaction Level - - ; } else { $ this - > is Rollback Only = true ; $ this - > transaction Level = max ( 0 , $ this - > transaction Level - 1 ) ; } } 
public function normalize Expression ( string $ sql , string $ table Name ) : string { preg _match _all ( ' / \ [ [a -z ] [a -z 0 - 9 _ \ . ] * \ ] | \ [ \ * \ ] /i ' , $ sql , $ matches , PREG _OFFSET _CAPTURE ) ; $ matches = reset ( $ matches ) ; $ out = ' ' ; $ offset = 0 ; foreach ( $ matches as $ value ) { $ length = strlen ( $ value [ 0 ] ) ; $ field = substr ( $ value [ 0 ] , 1 , $ length - 2 ) ; $ tmp = explode ( ' . ' , $ field ) ; switch ( count ( $ tmp ) ) { case 2 : $ field = $ tmp [ 1 ] ; $ table = $ tmp [ 0 ] ; break ; default : $ field = $ tmp [ 0 ] ; $ table = $ table Name ; } $ field = $ this - > normalize Table Or Column ( " { $table } . { $field } " ) ; $ out . = substr ( $ sql , $ offset , $ value [ 1 ] - $ offset ) . $ field ; $ offset = $ value [ 1 ] + $ length ; } $ out . = substr ( $ sql , $ offset ) ; return $ out ; } 
public function normalize Table Or Column ( string $ name , ? string $ alias = null , ? string $ as = null ) : string { $ name = str _replace ( ' ` ' , ' ' , $ name ) ; if ( false = = = strpos ( $ name , ' . ' ) ) { $ name = $ this - > identifier Column ( $ name ) ; } else { $ tmp = explode ( ' . ' , $ name ) ; foreach ( $ tmp as $ offset = > $ name ) { if ( empty ( $ name ) ) { unset ( $ tmp [ $ offset ] ) ; } else { $ tmp [ $ offset ] = $ this - > identifier Column ( $ name ) ; } } $ name = implode ( ' . ' , $ tmp ) ; } if ( $ alias ) { return " { $name } " . ( $ as ? $ as . ' ' : ' ' ) . $ this - > identifier Column ( $ alias ) ; } return $ name ; } 
public function normalize Column Value ( $ value , bool $ quotation Mark = true ) { if ( is _int ( $ value ) ) { return $ value ; } if ( is _bool ( $ value ) ) { return $ value ; } if ( null = = = $ value ) { return ; } $ value = trim ( $ value ) ; 
public function normalize Sql Type ( string $ sql ) : string { $ sql = trim ( $ sql ) ; foreach ( [ 'select ' , 'show ' , 'call ' , 'exec ' , 'delete ' , 'insert ' , 'replace ' , 'update ' , ] as $ value ) { if ( 0 = = = stripos ( $ sql , $ value ) ) { if ( 'show ' = = = $ value ) { $ value = 'select ' ; } elseif ( in _array ( $ value , [ 'call ' , 'exec ' ] , true ) ) { $ value = 'procedure ' ; } return $ value ; } } return 'statement ' ; } 
public function normalize Bind Param Type ( $ value ) : int { switch ( true ) { case is _int ( $ value ) : return PDO : : PARAM _INT ; break ; case is _bool ( $ value ) : return PDO : : PARAM _BOOL ; break ; case null = = = $ value : return PDO : : PARAM _NULL ; break ; case is _string ( $ value ) : return PDO : : PARAM _STR ; break ; default : return PDO : : PARAM _STMT ; break ; } } 
protected function write Connect ( ) : PDO { return $ this - > connect = $ this - > common Connect ( $ this - > option [ 'master ' ] , IConnect : : MASTER , true ) ; } 
protected function read Connect ( ) : PDO { if ( false = = = $ this - > option [ 'distributed ' ] | | empty ( $ this - > option [ 'slave ' ] ) ) { return $ this - > write Connect ( ) ; } if ( count ( $ this - > connects ) < = 1 ) { foreach ( $ this - > option [ 'slave ' ] as $ read ) { $ this - > common Connect ( $ read , null ) ; } if ( 0 = = = count ( $ this - > connects ) ) { return $ this - > write Connect ( ) ; } } $ connects = $ this - > connects ; if ( true = = = $ this - > option [ 'separate ' ] & & isset ( $ connects [ IConnect : : MASTER ] ) ) { unset ( $ connects [ IConnect : : MASTER ] ) ; } if ( ! $ connects ) { return $ this - > write Connect ( ) ; } $ connects = array _values ( $ connects ) ; if ( 1 = = = count ( $ connects ) ) { return $ connects [ 0 ] ; } return $ this - > connect = $ connects [ floor ( mt _rand ( 0 , count ( $ connects ) - 1 ) ) ] ; } 
protected function common Connect ( array $ option = [ ] , ? int $ linkid = null , bool $ throw Exception = false ) { if ( null = = = $ linkid ) { $ linkid = count ( $ this - > connects ) ; } if ( ! empty ( $ this - > connects [ $ linkid ] ) ) { return $ this - > connects [ $ linkid ] ; } try { $ connect = $ this - > connects [ $ linkid ] = new PDO ( $ this - > parse Dsn ( $ option ) , $ option [ 'user ' ] , $ option [ 'password ' ] , $ option [ 'options ' ] ) ; $ connect - > set Attribute ( PDO : : ATTR _ERRMODE , PDO : : ERRMODE _EXCEPTION ) ; return $ connect ; } catch ( PDOException $ e ) { if ( false = = = $ throw Exception ) { return false ; } throw $ e ; } } 
protected function bind Params ( array $ bind Params = [ ] ) : void { foreach ( $ bind Params as $ key = > $ val ) { $ key = is _numeric ( $ key ) ? $ key + 1 : ' : ' . $ key ; if ( is _array ( $ val ) ) { $ param = $ val [ 1 ] ; $ val = $ val [ 0 ] ; } else { $ param = PDO : : PARAM _STR ; } $ this - > pdo Statement - > bind Value ( $ key , $ val , $ param ) ; } } 
protected function fetch Result ( ? int $ fetch Style = null , $ fetch Argument = null , array $ ctor Args = [ ] , bool $ procedure = false ) : array { if ( $ procedure ) { return $ this - > fetch Procedure Result ( $ fetch Style , $ fetch Argument , $ ctor Args ) ; } if ( null = = = $ fetch Style ) { $ fetch Style = PDO : : FETCH _OBJ ; } $ args = [ $ fetch Style ] ; if ( $ fetch Argument ) { $ args [ ] = $ fetch Argument ; if ( $ ctor Args ) { $ args [ ] = $ ctor Args ; } } return $ this - > pdo Statement - > fetch All ( . . . $ args ) ; } 
protected function fetch Procedure Result ( ? int $ fetch Style = null , $ fetch Argument = null , array $ ctor Args = [ ] ) : array { $ result = [ ] ; do { try { $ result [ ] = $ tim = $ this - > fetch Result ( $ fetch Style , $ fetch Argument , $ ctor Args ) ; } catch ( PDOException $ e ) { } } while ( $ this - > pdo Statement - > next Rowset ( ) ) ; return $ result ; } 
protected function set Last Sql ( string $ sql , array $ bind Params = [ ] ) : void { $ this - > sql = $ sql ; $ this - > bind Params = $ bind Params ; $ this - > handle Dispatch ( $ sql , $ bind Params ) ; } 
protected function handle Dispatch ( string $ sql , array $ bind Params = [ ] ) : void { if ( $ this - > dispatch ) { $ this - > dispatch - > handle ( IConnect : : SQL _EVENT , $ sql , $ bind Params ) ; } } 
protected function create Savepoint ( string $ savepoint Name ) : void { $ this - > set Last Sql ( $ sql = 'SAVEPOINT ' . $ savepoint Name ) ; $ this - > pdo ( true ) - > exec ( $ sql ) ; } 
protected function rollback Savepoint ( string $ savepoint Name ) { $ this - > set Last Sql ( $ sql = 'ROLLBACK TO SAVEPOINT ' . $ savepoint Name ) ; $ this - > pdo ( true ) - > exec ( $ sql ) ; } 
protected function need Reconnect ( PDOException $ e ) : bool { 
protected function pdo Exception ( PDOException $ e ) : void { $ message = $ e - > get Message ( ) ; 
public function encrypt ( string $ value , int $ expiry = 0 ) : string { $ iv = $ this - > create Iv ( ) ; $ value = $ this - > pack Data ( $ value , $ expiry , $ iv ) ; return $ this - > encrypt Data ( $ value , $ iv ) ; } 
public function decrypt ( string $ value ) : string { if ( false = = = ( $ value = $ this - > decrypt Data ( $ value ) ) ) { return ' ' ; } list ( $ data , $ iv ) = $ value ; return $ this - > validate Data ( $ data , $ iv ) ; } 
protected function pack Data ( string $ value , int $ expiry , string $ iv ) : string { $ data = [ $ this - > normalize Expiry ( $ expiry ) , base 6 4 _encode ( $ value ) , base 6 4 _encode ( $ iv ) , $ this - > normalize Sign ( $ value ) , ] ; return implode ( " \t " , $ data ) ; } 
protected function unpack Data ( string $ value ) { $ data = explode ( " \t " , $ value ) ; if ( 4 ! = = count ( $ data ) ) { return false ; } $ key = [ 'expiry ' , 'value ' , 'iv ' , 'sign ' ] ; return array _combine ( $ key , $ data ) ; } 
protected function encrypt Data ( string $ value , string $ iv ) : string { $ value = openssl _encrypt ( $ value , $ this - > cipher , $ this - > key , OPENSSL _RAW _DATA , $ iv ) ; if ( false = = = $ value ) { throw new Invalid Argument Exception ( 'Encrypt the data failed . ' ) ; 
protected function decrypt Data ( string $ value ) { if ( false = = = ( $ value = base 6 4 _decode ( $ value , true ) ) ) { return false ; } if ( false = = = ( $ value = $ this - > unpack Data With Iv ( $ value ) ) ) { return false ; } $ data = openssl _decrypt ( $ value [ 'value ' ] , $ this - > cipher , $ this - > key , OPENSSL _RAW _DATA , $ value [ 'iv ' ] ) ; if ( false = = = $ data ) { throw new Invalid Argument Exception ( 'Decrypt the data failed . ' ) ; } return [ $ data , base 6 4 _encode ( $ value [ 'iv ' ] ) ] ; } 
protected function pack Data With Iv ( string $ value , string $ iv ) : string { return base 6 4 _encode ( base 6 4 _encode ( $ value ) . " \t " . base 6 4 _encode ( $ iv ) ) ; } 
protected function unpack Data With Iv ( string $ value ) { $ data = explode ( " \t " , $ value ) ; if ( 2 ! = = count ( $ data ) ) { return false ; } $ key = [ 'value ' , 'iv ' ] ; $ data [ 0 ] = base 6 4 _decode ( $ data [ 0 ] , true ) ; $ data [ 1 ] = base 6 4 _decode ( $ data [ 1 ] , true ) ; return array _combine ( $ key , $ data ) ; } 
protected function normalize Sign ( string $ value ) : string { if ( ! $ this - > rsa Private ) { return ' ' ; } try { $ rsa Private = openssl _pkey _get _private ( $ this - > rsa Private ) ; if ( openssl _sign ( $ value , $ sign , $ rsa Private ) ) { return base 6 4 _encode ( $ sign ) ; } 
protected function validate Cipher ( string $ cipher ) : void { if ( ! in _array ( $ cipher , openssl _get _cipher _methods ( ) , true ) ) { $ e = sprintf ( 'Encrypt cipher ` %s ` was not found . ' , $ cipher ) ; throw new Invalid Argument Exception ( $ e ) ; } } 
protected function validate Data ( string $ data , string $ iv ) : string { if ( false = = = ( $ data = $ this - > unpack Data ( $ data ) ) ) { return ' ' ; } if ( $ data [ 'iv ' ] ! = = $ iv | | ( ' 0 0 0 0 0 0 0 0 0 0 ' ! = = $ data [ 'expiry ' ] & & time ( ) > $ data [ 'expiry ' ] ) ) { return ' ' ; } $ result = base 6 4 _decode ( $ data [ 'value ' ] , true ) ? : false ; if ( false = = = $ result ) { return ' ' ; } return $ this - > validate Sign ( $ result , $ data [ 'sign ' ] ) ; } 
protected function validate Sign ( string $ value , string $ sign ) : string { if ( ! $ this - > rsa Public ) { return $ value ; } try { $ rsa Public = openssl _pkey _get _public ( $ this - > rsa Public ) ; if ( 1 = = = openssl _verify ( $ value , base 6 4 _decode ( $ sign , true ) , $ rsa Public ) ) { return $ value ; } 
protected function set Router And Request ( IRouter $ router , IRequest $ request ) : void { $ this - > request = $ request ; $ this - > router = $ router ; } 
protected function matche Path Info ( ) : string { $ path Info = $ this - > get Path Info ( ) ; 
protected function matche Base Paths ( string $ path Info ) : array { $ middlewares = [ ] ; foreach ( $ this - > router - > get Base Paths ( ) as $ item = > $ option ) { if ( ' * ' = = = $ item ) { if ( isset ( $ option [ 'middlewares ' ] ) ) { $ middlewares = $ option [ 'middlewares ' ] ; } } elseif ( preg _match ( $ item , $ path Info , $ matches ) ) { if ( isset ( $ option [ 'middlewares ' ] ) ) { $ middlewares = $ this - > merge Middlewares ( $ middlewares , $ option [ 'middlewares ' ] ) ; } break ; } } return $ middlewares ; } 
protected function matche Group Paths ( string $ path Info , array $ middlewares ) : array { foreach ( $ this - > router - > get Group Paths ( ) as $ item = > $ option ) { if ( 0 = = = strpos ( $ path Info , $ item ) ) { $ path Info = substr ( $ path Info , strlen ( $ item ) ) ; if ( isset ( $ option [ 'middlewares ' ] ) ) { $ middlewares = $ this - > merge Middlewares ( $ middlewares , $ option [ 'middlewares ' ] ) ; } break ; } } return [ $ path Info , $ middlewares ] ; } 
public function dispatch ( IRequest $ request ) : IResponse { $ this - > request = $ request ; return $ this - > dispatch To Route ( $ request ) ; } 
public function set Pre Request Matched ( IRequest $ request , array $ matched Data ) : void { $ this - > pre Request Matched [ spl _object _id ( $ request ) ] = $ matched Data ; } 
public function through Middleware ( IRequest $ passed , array $ passed Extend = [ ] ) : void { $ method = ! $ passed Extend ? 'handle ' : 'terminate ' ; $ middlewares = $ this - > matched Middlewares ( ) ; if ( empty ( $ middlewares [ $ method ] ) ) { return ; } ( new Pipeline ( $ this - > container ) ) - > send ( [ $ passed ] ) - > send ( $ passed Extend ) - > through ( $ middlewares [ $ method ] ) - > then ( ) ; } 
public function set Controller Dir ( string $ controller Dir ) : void { $ controller Dir = str _replace ( ' / ' , ' \ \ ' , $ controller Dir ) ; $ this - > controller Dir = $ controller Dir ; } 
public function merge Middlewares ( array $ middlewares , array $ new Middlewares ) : array { return [ 'handle ' = > array _unique ( array _merge ( $ middlewares [ 'handle ' ] ? ? [ ] , $ new Middlewares [ 'handle ' ] ? ? [ ] ) ) , 'terminate ' = > array _unique ( array _merge ( $ middlewares [ 'terminate ' ] ? ? [ ] , $ new Middlewares [ 'terminate ' ] ? ? [ ] ) ) , ] ; } 
protected function match Router ( ) { $ this - > init Request ( ) ; $ this - > resolve Matched Data ( $ data Path Info = $ this - > normalize Matched Data ( 'Path Info ' ) ) ; if ( false = = = ( $ bind = $ this - > normalize Router Bind ( ) ) ) { $ bind = $ this - > annotation Router Bind ( $ data Path Info ) ; } return $ bind ; } 
protected function annotation Router Bind ( array $ data Path Info ) { $ data = $ this - > normalize Matched Data ( 'Annotation ' ) ; if ( ! $ data ) { $ data = $ data Path Info ; } else { $ this - > init Request ( ) ; } $ this - > resolve Matched Data ( $ data ) ; return $ this - > find Router Bind ( ) ; } 
protected function resolve Matched Data ( array $ data ) : void { $ data = $ this - > merge Matched Data ( $ data , $ this - > pre Request Matched [ spl _object _id ( $ this - > request ) ] ? ? [ ] ) ; if ( ! $ data [ IRouter : : APP ] ) { $ data [ IRouter : : APP ] = self : : DEFAULT _APP ; } $ this - > matched Data = $ data ; } 
protected function merge Matched Data ( array $ before , array $ after ) : array { $ result = [ ] ; foreach ( self : : MATCHED as $ key ) { if ( self : : MIDDLEWARES = = = $ key ) { $ result [ $ key ] = $ this - > merge Middlewares ( $ before [ $ key ] ? ? [ ] , $ after [ $ key ] ? ? [ ] ) ; } elseif ( in _array ( $ key , [ self : : PARAMS , self : : VARS ] , true ) ) { $ result [ $ key ] = array _merge ( $ before [ $ key ] ? ? [ ] , $ after [ $ key ] ? ? [ ] ) ; } else { $ result [ $ key ] = $ after [ $ key ] ? ? $ before [ $ key ] ? ? null ; } } return $ result ; } 
protected function normalize Matched Data ( string $ matche ) : array { $ matche = _ _NAMESPACE _ _ . ' \ \Match \ \ ' . $ matche ; return ( new $ matche ( ) ) - > matche ( $ this , $ this - > request ) ; } 
protected function run Route ( IRequest $ request , callable $ bind ) : IResponse { $ this - > through Middleware ( $ this - > request ) ; $ response = $ this - > container - > call ( $ bind , $ this - > matched Vars ( ) ) ; if ( ! ( $ response instanceof IResponse ) ) { $ response = new Response ( $ response ) ; } return $ response ; } 
protected function make Router Node ( ) : string { if ( $ matched Bind = $ this - > matched Bind ( ) ) { return $ matched Bind ; } return $ this - > matched App ( ) . ' \ \ ' . $ this - > parse Controller Dir ( ) . ' \ \ ' . $ this - > matched Controller ( ) . ' : : ' . $ this - > matched Action ( ) . ' ( ) ' ; } 
protected function parse Controller Dir ( ) : string { $ result = $ this - > get Controller Dir ( ) ; if ( $ this - > matched Prefix ( ) ) { $ result . = ' \ \ ' . $ this - > matched Prefix ( ) ; } return $ result ; } 
protected function complete Request ( ) : void { $ this - > pathinfo Restful ( ) ; $ this - > container - > instance ( 'app _name ' , $ this - > matched App ( ) ) ; $ this - > request - > params - > add ( $ this - > matched Params ( ) ) ; } 
protected function pathinfo Restful ( ) : void { if ( ! empty ( $ this - > matched Data [ static : : ACTION ] ) ) { return ; } switch ( $ this - > request - > get Method ( ) ) { 
protected function parse Matched Bind ( ) { if ( $ matched Bind = $ this - > matched Bind ( ) ) { if ( false ! = = strpos ( $ matched Bind , ' @ ' ) ) { list ( $ bind Class , $ method ) = explode ( ' @ ' , $ matched Bind ) ; if ( ! class _exists ( $ bind Class ) ) { return false ; } $ controller = $ this - > container - > make ( $ bind Class ) ; } else { if ( ! class _exists ( $ matched Bind ) ) { return false ; } $ controller = $ this - > container - > make ( $ matched Bind ) ; $ method = 'handle ' ; } } else { $ matched App = $ this - > matched App ( ) ; $ matched Controller = $ this - > matched Controller ( ) ; $ matched Action = $ this - > matched Action ( ) ; 
protected function normalize For Subdir ( string $ class Name , bool $ for Action = false ) : string { if ( false = = = strpos ( $ class Name , ' : ' ) ) { return $ class Name ; } $ class Name = preg _replace _callback ( ' / : ( [a -z A -Z ] ) / ' , function ( array $ matches ) use ( $ for Action ) { return false = = = $ for Action ? ' \ \ ' . ucfirst ( $ matches [ 1 ] ) : ucfirst ( $ matches [ 1 ] ) ; } , $ class Name ) ; return str _replace ( ' \ \ \ \ ' , ' \ \ ' , $ class Name ) ; } 
protected function matched Prefix ( ) : ? string { $ prefix = $ this - > matched Data [ static : : PREFIX ] ; if ( ! $ prefix | | is _scalar ( $ prefix ) ) { return $ prefix ; } $ prefix = array _map ( function ( $ item ) { return $ this - > convert Matched ( ucfirst ( $ item ) ) ; } , $ prefix ) ; return $ this - > matched Data [ static : : PREFIX ] = implode ( ' \ \ ' , $ prefix ) ; } 
protected function convert Matched ( string $ matched ) : string { if ( false ! = = strpos ( $ matched , ' - ' ) ) { $ matched = str _replace ( ' - ' , ' _ ' , $ matched ) ; } if ( false ! = = strpos ( $ matched , ' _ ' ) ) { $ matched = ' _ ' . str _replace ( ' _ ' , ' ' , $ matched ) ; $ matched = ltrim ( str _replace ( ' ' , ' ' , ucwords ( $ matched ) ) , ' _ ' ) ; } return $ matched ; } 
public function notify ( . . . $ args ) { $ this - > notify Args = $ args ; foreach ( $ this - > observers as $ observer ) { $ observer - > update ( $ this ) ; } } 
public function register ( $ observer ) : void { if ( $ observer instanceof Closure ) { $ observer = new Observer ( $ observer ) ; } else { if ( is _string ( $ observer ) & & is _string ( $ observer = $ this - > container - > make ( $ observer ) ) ) { throw new Invalid Argument Exception ( sprintf ( 'Observer ` %s ` is invalid . ' , $ observer ) ) ; } if ( ! ( $ observer instanceof Spl Observer ) ) { if ( ! is _callable ( [ $ observer , 'handle ' ] ) ) { throw new Invalid Argument Exception ( sprintf ( 'Observer ` %s ` is invalid . ' , get _class ( $ observer ) ) ) ; } $ observer = new Observer ( Closure : : from Callable ( [ $ observer , 'handle ' ] ) ) ; } } $ this - > attach ( $ observer ) ; } 
public function create Response ( Response Interface $ psr Response ) : IResponse { $ response = new Response ( $ psr Response - > get Body ( ) - > _ _to String ( ) , $ psr Response - > get Status Code ( ) , $ psr Response - > get Headers ( ) ) ; $ response - > set Protocol Version ( $ psr Response - > get Protocol Version ( ) ) ; foreach ( $ psr Response - > get Header ( 'Set -Cookie ' ) as $ cookie ) { $ response - > set Cookie ( . . . $ this - > create Cookie ( $ cookie ) ) ; } return $ response ; } 
protected function get Files ( array $ uploaded Files , string $ parent = ' ' ) : array { $ files = [ ] ; foreach ( $ uploaded Files as $ key = > $ value ) { $ key = ( $ parent ? $ parent . ' \ \ ' : ' ' ) . $ key ; if ( $ value instanceof Uploaded File Interface ) { $ files [ $ key ] = $ this - > create Uploaded File ( $ value ) ; } else { $ files = array _merge ( $ files , $ this - > get Files ( $ value , $ key ) ) ; } } return $ files ; } 
protected function create Uploaded File ( Uploaded File Interface $ psr Uploaded File ) : Uploaded File { $ temporary Path = ' ' ; $ client File Name = ' ' ; if ( UPLOAD _ERR _NO _FILE ! = = $ psr Uploaded File - > get Error ( ) ) { $ temporary Path = $ this - > get Temporary Path ( ) ; $ psr Uploaded File - > move To ( $ temporary Path ) ; $ client File Name = $ psr Uploaded File - > get Client Filename ( ) ; } return new Uploaded File ( $ temporary Path , $ client File Name ? : ' ' , $ psr Uploaded File - > get Client Media Type ( ) , $ psr Uploaded File - > get Error ( ) ) ; } 
protected function create Cookie ( string $ cookie ) : array { foreach ( explode ( ' ; ' , $ cookie ) as $ part ) { $ part = trim ( $ part ) ; $ data = explode ( ' = ' , $ part , 2 ) ; $ name = $ data [ 0 ] ; $ value = isset ( $ data [ 1 ] ) ? trim ( $ data [ 1 ] , " \n \r \t \ 0 \x 0B \ " " ) : null ; if ( ! isset ( $ cookie Name ) ) { $ cookie Name = $ name ; $ cookie Value = $ value ; continue ; } if ( 'expires ' = = = strtolower ( $ name ) & & null ! = = $ value ) { $ cookie Expire = new Date Time ( $ value ) ; continue ; } if ( 'path ' = = = strtolower ( $ name ) & & null ! = = $ value ) { $ cookie Path = $ value ; continue ; } if ( 'domain ' = = = strtolower ( $ name ) & & null ! = = $ value ) { $ cookie Domain = $ value ; continue ; } if ( 'secure ' = = = strtolower ( $ name ) ) { $ cookie Secure = true ; continue ; } if ( 'httponly ' = = = strtolower ( $ name ) ) { $ cookie Http Only = true ; continue ; } } if ( ! isset ( $ cookie Name ) ) { throw new Invalid Argument Exception ( 'The value of the Set -Cookie header is malformed . ' ) ; } return [ $ cookie Name , $ cookie Value , [ 'expire ' = > $ cookie Expire ? ? 0 , 'path ' = > $ cookie Path ? ? ' / ' , 'domain ' = > $ cookie Domain ? ? null , 'secure ' = > isset ( $ cookie Secure ) , 'httponly ' = > isset ( $ cookie Http Only ) , ] , ] ; } 
public function handle ( Select $ select , IEntity $ entity ) : void { call _user _func ( $ this - > handle , $ select , $ entity ) ; } 
public function and ( ISpecification $ spec ) : ISpecification { return new self ( function ( IEntity $ entity ) use ( $ spec ) : bool { return $ this - > is Satisfied By ( $ entity ) & & $ spec - > is Satisfied By ( $ entity ) ; } , function ( Select $ select , IEntity $ entity ) use ( $ spec ) { $ this - > handle ( $ select , $ entity ) ; $ spec - > handle ( $ select , $ entity ) ; } ) ; } 
public function not ( ) : ISpecification { return new self ( function ( IEntity $ entity ) : bool { return ! $ this - > is Satisfied By ( $ entity ) ; } , $ this - > handle ) ; } 
public static function create ( $ file = null , int $ status = 2 0 0 , array $ headers = [ ] , ? string $ content Disposition = null , bool $ auto Etag = false , bool $ auto Last Modified = true ) : IResponse { return new static ( $ file , $ status , $ headers , $ content Disposition , $ auto Etag , $ auto Last Modified ) ; } 
public function set File ( $ file , ? string $ content Disposition = null , bool $ auto Etag = false , bool $ auto Last Modified = true ) : IResponse { if ( $ this - > check Flow Control ( ) ) { return $ this ; } if ( ! $ file instanceof File ) { if ( $ file instanceof Spl File Info | | $ file instanceof Spl File Object ) { $ file = new File ( $ file - > get Pathname ( ) ) ; } else { if ( ! is _readable ( $ file ) ) { throw new File Exception ( 'File must be readable . ' ) ; } $ file = new File ( ( string ) $ file ) ; } } if ( ! $ file - > is Readable ( ) ) { throw new File Exception ( 'File must be readable . ' ) ; } $ this - > file = $ file ; if ( $ auto Etag ) { $ this - > set Auto Etag ( ) ; } if ( $ auto Last Modified ) { $ this - > set Auto Last Modified ( ) ; } if ( $ content Disposition ) { $ this - > set Content Disposition ( $ content Disposition ) ; } return $ this ; } 
public function set Auto Last Modified ( ) : IResponse { if ( $ this - > check Flow Control ( ) ) { return $ this ; } $ this - > set Last Modified ( Date Time : : create From Format ( 'U ' , ( string ) $ this - > file - > get MTime ( ) ) ) ; return $ this ; } 
public function set Auto Etag ( ) : IResponse { if ( $ this - > check Flow Control ( ) ) { return $ this ; } $ etag = base 6 4 _encode ( hash _file ( 'sha 2 5 6 ' , $ this - > file - > get Pathname ( ) , true ) ) ; $ this - > set Etag ( $ etag ) ; return $ this ; } 
public function set Content ( $ content ) : IResponse { if ( $ this - > check Flow Control ( ) ) { return $ this ; } if ( null ! = = $ content ) { throw new Logic Exception ( 'The content cannot be set on a File Response instance . ' ) ; } return $ this ; } 
public function set Content Disposition ( string $ disposition , string $ filename = ' ' ) : IResponse { if ( $ this - > check Flow Control ( ) ) { return $ this ; } if ( ' ' = = = $ filename ) { $ filename = $ this - > file - > get Filename ( ) ; } if ( ! in _array ( $ disposition , [ Response Header Bag : : DISPOSITION _ATTACHMENT , Response Header Bag : : DISPOSITION _INLINE , ] , true ) ) { throw new Invalid Argument Exception ( 'The disposition type is invalid . ' ) ; } $ this - > headers - > set ( 'Content -Disposition ' , sprintf ( ' %s ; filename = " %s " ' , $ disposition , str _replace ( ' " ' , ' \ \ " ' , basename ( $ filename ) ) ) ) ; return $ this ; } 
public function send Content ( ) : IResponse { if ( $ this - > check Flow Control ( ) ) { return $ this ; } if ( ! $ this - > is Successful ( ) ) { return parent : : send Content ( ) ; } $ out = fopen ( 'php : / /output ' , 'w ' ) ; $ file = fopen ( $ this - > file - > get Pathname ( ) , 'r ' ) ; stream _copy _to _stream ( $ file , $ out ) ; fclose ( $ out ) ; fclose ( $ file ) ; return $ this ; } 
public function set Entity ( string $ entity ) : self { $ this - > entity = $ entity ; $ this - > message = sprintf ( 'Entity ` %s ` was not found . ' , $ entity ) ; return $ this ; } 
public function handle ( Closure $ next , IRequest $ request ) : void { $ this - > start Session ( $ request ) ; $ next ( $ request ) ; } 
public function terminate ( Closure $ next , IRequest $ request , IResponse $ response ) : void { $ this - > set Prev Url ( $ request ) ; $ this - > save Session ( ) ; if ( ! $ this - > get Session Id ( $ request ) ) { $ response - > set Cookie ( $ this - > manager - > get Name ( ) , $ this - > manager - > get Id ( ) , [ 'expire ' = > $ this - > get Session Expire ( ) ] ) ; } $ next ( $ request , $ response ) ; } 
protected function start Session ( IRequest $ request ) : void { $ this - > manager - > start ( $ this - > get Session Id ( $ request ) ) ; } 
protected function get Session Id ( IRequest $ request ) : ? string { return $ request - > cookies - > get ( $ this - > manager - > get Name ( ) , null ) ; } 
public function make ( array $ datas = [ ] , array $ rules = [ ] , array $ names = [ ] , array $ messages = [ ] ) : IValidator { $ validator = new Validator ( $ datas , $ rules , $ names , $ messages ) ; $ validator - > set Container ( $ this - > container ) ; return $ validator ; } 
public static function init Messages ( ) : void { Validator : : init Messages ( [ 'required ' = > _ _ ( ' {field } 不 能 为 空 ' ) , 'number ' = > _ _ ( ' {field } 必 须 是 数 字 ' ) , 'float ' = > _ _ ( ' {field } 必 须 是 浮 点 数 ' ) , 'double ' = > _ _ ( ' {field } 必 须 是 双 精 度 浮 点 数 ' ) , 'boolean ' = > _ _ ( ' {field } 必 须 是 布 尔 值 ' ) , 'array ' = > _ _ ( ' {field } 必 须 是 数 组 ' ) , 'accepted ' = > _ _ ( ' {field } 必 须 是 yes 、on 、true 或 者 1 ' ) , 'date ' = > _ _ ( ' {field } 不 是 正 确 的 日 期 格 式 ' ) , 'date _format ' = > _ _ ( ' {field } 必 须 使 用 日 期 格 式 {rule } ' ) , 'timezone ' = > _ _ ( ' {field } 不 是 正 确 的 时 区 ' ) , 'alpha ' = > _ _ ( ' {field } 只 能 是 字 母 ' ) , 'alpha _upper ' = > _ _ ( ' {field } 只 能 是 大 写 字 母 ' ) , 'alpha _lower ' = > _ _ ( ' {field } 只 能 是 小 写 字 母 ' ) , 'alpha _num ' = > _ _ ( ' {field } 只 能 是 字 母 和 数 字 ' ) , 'alpha _dash ' = > _ _ ( ' {field } 只 能 是 字 母 、 数 字 、 短 横 线 和 下 划 线 ' ) , 'chinese ' = > _ _ ( ' {field } 只 能 是 汉 字 ' ) , 'chinese _alpha _num ' = > _ _ ( ' {field } 只 能 是 汉 字 、 字 母 、 数 字 ' ) , 'chinese _alpha _dash ' = > _ _ ( ' {field } 只 能 是 汉 字 、 字 母 、 数 字 、 短 横 线 和 下 划 线 ' ) , 'url ' = > _ _ ( ' {field } 不 是 有 效 的 URL 地 址 ' ) , 'active _url ' = > _ _ ( ' {field } 不 是 有 效 的 域 名 或 者 IP ' ) , 'ip ' = > _ _ ( ' {field } 不 是 有 效 的 IP 地 址 ' ) , 'ipv 4 ' = > _ _ ( ' {field } 不 是 有 效 的 IPV 4 地 址 ' ) , 'ipv 6 ' = > _ _ ( ' {field } 不 是 有 效 的 IPV 6 地 址 ' ) , 'in ' = > _ _ ( ' {field } 必 须 在 {rule } 范 围 内 ' ) , 'not _in ' = > _ _ ( ' {field } 不 能 在 {rule } 范 围 内 ' ) , 'between ' = > _ _ ( ' {field } 只 能 在 {rule } 和 {rule 1 } 之 间 ， 不 包 含 等 于 ' ) , 'not _between ' = > _ _ ( ' {field } 不 在 {rule } 和 {rule 1 } 之 间 ， 不 包 含 等 于 ' ) , 'between _equal ' = > _ _ ( ' {field } 只 能 在 {rule } 和 {rule 1 } 之 间 ， 包 含 等 于 ' ) , 'not _between _equal ' = > _ _ ( ' {field } 不 在 {rule } 和 {rule 1 } 之 间 ， 包 含 等 于 ' ) , 'greater _than ' = > _ _ ( ' {field } 必 须 大 于 {rule } ' ) , 'equal _greater _than ' = > _ _ ( ' {field } 必 须 大 于 等 于 {rule } ' ) , 'less _than ' = > _ _ ( ' {field } 必 须 小 于 {rule } ' ) , 'equal _less _than ' = > _ _ ( ' {field } 必 须 小 于 等 于 {rule } ' ) , 'equal ' = > _ _ ( ' {field } 必 须 等 于 {rule } ' ) , 'not _equal ' = > _ _ ( ' {field } 不 能 等 于 {rule } ' ) , 'equal _to ' = > _ _ ( ' {field } 必 须 等 于 字 段 {rule } ' ) , 'different ' = > _ _ ( ' {field } 不 能 等 于 字 段 {rule } ' ) , 'same ' = > _ _ ( ' {field } 必 须 完 全 等 于 {rule } ' ) , 'not _same ' = > _ _ ( ' {field } 不 能 完 全 等 于 {rule } ' ) , 'empty ' = > _ _ ( ' {field } 必 须 为 空 ' ) , 'not _empty ' = > _ _ ( ' {field } 不 能 为 空 ' ) , 'null ' = > _ _ ( ' {field } 必 须 null ' ) , 'not _null ' = > _ _ ( ' {field } 不 能 为 null ' ) , 'strlen ' = > _ _ ( ' {field } 长 度 不 符 合 要 求 {rule } ' ) , 'max ' = > _ _ ( ' {field } 长 度 不 能 超 过 {rule } ' ) , 'min ' = > _ _ ( ' {field } 长 度 不 能 小 于 {rule } ' ) , 'digit ' = > _ _ ( ' {field } 字 符 串 中 的 字 符 必 须 都 是 数 字 ' ) , 'type ' = > _ _ ( ' {field } 类 型 不 符 合 要 求 {rule } ' ) , 'lower ' = > _ _ ( ' {field } 必 须 全 部 是 小 写 ' ) , 'upper ' = > _ _ ( ' {field } 必 须 全 部 是 大 写 ' ) , 'min _length ' = > _ _ ( ' {field } 不 满 足 最 小 长 度 {rule } ' ) , 'max _length ' = > _ _ ( ' {field } 不 满 足 最 大 长 度 {rule } ' ) , 'id _card ' = > _ _ ( ' {field } 必 须 是 有 效 的 中 国 大 陆 身 份 证 ' ) , 'zip _code ' = > _ _ ( ' {field } 必 须 是 有 效 的 中 国 邮 政 编 码 ' ) , 'qq ' = > _ _ ( ' {field } 必 须 是 有 效 的 QQ 号 码 ' ) , 'phone ' = > _ _ ( ' {field } 必 须 是 有 效 的 电 话 号 码 或 者 手 机 号 ' ) , 'mobile ' = > _ _ ( ' {field } 必 须 是 有 效 的 手 机 号 ' ) , 'telephone ' = > _ _ ( ' {field } 必 须 是 有 效 的 电 话 号 码 ' ) , 'email ' = > _ _ ( ' {field } 必 须 为 正 确 的 电 子 邮 件 格 式 ' ) , 'luhn ' = > _ _ ( ' {field } 必 须 为 正 确 的 符 合 luhn 格 式 算 法 银 行 卡 ' ) , 'after ' = > _ _ ( ' {field } 日 期 不 能 小 于 {rule } ' ) , 'before ' = > _ _ ( ' {field } 日 期 不 能 超 过 {rule } ' ) , 'allowed _ip ' = > _ _ ( ' {field } 不 允 许 的 IP 访 问 {rule } ' ) , 'deny _ip ' = > _ _ ( ' {field } 禁 止 的 IP 访 问 {rule } ' ) , 'json ' = > _ _ ( ' {field } 不 是 有 效 的 JSON ' ) , 'unique ' = > _ _ ( ' {field } 不 能 出 现 重 复 值 ' ) , ] ) ; } 
public function matche ( IRouter $ router , IRequest $ request ) : array { $ this - > set Router And Request ( $ router , $ request ) ; return $ this - > match Main ( ) ; } 
protected function match Main ( ) : array { 
protected function matche App ( array $ path ) : array { $ result = [ ] ; if ( $ path & & $ this - > is Find App ( $ path [ 0 ] ) ) { $ result [ IRouter : : APP ] = substr ( array _shift ( $ path ) , 1 ) ; } if ( $ restful Result = $ this - > matche Restful ( $ path ) ) { return [ array _merge ( $ result , $ restful Result ) , [ ] ] ; } if ( ! $ path ) { $ result [ IRouter : : CONTROLLER ] = IRouter : : DEFAULT _CONTROLLER ; } return [ $ result , $ path ] ; } 
protected function matche Mvc ( array $ path ) : array { $ result = [ ] ; if ( 1 = = = count ( $ path ) ) { $ result [ IRouter : : CONTROLLER ] = array _pop ( $ path ) ; } else { if ( $ path ) { $ result [ IRouter : : ACTION ] = array _pop ( $ path ) ; } if ( $ path ) { $ result [ IRouter : : CONTROLLER ] = array _pop ( $ path ) ; } if ( $ path ) { $ result [ IRouter : : PREFIX ] = $ path ; } } return $ result ; } 
protected function matche Restful ( array $ path ) : array { $ restful Path = implode ( ' / ' , $ path ) ; $ regex = ' / ^ ( \S + ) \ / ( ' . IRouter : : RESTFUL _REGEX . ' ) ( \ / * \S * ) $ / ' ; if ( preg _match ( $ regex , $ restful Path , $ matches ) ) { $ result [ IRouter : : CONTROLLER ] = $ matches [ 1 ] ; $ result [ IRouter : : PARAMS ] [ IRouter : : RESTFUL _ID ] = $ matches [ 2 ] ; if ( ' ' ! = = $ matches [ 3 ] ) { $ result [ IRouter : : ACTION ] = substr ( $ matches [ 3 ] , 1 ) ; } return $ result ; } return [ ] ; } 
protected function throttler ( ) : void { $ this - > container - > singleton ( 'throttler ' , function ( IContainer $ container ) { return ( new Throttler ( $ container [ 'caches ' ] - > connect ( $ container [ 'option ' ] [ 'throttler \ \driver ' ] ) ) ) - > set Request ( $ container [ 'request ' ] ) ; } ) ; } 
public function find ( int $ id , array $ column = [ ' * ' ] ) : IEntity { return $ this - > entity - > find ( $ id , $ column ) ; } 
public function find Or Fail ( int $ id , array $ column = [ ' * ' ] ) : IEntity { return $ this - > entity - > find Or Fail ( $ id , $ column ) ; } 
public function find All ( $ condition = null ) : Collection { $ select = $ this - > entity - > self Database Select ( ) ; if ( $ condition ) { $ this - > normalize Condition ( $ condition , $ select ) ; } return $ select - > find All ( ) ; } 
public function find List ( $ condition , $ field Value , ? string $ field Key = null ) : array { $ select = $ this - > entity - > self Database Select ( ) ; if ( $ condition ) { $ this - > normalize Condition ( $ condition , $ select ) ; } return $ select - > list ( $ field Value , $ field Key ) ; } 
public function find Count ( $ condition = null , string $ field = ' * ' ) : int { $ select = $ this - > entity - > self Database Select ( ) ; if ( $ condition ) { $ this - > normalize Condition ( $ condition , $ select ) ; } return $ select - > find Count ( $ field ) ; } 
public function find Page ( int $ current Page , int $ per Page = 1 0 , $ condition = null , bool $ flag = false , bool $ with Total = true , string $ column = ' * ' ) : array { $ select = $ this - > entity - > self Database Select ( ) ; if ( $ condition ) { $ this - > normalize Condition ( $ condition , $ select ) ; } return $ select - > page ( $ current Page , $ per Page , $ flag , $ with Total , $ column ) ; } 
public function find Page Html ( int $ current Page , int $ per Page = 1 0 , $ condition = null , bool $ flag = false , string $ column = ' * ' , array $ option = [ ] ) : array { $ select = $ this - > entity - > self Database Select ( ) ; if ( $ condition ) { $ this - > normalize Condition ( $ condition , $ select ) ; } return $ select - > page Html ( $ current Page , $ per Page , $ flag , $ column , $ option ) ; } 
public function find Page Macro ( int $ current Page , int $ per Page = 1 0 , $ condition = null , bool $ flag = false , array $ option = [ ] ) : array { $ select = $ this - > entity - > self Database Select ( ) ; if ( $ condition ) { $ this - > normalize Condition ( $ condition , $ select ) ; } return $ select - > page Macro ( $ current Page , $ per Page , $ flag , $ option ) ; } 
public function find Page Prev Next ( int $ current Page , int $ per Page = 1 0 , $ condition = null , bool $ flag = false , array $ option = [ ] ) : array { $ select = $ this - > entity - > self Database Select ( ) ; if ( $ condition ) { $ this - > normalize Condition ( $ condition , $ select ) ; } return $ select - > page Prev Next ( $ current Page , $ per Page , $ flag , $ option ) ; } 
public function condition ( $ condition ) : Select { $ select = $ this - > entity - > self Database Select ( ) ; $ this - > normalize Condition ( $ condition , $ select ) ; return $ select ; } 
protected function normalize Condition ( $ condition , Select $ select ) : void { if ( is _string ( $ condition ) ) { $ select - > scope ( $ condition ) ; } elseif ( is _object ( $ condition ) & & $ condition instanceof ISpecification ) { $ this - > normalize Spec ( $ select , $ condition ) ; } elseif ( is _object ( $ condition ) & & $ condition instanceof Closure ) { $ condition ( $ select , $ this - > entity ) ; } elseif ( is _array ( $ condition ) & & count ( $ condition ) > = 2 ) { $ tmp Condition = array _shift ( $ condition ) ; $ scope = $ condition ; $ this - > normalize Condition ( $ tmp Condition , $ select ) ; $ select - > scope ( $ scope ) ; } else { throw new Invalid Argument Exception ( 'Invalid condition type . ' ) ; } } 
protected function normalize Spec ( Select $ select , ISpecification $ spec ) : void { if ( $ spec instanceof ISpecification & & $ spec - > is Satisfied By ( $ this - > entity ) ) { $ spec - > handle ( $ select , $ this - > entity ) ; } } 
public function read ( array $ filenames ) : array { $ translations = new Translations ( ) ; foreach ( $ filenames as $ val ) { $ translations - > add From Po File ( $ val ) ; } $ result = json _decode ( $ translations - > to Json String ( ) , true ) ; $ result = $ result [ 'messages ' ] [ ' ' ] ? ? [ ] ; $ result = array _map ( function ( $ item ) { return $ item [ 0 ] ; } , $ result ) ; return $ result ; } 
public function display ( string $ file , array $ vars = [ ] , ? string $ ext = null , bool $ display = true ) { 
protected function debug ( ) : void { $ this - > container - > singleton ( 'debug ' , function ( IContainer $ container ) { return new Debug ( $ container , $ container [ 'option ' ] - > get ( 'debug \ \ ' ) ) ; } ) ; } 
public function add ( array $ elements = [ ] ) : void { foreach ( $ elements as $ key = > $ value ) { $ this - > set ( $ key , $ value ) ; } } 
public function add Relation Condition ( ) : void { if ( static : : $ relation Condition ) { $ this - > select - > join ( $ this - > middle Entity - > table ( ) , [ 'middle _ ' . $ this - > middle Target Key = > $ this - > middle Target Key , 'middle _ ' . $ this - > middle Source Key = > $ this - > middle Source Key , ] , [ $ this - > middle Target Key = > ' { [ ' . $ this - > target Entity - > table ( ) . ' . ' . $ this - > target Key . ' ] } ' , ] ) - > where ( $ this - > middle Entity - > table ( ) . ' . ' . $ this - > middle Source Key , $ this - > get Source Value ( ) ) - > as Default ( ) - > as Collection ( false ) ; } } 
public function pre Load Condition ( array $ entitys ) : void { $ this - > select - > join ( $ this - > middle Entity - > table ( ) , [ 'middle _ ' . $ this - > middle Target Key = > $ this - > middle Target Key , 'middle _ ' . $ this - > middle Source Key = > $ this - > middle Source Key , ] , [ $ this - > middle Target Key = > ' { [ ' . $ this - > target Entity - > table ( ) . ' . ' . $ this - > target Key . ' ] } ' , ] ) - > where In ( $ this - > middle Entity - > table ( ) . ' . ' . $ this - > middle Source Key , $ this - > get Pre Load Source Value ( $ entitys ) ) - > as Default ( ) - > as Collection ( false ) ; } 
public function match Pre Load ( array $ entitys , collection $ result , string $ relation ) : array { $ maps = $ this - > build Map ( $ result ) ; foreach ( $ entitys as $ entity ) { $ key = $ entity - > _ _get ( $ this - > source Key ) ; if ( isset ( $ maps [ $ key ] ) ) { $ entity - > with Relation Prop ( $ relation , $ this - > target Entity - > collection ( $ maps [ $ key ] ) ) ; } } return $ entitys ; } 
public function source Query ( ) { $ tmps = $ this - > select - > find All ( ) ; if ( ! $ tmps ) { return new Collection ( ) ; } $ result = [ ] ; $ middel Class = get _class ( $ this - > middle Entity ) ; $ target Class = get _class ( $ this - > target Entity ) ; foreach ( $ tmps as $ value ) { $ value = ( array ) $ value ; $ middle Enity = new $ middel Class ( [ $ this - > middle Source Key = > $ value [ 'middle _ ' . $ this - > middle Source Key ] , $ this - > middle Target Key = > $ value [ 'middle _ ' . $ this - > middle Target Key ] , ] ) ; unset ( $ value [ 'middle _ ' . $ this - > middle Source Key ] , $ value [ 'middle _ ' . $ this - > middle Target Key ] ) ; $ target Entity = new $ target Class ( $ value ) ; $ target Entity - > with Middle ( $ middle Enity ) ; $ result [ ] = $ target Entity ; } return new Collection ( $ result , [ $ target Class ] ) ; } 
protected function get Pre Load Source Value ( array $ entitys ) : array { $ arr = [ ] ; foreach ( $ entitys as $ source Entity ) { $ arr [ ] = $ source Entity - > _ _get ( $ this - > source Key ) ; } return $ arr ; } 
protected function build Map ( Collection $ result ) : array { $ maps = [ ] ; foreach ( $ result as $ entity ) { $ maps [ $ entity - > middle ( ) - > _ _get ( $ this - > middle Source Key ) ] [ ] = $ entity ; } return $ maps ; } 
public function parse Dsn ( array $ option ) : string { $ dsn = [ ] ; foreach ( [ 'Base ' , 'Port ' , 'Socket ' , 'Charset ' ] as $ method ) { $ dsn [ ] = $ this - > { 'parse ' . $ method } ( $ option ) ; } return implode ( ' ' , $ dsn ) ; } 
public function table Names ( string $ db Name , $ master = false ) : array { $ sql = 'SHOW TABLES FROM ' . $ this - > normalize Table Or Column ( $ db Name ) ; $ result = [ ] ; if ( ( $ tables = $ this - > query ( $ sql , [ ] , $ master , PDO : : FETCH _ASSOC ) ) ) { foreach ( $ tables as $ v ) { $ result [ ] = reset ( $ v ) ; } } unset ( $ tables , $ sql ) ; return $ result ; } 
public function table Columns ( string $ table Name , $ master = false ) : array { $ sql = 'SHOW FULL COLUMNS FROM ' . $ this - > normalize Table Or Column ( $ table Name ) ; $ result = [ 'list ' = > [ ] , 'primary _key ' = > null , 'auto _increment ' = > null , ] ; if ( ( $ columns = $ this - > query ( $ sql , [ ] , $ master , PDO : : FETCH _ASSOC ) ) ) { foreach ( $ columns as $ column ) { $ tmp = [ ] ; $ tmp [ 'name ' ] = $ column [ 'Field ' ] ; if ( preg _match ( ' / ( . + ) \ ( ( . + ) \ ) / ' , $ column [ 'Type ' ] , $ matche ) ) { $ tmp [ 'type ' ] = $ matche [ 1 ] ; $ tmp [ 'length ' ] = $ matche [ 1 ] ; } else { $ tmp [ 'type ' ] = $ column [ 'Type ' ] ; $ tmp [ 'length ' ] = null ; } $ tmp [ 'primary _key ' ] = 'pri ' = = = strtolower ( $ column [ 'Key ' ] ) ; $ tmp [ 'auto _increment ' ] = false ! = = strpos ( $ column [ 'Extra ' ] , 'auto _increment ' ) ; if ( null ! = = $ column [ 'Default ' ] & & 'null ' ! = = strtolower ( $ column [ 'Default ' ] ) ) { $ tmp [ 'default ' ] = $ column [ 'Default ' ] ; } else { $ tmp [ 'default ' ] = null ; } $ tmp [ 'comment ' ] = $ column [ 'Comment ' ] ; $ result [ 'list ' ] [ $ tmp [ 'name ' ] ] = $ tmp ; if ( $ tmp [ 'auto _increment ' ] ) { $ result [ 'auto _increment ' ] = $ tmp [ 'name ' ] ; } if ( $ tmp [ 'primary _key ' ] ) { if ( ! is _array ( $ result [ 'primary _key ' ] ) ) { $ result [ 'primary _key ' ] = [ ] ; } $ result [ 'primary _key ' ] [ ] = $ tmp [ 'name ' ] ; } } } unset ( $ columns , $ sql ) ; return $ result ; } 
public function limit Count ( ? int $ limit Count = null , ? int $ limit Offset = null ) : string { if ( null ! = = $ limit Offset ) { $ sql = 'LIMIT ' . $ limit Offset ; if ( null ! = = $ limit Count ) { $ sql . = ' , ' . $ limit Count ; } else { $ sql . = ' , 9 9 9 9 9 9 9 9 9 9 9 9 ' ; } return $ sql ; } if ( null ! = = $ limit Count ) { return 'LIMIT ' . $ limit Count ; } return ' ' ; } 
public function create ( ? string $ key = null , int $ limit = 6 0 , int $ time = 6 0 ) : IRate Limiter { $ key = $ this - > get Request Key ( $ key ) ; if ( isset ( $ this - > rate Limiter [ $ key ] ) ) { return $ this - > rate Limiter [ $ key ] - > limit ( $ limit ) - > time ( $ time ) ; } return $ this - > rate Limiter [ $ key ] = new Rate Limiter ( $ this - > cache , $ key , $ limit , $ time ) ; } 
public function get Request Key ( ? string $ key = null ) : string { if ( ! $ key & & ! $ this - > request ) { throw new Runtime Exception ( 'Request is not set . ' ) ; } return $ key ? : sha 1 ( $ this - > request - > get Client Ip ( ) . ' @ ' . $ this - > request - > get Root ( ) ) ; } 
public function handle ( IApp $ app ) : void { $ this - > app = $ app ; $ this - > line ( " <info >The Query PHP server started : < /info > <http : / / { $this - >host ( ) } : { $this - >port ( ) } > " ) ; $ this - > table ( [ 'key ' , 'value ' ] , [ [ 'php ' , $ this - > php ( ) ] , [ 'server ' , $ this - > server ( ) ] , ] ) ; passthru ( $ this - > normalize Command ( ) , $ status ) ; } 
protected function normalize Command ( ) : string { return sprintf ( ' %s -S %s : %d -t %s ' , escapeshellarg ( $ this - > php ( ) ) , $ this - > host ( ) , $ this - > port ( ) , escapeshellarg ( $ this - > server ( ) ) ) ; } 
protected function get Options ( ) : array { return [ [ 'host ' , null , Option : : VALUE _OPTIONAL , 'The host address to be listening on . ' , ' 1 2 7 . 0 . 0 . 1 ' , ] , [ 'port ' , null , Option : : VALUE _OPTIONAL , 'The port to be listening on . ' , ' 9 5 2 7 ' , ] , [ 'server ' , null , Option : : VALUE _OPTIONAL , 'The server enter . ' , null , ] , [ 'php ' , null , Option : : VALUE _OPTIONAL , 'Where is php . ' , ( new Php Executable Finder ( ) ) - > find ( false ) , ] , ] ; } 
public function call ( string $ call , array $ params = [ ] , array $ metas = [ ] ) : IResponse { $ transport = $ this - > make Transport ( ) ; $ protocol = new TBinary Protocol ( $ transport ) ; $ transport - > open ( ) ; $ response = $ this - > get Response With Protocol ( $ protocol , [ 'call ' = > $ call , 'params ' = > $ params , 'metas ' = > $ metas , ] ) ; $ transport - > close ( ) ; $ response = $ this - > normalize Response ( $ response ) ; return $ response ; } 
public function add Metas ( $ key , $ value = null ) { $ key = is _array ( $ key ) ? $ key : [ $ key = > $ value , ] ; foreach ( $ key as $ k = > $ v ) { $ this - > metas [ $ k ] = $ v ; } } 
protected function normalize Response ( Response $ response ) : IResponse { if ( $ this - > is Json ( $ response - > data ) ) { $ data = json _decode ( $ response - > data , true ) ; if ( isset ( $ data [ 'target _url ' ] ) ) { return new Redirect Response ( $ data [ 'target _url ' ] , $ response - > status ) ; } return Json Response : : from Json String ( $ response - > data , $ response - > status ) ; } return new Http Response ( $ response - > data , $ response - > status ) ; } 
protected function get Response With Protocol ( TBinary Protocol $ protocol , array $ data ) : Response { $ client = new Thrift Client ( $ protocol ) ; $ message = new Request ( $ data ) ; return $ client - > call ( $ message ) ; } 
public static function instance ( string $ table ) : IMeta { if ( ! isset ( static : : $ instances [ $ table ] ) ) { return static : : $ instances [ $ table ] = new static ( $ table ) ; } return static : : $ instances [ $ table ] ; } 
public static function resolve Database ( ) : Database Manager { if ( static : : $ resolve Database ) { return static : : $ resolve Database ; } if ( ! static : : $ database Resolver & & static : : lazyload Placeholder ( ) & & ! static : : $ database Resolver ) { throw new Invalid Argument Exception ( 'Database resolver was not set . ' ) ; } return static : : $ resolve Database = call _user _func ( static : : $ database Resolver ) ; } 
public static function set Database Resolver ( ? Closure $ database Resolver = null ) : void { static : : $ database Resolver = $ database Resolver ; if ( null = = = $ database Resolver ) { static : : $ resolve Database = null ; } } 
public function set Connect ( $ connect = null ) : IMeta { $ this - > connect = self : : resolve Database ( ) - > connect ( $ connect ) ; return $ this ; } 
public function update ( array $ condition , array $ save Data ) : int { return $ this - > select ( ) - > where ( $ condition ) - > update ( $ save Data ) ; } 
protected function token Persistence ( array $ data , int $ login Time = 0 ) : void { $ this - > set Persistence ( $ this - > get Token Name ( ) , json _encode ( $ data ) , $ login Time ) ; } 
protected function token Data ( ) : array { $ data = $ this - > get Persistence ( $ this - > get Token Name ( ) ) ; return $ data ? json _decode ( $ data , true ) : [ ] ; } 
public function handle ( IApp $ app ) : void { $ this - > app = $ app ; $ this - > extends = $ this - > extends ( ) ; $ this - > line ( 'Start to cache i 1 8n . ' ) ; list _directory ( $ app - > i 1 8n Path ( ) , false , function ( $ item ) use ( $ app ) { if ( $ item - > is Dir ( ) ) { $ i 1 8n = $ item - > get Filename ( ) ; $ data = $ this - > data ( $ i 1 8n ) ; $ cache Path = $ app - > i 1 8n Cached Path ( $ i 1 8n ) ; $ this - > write Cache ( $ cache Path , $ data ) ; $ this - > info ( sprintf ( 'I 1 8n cache file %s cache successed . ' , $ cache Path ) ) ; } } ) ; $ this - > info ( 'I 1 8n cache files cache successed . ' ) ; } 
protected function data ( string $ i 1 8n ) : array { $ load = ( new Load ( [ $ this - > app - > i 1 8n Path ( ) ] ) ) - > set I 1 8n ( $ i 1 8n ) - > add Dir ( $ this - > extends ) ; return $ load - > load Data ( ) ; } 
protected function write Cache ( string $ cache Path , array $ data ) : void { $ content = ' < ? ' . 'php / * ' . date ( 'Y -m -d H :i :s ' ) . ' * / ? ' . ' > ' . PHP _EOL . ' < ? ' . 'php return ' . var _export ( $ data , true ) . ' ; ? ' . ' > ' ; create _file ( $ cache Path , $ content ) ; } 
public function set Option ( string $ name , $ value ) : IRender { $ this - > option [ $ name ] = $ value ; return $ this ; } 
public function render ( array $ option = [ ] ) : string { if ( $ option ) { $ this - > option = array _merge ( $ this - > option , $ option ) ; $ this - > int Option ( ) ; } return preg _replace _callback ( ' / { ( . + ? ) } / ' , function ( $ matches ) { return $ this - > { 'get ' . ucwords ( $ matches [ 1 ] ) . 'Render ' } ( ) ; } , $ this - > option [ 'template ' ] ) ; } 
protected function get Total Render ( ) : string { if ( ! $ this - > page - > can Total Render ( ) ) { return ' ' ; } return sprintf ( ' <span class = "pagination -total " > %s < /span > ' , _ _ ( ' 共 %d 条 ' , $t h s - >pa ge - >ge t T otal Record ( ) ? : ) ) ; } 
protected function get Main Render ( ) : string { if ( ! $ this - > page - > can Main Render ( ) ) { return ' ' ; } $ result = ' ' ; for ( $ i = $ this - > page - > get Page Start ( ) ; $ i < = $ this - > page - > get Page End ( ) ; $ i + + ) { $ active = $ this - > page - > get Current Page ( ) = = = $ i ; $ result . = sprintf ( ' <li class = "number %s " > <a %s > %d < /a > < /li > ' , $ active ? ' active ' : ' ' , $ active ? ' ' : sprintf ( ' href = " %s " ' , $ this - > replace ( $ i ) ) , $ i ) ; } return $ result ; } 
protected function get Next Render ( ) : string { if ( $ this - > page - > can Next Render ( ) ) { return sprintf ( ' <button class = "btn -next " ' . 'onclick = "window .location .href = \ ' %s \ ' ; " > & # 8 2 5 0 ; < /button > ' , $ this - > replace ( $ this - > page - > get Current Page ( ) + 1 ) ) ; } return ' <button class = "btn -next disabled " > ' . ' & # 8 2 5 0 ; < /button > ' ; } 
protected function get Last Render ( ) : string { if ( $ this - > page - > is Total Macro ( ) ) { return sprintf ( ' <li class = "btn -quicknext " ' . 'onclick = "window .location .href = \ ' %s \ ' ; " ' . 'onmouseenter = "this .inner HTML = \ ' &raquo ; \ ' ; " ' . 'onmouseleave = "this .inner HTML = \ ' . . . \ ' ; " > . . . < /li > ' , $ this - > replace ( $ this - > page - > parse Last Render Next ( ) ) ) ; } if ( $ this - > page - > can Last Render ( ) ) { return ( $ this - > page - > can Last Render Next ( ) ? sprintf ( ' <li class = "btn -quicknext " ' . 'onclick = "window .location .href = \ ' %s \ ' ; " ' . 'onmouseenter = "this .inner HTML = \ ' &raquo ; \ ' ; " ' . 'onmouseleave = "this .inner HTML = \ ' . . . \ ' ; " > . . . < /li > ' , $ this - > replace ( $ this - > page - > parse Last Render Next ( ) ) ) : ' ' ) . sprintf ( ' <li > <a href = " %s " > %d < /a > < /li > ' , $ this - > replace ( $ this - > page - > get Total Page ( ) ) , $ this - > page - > get Total Page ( ) ) ; } return ' ' ; } 
public function start ( ? string $ session Id = null ) : void { if ( $ this - > is Start ( ) ) { return ; } $ this - > set Id ( $ session Id ? : $ this - > option [ 'id ' ] ) ; $ this - > load Data ( ) ; $ this - > started = true ; } 
public function save ( ) : void { if ( ! $ this - > is Start ( ) ) { throw new Runtime Exception ( 'Session is not start yet . ' ) ; } $ this - > unregister Flash ( ) ; $ this - > connect - > write ( $ this - > get Id ( ) , serialize ( $ this - > datas ) ) ; $ this - > started = false ; } 
public function set ( string $ name , $ value ) : void { $ name = $ this - > get Normalize Name ( $ name ) ; $ this - > datas [ $ name ] = $ value ; } 
public function put ( $ keys , $ value = null ) : void { if ( ! is _array ( $ keys ) ) { $ keys = [ $ keys = > $ value , ] ; } foreach ( $ keys as $ item = > $ value ) { $ this - > set ( $ item , $ value ) ; } } 
public function get ( string $ name , $ value = null ) { $ name = $ this - > get Normalize Name ( $ name ) ; return $ this - > datas [ $ name ] ? ? $ value ; } 
public function delete ( string $ name ) : void { $ name = $ this - > get Normalize Name ( $ name ) ; if ( isset ( $ this - > datas [ $ name ] ) ) { unset ( $ this - > datas [ $ name ] ) ; } } 
public function has ( string $ name ) : bool { $ name = $ this - > get Normalize Name ( $ name ) ; return isset ( $ this - > datas [ $ name ] ) ; } 
public function flash ( string $ key , $ value ) : void { $ this - > set ( $ this - > flash Data Key ( $ key ) , $ value ) ; $ this - > merge New Flash ( [ $ key , ] ) ; $ this - > pop Old Flash ( [ $ key , ] ) ; } 
public function flashs ( array $ flash ) : void { foreach ( $ flash as $ key = > $ value ) { $ this - > flash ( $ key , $ value ) ; } } 
public function now Flash ( string $ key , $ value ) : void { $ this - > set ( $ this - > flash Data Key ( $ key ) , $ value ) ; $ this - > merge Old Flash ( [ $ key , ] ) ; } 
public function now Flashs ( array $ flash ) : void { foreach ( $ flash as $ key = > $ value ) { $ this - > now Flash ( $ key , $ value ) ; } } 
public function rebuild Flash ( ) : void { $ this - > merge New Flash ( $ this - > get ( $ this - > flash Old Key ( ) , [ ] ) ) ; $ this - > set ( $ this - > flash Old Key ( ) , [ ] ) ; } 
public function get Flash ( string $ key , $ defaults = null ) { if ( false ! = = strpos ( $ key , ' \ \ ' ) ) { return $ this - > get Part Data ( $ key , $ defaults , 'flash ' ) ; } return $ this - > get ( $ this - > flash Data Key ( $ key ) , $ defaults ) ; } 
public function delete Flash ( array $ keys ) : void { foreach ( $ keys as $ item ) { $ this - > delete ( $ this - > flash Data Key ( $ item ) ) ; } $ this - > merge Old Flash ( $ keys ) ; $ this - > pop New Flash ( $ keys ) ; } 
public function unregister Flash ( ) : void { $ arr = $ this - > get ( $ this - > flash New Key ( ) , [ ] ) ; $ old = $ this - > get ( $ this - > flash Old Key ( ) , [ ] ) ; foreach ( $ old as $ item ) { $ this - > delete ( $ this - > flash Data Key ( $ item ) ) ; } $ this - > delete ( $ this - > flash New Key ( ) ) ; $ this - > set ( $ this - > flash Old Key ( ) , $ arr ) ; unset ( $ arr , $ old ) ; } 
public function destroy ( ) : void { $ this - > clear ( ) ; $ this - > connect - > destroy ( $ this - > get Id ( ) ) ; $ this - > id = null ; $ this - > started = false ; } 
public function set Id ( ? string $ id = null ) : void { $ this - > id = $ id ? : $ this - > generate Session Id ( ) ; } 
protected function parse Microtime ( ) : string { list ( $ usec , $ sec ) = explode ( ' ' , microtime ( ) ) ; return ( string ) ( ( float ) $ usec + ( float ) $ sec ) ; } 
protected function get Part Data ( string $ key , $ defaults = null , ? string $ type = null ) { list ( $ key , $ name ) = explode ( ' \ \ ' , $ key ) ; if ( 'flash ' = = = $ type ) { $ key = $ this - > flash Data Key ( $ key ) ; } $ value = $ this - > get ( $ key ) ; if ( is _array ( $ value ) ) { if ( ! strpos ( $ name , ' . ' ) ) { return array _key _exists ( $ name , $ value ) ? $ value [ $ name ] : $ defaults ; } $ parts = explode ( ' . ' , $ name ) ; foreach ( $ parts as $ part ) { if ( ! isset ( $ value [ $ part ] ) ) { return $ defaults ; } $ value = $ value [ $ part ] ; } return $ value ; } return $ defaults ; } 
protected function console ( array $ data ) : string { $ content = [ ] ; $ content [ ] = ' <script type = "text /javascript " > console .log ( \ ' %c The PHP Framework For Code Poem As Free As Wind %c (http : 
public function bootstrap ( ) : void { $ this - > set Controller Dir ( ) ; $ this - > set Middleware ( ) ; if ( $ this - > is Router Cached ( ) ) { $ this - > import Cached Routers ( ) ; } else { $ this - > load Routers ( ) ; } } 
protected function set Routers Data ( array $ routers ) : void { $ this - > container [ 'router ' ] - > set Base Paths ( $ routers [ 'base _paths ' ] ) ; $ this - > container [ 'router ' ] - > set Group Paths ( $ routers [ 'group _paths ' ] ) ; $ this - > container [ 'router ' ] - > set Groups ( $ routers [ 'groups ' ] ) ; $ this - > container [ 'router ' ] - > set Routers ( $ routers [ 'routers ' ] ) ; } 
protected function set Controller Dir ( ) : void { if ( null ! = = $ this - > controller Dir ) { $ this - > container [ 'router ' ] - > set Controller Dir ( $ this - > controller Dir ) ; } } 
protected function set Middleware ( ) : void { if ( null ! = = $ this - > middleware Groups ) { $ this - > container [ 'router ' ] - > set Middleware Groups ( $ this - > middleware Groups ) ; } if ( null ! = = $ this - > middleware Alias ) { $ this - > container [ 'router ' ] - > set Middleware Alias ( $ this - > middleware Alias ) ; } } 
public function handle ( IApp $ app ) : void { $ this - > app = $ app ; $ test = 2 = = = func _num _args ( ) ; if ( ! $ test ) { 
public function set Error Handle ( int $ code , string $ description , ? string $ file = null , ? int $ line = null , $ context = null ) : void { 
public function register Shutdown Function ( ) : void { if ( ( $ error = error _get _last ( ) ) & & ! empty ( $ error [ 'type ' ] ) ) { $ this - > set Exception Handler ( $ this - > format Error Exception ( $ error ) ) ; } } 
public function set Exception Handler ( Throwable $ e ) : void { if ( ! $ e instanceof Exception ) { $ e = new Error Exception ( $ e - > get Message ( ) , $ e - > get Code ( ) , E _ERROR , $ e - > get File ( ) , $ e - > get Line ( ) , $ e - > get Previous ( ) ) ; } try { $ this - > get Runtime ( ) - > report ( $ e ) ; 
protected function render Http Response ( Exception $ e ) : void { $ this - > get Runtime ( ) - > render ( $ this - > app [ 'request ' ] , $ e ) - > send ( ) ; } 
protected function format Error Exception ( array $ error ) : Error Exception { return new Error Exception ( ( string ) ( $ error [ 'message ' ] ) , ( int ) ( $ error [ 'type ' ] ) , 0 , ( string ) ( $ error [ 'file ' ] ) , ( int ) ( $ error [ 'line ' ] ) ) ; } 
protected function set Persistence ( string $ key , string $ value , int $ expire = 0 ) : void { $ this - > cache - > set ( $ key , $ value , [ 'expire ' = > $ expire ] ) ; } 
protected function get Token Name From Request ( ) : string { $ token = $ this - > request - > query ( $ this - > option [ 'input _token ' ] , ' ' ) ; if ( ! $ token ) { $ token = $ this - > request - > input ( $ this - > option [ 'input _token ' ] , ' ' ) ; } return $ token ; } 
public function register ( ) : void { $ this - > http Server ( ) ; $ this - > websocket Server ( ) ; $ this - > rpc Server ( ) ; $ this - > pool ( ) ; $ this - > rpc ( ) ; } 
protected function http Server ( ) : void { $ this - > container - > singleton ( 'http .server ' , function ( IContainer $ container ) { return new Http Server ( $ container , array _merge ( $ container [ 'option ' ] [ 'protocol \ \server ' ] , $ container [ 'option ' ] [ 'protocol \ \http ' ] ) ) ; } ) ; } 
protected function websocket Server ( ) : void { $ this - > container - > singleton ( 'websocket .server ' , function ( IContainer $ container ) { return new Websocket Server ( $ container , array _merge ( $ container [ 'option ' ] [ 'protocol \ \server ' ] , $ container [ 'option ' ] [ 'protocol \ \websocket ' ] ) ) ; } ) ; } 
protected function rpc Server ( ) : void { $ this - > container - > singleton ( 'rpc .server ' , function ( IContainer $ container ) { return new Rpc Server ( $ container , array _merge ( $ container [ 'option ' ] [ 'protocol \ \server ' ] , $ container [ 'option ' ] [ 'protocol \ \rpc ' ] ) ) ; } ) ; } 
public function flush ( ) : void { $ this - > validate Closed ( ) ; if ( ! ( $ this - > entity Creates | | $ this - > entity Updates | | $ this - > entity Deletes | | $ this - > entity Replaces ) ) { return ; } $ this - > begin Transaction ( ) ; try { $ this - > handle Repository ( ) ; $ this - > commit ( ) ; } catch ( Throwable $ e ) { $ this - > close ( ) ; $ this - > roll Back ( ) ; throw $ e ; } } 
public function persist Before ( IEntity $ entity , string $ method = 'save ' ) : IUnit Of Work { return $ this - > persist Entity ( 'Before ' , $ entity , $ method ) ; } 
public function persist ( IEntity $ entity , string $ method = 'save ' ) : IUnit Of Work { return $ this - > persist Entity ( ' ' , $ entity , $ method ) ; } 
public function persiste After ( IEntity $ entity , string $ method = 'save ' ) : IUnit Of Work { return $ this - > persist Entity ( 'After ' , $ entity , $ method ) ; } 
public function remove Before ( IEntity $ entity , int $ priority = 5 0 0 ) : IUnit Of Work { return $ this - > remove Entity ( 'Before ' , $ entity , $ priority ) ; } 
public function remove ( IEntity $ entity , int $ priority = 5 0 0 ) : IUnit Of Work { return $ this - > remove Entity ( ' ' , $ entity , $ priority ) ; } 
public function remove After ( IEntity $ entity , int $ priority = 5 0 0 ) : IUnit Of Work { return $ this - > remove Entity ( 'After ' , $ entity , $ priority ) ; } 
public function create Before ( IEntity $ entity , int $ priority = 5 0 0 ) : IUnit Of Work { $ this - > create Entity ( $ entity ) ; $ id = spl _object _id ( $ entity ) ; $ this - > creates Flag Before [ $ id ] = $ priority ; return $ this ; } 
public function create ( IEntity $ entity , int $ priority = 5 0 0 ) : IUnit Of Work { $ this - > create Entity ( $ entity ) ; $ id = spl _object _id ( $ entity ) ; $ this - > creates Flag [ $ id ] = $ priority ; return $ this ; } 
public function create After ( IEntity $ entity , int $ priority = 5 0 0 ) : IUnit Of Work { $ this - > create Entity ( $ entity ) ; $ id = spl _object _id ( $ entity ) ; $ this - > creates Flag After [ $ id ] = $ priority ; return $ this ; } 
public function created ( IEntity $ entity , int $ priority = 5 0 0 ) : bool { return isset ( $ this - > entity Creates [ spl _object _id ( $ entity ) ] ) ; } 
public function update Before ( IEntity $ entity , int $ priority = 5 0 0 ) : IUnit Of Work { $ this - > update Entity ( $ entity ) ; $ id = spl _object _id ( $ entity ) ; $ this - > updates Flag Before [ $ id ] = $ priority ; return $ this ; } 
public function update ( IEntity $ entity , int $ priority = 5 0 0 ) : IUnit Of Work { $ this - > update Entity ( $ entity ) ; $ id = spl _object _id ( $ entity ) ; $ this - > updates Flag [ $ id ] = $ priority ; return $ this ; } 
public function update After ( IEntity $ entity , int $ priority = 5 0 0 ) : IUnit Of Work { $ this - > update Entity ( $ entity ) ; $ id = spl _object _id ( $ entity ) ; $ this - > updates Flag After [ $ id ] = $ priority ; return $ this ; } 
public function replace Before ( IEntity $ entity , int $ priority = 5 0 0 ) : IUnit Of Work { $ this - > replace Entity ( $ entity ) ; $ id = spl _object _id ( $ entity ) ; $ this - > replaces Flag Before [ $ id ] = $ priority ; return $ this ; } 
public function replace ( IEntity $ entity , int $ priority = 5 0 0 ) : IUnit Of Work { $ this - > replace Entity ( $ entity ) ; $ id = spl _object _id ( $ entity ) ; $ this - > replaces Flag [ $ id ] = $ priority ; return $ this ; } 
public function replace After ( IEntity $ entity , int $ priority = 5 0 0 ) : IUnit Of Work { $ this - > replace Entity ( $ entity ) ; $ id = spl _object _id ( $ entity ) ; $ this - > replaces Flag After [ $ id ] = $ priority ; return $ this ; } 
public function delete Before ( IEntity $ entity , int $ priority = 5 0 0 ) : IUnit Of Work { $ this - > delete Entity ( $ entity ) ; $ id = spl _object _id ( $ entity ) ; $ this - > deletes Flag Before [ $ id ] = $ priority ; return $ this ; } 
public function delete ( IEntity $ entity , int $ priority = 5 0 0 ) : IUnit Of Work { $ this - > delete Entity ( $ entity ) ; $ id = spl _object _id ( $ entity ) ; $ this - > deletes Flag [ $ id ] = $ priority ; return $ this ; } 
public function delete After ( IEntity $ entity , int $ priority = 5 0 0 ) : IUnit Of Work { $ this - > delete Entity ( $ entity ) ; $ id = spl _object _id ( $ entity ) ; $ this - > deletes Flag After [ $ id ] = $ priority ; return $ this ; } 
public function registered ( IEntity $ entity ) : bool { $ id = spl _object _id ( $ entity ) ; return isset ( $ this - > entity Creates [ $ id ] ) | | isset ( $ this - > entity Updates [ $ id ] ) | | isset ( $ this - > entity Deletes [ $ id ] ) | | isset ( $ this - > entity Replaces [ $ id ] ) ; } 
public function refresh ( IEntity $ entity ) : IUnit Of Work { $ this - > validate Closed ( ) ; if ( self : : STATE _MANAGED ! = = $ this - > get Entity State ( $ entity ) ) { $ e = sprintf ( 'Entity ` %s ` was not managed . ' , get _class ( $ entity ) ) ; throw new Invalid Argument Exception ( $ e ) ; } $ this - > repository ( $ entity ) - > refresh ( $ entity ) ; return $ this ; } 
public function register Managed ( IEntity $ entity ) : void { $ this - > entity States [ spl _object _id ( $ entity ) ] = self : : STATE _MANAGED ; } 
public function transaction ( Closure $ action ) { $ this - > begin Transaction ( ) ; try { $ result = $ action ( $ this ) ; $ this - > flush ( ) ; $ this - > commit ( ) ; return $ result ; } catch ( Throwable $ e ) { $ this - > roll Back ( ) ; $ this - > close ( ) ; throw $ e ; } } 
public function clear ( ) : void { $ this - > entity Creates = [ ] ; $ this - > entity Updates = [ ] ; $ this - > entity Deletes = [ ] ; $ this - > entity Replaces = [ ] ; $ this - > entity States = [ ] ; $ this - > on Callbacks = [ ] ; $ this - > creates Flag Before = [ ] ; $ this - > creates Flag = [ ] ; $ this - > creates Flag After = [ ] ; $ this - > replaces Flag Before = [ ] ; $ this - > replaces Flag = [ ] ; $ this - > replaces Flag After = [ ] ; $ this - > updates Flag Before = [ ] ; $ this - > updates Flag = [ ] ; $ this - > updates Flag After = [ ] ; $ this - > deletes Flag Before = [ ] ; $ this - > deletes Flag = [ ] ; $ this - > deletes Flag After = [ ] ; } 
public function on ( IEntity $ entity , Closure $ callbacks ) : void { $ this - > on Callbacks [ spl _object _id ( $ entity ) ] [ ] = $ callbacks ; } 
public function repository ( $ entity ) : IRepository { if ( is _string ( $ entity ) ) { $ entity = new $ entity ( ) ; } if ( defined ( get _class ( $ entity ) . ' : :REPOSITORY ' ) ) { $ name = $ entity : : REPOSITORY ; $ repository = new $ name ( $ entity ) ; } else { $ repository = new Repository ( $ entity ) ; } return $ repository ; } 
public function get Entity State ( IEntity $ entity , ? int $ defaults = null ) : int { $ id = spl _object _id ( $ entity ) ; if ( isset ( $ this - > entity States [ $ id ] ) ) { return $ this - > entity States [ $ id ] ; } if ( null ! = = $ defaults ) { return $ defaults ; } if ( ! $ entity - > id ( ) ) { return self : : STATE _NEW ; } return self : : STATE _DETACHED ; } 
protected function persist Entity ( string $ position , IEntity $ entity , string $ method = 'save ' ) : IUnit Of Work { $ this - > validate Closed ( ) ; $ id = spl _object _id ( $ entity ) ; $ entity State = $ this - > get Entity State ( $ entity , self : : STATE _NEW ) ; switch ( $ entity State ) { case self : : STATE _MANAGED : break ; case self : : STATE _NEW : $ this - > persist New Entry ( $ position , $ method , $ entity ) ; break ; case self : : STATE _REMOVED : if ( isset ( $ this - > entity Deletes [ $ id ] ) ) { unset ( $ this - > entity Deletes [ $ id ] ) ; foreach ( [ 'deletes Flag Before ' , 'deletes Flag ' , 'deletes Flag After ' ] as $ flag ) { if ( isset ( $ this - > { $ flag } [ $ id ] ) ) { unset ( $ this - > { $ flag } [ $ id ] ) ; } } } $ this - > entity States [ $ id ] = self : : STATE _MANAGED ; break ; case self : : STATE _DETACHED : default : $ e = sprintf ( 'Detached entity ` %s ` cannot be persist . ' , get _class ( $ entity ) ) ; throw new Invalid Argument Exception ( $ e ) ; } return $ this ; } 
protected function remove Entity ( string $ position , IEntity $ entity , int $ priority = 5 0 0 ) : IUnit Of Work { $ id = spl _object _id ( $ entity ) ; $ entity State = $ this - > get Entity State ( $ entity ) ; switch ( $ entity State ) { case self : : STATE _NEW : case self : : STATE _REMOVED : break ; case self : : STATE _MANAGED : $ this - > { 'delete ' . $ position } ( $ entity , $ priority ) ; break ; case self : : STATE _DETACHED : default : $ e = sprintf ( 'Detached entity ` %s ` cannot be remove . ' , get _class ( $ entity ) ) ; throw new Invalid Argument Exception ( $ e ) ; } return $ this ; } 
protected function update Entity ( IEntity $ entity ) : IUnit Of Work { $ this - > validate Closed ( ) ; $ id = spl _object _id ( $ entity ) ; if ( ! $ entity - > id ( ) ) { $ e = sprintf ( 'Entity ` %s ` has no identity for update . ' , get _class ( $ entity ) ) ; throw new Invalid Argument Exception ( $ e ) ; } if ( isset ( $ this - > entity Deletes [ $ id ] ) ) { $ e = sprintf ( 'Deleted entity ` %s ` cannot be added for update . ' , get _class ( $ entity ) ) ; throw new Invalid Argument Exception ( $ e ) ; } if ( isset ( $ this - > entity Creates [ $ id ] ) ) { $ e = sprintf ( 'Created entity ` %s ` cannot be added for update . ' , get _class ( $ entity ) ) ; throw new Invalid Argument Exception ( $ e ) ; } if ( isset ( $ this - > entity Replaces [ $ id ] ) ) { $ e = sprintf ( 'Replaced entity ` %s ` cannot be added for update . ' , get _class ( $ entity ) ) ; throw new Invalid Argument Exception ( $ e ) ; } if ( isset ( $ this - > entity Updates [ $ id ] ) ) { $ e = sprintf ( 'Entity ` %s ` cannot be updated for twice . ' , get _class ( $ entity ) ) ; throw new Invalid Argument Exception ( $ e ) ; } $ this - > entity Updates [ $ id ] = $ entity ; $ this - > entity States [ $ id ] = self : : STATE _MANAGED ; return $ this ; } 
protected function delete Entity ( IEntity $ entity ) : IUnit Of Work { $ this - > validate Closed ( ) ; $ id = spl _object _id ( $ entity ) ; if ( isset ( $ this - > entity Creates [ $ id ] ) ) { unset ( $ this - > entity Creates [ $ id ] , $ this - > entity States [ $ id ] ) ; foreach ( [ 'creates Flag Before ' , 'creates Flag ' , 'creates Flag After ' ] as $ flag ) { if ( isset ( $ this - > { $ flag } [ $ id ] ) ) { unset ( $ this - > { $ flag } [ $ id ] ) ; } } return $ this ; } if ( isset ( $ this - > entity Replaces [ $ id ] ) ) { unset ( $ this - > entity Replaces [ $ id ] ) ; foreach ( [ 'replaces Flag Before ' , 'replaces Flag ' , 'replaces Flag After ' ] as $ flag ) { if ( isset ( $ this - > { $ flag } [ $ id ] ) ) { unset ( $ this - > { $ flag } [ $ id ] ) ; } } if ( ! $ entity - > id ( ) ) { return $ this ; } } if ( ! $ entity - > id ( ) ) { $ e = sprintf ( 'Entity ` %s ` has no identity for delete . ' , get _class ( $ entity ) ) ; throw new Invalid Argument Exception ( $ e ) ; } if ( isset ( $ this - > entity Updates [ $ id ] ) ) { unset ( $ this - > entity Updates [ $ id ] ) ; foreach ( [ 'updates Flag Before ' , 'updates Flag ' , 'updates Flag After ' ] as $ flag ) { if ( isset ( $ this - > { $ flag } [ $ id ] ) ) { unset ( $ this - > { $ flag } [ $ id ] ) ; } } } if ( isset ( $ this - > entity Deletes [ $ id ] ) ) { $ e = sprintf ( 'Entity ` %s ` cannot be deleted for twice . ' , get _class ( $ entity ) ) ; throw new Invalid Argument Exception ( $ e ) ; } $ this - > entity Deletes [ $ id ] = $ entity ; $ this - > entity States [ $ id ] = self : : STATE _REMOVED ; return $ this ; } 
protected function handle Repository ( ) : void { foreach ( [ 'Before ' , ' ' , 'After ' ] as $ position ) { foreach ( [ 'creates ' , 'replaces ' , 'updates ' , 'deletes ' ] as $ type ) { $ flag = $ type . 'Flag ' . $ position ; if ( $ this - > { $ flag } ) { $ flags = $ this - > { $ flag } ; asort ( $ flags ) ; foreach ( $ flags as $ id = > $ _ ) { $ entity = $ this - > { 'entity ' . ucfirst ( $ type ) } [ $ id ] ; $ this - > repository ( $ entity ) - > { substr ( $ type , 0 , - 1 ) } ( $ entity ) ; if ( isset ( $ this - > on Callbacks [ $ id ] ) ) { foreach ( $ this - > on Callbacks [ $ id ] as $ c ) { $ c ( $ entity , $ this ) ; } } $ this - > entity States [ $ id ] = self : : STATE _DETACHED ; } } } } $ old States = $ this - > entity States ; $ this - > clear ( ) ; $ this - > entity States = $ old States ; } 
protected function persist New Entry ( string $ position , string $ method , IEntity $ entity ) : void { switch ( strtolower ( $ method ) ) { case 'create ' : $ this - > { 'create ' . $ position } ( $ entity ) ; break ; case 'update ' : $ this - > { 'update ' . $ position } ( $ entity ) ; break ; case 'replace ' : $ this - > { 'replace ' . $ position } ( $ entity ) ; break ; case 'save ' : default : $ ids = $ entity - > id ( ) ; if ( is _array ( $ ids ) ) { $ this - > { 'replace ' . $ position } ( $ entity ) ; } else { if ( empty ( $ ids ) ) { $ this - > { 'create ' . $ position } ( $ entity ) ; } else { $ this - > { 'update ' . $ position } ( $ entity ) ; } } break ; } } 
public function set Option ( string $ name , $ value ) : IPage { $ this - > option [ $ name ] = $ value ; return $ this ; } 
public function append ( string $ key , string $ value ) : IPage { return $ this - > add Parameter ( $ key , $ value ) ; } 
public function appends ( array $ values ) : IPage { foreach ( $ values as $ key = > $ value ) { $ this - > add Parameter ( $ key , $ value ) ; } return $ this ; } 
public function add Parameter ( string $ key , $ value ) : IPage { $ tmp = $ this - > option [ 'parameter ' ] ; $ tmp [ $ key ] = $ value ; $ this - > set Option ( 'parameter ' , $ tmp ) ; return $ this ; } 
public function render Options ( array $ option ) : IPage { foreach ( $ option as $ key = > $ value ) { $ this - > render Option ( $ key , $ value ) ; } return $ this ; } 
public function get Per Page ( ) : int { if ( null = = = $ this - > per Page ) { $ this - > per Page = static : : PER _PAGE ; } return $ this - > per Page ; } 
public function get To Record ( ) : ? int { if ( ! $ this - > can Total Render ( ) ) { return null ; } $ to = $ this - > get From Record ( ) + $ this - > get Per Page ( ) ; return $ to < = $ this - > get Total Record ( ) ? $ to : $ this - > get Total Record ( ) ; } 
public function get Page Start ( ) : int { if ( null ! = = $ this - > page Start ) { return $ this - > page Start ; } $ this - > page Start = $ this - > get Current Page ( ) - $ this - > get Range ( ) ; if ( $ this - > page Start < $ this - > get Range ( ) * 2 ) { $ this - > page Start = 1 ; } return $ this - > page Start ; } 
public function get Page End ( ) : int { if ( null ! = = $ this - > page End ) { return $ this - > page End ; } $ this - > page End = $ this - > get Current Page ( ) + $ this - > get Range ( ) ; if ( 1 = = = $ this - > get Page Start ( ) ) { $ this - > page End = $ this - > get Range ( ) * 2 + 2 ; } if ( $ this - > get Total Page ( ) & & $ this - > page End > $ this - > get Total Page ( ) ) { $ this - > page End = $ this - > get Total Page ( ) ; } return $ this - > page End ; } 
public function get Total Page ( ) : ? int { if ( null ! = = $ this - > total Page | | ! $ this - > get Total Record ( ) ) { return $ this - > total Page ; } $ this - > total Page = ( int ) ( ceil ( $ this - > get Total Record ( ) / $ this - > get Per Page ( ) ) ) ; return $ this - > total Page ; } 
public function can Next Render ( ) : bool { return null = = = $ this - > get Total Page ( ) | | ( $ this - > get Total Page ( ) > 1 & & $ this - > get Current Page ( ) ! = = $ this - > get Total Page ( ) ) ; } 
public function can Last Render ( ) : bool { return $ this - > get Total Page ( ) > 1 & & $ this - > get Current Page ( ) ! = = $ this - > get Total Page ( ) & & $ this - > get Total Page ( ) > $ this - > get Page End ( ) ; } 
public function parse Last Render Next ( ) : int { $ next = $ this - > get Current Page ( ) + $ this - > get Range ( ) * 2 + 1 ; if ( ! $ this - > is Total Macro ( ) & & $ next > $ this - > get Total Page ( ) ) { $ next = $ this - > get Total Page ( ) ; } return $ next ; } 
public function render ( $ render = null , array $ option = [ ] ) : string { $ option = array _merge ( $ this - > option [ 'render _option ' ] , $ option ) ; if ( null = = = $ render | | is _string ( $ render ) ) { $ render = $ render ? : $ this - > get Render ( ) ; $ render = _ _NAMESPACE _ _ . ' \ \ ' . ucfirst ( $ render ) ; $ render = new $ render ( $ this ) ; } elseif ( ! $ render instanceof IRender ) { throw new Runtime Exception ( 'Unsupported render type . ' ) ; } $ result = $ render - > render ( $ option ) ; $ this - > cached Url = null ; return $ result ; } 
public function to Array ( ) : array { return [ 'per _page ' = > $ this - > get Per Page ( ) , 'current _page ' = > $ this - > get Current Page ( ) , 'total _page ' = > $ this - > get Total Page ( ) , 'total _record ' = > $ this - > get Total Record ( ) , 'total _macro ' = > $ this - > is Total Macro ( ) , 'from ' = > $ this - > get From Record ( ) , 'to ' = > $ this - > get To Record ( ) , ] ; } 
public function to Json ( $ option = null ) : string { if ( null = = = $ option ) { $ option = JSON _UNESCAPED _UNICODE ; } return json _encode ( $ this - > json Serialize ( ) , $ option ) ; } 
protected function get Url ( ) : string { if ( null ! = = $ this - > cached Url ) { return $ this - > cached Url ; } $ url = ( string ) ( $ this - > option [ 'url ' ] ) ; $ parameter = $ this - > option [ 'parameter ' ] ; if ( isset ( $ parameter [ $ this - > option [ 'page ' ] ] ) ) { unset ( $ parameter [ $ this - > option [ 'page ' ] ] ) ; } if ( false = = = strpos ( $ url , ' {page } ' ) ) { $ parameter [ $ this - > option [ 'page ' ] ] = ' {page } ' ; } $ this - > cached Url = $ url . ( false = = = strpos ( $ url , ' ? ' ) ? ' ? ' : ' & ' ) . http _build _query ( $ parameter , ' ' , ' & ' ) ; return $ this - > cached Url . = $ this - > build Fragment ( ) ; } 
protected function match Main ( ) : array { if ( ! ( $ routers = $ this - > router - > get Routers ( ) ) ) { return [ ] ; } 
protected function matche Method ( array $ routers ) { $ method = strtolower ( $ this - > request - > get Method ( ) ) ; return $ routers [ $ method ] ? ? false ; } 
protected function matche Static ( array $ routers ) { $ path Info = $ this - > get Path Info ( ) ; if ( isset ( $ routers [ 'static ' ] , $ routers [ 'static ' ] [ $ path Info ] ) ) { $ routers = $ routers [ 'static ' ] [ $ path Info ] ; return $ this - > matche Successed ( $ routers ) ; } return false ; } 
protected function matche Groups ( string $ path Info , array $ routers ) : array { $ match Group = false ; foreach ( $ this - > router - > get Groups ( ) as $ group ) { if ( 0 = = = strpos ( $ path Info , $ group ) ) { $ routers = $ routers [ $ group ] ; $ match Group = true ; break ; } } if ( false = = = $ match Group ) { $ routers = $ routers [ ' _ ' ] ? ? [ ] ; } return $ routers ; } 
protected function matche Regex Groups ( array $ routers ) { $ path Info = $ this - > get Path Info ( ) ; foreach ( $ routers [ 'regex ' ] as $ key = > $ regex ) { if ( ! preg _match ( $ regex , $ path Info , $ matches ) ) { continue ; } $ matched Router = $ routers [ 'map ' ] [ $ key ] [ count ( $ matches ) ] ; $ routers = $ routers [ $ matched Router ] ; $ matche Vars = $ this - > matche Variable ( $ routers , $ matches ) ; return $ this - > matche Successed ( $ routers , $ matche Vars ) ; } return false ; } 
protected function matche Successed ( array $ routers , array $ matche Vars = [ ] ) : array { 
protected function matche Scheme ( string $ scheme ) : bool { if ( $ scheme & & $ this - > request - > get Scheme ( ) ! = = $ scheme ) { return false ; } return true ; } 
protected function matche Domain ( array $ routers ) { $ domain Vars = [ ] ; if ( ! empty ( $ routers [ 'domain ' ] ) ) { 
protected function matche Variable ( array $ routers , array $ matches ) : array { $ result = [ ] ; array _shift ( $ matches ) ; foreach ( $ routers [ 'var ' ] as $ key = > $ var ) { $ value = $ matches [ $ key ] ; $ result [ $ var ] = $ matches [ $ key ] ; $ this - > add Variable ( $ var , $ matches [ $ key ] ) ; } return $ result ; } 
public function eager ( array $ relation ) : self { $ this - > pre Loads = array _merge ( $ this - > pre Loads , $ this - > parse With Relation ( $ relation ) ) ; return $ this ; } 
public function pre Load Result ( $ result ) { list ( $ result , $ type ) = $ this - > conversion To Entitys ( $ result ) ; if ( $ type ) { $ result = $ this - > pre Load Relation ( $ result ) ; if ( 'entity ' = = = $ type ) { $ result = reset ( $ result ) ; } elseif ( 'collection ' = = = $ type ) { $ result = new Collection ( $ result ) ; } } return $ result ; } 
public function find ( int $ id , array $ column = [ ' * ' ] ) : IEntity { return $ this - > select - > where ( $ this - > entity - > single Primary Key ( ) , ' = ' , $ id ) - > set Columns ( $ column ) - > find One ( ) ; } 
public function find Many ( array $ ids , array $ column = [ ' * ' ] ) : Collection { if ( empty ( $ ids ) ) { return $ this - > entity - > collection ( ) ; } return $ this - > select - > where In ( $ this - > entity - > single Primary Key ( ) , $ ids ) - > set Columns ( $ column ) - > find All ( ) ; } 
public function find Or Fail ( int $ id , array $ column = [ ' * ' ] ) : IEntity { $ result = $ this - > find ( $ id , $ column ) ; if ( null ! = = $ result - > _ _get ( $ this - > entity - > single Primary Key ( ) ) ) { return $ result ; } throw ( new Entity Not Found Exception ( ) ) - > set Entity ( get _class ( $ this - > entity ) ) ; } 
public function soft Delete ( ) : int { $ this - > entity - > _ _set ( $ this - > delete At Column ( ) , $ time = date ( 'Y -m -d H :i :s ' ) ) ; $ this - > entity - > handle Event ( IEntity : : BEFORE _SOFT _DELETE _EVENT ) ; $ num = $ this - > entity - > update ( ) - > flush ( ) ; $ this - > entity - > handle Event ( IEntity : : AFTER _SOFT _DELETE _EVENT ) ; return $ num ; } 
public function soft Destroy ( array $ ids ) : int { $ count = 0 ; $ instance = $ this - > entity - > make ( ) ; $ entitys = $ instance - > where In ( $ instance - > single Primary Key ( ) , $ ids ) - > find All ( ) ; foreach ( $ entitys as $ value ) { if ( $ value - > soft Delete ( ) ) { $ count + + ; } } return $ count ; } 
public function soft Restore ( ) : int { $ this - > entity - > handle Event ( IEntity : : BEFORE _SOFT _RESTORE _EVENT ) ; $ this - > entity - > _ _set ( $ this - > delete At Column ( ) , null ) ; $ num = $ this - > entity - > update ( ) - > flush ( ) ; $ this - > entity - > handle Event ( IEntity : : AFTER _SOFT _RESTORE _EVENT ) ; return $ num ; } 
public function delete At Column ( ) : string { if ( defined ( get _class ( $ this - > entity ) . ' : :DELETE _AT ' ) ) { $ delete At = $ this - > entity : : DELETE _AT ; } else { $ delete At = 'delete _at ' ; } if ( ! $ this - > entity - > has Field ( $ delete At ) ) { throw new Invalid Argument Exception ( sprintf ( 'Entity ` %s ` soft delete field ` %s ` was not found . ' , get _class ( $ this - > entity ) , $ delete At ) ) ; } return $ delete At ; } 
public function scope ( $ scope ) : IEntity { $ scope Select = $ this - > select ; $ args = func _get _args ( ) ; array _shift ( $ args ) ; array _unshift ( $ args , $ scope Select ) ; if ( $ scope instanceof Closure ) { $ scope ( . . . $ args ) ; $ this - > entity - > with Scope Select ( $ scope Select ) ; } else { foreach ( normalize ( $ scope ) as $ value ) { $ value = 'scope ' . ucfirst ( $ value ) ; if ( method _exists ( $ this - > entity , $ value ) ) { $ this - > entity - > { $ value } ( . . . $ args ) ; $ this - > entity - > with Scope Select ( $ scope Select ) ; } } } return $ this - > entity ; } 
protected function pre Load Relation ( array $ entitys ) : array { foreach ( $ this - > pre Loads as $ name = > $ condition ) { if ( false = = = strpos ( $ name , ' . ' ) ) { $ entitys = $ this - > load Relation ( $ entitys , $ name , $ condition ) ; } } return $ entitys ; } 
protected function get Relation ( string $ name ) : Relation { $ relation = Relation : : without Relation Condition ( function ( ) use ( $ name ) { return $ this - > entity - > { $ name } ( ) ; } ) ; $ nested = $ this - > nested Relation ( $ name ) ; if ( count ( $ nested ) > 0 ) { $ relation - > get Select ( ) - > eager ( $ nested ) ; } return $ relation ; } 
protected function nested Relation ( string $ relation ) : array { $ nested = [ ] ; foreach ( $ this - > pre Loads as $ name = > $ condition ) { if ( $ this - > is Nested ( $ name , $ relation ) ) { $ nested [ substr ( $ name , strlen ( $ relation . ' . ' ) ) ] = $ condition ; } } return $ nested ; } 
protected function is Nested ( string $ name , string $ relation ) : bool { return contains ( $ name , ' . ' ) & & starts _with ( $ name , $ relation . ' . ' ) ; } 
protected function parse With Relation ( array $ relation ) : array { $ arr = [ ] ; foreach ( $ relation as $ name = > $ condition ) { if ( is _numeric ( $ name ) ) { list ( $ name , $ condition ) = [ $ condition , function ( ) { } , ] ; } $ arr = $ this - > parse Nested With ( $ name , $ arr ) ; $ arr [ $ name ] = $ condition ; } return $ arr ; } 
protected function parse Nested With ( string $ name , array $ result ) : array { $ progress = [ ] ; foreach ( explode ( ' . ' , $ name ) as $ segment ) { $ progress [ ] = $ segment ; if ( ! isset ( $ result [ $ last = implode ( ' . ' , $ progress ) ] ) ) { $ result [ $ last ] = function ( ) { } ; } } return $ result ; } 
protected function conversion To Entitys ( $ result ) : array { $ type = ' ' ; if ( $ result instanceof Collection ) { $ arr = [ ] ; foreach ( $ result as $ entity ) { $ arr [ ] = $ entity ; } $ result = $ arr ; $ type = 'collection ' ; } elseif ( is _object ( $ result ) & & $ result instanceof IEntity ) { $ result = [ $ result ] ; $ type = 'entity ' ; } return [ $ result , $ type ] ; } 
protected function load Relation ( array $ entitys , string $ name , Closure $ condition ) : array { $ relation = $ this - > get Relation ( $ name ) ; $ relation - > pre Load Condition ( $ entitys ) ; call _user _func ( $ condition , $ relation ) ; return $ relation - > match Pre Load ( $ entitys , $ relation - > get Pre Load ( ) , $ name ) ; } 
public function handle ( $ event , . . . $ params ) : void { if ( is _object ( $ event ) ) { $ name = get _class ( $ event ) ; } else { $ name = $ event ; 
public function register ( $ event , $ listener , int $ priority = 5 0 0 ) : void { $ event = is _object ( $ event ) ? [ $ event ] : ( array ) $ event ; foreach ( $ event as $ item ) { $ item = $ this - > normalize Event ( $ item ) ; if ( false ! = = strpos ( $ item , ' * ' ) ) { $ this - > wildcards [ $ item ] [ $ priority ] [ ] = $ listener ; } else { $ this - > listeners [ $ item ] [ $ priority ] [ ] = $ listener ; } } } 
public function get ( $ event ) : array { $ listeners = [ ] ; $ event = $ this - > normalize Event ( $ event ) ; if ( isset ( $ this - > listeners [ $ event ] ) ) { $ listeners = $ this - > listeners [ $ event ] ; } foreach ( $ this - > wildcards as $ key = > $ item ) { $ key = $ this - > prepare Regex For Wildcard ( $ key ) ; if ( preg _match ( $ key , $ event , $ res ) ) { foreach ( $ item as $ priority = > $ value ) { $ listeners [ $ priority ] = array _merge ( $ listeners [ $ priority ] ? ? [ ] , $ value ) ; } } } return $ listeners ; } 
public function delete ( $ event ) : void { $ event = $ this - > normalize Event ( $ event ) ; if ( isset ( $ this - > listeners [ $ event ] ) ) { unset ( $ this - > listeners [ $ event ] ) ; } if ( isset ( $ this - > wildcards [ $ event ] ) ) { unset ( $ this - > wildcards [ $ event ] ) ; } } 
protected function make Subject ( array $ listeners ) : Subject { $ subject = new Subject ( $ this - > container ) ; foreach ( $ listeners as $ item ) { $ subject - > register ( $ item ) ; } return $ subject ; } 
protected function prepare Regex For Wildcard ( string $ regex ) : string { $ regex = preg _quote ( $ regex , ' / ' ) ; $ regex = ' / ^ ' . str _replace ( ' \ * ' , ' ( \S * ) ' , $ regex ) . ' $ / ' ; return $ regex ; } 
public function get ( string $ class Name , . . . $ args ) { $ this - > valid ( $ class Name ) ; $ class Name = $ this - > normalize ( $ class Name ) ; $ pool = $ this - > pool ( $ class Name ) ; if ( $ pool - > count ( ) ) { $ obj = $ pool - > shift ( ) ; if ( is _callable ( [ $ obj , ' _ _construct ' ] ) ) { $ obj - > _ _construct ( . . . $ args ) ; } if ( is _callable ( [ $ obj , 'construct ' ] ) ) { $ obj - > construct ( ) ; } return $ obj ; } return $ this - > container - > make ( $ class Name , $ args ) ; } 
public function back ( $ obj ) : void { if ( method _exists ( $ obj , 'destruct ' ) ) { $ obj - > destruct ( ) ; } $ class Name = $ this - > normalize ( get _class ( $ obj ) ) ; $ pool = $ this - > pool ( $ class Name ) ; $ pool - > push ( $ obj ) ; } 
public function pool ( string $ class Name ) : Spl Stack { $ this - > valid ( $ class Name ) ; $ class Name = $ this - > normalize ( $ class Name ) ; $ pool = $ this - > pools [ $ class Name ] ? ? null ; if ( null ! = = $ pool ) { return $ pool ; } return $ this - > pools [ $ class Name ] = new Spl Stack ( ) ; } 
public function register ( ) : void { $ this - > view Views ( ) ; $ this - > view View ( ) ; $ this - > view Compiler ( ) ; $ this - > view Parser ( ) ; } 
protected function view Parser ( ) : void { $ this - > container - > singleton ( 'view .parser ' , function ( IContainer $ container ) { return ( new Parser ( $ container [ 'view .compiler ' ] ) ) - > register Compilers ( ) - > register Parsers ( ) ; } ) ; } 
public function handle ( Closure $ next , IRequest $ request , int $ limit = 6 0 , int $ time = 6 0 ) : void { $ rate Limiter = $ this - > throttler - > set Request ( $ request ) - > create ( null , $ limit , $ time ) ; if ( $ rate Limiter - > attempt ( ) ) { $ e = new Too Many Requests Http Exception ( 'Too many attempts . ' ) ; $ e - > set Headers ( $ rate Limiter - > header ( ) ) ; throw $ e ; } $ next ( $ request ) ; } 
protected function create Connect ( object $ connect ) : object { return new Log ( $ connect , $ this - > get Common Option ( ) , $ this - > container - > make ( IDispatch : : class ) ) ; } 
public function handle ( Input Interface $ input = null , Output Interface $ output = null ) : int { $ this - > register Base Service ( ) ; $ this - > bootstrap ( ) ; $ this - > set Global Replace ( ) ; $ this - > load Commands ( ) ; return $ this - > get Console Application ( ) - > run ( $ input , $ output ) ; } 
protected function get Console Application ( ) : Application { if ( $ this - > console Application ) { return $ this - > console Application ; } return $ this - > console Application = new Application ( $ this - > app , $ this - > app - > version ( ) ) ; } 
protected function load Commands ( ) : void { $ commands = $ this - > normalize Commands ( $ this - > get Commands ( ) ) ; $ this - > get Console Application ( ) - > normalize Commands ( $ commands ) ; } 
protected function normalize Commands ( array $ commands ) : array { $ result = $ tmp = [ ] ; foreach ( $ commands as $ item ) { $ tmp [ class _exists ( $ item ) ? 'class ' : 'namespace ' ] [ ] = $ item ; } if ( isset ( $ tmp [ 'class ' ] ) ) { $ result = $ tmp [ 'class ' ] ; } if ( isset ( $ tmp [ 'namespace ' ] ) ) { $ result = array _merge ( $ result , $ this - > get Commands With Namespace ( $ tmp [ 'namespace ' ] ) ) ; } return $ result ; } 
protected function get Commands With Namespace ( array $ namespaces ) : array { $ data = [ ] ; foreach ( $ namespaces as $ item ) { $ data [ $ item ] = $ this - > app - > namespace Path ( $ item . ' \ \index ' ) ; } return ( new Load ( ) ) - > add Namespace ( $ data ) - > load Data ( ) ; } 
public function get Compilers ( ) : array { $ methods = get _class _methods ( $ this ) ; $ compilers = [ ] ; foreach ( $ methods as $ method ) { if ( 'Compiler ' ! = = substr ( $ method , - 8 ) ) { continue ; } $ method = substr ( $ method , 0 , - 8 ) ; if ( ! in _array ( $ method , [ 'global ' , 'jsvar ' , 'globalrevert ' , 'revert ' , ] , true ) ) { $ type = strtolower ( substr ( $ method , - 4 ) ) ; $ tag = substr ( $ method , 0 , - 4 ) ; if ( 'code ' = = = $ type ) { $ name = $ this - > code Map [ $ tag ] ? ? $ tag ; } elseif ( 'node ' = = = $ type ) { $ name = $ this - > node Map [ $ tag ] ? ? $ tag ; } else { $ type = strtolower ( substr ( $ method , - 2 ) ) ; $ tag = substr ( $ method , 0 , - 2 ) ; $ name = $ this - > js Map [ $ tag ] ? ? $ tag ; } $ compilers [ ] = [ $ type , $ name , $ tag , ] ; } } unset ( $ methods ) ; return $ compilers ; } 
public function variable Code Compiler ( array & $ theme ) : void { $ theme [ 'content ' ] = ! empty ( $ theme [ 'content ' ] ) ? $ this - > parse Content ( $ theme [ 'content ' ] ) : null ; if ( null ! = = $ theme [ 'content ' ] ) { $ theme [ 'content ' ] = $ this - > with Php Tag ( 'echo ' . $ theme [ 'content ' ] . ' ; ' ) ; } $ theme [ 'content ' ] = $ this - > encode Content ( $ theme [ 'content ' ] ) ; } 
public function if Code Compiler ( array & $ theme ) : void { $ theme [ 'content ' ] = $ this - > parse Content If ( $ theme [ 'content ' ] , ' ' ) ; $ theme [ 'content ' ] = $ this - > encode Content ( $ this - > with Php Tag ( $ theme [ 'content ' ] . ' : ' ) ) ; } 
public function elseif Code Compiler ( array & $ theme ) : void { $ theme [ 'content ' ] = $ this - > parse Content If ( $ theme [ 'content ' ] , 'else ' ) ; $ theme [ 'content ' ] = $ this - > encode Content ( $ this - > with Php Tag ( $ theme [ 'content ' ] . ' : ' ) ) ; } 
public function foreach Code Compiler ( array & $ theme ) : void { $ theme [ 'content ' ] = call _user _func ( function ( $ content ) { preg _match _all ( ' / \ \ $ ( [ \S ] + ) / ' , $ content , $ matches ) ; $ matches = $ matches [ 1 ] ; $ num = count ( $ matches ) ; if ( $ num > 0 ) { if ( 2 = = = $ num ) { $ result = " \ $ { $matches [ 1 ] } " ; } elseif ( 3 = = = $ num ) { $ result = " \ $ { $matches [ 1 ] } = > \ $ { $matches [ 2 ] } " ; } else { throw new Invalid Argument Exception ( 'The parameter of code .foreach tag can be at most three . ' ) ; } return "if (is _array ( \ $ { $matches [ 0 ] } ) ) : foreach ( \ $ { $matches [ 0 ] } as { $result } ) " ; } } , $ theme [ 'content ' ] ) ; $ theme [ 'content ' ] = $ this - > encode Content ( $ this - > with Php Tag ( $ theme [ 'content ' ] . ' : ' ) ) ; } 
public function endtag Code Compiler ( array & $ theme ) : void { $ theme [ 'content ' ] = substr ( $ theme [ 'source ' ] , strpos ( $ theme [ 'source ' ] , ' / ' ) , strripos ( $ theme [ 'source ' ] , ' } ' ) - 1 ) ; $ theme [ 'content ' ] = call _user _func ( function ( $ content ) { $ content = ltrim ( trim ( $ content ) , ' / ' ) ; switch ( $ content ) { case 'list ' : $ content = $ this - > with Php Tag ( 'endforeach ; endif ; ' ) ; break ; case 'for ' : $ content = $ this - > with Php Tag ( 'endfor ; ' ) ; break ; case 'while ' : $ content = $ this - > with Php Tag ( 'endwhile ; ' ) ; break ; case 'if ' : $ content = $ this - > with Php Tag ( 'endif ; ' ) ; break ; case 'script ' : $ content = ' < /script > ' ; break ; case 'style ' : $ content = ' < /style > ' ; break ; } return $ content ; } , $ theme [ 'content ' ] ) ; $ theme [ 'content ' ] = $ this - > encode Content ( $ theme [ 'content ' ] ) ; } 
public function let Js Compiler ( array & $ theme ) : void { $ this - > check Node ( $ theme , true ) ; $ attr = $ this - > get Node Attribute ( $ theme ) ; $ name = array _shift ( $ attr ) ; $ equal = array _shift ( $ attr ) ; if ( ' = ' ! = = $ equal ) { array _unshift ( $ attr , $ equal ) ; } if ( ! $ attr ) { $ value = 'null ' ; } else { $ value = $ this - > parse Expression ( implode ( ' ' , $ attr ) ) ; if ( ' ' = = = $ value ) { $ value = 'null ' ; } } $ theme [ 'content ' ] = $ this - > with Php Tag ( " \ $ { $name } = " . $ value . ' ; ' ) ; } 
public function if Js Compiler ( array & $ theme ) : void { $ this - > check Node ( $ theme , true ) ; $ attr = $ this - > get Node Attribute ( $ theme ) ; $ attr = $ this - > parse Expression ( implode ( ' ' , $ attr ) ) ; $ theme [ 'content ' ] = $ this - > with Php Tag ( "if ( { $attr } ) : " ) ; $ theme [ 'content ' ] . = $ this - > get Node Body ( $ theme ) ; $ theme [ 'content ' ] . = $ this - > with Php Tag ( 'endif ; ' ) ; } 
public function for Js Compiler ( array & $ theme ) : void { $ this - > check Node ( $ theme , true ) ; $ attr = $ this - > get Node Attribute ( $ theme ) ; $ attr = array _values ( $ attr ) ; if ( ! in _array ( 'in ' , $ attr , true ) ) { throw new Invalid Argument Exception ( 'For tag need “in “ separate . ' ) ; } $ key = 'key ' ; $ value = array _shift ( $ attr ) ; if ( false ! = = strpos ( $ value , ' , ' ) ) { list ( $ key , $ value ) = explode ( ' , ' , $ value ) ; } $ next = array _shift ( $ attr ) ; if ( 'in ' ! = = $ next ) { $ key = $ value ; $ value = $ next ; array _shift ( $ attr ) ; } $ attr = $ this - > parse Expression ( implode ( ' ' , $ attr ) ) ; $ theme [ 'content ' ] = $ this - > with Php Tag ( "foreach ( { $attr } as \ $ { $key } = > \ $ { $value } ) : " ) ; $ theme [ 'content ' ] . = $ this - > get Node Body ( $ theme ) ; $ theme [ 'content ' ] . = $ this - > with Php Tag ( 'endforeach ; ' ) ; } 
public function assign Node Compiler ( array & $ theme ) : void { $ this - > check Node ( $ theme ) ; $ attr = $ this - > get Node Attribute ( $ theme ) ; $ attr [ 'name ' ] = $ this - > parse Content ( $ attr [ 'name ' ] , false ) ; if ( null = = = $ attr [ 'value ' ] ) { $ attr [ 'value ' ] = 'null ' ; } else { if ( ' $ ' = = = substr ( $ attr [ 'value ' ] , 0 , 1 ) ) { $ attr [ 'value ' ] = $ this - > parse Content ( substr ( $ attr [ 'value ' ] , 1 ) ) ; } else { $ attr [ 'value ' ] = ' \ ' ' . $ attr [ 'value ' ] . ' \ ' ' ; } } 
public function if Node Compiler ( array & $ theme ) : void { $ this - > check Node ( $ theme ) ; $ attr = $ this - > get Node Attribute ( $ theme ) ; $ attr [ 'condition ' ] = $ this - > parse Content If ( $ attr [ 'condition ' ] ) ; $ theme [ 'content ' ] = $ this - > with Php Tag ( 'if ( ' . $ attr [ 'condition ' ] . ' ) : ' ) . $ this - > get Node Body ( $ theme ) . $ this - > with Php Tag ( 'endif ; ' ) ; } 
public function elseif Node Compiler ( array & $ theme ) : void { $ this - > check Node ( $ theme ) ; $ attr = $ this - > get Node Attribute ( $ theme ) ; $ attr [ 'condition ' ] = $ this - > parse Content If ( $ attr [ 'condition ' ] ) ; $ theme [ 'content ' ] = $ this - > with Php Tag ( 'elseif ( ' . $ attr [ 'condition ' ] . ' ) : ' ) ; } 
public function list Node Compiler ( array & $ theme ) : void { $ this - > check Node ( $ theme ) ; $ attr = $ this - > get Node Attribute ( $ theme ) ; foreach ( [ 'key ' , 'value ' , 'index ' , ] as $ key ) { null = = = $ attr [ $ key ] & & $ attr [ $ key ] = ' $ ' . $ key ; } foreach ( [ 'for ' , 'key ' , 'value ' , 'index ' , ] as $ key ) { if ( ' $ ' . $ key = = = $ attr [ $ key ] ) { continue ; } $ attr [ $ key ] = $ this - > parse Content ( $ attr [ $ key ] ) ; } 
public function lists Node Compiler ( array & $ theme ) : void { $ this - > check Node ( $ theme ) ; $ attr = $ this - > get Node Attribute ( $ theme ) ; null = = = $ attr [ 'index ' ] & & $ attr [ 'index ' ] = 'index ' ; null = = = $ attr [ 'key ' ] & & $ attr [ 'key ' ] = 'key ' ; null = = = $ attr [ 'id ' ] & & $ attr [ 'id ' ] = 'id ' ; null = = = $ attr [ 'mod ' ] & & $ attr [ 'mod ' ] = 2 ; if ( preg _match ( ' / [ ^ \ \d \ - . , ] / ' , ( string ) ( $ attr [ 'mod ' ] ) ) ) { $ attr [ 'mod ' ] = ' $ ' . $ attr [ 'mod ' ] ; } null = = = $ attr [ 'empty ' ] & & $ attr [ 'empty ' ] = ' ' ; null = = = $ attr [ 'length ' ] & & $ attr [ 'length ' ] = ' ' ; null = = = $ attr [ 'offset ' ] & & $ attr [ 'offset ' ] = ' ' ; $ attr [ 'name ' ] = $ this - > parse Content ( $ attr [ 'name ' ] ) ; $ compiled = [ ] ; $ tmp = 'if (is _array ( ' . $ attr [ 'name ' ] . ' ) ) : ' . PHP _EOL . ' $ ' . $ attr [ 'index ' ] . ' = 0 ; ' . PHP _EOL ; if ( ' ' ! = = $ attr [ 'length ' ] ) { $ tmp . = ' $tmp = array _slice ( ' . $ attr [ 'name ' ] . ' , ' . $ attr [ 'offset ' ] . ' , ' . $ attr [ 'length ' ] . ' ) ; ' ; } elseif ( ' ' ! = = $ attr [ 'offset ' ] ) { $ tmp . = ' $tmp = array _slice ( ' . $ attr [ 'name ' ] . ' , ' . $ attr [ 'offset ' ] . ' ) ; ' ; } else { $ tmp . = ' $tmp = ' . $ attr [ 'name ' ] . ' ; ' ; } $ tmp . = PHP _EOL . ' if ( 0 = = = count ( $tmp ) ) : ' . PHP _EOL . ' echo " ' . $ attr [ 'empty ' ] . ' " ; ' ; $ tmp . = PHP _EOL . ' else : ' ; $ tmp . = PHP _EOL . ' foreach ( $tmp as $ ' . $ attr [ 'key ' ] . ' = > $ ' . $ attr [ 'id ' ] . ' ) : ' ; $ tmp . = PHP _EOL . ' + + $ ' . $ attr [ 'index ' ] . ' ; ' . PHP _EOL ; $ tmp . = ' ' . ' $mod = $ ' . $ attr [ 'index ' ] . ' % ' . $ attr [ 'mod ' ] . ' ; ' ; $ compiled [ ] = $ this - > with Php Tag ( $ tmp ) ; $ compiled [ ] = $ this - > get Node Body ( $ theme ) ; $ compiled [ ] = ' ' . $ this - > with Php Tag ( 'endforeach ; ' . PHP _EOL . ' endif ; ' . PHP _EOL . 'else : ' . PHP _EOL . ' echo " ' . $ attr [ 'empty ' ] . ' " ; ' . PHP _EOL . 'endif ; ' ) ; $ theme [ 'content ' ] = implode ( ' ' , $ compiled ) ; } 
public function include Node Compiler ( array & $ theme ) : void { $ this - > check Node ( $ theme ) ; $ attr = $ this - > get Node Attribute ( $ theme ) ; if ( false = = = strpos ( $ attr [ 'file ' ] , ' ( ' ) ) { 
public function for Node Compiler ( array & $ theme ) : void { $ this - > check Node ( $ theme ) ; $ attr = $ this - > get Node Attribute ( $ theme ) ; null = = = $ attr [ 'step ' ] & & $ attr [ 'step ' ] = ' 1 ' ; null = = = $ attr [ 'start ' ] & & $ attr [ 'start ' ] = ' 0 ' ; null = = = $ attr [ 'end ' ] & & $ attr [ 'end ' ] = ' 0 ' ; null = = = $ attr [ 'var ' ] & & $ attr [ 'var ' ] = 'var ' ; $ attr [ 'var ' ] = ' $ ' . $ attr [ 'var ' ] ; if ( ' - ' = = = $ attr [ 'type ' ] ) { $ comparison = ' > = ' ; $ minus Plus = ' - = ' ; } else { $ comparison = ' < = ' ; $ minus Plus = ' + = ' ; } $ compiled = [ ] ; $ compiled [ ] = $ this - > with Php Tag ( 'for ( ' . $ attr [ 'var ' ] . ' = ' . $ attr [ 'start ' ] . ' ; ' . $ attr [ 'var ' ] . $ comparison . $ attr [ 'end ' ] . ' ; ' . $ attr [ 'var ' ] . $ minus Plus . $ attr [ 'step ' ] . ' ) : ' ) ; $ compiled [ ] = $ this - > get Node Body ( $ theme ) ; $ compiled [ ] = $ this - > with Php Tag ( 'endfor ; ' ) ; $ theme [ 'content ' ] = implode ( ' ' , $ compiled ) ; } 
public function while Node Compiler ( array & $ theme ) : void { $ this - > check Node ( $ theme ) ; $ attr = $ this - > get Node Attribute ( $ theme ) ; $ theme [ 'content ' ] = $ this - > with Php Tag ( 'while ( ' . $ attr [ 'condition ' ] . ' ) : ' ) . $ this - > get Node Body ( $ theme ) . $ this - > with Php Tag ( 'endwhile ; ' ) ; } 
public function php Node Compiler ( array & $ theme ) : void { $ this - > check Node ( $ theme ) ; $ theme [ 'content ' ] = $ this - > with Php Tag ( $ this - > get Node Body ( $ theme ) ) ; } 
public function attribute Node Compiler ( array & $ theme ) : void { $ source = trim ( $ theme [ 'content ' ] ) ; $ source = $ this - > escape Regex Character ( $ source ) ; if ( true = = = $ theme [ 'is _js ' ] ) { $ tag = $ this - > js Tag ; } else { $ tag = $ this - > node Tag ; } $ allowed Attr = $ tag [ $ theme [ 'parent _name ' ] ] [ 'attr ' ] ; 
protected function parse Content If ( string $ content , ? string $ type = null ) : string { $ param = [ ] ; foreach ( explode ( ' ' , $ content ) as $ value ) { if ( strpos ( $ value , ' . ' ) > 0 ) { $ args = explode ( ' . ' , $ value ) ; $ param [ ] = $ args [ 0 ] . ( $ this - > array Handler ( $ args , true , 1 ) ) ; } else { $ param [ ] = $ value ; } } $ result = implode ( ' ' , $ param ) ; if ( null = = = $ type ) { return $ result ; } return $ type . "if ( { $result } ) " ; } 
protected function parse Jcontent ( string $ content ) : string { $ var = explode ( ' | ' , $ content ) ; $ content = array _shift ( $ var ) ; $ content = $ this - > parse Expression ( $ content ) ; if ( count ( $ var ) > 0 ) { return $ this - > parse Js Function ( $ content , $ var ) ; } return $ content ; } 
protected function parse Expression ( string $ content ) : string { $ content = trim ( $ content ) ; $ logic = [ ' + ' , ' - ' , ' . ' , ' ( ' , ' ) ' , ' / ' , ' % ' , ' * ' , ' ? ' , ' : ' , ' < ' , ' > ' , ' = ' , ' | ' , ' & ' , ' ~ ' , ' ! ' , ] ; $ result = [ ] ; 
protected function parse Content ( string $ content , bool $ is Func = true ) : string { 
protected function parse Var Function ( string $ name , array $ var , bool $ is Javascript = false ) : string { $ len = count ( $ var ) ; for ( $ index = 0 ; $ index < $ len ; $ index + + ) { if ( 0 = = = stripos ( $ var [ $ index ] , 'default = ' ) ) { $ args = explode ( ' = ' , $ var [ $ index ] , 2 ) ; } else { $ args = explode ( ' = ' , $ var [ $ index ] ) ; } $ args [ 0 ] = trim ( $ args [ 0 ] ) ; if ( false = = = $ is Javascript & & isset ( $ args [ 1 ] ) ) { $ args [ 1 ] = str _replace ( ' - > ' , ' : ' , $ args [ 1 ] ) ; } switch ( strtolower ( $ args [ 0 ] ) ) { 
protected function array Handler ( array & $ vars , bool $ for Obj = true , int $ start = 2 ) : string { $ len = count ( $ vars ) ; $ param = ' ' ; for ( $ index = $ start ; $ index < $ len ; $ index + + ) { if ( true = = = $ for Obj ) { 
protected function encode Content ( string $ content , string $ type = ' ' ) : string { if ( 'global ' = = = $ type ) { $ content = Parser : : global Encode ( $ content ) ; } elseif ( in _array ( $ type , [ 'revert ' , 'include ' ] , true ) ) { $ content = base 6 4 _decode ( $ content , true ) ; } else { $ content = Parser : : revert Encode ( $ content ) ; } return $ content ; } 
protected function check Node ( array $ theme , bool $ js Node = false ) : bool { $ attribute = $ theme [ 'children ' ] [ 0 ] ; 
protected function get Node Attribute ( array $ theme ) : array { foreach ( $ theme [ 'children ' ] as $ child ) { if ( isset ( $ child [ 'is _attribute ' ] ) & & true = = = $ child [ 'is _attribute ' ] ) { return $ child [ 'attribute _list ' ] ; } } return [ ] ; } 
protected function get Node Body ( array $ theme ) { foreach ( $ theme [ 'children ' ] as $ child ) { if ( isset ( $ child [ 'is _body ' ] ) & & true = = = $ child [ 'is _body ' ] ) { return $ child [ 'content ' ] ; } } } 
protected function escape Regex Character ( string $ txt , bool $ esc = true ) : string { $ txt = $ this - > escape Character ( $ txt , $ esc ) ; if ( ! $ esc ) { $ txt = str _replace ( [ ' band ' , ' bxor ' , ' bor ' , ' bnot ' , ' bleft ' , ' bright ' , ' and ' , ' or ' , ' not ' , ' dot ' , ' nheq ' , ' heq ' , ' neq ' , ' eq ' , ' egt ' , ' gt ' , ' elt ' , ' lt ' , ] , [ ' & ' , ' ^ ' , ' | ' , ' ~ ' , ' < < ' , ' > > ' , ' & & ' , ' | | ' , ' ! = ' , ' - > ' , ' ! = = ' , ' = = = ' , ' ! = ' , ' = = ' , ' > = ' , ' > ' , ' < = ' , ' < ' , ] , $ txt ) ; } return $ txt ; } 
protected function escape Character ( string $ txt , bool $ esc = true ) : string { if ( ' " " ' = = = $ txt ) { $ txt = ' ' ; } if ( $ esc ) { 
public function set Default Driver ( string $ name ) : void { $ option = $ this - > get Container Option ( 'default ' ) ; $ this - > set Container Option ( $ option . ' _default ' , $ name ) ; } 
protected function make Connect Session ( array $ options = [ ] ) : Session { $ options = array _merge ( $ this - > normalize Connect Option ( 'session ' , $ options ) ) ; return new Session ( $ this - > container [ 'session ' ] , $ options ) ; } 
protected function make Connect Token ( array $ options = [ ] ) : Token { $ options = array _merge ( $ this - > normalize Connect Option ( 'token ' , $ options ) ) ; return new Token ( $ this - > container [ 'cache ' ] , $ this - > container [ 'request ' ] , $ options ) ; } 
public static function singletons ( ? string $ path = null ) : IApp { if ( null ! = = static : : $ app ) { return static : : $ app ; } return static : : $ app = new static ( $ path ) ; } 
public function make ( string $ name , array $ args = [ ] ) { $ name = $ this - > get Alias ( $ name ) ; if ( isset ( $ this - > deferred Providers [ $ name ] ) ) { $ this - > register Deferred Provider ( $ name ) ; } return parent : : make ( $ name , $ args ) ; } 
public function app Path ( $ app = false , string $ path = ' ' ) : string { return ( $ this - > app Path ? ? $ this - > path . \ DIRECTORY _SEPARATOR . 'application ' ) . ( $ app ? \ DIRECTORY _SEPARATOR . $ this - > normalize App ( $ app ) : $ app ) . $ this - > normalize Path ( $ path ) ; } 
public function common Path ( string $ path = ' ' ) : string { return ( $ this - > common Path ? ? $ this - > path . \ DIRECTORY _SEPARATOR . 'common ' ) . $ this - > normalize Path ( $ path ) ; } 
public function runtime Path ( string $ path = ' ' ) : string { return ( $ this - > runtime Path ? ? $ this - > path . \ DIRECTORY _SEPARATOR . 'runtime ' ) . $ this - > normalize Path ( $ path ) ; } 
public function storage Path ( string $ path = ' ' ) : string { return ( $ this - > storage Path ? ? $ this - > path . \ DIRECTORY _SEPARATOR . 'storage ' ) . $ this - > normalize Path ( $ path ) ; } 
public function public Path ( string $ path = ' ' ) : string { return ( $ this - > public Path ? ? $ this - > path . \ DIRECTORY _SEPARATOR . 'public ' ) . $ this - > normalize Path ( $ path ) ; } 
public function themes Path ( string $ path = ' ' ) : string { return ( $ this - > themes Path ? ? $ this - > path . \ DIRECTORY _SEPARATOR . 'themes ' ) . $ this - > normalize Path ( $ path ) ; } 
public function option Path ( string $ path = ' ' ) : string { return ( $ this - > option Path ? ? $ this - > path . \ DIRECTORY _SEPARATOR . 'option ' ) . $ this - > normalize Path ( $ path ) ; } 
public function i 1 8n Path ( ? string $ path = null ) : string { return ( $ this - > i 1 8n Path ? ? $ this - > path . \ DIRECTORY _SEPARATOR . 'i 1 8n ' ) . $ this - > normalize Path ( $ path ? : ' ' ) ; } 
public function i 1 8n Cached Path ( string $ i 1 8n ) : string { $ base Path = $ this - > i 1 8n Cached Path ? : $ this - > path ( ) . ' /bootstrap /i 1 8n ' ; return $ base Path . ' / ' . $ i 1 8n . ' .php ' ; } 
public function option Cached Path ( ) : string { $ base Path = $ this - > option Cached Path ? : $ this - > path ( ) . ' /bootstrap ' ; $ cache = getenv ( 'RUNTIME _ENVIRONMENT ' ) ? : 'option ' ; return $ base Path . ' / ' . $ cache . ' .php ' ; } 
public function namespace Path ( string $ specific Class , bool $ throw Exception = true ) : string { if ( false = = = $ path = $ this - > composer ( ) - > find File ( $ specific Class ) ) { if ( true = = = $ throw Exception ) { $ e = sprintf ( 'Specific class ` %s ` for finding namespaces was not found . ' , $ specific Class ) ; throw new Runtime Exception ( $ e ) ; } return ' ' ; } return dirname ( $ path ) ; } 
public function bootstrap ( array $ bootstraps ) : void { if ( $ this - > is Bootstrap ) { return ; } foreach ( $ bootstraps as $ value ) { ( new $ value ( ) ) - > handle ( $ this ) ; } } 
public function register Providers ( ) : void { if ( $ this - > is Bootstrap ) { return ; } list ( $ this - > deferred Providers , $ deferred Alias ) = $ this - > make ( 'option ' ) - > get ( ' _deferred _providers ' , [ [ ] , [ ] ] ) ; foreach ( $ deferred Alias as $ alias ) { $ this - > alias ( $ alias ) ; } $ providers = $ this - > make ( 'option ' ) - > get ( ' _composer .providers ' , [ ] ) ; foreach ( $ providers as $ provider ) { $ provider = $ this - > register ( $ provider ) ; if ( method _exists ( $ provider , 'bootstrap ' ) ) { $ this - > provider Bootstraps [ ] = $ provider ; } } } 
public function bootstrap Providers ( ) : void { if ( $ this - > is Bootstrap ) { return ; } foreach ( $ this - > provider Bootstraps as $ item ) { $ this - > call Provider Bootstrap ( $ item ) ; } $ this - > is Bootstrap = true ; } 
public function register ( $ provider ) : Provider { if ( is _string ( $ provider ) ) { $ provider = $ this - > make Provider ( $ provider ) ; } if ( method _exists ( $ provider , 'register ' ) ) { $ provider - > register ( ) ; } if ( $ this - > is Bootstrap ( ) ) { $ this - > call Provider Bootstrap ( $ provider ) ; } return $ provider ; } 
protected function register Base Provider ( ) : void { $ this - > register ( new Event Provider ( $ this ) ) ; $ this - > register ( new Log Provider ( $ this ) ) ; $ this - > register ( new Router Provider ( $ this ) ) ; } 
protected function register Deferred Provider ( string $ provider ) : void { if ( ! isset ( $ this - > deferred Providers [ $ provider ] ) ) { return ; } $ provider Instance = $ this - > register ( $ this - > deferred Providers [ $ provider ] ) ; $ this - > call Provider Bootstrap ( $ provider Instance ) ; unset ( $ this - > deferred Providers [ $ provider ] ) ; } 
public function validate ( $ value , array $ parameter , IValidator $ validator , string $ field ) : bool { if ( ! array _key _exists ( 0 , $ parameter ) ) { throw new Invalid Argument Exception ( 'Missing the first element of parameter . ' ) ; } if ( ! is _string ( $ parameter [ 0 ] ) & & ! is _object ( $ parameter [ 0 ] ) ) { return false ; } $ select = $ this - > normalize Select ( $ value , $ parameter , $ field ) ; $ this - > parse Except Id ( $ select , $ parameter ) ; $ this - > parse Additional ( $ select , $ parameter ) ; return 0 = = = $ select - > find Count ( ) ; } 
public static function rule ( string $ entity , ? string $ field = null , $ except Id = null , ? string $ primary Key = null , . . . $ additional ) : string { if ( ! type _array ( $ additional , [ 'string ' ] ) ) { $ e = 'Unique additional conditions must be string . ' ; throw new Invalid Argument Exception ( $ e ) ; } $ tmp = [ ] ; $ tmp [ ] = $ entity ; $ tmp [ ] = $ field ? : self : : PLACEHOLDER ; $ tmp [ ] = $ except Id ? : self : : PLACEHOLDER ; $ tmp [ ] = $ primary Key ? : self : : PLACEHOLDER ; $ tmp = array _merge ( $ tmp , $ additional ) ; return 'unique : ' . implode ( ' , ' , $ tmp ) ; } 
protected function normalize Select ( $ value , array $ parameter , string $ field ) : Select { $ entity = $ this - > parse Entity ( $ parameter ) ; if ( isset ( $ parameter [ 1 ] ) & & self : : PLACEHOLDER ! = = $ parameter [ 1 ] ) { $ field = $ parameter [ 1 ] ; } if ( false ! = = strpos ( $ field , self : : SEPARATE ) ) { $ select = $ entity - > self Database Select ( ) ; foreach ( explode ( self : : SEPARATE , $ field ) as $ v ) { $ select - > where ( $ v , $ value ) ; } } else { $ select = $ entity - > where ( $ field , $ value ) ; } return $ select ; } 
protected function parse Entity ( array $ parameter ) : IEntity { $ connect = null ; if ( is _string ( $ parameter [ 0 ] ) ) { if ( false ! = = strpos ( $ parameter [ 0 ] , self : : SEPARATE ) ) { list ( $ connect , $ entity Class ) = explode ( self : : SEPARATE , $ parameter [ 0 ] ) ; } else { $ entity Class = $ parameter [ 0 ] ; } if ( ! class _exists ( $ entity Class ) ) { $ e = sprintf ( 'Validate entity ` %s ` was not found . ' , $ entity Class ) ; throw new Invalid Argument Exception ( $ e ) ; } $ entity = new $ entity Class ( ) ; } else { $ entity = $ parameter [ 0 ] ; } if ( ! ( $ entity instanceof IEntity ) ) { $ e = sprintf ( 'Validate entity ` %s ` must be an entity . ' , get _class ( $ entity ) ) ; throw new Invalid Argument Exception ( $ e ) ; } if ( $ connect ) { $ entity - > with Connect ( $ connect ) ; } return $ entity ; } 
protected function parse Except Id ( Select $ select , array $ parameter ) : void { if ( isset ( $ parameter [ 2 ] ) & & self : : PLACEHOLDER ! = = $ parameter [ 2 ] ) { $ without Primary = true ; if ( ! empty ( $ parameter [ 3 ] ) & & self : : PLACEHOLDER ! = = $ parameter [ 3 ] ) { $ primary Key = $ parameter [ 3 ] ; } else { if ( is _string ( $ _ = $ select - > entity ( ) - > primary Key ( ) ) ) { $ primary Key = $ _ ; } else { $ without Primary = false ; } } if ( $ without Primary ) { $ select - > where ( $ primary Key , ' < > ' , $ parameter [ 2 ] ) ; } } } 
protected function parse Additional ( Select $ select , array $ parameter ) : void { if ( ( $ num = count ( $ parameter ) ) > = 4 ) { for ( $ i = 4 ; $ i < $ num ; $ i + = 2 ) { if ( ! isset ( $ parameter [ $ i + 1 ] ) ) { $ e = 'Unique additional conditions must be paired . ' ; throw new Invalid Argument Exception ( $ e ) ; } if ( false ! = = strpos ( $ parameter [ $ i ] , self : : SEPARATE ) ) { list ( $ field , $ operator ) = explode ( self : : SEPARATE , $ parameter [ $ i ] ) ; } else { $ field = $ parameter [ $ i ] ; $ operator = ' = ' ; } $ select - > where ( $ field , $ operator , $ parameter [ $ i + 1 ] ) ; } } } 
public function clear ( ) : void { foreach ( $ this - > pool - > get Pools ( ) as $ class Name = > & $ pool ) { while ( $ pool - > count ( ) ) { $ pool - > shift ( ) ; } } $ this - > log ( 'The object pool has cleared . ' ) ; } 
public function reset ( array $ query = [ ] , array $ request = [ ] , array $ params = [ ] , array $ cookies = [ ] , array $ files = [ ] , array $ server = [ ] , $ content = null ) : void { $ this - > query = new Bag ( $ query ) ; $ this - > request = new Bag ( $ request ) ; $ this - > params = new Bag ( $ params ) ; $ this - > cookies = new Bag ( $ cookies ) ; $ this - > files = new File Bag ( $ files ) ; $ this - > server = new Server Bag ( $ server ) ; $ this - > headers = new Header Bag ( $ this - > server - > get Headers ( ) ) ; $ this - > content = $ content ; $ this - > base Url = null ; $ this - > request Uri = null ; $ this - > method = null ; $ this - > path Info = null ; $ this - > language = null ; } 
public static function create From Globals ( ) : IRequest { $ request = new static ( $ _GET , $ _POST , [ ] , $ _COOKIE , $ _FILES , $ _SERVER , null ) ; $ request = static : : normalize Request From Content ( $ request ) ; return $ request ; } 
public static function normalize Request From Content ( IRequest $ request ) : IRequest { $ content Type = $ request - > headers - > get ( 'CONTENT _TYPE ' ) ; $ method = strtoupper ( $ request - > server - > get ( 'REQUEST _METHOD ' , self : : METHOD _GET ) ) ; if ( $ content Type ) { if ( 0 = = = strpos ( $ content Type , 'application /x -www -form -urlencoded ' ) & & in _array ( $ method , [ static : : METHOD _PUT , static : : METHOD _DELETE , static : : METHOD _PATCH , ] , true ) ) { parse _str ( $ request - > get Content ( ) , $ data ) ; $ request - > request = new Bag ( $ data ) ; } elseif ( 0 = = = strpos ( $ content Type , 'application /json ' ) & & $ content = $ request - > get Content ( ) ) { $ request - > request = new Bag ( json _decode ( $ content , true ) ) ; } } return $ request ; } 
public function get ( string $ key , $ defaults = null ) { $ all = $ this - > all ( ) ; if ( array _key _exists ( $ key , $ all ) ) { return $ all [ $ key ] ; } return $ this - > params - > get ( $ key , $ defaults ) ; } 
public function exists ( array $ keys ) : bool { $ input = $ this - > all ( ) ; foreach ( $ keys as $ value ) { if ( ! array _key _exists ( $ value , $ input ) ) { return false ; } } return true ; } 
public function has ( array $ keys ) : bool { foreach ( $ keys as $ value ) { if ( $ this - > is Empty String ( $ value ) ) { return false ; } } return true ; } 
public function only ( array $ keys ) : array { $ results = [ ] ; $ input = $ this - > all ( ) ; foreach ( $ keys as $ key ) { $ results [ $ key ] = $ input [ $ key ] ? ? null ; } return $ results ; } 
public function except ( array $ keys ) : array { $ results = $ this - > all ( ) ; foreach ( $ keys as $ key ) { if ( array _key _exists ( $ key , $ results ) ) { unset ( $ results [ $ key ] ) ; } } return $ results ; } 
public function input ( ? string $ key = null , $ defaults = null ) { $ input = $ this - > get Input Source ( ) - > all ( ) + $ this - > query - > all ( ) ; if ( null = = = $ key ) { return $ input ; } return $ input [ $ key ] ? ? $ defaults ; } 
public function query ( ? string $ key = null , $ defaults = null ) { return $ this - > get Item ( 'query ' , $ key , $ defaults ) ; } 
public function cookie ( ? string $ key = null , $ defaults = null ) { return $ this - > get Item ( 'cookies ' , $ key , $ defaults ) ; } 
public function file ( ? string $ key = null , $ defaults = null ) { if ( ! $ key | | false = = = strpos ( $ key , ' \ \ ' ) ) { return $ this - > get Item ( 'files ' , $ key , $ defaults ) ; } return $ this - > files - > get Arr ( $ key , is _array ( $ defaults ) ? $ defaults : [ ] ) ; } 
public function header ( ? string $ key = null , $ defaults = null ) { return $ this - > get Item ( 'headers ' , $ key , $ defaults ) ; } 
public function server ( ? string $ key = null , $ defaults = null ) { return $ this - > get Item ( 'server ' , $ key , $ defaults ) ; } 
public function get Item ( string $ source , ? string $ key , $ defaults ) { if ( null = = = $ key ) { return $ this - > { $ source } - > all ( ) ; } return $ this - > { $ source } - > get ( $ key , $ defaults ) ; } 
public function is Ajax ( ) : bool { $ field = static : : VAR _AJAX ; if ( $ this - > request - > has ( $ field ) | | $ this - > query - > has ( $ field ) ) { return true ; } return $ this - > is Real Ajax ( ) ; } 
public function is Pjax ( ) : bool { $ field = static : : VAR _PJAX ; if ( $ this - > request - > has ( $ field ) | | $ this - > query - > has ( $ field ) ) { return true ; } return $ this - > is Real Pjax ( ) ; } 
public function is Json ( ) : bool { $ field = static : : VAR _JSON ; if ( $ this - > request - > has ( $ field ) | | $ this - > query - > has ( $ field ) ) { return true ; } return $ this - > is Real Json ( ) ; } 
public function is Real Json ( ) : bool { $ content Type = $ this - > headers - > get ( 'CONTENT _TYPE ' ) ; if ( ! $ content Type ) { return false ; } foreach ( [ ' /json ' , ' +json ' ] as $ item ) { if ( false ! = = strpos ( $ content Type , $ item ) ) { return true ; } } return false ; } 
public function is Accept Json ( ) : bool { $ field = static : : VAR _ACCEPT _JSON ; if ( $ this - > request - > has ( $ field ) | | $ this - > query - > has ( $ field ) ) { return true ; } if ( $ this - > is Ajax ( ) & & ! $ this - > is Pjax ( ) & & $ this - > is Accept Any ( ) ) { return true ; } return $ this - > is Real Accept Json ( ) ; } 
public function is Real Accept Json ( ) : bool { $ accept = $ this - > headers - > get ( 'ACCEPT ' ) ; if ( ! $ accept ) { return false ; } foreach ( [ ' /json ' , ' +json ' ] as $ item ) { if ( false ! = = strpos ( $ accept , $ item ) ) { return true ; } } return false ; } 
public function is Accept Any ( ) : bool { $ accept = $ this - > headers - > get ( 'ACCEPT ' ) ; if ( ! $ accept ) { return true ; } if ( false ! = = strpos ( $ accept , ' * ' ) ) { return true ; } return false ; } 
public function get Method ( ) : string { if ( null ! = = $ this - > method ) { return $ this - > method ; } $ this - > method = strtoupper ( $ this - > server - > get ( 'REQUEST _METHOD ' , 'GET ' ) ) ; if ( 'POST ' = = = $ this - > method ) { if ( $ method = $ this - > headers - > get ( 'X -HTTP -METHOD -OVERRIDE ' ) ) { $ this - > method = strtoupper ( $ method ) ; } else { $ field = static : : VAR _METHOD ; $ this - > method = strtoupper ( $ this - > request - > get ( $ field , $ this - > query - > get ( $ field , 'POST ' ) ) ) ; } } return $ this - > method ; } 
public function set Method ( string $ method ) : IRequest { $ this - > method = null ; $ this - > server - > set ( 'REQUEST _METHOD ' , $ method ) ; return $ this ; } 
public function get Content ( ) : string { $ resources = is _resource ( $ this - > content ) ; if ( $ resources ) { rewind ( $ this - > content ) ; return stream _get _contents ( $ this - > content ) ; } if ( null = = = $ this - > content ) { $ this - > content = file _get _contents ( 'php : / /input ' ) ; } return $ this - > content ; } 
public function get Enter ( ) : string { if ( $ this - > is Cli ( ) ) { return ' ' ; } $ script Name = $ this - > get Script Name ( ) ; $ script Name = dirname ( $ script Name ) ; if ( ' \ \ ' = = = $ script Name ) { $ script Name = ' / ' ; } return $ script Name ; } 
public function is Secure ( ) : bool { if ( in _array ( $ this - > server - > get ( 'HTTPS ' ) , [ ' 1 ' , 'on ' ] , true ) ) { return true ; } if ( ' 4 4 3 ' = = = $ this - > server - > get ( 'SERVER _PORT ' ) ) { return true ; } return false ; } 
public function get Host ( ) : string { $ host = $ this - > headers - > get ( 'X _FORWARDED _HOST ' , $ this - > headers - > get ( 'HOST ' , ' ' ) ) ; if ( ! $ host ) { $ host = $ this - > server - > get ( 'SERVER _NAME ' , $ this - > server - > get ( 'SERVER _ADDR ' , ' ' ) ) ; } if ( false ! = = strpos ( $ host , ' : ' ) ) { list ( $ host ) = explode ( ' : ' , $ host ) ; } return $ host ; } 
public function get Uri ( ) : string { if ( null ! = = $ query String = $ this - > get Query String ( ) ) { $ query String = ' ? ' . $ query String ; } return $ this - > get Scheme And Http Host ( ) . rtrim ( $ this - > get Base Url ( ) , ' / ' ) . $ this - > get Path Info ( ) . $ query String ; } 
public function get Port ( ) : int { $ port = ( int ) $ this - > server - > get ( 'SERVER _PORT ' ) ; if ( ! $ port ) { $ port = 'https ' = = = $ this - > get Scheme ( ) ? 4 4 3 : 8 0 ; } return $ port ; } 
public function get Query String ( ) : ? string { $ query String = $ this - > normalize Query String ( $ this - > server - > get ( 'QUERY _STRING ' ) ) ; return ' ' = = = $ query String & & ' 0 ' ! = = $ query String ? null : $ query String ; } 
public function get Path Info ( ) : string { if ( null ! = = $ this - > path Info ) { return $ this - > path Info ; } $ path Info = $ this - > server - > get ( 'PATH _INFO ' ) ; if ( $ path Info ) { return $ this - > path Info = $ this - > parse Path Info ( $ path Info ) ; } 
public function get Base Path ( ) : string { if ( null ! = = $ this - > base Path ) { return $ this - > base Path ; } $ base Url = $ this - > get Base Url ( ) ; if ( empty ( $ base Url ) ) { return ' ' ; } $ filename = basename ( $ this - > server - > get ( 'SCRIPT _FILENAME ' , ' ' ) ) ; if ( basename ( $ base Url ) = = = $ filename ) { $ base Path = dirname ( $ base Url ) ; } else { $ base Path = $ base Url ; } if ( ' \ \ ' = = = \ DIRECTORY _SEPARATOR ) { $ base Path = str _replace ( ' \ \ ' , ' / ' , $ base Path ) ; } $ this - > base Path = rtrim ( $ base Path , ' / ' ) ; return $ this - > base Path ; } 
public function get Base Url ( ) : string { if ( null ! = = $ this - > base Url ) { return $ this - > base Url ; } 
public function get Request Uri ( ) : ? string { if ( null ! = = $ this - > request Uri ) { return $ this - > request Uri ; } $ request Uri = $ this - > headers - > get ( 'X _REWRITE _URL ' , $ this - > server - > get ( 'REQUEST _URI ' , ' ' ) ) ; if ( ! $ request Uri ) { $ request Uri = $ this - > server - > get ( 'ORIG _PATH _INFO ' ) ; if ( $ this - > server - > get ( 'QUERY _STRING ' ) ) { $ request Uri . = ' ? ' . $ this - > server - > get ( 'QUERY _STRING ' ) ; } } return $ this - > request Uri = $ request Uri ; } 
protected function parse Path Info ( string $ path Info ) : string { if ( $ path Info ) { $ ext = pathinfo ( $ path Info , PATHINFO _EXTENSION ) ; if ( $ ext ) { $ path Info = substr ( $ path Info , 0 , - ( strlen ( $ ext ) + 1 ) ) ; } } $ path Info = empty ( $ path Info ) ? ' / ' : ' / ' . ltrim ( $ path Info , ' / ' ) ; return $ path Info ; } 
protected function normalize Query String ( ? string $ query String ) : string { if ( ! $ query String & & ' 0 ' ! = = $ query String ) { return ' ' ; } $ parts = [ ] ; foreach ( explode ( ' & ' , $ query String ) as $ item ) { if ( ' ' = = = $ item & & ' 0 ' ! = = $ item ) { continue ; } $ parts [ ] = $ item ; } return implode ( ' & ' , $ parts ) ; } 
protected function is Empty String ( string $ key ) : bool { $ value = $ this - > input ( $ key ) ; return is _string ( $ value ) & & ' ' = = = trim ( $ value ) & & ' 0 ' ! = = $ value ; } 
protected function get Urlencoded Prefix ( string $ strings , string $ prefix ) { if ( 0 ! = = strpos ( rawurldecode ( $ strings ) , $ prefix ) ) { return false ; } $ len = strlen ( $ prefix ) ; if ( preg _match ( sprintf ( ' # ^ ( % % [ [ :xdigit : ] ] { 2 } | . ) { %d } # ' , $ len ) , $ strings , $ matches ) ) { return $ matches [ 0 ] ; } return false ; } 
protected function close ( array $ option ) : void { $ pid File = $ option [ 'pid _path ' ] ; $ process Name = $ option [ 'process _name ' ] ; if ( ! file _exists ( $ pid File ) ) { throw new Invalid Argument Exception ( sprintf ( 'Pid path ` %s ` was not found . ' , $ pid File ) ) ; } $ pids = explode ( PHP _EOL , file _get _contents ( $ pid File ) ) ; $ pid = ( int ) $ pids [ 0 ] ; if ( ! Process : : kill ( $ pid , 0 ) ) { throw new Invalid Argument Exception ( sprintf ( 'Pid ` %s ` was not found . ' , $ pid ) ) ; } Process : : kill ( $ pid , SIGKILL ) ; if ( is _file ( $ pid File ) ) { unlink ( $ pid File ) ; } $ this - > info ( sprintf ( 'Process %s : %d has stoped . ' , $ process Name , $ pid ) , true ) ; } 
public function ifs ( $ value = false ) : self { return $ this - > set Flow Control ( true , $ value ? true : false ) ; } 
public function else Ifs ( $ value = false ) : self { return $ this - > set Flow Control ( true , $ value ? true : false ) ; } 
public function set Flow Control ( bool $ in Flow Control , bool $ is Flow Control True ) : self { $ this - > in Flow Control = $ in Flow Control ; $ this - > is Flow Control True = $ is Flow Control True ; return $ this ; } 
public function set Option ( string $ name , $ value ) : IMail { $ this - > option [ $ name ] = $ value ; return $ this ; } 
public function global From ( string $ address , ? string $ name = null ) : IMail { $ this - > set Option ( 'global _from ' , compact ( 'address ' , 'name ' ) ) ; return $ this ; } 
public function view ( string $ file , array $ data = [ ] ) : IMail { $ this - > message Data [ 'html ' ] [ ] = [ 'file ' = > $ file , 'data ' = > $ data , ] ; return $ this ; } 
public function view Plain ( string $ file , array $ data = [ ] ) : IMail { $ this - > message Data [ 'plain ' ] [ ] = [ 'file ' = > $ file , 'data ' = > $ data , ] ; return $ this ; } 
public function message ( Closure $ callbacks ) : IMail { $ this - > callback Message ( $ callbacks , $ this - > make Message ( ) ) ; return $ this ; } 
public function attach ( string $ file , Closure $ callbacks = null ) : IMail { $ this - > make Message ( ) ; return $ this - > callback Attachment ( $ this - > create Path Attachment ( $ file ) , $ callbacks ) ; } 
public function attach Data ( string $ data , string $ name , Closure $ callbacks = null ) : IMail { $ this - > make Message ( ) ; return $ this - > callback Attachment ( $ this - > create Data Attachment ( $ data , $ name ) , $ callbacks ) ; } 
public function attach View ( string $ file ) : string { $ this - > make Message ( ) ; return $ this - > message - > embed ( Swift _Image : : from Path ( $ file ) ) ; } 
public function attach Data View ( string $ data , string $ name , ? string $ content Type = null ) : string { $ this - > make Message ( ) ; return $ this - > message - > embed ( new Swift _Image ( $ data , $ name , $ content Type ) ) ; } 
public function attach Chinese ( string $ file ) : string { $ ext = pathinfo ( $ file , PATHINFO _EXTENSION ) ; if ( $ ext ) { $ file = substr ( $ file , 0 , strrpos ( $ file , ' . ' . $ ext ) ) ; } return ' = ?UTF - 8 ?B ? ' . base 6 4 _encode ( $ file ) . ' ? = ' . ( $ ext ? ' . ' . $ ext : ' ' ) ; } 
public function send ( Closure $ callbacks = null , bool $ html Priority = true ) : int { $ this - > make Message ( ) ; $ this - > parse Mail Content ( $ html Priority ) ; if ( $ callbacks ) { $ this - > message ( $ callbacks ) ; } if ( ! empty ( $ this - > option [ 'global _to ' ] [ 'address ' ] ) ) { $ this - > message - > add To ( $ this - > option [ 'global _to ' ] [ 'address ' ] , $ this - > option [ 'global _to ' ] [ 'name ' ] ) ; } $ this - > handle Dispatch ( $ this - > message ) ; return $ this - > send Message ( $ this - > message ) ; } 
protected function handle Dispatch ( Swift _Message $ message ) : void { if ( $ this - > dispatch ) { $ this - > dispatch - > handle ( self : : MAIL _EVENT , $ message ) ; } } 
protected function get View Data ( string $ file , array $ data ) : string { return $ this - > view - > clear Assign ( ) - > assign ( 'mail ' , $ this ) - > assign ( $ data ) - > display ( $ file , [ ] , null ) ; } 
protected function parse Mail Content ( bool $ html Priority = true ) : void { $ find Body = false ; $ message Data = $ this - > message Data ; if ( ! empty ( $ message Data [ 'html ' ] ) & & ! empty ( $ message Data [ 'plain ' ] ) ) { unset ( $ message Data [ true = = = $ html Priority ? 'plain ' : 'html ' ] ) ; } if ( ! empty ( $ message Data [ 'html ' ] ) ) { foreach ( $ message Data [ 'html ' ] as $ view ) { if ( false = = = $ find Body ) { $ method = 'set Body ' ; $ find Body = true ; } else { $ method = 'add Part ' ; } $ this - > message - > { $ method } ( is _array ( $ view ) ? $ this - > get View Data ( $ view [ 'file ' ] , $ view [ 'data ' ] ) : $ view , 'text /html ' ) ; } } if ( ! empty ( $ message Data [ 'plain ' ] ) ) { foreach ( $ message Data [ 'plain ' ] as $ view ) { if ( false = = = $ find Body ) { $ method = 'set Body ' ; $ find Body = true ; } else { $ method = 'add Part ' ; } $ this - > message - > { $ method } ( is _array ( $ view ) ? $ this - > get View Data ( $ view [ 'file ' ] , $ view [ 'data ' ] ) : $ view , 'text /plain ' ) ; } } } 
protected function send Message ( Swift _Message $ message ) : int { return $ this - > connect - > send ( $ message , $ this - > failed Recipients ) ; } 
protected function make Message ( ) : Swift _Message { if ( null ! = = $ this - > message ) { return $ this - > message ; } $ message = new Swift _Message ( ) ; if ( ! empty ( $ this - > option [ 'global _from ' ] [ 'address ' ] ) ) { $ message - > set From ( $ this - > option [ 'global _from ' ] [ 'address ' ] , $ this - > option [ 'global _from ' ] [ 'name ' ] ) ; } return $ this - > message = $ message ; } 
protected function callback Attachment ( Swift _Attachment $ attachment , Closure $ callbacks = null ) : IMail { if ( $ callbacks ) { $ callbacks ( $ attachment , $ this ) ; } $ this - > message - > attach ( $ attachment ) ; return $ this ; } 
public function get Cache Path ( string $ file ) : string { if ( ! $ this - > option [ 'cache _path ' ] ) { throw new Runtime Exception ( 'Theme cache path must be set . ' ) ; } $ file = str _replace ( ' / / ' , ' / ' , str _replace ( ' \ \ ' , ' / ' , $ file ) ) ; $ file = basename ( $ file , ' . ' . pathinfo ( $ file , PATHINFO _EXTENSION ) ) . ' . ' . md 5 ( $ file ) . ' .php ' ; return $ this - > option [ 'cache _path ' ] . ' / ' . $ file ; } 
protected function parser ( ) : IParser { if ( null ! = = $ this - > parser ) { return $ this - > parser ; } return $ this - > parser = $ this - > resolver Parser ( ) ; } 
protected function is Cache Expired ( string $ file , string $ cachepath ) : bool { if ( ! is _file ( $ cachepath ) ) { return true ; } if ( filemtime ( $ file ) > = filemtime ( $ cachepath ) ) { return true ; } return false ; } 
public function call ( Request $ request ) : Response { $ http Request = $ this - > normalize Request ( $ request ) ; $ response = App : : make ( IKernel : : class ) - > handle ( $ http Request ) ; return $ this - > normalize Response ( $ response ) ; } 
protected function normalize Response ( IResponse $ response ) : Response { if ( $ response instanceof Redirect Response ) { $ content = json _encode ( [ 'target _url ' = > $ response - > get Target Url ( ) ] ) ; } else { $ content = $ response - > get Content ( ) ; } return new Response ( [ 'status ' = > $ response - > get Status Code ( ) , 'data ' = > $ content , ] ) ; } 
protected function normalize Request ( Request $ request ) : Http Request { if ( ! $ request - > call ) { throw new Invalid Argument Exception ( 'Rpc call is not set . ' ) ; } $ http Request = new Http Request ( ) ; 
protected function set Pre Request Matched ( IRequest $ request , array $ data ) : void { App : : make ( IRouter : : class ) - > set Pre Request Matched ( $ request , [ IRouter : : VARS = > $ data ] ) ; } 
public function add Scandir ( string $ dir ) : void { if ( ! is _dir ( $ dir ) ) { throw new Invalid Argument Exception ( sprintf ( 'Open Api scandir %s is exits . ' , $ dir ) ) ; } $ this - > scandirs [ ] = $ dir ; } 
public function handle ( ) : array { $ open Api = $ this - > make Open Api ( ) ; $ this - > parse Main Path ( $ open Api ) ; $ routers = $ this - > normalize Fast Route ( $ this - > parse Main Routers ( $ open Api ) ) ; return $ this - > package Routers ( $ routers ) ; } 
protected function parse Main Path ( Open Api $ open Api ) : void { list ( $ this - > base Paths , $ this - > group Paths ) = $ this - > parse Paths ( $ open Api ) ; $ this - > groups = $ this - > parse Groups ( $ open Api ) ; } 
protected function parse Main Routers ( Open Api $ open Api ) : array { $ routers = [ ] ; if ( $ open Api - > paths ) { foreach ( $ open Api - > paths as $ path ) { $ routers = $ this - > parse Open Api Path ( $ path , $ routers ) ; } } return $ routers ; } 
protected function parse Open Api Path ( Path Item $ path , array $ routers ) : array { foreach ( $ this - > methods as $ m ) { $ method = $ path - > { $ m } ; 
protected function is Router Ignore ( $ method , string $ path ) : bool { if ( ! is _object ( $ method ) | | true = = = $ method - > deprecated | | ( property _exists ( $ method , 'leevel Ignore ' ) & & $ method - > leevel Ignore ) ) { return true ; } 
protected function parse Router Field ( $ method ) : array { $ result = [ ] ; foreach ( $ this - > router Field as $ f ) { $ field = 'leevel ' . ucfirst ( $ f ) ; if ( property _exists ( $ method , $ field ) ) { $ result [ $ f ] = $ method - > { $ field } ; } } return $ result ; } 
protected function parse Router Bind ( $ method , array $ router ) : array { if ( empty ( $ router [ 'bind ' ] ) ) { $ router [ 'bind ' ] = $ this - > parse Bind By Source ( $ method - > _context ) ; } if ( $ router [ 'bind ' ] ) { $ router [ 'bind ' ] = ' \ \ ' . trim ( $ router [ 'bind ' ] , ' \ \ ' ) ; } return $ router ; } 
protected function parse Router Path ( string $ path , array $ group Paths , array $ groups ) : array { $ router Path = $ this - > normalize Path ( $ path ) ; $ path Prefix = ' ' ; if ( $ group Paths ) { foreach ( $ group Paths as $ key = > $ item ) { if ( 0 = = = strpos ( $ router Path , $ key ) ) { $ path Prefix = $ key ; $ router Path = substr ( $ router Path , strlen ( $ key ) ) ; break ; } } } $ prefix = $ router Path [ 1 ] ; $ group Prefix = ' _ ' ; foreach ( $ groups as $ g ) { if ( 0 = = = strpos ( $ router Path , $ g ) ) { $ group Prefix = $ g ; break ; } } $ router Path = $ path Prefix . $ router Path ; return [ $ prefix , $ group Prefix , $ router Path ] ; } 
protected function parse Router Middlewares ( array $ router ) : array { if ( ! empty ( $ router [ 'middlewares ' ] ) ) { $ router [ 'middlewares ' ] = $ this - > middleware Parser - > handle ( normalize ( $ router [ 'middlewares ' ] ) ) ; } return $ router ; } 
protected function parse Router Domain ( array $ router ) : array { $ router [ 'domain ' ] = $ this - > normalize Domain ( $ router [ 'domain ' ] ? ? ' ' , $ this - > domain ? : ' ' ) ; if ( $ router [ 'domain ' ] & & false ! = = strpos ( $ router [ 'domain ' ] , ' { ' ) ) { list ( $ router [ 'domain _regex ' ] , $ router [ 'domain _var ' ] ) = $ this - > rule Regex ( $ router [ 'domain ' ] , $ router , true ) ; } if ( ! $ router [ 'domain ' ] ) { unset ( $ router [ 'domain ' ] ) ; } return $ router ; } 
protected function parse Router Regex ( string $ path , array $ router ) : array { list ( $ router [ 'regex ' ] , $ router [ 'var ' ] ) = $ this - > rule Regex ( $ path , $ router ) ; return $ router ; } 
protected function normalize Fast Route ( array $ routers ) : array { 
protected function parse To Groups ( array & $ routers ) : array { $ groups = [ ] ; $ group Index = 0 ; foreach ( $ routers as $ key = > & $ item ) { $ groups [ ( int ) ( $ group Index / 1 0 ) ] [ $ key ] = $ item ; unset ( $ item [ 'regex ' ] ) ; $ group Index + + ; } return $ groups ; } 
protected function parse Group Regex ( array $ routers ) : array { $ min Count = $ this - > compute Min Count Var ( $ routers ) ; $ regex = [ ] ; $ rule Map = [ ] ; $ rule Key = 0 ; $ regex [ ] = ' ~ ^ ( ? ' ; foreach ( $ routers as $ key = > $ router ) { $ count Var = $ min Count + $ rule Key ; $ empty Matche = $ count Var - count ( $ router [ 'var ' ] ) ; $ rule Map [ $ count Var + 1 ] = $ key ; $ regex [ ] = ' | ' . $ router [ 'regex ' ] . ( $ empty Matche ? str _repeat ( ' ( ) ' , $ empty Matche ) : ' ' ) ; $ rule Key + + ; } $ regex [ ] = ' ) $ ~x ' ; return [ implode ( ' ' , $ regex ) , $ rule Map , ] ; } 
protected function compute Min Count Var ( array $ routers ) : int { $ min Count = 1 ; foreach ( $ routers as $ item ) { if ( ( $ cur Count = count ( $ item [ 'var ' ] ) ) > $ min Count ) { $ min Count = $ cur Count ; } } return $ min Count ; } 
protected function parse Bind By Source ( Context $ context ) : ? string { if ( ! $ context - > class | | ! $ context - > method ) { return null ; } return $ context - > fully Qualified Name ( $ context - > class ) . ' @ ' . $ context - > method ; } 
protected function parse Groups ( Open Api $ open Api ) : array { $ groups = [ ] ; if ( $ open Api - > tags ) { foreach ( $ open Api - > tags as $ tag ) { if ( property _exists ( $ tag , 'leevel Group ' ) ) { $ groups [ ] = ' / ' . $ tag - > leevel Group ; } } } return $ groups ; } 
protected function rule Regex ( string $ rule , array $ routers , bool $ for Single Regex = false ) : array { $ router Var = [ ] ; $ map Regex = [ 'find ' = > [ ] , 'replace ' = > [ ] , ] ; $ rule = preg _replace _callback ( ' / { ( . + ? ) } / ' , function ( $ matches ) use ( $ routers , & $ router Var , & $ map Regex ) { if ( false ! = = strpos ( $ matches [ 1 ] , ' : ' ) ) { list ( $ router Var [ ] , $ regex ) = explode ( ' : ' , $ matches [ 1 ] ) ; } else { $ router Var [ ] = $ matches [ 1 ] ; $ regex = IRouter : : DEFAULT _REGEX ; } $ regex = ' ( ' . $ regex . ' ) ' ; $ regex Encode = ' ` ' . md 5 ( $ regex ) . ' ` ' ; $ map Regex [ 'find ' ] [ ] = $ regex Encode ; $ map Regex [ 'replace ' ] [ ] = $ regex ; return $ regex Encode ; } , $ rule ) ; if ( false = = = $ for Single Regex ) { $ rule = preg _quote ( $ rule ) ; } else { $ rule = preg _quote ( $ rule , ' / ' ) ; } if ( $ map Regex [ 'find ' ] ) { $ rule = str _replace ( $ map Regex [ 'find ' ] , $ map Regex [ 'replace ' ] , $ rule ) ; } if ( true = = = $ for Single Regex ) { $ rule = ' / ^ ' . $ rule . ' $ / ' ; } return [ $ rule , $ router Var ] ; } 
protected function normalize Domain ( string $ domain , string $ top Domain ) : string { if ( ! $ domain | | ! $ this - > domain ) { return $ domain ; } if ( $ top Domain ! = = substr ( $ domain , - strlen ( $ top Domain ) ) ) { $ domain . = ' . ' . $ top Domain ; } return $ domain ; } 
protected function parse Paths ( Open Api $ open Api ) : array { if ( \ Open Api \ UNDEFINED = = = $ open Api - > external Docs ) { return [ [ ] , [ ] ] ; } $ external Docs = $ open Api - > external Docs ; if ( ! property _exists ( $ external Docs , 'leevels ' ) ) { return [ [ ] , [ ] ] ; } $ leevels = $ external Docs - > leevels ; $ tmps = is _array ( $ leevels ) ? $ leevels : [ $ leevels ] ; $ base Paths = $ group Paths = [ ] ; foreach ( $ tmps as $ key = > $ value ) { 
protected function cache Load ( ) : void { $ this - > container - > singleton ( 'cache .load ' , function ( IContainer $ container ) { return new Load ( $ container , $ container [ 'cache ' ] ) ; } ) ; } 
public function handle ( IApp $ app ) : void { $ this - > line ( 'Start to cache option . ' ) ; $ load = new Load ( $ app - > option Path ( ) ) ; $ data = $ load - > load Data ( $ app ) ; $ cache Path = $ app - > option Cached Path ( ) ; $ this - > base Path = $ app - > path ( ) ; $ this - > write Cache ( $ cache Path , $ data ) ; $ this - > info ( sprintf ( 'Option cache file %s cache successed . ' , $ cache Path ) ) ; } 
protected function compute Relative Path ( string $ cache Path ) : int { if ( false = = = strpos ( $ cache Path , $ this - > base Path ) ) { return - 1 ; } $ relative Path = str _replace ( $ this - > base Path . ' / ' , ' ' , $ cache Path ) ; $ relative Path = dirname ( $ relative Path ) ; return count ( explode ( ' / ' , $ relative Path ) ) ; } 
protected function write Cache ( string $ cache Path , array $ data ) : void { $ relative Path Level = $ this - > compute Relative Path ( $ cache Path ) ; $ is Relative Path = $ relative Path Level > - 1 ; $ content = ' < ? ' . 'php / * ' . date ( 'Y -m -d H :i :s ' ) . ' * / ? ' . ' > ' ; if ( $ is Relative Path ) { $ content . = PHP _EOL . ' < ? ' . 'php $base Dir = dirname ( _ _DIR _ _ , ' . $ relative Path Level . ' ) ; ? > ' ; } $ content . = PHP _EOL . ' < ? ' . 'php return ' . var _export ( $ data , true ) . ' ; ? ' . ' > ' ; if ( $ is Relative Path ) { $ content = $ this - > replace Relative Path ( $ content ) ; } create _file ( $ cache Path , $ content ) ; } 
protected function create Connect ( object $ connect ) : object { return new Mail ( $ connect , $ this - > container [ 'view ' ] , $ this - > container [ 'event ' ] , $ this - > get Common Option ( ) ) ; } 
public function has ( string $ name = 'app \ \ ' ) : bool { $ name = $ this - > parse Namespace ( $ name ) ; $ namespaces = $ name [ 0 ] ; $ name = $ name [ 1 ] ; if ( ' * ' = = = $ name ) { return isset ( $ this - > option [ $ namespaces ] ) ; } if ( ! strpos ( $ name , ' . ' ) ) { return array _key _exists ( $ name , $ this - > option [ $ namespaces ] ) ; } $ parts = explode ( ' . ' , $ name ) ; $ option = $ this - > option [ $ namespaces ] ; foreach ( $ parts as $ part ) { if ( ! isset ( $ option [ $ part ] ) ) { return false ; } $ option = $ option [ $ part ] ; } return true ; } 
public function get ( string $ name = 'app \ \ ' , $ defaults = null ) { $ name = $ this - > parse Namespace ( $ name ) ; $ namespaces = $ name [ 0 ] ; $ name = $ name [ 1 ] ; if ( ' * ' = = = $ name ) { return $ this - > option [ $ namespaces ] ; } if ( ! strpos ( $ name , ' . ' ) ) { return array _key _exists ( $ name , $ this - > option [ $ namespaces ] ) ? $ this - > option [ $ namespaces ] [ $ name ] : $ defaults ; } $ parts = explode ( ' . ' , $ name ) ; $ option = $ this - > option [ $ namespaces ] ; foreach ( $ parts as $ part ) { if ( ! isset ( $ option [ $ part ] ) ) { return $ defaults ; } $ option = $ option [ $ part ] ; } return $ option ; } 
public function set ( $ name , $ value = null ) : void { if ( is _array ( $ name ) ) { foreach ( $ name as $ key = > $ value ) { $ this - > set ( $ key , $ value ) ; } } else { $ name = $ this - > parse Namespace ( $ name ) ; $ namespaces = $ name [ 0 ] ; $ name = $ name [ 1 ] ; if ( ' * ' = = = $ name ) { $ this - > option [ $ namespaces ] = $ value ; return ; } if ( ! strpos ( $ name , ' . ' ) ) { $ this - > option [ $ namespaces ] [ $ name ] = $ value ; } else { $ parts = explode ( ' . ' , $ name ) ; $ max = count ( $ parts ) - 1 ; $ option = & $ this - > option [ $ namespaces ] ; for ( $ i = 0 ; $ i < = $ max ; $ i + + ) { $ part = $ parts [ $ i ] ; if ( $ i < $ max ) { if ( ! isset ( $ option [ $ part ] ) ) { $ option [ $ part ] = [ ] ; } $ option = & $ option [ $ part ] ; } else { $ option [ $ part ] = $ value ; } } } } } 
public function delete ( string $ name ) : void { $ name = $ this - > parse Namespace ( $ name ) ; $ namespaces = $ name [ 0 ] ; $ name = $ name [ 1 ] ; if ( ' * ' = = = $ name ) { $ this - > option [ $ namespaces ] = [ ] ; return ; } if ( ! strpos ( $ name , ' . ' ) ) { if ( isset ( $ this - > option [ $ namespaces ] [ $ name ] ) ) { unset ( $ this - > option [ $ namespaces ] [ $ name ] ) ; } } else { $ parts = explode ( ' . ' , $ name ) ; $ max = count ( $ parts ) - 1 ; $ option = & $ this - > option [ $ namespaces ] ; for ( $ i = 0 ; $ i < = $ max ; $ i + + ) { $ part = $ parts [ $ i ] ; if ( $ i < $ max ) { if ( ! isset ( $ option [ $ part ] ) ) { break ; } $ option = & $ option [ $ part ] ; } else { if ( isset ( $ option [ $ part ] ) ) { unset ( $ option [ $ part ] ) ; } } } } } 
public function reset ( $ namespaces = null ) : void { if ( is _array ( $ namespaces ) ) { $ this - > option = $ namespaces ; } elseif ( is _string ( $ namespaces ) ) { $ this - > option [ $ namespaces ] = [ ] ; } else { $ this - > option = [ ] ; } } 
protected function parse Namespace ( string $ name ) : array { if ( strpos ( $ name , ' \ \ ' ) ) { $ namespaces = explode ( ' \ \ ' , $ name ) ; if ( empty ( $ namespaces [ 1 ] ) ) { $ namespaces [ 1 ] = ' * ' ; } $ name = $ namespaces [ 1 ] ; $ namespaces = $ namespaces [ 0 ] ; } else { $ namespaces = static : : DEFAUTL _NAMESPACE ; } if ( ! isset ( $ this - > option [ $ namespaces ] ) ) { $ this - > option [ $ namespaces ] = [ ] ; } return [ $ namespaces , $ name , ] ; } 
public function get ( string $ name , $ defaults = false , array $ option = [ ] ) { $ option = $ this - > normalize Options ( $ option ) ; $ data = $ this - > handle - > get ( $ this - > get Cache Name ( $ name ) ) ; if ( false = = = $ data ) { return $ defaults ; } if ( $ option [ 'serialize ' ] & & is _string ( $ data ) ) { $ data = unserialize ( $ data ) ; } return $ data ; } 
public function set ( string $ name , $ data , array $ option = [ ] ) : void { $ option = $ this - > normalize Options ( $ option ) ; if ( $ option [ 'serialize ' ] ) { $ data = serialize ( $ data ) ; } $ option [ 'expire ' ] = $ this - > cache Time ( $ name , ( int ) $ option [ 'expire ' ] ) ; $ this - > handle - > set ( $ this - > get Cache Name ( $ name ) , $ data , $ option [ 'expire ' ] ? ( int ) $ option [ 'expire ' ] : null ) ; } 
public function delete ( string $ name ) : void { $ this - > handle - > delete ( $ this - > get Cache Name ( $ name ) ) ; } 
public function add ( $ index , $ newval ) : void { $ this - > validate ( $ newval ) ; parent : : add ( $ index , $ newval ) ; } 
public function offset Set ( $ index , $ newval ) : void { $ this - > validate ( $ newval ) ; parent : : offset Set ( $ index , $ newval ) ; } 
public function validate ( $ value ) : void { if ( ! $ this - > check Type ( $ value ) ) { $ e = sprintf ( 'The linkedlist element type verification failed , and the allowed type is %s . ' , implode ( ' , ' , $ this - > type ) ) ; throw new Invalid Argument Exception ( $ e ) ; } } 
protected function check Type ( $ value ) : bool { if ( ! $ this - > type ) { return true ; } return type _these ( $ value , $ this - > type ) ; } 
protected function int Option ( ) : void { if ( $ this - > option [ 'large _size ' ] ) { $ this - > set Large Size ( ) ; } elseif ( $ this - > option [ 'small _size ' ] ) { $ this - > set Small Size ( ) ; } } 
protected function get First Render ( ) : string { if ( ! $ this - > page - > can First Render ( ) ) { return ' ' ; } return sprintf ( ' <li class = " " > <a href = " %s " > 1 < /a > < /li > ' . ' <li > <a href = " %s " > . . . < /a > < /li > ' , $ this - > replace ( 1 ) , $ this - > replace ( $ this - > page - > parse First Render Prev ( ) ) ) ; } 
protected function get Prev Render ( ) : string { if ( $ this - > page - > can Prev Render ( ) ) { return sprintf ( ' <li > <a aria -label = "Previous " href = " %s " > ' . ' <span aria -hidden = "true " > &laquo ; < /span > < /a > < /li > ' , $ this - > replace ( $ this - > page - > parse Prev Render Prev ( ) ) ) ; } return ' <li class = "disabled " > <a aria -label = "Previous " > ' . ' <span aria -hidden = "true " > &laquo ; < /span > < /a > < /li > ' ; } 
public function add Dir ( array $ dirs ) : self { $ this - > dirs = array _unique ( array _merge ( $ this - > dirs , $ dirs ) ) ; return $ this ; } 
public function load Data ( ) : array { if ( null ! = = $ this - > loaded ) { return $ this - > loaded ; } $ files = $ this - > find Mo File ( $ this - > parse Dir ( $ this - > dirs ) ) ; $ texts = $ this - > parse Mo Data ( $ files ) ; return $ this - > loaded = $ texts ; } 
protected function find Mo File ( array $ dirs ) : array { $ files = [ ] ; foreach ( $ dirs as $ dir ) { if ( ! is _dir ( $ dir ) ) { throw new Runtime Exception ( sprintf ( 'I 1 8n load dir %s is not exits . ' , $ dir ) ) ; } $ files = array _merge ( $ files , $ this - > get Mo Files ( $ dir ) ) ; } return $ files ; } 
protected function parse Dir ( array $ dirs ) : array { $ i 1 8n = $ this - > i 1 8n ; return array _map ( function ( $ dir ) use ( $ i 1 8n ) { return $ dir . ' / ' . $ i 1 8n ; } , $ dirs ) ; } 
public function insert ( $ data , array $ bind = [ ] , bool $ replace = false ) : array { 
public function insert All ( array $ data , array $ bind = [ ] , bool $ replace = false ) : array { 
public function update ( $ data , array $ bind = [ ] ) : array { 
public function delete ( ? string $ data = null , array $ bind = [ ] ) : array { 
public function truncate ( ) : array { 
public function for Page ( int $ page , int $ per Page = 1 5 ) : self { return $ this - > limit ( ( $ page - 1 ) * $ per Page , $ per Page ) ; } 
public function time ( string $ type = 'date ' ) : self { if ( $ this - > check Flow Control ( ) ) { return $ this ; } if ( ! in _array ( $ type , [ 'date ' , 'month ' , 'day ' , 'year ' ] , true ) ) { throw new Invalid Argument Exception ( sprintf ( 'Time type ` %s ` is invalid . ' , $ type ) ) ; } $ this - > set In Time Condition ( $ type ) ; return $ this ; } 
public function reset ( ? string $ option = null ) : self { if ( $ this - > check Flow Control ( ) ) { return $ this ; } if ( null = = = $ option ) { $ this - > init Option ( ) ; } elseif ( array _key _exists ( $ option , static : : $ options Default ) ) { $ this - > options [ $ option ] = static : : $ options Default [ $ option ] ; } return $ this ; } 
public function prefix ( string $ prefix ) : self { if ( $ this - > check Flow Control ( ) ) { return $ this ; } $ this - > options [ 'prefix ' ] [ ] = $ prefix ; return $ this ; } 
public function table ( $ table , $ cols = ' * ' ) : self { if ( $ this - > check Flow Control ( ) ) { return $ this ; } $ this - > set Is Table ( true ) ; $ this - > add Join ( 'inner join ' , $ table , $ cols ) ; $ this - > set Is Table ( false ) ; return $ this ; } 
public function columns ( $ cols = ' * ' , ? string $ table = null ) : self { if ( $ this - > check Flow Control ( ) ) { return $ this ; } if ( null = = = $ table ) { $ table = $ this - > get Table ( ) ; } $ this - > add Cols ( $ table , $ cols ) ; return $ this ; } 
public function set Columns ( $ cols = ' * ' , ? string $ table = null ) : self { if ( $ this - > check Flow Control ( ) ) { return $ this ; } if ( null = = = $ table ) { $ table = $ this - > get Table ( ) ; } $ this - > options [ 'columns ' ] = [ ] ; $ this - > add Cols ( $ table , $ cols ) ; return $ this ; } 
public function where ( . . . $ arr ) : self { if ( $ this - > check Flow Control ( ) ) { return $ this ; } array _unshift ( $ arr , static : : LOGIC _AND ) ; array _unshift ( $ arr , 'where ' ) ; return $ this - > aliatype And Logic ( . . . $ arr ) ; } 
public function or Where ( . . . $ arr ) : self { if ( $ this - > check Flow Control ( ) ) { return $ this ; } array _unshift ( $ arr , static : : LOGIC _OR ) ; array _unshift ( $ arr , 'where ' ) ; return $ this - > aliatype And Logic ( . . . $ arr ) ; } 
public function bind ( $ names , $ value = null , int $ type = PDO : : PARAM _STR ) : self { if ( $ this - > check Flow Control ( ) ) { return $ this ; } if ( is _array ( $ names ) ) { foreach ( $ names as $ key = > $ item ) { if ( ! is _array ( $ item ) ) { $ item = [ $ item , $ type , ] ; } $ this - > bind Params [ $ key ] = $ item ; } } else { if ( ! is _array ( $ value ) ) { $ value = [ $ value , $ type , ] ; } $ this - > bind Params [ $ names ] = $ value ; } return $ this ; } 
public function force Index ( $ indexs , $ type = 'FORCE ' ) : self { if ( $ this - > check Flow Control ( ) ) { return $ this ; } if ( ! isset ( static : : $ index Types [ $ type ] ) ) { throw new Invalid Argument Exception ( sprintf ( 'Invalid Index type ` %s ` . ' , $ type ) ) ; } $ type = strtoupper ( $ type ) ; $ indexs = normalize ( $ indexs ) ; foreach ( $ indexs as $ value ) { $ value = normalize ( $ value ) ; foreach ( $ value as $ tmp ) { $ this - > options [ 'index ' ] [ $ type ] [ ] = $ tmp ; } } return $ this ; } 
public function join ( $ table , $ cols , $ cond ) : self { if ( $ this - > check Flow Control ( ) ) { return $ this ; } $ args = func _get _args ( ) ; array _unshift ( $ args , 'inner join ' ) ; return $ this - > add Join ( . . . $ args ) ; } 
public function union ( $ selects , string $ type = 'UNION ' ) : self { if ( $ this - > check Flow Control ( ) ) { return $ this ; } if ( ! isset ( static : : $ union Types [ $ type ] ) ) { throw new Invalid Argument Exception ( sprintf ( 'Invalid UNION type ` %s ` . ' , $ type ) ) ; } if ( ! is _array ( $ selects ) ) { $ selects = [ $ selects , ] ; } foreach ( $ selects as $ tmp ) { $ this - > options [ 'union ' ] [ ] = [ $ tmp , $ type , ] ; } return $ this ; } 
public function group By ( $ expression ) : self { if ( $ this - > check Flow Control ( ) ) { return $ this ; } if ( is _string ( $ expression ) & & false ! = = strpos ( $ expression , ' , ' ) & & false ! = = strpos ( $ expression , ' { ' ) & & preg _match _all ( ' / { ( . + ? ) } / ' , $ expression , $ matches ) ) { $ expression = str _replace ( $ matches [ 1 ] [ 0 ] , base 6 4 _encode ( $ matches [ 1 ] [ 0 ] ) , $ expression ) ; } $ expression = normalize ( $ expression ) ; 
public function having ( . . . $ arr ) : self { if ( $ this - > check Flow Control ( ) ) { return $ this ; } array _unshift ( $ arr , static : : LOGIC _AND ) ; array _unshift ( $ arr , 'having ' ) ; return $ this - > aliatype And Logic ( . . . $ arr ) ; } 
public function or Having ( . . . $ arr ) : self { if ( $ this - > check Flow Control ( ) ) { return $ this ; } array _unshift ( $ arr , static : : LOGIC _OR ) ; array _unshift ( $ arr , 'having ' ) ; return $ this - > aliatype And Logic ( . . . $ arr ) ; } 
public function having Raw ( string $ raw ) : self { if ( $ this - > check Flow Control ( ) ) { return $ this ; } $ condition = [ ] ; array _unshift ( $ condition , static : : LOGIC _AND ) ; array _unshift ( $ condition , 'having ' ) ; $ condition [ ] = [ ' :string Simple ' = > ' { ' . $ raw . ' } ' ] ; return $ this - > aliatype And Logic ( . . . $ condition ) ; } 
public function or Having Raw ( string $ raw ) : self { if ( $ this - > check Flow Control ( ) ) { return $ this ; } $ condition = [ ] ; array _unshift ( $ condition , static : : LOGIC _OR ) ; array _unshift ( $ condition , 'having ' ) ; $ condition [ ] = [ ' :string Simple ' = > ' { ' . $ raw . ' } ' ] ; return $ this - > aliatype And Logic ( . . . $ condition ) ; } 
public function order By ( $ expression , string $ order Default = 'ASC ' ) : self { if ( $ this - > check Flow Control ( ) ) { return $ this ; } 
public function distinct ( bool $ flag = true ) : self { if ( $ this - > check Flow Control ( ) ) { return $ this ; } $ this - > options [ 'distinct ' ] = $ flag ; return $ this ; } 
public function count ( string $ field = ' * ' , string $ alias = 'row _count ' ) : self { if ( $ this - > check Flow Control ( ) ) { return $ this ; } return $ this - > add Aggregate ( 'COUNT ' , $ field , $ alias ) ; } 
public function avg ( string $ field , string $ alias = 'avg _value ' ) : self { if ( $ this - > check Flow Control ( ) ) { return $ this ; } return $ this - > add Aggregate ( 'AVG ' , $ field , $ alias ) ; } 
public function max ( string $ field , string $ alias = 'max _value ' ) : self { if ( $ this - > check Flow Control ( ) ) { return $ this ; } return $ this - > add Aggregate ( 'MAX ' , $ field , $ alias ) ; } 
public function min ( string $ field , string $ alias = 'min _value ' ) : self { if ( $ this - > check Flow Control ( ) ) { return $ this ; } return $ this - > add Aggregate ( 'MIN ' , $ field , $ alias ) ; } 
public function sum ( string $ field , string $ alias = 'sum _value ' ) : self { if ( $ this - > check Flow Control ( ) ) { return $ this ; } return $ this - > add Aggregate ( 'SUM ' , $ field , $ alias ) ; } 
public function one ( ) : self { if ( $ this - > check Flow Control ( ) ) { return $ this ; } $ this - > options [ 'limit Count ' ] = 1 ; $ this - > options [ 'limit Offset ' ] = null ; $ this - > options [ 'limit Query ' ] = false ; return $ this ; } 
public function all ( ) : self { if ( $ this - > check Flow Control ( ) ) { return $ this ; } if ( $ this - > options [ 'limit Query ' ] ) { return $ this ; } $ this - > options [ 'limit Count ' ] = null ; $ this - > options [ 'limit Offset ' ] = null ; $ this - > options [ 'limit Query ' ] = true ; return $ this ; } 
public function top ( int $ count = 3 0 ) : self { if ( $ this - > check Flow Control ( ) ) { return $ this ; } return $ this - > limit ( 0 , $ count ) ; } 
public function limit ( int $ offset = 0 , int $ count = 0 ) : self { if ( $ this - > check Flow Control ( ) ) { return $ this ; } if ( 0 = = = $ count ) { return $ this - > top ( $ offset ) ; } $ this - > options [ 'limit Count ' ] = $ count ; $ this - > options [ 'limit Offset ' ] = $ offset ; $ this - > options [ 'limit Query ' ] = true ; return $ this ; } 
public function for Update ( bool $ flag = true ) : self { if ( $ this - > check Flow Control ( ) ) { return $ this ; } $ this - > options [ 'for Update ' ] = $ flag ; return $ this ; } 
public function make Sql ( bool $ with Logic Group = false ) : string { $ sql = [ 'SELECT ' , ] ; foreach ( array _keys ( $ this - > options ) as $ option ) { if ( 'from ' = = = $ option ) { $ sql [ 'from ' ] = ' ' ; } elseif ( 'union ' = = = $ option ) { continue ; } else { $ method = 'parse ' . ucfirst ( $ option ) ; if ( method _exists ( $ this , $ method ) ) { $ sql [ $ option ] = $ this - > { $ method } ( ) ; } } } $ sql [ 'from ' ] = $ this - > parse From ( ) ; 
public function set Option ( string $ name , $ value ) : self { $ this - > options [ $ name ] = $ value ; return $ this ; } 
protected function call Where Sugar ( string $ method , array $ args ) { if ( ! in _array ( $ method , [ 'where Not Between ' , 'where Between ' , 'where Not Null ' , 'where Null ' , 'where Not In ' , 'where In ' , 'where Not Like ' , 'where Like ' , 'where Date ' , 'where Day ' , 'where Month ' , 'where Year ' , ] , true ) ) { return false ; } if ( $ this - > check Flow Control ( ) ) { return $ this ; } if ( in _array ( $ method , [ 'where Date ' , 'where Day ' , 'where Month ' , 'where Year ' ] , true ) ) { $ this - > set In Time Condition ( strtolower ( substr ( $ method , 5 ) ) ) ; $ this - > where ( . . . $ args ) ; $ this - > set In Time Condition ( null ) ; return $ this ; } $ this - > set Type And Logic ( 'where ' , static : : LOGIC _AND ) ; if ( 0 = = = strpos ( $ method , 'where Not ' ) ) { $ type = 'not ' . strtolower ( substr ( $ method , 8 ) ) ; } else { $ type = strtolower ( substr ( $ method , 5 ) ) ; } array _unshift ( $ args , $ type ) ; return $ this - > alias Condition ( . . . $ args ) ; } 
protected function call Join Sugar ( string $ method , array $ args ) { if ( ! in _array ( $ method , [ 'inner Join ' , 'left Join ' , 'right Join ' , 'full Join ' , 'cross Join ' , 'natural Join ' , ] , true ) ) { return false ; } if ( $ this - > check Flow Control ( ) ) { return $ this ; } $ type = substr ( $ method , 0 , - 4 ) . ' join ' ; array _unshift ( $ args , $ type ) ; return $ this - > add Join ( . . . $ args ) ; } 
protected function parse Columns ( ) : string { if ( empty ( $ this - > options [ 'columns ' ] ) ) { return ' ' ; } $ columns = [ ] ; foreach ( $ this - > options [ 'columns ' ] as $ item ) { list ( $ table Name , $ col , $ alias ) = $ item ; 
protected function parse Aggregate ( ) : string { if ( empty ( $ this - > options [ 'aggregate ' ] ) ) { return ' ' ; } $ columns = [ ] ; foreach ( $ this - > options [ 'aggregate ' ] as $ item ) { list ( , $ field , $ alias ) = $ item ; $ columns [ ] = $ field . ' AS ' . $ alias ; } return $ columns ? implode ( ' , ' , $ columns ) : ' ' ; } 
protected function parse From ( ) : string { if ( empty ( $ this - > options [ 'from ' ] ) ) { return ' ' ; } $ from = [ ] ; foreach ( $ this - > options [ 'from ' ] as $ alias = > $ value ) { $ tmp = ' ' ; 
protected function parse Table ( ) : string { foreach ( $ this - > options [ 'from ' ] as $ alias = > $ value ) { if ( $ alias = = = $ value [ 'table _name ' ] ) { $ alias = $ this - > connect - > normalize Table Or Column ( " { $value [ 'schema ' ] } . { $value [ 'table _name ' ] } " ) ; } break ; } return $ alias ; } 
protected function parse Index ( ) : string { $ index = ' ' ; foreach ( [ 'FORCE ' , 'IGNORE ' , ] as $ type ) { if ( empty ( $ this - > options [ 'index ' ] [ $ type ] ) ) { continue ; } $ index . = ( $ index ? ' ' : ' ' ) . $ type . ' INDEX ( ' . implode ( ' , ' , $ this - > options [ 'index ' ] [ $ type ] ) . ' ) ' ; } return $ index ; } 
protected function parse Where ( bool $ child = false ) : string { if ( empty ( $ this - > options [ 'where ' ] ) ) { return ' ' ; } return $ this - > analyse Condition ( 'where ' , $ child ) ; } 
protected function parse Union ( ) : string { if ( empty ( $ this - > options [ 'union ' ] ) ) { return ' ' ; } $ sql = ' ' ; if ( $ this - > options [ 'union ' ] ) { $ options = count ( $ this - > options [ 'union ' ] ) ; foreach ( $ this - > options [ 'union ' ] as $ index = > $ value ) { list ( $ union , $ type ) = $ value ; if ( $ union instanceof self | | $ union instanceof Select ) { $ union = $ union - > make Sql ( ) ; } if ( $ index < = $ options - 1 ) { $ sql . = " \n " . $ type . ' ' . $ union ; } } } return $ sql ; } 
protected function parse Limit Count ( bool $ without Offset = false ) : string { if ( null = = = $ this - > options [ 'limit Offset ' ] & & null = = = $ this - > options [ 'limit Count ' ] ) { return ' ' ; } return $ this - > connect - > limit Count ( $ this - > options [ 'limit Count ' ] , $ without Offset ? null : $ this - > options [ 'limit Offset ' ] ) ; } 
protected function analyse Condition ( string $ cond Type , bool $ child = false ) : string { $ sql Cond = [ ] ; $ table = $ this - > get Table ( ) ; foreach ( $ this - > options [ $ cond Type ] as $ key = > $ cond ) { 
protected function alias Condition ( string $ condition Type , $ cond ) : self { if ( ! is _array ( $ cond ) ) { $ args = func _get _args ( ) ; $ this - > add Conditions ( $ args [ 1 ] , $ condition Type , $ args [ 2 ] ? ? null ) ; } else { foreach ( $ cond as $ tmp ) { $ this - > add Conditions ( $ tmp [ 0 ] , $ condition Type , $ tmp [ 1 ] ) ; } } return $ this ; } 
protected function aliatype And Logic ( string $ type , string $ logic , $ cond ) : self { $ this - > set Type And Logic ( $ type , $ logic ) ; if ( $ cond instanceof Closure ) { $ select = new static ( $ this - > connect ) ; $ select - > set Table ( $ this - > get Table ( ) ) ; call _user _func _array ( $ cond , [ $ select , ] ) ; $ tmp = $ select - > { 'parse ' . ucwords ( $ type ) } ( true ) ; $ this - > set Condition Item ( static : : LOGIC _GROUP _LEFT . $ tmp . static : : LOGIC _GROUP _RIGHT , ' :string ' ) ; return $ this ; } $ args = func _get _args ( ) ; array _shift ( $ args ) ; array _shift ( $ args ) ; return $ this - > add Conditions ( . . . $ args ) ; } 
protected function add Conditions ( ) : self { $ args = func _get _args ( ) ; $ table = $ this - > get Table ( ) ; 
protected function set Condition Item ( $ items , string $ type = ' ' ) : void { $ type And Logic = $ this - > get Type And Logic ( ) ; 
protected function set Type And Logic ( ? string $ type = null , ? string $ logic = null ) : void { if ( null ! = = $ type ) { $ this - > condition Type = $ type ; } if ( null ! = = $ logic ) { $ this - > condition Logic = $ logic ; } } 
protected function normalize Column ( string $ field , string $ table Name ) : string { if ( false ! = = strpos ( $ field , ' { ' ) & & preg _match ( ' / ^ { ( . + ? ) } $ / ' , $ field , $ matches ) ) { $ field = $ this - > connect - > normalize Expression ( $ matches [ 1 ] , $ table Name ) ; } elseif ( ! preg _match ( ' / \ ( . * \ ) / ' , $ field ) ) { if ( preg _match ( ' / ( . + ) \ . ( . + ) / ' , $ field , $ matches ) ) { $ current Table Name = $ matches [ 1 ] ; $ tmp = $ matches [ 2 ] ; } else { $ current Table Name = $ table Name ; } $ field = $ this - > connect - > normalize Table Or Column ( " { $current Table Name } . { $field } " ) ; } return $ field ; } 
protected function add Join ( string $ join Type , $ names , $ cols , $ cond = null ) : self { 
protected function add Cols ( string $ table Name , $ cols ) : void { 
protected function add Aggregate ( string $ type , string $ field , string $ alias ) : self { $ this - > options [ 'columns ' ] = [ ] ; $ table Name = $ this - > get Table ( ) ; 
protected function delete Bind Params ( $ names ) : void { if ( isset ( $ this - > bind Params [ $ names ] ) ) { unset ( $ this - > bind Params [ $ names ] ) ; } } 
protected function normalize Bind Data ( array $ data , array $ bind = [ ] , int $ question Mark = 0 , int $ index = 0 ) : array { $ fields = $ values = [ ] ; $ table Name = $ this - > get Table ( ) ; foreach ( $ data as $ key = > $ value ) { 
protected function parse Time ( string $ field , $ value , string $ type ) { $ field = str _replace ( ' ` ' , ' ' , $ field ) ; $ table = $ this - > get Table ( ) ; if ( ! preg _match ( ' / \ ( . * \ ) / ' , $ field ) ) { if ( preg _match ( ' / ( . + ) \ . ( . + ) / ' , $ field , $ matches ) ) { $ table = $ matches [ 1 ] ; $ field = $ matches [ 2 ] ; } } 
public function handle ( ) : void { $ this - > info ( $ this - > get Logo ( ) ) ; $ this - > warn ( $ this - > get Version ( ) ) ; $ server = $ this - > create Server ( ) ; if ( true = = = $ this - > option ( 'daemonize ' ) ) { $ server - > set Option ( 'daemonize ' , ' 1 ' ) ; } $ this - > check Port ( $ option = $ server - > get Option ( ) ) ; $ this - > check Service ( $ option ) ; $ this - > start ( $ option ) ; $ server - > start Server ( ) ; } 
protected function start ( array $ option ) : void { $ show = [ ] ; $ base Path = App : : path ( ) ; foreach ( $ option as $ key = > $ val ) { if ( is _array ( $ val ) ) { continue ; } if ( in _array ( $ key , [ 'pid _path ' , 'document _root ' ] , true ) ) { $ val = str _replace ( $ base Path , ' @path ' , $ val ) ; } $ show [ ] = [ $ key , $ val ] ; } $ this - > table ( [ 'Item ' , 'Value ' ] , $ show ) ; } 
protected function check Port ( array $ option ) : void { $ bind = $ this - > port Bind ( ( int ) ( $ option [ 'port ' ] ) ) ; if ( $ bind ) { foreach ( $ bind as $ k = > $ val ) { if ( ' * ' = = = $ val [ 'ip ' ] | | $ val [ 'ip ' ] = = = $ option [ 'host ' ] ) { throw new Invalid Argument Exception ( sprintf ( 'The port has been used %s : %s ,the port process ID is %s ' , $ val [ 'ip ' ] , $ val [ 'port ' ] , $ k ) ) ; } } } } 
protected function port Bind ( int $ port ) : array { $ result = [ ] ; $ cmd = "lsof -i : { $port } |awk ' $ 1 ! = \ "COMMAND \ " {print $ 1 , $ 2 , $ 9 } ' " ; exec ( $ cmd , $ out ) ; if ( ! empty ( $ out ) ) { foreach ( $ out as $ val ) { $ tmp = explode ( ' ' , $ val ) ; list ( $ ip , $ p ) = explode ( ' : ' , $ tmp [ 2 ] ) ; $ result [ $ tmp [ 1 ] ] = [ 'cmd ' = > $ tmp [ 0 ] , 'ip ' = > $ ip , 'port ' = > $ p , ] ; } } return $ result ; } 
protected function check Service ( array $ option ) : void { $ file = $ option [ 'pid _path ' ] ; if ( ! is _file ( $ file ) ) { return ; } $ pid = explode ( PHP _EOL , file _get _contents ( $ file ) ) ; $ cmd = "ps ax | awk ' { print $ 1 } ' | grep -e \ " ^ { $pid [ 0 ] } $ \ " " ; exec ( $ cmd , $ out ) ; if ( ! empty ( $ out ) ) { throw new Invalid Argument Exception ( sprintf ( 'Swoole pid file %s is already exists ,pid is %d ' , $ file , $ pid [ 0 ] ) ) ; } $ this - > warn ( sprintf ( 'Warning :swoole pid file is already exists . ' , $ file ) . PHP _EOL . 'It is possible that the swoole service was last unusual exited . ' . PHP _EOL . 'The non daemon mode ctrl +c termination is the most possible . ' . PHP _EOL ) ; unlink ( $ file ) ; } 
public function add Relation Condition ( ) : void { if ( static : : $ relation Condition ) { $ this - > select - > where ( $ this - > target Key , $ this - > get Source Value ( ) ) ; $ this - > select - > where Not Null ( $ this - > target Key ) ; } } 
public function pre Load Condition ( array $ entitys ) : void { $ this - > select - > where In ( $ this - > target Key , $ this - > get Entity Key ( $ entitys , $ this - > source Key ) ) ; } 
protected function match Pre Load One Or Many ( array $ entitys , Collection $ result , string $ relation , string $ type ) : array { $ maps = $ this - > build Map ( $ result ) ; foreach ( $ entitys as & $ entity ) { $ key = $ entity - > _ _get ( $ this - > source Key ) ; if ( isset ( $ maps [ $ key ] ) ) { $ entity - > with Relation Prop ( $ relation , $ this - > get Relation Value ( $ maps , $ key , $ type ) ) ; } } return $ entitys ; } 
protected function get Relation Value ( array $ maps , string $ key , string $ type ) { $ value = $ maps [ $ key ] ; return 'one ' = = = $ type ? reset ( $ value ) : $ this - > target Entity - > collection ( $ value ) ; } 
protected function build Map ( Collection $ result ) : array { $ maps = [ ] ; foreach ( $ result as $ value ) { $ maps [ $ value - > _ _get ( $ this - > target Key ) ] [ ] = $ value ; } return $ maps ; } 
public function handle ( ) : void { $ this - > line ( 'Start to create symbolic links . ' ) ; $ this - > call Apis ( ) ; $ this - > call Public ( ) ; $ this - > call Storage ( ) ; $ this - > call Debug Bar ( ) ; $ this - > line ( ' ' ) ; $ this - > info ( 'Links created successed . ' ) ; } 
protected function make Syslog Handler ( ) : Logger Interface { $ handler = new Syslog Handler ( $ this - > option [ 'channel ' ] , $ this - > option [ 'facility ' ] , $ this - > normalize Monolog Level ( $ this - > option [ 'level ' ] ) ) ; return $ this - > monolog - > push Handler ( $ this - > normalize Handler ( $ handler ) ) ; } 
public function move ( string $ directory , ? string $ name = null ) : self { $ target = $ this - > get Target File ( $ directory , $ name ) ; $ this - > move To Target ( $ this - > get Pathname ( ) , $ target ) ; return new self ( $ target ) ; } 
protected function get Target File ( string $ directory , ? string $ name = null ) : string { create _directory ( $ directory ) ; $ target = rtrim ( $ directory , ' / \ \ ' ) . \ DIRECTORY _SEPARATOR . ( $ name ? ? $ this - > get Basename ( ) ) ; return $ target ; } 
protected function move To Target ( string $ source Path , string $ target , bool $ is Uploaded = false ) : void { set _error _handler ( function ( $ type , $ msg ) { throw new File Exception ( $ msg ) ; } ) ; $ method = $ is Uploaded ? 'move _uploaded _file ' : 'rename ' ; $ method ( $ source Path , $ target ) ; restore _error _handler ( ) ; chmod ( $ target , 0 6 6 6 & ~ umask ( ) ) ; } 
public function load Data ( ) : array { if ( null ! = = $ this - > loaded ) { return $ this - > loaded ; } $ data = [ ] ; foreach ( $ this - > get Packages ( ) as $ package ) { if ( $ option = $ this - > get Leevel Option ( $ package ) ) { $ data = $ data ? $ this - > merge Option ( $ data , $ option ) : $ option ; } } $ app Option = $ this - > get App Composer Option ( ) ; return $ this - > loaded = $ this - > merge Option ( $ data , $ app Option ) ; } 
protected function get Packages ( ) : array { $ packages = [ ] ; $ installed Json = $ this - > path . ' /vendor /composer /installed .json ' ; if ( is _file ( $ installed Json ) ) { $ packages = $ this - > get File Content ( $ installed Json ) ; } return $ packages ; } 
protected function merge Option ( array $ olds , array $ options ) : array { $ result = [ ] ; foreach ( $ this - > supported Options as $ item ) { $ result [ $ item ] = array _merge ( $ olds [ $ item ] ? ? [ ] , $ options [ $ item ] ? ? [ ] ) ; } return $ result ; } 
protected function get Leevel Option ( array $ package ) : array { $ options = $ package [ 'extra ' ] [ 'leevel ' ] ? ? [ ] ; if ( $ options ) { $ options = $ this - > normalize Option ( $ options ) ; } return $ options ; } 
protected function normalize Option ( array $ options ) : array { $ result = [ ] ; foreach ( $ this - > supported Options as $ item ) { $ tmp = $ options [ $ item ] ? ? [ ] ; if ( ! is _array ( $ tmp ) ) { $ tmp = [ $ tmp ] ; } $ result [ $ item ] = $ tmp ; } return $ result ; } 
protected function get App Composer Option ( ) : array { $ path = $ this - > path . ' /composer .json ' ; if ( ! is _file ( $ path ) ) { return [ ] ; } return $ this - > get Leevel Option ( $ this - > get File Content ( $ path ) ) ; } 
public function replace ( array $ elements = [ ] ) : void { $ this - > elements = [ ] ; $ elements = $ this - > normalize Array ( $ elements ) ; $ this - > add ( $ elements ) ; } 
public function set ( string $ key , $ value ) : void { if ( ! is _array ( $ value ) & & ! $ value instanceof Uploaded File ) { $ e = 'An uploaded file must be an array or an instance of Uploaded File . ' ; throw new Invalid Argument Exception ( $ e ) ; } parent : : set ( $ key , $ this - > convert File ( $ value ) ) ; } 
public function add ( array $ files = [ ] ) : void { foreach ( $ files as $ key = > $ file ) { $ this - > set ( $ key , $ file ) ; } } 
public function get Arr ( string $ key , array $ defaults = [ ] ) { $ files = [ ] ; foreach ( $ this - > elements as $ k = > $ value ) { if ( 0 = = = strpos ( $ k , $ key ) & & null ! = = $ value ) { $ files [ ] = $ value ; } } return $ files ? : $ defaults ; } 
protected function convert File ( $ file ) : ? Uploaded File { if ( $ file instanceof Uploaded File ) { return $ file ; } $ file = $ this - > normalize File ( $ file ) ; if ( UPLOAD _ERR _NO _FILE = = = $ file [ 'error ' ] ) { $ file = null ; } else { $ file = new Uploaded File ( $ file [ 'tmp _name ' ] , $ file [ 'name ' ] , $ file [ 'type ' ] , $ file [ 'error ' ] ) ; } return $ file ; } 
protected function normalize File ( array $ data ) : array { $ result = [ ] ; foreach ( $ data as $ key = > $ value ) { if ( in _array ( $ key , static : : $ file Keys , true ) ) { $ result [ $ key ] = $ value ; } } $ keys = $ this - > normalize Key ( $ result ) ; if ( $ keys ! = = static : : $ file Keys ) { $ e = sprintf ( 'An array uploaded file must be contain keys %s . ' , implode ( ' , ' , static : : $ file Keys ) ) ; throw new Invalid Argument Exception ( $ e ) ; } return $ result ; } 
protected function normalize Array ( array $ elements ) : array { $ result = [ ] ; foreach ( $ elements as $ key = > $ value ) { if ( is _array ( $ value ) ) { if ( false = = = array _key _exists ( 'name ' , $ value ) ) { $ e = 'An uploaded file must be contain key name . ' ; throw new Invalid Argument Exception ( $ e ) ; } if ( isset ( $ value [ 'name ' ] ) & & is _array ( $ value [ 'name ' ] ) ) { foreach ( $ value [ 'name ' ] as $ index = > $ item ) { $ element = [ ] ; foreach ( static : : $ file Keys as $ file Key ) { if ( ! array _key _exists ( $ file Key , $ value ) ) { $ e = sprintf ( 'An uploaded file must be contain key %s . ' , $ file Key ) ; throw new Invalid Argument Exception ( $ e ) ; } if ( ! array _key _exists ( $ index , $ value [ $ file Key ] ) ) { $ e = sprintf ( 'An uploaded file must be contain %s in key %s . ' , $ index , $ file Key ) ; throw new Invalid Argument Exception ( $ e ) ; } $ element [ $ file Key ] = $ value [ $ file Key ] [ $ index ] ? ? ' ' ; } $ result [ $ key . ' \ \ ' . $ index ] = $ element ; $ result = $ this - > normalize Array ( $ result ) ; } } else { $ result [ $ key ] = $ value ; } } else { $ result [ $ key ] = $ value ; } } return $ result ; } 
public function validate Date ( $ value , array $ parameter , IValidator $ validator , string $ field , bool $ before = false ) : bool { if ( ! is _string ( $ value ) ) { return false ; } if ( ! array _key _exists ( 0 , $ parameter ) ) { throw new Invalid Argument Exception ( 'Missing the first element of parameter . ' ) ; } $ this - > validator = $ validator ; if ( $ format = $ this - > get Date Format ( $ field ) ) { return $ this - > do With Format ( $ format , $ value , $ parameter , $ before ) ; } if ( ! ( $ time = strtotime ( $ parameter [ 0 ] ) ) ) { if ( null = = = ( $ _ = $ validator - > get Field Value ( $ parameter [ 0 ] ) ) ) { return false ; } return $ this - > compare Time ( strtotime ( $ value ) , strtotime ( $ _ ) , $ before ) ; } return $ this - > compare Time ( strtotime ( $ value ) , $ time , $ before ) ; } 
protected function compare Time ( int $ left , int $ right , bool $ before = false ) : bool { if ( true = = = $ before ) { return $ left < $ right ; } return $ left > $ right ; } 
protected function do With Format ( string $ format , $ value , array $ parameter , bool $ before = false ) : bool { $ parameter [ 0 ] = $ this - > validator - > get Field Value ( $ parameter [ 0 ] ) ? : $ parameter [ 0 ] ; if ( true = = = $ before ) { list ( $ parameter [ 0 ] , $ value ) = [ $ value , $ parameter [ 0 ] ] ; } return $ this - > do Check Date ( $ format , $ parameter [ 0 ] , $ value ) ; } 
protected function do Check Date ( string $ format , string $ first , string $ second ) : bool { $ before = $ this - > make Date Time Format ( $ format , $ first ) ; $ after = $ this - > make Date Time Format ( $ format , $ second ) ; return $ before & & $ after & & $ before < $ after ; } 
protected function make Date Time Format ( string $ format , string $ value ) { $ date = Date Time : : create From Format ( $ format , $ value ) ; if ( $ date ) { return $ date ; } try { return new Date Time ( $ value ) ; } catch ( Exception $ e ) { } } 
protected function make Connect Redis ( array $ options = [ ] ) : Redis { $ options = $ this - > normalize Connect Option ( 'redis ' , $ options ) ; return new Redis ( new Php Redis ( $ options ) , $ options ) ; } 
public function register Compilers ( ) : IParser { foreach ( $ this - > compiler - > get Compilers ( ) as $ compiler ) { foreach ( ( array ) $ compiler [ 1 ] as $ name ) { $ this - > register Compiler ( $ compiler [ 0 ] , $ name , $ compiler [ 2 ] ) ; } } return $ this ; } 
public function register Parsers ( ) : IParser { foreach ( $ this - > tags as $ key = > $ value ) { $ this - > register Parser ( $ key ) ; } return $ this ; } 
public function do Compile ( string $ file , ? string $ cache Path = null , bool $ is Content = false ) { 
protected function global Parse ( string & $ compiled ) : void { $ tag = $ this - > get Tag ( 'global ' ) ; if ( preg _match _all ( " / { $tag [ 'left ' ] }tagself { $tag [ 'right ' ] } ( . + ? ) { $tag [ 'left ' ] } \ \ /tagself { $tag [ 'right ' ] } /isx " , $ compiled , $ res ) ) { $ start Pos = 0 ; foreach ( $ res [ 1 ] as $ index = > $ encode ) { $ source = trim ( $ res [ 0 ] [ $ index ] ) ; $ content = trim ( $ res [ 1 ] [ $ index ] ) ; $ theme = [ 'source ' = > $ source , 'content ' = > $ content , 'compiler ' = > 'global ' , 
protected function code Parse ( string & $ compiled ) : void { foreach ( $ this - > compilers [ 'code ' ] as $ compilers = > $ tag ) { 
protected function js Parse ( string & $ compiled ) : void { $ this - > js Node = true ; $ this - > normalize Node Parse ( $ compiled ) ; } 
protected function node Parse ( string & $ compiled ) : void { $ this - > js Node = false ; $ this - > normalize Node Parse ( $ compiled ) ; } 
protected function normalize Node Parse ( string & $ compiled ) : void { 
protected function revert Parse ( string & $ compiled ) : void { if ( preg _match _all ( ' / _ _ # #revert # #START # # \d + @ ( . + ? ) # #END # #revert # # _ _ / ' , $ compiled , $ res ) ) { $ start Pos = 0 ; foreach ( $ res [ 1 ] as $ index = > $ encode ) { $ source = $ res [ 0 ] [ $ index ] ; $ theme = [ 'source ' = > $ source , 'content ' = > $ encode , 'compiler ' = > 'revert ' , 
protected function find Node Tag ( string & $ compiled ) : void { 
protected function pack Node ( string & $ compiled ) : void { if ( true = = = $ this - > js Node ) { $ node Tag = $ this - > compiler - > get Js Tag Help ( ) ; $ compiler = 'Js ' ; } else { $ node Tag = $ this - > compiler - > get Node Tag Help ( ) ; $ compiler = 'Node ' ; } 
protected function register Compiler ( string $ type , string $ name , string $ tag ) : void { $ this - > compilers [ $ type ] [ $ name ] = $ tag ; } 
protected function compile Theme Tree ( ) : string { $ cache = ' ' ; foreach ( $ this - > theme Tree as $ theme ) { $ this - > compile Theme ( $ theme ) ; $ cache . = $ theme [ 'content ' ] ; } return $ cache ; } 
protected function compile Theme ( array & $ theme ) : void { foreach ( $ theme [ 'children ' ] as $ key = > $ value ) { $ source = $ value [ 'source ' ] ; 
protected function make Cache File ( string $ cache Path , string & $ compiled ) : void { $ content = ' < ? ' . 'php / * ' . date ( 'Y -m -d H :i :s ' ) . ' * / ? ' . ' > ' . PHP _EOL . $ compiled ; create _file ( $ cache Path , $ content ) ; } 
protected function add Theme ( array $ theme ) : void { $ top = & $ this - > theme Tree [ 0 ] ; $ top = $ this - > add Theme Tree ( $ top , $ theme ) ; } 
protected function add Theme Tree ( array $ top , array $ new ) : array { $ result = [ ] ; foreach ( $ top [ 'children ' ] as $ child ) { if ( $ new ) { $ relative = $ this - > position Relative ( $ new [ 'position ' ] , $ child [ 'position ' ] ) ; switch ( $ relative ) { case 'front ' : $ result [ ] = $ new ; $ result [ ] = $ child ; $ new = null ; break ; case 'behind ' : $ result [ ] = $ child ; break ; case 'in ' : $ child = $ this - > add Theme Tree ( $ child , $ new ) ; $ result [ ] = $ child ; $ new = null ; break ; case 'out ' : $ new = $ this - > add Theme Tree ( $ new , $ child ) ; break ; } } else { $ result [ ] = $ child ; } } if ( $ new ) { $ result [ ] = $ new ; } $ top [ 'children ' ] = $ result ; return $ top ; } 
protected function get Position ( string $ content , string $ find , int $ start ) : array { $ data = [ ] ; * 匹 配 模 块 范 围 圈 （ 在 这 个 字 节 里 面 的 都 是 它 的 子 模 快 ） * 找 到 开 始 和 结 束 的 地 方 就 确 定 了 这 个 模 块 所 在 区 域 范 围 . * / 
protected function position Relative ( array $ value , array $ beyond ) : string { if ( $ value [ 'end ' ] < = $ beyond [ 'start ' ] ) { return 'front ' ; } if ( $ value [ 'start ' ] > = $ beyond [ 'end ' ] ) { return 'behind ' ; } if ( $ value [ 'start ' ] > = $ beyond [ 'start ' ] & & $ value [ 'end ' ] < = $ beyond [ 'end ' ] ) { return 'in ' ; } if ( $ value [ 'start ' ] < = $ beyond [ 'start ' ] & & $ value [ 'end ' ] > = $ beyond [ 'end ' ] ) { return 'out ' ; } 
protected function get Location ( array $ position ) : string { return sprintf ( 'Line : %s ; column : %s ; file : %s . ' , $ position [ 'start _line ' ] , $ position [ 'start _in ' ] , $ this - > source File ? : null ) . ( $ this - > source File ? $ this - > get Location Source ( $ position ) : null ) ; } 
protected function get Location Source ( array $ position ) : string { $ line = explode ( PHP _EOL , htmlentities ( substr ( file _get _contents ( $ this - > source File ) , $ position [ 'start ' ] , $ position [ 'end ' ] ) ) ) ; $ line [ ] = ' <div class = "template -key " > ' . array _pop ( $ line ) . ' < /div > ' ; return ' <pre > <code > ' . implode ( PHP _EOL , $ line ) . ' < /code > < /pre > ' ; } 
public function terminate ( Closure $ next , IRequest $ request , IResponse $ response ) : void { $ this - > save Log ( ) ; $ next ( $ request , $ response ) ; } 
public function make Connect ( ) { if ( empty ( $ this - > option [ 'path ' ] ) ) { throw new Invalid Argument Exception ( 'The zip requires path option . ' ) ; } if ( ! class _exists ( 'League \Flysystem \Zip Archive \Zip Archive Adapter ' ) ) { throw new Invalid Argument Exception ( 'Please run composer require league /flysystem -ziparchive . ' ) ; } return new Zip Archive Adapter ( $ this - > option [ 'path ' ] ) ; } 
public function switch View ( IViews $ theme ) : IView { $ assign = $ this - > get Assign ( ) ; $ this - > theme = $ theme ; $ this - > assign ( $ assign ) ; return $ this ; } 
public function assign ( $ name , $ value = null ) : IView { $ this - > theme - > set Var ( $ name , $ value ) ; return $ this ; } 
public function display ( string $ file , array $ vars = [ ] , ? string $ ext = null ) : string { return $ this - > theme - > display ( $ file , $ vars , $ ext , false ) ; } 
public static function create ( $ data = null , int $ status = 2 0 0 , array $ headers = [ ] ) : IResponse { return new static ( $ data , $ status , $ headers ) ; } 
public static function from Json String ( ? string $ data = null , $ status = 2 0 0 , $ headers = [ ] ) : IResponse { return new static ( $ data , $ status , $ headers , true ) ; } 
public function set Callback ( ? string $ callback = null ) : IResponse { if ( $ this - > check Flow Control ( ) ) { return $ this ; } $ this - > callback = $ callback ; return $ this - > update Content ( ) ; } 
public function set Json ( $ json ) : IResponse { if ( $ this - > check Flow Control ( ) ) { return $ this ; } if ( ! $ this - > is Json Data ( $ json ) ) { throw new Invalid Argument Exception ( 'The method set Json need a json data . ' ) ; } $ this - > data = $ json ; return $ this - > update Content ( ) ; } 
public function get Data ( bool $ assoc = true , int $ depth = 5 1 2 ) { return json _decode ( $ this - > data , $ assoc , $ depth ) ; } 
public function set Encoding Options ( int $ encoding Options ) : IResponse { if ( $ this - > check Flow Control ( ) ) { return $ this ; } $ this - > encoding Options = ( int ) $ encoding Options ; return $ this - > set Data ( $ this - > get Data ( ) ) ; } 
protected function is Json Data ( $ data ) : bool { if ( ! is _scalar ( $ data ) & & ! method _exists ( $ data , ' _ _to String ' ) ) { return false ; } json _decode ( ( string ) ( $ data ) ) ; return JSON _ERROR _NONE = = = json _last _error ( ) ; } 
protected function update Content ( ) : IResponse { if ( null ! = = $ this - > callback ) { $ this - > headers - > set ( 'Content -Type ' , 'text /javascript ' ) ; return $ this - > set Content ( sprintf ( ' ; %s ( %s ) ; ' , $ this - > callback , $ this - > data ) ) ; } if ( ! $ this - > headers - > has ( 'Content -Type ' ) | | 'text /javascript ' = = = $ this - > headers - > get ( 'Content -Type ' ) ) { $ this - > headers - > set ( 'Content -Type ' , 'application /json ' ) ; } return $ this - > set Content ( $ this - > data ) ; } 
protected function create ( ) : void { 
protected function replace Template Source ( ) : void { 
protected function save Template Result ( ) : void { $ save File Path = $ this - > get Save File Path ( ) ; if ( is _file ( $ save File Path ) ) { $ e = 'File is already exits . ' . PHP _EOL . $ this - > format File ( $ save File Path ) ; throw new Runtime Exception ( $ e ) ; } create _file ( $ save File Path , $ this - > get Template Result ( ) ) ; } 
protected function parse Template Source ( ) : void { $ template Source = $ this - > get Template Path ( ) ; if ( ! is _file ( $ template Source ) ) { throw new Runtime Exception ( 'Stub not found . ' . PHP _EOL . $ this - > format File ( $ template Source ) ) ; } $ this - > template Source = file _get _contents ( $ template Source ) ; } 
protected function parse Source And Replace ( ) : array { $ replace Key Value = array _merge ( static : : $ global Replace , $ this - > get Default Replace Key Value ( ) ) ; $ source Key = array _map ( function ( $ item ) { return ' { { ' . $ item . ' } } ' ; } , array _keys ( $ replace Key Value ) ) ; $ replace = array _values ( $ replace Key Value ) ; return [ $ source Key , $ replace ] ; } 
protected function get Namespace Path ( ) : string { $ namespace Path = $ this - > get Container ( ) - > namespace Path ( $ this - > get Namespace ( ) . ' \ \index ' , true ) . ' / ' ; return $ namespace Path ; } 
protected function set Custom Replace Key Value ( $ key , $ value = null ) { if ( is _array ( $ key ) ) { $ this - > custom Replace Key Value = array _merge ( $ this - > custom Replace Key Value , $ key ) ; } else { $ this - > custom Replace Key Value [ $ key ] = $ value ; } } 
public function context ( string $ class Name ) : bool { if ( ! class _exists ( $ class Name ) ) { return false ; } if ( method _exists ( $ class Name , 'coroutine Context ' ) & & true = = = $ class Name : : coroutine Context ( ) ) { return true ; } return false ; } 
public function set Option ( string $ name , $ value ) : self { $ this - > option [ $ name ] = $ value ; return $ this ; } 
public function handle ( IRequest $ request , IResponse $ response ) : void { if ( ! $ this - > enabled ) { return ; } if ( $ request - > is Json ( ) | | $ response instanceof Api Response | | $ response instanceof Json Response | | $ response - > is Json ( ) ) { if ( $ this - > option [ 'json ' ] & & is _array ( $ data = $ response - > get Data ( ) ) ) { $ json Renderer = $ this - > get Json Renderer ( ) ; if ( array _values ( $ data ) ! = = $ data ) { $ data [ ' :trace ' ] = $ json Renderer - > render ( ) ; } else { $ data [ ] = [ ' :trace ' = > $ json Renderer - > render ( ) ] ; } $ response - > set Data ( $ data ) ; } } elseif ( ! ( $ response instanceof Redirect Response ) ) { if ( $ this - > option [ 'javascript ' ] ) { $ javascript Renderer = $ this - > get Javascript Renderer ( ' /debugbar ' ) ; $ response - > append Content ( $ javascript Renderer - > render Head ( ) . $ javascript Renderer - > render ( ) ) ; } if ( $ this - > option [ 'console ' ] ) { $ console Renderer = $ this - > get Console Renderer ( ) ; $ response - > append Content ( $ console Renderer - > render ( ) ) ; } } } 
public function message ( $ message , string $ label = 'info ' ) : void { $ this - > get Collector ( 'messages ' ) - > add Message ( $ message , $ label ) ; } 
public function time ( string $ name , ? string $ label = null ) : void { $ this - > get Collector ( 'time ' ) - > start Measure ( $ name , $ label ) ; } 
public function end ( string $ name ) : void { try { $ this - > get Collector ( 'time ' ) - > stop Measure ( $ name ) ; } catch ( Exception $ e ) { } } 
public function add Time ( string $ label , float $ start , float $ end ) : void { $ this - > get Collector ( 'time ' ) - > add Measure ( $ label , $ start , $ end ) ; } 
public function closure Time ( string $ label , Closure $ closure ) : void { $ this - > get Collector ( 'time ' ) - > measure ( $ label , $ closure ) ; } 
public function get Javascript Renderer ( $ base Url = null , $ base Path = null ) : Javascript Renderer { return new Javascript Renderer ( $ this , $ base Url , $ base Path ) ; } 
public function bootstrap ( ) : void { if ( $ this - > is Bootstrap ) { return ; } $ this - > add Collector ( new Php Info Collector ( ) ) ; $ this - > add Collector ( new Messages Collector ( ) ) ; $ this - > add Collector ( new Request Data Collector ( ) ) ; $ this - > add Collector ( new Time Data Collector ( ) ) ; $ this - > add Collector ( new Memory Collector ( ) ) ; $ this - > add Collector ( new Exceptions Collector ( ) ) ; $ this - > add Collector ( new Config Collector ( ) ) ; $ this - > add Collector ( new Leevel Collector ( $ this - > app ) ) ; $ this - > add Collector ( new Session Collector ( $ this - > app - > make ( 'session ' ) ) ) ; $ this - > add Collector ( new Files Collector ( $ this - > app ) ) ; $ this - > add Collector ( new Logs Collector ( ) ) ; $ this - > init Data ( ) ; $ this - > database Event Dispatch ( ) ; $ this - > log Event Dispatch ( ) ; $ this - > is Bootstrap = true ; } 
protected function init Data ( ) : void { $ this - > message ( 'Starts from this moment with Query PHP . ' , ' ' ) ; $ this - > get Collector ( 'config ' ) - > set Data ( $ this - > app - > make ( 'option ' ) - > all ( ) ) ; } 
protected function database Event Dispatch ( ) : void { $ this - > get Event Dispatch ( ) - > register ( IConnect : : SQL _EVENT , function ( string $ event , string $ sql , array $ bind Params = [ ] ) { $ this - > get Collector ( 'logs ' ) - > add Message ( $ sql . ' : ' . json _encode ( $ bind Params , JSON _UNESCAPED _UNICODE ) , 'sql ' ) ; } ) ; } 
protected function log Event Dispatch ( ) : void { $ this - > get Event Dispatch ( ) - > register ( ILog : : LOG _EVENT , function ( string $ event , string $ level , string $ message , array $ context = [ ] ) { $ this - > get Collector ( 'logs ' ) - > add Message ( File : : format Message ( $ level , $ message , $ context ) , $ level ) ; } ) ; } 
public function handle ( IApp $ app ) : void { $ this - > line ( 'Start to clear cache log . ' ) ; delete _directory ( $ cache Path = $ app - > runtime Path ( 'log ' ) , true ) ; $ this - > info ( sprintf ( 'Log files in path %s cache clear successed . ' , $ cache Path ) ) ; } 
public function handle ( ) : void { $ this - > include Bootstrap File ( ) ; if ( ! ( $ files = $ this - > parse Files ( ) ) ) { throw new Invalid Argument Exception ( 'Files was not found . ' ) ; } $ this - > utils Doc = new Utils Doc ( $ this - > output Dir ( ) ) ; $ this - > class Parser = new Class Parser ( ) ; $ succeed Count = 0 ; foreach ( $ files as $ file ) { if ( true = = = $ this - > convert Markdown ( $ file ) ) { $ succeed Count + + ; } } $ this - > info ( sprintf ( 'A total of <comment > %d < /comment > files generate succeed . ' , $ succeed Count ) ) ; } 
protected function convert Markdown ( string $ file ) : bool { $ class Name = $ this - > class Parser - > handle ( $ file ) ; if ( ! class _exists ( $ class Name ) ) { return false ; } $ result = $ this - > utils Doc - > handle And Save ( $ class Name ) ; if ( true = = = $ result ) { $ this - > line ( sprintf ( 'Class <info > %s < /info > was generate succeed . ' , $ class Name ) ) ; } return $ result ; } 
protected function parse Files ( ) : array { $ file Or Dir = dirname ( $ this - > tests Dir ( ) ) . ' / ' . $ this - > path ( ) ; $ result = [ ] ; if ( is _file ( $ file Or Dir ) ) { $ result [ ] = $ file Or Dir ; } elseif ( is _dir ( $ file Or Dir ) ) { list _directory ( $ file Or Dir , true , function ( Directory Iterator $ file ) use ( & $ result ) { if ( $ file - > is File ( ) ) { $ result [ ] = $ file - > get Pathname ( ) ; } } ) ; } return $ result ; } 
public function handle ( Manager $ database ) : void { $ this - > database = $ database ; 
protected function get Replace ( ) : array { $ columns = $ this - > get Columns ( ) ; return [ 'file _name ' = > ucfirst ( camelize ( $ this - > argument ( 'name ' ) ) ) , 'table _name ' = > $ this - > get Table Name ( ) , 'primary _key ' = > $ this - > get Primary Key ( $ columns ) , 'primary _key _type ' = > $ this - > get Primary Key Type ( $ columns ) , 'auto _increment ' = > $ this - > get Auto Increment ( $ columns ) , 'struct ' = > $ this - > get Struct ( $ columns ) , 'props ' = > $ this - > get Props ( $ columns ) , ] ; } 
protected function get Primary Key ( array $ columns ) : string { if ( ! $ columns [ 'primary _key ' ] ) { return 'null ' ; } if ( count ( $ columns [ 'primary _key ' ] ) > 1 ) { return ' [ ' . implode ( ' , ' , array _map ( function ( $ item ) { return " ' { $item } ' " ; } , $ columns [ 'primary _key ' ] ) ) . ' ] ' ; } return " ' { $columns [ 'primary _key ' ] [ 0 ] } ' " ; } 
protected function get Struct ( array $ columns ) : string { $ struct = [ ' [ ' ] ; foreach ( $ columns [ 'list ' ] as $ val ) { if ( $ val [ 'primary _key ' ] ) { $ struct [ ] = " ' { $val [ 'name ' ] } ' = > [ 'readonly ' = > true , ] , " ; } else { $ struct [ ] = " ' { $val [ 'name ' ] } ' = > [ ] , " ; } } $ struct [ ] = ' ] ' ; return implode ( PHP _EOL , $ struct ) ; } 
protected function get Props ( array $ columns ) : string { $ props = [ ] ; foreach ( $ columns [ 'list ' ] as $ val ) { $ comment = $ val [ 'comment ' ] ? : $ val [ 'name ' ] ; $ prop Name = camelize ( $ val [ 'name ' ] ) ; $ type = in _array ( $ val [ 'type ' ] , [ 'tinyint ' , 'smallint ' , 'mediumint ' , 'int ' , 'integer ' , 'bigint ' ] , true ) ? 'int ' : 'string ' ; $ tmp Prop = " / * * * { $comment } . * * @var { $type } * / private \ $ { $prop Name } ; " ; $ props [ ] = $ tmp Prop ; } return implode ( ' ' , $ props ) ; } 
public function bind ( $ name , $ service = null , bool $ share = false ) : IContainer { if ( is _array ( $ name ) ) { list ( $ name , $ alias ) = $ this - > parse Alias ( $ name ) ; $ this - > alias ( $ name , $ alias ) ; } if ( null = = = $ service ) { $ service = $ name ; } $ this - > services [ $ name ] = $ service ; if ( $ share ) { $ this - > singletons [ ] = $ name ; } return $ this ; } 
public function instance ( $ name , $ service = null ) : IContainer { if ( is _array ( $ name ) ) { list ( $ name , $ alias ) = $ this - > parse Alias ( $ name ) ; $ this - > alias ( $ name , $ alias ) ; } if ( null = = = $ service ) { $ service = $ name ; } if ( $ this - > coroutine Context ( $ service ) ) { $ this - > coroutine Instances [ $ this - > coroutine Uid ( ) ] [ $ name ] = $ service ; } else { $ this - > instances [ $ name ] = $ service ; } return $ this ; } 
public function singleton ( $ name , $ service = null ) : IContainer { return $ this - > bind ( $ name , $ service , true ) ; } 
public function alias ( $ alias , $ value = null ) : IContainer { if ( is _array ( $ alias ) ) { foreach ( $ alias as $ key = > $ item ) { if ( is _int ( $ key ) ) { continue ; } $ this - > alias ( $ key , $ item ) ; } } else { $ value = ( array ) $ value ; foreach ( $ value as $ item ) { $ this - > alias [ $ item ] = $ alias ; } } return $ this ; } 
public function make ( string $ name , array $ args = [ ] ) { 
public function call ( $ callback , array $ args = [ ] ) { $ is Static = false ; if ( is _string ( $ callback ) ) { if ( false ! = = strpos ( $ callback , ' @ ' ) ) { $ callback = explode ( ' @ ' , $ callback ) ; } elseif ( false ! = = strpos ( $ callback , ' : : ' ) ) { $ callback = explode ( ' : : ' , $ callback ) ; $ is Static = true ; } } if ( false = = = $ is Static & & is _array ( $ callback ) ) { if ( ! is _object ( $ callback [ 0 ] ) ) { if ( ! is _string ( $ callback [ 0 ] ) ) { throw new Invalid Argument Exception ( 'The classname must be string . ' ) ; } $ callback [ 0 ] = $ this - > get Injection Object ( $ callback [ 0 ] ) ; } if ( empty ( $ callback [ 1 ] ) ) { $ callback [ 1 ] = 'handle ' ; } } $ args = $ this - > normalize Injection Args ( $ callback , $ args ) ; return call _user _func _array ( $ callback , $ args ) ; } 
public function remove ( string $ name ) : void { $ name = $ this - > normalize ( $ name ) ; $ prop = [ 'services ' , 'instances ' , 'singletons ' , ] ; foreach ( $ prop as $ item ) { if ( isset ( $ this - > { $ item } [ $ name ] ) ) { unset ( $ this - > { $ item } [ $ name ] ) ; } } if ( $ this - > exists Coroutine ( $ name ) ) { unset ( $ this - > coroutine Instances [ $ this - > coroutine Uid ( ) ] [ $ name ] ) ; } } 
public function remove Coroutine ( ? string $ name = null ) : void { if ( ! $ this - > coroutine ) { return ; } if ( null = = = $ name ) { if ( isset ( $ this - > coroutine Instances [ $ this - > coroutine Uid ( ) ] ) ) { unset ( $ this - > coroutine Instances [ $ this - > coroutine Uid ( ) ] ) ; } } else { $ name = $ this - > normalize ( $ name ) ; if ( $ this - > exists Coroutine ( $ name ) ) { unset ( $ this - > coroutine Instances [ $ this - > coroutine Uid ( ) ] [ $ name ] ) ; } } } 
public function exists ( string $ name ) : bool { $ name = $ this - > normalize ( $ name ) ; $ name = $ this - > get Alias ( $ name ) ; return isset ( $ this - > services [ $ name ] ) | | isset ( $ this - > instances [ $ name ] ) | | $ this - > exists Coroutine ( $ name ) ; } 
public function clear ( ) : void { $ prop = [ 'services ' , 'instances ' , 'singletons ' , 'coroutine Instances ' , ] ; foreach ( $ prop as $ item ) { $ this - > { $ item } = [ ] ; } $ this - > alias = [ ] ; } 
public function exists Coroutine ( string $ name ) : bool { return false ! = = $ this - > coroutine Uid ( ) & & isset ( $ this - > coroutine Instances [ $ this - > coroutine Uid ( ) ] , $ this - > coroutine Instances [ $ this - > coroutine Uid ( ) ] [ $ name ] ) ; } 
protected function coroutine Context ( $ instance ) : bool { if ( ! $ this - > coroutine ) { return false ; } if ( is _object ( $ instance ) ) { $ instance = get _class ( $ instance ) ; } return $ this - > coroutine - > context ( $ instance ) ; } 
protected function get Injection Object ( string $ classname , array $ args = [ ] ) { if ( interface _exists ( $ classname ) ) { $ e = sprintf ( 'Interface %s cannot be normalize because not binded . ' , $ classname ) ; throw new Container Invalid Argument Exception ( $ e ) ; } if ( ! class _exists ( $ classname ) ) { return $ classname ; } $ args = $ this - > normalize Injection Args ( $ classname , $ args ) ; return $ this - > new Instance Args ( $ classname , $ args ) ; } 
protected function normalize Injection Args ( $ value , array $ args ) : array { list ( $ args , $ required , $ valid Args ) = $ this - > parse Injection ( $ value , $ args ) ; if ( $ valid Args < $ required ) { $ e = sprintf ( 'There are %d required args ,but %d gived . ' , $ required , $ valid Args ) ; throw new Container Invalid Argument Exception ( $ e ) ; } return $ args ; } 
protected function parse Injection ( $ injection , array $ args = [ ] ) : array { $ result = [ ] ; $ required = 0 ; $ param = $ this - > parse Reflection ( $ injection ) ; $ valid Args = count ( $ param ) ; foreach ( $ param as $ key = > $ item ) { try { switch ( true ) { case $ argsclass = $ this - > parse Parameter Class ( $ item ) : if ( isset ( $ args [ 0 ] ) & & is _object ( $ args [ 0 ] ) & & $ args [ 0 ] instanceof $ argsclass ) { $ data = array _shift ( $ args ) ; } elseif ( array _key _exists ( $ argsclass , $ args ) ) { $ data = $ args [ $ argsclass ] ; } elseif ( $ item - > is Default Value Available ( ) ) { $ data = $ item - > get Default Value ( ) ; } else { $ data = $ this - > parse Class From Container ( $ argsclass ) ; } $ required + + ; $ valid Args + + ; break ; case $ item - > is Default Value Available ( ) : $ data = array _key _exists ( $ item - > name , $ args ) ? $ args [ $ item - > name ] : $ item - > get Default Value ( ) ; break ; default : $ required + + ; if ( array _key _exists ( $ item - > name , $ args ) ) { $ data = $ args [ $ item - > name ] ; $ valid Args + + ; } else { if ( isset ( $ args [ 0 ] ) ) { $ data = array _shift ( $ args ) ; } else { $ valid Args - - ; $ data = null ; } } break ; } $ result [ $ item - > name ] = $ data ; } catch ( Reflection Exception $ e ) { throw new Invalid Argument Exception ( $ e - > get Message ( ) ) ; } } if ( $ args ) { $ result = array _values ( $ result ) ; 
protected function parse Parameter Class ( Reflection Parameter $ param ) { $ class Object = $ param - > get Class ( ) ; if ( ! $ class Object | | ! ( $ class Object instanceof Reflection Class ) ) { return false ; } return $ class Object - > get Name ( ) ; } 
protected function parse Class From Container ( string $ argsclass ) { $ item Make = $ this - > make ( $ argsclass ) ; 
protected function parse Reflection ( $ injection ) : array { switch ( true ) { case $ injection instanceof Closure : return $ this - > parse Closure Reflection ( $ injection ) ; case ! is _string ( $ injection ) & & is _callable ( $ injection ) : return $ this - > parse Method Reflection ( $ injection ) ; case is _string ( $ injection ) : return $ this - > parse Class Reflection ( $ injection ) ; default : throw new Invalid Argument Exception ( 'Unsupported callback types . ' ) ; } } 
protected function parse Closure Reflection ( Closure $ injection ) : array { $ reflection = new Reflection Function ( $ injection ) ; if ( ! ( $ param = $ reflection - > get Parameters ( ) ) ) { $ param = [ ] ; } return $ param ; } 
protected function parse Method Reflection ( callable $ injection ) : array { $ reflection = new Reflection Method ( $ injection [ 0 ] , $ injection [ 1 ] ) ; if ( ! ( $ param = $ reflection - > get Parameters ( ) ) ) { $ param = [ ] ; } return $ param ; } 
protected function parse Class Reflection ( string $ injection ) : array { $ reflection = new Reflection Class ( $ injection ) ; if ( ! $ reflection - > is Instantiable ( ) ) { $ e = sprintf ( 'Class %s is not instantiable . ' , $ injection ) ; throw new Invalid Argument Exception ( $ e ) ; } $ param = [ ] ; if ( ( $ constructor = $ reflection - > get Constructor ( ) ) ) { $ param = $ constructor - > get Parameters ( ) ; } return $ param ; } 
protected function new Instance Args ( string $ classname , array $ args ) { try { 
public function set Option ( string $ name , $ value ) : IConnect { $ this - > option [ $ name ] = $ value ; return $ this ; } 
public function flush ( array $ data ) : void { foreach ( $ data as $ value ) { $ method = $ this - > normalize Level ( array _shift ( $ value ) ) ; $ this - > monolog - > { $ method } ( . . . $ value ) ; } } 
protected function normalize Level ( string $ level ) : string { if ( ! in _array ( $ level , array _keys ( $ this - > support Level ) , true ) ) { return ILog : : DEBUG ; } return $ level ; } 
protected function normalize Monolog Level ( string $ level ) : int { if ( isset ( $ this - > support Level [ $ level ] ) ) { return $ this - > support Level [ $ level ] ; } return $ this - > support Level [ ILog : : DEBUG ] ; } 
public function report ( Exception $ e ) { if ( method _exists ( $ e , 'report ' ) ) { return $ e - > report ( ) ; } 
public function render ( IRequest $ request , Exception $ e ) : IResponse { if ( method _exists ( $ e , 'render ' ) & & $ response = $ e - > render ( $ request , $ e ) ) { if ( ! ( $ response instanceof IResponse ) ) { $ response = new Response ( $ response , $ this - > normalize Status Code ( $ e ) , $ this - > normalize Headers ( $ e ) ) ; } return $ response ; } $ e = $ this - > prepare Exception ( $ e ) ; if ( $ request - > is Accept Json ( ) ) { return $ this - > make Json Response ( $ e ) ; } return $ this - > make Http Response ( $ e ) ; } 
public function render For Console ( Output Interface $ output , Exception $ e ) : void { $ handler = ( new Collision Provider ( ) ) - > register ( ) - > get Handler ( ) - > set Output ( $ output ) ; $ handler - > set Inspector ( new Inspector ( $ e ) ) ; $ handler - > handle ( ) ; } 
public function rendor With Http Exception View ( Exception $ e ) : IResponse { $ filepath = $ this - > get Http Exception View ( $ e ) ; if ( file _exists ( $ filepath ) ) { $ vars = $ this - > get Exception Vars ( $ e ) ; $ content = $ this - > render With File ( $ filepath , $ vars ) ; return new Response ( $ content , $ e - > get Status Code ( ) , $ e - > get Headers ( ) ) ; } return $ this - > convert Exception To Response ( $ e ) ; } 
protected function make Http Response ( Exception $ e ) : IResponse { if ( $ this - > container - > debug ( ) ) { return $ this - > convert Exception To Response ( $ e ) ; } if ( ! $ this - > is Http Exception ( $ e ) ) { $ e = new Http Exception ( 5 0 0 , $ e - > get Message ( ) ) ; } return $ this - > rendor With Http Exception View ( $ e ) ; } 
protected function make Json Response ( Exception $ e ) : IResponse { $ whoops = $ this - > make Whoops ( ) ; $ whoops - > push Handler ( $ this - > make Json Response Handler ( ) ) ; 
protected function convert Exception To Response ( Exception $ e ) : IResponse { return new Response ( $ this - > render Exception Content ( $ e ) , $ this - > normalize Status Code ( $ e ) , $ this - > normalize Headers ( $ e ) ) ; } 
protected function render Exception Content ( Exception $ e ) : string { if ( $ this - > container - > debug ( ) ) { return $ this - > render Exception With Whoops ( $ e ) ; } return $ this - > render Exception With Default ( $ e ) ; } 
protected function render Exception With Default ( Exception $ e ) : string { $ vars = $ this - > get Exception Vars ( $ e ) ; return $ this - > render With File ( $ this - > get Default Http Exception View ( ) , $ vars ) ; } 
protected function render Exception With Whoops ( Exception $ e ) : string { $ whoops = $ this - > make Whoops ( ) ; $ pretty Page = new Pretty Page Handler ( ) ; $ pretty Page - > handle Unconditionally ( true ) ; $ whoops - > push Handler ( $ pretty Page ) ; return $ whoops - > handle Exception ( $ e ) ; } 
protected function get Exception Vars ( Exception $ e ) : array { return [ 'e ' = > $ e , 'code ' = > $ this - > normalize Status Code ( $ e ) , 'message ' = > $ e - > get Message ( ) , 'type ' = > get _class ( $ e ) , 'file ' = > $ this - > filter Physical Path ( $ e - > get File ( ) ) , 'line ' = > $ e - > get Line ( ) , ] ; } 
protected function make Whoops ( ) : Run { $ whoops = new Run ( ) ; $ whoops - > write To Output ( false ) ; $ whoops - > allow Quit ( false ) ; return $ whoops ; } 
protected function prepare Exception ( Exception $ e ) : Exception { if ( $ e instanceof Entity Not Found Exception ) { $ e = new Not Found Http Exception ( $ e - > get Message ( ) , $ e - > get Code ( ) ) ; } return $ e ; } 
protected function render With File ( string $ filepath , array $ vars = [ ] ) : string { if ( ! is _file ( $ filepath ) ) { throw new Exception ( sprintf ( 'Exception file %s is not extis . ' , $ filepath ) ) ; } extract ( $ vars ) ; ob _start ( ) ; require $ filepath ; $ content = ob _get _contents ( ) ; ob _end _clean ( ) ; return $ content ; } 
public function validate ( $ value , array $ parameter , IValidator $ validator , string $ field ) : bool { return $ this - > validate Date ( $ value , $ parameter , $ validator , $ field ) ; } 
public function flush ( array $ datas ) : void { $ level = $ datas [ 0 ] [ 0 ] ; $ this - > check Size ( $ filepath = $ this - > normalize Path ( $ level ) ) ; foreach ( $ datas as $ value ) { error _log ( self : : format Message ( . . . $ value ) , 3 , $ filepath ) ; } } 
public static function format Message ( string $ level , string $ message , array $ context = [ ] ) : string { return sprintf ( ' [ %s ] %s %s : %s ' . PHP _EOL , date ( 'Y -m -d H :i :s ' ) , $ message , $ level , json _encode ( $ context , JSON _UNESCAPED _UNICODE ) ) ; } 
protected function check Size ( string $ file Path ) : void { $ dirname = dirname ( $ file Path ) ; if ( ! is _file ( $ file Path ) ) { create _directory ( $ dirname ) ; } 
protected function normalize Path ( string $ level ) : string { if ( ! $ this - > option [ 'path ' ] ) { throw new Invalid Argument Exception ( 'Path for log has not set . ' ) ; } return $ this - > option [ 'path ' ] . ' / ' . $ this - > option [ 'channel ' ] . ' . ' . ( $ level ? $ level . ' / ' : ' ' ) . date ( $ this - > option [ 'name ' ] ) . ' .log ' ; } 
public function make ( string $ url , array $ params = [ ] , string $ subdomain = 'www ' , $ suffix = null ) : string { $ url = $ this - > make Url ( $ url , $ params , null ! = = $ suffix ? $ suffix : $ this - > option [ 'with _suffix ' ] ) ; $ url = $ this - > with Enter ( $ url ) ; $ url = $ this - > With Domain ( $ url , $ subdomain ) ; return $ url ; } 
public function set Option ( string $ name , $ value ) : IUrl { $ this - > option [ $ name ] = $ value ; return $ this ; } 
protected function make Url ( string $ url , array $ params , $ suffix ) : string { $ this - > params = $ params ; if ( ' / ' ! = = substr ( $ url , 0 , 1 ) ) { $ url = ' / ' . $ url ; } if ( false ! = = strpos ( $ url , ' { ' ) ) { $ url = preg _replace _callback ( ' / { ( . + ? ) } / ' , function ( $ matches ) { if ( isset ( $ this - > params [ $ matches [ 1 ] ] ) ) { $ value = $ this - > params [ $ matches [ 1 ] ] ; unset ( $ this - > params [ $ matches [ 1 ] ] ) ; } else { $ value = $ matches [ 0 ] ; } return $ value ; } , $ url ) ; } if ( $ this - > params ) { $ query Url = http _build _query ( $ this - > params ) ; $ url . = ( false ! = = strpos ( $ url , ' ? ' ) ? ' & ' : ' ? ' ) . $ query Url ; } $ url = $ this - > with Suffix ( $ url , $ suffix ) ; return $ url ; } 
protected function with Domain ( string $ url , string $ domain ) : string { if ( ! $ this - > option [ 'domain ' ] | | ! $ domain ) { return $ url ; } return ( $ this - > is Secure ( ) ? 'https : / / ' : 'http : / / ' ) . ( $ domain & & ' * ' ! = = $ domain ? $ domain . ' . ' : ' ' ) . $ this - > option [ 'domain ' ] . $ url ; } 
protected function with Suffix ( string $ url , $ suffix ) : string { if ( ' / ' = = = $ url | | 0 = = = strpos ( $ url , ' / ? ' ) ) { return $ url ; } $ suffix = true = = = $ suffix ? $ this - > option [ 'suffix ' ] : $ suffix ; if ( false ! = = strpos ( $ url , ' ? ' ) ) { $ url = str _replace ( ' ? ' , $ suffix . ' ? ' , $ url ) ; } else { $ url . = $ suffix ; } return $ url ; } 
protected function with Enter ( string $ url ) : string { $ enter = $ this - > request - > get Enter ( ) ; $ enter = ' / ' ! = = $ enter ? $ enter : ' ' ; return $ enter . $ url ; } 
public function get Headers ( ) : array { $ result = [ ] ; $ content Headers = [ 'CONTENT _LENGTH ' , 'CONTENT _MD 5 ' , 'CONTENT _TYPE ' , ] ; foreach ( $ this - > elements as $ key = > $ value ) { if ( 0 = = = strpos ( $ key , 'HTTP _ ' ) ) { $ result [ substr ( $ key , 5 ) ] = $ value ; } elseif ( in _array ( $ key , $ content Headers , true ) ) { $ result [ $ key ] = $ value ; } } return $ result ; } 
public function add ( Symfony Command $ command ) { if ( $ command instanceof Command ) { $ command - > set Container ( $ this - > container ) ; } return parent : : add ( $ command ) ; } 
public function normalize Command ( string $ command ) : Symfony Command { return $ this - > add ( $ this - > container - > make ( $ command ) ) ; } 
public function and ( ISpecification $ spec ) : ISpecification { $ old = $ this - > spec ; $ old Handle = $ this - > handle ; $ this - > spec = function ( IEntity $ entity ) use ( $ old , $ spec ) : bool { return $ old ( $ entity ) & & $ spec - > is Satisfied By ( $ entity ) ; } ; $ this - > handle = function ( Select $ select , IEntity $ entity ) use ( $ spec , $ old Handle ) { $ old Handle ( $ select , $ entity ) ; $ spec - > handle ( $ select , $ entity ) ; } ; return $ this ; } 
public function not ( ) : ISpecification { $ old = $ this - > spec ; $ this - > spec = function ( IEntity $ entity ) use ( $ old ) : bool { return ! $ old ( $ entity ) ; } ; return $ this ; } 
public function update ( Spl Subject $ subject ) : void { if ( method _exists ( $ this , 'handle ' ) ) { $ handle = [ $ this , 'handle ' ] ; } elseif ( $ this - > handle ) { $ handle = [ $ this , ' _ _invoke ' ] ; } else { $ handle = null ; } if ( ! is _callable ( $ handle ) ) { throw new Invalid Argument Exception ( sprintf ( 'Observer %s must has handle method . ' , get _class ( $ this ) ) ) ; } $ subject - > container - > call ( $ handle , $ subject - > notify Args ) ; } 
public function get ( string $ key , $ defaults = null ) { $ key = $ this - > normalize ( $ key ) ; return $ this - > filter ( $ key , $ defaults ) ; } 
public function set ( string $ key , $ value ) : void { $ key = $ this - > normalize ( $ key ) ; $ this - > elements [ $ key ] = $ value ; } 
public function has ( string $ key ) : bool { $ key = $ this - > normalize ( $ key ) ; return array _key _exists ( $ key , $ this - > elements ) ; } 
public function remove ( string $ key ) : void { $ key = $ this - > normalize ( $ key ) ; if ( $ this - > has ( $ key ) ) { unset ( $ this - > elements [ $ key ] ) ; } } 
public function filter ( string $ key , $ defaults = null , $ filter = null , array $ options = [ ] ) { $ key = $ this - > normalize ( $ key ) ; $ filter = $ this - > parse Filter ( $ filter ) ; list ( $ key , $ filter ) = $ this - > parse Key Filter ( $ key , $ filter ) ; $ part = ' ' ; if ( false ! = = strpos ( $ key , ' \ \ ' ) ) { list ( $ key , $ part ) = explode ( ' \ \ ' , $ key ) ; } $ result = array _key _exists ( $ key , $ this - > elements ) ? $ this - > elements [ $ key ] : $ defaults ; if ( $ part ) { $ result = $ this - > get Part Data ( $ part , $ result , $ defaults ) ; } if ( $ filter ) { $ result = $ this - > filter Value ( $ result , $ defaults , $ filter , $ options ) ; } return $ result ; } 
protected function parse Key Filter ( string $ key , array $ filter ) : array { if ( false ! = = strpos ( $ key , ' | ' ) ) { $ temp = explode ( ' | ' , $ key ) ; $ key = array _shift ( $ temp ) ; $ filter = array _merge ( $ temp , $ filter ) ; } return [ $ key , $ filter ] ; } 
protected function filter Value ( $ value , $ defaults , array $ filters , array $ options = [ ] ) { foreach ( $ filters as $ item ) { if ( is _string ( $ item ) & & false ! = = strpos ( $ item , ' = ' ) ) { $ value = $ this - > filter Value With Func ( $ value , $ item ) ; } elseif ( is _callable ( $ item ) ) { $ value = $ this - > filter Value With Callable ( $ value , $ item ) ; } elseif ( is _scalar ( $ value ) & & ! empty ( $ item ) ) { $ value = $ this - > filter Value With Filter Var ( $ value , $ item , $ options ) ; if ( false = = = $ value ) { $ value = $ defaults ; break ; } } } return $ value ; } 
protected function filter Value With Func ( $ value , string $ filter ) { list ( $ filter , $ extend ) = explode ( ' = ' , $ filter ) ; if ( 'default ' = = = $ filter ) { if ( ! is _numeric ( $ extend ) & & ! preg _match ( ' / ^ [A -Z \ _ ] + $ / ' , $ extend ) ) { $ extend = " ' " . $ extend . " ' " ; } $ evals = " \ $value = ' " . ( $ value ? ' 1 ' : ' ' ) . " ' ? : " . $ extend . ' ; ' ; } elseif ( $ extend ) { if ( false ! = = strpos ( $ extend , ' , ' ) ) { $ tmp = explode ( ' , ' , $ extend ) ; $ result = [ ] ; foreach ( $ tmp as $ v ) { $ v = trim ( $ v ) ; if ( ' * * ' = = = $ v | | is _numeric ( $ v ) | | preg _match ( ' / ^ [A -Z \ _ ] + $ / ' , $ v ) ) { $ result [ ] = $ v ; } else { $ result [ ] = " ' " . $ v . " ' " ; } } $ extend = implode ( ' , ' , $ result ) ; } if ( strstr ( $ extend , ' * * ' ) ) { $ extend = str _replace ( ' * * ' , ' $value ' , $ extend ) ; $ evals = " \ $value = { $filter } ( { $extend } ) ; " ; } else { $ evals = " \ $value = { $filter } ( \ $value , { $extend } ) ; " ; } } eval ( $ evals ) ; return $ value ; } 
protected function filter Value With Filter Var ( $ value , $ filter , array $ options ) { $ value = filter _var ( $ value , $ this - > parse Filter Id ( $ filter ) , $ options ) ; return $ value ; } 
protected function parse Filter Id ( $ filter ) : int { $ filter = $ this - > is Int ( $ filter ) ? $ filter : filter _id ( $ filter ) ; return $ filter ; } 
protected function get Part Data ( string $ key , $ value , $ defaults = null ) { if ( ! is _array ( $ value ) ) { return $ value ; } $ parts = explode ( ' . ' , $ key ) ; foreach ( $ parts as $ item ) { if ( ! is _array ( $ value ) | | ! isset ( $ value [ $ item ] ) ) { return $ defaults ; } $ value = $ value [ $ item ] ; } return $ value ; } 
public function get ( string $ name , $ defaults = false , array $ option = [ ] ) { $ option = $ this - > normalize Options ( $ option ) ; $ cache Path = $ this - > get Cache Path ( $ name ) ; 
public function set ( string $ name , $ data , array $ option = [ ] ) : void { $ option = $ this - > normalize Options ( $ option ) ; if ( $ option [ 'serialize ' ] ) { $ data = serialize ( $ data ) ; } $ data = sprintf ( static : : HEADER , ' / * ' . date ( 'Y -m -d H :i :s ' ) . ' * / ' ) . $ data ; $ cache Path = $ this - > get Cache Path ( $ name ) ; $ this - > write Data ( $ cache Path , $ data ) ; } 
public function delete ( string $ name ) : void { $ cache Path = $ this - > get Cache Path ( $ name ) ; if ( $ this - > exist ( $ name ) ) { unlink ( $ cache Path ) ; } } 
protected function is Expired ( string $ name , array $ option ) : bool { $ file Path = $ this - > get Cache Path ( $ name ) ; $ option [ 'expire ' ] = $ this - > cache Time ( $ name , ( int ) $ option [ 'expire ' ] ) ; if ( $ option [ 'expire ' ] < = 0 ) { return true ; } return filemtime ( $ file Path ) + ( int ) $ option [ 'expire ' ] < time ( ) ; } 
protected function get Cache Path ( string $ name ) : string { if ( ! $ this - > option [ 'path ' ] ) { throw new Invalid Argument Exception ( 'Cache path is not allowed empty . ' ) ; } return $ this - > option [ 'path ' ] . ' / ' . $ this - > get Cache Name ( $ name ) . ' .php ' ; } 
protected function write Data ( string $ file Name , string $ data ) : void { create _file ( $ file Name ) ; file _put _contents ( $ file Name , $ data , LOCK _EX ) ; } 
public function handle ( IApp $ app ) : void { $ this - > check Runtime Env ( $ app ) ; if ( $ app - > is Cached Option ( ) ) { $ data = ( array ) include $ app - > option Cached Path ( ) ; $ this - > set Envs ( $ data [ 'app ' ] [ ' _env ' ] ) ; } else { $ load = new Load ( $ app - > option Path ( ) ) ; $ data = $ load - > load Data ( $ app ) ; } $ app - > instance ( 'option ' , $ option = new Option ( $ data ) ) ; $ test = 2 = = = func _num _args ( ) ; if ( ! $ test ) { 
protected function check Runtime Env ( IApp $ app ) : void { if ( ! getenv ( 'RUNTIME _ENVIRONMENT ' ) ) { return ; } $ file = ' . ' . getenv ( 'RUNTIME _ENVIRONMENT ' ) ; 
protected function set Envs ( array $ env ) : void { foreach ( $ env as $ name = > $ value ) { $ this - > set Env Var ( $ name , $ value ) ; } } 
protected function set Env Var ( string $ name , $ value = null ) : void { if ( is _bool ( $ value ) ) { putenv ( $ name . ' = ' . ( $ value ? ' (true ) ' : ' (false ) ' ) ) ; } elseif ( null = = = $ value ) { putenv ( $ name . ' (null ) ' ) ; } else { putenv ( $ name . ' = ' . $ value ) ; } $ _ENV [ $ name ] = $ value ; $ _SERVER [ $ name ] = $ value ; } 
protected function initialization ( Option $ option ) : void { mb _internal _encoding ( 'UTF - 8 ' ) ; if ( function _exists ( 'date _default _timezone _set ' ) ) { date _default _timezone _set ( $ option - > get ( 'time _zone ' , 'UTC ' ) ) ; } if ( \ PHP _SAPI = = = 'cli ' ) { return ; } if ( function _exists ( 'gz _handler ' ) & & $ option - > get ( 'start _gzip ' ) ) { ob _start ( 'gz _handler ' ) ; } else { ob _start ( ) ; } } 
public function handle ( string $ class Name ) : string { $ this - > lines = $ this - > parse File Contnet ( $ reflection = new Reflection Class ( $ class Name ) ) ; if ( ! ( $ markdown = $ this - > parse Class Content ( $ reflection ) ) ) { return ' ' ; } $ markdown . = $ this - > parse Method Contents ( $ reflection ) ; return $ markdown ; } 
public function handle And Save ( string $ class Name , ? string $ path = null ) : bool { $ this - > set Save Path ( $ path ) ; $ markdown = trim ( $ this - > handle ( $ class Name ) ) ; if ( ! $ markdown | | ! $ this - > save Path ) { return false ; } $ this - > write Cache ( $ this - > save Path , $ markdown ) ; return true ; } 
public static function get Method Body ( string $ class Name , string $ method , bool $ is Doc = false ) : string { $ doc = new static ( ' ' ) ; $ lines = $ doc - > parse File Contnet ( new Reflection Class ( $ class Name ) ) ; $ method = new Reflection Method ( $ class Name , $ method ) ; return $ doc - > parse Method Body ( $ lines , $ method , $ is Doc ) ; } 
public static function get Class Body ( string $ class Name ) : string { $ doc = new static ( ' ' ) ; $ lines = $ doc - > parse File Contnet ( $ reflection Class = new Reflection Class ( $ class Name ) ) ; $ start Line = $ reflection Class - > get Start Line ( ) - 1 ; $ end Line = $ reflection Class - > get End Line ( ) ; $ has Use = false ; $ result = [ ] ; $ result [ ] = 'namespace ' . $ reflection Class - > get Namespace Name ( ) . ' ; ' ; $ result [ ] = ' ' ; foreach ( $ lines as $ k = > $ v ) { if ( $ k < $ start Line | | $ k > = $ end Line ) { 
protected function set Save Path ( ? string $ path = null ) : void { if ( null = = = $ path ) { $ this - > save Path = null ; } else { $ this - > save Path = $ this - > base Path . ' / ' . $ path . ' .md ' ; } } 
protected function is Method Need Parsed ( Reflection Method $ method ) : bool { $ name = $ method - > get Name ( ) ; return 0 = = = strpos ( $ name , 'test ' ) | | 0 = = = strpos ( $ name , 'doc ' ) ; } 
protected function parse Class Content ( Reflection Class $ reflection ) : string { if ( ! ( $ comment = $ reflection - > get Doc Comment ( ) ) | | ! ( $ info = $ this - > parse Comment ( $ comment ) ) ) { return ' ' ; } $ data = [ ] ; $ data [ ] = $ this - > format Title ( $ info [ 'title ' ] ? ? ' ' , true ) ; $ data [ ] = $ this - > format Description ( $ info [ 'description ' ] ? ? ' ' ) ; $ data [ ] = $ this - > format Users ( $ reflection ) ; 
protected function parse Method Contents ( Reflection Class $ reflection ) : string { $ markdown = ' ' ; foreach ( $ reflection - > get Methods ( ) as $ method ) { if ( ! $ this - > is Method Need Parsed ( $ method ) ) { continue ; } $ markdown . = $ this - > parse Method Content ( $ method ) ; } return $ markdown ; } 
protected function parse Method Content ( Reflection Method $ method ) : string { if ( ! ( $ comment = $ method - > get Doc Comment ( ) ) | | ! ( $ info = $ this - > parse Comment ( $ comment ) ) ) { return ' ' ; } $ data = [ ] ; $ data [ ] = $ this - > format Title ( $ info [ 'title ' ] ? ? ' ' ) ; $ data [ ] = $ this - > format Description ( $ info [ 'description ' ] ? ? ' ' ) ; $ data [ ] = $ this - > format Body ( $ method , $ info [ 'lang ' ] ? ? 'php ' ) ; $ data [ ] = $ this - > format Note ( $ info [ 'note ' ] ? ? ' ' ) ; return implode ( PHP _EOL , $ data ) . PHP _EOL ; } 
protected function format Title ( string $ title , bool $ is Header = false ) : string { if ( $ title ) { $ title = ( $ is Header ? ' # ' : ' # # ' ) . " { $title } " . PHP _EOL ; } return $ title ; } 
protected function format Users ( Reflection Class $ reflection ) : string { $ uses = $ this - > parse Use Defined ( $ this - > lines , $ reflection ) ; if ( $ uses ) { $ uses = < < <eot * * 引 入 相 关 类 * * { $uses } eot ; } return $ uses ; } 
protected function format Body ( Reflection Method $ method , string $ lang ) : string { $ body = $ this - > parse Method Body ( $ this - > lines , $ method , 0 = = = strpos ( $ method - > get Name ( ) , 'doc ' ) ) ; if ( $ body ) { $ body = < < <eot ` ` ` { $lang } { $body } ` ` ` eot ; } return $ body ; } 
protected function parse Use Defined ( array $ lines , Reflection Class $ class Ref ) : string { $ start Line = $ class Ref - > get Start Line ( ) - 1 ; $ result = [ ] ; foreach ( $ lines as $ k = > $ v ) { $ v = trim ( $ v ) ; if ( $ k > = $ start Line ) { break ; } if ( 0 = = = strpos ( $ v , 'use ' ) & & ! in _array ( $ v , [ 'use Tests \Test Case ; ' ] , true ) & & false = = = strpos ( $ v , ' \ \Fixtures \ \ ' ) ) { $ result [ ] = ' * ' . $ v ; } } return implode ( PHP _EOL , $ result ) ; } 
protected function parse Method Body ( array $ lines , Reflection Method $ method , bool $ is Doc = false ) : string { $ start Line = $ method - > get Start Line ( ) - 1 ; $ end Line = $ method - > get End Line ( ) ; $ offset Length = 4 ; $ find Eot = false ; $ result = [ ] ; 
protected function parse Comment ( string $ comment ) : array { $ comments = explode ( PHP _EOL , $ comment ) ; $ find Api = false ; $ result = [ ] ; $ code = [ ' $result = [ ' ] ; foreach ( $ comments as $ v ) { $ v = trim ( $ v , ' * ' ) ; $ v = trim ( $ v , ' _ ' ) ; 
public static function make ( array $ datas = [ ] , array $ rules = [ ] , array $ names = [ ] , array $ messages = [ ] ) : IValidator { return new static ( $ datas , $ rules , $ names , $ messages ) ; } 
public function success ( ) : bool { $ skip Rule = $ this - > get Skip Rule ( ) ; $ this - > failed Rules = $ this - > error Messages = [ ] ; foreach ( $ this - > rules as $ field = > $ rules ) { foreach ( $ rules as $ rule ) { if ( in _array ( $ rule , $ skip Rule , true ) ) { continue ; } if ( false = = = $ this - > do Validate Item ( $ field , $ rule ) ) { 
public function data ( array $ datas ) : IValidator { if ( $ this - > check Flow Control ( ) ) { return $ this ; } $ this - > datas = $ datas ; return $ this ; } 
public function add Data ( array $ datas ) : IValidator { if ( $ this - > check Flow Control ( ) ) { return $ this ; } $ this - > datas = array _merge ( $ this - > datas , $ datas ) ; return $ this ; } 
public function rule ( array $ rules , Closure $ callbacks = null ) : IValidator { if ( $ this - > check Flow Control ( ) ) { return $ this ; } if ( null = = = $ callbacks | | $ this - > is Callback Valid ( $ callbacks ) ) { $ this - > rules = $ this - > array Rule ( $ rules ) ; } return $ this ; } 
public function add Rule ( array $ rules , Closure $ callbacks = null ) : IValidator { if ( $ this - > check Flow Control ( ) ) { return $ this ; } if ( null = = = $ callbacks | | $ this - > is Callback Valid ( $ callbacks ) ) { $ this - > rules = array _merge ( $ this - > rules , $ this - > array Rule ( $ rules ) ) ; } return $ this ; } 
public function message ( array $ messages ) : IValidator { if ( $ this - > check Flow Control ( ) ) { return $ this ; } $ this - > messages = $ this - > array Message ( $ messages ) ; return $ this ; } 
public function add Message ( array $ messages ) : IValidator { if ( $ this - > check Flow Control ( ) ) { return $ this ; } $ this - > messages = array _merge ( $ this - > messages , $ this - > array Message ( $ messages ) ) ; return $ this ; } 
public function name ( array $ names ) : IValidator { if ( $ this - > check Flow Control ( ) ) { return $ this ; } $ this - > names = $ names ; return $ this ; } 
public function add Name ( array $ names ) : IValidator { if ( $ this - > check Flow Control ( ) ) { return $ this ; } $ this - > names = array _merge ( $ this - > names , $ names ) ; return $ this ; } 
public function alias ( string $ name , string $ alias ) : IValidator { if ( in _array ( $ name , $ this - > get Skip Rule ( ) , true ) ) { $ e = sprintf ( 'You cannot set alias for skip rule %s . ' , $ name ) ; throw new Invalid Argument Exception ( $ e ) ; } $ this - > alias [ $ alias ] = $ name ; return $ this ; } 
public function alias Many ( array $ alias ) : IValidator { foreach ( $ alias as $ alias = > $ value ) { $ this - > alias ( $ alias , $ value ) ; } return $ this ; } 
public function after ( Closure $ callbacks ) : IValidator { $ this - > afters [ ] = function ( ) use ( $ callbacks ) { return $ callbacks ( $ this ) ; } ; return $ this ; } 
public function get Parse Rule ( string $ field , $ rules ) : array { $ rules = ( array ) $ rules ; foreach ( $ this - > rules [ $ field ] as $ rule ) { list ( $ rule , $ parameter ) = $ this - > parse Rule ( $ rule ) ; if ( in _array ( $ rule , $ rules , true ) ) { return [ $ rule , $ parameter ] ; } } return [ ] ; } 
public function get Field Value ( string $ rule ) { if ( false = = = strpos ( $ rule , ' . ' ) ) { if ( isset ( $ this - > datas [ $ rule ] ) ) { return $ this - > datas [ $ rule ] ; } } else { $ parts = explode ( ' . ' , $ rule ) ; $ datas = $ this - > datas ; foreach ( $ parts as $ part ) { if ( ! isset ( $ datas [ $ part ] ) ) { return ; } $ datas = $ datas [ $ part ] ; } return $ datas ; } } 
protected function array Message ( array $ messages ) : array { $ result = [ ] ; foreach ( $ messages as $ field = > $ message ) { 
protected function wildcard Message Item ( string $ field , $ message ) : array { $ field = $ this - > prepare Regex For Wildcard ( $ field ) ; $ messages = [ ] ; foreach ( $ this - > parse Data Key ( ) as $ key ) { if ( preg _match ( $ field , $ key , $ matche ) ) { $ messages = array _merge ( $ messages , $ this - > array Message Item ( $ key , $ message ) ) ; } } return $ messages ; } 
protected function prepare Regex For Wildcard ( string $ regex , bool $ strict = true ) : string { $ regex = preg _quote ( $ regex , ' / ' ) ; $ regex = ' / ^ ' . str _replace ( ' \ * ' , ' ( \S + ) ' , $ regex ) . ( $ strict ? ' $ ' : ' ' ) . ' / ' ; return $ regex ; } 
protected function array Message Item ( string $ field , $ message ) : array { $ result = [ ] ; if ( is _array ( $ message ) ) { foreach ( $ message as $ key = > $ message ) { $ result [ $ field . ' . ' . $ key ] = $ message ; } } else { foreach ( $ this - > get Field Rule Without Skip ( $ field ) as $ rule ) { $ result [ $ field . ' . ' . $ rule ] = $ message ; } } return $ result ; } 
protected function get Field Rule ( string $ field ) : array { if ( isset ( $ this - > rules [ $ field ] ) ) { return $ this - > rules [ $ field ] ; } return [ ] ; } 
protected function parse Rule ( string $ rule ) : array { $ parameter = [ ] ; if ( false ! = = strpos ( $ rule , ' : ' ) ) { list ( $ rule , $ parameter ) = explode ( ' : ' , $ rule , 2 ) ; if ( isset ( $ this - > alias [ $ rule ] ) ) { $ rule = $ this - > alias [ $ rule ] ; } $ parameter = $ this - > parse Parameters ( $ rule , $ parameter ) ; } return [ trim ( $ rule ) , $ parameter ] ; } 
protected function array Rule ( array $ rules ) : array { $ result = [ ] ; foreach ( $ rules as $ field = > $ rules ) { if ( false = = = strpos ( $ field , ' * ' ) ) { $ result [ $ field ] = $ this - > array Rule Item ( $ rules ) ; } else { $ result = array _merge ( $ result , $ this - > wildcard Rule Item ( $ field , $ rules ) ) ; } } return $ result ; } 
protected function wildcard Rule Item ( string $ field , $ rules ) : array { $ field = $ this - > prepare Regex For Wildcard ( $ field ) ; $ result = [ ] ; foreach ( $ this - > parse Data Key ( ) as $ key ) { if ( preg _match ( $ field , $ key , $ matche ) ) { $ result [ $ key ] = $ this - > array Rule Item ( $ rules ) ; } } return $ result ; } 
protected function parse Data Key Recursion ( array $ datas , string $ parent Key = ' ' ) : array { $ data Keys = [ ] ; foreach ( $ datas as $ key = > $ datas ) { $ first = ( $ parent Key ? $ parent Key . ' . ' : ' ' ) . $ key ; if ( is _array ( $ datas ) ) { $ data Keys = array _merge ( $ data Keys , $ this - > parse Data Key Recursion ( $ datas , $ first ) ) ; } else { $ data Keys [ ] = $ first ; } } return $ data Keys ; } 
protected function has Field Rule Without Parameter ( string $ field , string $ rule ) { $ result = $ this - > has Field Rule Without Parameter Real ( $ field , $ rule ) ; if ( ! $ result & & $ rule = = = static : : DEFAULT _CONDITION ) { return ! $ this - > has Field Rule Without Parameter Real ( $ field , [ static : : CONDITION _MUST , static : : CONDITION _VALUE , ] ) ; } return $ result ; } 
protected function has Field Rule Without Parameter Real ( string $ field , $ rules ) : bool { if ( ! isset ( $ this - > rules [ $ field ] ) ) { return false ; } $ rules = ( array ) $ rules ; foreach ( $ rules as $ rule ) { if ( in _array ( $ rule , $ this - > rules [ $ field ] , true ) ) { return true ; } } return false ; } 
protected function parse Parameters ( string $ rule , string $ parameter ) : array { if ( 'regex ' = = = strtolower ( $ rule ) ) { return [ $ parameter ] ; } return explode ( ' , ' , $ parameter ) ; } 
protected function do Validate Item ( string $ field , string $ rule ) { list ( $ rule , $ parameter ) = $ this - > parse Rule ( $ rule ) ; if ( ' ' = = = $ rule ) { return ; } $ field Value = $ this - > get Field Value ( $ field ) ; 
protected function add Failure ( string $ field , string $ rule , array $ parameter ) : void { $ this - > add Error ( $ field , $ rule , $ parameter ) ; $ this - > failed Rules [ $ field ] [ $ rule ] = $ parameter ; } 
protected function add Error ( string $ field , string $ rule , array $ parameter ) : void { $ message = $ this - > get Field Rule Message ( $ field , $ rule ) ; $ replace = [ 'field ' = > $ this - > parse Field Name ( $ field ) , ] ; if ( ! $ this - > is Implode Rule Parameter ( $ rule ) ) { foreach ( $ parameter as $ key = > $ parameter ) { $ replace [ 'rule ' . ( $ key ? : ' ' ) ] = $ parameter ; } } else { $ replace [ 'rule ' ] = implode ( ' , ' , $ parameter ) ; } $ message = preg _replace _callback ( ' / { ( . + ? ) } / ' , function ( $ matche ) use ( $ replace ) { return $ replace [ $ matche [ 1 ] ] ? ? $ matche [ 0 ] ; } , $ message ) ; $ this - > error Messages [ $ field ] [ ] = $ message ; unset ( $ replace , $ message ) ; } 
protected function get Field Rule Message ( string $ field , string $ rule ) : string { return $ this - > messages [ $ field . ' . ' . $ rule ] ? ? $ this - > messages [ $ rule ] ? ? static : : $ default Messages [ $ rule ] ? ? ' ' ; } 
protected function call Class Extend ( string $ extend , array $ parameter ) : bool { if ( ! $ this - > container ) { throw new Invalid Argument Exception ( 'Container was not set . ' ) ; } if ( false = = = strpos ( $ extend , ' @ ' ) ) { $ class Name = $ extend ; $ method = 'handle ' ; } else { list ( $ class Name , $ method ) = explode ( ' @ ' , $ extend ) ; } if ( ! is _object ( $ extend = $ this - > container - > make ( $ class Name ) ) ) { $ e = sprintf ( 'Extend class %s is not valid . ' , $ class Name ) ; throw new Invalid Argument Exception ( $ e ) ; } $ parameter [ ] = $ this ; return $ extend - > { $ method } ( . . . $ parameter ) ; } 
protected function call Extend ( string $ rule , array $ parameter ) : bool { $ extends = $ this - > extends [ $ rule ] ; if ( is _callable ( $ extends ) ) { $ parameter [ ] = $ this ; return $ extends ( . . . $ parameter ) ; } if ( is _string ( $ extends ) ) { return $ this - > call Class Extend ( $ extends , $ parameter ) ; } $ e = sprintf ( 'Extend in rule %s is not valid . ' , $ rule ) ; throw new Invalid Argument Exception ( $ e ) ; } 
public function on Receive ( Swoole Server $ server , int $ fd , int $ reactor Id , string $ data ) : void { parent : : on Receive ( $ server , $ fd , $ reactor Id , $ data ) ; $ this - > thrift Server - > receive ( $ server , $ fd , $ reactor Id , $ data ) ; } 
protected function make Thrift Server ( ) : Thrift Server { $ service = new Thrift Handler ( ) ; $ processor = new Thrift Processor ( $ service ) ; $ socket Tranport = new TServer Socket ( $ this - > option [ 'host ' ] , ( int ) ( $ this - > option [ 'port ' ] ) ) ; $ out Factory = $ in Factory = new TFramed Transport Factory ( ) ; $ out Protocol = $ in Protocol = new TBinary Protocol Factory ( ) ; $ server = new Thrift Server ( $ processor , $ socket Tranport , $ in Factory , $ out Factory , $ in Protocol , $ out Protocol ) ; return $ server ; } 
public function gettext ( string $ text , . . . $ arr ) : string { $ value = $ this - > text [ $ this - > i 1 8n ] [ $ text ] ? ? $ text ; if ( $ arr ) { return sprintf ( $ value , . . . $ arr ) ; } return $ value ; } 
public function addtext ( string $ i 1 8n , array $ data = [ ] ) : void { if ( array _key _exists ( $ i 1 8n , $ this - > text ) ) { $ this - > text [ $ i 1 8n ] = array _merge ( $ this - > text [ $ i 1 8n ] , $ data ) ; } else { $ this - > text [ $ i 1 8n ] = $ data ; } } 
public function set Var ( $ name , $ value = null ) : void { if ( is _array ( $ name ) ) { $ this - > vars = array _merge ( $ this - > vars , $ name ) ; } else { $ this - > vars [ $ name ] = $ value ; } } 
public function delete Var ( array $ name ) : void { foreach ( $ name as $ item ) { if ( isset ( $ this - > vars [ $ item ] ) ) { unset ( $ this - > vars [ $ item ] ) ; } } } 
protected function parse Display File ( ? string $ file = null , ? string $ ext = ' ' ) : string { if ( ! is _file ( $ file ) ) { $ file = $ this - > parse File ( $ file , $ ext ) ; } if ( ! is _file ( $ file ) ) { throw new Runtime Exception ( sprintf ( 'Template file %s does not exist . ' , $ file ) ) ; } return $ file ; } 
protected function parse File ( ? string $ tpl = null , ? string $ ext = ' ' ) : string { $ tpl = trim ( str _replace ( ' - > ' , ' . ' , $ tpl ) ) ; 
public function set Cookie ( string $ name , string $ value = ' ' , array $ option = [ ] ) : void { $ this - > cookie - > set ( $ name , $ value , $ option ) ; } 
public function with Cookies ( array $ cookies , array $ option = [ ] ) : void { foreach ( $ cookies as $ key = > $ value ) { $ this - > set Cookie ( $ key , $ value , $ option ) ; } } 
public function set Node ( $ id , $ parent , $ value , bool $ priority = false ) : void { $ this - > data [ $ id ] = $ value ; if ( $ priority ) { $ tmp = [ $ id = > $ parent , ] ; foreach ( $ this - > map as $ key = > $ value ) { $ tmp [ $ key ] = $ value ; } $ this - > map = $ tmp ; unset ( $ tmp ) ; } else { $ this - > map [ $ id ] = $ parent ; } } 
public function get Child ( $ id ) : array { $ data = [ ] ; foreach ( $ this - > map as $ key = > $ parent ) { if ( ( string ) $ parent = = = ( string ) $ id ) { $ data [ $ key ] = $ key ; } } return $ data ; } 
public function get Children ( $ id = 0 ) : array { $ data = [ ] ; foreach ( $ this - > get Child ( $ id ) as $ key ) { $ data [ ] = $ key ; $ data = array _merge ( $ data , $ this - > get Children ( $ key ) ) ; } return $ data ; } 
public function has Children ( $ id , array $ validate Children , bool $ strict = true ) : bool { if ( empty ( $ validate Children ) ) { return false ; } $ children = $ this - > get Children ( $ id ) ; if ( true = = = $ strict & & array _diff ( $ validate Children , $ children ) ) { return false ; } if ( false = = = $ strict & & array _intersect ( $ validate Children , $ children ) ) { return true ; } return false ; } 
public function get Parent ( $ id , bool $ with It Self = false ) : array { if ( ! array _key _exists ( $ id , $ this - > map ) ) { return [ ] ; } $ data = [ ] ; if ( array _key _exists ( $ this - > map [ $ id ] , $ this - > map ) ) { $ data [ ] = $ this - > map [ $ id ] ; } if ( true = = = $ with It Self ) { $ data [ ] = $ id ; } return $ data ; } 
public function get Parents ( $ id , bool $ with It Self = false ) : array { $ data = $ this - > get Parents Real ( $ id ) ; sort ( $ data ) ; if ( true = = = $ with It Self ) { $ data [ ] = $ id ; } return $ data ; } 
public function set Data ( $ id , $ value ) : void { if ( isset ( $ this - > data [ $ id ] ) ) { $ this - > data [ $ id ] = $ value ; } } 
public function normalize ( Closure $ callables = null , array $ key = [ ] , $ id = 0 ) : array { $ data = [ ] ; foreach ( $ this - > get Child ( $ id ) as $ value ) { $ item = [ $ key [ 'value ' ] ? ? 'value ' = > $ value , $ key [ 'data ' ] ? ? 'data ' = > $ this - > data [ $ value ] , ] ; if ( $ callables ) { $ result = $ callables ( $ item , $ this ) ; if ( null ! = = $ result ) { $ item = $ result ; } } if ( $ children = $ this - > normalize ( $ callables , $ key , $ value ) ) { $ item [ $ key [ 'children ' ] ? ? 'children ' ] = $ children ; } $ data [ ] = $ item ; } return $ data ; } 
public function to Json ( $ option = null ) : string { if ( null = = = $ option ) { $ option = JSON _UNESCAPED _UNICODE ; } $ args = func _get _args ( ) ; array _shift ( $ args ) ; return json _encode ( $ this - > to Array ( . . . $ args ) , $ option ) ; } 
protected function get Parents Real ( $ id ) : array { if ( ! array _key _exists ( $ id , $ this - > map ) ) { return [ ] ; } $ data = [ ] ; if ( array _key _exists ( $ this - > map [ $ id ] , $ this - > map ) ) { $ data [ ] = $ this - > map [ $ id ] ; $ data = array _merge ( $ data , $ this - > get Parents Real ( $ this - > map [ $ id ] ) ) ; } return $ data ; } 
protected function cache Time ( string $ id , int $ default Time = 0 ) : int { if ( ! $ this - > option [ 'time _preset ' ] ) { return $ default Time ; } if ( isset ( $ this - > option [ 'time _preset ' ] [ $ id ] ) ) { return $ this - > option [ 'time _preset ' ] [ $ id ] ; } foreach ( $ this - > option [ 'time _preset ' ] as $ key = > $ value ) { if ( preg _match ( $ this - > prepare Regex For Wildcard ( $ key ) , $ id , $ res ) ) { return $ this - > option [ 'time _preset ' ] [ $ key ] ; } } return $ default Time ; } 
public function handle ( IApp $ app ) : void { if ( file _exists ( $ link = $ app - > path ( 'www /public ' ) ) ) { $ this - > error ( sprintf ( 'The ` %s ` directory already exists . ' , $ link ) ) ; return ; } link ( $ path = $ app - > public Path ( ) , $ link ) ; $ this - > info ( sprintf ( 'Linked ` %s ` directory to ` %s ` successed . ' , $ path , $ link ) ) ; } 
public function connect ( $ options = null ) : object { list ( $ options , $ unique ) = $ this - > parse Option And Unique ( $ options ) ; if ( isset ( $ this - > connects [ $ unique ] ) ) { return $ this - > connects [ $ unique ] ; } $ driver = $ options [ 'driver ' ] ? ? $ this - > get Default Driver ( ) ; return $ this - > connects [ $ unique ] = $ this - > make Connect ( $ driver , $ options ) ; } 
public function disconnect ( $ options = [ ] ) : void { list ( $ options , $ unique ) = $ this - > parse Option And Unique ( $ options ) ; if ( isset ( $ this - > connects [ $ unique ] ) ) { unset ( $ this - > connects [ $ unique ] ) ; } } 
public function get Container Option ( ? string $ name = null ) { $ name = $ this - > normalize Option Name ( $ name ) ; return $ this - > container [ 'option ' ] [ $ name ] ; } 
public function set Container Option ( string $ name , $ value ) : void { $ name = $ this - > normalize Option Name ( $ name ) ; $ this - > container [ 'option ' ] [ $ name ] = $ value ; } 
protected function make Connect ( string $ connect , array $ options = [ ] ) : object { if ( null = = = $ this - > get Container Option ( 'connect . ' . $ connect ) ) { $ e = sprintf ( 'Connect driver %s not exits . ' , $ connect ) ; throw new Exception ( $ e ) ; } return $ this - > create Connect ( $ this - > create Connect Common ( $ connect , $ options ) ) ; } 
protected function parse Option Parameter ( $ options = [ ] ) : array { if ( null = = = $ options ) { return [ ] ; } if ( is _string ( $ options ) ) { $ options = $ this - > get Container Option ( 'connect . ' . $ options ) ; if ( ! is _array ( $ options ) ) { return [ ] ; } } return $ options ; } 
protected function normalize Connect Option ( string $ connect , array $ extend Option = [ ] ) : array { return array _merge ( $ this - > get Connect Option ( $ connect ) , $ this - > get Common Option ( ) , $ extend Option ) ; } 
protected function filter Common Option ( array $ options ) : array { foreach ( $ this - > default Common Option ( ) as $ item ) { if ( isset ( $ options [ $ item ] ) ) { unset ( $ options [ $ item ] ) ; } } return $ options ; } 
public function load Data ( IApp $ app ) : array { if ( $ this - > loaded ) { return $ this - > loaded ; } $ env = $ this - > load Env Data ( $ app ) ; $ composer = $ this - > load Composer Option ( $ app - > path ( ) ) ; $ data = $ this - > load Option Data ( ) ; 
protected function load Env Data ( IApp $ app ) : array { $ old Env = $ _ENV ; $ _ENV = [ ] ; try { ( new Dotenv ( $ app - > env Path ( ) , $ app - > env File ( ) ) ) - > overload ( ) ; } catch ( Invalid Path Exception $ e ) { throw new Runtime Exception ( $ e - > get Message ( ) ) ; } catch ( Invalid File Exception $ e ) { throw new Runtime Exception ( $ e - > get Message ( ) ) ; } $ result = $ _ENV ; $ _ENV = array _merge ( $ old Env , $ _ENV ) ; return $ result ; } 
protected function load Deferred Provider Data ( array & $ providers ) : array { $ deferred Providers = $ deferred Alias = [ ] ; foreach ( $ providers as $ k = > $ provider ) { if ( ! class _exists ( $ provider ) ) { unset ( $ providers [ $ k ] ) ; continue ; } if ( $ provider : : is Deferred ( ) ) { $ provider Alias = $ provider : : providers ( ) ; foreach ( $ provider Alias as $ key = > $ alias ) { if ( is _int ( $ key ) ) { $ key = $ alias ; } $ deferred Providers [ $ key ] = $ provider ; } $ deferred Alias [ $ provider ] = $ provider Alias ; unset ( $ providers [ $ k ] ) ; } } $ providers = array _values ( $ providers ) ; return [ $ deferred Providers , $ deferred Alias , ] ; } 
protected function load Option Data ( ) : array { $ data = [ ] ; $ files = glob ( $ this - > dir . ' / * .php ' ) ; $ find App = false ; foreach ( $ files as $ file ) { $ type = substr ( basename ( $ file ) , 0 , - 4 ) ; if ( 'app ' = = = $ type ) { $ find App = true ; } $ data [ $ type ] = ( array ) include $ file ; } if ( false = = = $ find App ) { throw new Runtime Exception ( 'Unable to load the app option file . ' ) ; } return $ data ; } 
protected function merge Composer Option ( array $ options , IApp $ app , array $ option Files ) : array { $ data = [ ] ; $ path = $ app - > path ( ) ; foreach ( $ option Files as $ key = > $ files ) { if ( ! is _array ( $ files ) ) { $ files = [ $ files ] ; } $ option Data = [ ] ; foreach ( $ files as $ item ) { if ( ! is _file ( $ item ) ) { $ item = $ path . ' / ' . $ item ; } if ( ! is _file ( $ item ) ) { $ e = sprintf ( 'Option file %s is not exist . ' , $ item ) ; throw new Runtime Exception ( $ e ) ; } $ option Data = array _merge ( $ option Data , include $ item ) ; } if ( array _key _exists ( $ key , $ options ) ) { $ options [ $ key ] = array _merge ( $ options [ $ key ] , $ option Data ) ; } else { $ options [ $ key ] = $ option Data ; } } return $ options ; } 
public function handle ( IApp $ app ) : void { ini _set ( 'display _errors ' , 'stderr ' ) ; $ kernel = $ app - > make ( IKernel : : class ) ; list ( $ psr 7 , $ psr 2Leevel , $ leevel 2Psr ) = $ this - > get Psr Bridge ( ) ; while ( $ req = $ psr 7 - > accept Request ( ) ) { try { $ request = $ psr 2Leevel - > create Request ( $ req ) ; $ response = $ kernel - > handle ( $ request ) ; $ psr 7 - > respond ( $ leevel 2Psr - > create Response ( $ response ) ) ; $ kernel - > terminate ( $ request , $ response ) ; } catch ( Throwable $ e ) { $ psr 7 - > get Worker ( ) - > error ( ( string ) $ e ) ; } } } 
public function handle ( IApp $ app ) : void { $ this - > line ( 'Start to clear cache autoload . ' ) ; $ cache Path = $ app - > runtime Path ( 'autoload .php ' ) ; $ this - > clear Cache ( $ cache Path ) ; $ this - > info ( sprintf ( 'Autoload file %s cache clear successed . ' , $ cache Path ) ) ; } 
protected function clear Cache ( string $ cache Path ) : void { if ( ! is _file ( $ cache Path ) ) { $ this - > warn ( 'Autoload cache files have been cleaned up . ' ) ; return ; } unlink ( $ cache Path ) ; } 
public function handle ( string $ path To File ) : string { 
public function call ( $ command , array $ arguments = [ ] ) : int { $ arguments [ 'command ' ] = $ command ; return $ this - > get Application ( ) - > find ( $ command ) - > run ( new Array Input ( $ arguments ) , $ this - > output ) ; } 
public function confirm ( $ question , $ defaults = false ) : bool { return $ this - > output - > confirm ( $ question , $ defaults ) ; } 
public function ask ( $ question , $ defaults = null ) : string { return $ this - > output - > ask ( $ question , $ defaults ) ; } 
public function table ( array $ headers , array $ rows , $ style = 'default ' ) : void { ( new Table ( $ this - > output ) ) - > set Headers ( $ headers ) - > set Rows ( $ rows ) - > set Style ( $ style ) - > render ( ) ; } 
public function choice ( $ question , array $ choices , $ defaults = null , $ attempts = null , $ multiple = null ) : string { $ question = new Choice Question ( $ question , $ choices , $ defaults ) ; $ question - > set Max Attempts ( $ attempts ) - > set Multiselect ( $ multiple ) ; return $ this - > output - > ask Question ( $ question ) ; } 
public function warn ( $ message , $ verbosity = null ) : void { if ( ! $ this - > output - > get Formatter ( ) - > has Style ( 'warning ' ) ) { $ this - > output - > get Formatter ( ) - > set Style ( 'warning ' , new Output Formatter Style ( 'yellow ' ) ) ; } $ this - > line ( $ message , 'warning ' , $ verbosity ) ; } 
public function line ( $ message , $ style = null , $ verbosity = null ) : void { $ message = $ style ? " < { $style } > { $message } < / { $style } > " : $ message ; $ this - > output - > writeln ( $ message , $ this - > parse Verbosity ( $ verbosity ) ) ; } 
protected function specify Parameters ( ) : void { foreach ( $ this - > get Arguments ( ) as $ argument ) { $ this - > add Argument ( . . . $ argument ) ; } foreach ( $ this - > get Options ( ) as $ option ) { $ this - > add Option ( . . . $ option ) ; } } 
protected function parse Verbosity ( $ level = null ) : int { return static : : $ verbosity Map [ $ level ] ? ? ( ! is _int ( $ level ) ? static : : DEFAULT _VERBOSITY : $ level ) ; } 
public function handle ( array $ middlewares ) : array { $ middleware Groups = $ this - > router - > get Middleware Groups ( ) ; $ middleware Alias = $ this - > router - > get Middleware Alias ( ) ; $ result = [ ] ; foreach ( $ middlewares as $ m ) { if ( ! is _string ( $ m ) ) { throw new Invalid Argument Exception ( 'Middleware only allowed string . ' ) ; } list ( $ m , $ params ) = $ this - > parse Middleware ( $ m ) ; if ( isset ( $ middleware Groups [ $ m ] ) ) { $ temp = is _array ( $ middleware Groups [ $ m ] ) ? $ middleware Groups [ $ m ] : [ $ middleware Groups [ $ m ] ] ; foreach ( $ temp as $ item ) { list ( $ item , $ params ) = $ this - > parse Middleware ( $ item ) ; $ result [ ] = $ this - > middleware Name ( $ middleware Alias [ $ item ] ? ? $ item , $ params ) ; } } else { $ result [ ] = $ this - > middleware Name ( $ middleware Alias [ $ m ] ? ? $ m , $ params ) ; } } $ result = [ 'handle ' = > $ this - > normalize Middleware ( $ result , 'handle ' ) , 'terminate ' = > $ this - > normalize Middleware ( $ result , 'terminate ' ) , ] ; if ( empty ( $ result [ 'handle ' ] ) & & empty ( $ result [ 'terminate ' ] ) ) { return [ ] ; } return $ result ; } 
protected function normalize Middleware ( array $ middlewares , string $ method ) : array { $ middlewares = array _map ( function ( $ item ) use ( $ method ) { if ( false = = = strpos ( $ item , ' : ' ) ) { $ real Class = $ item ; } else { list ( $ real Class ) = explode ( ' : ' , $ item ) ; } 
protected function parse Middleware ( string $ middleware ) : array { $ params = ' ' ; if ( false ! = = strpos ( $ middleware , ' : ' ) ) { list ( $ middleware , $ params ) = explode ( ' : ' , $ middleware ) ; } return [ $ middleware , $ params , ] ; } 
public function with Props ( array $ data ) : IEntity { foreach ( $ data as $ prop = > $ value ) { $ this - > offset Set ( $ prop , $ value ) ; } return $ this ; } 
public function save ( array $ data = [ ] , array $ fill = null ) : IEntity { $ this - > save Entry ( 'save ' , $ data , $ fill ) ; return $ this ; } 
public function create ( array $ data = [ ] , array $ fill = null ) : IEntity { $ this - > save Entry ( 'create ' , $ data , $ fill ) ; return $ this ; } 
public function update ( array $ data = [ ] , array $ fill = null ) : IEntity { $ this - > save Entry ( 'update ' , $ data , $ fill ) ; return $ this ; } 
public function replace ( array $ data = [ ] , array $ fill = null ) : IEntity { $ this - > save Entry ( 'replace ' , $ data , $ fill ) ; return $ this ; } 
public static function destroys ( array $ ids ) : int { $ count = 0 ; $ instance = new static ( ) ; foreach ( $ instance - > where In ( $ instance - > single Primary Key ( ) , $ ids ) - > find All ( ) as $ entity ) { if ( $ entity - > destroy ( ) - > flush ( ) ) { $ count + + ; } } return $ count ; } 
public function destroy ( ) : IEntity { if ( null = = = $ this - > primary Key ( ) ) { $ e = sprintf ( 'Entity %s has no primary key . ' , static : : class ) ; throw new Invalid Argument Exception ( $ e ) ; } $ this - > leevel Flushed = false ; $ this - > leevel Flush = function ( $ condition ) { $ this - > handle Event ( static : : BEFORE _DELETE _EVENT , $ condition ) ; $ num = $ this - > meta Connect ( ) - > delete ( $ condition ) ; $ this - > handle Event ( static : : AFTER _DELETE _EVENT ) ; return $ num ; } ; $ this - > leevel Flush Data = [ $ this - > id Condition ( ) ] ; return $ this ; } 
public function flush ( ) { if ( ! $ this - > leevel Flush | | true = = = $ this - > leevel Flushed ) { return ; } try { $ result = call _user _func _array ( $ this - > leevel Flush , $ this - > leevel Flush Data ) ; } catch ( Replace Exception $ e ) { if ( false = = = $ this - > leevel Replace ) { throw $ e ; } $ this - > leevel Flush = null ; $ this - > leevel Flush Data = null ; $ this - > update Real ( $ this - > leevel Replace ) ; $ this - > leevel Replace = false ; return $ this - > flush ( ) ; } $ this - > leevel Flush = null ; $ this - > leevel Flush Data = null ; $ this - > leevel Flushed = true ; $ this - > handle Event ( static : : AFTER _SAVE _EVENT ) ; return $ result ; } 
public function id ( ) { $ result = [ ] ; foreach ( ( $ keys = $ this - > primary Keys ( ) ) as $ value ) { if ( ! ( $ tmp = $ this - > _ _get ( $ value ) ) ) { continue ; } $ result [ $ value ] = $ tmp ; } if ( ! $ result ) { return ; } 
public function refresh ( ) : void { $ key = $ this - > primary Key ( ) ; if ( null = = = $ key ) { $ e = sprintf ( 'Entity %s do not have primary key . ' , static : : class ) ; throw new Invalid Argument Exception ( $ e ) ; } if ( is _array ( $ key ) ) { $ map = $ this - > id ( ) ; } else { $ map = [ $ this - > single Primary Key ( ) , $ this - > id ( ) ] ; } $ data = $ this - > meta Connect ( ) - > select ( ) - > where ( $ map ) - > find One ( ) ; foreach ( $ data as $ k = > $ v ) { $ this - > with Prop Value ( $ k , $ v , false ) ; } } 
public function load Relation Prop ( string $ prop ) { if ( $ result = $ this - > relation Prop ( $ prop ) ) { return $ result ; } return $ this - > load Data From Relation ( $ prop ) ; } 
public function is Relation ( string $ prop ) : bool { $ prop = $ this - > normalize ( $ prop ) ; $ this - > validate ( $ prop ) ; $ struct = static : : STRUCT [ $ prop ] ; if ( isset ( $ struct [ self : : BELONGS _TO ] ) | | isset ( $ struct [ self : : HAS _MANY ] ) | | isset ( $ struct [ self : : HAS _ONE ] ) | | isset ( $ struct [ self : : MANY _MANY ] ) ) { return true ; } return false ; } 
public function load Relation ( string $ prop ) : Relation { $ prop = $ this - > normalize ( $ prop ) ; $ this - > validate ( $ prop ) ; $ defined = static : : STRUCT [ $ prop ] ; if ( isset ( $ defined [ self : : BELONGS _TO ] ) ) { $ this - > validate Relation Defined ( $ defined , [ 'source _key ' , 'target _key ' ] ) ; $ relation = $ this - > belongs To ( $ defined [ self : : BELONGS _TO ] , $ defined [ 'target _key ' ] , $ defined [ 'source _key ' ] ) ; } elseif ( isset ( $ defined [ self : : HAS _MANY ] ) ) { $ this - > validate Relation Defined ( $ defined , [ 'source _key ' , 'target _key ' ] ) ; $ relation = $ this - > has Many ( $ defined [ self : : HAS _MANY ] , $ defined [ 'target _key ' ] , $ defined [ 'source _key ' ] ) ; } elseif ( isset ( $ defined [ self : : HAS _ONE ] ) ) { $ this - > validate Relation Defined ( $ defined , [ 'source _key ' , 'target _key ' ] ) ; $ relation = $ this - > has One ( $ defined [ self : : HAS _ONE ] , $ defined [ 'target _key ' ] , $ defined [ 'source _key ' ] ) ; } elseif ( isset ( $ defined [ self : : MANY _MANY ] ) ) { $ this - > validate Relation Defined ( $ defined , [ 'middle _entity ' , 'source _key ' , 'target _key ' , 'middle _target _key ' , 'middle _source _key ' , ] ) ; $ relation = $ this - > Many Many ( $ defined [ self : : MANY _MANY ] , $ defined [ 'middle _entity ' ] , $ defined [ 'target _key ' ] , $ defined [ 'source _key ' ] , $ defined [ 'middle _target _key ' ] , $ defined [ 'middle _source _key ' ] ) ; } if ( isset ( $ defined [ self : : SCOPE ] ) ) { call _user _func ( [ $ this , 'scope ' . ucfirst ( $ defined [ self : : SCOPE ] ) ] , $ relation ) ; } return $ relation ; } 
public function with Relation Prop ( string $ prop , $ value ) : void { $ this - > validate ( $ prop ) ; $ this - > prop Setter ( $ prop , $ value ) ; } 
public function has One ( string $ related Entity Class , string $ target Key , string $ source Key ) : Has One { $ entity = new $ related Entity Class ( ) ; $ this - > validate Relation Field ( $ entity , $ target Key ) ; $ this - > validate Relation Field ( $ this , $ source Key ) ; return new Has One ( $ entity , $ this , $ target Key , $ source Key ) ; } 
public function belongs To ( string $ related Entity Class , string $ target Key , string $ source Key ) : Belongs To { $ entity = new $ related Entity Class ( ) ; $ this - > validate Relation Field ( $ entity , $ target Key ) ; $ this - > validate Relation Field ( $ this , $ source Key ) ; return new Belongs To ( $ entity , $ this , $ target Key , $ source Key ) ; } 
public function has Many ( string $ related Entity Class , string $ target Key , string $ source Key ) : Has Many { $ entity = new $ related Entity Class ( ) ; $ this - > validate Relation Field ( $ entity , $ target Key ) ; $ this - > validate Relation Field ( $ this , $ source Key ) ; return new Has Many ( $ entity , $ this , $ target Key , $ source Key ) ; } 
public function many Many ( string $ related Entity Class , string $ middle Entity Class , string $ target Key , string $ source Key , string $ middle Target Key , string $ middle Source Key ) : Many Many { $ entity = new $ related Entity Class ( ) ; $ middle Entity = new $ middle Entity Class ( ) ; $ this - > validate Relation Field ( $ entity , $ target Key ) ; $ this - > validate Relation Field ( $ middle Entity , $ middle Target Key ) ; $ this - > validate Relation Field ( $ this , $ source Key ) ; $ this - > validate Relation Field ( $ middle Entity , $ middle Source Key ) ; return new Many Many ( $ entity , $ this , $ middle Entity , $ target Key , $ source Key , $ middle Target Key , $ middle Source Key ) ; } 
public static function event ( string $ event , $ listener ) : void { if ( null = = = static : : $ leevel Dispatch & & static : : lazyload Placeholder ( ) & & null = = = static : : $ leevel Dispatch ) { return ; } static : : is Support Event ( $ event ) ; static : : $ leevel Dispatch - > register ( "entity . { $event } : " . static : : class , $ listener ) ; } 
public function handle Event ( string $ event , . . . $ args ) : void { if ( null = = = static : : $ leevel Dispatch ) { return ; } $ this - > is Support Event ( $ event ) ; array _unshift ( $ args , $ this ) ; array _unshift ( $ args , "entity . { $event } : " . get _class ( $ this ) ) ; static : : $ leevel Dispatch - > handle ( . . . $ args ) ; } 
public static function is Support Event ( string $ event ) : void { if ( ! in _array ( $ event , static : : support Event ( ) , true ) ) { $ e = sprintf ( 'Event ` %s ` do not support . ' ) ; throw new Invalid Argument Exception ( $ e ) ; } } 
public static function support Event ( ) : array { return [ static : : BEFORE _SELECT _EVENT , static : : AFTER _SELECT _EVENT , static : : BEFORE _FIND _EVENT , static : : AFTER _FIND _EVENT , static : : BEFORE _SAVE _EVENT , static : : AFTER _SAVE _EVENT , static : : BEFORE _CREATE _EVENT , static : : AFTER _CREATE _EVENT , static : : BEFORE _UPDATE _EVENT , static : : AFTER _UPDATE _EVENT , static : : BEFORE _DELETE _EVENT , static : : AFTER _DELETE _EVENT , static : : BEFORE _SOFT _DELETE _EVENT , static : : AFTER _SOFT _DELETE _EVENT , static : : BEFORE _SOFT _RESTORE _EVENT , static : : AFTER _SOFT _RESTORE _EVENT , ] ; } 
public function add Changed ( array $ props ) : IEntity { foreach ( $ props as $ prop ) { if ( ! in _array ( $ prop , $ this - > leevel Changed Prop , true ) ) { continue ; } $ this - > leevel Changed Prop [ ] = $ prop ; } return $ this ; } 
public function delete Changed ( array $ props ) : IEntity { $ this - > leevel Changed Prop = array _values ( array _diff ( $ this - > leevel Changed Prop , $ props ) ) ; return $ this ; } 
public static function single Primary Key ( ) : string { $ key = static : : primary Key ( ) ; if ( ! is _string ( $ key ) ) { $ e = sprintf ( 'Entity %s do not have primary key or composite id not supported . ' , static : : class ) ; throw new Invalid Argument Exception ( $ e ) ; } return $ key ; } 
public static function enum ( string $ prop , $ enum = null , string $ separate = ' , ' ) { $ prop = static : : normalize ( $ prop ) ; $ enum Defined = static : : class . ' : : ' . strtoupper ( $ prop ) . ' _ENUM ' ; if ( ! defined ( $ enum Defined ) ) { return false ; } if ( ! isset ( static : : $ leevel Enums [ static : : class ] ) | | ! isset ( static : : $ leevel Enums [ static : : class ] [ $ prop ] ) ) { $ enums = constant ( $ enum Defined ) ; $ enums = array _values ( $ enums ) ; foreach ( $ enums as & $ e ) { if ( ! isset ( $ e [ 1 ] ) ) { $ e = sprintf ( 'Invalid enum in the field ` %s ` of entity ` %s ` . ' , $ prop , static : : class ) ; throw new Invalid Argument Exception ( $ e ) ; } $ e [ 1 ] = _ _ ( $ e [ 1 ] ) ; } static : : $ leevel Enums [ static : : class ] [ $ prop ] = $ enums ; } else { $ enums = static : : $ leevel Enums [ static : : class ] [ $ prop ] ; } if ( null = = = $ enum ) { return $ enums ; } $ enums = array _column ( $ enums , 1 , 0 ) ; $ enum Sep = explode ( ' , ' , ( string ) $ enum ) ; foreach ( $ enum Sep as $ v ) { if ( ! isset ( $ enums [ $ v ] ) & & ! isset ( $ enums [ ( int ) $ v ] ) ) { $ e = sprintf ( 'Value not a enum in the field ` %s ` of entity ` %s ` . ' , $ prop , static : : class ) ; throw new Invalid Argument Exception ( $ e ) ; } $ result [ ] = isset ( $ enums [ $ v ] ) ? $ enums [ $ v ] : $ enums [ ( int ) $ v ] ; } return implode ( $ separate , $ result ) ; } 
public function to Json ( $ option = null ) : string { if ( null = = = $ option ) { $ option = JSON _UNESCAPED _UNICODE ; } return json _encode ( $ this - > to Array ( ) , $ option ) ; } 
public function id Condition ( ) : array { if ( null = = = ( ( $ ids = $ this - > id ( ) ) ) ) { $ e = sprintf ( 'Entity %s has no primary key data . ' , static : : class ) ; throw new Invalid Argument Exception ( $ e ) ; } if ( ! is _array ( $ ids ) ) { $ ids = [ $ this - > single Primary Key ( ) = > $ ids ] ; } return $ ids ; } 
public function database Select ( ) : Database Select { if ( $ this - > leevel Scope Select ) { return $ this - > leevel Scope Select ; } return $ this - > meta Connect ( ) - > select ( ) - > as Class ( static : : class , [ true ] ) - > as Collection ( ) ; } 
protected function save Entry ( string $ method , array $ data , ? array $ fill = null ) : IEntity { foreach ( $ data as $ k = > $ v ) { $ this - > with Prop Value ( $ k , $ v ) ; } $ this - > handle Event ( static : : BEFORE _SAVE _EVENT ) ; 
protected function create Real ( ? array $ fill = null ) : IEntity { $ this - > leevel Flushed = false ; $ this - > parse Auto Fill ( 'create ' , $ fill ) ; $ prop Key = $ this - > normalize White And Black ( array _flip ( $ this - > leevel Changed Prop ) , 'create _prop ' ) ; $ save Data = [ ] ; foreach ( $ this - > leevel Changed Prop as $ prop ) { if ( ! array _key _exists ( $ prop , $ prop Key ) ) { continue ; } $ save Data [ $ prop ] = $ this - > _ _get ( $ prop ) ; } if ( ! $ save Data ) { if ( null = = = ( ( $ primary Key = $ this - > primary Keys ( ) ) ) ) { $ e = sprintf ( 'Entity %s has no primary key . ' , static : : class ) ; throw new Invalid Argument Exception ( $ e ) ; } foreach ( $ primary Key as $ value ) { $ save Data [ $ value ] = null ; } } $ this - > leevel Flush = function ( $ save Data ) { $ this - > handle Event ( static : : BEFORE _CREATE _EVENT , $ save Data ) ; $ last Insert Id = $ this - > meta Connect ( ) - > insert ( $ save Data ) ; if ( $ auto = $ this - > auto Increment ( ) ) { $ this - > with Prop Value ( $ auto , $ last Insert Id , false , true ) ; } $ this - > leevel Newed = false ; $ this - > clear Changed ( ) ; $ this - > handle Event ( static : : AFTER _CREATE _EVENT , $ save Data ) ; return $ last Insert Id ; } ; $ this - > leevel Flush Data = [ $ save Data ] ; return $ this ; } 
protected function update Real ( ? array $ fill = null ) : IEntity { $ this - > leevel Flushed = false ; $ this - > parse Auto Fill ( 'update ' , $ fill ) ; $ prop Key = $ this - > normalize White And Black ( array _flip ( $ this - > leevel Changed Prop ) , 'update _prop ' ) ; $ save Data = [ ] ; foreach ( $ this - > leevel Changed Prop as $ prop ) { if ( ! array _key _exists ( $ prop , $ prop Key ) ) { continue ; } $ save Data [ $ prop ] = $ this - > _ _get ( $ prop ) ; } if ( ! $ save Data ) { return $ this ; } $ condition = [ ] ; foreach ( $ this - > primary Keys ( ) as $ field ) { if ( isset ( $ save Data [ $ field ] ) ) { unset ( $ save Data [ $ field ] ) ; } if ( $ value = $ this - > _ _get ( $ field ) ) { $ condition [ $ field ] = $ value ; } } if ( empty ( $ condition ) | | empty ( $ save Data ) ) { return $ this ; } $ this - > leevel Flush = function ( $ condition , $ save Data ) { $ this - > handle Event ( static : : BEFORE _UPDATE _EVENT , $ save Data , $ condition ) ; $ num = $ this - > meta Connect ( ) - > update ( $ condition , $ save Data ) ; $ this - > handle Event ( static : : BEFORE _UPDATE _EVENT , null , null ) ; $ this - > clear Changed ( ) ; $ this - > handle Event ( static : : AFTER _UPDATE _EVENT ) ; return $ num ; } ; $ this - > leevel Flush Data = [ $ condition , $ save Data ] ; return $ this ; } 
protected function replace Real ( ? array $ fill = null ) : void { $ this - > leevel Replace = $ fill ; $ this - > create Real ( $ fill ) ; } 
protected function with Prop Value ( string $ prop , $ value , bool $ force = true , bool $ ignore Readonly = false ) : void { $ prop = $ this - > normalize ( $ prop ) ; $ this - > validate ( $ prop ) ; if ( $ this - > is Relation ( $ prop ) ) { $ e = sprintf ( 'Cannot set a relation prop ` %s ` on entity ` %s ` . ' , $ prop , static : : class ) ; throw new Invalid Argument Exception ( $ e ) ; } $ this - > prop Setter ( $ prop , $ value ) ; if ( ! $ force ) { return ; } if ( false = = = $ ignore Readonly & & isset ( static : : STRUCT [ $ prop ] [ 'readonly ' ] ) & & true = = = static : : STRUCT [ $ prop ] [ 'readonly ' ] ) { $ e = sprintf ( 'Cannot set a read -only prop ` %s ` on entity ` %s ` . ' , $ prop , static : : class ) ; throw new Invalid Argument Exception ( $ e ) ; } if ( in _array ( $ prop , $ this - > leevel Changed Prop , true ) ) { return ; } $ this - > leevel Changed Prop [ ] = $ prop ; } 
protected function prop Value ( string $ prop ) { $ prop = $ this - > normalize ( $ prop ) ; $ this - > validate ( $ prop ) ; if ( ! $ this - > is Relation ( $ prop ) ) { return $ this - > prop Getter ( $ prop ) ; } return $ this - > load Relation Prop ( $ prop ) ; } 
protected function has Prop ( string $ prop ) : bool { $ prop = $ this - > normalize ( $ prop ) ; if ( ! $ this - > has Field ( $ prop ) ) { return false ; } $ prop = $ this - > as Prop ( $ prop ) ; if ( ! property _exists ( $ this , $ prop ) ) { $ e = sprintf ( 'Prop ` %s ` of entity ` %s ` was not defined . ' , $ prop , get _class ( $ this ) ) ; throw new Invalid Argument Exception ( $ e ) ; } return true ; } 
protected function prop Setter ( string $ prop , $ value ) : void { $ this - > { 'setter ' . ucfirst ( $ this - > as Prop ( $ prop ) ) } ( $ value ) ; } 
protected function parse Auto Fill ( string $ type , ? array $ fill = null ) : void { if ( null = = = $ fill ) { return ; } foreach ( static : : STRUCT as $ prop = > $ value ) { if ( $ fill & & ! in _array ( $ prop , $ fill , true ) ) { continue ; } if ( array _key _exists ( $ type . ' _fill ' , $ value ) ) { $ this - > normalize Fill ( $ prop , $ value [ $ type . ' _fill ' ] ) ; } } } 
protected function normalize Fill ( string $ prop , $ value ) : void { if ( null = = = $ value ) { $ camelize Class = 'fill ' . ucfirst ( $ this - > as Prop ( $ prop ) ) ; if ( method _exists ( $ this , $ camelize Class ) ) { $ value = $ this - > { $ camelize Class } ( $ this - > prop Value ( $ prop ) ) ; } } $ this - > with Prop Value ( $ prop , $ value ) ; } 
protected function load Data From Relation ( string $ prop ) { $ relation = $ this - > load Relation ( $ prop ) ; $ result = $ relation - > source Query ( ) ; $ this - > with Relation Prop ( $ prop , $ result ) ; return $ result ; } 
protected function prop ( string $ prop ) : string { $ this - > validate ( $ prop ) ; return $ this - > as Prop ( $ prop ) ; } 
protected function validate ( string $ prop ) : void { $ prop = $ this - > normalize ( $ prop ) ; if ( ! $ this - > has Prop ( $ prop ) ) { $ e = sprintf ( 'Entity ` %s ` prop or field of struct ` %s ` was not defined . ' , get _class ( $ this ) , $ prop ) ; throw new Invalid Argument Exception ( $ e ) ; } } 
protected function validate Relation Defined ( array $ defined , array $ field ) : void { foreach ( $ field as $ v ) { if ( ! isset ( $ defined [ $ v ] ) ) { $ e = sprintf ( 'Relation ` %s ` field was not defined . ' , $ v ) ; throw new Invalid Argument Exception ( $ e ) ; } } } 
protected function validate Relation Field ( IEntity $ entity , string $ field ) : void { if ( ! $ entity - > has Field ( $ field ) ) { $ e = sprintf ( 'The field ` %s ` . ` %s ` of entity ` %s ` was not defined . ' , $ entity - > table ( ) , $ field , get _class ( $ entity ) ) ; throw new Invalid Argument Exception ( $ e ) ; } } 
protected function normalize White And Black ( array $ key , string $ type ) : array { return $ this - > white And Black ( $ key , $ this - > leevel Black Whites [ $ type ] [ 'white ' ] , $ this - > leevel Black Whites [ $ type ] [ 'black ' ] ) ; } 
protected function to Array Source ( array $ white = [ ] , array $ black = [ ] , string $ separate = ' , ' ) : array { if ( $ white | | $ black ) { $ prop = $ this - > white And Black ( $ this - > fields ( ) , $ white , $ black ) ; } else { $ prop = $ this - > normalize White And Black ( $ this - > fields ( ) , 'show _prop ' ) ; } $ result = [ ] ; foreach ( $ prop as $ k = > $ value ) { if ( $ this - > is Relation ( $ k ) ) { continue ; } $ value = $ this - > prop Value ( $ k ) ; $ result [ $ k ] = $ value ; $ result = static : : prepare Enum ( $ k , $ result , $ separate ) ; } return $ result ; } 
protected static function prepare Enum ( string $ prop , array $ data , string $ separate = ' , ' ) : array { if ( ! isset ( $ data [ $ prop ] ) ) { return $ data ; } if ( false = = = ( $ enum = static : : enum ( $ prop , $ data [ $ prop ] , $ separate ) ) ) { return $ data ; } $ data [ $ prop . ' _ ' . self : : ENUM ] = $ enum ; return $ data ; } 
protected function white And Black ( array $ key , array $ white , array $ black ) : array { if ( $ white ) { $ key = array _intersect _key ( $ key , array _flip ( $ white ) ) ; } elseif ( $ black ) { $ key = array _diff _key ( $ key , array _flip ( $ black ) ) ; } return $ key ; } 
protected static function normalize ( string $ prop ) : string { if ( isset ( static : : $ leevel Un Camelize [ $ prop ] ) ) { return static : : $ leevel Un Camelize [ $ prop ] ; } return static : : $ leevel Un Camelize [ $ prop ] = un _camelize ( $ prop ) ; } 
protected function as Prop ( string $ prop ) : string { if ( isset ( static : : $ leevel Camelize [ $ prop ] ) ) { return static : : $ leevel Camelize [ $ prop ] ; } return static : : $ leevel Camelize [ $ prop ] = camelize ( $ prop ) ; } 
public function on Request ( Swoole Http Request $ swoole Request , Swoole Http Response $ swoole Response ) : void { 
public function on Http Close ( Swoole Http Server $ server , int $ fd , int $ reactor Id ) : void { $ this - > log ( sprintf ( 'Server close , fd %d , reactor Id %d . ' , $ fd , $ reactor Id ) ) ; } 
protected function dispatch Router ( IRequest $ request ) : IResponse { $ kernel = $ this - > container - > make ( IKernel : : class ) ; $ response = $ kernel - > handle ( $ request ) ; $ kernel - > terminate ( $ request , $ response ) ; $ this - > remove Coroutine ( ) ; return $ response ; } 
protected function normalize Response ( IResponse $ response , Swoole Http Response $ swoole Response ) : Swoole Http Response { foreach ( $ response - > get Cookies ( ) as $ item ) { call _user _func _array ( [ $ swoole Response , 'cookie ' ] , $ item ) ; } if ( $ response instanceof Redirect Response & & method _exists ( $ swoole Response , 'redirect ' ) ) { $ swoole Response - > redirect ( $ response - > get Target Url ( ) ) ; } foreach ( $ response - > headers - > all ( ) as $ key = > $ value ) { $ swoole Response - > header ( $ key , $ value ) ; } $ swoole Response - > status ( $ response - > get Status Code ( ) ) ; $ swoole Response - > write ( $ response - > get Content ( ) ? : ' ' ) ; return $ swoole Response ; } 
protected function normalize Request ( Swoole Http Request $ swoole Request ) : IRequest { $ request = new Request ( ) ; $ datas = [ 'header ' = > 'headers ' , 'server ' = > 'server ' , 'cookie ' = > 'cookies ' , 'get ' = > 'query ' , 'files ' = > 'files ' , 'post ' = > 'request ' , ] ; $ servers = [ ] ; if ( $ swoole Request - > header ) { $ tmp = $ tmp Header = [ ] ; foreach ( $ swoole Request - > header as $ key = > $ value ) { $ key = strtoupper ( str _replace ( ' - ' , ' _ ' , $ key ) ) ; $ tmp Header [ $ key ] = $ value ; $ key = 'HTTP _ ' . $ key ; $ tmp [ $ key ] = $ value ; } $ servers = $ tmp ; $ swoole Request - > header = $ tmp Header ; } if ( $ swoole Request - > server ) { $ swoole Request - > server = array _change _key _case ( $ swoole Request - > server , CASE _UPPER ) ; $ servers = array _merge ( $ servers , $ swoole Request - > server ) ; $ swoole Request - > server = $ servers ; } else { $ swoole Request - > server = $ servers ? : null ; } foreach ( $ datas as $ key = > $ item ) { if ( $ swoole Request - > { $ key } ) { $ request - > { $ item } - > replace ( $ swoole Request - > { $ key } ) ; } } return $ request ; } 
protected function create Server ( ) : void { unset ( $ this - > option [ 'task _worker _num ' ] ) ; $ this - > server = new Swoole Http Server ( $ this - > option [ 'host ' ] , ( int ) ( $ this - > option [ 'port ' ] ) ) ; $ this - > init Server ( ) ; 
public function add Namespace ( array $ namespaces ) : self { $ this - > namespaces = array _merge ( $ this - > namespaces , $ namespaces ) ; return $ this ; } 
public function load Data ( ) : array { if ( null ! = = $ this - > loaded ) { return $ this - > loaded ; } $ files = $ this - > find Console File ( $ this - > namespaces ) ; return $ this - > loaded = $ files ; } 
public function find Console File ( array $ namespaces ) : array { $ files = [ ] ; foreach ( $ namespaces as $ key = > $ dir ) { if ( ! is _dir ( $ dir ) ) { throw new Runtime Exception ( sprintf ( 'Console load dir %s is not exits . ' , $ dir ) ) ; } $ current Files = glob ( $ dir . ' / * .php ' ) ; $ current Files = array _map ( function ( $ item ) use ( $ key ) { return $ key . ' \ \ ' . basename ( $ item , ' .php ' ) ; } , $ current Files ) ; 
public function send ( Swift _Mime _Simple Message $ message , & $ failed Recipients = null ) { return $ this - > get Swift Mailer ( ) - > send ( $ message , $ failed Recipients ) ; } 
public function set Option ( string $ name , $ value ) : IServer { $ this - > option [ $ name ] = $ value ; return $ this ; } 
public function process ( string $ process ) : void { $ new Progress = new Process ( function ( Process $ worker ) use ( $ process ) { $ new Progress = $ this - > container - > make ( $ process ) ; if ( ! is _object ( $ new Progress ) | | ( $ new Progress instanceof Protocol Process ) ) { throw new Invalid Argument Exception ( sprintf ( 'Process ` %s ` was invalid . ' , $ process ) ) ; } if ( ! is _callable ( [ $ new Progress , 'handle ' ] ) ) { throw new Invalid Argument Exception ( sprintf ( 'The `handle ` of process ` %s ` was not found . ' , $ process ) ) ; } $ worker - > name ( $ this - > option [ 'process _name ' ] . ' . ' . $ new Progress - > get Name ( ) ) ; $ new Progress - > handle ( $ this , $ worker ) ; } ) ; $ this - > server - > add Process ( $ new Progress ) ; } 
public function start Server ( ) : void { $ this - > check Pid Path ( ) ; $ this - > create Server ( ) ; $ this - > event Server ( ) ; $ this - > start Swoole Server ( ) ; } 
public function on Start ( Swoole Server $ server ) : void { $ this - > log ( sprintf ( 'Server is started at %s : %d ' , $ this - > option [ 'host ' ] , $ this - > option [ 'port ' ] ) , true , ' ' ) ; $ this - > log ( 'Server master worker start ' , true ) ; $ this - > set Process Name ( $ this - > option [ 'process _name ' ] . ' .master ' ) ; $ pid = $ server - > master _pid . " \n " . $ server - > manager _pid ; $ dirname = dirname ( $ this - > option [ 'pid _path ' ] ) ; if ( ! is _writable ( $ dirname ) | | ! file _put _contents ( $ this - > option [ 'pid _path ' ] , $ pid ) ) { throw new Invalid Argument Exception ( sprintf ( 'Dir %s is not writeable . ' , $ dirname ) ) ; } chmod ( $ this - > option [ 'pid _path ' ] , 0 6 6 6 & ~ umask ( ) ) ; 
public function on Connect ( Swoole Server $ server , int $ fd , int $ reactor Id ) : void { $ this - > log ( sprintf ( 'Server connect , fd %d , reactor Id %d . ' , $ fd , $ reactor Id ) ) ; } 
public function on Worker Start ( Swoole Server $ server , int $ worke Id ) : void { if ( $ worke Id > = $ this - > option [ 'worker _num ' ] ) { $ this - > set Process Name ( $ this - > option [ 'process _name ' ] . ' .task ' ) ; } else { $ this - > set Process Name ( $ this - > option [ 'process _name ' ] . ' .worker ' ) ; } 
public function on Manager Start ( Swoole Server $ server ) : void { $ this - > log ( 'Server manager worker start ' , true ) ; $ this - > set Process Name ( $ this - > option [ 'process _name ' ] . ' .manager ' ) ; } 
public function on Worker Stop ( Swoole Server $ server , int $ worker Id ) : void { $ this - > log ( sprintf ( 'Server %s worker %d shutdown ' , $ server - > setting [ 'process _name ' ] , $ worker Id ) ) ; } 
public function on Receive ( Swoole Server $ server , int $ fd , int $ reactor Id , string $ data ) : void { } 
public function on Finish ( Swoole Server $ server , int $ task Id , string $ data ) : void { $ this - > log ( sprintf ( 'Task %d finish , the result is %s ' , $ task Id , $ data ) ) ; } 
public function on Task ( Swoole Server $ server , int $ task Id , int $ from Id , string $ data ) : void { $ this - > log ( sprintf ( 'Task %d form workder %d , the result is %s ' , $ task Id , $ from Id , $ data ) ) ; $ server - > finish ( $ data ) ; } 
public function on Shutdown ( Swoole Server $ server ) : void { if ( is _file ( $ this - > option [ 'pid _path ' ] ) ) { unlink ( $ this - > option [ 'pid _path ' ] ) ; } $ this - > log ( 'Server shutdown ' ) ; } 
protected function create Server ( ) : void { $ this - > server = new Swoole Server ( $ this - > option [ 'host ' ] , ( int ) ( $ this - > option [ 'port ' ] ) ) ; $ this - > init Server ( ) ; } 
protected function init Server ( ) : void { $ this - > server - > set ( $ this - > option ) ; foreach ( $ this - > option [ 'processes ' ] as $ process ) { $ this - > process ( $ process ) ; } } 
protected function event Server ( ) : void { $ type = get _class ( $ this ) ; $ type = substr ( $ type , strrpos ( $ type , ' \ \ ' ) + 1 ) ; $ type = str _replace ( 'Server ' , ' ' , $ type ) ; foreach ( $ this - > server Event as $ event ) { if ( ! method _exists ( $ this , $ on Event = 'on ' . $ type . ucfirst ( $ event ) ) ) { $ on Event = 'on ' . ucfirst ( $ event ) ; } $ this - > server - > on ( $ event , [ $ this , $ on Event ] ) ; } } 
protected function set Process Name ( string $ name ) : void { if ( function _exists ( 'cli _set _process _title ' ) ) { cli _set _process _title ( $ name ) ; } else { if ( function _exists ( 'swoole _set _process _name ' ) ) { swoole _set _process _name ( $ name ) ; } else { throw new Invalid Argument Exception ( 'Require cli _set _process _title or swoole _set _process _name . ' ) ; } } } 
protected function log ( string $ message , bool $ force = false , string $ format Time = 'H :i :s ' ) : void { if ( ! $ force & & ! $ this - > daemonize ( ) ) { return ; } fwrite ( STDOUT , $ this - > message Time ( $ message , $ format Time ) . PHP _EOL ) ; } 
protected function message Time ( string $ message , string $ format Time = ' ' ) : string { return ( $ format Time ? sprintf ( ' [ %s ] ' , date ( $ format Time ) ) : ' ' ) . $ message ; } 
public static function lazy ( $ value , ? string $ message = null , bool $ all = true ) : self { return new static ( $ value , $ message , true , $ all ) ; } 
public function flush ( Closure $ format = null ) : bool { if ( $ this - > error ) { if ( ! $ format ) { $ format = 'json _encode ' ; } $ e = $ format ( $ this - > error ) ; throw new Assert Exception ( $ e ) ; } return true ; } 
protected static function validate Assert ( string $ method , array $ args ) : bool { if ( ! array _key _exists ( 0 , $ args ) ) { throw new Invalid Argument Exception ( 'Missing the first argument . ' ) ; } 
protected static function normalize Message ( array $ args , ? string $ message = null ) : string { if ( count ( $ args ) > = 2 & & is _string ( $ args [ array _key _last ( $ args ) ] ) ) { $ message = array _pop ( $ args ) ; } else { $ message = $ message ? ? 'No exception messsage specified . ' ; } return $ message ; } 
protected static function match Optional ( string $ method , array $ args ) { if ( 0 ! = = strpos ( $ method , 'optional ' ) ) { return [ $ method , false ] ; } if ( null = = = $ args [ 0 ] ) { self : : count Php Unit ( ) ; return true ; } $ method = substr ( $ method , 8 ) ; return [ $ method , true ] ; } 
protected static function match Multi ( string $ method , array $ args , bool $ optional ) { if ( 0 ! = = stripos ( $ method , 'multi ' ) ) { return [ $ method , [ $ args ] ] ; } if ( ! is _array ( $ args [ 0 ] ) & & ! $ args instanceof Traversable ) { $ e = sprintf ( 'Invalid first argument for multi assert . ' ) ; throw new Invalid Argument Exception ( $ e ) ; } $ multi = [ ] ; $ args Source = $ args ; foreach ( $ args [ 0 ] as $ v ) { if ( null = = = $ v & & true = = = $ optional ) { continue ; } $ args Source [ 0 ] = $ v ; $ multi [ ] = $ args Source ; } if ( ! $ multi ) { self : : count Php Unit ( ) ; return true ; } $ method = substr ( $ method , 5 ) ; return [ $ method , $ multi ] ; } 
protected static function validate Rule ( string $ method , array $ multi ) : bool { try { $ fn = _ _NAMESPACE _ _ . ' \ \Helper \ \validate _ ' . un _camelize ( $ method ) ; foreach ( $ multi as $ m ) { if ( ! function _exists ( $ fn ) ) { class _exists ( $ fn ) ; } if ( false = = = $ fn ( . . . $ m ) ) { return false ; } self : : count Php Unit ( ) ; } } catch ( Function Not Found Exception $ th ) { $ e = sprintf ( 'Method ` %s ` is not exits . ' , $ method ) ; throw new Bad Method Call Exception ( $ e ) ; } return true ; } 
public function register ( ) : void { $ this - > databases ( ) ; $ this - > database ( ) ; $ this - > work ( ) ; $ this - > database Lazyload ( ) ; } 
public function handle ( IApp $ app ) : void { $ i 1 8n Default = $ app [ 'option ' ] [ 'i 1 8n \ \default ' ] ; if ( $ app - > is Cached I 1 8n ( $ i 1 8n Default ) ) { $ data = ( array ) include $ app - > i 1 8n Cached Path ( $ i 1 8n Default ) ; } else { $ load = ( new Load ( [ $ app - > i 1 8n Path ( ) ] ) ) - > set I 1 8n ( $ i 1 8n Default ) - > add Dir ( $ this - > get Extend ( $ app ) ) ; $ data = $ load - > load Data ( ) ; } $ app - > instance ( 'i 1 8n ' , $ i 1 8n = new I 1 8n ( $ i 1 8n Default ) ) ; $ i 1 8n - > addtext ( $ i 1 8n Default , $ data ) ; } 
public function get Extend ( IApp $ app ) : array { $ extend = $ app [ 'option ' ] - > get ( ' _composer .i 1 8ns ' , [ ] ) ; $ path = $ app - > path ( ) ; $ extend = array _map ( function ( string $ item ) use ( $ path ) { if ( ! is _file ( $ item ) ) { $ item = $ path . ' / ' . $ item ; } if ( ! is _dir ( $ item ) ) { throw new Exception ( sprintf ( 'I 1 8n dir %s is not exist . ' , $ item ) ) ; } return $ item ; } , $ extend ) ; return $ extend ; } 
public function set Option ( string $ name , $ value ) : ISeccode { $ this - > option [ $ name ] = $ value ; return $ this ; } 
public function display ( $ code = null , ? string $ out Path = null , bool $ auto Code = true , string $ auto Type = self : : ALPHA _UPPERCASE ) : void { if ( is _int ( $ code ) & & $ auto Code ) { $ this - > auto Code ( $ code , $ auto Type ) ; } else { $ code & & $ this - > code ( $ code ) ; } $ res Image = imagecreatefromstring ( $ this - > make Background ( ) ) ; if ( $ this - > option [ 'adulterate ' ] ) { $ this - > make Adulterate ( $ res Image ) ; } $ this - > make Ttf Font ( $ res Image ) ; if ( $ out Path ) { create _directory ( dirname ( $ out Path ) ) ; imagepng ( $ res Image , $ out Path , 9 ) ; } else { 
protected function normalize Width ( ) : int { if ( $ this - > option [ 'width ' ] < static : : MIN _WIDTH ) { return static : : MIN _WIDTH ; } if ( $ this - > option [ 'width ' ] > static : : MAX _WIDTH ) { return static : : MAX _WIDTH ; } return $ this - > option [ 'width ' ] ; } 
protected function normalize Height ( ) : int { if ( $ this - > option [ 'height ' ] < static : : MIN _HEIGHT ) { return static : : MIN _HEIGHT ; } if ( $ this - > option [ 'height ' ] > static : : MAX _HEIGHT ) { return static : : MAX _HEIGHT ; } return $ this - > option [ 'height ' ] ; } 
protected function make Background ( ) : string { $ res Image = imagecreatetruecolor ( $ this - > normalize Width ( ) , $ this - > normalize Height ( ) ) ; $ res Color = imagecolorallocate ( $ res Image , 2 5 5 , 2 5 5 , 2 5 5 ) ; if ( false = = = $ this - > make Background With Image ( $ res Image ) ) { $ this - > make Background Default ( $ res Image ) ; } ob _start ( ) ; imagepng ( $ res Image ) ; imagedestroy ( $ res Image ) ; $ background = ob _get _contents ( ) ; ob _end _clean ( ) ; return $ background ; } 
protected function make Adulterate ( & $ res Image ) : void { $ width = $ this - > normalize Width ( ) ; $ height = $ this - > normalize Height ( ) ; $ line Num = $ height / 1 0 ; for ( $ i = 0 ; $ i < = $ line Num ; $ i + + ) { $ res Color = $ this - > option [ 'color ' ] ? imagecolorallocate ( $ res Image , $ this - > mt Rand ( 0 , 2 5 5 ) , $ this - > mt Rand ( 0 , 2 5 5 ) , $ this - > mt Rand ( 0 , 2 5 5 ) ) : imagecolorallocate ( $ res Image , $ this - > font Color [ 0 ] , $ this - > font Color [ 1 ] , $ this - > font Color [ 2 ] ) ; $ x = $ this - > mt Rand ( 0 , $ width ) ; $ y = $ this - > mt Rand ( 0 , $ height ) ; if ( mt _rand ( 0 , 1 ) ) { imagearc ( $ res Image , $ x , $ y , $ this - > mt Rand ( 0 , $ width ) , $ this - > mt Rand ( 0 , $ height ) , $ this - > mt Rand ( 0 , 3 6 0 ) , $ this - > mt Rand ( 0 , 3 6 0 ) , $ res Color ) ; } else { imageline ( $ res Image , $ x , $ y , 0 + $ this - > mt Rand ( 0 , 0 ) , 0 + $ this - > mt Rand ( 0 , $ this - > mt Rand ( $ height , $ width ) ) , $ res Color ) ; } } } 
protected function make Ttf Font ( & $ res Image ) : void { if ( ! function _exists ( 'imagettftext ' ) ) { 
protected function get Font Option ( ) : array { $ code = $ this - > get Code ( ) ; $ ttf = $ this - > get Ttf ( ) ; if ( $ this - > is Chinese ( $ code ) ) { $ code = str _split ( $ code , 3 ) ; $ code Length = count ( $ code ) ; } else { $ code Length = strlen ( $ code ) ; } $ font = [ ] ; $ width Total = 0 ; $ width = $ this - > normalize Width ( ) ; for ( $ i = 0 ; $ i < $ code Length ; $ i + + ) { if ( ! isset ( $ font [ $ i ] ) ) { $ font [ $ i ] = [ ] ; } $ font [ $ i ] [ 'font ' ] = $ ttf [ array _rand ( $ ttf ) ] ; $ font [ $ i ] [ 'tilt ' ] = $ this - > option [ 'tilt ' ] ? $ this - > mt Rand ( - 3 0 , 3 0 ) : 0 ; $ font [ $ i ] [ 'size ' ] = $ width / 6 ; $ this - > option [ 'size ' ] & & $ font [ $ i ] [ 'size ' ] = $ this - > mt Rand ( $ font [ $ i ] [ 'size ' ] - $ width / 4 0 , $ font [ $ i ] [ 'size ' ] + $ width / 2 0 ) ; $ res Box = imagettfbbox ( $ font [ $ i ] [ 'size ' ] , 0 , $ font [ $ i ] [ 'font ' ] , $ code [ $ i ] ) ; $ font [ $ i ] [ 'zheight ' ] = max ( $ res Box [ 1 ] , $ res Box [ 3 ] ) - min ( $ res Box [ 5 ] , $ res Box [ 7 ] ) ; $ res Box = imagettfbbox ( $ font [ $ i ] [ 'size ' ] , $ font [ $ i ] [ 'tilt ' ] , $ font [ $ i ] [ 'font ' ] , $ code [ $ i ] ) ; $ font [ $ i ] [ 'height ' ] = max ( $ res Box [ 1 ] , $ res Box [ 3 ] ) - min ( $ res Box [ 5 ] , $ res Box [ 7 ] ) ; $ font [ $ i ] [ 'hd ' ] = $ font [ $ i ] [ 'height ' ] - $ font [ $ i ] [ 'zheight ' ] ; $ font [ $ i ] [ 'width ' ] = ( max ( $ res Box [ 2 ] , $ res Box [ 4 ] ) - min ( $ res Box [ 0 ] , $ res Box [ 6 ] ) ) + $ this - > mt Rand ( 0 , ( int ) ( $ width / 8 ) ) ; $ font [ $ i ] [ 'width ' ] = $ font [ $ i ] [ 'width ' ] > $ width / $ code Length ? $ width / $ code Length : $ font [ $ i ] [ 'width ' ] ; $ width Total + = $ font [ $ i ] [ 'width ' ] ; } return [ $ font , $ code , $ width Total , ] ; } 
protected function make Background With Image ( & $ res Image ) : bool { $ find Background = false ; $ background Path = $ this - > option [ 'background _path ' ] ; $ width = $ this - > normalize Width ( ) ; $ height = $ this - > normalize Height ( ) ; if ( $ this - > option [ 'background ' ] & & function _exists ( 'imagecreatefromjpeg ' ) & & function _exists ( 'imagecolorat ' ) & & function _exists ( 'imagecopymerge ' ) & & function _exists ( 'imagesetpixel ' ) & & function _exists ( 'image SX ' ) & & function _exists ( 'image SY ' ) ) { if ( ! is _dir ( $ background Path ) ) { $ e = sprintf ( 'Background path %s is not exists . ' , $ background Path ) ; throw new Invalid Argument Exception ( $ e ) ; } $ background = glob ( $ background Path . ' / * . * ' ) ; if ( $ background ) { $ res Background = imagecreatefromjpeg ( $ background [ array _rand ( $ background ) ] ) ; $ res Color Index = imagecolorat ( $ res Background , 0 , 0 ) ; $ color = imagecolorsforindex ( $ res Background , $ res Color Index ) ; $ res Color Index = imagecolorat ( $ res Background , 1 , 0 ) ; imagesetpixel ( $ res Background , 0 , 0 , $ res Color Index ) ; $ color [ 0 ] = ( int ) ( $ color [ 'red ' ] ) ; $ color [ 1 ] = ( int ) ( $ color [ 'green ' ] ) ; $ color [ 2 ] = ( int ) ( $ color [ 'blue ' ] ) ; imagecopymerge ( $ res Image , $ res Background , 0 , 0 , $ this - > mt Rand ( 0 , 2 0 0 - $ width ) , $ this - > mt Rand ( 0 , 8 0 - $ height ) , imagesx ( $ res Background ) , imagesy ( $ res Background ) , 1 0 0 ) ; imagedestroy ( $ res Background ) ; $ find Background = true ; $ this - > font Color = $ color ; } } return $ find Background ; } 
protected function make Background Default ( & $ res Image ) : void { $ width = $ this - > normalize Width ( ) ; $ height = $ this - > normalize Height ( ) ; for ( $ i = 0 ; $ i < 3 ; $ i + + ) { $ start [ $ i ] = $ this - > mt Rand ( 2 0 0 , 2 5 5 ) ; $ end [ $ i ] = $ this - > mt Rand ( 1 0 0 , 1 5 0 ) ; $ step [ $ i ] = ( $ end [ $ i ] - $ start [ $ i ] ) / $ width ; $ color [ $ i ] = $ start [ $ i ] ; } for ( $ i = 0 ; $ i < $ width ; $ i + + ) { $ res Color = imagecolorallocate ( $ res Image , ( int ) ( $ color [ 0 ] ) , ( int ) ( $ color [ 1 ] ) , ( int ) ( $ color [ 2 ] ) ) ; imageline ( $ res Image , $ i , 0 , $ i - ( $ this - > option [ 'tilt ' ] ? $ this - > mt Rand ( - 3 0 , 3 0 ) : 0 ) , $ height , $ res Color ) ; $ color [ 0 ] + = $ step [ 0 ] ; $ color [ 1 ] + = $ step [ 1 ] ; $ color [ 2 ] + = $ step [ 2 ] ; } $ color [ 0 ] - = 2 0 ; $ color [ 1 ] - = 2 0 ; $ color [ 2 ] - = 2 0 ; $ color [ 0 ] = ( int ) ( $ color [ 0 ] ) ; $ color [ 1 ] = ( int ) ( $ color [ 1 ] ) ; $ color [ 2 ] = ( int ) ( $ color [ 2 ] ) ; $ this - > font Color = $ color ; unset ( $ color ) ; } 
protected function get Ttf ( ) : array { $ font Path = $ this - > is Chinese ( $ this - > get Code ( ) ) ? $ this - > option [ 'chinese _font _path ' ] : $ this - > option [ 'font _path ' ] ; if ( ! is _dir ( $ font Path ) ) { $ e = sprintf ( 'Font path %s is not exits . ' , $ font Path ) ; throw new Invalid Argument Exception ( $ e ) ; } $ ttf = glob ( $ font Path . ' / * . * ' ) ; if ( empty ( $ ttf ) ) { throw new Invalid Argument Exception ( 'Font files not found . ' ) ; } return $ ttf ; } 
protected function auto Code ( int $ size , string $ auto Type = self : : ALPHA _UPPERCASE ) : void { if ( $ size < 1 ) { $ e = sprintf ( 'Code must be greater than %d . ' , 0 ) ; throw new Invalid Argument Exception ( $ e ) ; } if ( ! in _array ( $ auto Type , $ this - > get Allowed Auto Type ( ) , true ) ) { $ e = sprintf ( 'Code type must be these %s . ' , implode ( ' , ' , $ this - > get Allowed Auto Type ( ) ) ) ; throw new Invalid Argument Exception ( $ e ) ; } $ rand Method = 'Leevel \ \Support \ \Str \ \rand _ ' . $ auto Type ; $ this - > code ( fn ( $ rand Method , $ size ) ) ; } 
protected function mt Rand ( $ num First , $ num Second ) : int { $ num First = ( int ) ( $ num First ) ; $ num Second = ( int ) ( $ num Second ) ; if ( $ num First > $ num Second ) { list ( $ num Second , $ num First ) = [ $ num First , $ num Second ] ; } return ( int ) ( mt _rand ( $ num First , $ num Second ) ) ; } 
protected function make Connect Html ( array $ options = [ ] ) : Html { $ options = $ this - > normalize Connect Option ( 'html ' , $ options ) ; $ options = array _merge ( $ options , $ this - > view Option Common ( ) ) ; $ container = $ this - > container ; $ html = new Html ( $ options ) ; $ html - > set Parse Resolver ( function ( ) use ( $ container ) { return $ container [ 'view .parser ' ] ; } ) ; return $ html ; } 
protected function make Connect Phpui ( array $ options = [ ] ) : Phpui { $ options = $ this - > normalize Connect Option ( 'phpui ' , $ options ) ; $ options = array _merge ( $ options , $ this - > view Option Common ( ) ) ; return new Phpui ( $ options ) ; } 
public function fetch Args ( int $ fetch Style , $ fetch Argument = null , array $ ctor Args = [ ] ) : self { $ this - > query Params [ 'fetch _args ' ] [ 'fetch _style ' ] = $ fetch Style ; if ( $ fetch Argument ) { $ this - > query Params [ 'fetch _args ' ] [ 'fetch _argument ' ] = $ fetch Argument ; } $ this - > query Params [ 'fetch _args ' ] [ 'ctor _args ' ] = $ ctor Args ; return $ this ; } 
public function as Class ( string $ class Name , array $ args = [ ] ) : self { $ this - > query Params [ 'as _class ' ] = $ class Name ; $ this - > query Params [ 'class _args ' ] = $ args ; $ this - > query Params [ 'as _default ' ] = false ; return $ this ; } 
public function select ( $ data = null , array $ bind = [ ] , bool $ flag = false ) { 
public function insert ( $ data , array $ bind = [ ] , bool $ replace = false , bool $ flag = false ) { return $ this - > safe Sql ( $ flag ) - > run Native Sql ( . . . $ this - > condition - > insert ( $ data , $ bind , $ replace ) ) ; } 
public function update ( $ data , array $ bind = [ ] , bool $ flag = false ) { return $ this - > safe Sql ( $ flag ) - > run Native Sql ( . . . $ this - > condition - > update ( $ data , $ bind ) ) ; } 
public function update Column ( string $ column , $ value , array $ bind = [ ] , bool $ flag = false ) { return $ this - > update ( [ $ column = > $ value ] , $ bind , $ flag ) ; } 
public function update Increase ( string $ column , int $ step = 1 , array $ bind = [ ] , bool $ flag = false ) { return $ this - > update Column ( $ column , ' { [ ' . $ column . ' ] + ' . $ step . ' } ' , $ bind , $ flag ) ; } 
public function delete ( ? string $ data = null , array $ bind = [ ] , bool $ flag = false ) { return $ this - > safe Sql ( $ flag ) - > run Native Sql ( . . . $ this - > condition - > delete ( $ data , $ bind ) ) ; } 
public function truncate ( bool $ flag = false ) { return $ this - > safe Sql ( $ flag ) - > run Native Sql ( . . . $ this - > condition - > truncate ( ) ) ; } 
public function find One ( bool $ flag = false ) { $ this - > condition - > one ( ) ; return $ this - > safe Sql ( $ flag ) - > query ( ) ; } 
public function find All ( bool $ flag = false ) { $ this - > condition - > all ( ) ; return $ this - > safe Sql ( $ flag ) - > query ( ) ; } 
public function find ( ? int $ num = null , bool $ flag = false ) { if ( null ! = = $ num ) { $ this - > condition - > top ( $ num ) ; } return $ this - > safe Sql ( $ flag ) - > query ( ) ; } 
public function value ( string $ field , bool $ flag = false ) { $ this - > condition - > set Columns ( $ field ) - > one ( ) ; $ result = ( array ) $ this - > safe Sql ( $ flag ) - > as Default ( ) - > query ( ) ; if ( true = = = $ this - > only Make Sql ) { return $ result ; } return $ result [ $ field ] ? ? null ; } 
public function pull ( string $ field , bool $ flag = false ) { return $ this - > value ( $ field , $ flag ) ; } 
public function list ( $ field Value , ? string $ field Key = null , bool $ flag = false ) : array { 
public function chunk ( int $ count , Closure $ chunk ) : void { $ result = $ this - > for Page ( $ page = 1 , $ count ) - > find All ( ) ; while ( count ( $ result ) > 0 ) { if ( false = = = $ chunk ( $ result , $ page ) ) { break ; } $ page + + ; $ result = $ this - > for Page ( $ page , $ count ) - > find All ( ) ; } } 
public function each ( int $ count , Closure $ each ) : void { $ this - > chunk ( $ count , function ( $ result , $ page ) use ( $ each ) { foreach ( $ result as $ key = > $ value ) { if ( false = = = $ each ( $ value , $ key , $ page ) ) { return false ; } } } ) ; } 
public function find Count ( string $ field = ' * ' , string $ alias = 'row _count ' , bool $ flag = false ) { $ result = $ this - > find Aggregate Result ( 'count ' , $ field , $ alias , $ flag ) ; if ( ! is _array ( $ result ) ) { $ result = ( int ) $ result ; } return $ result ; } 
public function find Sum ( string $ field , string $ alias = 'sum _value ' , bool $ flag = false ) { return $ this - > find Aggregate Result ( 'sum ' , $ field , $ alias , $ flag ) ; } 
public function page ( int $ current Page , int $ per Page = 1 0 , bool $ flag = false , bool $ with Total = true , string $ column = ' * ' ) : array { $ from = ( $ current Page - 1 ) * $ per Page ; return [ [ 'per _page ' = > $ per Page , 'current _page ' = > $ current Page , 'total _record ' = > $ with Total ? $ this - > page Count ( $ column ) : null , 'from ' = > $ from , ] , $ this - > limit ( $ from , $ per Page ) - > find All ( $ flag ) , self : : PAGE = > true , ] ; } 
public function page Html ( int $ current Page , int $ per Page = 1 0 , bool $ flag = false , string $ column = ' * ' , array $ option = [ ] ) : array { $ page = new Page ( $ current Page , $ per Page , $ this - > page Count ( $ column ) , $ option ) ; return [ $ page , $ this - > limit ( $ page - > get From Record ( ) , $ per Page ) - > find All ( $ flag ) , self : : PAGE = > true , ] ; } 
public function page Macro ( int $ current Page , int $ per Page = 1 0 , bool $ flag = false , array $ option = [ ] ) : array { $ page = new Page ( $ current Page , $ per Page , IPage : : MACRO , $ option ) ; return [ $ page , $ this - > limit ( $ page - > get From Record ( ) , $ per Page ) - > find All ( $ flag ) , self : : PAGE = > true , ] ; } 
public function page Prev Next ( int $ current Page , int $ per Page = 1 0 , bool $ flag = false , array $ option = [ ] ) : array { $ page = new Page ( $ current Page , $ per Page , null , $ option ) ; return [ $ page , $ this - > limit ( $ page - > get From Record ( ) , $ per Page ) - > find All ( $ flag ) , self : : PAGE = > true , ] ; } 
public function page Count ( string $ cols = ' * ' ) : int { $ this - > backup Page Args ( ) ; $ count = $ this - > find Count ( $ cols ) ; $ this - > restore Page Args ( ) ; return $ count ; } 
protected function safe Sql ( bool $ flag = true ) : self { if ( true = = = $ this - > only Make Sql ) { return $ this ; } $ this - > only Make Sql = $ flag ; return $ this ; } 
protected function query ( ) { $ sql = $ this - > make Sql ( ) ; $ args = [ $ sql , $ this - > condition - > get Bind Params ( ) , $ this - > query Params [ 'master ' ] , $ this - > query Params [ 'fetch _args ' ] [ 'fetch _style ' ] , $ this - > query Params [ 'fetch _args ' ] [ 'fetch _argument ' ] , $ this - > query Params [ 'fetch _args ' ] [ 'ctor _args ' ] , ] ; 
protected function query Default ( array $ data ) { if ( ! $ this - > condition - > get Option ( ) [ 'limit Query ' ] ) { return reset ( $ data ) ? : [ ] ; } return $ this - > query Params [ 'as _collection ' ] ? new Collection ( $ data ) : $ data ; } 
protected function query Class ( array $ data ) { $ class Name = $ this - > query Params [ 'as _class ' ] ; if ( ! class _exists ( $ class Name ) ) { $ e = sprintf ( 'The class of query ` %s ` was not found . ' , $ class Name ) ; throw new Invalid Argument Exception ( $ e ) ; } foreach ( $ data as $ key = > $ tmp ) { $ data [ $ key ] = new $ class Name ( ( array ) $ tmp , . . . $ this - > query Params [ 'class _args ' ] ) ; } if ( ! $ this - > condition - > get Option ( ) [ 'limit Query ' ] ) { $ data = reset ( $ data ) ? : new $ class Name ( [ ] , . . . $ this - > query Params [ 'class _args ' ] ) ; } elseif ( $ this - > query Params [ 'as _collection ' ] ) { $ data = new Collection ( $ data , [ $ class Name ] ) ; } return $ data ; } 
protected function find Aggregate Result ( string $ method , string $ field , string $ alias , bool $ flag = false ) { $ this - > condition - > { $ method } ( $ field , $ alias ) ; $ result = $ this - > safe Sql ( $ flag ) - > as Default ( ) - > query ( ) ; if ( true = = = $ this - > only Make Sql ) { return $ result ; } return is _object ( $ result ) ? $ result - > { $ alias } : $ result [ $ alias ] ; } 
protected function run Native Sql ( string $ native Type , string $ data , array $ bind Params = [ ] ) { $ sql Type = $ this - > connect - > normalize Sql Type ( $ data ) ; if ( 'procedure ' = = = $ sql Type ) { $ sql Type = 'select ' ; } if ( $ sql Type ! = = $ native Type ) { $ e = sprintf ( 'The SQL type ` %s ` must be consistent with the provided ` %s ` . ' , $ sql Type , $ native Type ) ; throw new Invalid Argument Exception ( $ e ) ; } $ args = [ $ data , $ bind Params ] ; 
protected function backup Page Args ( ) : void { $ this - > backup Page = [ ] ; $ this - > backup Page [ 'query _params ' ] = $ this - > query Params ; $ this - > backup Page [ 'aggregate ' ] = $ this - > condition - > get Option ( ) [ 'aggregate ' ] ; $ this - > backup Page [ 'columns ' ] = $ this - > condition - > get Option ( ) [ 'columns ' ] ; } 
protected function restore Page Args ( ) : void { $ this - > query Params = $ this - > backup Page [ 'query _params ' ] ; $ this - > condition - > set Option ( 'aggregate ' , $ this - > backup Page [ 'aggregate ' ] ) ; $ this - > condition - > set Option ( 'columns ' , $ this - > backup Page [ 'columns ' ] ) ; } 
protected function un Camelize ( string $ value , string $ separator = ' _ ' ) : string { return strtolower ( preg _replace ( ' / ( [a -z ] ) ( [A -Z ] ) / ' , ' $ 1 ' . $ separator . ' $ 2 ' , $ value ) ) ; } 
public function read ( $ sessionid ) : string { return serialize ( $ this - > cache - > get ( $ this - > get Session Name ( $ sessionid ) , [ ] ) ? : [ ] ) ; } 
public function write ( $ sessionid , $ sessiondata ) : bool { $ this - > cache - > set ( $ this - > get Session Name ( $ sessionid ) , unserialize ( $ sessiondata ) ) ; return true ; } 
public function destroy ( $ sessionid ) : bool { $ this - > cache - > delete ( $ this - > get Session Name ( $ sessionid ) ) ; return true ; } 
public function is Valid ( ) : bool { return UPLOAD _ERR _OK = = = $ this - > error & & ( $ this - > test ? true : is _uploaded _file ( $ this - > get Pathname ( ) ) ) ; } 
public function move ( string $ directory , ? string $ name = null ) : File { if ( $ this - > is Valid ( ) ) { if ( $ this - > test ) { return parent : : move ( $ directory , $ name ) ; } $ target = $ this - > get Target File ( $ directory , $ name ) ; $ this - > move To Target ( $ this - > get Pathname ( ) , $ target , true ) ; return new File ( $ target ) ; } throw new File Exception ( $ this - > get Error Message ( ) ) ; } 
public function get Error Message ( ) : string { $ error Code = $ this - > error ; $ max Filesize = UPLOAD _ERR _INI _SIZE = = = $ error Code ? self : : get Max Filesize ( ) / 1 0 2 4 : 0 ; $ message = isset ( self : : $ errors [ $ error Code ] ) ? self : : $ errors [ $ error Code ] : 'The file %s was not uploaded due to an unknown error . ' ; $ message = sprintf ( $ message , $ this - > get Original Name ( ) , $ max Filesize ) ; return $ message ; } 
public function with Input ( ? array $ input = null ) : IResponse { if ( $ this - > check Flow Control ( ) ) { return $ this ; } $ input = $ input ? : $ this - > request - > input ( ) ; $ inputs = array _merge ( $ this - > session - > get Flash ( 'inputs ' , [ ] ) , $ input ) ; $ this - > session - > flash ( 'inputs ' , $ inputs ) ; return $ this ; } 
public function only Input ( . . . $ args ) : IResponse { if ( ! $ args ) { throw new Invalid Argument Exception ( 'Method only Input need an args . ' ) ; } return $ this - > with Input ( $ this - > request - > only ( $ args ) ) ; } 
public function except Input ( . . . $ args ) : IResponse { if ( ! $ args ) { throw new Invalid Argument Exception ( 'Method except Input need an args . ' ) ; } return $ this - > with Input ( $ this - > request - > except ( $ args ) ) ; } 
public function with Errors ( $ value , string $ key = 'default ' ) : IResponse { if ( $ this - > check Flow Control ( ) ) { return $ this ; } $ errors = $ this - > session - > get Flash ( 'errors ' , [ ] ) ; $ errors [ $ key ] = $ value ; $ this - > session - > flash ( 'errors ' , $ errors ) ; return $ this ; } 
public function set ( string $ name , $ value = null , array $ option = [ ] ) : void { $ option = $ this - > normalize Options ( $ option ) ; if ( is _array ( $ value ) ) { $ value = json _encode ( $ value ) ; } elseif ( ! is _string ( $ value ) & & null ! = = $ value ) { throw new Exception ( 'Cookie value must be string ,array or null . ' ) ; } $ option [ 'expire ' ] = ( int ) ( $ option [ 'expire ' ] ) ; if ( $ option [ 'expire ' ] < 0 ) { throw new Exception ( 'Cookie expire date must greater than or equal 0 . ' ) ; } if ( $ option [ 'expire ' ] > 0 ) { $ option [ 'expire ' ] = time ( ) + $ option [ 'expire ' ] ; } 
public function put ( $ keys , $ value = null , array $ option = [ ] ) : void { if ( ! is _array ( $ keys ) ) { $ keys = [ $ keys = > $ value , ] ; } foreach ( $ keys as $ key = > $ value ) { $ this - > set ( $ key , $ value , $ option ) ; } } 
public function merge ( string $ key , array $ value , array $ option = [ ] ) : void { $ this - > set ( $ key , array _merge ( $ this - > get ( $ key , [ ] , $ option ) , $ value ) , $ option ) ; } 
public function pop ( string $ key , array $ value , array $ option = [ ] ) : void { $ this - > set ( $ key , array _diff ( $ this - > get ( $ key , [ ] , $ option ) , $ value ) , $ option ) ; } 
public function arr ( string $ key , $ keys , $ value = null , array $ option = [ ] ) : void { $ arr = $ this - > get ( $ key , [ ] , $ option ) ; if ( is _string ( $ keys ) ) { $ arr [ $ keys ] = $ value ; } elseif ( is _array ( $ keys ) ) { $ arr = array _merge ( $ arr , $ keys ) ; } $ this - > set ( $ key , $ arr , $ option ) ; } 
public function arr Delete ( string $ key , $ keys , array $ option = [ ] ) : void { $ arr = $ this - > get ( $ key , [ ] , $ option ) ; if ( ! is _array ( $ keys ) ) { $ keys = [ $ keys , ] ; } foreach ( $ keys as $ tmp ) { if ( isset ( $ arr [ $ tmp ] ) ) { unset ( $ arr [ $ tmp ] ) ; } } $ this - > set ( $ key , $ arr , $ option ) ; } 
public function get ( string $ name , $ defaults = null , array $ option = [ ] ) { $ option = $ this - > normalize Options ( $ option ) ; if ( isset ( $ this - > cookies [ $ name ] ) ) { if ( $ this - > is Json ( $ this - > cookies [ $ name ] [ 1 ] ) ) { return json _decode ( $ this - > cookies [ $ name ] [ 1 ] , true ) ; } return $ this - > cookies [ $ name ] [ 1 ] ; } return $ defaults ; } 
public function delete ( string $ name , array $ option = [ ] ) : void { $ this - > set ( $ name , null , $ option ) ; } 
public function clear ( array $ option = [ ] ) : void { $ option = $ this - > normalize Options ( $ option ) ; foreach ( $ this - > cookies as $ key = > $ val ) { $ this - > delete ( $ key , $ option ) ; } } 
public static function format ( array $ cookie ) : string { if ( 7 ! = = count ( $ cookie ) ) { throw new Exception ( 'Invalid cookie data . ' ) ; } $ str = $ cookie [ 0 ] . ' = ' ; if ( ' ' = = = ( string ) $ cookie [ 1 ] ) { $ str . = 'deleted ; expires = ' . gmdate ( 'D , d -M -Y H :i :s T ' , time ( ) - 3 1 5 3 6 0 0 1 ) . ' ; Max -Age = 0 ' ; } else { $ str . = $ cookie [ 1 ] ; if ( 0 ! = = $ cookie [ 2 ] ) { $ str . = ' ; expires = ' . gmdate ( 'D , d -M -Y H :i :s T ' , $ cookie [ 2 ] ) . ' ; Max -Age = ' . ( $ cookie [ 2 ] - time ( ) ? : 0 ) ; } } if ( $ cookie [ 3 ] ) { $ str . = ' ; path = ' . $ cookie [ 3 ] ; } if ( $ cookie [ 4 ] ) { $ str . = ' ; domain = ' . $ cookie [ 4 ] ; } if ( true = = = $ cookie [ 5 ] ) { $ str . = ' ; secure ' ; } if ( true = = = $ cookie [ 6 ] ) { $ str . = ' ; httponly ' ; } return $ str ; } 
protected function make Connect Mysql ( array $ option = [ ] ) : Mysql { return new Mysql ( $ this - > normalize Connect Option ( 'mysql ' , $ option ) , $ this - > container - > make ( IDispatch : : class ) ) ; } 
protected function normalize Connect Option ( string $ connect , array $ extend Option = [ ] ) : array { return $ this - > parse Database Option ( parent : : normalize Connect Option ( $ connect , $ extend Option ) ) ; } 
protected function parse Database Option ( array $ option ) : array { $ temp = $ option ; $ type = [ 'distributed ' , 'separate ' , 'driver ' , 'master ' , 'slave ' ] ; foreach ( array _keys ( $ option ) as $ t ) { if ( in _array ( $ t , $ type , true ) ) { if ( isset ( $ temp [ $ t ] ) ) { unset ( $ temp [ $ t ] ) ; } } elseif ( isset ( $ option [ $ t ] ) ) { unset ( $ option [ $ t ] ) ; } } foreach ( [ 'master ' , 'slave ' ] as $ t ) { if ( ! is _array ( $ option [ $ t ] ) ) { $ e = sprintf ( 'Database option ` %s ` must be an array . ' , $ t ) ; throw new Invalid Argument Exception ( $ e ) ; } } $ option [ 'master ' ] = array _merge ( $ option [ 'master ' ] , $ temp ) ; if ( ! $ option [ 'distributed ' ] ) { $ option [ 'slave ' ] = [ ] ; } elseif ( $ option [ 'slave ' ] ) { if ( count ( $ option [ 'slave ' ] ) = = = count ( $ option [ 'slave ' ] , COUNT _RECURSIVE ) ) { $ option [ 'slave ' ] = [ $ option [ 'slave ' ] ] ; } foreach ( $ option [ 'slave ' ] as & $ slave ) { $ slave = array _merge ( $ slave , $ temp ) ; } } return $ option ; } 
protected function get Prev Render ( ) : string { if ( $ this - > page - > can Prev Render ( ) ) { return sprintf ( ' <li class = " %s " > <a aria -label = "Previous " href = " %s " > ' . ' <span aria -hidden = "true " > %s < /span > < /a > < /li > ' , 'justify ' = = = $ this - > option [ 'align ' ] ? 'previous ' : ' ' , $ this - > replace ( $ this - > page - > parse Prev Render Prev ( ) ) , _ _ ( ' 上 一 页 ' ) ) ; } return sprintf ( ' <li class = "disabled %s " > <a aria -label = "Previous " > ' . ' <span aria -hidden = "true " > %s < /span > < /a > < /li > ' , 'justify ' = = = $ this - > option [ 'align ' ] ? ' previous ' : ' ' , _ _ ( ' 上 一 页 ' ) ) ; } 
protected function get Next Render ( ) : string { if ( $ this - > page - > can Next Render ( ) ) { return sprintf ( ' <li class = " %s " > <a aria -label = "Next " href = " %s " > ' . ' <span aria -hidden = "true " > %s < /span > < /a > < /li > ' , 'justify ' = = = $ this - > option [ 'align ' ] ? 'next ' : ' ' , $ this - > replace ( $ this - > page - > get Current Page ( ) + 1 ) , _ _ ( ' 下 一 页 ' ) ) ; } return sprintf ( ' <li class = "disabled %s " > <a aria -label = "Next " > ' . ' <span aria -hidden = "true " > %s < /span > < /a > < /li > ' , 'justify ' = = = $ this - > option [ 'align ' ] ? ' next ' : ' ' , _ _ ( ' 下 一 页 ' ) ) ; } 
public function next ( ) : void { $ next = next ( $ this - > elements ) ; $ this - > valid = false ! = = $ next ; } 
public function offset Set ( $ index , $ newval ) : void { $ this - > check Type ( $ newval ) ; $ this - > elements [ $ index ] = $ newval ; } 
public function offset Unset ( $ index ) : void { if ( isset ( $ this - > elements [ $ index ] ) ) { unset ( $ this - > elements [ $ index ] ) ; } } 
public function to Array ( ) : array { $ args = func _get _args ( ) ; return array _map ( function ( $ value ) use ( $ args ) { return $ value instanceof IArray ? $ value - > to Array ( . . . $ args ) : $ value ; } , $ this - > elements ) ; } 
public function json Serialize ( ) : array { return array _map ( function ( $ value ) { if ( $ value instanceof Json Serializable ) { return $ value - > json Serialize ( ) ; } if ( $ value instanceof IJson ) { return json _decode ( $ value - > to Json ( ) , true ) ; } if ( $ value instanceof IArray ) { return $ value - > to Array ( ) ; } return $ value ; } , $ this - > elements ) ; } 
public function each ( Closure $ callback ) : void { foreach ( $ this - > elements as $ key = > $ item ) { if ( false = = = $ callback ( $ item , $ key ) ) { break ; } } } 
protected function get Array Elements ( $ elements ) : array { if ( is _array ( $ elements ) ) { return $ elements ; } if ( $ elements instanceof self ) { return $ elements - > all ( ) ; } if ( $ elements instanceof IArray ) { return $ elements - > to Array ( ) ; } if ( $ elements instanceof IJson ) { return json _decode ( $ elements - > to Json ( ) , true ) ; } if ( $ elements instanceof Json Serializable ) { return $ elements - > json Serialize ( ) ; } if ( $ elements instanceof std Class ) { return json _decode ( json _encode ( $ elements ) , true ) ; } return [ $ elements ] ; } 
public function view ( string $ file , array $ vars = [ ] , ? string $ ext = null , int $ status = 2 0 0 , array $ headers = [ ] ) : Response { return $ this - > make ( $ this - > view - > display ( $ file , $ vars , $ ext ) , $ status , $ headers ) ; } 
public function view Success ( string $ message , string $ url = ' ' , int $ time = 1 , int $ status = 2 0 0 , array $ headers = [ ] ) : Response { $ vars = [ 'message ' = > $ message , 'url ' = > $ url , 'time ' = > $ time , ] ; return $ this - > view ( $ this - > view Success Template , $ vars , null , $ status , $ headers ) ; } 
public function view Fail ( string $ message , string $ url = ' ' , int $ time = 3 , int $ status = 4 0 4 , array $ headers = [ ] ) : Response { $ vars = [ 'message ' = > $ message , 'url ' = > $ url , 'time ' = > $ time , ] ; return $ this - > view ( $ this - > view Fail Template , $ vars , null , $ status , $ headers ) ; } 
public function jsonp ( string $ callback , $ data = null , int $ status = 2 0 0 , array $ headers = [ ] , bool $ json = false ) : Json Response { return $ this - > json ( $ data , $ status , $ headers , $ json ) - > set Callback ( $ callback ) ; } 
public function download ( $ file , string $ name = null , int $ status = 2 0 0 , array $ headers = [ ] , bool $ auto Etag = false , bool $ auto Last Modified = true ) : File Response { $ response = new File Response ( $ file , $ status , $ headers , Response Header Bag : : DISPOSITION _ATTACHMENT , $ auto Etag , $ auto Last Modified ) ; if ( null ! = = $ name ) { return $ response - > set Content Disposition ( Response Header Bag : : DISPOSITION _ATTACHMENT , $ name ) ; } return $ response ; } 
public function file ( $ file , int $ status = 2 0 0 , array $ headers = [ ] , bool $ auto Etag = false , bool $ auto Last Modified = true ) : File Response { return new File Response ( $ file , $ status , $ headers , Response Header Bag : : DISPOSITION _INLINE , $ auto Etag , $ auto Last Modified ) ; } 
public function redirect ( string $ url , array $ params = [ ] , string $ subdomain = 'www ' , $ suffix = null , int $ status = 3 0 2 , array $ headers = [ ] ) : Redirect Response { return $ this - > redirector - > url ( $ url , $ params , $ subdomain , $ suffix , $ status , $ headers ) ; } 
public function redirect Raw ( string $ url , int $ status = 3 0 2 , array $ headers = [ ] ) : Redirect Response { return $ this - > redirector - > raw ( $ url , $ status , $ headers ) ; } 
public function api Ok ( $ content = ' ' , ? string $ text = null ) : Api Response { return $ this - > create Api Response ( ) - > ok ( $ content , $ text ) ; } 
public function api Created ( ? string $ location = null , $ content = ' ' ) : Api Response { return $ this - > create Api Response ( ) - > created ( $ location , $ content ) ; } 
public function api Accepted ( ? string $ location = null , $ content = ' ' ) : Api Response { return $ this - > create Api Response ( ) - > accepted ( $ location , $ content ) ; } 
public function api Error ( string $ message , int $ status Code , ? string $ text = null ) : Api Response { return $ this - > create Api Response ( ) - > error ( $ message , $ status Code , $ text ) ; } 
public function api Bad Request ( ? string $ message = null , ? string $ text = null ) : Api Response { return $ this - > create Api Response ( ) - > bad Request ( $ message , $ text ) ; } 
public function api Unauthorized ( ? string $ message = null , ? string $ text = null ) : Api Response { return $ this - > create Api Response ( ) - > unauthorized ( $ message , $ text ) ; } 
public function api Forbidden ( ? string $ message = null , ? string $ text = null ) : Api Response { return $ this - > create Api Response ( ) - > forbidden ( $ message , $ text ) ; } 
public function api Not Found ( ? string $ message = null , ? string $ text = null ) : Api Response { return $ this - > create Api Response ( ) - > not Found ( $ message , $ text ) ; } 
public function api Method Not Allowed ( ? string $ message = null , ? string $ text = null ) : Api Response { return $ this - > create Api Response ( ) - > method Not Allowed ( $ message , $ text ) ; } 
public function api Unprocessable Entity ( ? array $ errors = null , ? string $ message = null , ? string $ text = null ) : Api Response { return $ this - > create Api Response ( ) - > unprocessable Entity ( $ errors , $ message , $ text ) ; } 
public function api Too Many Requests ( ? string $ message = null , ? string $ text = null ) : Api Response { return $ this - > create Api Response ( ) - > too Many Requests ( $ message , $ text ) ; } 
public function api Internal Server Error ( ? string $ message = null , ? string $ text = null ) : Api Response { return $ this - > create Api Response ( ) - > internal Server Error ( $ message , $ text ) ; } 
public function create Request ( IRequest $ leevel Request ) : Server Request Interface { $ server = normalize Server ( $ leevel Request - > server - > all ( ) ) ; $ headers = $ leevel Request - > headers - > all ( ) ; $ body = new Diactoros Stream ( $ this - > normalize Content ( $ leevel Request - > get Content ( ) ) ) ; $ request = new Server Request ( $ server , normalize Uploaded Files ( $ this - > get Files ( $ leevel Request - > files - > all ( ) ) ) , $ leevel Request - > get Scheme And Http Host ( ) . $ leevel Request - > get Request Uri ( ) , $ leevel Request - > get Method ( ) , $ body , $ headers ) ; $ request = $ request - > with Cookie Params ( $ leevel Request - > cookies - > all ( ) ) - > with Query Params ( $ leevel Request - > query - > all ( ) ) - > with Parsed Body ( $ leevel Request - > request - > all ( ) ) - > with Request Target ( $ leevel Request - > get Request Uri ( ) ) ; foreach ( $ leevel Request - > params - > all ( ) as $ key = > $ value ) { $ request = $ request - > with Attribute ( $ key , $ value ) ; } return $ request ; } 
public function create Response ( Response $ leevel Response ) : Response Interface { $ stream = new Diactoros Stream ( 'php : / /temp ' , 'wb + ' ) ; $ stream - > write ( $ leevel Response - > get Content ( ) ) ; $ headers = $ leevel Response - > headers - > all ( ) ; if ( ! isset ( $ headers [ 'Set -Cookie ' ] ) & & ! isset ( $ headers [ 'set -sookie ' ] ) & & $ cookies = $ leevel Response - > get Cookies ( ) ) { foreach ( $ cookies as $ item ) { $ headers [ 'Set -Cookie ' ] [ ] = Cookie : : format ( $ item ) ; } } $ response = new Diactoros Response ( $ stream , $ leevel Response - > get Status Code ( ) , $ headers ) ; $ protocol Version = $ leevel Response - > get Protocol Version ( ) ; if ( ' 1 . 1 ' ! = = $ protocol Version ) { $ response = $ response - > with Protocol Version ( $ protocol Version ) ; } return $ response ; } 
protected function normalize Content ( string $ content ) { $ resource = fopen ( 'php : / /temp ' , 'r + ' ) ; fwrite ( $ resource , $ content ) ; rewind ( $ resource ) ; return $ resource ; } 
protected function create Uploaded File ( Uploaded File $ leevel Uploaded File ) : Uploaded File Interface { return new Diactoros Uploaded File ( $ leevel Uploaded File - > get Real Path ( ) , ( int ) $ leevel Uploaded File - > get Size ( ) , $ leevel Uploaded File - > get Error ( ) , $ leevel Uploaded File - > get Original Name ( ) , $ leevel Uploaded File - > get Mime Type ( ) ) ; } 
public function handle ( IApp $ app , Router Provider $ router Provider ) : void { $ this - > line ( 'Start to cache router . ' ) ; $ data = $ router Provider - > get Routers ( ) ; $ cache Path = $ app - > router Cached Path ( ) ; $ this - > write Cache ( $ cache Path , $ data ) ; $ this - > info ( sprintf ( 'Router cache file %s cache successed . ' , $ cache Path ) ) ; } 
public function handle ( IServer $ server ) : void { while ( true ) { sleep ( 1 ) ; $ new Md 5 = $ this - > md 5 ( ) ; $ this - > count + + ; if ( $ this - > md 5 & & $ new Md 5 ! = = $ this - > md 5 ) { $ this - > log ( 'The Swoole server will reload . ' ) ; $ this - > count = 0 ; $ this - > reloading = true ; } if ( true = = = $ this - > reloading & & $ this - > count > $ this - > after ) { $ this - > reload ( $ server ) ; } $ this - > md 5 = $ new Md 5 ; } } 
protected function md 5 ( ) : string { $ md 5File = [ ] ; foreach ( $ this - > files ( ) as $ file ) { $ md 5File [ $ file ] = md 5 _file ( $ file ) ; } ksort ( $ md 5File ) ; return md 5 ( json _encode ( $ md 5File ) ) ; } 
protected function files ( ) : array { $ files = [ ] ; foreach ( ( array ) $ this - > option - > get ( 'swoole \ \hotoverload _watch ' ) as $ dir ) { if ( ! is _dir ( $ dir ) ) { continue ; } list _directory ( $ dir , true , function ( $ file ) use ( & $ files ) { if ( $ file - > is File ( ) ) { if ( in _array ( $ file - > get Extension ( ) , [ 'php ' ] , true ) ) { $ files [ ] = $ file - > get Path ( ) . ' / ' . $ file - > get Filename ( ) ; } } } ) ; } return $ files ; } 
protected function reload ( IServer $ server ) : void { $ this - > reloading = false ; $ this - > log ( 'The Swoole server is start reloading . ' ) ; $ server - > get Server ( ) - > reload ( ) ; $ this - > log ( 'The Swoole server has reloaded . ' ) ; } 
public function remember ( string $ name , $ data , array $ option = [ ] ) { if ( false ! = = ( $ result = $ this - > connect - > get ( $ name , false , $ option ) ) ) { return $ result ; } if ( is _object ( $ data ) & & $ data instanceof Closure ) { $ data = $ data ( $ name ) ; } $ this - > connect - > set ( $ name , $ data , $ option ) ; return $ data ; } 
protected function status ( array $ option ) : void { $ process Name = $ option [ 'process _name ' ] ; if ( $ this - > option ( 'all ' ) ) { $ item = ' $ 1 , $ 2 , $ 3 , $ 4 , $ 5 , $ 6 , $ 7 , $ 8 , $ 9 , $ 1 0 , $ 1 1 ' ; $ nikename = [ 
public function url ( string $ url , array $ params = [ ] , string $ subdomain = 'www ' , $ suffix = null , int $ status = 3 0 2 , array $ headers = [ ] ) : Redirect Response { $ url = $ this - > url - > make ( $ url , $ params , $ subdomain , $ suffix ) ; return $ this - > create Redirect Response ( $ url , $ status , $ headers ) ; } 
public function raw ( string $ url , int $ status = 3 0 2 , array $ headers = [ ] ) : Redirect Response { return $ this - > create Redirect Response ( $ url , $ status , $ headers ) ; } 
protected function create Redirect Response ( string $ url , int $ status = 3 0 2 , array $ headers = [ ] ) : Redirect Response { $ redirect = new Redirect Response ( $ url , $ status , $ headers ) ; if ( isset ( $ this - > session ) ) { $ redirect - > set Session ( $ this - > session ) ; } $ redirect - > set Request ( $ this - > url - > get Request ( ) ) ; return $ redirect ; } 
public function handle ( Closure $ next , IRequest $ request ) : void { if ( ! $ this - > manager - > is Login ( ) ) { throw new Auth Exception ( 'User authorization failed . ' ) ; } $ next ( $ request ) ; } 
public function password ( string $ password , array $ option = [ ] ) : string { $ algo = $ option [ self : : ALGO ] ? ? PASSWORD _BCRYPT ; return password _hash ( $ password , ( int ) $ algo , $ option ) ; } 
public function handle ( Closure $ next , IRequest $ request ) : void { if ( ! $ this - > app - > debug ( ) ) { $ next ( $ request ) ; return ; } $ this - > debug - > bootstrap ( ) ; $ next ( $ request ) ; } 
public function terminate ( Closure $ next , IRequest $ request , IResponse $ response ) : void { if ( ! $ this - > app - > debug ( ) ) { $ next ( $ request , $ response ) ; return ; } $ this - > debug - > handle ( $ request , $ response ) ; $ next ( $ request , $ response ) ; } 
public function handle ( ) : void { $ this - > line ( 'Start to optimize you app . ' ) ; $ this - > call Router ( ) ; $ this - > call Option ( ) ; $ this - > call I 1 8n ( ) ; $ this - > call View ( ) ; $ this - > call Autoload ( ) ; $ this - > line ( ' ' ) ; $ this - > info ( 'Optimize successed . ' ) ; } 
public function register ( ) : void { $ this - > router ( ) ; $ this - > url ( ) ; $ this - > redirect ( ) ; $ this - > response ( ) ; $ this - > view ( ) ; } 
protected function url ( ) : void { $ this - > container - > singleton ( 'url ' , function ( IContainer $ container ) { $ option = $ container [ 'option ' ] ; $ router = $ container [ 'router ' ] ; $ options = [ ] ; foreach ( [ 'with _suffix ' , 'suffix ' , 'domain ' , ] as $ item ) { $ options [ $ item ] = $ option - > get ( $ item ) ; } return new Url ( $ container [ 'request ' ] , $ options ) ; } ) ; } 
protected function redirect ( ) : void { $ this - > container - > singleton ( 'redirect ' , function ( IContainer $ container ) { $ redirect = new Redirect ( $ container [ 'url ' ] ) ; if ( isset ( $ container [ 'session ' ] ) ) { $ redirect - > set Session ( $ container [ 'session ' ] ) ; } return $ redirect ; } ) ; } 
protected function response ( ) : void { $ this - > container - > singleton ( 'response ' , function ( IContainer $ container ) { $ option = $ container [ 'option ' ] ; return ( new Response Factory ( $ container [ 'view ' ] , $ container [ 'redirect ' ] ) ) - > set View Success Template ( $ option - > get ( 'view \ \success ' ) ) - > set View Fail Template ( $ option - > get ( 'view \ \fail ' ) ) ; } ) ; } 
public function handle ( IRequest $ request ) : IResponse { try { $ this - > register Base Service ( $ request ) ; $ this - > bootstrap ( ) ; $ response = $ this - > get Response With Request ( $ request ) ; $ this - > middleware Terminate ( $ request , $ response ) ; } catch ( Exception $ e ) { $ this - > report Exception ( $ e ) ; $ response = $ this - > render Exception ( $ request , $ e ) ; } catch ( Throwable $ e ) { $ e = new Error Exception ( $ e - > get Message ( ) , $ e - > get Code ( ) , E _ERROR , $ e - > get File ( ) , $ e - > get Line ( ) , $ e - > get Previous ( ) ) ; $ this - > report Exception ( $ e ) ; $ response = $ this - > render Exception ( $ request , $ e ) ; } return $ response ; } 
protected function render Exception ( IRequest $ request , Exception $ e ) : IResponse { return $ this - > get Runtime ( ) - > render ( $ request , $ e ) ; } 
protected function middleware Terminate ( IRequest $ request , IResponse $ response ) : void { $ this - > router - > through Middleware ( $ request , [ $ response , ] ) ; } 
public function set Option ( string $ name , $ value ) : ILog { $ this - > option [ $ name ] = $ value ; return $ this ; } 
public function log ( string $ level , string $ message , array $ context = [ ] ) : void { if ( ! in _array ( $ level , $ this - > option [ 'levels ' ] , true ) ) { return ; } $ data = [ $ level , $ message , $ context ] ; $ this - > handle Dispatch ( $ data ) ; $ this - > count + + ; $ this - > logs [ $ level ] [ ] = $ data ; if ( false = = = $ this - > option [ 'buffer ' ] | | ( $ this - > option [ 'buffer _size ' ] & & $ this - > count > = $ this - > option [ 'buffer _size ' ] ) ) { $ this - > flush ( ) ; } } 
public function flush ( ) : void { foreach ( $ this - > logs as $ data ) { $ this - > save Store ( $ data ) ; } $ this - > clear ( ) ; } 
public function clear ( ? string $ level = null ) : void { if ( null = = = $ level ) { $ this - > count = 0 ; $ this - > logs = [ ] ; } if ( isset ( $ this - > logs [ $ level ] ) ) { $ this - > count - = count ( $ this - > logs [ $ level ] ) ; $ this - > logs [ $ level ] = [ ] ; } } 
public function all ( ? string $ level = null ) : array { if ( null = = = $ level ) { return $ this - > logs ; } if ( isset ( $ this - > logs [ $ level ] ) ) { return $ this - > logs [ $ level ] ; } return [ ] ; } 
public function count ( ? string $ level = null ) : int { if ( null = = = $ level ) { return $ this - > count ; } return count ( $ this - > all ( $ level ) ) ; } 
protected function handle Dispatch ( array $ data ) : void { if ( $ this - > dispatch ) { $ this - > dispatch - > handle ( self : : LOG _EVENT , . . . $ data ) ; } } 
public function bootstrap ( IDispatch $ dispatch ) : void { foreach ( $ this - > get ( ) as $ event = > $ listeners ) { foreach ( $ listeners as $ key = > $ item ) { if ( is _int ( $ item ) ) { $ dispatch - > register ( $ event , $ key , $ item ) ; } else { $ dispatch - > register ( $ event , $ item ) ; } } } } 
public function data ( $ names , array $ option = [ ] , bool $ force = false ) : array { $ names = is _array ( $ names ) ? $ names : [ $ names , ] ; foreach ( $ names as $ name ) { if ( ! isset ( $ this - > cache Loaded [ $ name ] ) | | $ force ) { $ this - > cache Loaded [ $ name ] = $ this - > cache ( $ name , $ option , $ force ) ; } } $ result = [ ] ; foreach ( $ names as $ name ) { $ result [ $ name ] = $ this - > cache Loaded [ $ name ] ; } return count ( $ result ) > 1 ? $ result : reset ( $ result ) ; } 
public function refresh ( $ names ) : void { $ tmp = is _array ( $ names ) ? $ names : [ $ names , ] ; foreach ( $ tmp as $ name ) { $ this - > delete ( $ name ) ; } } 
public function data Loaded ( $ names , array $ option = [ ] , bool $ force = false ) { $ result = [ ] ; $ names = is _array ( $ names ) ? $ names : [ $ names , ] ; foreach ( $ names as $ name ) { $ result [ $ name ] = array _key _exists ( $ name , $ this - > cache Loaded ) ? $ this - > cache Loaded [ $ name ] : false ; } return count ( $ result ) > 1 ? $ result : reset ( $ result ) ; } 
protected function cache ( string $ name , array $ option = [ ] , bool $ force = false ) { if ( false = = = $ force ) { $ data = $ this - > get Persistence ( $ name , false , $ option ) ; } else { $ data = false ; } if ( false = = = $ data ) { $ data = $ this - > update ( $ name , $ option ) ; } return $ data ; } 
protected function update ( string $ name , array $ option = [ ] ) { $ source Name = $ name ; list ( $ name , $ params ) = $ this - > parse ( $ name ) ; if ( false ! = = strpos ( $ name , ' @ ' ) ) { list ( $ name , $ method ) = explode ( ' @ ' , $ name ) ; } else { $ method = 'handle ' ; } if ( ! is _object ( $ cache = $ this - > container - > make ( $ name ) ) ) { throw new Invalid Argument Exception ( sprintf ( 'Cache %s is not valid . ' , $ name ) ) ; } if ( ! is _callable ( [ $ cache , $ method ] ) ) { throw new Invalid Argument Exception ( sprintf ( 'Cache %s is not a callable . ' , $ name . ' @ ' . $ method ) ) ; } $ source Data = $ cache - > { $ method } ( . . . $ params ) ; $ this - > set Persistence ( $ source Name , $ source Data , $ option ) ; return $ source Data ; } 
protected function get Persistence ( string $ name , $ defaults = false , array $ option = [ ] ) { return $ this - > cache - > get ( $ name , $ defaults , $ option ) ; } 
protected function set Persistence ( string $ name , $ data , array $ option = [ ] ) : void { $ this - > cache - > set ( $ name , $ data , $ option ) ; } 
public static function without Relation Condition ( Closure $ return Relation ) : self { $ old = static : : $ relation Condition ; static : : $ relation Condition = false ; $ relation = call _user _func ( $ return Relation ) ; static : : $ relation Condition = $ old ; return $ relation ; } 
protected function get Entity Key ( array $ entitys , ? string $ key = null ) : array { return array _unique ( array _values ( array _map ( function ( $ entity ) use ( $ key ) { return $ key ? $ entity - > _ _get ( $ key ) : $ entity - > single Id ( ) ; } , $ entitys ) ) ) ; } 
public function register ( ) : void { $ this - > container - > singleton ( 'encryption ' , function ( IContainer $ container ) { $ option = $ container [ 'option ' ] ; return new Encryption ( $ option [ 'auth _key ' ] , $ option [ 'auth _cipher ' ] , $ option [ 'auth _rsa _private ' ] , $ option [ 'auth _rsa _public ' ] ) ; } ) ; } 
public function send Headers ( ) : IResponse { if ( headers _sent ( ) ) { return $ this ; } 
public function set Content ( $ content ) : IResponse { if ( $ this - > check Flow Control ( ) ) { return $ this ; } $ this - > original = $ content ; if ( $ this - > content Should Json ( $ content ) ) { $ this - > set Header ( 'Content -Type ' , 'application /json ' ) ; $ this - > is Json = true ; $ content = $ this - > content To Json ( $ content ) ; } if ( null ! = = $ content & & ! is _scalar ( $ content ) & & ! is _callable ( [ $ content , ' _ _to String ' ] ) ) { $ e = sprintf ( 'The Response content must be a scalar or object implementing _ _to String ( ) , %s given . ' , gettype ( $ content ) ) ; throw new Unexpected Value Exception ( $ e ) ; } $ this - > content = ( string ) $ content ; return $ this ; } 
public function append Content ( string $ content = null ) : IResponse { if ( $ this - > check Flow Control ( ) ) { return $ this ; } $ this - > content = $ this - > get Content ( ) . $ content ; return $ this ; } 
public function set Header ( string $ key , string $ value , bool $ replace = true ) : IResponse { if ( $ this - > check Flow Control ( ) ) { return $ this ; } if ( true = = = $ replace | | ! $ this - > headers - > has ( $ key ) ) { $ this - > headers - > set ( $ key , $ value ) ; } return $ this ; } 
public function with Headers ( array $ headers ) : IResponse { if ( $ this - > check Flow Control ( ) ) { return $ this ; } foreach ( $ headers as $ key = > $ value ) { $ this - > headers - > set ( $ key , $ value ) ; } return $ this ; } 
public function cookie ( string $ name , string $ value = ' ' , array $ option = [ ] ) : IResponse { return $ this - > set Cookie ( $ name , $ value , $ option ) ; } 
public function set Cookie ( string $ name , string $ value = ' ' , array $ option = [ ] ) : IResponse { if ( $ this - > check Flow Control ( ) ) { return $ this ; } $ this - > headers - > set Cookie ( $ name , $ value , $ option ) ; return $ this ; } 
public function with Cookies ( array $ cookies , array $ option = [ ] ) : IResponse { if ( $ this - > check Flow Control ( ) ) { return $ this ; } foreach ( $ cookies as $ key = > $ value ) { $ this - > set Cookie ( $ key , $ value , $ option ) ; } return $ this ; } 
public function get Data ( bool $ assoc = true , int $ depth = 5 1 2 ) { if ( $ this - > is Json ) { return json _decode ( $ this - > content , $ assoc , $ depth ) ; } return $ this - > content ; } 
public function set Data ( $ data = [ ] , ? int $ encoding Options = null ) : IResponse { if ( $ this - > check Flow Control ( ) ) { return $ this ; } $ this - > original = $ data ; if ( null = = = $ encoding Options ) { $ encoding Options = 2 5 6 ; } if ( $ data instanceof IArray ) { $ data = json _encode ( $ data - > to Array ( ) , $ encoding Options ) ; } elseif ( is _object ( $ data ) & & $ data instanceof IJson ) { $ data = $ data - > to Json ( $ encoding Options ) ; } elseif ( is _object ( $ data ) & & $ data instanceof Json Serializable ) { $ data = json _encode ( $ data - > json Serialize ( ) , $ encoding Options ) ; } else { $ data = json _encode ( $ data , $ encoding Options ) ; } if ( JSON _ERROR _NONE ! = = json _last _error ( ) ) { throw new Invalid Argument Exception ( json _last _error _msg ( ) ) ; } $ this - > content = ( string ) $ data ; return $ this ; } 
public function set Protocol Version ( string $ protocol Version ) : IResponse { if ( $ this - > check Flow Control ( ) ) { return $ this ; } $ this - > protocol Version = $ protocol Version ; return $ this ; } 
public function set Status Code ( int $ code , ? string $ text = null ) : IResponse { if ( $ this - > check Flow Control ( ) ) { return $ this ; } $ this - > status Code = $ code ; if ( $ this - > is Invalid ( ) ) { $ e = sprintf ( 'The HTTP status code %s is not valid . ' , $ code ) ; throw new Invalid Argument Exception ( $ e ) ; } if ( null = = = $ text ) { $ this - > status Text = self : : $ status Texts [ $ code ] ? ? 'unknown status ' ; return $ this ; } $ this - > status Text = $ text ; return $ this ; } 
public function charset ( string $ charset ) : IResponse { if ( $ this - > check Flow Control ( ) ) { return $ this ; } $ this - > charset = $ charset ; return $ this ; } 
public function set Last Modified ( Date Time $ datetime = null ) : IResponse { if ( $ this - > check Flow Control ( ) ) { return $ this ; } if ( null = = = $ datetime ) { $ this - > headers - > remove ( 'Last -Modified ' ) ; return $ this ; } $ this - > set Header ( 'Last -Modified ' , $ this - > normalize Date Time ( $ datetime ) ) ; return $ this ; } 
public function set Cache ( int $ minutes ) : IResponse { if ( $ this - > check Flow Control ( ) ) { return $ this ; } $ date = new Date Time ( ) ; $ date - > modify ( ' + ' . $ minutes . 'minutes ' ) ; $ this - > set Expires ( $ date ) ; $ this - > set Header ( 'Cache -Control ' , 'max -age = ' . ( $ minutes * 6 0 ) ) ; return $ this ; } 
public function set Not Modified ( ) : IResponse { if ( $ this - > check Flow Control ( ) ) { return $ this ; } $ this - > set Status Code ( 3 0 4 , self : : $ status Texts [ 3 0 4 ] ) ; return $ this ; } 
public function set Content Type ( string $ content Type , ? string $ charset = null ) : IResponse { if ( $ this - > check Flow Control ( ) ) { return $ this ; } if ( null = = = $ charset ) { $ charset = $ this - > get Charset ( ) ; } if ( null = = = $ charset ) { $ this - > set Header ( 'Content -Type ' , $ content Type ) ; } else { $ this - > set Header ( 'Content -Type ' , $ content Type . ' ; charset = ' . $ charset ) ; } return $ this ; } 
public function set Content Length ( int $ content Length ) : IResponse { if ( $ this - > check Flow Control ( ) ) { return $ this ; } $ this - > set Header ( 'Content -Length ' , ( string ) $ content Length ) ; return $ this ; } 
public function set Etag ( string $ etag ) : IResponse { if ( $ this - > check Flow Control ( ) ) { return $ this ; } $ this - > set Header ( 'Etag ' , $ etag ) ; return $ this ; } 
protected function normalize Date Time ( Date Time $ datetime ) : string { $ date = clone $ datetime ; $ date - > set Timezone ( new Date Time Zone ( 'UTC ' ) ) ; return $ date - > format ( 'D , d M Y H :i :s ' ) . ' GMT ' ; } 
protected function content To Json ( $ content ) : string { if ( $ content instanceof IJson ) { return $ content - > to Json ( ) ; } if ( $ content instanceof IArray ) { $ content = $ content - > to Array ( ) ; } return json _encode ( $ content , JSON _UNESCAPED _UNICODE ) ; } 
protected function content Should Json ( $ content ) : bool { return $ content instanceof IJson | | $ content instanceof IArray | | $ content instanceof Array Object | | $ content instanceof Json Serializable | | is _array ( $ content ) ; } 
public function add Relation Condition ( ) : void { if ( static : : $ relation Condition ) { $ this - > select - > where ( $ this - > target Key , $ this - > get Source Value ( ) ) ; } } 
public function match Pre Load ( array $ entitys , Collection $ result , string $ relation ) : array { $ maps = $ this - > build Map ( $ result ) ; foreach ( $ entitys as $ value ) { $ key = $ value - > _ _get ( $ this - > source Key ) ; if ( isset ( $ maps [ $ key ] ) ) { $ value - > with Relation Prop ( $ relation , $ maps [ $ key ] ) ; } } return $ entitys ; } 
public function pre Load Condition ( array $ entitys ) : void { $ this - > select - > where In ( $ this - > target Key , $ this - > get Pre Load Entity Value ( $ entitys ) ) ; } 
protected function build Map ( Collection $ result ) : array { $ maps = [ ] ; foreach ( $ result as $ entity ) { $ maps [ $ entity - > _ _get ( $ this - > target Key ) ] = $ entity ; } return $ maps ; } 
protected function get Pre Load Entity Value ( array $ entitys ) : array { $ arr = [ ] ; foreach ( $ entitys as $ value ) { if ( null ! = = ( $ tmp = $ value - > _ _get ( $ this - > source Key ) ) ) { $ arr [ ] = $ tmp ; } } if ( 0 = = = count ( $ arr ) ) { return [ 0 ] ; } return array _values ( array _unique ( $ arr ) ) ; } 
public function handle ( ) : void { $ this - > warn ( $ this - > get Version ( ) ) ; $ server = $ this - > create Server ( ) ; $ this - > reload ( $ server - > get Option ( ) ) ; } 
protected function reload ( array $ option ) : void { $ pid File = $ option [ 'pid _path ' ] ; $ process Name = $ option [ 'process _name ' ] ; if ( ! file _exists ( $ pid File ) ) { throw new Invalid Argument Exception ( sprintf ( 'Pid path ` %s ` was not found . ' , $ pid File ) ) ; } $ pids = explode ( PHP _EOL , file _get _contents ( $ pid File ) ) ; $ pid = ( int ) $ pids [ 0 ] ; if ( ! Process : : kill ( $ pid , 0 ) ) { throw new Invalid Argument Exception ( sprintf ( 'Pid ` %s ` was not found . ' , $ pid ) ) ; } Process : : kill ( $ pid , $ this - > option ( 'all ' ) ? SIGUSR 1 : SIGUSR 2 ) ; 
public function ok ( $ content = ' ' , ? string $ text = null ) : IResponse { if ( $ this - > check Flow Control ( ) ) { return $ this ; } $ this - > set Status Code ( static : : HTTP _OK , $ text ) ; return $ this - > set Data ( $ content ) ; } 
public function created ( ? string $ location = null , $ content = ' ' ) : IResponse { if ( $ this - > check Flow Control ( ) ) { return $ this ; } $ this - > set Data ( $ content ) ; $ this - > set Status Code ( static : : HTTP _CREATED ) ; if ( null ! = = $ location ) { $ this - > set Header ( 'Location ' , $ location ) ; } return $ this ; } 
public function accepted ( ? string $ location = null , $ content = ' ' ) : IResponse { if ( $ this - > check Flow Control ( ) ) { return $ this ; } $ this - > set Data ( $ content ) ; $ this - > set Status Code ( static : : HTTP _ACCEPTED ) ; if ( null ! = = $ location ) { $ this - > set Header ( 'Location ' , $ location ) ; } return $ this ; } 
public function unprocessable Entity ( ? array $ errors = null , ? string $ message = null , ? string $ text = null ) : IResponse { if ( $ this - > check Flow Control ( ) ) { return $ this ; } $ this - > set Status Code ( static : : HTTP _UNPROCESSABLE _ENTITY , $ text ) ; $ this - > set Data ( [ 'message ' = > $ this - > parse Error Message ( $ message ) , 'errors ' = > $ errors ? : [ ] , ] ) ; return $ this ; } 
public function error ( ? string $ message , int $ status Code , ? string $ text = null ) : IResponse { if ( $ this - > check Flow Control ( ) ) { return $ this ; } $ this - > set Status Code ( $ status Code , $ text ) ; return $ this - > normalize Error Message ( $ message ) ; } 
public function bad Request ( ? string $ message = null , ? string $ text = null ) : IResponse { return $ this - > error ( $ message , static : : HTTP _BAD _REQUEST , $ text ) ; } 
public function unauthorized ( ? string $ message = null , ? string $ text = null ) : IResponse { return $ this - > error ( $ message , static : : HTTP _UNAUTHORIZED , $ text ) ; } 
public function forbidden ( ? string $ message = null , ? string $ text = null ) : IResponse { return $ this - > error ( $ message , static : : HTTP _FORBIDDEN , $ text ) ; } 
public function not Found ( ? string $ message = null , ? string $ text = null ) : IResponse { return $ this - > error ( $ message , static : : HTTP _NOT _FOUND , $ text ) ; } 
public function method Not Allowed ( ? string $ message = null , ? string $ text = null ) : IResponse { return $ this - > error ( $ message , static : : HTTP _METHOD _NOT _ALLOWED , $ text ) ; } 
public function too Many Requests ( ? string $ message = null , ? string $ text = null ) : IResponse { return $ this - > error ( $ message , static : : HTTP _TOO _MANY _REQUESTS , $ text ) ; } 
public function internal Server Error ( ? string $ message = null , ? string $ text = null ) : IResponse { return $ this - > error ( $ message , static : : HTTP _INTERNAL _SERVER _ERROR , $ text ) ; } 
protected function normalize Error Message ( ? string $ message = null , ? string $ text = null ) : IResponse { return $ this - > set Data ( [ 'message ' = > $ this - > parse Error Message ( $ message ) , ] ) ; } 
public function verify Response Content ( $ response Content ) { 
public function get Translation ( ) { if ( sizeof ( $ this - > response Content - > translations ) = = = 0 ) { return null ; } $ translated Text = ' ' ; $ line Breaks = $ this - > line Breaks ; 
public function get Translation Alternatives ( ) { if ( sizeof ( $ this - > response Content - > translations ) = = = 0 ) { return [ ] ; } if ( sizeof ( $ this - > response Content - > translations ) > 1 ) { throw new \ Logic Exception ( 'This method does not operate on more than one source text ' , 2 9 0 ) ; } $ beams = $ this - > response Content - > translations [ 0 ] - > beams ; $ translation Alternatives = [ ] ; foreach ( $ beams as $ beam ) { $ translation Alternatives [ ] = $ beam - > postprocessed _sentence ; } return $ translation Alternatives ; } 
public function get Translated Sentences ( ) { $ translated Texts = [ ] ; foreach ( $ this - > response Content - > translations as $ translation ) { 
public function call Api ( $ url , array $ payload , $ method ) { if ( ! is _string ( $ url ) ) { throw new \ Invalid Argument Exception ( ' $url has to be a string ' ) ; } if ( ! is _string ( $ method ) ) { throw new \ Invalid Argument Exception ( ' $method has to be a string ' ) ; } $ json Data = $ this - > protocol - > create Request Data ( $ payload , $ method ) ; $ options = [ 'body ' = > $ json Data ] ; try { $ guzzle Response = $ this - > guzzle - > post ( $ url , $ options ) ; } catch ( Guzzle Exception $ exception ) { $ call Exception = new Call Exception ( 'c URL error during Deep Ly API call : ' . $ exception - > get Message ( ) ) ; throw $ call Exception ; } $ code = $ guzzle Response - > get Status Code ( ) ; if ( $ code ! = = 2 0 0 ) { 
public function ping ( $ url ) { if ( ! is _string ( $ url ) ) { throw new \ Invalid Argument Exception ( ' $url has to be a string ' ) ; } try { $ started At = microtime ( true ) ; $ this - > guzzle - > get ( $ url ) ; $ duration = microtime ( true ) - $ started At ; } catch ( Guzzle Exception $ exception ) { throw new Call Exception ( 'Did not get a valid response . API seems to be unreachable . ' ) ; } return $ duration ; } 
public function create Request Data ( array $ payload , $ method ) { if ( ! is _string ( $ method ) ) { throw new \ Invalid Argument Exception ( 'The $method argument has to be null or of type string ' ) ; } 
public function process Response Data ( $ raw Response Data ) { if ( ! is _string ( $ raw Response Data ) ) { throw new \ Invalid Argument Exception ( 'The $raw Response Data argument has to be a string ' ) ; } $ response Data = json _decode ( $ raw Response Data ) ; $ this - > validate Response Data ( $ response Data ) ; 
protected function validate Response Data ( $ response Data ) { if ( ! $ response Data instanceof \ std Class ) { throw new Protocol Exception ( 'Deep Ly API call did not return JSON that describes a \std Class object ' ) ; } if ( ! property _exists ( $ response Data , 'jsonrpc ' ) ) { throw new Protocol Exception ( ' The given response data does not seem to be come from a JSON RPC request - it has no "jsonrpc " property ' ) ; } if ( $ response Data - > jsonrpc ! = = self : : PROTOCOL _VERSION ) { throw new Protocol Exception ( 'The version of the JSON RPC response does not match the expected version ' . self : : PROTOCOL _VERSION ) ; } if ( property _exists ( $ response Data , 'error ' ) ) { if ( $ response Data - > error instanceof \ std Class and property _exists ( $ response Data - > error , 'message ' ) ) { $ message = 'Deep Ly API call resulted in this error : ' . $ response Data - > error - > message ; 
public function call Api ( $ url , array $ payload , $ method ) { if ( ! is _string ( $ url ) ) { throw new \ Invalid Argument Exception ( ' $url has to be a string ' ) ; } if ( ! is _string ( $ method ) ) { throw new \ Invalid Argument Exception ( ' $method has to be a string ' ) ; } $ json Data = $ this - > protocol - > create Request Data ( $ payload , $ method ) ; $ curl = curl _init ( $ url ) ; curl _setopt ( $ curl , CURLOPT _CUSTOMREQUEST , 'POST ' ) ; curl _setopt ( $ curl , CURLOPT _POSTFIELDS , $ json Data ) ; curl _setopt ( $ curl , CURLOPT _RETURNTRANSFER , true ) ; curl _setopt ( $ curl , CURLOPT _SSL _VERIFYPEER , $ this - > ssl Verify Peer ) ; 
protected function get Text From Html ( $ html Code ) { $ document = new \ DOMDocument ( ) ; $ okay = $ document - > load HTML ( $ html Code ) ; 
public function ping ( $ url ) { if ( ! is _string ( $ url ) ) { throw new \ Invalid Argument Exception ( ' $url has to be a string ' ) ; } $ curl = curl _init ( $ url ) ; 
public function verify Response Content ( $ response Content ) { 
public function get All Sentences ( ) { $ split Texts = $ this - > response Content - > splitted _texts ; $ sentences = [ ] ; foreach ( $ split Texts as $ split Text ) { foreach ( $ split Text as $ sentence ) { $ sentences [ ] = $ sentence ; } } return $ sentences ; } 
public function request Split Text ( $ text , $ from = self : : LANG _AUTO ) { if ( ! is _string ( $ text ) and ! is _array ( $ text ) ) { throw new \ Invalid Argument Exception ( 'The $text argument has to be a string or an array of strings ' ) ; } if ( is _array ( $ text ) ) { foreach ( $ text as $ index = > $ part ) { if ( ! is _string ( $ part ) ) { throw new \ Invalid Argument Exception ( 'If the $text argument is an array it ha to be an array of strings , but the ' . ( $ index + 1 ) . ' . item is not a string ' ) ; } } } else { $ text = [ $ text ] ; } $ params = [ 'texts ' = > $ text , 'lang ' = > [ 'lang _user _selected ' = > $ from ] ] ; $ raw Response Data = $ this - > http Client - > call Api ( self : : API _BASE _URL , $ params , self : : METHOD _SPLIT ) ; $ response Content = $ this - > protocol - > process Response Data ( $ raw Response Data ) ; $ split Text Bag = new Sentences Bag ( $ response Content ) ; return $ split Text Bag ; } 
public function split Text ( $ text , $ from = self : : LANG _AUTO ) { $ split Text Bag = $ this - > request Split Text ( $ text , $ from ) ; $ sentences = $ split Text Bag - > get All Sentences ( ) ; return $ sentences ; } 
public function detect Language ( $ text ) { 
protected function request Translation ( $ text , $ to = self : : LANG _EN , $ from = self : : LANG _AUTO ) { $ this - > translation Bag = null ; if ( ! is _string ( $ text ) and ! is _array ( $ text ) ) { throw new \ Invalid Argument Exception ( 'The $text argument has to be a string or an array ' ) ; } if ( is _array ( $ text ) ) { foreach ( $ text as $ index = > $ sentence ) { if ( ! is _string ( $ sentence ) ) { throw new \ Invalid Argument Exception ( 'The $text argument has to be a string or an array of strings . ' . 'The ' . ( + + $ index ) . ' . item of the array is not a string . ' ) ; } 
public function translate ( $ text , $ to = self : : LANG _EN , $ from = self : : LANG _AUTO ) { $ translation Bag = $ this - > request Translation ( $ text , $ to , $ from ) ; return $ translation Bag - > get Translation ( ) ; } 
public function propose Translations ( $ text , $ to = self : : LANG _EN , $ from = self : : LANG _AUTO ) { $ translation Bag = $ this - > request Translation ( $ text , $ to , $ from ) ; return $ translation Bag - > get Translation Alternatives ( ) ; } 
public function translate Sentences ( array $ sentences , $ to = self : : LANG _EN , $ from = self : : LANG _AUTO , $ join = false ) { $ translation Bag = $ this - > request Translation ( $ sentences , $ to , $ from ) ; $ translated Sentences = $ translation Bag - > get Translated Sentences ( ) ; if ( $ join ) { return implode ( ' ' , $ translated Sentences ) ; } return $ translated Sentences ; } 
public function translate File ( $ filename , $ to = self : : LANG _EN , $ from = self : : LANG _AUTO ) { if ( ! is _string ( $ filename ) ) { throw new \ Invalid Argument Exception ( 'The $filename argument has to be a string ' ) ; } if ( ! is _readable ( $ filename ) ) { throw new \ Invalid Argument Exception ( 'Could not read file with the given filename ' ) ; } $ text = file _get _contents ( $ filename ) ; if ( $ text = = = false ) { throw new \ Runtime Exception ( 'Could not read file with the given filename . Does this file exist and do we have read permission ? ' ) ; } return $ this - > translate ( $ text , $ to , $ from ) ; } 
public function supports Lang Code ( $ lang Code , $ allow Auto = false ) { if ( ! is _string ( $ lang Code ) ) { throw new \ Invalid Argument Exception ( 'The $lang Code argument has to be a string ' ) ; } $ supported = in _array ( $ lang Code , $ this - > get Lang Codes ( $ allow Auto ) ) ; return $ supported ; } 
public function get Lang Codes ( $ with Auto = true ) { if ( ! is _bool ( $ with Auto ) ) { throw new \ Invalid Argument Exception ( 'The $with Auto argument has to be boolean ' ) ; } if ( $ with Auto ) { return self : : LANG _CODES ; } 
public function get Lang Name ( $ lang Code ) { if ( ! in _array ( $ lang Code , self : : LANG _CODES ) ) { throw new \ Invalid Argument Exception ( 'The language code is unknown ' ) ; } return self : : LANG _NAMES [ $ lang Code ] ; } 
public function get Lang Code By Name ( $ lang Name ) { if ( ! in _array ( $ lang Name , self : : LANG _NAMES ) ) { throw new \ Invalid Argument Exception ( 'The language name is unknown ' ) ; } return array _search ( $ lang Name , self : : LANG _NAMES ) ; } 
public function verify Response Content ( $ response Content ) { if ( ! $ response Content instanceof \ std Class ) { throw new Bag Exception ( 'Deep Ly API call did not return JSON that describes a \std Class object ' , 1 0 ) ; } if ( property _exists ( $ response Content , 'error ' ) ) { if ( $ response Content - > error instanceof \ std Class and property _exists ( $ response Content - > error , 'message ' ) ) { throw new Bag Exception ( 'Deep Ly API call resulted in this error : ' . $ response Content - > error - > message , 2 0 ) ; } else { throw new Bag Exception ( 'Deep Ly API call resulted in an unknown error ' , 2 1 ) ; } } } 
public function get Defaults ( array $ overrides = null ) : array { if ( empty ( $ overrides ) ) { return $ this - > defaults ; } $ diff = array _diff _key ( $ overrides , $ this - > fields ) ; if ( ! empty ( $ diff ) ) { throw new Simple Crud Exception ( sprintf ( 'The field %s does not exist in the table %s ' , implode ( array _keys ( $ diff ) ) , $ this ) ) ; } return $ overrides + $ this - > defaults ; } 
public function cache ( Row $ row ) : Row { if ( $ row - > id ) { $ this - > cache [ $ row - > id ] = $ row ; } return $ row ; } 
public function get Cached ( $ id ) : ? Row { if ( ! $ this - > is Cached ( $ id ) ) { return null ; } $ row = $ this - > cache [ $ id ] ; if ( $ row & & ! $ row - > id ) { return $ this - > cache [ $ id ] = null ; } return $ row ; } 
public function offset Exists ( $ offset ) : bool { if ( $ this - > is Cached ( $ offset ) ) { return $ this - > get Cached ( $ offset ) ! = = null ; } return $ this - > select Aggregate ( 'COUNT ' ) - > where ( 'id = ' , $ offset ) - > limit ( 1 ) - > run ( ) = = = 1 ; } 
public function offset Get ( $ offset ) : ? Row { if ( $ this - > is Cached ( $ offset ) ) { return $ this - > get Cached ( $ offset ) ; } return $ this - > cache [ $ offset ] = $ this - > select ( ) - > one ( ) - > where ( 'id = ' , $ offset ) - > run ( ) ; } 
public function offset Set ( $ offset , $ value ) : Row { 
public function offset Unset ( $ offset ) { $ this - > cache [ $ offset ] = null ; $ this - > delete ( ) - > where ( 'id = ' , $ offset ) - > run ( ) ; } 
public function get Join Field ( Table $ table ) : ? Field { $ field = $ table - > get Foreign Key ( ) ; return $ this - > fields [ $ field ] ? ? null ; } 
public function delete ( ) : self { $ ids = array _values ( $ this - > id ) ; if ( count ( $ ids ) ) { $ this - > table - > delete ( ) - > where ( 'id IN ' , $ ids ) - > run ( ) ; $ this - > id = null ; } return $ this ; } 
public function get ( Table $ table , array $ info ) : Field { $ class Name = $ this - > get Class Name ( $ info [ 'name ' ] , $ info [ 'type ' ] ) ; if ( class _exists ( $ class Name ) ) { $ field = new $ class Name ( $ table , $ info ) ; $ config = $ this - > fields [ $ class Name ] [ 'config ' ] ? ? [ ] ; foreach ( $ config as $ name = > $ value ) { $ field - > set Config ( $ name , $ value ) ; } return $ field ; } throw new Simple Crud Exception ( "No field class found for ' { $class Name } ' " ) ; } 
private function get Class Name ( string $ name , string $ type ) : ? string { foreach ( $ this - > fields as $ class Name = > $ definition ) { foreach ( $ definition [ 'names ' ] as $ def Name ) { if ( $ def Name = = = $ name | | ( $ def Name [ 0 ] = = = ' / ' & & preg _match ( $ def Name , $ name ) ) ) { return $ class Name ; } } if ( in _array ( $ type , $ definition [ 'types ' ] ) ) { return $ class Name ; } } return $ this - > default Type ; } 
public function set Config ( string $ name , $ value ) : self { $ this - > config [ $ name ] = $ value ; return $ this ; } 
public function get Field Factory ( ) : Field Factory { if ( $ this - > field Factory = = = null ) { return $ this - > field Factory = new Field Factory ( ) ; } return $ this - > field Factory ; } 
public function execute ( string $ query , array $ marks = null ) : PDOStatement { $ statement = $ this - > connection - > prepare ( $ query ) ; $ statement - > execute ( $ marks ) ; return $ statement ; } 
public function execute Transaction ( callable $ callable ) { try { $ transaction = $ this - > begin Transaction ( ) ; $ return = $ callable ( $ this ) ; if ( $ transaction ) { $ this - > commit ( ) ; } } catch ( Exception $ exception ) { if ( $ transaction ) { $ this - > roll Back ( ) ; } throw $ exception ; } return $ return ; } 
public function begin Transaction ( ) : bool { if ( ! $ this - > in Transaction ( ) ) { $ this - > connection - > begin Transaction ( ) ; return $ this - > in Transaction = true ; } return false ; } 
private static function is Valid ( $ data ) : bool { if ( ! is _array ( $ data ) ) { return false ; } if ( ! isset ( $ data [ 0 ] ) | | ! isset ( $ data [ 1 ] ) | | count ( $ data ) > 2 ) { return false ; } return is _numeric ( $ data [ 0 ] ) & & is _numeric ( $ data [ 1 ] ) ; } 
public function & _ _get ( string $ name ) { if ( $ name = = = 'id ' ) { return $ this - > values [ 'id ' ] ; } 
public function _ _isset ( string $ name ) : bool { $ value Name = $ this - > get Value Name ( $ name ) ; return ( isset ( $ value Name ) & & ! is _null ( $ this - > get Value ( $ value Name ) ) ) | | isset ( $ this - > data [ $ name ] ) ; } 
public function edit ( array $ values ) : self { foreach ( $ values as $ name = > $ value ) { $ this - > _ _set ( $ name , $ value ) ; } return $ this ; } 
public function save ( ) : self { if ( ! empty ( $ this - > changes ) ) { $ event Dispatcher = $ this - > table - > get Event Dispatcher ( ) ; if ( $ event Dispatcher ) { $ event Dispatcher - > dispatch ( new Before Save Row ( $ this ) ) ; } if ( empty ( $ this - > id ) ) { $ this - > id = $ this - > table - > insert ( $ this - > changes ) - > run ( ) ; } else { $ this - > table - > update ( $ this - > changes ) - > where ( 'id = ' , $ this - > id ) - > run ( ) ; } $ this - > values = $ this - > to Array ( ) ; $ this - > changes = [ ] ; $ this - > table - > cache ( $ this ) ; } return $ this ; } 
public function delete ( ) : self { $ id = $ this - > id ; if ( ! empty ( $ id ) ) { $ this - > table - > delete ( ) - > where ( 'id = ' , $ id ) - > run ( ) ; $ this - > values [ 'id ' ] = null ; } return $ this ; } 
public function relate ( Row . . . $ rows ) : self { $ table 1 = $ this - > table ; foreach ( $ rows as $ row ) { $ table 2 = $ row - > get Table ( ) ; 
public function unrelate ( Row . . . $ rows ) : self { $ table 1 = $ this - > table ; foreach ( $ rows as $ row ) { $ table 2 = $ row - > get Table ( ) ; 
public function unrelate All ( Table . . . $ tables ) : self { $ table 1 = $ this - > table ; foreach ( $ tables as $ table 2 ) { 
public function select ( Table $ table ) : Select { 
private function get Value Name ( string $ name ) : ? string { if ( array _key _exists ( $ name , $ this - > values ) ) { return $ name ; } 
public function set Limits ( $ var ) { $ arr = GPBUtil : : check Repeated Field ( $ var , \ Google \ Protobuf \ Internal \ GPBType : : MESSAGE , \ Google \ Api \ Quota Limit : : class ) ; $ this - > limits = $ arr ; return $ this ; } 
public function set Metric Rules ( $ var ) { $ arr = GPBUtil : : check Repeated Field ( $ var , \ Google \ Protobuf \ Internal \ GPBType : : MESSAGE , \ Google \ Api \ Metric Rule : : class ) ; $ this - > metric _rules = $ arr ; return $ this ; } 
public function set Producer Destinations ( $ var ) { $ arr = GPBUtil : : check Repeated Field ( $ var , \ Google \ Protobuf \ Internal \ GPBType : : MESSAGE , \ Google \ Api \ Logging \ Logging Destination : : class ) ; $ this - > producer _destinations = $ arr ; return $ this ; } 
public function set Consumer Destinations ( $ var ) { $ arr = GPBUtil : : check Repeated Field ( $ var , \ Google \ Protobuf \ Internal \ GPBType : : MESSAGE , \ Google \ Api \ Logging \ Logging Destination : : class ) ; $ this - > consumer _destinations = $ arr ; return $ this ; } 
public function set Advices ( $ var ) { $ arr = GPBUtil : : check Repeated Field ( $ var , \ Google \ Protobuf \ Internal \ GPBType : : MESSAGE , \ Google \ Api \ Advice : : class ) ; $ this - > advices = $ arr ; return $ this ; } 
public function set Attachments ( $ var ) { $ arr = GPBUtil : : check Repeated Field ( $ var , \ Google \ Protobuf \ Internal \ GPBType : : MESSAGE , \ Google \ Protobuf \ Any : : class ) ; $ this - > attachments = $ arr ; return $ this ; } 
public function set Apis ( $ var ) { $ arr = GPBUtil : : check Repeated Field ( $ var , \ Google \ Protobuf \ Internal \ GPBType : : MESSAGE , \ Google \ Protobuf \ Api : : class ) ; $ this - > apis = $ arr ; return $ this ; } 
public function set Types ( $ var ) { $ arr = GPBUtil : : check Repeated Field ( $ var , \ Google \ Protobuf \ Internal \ GPBType : : MESSAGE , \ Google \ Protobuf \ Type : : class ) ; $ this - > types = $ arr ; return $ this ; } 
public function set Enums ( $ var ) { $ arr = GPBUtil : : check Repeated Field ( $ var , \ Google \ Protobuf \ Internal \ GPBType : : MESSAGE , \ Google \ Protobuf \ Enum : : class ) ; $ this - > enums = $ arr ; return $ this ; } 
public function set Endpoints ( $ var ) { $ arr = GPBUtil : : check Repeated Field ( $ var , \ Google \ Protobuf \ Internal \ GPBType : : MESSAGE , \ Google \ Api \ Endpoint : : class ) ; $ this - > endpoints = $ arr ; return $ this ; } 
public function set Logs ( $ var ) { $ arr = GPBUtil : : check Repeated Field ( $ var , \ Google \ Protobuf \ Internal \ GPBType : : MESSAGE , \ Google \ Api \ Log Descriptor : : class ) ; $ this - > logs = $ arr ; return $ this ; } 
public function set Metrics ( $ var ) { $ arr = GPBUtil : : check Repeated Field ( $ var , \ Google \ Protobuf \ Internal \ GPBType : : MESSAGE , \ Google \ Api \ Metric Descriptor : : class ) ; $ this - > metrics = $ arr ; return $ this ; } 
public function set Monitored Resources ( $ var ) { $ arr = GPBUtil : : check Repeated Field ( $ var , \ Google \ Protobuf \ Internal \ GPBType : : MESSAGE , \ Google \ Api \ Monitored Resource Descriptor : : class ) ; $ this - > monitored _resources = $ arr ; return $ this ; } 
public function set Field Violations ( $ var ) { $ arr = GPBUtil : : check Repeated Field ( $ var , \ Google \ Protobuf \ Internal \ GPBType : : MESSAGE , \ Google \ Rpc \ Bad Request \ Field Violation : : class ) ; $ this - > field _violations = $ arr ; return $ this ; } 
public function set Operations ( $ var ) { $ arr = GPBUtil : : check Repeated Field ( $ var , \ Google \ Protobuf \ Internal \ GPBType : : MESSAGE , \ Google \ Long Running \ Operation : : class ) ; $ this - > operations = $ arr ; return $ this ; } 
public function set View ( $ var ) { GPBUtil : : check Enum ( $ var , \ Google \ Iam \ Admin \ V 1 \ Role View : : class ) ; $ this - > view = $ var ; return $ this ; } 
public function set Included Permissions ( $ var ) { $ arr = GPBUtil : : check Repeated Field ( $ var , \ Google \ Protobuf \ Internal \ GPBType : : STRING ) ; $ this - > included _permissions = $ arr ; return $ this ; } 
public function set Stage ( $ var ) { GPBUtil : : check Enum ( $ var , \ Google \ Iam \ Admin \ V 1 \ Role _Role Launch Stage : : class ) ; $ this - > stage = $ var ; return $ this ; } 
public function set Consumer Destinations ( $ var ) { $ arr = GPBUtil : : check Repeated Field ( $ var , \ Google \ Protobuf \ Internal \ GPBType : : MESSAGE , \ Google \ Api \ Billing \ Billing Destination : : class ) ; $ this - > consumer _destinations = $ arr ; return $ this ; } 
public function set Extensions ( $ var ) { $ arr = GPBUtil : : check Repeated Field ( $ var , \ Google \ Protobuf \ Internal \ GPBType : : MESSAGE , \ Google \ Protobuf \ Any : : class ) ; $ this - > extensions = $ arr ; return $ this ; } 
public function set Providers ( $ var ) { $ arr = GPBUtil : : check Repeated Field ( $ var , \ Google \ Protobuf \ Internal \ GPBType : : MESSAGE , \ Google \ Api \ Auth Provider : : class ) ; $ this - > providers = $ arr ; return $ this ; } 
public function set Requested ( $ var ) { $ arr = GPBUtil : : check Repeated Field ( $ var , \ Google \ Protobuf \ Internal \ GPBType : : STRING ) ; $ this - > requested = $ arr ; return $ this ; } 
public function set Provided ( $ var ) { $ arr = GPBUtil : : check Repeated Field ( $ var , \ Google \ Protobuf \ Internal \ GPBType : : STRING ) ; $ this - > provided = $ arr ; return $ this ; } 
public function set Bounds ( $ var ) { $ arr = GPBUtil : : check Repeated Field ( $ var , \ Google \ Protobuf \ Internal \ GPBType : : DOUBLE ) ; $ this - > bounds = $ arr ; return $ this ; } 
public function set Role ( $ var ) { GPBUtil : : check Message ( $ var , \ Google \ Iam \ Admin \ V 1 \ Role : : class ) ; $ this - > role = $ var ; return $ this ; } 
public function set Subpages ( $ var ) { $ arr = GPBUtil : : check Repeated Field ( $ var , \ Google \ Protobuf \ Internal \ GPBType : : MESSAGE , \ Google \ Api \ Page : : class ) ; $ this - > subpages = $ arr ; return $ this ; } 
public function set Key Types ( $ var ) { $ arr = GPBUtil : : check Repeated Field ( $ var , \ Google \ Protobuf \ Internal \ GPBType : : ENUM , \ Google \ Iam \ Admin \ V 1 \ List Service Account Keys Request \ Key Type : : class ) ; $ this - > key _types = $ arr ; return $ this ; } 
public function set Address Lines ( $ var ) { $ arr = GPBUtil : : check Repeated Field ( $ var , \ Google \ Protobuf \ Internal \ GPBType : : STRING ) ; $ this - > address _lines = $ arr ; return $ this ; } 
public function set Recipients ( $ var ) { $ arr = GPBUtil : : check Repeated Field ( $ var , \ Google \ Protobuf \ Internal \ GPBType : : STRING ) ; $ this - > recipients = $ arr ; return $ this ; } 
public function set Logs ( $ var ) { $ arr = GPBUtil : : check Repeated Field ( $ var , \ Google \ Protobuf \ Internal \ GPBType : : STRING ) ; $ this - > logs = $ arr ; return $ this ; } 
public function set Requirements ( $ var ) { $ arr = GPBUtil : : check Repeated Field ( $ var , \ Google \ Protobuf \ Internal \ GPBType : : STRING ) ; $ this - > requirements = $ arr ; return $ this ; } 
public function set Stack Entries ( $ var ) { $ arr = GPBUtil : : check Repeated Field ( $ var , \ Google \ Protobuf \ Internal \ GPBType : : STRING ) ; $ this - > stack _entries = $ arr ; return $ this ; } 
public function set Members ( $ var ) { $ arr = GPBUtil : : check Repeated Field ( $ var , \ Google \ Protobuf \ Internal \ GPBType : : STRING ) ; $ this - > members = $ arr ; return $ this ; } 
public function set Producer Destinations ( $ var ) { $ arr = GPBUtil : : check Repeated Field ( $ var , \ Google \ Protobuf \ Internal \ GPBType : : MESSAGE , \ Google \ Api \ Monitoring \ Monitoring Destination : : class ) ; $ this - > producer _destinations = $ arr ; return $ this ; } 
public function set Consumer Destinations ( $ var ) { $ arr = GPBUtil : : check Repeated Field ( $ var , \ Google \ Protobuf \ Internal \ GPBType : : MESSAGE , \ Google \ Api \ Monitoring \ Monitoring Destination : : class ) ; $ this - > consumer _destinations = $ arr ; return $ this ; } 
public function set Additional Bindings ( $ var ) { $ arr = GPBUtil : : check Repeated Field ( $ var , \ Google \ Protobuf \ Internal \ GPBType : : MESSAGE , \ Google \ Api \ Http Rule : : class ) ; $ this - > additional _bindings = $ arr ; return $ this ; } 
public function set Requirements ( $ var ) { $ arr = GPBUtil : : check Repeated Field ( $ var , \ Google \ Protobuf \ Internal \ GPBType : : MESSAGE , \ Google \ Api \ Auth Requirement : : class ) ; $ this - > requirements = $ arr ; return $ this ; } 
public function set Bindings ( $ var ) { $ arr = GPBUtil : : check Repeated Field ( $ var , \ Google \ Protobuf \ Internal \ GPBType : : MESSAGE , \ Google \ Cloud \ Iam \ V 1 \ Binding : : class ) ; $ this - > bindings = $ arr ; return $ this ; } 
public function set Metric Costs ( $ var ) { $ arr = GPBUtil : : check Map Field ( $ var , \ Google \ Protobuf \ Internal \ GPBType : : STRING , \ Google \ Protobuf \ Internal \ GPBType : : INT 6 4 ) ; $ this - > metric _costs = $ arr ; return $ this ; } 
public function set Pages ( $ var ) { $ arr = GPBUtil : : check Repeated Field ( $ var , \ Google \ Protobuf \ Internal \ GPBType : : MESSAGE , \ Google \ Api \ Page : : class ) ; $ this - > pages = $ arr ; return $ this ; } 
public function set Rules ( $ var ) { $ arr = GPBUtil : : check Repeated Field ( $ var , \ Google \ Protobuf \ Internal \ GPBType : : MESSAGE , \ Google \ Api \ Documentation Rule : : class ) ; $ this - > rules = $ arr ; return $ this ; } 
public function set Action ( $ var ) { GPBUtil : : check Enum ( $ var , \ Google \ Cloud \ Iam \ V 1 \ Binding Delta _Action : : class ) ; $ this - > action = $ var ; return $ this ; } 
public function set Source Files ( $ var ) { $ arr = GPBUtil : : check Repeated Field ( $ var , \ Google \ Protobuf \ Internal \ GPBType : : MESSAGE , \ Google \ Protobuf \ Any : : class ) ; $ this - > source _files = $ arr ; return $ this ; } 
public function set Keys ( $ var ) { $ arr = GPBUtil : : check Repeated Field ( $ var , \ Google \ Protobuf \ Internal \ GPBType : : MESSAGE , \ Google \ Iam \ Admin \ V 1 \ Service Account Key : : class ) ; $ this - > keys = $ arr ; return $ this ; } 
public function set Accounts ( $ var ) { $ arr = GPBUtil : : check Repeated Field ( $ var , \ Google \ Protobuf \ Internal \ GPBType : : MESSAGE , \ Google \ Iam \ Admin \ V 1 \ Service Account : : class ) ; $ this - > accounts = $ arr ; return $ this ; } 
public function set Custom Roles Support Level ( $ var ) { GPBUtil : : check Enum ( $ var , \ Google \ Iam \ Admin \ V 1 \ Permission _Custom Roles Support Level : : class ) ; $ this - > custom _roles _support _level = $ var ; return $ this ; } 
public function set Policy Delta ( $ var ) { GPBUtil : : check Message ( $ var , \ Google \ Cloud \ Iam \ V 1 \ Policy Delta : : class ) ; $ this - > policy _delta = $ var ; return $ this ; } 
public function set Bucket Counts ( $ var ) { $ arr = GPBUtil : : check Repeated Field ( $ var , \ Google \ Protobuf \ Internal \ GPBType : : INT 6 4 ) ; $ this - > bucket _counts = $ arr ; return $ this ; } 
public function set Exemplars ( $ var ) { $ arr = GPBUtil : : check Repeated Field ( $ var , \ Google \ Protobuf \ Internal \ GPBType : : MESSAGE , \ Google \ Api \ Distribution \ Exemplar : : class ) ; $ this - > exemplars = $ arr ; return $ this ; } 
public function set Metrics ( $ var ) { $ arr = GPBUtil : : check Repeated Field ( $ var , \ Google \ Protobuf \ Internal \ GPBType : : STRING ) ; $ this - > metrics = $ arr ; return $ this ; } 
public function set Links ( $ var ) { $ arr = GPBUtil : : check Repeated Field ( $ var , \ Google \ Protobuf \ Internal \ GPBType : : MESSAGE , \ Google \ Rpc \ Help \ Link : : class ) ; $ this - > links = $ arr ; return $ this ; } 
public function set Aliases ( $ var ) { $ arr = GPBUtil : : check Repeated Field ( $ var , \ Google \ Protobuf \ Internal \ GPBType : : STRING ) ; $ this - > aliases = $ arr ; return $ this ; } 
public function set Features ( $ var ) { $ arr = GPBUtil : : check Repeated Field ( $ var , \ Google \ Protobuf \ Internal \ GPBType : : STRING ) ; $ this - > features = $ arr ; return $ this ; } 
public function set Values ( $ var ) { $ arr = GPBUtil : : check Map Field ( $ var , \ Google \ Protobuf \ Internal \ GPBType : : STRING , \ Google \ Protobuf \ Internal \ GPBType : : INT 6 4 ) ; $ this - > values = $ arr ; return $ this ; } 
public function set Service Account ( $ var ) { GPBUtil : : check Message ( $ var , \ Google \ Iam \ Admin \ V 1 \ Service Account : : class ) ; $ this - > service _account = $ var ; return $ this ; } 
public function set Properties ( $ var ) { $ arr = GPBUtil : : check Repeated Field ( $ var , \ Google \ Protobuf \ Internal \ GPBType : : MESSAGE , \ Google \ Api \ Property : : class ) ; $ this - > properties = $ arr ; return $ this ; } 
public function set Violations ( $ var ) { $ arr = GPBUtil : : check Repeated Field ( $ var , \ Google \ Protobuf \ Internal \ GPBType : : MESSAGE , \ Google \ Rpc \ Quota Failure \ Violation : : class ) ; $ this - > violations = $ arr ; return $ this ; } 
public function set Private Key Type ( $ var ) { GPBUtil : : check Enum ( $ var , \ Google \ Iam \ Admin \ V 1 \ Service Account Private Key Type : : class ) ; $ this - > private _key _type = $ var ; return $ this ; } 
public function set Key Algorithm ( $ var ) { GPBUtil : : check Enum ( $ var , \ Google \ Iam \ Admin \ V 1 \ Service Account Key Algorithm : : class ) ; $ this - > key _algorithm = $ var ; return $ this ; } 
public function set Details ( $ var ) { $ arr = GPBUtil : : check Repeated Field ( $ var , \ Google \ Protobuf \ Internal \ GPBType : : MESSAGE , \ Google \ Protobuf \ Any : : class ) ; $ this - > details = $ arr ; return $ this ; } 
public function set Binding Deltas ( $ var ) { $ arr = GPBUtil : : check Repeated Field ( $ var , \ Google \ Protobuf \ Internal \ GPBType : : MESSAGE , \ Google \ Cloud \ Iam \ V 1 \ Binding Delta : : class ) ; $ this - > binding _deltas = $ arr ; return $ this ; } 
public function set Public Key Type ( $ var ) { GPBUtil : : check Enum ( $ var , \ Google \ Iam \ Admin \ V 1 \ Service Account Public Key Type : : class ) ; $ this - > public _key _type = $ var ; return $ this ; } 
public function set Policy ( $ var ) { GPBUtil : : check Message ( $ var , \ Google \ Cloud \ Iam \ V 1 \ Policy : : class ) ; $ this - > policy = $ var ; return $ this ; } 
public function set Roles ( $ var ) { $ arr = GPBUtil : : check Repeated Field ( $ var , \ Google \ Protobuf \ Internal \ GPBType : : MESSAGE , \ Google \ Iam \ Admin \ V 1 \ Role : : class ) ; $ this - > roles = $ arr ; return $ this ; } 
public function set Parameters ( $ var ) { $ arr = GPBUtil : : check Repeated Field ( $ var , \ Google \ Protobuf \ Internal \ GPBType : : MESSAGE , \ Google \ Api \ System Parameter : : class ) ; $ this - > parameters = $ arr ; return $ this ; } 
public function get Cache File ( $ filename , $ actual = false , $ mkdir = false ) { $ path = array ( ) ; 
protected function check Conditions ( $ cache File , array $ conditions = array ( ) ) { 
public function exists ( $ filename , array $ conditions = array ( ) ) { $ cache File = $ this - > get Cache File ( $ filename , true ) ; return $ this - > check Conditions ( $ cache File , $ conditions ) ; } 
public function set ( $ filename , $ contents = ' ' ) { $ cache File = $ this - > get Cache File ( $ filename , true , true ) ; file _put _contents ( $ cache File , $ contents , \ LOCK _EX ) ; return $ this ; } 
public function get ( $ filename , array $ conditions = array ( ) ) { if ( $ this - > exists ( $ filename , $ conditions ) ) { return file _get _contents ( $ this - > get Cache File ( $ filename , true ) ) ; } else { return null ; } } 
public function get Or Create ( $ filename , array $ conditions = array ( ) , $ function , $ file = false , $ actual = false ) { if ( ! is _callable ( $ function ) ) { throw new \ Invalid Argument Exception ( 'The argument $function should be callable ' ) ; } $ cache File = $ this - > get Cache File ( $ filename , true , true ) ; $ data = null ; if ( ! $ this - > check ( $ filename , $ conditions ) ) { if ( file _exists ( $ cache File ) ) { unlink ( $ cache File ) ; } $ data = call _user _func ( $ function , $ cache File ) ; 
public function get Or Create File ( $ filename , array $ conditions = array ( ) , $ function , $ actual = false ) { return $ this - > get Or Create ( $ filename , $ conditions , $ function , true , $ actual ) ; } 
public function download ( $ args , $ assoc _args ) { $ download _dir = ! empty ( $ assoc _args [ 'path ' ] ) ? ( rtrim ( $ assoc _args [ 'path ' ] , ' / \ \ ' ) . ' / ' ) : ABSPATH ; $ wordpress _present = is _readable ( $ download _dir . 'wp -load .php ' ) ; if ( $ wordpress _present & & ! Utils \ get _flag _value ( $ assoc _args , 'force ' ) ) { WP _CLI : : error ( 'Word Press files seem to already be present here . ' ) ; } if ( ! is _dir ( $ download _dir ) ) { if ( ! is _writable ( dirname ( $ download _dir ) ) ) { WP _CLI : : error ( "Insufficient permission to create directory ' { $download _dir } ' . " ) ; } WP _CLI : : log ( "Creating directory ' { $download _dir } ' . " ) ; if ( ! @ mkdir ( $ download _dir , 0 7 7 7 , true ) ) { $ error = error _get _last ( ) ; WP _CLI : : error ( "Failed to create directory ' { $download _dir } ' : { $error [ 'message ' ] } . " ) ; } } if ( ! is _writable ( $ download _dir ) ) { WP _CLI : : error ( " ' { $download _dir } ' is not writable by current user . " ) ; } $ locale = Utils \ get _flag _value ( $ assoc _args , 'locale ' , 'en _US ' ) ; $ skip _content = Utils \ get _flag _value ( $ assoc _args , 'skip -content ' ) ; if ( isset ( $ assoc _args [ 'version ' ] ) & & 'latest ' ! = = $ assoc _args [ 'version ' ] ) { $ version = $ assoc _args [ 'version ' ] ; if ( in _array ( strtolower ( $ version ) , [ 'trunk ' , 'nightly ' ] , true ) ) { $ version = 'nightly ' ; } 
public function is _installed ( $ args , $ assoc _args ) { if ( is _blog _installed ( ) & & ( ! Utils \ get _flag _value ( $ assoc _args , 'network ' ) | | is _multisite ( ) ) ) { WP _CLI : : halt ( 0 ) ; } WP _CLI : : halt ( 1 ) ; } 
public function install ( $ args , $ assoc _args ) { if ( $ this - > do _install ( $ assoc _args ) ) { WP _CLI : : success ( 'Word Press installed successfully . ' ) ; } else { WP _CLI : : log ( 'Word Press is already installed . ' ) ; } } 
public function multisite _convert ( $ args , $ assoc _args ) { if ( is _multisite ( ) ) { WP _CLI : : error ( 'This already is a multisite install . ' ) ; } $ assoc _args = self : : set _multisite _defaults ( $ assoc _args ) ; if ( ! isset ( $ assoc _args [ 'title ' ] ) ) { 
public function multisite _install ( $ args , $ assoc _args ) { if ( $ this - > do _install ( $ assoc _args ) ) { WP _CLI : : log ( 'Created single site database tables . ' ) ; } else { WP _CLI : : log ( 'Single site database tables already present . ' ) ; } $ assoc _args = self : : set _multisite _defaults ( $ assoc _args ) ; 
private static function create _initial _blog ( $ network _id , $ blog _id , $ domain , $ path , $ subdomain _install , $ site _user ) { global $ wpdb , $ current _site , $ wp _rewrite ; 
private static function add _site _admins ( $ site _user ) { $ site _admins = [ $ site _user - > user _login ] ; $ users = get _users ( [ 'fields ' = > [ 'ID ' , 'user _login ' ] ] ) ; if ( $ users ) { foreach ( $ users as $ user ) { if ( is _super _admin ( $ user - > ID ) & & ! in _array ( $ user - > user _login , $ site _admins , true ) ) { $ site _admins [ ] = $ user - > user _login ; } } } update _site _option ( 'site _admins ' , $ site _admins ) ; } 
public function version ( $ args = [ ] , $ assoc _args = [ ] ) { $ details = self : : get _wp _details ( ) ; if ( ! Utils \ get _flag _value ( $ assoc _args , 'extra ' ) ) { WP _CLI : : line ( $ details [ 'wp _version ' ] ) ; return ; } $ match = [ ] ; $ found _version = preg _match ( ' / ( \d ) ( \d + ) - / ' , $ details [ 'tinymce _version ' ] , $ match ) ; $ human _readable _tiny _mce = $ found _version ? " { $match [ 1 ] } . { $match [ 2 ] } " : ' ' ; echo Utils \ mustache _render ( self : : get _template _path ( 'versions .mustache ' ) , [ 'wp -version ' = > $ details [ 'wp _version ' ] , 'db -version ' = > $ details [ 'wp _db _version ' ] , 'local -package ' = > empty ( $ details [ 'wp _local _package ' ] ) ? 'en _US ' : $ details [ 'wp _local _package ' ] , 'mce -version ' = > $ human _readable _tiny _mce ? " { $human _readable _tiny _mce } ( { $details [ 'tinymce _version ' ] } ) " : $ details [ 'tinymce _version ' ] , ] ) ; } 
private static function get _wp _details ( $ abspath = ABSPATH ) { $ versions _path = $ abspath . 'wp -includes /version .php ' ; if ( ! is _readable ( $ versions _path ) ) { WP _CLI : : error ( "This does not seem to be a Word Press install . \n " . 'Pass - -path = `path /to /wordpress ` or run `wp core download ` . ' ) ; } $ version _content = file _get _contents ( $ versions _path , null , null , 6 , 2 0 4 8 ) ; $ vars = [ 'wp _version ' , 'wp _db _version ' , 'tinymce _version ' , 'wp _local _package ' ] ; $ result = [ ] ; foreach ( $ vars as $ var _name ) { $ result [ $ var _name ] = self : : find _var ( $ var _name , $ version _content ) ; } return $ result ; } 
private static function find _var ( $ var _name , $ code ) { $ start = strpos ( $ code , ' $ ' . $ var _name . ' = ' ) ; if ( ! $ start ) { return null ; } $ start = $ start + strlen ( $ var _name ) + 3 ; $ end = strpos ( $ code , ' ; ' , $ start ) ; $ value = substr ( $ code , $ start , $ end - $ start ) ; return trim ( $ value , " ' " ) ; } 
private static function get _core _checksums ( $ version , $ locale ) { $ query = http _build _query ( compact ( 'version ' , 'locale ' ) , null , ' & ' ) ; $ url = "https : / /api .wordpress .org /core /checksums / 1 . 0 / ? { $query } " ; $ options = [ 'timeout ' = > 3 0 ] ; $ headers = [ 'Accept ' = > 'application /json ' ] ; $ response = Utils \ http _request ( 'GET ' , $ url , null , $ headers , $ options ) ; if ( ! $ response - > success | | 2 0 0 ! = = ( int ) $ response - > status _code ) { return "Checksum request ' { $url } ' failed (HTTP { $response - >status _code } ) . " ; } $ body = trim ( $ response - > body ) ; $ body = json _decode ( $ body , true ) ; if ( ! is _array ( $ body ) | | ! isset ( $ body [ 'checksums ' ] ) | | ! is _array ( $ body [ 'checksums ' ] ) ) { return "Checksums not available for Word Press { $version } / { $locale } . " ; } return $ body [ 'checksums ' ] ; } 
public function update ( $ args , $ assoc _args ) { global $ wp _version ; $ update = null ; $ from _api = null ; $ upgrader = 'WP _CLI \ \Core \ \Core Upgrader ' ; if ( 'trunk ' = = = Utils \ get _flag _value ( $ assoc _args , 'version ' ) ) { $ assoc _args [ 'version ' ] = 'nightly ' ; } if ( ! empty ( $ args [ 0 ] ) ) { 
public function update _db ( $ args , $ assoc _args ) { global $ wpdb , $ wp _db _version , $ wp _current _db _version ; $ network = Utils \ get _flag _value ( $ assoc _args , 'network ' ) ; if ( $ network & & ! is _multisite ( ) ) { WP _CLI : : error ( 'This is not a multisite installation . ' ) ; } $ dry _run = Utils \ get _flag _value ( $ assoc _args , 'dry -run ' ) ; if ( $ dry _run ) { WP _CLI : : log ( 'Performing a dry run , with no database modification . ' ) ; } if ( $ network ) { $ iterator _args = [ 'table ' = > $ wpdb - > blogs , 'where ' = > [ 'spam ' = > 0 , 'deleted ' = > 0 , 'archived ' = > 0 , ] , ] ; $ it = new Table Iterator ( $ iterator _args ) ; $ success = 0 ; $ total = 0 ; $ site _ids = [ ] ; foreach ( $ it as $ blog ) { $ total + + ; $ site _ids [ ] = $ blog - > site _id ; $ url = $ blog - > domain . $ blog - > path ; $ cmd = " - -url = { $url } core update -db " ; if ( $ dry _run ) { $ cmd . = ' - -dry -run ' ; } $ process = WP _CLI : : runcommand ( $ cmd , [ 'return ' = > 'all ' ] ) ; if ( 0 = = = ( int ) $ process - > return _code ) { 
private function get _download _url ( $ version , $ locale = 'en _US ' , $ file _type = 'zip ' ) { if ( 'nightly ' = = = $ version ) { if ( 'zip ' = = = $ file _type ) { return 'https : / /wordpress .org /nightly -builds /wordpress -latest .zip ' ; } else { WP _CLI : : error ( 'Nightly builds are only available in .zip format . ' ) ; } } $ locale _subdomain = 'en _US ' = = = $ locale ? ' ' : substr ( $ locale , 0 , 2 ) . ' . ' ; $ locale _suffix = 'en _US ' = = = $ locale ? ' ' : " - { $locale } " ; return "https : / / { $locale _subdomain }wordpress .org /wordpress - { $version } { $locale _suffix } . { $file _type } " ; } 
private function get _updates ( $ assoc _args ) { wp _version _check ( ) ; $ from _api = get _site _transient ( 'update _core ' ) ; if ( ! $ from _api ) { return [ ] ; } $ compare _version = str _replace ( ' -src ' , ' ' , $ GLOBALS [ 'wp _version ' ] ) ; $ updates = [ 'major ' = > false , 'minor ' = > false , ] ; foreach ( $ from _api - > updates as $ offer ) { $ update _type = Utils \ get _named _sem _ver ( $ offer - > version , $ compare _version ) ; if ( ! $ update _type ) { continue ; } 
public function download _package ( $ package , $ check _signatures = true ) { $ reply = apply _filters ( * Download to a temporary file because piping from c URL to tar is flaky * on Min GW (and probably in other environments too ) . * / $ headers = [ 'Accept ' = > 'application /json ' ] ; $ options = [ 'timeout ' = > 6 0 0 , 
public function upgrade ( $ current , $ args = [ ] ) { set _error _handler ( [ _ _CLASS _ _ , 'error _handler ' ] , E _USER _WARNING | E _USER _NOTICE ) ; $ result = parent : : upgrade ( $ current , $ args ) ; restore _error _handler ( ) ; return $ result ; } 
protected function build _table ( array $ arr , $ child = false ) { $ html = ' <div class = "papi -property -table " > <table class = "papi -table " > ' ; $ allow _html = $ this - > get _setting ( 'allow _html ' ) ; if ( $ child ) { $ html . = ' <thead > ' ; foreach ( $ arr [ 0 ] as $ key = > $ value ) { if ( $ allow _html ) { $ key = html _entity _decode ( $ key ) ; } $ html . = sprintf ( ' <th > %s < /th > ' , $ key ) ; } $ html . = ' < /thead > ' ; } foreach ( $ arr as $ key = > $ value ) { $ html . = ' <tr > ' ; foreach ( $ value as $ key 2 = > $ value 2 ) { if ( is _array ( $ value 2 ) ) { $ value 2 = $ this - > build _table ( $ value 2 , true ) ; } $ value 2 = papi _convert _to _string ( $ value 2 ) ; if ( $ allow _html ) { $ value 2 = html _entity _decode ( $ value 2 ) ; } $ html . = sprintf ( ' <td > %s < /td > ' , $ value 2 ) ; } $ html . = ' < /tr > ' ; } return $ html . ' < /table > < /div > ' ; } 
public function html ( ) { $ value = $ this - > get _value ( ) ; $ data = $ this - > get _setting ( 'items ' ) ; if ( ! is _array ( $ data ) ) { return ; } 
public function admin _head ( ) { if ( ! $ this - > box - > frame ) { echo sprintf ( ' <style type = "text /css " >label [for = " %s -hide " ] , # %s >h 2 , # %s >button {display :none !important } < /style > ' , esc _attr ( $ this - > box - > id ) , esc _attr ( $ this - > box - > id ) , esc _attr ( $ this - > box - > id ) ) ; } } 
public function move _meta _box _after _title ( ) { global $ post , $ wp _meta _boxes ; do _meta _boxes ( get _current _screen ( ) , $ this - > box - > context , $ post ) ; unset ( $ wp _meta _boxes [ get _post _type ( $ post ) ] [ $ this - > box - > context ] ) ; } 
protected function get _post _type ( ) { if ( papi _get _meta _type ( ) = = = 'post ' ) { if ( $ post _id = papi _get _post _id ( ) ) { return get _post _type ( $ post _id ) ; } if ( $ post _type = papi _get _post _type ( ) ) { return $ post _type ; } } return $ this - > box - > id ; } 
protected function get _title ( ) { $ title = $ this - > box - > title ; if ( $ this - > box - > get _option ( 'required ' ) ) { $ title . = papi _property _required _html ( $ this - > box - > properties [ 0 ] , true ) ; } return $ title ; } 
public function render _meta _box ( $ post , array $ args ) { if ( ! isset ( $ args [ 'args ' ] ) ) { return ; } 
protected function setup _actions ( ) { if ( post _type _exists ( $ this - > get _post _type ( ) ) & & papi _get _meta _type ( ) = = = 'post ' ) { add _action ( 'add _meta _boxes ' , [ $ this , 'setup _meta _box ' ] ) ; if ( $ this - > box - > context = = = 'after _title ' ) { add _action ( 'edit _form _after _title ' , [ $ this , 'move _meta _box _after _title ' ] ) ; } } else { $ this - > setup _meta _box ( ) ; } 
public function setup _meta _box ( ) { $ properties = $ this - > box - > properties ; 
protected function get _meta ( ) { $ method = 'meta ' ; if ( ! method _exists ( $ this , $ method ) ) { return [ ] ; } $ child _meta = call _user _func ( [ $ this , $ method ] ) ; $ child _meta = is _array ( $ child _meta ) ? $ child _meta : [ ] ; $ parent _class = get _parent _class ( $ this ) ; $ parent _exists = method _exists ( $ parent _class , $ method ) ; $ parent _meta = [ ] ; while ( $ parent _exists ) { $ rc = new Reflection Class ( $ parent _class ) ; 
protected function setup _file ( $ file _path ) { $ this - > _file _path = $ file _path ; $ this - > _class _name = papi _get _class _name ( $ this - > _file _path ) ; } 
protected function setup _meta _data ( ) { foreach ( $ this - > get _meta ( ) as $ key = > $ value ) { if ( substr ( $ key , 0 , 1 ) = = = ' _ ' ) { continue ; } $ this - > $ key = papi _esc _html ( $ value ) ; } if ( $ this - > sort _order = = = 1 0 0 0 ) { $ this - > sort _order = papi _filter _settings _sort _order ( ) ; } } 
public function disabled ( ) { 
public static function factory ( ) { if ( count ( func _get _args ( ) ) = = = 0 ) { return new static ; } else { $ type = func _get _arg ( 0 ) ; } if ( is _array ( $ type ) ) { $ type = ( object ) $ type ; } if ( ! is _string ( $ type ) & & ! is _object ( $ type ) ) { return ; } if ( is _object ( $ type ) & & ! isset ( $ type - > type ) ) { $ property = new static ; $ property - > set _options ( $ type ) ; return $ property ; } if ( is _subclass _of ( $ type , _ _CLASS _ _ ) ) { return $ type ; } $ options = null ; if ( is _object ( $ type ) ) { if ( ! isset ( $ type - > type ) | | ! is _string ( $ type - > type ) ) { return ; } $ options = $ type ; $ type = $ type - > type ; } 
public function format _value ( $ value , $ slug , $ post _id ) { $ value = maybe _unserialize ( $ value ) ; return papi _maybe _json _decode ( $ value , $ this - > convert _type = = = 'array ' ) ; } 
public function get _child _property ( $ slug , array $ items = [ ] ) { $ items = empty ( $ items ) ? $ this - > get _child _properties ( ) : $ items ; foreach ( $ items as $ property ) { if ( is _array ( $ property ) & & isset ( $ property [ 'items ' ] ) ) { $ property = $ this - > get _child _property ( $ slug , $ property [ 'items ' ] ) ; } $ property = papi _get _property _type ( $ property ) ; if ( papi _is _property ( $ property ) & & $ property - > match _slug ( $ slug ) ) { return $ property ; } } } 
public function get _option ( $ key , $ default = null ) { $ value = $ default ; if ( isset ( $ this - > options - > $ key ) ) { $ value = $ this - > options - > $ key ; } if ( papi _is _empty ( $ value ) & & isset ( $ this - > default _options [ $ key ] ) ) { $ value = $ this - > default _options [ $ key ] ; } if ( $ key = = = 'settings ' & & is _array ( $ value ) ) { $ value = ( object ) $ value ; } return $ value ; } 
public function get _post _id ( ) { if ( ! papi _is _empty ( $ this - > post _id ) ) { return $ this - > post _id ; } if ( $ this - > store instanceof Papi _Core _Meta _Store ) { return $ this - > store - > id ; } return papi _get _post _id ( ) ; } 
public function get _setting ( $ key , $ default = null ) { if ( ! is _string ( $ key ) ) { return $ default ; } $ settings = $ this - > get _settings ( ) ; if ( isset ( $ settings - > $ key ) ) { return $ settings - > $ key ; } return $ default ; } 
public function html _id ( $ suffix = ' ' , $ row = null ) { if ( is _array ( $ suffix ) | | is _object ( $ suffix ) ) { return papi _f ( $ this - > html _name ( $ suffix , $ row ) ) ; } else { $ suffix = empty ( $ suffix ) | | ! is _string ( $ suffix ) ? ' ' : ' _ ' . $ suffix ; $ suffix = papi _underscorify ( papi _slugify ( $ suffix ) ) ; } $ name = $ this - > html _name ( ) ; $ len = strlen ( $ name ) ; if ( isset ( $ name [ $ len - 1 ] ) & & $ name [ $ len - 1 ] = = = ' ] ' ) { return papi _f ( sprintf ( ' %s %s ] ' , substr ( $ name , 0 , $ len - 1 ) , $ suffix ) ) ; } return papi _f ( sprintf ( ' %s %s ' , $ this - > html _name ( ) , $ suffix ) ) ; } 
public function html _name ( $ sub _property = null , $ row = null ) { $ base _slug = $ this - > slug ; if ( is _null ( $ sub _property ) ) { return $ base _slug ; } if ( is _numeric ( $ row ) ) { $ base _slug = sprintf ( ' %s [ %d ] ' , $ base _slug , intval ( $ row ) ) ; } if ( ! papi _is _property ( $ sub _property ) ) { if ( is _array ( $ sub _property ) | | is _object ( $ sub _property ) ) { $ sub _property = self : : factory ( $ sub _property ) ; } else { return $ base _slug ; } } return sprintf ( ' %s [ %s ] ' , $ base _slug , unpapify ( $ sub _property - > get _slug ( ) ) ) ; } 
public function load _value ( $ value , $ slug , $ post _id ) { $ value = maybe _unserialize ( $ value ) ; return papi _maybe _json _decode ( $ value , $ this - > convert _type = = = 'array ' ) ; } 
public function match _slug ( $ slug ) { if ( ! is _string ( $ slug ) ) { return false ; } return $ this - > get _slug ( ! preg _match ( ' / ^papi \ _ / ' , $ slug ) ) = = = $ slug ; } 
protected function prepare _value ( $ value ) { if ( papi _is _empty ( $ value ) ) { return ; } $ value = papi _santize _data ( $ value ) ; if ( is _array ( $ value ) ) { $ value = array _filter ( $ value , function ( $ val ) { return ! papi _is _empty ( $ val ) ; } ) ; if ( ! count ( array _filter ( array _keys ( $ value ) , 'is _string ' ) ) ) { $ value = array _values ( $ value ) ; } } return $ value ; } 
public function register ( $ type = 'post ' ) { if ( version _compare ( get _bloginfo ( 'version ' ) , ' 4 . 6 ' , ' < ' ) ) { return false ; } $ type = papi _get _meta _type ( $ type ) ; 
public function render _is _allowed _by _rules ( array $ rules = [ ] ) { if ( empty ( $ rules ) ) { $ rules = $ this - > get _rules ( ) ; } return $ this - > conditional - > display ( $ rules , $ this ) ; } 
public function set _option ( $ key , $ value ) { if ( ! is _object ( $ this - > options ) ) { $ this - > options = ( object ) $ this - > default _options ; } $ this - > options - > $ key = $ value ; } 
public function set _setting ( $ key , $ value ) { if ( isset ( $ this - > options - > settings , $ this - > options - > settings - > $ key ) ) { $ this - > options - > settings - > $ key = $ value ; } } 
protected function setup _properties ( ) { $ this - > conditional = new Papi _Core _Conditional ( ) ; if ( $ this - > default _options [ 'sort _order ' ] = = = - 1 ) { $ this - > default _options [ 'sort _order ' ] = papi _filter _settings _sort _order ( ) ; } if ( papi _is _empty ( $ this - > default _options [ 'post _type ' ] ) ) { $ this - > default _options [ 'post _type ' ] = papi _get _post _type ( ) ; } } 
protected function setup _options ( $ options = [ ] ) { 
protected function setup _options _slug ( $ options ) { $ slug = $ options - > slug ; 
protected function setup _options _settings ( $ options ) { $ property _class = self : : factory ( $ options - > type ) ; if ( papi _is _property ( $ property _class ) ) { $ options - > settings = array _merge ( ( array ) $ property _class - > get _default _settings ( ) , ( array ) $ options - > settings ) ; } return ( object ) $ options - > settings ; } 
public function update _value ( $ value , $ slug , $ post _id ) { if ( ! ( $ value = $ this - > prepare _value ( $ value ) ) ) { return ; } return papi _maybe _json _encode ( $ value ) ; } 
public function edit _attachment ( $ form _fields , $ post ) { foreach ( $ this - > get _boxes ( ) as $ box ) { if ( ! empty ( $ box - > title ) ) { $ form _fields [ 'papi -media -title - ' . uniqid ( ) ] = [ 'label ' = > ' ' , 'input ' = > 'html ' , 'html ' = > ' <h 4 class = "papi -media -title " > ' . $ box - > title . ' < /h 4 > ' ] ; } foreach ( $ box - > properties as $ prop ) { 
public function save _attachment ( $ post ) { update _post _meta ( $ post [ 'ID ' ] , papi _get _page _type _key ( ) , $ this - > get _id ( ) ) ; $ handler = new Papi _Admin _Meta _Handler ( ) ; $ handler - > save _meta _boxes ( $ post [ 'ID ' ] , $ post ) ; return $ post ; } 
public function singleton ( ) { $ key = sprintf ( 'entry _type _id .post _type . %s ' , $ this - > get _post _type ( ) ) ; if ( papi ( ) - > exists ( $ key ) ) { return true ; } papi ( ) - > singleton ( $ key , $ this - > get _id ( ) ) ; return false ; } 
public function get _property _meta _value ( $ slug ) { $ slug = strtolower ( $ slug ) ; if ( isset ( $ this - > meta _values [ $ slug ] ) ) { return $ this - > meta _values [ $ slug ] ; } return papi _data _get ( $ this - > id , $ slug , $ this - > get _type ( ) ) ; } 
public function get _value ( $ id = null , $ slug = null , $ default = null , $ type = 'post ' ) { if ( ! is _numeric ( $ id ) & & is _string ( $ id ) ) { $ type = empty ( $ default ) ? $ type : $ default ; $ default = $ slug ; $ slug = $ id ; $ id = null ; } $ slug = strtolower ( $ slug ) ; 
public function format _value ( $ slug , $ value ) { $ slug = strtolower ( unpapify ( $ slug ) ) ; $ property = $ this - > property ( $ slug ) ; 
protected function property ( $ slug = ' ' ) { if ( isset ( $ this - > properties [ $ slug ] ) & & papi _is _property ( $ this - > properties [ $ slug ] ) ) { $ property = $ this - > properties [ $ slug ] ; } else { $ property = $ this - > properties [ $ slug ] = $ this - > get _property ( $ slug ) ; } return apply _filters ( 'papi /get _property ' , $ property ) ; } 
public function load _value ( $ slug ) { $ slug = strtolower ( unpapify ( $ slug ) ) ; $ property = $ this - > property ( $ slug ) ; 
public static function factory ( $ post _id , $ type = 'post ' ) { $ type = papi _get _meta _type ( $ type ) ; $ class _suffix = ' _ ' . ucfirst ( $ type ) . ' _Store ' ; $ class _name = 'Papi ' . $ class _suffix ; if ( ! class _exists ( $ class _name ) ) { return ; } $ post _id = papi _get _post _id ( $ post _id ) ; $ page = new $ class _name ( $ post _id ) ; if ( ! $ page - > valid ( ) ) { return ; } return $ page ; } 
public function get _property _option ( $ slug , $ option , $ default = null ) { $ slug = unpapify ( $ slug ) ; $ property = $ this - > property ( $ slug ) ; 
public function html ( ) { $ options = $ this - > get _options ( ) ; $ title = ' ' ; $ text = ' ' ; if ( ! papi _is _empty ( $ options - > title ) ) { $ title = sprintf ( ' <h 3 > <span > %s < /span > < /h 3 > ' , esc _html ( $ options - > title ) ) ; } if ( ! papi _is _empty ( $ options - > description ) ) { $ text = sprintf ( ' <p > %s < /p > ' , $ options - > description ) ; } papi _render _html _tag ( 'div ' , [ 'class ' = > 'papi -property -divider ' , 'data -papi -rule ' = > esc _attr ( $ this - > html _name ( ) ) , sprintf ( ' %s %s ' , $ title , $ text ) ] ) ; } 
public function get _value ( ) { $ value = $ this - > get _option ( 'value ' ) ; if ( papi _is _empty ( $ value ) ) { $ type = papi _get _meta _type ( ) ; $ slug = $ this - > get _slug ( true ) ; $ value = papi _get _field ( $ slug , null , $ type ) ; $ post _status = get _post _status ( $ this - > get _post _id ( ) ) ; if ( papi _is _empty ( $ value ) & & ( $ post _status = = = false | | $ post _status = = = 'auto -draft ' ) ) { $ value = $ this - > get _option ( 'default ' ) ; } } if ( papi _is _empty ( $ value ) ) { return $ this - > default _value ; } if ( $ this - > convert _type = = = 'string ' ) { $ value = papi _convert _to _string ( $ value ) ; } return papi _santize _data ( $ value ) ; } 
public function can _render ( ) { 
public function render ( ) { 
protected function render _hidden _html ( ) { $ slug = $ this - > get _option ( 'slug ' ) ; if ( substr ( $ slug , - 1 ) = = = ' ] ' ) { $ slug = substr ( $ slug , 0 , - 1 ) ; $ slug = papi _get _property _type _key ( $ slug ) ; $ slug . = ' ] ' ; } else { $ slug = papi _get _property _type _key ( $ slug ) ; } $ slug = papify ( $ slug ) ; $ options = $ this - > get _options ( ) ; $ property _json = base 6 4 _encode ( papi _maybe _json _encode ( $ options ) ) ; papi _render _html _tag ( 'input ' , [ 'data -property ' = > strtolower ( $ this - > get _option ( 'type ' ) ) , 'name ' = > $ slug , 'type ' = > 'hidden ' , 'value ' = > $ property _json ] ) ; } 
protected function render _label _html ( ) { $ title = $ this - > get _option ( 'title ' ) ; papi _render _html _tag ( 'label ' , [ 'for ' = > $ this - > html _id ( ) , 'title ' = > trim ( $ title . ' ' . papi _property _require _text ( $ this - > get _options ( ) ) ) , $ title , papi _property _required _html ( $ this ) ] ) ; } 
protected function render _property _html ( ) { papi _render _html _tag ( 'div ' , [ 'class ' = > 'papi -before -html ' . $ this - > get _option ( 'before _class ' ) , 'data -property ' = > $ this - > get _option ( 'type ' ) , papi _maybe _get _callable _value ( $ this - > get _option ( 'before _html ' ) ) ] ) ; $ this - > html ( ) ; papi _render _html _tag ( 'div ' , [ 'class ' = > 'papi -after -html ' . $ this - > get _option ( 'after _class ' ) , 'data -property ' = > $ this - > get _option ( 'type ' ) , papi _maybe _get _callable _value ( $ this - > get _option ( 'after _html ' ) ) ] ) ; } 
protected function render _row _html ( ) { $ display _class = $ this - > display ( ) ? ' ' : ' papi -hide ' ; $ rules _class = papi _is _empty ( $ this - > get _rules ( ) ) ? ' ' : ' papi -rules -exists ' ; $ css _class = trim ( $ display _class . $ rules _class ) ; $ css _class . = sprintf ( ' papi -layout - %s ' , $ this - > get _option ( 'layout ' ) ) ; if ( $ this - > get _option ( 'raw ' ) ) { echo sprintf ( ' <div class = " %s " > ' , esc _attr ( $ css _class ) ) ; $ this - > render _property _html ( ) ; $ this - > render _hidden _html ( ) ; $ this - > render _rules _json ( ) ; echo ' < /div > ' ; } else { ? > <tr class = " < ?php echo esc _attr ( $ css _class ) ; ? > " > < ?php if ( $ this - > get _option ( 'sidebar ' ) & & $ this - > get _option ( 'layout ' ) = = = 'horizontal ' ) : ? > <td class = "papi -table -sidebar " > < ?php $ this - > render _label _html ( ) ; $ this - > render _description _html ( ) ; ? > < /td > < ?php endif ; ? > <td < ?php echo $ this - > get _option ( 'sidebar ' ) & & $ this - > get _option ( 'layout ' ) = = = 'horizontal ' ? ' ' : 'colspan = " 2 " ' ; ? > > < ?php < /td > < /tr > < ?php } } 
protected function render _rules _json ( ) { $ rules = $ this - > get _rules ( ) ; if ( empty ( $ rules ) ) { return ; } $ rules = $ this - > conditional - > prepare _rules ( $ rules , $ this ) ; papi _render _html _tag ( 'script ' , [ 'data -papi -rule -source -slug ' = > $ this - > html _name ( ) , 'data -papi -rules ' = > 'true ' , 'type ' = > 'application /json ' , papi _maybe _json _encode ( $ rules ) ] ) ; } 
public function format _value ( $ value , $ slug , $ post _id ) { if ( ! $ this - > get _setting ( 'allow _html ' ) & & $ this - > input _type = = = 'text ' ) { $ value = papi _maybe _json _decode ( maybe _unserialize ( $ value ) ) ; if ( ! is _string ( $ value ) ) { $ value = ' ' ; } $ value = wp _strip _all _tags ( $ value ) ; } return $ value ; } 
public function get _value ( ) { $ value = $ this - > format _value ( parent : : get _value ( ) , $ this - > get _slug ( ) , papi _get _post _id ( ) ) ; return $ this - > get _setting ( 'allow _html ' ) ? $ value : esc _html ( $ value ) ; } 
public function html ( ) { papi _render _html _tag ( 'input ' , [ 'id ' = > esc _attr ( $ this - > html _id ( ) ) , 'name ' = > esc _attr ( $ this - > html _name ( ) ) , 'type ' = > esc _attr ( $ this - > input _type ) , 'value ' = > $ this - > get _value ( ) , 'placeholder ' = > esc _attr ( $ this - > get _setting ( 'placeholder ' ) ) ] ) ; } 
protected function decode _property ( $ key , $ value ) { if ( papi _is _property _type _key ( $ key ) & & is _string ( $ value ) ) { $ value = base 6 4 _decode ( $ value ) ; $ value = papi _maybe _json _decode ( $ value ) ; } return $ value ; } 
protected function get _post _data ( $ pattern = ' / ^papi \ _ . * / ' ) { $ data = [ ] ; $ keys = preg _grep ( $ pattern , array _keys ( $ _POST ) ) ; foreach ( $ keys as $ key ) { 
protected function get _pre _deep _keys _value ( array $ arr ) { $ keys = [ ] ; $ value = null ; foreach ( $ arr as $ key = > $ v ) { if ( is _array ( $ v ) ) { $ keys [ ] = $ key ; list ( $ ks , $ val ) = $ this - > get _pre _deep _keys _value ( $ v ) ; $ keys = array _merge ( $ keys , $ ks ) ; $ value = $ val ; } else { $ keys [ ] = $ key ; $ value = $ v ; } } return [ $ keys , $ value ] ; } 
protected function prepare _post _data ( $ data ) { if ( ! is _array ( $ data ) ) { return $ data ; } foreach ( $ data as $ key = > $ value ) { if ( is _array ( $ value ) ) { $ data [ $ key ] = $ this - > prepare _post _data ( $ value ) ; } else { $ data [ $ key ] = $ this - > decode _property ( $ key , $ value ) ; } } return $ data ; } 
protected function prepare _properties _data ( array $ data = [ ] , $ post _id = 0 ) { 
protected function santize _data ( $ value ) { if ( is _array ( $ value ) ) { foreach ( $ value as $ k = > $ v ) { if ( is _string ( $ v ) ) { $ value [ $ k ] = $ this - > santize _data ( $ v ) ; } } } else if ( is _string ( $ value ) ) { $ value = wp _unslash ( $ value ) ; } return $ value ; } 
public function delete ( $ id , $ slug ) { $ fn = $ this - > get _function ( 'delete ' ) ; 
public function get _function ( $ context = 'get ' ) { switch ( $ this - > type ) { case 'option ' : return sprintf ( ' %s _option ' , $ context ) ; case 'site ' : case 'network ' : return sprintf ( ' %s _site _option ' , $ context ) ; case 'post ' : case 'term ' : return sprintf ( ' %s _metadata ' , $ context ) ; default : break ; } } 
public function get ( $ id , $ slug ) { $ fn = $ this - > get _function ( 'get ' ) ; if ( ! is _callable ( $ fn ) ) { return ; } if ( $ this - > id ) { $ value = call _user _func _array ( $ fn , [ $ this - > type , $ id , unpapify ( $ slug ) , true ] ) ; } else { $ value = call _user _func _array ( $ fn , [ unpapify ( $ slug ) , null ] ) ; } if ( papi _is _empty ( $ value ) ) { return ; } return $ value ; } 
public function update ( $ id , $ slug , $ value ) { $ save _value = true ; 
public function update _clear _cache ( $ id , $ value ) { $ value = is _array ( $ value ) ? $ value : [ ] ; foreach ( $ value as $ child _key = > $ child _value ) { papi _cache _delete ( $ child _key , $ id , $ this - > type ) ; if ( is _array ( $ child _value ) ) { $ this - > update _clear _cache ( $ id , $ child _value ) ; } } } 
public function get _revision _ui _diff ( $ return , $ compare _from , $ compare _to ) { $ meta = get _post _meta ( $ compare _from - > ID ) ; $ meta = is _array ( $ meta ) ? $ meta : [ ] ; foreach ( $ meta as $ key = > $ value ) { if ( $ key [ 0 ] = = = ' _ ' & & $ key ! = = papi _get _page _type _key ( ) ) { continue ; } $ content _from = papi _data _get ( $ compare _from - > ID , $ key ) ; $ content _to = papi _data _get ( $ compare _to - > ID , $ key ) ; $ diff = wp _text _diff ( $ content _from , $ content _to , [ 'show _split _view ' = > true ] ) ; if ( $ diff ) { $ return [ ] = [ 'id ' = > $ key , 'name ' = > $ key , 'diff ' = > $ diff , ] ; } } return $ return ; } 
public function hidden _meta _boxes ( ) { global $ _wp _post _type _features ; if ( isset ( $ _wp _post _type _features [ $ this - > post _type ] [ 'editor ' ] ) ) { return ; } add _meta _box ( 'papi -hidden -editor ' , 'Papi hidden editor ' , [ $ this , 'hidden _meta _box _editor ' ] , $ this - > post _type ) ; } 
public function load _post _new ( ) { $ request _uri = $ _SERVER [ 'REQUEST _URI ' ] ; $ post _types = papi _get _post _types ( ) ; if ( in _array ( $ this - > post _type , $ post _types , true ) & & strpos ( $ request _uri , 'page _type = ' ) = = = false ) { $ parsed _url = parse _url ( $ request _uri ) ; $ only _page _type = papi _filter _settings _only _page _type ( $ this - > post _type ) ; $ page _types = papi _get _all _page _types ( $ this - > post _type ) ; $ show _standard = false ; if ( count ( $ page _types ) = = = 1 & & empty ( $ only _page _type ) ) { $ show _standard = $ page _types [ 0 ] - > standard _type ; $ show _standard = $ show _standard ? papi _filter _settings _show _standard _page _type ( $ this - > post _type ) : $ show _standard ; $ only _page _type = $ show _standard ? ' ' : $ page _types [ 0 ] - > get _id ( ) ; } 
public function redirect _post _location ( $ location ) { if ( ! isset ( $ _SERVER [ 'HTTP _REFERER ' ] ) ) { return $ location ; } $ referer = $ _SERVER [ 'HTTP _REFERER ' ] ; $ referer = strtolower ( $ referer ) ; if ( strpos ( $ referer , 'papi -iframe -mode ' ) = = = false ) { return $ location ; } return sprintf ( ' %s &papi _css [ ] =papi -iframe -mode ' , $ location ) ; } 
public function setup ( ) { 
public function rename ( $ args , $ assoc _args ) { $ type = $ args [ 0 ] ; $ old _key = $ args [ 1 ] ; $ new _key = $ args [ 2 ] ; $ posts = ( new Papi _Query ( [ 'entry _type ' = > $ type , 'fields ' = > 'ids ' ] ) ) - > get _result ( ) ; if ( empty ( $ posts ) ) { WP _CLI : : error ( 'No posts found ' ) ; } foreach ( $ posts as $ post ) { $ meta = get _post _meta ( $ post , $ old _key , true ) ; if ( papi _is _empty ( $ meta ) ) { continue ; } if ( delete _post _meta ( $ post , $ old _key ) = = = false ) { WP _CLI : : error ( 'Could not delete post meta with key : ' . $ old _key ) ; } if ( update _post _meta ( $ post , $ new _key , $ meta ) = = = false ) { WP _CLI : : error ( 'Could not update post meta with key : ' . $ new _key ) ; } } WP _CLI : : success ( 'Done ' ) ; } 
public function get _field _slug ( ) { if ( preg _match ( ' / \ [ | \ ] / ' , $ this - > slug ) ) { $ slug = preg _replace ( ' / \ [ | \ ] / ' , ' . ' , $ this - > slug ) ; $ slug = str _replace ( ' . . ' , ' . ' , $ slug ) ; return substr ( $ slug , 0 , - 1 ) ; } return $ this - > slug ; } 
public function get _source ( ) { if ( is _callable ( $ this - > source ) ) { return call _user _func _array ( $ this - > source , [ $ this - > slug ] ) ; } if ( is _string ( $ this - > source ) & & strpos ( $ this - > source , ' # ' ) ! = = false ) { $ source = explode ( ' # ' , $ this - > source ) ; if ( empty ( $ source [ 0 ] ) | | empty ( $ source [ 1 ] ) ) { return $ this - > source ; } $ source [ 0 ] = new $ source [ 0 ] ( ) ; if ( method _exists ( $ source [ 0 ] , $ source [ 1 ] ) ) { return call _user _func _array ( $ source , [ $ this - > slug ] ) ; } return ; } return $ this - > source ; } 
public function setup _source ( $ value ) { if ( is _array ( $ value ) & & count ( $ value ) = = = 2 & & is _object ( $ value [ 0 ] ) & & is _string ( $ value [ 1 ] ) ) { return sprintf ( ' %s # %s ' , get _class ( $ value [ 0 ] ) , $ value [ 1 ] ) ; } if ( is _string ( $ value ) & & is _callable ( $ value ) ) { return $ value ; } 
protected function setup ( array $ rule ) { foreach ( $ rule as $ key = > $ value ) { if ( $ key = = = 'operator ' ) { $ value = strtoupper ( $ value ) ; $ value = html _entity _decode ( $ value ) ; } else if ( $ key = = = 'slug ' ) { $ value = papify ( $ value ) ; } else if ( $ key = = = 'source ' ) { $ value = $ this - > setup _source ( $ value ) ; } $ this - > $ key = $ value ; } } 
public function admin _init ( ) { $ meta _type = papi _get _meta _type ( ) ; $ meta _type = ucfirst ( $ meta _type ) ; $ class _name = 'Papi _Admin _Entry _ ' . $ meta _type ; 
public function admin _body _class ( $ classes ) { if ( $ entry _type = $ this - > get _entry _type ( ) ) { $ classes . = sprintf ( ' papi -body papi -meta -type - %s ' , papi _get _meta _type ( ) ) ; 
public function edit _form _after _title ( ) { wp _nonce _field ( 'papi _save _data ' , 'papi _meta _nonce ' ) ; if ( $ value = esc _attr ( papi _get _entry _type _id ( ) ) ) { papi _render _html _tag ( 'input ' , [ 'data -papi -page -type -key ' = > true , 'name ' = > esc _attr ( papi _get _page _type _key ( ) ) , 'type ' = > 'hidden ' , 'value ' = > $ value ] ) ; } } 
protected function get _entry _type ( ) { if ( $ this - > entry _type instanceof Papi _Entry _Type ) { return $ this - > entry _type ; } $ entry _type _id = papi _get _entry _type _id ( ) ; 
public function plugin _row _meta ( array $ links , $ file ) { if ( $ file = = = PAPI _PLUGIN _BASENAME ) { return array _merge ( $ links , [ 'docs ' = > ' <a href = " ' . esc _url ( 'https : / /wp -papi .github .io /docs / ' ) . ' " title = " ' . esc _attr ( _ _ ( 'View Papi Documentation ' , 'papi ' ) ) . ' " > ' . _ _ ( 'Docs ' , 'papi ' ) . ' < /a > ' , ] ) ; } return $ links ; } 
protected function setup _actions ( ) { add _action ( 'admin _init ' , [ $ this , 'admin _init ' ] ) ; add _action ( 'edit _form _after _title ' , [ $ this , 'edit _form _after _title ' ] ) ; if ( $ taxonomy = papi _get _taxonomy ( ) ) { add _action ( $ taxonomy . ' _add _form ' , [ $ this , 'edit _form _after _title ' ] ) ; add _action ( $ taxonomy . ' _edit _form ' , [ $ this , 'edit _form _after _title ' ] ) ; } } 
protected function setup _filters ( ) { add _filter ( 'admin _body _class ' , [ $ this , 'admin _body _class ' ] ) ; add _filter ( 'plugin _row _meta ' , [ $ this , 'plugin _row _meta ' ] , 1 0 , 2 ) ; add _filter ( 'wp _link _query ' , [ $ this , 'wp _link _query ' ] ) ; add _filter ( 'wp _refresh _nonces ' , [ $ this , 'wp _refresh _nonces ' ] , 1 1 ) ; add _filter ( 'pre _update _option ' , [ $ this , 'update _front _page ' ] , 1 0 , 2 ) ; } 
public function update _front _page ( $ value , $ option ) { if ( $ option ! = = 'page _on _front ' ) { return $ value ; } $ front _pages = papi _get _all _entry _types ( [ 'types ' = > [ 'front -page ' ] , ] ) ; if ( count ( $ front _pages ) = = = 0 ) { return $ value ; } $ old _page _type _id = papi _get _page _type _id ( $ value ) ; $ new _page _type _id = $ front _pages [ 0 ] - > get _id ( ) ; 
public function wp _link _query ( array $ results ) { foreach ( $ results as $ index = > $ value ) { $ post _type = papi _get _post _type ( $ value [ 'ID ' ] ) ; $ name = papi _get _page _type _name ( $ value [ 'ID ' ] ) ; if ( empty ( $ name ) ) { $ name = papi _filter _settings _standard _page _type _name ( $ post _type ) ; } $ results [ $ index ] [ 'info ' ] = esc _html ( $ name ) ; } return $ results ; } 
public function format _value ( $ value , $ slug , $ post _id ) { if ( is _numeric ( $ value ) & & intval ( $ value ) ! = = 0 ) { $ value = [ 'module ' = > get _post ( $ value ) , 'template ' = > papi _data _get ( $ post _id , sprintf ( ' %s _template ' , unpapify ( $ this - > html _name ( ) ) ) ) ] ; if ( papi _is _admin ( ) ) { return ( object ) $ value ; } 
protected function get _posts ( $ post _type = null ) { $ query = $ this - > get _setting ( 'query ' ) ; 
protected function get _templates ( $ id ) { if ( empty ( $ id ) & & ! is _numeric ( $ id ) ) { return [ ] ; } if ( $ data = papi _get _entry _type _by _meta _id ( $ id ) ) { $ templates = papi _to _array ( $ data - > template ) ; ksort ( $ templates ) ; return $ templates ; } return [ ] ; } 
public function html ( ) { $ layout = $ this - > get _setting ( 'layout ' ) ; $ post _type = $ this - > get _post _type ( ) ; $ settings = $ this - > get _settings ( ) ; $ value = $ this - > get _value ( ) ; $ posts = $ this - > get _posts ( $ post _type ) ; $ selected _post _id = is _object ( $ value ) ? $ value - > module : 0 ; $ selected _post _id = is _object ( $ selected _post _id ) ? $ selected _post _id - > ID : 0 ; $ templates = $ this - > get _templates ( $ selected _post _id ) ; $ selected _template = is _object ( $ value ) ? intval ( $ value - > template ) : null ; $ classes = ' ' ; if ( $ settings - > select 2 ) { $ classes . = ' papi -component -select 2 ' ; } ? > <div class = "papi -property -module papi -property -post advanced " > <table class = "papi -table " > <tr > <td > <label for = " < ?php echo esc _attr ( $ this - > html _id ( ) ) ; ? > _modules " > < ?php echo esc _html ( $ settings - > labels [ 'select _module ' ] ) ; ? > < /label > < /td > <td > < ?php $ placeholder = ! is _null ( $ settings - > placeholder ) ? $ settings - > placeholder : ' ' ; ? > <select class = " < ?php echo esc _attr ( $ classes ) ; ? > papi -property -module -right " id = " < ?php echo esc _attr ( $ this - > html _id ( ) ) ; ? > _modules " name = " < ?php echo esc _attr ( $ this - > html _name ( ) ) ; ? > " data -allow -clear = " < ?php echo empty ( $ settings - > placeholder ) ? 'false ' : 'true ' ; ? > " data -select -item = " < ?php echo esc _attr ( $ settings - > labels [ 'select _module ' ] ) ; ? > " data -placeholder = " < ?php echo esc _attr ( $ settings - > placeholder ) ; ? > " data -width = " 1 0 0 % " > < ?php if ( ! empty ( $ settings - > placeholder ) ) : ? > < ?php if ( $ settings - > new _url ) : ? > <option data -placeholder data -new -url = " < ?php echo esc _attr ( admin _url ( 'post -new .php ?post _type = ' . $ post _type ) ) ; ? > " > < /option > < ?php else : ? > <option > < /option > < ?php endif ; ? > < ?php endif ; ? > < ?php foreach ( $ posts as $ post ) { if ( papi _is _empty ( $ post - > post _title ) ) { continue ; } papi _render _html _tag ( 'option ' , [ 'data -entry -type ' = > get _post _meta ( $ post - > ID , papi _get _page _type _key ( ) , true ) , 'data -edit -url ' = > get _edit _post _link ( $ value ) , 'data -new -url ' = > $ settings - > new _url ? admin _url ( 'post -new .php ?post _type = ' . $ post - > post _type ) : ' ' , 'selected ' = > $ selected _post _id = = = $ post - > ID , 'value ' = > $ post - > ID , $ post - > post _title ] ) ; } ? > < /select > < /td > < /tr > <tr > <td > <label for = " < ?php echo esc _attr ( $ this - > html _id ( ) ) ; ? > _template " > < ?php echo esc _html ( $ settings - > labels [ 'select _template ' ] ) ; ? > < /label > < /td > <td > <select id = " < ?php echo esc _attr ( $ this - > html _id ( ) ) ; ? > _template " name = " < ?php echo esc _attr ( $ this - > html _name ( ) ) ; ? > _template " class = " < ?php echo esc _attr ( $ classes ) ; ? > papi -property -module -left " data -post -query = ' < ?php echo esc _attr ( papi _maybe _json _encode ( $ settings - > query ) ) ; ? > ' data -width = " 1 0 0 % " > < ?php foreach ( $ templates as $ index = > $ item ) { < /select > < /td > < /tr > < /table > < /div > < ?php } 
public function render _option _template ( ) { $ settings = $ this - > get _settings ( ) ; $ post _type = $ this - > get _post _type ( ) ; ? > <script type = "text /template " id = "tmpl -papi -property -module -option " > <option data -allow -clear = " < ?php echo esc _attr ( $ settings - > allow _clear ) ; ? > " value = " < % = value % > " > < % = title % > < /option > < /script > <script type = "text /template " id = "tmpl -papi -property -module -option -placeholder " > <option data -placeholder < ?php if ( $ settings - > new _url ) : ? > data -new -url = " < ?php echo esc _attr ( admin _url ( 'post -new .php ?post _type = ' . $ post _type ) ) ; ? > " < ?php endif ; ? > > < /option > < /script > < ?php } 
public function html ( ) { $ settings = $ this - > get _settings ( ) ; $ html = papi _maybe _get _callable _value ( $ settings - > html ) ; if ( $ settings - > save ) { $ value = $ this - > get _value ( ) ; if ( ! empty ( $ value ) & & is _string ( $ value ) ) { $ html = $ value ; } papi _render _html _tag ( 'input ' , [ 'name ' = > esc _attr ( $ this - > html _name ( ) ) , 'type ' = > 'hidden ' , 'value ' = > $ html ] ) ; } papi _render _html _tag ( 'div ' , [ 'data -papi -rule ' = > esc _attr ( $ this - > html _name ( ) ) , 'class ' = > 'property -html ' , $ html ] ) ; } 
protected function setup _args ( array $ args ) { foreach ( $ args as $ key = > $ value ) { if ( isset ( $ this - > $ key ) ) { $ this - > $ key = papi _esc _html ( $ value ) ; } } if ( empty ( $ this - > id ) ) { $ this - > id = strtolower ( papi _f ( papi _underscorify ( papify ( $ this - > title ) ) ) ) ; } } 
public function format _value ( $ value , $ slug , $ post _id ) { if ( ! $ this - > get _setting ( 'allow _html ' ) ) { $ value = maybe _unserialize ( $ value ) ; if ( ! is _string ( $ value ) ) { $ value = ' ' ; } $ value = wp _strip _all _tags ( $ value ) ; if ( ! papi _is _admin ( ) ) { $ value = $ this - > get _setting ( 'nl 2br ' ) ? nl 2br ( $ value ) : $ value ; } } return $ value ; } 
public function html ( ) { papi _render _html _tag ( 'textarea ' , [ 'class ' = > 'papi -property -text ' , 'id ' = > esc _attr ( $ this - > html _id ( ) ) , 'name ' = > esc _attr ( $ this - > html _name ( ) ) , $ this - > get _value ( ) ] ) ; } 
public function get _property ( $ slug , $ child _slug = ' ' ) { $ page _type _id = papi _get _page _type _id ( $ this - > id ) ; $ page _type = papi _get _entry _type _by _id ( $ page _type _id ) ; if ( $ page _type instanceof Papi _Page _Type = = = false ) { return ; } if ( $ property = $ page _type - > get _property ( $ slug , $ child _slug ) ) { return $ this - > prepare _property ( $ property ) ; } } 
protected function prepare _load _value ( Papi _Core _Property $ property , $ value ) { if ( $ property - > overwrite ) { 
public function save _properties ( ) { if ( $ _SERVER [ 'REQUEST _METHOD ' ] ! = = 'POST ' | | papi _get _meta _type ( ) ! = = 'option ' ) { return ; } * Fire `save _properties ` action when all is done . * * @param int $id * @param string $meta _type * / do _action ( 'papi /save _properties ' , 0 , 'option ' ) ; } 
public function metabox ( ) { $ post _type = papi _get _post _type ( ) ; $ page _type = papi _get _entry _type _by _id ( papi _get _page _type _id ( ) ) ; $ page _type _key = papi _get _page _type _key ( 'switch ' ) ; $ page _types = papi _get _all _page _types ( $ post _type ) ; $ show _standard = papi _filter _settings _show _standard _page _type ( $ post _type ) ; if ( $ show _standard ) { $ standard _page _type = papi _get _standard _page _type ( $ post _type ) ; $ page _types [ ] = $ standard _page _type ; if ( empty ( $ page _type ) ) { $ page _type = $ standard _page _type ; } } usort ( $ page _types , function ( $ a , $ b ) { return strcmp ( $ a - > name , $ b - > name ) ; } ) ; $ page _types = papi _sort _order ( array _reverse ( $ page _types ) ) ; <div class = "misc -pub -section misc -pub -section -last papi -page -type -switcher " > <label for = " < ?php echo esc _attr ( $ page _type _key ) ; ? > " > < ?php esc _html _e ( 'Page Type : ' , 'papi ' ) ; ? > < /label > <span > < ?php echo esc _html ( $ page _type - > name ) ; ? > < /span > < ?php if ( papi _current _user _is _allowed ( $ page _type - > capabilities ) & & $ page _type - > switcher ) : ? > <a href = " # " id = "papi -page -type -switcher -edit " class = "hide -if -no -js " > < ?php esc _html _e ( 'Edit ' , 'papi ' ) ; ? > < /a > <div > <select name = " < ?php echo esc _attr ( $ page _type _key ) ; ? > " id = " < ?php echo esc _attr ( $ page _type _key ) ; ? > " > < ?php foreach ( $ page _types as $ pt ) { if ( ! papi _current _user _is _allowed ( $ pt - > capabilities ) ) { continue ; } papi _render _html _tag ( 'option ' , [ 'selected ' = > $ page _type - > match _id ( $ pt - > get _id ( ) ) , 'value ' = > esc _attr ( $ pt - > get _id ( ) ) , esc _html ( $ pt - > name ) ] ) ; } ? > < /select > <a href = " # " id = "papi -page -type -switcher -save " class = "hide -if -no -js button " > < ?php esc _html _e ( 'OK ' , 'papi ' ) ; ? > < /a > <a href = " # " id = "papi -page -type -switcher -cancel " class = "hide -if -no -js " > < ?php esc _html _e ( 'Cancel ' , 'papi ' ) ; ? > < /a > < /div > < ?php endif ; ? > < /div > < ?php } 
public function save _post ( $ post _id , $ post ) { 
protected function overwrite _post _data ( $ post _id ) { global $ wpdb ; if ( empty ( $ post _id ) | | empty ( $ this - > overwrite ) ) { return ; } $ wpdb - > update ( $ wpdb - > posts , $ this - > overwrite , [ 'ID ' = > $ post _id ] ) ; 
protected function pre _save ( $ id ) { if ( empty ( $ id ) ) { return ; } $ data = $ this - > get _pre _data ( ) ; foreach ( $ data as $ key = > $ value ) { if ( empty ( $ value ) ) { continue ; } if ( is _array ( $ value ) ) { list ( $ keys , $ value ) = $ this - > get _pre _deep _keys _value ( $ value ) ; $ key = sprintf ( ' %s _ %s ' , $ key , implode ( ' _ ' , $ keys ) ) ; } update _metadata ( $ this - > get _meta _type ( ) , $ id , $ key , $ value ) ; } } 
public function save _meta _boxes ( $ id , $ post = null ) { 
public function save _revision ( $ revision _id ) { 
public function save _properties ( $ id ) { * Fire `save _properties ` action when all is done . * * @param int $id * @param string $meta _type * / do _action ( 'papi /save _properties ' , $ id , $ meta _type ) ; } 
public function restore _post _revision ( $ post _id , $ revision _id ) { if ( papi _is _empty ( papi _get _entry _type _by _meta _id ( $ post _id , 'post ' ) ) ) { return ; } $ meta = get _post _meta ( $ revision _id ) ; foreach ( $ meta as $ key = > $ value ) { if ( $ key [ 0 ] = = = ' _ ' & & $ key ! = = papi _get _page _type _key ( ) ) { continue ; } papi _data _update ( $ post _id , $ key , array _shift ( $ value ) ) ; } } 
protected function setup _actions ( ) { add _action ( ' _wp _put _post _revision ' , [ $ this , 'save _revision ' ] ) ; add _action ( 'save _post ' , [ $ this , 'save _meta _boxes ' ] , 1 , 2 ) ; add _action ( 'created _term ' , [ $ this , 'save _meta _boxes ' ] , 1 ) ; add _action ( 'edit _term ' , [ $ this , 'save _meta _boxes ' ] , 1 ) ; add _action ( 'wp _restore _post _revision ' , [ $ this , 'restore _post _revision ' ] , 1 0 , 2 ) ; } 
protected function valid _post _id ( $ post _id ) { $ key = papi _get _sanitized _post ( 'action ' ) = = = 'save -attachment -compat ' ? 'id ' : 'post _ID ' ; $ val = papi _get _sanitized _post ( $ key ) ; 
public function display ( array $ rules , $ property = null ) { if ( empty ( $ rules ) ) { return true ; } $ rules = $ this - > prepare _rules ( $ rules , $ property ) ; if ( in _array ( $ rules [ 'relation ' ] , $ this - > relations , true ) ) { return $ this - > display _by _relation ( $ rules ) ; } return true ; } 
protected function display _by _relation ( array $ rules ) { if ( $ rules [ 'relation ' ] = = = 'AND ' ) { $ display = true ; foreach ( $ rules as $ rule ) { if ( ! $ display ) { break ; } if ( papi _is _rule ( $ rule ) ) { $ display = apply _filters ( 'papi /conditional /rule _allowed ' , papi _filter _conditional _rule _allowed ( $ rule ) , $ rule ) ; } } return $ display ; } $ empty = array _filter ( $ rules , function ( $ rule ) { return papi _is _rule ( $ rule ) ? true : null ; } ) ; if ( empty ( $ empty ) ) { return true ; } $ result = [ ] ; foreach ( $ rules as $ rule ) { if ( papi _is _rule ( $ rule ) ) { $ result [ ] = apply _filters ( 'papi /conditional /rule _allowed ' , papi _filter _conditional _rule _allowed ( $ rule ) , $ rule ) ; } } $ result = array _filter ( $ result , function ( $ res ) { return $ res = = = true ? true : null ; } ) ; return ! empty ( $ result ) ; } 
protected function get _rule _slug ( $ rule , $ property ) { $ arr _reg = ' / \ [ \d + \ ] ( \ [ \w + \ ] ) $ / ' ; $ slug = $ property - > get _slug ( ) ; $ page _type = papi _get _entry _type _by _meta _id ( ) ; if ( $ page _type instanceof Papi _Page _Type = = = false ) { return $ rule - > slug ; } if ( preg _match ( $ arr _reg , $ slug , $ out ) ) { $ slug = str _replace ( $ out [ 1 ] , ' [ ' . unpapify ( $ rule - > slug ) . ' ] ' , $ slug ) ; $ property = $ page _type - > get _property ( $ slug ) ; if ( papi _is _property ( $ property ) ) { return $ slug ; } } return $ rule - > slug ; } 
public function prepare _rules ( array $ rules , $ property = null ) { if ( ! isset ( $ rules [ 'relation ' ] ) ) { $ rules [ 'relation ' ] = 'OR ' ; } else { $ rules [ 'relation ' ] = strtoupper ( $ rules [ 'relation ' ] ) ; } foreach ( $ rules as $ index = > $ value ) { if ( is _string ( $ index ) ) { continue ; } if ( is _array ( $ value ) ) { $ rules [ $ index ] = new Papi _Core _Conditional _Rule ( $ value ) ; if ( strpos ( $ rules [ $ index ] - > slug , ' . ' ) = = = false & & papi _is _property ( $ property ) ) { $ rules [ $ index ] - > slug = $ this - > get _rule _slug ( $ rules [ $ index ] , $ property ) ; } } } return $ rules ; } 
public function allowed ( ) { $ args = func _get _args ( ) ; if ( empty ( $ args ) ) { return parent : : allowed ( ) ; } return papi _current _user _is _allowed ( $ this - > capabilities ) & & isset ( $ args [ 0 ] ) & & in _array ( $ args [ 0 ] , $ this - > post _type , true ) ; } 
public function get _body _classes ( ) { $ classes = parent : : get _body _classes ( ) ; if ( ! $ this - > show _permalink ) { $ classes [ ] = 'papi -hide -edit -slug -box ' ; } if ( ! $ this - > show _page _attributes ) { $ classes [ ] = 'papi -hide -pageparentdiv ' ; } return $ classes ; } 
public function get _child _types ( ) { $ child _types = [ ] ; foreach ( papi _to _array ( $ this - > child _types ) as $ id ) { $ child _type = papi _get _entry _type _by _id ( $ id ) ; if ( $ child _type instanceof Papi _Page _Type ) { $ child _types [ ] = $ child _type ; } } return $ child _types ; } 
public function get _labels ( ) { if ( ! $ this - > fill _labels ) { return $ this - > labels ; } return array _merge ( $ this - > labels , [ 'add _new _item ' = > sprintf ( ' %s %s ' , _ _ ( 'Add New ' , 'papi ' ) , $ this - > name ) , 'edit _item ' = > sprintf ( ' %s %s ' , _ _ ( 'Edit ' , 'papi ' ) , $ this - > name ) , 'view _item ' = > sprintf ( ' %s %s ' , _ _ ( 'View ' , 'papi ' ) , $ this - > name ) ] ) ; } 
protected function get _post _type _supports ( ) { $ supports = [ 'custom -fields ' ] ; if ( method _exists ( $ this , 'remove ' ) ) { $ output = $ this - > remove ( ) ; $ output = is _string ( $ output ) ? [ $ output ] : $ output ; $ output = is _array ( $ output ) ? $ output : [ ] ; $ output = array _filter ( $ output , 'is _string ' ) ; $ supports = array _merge ( $ supports , $ output ) ; } $ parent _class = get _parent _class ( $ this ) ; $ parent _remove = method _exists ( $ parent _class , 'remove ' ) ; while ( $ parent _remove ) { $ parent = new $ parent _class ( ) ; $ output = $ parent - > remove ( ) ; $ output = is _string ( $ output ) ? [ $ output ] : $ output ; $ output = is _array ( $ output ) ? $ output : [ ] ; $ output = array _filter ( $ output , 'is _string ' ) ; $ supports = array _merge ( $ supports , $ output ) ; $ parent _class = get _parent _class ( $ parent _class ) ; $ parent _remove = method _exists ( $ parent _class , 'remove ' ) ; } return $ supports ; } 
public function remove _post _type _support ( ) { global $ _wp _post _type _features ; $ post _type = $ this - > get _post _type ( ) ; if ( empty ( $ post _type ) ) { return ; } $ post _type _supports = $ this - > get _post _type _supports ( ) ; foreach ( $ post _type _supports as $ key = > $ value ) { if ( is _numeric ( $ key ) ) { $ key = $ value ; $ value = ' ' ; } if ( isset ( $ _wp _post _type _features [ $ post _type ] , $ _wp _post _type _features [ $ post _type ] [ $ key ] ) ) { unset ( $ _wp _post _type _features [ $ post _type ] [ $ key ] ) ; continue ; } if ( in _array ( strtolower ( $ key ) , [ 'all ' , 'normal ' , 'side ' , 'advanced ' ] , true ) ) { $ value = strtolower ( $ key ) ; } else if ( empty ( $ value ) ) { $ value = 'normal ' ; } $ this - > remove _meta _boxes [ ] = [ $ key , $ value ] ; } add _action ( 'add _meta _boxes ' , [ $ this , 'remove _meta _boxes ' ] , 9 9 9 ) ; } 
public function remove _meta _boxes ( ) { global $ wp _meta _boxes ; $ post _type = $ this - > get _post _type ( ) ; $ context = [ ] ; foreach ( $ this - > remove _meta _boxes as $ item ) { if ( $ item [ 0 ] ! = = $ item [ 1 ] ) { remove _meta _box ( $ item [ 0 ] , $ post _type , $ item [ 1 ] ) ; continue ; } $ context = $ item [ 0 ] ; 
public function setup ( ) { parent : : setup ( ) ; 
protected function setup _post _types ( ) { $ this - > post _type = papi _to _array ( $ this - > post _type ) ; 
protected function setup _page _templates ( ) { if ( ! is _array ( $ this - > template ) | | ! $ this - > has _post _type ( papi _get _post _type ( ) ) ) { return ; } $ this - > show _page _template = true ; foreach ( $ this - > post _type as $ post _type ) { 
protected function add _mce _buttons ( ) { for ( $ i = 0 ; $ i < 4 ; $ i + + ) { $ num = $ i = = = 0 ? ' ' : ' _ ' . ( $ i + 1 ) ; add _filter ( 'mce _buttons ' . $ num , [ $ this , 'mce _buttons ' ] ) ; } } 
public function html ( ) { $ value = $ this - > get _value ( ) ; $ value = html _entity _decode ( $ value ) ; $ id = str _replace ( ' [ ' , ' ' , str _replace ( ' ] ' , ' ' , $ this - > html _name ( ) ) ) . ' - ' . uniqid ( ) ; 
protected function reove _mce _buttons ( ) { for ( $ i = 0 ; $ i < 4 ; $ i + + ) { $ num = $ i = = = 0 ? ' ' : ' _ ' . ( $ i + 1 ) ; remove _filter ( 'mce _buttons ' . $ num , [ $ this , 'mce _buttons ' ] ) ; } } 
public function delete _value ( $ slug , $ post _id , $ type ) { $ rows = intval ( papi _data _get ( $ post _id , $ slug , $ type ) ) ; $ value = $ this - > load _value ( $ rows , $ slug , $ post _id ) ; $ value = papi _property _to _array _slugs ( $ value , $ slug ) ; $ result = true ; foreach ( array _keys ( $ value ) as $ key ) { $ out = papi _data _delete ( $ post _id , $ key , $ type ) ; $ result = $ out ? $ result : $ out ; } return $ result ; } 
public function format _value ( $ values , $ repeater _slug , $ post _id ) { if ( ! is _array ( $ values ) ) { return [ ] ; } $ top _property = new Papi _Core _Property ; foreach ( $ values as $ index = > $ row ) { if ( ! is _array ( $ row ) ) { continue ; } $ top _property - > slug = $ repeater _slug . ' _ ' . $ index ; foreach ( $ row as $ slug = > $ value ) { if ( papi _is _property _type _key ( $ slug ) ) { continue ; } 
protected function get _results ( $ value , $ repeater _slug , $ post _id ) { global $ wpdb ; if ( $ this - > get _meta _type ( ) = = = 'option ' ) { $ table = $ wpdb - > prefix . 'options ' ; 
protected function get _row _results ( $ dbresults ) { $ results = [ ] ; $ is _option = $ this - > get _meta _type ( ) = = = 'option ' ; foreach ( $ dbresults as $ meta ) { if ( $ is _option ) { preg _match ( ' / ^ [ ^ \d ] * ( \d + ) / ' , $ meta - > option _name , $ matches ) ; } else { preg _match ( ' / ^ [ ^ \d ] * ( \d + ) / ' , $ meta - > meta _key , $ matches ) ; } if ( count ( $ matches ) < 2 ) { continue ; } $ i = intval ( $ matches [ 1 ] ) ; if ( ! isset ( $ results [ $ i ] ) ) { $ results [ $ i ] = [ ] ; } if ( $ is _option ) { $ results [ $ i ] [ $ meta - > option _name ] = ( object ) [ 'meta _key ' = > $ meta - > option _name , 'meta _value ' = > $ meta - > option _value ] ; } else { $ results [ $ i ] [ $ meta - > meta _key ] = $ meta ; } } return $ results ; } 
protected function get _settings _properties ( ) { $ settings = $ this - > get _settings ( ) ; if ( is _null ( $ settings ) ) { return [ ] ; } return $ this - > prepare _properties ( papi _to _array ( $ settings - > items ) ) ; } 
public function html ( ) { $ options = $ this - > get _options ( ) ; 
public function load _value ( $ value , $ repeater _slug , $ post _id ) { if ( is _array ( $ value ) ) { return $ value ; } list ( $ results , $ trash ) = $ this - > get _results ( $ value , $ repeater _slug , $ post _id ) ; 
protected function load _child _properties ( array $ results , $ property = null ) { foreach ( $ results as $ index = > $ row ) { foreach ( $ row as $ slug = > $ value ) { if ( is _array ( $ value ) & & isset ( $ value [ $ slug ] ) ) { $ child _property = $ this - > get _store ( ) - > get _property ( $ this - > get _slug ( true ) , $ slug ) ; if ( papi _is _property ( $ child _property ) & & ! empty ( $ child _property - > get _child _properties ( ) ) ) { $ value = papi _from _property _array _slugs ( $ value , unpapify ( $ slug ) ) ; $ results [ $ index ] [ $ slug ] = $ this - > load _child _properties ( $ value , $ child _property ) ; } } $ type _key = papi _get _property _type _key _f ( $ slug ) ; if ( $ property - > match _slug ( $ slug ) ) { $ results [ $ index ] [ $ type _key ] = $ property ; } else { $ results [ $ index ] [ $ type _key ] = $ property - > get _child _property ( $ slug ) ; } } } return $ results ; } 
protected function prepare _properties ( $ items ) { $ key = isset ( $ this - > layout _key ) & & $ this - > layout _key = = = ' _layout ' ? 'flexible ' : 'repeater ' ; $ items = array _map ( 'papi _property ' , $ items ) ; $ exclude _properties = $ this - > exclude _properties ; $ exclude _properties = array _merge ( $ exclude _properties , apply _filters ( 'papi /property / ' . $ key . ' /exclude ' , [ ] ) ) ; return array _filter ( $ items , function ( $ item ) use ( $ exclude _properties ) { if ( ! is _object ( $ item ) ) { return false ; } if ( empty ( $ item - > type ) ) { return false ; } return ! in _array ( $ item - > type , $ exclude _properties , true ) ; } ) ; } 
protected function prepare _property _for _json ( $ property ) { 
protected function remove _repeater _rows ( $ post _id , $ repeater _slug ) { global $ wpdb ; $ is _option = $ this - > get _meta _type ( ) = = = 'option ' ; $ repeater _slug = $ repeater _slug . ' _ % ' ; if ( $ is _option ) { $ table = $ wpdb - > prefix . 'options ' ; 
public function render _ajax _request ( ) { $ items = $ this - > get _settings _properties ( ) ; if ( papi _doing _ajax ( ) ) { $ counter = papi _get _qs ( 'counter ' ) ; $ this - > counter = intval ( $ counter ) ; } $ this - > render _properties ( $ items , false ) ; } 
protected function render _json _template ( $ slug ) { $ options = $ this - > get _options ( ) ; $ options - > settings - > items = papi _to _array ( $ options - > settings - > items ) ; foreach ( $ options - > settings - > items as $ key = > $ value ) { $ property = $ this - > prepare _property _for _json ( papi _property ( $ value ) ) ; if ( $ property = = = false ) { unset ( $ options - > settings - > items [ $ key ] ) ; continue ; } $ options - > settings - > items [ $ key ] = $ property ; } papi _render _html _tag ( 'script ' , [ 'data -papi -json ' = > esc _attr ( sprintf ( ' %s _repeater _json ' , $ slug ) ) , 'type ' = > 'application /json ' , papi _maybe _json _encode ( [ $ options ] ) ] ) ; } 
protected function render _properties ( $ row , $ value ) { $ layout = $ this - > get _setting ( 'layout ' ) ; if ( $ layout = = = 'row ' ) : ? > <td class = "repeater -layout -row " > <div class = "repeater -content -open " > <table class = "papi -table " > <tbody > < ?php endif ; $ has _value = $ value ! = = false ; foreach ( $ row as $ property ) { < /tbody > < /table > < /div > < /td > < ?php endif ; } 
protected function render _repeater ( $ options ) { ? > <div class = "papi -property -repeater papi -property -repeater -top " data -limit = " < ?php echo esc _attr ( $ this - > get _setting ( 'limit ' ) ) ; ? > " > <table class = "papi -table " > < ?php $ this - > render _repeater _head ( ) ; ? > <tbody class = "repeater -tbody " > < ?php $ this - > render _repeater _rows ( ) ; ? > < /tbody > < /table > <div class = "bottom " > < ?php papi _render _html _tag ( 'button ' , [ 'class ' = > 'button button -primary ' , 'data -papi -json ' = > sprintf ( ' %s _repeater _json ' , $ options - > slug ) , 'type ' = > 'button ' , esc _html ( $ this - > get _setting ( 'add _new _label ' ) ) ] ) ; ? > < /div > < ?php ? > <input type = "hidden " data -papi -rule = " < ?php echo esc _attr ( $ options - > slug ) ; ? > " name = " < ?php echo esc _attr ( $ options - > slug ) ; ? > [ ] " / > < /div > < ?php } 
protected function render _repeater _head ( ) { $ properties = $ this - > get _settings _properties ( ) ; ? > <thead > < ?php if ( ! $ this - > layout ( 'row ' ) ) : ? > <tr > <th > < /th > < ?php foreach ( $ properties as $ property ) : <th class = "repeater -column < ?php echo $ property - > display ( ) ? ' ' : 'papi -hide ' ; ? > " > < ?php echo esc _html ( $ property - > title ) ; ? > < /th > < ?php endforeach ; ? > <th class = "last " > < /th > < /tr > < ?php endif ; ? > < /thead > < ?php } 
protected function render _repeater _rows ( ) { $ items = $ this - > get _settings _properties ( ) ; $ values = $ this - > get _value ( ) ; $ values = is _array ( $ values ) ? $ values : [ ] ; $ slugs = wp _list _pluck ( $ items , 'slug ' ) ; <tr < ?php echo $ closed _rows ? 'class = "closed " ' : ' ' ; ? > > <td class = "handle " > <span class = "toggle " > < /span > <span class = "count " > < ?php echo esc _html ( $ this - > counter + 1 ) ; ? > < /span > < /td > < ?php $ this - > render _properties ( $ items , $ row ) ; $ this - > counter + + ; ? > <td class = "last " > <span > <a title = " < ?php esc _attr _e ( 'Remove ' , 'papi ' ) ; ? > " href = " # " class = "repeater -remove -item " >x < /a > < /span > < /td > < /tr > < ?php endforeach ; } 
public function update _value ( $ values , $ repeater _slug , $ post _id ) { $ rows = intval ( papi _data _get ( $ post _id , $ repeater _slug , $ this - > get _meta _type ( ) ) ) ; if ( ! is _array ( $ values ) ) { $ values = [ ] ; } list ( $ results , $ trash ) = $ this - > get _results ( $ rows , $ repeater _slug , $ post _id ) ; 
public function register ( ) { 
public function get _setting ( $ key , $ value ) { $ property = null ; foreach ( ( array ) $ this - > entries as $ entry ) { if ( $ property = $ entry - > get _property ( $ key ) ) { break ; } } if ( is _null ( $ property ) ) { return $ value ; } $ value = papi _get _option ( $ key ) ; return $ property - > rest _prepare _value ( $ value ) ; } 
public function prepare _response ( $ response ) { $ response = ( array ) $ response ; foreach ( $ response as $ key = > $ value ) { $ setting = $ this - > get _setting ( $ key , $ value ) ; if ( $ setting ! = = $ value ) { $ response [ $ key ] = $ setting ; } } return $ response ; } 
public function format _value ( $ value , $ slug , $ post _id ) { if ( is _object ( $ value ) & & isset ( $ value - > ID ) ) { $ value = $ value - > ID ; } if ( is _numeric ( $ value ) ) { return $ value = = = 0 ? null : new WP _User ( $ value ) ; } return $ value ; } 
public function get _value ( ) { $ user = parent : : get _value ( ) ; if ( is _object ( $ user ) & & isset ( $ user - > ID ) ) { return $ user - > ID ; } return 0 ; } 
public function get _items ( ) { $ capabilities = papi _to _array ( $ this - > get _setting ( 'capabilities ' ) ) ; $ users = get _users ( ) ; $ items = [ ] ; foreach ( $ users as $ user ) { $ allcaps = $ user - > allcaps ; if ( count ( array _diff ( $ capabilities , array _keys ( $ allcaps ) ) ) = = = 0 ) { $ items [ $ user - > display _name ] = $ user - > ID ; } } ksort ( $ items ) ; return $ items ; } 
public function update _value ( $ value , $ slug , $ post _id ) { if ( $ value instanceof WP _User ) { $ value = $ value - > ID ; } return ( int ) $ value ; } 
protected function constants ( ) { 
protected function init ( ) { 
protected function load _textdomain ( ) { $ locale = function _exists ( 'get _user _local ' ) ? get _user _local ( ) : get _locale ( ) ; $ locale = apply _filters ( 'plugin _locale ' , $ locale , 'papi ' ) ; load _textdomain ( 'papi ' , WP _LANG _DIR . ' /papi /papi - ' . $ locale . ' .mo ' ) ; load _textdomain ( 'papi ' , PAPI _PLUGIN _DIR . ' . . /languages /papi - ' . $ locale . ' .mo ' ) ; } 
protected function require _files ( ) { 
public static function deactivate ( ) { 
public function format _value ( $ value , $ slug , $ post _id ) { if ( ! $ this - > get _setting ( 'multiple ' ) ) { return $ this - > is _string _items ( ) ? $ value : papi _cast _string _value ( $ value ) ; } $ value = is _array ( $ value ) ? $ value : [ ] ; if ( ! $ this - > is _string _items ( ) ) { $ value = array _map ( 'papi _cast _string _value ' , $ value ) ; } return $ value ; } 
public function is _string _items ( ) { $ items = $ this - > get _items ( ) ; if ( empty ( $ items ) ) { return false ; } $ items = array _values ( $ items ) ; return is _string ( $ items [ 0 ] ) ; } 
public function html ( ) { 
public function load _value ( $ value , $ slug , $ post _id ) { $ value = maybe _unserialize ( $ value ) ; return papi _maybe _json _decode ( $ value , $ this - > get _setting ( 'multiple ' ) ) ; } 
public function format _value ( $ value , $ slug , $ post _id ) { if ( ! is _array ( $ value ) ) { return [ ] ; } 
protected function get _settings _properties ( ) { $ settings = $ this - > get _settings ( ) ; if ( is _null ( $ settings ) ) { return [ ] ; } return array _filter ( array _map ( 'papi _property ' , papi _to _array ( $ settings - > items ) ) , 'papi _is _property ' ) ; } 
public function html ( ) { $ properties = $ this - > get _settings _properties ( ) ; $ properties = $ this - > prepare _properties ( $ properties ) ; 
protected function prepare _properties ( $ properties ) { $ result = [ ] ; $ value = $ this - > get _value ( ) ; $ value = is _array ( $ value ) ? $ value : [ ] ; foreach ( $ properties as $ property ) { $ render _property = clone $ property - > get _options ( ) ; $ value _slug = $ property - > get _slug ( true ) ; if ( array _key _exists ( $ value _slug , $ value ) ) { $ render _property - > value = $ value [ $ value _slug ] ; } else { $ render _property - > value = null ; } $ render _property - > slug = $ this - > html _name ( $ property ) ; $ result [ ] = $ render _property ; } return $ result ; } 
public function update _value ( $ values , $ slug , $ post _id ) { if ( ! isset ( $ values [ 0 ] ) & & ! empty ( $ values ) ) { $ values = [ $ values ] ; } return parent : : update _value ( $ values , $ slug , $ post _id ) ; } 
public function format _value ( $ value , $ slug , $ post _id ) { if ( ! is _array ( $ value ) ) { $ value = $ this - > get _file ( $ value ) ; } 
public function get _file ( $ value ) { $ meta _key = $ this - > get _setting ( 'meta _key ' ) ; if ( empty ( $ meta _key ) ) { if ( is _numeric ( $ value ) & & intval ( $ value ) ! = = 0 ) { $ post = get _post ( $ value ) ; } } else if ( ! empty ( $ value ) ) { $ args = [ 'fields ' = > 'ids ' , 'meta _key ' = > $ meta _key , 'meta _value ' = > $ value , 'posts _per _page ' = > 1 , 'post _type ' = > 'attachment ' , 'post _status ' = > 'any ' ] ; $ query = new WP _Query ( $ args ) ; if ( ! empty ( $ query - > posts ) ) { $ post = get _post ( $ query - > posts [ 0 ] ) ; } } if ( empty ( $ post ) ) { return $ value ; } return $ post - > ID ; } 
protected function get _file _value ( $ value ) { $ meta _key = $ this - > get _setting ( 'meta _key ' ) ; if ( ! is _object ( $ value ) ) { return 0 ; } if ( empty ( $ meta _key ) ) { return $ value - > id ; } if ( $ value = get _post _meta ( $ value - > id , $ meta _key , true ) ) { return $ value ; } return 0 ; } 
public function html ( ) { $ css _classes = ' ' ; $ labels = $ this - > get _labels ( ) ; $ settings = $ this - > get _settings ( ) ; $ slug = $ this - > html _name ( ) ; $ value = papi _to _array ( $ this - > get _value ( ) ) ; <div class = "papi -property -file < ?php echo esc _attr ( $ css _classes ) ; ? > " data -file -type = " < ?php echo esc _attr ( $ this - > file _type ) ; ? > " > <p class = "papi -file -select < ?php echo $ show _button ? ' ' : 'papi -hide ' ; ? > " > < ?php if ( ! $ settings - > multiple ) { echo esc _html ( $ labels [ 'no _file ' ] ) . ' &nbsp ; ' ; } papi _render _html _tag ( 'input ' , [ 'name ' = > esc _attr ( $ slug ) , 'type ' = > 'hidden ' , 'value ' = > ' ' ] ) ; papi _render _html _tag ( 'button ' , [ 'data -slug ' = > esc _attr ( $ slug ) , 'class ' = > 'button ' , 'type ' = > 'button ' , esc _html ( $ labels [ 'add ' ] ) ] ) ; ? > < /p > <div class = "attachments " > < ?php if ( is _array ( $ value ) ) : foreach ( $ value as $ file ) : if ( ! is _object ( $ file ) ) { continue ; } $ url = wp _get _attachment _thumb _url ( $ file - > id ) ; if ( empty ( $ url ) ) { $ url = wp _mime _type _icon ( $ file - > id ) ; } ? > <div class = "attachment " > <a class = "check " href = " # " > &times ; < /a > <div class = "attachment -preview " > <div class = "thumbnail " > <div class = "centered " > < ?php papi _render _html _tag ( 'img ' , [ 'alt ' = > esc _attr ( $ file - > alt ) , 'src ' = > esc _attr ( $ url ) ] ) ; papi _render _html _tag ( 'input ' , [ 'name ' = > esc _attr ( $ slug ) , 'type ' = > 'hidden ' , 'value ' = > $ file - > id ] ) ; if ( ! isset ( $ file - > file ) & & isset ( $ file - > url ) ) { $ file - > file = $ file - > url ; } ? > < /div > < ?php if ( $ this - > file _type = = = 'file ' ) : ? > <div class = "filename " > <div > < ?php echo esc _html ( basename ( $ file - > file ) ) ; ? > < /div > < /div > < ?php endif ; ? > < /div > < /div > < /div > < ?php endforeach ; endif ; ? > < /div > <div class = "clear " > < /div > < /div > < ?php } 
public function update _value ( $ values , $ slug , $ post _id ) { if ( ! is _array ( $ values ) ) { $ values = $ this - > get _file _value ( ( object ) [ 'id ' = > $ values ] ) ; if ( empty ( $ values ) ) { return ; } return $ values ; } foreach ( $ values as $ index = > $ value ) { if ( ! is _numeric ( $ value ) ) { continue ; } $ values [ $ index ] = $ this - > get _file _value ( ( object ) [ 'id ' = > $ value ] ) ; } return array _filter ( $ values ) ; } 
public function bind ( $ id , $ value = null , $ singleton = false ) { if ( is _string ( $ id ) & & $ this - > is _singleton ( $ id ) ) { throw new Exception ( sprintf ( 'Identifier ` %s ` is a singleton and cannot be rebind ' , $ id ) ) ; } if ( is _object ( $ id ) & & get _class ( $ id ) ! = = false ) { $ value = $ id ; $ id = $ this - > get _class _prefix ( get _class ( $ id ) , false ) ; $ this - > classes [ $ id ] = true ; } if ( $ value instanceof Closure ) { $ closure = $ value ; } else { $ closure = $ this - > get _closure ( $ value , $ singleton ) ; } $ this - > values [ $ id ] = compact ( 'closure ' , 'singleton ' ) ; $ this - > keys [ $ id ] = true ; return $ value ; } 
protected function call _closure ( $ closure , array $ parameters = [ ] ) { if ( $ closure instanceof Closure ) { $ rc = new Reflection Function ( $ closure ) ; $ args = $ rc - > get Parameters ( ) ; $ params = $ parameters ; $ classes = [ $ this - > get _class _prefix ( get _class ( $ this ) ) , get _class ( $ this ) , get _parent _class ( $ this ) ] ; foreach ( $ args as $ index = > $ arg ) { if ( $ arg - > get Class ( ) = = = null ) { continue ; } if ( in _array ( $ arg - > get Class ( ) - > name , $ classes , true ) ) { $ parameters [ $ index ] = $ this ; } else if ( $ this - > exists ( $ arg - > get Class ( ) - > name ) ) { $ parameters [ $ index ] = $ this - > make ( $ arg - > get Class ( ) - > name ) ; } } if ( ! empty ( $ args ) & & empty ( $ parameters ) ) { $ parameters [ 0 ] = $ this ; } if ( count ( $ args ) > count ( $ parameters ) ) { $ parameters = array _merge ( $ parameters , $ params ) ; } return $ this - > call _closure ( call _user _func _array ( $ closure , $ parameters ) , $ parameters ) ; } return $ closure ; } 
protected function get _class _prefix ( $ id , $ check = true ) { if ( strpos ( $ id , ' \ \ ' ) ! = = false & & $ id [ 0 ] ! = = ' \ \ ' ) { $ class = ' \ \ ' . $ id ; if ( $ check ) { return isset ( $ this - > classes [ $ class ] ) ? $ class : $ id ; } return $ class ; } return $ id ; } 
public function is _singleton ( $ id ) { if ( ! is _string ( $ id ) ) { throw new Invalid Argument Exception ( 'Invalid argument . Must be string . ' ) ; } if ( ! $ this - > exists ( $ id ) ) { return false ; } $ id = $ this - > get _class _prefix ( $ id ) ; return $ this - > values [ $ id ] [ 'singleton ' ] = = = true ; } 
public function make ( $ id , array $ parameters = [ ] ) { if ( ! $ this - > exists ( $ id ) ) { throw new Exception ( sprintf ( 'Identifier ` %s ` is not defined ' , $ id ) ) ; } $ id = $ this - > get _class _prefix ( $ id ) ; $ value = $ this - > values [ $ id ] ; $ closure = $ value [ 'closure ' ] ; return $ this - > call _closure ( $ closure , $ parameters ) ; } 
public function once ( $ key , $ callback ) { if ( ! is _string ( $ key ) & & ! is _callable ( $ callback ) ) { return ; } if ( ! $ this - > exists ( $ key ) ) { $ result = $ callback ( ) ; $ this - > singleton ( $ key , $ result ) ; } return $ this - > make ( $ key ) ; } 
public function remove ( $ id ) { $ id = $ this - > get _class _prefix ( $ id ) ; unset ( $ this - > keys [ $ id ] , $ this - > values [ $ id ] ) ; } 
protected function override _labels ( Papi _Entry _Type $ entry _type ) { global $ wp _post _types , $ wp _taxonomies ; if ( $ entry _type - > get _type ( ) = = = 'taxonomy ' ) { $ meta _type _value = papi _get _taxonomy ( ) ; } else { $ meta _type _value = papi _get _post _type ( ) ; } if ( empty ( $ meta _type _value ) | | ( ! isset ( $ wp _post _types [ $ meta _type _value ] ) & & ! isset ( $ wp _taxonomies [ $ meta _type _value ] ) ) ) { return ; } foreach ( $ entry _type - > get _labels ( ) as $ key = > $ value ) { if ( empty ( $ value ) ) { continue ; } if ( $ entry _type - > get _type ( ) = = = 'taxonomy ' & & isset ( $ wp _taxonomies [ $ meta _type _value ] - > labels - > $ key ) ) { $ wp _taxonomies [ $ meta _type _value ] - > labels - > $ key = $ value ; } else if ( isset ( $ wp _post _types [ $ meta _type _value ] - > labels - > $ key ) ) { $ wp _post _types [ $ meta _type _value ] - > labels - > $ key = $ value ; } } } 
public function page _items _menu ( ) { $ entry _types = papi _get _all _entry _types ( [ 'mode ' = > 'exclude ' , 'types ' = > 'page ' ] ) ; foreach ( $ entry _types as $ entry _type ) { if ( empty ( $ entry _type - > get _menu ( ) ) | | empty ( $ entry _type - > name ) ) { continue ; } $ slug = sprintf ( 'papi / %s / %s ' , $ entry _type - > get _type ( ) , $ entry _type - > get _id ( ) ) ; add _submenu _page ( $ entry _type - > get _menu ( ) , $ entry _type - > name , $ entry _type - > name , $ entry _type - > capability , $ slug , [ $ entry _type , 'render ' ] ) ; } } 
public function post _types _menu ( ) { global $ submenu ; $ post _types = papi _get _post _types ( ) ; foreach ( $ post _types as $ post _type ) { if ( ! post _type _exists ( $ post _type ) ) { continue ; } if ( $ post _type = = = 'post ' ) { $ edit _url = 'edit .php ' ; } else { $ edit _url = 'edit .php ?post _type = ' . $ post _type ; } if ( ! isset ( $ submenu [ $ edit _url ] , $ submenu [ $ edit _url ] [ 1 0 ] , $ submenu [ $ edit _url ] [ 1 0 ] [ 2 ] ) ) { $ post _type _object = get _post _type _object ( $ post _type ) ; if ( $ post _type _object - > show _in _menu ! = = true ) { $ submenu [ $ edit _url ] = [ 1 0 = > [ _ _ ( 'Add New ' , 'papi ' ) , 'edit _posts ' , 'post -new .php ' ] ] ; } else { continue ; } } $ only _page _type = papi _filter _settings _only _page _type ( $ post _type ) ; $ page _types = papi _get _all _page _types ( $ post _type ) ; $ show _standard = false ; 
public function render _view ( ) { if ( strpos ( papi _get _qs ( 'page ' ) , 'papi ' ) ! = = false ) { $ page = str _replace ( 'papi - ' , ' ' , papi _get _qs ( 'page ' ) ) ; $ res = preg _replace ( ' / \ , . * / ' , ' ' , $ page ) ; if ( is _string ( $ res ) ) { $ page _view = $ res ; } } if ( ! isset ( $ page _view ) ) { $ page _view = null ; } if ( ! is _null ( $ page _view ) ) { $ view = new Papi _Admin _View ; $ view - > render ( $ page _view ) ; } else { echo ' <h 2 >Papi - 4 0 4 < /h 2 > ' ; } } 
protected function setup _actions ( ) { if ( papi _is _admin ( ) ) { add _action ( 'admin _init ' , [ $ this , 'admin _bar _menu ' ] ) ; add _action ( 'admin _menu ' , [ $ this , 'page _items _menu ' ] ) ; add _action ( 'admin _menu ' , [ $ this , 'post _types _menu ' ] ) ; } else { add _action ( 'admin _bar _menu ' , [ $ this , 'admin _bar _menu ' ] ) ; } } 
public function autoload ( $ class ) { $ class = strtolower ( $ class ) ; $ file = 'class - ' . str _replace ( ' _ ' , ' - ' , strtolower ( $ class ) ) . ' .php ' ; $ path = PAPI _PLUGIN _DIR ; if ( strpos ( $ class , 'papi _admin ' ) = = = 0 ) { $ path . = 'admin / ' ; } else if ( strpos ( $ class , 'papi _core _ ' ) = = = 0 ) { $ path . = 'core / ' ; } else if ( strpos ( $ class , 'papi _cli _ ' ) = = = 0 ) { $ path . = 'cli / ' ; } else if ( preg _match ( ' / ^papi \ _ \w + \ _store $ / ' , $ class ) ) { $ path . = 'stores / ' ; } else if ( strpos ( $ class , 'papi _property ' ) = = = 0 ) { $ path . = 'properties / ' ; } else if ( strpos ( $ class , 'papi _query ' ) = = = 0 ) { $ path . = 'query / ' ; } else if ( preg _match ( ' / ^papi \ _ \w + \ _type / ' , $ class ) ) { $ path . = 'types / ' ; } if ( is _readable ( $ path . $ file ) ) { require _once $ path . $ file ; } } 
public function get _property ( $ slug , $ child _slug = ' ' ) { $ taxonomy _type _id = papi _get _taxonomy _type _id ( $ this - > id , 'term ' ) ; $ taxonomy _type = papi _get _entry _type _by _id ( $ taxonomy _type _id ) ; if ( $ taxonomy _type instanceof Papi _Taxonomy _Type = = = false ) { return ; } if ( $ property = $ taxonomy _type - > get _property ( $ slug , $ child _slug ) ) { return $ this - > prepare _property ( $ property ) ; } } 
public function format _value ( $ value , $ slug , $ post _id ) { if ( is _admin ( ) | | ! $ this - > settings - > render ) { return $ value ; } ob _start ( ) ; if ( is _active _sidebar ( $ value ) ) { dynamic _sidebar ( $ value ) ; } return ob _get _clean ( ) ; } 
public function get _items ( ) { global $ wp _registered _sidebars ; $ items = [ ] ; foreach ( $ wp _registered _sidebars as $ item ) { $ items [ $ item [ 'name ' ] ] = $ item [ 'id ' ] ; } ksort ( $ items ) ; return $ items ; } 
public function html ( ) { $ settings = $ this - > get _settings ( ) ; papi _render _html _tag ( 'input ' , [ 'class ' = > $ settings - > mediauploader ? 'papi -url -media -input ' : null , 'id ' = > esc _attr ( $ this - > html _id ( ) ) , 'name ' = > esc _attr ( $ this - > html _name ( ) ) , 'type ' = > 'url ' , 'value ' = > $ this - > get _value ( ) ] ) ; if ( $ settings - > mediauploader ) { echo ' &nbsp ; ' ; papi _render _html _tag ( 'input ' , [ 'class ' = > 'button papi -url -media -button ' , 'data -papi -action ' = > 'mediauploader ' , 'id ' = > esc _attr ( $ this - > html _id ( ) ) , 'name ' = > esc _attr ( $ this - > html _name ( ) . ' _button ' ) , 'type ' = > 'button ' , 'value ' = > esc _attr _ _ ( 'Select file ' , 'papi ' ) ] ) ; } } 
public function format _value ( $ value , $ slug , $ post _id ) { $ meta _key = $ this - > get _setting ( 'meta _key ' ) ; if ( ! empty ( $ meta _key ) ) { $ args = [ 'fields ' = > 'ids ' , 'meta _key ' = > $ meta _key , 'meta _value ' = > $ value , 'posts _per _page ' = > 1 , 'post _type ' = > $ this - > get _setting ( 'post _type ' ) , ] ; $ query = new WP _Query ( $ args ) ; if ( ! empty ( $ query - > posts ) ) { $ value = $ query - > posts [ 0 ] ; } } $ post = $ this - > default _value ; 
protected function get _labels ( ) { $ results = [ ] ; foreach ( $ this - > get _post _types ( ) as $ post _type ) { if ( post _type _exists ( $ post _type ) ) { $ post _type _object = get _post _type _object ( $ post _type ) ; $ results [ $ post _type ] = $ post _type _object - > labels - > menu _name ; } } return $ results ; } 
protected function get _posts ( $ post _type = ' ' ) { $ query = $ this - > get _setting ( 'query ' ) ; $ layout = $ this - > get _setting ( 'layout ' ) ; 
protected function get _post _value ( $ post ) { $ meta _key = $ this - > get _setting ( 'meta _key ' ) ; if ( is _numeric ( $ post ) ) { $ post _id = $ post ; } else if ( ! empty ( $ post ) ) { $ post = get _post ( $ post ) ; if ( $ post instanceof WP _Post = = = false ) { return 0 ; } $ post _id = $ post - > ID ; } if ( empty ( $ post _id ) ) { return 0 ; } if ( ! empty ( $ meta _key ) ) { $ value = get _post _meta ( $ post _id , $ meta _key , true ) ; } else { $ value = $ post _id ; } return $ value ; } 
public function html ( ) { $ settings = $ this - > get _settings ( ) ; $ layout = $ settings - > layout ; $ labels = $ this - > get _labels ( ) ; $ post _types = $ this - > get _post _types ( ) ; $ render _label = count ( $ post _types ) > 1 ; $ advanced = $ render _label & & $ layout = = = 'advanced ' ; $ single = $ render _label & & $ layout ! = = 'advanced ' ; $ classes = count ( $ post _types ) > 1 ? ' ' : 'papi -fullwidth ' ; $ value = $ this - > get _value ( ) ; $ value = $ this - > get _post _value ( $ value ) ; $ selected _label = is _array ( $ labels ) & & ! empty ( $ labels ) ? array _values ( $ labels ) [ 0 ] : ' ' ; $ selected _post _type = empty ( $ value ) ? ' ' : get _post _type ( $ value ) ; $ selected _post _type = empty ( $ selected _post _type ) ? ' ' : $ selected _post _type ; $ posts = $ this - > get _posts ( $ selected _post _type ) ; if ( $ settings - > select 2 ) { $ classes . = ' papi -component -select 2 ' ; } <div class = "papi -property -post < ?php echo $ advanced ? 'advanced ' : ' ' ; ? > " > < ?php if ( $ advanced ) : ? > <table class = "papi -table " > <tr > <td > <label for = " < ?php echo esc _attr ( $ this - > html _id ( ) ) ; ? > _post _type " > < ?php echo esc _html ( $ settings - > labels [ 'select _post _type ' ] ) ; ? > < /label > < /td > <td > <select id = " < ?php echo esc _attr ( $ this - > html _id ( ) ) ; ? > _post _type " class = " < ?php echo esc _attr ( $ classes ) ; ? > papi -property -post -left " data -select -item = " < ?php echo esc _attr ( $ settings - > labels [ 'select _item ' ] ) ; ? > " data -post -query = ' < ?php echo esc _attr ( papi _maybe _json _encode ( $ settings - > query ) ) ; ? > ' data -width = " 1 0 0 % " > < ?php foreach ( $ labels as $ post _type = > $ label ) { $ selected = $ post _type = = = $ selected _post _type ; papi _render _html _tag ( 'option ' , [ 'value ' = > $ post _type , 'selected ' = > $ selected , $ label ] ) ; if ( $ selected ) { $ selected _label = $ label ; } } ? > < /select > < /td > < /tr > <tr > <td > <label for = " < ?php echo esc _attr ( $ this - > html _id ( ) ) ; ? > _posts " > < ?php echo esc _html ( sprintf ( $ settings - > labels [ 'select _item ' ] , $ selected _label ) ) ; ? > < /label > < /td > <td > < ?php endif ; ? > < ?php $ placeholder = ! is _null ( $ settings - > placeholder ) ? $ settings - > placeholder : ' ' ; ? > <select class = " < ?php echo esc _attr ( $ classes ) ; ? > papi -property -post -right " id = " < ?php echo esc _attr ( $ this - > html _id ( ) ) ; ? > _posts " name = " < ?php echo esc _attr ( $ this - > html _name ( ) ) ; ? > " data -allow -clear = " < ?php echo is _null ( $ settings - > placeholder ) ? 'false ' : 'true ' ; ? > " data -placeholder = " < ?php echo esc _attr ( $ placeholder ) ; ? > " data -width = " 1 0 0 % " > < ?php if ( ! empty ( $ settings - > placeholder ) ) : ? > < ?php if ( $ settings - > new _url ) : ? > <option data -placeholder data -new -url = " < ?php echo esc _attr ( admin _url ( 'post -new .php ?post _type = ' . $ post _types [ 0 ] ) ) ; ? > " > < /option > < ?php else : ? > <option > < /option > < ?php endif ; ? > < ?php endif ; ? > < ?php foreach ( $ posts as $ label = > $ items ) : ? > < ?php if ( $ single ) : ? > <optgroup label = " < ?php echo esc _attr ( $ label ) ; ? > " > < ?php endif ; ? > < ?php foreach ( $ items as $ post ) { if ( papi _is _empty ( $ post - > post _title ) ) { continue ; } papi _render _html _tag ( 'option ' , [ 'data -allow -clear ' = > $ settings - > allow _clear , 'data -edit -url ' = > $ settings - > edit _url ? get _edit _post _link ( $ post ) : ' ' , 'data -new -url ' = > $ settings - > new _url ? admin _url ( 'post -new .php ?post _type = ' . $ post - > post _type ) : ' ' , 'selected ' = > $ value = = = $ this - > get _post _value ( $ post ) , 'value ' = > $ this - > get _post _value ( $ post ) , $ post - > post _title ] ) ; } ? > < ?php if ( $ single ) : ? > < /optgroup > < ?php endif ; ? > < ?php endforeach ; ? > < /select > < ?php if ( $ advanced ) : ? > < /td > < /tr > < /table > < ?php endif ; ? > < /div > < ?php } 
public function render _option _template ( ) { $ settings = $ this - > get _settings ( ) ; $ post _types = $ this - > get _post _types ( ) ; ? > <script type = "text /template " id = "tmpl -papi -property -post -option " > <option data -allow -clear = " < ?php echo esc _attr ( $ settings - > allow _clear ) ; ? > " < ?php if ( $ settings - > edit _url ) : ? > data -edit -url = " < ?php echo esc _attr ( admin _url ( 'post .php ' ) ) ; ? > ?post = < % = id % > &action =edit " < ?php endif ; ? > < ?php if ( $ settings - > new _url ) : ? > data -new -url = " < ?php echo esc _attr ( admin _url ( 'post -new .php ?post _type = ' ) ) ; ? > < % = typeof type ! = = 'undefined ' ? type : ' < ?php echo esc _attr ( $ post _types [ 0 ] ) ; ? > ' % > " < ?php endif ; ? > value = " < % = id % > " > < % = title % > < /option > < /script > <script type = "text /template " id = "tmpl -papi -property -post -option -placeholder " > <option data -placeholder < ?php if ( $ settings - > new _url ) : ? > data -new -url = " < ?php echo esc _attr ( admin _url ( 'post -new .php ?post _type = ' ) ) ; ? > < % = typeof type ! = = 'undefined ' ? type : ' < ?php echo esc _attr ( $ post _types [ 0 ] ) ; ? > ' % > " < ?php endif ; ? > > < /option > < /script > < ?php } 
public function parse _args ( array $ args ) { $ args = array _merge ( $ this - > default _args , $ args ) ; 
protected function parse _post _args ( array $ args ) { if ( isset ( $ args [ 'page _type ' ] ) ) { $ args [ 'entry _type ' ] = $ args [ 'page _type ' ] ; unset ( $ args [ 'page _type ' ] ) ; } $ entry _type = papi _get _entry _type _by _id ( $ args [ 'entry _type ' ] ) ; if ( $ entry _type instanceof Papi _Page _Type ) { $ args [ 'post _type ' ] = papi _to _array ( $ entry _type - > post _type ) ; } else { $ args [ 'post _type ' ] = isset ( $ args [ 'post _type ' ] ) ? $ args [ 'post _type ' ] : ' ' ; } return $ args ; } 
protected function parse _term _args ( array $ args ) { if ( isset ( $ args [ 'taxonomy _type ' ] ) ) { $ args [ 'entry _type ' ] = $ args [ 'taxonomy _type ' ] ; unset ( $ args [ 'taxonomy _type ' ] ) ; } $ entry _type = papi _get _entry _type _by _id ( $ args [ 'entry _type ' ] ) ; if ( $ entry _type instanceof Papi _Taxonomy _Type ) { $ args [ 'taxonomy ' ] = papi _to _array ( $ entry _type - > taxonomy ) ; } else { $ args [ 'taxonomy ' ] = isset ( $ args [ 'taxonomy ' ] ) ? $ args [ 'taxonomy ' ] : ' ' ; } return $ args ; } 
public function get _query _args ( ) { $ args = $ this - > args ; if ( empty ( $ args [ 'meta _query ' ] ) ) { 
public function get _result ( ) { if ( ! method _exists ( $ this - > query , 'query ' ) ) { return [ ] ; } $ this - > parse _args ( $ this - > args ) ; return $ this - > query - > query ( $ this - > get _query _args ( ) ) ; } 
public function html ( ) { $ settings = $ this - > get _settings ( ) ; $ value = $ this - > get _value ( ) ; papi _render _html _tag ( 'div ' , [ 'class ' = > 'papi -property -color -picker ' , papi _html _tag ( 'input ' , [ 'data -settings ' = > $ settings , 'id ' = > $ this - > html _id ( ) , 'name ' = > $ this - > html _name ( ) , 'type ' = > $ settings - > show _input = = = true ? 'text ' : 'hidden ' , 'value ' = > $ value , ] ) ] ) ; } 
public function format _value ( $ value , $ slug , $ post _id ) { if ( is _string ( $ value ) & & ! papi _is _empty ( $ value ) ) { return [ papi _cast _string _value ( $ value ) ] ; } if ( ! is _array ( $ value ) ) { return $ this - > default _value ; } return array _map ( 'papi _cast _string _value ' , $ value ) ; } 
public function html ( ) { $ settings = $ this - > get _settings ( ) ; $ value = papi _cast _string _value ( $ this - > get _value ( ) ) ; 
public function get _property ( $ slug , $ child _slug = ' ' ) { $ entry _type _id = papi _get _qs ( 'page ' ) ; if ( empty ( $ entry _type _id ) ) { $ property = null ; $ entry _types = papi _get _all _entry _types ( [ 'types ' = > 'option ' ] ) ; foreach ( $ entry _types as $ entry _type ) { if ( $ property = $ entry _type - > get _property ( $ slug , $ child _slug ) ) { break ; } } if ( is _null ( $ property ) ) { return ; } return $ property ; } $ entry _type = papi _get _entry _type _by _id ( $ entry _type _id ) ; if ( $ entry _type instanceof Papi _Option _Type = = = false ) { return ; } if ( $ property = $ entry _type - > get _property ( $ slug , $ child _slug ) ) { return $ this - > prepare _property ( $ property ) ; } } 
public function html ( ) { $ settings = $ this - > get _settings ( ) ; $ value = $ this - > get _value ( ) ; $ settings _json = [ 'i 1 8n ' = > [ 'previous Month ' = > _ _ ( 'Previous Month ' , 'papi ' ) , 'next Month ' = > _ _ ( 'Next Month ' , 'papi ' ) , 'midnight ' = > _ _ ( 'Midnight ' , 'papi ' ) , 'months ' = > [ _ _ ( 'January ' , 'papi ' ) , _ _ ( 'February ' , 'papi ' ) , _ _ ( 'March ' , 'papi ' ) , _ _ ( 'April ' , 'papi ' ) , _ _ ( 'May ' , 'papi ' ) , _ _ ( 'June ' , 'papi ' ) , _ _ ( 'July ' , 'papi ' ) , _ _ ( 'August ' , 'papi ' ) , _ _ ( 'September ' , 'papi ' ) , _ _ ( 'October ' , 'papi ' ) , _ _ ( 'November ' , 'papi ' ) , _ _ ( 'December ' , 'papi ' ) ] , 'noon ' = > _ _ ( 'Noon ' , 'papi ' ) , 'weekdays ' = > [ _ _ ( 'Sunday ' , 'papi ' ) , _ _ ( 'Monday ' , 'papi ' ) , _ _ ( 'Tuesday ' , 'papi ' ) , _ _ ( 'Wednesday ' , 'papi ' ) , _ _ ( 'Thursday ' , 'papi ' ) , _ _ ( 'Friday ' , 'papi ' ) , _ _ ( 'Saturday ' , 'papi ' ) ] , 'weekdays Short ' = > [ _ _ ( 'Sun ' , 'papi ' ) , _ _ ( 'Mon ' , 'papi ' ) , _ _ ( 'Tue ' , 'papi ' ) , _ _ ( 'Wed ' , 'papi ' ) , _ _ ( 'Thu ' , 'papi ' ) , _ _ ( 'Fri ' , 'papi ' ) , _ _ ( 'Sat ' , 'papi ' ) ] ] ] ; 
public function add _help _tabs ( ) { $ help = $ this - > help ( ) ; $ screen = get _current _screen ( ) ; 
protected function box ( $ file _or _options = [ ] , $ properties = [ ] ) { if ( ! is _string ( $ file _or _options ) & & ! is _array ( $ file _or _options ) & & ! is _object ( $ file _or _options ) ) { return ; } list ( $ options , $ properties ) = papi _get _options _and _properties ( $ file _or _options , $ properties , true ) ; 
protected function call _parent _register ( ) { $ parent _class = get _parent _class ( $ this ) ; if ( ! method _exists ( $ parent _class , 'register ' ) ) { return ; } $ rc = new Reflection Class ( $ parent _class ) ; 
protected function convert _properties ( $ properties ) { if ( is _array ( $ properties ) ) { if ( isset ( $ properties [ 'type ' ] ) ) { $ properties = [ $ properties ] ; } else if ( isset ( $ properties [ 0 ] ) & & $ properties [ 0 ] instanceof Papi _Core _Tab ) { foreach ( $ properties as $ items ) { $ items - > properties = array _map ( 'papi _get _property _type ' , $ items - > properties ) ; } return $ properties ; } } if ( is _object ( $ properties ) ) { $ properties = papi _get _property _type ( $ properties ) ; } if ( papi _is _property ( $ properties ) ) { $ properties = [ $ properties ] ; } $ properties = is _array ( $ properties ) ? $ properties : [ ] ; $ properties = array _map ( 'papi _get _property _type ' , $ properties ) ; return array _filter ( $ properties , 'papi _is _property ' ) ; } 
public function get _body _classes ( ) { $ arr = $ this - > body _classes ( ) ; $ arr = is _string ( $ arr ) ? [ $ arr ] : $ arr ; $ arr = is _array ( $ arr ) ? $ arr : [ ] ; return array _merge ( $ arr , [ ] ) ; } 
public function get _boxes ( ) { if ( empty ( $ this - > boxes ) & & $ this - > load _boxes = = = false ) { if ( ! method _exists ( $ this , 'register ' ) ) { return [ ] ; } $ this - > load _boxes = true ; $ this - > call _parent _register ( ) ; $ this - > register ( ) ; } * Modify boxes array . * * @param array $boxes * @param string $id * / $ this - > boxes = apply _filters ( 'papi /get _boxes ' , $ this - > boxes , $ this - > get _id ( ) ) ; $ this - > boxes = is _array ( $ this - > boxes ) ? $ this - > boxes : [ ] ; 
public function get _property ( $ slug , $ child _slug = ' ' ) { $ boxes = $ this - > get _boxes ( ) ; $ parts = preg _match ( ' / \ [ \d + \ ] / ' , $ slug ) ? preg _split ( ' / \ [ \d + \ ] / ' , $ slug ) : explode ( ' [ ' , $ slug ) ; $ parts = array _map ( function ( $ part ) { return preg _replace ( ' / ( \ [ | \ ] ) / ' , ' ' , $ part ) ; } , $ parts ) ; if ( count ( $ parts ) > 1 ) { $ property = null ; for ( $ i = 0 , $ l = count ( $ parts ) ; $ i < $ l ; $ i + + ) { $ child = isset ( $ parts [ $ i + 1 ] ) ? $ parts [ $ i + 1 ] : ' ' ; $ property = $ this - > get _property ( $ parts [ $ i ] , $ child ) ; if ( isset ( $ parts [ $ i + 1 ] ) ) { $ i + + ; } } return apply _filters ( 'papi /get _property ' , $ property ) ; } foreach ( $ boxes as $ box ) { foreach ( $ box - > properties as $ property ) { $ property = papi _get _property _type ( $ property ) ; if ( papi _is _property ( $ property ) & & $ property - > match _slug ( $ slug ) ) { if ( empty ( $ child _slug ) ) { return apply _filters ( 'papi /get _property ' , $ property ) ; } $ property = $ property - > get _child _property ( $ child _slug ) ; if ( papi _is _property ( $ property ) ) { return apply _filters ( 'papi /get _property ' , $ property ) ; } } } } } 
public function get _properties ( ) { $ boxes = $ this - > get _boxes ( ) ; $ list = [ ] ; foreach ( $ boxes as $ box ) { foreach ( $ box - > properties as $ property ) { $ list [ ] = $ property ; } } return $ list ; } 
protected function merge _boxes ( array $ boxes ) { $ result = [ ] ; foreach ( $ boxes as $ box ) { if ( ! isset ( $ result [ $ box - > id ] ) ) { $ result [ $ box - > id ] = $ box ; continue ; } foreach ( $ box - > properties as $ property ) { $ result [ $ box - > id ] - > properties [ ] = $ property ; } $ result [ $ box - > id ] - > properties = array _unique ( $ result [ $ box - > id ] - > properties ) ; } return array _values ( $ result ) ; } 
public function setup ( ) { add _action ( 'in _admin _header ' , [ $ this , 'add _help _tabs ' ] ) ; add _filter ( 'screen _options _show _screen ' , function ( ) { return $ this - > show _screen _options ; } ) ; 
protected function tab ( $ file _or _options = [ ] , $ properties = [ ] ) { if ( ! is _string ( $ file _or _options ) & & ! is _array ( $ file _or _options ) ) { return ; } return papi _tab ( $ file _or _options , $ properties ) ; } 
public function format _value ( $ value , $ slug , $ post _id ) { $ value = is _string ( $ value ) & & is _numeric ( $ value ) ? $ value + 0 : $ value ; if ( is _float ( $ value ) ) { return floatval ( $ value ) ; } else { return intval ( $ value ) ; } } 
public function html ( ) { $ settings = $ this - > get _settings ( ) ; $ value = $ this - > get _value ( ) ; 
public function delete _value ( $ slug , $ post _id , $ type ) { $ values = $ this - > load _value ( null , $ slug , $ post _id ) ; $ values = is _object ( $ values ) ? ( array ) $ values : $ values ; $ result = true ; foreach ( array _keys ( $ values ) as $ key ) { $ out = papi _data _delete ( $ post _id , $ slug . ' _ ' . $ key ) ; $ result = $ out ? $ result : $ out ; } if ( $ result ) { $ result = papi _data _delete ( $ post _id , $ slug ) ; } return $ result ; } 
public function load _value ( $ value , $ slug , $ post _id ) { if ( is _array ( $ value ) | | is _object ( $ value ) ) { $ values = $ value ; } else { $ values = $ this - > link _fields ; foreach ( $ values as $ index = > $ key ) { $ values [ $ key ] = papi _data _get ( $ post _id , sprintf ( ' %s _ %s ' , $ slug , $ key ) , $ this - > get _meta _type ( ) ) ; unset ( $ values [ $ index ] ) ; } } return ( object ) $ this - > prepare _link _array ( $ values , $ slug ) ; } 
public function html ( ) { $ value = $ this - > get _value ( ) ; $ value = is _array ( $ value ) | | is _object ( $ value ) ? $ value : [ ] ; $ value = ( object ) $ value ; $ exists = ! empty ( $ value - > url ) ; ? > <div class = "papi -property -link " data -replace -slug = "true " data -slug = " < ?php echo esc _attr ( $ this - > html _name ( ) ) ; ? > " > <input type = "hidden " name = " < ?php echo esc _attr ( $ this - > html _name ( ) ) ; ? > " value = " < ?php echo $ exists ? 1 : ' ' ; ? > " > < ?php if ( $ exists ) : ? > <table class = "papi -table link -table " > <tbody > <tr > <td > < ?php esc _html _e ( 'URL ' , 'papi ' ) ; ? > < /td > <td > <a href = " < ?php echo esc _attr ( $ value - > url ) ; ? > " target = " _blank " > < ?php echo esc _attr ( $ value - > url ) ; ? > < /a > <input type = "hidden " value = " < ?php echo esc _attr ( $ value - > title . ' - ' . $ value - > url ) ; ? > " data -papi -rule = " < ?php echo esc _attr ( $ this - > html _name ( ) ) ; ? > " > <input class = "wp -link -url " type = "hidden " value = " < ?php echo esc _attr ( $ value - > url ) ; ? > " name = " < ?php echo esc _attr ( $ this - > html _name ( ) ) ; ? > [url ] " > < /td > < /tr > <tr > <td > < ?php esc _html _e ( 'Title ' , 'papi ' ) ; ? > < /td > <td > < ?php echo esc _html ( $ value - > title ) ; ? > <input class = "wp -link -text " type = "hidden " value = " < ?php echo esc _attr ( $ value - > title ) ; ? > " name = " < ?php echo esc _attr ( $ this - > html _name ( ) ) ; ? > [title ] " > < /td > < /tr > <tr > <td > < ?php esc _html _e ( 'Target ' , 'papi ' ) ; ? > < /td > <td > < ?php echo $ value - > target = = = ' _blank ' ? esc _html _e ( 'New window ' , 'papi ' ) : esc _html _e ( 'Same window ' , 'papi ' ) ; ? > <input class = "wp -link -target " type = "hidden " value = " < ?php echo esc _attr ( $ value - > target ) ; ? > " name = " < ?php echo esc _attr ( $ this - > html _name ( ) ) ; ? > [target ] " > < /td > < /tr > < /tbody > < /table > < ?php endif ; ? > <p class = "papi -file -select " > <span class = " < ?php echo empty ( $ value - > url ) ? ' ' : 'papi -hide ' ; ? > " > < ?php esc _html _e ( 'No link selected ' , 'papi ' ) ; ? > <button class = "button " data -link -action = "add " > < ?php esc _html _e ( 'Add link ' , 'papi ' ) ; ? > < /button > < /span > <span class = " < ?php echo empty ( $ value - > url ) ? 'papi -hide ' : ' ' ; ? > " > <button class = "button " data -link -action = "edit " > < ?php esc _html _e ( 'Edit link ' , 'papi ' ) ; ? > < /button > <button class = "button " data -link -action = "remove " > < ?php esc _html _e ( 'Remove link ' , 'papi ' ) ; ? > < /button > < /span > < /p > < /div > < ?php } 
protected function prepare _link _array ( $ link , $ slug ) { $ array = is _array ( $ link ) ; $ values = ( array ) $ link ; foreach ( $ values as $ key = > $ val ) { unset ( $ values [ $ key ] ) ; $ key = preg _replace ( ' / ^ ' . $ slug . ' \ _ / ' , ' ' , $ key ) ; $ values [ $ key ] = $ val ; } $ link = ( object ) $ values ; 
public function update _value ( $ values , $ slug , $ post _id ) { if ( is _object ( $ values ) ) { $ values = ( array ) $ values ; } if ( ! isset ( $ values [ 'url ' ] ) ) { $ values = $ this - > link _fields ; foreach ( $ values as $ index = > $ key ) { $ values [ sprintf ( ' %s _ %s ' , $ slug , $ key ) ] = ' ' ; unset ( $ values [ $ index ] ) ; } 
public function allowed ( ) { $ args = func _get _args ( ) ; if ( empty ( $ args ) ) { return parent : : allowed ( ) ; } return isset ( $ args [ 0 ] ) & & in _array ( $ args [ 0 ] , $ this - > taxonomy , true ) ; } 
protected function setup _actions ( ) { foreach ( papi _to _array ( $ this - > taxonomy ) as $ taxonomy ) { if ( is _string ( $ taxonomy ) & & taxonomy _exists ( $ taxonomy ) ) { add _action ( $ taxonomy . ' _edit _form ' , [ $ this , 'edit _form ' ] ) ; } } } 
public function edit _form ( ) { ? > <div id = "papi -hidden -editor " class = "hide -if -js " > < ?php wp _editor ( ' ' , 'papi Hidden Editor ' ) ; ? > < /div > <div id = "poststuff " > <div id = "post -body " > < ?php foreach ( $ this - > boxes as $ box ) { do _meta _boxes ( $ box - > id , 'normal ' , null ) ; } ? > < /div > < /div > < ?php } 
public function get _post ( WP _Post $ post ) { if ( ! ( $ page _type = papi _get _entry _type _by _meta _id ( $ post - > ID ) ) ) { return $ post ; } 
public function prepare _response ( $ response ) { if ( ! isset ( $ response - > data [ 'meta ' ] ) ) { return $ response ; } foreach ( $ response - > data [ 'meta ' ] as $ key = > $ value ) { $ response - > data [ 'meta ' ] [ $ key ] = papi _get _field ( $ key , $ value , 'post ' ) ; } return $ response ; } 
public function setup _fields ( ) { if ( ! function _exists ( 'register _rest _field ' ) ) { return ; } $ post _types = papi _get _post _types ( ) ; foreach ( $ post _types as $ post _type ) { register _rest _field ( $ post _type , 'page _type ' , [ 'get _callback ' = > [ $ this , 'get _page _type ' ] ] ) ; } } 
protected function get _format _args ( $ assoc _args ) { $ format _args = [ 'fields ' = > $ this - > get _default _format _fields ( ) , 'field ' = > null , 'format ' = > 'table ' , ] ; if ( isset ( $ assoc _args [ 'fields ' ] ) ) { $ format _args [ 'fields ' ] = $ assoc _args [ 'fields ' ] ; } if ( isset ( $ assoc _args [ 'field ' ] ) ) { $ format _args [ 'field ' ] = $ assoc _args [ 'field ' ] ; } if ( ! empty ( $ assoc _args [ 'format ' ] ) & & in _array ( $ assoc _args [ 'format ' ] , [ 'count ' , 'ids ' , 'table ' , 'csv ' , 'json ' ] , true ) ) { $ format _args [ 'format ' ] = $ assoc _args [ 'format ' ] ; } return $ format _args ; } 
public function render ( $ file ) { if ( ! empty ( $ file ) & & $ this - > exists ( $ file ) ) { require $ this - > file ( $ file ) ; } } 
public function get _option ( $ key ) { return isset ( $ this - > options [ $ key ] ) ? $ this - > options [ $ key ] : null ; } 
protected function setup _args ( array $ args ) { $ excluded _keys = [ 'options ' , 'properties ' ] ; foreach ( $ args as $ key = > $ value ) { if ( isset ( $ this - > $ key ) & & ! in _array ( $ key , $ excluded _keys , true ) ) { $ this - > $ key = papi _esc _html ( $ value ) ; } } if ( empty ( $ this - > id ) ) { $ this - > id = papi _slugify ( strtolower ( papi _f ( papi _underscorify ( papify ( $ this - > title ) ) ) ) ) ; $ this - > id = sanitize _text _field ( $ this - > id ) ; } } 
protected function convert _prop ( $ value , Papi _Core _Conditional _Rule $ rule ) { $ meta _id = papi _get _meta _id ( ) ; $ meta _type = papi _get _meta _type ( ) ; $ entry _type = papi _get _entry _type _by _meta _id ( $ meta _id , $ meta _type ) ; if ( ! papi _is _empty ( $ value ) & & $ entry _type instanceof Papi _Entry _Type ! = = false ) { $ property = $ entry _type - > get _property ( $ rule - > slug ) ; if ( papi _is _property ( $ property ) ) { $ prop _value = $ property - > format _value ( $ value , $ property - > slug , $ meta _id ) ; $ prop _value = papi _filter _format _value ( $ property - > type , $ prop _value , $ property - > slug , $ meta _id , $ meta _type ) ; $ prop _value = $ this - > get _deep _value ( $ rule - > slug , $ prop _value ) ; if ( gettype ( $ prop _value ) = = = gettype ( $ rule - > value ) ) { return $ prop _value ; } } return $ value ; } return $ value ; } 
protected function get _converted _value ( Papi _Core _Conditional _Rule $ rule ) { $ value = $ this - > get _value ( $ rule ) ; 
protected function get _deep _value ( $ slug , $ value ) { $ slugs = explode ( ' . ' , $ slug ) ; array _shift ( $ slugs ) ; return papi _field _value ( $ slugs , $ value , $ value ) ; } 
protected function get _value ( Papi _Core _Conditional _Rule $ rule ) { if ( papi _doing _ajax ( ) ) { $ source = $ rule - > get _source ( ) ; $ meta _id = papi _get _meta _id ( ) ; $ entry _type = papi _get _entry _type _by _meta _id ( $ meta _id ) ; if ( ! papi _is _empty ( $ source ) & & $ entry _type instanceof Papi _Entry _Type ! = = false ) { if ( papi _is _property ( $ entry _type - > get _property ( $ rule - > slug ) ) ) { return $ this - > get _deep _value ( $ rule - > slug , $ source ) ; } } } if ( ! papi _is _empty ( $ rule - > get _source ( ) ) ) { return $ this - > get _deep _value ( $ rule - > slug , $ rule - > get _source ( ) ) ; } $ slug = $ rule - > get _field _slug ( ) ; $ type = papi _get _meta _type ( ) ; $ value = papi _get _field ( $ slug , null , $ type ) ; return $ this - > get _deep _value ( $ slug , $ value ) ; } 
public function rule _equal ( Papi _Core _Conditional _Rule $ rule ) { list ( $ value , $ rule _value ) = $ this - > get _converted _value ( $ rule ) ; return $ value = = = $ rule _value ; } 
public function rule _not _equal ( Papi _Core _Conditional _Rule $ rule ) { list ( $ value , $ rule _value ) = $ this - > get _converted _value ( $ rule ) ; return $ value ! = = $ rule _value ; } 
public function rule _greater _then ( Papi _Core _Conditional _Rule $ rule ) { $ value = $ this - > get _value ( $ rule ) ; if ( is _array ( $ value ) ) { $ value = count ( $ value ) ; } if ( ! is _numeric ( $ value ) | | ! is _numeric ( $ rule - > value ) ) { return false ; } return $ this - > convert _number ( $ value ) > $ this - > convert _number ( $ rule - > value ) ; } 
public function rule _not _in ( Papi _Core _Conditional _Rule $ rule ) { list ( $ value , $ rule _value ) = $ this - > get _converted _value ( $ rule ) ; if ( ! is _array ( $ rule _value ) ) { return false ; } return ! in _array ( $ value , $ rule _value , true ) ; } 
public function rule _like ( Papi _Core _Conditional _Rule $ rule ) { $ value = $ this - > get _value ( $ rule ) ; if ( ! is _string ( $ value ) ) { $ value = papi _convert _to _string ( $ value ) ; } if ( papi _is _empty ( $ value ) ) { return false ; } return strpos ( strtolower ( $ value ) , strtolower ( $ rule - > value ) ) ! = = false ; } 
protected function get _between _values ( Papi _Core _Conditional _Rule $ rule ) { $ value = $ this - > get _value ( $ rule ) ; if ( ! is _array ( $ rule - > value ) ) { return [ $ rule , false ] ; } foreach ( $ rule - > value as $ index = > $ v ) { $ v = $ this - > convert _number ( $ v ) ; if ( is _numeric ( $ v ) ) { $ rule - > value [ $ index ] = $ v ; } else { unset ( $ rule - > value [ $ index ] ) ; } } if ( ! is _numeric ( $ value ) | | count ( $ rule - > value ) ! = = 2 ) { return [ $ rule , false ] ; } return [ $ rule , $ this - > convert _number ( $ value ) ] ; } 
public function rule _between ( Papi _Core _Conditional _Rule $ rule ) { list ( $ rule , $ value ) = $ this - > get _between _values ( $ rule ) ; if ( $ value = = = false ) { return false ; } return $ rule - > value [ 0 ] < = $ value & & $ value < = $ rule - > value [ 1 ] ; } 
public function rule _not _between ( Papi _Core _Conditional _Rule $ rule ) { list ( $ rule , $ value ) = $ this - > get _between _values ( $ rule ) ; if ( $ value = = = false ) { return false ; } return ! ( $ rule - > value [ 0 ] < = $ value & & $ value < = $ rule - > value [ 1 ] ) ; } 
public function setup _filters ( ) { add _filter ( 'papi /conditional /rule / = ' , [ $ this , 'rule _equal ' ] ) ; add _filter ( 'papi /conditional /rule / ! = ' , [ $ this , 'rule _not _equal ' ] ) ; add _filter ( 'papi /conditional /rule / > ' , [ $ this , 'rule _greater _then ' ] ) ; add _filter ( 'papi /conditional /rule / > = ' , [ $ this , 'rule _greater _then _or _equal ' ] ) ; add _filter ( 'papi /conditional /rule / < ' , [ $ this , 'rule _less _then ' ] ) ; add _filter ( 'papi /conditional /rule / < = ' , [ $ this , 'rule _less _then _or _equal ' ] ) ; add _filter ( 'papi /conditional /rule /IN ' , [ $ this , 'rule _in ' ] ) ; add _filter ( 'papi /conditional /rule /NOT IN ' , [ $ this , 'rule _not _in ' ] ) ; add _filter ( 'papi /conditional /rule /LIKE ' , [ $ this , 'rule _like ' ] ) ; add _filter ( 'papi /conditional /rule /BETWEEN ' , [ $ this , 'rule _between ' ] ) ; add _filter ( 'papi /conditional /rule /NOT BETWEEN ' , [ $ this , 'rule _not _between ' ] ) ; add _filter ( 'papi /conditional /rule /EXISTS ' , [ $ this , 'rule _exists ' ] ) ; add _filter ( 'papi /conditional /rule /NOT EXISTS ' , [ $ this , 'rule _not _exists ' ] ) ; add _filter ( 'papi /conditional /rule /EMPTY ' , [ $ this , 'rule _empty ' ] ) ; add _filter ( 'papi /conditional /rule /NOT EMPTY ' , [ $ this , 'rule _not _empty ' ] ) ; } 
public function format _value ( $ values , $ slug , $ post _id ) { if ( is _array ( $ values ) | | is _object ( $ values ) ) { $ items = $ this - > get _setting ( 'items ' ) ; $ result = [ ] ; foreach ( $ values as $ id ) { 
public function get _sort _option ( $ post _id ) { $ slug = $ this - > html _id ( 'sort _option ' ) ; $ slug = str _replace ( ' ] [ ' , ' _ ' , $ slug ) ; $ slug = str _replace ( ' [ ' , ' _ ' , $ slug ) ; $ slug = str _replace ( ' ] ' , ' ' , $ slug ) ; return papi _data _get ( $ post _id , $ slug , $ this - > get _meta _type ( ) ) ; } 
public static function get _sort _options ( ) { $ sort _options = [ ] ; $ sort _options [ _ _ ( 'Select ' , 'papi ' ) ] = null ; $ sort _options [ _ _ ( 'Name (alphabetically ) ' , 'papi ' ) ] = function ( $ a , $ b ) { 
protected function get _items ( $ settings ) { if ( is _array ( $ settings - > items ) & & ! empty ( $ settings - > items ) ) { $ mapping = function ( $ item ) { return is _array ( $ item ) ? isset ( $ item [ 'id ' ] , $ item [ 'title ' ] ) : isset ( $ item - > id , $ item - > title ) ; } ; return array _map ( 'papi _maybe _convert _to _object ' , array _filter ( $ settings - > items , $ mapping ) ) ; } 
protected function get _post _value ( $ value ) { $ meta _key = $ this - > get _setting ( 'meta _key ' ) ; if ( $ value instanceof WP _Post = = = false ) { return 0 ; } if ( empty ( $ meta _key ) ) { return $ value - > ID ; } if ( $ value = get _post _meta ( $ value - > ID , $ meta _key , true ) ) { return $ value ; } return 0 ; } 
public function html ( ) { $ post _id = papi _get _post _id ( ) ; $ slug = $ this - > html _name ( ) ; $ settings = $ this - > get _settings ( ) ; $ settings _json = [ ] ; $ sort _option = $ this - > get _sort _option ( $ post _id ) ; $ sort _options = static : : get _sort _options ( ) ; $ values = papi _get _only _objects ( $ this - > get _value ( ) ) ; $ items = $ this - > get _items ( $ settings ) ; if ( papi _is _empty ( $ settings - > items ) ) { $ values = array _map ( [ $ this , 'convert _post _to _item ' ] , $ values ) ; } else { foreach ( array _keys ( $ sort _options ) as $ key ) { if ( strpos ( $ key , 'Post ' ) = = = 0 ) { unset ( $ sort _options [ $ key ] ) ; } } } <div class = "papi -property -relationship " data -settings = ' < ?php echo esc _attr ( papi _maybe _json _encode ( $ settings _json ) ) ; ? > ' > <input type = "hidden " name = " < ?php echo esc _attr ( $ slug ) ; ? > [ ] " data -papi -rule = " < ?php echo esc _attr ( $ slug ) ; ? > " / > <div class = "relationship -inner " > <div class = "relationship -top -left " > <label for = " < ?php echo esc _attr ( $ this - > html _id ( 'search ' ) ) ; ? > " > < ?php esc _html _e ( 'Search ' , 'papi ' ) ; ? > < /label > <input id = " < ?php echo esc _attr ( $ this - > html _id ( 'search ' ) ) ; ? > " type = "search " / > < /div > <div class = "relationship -top -right " > < ?php if ( $ settings - > show _sort _by ) : ? > <label for = " < ?php echo esc _attr ( $ this - > html _id ( 'sort _option ' ) ) ; ? > " > < ?php esc _html _e ( 'Sort by ' , 'papi ' ) ; ? > < /label > <select id = " < ?php echo esc _attr ( $ this - > html _id ( 'sort _option ' ) ) ; ? > " name = " < ?php echo esc _attr ( $ this - > html _id ( 'sort _option ' ) ) ; ? > " > < ?php foreach ( array _keys ( $ sort _options ) as $ key ) : ? > <option value = " < ?php echo esc _attr ( $ key ) ; ? > " < ?php echo $ key = = = $ sort _option ? 'selected = "selected " ' : ' ' ; ? > > < ?php echo esc _html ( $ key ) ; ? > < /option > < ?php endforeach ; ? > < /select > < ?php endif ; ? > < /div > <div class = "papi -clear " > < /div > < /div > <div class = "relationship -inner " > <div class = "relationship -left " > <ul > < ?php foreach ( $ items as $ item ) : if ( ! empty ( $ item - > title ) ) : ? > <li > <input type = "hidden " data -name = " < ?php echo esc _attr ( $ slug ) ; ? > [ ] " value = " < ?php echo esc _attr ( $ item - > id ) ; ? > " / > <a href = " # " title = " < ?php echo esc _attr ( $ item - > title ) ; ? > " > < ?php echo esc _html ( $ item - > title ) ; ? > < /a > <span class = "icon plus " > < /span > < /li > < ?php endif ; endforeach ; ? > < /ul > < /div > <div class = "relationship -right " > <ul > < ?php foreach ( $ values as $ item ) : ? > <li > <input type = "hidden " name = " < ?php echo esc _attr ( $ slug ) ; ? > [ ] " value = " < ?php echo esc _attr ( $ item - > id ) ; ? > " / > <a href = " # " > < ?php echo esc _attr ( $ item - > title ) ; ? > < /a > <span class = "icon minus " > < /span > < /li > < ?php endforeach ; ? > < /ul > < /div > <div class = "papi -clear " > < /div > < /div > < /div > < ?php } 
public function load _value ( $ values , $ slug , $ post _id ) { $ values = ( array ) papi _maybe _json _decode ( maybe _unserialize ( $ values ) , true ) ; return array _map ( 'papi _maybe _convert _to _object ' , $ values ) ; } 
public function sort _value ( $ values , $ slug , $ post _id ) { $ sort _option = $ this - > get _sort _option ( $ post _id ) ; $ sort _options = static : : get _sort _options ( ) ; if ( empty ( $ sort _option ) | | ! isset ( $ sort _options [ $ sort _option ] ) | | is _null ( $ sort _options [ $ sort _option ] ) ) { return $ values ; } usort ( $ values , $ sort _options [ $ sort _option ] ) ; return $ values ; } 
public function update _value ( $ values , $ slug , $ post _id ) { $ values = $ this - > format _value ( $ values , $ slug , $ post _id ) ; $ values = array _map ( function ( $ item ) { if ( $ item instanceof WP _Post ) { $ item = $ this - > convert _post _to _item ( $ item ) ; } if ( isset ( $ item - > title ) ) { unset ( $ item - > title ) ; } return $ item ; } , $ values ) ; return papi _maybe _json _decode ( $ values ) ; } 
protected function get _meta _type _value ( $ entry _type ) { if ( in _array ( $ entry _type - > get _type ( ) , [ 'attachment ' ] , true ) ) { return $ entry _type - > get _type ( ) ; } switch ( papi _get _meta _type ( $ entry _type - > get _type ( ) ) ) { case 'post ' : return implode ( ' , ' , $ entry _type - > post _type ) ; case 'term ' : return implode ( ' , ' , $ entry _type - > taxonomy ) ; default : return 'n /a ' ; } } 
public function list _ ( $ args , $ assoc _args ) { 
protected function html ( ) { ? > <div class = "papi -tabs -wrapper " > <div class = "papi -tabs -table -back " > < /div > <div class = "papi -tabs -back " > < /div > <ul class = "papi -tabs " > < ?php foreach ( $ this - > tabs as $ tab ) : $ css _classes = $ this - > tabs [ 0 ] = = = $ tab ? 'active ' : ' ' ; if ( empty ( $ tab - > background ) ) { <li class = " < ?php echo esc _attr ( $ css _classes ) ; ? > " > <a href = " # " data -papi -tab = " < ?php echo esc _attr ( $ tab - > id ) ; ? > " > < ?php if ( ! empty ( $ tab - > icon ) ) : ? > <img src = " < ?php echo esc _attr ( $ tab - > icon ) ; ? > " alt = " < ?php echo esc _attr ( $ tab - > title ) ; ? > " / > < ?php endif ; echo esc _html ( $ tab - > title ) ; ? > < /a > < /li > < ?php endforeach ; ? > < /ul > <div class = "papi -tabs -content " > < ?php foreach ( $ this - > tabs as $ tab ) : ? > <div class = " < ?php echo $ this - > tabs [ 0 ] = = = $ tab ? 'active ' : ' ' ; ? > " data -papi -tab = " < ?php echo esc _attr ( $ tab - > id ) ; ? > " > < ?php papi _render _properties ( $ tab - > properties ) ; ? > < /div > < ?php endforeach ; ? > < /div > < /div > <div class = "papi -clear " > < /div > < ?php } 
public function format _value ( $ values , $ repeater _slug , $ post _id ) { if ( ! is _array ( $ values ) ) { return [ ] ; } foreach ( $ values as $ index = > $ layout ) { foreach ( $ layout as $ slug = > $ value ) { if ( is _string ( $ value ) & & preg _match ( $ this - > layout _value _regex , $ value ) ) { if ( isset ( $ values [ $ index ] [ $ this - > layout _key ] ) ) { unset ( $ values [ $ index ] [ $ slug ] ) ; continue ; } $ values [ $ index ] [ $ this - > layout _key ] = $ value ; unset ( $ values [ $ index ] [ $ slug ] ) ; continue ; } if ( papi _is _property _type _key ( $ slug ) ) { continue ; } $ property _type _slug = papi _get _property _type _key _f ( $ slug ) ; if ( ! isset ( $ values [ $ index ] [ $ property _type _slug ] ) ) { continue ; } $ property _type _value = $ values [ $ index ] [ $ property _type _slug ] ; $ property _type = papi _get _property _type ( $ property _type _value ) ; if ( ! is _object ( $ property _type ) ) { continue ; } 
protected function get _json _id ( $ key , $ extra = ' ' ) { return $ this - > get _slug ( ) . ' _ ' . papi _slugify ( $ key ) . ( empty ( $ extra ) ? ' ' : ' _ ' . $ extra ) ; } 
protected function get _layout ( $ slug ) { $ layouts = $ this - > get _settings _layouts ( ) ; foreach ( $ layouts as $ layout ) { if ( $ layout [ 'slug ' ] = = = $ slug ) { return $ layout ; } } return [ ] ; } 
protected function get _results ( $ value , $ repeater _slug , $ post _id ) { global $ wpdb ; if ( $ this - > get _meta _type ( ) = = = 'option ' ) { $ table = $ wpdb - > prefix . 'options ' ; 
public function load _value ( $ value , $ repeater _slug , $ post _id ) { if ( is _array ( $ value ) ) { return $ value ; } list ( $ results , $ trash ) = $ this - > get _results ( $ value , $ repeater _slug , $ post _id ) ; 
protected function load _child _properties ( array $ results , $ property = null ) { $ layout _key = substr ( $ this - > layout _key , 1 ) ; foreach ( $ results as $ index = > $ row ) { foreach ( $ row as $ slug = > $ value ) { $ children = [ ] ; if ( $ layout _key = = = $ slug ) { continue ; } if ( isset ( $ results [ $ index ] [ $ layout _key ] ) ) { $ layout = $ results [ $ index ] [ $ layout _key ] ; $ layout = $ this - > get _layout ( $ layout ) ; if ( ! empty ( $ layout ) & & isset ( $ layout [ 'items ' ] ) ) { $ children = $ layout [ 'items ' ] ; } } $ child _property = null ; foreach ( $ children as $ child ) { if ( $ child - > match _slug ( $ slug ) ) { $ child _property = $ child ; } } if ( empty ( $ child _property ) ) { $ child _property = $ this - > get _store ( ) - > get _property ( $ this - > get _slug ( true ) , $ slug ) ; } if ( is _array ( $ value ) & & papi _is _property ( $ child _property ) & & ! empty ( $ child _property - > get _child _properties ( ) ) ) { $ new _value = papi _from _property _array _slugs ( $ value , unpapify ( $ slug ) ) ; if ( empty ( $ new _value ) ) { $ results [ $ index ] [ $ slug ] = $ value ; } else { $ results [ $ index ] [ $ slug ] = $ this - > load _child _properties ( $ new _value , $ child _property ) ; } } $ type _key = papi _get _property _type _key _f ( $ slug ) ; if ( $ property - > match _slug ( $ slug ) ) { $ results [ $ index ] [ $ type _key ] = $ property ; } else { $ results [ $ index ] [ $ type _key ] = $ property - > get _child _property ( $ slug , $ children ) ; } } } return $ results ; } 
protected function prepare _properties ( $ layouts ) { $ layouts = array _map ( function ( $ layout ) { return ( array ) $ layout ; } , $ layouts ) ; foreach ( $ layouts as $ index = > $ layout ) { if ( ! $ this - > valid _layout ( $ layout ) ) { if ( is _array ( $ layout ) ) { unset ( $ layout [ $ index ] ) ; } else { unset ( $ layouts [ $ index ] ) ; } continue ; } if ( ! isset ( $ layout [ 'slug ' ] ) ) { $ layout [ 'slug ' ] = $ layout [ 'title ' ] ; } if ( ! isset ( $ layout [ 'row _label ' ] ) ) { $ layout [ 'row _label ' ] = $ layout [ 'title ' ] ; } if ( ! isset ( $ layout [ 'show _label ' ] ) ) { $ layout [ 'show _label ' ] = true ; } $ layouts [ $ index ] = array _merge ( $ layouts [ $ index ] , $ layout ) ; $ layouts [ $ index ] [ 'slug ' ] = papi _slugify ( $ layout [ 'slug ' ] ) ; $ layouts [ $ index ] [ 'slug ' ] = $ this - > get _layout _value ( $ layouts [ $ index ] [ 'slug ' ] ) ; $ layouts [ $ index ] [ 'items ' ] = parent : : prepare _properties ( $ layout [ 'items ' ] ) ; } return array _filter ( $ layouts ) ; } 
public function render _ajax _request ( ) { $ items = null ; $ layouts = $ this - > get _settings _layouts ( ) ; if ( defined ( 'DOING _PAPI _AJAX ' ) & & DOING _PAPI _AJAX ) { $ counter = papi _get _qs ( 'counter ' ) ; $ this - > counter = intval ( $ counter ) ; $ flexible _layout = papi _get _qs ( 'flexible _layout ' ) ; foreach ( $ layouts as $ layout ) { if ( $ layout [ 'slug ' ] = = = $ flexible _layout ) { $ items = $ layout ; break ; } } } if ( ! empty ( $ items ) ) { $ this - > render _properties ( $ items , false ) ; } } 
protected function render _layout _input ( $ value ) { $ slug = sprintf ( ' %s [ %d ] [ %s ] ' , $ this - > get _slug ( ) , $ this - > counter , $ this - > layout _key ) ; ? > <input type = "hidden " name = " < ?php echo esc _attr ( $ slug ) ; ? > " value = " < ?php echo esc _attr ( $ value ) ; ? > " / > < ?php } 
protected function render _properties ( $ row , $ value ) { $ has _value = $ value ! = = false ; $ render _layout = $ this - > get _setting ( 'layout ' ) ; $ layout _slug = isset ( $ row [ 'slug ' ] ) ? $ row [ 'slug ' ] : false ; $ layout _slug = empty ( $ layout _slug ) & & isset ( $ value [ ' _layout ' ] ) ? $ value [ ' _layout ' ] : $ layout _slug ; $ layout _slug = empty ( $ layout _slug ) & & isset ( $ value [ $ this - > layout _key ] ) ? $ value [ $ this - > layout _key ] : $ layout _slug ; $ row = isset ( $ row [ 'items ' ] ) ? $ row [ 'items ' ] : $ row ; $ layout = $ this - > get _layout ( $ layout _slug ) ; <td class = "repeater -column flexible -column < ?php echo $ render _layout = = = 'table ' ? 'flexible -layout -table ' : 'flexible -layout -row ' ; ? > " > <div class = "repeater -content -open " > < ?php <label class = "flexible -row -label " > < ?php echo esc _html ( $ layout [ 'row _label ' ] ) ; ? > < /label > < ?php endif ; ? > <table class = " < ?php echo $ render _layout = = = 'table ' ? 'flexible -table ' : 'papi -table ' ; ? > " > < ?php if ( $ render _layout = = = 'table ' ) : echo ' <thead > ' ; for ( $ i = 0 , $ l = count ( $ row ) ; $ i < $ l ; $ i + + ) { < /table > < /div > <div class = "repeater -content -closed " > < ?php if ( ! empty ( $ layout [ 'title ' ] ) ) { echo esc _html ( $ layout [ 'title ' ] ) ; } ? > < /div > < /td > < ?php } 
protected function render _repeater ( $ options ) { $ layouts = $ this - > get _settings _layouts ( ) ; ? > <div class = "papi -property -flexible papi -property -repeater -top " data -limit = " < ?php echo esc _attr ( $ this - > get _setting ( 'limit ' ) ) ; ? > " > <table class = "papi -table " > <tbody class = "repeater -tbody flexible -tbody " > < ?php $ this - > render _repeater _row ( ) ; ? > < /tbody > < /table > <div class = "bottom " > <div class = "flexible -layouts -btn -wrap " > <div class = "flexible -layouts flexible -layouts -hidden " > <div class = "flexible -layouts -arrow " > < /div > <ul > < ?php foreach ( $ layouts as $ layout ) { papi _render _html _tag ( 'li ' , [ papi _html _tag ( 'a ' , [ 'data -layout ' = > esc _html ( $ layout [ 'slug ' ] ) , 'data -papi -json ' = > sprintf ( ' %s _repeater _json ' , $ options - > slug ) , 'href ' = > ' # ' , 'role ' = > 'button ' , 'tabindex ' = > 0 , esc _html ( $ layout [ 'title ' ] ) ] ) ] ) ; } ? > < /ul > < /div > < ?php papi _render _html _tag ( 'button ' , [ 'class ' = > 'button button -primary ' , 'type ' = > 'button ' , esc _html ( $ this - > get _setting ( 'add _new _label ' ) ) ] ) ; ? > < /div > < /div > < ?php ? > <input type = "hidden " data -papi -rule = " < ?php echo esc _attr ( $ options - > slug ) ; ? > " name = " < ?php echo esc _attr ( $ this - > get _slug ( ) ) ; ? > [ ] " / > < /div > < ?php } 
protected function render _repeater _row ( ) { $ layouts = $ this - > get _settings _layouts ( ) ; $ values = $ this - > get _value ( ) ; <tr < ?php echo $ closed _rows ? 'class = "closed " ' : ' ' ; ? > > <td class = "handle " > <span class = "toggle " > < /span > <span class = "count " > < ?php echo esc _html ( $ this - > counter + 1 ) ; ? > < /span > < /td > < ?php foreach ( $ layouts as $ layout ) { <td class = "last " > <span > <a title = " < ?php esc _html _e ( 'Remove ' , 'papi ' ) ; ? > " href = " # " class = "repeater -remove -item " >x < /a > < /span > < /td > < /tr > < ?php endforeach ; } 
public function add _form _fields ( ) { $ html _name = esc _attr ( papi _get _page _type _key ( ) ) ; $ taxonomy = papi _get _qs ( 'taxonomy ' ) ; $ taxonomy _object = get _taxonomy ( $ taxonomy ) ; <div class = "form -field " > <label for = " < ?php echo esc _attr ( $ html _name ) ; ? > " > < ?php echo esc _html ( sprintf ( _ _ ( ' %s type ' , 'papi ' ) , $ taxonomy _object - > labels - > singular _name ) ) ; ? > < /label > <select name = " < ?php echo esc _attr ( $ html _name ) ; ? > " id = " < ?php echo esc _attr ( $ html _name ) ; ? > " data -papi -page -type -key = "true " > < ?php foreach ( $ taxonomy _types as $ taxonomy _type ) { papi _render _html _tag ( 'option ' , [ 'data -redirect ' = > $ taxonomy _type - > redirect _after _create , 'value ' = > esc _attr ( $ taxonomy _type - > get _id ( ) ) , esc _html ( $ taxonomy _type - > name ) ] ) ; } ? > < /select > < /div > < ?php else : papi _render _html _tag ( 'input ' , [ 'data -redirect ' = > $ taxonomy _types [ 0 ] - > redirect _after _create , 'data -papi -page -type -key ' = > true , 'name ' = > esc _attr ( $ html _name ) , 'type ' = > 'hidden ' , 'value ' = > esc _attr ( $ taxonomy _types [ 0 ] - > get _id ( ) ) ] ) ; endif ; } 
protected function prepare _taxonomy _types ( array $ taxonomy _types ) { $ taxonomy = papi _get _qs ( 'taxonomy ' ) ; if ( papi _filter _settings _show _standard _taxonomy _type ( $ taxonomy ) ) { $ id = sprintf ( 'papi -standard - %s -type ' , $ taxonomy ) ; $ taxonomy _type = new Papi _Taxonomy _Type ( $ id ) ; $ taxonomy _type - > id = $ id ; $ taxonomy _type - > name = papi _filter _settings _standard _taxonomy _type _name ( $ taxonomy ) ; $ taxonomy _type - > taxonomy = [ $ taxonomy ] ; $ taxonomy _types [ ] = $ taxonomy _type ; } usort ( $ taxonomy _types , function ( $ a , $ b ) { return strcmp ( $ a - > name , $ b - > name ) ; } ) ; return papi _sort _order ( array _reverse ( $ taxonomy _types ) ) ; } 
public function setup _taxonomies _hooks ( ) { $ this - > taxonomy _types = papi _get _all _entry _types ( [ 'types ' = > 'taxonomy ' ] ) ; $ taxonomies = array _reduce ( $ this - > taxonomy _types , function ( $ taxonomies , $ taxonomy _type ) { return array _merge ( $ taxonomies , $ taxonomy _type - > taxonomy ) ; } , [ ] ) ; $ taxonomies = array _unique ( $ taxonomies ) ; foreach ( $ taxonomies as $ taxonomy ) { if ( is _string ( $ taxonomy ) & & taxonomy _exists ( $ taxonomy ) ) { add _action ( $ taxonomy . ' _add _form _fields ' , [ $ this , 'add _form _fields ' ] ) ; } } } 
public function ajax _url ( ) { if ( empty ( $ this - > structure ) ) { $ url = esc _url ( home _url ( 'index .php ' , is _ssl ( ) ? 'https ' : 'http ' ) ) ; } else { $ url = esc _url ( home _url ( ' /papi -ajax / ' , is _ssl ( ) ? 'https ' : 'http ' ) ) ; } ? > <script type = "text /javascript " > var papi = papi | | { } ; papi .ajax Url = ' < ?php echo esc _html ( $ url ) ; ? > ' ; < /script > < ?php } 
public function handle _papi _ajax ( ) { if ( defined ( 'DOING _AJAX ' ) & & DOING _AJAX ) { return ; } $ ajax _action = ' ' ; if ( ! empty ( $ _GET [ 'action ' ] ) ) { $ ajax _action = sanitize _text _field ( $ _GET [ 'action ' ] ) ; } if ( is _user _logged _in ( ) & & has _action ( $ this - > action _prefix . $ ajax _action ) ! = = false ) { if ( ! defined ( 'DOING _AJAX ' ) ) { define ( 'DOING _AJAX ' , true ) ; } if ( ! defined ( 'DOING _PAPI _AJAX ' ) ) { define ( 'DOING _PAPI _AJAX ' , true ) ; } status _header ( 2 0 0 ) ; do _action ( $ this - > action _prefix . $ ajax _action ) ; wp _die ( ) ; } } 
public function get _entry _type ( ) { $ entry _type _id = papi _get _qs ( 'entry _type ' ) ; $ entry _type = papi _get _entry _type _by _id ( $ entry _type _id ) ; if ( empty ( $ entry _type ) ) { $ this - > render _error ( 'No entry type found ' ) ; return ; } wp _send _json ( $ entry _type ) ; } 
public function get _posts ( ) { $ args = papi _get _qs ( 'query ' ) ? : [ ] ; $ args = is _array ( $ args ) ? $ args : [ ] ; $ fields = papi _get _qs ( 'fields ' ) ? : [ ] ; $ fields = is _array ( $ fields ) ? $ fields : [ ] ; $ posts = ( new WP _Query ( array _merge ( [ 'posts _per _page ' = > - 1 , 'post _status ' = > 'any ' , 'post _type ' = > [ 'post ' ] , 'no _found _rows ' = > true , 'update _post _meta _cache ' = > false , 'update _post _term _cache ' = > false ] , $ args ) ) ) - > posts ; $ posts = array _filter ( $ posts , function ( $ post ) { return ! empty ( $ post - > post _title ) ; } ) ; usort ( $ posts , function ( $ a , $ b ) { return strcmp ( strtolower ( $ a - > post _title ) , strtolower ( $ b - > post _title ) ) ; } ) ; if ( ! empty ( $ fields ) ) { foreach ( $ posts as $ index = > $ post ) { $ item = [ ] ; foreach ( $ fields as $ field ) { $ item [ $ field ] = $ post - > $ field ; } $ posts [ $ index ] = $ item ; } } wp _send _json ( $ posts ) ; } 
public function get _property ( ) { $ default _options = Papi _Core _Property : : factory ( ) - > get _options ( ) ; $ keys = array _keys ( get _object _vars ( $ default _options ) ) ; $ options = papi _get _qs ( $ keys , true ) ; if ( $ property = papi _property ( $ options ) ) { ob _start ( ) ; $ property - > render _ajax _request ( ) ; $ html = ob _get _clean ( ) ; wp _send _json ( [ 'html ' = > utf 8 _encode ( $ html ) ] ) ; return ; } $ this - > render _error ( 'No property found ' ) ; } 
public function get _properties ( ) { if ( ! papi _get _sanitized _post ( 'properties ' ) ) { $ this - > render _error ( 'No properties found ' ) ; return ; } $ items = json _decode ( stripslashes ( $ _POST [ 'properties ' ] ) , true ) ; if ( empty ( $ items ) | | ! is _array ( $ items ) ) { $ this - > render _error ( 'No properties found ' ) ; return ; } foreach ( $ items as $ key = > $ item ) { $ property = papi _property ( ( array ) $ item ) ; if ( ! papi _is _property ( $ property ) ) { unset ( $ items [ $ key ] ) ; continue ; } ob _start ( ) ; $ property - > render _ajax _request ( ) ; $ items [ $ key ] = trim ( ob _get _clean ( ) ) ; } $ items = array _filter ( $ items ) ; if ( empty ( $ items ) ) { $ this - > render _error ( 'No properties found ' ) ; return ; } wp _send _json ( [ 'html ' = > $ items ] ) ; } 
public function get _rules _result ( ) { if ( ! papi _get _sanitized _post ( 'data ' ) ) { $ this - > render _error ( 'No rule found ' ) ; return ; } $ data = json _decode ( stripslashes ( papi _get _sanitized _post ( 'data ' ) ) , true ) ; if ( empty ( $ data ) | | ! is _array ( $ data ) | | ! isset ( $ data [ 'slug ' ] ) ) { $ this - > render _error ( 'No rule found ' ) ; return ; } $ entry _type = papi _get _entry _type _by _meta _id ( ) ; if ( empty ( $ entry _type ) ) { $ entry _type _id = papi _get _qs ( 'entry _type ' ) ; $ entry _type = papi _get _entry _type _by _id ( $ entry _type _id ) ; } if ( $ entry _type instanceof Papi _Entry _Type = = = false ) { $ this - > render _error ( 'No rule found ' ) ; return ; } if ( preg _match ( ' / \ [ \ ] $ / ' , $ data [ 'slug ' ] ) ) { $ data [ 'slug ' ] = preg _replace ( ' / \ [ \ ] $ / ' , ' ' , $ data [ 'slug ' ] ) ; } if ( $ property = $ entry _type - > get _property ( $ data [ 'slug ' ] ) ) { wp _send _json ( [ 'render ' = > $ property - > render _is _allowed _by _rules ( $ data [ 'rules ' ] ) ] ) ; return ; } $ this - > render _error ( 'No rule found ' ) ; } 
public function get _shortcode ( ) { $ shortcode = papi _get _qs ( 'shortcode ' ) ? : ' ' ; $ shortcode = html _entity _decode ( $ shortcode ) ; $ shortcode = wp _unslash ( $ shortcode ) ; wp _send _json ( [ 'html ' = > do _shortcode ( $ shortcode ) ] ) ; } 
public function get _terms ( ) { $ query = papi _get _qs ( 'query ' ) ? : [ ] ; $ query = is _array ( $ query ) ? $ query : [ ] ; $ taxonomy = papi _get _qs ( 'taxonomy ' ) ? : ' ' ; $ args = array _merge ( $ query , [ 'fields ' = > 'id = >name ' ] ) ; $ terms = [ ] ; if ( taxonomy _exists ( $ taxonomy ) ) { $ terms = get _terms ( $ taxonomy , $ args ) ; } wp _send _json ( $ terms ) ; } 
protected function setup _actions ( ) { add _action ( 'init ' , [ $ this , 'add _endpoint ' ] ) ; add _action ( 'parse _request ' , [ $ this , 'handle _papi _ajax ' ] ) ; add _action ( 'admin _enqueue _scripts ' , [ $ this , 'ajax _url ' ] , 1 0 ) ; 
public function get ( $ args , $ assoc _args ) { try { 
public function rename ( $ args , $ assoc _args ) { $ type = $ args [ 0 ] ; $ old _key = $ args [ 1 ] ; $ new _key = $ args [ 2 ] ; $ terms = ( new Papi _Query ( [ 'entry _type ' = > $ type , 'fields ' = > 'ids ' ] ) ) - > get _result ( ) ; if ( empty ( $ terms ) ) { WP _CLI : : error ( 'No terms found ' ) ; } foreach ( $ terms as $ term ) { $ meta = get _term _meta ( $ term , $ old _key , true ) ; if ( papi _is _empty ( $ meta ) ) { continue ; } if ( delete _term _meta ( $ term , $ old _key ) = = = false ) { WP _CLI : : error ( 'Could not delete term meta with key : ' . $ old _key ) ; } if ( update _term _meta ( $ term , $ new _key , $ meta ) = = = false ) { WP _CLI : : error ( 'Could not update term meta with key : ' . $ new _key ) ; } } WP _CLI : : success ( 'Done ' ) ; } 
public function manage _page _type _posts _columns ( array $ defaults = [ ] ) { if ( ! in _array ( $ this - > post _type , papi _get _post _types ( ) , true ) & & ! in _array ( $ this - > taxonomy , papi _get _taxonomies ( ) , true ) ) { return $ defaults ; } if ( apply _filters ( 'papi /settings /column _hide _ ' . $ this - > get _meta _type _value ( ) , false ) ) { return $ defaults ; } $ defaults [ 'entry _type ' ] = apply _filters ( 'papi /settings /column _title _ ' . $ this - > get _meta _type _value ( ) , esc _html _ _ ( 'Type ' , 'papi ' ) ) ; return $ defaults ; } 
public function manage _page _type _posts _custom _column ( $ column _name , $ post _id , $ term _id = null ) { if ( ! in _array ( $ this - > post _type , papi _get _post _types ( ) , true ) & & ! in _array ( $ this - > taxonomy , papi _get _taxonomies ( ) , true ) ) { return ; } if ( apply _filters ( 'papi /settings /column _hide _ ' . $ this - > get _meta _type _value ( ) , false ) ) { return ; } 
public function manage _page _type _sortable _columns ( $ columns ) { if ( in _array ( $ this - > post _type , papi _get _post _types ( ) , true ) | | in _array ( $ this - > taxonomy , papi _get _taxonomies ( ) , true ) ) { $ columns [ 'entry _type ' ] = 'entry _type ' ; } return $ columns ; } 
public function pre _get _posts ( WP _Query $ query ) { global $ pagenow ; if ( $ pagenow = = = 'edit .php ' & & ! is _null ( papi _get _qs ( 'page _type ' ) ) ) { if ( papi _get _qs ( 'page _type ' ) = = = 'papi -standard -page ' ) { $ query - > set ( 'meta _query ' , [ [ 'key ' = > papi _get _page _type _key ( ) , 'compare ' = > 'NOT EXISTS ' ] ] ) ; } else { $ query - > set ( 'meta _key ' , papi _get _page _type _key ( ) ) ; $ query - > set ( 'meta _value ' , papi _get _qs ( 'page _type ' ) ) ; } } 
public function restrict _page _types ( ) { $ post _types = papi _get _post _types ( ) ; if ( in _array ( $ this - > post _type , $ post _types , true ) ) { $ page _types = papi _get _all _page _types ( $ this - > post _type ) ; $ page _types = array _map ( function ( $ page _type ) { return [ 'name ' = > $ page _type - > name , 'value ' = > $ page _type - > get _id ( ) ] ; } , $ page _types ) ; <select name = "page _type " class = "postform " > <option value = " 0 " selected > < ?php esc _html _e ( 'All types ' , 'papi ' ) ; ? > < /option > < ?php foreach ( $ page _types as $ page _type ) { printf ( ' <option value = " %s " %s > %s < /option > ' , esc _attr ( $ page _type [ 'value ' ] ) , papi _get _qs ( 'page _type ' ) = = = $ page _type [ 'value ' ] ? ' selected ' : ' ' , esc _html ( $ page _type [ 'name ' ] ) ) ; } ? > < /select > < ?php } } 
protected function setup _actions ( ) { 
protected function setup _filters ( ) { 
public function format _value ( $ value , $ slug , $ term _id ) { $ meta _key = $ this - > get _setting ( 'meta _key ' ) ; if ( empty ( $ meta _key ) ) { if ( is _numeric ( $ value ) & & intval ( $ value ) ! = = 0 ) { $ term _id = $ value ; } } else { $ args = [ 'fields ' = > 'ids ' , 'meta _key ' = > $ meta _key , 'meta _value ' = > $ value , 'hide _empty ' = > false , 'taxonomy ' = > $ this - > get _setting ( 'taxonomy ' ) , 'number ' = > 1 ] ; $ terms = get _terms ( $ args ) ; if ( ! empty ( $ terms ) & & ! is _wp _error ( $ terms ) ) { $ term _id = $ terms [ 0 ] ; } } 
protected function get _labels ( ) { $ results = [ ] ; foreach ( $ this - > get _taxonomies ( ) as $ taxonomy ) { if ( taxonomy _exists ( $ taxonomy ) ) { $ taxonomy _object = get _taxonomy ( $ taxonomy ) ; $ results [ $ taxonomy ] = $ taxonomy _object - > labels - > name ; } } return $ results ; } 
protected function get _terms ( $ taxonomy ) { 
protected function get _term _value ( $ term ) { $ meta _key = $ this - > get _setting ( 'meta _key ' ) ; if ( is _numeric ( $ term ) ) { $ term _id = $ term ; } else { $ term = get _term ( $ term ) ; if ( $ term instanceof WP _Term = = = false ) { return 0 ; } $ term _id = $ term - > term _id ; } if ( ! empty ( $ meta _key ) ) { $ value = get _term _meta ( $ term _id , $ meta _key , true ) ; } else { $ value = $ term _id ; } return $ value ; } 
public function html ( ) { $ settings = $ this - > get _settings ( ) ; $ layout = $ settings - > layout ; $ labels = $ this - > get _labels ( ) ; $ taxonomies = $ this - > get _taxonomies ( ) ; $ render _label = count ( $ taxonomies ) > 1 ; $ advanced = $ render _label & & $ layout = = = 'advanced ' ; $ single = $ render _label & & $ layout ! = = 'advanced ' ; $ classes = count ( $ taxonomies ) > 1 ? ' ' : 'papi -fullwidth ' ; $ value = $ this - > get _value ( ) ; $ selected _term = get _term ( $ value ) ; $ selected _term = is _wp _error ( $ selected _term ) | | empty ( $ selected _term ) ? ' ' : $ selected _term ; $ selected _taxonomy = empty ( $ selected _term ) ? reset ( $ taxonomies ) : $ selected _term - > taxonomy ; $ value = $ this - > get _term _value ( $ value ) ; $ selected _label = reset ( $ labels ) ; if ( $ settings - > select 2 ) { $ classes = ' papi -component -select 2 ' ; } ? > <div class = "papi -property -term < ?php echo $ advanced ? 'advanced ' : ' ' ; ? > " > < ?php if ( $ advanced ) : ? > <table class = "papi -table " > <tr > <td > <label for = " < ?php echo esc _attr ( $ this - > html _id ( ) ) ; ? > _taxonomy " > < ?php echo esc _html ( $ settings - > labels [ 'select _taxonomy ' ] ) ; ? > < /label > < /td > <td > <select id = " < ?php echo esc _attr ( $ this - > html _id ( ) ) ; ? > _taxonomy " class = " < ?php echo esc _attr ( $ classes ) ; ? > papi -property -term -left " data -select -item = " < ?php echo esc _attr ( $ settings - > labels [ 'select _item ' ] ) ; ? > " data -term -query = ' < ?php echo esc _attr ( papi _maybe _json _encode ( $ settings - > query ) ) ; ? > ' data -width = " 1 0 0 % " > < ?php foreach ( $ labels as $ taxonomy = > $ label ) { papi _render _html _tag ( 'option ' , [ 'value ' = > $ taxonomy , 'selected ' = > $ taxonomy = = = $ selected _taxonomy , $ label ] ) ; if ( $ selected ) { $ selected _label = $ label ; } } ? > < /select > < /td > < /tr > <tr > <td > <label for = " < ?php echo esc _attr ( $ this - > html _id ( ) ) ; ? > _terms " > < ?php echo esc _html ( sprintf ( $ settings - > labels [ 'select _item ' ] , $ selected _label ) ) ; ? > < /label > < /td > <td > < ?php endif ; ? > < ?php $ placeholder = ! is _null ( $ settings - > placeholder ) ? $ settings - > placeholder : ' ' ; $ placeholder = papi _is _empty ( $ placeholder ) ? ' &nbsp ; ' : $ placeholder ; ? > <select class = " < ?php echo esc _attr ( $ classes ) ; ? > papi -property -term -right " id = " < ?php echo esc _attr ( $ this - > html _id ( ) ) ; ? > _terms " name = " < ?php echo esc _attr ( $ this - > html _name ( ) ) ; ? > " class = " < ?php echo esc _attr ( $ classes ) ; ? > " data -allow -clear = " < ?php echo is _null ( $ settings - > placeholder ) ? 'false ' : 'true ' ; ? > " data -placeholder = " < ?php echo esc _attr ( $ placeholder ) ; ? > " data -width = " 1 0 0 % " > < ?php if ( ! is _null ( $ settings - > placeholder ) ) : ? > <option value = " < ?php echo esc _attr ( $ this - > get _option ( 'default ' , ' ' ) ) ; ? > " > < ?php echo esc _html ( $ placeholder ) ; ? > < /option > < ?php endif ; ? > < ?php foreach ( $ taxonomies as $ taxonomy ) : ? > < ?php if ( $ advanced & & $ taxonomy ! = = $ selected _taxonomy ) { continue ; } $ terms = $ this - > get _terms ( $ taxonomy ) ; if ( empty ( $ terms ) ) { continue ; } ? > < ?php if ( $ single ) : ? > <optgroup label = " < ?php echo esc _attr ( $ labels [ $ taxonomy ] ) ; ? > " > < ?php endif ; ? > < ?php foreach ( $ terms as $ term _id = > $ term _name ) { if ( papi _is _empty ( $ term _name ) ) { continue ; } papi _render _html _tag ( 'option ' , [ 'data -allow -clear ' = > $ settings - > allow _clear , 'value ' = > $ this - > get _term _value ( $ term _id ) , 'selected ' = > $ value = = = $ this - > get _term _value ( $ term _id ) , esc _html ( $ term _name ) ] ) ; } ? > < ?php if ( $ single ) : ? > < /optgroup > < ?php endif ; ? > < ?php endforeach ; ? > < /select > < ?php if ( $ advanced ) : ? > < /td > < /tr > < /table > < ?php endif ; ? > < /div > < ?php } 
public function format _value ( $ value , $ slug , $ post _id ) { if ( is _string ( $ value ) & & $ value = = = 'false ' | | $ value = = = false ) { return false ; } return is _string ( $ value ) & & ( $ value = = = 'true ' | | $ value = = = 'on ' ) | | $ value = = = true ; } 
public function html ( ) { $ value = $ this - > get _value ( ) ; papi _render _html _tag ( 'input ' , [ 'type ' = > 'hidden ' , 'name ' = > esc _attr ( $ this - > html _name ( ) ) , 'value ' = > false ] ) ; papi _render _html _tag ( 'input ' , [ 'checked ' = > ! empty ( $ value ) , 'id ' = > esc _attr ( $ this - > html _id ( ) ) , 'name ' = > esc _attr ( $ this - > html _name ( ) ) , 'type ' = > 'checkbox ' ] ) ; } 
protected function prepare _value ( $ value ) { if ( is _string ( $ value ) & & ( $ value = = = 'true ' | | $ value = = = 'on ' ) | | $ value = = = true ) { return true ; } return null ; } 
public function html ( ) { $ post _id = papi _get _post _id ( ) ; $ settings = $ this - > get _settings ( ) ; <ul class = "papi -property -reference " data -papi -rule = " < ?php echo esc _attr ( $ this - > html _name ( ) ) ; ? > " > < ?php if ( empty ( $ values ) ) : ? > <p > < ?php esc _html _e ( 'No references exists ' , 'papi ' ) ; ? > < /p > < ?php endif ; ksort ( $ values ) ; foreach ( $ values as $ title = > $ val ) : $ post _type = get _post _type _object ( $ title ) ; ? > <li > <h 3 > < ?php echo esc _html ( $ post _type - > labels - > name ) ; ? > < /h 3 > <div class = "handlediv " title = "Click to toggle " > <br > < /div > < /li > <li > <div class = "page -types " > <ul > < ?php ksort ( $ val ) ; foreach ( $ val as $ name = > $ posts ) : ? > <li class = "heading -border " > <h 4 > < ?php echo esc _html ( $ name ) ; ? > < /h 4 > <div class = "handlediv " title = "Click to toggle " > <br > < /div > < /li > <li > <div class = "box " > < ?php $ i = 0 ; foreach ( $ posts as $ post ) : ? > <a href = " < ?php echo esc _attr ( get _edit _post _link ( $ post - > ID ) ) ; ? > " > < ?php echo esc _html ( $ post - > post _title ) ; ? > < /a > < ?php $ i + + ; endforeach ; ? > <div class = "clear " > < /div > < /div > < /li > < ?php endforeach ; ? > < /ul > <div class = "clear " > < /div > < /div > < /li > < ?php endforeach ; ? > < /ul > < ?php } 
public function search ( $ search Term ) { $ url = 'https : / /finance .yahoo .com / _finance _doubledown /api /resource /searchassist ;gossip Config = % 7B % 2 2query Key % 2 2 : % 2 2query % 2 2 , % 2 2result Accessor % 2 2 : % 2 2Result Set .Result % 2 2 , % 2 2suggestion Title Accessor % 2 2 : % 2 2symbol % 2 2 , % 2 2suggestion Meta % 2 2 : [ % 2 2symbol % 2 2 ] , % 2 2url % 2 2 : % 7B % 2 2query % 2 2 : % 7B % 2 2region % 2 2 : % 2 2US % 2 2 , % 2 2lang % 2 2 : % 2 2en -US % 2 2 % 7D % 7D % 7D ;search Term = ' . urlencode ( $ search Term ) . ' ?bkt = [ % 2 2findd -ctrl % 2 2 , % 2 2fin -strm -test 1 % 2 2 , % 2 2fndmtest % 2 2 , % 2 2finnossl % 2 2 ] &device =desktop &feature =canvass Offnet ,fin Gray Nav ,new Content Attribution ,related Video Feature ,video Native Playlist ,livecoverage &intl =us &lang =en -US &partner =none &prid =eo 2okrhcni 0 0f &region =US &site =finance &tz =UTC &ver = 0 . 1 0 2 . 4 3 2 &return Meta =true ' ; $ response Body = ( string ) $ this - > client - > request ( 'GET ' , $ url ) - > get Body ( ) ; return $ this - > result Decoder - > transform Search Result ( $ response Body ) ; } 
public function get Historical Data ( $ symbol , $ interval , \ Date Time $ start Date , \ Date Time $ end Date ) { $ allowed Intervals = [ self : : INTERVAL _ 1 _DAY , self : : INTERVAL _ 1 _WEEK , self : : INTERVAL _ 1 _MONTH ] ; if ( ! in _array ( $ interval , $ allowed Intervals ) ) { throw new \ Invalid Argument Exception ( 'Interval must be one of : ' . implode ( ' , ' , $ allowed Intervals ) ) ; } if ( $ start Date > $ end Date ) { throw new \ Invalid Argument Exception ( 'Start date must be before end date ' ) ; } $ cookie Jar = new Cookie Jar ( ) ; $ initial Url = 'https : / /finance .yahoo .com /quote / ' . urlencode ( $ symbol ) . ' /history ?p = ' . urlencode ( $ symbol ) ; $ response Body = ( string ) $ this - > client - > request ( 'GET ' , $ initial Url , [ 'cookies ' = > $ cookie Jar ] ) - > get Body ( ) ; $ crumb = $ this - > result Decoder - > extract Crumb ( $ response Body ) ; $ data Url = 'https : / /query 1 .finance .yahoo .com /v 7 /finance /download / ' . urlencode ( $ symbol ) . ' ?period 1 = ' . $ start Date - > get Timestamp ( ) . ' &period 2 = ' . $ end Date - > get Timestamp ( ) . ' &interval = ' . $ interval . ' &events =history &crumb = ' . urlencode ( $ crumb ) ; $ response Body = ( string ) $ this - > client - > request ( 'GET ' , $ data Url , [ 'cookies ' = > $ cookie Jar ] ) - > get Body ( ) ; return $ this - > result Decoder - > transform Historical Data Result ( $ response Body ) ; } 
public function get Quote ( $ symbol ) { $ list = $ this - > fetch Quotes ( [ $ symbol ] ) ; return isset ( $ list [ 0 ] ) ? $ list [ 0 ] : null ; } 
public function get Exchange Rate ( $ currency 1 , $ currency 2 ) { $ list = $ this - > get Exchange Rates ( [ [ $ currency 1 , $ currency 2 ] ] ) ; return isset ( $ list [ 0 ] ) ? $ list [ 0 ] : null ; } 
public function get Exchange Rates ( array $ currency Pairs ) { $ currency Symbols = array _map ( function ( array $ currencies ) { return implode ( $ currencies ) . self : : CURRENCY _SYMBOL _SUFFIX ; 
private function fetch Quotes ( array $ symbols ) { $ url = 'https : / /query 1 .finance .yahoo .com /v 7 /finance /quote ?symbols = ' . urlencode ( implode ( ' , ' , $ symbols ) ) ; $ response Body = ( string ) $ this - > client - > request ( 'GET ' , $ url ) - > get Body ( ) ; return $ this - > result Decoder - > transform Quotes ( $ response Body ) ; } 
public static function create Api Client ( Client Interface $ guzzle Client = null ) { $ guzzle Client = $ guzzle Client ? $ guzzle Client : new Client ( ) ; $ result Decoder = new Result Decoder ( ) ; return new Api Client ( $ guzzle Client , $ result Decoder ) ; } 
public function fire ( ) { if ( $ this - > option ( 'new ' ) ) { $ this - > create New Administrator ( ) ; return ; } if ( $ this - > option ( 'delete ' ) ) { $ this - > delete Administrator ( ) ; return ; } if ( $ this - > option ( 'password ' ) ) { $ this - > change Password ( ) ; return ; } $ this - > list Administrators ( ) ; } 
protected function get Attributes For Header ( ) { $ attributes = [ ] ; if ( ! $ this - > is Sortable ( ) ) { $ attributes [ 'data -sortable ' ] = 'false ' ; } if ( $ this - > is Sortable Default ( ) ) { $ attributes [ 'data -sortable -default ' ] = $ this - > sortable Dest ; } $ attributes [ 'style ' ] = 'width : 1 0px ; ' ; return $ attributes ; } 
public function render ( $ instance , $ total Count , $ content = null ) { if ( is _null ( $ content ) ) { $ content = $ this - > value From Instance ( $ instance , $ this - > name ) ; } $ content = $ this - > render Appends ( $ instance , $ total Count , $ content ) ; return $ this - > html Builder - > tag ( 'td ' , $ this - > get Attributes For Cell ( $ instance ) , $ content ) ; } 
protected function render Appends ( $ instance , $ total Count , $ content ) { $ appends = [ $ content ] ; foreach ( $ this - > appends as $ append ) { $ appends [ ] = $ append - > render ( $ instance , $ total Count ) ; } return implode ( ' ' , $ appends ) ; } 
public function value From Instance ( $ instance , $ name ) { $ result = $ instance ; $ parts = explode ( ' . ' , $ name ) ; foreach ( $ parts as $ part ) { if ( $ result instanceof Collection ) { $ result = $ result - > lists ( $ part ) ; } elseif ( is _null ( $ result ) ) { $ result = null ; } else { $ result = $ result - > $ part ; } } if ( is _string ( $ result ) ) { $ result = e ( $ result ) ; } return $ result ; } 
public function get All ( ) { $ files = $ this - > get All Files ( ) ; $ result = [ ] ; foreach ( $ files as $ file ) { $ result [ ] = $ this - > create Image Object ( $ file ) ; } return $ result ; } 
public function post Upload ( ) { $ image Directory = Config : : get ( 'admin .images Upload Directory ' ) ; $ upload _dir = Config : : get ( 'admin .images Directory ' ) . ' / ' . $ image Directory ; $ allowed Extensions = [ 'bmp ' , 'gif ' , 'jpg ' , 'jpeg ' , 'png ' ] ; $ maxsize = 2 0 0 0 ; $ maxwidth = 9 0 0 0 ; $ maxheight = 8 0 0 0 ; $ minwidth = 1 0 ; $ minheight = 1 0 ; $ file = Input : : file ( 'upload ' ) ; $ errors = [ ] ; $ extension = null ; $ width = 0 ; $ height = 0 ; try { if ( is _null ( $ file ) ) { $ errors [ ] = Lang : : get ( 'admin : :lang .ckeditor .upload .error .common ' ) ; throw new Exception ; } $ extension = $ file - > guess Client Extension ( ) ; if ( ! in _array ( $ extension , $ allowed Extensions ) ) { $ errors [ ] = Lang : : get ( 'admin : :lang .ckeditor .upload .error .wrong _extension ' , [ 'file ' = > $ file - > get Client Original Name ( ) ] ) ; throw new Exception ; } if ( $ file - > get Size ( ) > $ maxsize * 1 0 0 0 ) { $ errors [ ] = Lang : : get ( 'admin : :lang .ckeditor .upload .error .filesize _limit ' , [ 'size ' = > $ maxsize ] ) ; } $ image = App : : make ( 'image ' ) - > make ( $ file ) ; $ width = $ image - > width ( ) ; $ height = $ image - > height ( ) ; if ( $ width > $ maxwidth | | $ height > $ maxheight ) { $ errors [ ] = Lang : : get ( 'admin : :lang .ckeditor .upload .error .imagesize _max _limit ' , [ 'width ' = > $ width , 'height ' = > $ height , 'maxwidth ' = > $ maxwidth , 'maxheight ' = > $ maxheight ] ) ; } if ( $ width < $ minwidth | | $ height < $ minheight ) { $ errors [ ] = Lang : : get ( 'admin : :lang .ckeditor .upload .error .imagesize _min _limit ' , [ 'width ' = > $ width , 'height ' = > $ height , 'minwidth ' = > $ minwidth , 'minheight ' = > $ minheight ] ) ; } } catch ( Exception $ e ) { } if ( ! empty ( $ errors ) ) { return ' <script >alert ( " ' . implode ( ' \ \n ' , $ errors ) . ' " ) ; < /script > ' ; } $ final Filename = Random Filenamer : : get ( $ upload _dir , $ extension ) ; $ file = $ file - > move ( $ upload _dir , $ final Filename ) ; $ CKEditor Func Num = Input : : get ( 'CKEditor Func Num ' ) ; $ url = URL : : route ( 'imagecache ' , [ 'original ' , $ image Directory . ' / ' . $ final Filename ] ) ; $ message = Lang : : get ( 'admin : :lang .ckeditor .upload .success ' , [ 'size ' = > number _format ( $ file - > get Size ( ) / 1 0 2 4 , 3 , ' . ' , ' ' ) , 'width ' = > $ width , 'height ' = > $ height ] ) ; $ result = "window .parent .CKEDITOR .tools .call Function ( $CKEditor Func Num , ' $url ' , ' $message ' ) " ; return ' <script > ' . $ result . ' ; < /script > ' ; } 
public function register ( ) { $ this - > register Commands ( ) ; $ this - > app - > register ( ' \Intervention \Image \Image Service Provider ' ) ; $ this - > app - > register ( ' \Sleeping Owl \Admin Auth \Admin Auth Service Provider ' ) ; $ this - > register Form Builder ( ) ; $ this - > app - > bind ( 'Sleeping Owl \Admin \Repositories \Interfaces \Model Repository Interface ' , 'Sleeping Owl \Admin \Repositories \Model Repository ' ) ; $ this - > app - > bind Shared ( 'Sleeping Owl \Admin \Admin ' , function ( $ app ) { return Admin : : instance ( ) ; } ) ; $ this - > app - > singleton ( 'admin ' , 'Sleeping Owl \Admin \Admin ' ) ; $ this - > app - > bind ( 'admin .router ' , function ( ) { return Admin : : instance ( ) - > router ; } ) ; $ this - > register Validate Exception Handler ( ) ; } 
public function fire ( ) { $ title = $ this - > option ( 'title ' ) ; $ this - > call ( 'vendor :publish ' , [ ' - -provider ' = > 'Intervention \Image \Image Service Provider Laravel 5 ' ] ) ; $ this - > call ( 'vendor :publish ' , [ ' - -provider ' = > 'Sleeping Owl \Admin \Admin Service Provider ' ] ) ; $ this - > publish DB ( ) ; $ this - > publish Imagecache Config ( ) ; $ this - > publish Self Config ( $ title ) ; $ this - > create Bootstrap Directory ( ) ; $ this - > create Menu File ( ) ; $ this - > create Bootstrap File ( ) ; $ this - > create Dummy User File ( ) ; $ this - > create Public Default Structure ( ) ; } 
public function with ( $ params = null ) { if ( ! is _array ( $ params ) ) { $ params = func _get _args ( ) ; } $ this - > with = $ params ; return $ this ; } 
public function set Defaults ( ) { foreach ( $ this - > items as $ item ) { $ name = $ item - > get Name ( ) ; if ( ! is _null ( $ name ) & & ! isset ( $ this - > instance - > $ name ) ) { $ this - > instance - > $ name = $ item - > get Default ( ) ; } } } 
public static function get ( $ path , $ extension ) { if ( ! Str : : ends With ( $ path , ' / ' ) ) { $ path . = ' / ' ; } do { $ name = Str : : random ( 1 0 ) . ' . ' . $ extension ; } while ( file _exists ( $ path . $ name ) ) ; return $ name ; } 
public function filter ( Builder $ query , $ parameters ) { $ parameter = $ this - > get Parameter ( $ parameters ) ; if ( is _null ( $ parameter ) ) return null ; if ( ! $ this - > apply Scope ( $ query , $ parameter ) & & $ this - > name ) { $ query - > where ( $ this - > name , ' = ' , $ parameter ) ; } return $ this - > title - > get ( $ parameter ) ; } 
protected function apply Scope ( Builder $ query , $ parameter ) { if ( $ this - > scope ) { $ query - > { $ this - > scope } ( $ parameter ) ; return true ; } return false ; } 
public function fire ( ) { $ compiler = new Model Compiler ( $ this , $ this - > get Model Class ( ) , $ this - > option ( 'title ' ) ) ; $ compiler - > parse Columns ( $ this - > option ( 'columns ' ) ) ; $ compiler - > generate Form ( ) ; $ template = $ this - > get Template ( ) ; $ replacement = $ compiler - > get Replacements ( ) ; $ template = $ this - > make Replacements ( $ template , $ replacement ) ; $ this - > save Result ( $ compiler - > get Model Class ( ) , $ template ) ; } 
public function from ( $ model Class , $ field = null ) { $ this - > from = $ model Class ; $ this - > field = $ field ? : static : : DEFAULT _FIELD ; return $ this ; } 
public function get ( $ parameter ) { if ( ! is _null ( $ this - > static Title ) ) return $ this - > static Title ; if ( is _null ( $ this - > from ) ) { throw new Title Not Formatted Exception ; } $ from = $ this - > from ; $ property = $ this - > field ; $ model = new $ this - > from ; $ model = $ this - > get Instance ( $ parameter , $ model ) ; if ( isset ( $ model - > $ property ) ) { return $ model - > $ property ; } throw new Model Attribute Not Found Exception ( $ from , $ property ) ; } 
protected function make Group ( $ name , $ label , $ form Element ) { $ content = ' ' ; $ content . = $ this - > label ( $ name , $ label ) ; $ content . = $ form Element ; return $ this - > wrap Content ( $ name , $ content ) ; } 
protected function wrap Content ( $ name , $ content ) { $ content . = $ this - > errors - > first ( $ name , $ this - > get Error Template ( ) ) ; $ class = $ this - > get Error Class ( $ name ) ; return $ this - > wrap Group ( $ content , compact ( 'class ' ) ) ; } 
protected function wrap Group ( $ content , array $ options = [ ] ) { $ options = $ this - > add Class To Options ( $ this - > get Form Group Class ( ) , $ options ) ; return $ this - > html - > tag ( 'div ' , $ options , $ content ) ; } 
protected function add Class To Options ( $ class To Add , array $ options = [ ] ) { $ class = array _get ( $ options , 'class ' , ' ' ) ; if ( is _array ( $ class ) ) { $ class [ ] = $ class To Add ; } elseif ( ! empty ( $ class ) ) { $ class . = ' ' . $ class To Add ; } else { $ class = $ class To Add ; } array _set ( $ options , 'class ' , $ class ) ; return $ options ; } 
public function register Routes ( ) { $ this - > register Assets Routes ( ) ; $ this - > register Auth Routes ( ) ; $ this - > register Image Cache Route ( ) ; $ models = Admin : : instance ( ) - > models - > get All Aliases ( ) ; $ this - > laravel Router - > group ( [ 'prefix ' = > $ this - > prefix , 'before ' = > $ this - > get Before Filters ( ) , 'namespace ' = > 'Sleeping Owl \Admin \Controllers ' , ] , function ( ) use ( $ models ) { if ( empty ( $ models ) ) $ models = [ ' _ _empty _models _ _ ' ] ; $ this - > laravel Router - > group ( [ 'where ' = > [ 'model ' = > implode ( ' | ' , $ models ) ] ] , function ( ) { foreach ( static : : $ model Routes as $ route ) { $ url = $ route [ 'url ' ] ; $ action = $ route [ 'action ' ] ; $ method = $ route [ 'method ' ] ; $ controller = isset ( $ route [ 'controller ' ] ) ? $ route [ 'controller ' ] : 'Admin Controller ' ; $ this - > laravel Router - > $ method ( $ url , [ 'as ' = > $ this - > route Prefix . ' .table . ' . $ action , 'uses ' = > $ controller . ' @ ' . $ action ] ) ; } } ) ; $ wildcard Route = $ this - > laravel Router - > any ( ' {wildcard ? } ' , [ 'as ' = > $ this - > route Prefix . ' .wildcard ' , 'uses ' = > 'Admin Controller @get Wildcard ' ] ) - > where ( 'wildcard ' , ' . * ' ) ; $ this - > set Route Priority ( $ wildcard Route , 0 ) ; } ) ; } 
protected function register Assets Routes ( ) { # CKEditor file listing and upload $ this - > laravel Router - > group ( [ 'before ' = > $ this - > get Before Filters ( ) , 'prefix ' = > 'images ' , 'namespace ' = > 'Sleeping Owl \Admin \Controllers ' ] , function ( ) { $ this - > laravel Router - > get ( 'all ' , 'Images Controller @get All ' ) ; $ this - > laravel Router - > post ( 'upload ' , 'Images Controller @post Upload ' ) ; } ) ; $ this - > laravel Router - > get ( 'js / {locale } /lang .js ' , [ 'prefix ' = > $ this - > prefix , 'as ' = > $ this - > route Prefix . ' .lang ' , 'uses ' = > 'Sleeping Owl \Admin \Controllers \Lang Controller @get All ' ] ) ; } 
protected function register Auth Routes ( ) { $ this - > laravel Router - > group ( [ 'prefix ' = > $ this - > prefix , 'namespace ' = > 'Sleeping Owl \Admin \Controllers ' ] , function ( ) { $ this - > laravel Router - > get ( 'login ' , [ 'as ' = > $ this - > route Prefix . ' .login ' , 'uses ' = > 'Auth Controller @get Login ' ] ) ; $ this - > laravel Router - > post ( 'login ' , [ 'as ' = > $ this - > route Prefix . ' .login .post ' , 'uses ' = > 'Auth Controller @post Login ' ] ) - > before ( 'csrf ' ) ; $ this - > laravel Router - > get ( 'logout ' , [ 'as ' = > $ this - > route Prefix . ' .logout ' , 'uses ' = > 'Auth Controller @get Logout ' ] ) ; } ) ; } 
public function add ( Process Wrapper $ process Wrapper ) : void { $ class Name = $ process Wrapper - > get Class Name ( ) ; if ( isset ( $ this - > processes [ $ class Name ] ) ) { throw new \ Invalid Argument Exception ( sprintf ( 'Testcase with name " %s " was already added , make sure you don \ 't have duplicate class names . ' , $ class Name ) ) ; } $ this - > processes [ $ class Name ] = $ process Wrapper ; $ this - > graph - > create Vertex ( $ class Name ) ; if ( $ this - > publisher ) { $ this - > publisher - > publish Results ( $ class Name , Process Wrapper : : PROCESS _STATUS _QUEUED , null ) ; } } 
public function get ( string $ status ) : array { Assertion : : choice ( $ status , Process Wrapper : : PROCESS _STATUSES ) ; $ return = [ ] ; foreach ( $ this - > processes as $ class Name = > $ process Wrapper ) { if ( $ process Wrapper - > get Status ( ) = = = $ status ) { $ return [ $ class Name ] = $ process Wrapper ; } } return $ return ; } 
public function build Tree ( ) : Out Tree { if ( $ this - > tree = = = null ) { $ root = $ this - > graph - > create Vertex ( 0 ) ; 
public function optimize Order ( Optimize Order Interface $ optimize Strategy ) : void { $ optimized Order = $ optimize Strategy - > optimize ( $ this - > build Tree ( ) ) ; 
public function count Statuses ( ) : array { $ statuses Count = [ ] ; foreach ( Process Wrapper : : PROCESS _STATUSES as $ status ) { $ statuses Count [ $ status ] = count ( $ this - > get ( $ status ) ) ; } return $ statuses Count ; } 
public function count Results ( ) : array { $ done = $ this - > get ( Process Wrapper : : PROCESS _STATUS _DONE ) ; $ done Classes = [ ] ; $ results Count = [ Process Wrapper : : PROCESS _RESULT _PASSED = > 0 , Process Wrapper : : PROCESS _RESULT _FAILED = > 0 , Process Wrapper : : PROCESS _RESULT _FATAL = > 0 , ] ; 
public function fail Dependants ( string $ class Name ) : array { $ descendant Processes = $ this - > get Dependency Tree ( $ class Name ) ; $ failed Processes = [ ] ; foreach ( $ descendant Processes as $ process Class Name = > $ process Wrapper ) { $ failed Processes [ $ process Class Name ] = $ process Wrapper ; $ process Wrapper - > set Status ( Process Wrapper : : PROCESS _STATUS _DONE ) ; } return $ failed Processes ; } 
protected function get Dependency Tree ( string $ class Name ) : array { Assertion : : not Empty ( $ this - > tree , 'Cannot get dependency tree - the tree was not yet build using build Tree ( ) ' ) ; $ descendants = $ this - > tree - > get Vertices Descendant ( $ this - > graph - > get Vertex ( $ class Name ) ) ; $ descendant Processes = [ ] ; foreach ( $ descendants as $ descendant ) { $ descendant Processes [ $ descendant - > get Id ( ) ] = $ this - > processes [ $ descendant - > get Id ( ) ] ; } return $ descendant Processes ; } 
public function output ( string $ output , string $ identifier ) : void { if ( empty ( $ output ) ) { return ; } $ lines = explode ( " \n " , $ output ) ; foreach ( $ lines as $ line ) { 
public function error Output ( string $ output , string $ identifier ) : void { $ output = rtrim ( $ output ) ; if ( empty ( $ output ) ) { return ; } $ lines = explode ( " \n " , $ output ) ; foreach ( $ lines as $ line ) { $ this - > write ( ' <error > ' . $ identifier . ' ERR > ' ) ; $ this - > writeln ( $ line . ' < / > ' ) ; } } 
protected function configure ( ) : void { $ this - > set Name ( 'run ' ) - > set Description ( 'Run tests planner and execute tests ' ) - > add Argument ( self : : ARGUMENT _ENVIRONMENT , Input Argument : : REQUIRED , 'Environment name (must be specified to avoid unintentional run against production ) ' ) - > add Argument ( self : : ARGUMENT _BROWSER , Input Argument : : REQUIRED , 'Browser in which tests should be run ' ) - > add Option ( self : : OPTION _SERVER _URL , null , Input Option : : VALUE _REQUIRED , 'Selenium server (hub ) URL ' , 'http : / /localhost : 4 4 4 4 /wd /hub ' ) - > add Option ( self : : OPTION _CAPABILITY , null , Input Option : : VALUE _IS _ARRAY | Input Option : : VALUE _REQUIRED , 'Extra Desired Capabilities to be passed to Web Driver , use format capability Name :value ' ) - > add Option ( self : : OPTION _TESTS _DIR , null , Input Option : : VALUE _REQUIRED , 'Path to directory with tests ' , STEWARD _BASE _DIR . DIRECTORY _SEPARATOR . 'tests ' ) - > add Option ( self : : OPTION _LOGS _DIR , null , Input Option : : VALUE _REQUIRED , 'Path to directory with logs ' , STEWARD _BASE _DIR . DIRECTORY _SEPARATOR . 'logs ' ) - > add Option ( self : : OPTION _PATTERN , null , Input Option : : VALUE _REQUIRED , 'Pattern for test files to be run ' , ' *Test .php ' ) - > add Option ( self : : OPTION _GROUP , null , Input Option : : VALUE _REQUIRED | Input Option : : VALUE _IS _ARRAY , 'Only run testcases with specified @group of this name ' ) - > add Option ( self : : OPTION _EXCLUDE _GROUP , null , Input Option : : VALUE _REQUIRED | Input Option : : VALUE _IS _ARRAY , 'Exclude testcases with specified @group from being run ' ) - > add Option ( self : : OPTION _FILTER , null , Input Option : : VALUE _REQUIRED , 'Run only testcases /tests with name matching this filter ' ) - > add Option ( self : : OPTION _NO _EXIT , null , Input Option : : VALUE _NONE , 'Always exit with code 0 <comment > (by default any failed test causes the command to return 1 ) < /comment > ' ) - > add Option ( self : : OPTION _IGNORE _DELAYS , 'i ' , Input Option : : VALUE _NONE , 'Ignore delays defined between testcases ' ) - > add Option ( self : : OPTION _PARALLEL _LIMIT , 'l ' , Input Option : : VALUE _REQUIRED , 'Number of maximum testcases being executed in a parallel ' , 5 0 ) ; $ this - > add Usage ( 'staging firefox ' ) ; $ this - > add Usage ( ' - -group =foo - -group =bar - -exclude -group =baz -vvv development phantomjs ' ) ; $ this - > get Dispatcher ( ) - > dispatch ( Command Events : : CONFIGURE , new Basic Console Event ( $ this ) ) ; } 
protected function initialize ( Input Interface $ input , Output Interface $ output ) : void { parent : : initialize ( $ input , $ output ) ; $ output - > writeln ( sprintf ( ' <info >Steward < /info > <comment > %s < /comment > is running the tests . . . %s ' , $ this - > get Application ( ) - > get Version ( ) , ( ! ( new Ci Detector ( ) ) - > is Ci Detected ( ) ? ' Just for you <fg =red > < 3 < /fg =red > ! ' : ' ' ) ) ) ; 
public function on Command Configure ( Basic Console Event $ event ) : void { if ( $ event - > get Command ( ) - > get Name ( ) ! = = 'run ' ) { return ; } $ event - > get Command ( ) - > add Option ( self : : OPTION _NO _CLEAN , null , Input Option : : VALUE _NONE , 'Do not clean content of logs directory on startup ' ) ; } 
public function get Version ( ) : ? string { if ( ! $ this - > version ) { $ this - > version = self : : get Latest Version ( ) ; } return $ this - > version ; } 
public function get File Url ( ) : string { $ version = $ this - > get Version ( ) ; Assert : : that ( $ version , 'Invalid version (expected format is X .Y .Z ) ' ) - > not Empty ( ) - > regex ( ' / ^ \d + \ . \d + \ . [ \da -z \ - ] + $ /i ' ) ; $ version Parts = explode ( ' . ' , $ version ) ; $ dev Version = ' ' ; if ( preg _match ( ' / ( \d + ) - ( [ [ :alnum : ] ] + ) / ' , $ version Parts [ 2 ] , $ matches ) ) { $ dev Version = $ matches [ 2 ] ; } $ file Url = self : : $ storage Url . ' / ' . $ version Parts [ 0 ] . ' . ' . $ version Parts [ 1 ] . ( ! empty ( $ dev Version ) ? ' - ' . $ dev Version : ' ' ) . ' / ' . $ this - > get File Name ( ) ; return $ file Url ; } 
public function download ( ) : int { $ target Path = $ this - > get File Path ( ) ; if ( ! is _dir ( dirname ( $ target Path ) ) ) { mkdir ( dirname ( $ target Path ) , 0 7 7 7 , true ) ; } $ file Url = $ this - > get File Url ( ) ; $ fp = @ fopen ( $ file Url , 'rb ' ) ; $ response Headers = get _headers ( $ file Url ) ; if ( mb _strpos ( $ response Headers [ 0 ] , ' 2 0 0 OK ' ) = = = false ) { throw new \ Runtime Exception ( sprintf ( 'Error downloading file " %s " ( %s ) ' , $ file Url , $ response Headers [ 0 ] ) ) ; } $ downloaded Size = file _put _contents ( $ target Path , $ fp ) ; 
public function get First Selected Option ( ) : Web Driver Element { if ( ! $ this - > is Multiple ( ) ) { return $ this - > find By Css ( $ this - > select 2Selector . ' ' . self : : SIMPLESELECT _SELECTED _OPTION _SELECTOR ) ; } $ selected = $ this - > find Multiple By Css ( $ this - > select 2Selector . ' ' . self : : MULTISELECT _SELECTED _OPTIONS _SELECTOR ) ; if ( count ( $ selected ) = = = 0 ) { throw new No Such Element Exception ( 'No options are selected ' ) ; } return reset ( $ selected ) ; } 
public function select By Visible Partial Text ( $ text ) : void { $ this - > open Dropdown Options ( ) ; $ this - > log ( 'Sending keys to select 2 : %s ' , $ text ) ; $ input Selector = Web Driver By : : css Selector ( $ this - > is Multiple ( ) ? $ this - > select 2Selector . ' input ' : ' #select 2 -drop input ' ) ; 
protected function configure ( ) : void { $ this - > set Name ( 'install ' ) - > set Description ( 'Download latest Selenium standalone server jar file ' ) - > add Argument ( 'version ' , Input Argument : : OPTIONAL , 'Specific Selenium version to install ' ) ; $ this - > get Dispatcher ( ) - > dispatch ( Command Events : : CONFIGURE , new Basic Console Event ( $ this ) ) ; } 
protected function execute ( Input Interface $ input , Output Interface $ output ) : int { $ verbose Output = false ; if ( $ input - > is Interactive ( ) | | $ output - > is Verbose ( ) ) { $ verbose Output = true ; } $ version = $ input - > get Argument ( 'version ' ) ; 
protected function configure ( ) : void { $ this - > set Name ( 'generate -timeline ' ) - > set Description ( 'Generates HTML file with timeline visualisation of test run ' ) - > add Option ( self : : OPTION _RESULTS _FILE , null , Input Option : : VALUE _REQUIRED , 'Path to test results xml file ' , STEWARD _BASE _DIR . DIRECTORY _SEPARATOR . 'logs ' . DIRECTORY _SEPARATOR . Xml Publisher : : FILE _NAME ) - > add Option ( self : : OPTION _OUTPUT _FILE , null , Input Option : : VALUE _REQUIRED , 'Path to output html file ' , STEWARD _BASE _DIR . DIRECTORY _SEPARATOR . 'logs ' . DIRECTORY _SEPARATOR . self : : DEFAULT _OUTPUT _FILENAME ) ; $ this - > get Dispatcher ( ) - > dispatch ( Command Events : : CONFIGURE , new Basic Console Event ( $ this ) ) ; } 
protected function get Legacy Name ( string $ type ) : string { $ name = $ this - > test Class Name ; if ( ! preg _match ( ' /Phase \d / ' , $ name ) ) { throw new Legacy Exception ( "Cannot generate Legacy name from class without 'Phase ' followed by number in name " . $ name ) ; } $ name = preg _replace ( ' /Phase \d / ' , ' ' , $ name ) ; 
public function save With Name ( $ data , string $ legacy Name ) : void { $ filename = $ this - > get Legacy Full Path ( $ legacy Name ) ; $ this - > log ( 'Saving data as Legacy " %s " to file " %s " ' , $ legacy Name , $ filename ) ; $ this - > debug ( 'Legacy data : %s ' , $ this - > get Printable Value ( $ data ) ) ; if ( @ file _put _contents ( $ filename , serialize ( $ data ) ) = = = false ) { throw new Legacy Exception ( 'Cannot save Legacy to file ' . $ filename ) ; } } 
public function save ( $ data , string $ type = self : : LEGACY _TYPE _CASE ) : void { $ this - > save With Name ( $ data , $ this - > get Legacy Name ( $ type ) ) ; } 
public function load ( string $ type = self : : LEGACY _TYPE _CASE ) { return $ this - > load With Name ( $ this - > get Legacy Name ( $ type ) ) ; } 
public function load With Name ( string $ legacy Name ) { $ filename = $ this - > get Legacy Full Path ( $ legacy Name ) ; $ this - > log ( 'Reading Legacy " %s " from file " %s " ' , $ legacy Name , $ filename ) ; $ data = @ file _get _contents ( $ filename ) ; if ( $ data = = = false ) { throw new Legacy Exception ( 'Cannot read Legacy file ' . $ filename ) ; } $ legacy = unserialize ( $ data ) ; if ( $ legacy = = = false ) { throw new Legacy Exception ( 'Cannot parse Legacy from file ' . $ filename ) ; } $ this - > debug ( 'Legacy data : %s ' , $ this - > get Printable Value ( $ legacy ) ) ; return $ legacy ; } 
private function get Printable Value ( $ object ) : string { if ( is _object ( $ object ) & & method _exists ( $ object , ' _ _to String ' ) ) { return ( string ) $ object ; } return print _r ( $ object , true ) ; } 
public function is Accessible ( ) : bool { 
public function is Selenium Server ( ) : bool { 
public function get Cloud Service ( ) : string { 
public function get Session Executor ( string $ session Id ) : string { $ context = stream _context _create ( [ 'http ' = > [ 'ignore _errors ' = > true , 'timeout ' = > 1 ] ] ) ; 
protected function guess Port ( string $ host , string $ scheme ) : int { if ( $ scheme = = = 'https ' ) { return self : : DEFAULT _PORT _CLOUD _SERVICE _HTTPS ; } foreach ( [ 'saucelabs .com ' , 'browserstack .com ' , 'testingbot .com ' ] as $ known Cloud Host ) { if ( mb _strpos ( $ host , $ known Cloud Host ) ! = = false ) { return self : : DEFAULT _PORT _CLOUD _SERVICE ; } } return self : : DEFAULT _PORT ; } 
private function detect Cloud Service By Status ( $ response Data ) : string { if ( isset ( $ response Data - > value , $ response Data - > value - > build , $ response Data - > value - > build - > version ) ) { if ( $ response Data - > value - > build - > version = = = 'Sauce Labs ' ) { return self : : CLOUD _SERVICE _SAUCELABS ; } elseif ( $ response Data - > value - > build - > version = = = 'Testing Bot ' ) { return self : : CLOUD _SERVICE _TESTINGBOT ; } elseif ( ! isset ( $ response Data - > class ) & & ! isset ( $ response Data - > value - > ready ) ) { return self : : CLOUD _SERVICE _BROWSERSTACK ; } } return ' ' ; } 
public function create From Files ( Finder $ files , array $ groups , array $ exclude Groups , string $ filter = null , bool $ ignore Delays = false ) : Process Set { $ files - > sort By Name ( ) ; $ process Set = $ this - > get Process Set ( ) ; if ( $ this - > output - > is Very Verbose ( ) ) { if ( ! empty ( $ groups ) | | ! empty ( $ exclude Groups ) | | ! empty ( $ filter ) ) { $ this - > output - > writeln ( 'Filtering testcases : ' ) ; } if ( ! empty ( $ groups ) ) { $ this - > output - > writeln ( sprintf ( ' - by group (s ) : %s ' , implode ( ' , ' , $ groups ) ) ) ; } if ( ! empty ( $ exclude Groups ) ) { $ this - > output - > writeln ( sprintf ( ' - excluding group (s ) : %s ' , implode ( ' , ' , $ exclude Groups ) ) ) ; } if ( ! empty ( $ filter ) ) { $ this - > output - > writeln ( sprintf ( ' - by testcase /test name : %s ' , $ filter ) ) ; } } $ test Cases Num = 0 ; foreach ( $ files as $ file ) { $ file Name = $ file - > get Real Path ( ) ; $ class Name = $ this - > get Class Name From File ( $ file Name ) ; $ annotations = $ this - > get Class Annotations ( $ class Name , $ file Name ) ; if ( $ excluding Groups = $ this - > get Excluding Groups ( $ exclude Groups , $ annotations ) ) { $ this - > output - > writeln ( sprintf ( 'Excluding testcase file %s with group %s ' , $ file Name , implode ( ' , ' , $ excluding Groups ) ) , Output Interface : : VERBOSITY _DEBUG ) ; continue ; } 
protected function build Process ( string $ file Name , array $ phpunit Args = [ ] ) : Process { $ capabilities = ( new Key Value Capability Options Parser ( ) ) - > parse ( $ this - > input - > get Option ( Run Command : : OPTION _CAPABILITY ) ) ; $ env = [ 'BROWSER _NAME ' = > $ this - > input - > get Argument ( Run Command : : ARGUMENT _BROWSER ) , 'ENV ' = > mb _strtolower ( $ this - > input - > get Argument ( Run Command : : ARGUMENT _ENVIRONMENT ) ) , 'CAPABILITY ' = > json _encode ( $ capabilities ) , 'CAPABILITIES _RESOLVER ' = > $ this - > config [ Config Options : : CAPABILITIES _RESOLVER ] , 'SERVER _URL ' = > $ this - > input - > get Option ( Run Command : : OPTION _SERVER _URL ) , 'LOGS _DIR ' = > $ this - > config [ Config Options : : LOGS _DIR ] , 'DEBUG ' = > $ this - > output - > is Debug ( ) ? ' 1 ' : ' 0 ' , ] ; $ dispatcher = $ this - > command - > get Dispatcher ( ) ; $ dispatcher - > dispatch ( Command Events : : RUN _TESTS _PROCESS , $ process Event = new Run Tests Process Event ( $ this - > command , $ this - > input , $ this - > output , $ env , $ phpunit Args ) ) ; $ phpunit Executable = realpath ( _ _DIR _ _ . ' / . . / . . /bin /phpunit -steward ' ) ; $ command Line = array _merge ( [ PHP _BINARY , $ phpunit Executable ] , $ process Event - > get Args ( ) , [ $ file Name ] ) ; return new Process ( $ command Line , STEWARD _BASE _DIR , $ process Event - > get Environment Vars ( ) , null , 3 6 0 0 ) ; } 
private function get Excluding Groups ( array $ exclude Groups , array $ annotations ) : array { $ excluding Groups = [ ] ; if ( ! empty ( $ exclude Groups ) & & array _key _exists ( 'group ' , $ annotations ) ) { if ( ! empty ( array _intersect ( $ exclude Groups , $ annotations [ 'group ' ] ) ) ) { $ excluding Groups = array _intersect ( $ exclude Groups , $ annotations [ 'group ' ] ) ; } } return $ excluding Groups ; } 
private function get Class Annotations ( string $ class Name , string $ file Name ) : array { try { return Annotations Parser : : get All ( new \ Reflection Class ( $ class Name ) ) ; } catch ( \ Reflection Exception $ e ) { throw new \ Runtime Exception ( sprintf ( 'Error loading class " %s " from file " %s " . Make sure the class name and namespace matches ' . 'the file path . ' , $ class Name , $ file Name ) ) ; } } 
protected function take Snapshot ( Abstract Test Case $ test ) : void { if ( ! $ test - > wd instanceof Remote Web Driver ) { $ test - > append Test Log ( ' [WARN ] Web Driver instance not found , cannot take snapshot . ' ) ; return ; } $ save Path = Config Provider : : get Instance ( ) - > logs Dir . DIRECTORY _SEPARATOR ; $ test Identifier = $ this - > assemble Test Identifier ( $ test ) ; ob _start ( ) ; $ output Buffer Closed = false ; try { $ current Url = $ test - > wd - > get Current URL ( ) ; 
protected function get Snapshot Url ( string $ path ) : string { if ( getenv ( 'JENKINS _URL ' ) & & getenv ( 'BUILD _URL ' ) & & getenv ( 'WORKSPACE ' ) ) { $ real Path = realpath ( $ path ) ; if ( $ real Path ) { 
public function on Command Configure ( Basic Console Event $ event ) : void { if ( $ event - > get Command ( ) - > get Name ( ) ! = = 'run ' ) { return ; } $ event - > get Command ( ) - > add Option ( self : : OPTION _XDEBUG , null , Input Option : : VALUE _OPTIONAL , 'Start Xdebug debugger on tests . Pass custom IDE key if needed for your IDE settings . ' , ' ' ) ; } 
protected function get Ide Key From Input Option ( Input Interface $ input ) : ? string { $ option Value = $ input - > get Option ( self : : OPTION _XDEBUG ) ; if ( $ option Value = = = null ) { 
public function instantiate ( Event Dispatcher $ dispatcher , string $ dir To Search For Listeners ) : void { $ listeners = $ this - > search Listeners ( $ dir To Search For Listeners ) ; foreach ( $ listeners as $ listener ) { $ r = new \ Reflection Class ( $ listener ) ; if ( $ r - > implements Interface ( 'Symfony \ \Component \ \Event Dispatcher \ \Event Subscriber Interface ' ) & & ! $ r - > is Abstract ( ) ) { $ listener Instance = $ r - > new Instance Without Constructor ( ) ; $ dispatcher - > add Subscriber ( $ listener Instance ) ; } } } 
protected function configure ( ) : void { $ this - > set Name ( 'clean ' ) - > set Description ( 'Clean logs directory ' ) - > add Option ( Run Command : : OPTION _LOGS _DIR , null , Input Option : : VALUE _REQUIRED , 'Path to directory with logs ' , STEWARD _BASE _DIR . DIRECTORY _SEPARATOR . 'logs ' ) ; $ this - > get Dispatcher ( ) - > dispatch ( Command Events : : CONFIGURE , new Basic Console Event ( $ this ) ) ; } 
public function get File Path ( ) : string { if ( ! $ this - > file Dir ) { $ this - > file Dir = Config Provider : : get Instance ( ) - > logs Dir ; } return $ this - > file Dir . ' / ' . $ this - > file Name ; } 
protected function quote Xpath Attribute ( string $ input ) : string { if ( mb _strpos ( $ input , ' \ ' ' ) = = = false ) { / / Selector does not contain single quotes return " ' $input ' " ; / / Encapsulate with double quotes } if ( mb _strpos ( $ input , ' " ' ) = = = false ) { / / Selector contain single quotes but not double quotes return " \ " $input \ " " ; / / Encapsulate with single quotes } / / When both single and double quotes are contained , escape each part individually and concat ( ) all parts return "concat ( ' " . strtr ( $ input , [ ' \ ' ' = > ' \ ' , " \ ' " , \ ' ' ] ) . " ' ) " ; } 
public function optimize ( Out Tree $ tree ) : array { 
private function cast To Guessed Data Type ( string $ value ) { $ string Value Without Quotes = $ this - > remove Encapsulating Quotes ( $ value ) ; if ( $ string Value Without Quotes ! = = null ) { return $ string Value Without Quotes ; } $ int Value = filter _var ( $ value , FILTER _VALIDATE _INT , [ ] ) ; if ( $ int Value ! = = false ) { return $ int Value ; } $ float Value = filter _var ( $ value , FILTER _VALIDATE _FLOAT , [ ] ) ; if ( $ float Value ! = = false ) { return $ float Value ; } $ bool Value = filter _var ( $ value , FILTER _VALIDATE _BOOLEAN , [ 'flags ' = > FILTER _NULL _ON _FAILURE ] ) ; if ( $ bool Value ! = = null ) { return $ bool Value ; } return $ value ; } 
public function check Process Timeout ( ) : ? string { try { $ this - > get Process ( ) - > check Timeout ( ) ; } catch ( Process Timed Out Exception $ e ) { $ this - > set Status ( self : : PROCESS _STATUS _DONE ) ; return sprintf ( 'Process for class " %s " exceeded the timeout of %d seconds and was killed . ' , $ this - > get Class Name ( ) , $ e - > get Exceeded Timeout ( ) ) ; } return ' ' ; } 
private function resolve Result ( ) : string { $ exit Code = $ this - > get Process ( ) - > get Exit Code ( ) ; 
private function get Executors ( ) : array { $ test Elements = $ this - > xml - > xpath ( ' / /testcase /test [ @status = "done " ] ' ) ; $ has Test Without Executor = false ; $ executors = [ ] ; foreach ( $ test Elements as $ test Element ) { $ executor Value = ( string ) $ test Element [ 'executor ' ] ; if ( ! empty ( $ executor Value ) ) { $ executors [ ] = $ executor Value ; } else { $ has Test Without Executor = true ; } } $ executors = array _unique ( $ executors ) ; 
protected function setup Ci Capabilities ( Desired Capabilities $ capabilities , Abstract Test Case $ test ) : Desired Capabilities { $ ci = $ this - > ci Detector - > detect ( ) ; $ capabilities - > set Capability ( 'build ' , $ this - > config - > env . ' - ' . $ ci - > get Build Number ( ) ) ; $ capabilities - > set Capability ( 'tags ' , [ $ this - > config - > env , $ ci - > get Ci Name ( ) , get _class ( $ test ) ] ) ; return $ capabilities ; } 
public function set Custom Configuration Options ( array $ custom Configuration Options ) : void { if ( $ this - > config ! = = null ) { throw new \ Runtime Exception ( 'Custom configuration options can be set only before initialization of configuration ' ) ; } $ this - > custom Configuration Options = $ custom Configuration Options ; } 
private function retrieve Configuration Values ( array $ options ) : array { $ output Values = [ ] ; foreach ( $ options as $ option ) { $ value = getenv ( $ option ) ; 
protected function dequeue Processes Without Delay ( ) : void { $ queued Processes = $ this - > process Set - > get ( Process Wrapper : : PROCESS _STATUS _QUEUED ) ; foreach ( $ queued Processes as $ class Name = > $ process Wrapper ) { if ( $ process Wrapper - > is Delayed ( ) ) { $ this - > io - > writeln ( sprintf ( 'Testcase " %s " is queued to be run % 0 1 . 1f minutes after testcase " %s " is finished ' , $ class Name , $ process Wrapper - > get Delay Minutes ( ) , $ process Wrapper - > get Delay After ( ) ) , Output Interface : : VERBOSITY _DEBUG ) ; } elseif ( $ this - > parallel Limit Reached ( ) ) { $ this - > io - > writeln ( sprintf ( 'Max parallel limit reached , testcase " %s " is queued ' , $ class Name ) , Output Interface : : VERBOSITY _QUIET ) ; } else { $ this - > io - > writeln ( sprintf ( 'Testcase " %s " is prepared to be run ' , $ class Name ) , Output Interface : : VERBOSITY _DEBUG ) ; $ process Wrapper - > set Status ( Process Wrapper : : PROCESS _STATUS _PREPARED ) ; } } } 
protected function flush Process Output ( Process Wrapper $ process Wrapper ) : void { $ this - > io - > output ( $ process Wrapper - > get Process ( ) - > get Incremental Output ( ) , $ process Wrapper - > get Class Name ( ) ) ; $ this - > io - > error Output ( $ process Wrapper - > get Process ( ) - > get Incremental Error Output ( ) , $ process Wrapper - > get Class Name ( ) ) ; } 
protected function create Web Driver ( Abstract Test Case $ test , string $ remote Server Url , Desired Capabilities $ desired Capabilities , Desired Capabilities $ required Capabilities , int $ connect Timeout Ms , int $ request Timeout Ms ) : void { $ browser Name = Config Provider : : get Instance ( ) - > browser Name ; for ( $ start Attempts = 0 ; $ start Attempts < 4 ; $ start Attempts + + ) { try { $ test - > wd = Remote Web Driver : : create ( $ remote Server Url , $ desired Capabilities , $ connect Timeout Ms , $ request Timeout Ms , null , null , $ required Capabilities ) ; return ; } catch ( Unknown Server Exception $ e ) { if ( $ this - > cannot Bind To Firefox Locking Port ( $ browser Name , $ e - > get Message ( ) ) ) { 
public function favorite ( $ class ) { return $ this - > favorites ( ) - > where ( 'favoriteable _type ' , $ class ) - > with ( 'favoriteable ' ) - > get ( ) - > map With Keys ( function ( $ item ) { return [ $ item [ 'favoriteable ' ] - > id = > $ item [ 'favoriteable ' ] ] ; } ) ; } 
private function count Summary ( $ dst File ) { $ tests = ( new \ DOMXPath ( $ dst File ) ) - > query ( " / /table /tr [contains ( @class , 'scenario Row ' ) ] " ) ; foreach ( $ tests as $ test ) { $ class = str _replace ( 'scenario Row ' , ' ' , $ test - > get Attribute ( 'class ' ) ) ; switch ( $ class ) { case 'scenario Success ' : $ this - > count Success + = 0 . 5 ; break ; case 'scenario Failed ' : $ this - > count Failed + = 0 . 5 ; break ; case 'scenario Skipped ' : $ this - > count Skipped + = 0 . 5 ; break ; case 'scenario Incomplete ' : $ this - > count Incomplete + = 0 . 5 ; break ; } } } 
private function update Summary Table ( $ dst File ) { $ dst File = new \ DOMXPath ( $ dst File ) ; $ path For = function ( $ type ) { return " / /div [ @id = 'step Container Summary ' ] / /td [ @class = ' $type ' ] " ; } ; $ dst File - > query ( $ path For ( 'scenario Success Value ' ) ) - > item ( 0 ) - > node Value = $ this - > count Success ; $ dst File - > query ( $ path For ( 'scenario Failed Value ' ) ) - > item ( 0 ) - > node Value = $ this - > count Failed ; $ dst File - > query ( $ path For ( 'scenario Skipped Value ' ) ) - > item ( 0 ) - > node Value = $ this - > count Skipped ; $ dst File - > query ( $ path For ( 'scenario Incomplete Value ' ) ) - > item ( 0 ) - > node Value = $ this - > count Incomplete ; } 
private function move Summary Table ( $ dst File , $ node ) { $ summary Table = ( new \ DOMXPath ( $ dst File ) ) - > query ( " / /div [ @id = 'step Container Summary ' ] " ) - > item ( 0 ) - > parent Node - > parent Node ; $ node - > append Child ( $ dst File - > import Node ( $ summary Table , true ) ) ; } 
private function update Toolbar Table ( $ dst File ) { $ dst File = new \ DOMXPath ( $ dst File ) ; $ path For = function ( $ type ) { return " / /ul [ @id = 'toolbar -filter ' ] / /a [ @title = ' $type ' ] " ; } ; $ dst File - > query ( $ path For ( 'Successful ' ) ) - > item ( 0 ) - > node Value = ' ✔ ' . $ t h is - > co unt Success ; $ dst File - > query ( $ path For ( 'Failed ' ) ) - > item ( 0 ) - > node Value = ' ✗ ' . $ t h is - > co unt Failed ; $ dst File - > query ( $ path For ( 'Skipped ' ) ) - > item ( 0 ) - > node Value = 'S ' . $ this - > count Skipped ; $ dst File - > query ( $ path For ( 'Incomplete ' ) ) - > item ( 0 ) - > node Value = 'I ' . $ this - > count Incomplete ; } 
private function update Buttons ( $ dst File ) { $ nodes = ( new \ DOMXPath ( $ dst File ) ) - > query ( " / /div [ @class = 'layout ' ] /table /tr [contains ( @class , 'scenario Row ' ) ] " ) ; for ( $ i = 2 ; $ i < $ nodes - > length ; $ i + = 2 ) { $ n = $ i / 2 + 1 ; $ p = $ nodes - > item ( $ i ) - > child Nodes - > item ( 1 ) - > child Nodes - > item ( 1 ) ; $ table = $ nodes - > item ( $ i + 1 ) - > child Nodes - > item ( 1 ) - > child Nodes - > item ( 1 ) ; $ p - > set Attribute ( 'onclick ' , "show Hide ( ' $n ' , this ) " ) ; $ table - > set Attribute ( 'id ' , "step Container " . $ n ) ; } } 
public function add Favorite ( $ user _id = null ) { $ favorite = new Favorite ( [ 'user _id ' = > ( $ user _id ) ? $ user _id : Auth : : id ( ) ] ) ; $ this - > favorites ( ) - > save ( $ favorite ) ; } 
public function remove Favorite ( $ user _id = null ) { $ this - > favorites ( ) - > where ( 'user _id ' , ( $ user _id ) ? $ user _id : Auth : : id ( ) ) - > delete ( ) ; } 
public function toggle Favorite ( $ user _id = null ) { $ this - > is Favorited ( $ user _id ) ? $ this - > remove Favorite ( $ user _id ) : $ this - > add Favorite ( $ user _id ) ; } 
public function is Favorited ( $ user _id = null ) { return $ this - > favorites ( ) - > where ( 'user _id ' , ( $ user _id ) ? $ user _id : Auth : : id ( ) ) - > exists ( ) ; } 
public function favorited By ( ) { return $ this - > favorites ( ) - > with ( 'user ' ) - > get ( ) - > map With Keys ( function ( $ item ) { return [ $ item [ 'user ' ] - > id = > $ item [ 'user ' ] ] ; } ) ; } 
public function load ( array $ configs , Container Builder $ container ) { $ configuration = new Configuration ( ) ; $ config = $ this - > process Configuration ( $ configuration , $ configs ) ; $ loader = new Xml File Loader ( $ container , new File Locator ( _ _DIR _ _ . ' / . . /Resources /config ' ) ) ; $ loader - > load ( 'services .xml ' ) ; $ container - > set Parameter ( 'overblog _graphiql .endpoint _resolver ' , $ config [ 'endpoint _resolver ' ] ) ; $ graphi QLView Config JSLibraries = $ container - > get Definition ( 'overblog _graphiql .view .config .javascript _libraries ' ) ; $ graphi QLView Config JSLibraries - > set Arguments ( [ $ config [ 'javascript _libraries ' ] [ 'graphiql ' ] , $ config [ 'javascript _libraries ' ] [ 'react ' ] , $ config [ 'javascript _libraries ' ] [ 'fetch ' ] , ] ) ; $ graphi QLView Config = $ container - > get Definition ( 'overblog _graphiql .view .config ' ) ; $ graphi QLView Config - > set Arguments ( [ new Reference ( 'overblog _graphiql .view .config .javascript _libraries ' ) , $ config [ 'template ' ] , ] ) ; } 
public function initialize ( $ input ) { 
public function get Permissions ( ) { $ permissions = [ $ this - > manage _permission ] ; if ( $ this - > create ) { $ permissions [ ] = $ this - > create _permission ; $ permissions [ ] = $ this - > store _permission ; } if ( $ this - > edit ) { $ permissions [ ] = $ this - > edit _permission ; $ permissions [ ] = $ this - > update _permission ; } if ( $ this - > delete ) { $ permissions [ ] = $ this - > delete _permission ; } return $ permissions ; } 
public function insert To Language Files ( ) { 
public function create View Files ( ) { 
public function create Migration ( ) { $ table = $ this - > table ; if ( Schema : : has Table ( $ table ) ) { return 'Table Already Exists ! ' ; } else { 
public function create Events ( ) { if ( ! empty ( $ this - > events ) ) { $ base _path = $ this - > event _namespace ; foreach ( $ this - > events as $ event ) { $ path = escape Slashes ( $ base _path . DIRECTORY _SEPARATOR . $ event ) ; $ model = str _replace ( DIRECTORY _SEPARATOR , ' \ \ ' , $ path ) ; Artisan : : call ( 'make :event ' , [ 'name ' = > $ model , ] ) ; Artisan : : call ( 'make :listener ' , [ 'name ' = > $ model . 'Listener ' , ' - -event ' = > $ model , ] ) ; } } } 
public function generate File ( $ stub _name , $ replacements , $ file , $ contents = null ) { if ( $ stub _name ) { 
public function get Stub Path ( ) { $ path = resource _path ( 'views ' . DIRECTORY _SEPARATOR . 'vendor ' . DIRECTORY _SEPARATOR . 'generator ' . DIRECTORY _SEPARATOR . 'Stubs ' . DIRECTORY _SEPARATOR ) ; $ package _stubs _path = base _path ( 'vendor ' . DIRECTORY _SEPARATOR . 'bvipul ' . DIRECTORY _SEPARATOR . 'generator ' . DIRECTORY _SEPARATOR . 'src ' . DIRECTORY _SEPARATOR . 'views ' . DIRECTORY _SEPARATOR . 'Stubs ' . DIRECTORY _SEPARATOR ) ; if ( $ this - > files - > exists ( $ path ) ) return $ path ; else return $ package _stubs _path ; } 
public function get Base Path ( $ namespace , $ status = false ) { if ( $ status ) { return base _path ( escape Slashes ( $ this - > remove File Name From End Of Namespace ( $ namespace , $ status ) ) ) ; } return base _path ( lcfirst ( escape Slashes ( $ namespace ) ) ) ; } 
public function delete _all _between ( $ beginning , $ end , $ string ) { $ beginning Pos = strpos ( $ string , $ beginning ) ; $ end Pos = strpos ( $ string , $ end ) ; if ( $ beginning Pos = = = false | | $ end Pos = = = false ) { return $ string ; } $ text To Delete = substr ( $ string , $ beginning Pos , ( $ end Pos + strlen ( $ end ) ) - $ beginning Pos ) ; return str _replace ( $ text To Delete , ' ' , $ string ) ; } 
public function create ( array $ input , array $ permissions ) { $ module = Module : : where ( 'name ' , $ input [ 'name ' ] ) - > first ( ) ; if ( ! $ module ) { $ name = $ input [ 'model _name ' ] ; $ model = strtolower ( $ name ) ; foreach ( $ permissions as $ permission ) { $ perm = [ 'name ' = > $ permission , 'display _name ' = > title _case ( str _replace ( ' - ' , ' ' , $ permission ) ) . ' Permission ' , ] ; 
public function boot ( ) { $ this - > load Views From ( _ _DIR _ _ . ' / . . /views ' , 'generator ' ) ; $ this - > load Migrations From ( _ _DIR _ _ . ' / . . /migrations ' ) ; $ this - > load Translations From ( _ _DIR _ _ . ' / . . /lang ' , 'generator ' ) ; $ this - > merge Config From ( _ _DIR _ _ . ' / . . /config /generator .php ' , 'generator ' ) ; $ this - > publishes ( [ _ _DIR _ _ . ' / . . /config /generator .php ' = > config _path ( 'generator .php ' ) , ] , 'generator ' ) ; $ this - > publishes ( [ _ _DIR _ _ . ' / . . /views ' = > base _path ( 'resources /views /vendor /generator ' ) , ] , 'generator _views ' ) ; 
public function register ( ) { include _ _DIR _ _ . ' / . . /routes .php ' ; require _once ( _ _DIR _ _ . ' / . . /helpers .php ' ) ; $ this - > app - > make ( 'Bvipul \Generator \Module ' ) ; $ this - > app - > make ( 'Bvipul \Generator \Controllers \Generator ' ) ; $ this - > app - > make ( 'Bvipul \Generator \Controllers \Module Controller ' ) ; $ this - > app - > make ( 'Bvipul \Generator \Repositories \Module Repository ' ) ; $ this - > app - > make ( 'Bvipul \Generator \Controllers \Module Table Controller ' ) ; } 
public function create ( Request $ request ) { return view ( 'generator : :create ' ) - > with ( 'model _namespace ' , $ this - > generator - > get Model Namespace ( ) ) - > with ( 'request _namespace ' , $ this - > generator - > get Request Namespace ( ) ) - > with ( 'controller _namespace ' , $ this - > generator - > get Controller Namespace ( ) ) - > with ( 'event _namespace ' , $ this - > event _namespace ) - > with ( 'repo _namespace ' , $ this - > generator - > get Repo Namespace ( ) ) - > with ( 'route _path ' , $ this - > generator - > get Route Path ( ) ) - > with ( 'view _path ' , $ this - > generator - > get View Path ( ) ) ; } 
public function store ( Request $ request ) { $ this - > generator - > initialize ( $ request - > all ( ) ) ; $ this - > generator - > create Migration ( ) ; $ this - > generator - > create Model ( ) ; $ this - > generator - > create Requests ( ) ; $ this - > generator - > create Responses ( ) ; $ this - > generator - > create Repository ( ) ; $ this - > generator - > create Controller ( ) ; $ this - > generator - > create Table Controller ( ) ; $ this - > generator - > create Route Files ( ) ; $ this - > generator - > insert To Language Files ( ) ; $ this - > generator - > create View Files ( ) ; $ this - > generator - > create Events ( ) ; 
public function check Namespace ( Request $ request ) { if ( isset ( $ request - > path ) ) { $ path = $ this - > parse Model ( $ request - > path ) ; $ path = base _path ( trim ( str _replace ( ' \ \ ' , ' / ' , $ request - > path ) ) , ' \ \ ' ) ; $ path = str _replace ( 'App ' , 'app ' , $ path ) ; if ( file _exists ( $ path . ' .php ' ) ) { return response ( ) - > json ( ( object ) [ 'type ' = > 'error ' , 'message ' = > 'File exists Already ' , ] ) ; } else { return response ( ) - > json ( ( object ) [ 'type ' = > 'success ' , 'message ' = > 'File can be generated at this location ' , ] ) ; } } else { return response ( ) - > json ( ( object ) [ 'type ' = > 'error ' , 'message ' = > 'Please provide some value ' , ] ) ; } } 
public function check Table ( Request $ request ) { if ( $ request - > table ) { if ( Schema : : has Table ( $ request - > table ) ) { return response ( ) - > json ( ( object ) [ 'type ' = > 'error ' , 'message ' = > 'Table exists Already ' , ] ) ; } else { return response ( ) - > json ( ( object ) [ 'type ' = > 'success ' , 'message ' = > 'Table Name Available ' , ] ) ; } } else { return response ( ) - > json ( ( object ) [ 'type ' = > 'error ' , 'message ' = > 'Please provide some value ' , ] ) ; } } 
public function parse Model ( $ model ) { if ( preg _match ( ' ( [ ^A -Za -z 0 - 9 _ / \ \ \ \ ] ) ' , $ model ) ) { throw new Invalid Argument Exception ( 'Name contains invalid characters . ' ) ; } $ model = trim ( str _replace ( ' / ' , ' \ \ ' , $ model ) , ' \ \ ' ) ; return $ model ; } 
public function on One Random Server ( ) { $ keys = array _keys ( $ this - > get Server Config ( ) ) ; do { $ rand Server Rank = array _rand ( $ keys ) ; if ( $ redis = $ this - > get Redis From Server Config ( $ keys [ $ rand Server Rank ] ) ) { $ this - > selected Redis = array ( $ keys [ $ rand Server Rank ] = > $ redis ) ; } else { unset ( $ keys [ $ rand Server Rank ] ) ; } } while ( ! empty ( $ keys ) & & empty ( $ this - > selected Redis ) ) ; if ( empty ( $ this - > selected Redis ) ) { throw new Exception ( "Can 't connect to a random redis server " ) ; } $ this - > multi Redis = false ; return $ this ; } 
public function on All Server ( $ strict = true ) { foreach ( $ this - > get Server Config ( ) as $ id Server = > $ config ) { if ( $ redis = $ this - > get Redis From Server Config ( $ id Server ) ) { $ this - > selected Redis [ $ id Server ] = $ redis ; } else { if ( $ strict ) { throw new Exception ( 'cant connect to redis ' . $ id Server ) ; } } } $ this - > multi Redis = true ; return $ this ; } 
public function on One Server ( $ id Server , $ strict = true ) { $ redis List = $ this - > get Server Config ( ) ; 
public function on One Key Server ( $ key ) { $ this - > selected Redis [ ] = $ this - > get Redis ( $ key ) ; $ this - > multi Redis = false ; return $ this ; } 
protected function call Redis Command ( Predis Proxy $ redis , $ name , $ arguments ) { $ start = microtime ( true ) ; try { $ return = call _user _func _array ( array ( $ redis , $ name ) , $ arguments ) ; $ this - > notify Event ( $ name , $ arguments , microtime ( true ) - $ start ) ; } catch ( Predis \ Predis Exception $ e ) { throw new Exception ( "Error calling the method " . $ name . " : " . $ e - > get Message ( ) ) ; } return $ return ; } 
public function set Current Db ( $ v ) { if ( ! is _int ( $ v ) ) { throw new Exception ( "please describe the db as an integer ^ ^ " ) ; } if ( $ v = = Cache : : CACHE ) { throw new Exception ( "cant use " . Cache : : CACHE . " in class " . _ _CLASS _ _ ) ; } $ this - > current Db = $ v ; return $ this ; } 
public function set Event Dispatcher ( $ event Dispatcher , $ event Class ) { if ( ! is _object ( $ event Dispatcher ) | | ! method _exists ( $ event Dispatcher , 'dispatch ' ) ) { throw new Exception ( "The Event Dispatcher must be an object and implement a dispatch method " ) ; } if ( ! class _exists ( $ event Class ) | | ! method _exists ( $ event Class , 'set Command ' ) | | ! method _exists ( $ event Class , 'set Arguments ' ) | | ! method _exists ( $ event Class , 'set Execution Time ' ) ) { $ msg = "The Event class : " . $ event Class . " must implement the set Command , " ; $ msg . = "set Execution Time and the set Arguments method " ; throw new Exception ( $ msg ) ; } $ this - > event Dispatcher = $ event Dispatcher ; $ this - > event Class = $ event Class ; return $ this ; } 
protected function init ( $ params ) { 
protected function check Server Config ( $ servers ) { if ( ! is _array ( $ servers ) ) { return false ; } foreach ( $ servers as $ server Id = > $ server ) { if ( ! is _string ( $ server Id ) ) { return false ; } if ( ! isset ( $ server [ 'ip ' ] ) or ! isset ( $ server [ 'port ' ] ) ) { return false ; } } return true ; } 
public function get Server Config ( $ servername = null ) { if ( is _null ( $ servername ) ) { return $ this - > server Config ; } else { return $ this - > server Config [ $ servername ] ; } } 
protected function set Server Config ( $ servers , $ check = true ) { if ( $ check and ( ! self : : check Server Config ( $ servers ) ) ) { throw new Exception ( "Le parametre server Config est mal form é " ) ; } 
protected function get Server Id ( $ key , $ servers = null ) { if ( is _null ( $ servers ) ) { $ servers = $ this - > get Server Config ( ) ; } $ server Keys = array _keys ( $ servers ) ; return $ server Keys [ ( int ) ( crc 3 2 ( $ key ) % count ( $ server Keys ) ) ] ; } 
protected function get Redis ( $ key , $ servers = null ) { if ( is _null ( $ servers ) ) { $ servers = $ this - > get Server Config ( ) ; 
public function get Redis From Server Config ( $ id Server ) { 
protected function connect Server ( Predis Proxy $ redis , $ server ) { try { $ redis - > call Redis Constructor ( array ( 'host ' = > $ server [ 'ip ' ] , 'port ' = > ( int ) $ server [ 'port ' ] , 'timeout ' = > $ this - > get Timeout ( ) , 'read _write _timeout ' = > $ this - > get Read Write Timeout ( ) ) ) ; 
public function get ( $ key ) { $ redis = $ this - > get Redis ( $ key ) ; $ start = microtime ( true ) ; $ ret = $ redis - > get ( $ this - > get Pattern Key ( ) . $ key ) ; 
public function del ( $ keys ) { if ( ! is _array ( $ keys ) ) { $ keys = array ( $ keys ) ; } $ funcs = array ( ) ; 
public function set ( $ key , $ value , $ ttl = null ) { if ( $ this - > get Compress ( ) ) { $ value = self : : compress ( $ value ) ; } $ key P = $ this - > get Pattern Key ( ) . $ key ; if ( is _null ( $ ttl ) ) { $ func = function ( $ redis ) use ( $ key P , $ value ) { $ start = microtime ( true ) ; $ redis - > set ( $ key P , $ value ) ; $ this - > notify Event ( 'set ' , array ( $ key P , $ value ) , microtime ( true ) - $ start ) ; return $ redis ; } ; } else { $ func = function ( $ redis ) use ( $ key P , $ value , $ ttl ) { $ start = microtime ( true ) ; $ redis - > setex ( $ key P , $ ttl , $ value ) ; $ this - > notify Event ( 'setex ' , array ( $ key P , $ ttl , $ value ) , microtime ( true ) - $ start ) ; return $ redis ; } ; } if ( true = = = $ this - > multi ) { $ this - > add To Exec List ( $ key , $ func ) ; } else { $ func ( $ this - > get Redis ( $ key ) ) ; 
public function exists ( $ key ) { $ start = microtime ( true ) ; $ ret = $ this - > get Redis ( $ key ) - > exists ( $ this - > get Pattern Key ( ) . $ key ) ; $ this - > notify Event ( 'exists ' , array ( $ this - > get Pattern Key ( ) . $ key ) , microtime ( true ) - $ start ) ; return ( boolean ) $ ret ; } 
public function type ( $ key ) { $ start = microtime ( true ) ; $ ret = ( string ) $ this - > get Redis ( $ key ) - > type ( $ this - > get Pattern Key ( ) . $ key ) ; $ this - > notify Event ( 'type ' , array ( $ this - > get Pattern Key ( ) . $ key ) , microtime ( true ) - $ start ) ; return $ ret ; } 
public function ttl ( $ key ) { $ start = microtime ( true ) ; $ ret = $ this - > get Redis ( $ key ) - > ttl ( $ this - > get Pattern Key ( ) . $ key ) ; $ this - > notify Event ( 'ttl ' , array ( $ this - > get Pattern Key ( ) . $ key ) , microtime ( true ) - $ start ) ; return $ ret ; } 
public function incr ( $ key , $ incr = 1 ) { $ key P = $ this - > get Pattern Key ( ) . $ key ; $ func = function ( $ redis ) use ( $ key P , $ incr ) { try { $ start = microtime ( true ) ; $ ret = $ redis - > incrby ( $ key P , $ incr ) ; $ this - > notify Event ( 'incrby ' , array ( $ key P , $ incr ) , microtime ( true ) - $ start ) ; return $ ret ; } catch ( Predis \ Server Exception $ e ) { return null ; } } ; if ( true = = = $ this - > multi ) { $ this - > add To Exec List ( $ key , $ func ) ; return $ this ; } else { if ( is _null ( $ ret = $ func ( $ this - > get Redis ( $ key ) ) ) ) { throw new Exception ( "Cant increment key " . $ key . " , not an integer ? " ) ; } return $ ret ; } } 
public function expire ( $ key , $ ttl ) { if ( $ ttl < = 0 ) { throw new Exception ( 'ttl arg cant be negative ' ) ; } $ key P = $ this - > get Pattern Key ( ) . $ key ; $ func = function ( $ redis ) use ( $ key P , $ ttl ) { try { $ start = microtime ( true ) ; $ ret = $ redis - > expire ( $ key P , $ ttl ) ; $ this - > notify Event ( 'expire ' , array ( $ key P , $ ttl ) , microtime ( true ) - $ start ) ; return $ ret ; } catch ( Predis \ Server Exception $ e ) { return null ; } } ; 
public function flush ( ) { $ pattern = $ this - > get Pattern Key ( ) ; $ arr Return = $ this - > run On All Redis Server ( function ( $ redis ) use ( $ pattern ) { $ was Deleted = 0 ; $ all Keys = $ redis - > keys ( $ pattern . ' * ' ) ; 
public function watch ( $ key ) { $ redis = $ this - > get Redis ( $ key ) ; $ this - > notify Event ( 'watch ' , array ( $ this - > get Pattern Key ( ) . $ key ) ) ; $ redis - > watch ( $ this - > get Pattern Key ( ) . $ key ) ; } 
public function exec ( ) { if ( true = = = $ this - > multi ) { $ ret = array ( ) ; $ this - > multi = false ; 
public function keys ( $ pattern ) { $ pattern = $ this - > get Pattern Key ( ) . $ pattern ; return $ this - > run On All Redis Server ( function ( $ redis ) use ( $ pattern ) { $ this - > notify Event ( 'keys ' , array ( $ pattern ) ) ; return $ redis - > keys ( $ pattern ) ; } ) ; } 
protected function run On All Redis Server ( \ Closure $ func ) { $ ret = array ( ) ; 
public function db Size ( $ id Server = null ) { if ( is _null ( $ id Server ) ) { $ servers = $ this - > get Server Config ( ) ; $ dbsize = array ( ) ; foreach ( array _keys ( $ servers ) as $ id Server ) { $ redis = $ this - > get Redis From Server Config ( $ id Server ) ; $ dbsize [ $ id Server ] = $ redis - > dbsize ( ) ; } } else { $ redis = $ this - > get Redis From Server Config ( $ id Server ) ; $ dbsize = $ redis - > dbsize ( ) ; } return $ dbsize ; } 
public function info ( $ id Server = null ) { if ( is _null ( $ id Server ) ) { $ servers = $ this - > get Server Config ( ) ; $ info = array ( ) ; foreach ( array _keys ( $ servers ) as $ id Server ) { $ redis = $ this - > get Redis From Server Config ( $ id Server ) ; $ info [ $ id Server ] = $ redis - > info ( ) ; } } else { $ redis = $ this - > get Redis From Server Config ( $ id Server ) ; $ info = $ redis - > info ( ) ; } return $ info ; } 
protected function add To Exec List ( $ key , \ Closure $ func ) { $ redis = $ this - > get Redis ( $ key ) ; $ this - > exec List [ md 5 ( serialize ( $ redis ) ) ] [ ] = array ( 'key ' = > $ key , 'function ' = > $ func , 'redis ' = > $ redis ) ; } 
public function get Redis Object ( $ server Rank = 0 ) { $ server Config = $ this - > get Server Config ( ) ; $ keys = array _keys ( $ server Config ) ; if ( isset ( $ keys [ $ server Rank ] ) ) { return $ this - > get Redis From Server Config ( $ keys [ $ server Rank ] ) ; } else { throw new Exception ( "No server found at rank " . $ server Rank ) ; } } 
public function load ( array $ configs , Container Builder $ container ) { $ configuration = new Configuration ( ) ; $ config = $ this - > process Configuration ( $ configuration , $ configs ) ; $ servers = isset ( $ config [ 'servers ' ] ) ? $ config [ 'servers ' ] : [ ] ; $ clients = isset ( $ config [ 'clients ' ] ) ? $ config [ 'clients ' ] : [ ] ; $ loader = new Loader \ Yaml File Loader ( $ container , new File Locator ( _ _DIR _ _ . ' / . . /Resources /config ' ) ) ; $ loader - > load ( 'services .yml ' ) ; $ client Service Names = [ ] ; foreach ( $ clients as $ alias = > $ client Config ) { 
protected function load Client ( $ container , $ alias , array $ config , array $ servers , $ base Events ) { $ used Servers = [ ] ; $ events = $ config [ 'events ' ] ; $ matched Servers = [ ] ; if ( $ config [ 'servers ' ] [ 0 ] = = 'all ' ) { 
public function get Config Tree Builder ( ) { $ tree Builder = new Tree Builder ( ) ; $ root Node = $ tree Builder - > root ( 'm 6 _statsd ' ) ; $ this - > add Servers Section ( $ root Node ) ; $ this - > add Clients Section ( $ root Node ) ; $ this - > add Default Event Section ( $ root Node ) ; return $ tree Builder ; } 
private function add Default Event Section ( $ root Node ) { $ root Node - > children ( ) - > boolean Node ( 'base _collectors ' ) - > default False ( ) - > end ( ) - > boolean Node ( 'console _events ' ) - > default False ( ) - > end ( ) ; } 
public function validate ( $ value , Constraint $ constraint ) { if ( ! is _scalar ( $ value ) & & ! ( is _object ( $ value ) & & method _exists ( $ value , ' _ _to String ' ) ) ) { $ this - > context - > add Violation ( 'node is not given or wrong datatype ' ) ; return ; } if ( empty ( $ value ) ) { $ this - > context - > add Violation ( 'the node is empty and isn \ 't suitable for graphite ' ) ; return ; } if ( ! self : : validate Pattern ( $ value ) ) { $ this - > context - > add Violation ( 'the node : ' . $ value . ' isn \ 't suitable for graphite ' ) ; return ; } } 
protected function dispatch ( $ event Name , Base Console Event $ e ) { if ( ! is _null ( $ this - > event Dispatcher ) ) { $ class = str _replace ( 'Symfony \Component \Console \Event ' , 'M 6Web \Bundle \Statsd Bundle \Event ' , get _class ( $ e ) ) ; $ finale Event = $ class : : create From Console Event ( $ e , $ this - > start Time , ! is _null ( $ this - > start Time ) ? microtime ( true ) - $ this - > start Time : null ) ; return $ this - > event Dispatcher - > dispatch ( $ event Name , $ finale Event ) ; } else { return false ; } } 
public function handle Event ( $ event , $ name = null ) { 
private function get Event Value ( $ event , $ method ) { if ( ! method _exists ( $ event , $ method ) ) { throw new Exception ( "The event class " . get _class ( $ event ) . " must have a " . $ method . " method in order to mesure value " ) ; } return call _user _func ( array ( $ event , $ method ) ) ; } 
private function add Timing ( $ event , $ timing Method , $ node , $ tags = [ ] ) { $ timing = $ this - > get Event Value ( $ event , $ timing Method ) ; if ( $ timing > 0 ) { $ this - > timing ( $ node , $ timing , 1 , $ tags ) ; } } 
private function replace Config Placeholder ( $ event , $ event Name , $ string ) { 
private function merge Tags ( $ event , $ config ) { $ config Tags = isset ( $ config [ 'tags ' ] ) ? $ config [ 'tags ' ] : [ ] ; if ( $ event instanceof Monitorable Event Interface ) { return array _merge ( $ config Tags , $ event - > get Tags ( ) ) ; } return $ config Tags ; } 
public function on Kernel Exception ( Get Response For Exception Event $ event ) { $ exception = $ event - > get Exception ( ) ; if ( $ exception instanceof Http Exception Interface ) { $ code = $ event - > get Exception ( ) - > get Status Code ( ) ; } else { $ code = 'unknown ' ; } $ this - > event Dispatcher - > dispatch ( 'statsd .exception ' , new Statsd Event ( $ code ) ) ; } 
private function dispatch Memory ( ) { $ memory = memory _get _peak _usage ( true ) ; $ memory = ( $ memory > 1 0 2 4 ? intval ( $ memory / 1 0 2 4 ) : 0 ) ; $ this - > event Dispatcher - > dispatch ( 'statsd .memory _usage ' , new Statsd Event ( $ memory ) ) ; } 
private function dispatch Request Time ( Post Response Event $ event ) { $ request = $ event - > get Request ( ) ; $ start Time = $ request - > server - > get ( 'REQUEST _TIME _FLOAT ' , $ request - > server - > get ( 'REQUEST _TIME ' ) ) ; $ time = microtime ( true ) - $ start Time ; $ time = round ( $ time * 1 0 0 0 ) ; $ this - > event Dispatcher - > dispatch ( 'statsd .time ' , new Statsd Event ( $ time ) ) ; } 
public static function create From Console Event ( Base Console Event $ e , $ start Time = null , $ execution Time = null ) { if ( static : : support ( $ e ) ) { return new static ( $ e , $ start Time , $ execution Time ) ; } else { throw \ Invalid Argument Exception ( 'Invalid event type . ' ) ; } } 
public function on Kernel Response ( $ event ) { if ( Http Kernel Interface : : MASTER _REQUEST = = $ event - > get Request Type ( ) ) { foreach ( $ this - > statsd Clients as $ client Name = > $ client ) { $ client Info = [ 'name ' = > $ client Name , 'operations ' = > [ ] ] ; foreach ( $ client - > get To Send ( ) as $ operation ) { if ( $ operation ) { $ this - > data [ 'operations ' ] + + ; $ message = $ operation [ 'message ' ] ; $ client Info [ 'operations ' ] [ ] = [ 'server ' = > $ operation [ 'server ' ] , 'node ' = > $ message - > get Node ( ) , 'value ' = > $ message - > get Value ( ) , 'sample ' = > $ message - > get Sample Rate ( ) , 'unit ' = > $ message - > get Unit ( ) ] ; } } $ this - > data [ 'clients ' ] [ ] = $ client Info ; } } } 
protected function get Type ( & $ value ) { if ( is _numeric ( $ value ) ) { $ value + = 0 ; if ( is _int ( $ value ) ) { return self : : T _INTEGER ; } return self : : T _FLOAT ; } if ( ctype _alpha ( $ value ) ) { $ name = _ _CLASS _ _ . ' : :T _ ' . strtoupper ( $ value ) ; if ( defined ( $ name ) ) { return constant ( $ name ) ; } return self : : T _STRING ; } switch ( $ value ) { case ' , ' : return self : : T _COMMA ; case ' ( ' : return self : : T _OPEN _PARENTHESIS ; case ' ) ' : return self : : T _CLOSE _PARENTHESIS ; case ' = ' : return self : : T _EQUALS ; case ' ; ' : return self : : T _SEMICOLON ; default : return self : : T _NONE ; } } 
public function parse ( $ input = null ) { if ( null ! = = $ input ) { $ this - > input = $ input ; } $ this - > lexer - > set Input ( $ this - > input ) ; $ this - > lexer - > move Next ( ) ; $ this - > srid = null ; $ this - > dimension = null ; if ( $ this - > lexer - > is Next Token ( Lexer : : T _SRID ) ) { $ this - > srid = $ this - > srid ( ) ; } $ geometry = $ this - > geometry ( ) ; $ geometry [ 'srid ' ] = $ this - > srid ; $ geometry [ 'dimension ' ] = ' ' = = = $ this - > dimension ? null : $ this - > dimension ; return $ geometry ; } 
protected function srid ( ) { $ this - > match ( Lexer : : T _SRID ) ; $ this - > match ( Lexer : : T _EQUALS ) ; $ this - > match ( Lexer : : T _INTEGER ) ; $ srid = $ this - > lexer - > value ( ) ; $ this - > match ( Lexer : : T _SEMICOLON ) ; return $ srid ; } 
protected function geometry ( ) { $ type = $ this - > type ( ) ; $ this - > type = $ type ; if ( $ this - > lexer - > is Next Token Any ( array ( Lexer : : T _Z , Lexer : : T _M , Lexer : : T _ZM ) ) ) { $ this - > match ( $ this - > lexer - > lookahead [ 'type ' ] ) ; $ this - > dimension = $ this - > lexer - > value ( ) ; } $ this - > match ( Lexer : : T _OPEN _PARENTHESIS ) ; $ value = $ this - > $ type ( ) ; $ this - > match ( Lexer : : T _CLOSE _PARENTHESIS ) ; return array ( 'type ' = > $ type , 'value ' = > $ value ) ; } 
protected function point ( ) { if ( null ! = = $ this - > dimension ) { return $ this - > coordinates ( 2 + strlen ( $ this - > dimension ) ) ; } $ values = $ this - > coordinates ( 2 ) ; for ( $ i = 3 ; $ i < = 4 & & $ this - > lexer - > is Next Token Any ( array ( Lexer : : T _FLOAT , Lexer : : T _INTEGER ) ) ; $ i + + ) { $ values [ ] = $ this - > coordinate ( ) ; } switch ( count ( $ values ) ) { case 2 : $ this - > dimension = ' ' ; break ; case 3 : $ this - > dimension = 'Z ' ; break ; case 4 : $ this - > dimension = 'ZM ' ; break ; } return $ values ; } 
protected function coordinates ( $ count ) { $ values = array ( ) ; for ( $ i = 1 ; $ i < = $ count ; $ i + + ) { $ values [ ] = $ this - > coordinate ( ) ; } return $ values ; } 
protected function coordinate ( ) { $ this - > match ( ( $ this - > lexer - > is Next Token ( Lexer : : T _FLOAT ) ? Lexer : : T _FLOAT : Lexer : : T _INTEGER ) ) ; return $ this - > lexer - > value ( ) ; } 
protected function point List ( ) { $ points = array ( $ this - > point ( ) ) ; while ( $ this - > lexer - > is Next Token ( Lexer : : T _COMMA ) ) { $ this - > match ( Lexer : : T _COMMA ) ; $ points [ ] = $ this - > point ( ) ; } return $ points ; } 
protected function point Lists ( ) { $ this - > match ( Lexer : : T _OPEN _PARENTHESIS ) ; $ point Lists = array ( $ this - > point List ( ) ) ; $ this - > match ( Lexer : : T _CLOSE _PARENTHESIS ) ; while ( $ this - > lexer - > is Next Token ( Lexer : : T _COMMA ) ) { $ this - > match ( Lexer : : T _COMMA ) ; $ this - > match ( Lexer : : T _OPEN _PARENTHESIS ) ; $ point Lists [ ] = $ this - > point List ( ) ; $ this - > match ( Lexer : : T _CLOSE _PARENTHESIS ) ; } return $ point Lists ; } 
protected function multi Polygon ( ) { $ this - > match ( Lexer : : T _OPEN _PARENTHESIS ) ; $ polygons = array ( $ this - > polygon ( ) ) ; $ this - > match ( Lexer : : T _CLOSE _PARENTHESIS ) ; while ( $ this - > lexer - > is Next Token ( Lexer : : T _COMMA ) ) { $ this - > match ( Lexer : : T _COMMA ) ; $ this - > match ( Lexer : : T _OPEN _PARENTHESIS ) ; $ polygons [ ] = $ this - > polygon ( ) ; $ this - > match ( Lexer : : T _CLOSE _PARENTHESIS ) ; } return $ polygons ; } 
protected function geometry Collection ( ) { $ collection = array ( $ this - > geometry ( ) ) ; while ( $ this - > lexer - > is Next Token ( Lexer : : T _COMMA ) ) { $ this - > match ( Lexer : : T _COMMA ) ; $ collection [ ] = $ this - > geometry ( ) ; } return $ collection ; } 
protected function match ( $ token ) { $ lookahead Type = $ this - > lexer - > lookahead [ 'type ' ] ; if ( $ lookahead Type ! = = $ token & & ( $ token ! = = Lexer : : T _TYPE | | $ lookahead Type < = Lexer : : T _TYPE ) ) { throw $ this - > syntax Error ( $ this - > lexer - > get Literal ( $ token ) ) ; } $ this - > lexer - > move Next ( ) ; } 
private function syntax Error ( $ expected ) { $ expected = sprintf ( 'Expected %s , got ' , $ expected ) ; $ token = $ this - > lexer - > lookahead ; $ found = null = = = $ this - > lexer - > lookahead ? 'end of string . ' : sprintf ( ' " %s " ' , $ token [ 'value ' ] ) ; $ message = sprintf ( ' [Syntax Error ] line 0 , col %d : Error : %s %s in value " %s " ' , isset ( $ token [ 'position ' ] ) ? $ token [ 'position ' ] : ' - 1 ' , $ expected , $ found , $ this - > input ) ; return new Unexpected Value Exception ( $ message ) ; } 
protected function create Response Parts ( $ response Parts ) { if ( $ response Parts = = = null ) { return array ( ) ; } $ responses = array ( ) ; foreach ( $ response Parts as $ response Part ) { $ responses [ ] = new Response ( $ response Part ) ; } return $ responses ; } 
public function get Time ( ) { if ( isset ( $ this - > data [ 'time ' ] ) ) { $ request Time = new \ Date Time ( ) ; 
protected function create Api Client ( ) { 
public function command ( ) { try { $ args = func _get _args ( ) ; $ command Name = $ args [ 0 ] ; array _shift ( $ args ) ; $ message To Send = json _encode ( array ( 'name ' = > $ command Name , 'args ' = > $ args ) ) ; $ command Response = $ this - > get Api Client ( ) - > post ( " /api " , array ( "body " = > $ message To Send ) ) ; $ json Response = json _decode ( $ command Response - > get Body ( ) , TRUE ) ; } catch ( Server Exception $ e ) { $ json Response = json _decode ( $ e - > get Response ( ) - > get Body ( ) - > get Contents ( ) , true ) ; } catch ( Connect Exception $ e ) { throw new Dead Client ( $ e - > get Message ( ) , $ e - > get Code ( ) , $ e ) ; } catch ( \ Exception $ e ) { throw $ e ; } if ( isset ( $ json Response [ 'error ' ] ) ) { throw $ this - > get Error Class ( $ json Response ) ; } return $ json Response [ 'response ' ] ; } 
public function send Keys ( $ page Id , $ element Id , $ keys ) { return $ this - > command ( 'send _keys ' , $ page Id , $ element Id , $ this - > normalize Keys ( $ keys ) ) ; } 
public function get Redirect Url ( ) { if ( isset ( $ this - > data [ 'redirect Url ' ] ) & & ! empty ( $ this - > data [ 'redirect Url ' ] ) ) { return $ this - > data [ 'redirect Url ' ] ; } return null ; } 
protected function check Render Options ( $ options ) { 
public function render ( $ path , $ options = array ( ) ) { $ fixed Options = $ this - > check Render Options ( $ options ) ; return $ this - > command ( 'render ' , $ path , $ fixed Options [ "full " ] , $ fixed Options [ "selector " ] ) ; } 
public function render Base 6 4 ( $ image Format , $ options = array ( ) ) { $ fixed Options = $ this - > check Render Options ( $ options ) ; return $ this - > command ( 'render _base 6 4 ' , $ image Format , $ fixed Options [ "full " ] , $ fixed Options [ "selector " ] ) ; } 
public function find ( $ method , $ selector ) { $ result = $ this - > command ( 'find ' , $ method , $ selector ) ; $ found [ "page _id " ] = $ result [ "page _id " ] ; foreach ( $ result [ "ids " ] as $ id ) { $ found [ "ids " ] [ ] = $ id ; } return $ found ; } 
public function find Within ( $ page Id , $ element Id , $ method , $ selector ) { return $ this - > command ( 'find _within ' , $ page Id , $ element Id , $ method , $ selector ) ; } 
public function set Attribute ( $ page Id , $ element Id , $ name , $ value ) { return $ this - > command ( 'set _attribute ' , $ page Id , $ element Id , $ name , $ value ) ; } 
public function key Event ( $ page Id , $ element Id , $ key Event , $ key , $ modifier ) { return $ this - > command ( "key _event " , $ page Id , $ element Id , $ key Event , $ key , $ modifier ) ; } 
public function select Option ( $ page Id , $ element Id , $ value , $ multiple = false ) { return $ this - > command ( "select _option " , $ page Id , $ element Id , $ value , $ multiple ) ; } 
public function debug ( $ enable = false ) { $ this - > debug = $ enable ; return $ this - > command ( 'set _debug ' , $ this - > debug ) ; } 
public function set Proxy ( $ proxy ) { $ args = array ( 'set _proxy ' ) ; if ( $ proxy ! = = false ) { if ( preg _match ( ' ~ ^ (http |socks 5 ) : / / ( ? : ( [ ^ : @ / ] * ? ) : ( [ ^ : @ / ] * ? ) @ ) ? ( [ ^ : @ / ] + ) : ( \d + ) $ ~ ' , $ proxy , $ components ) ) { array _push ( $ args , $ components [ 4 ] , intval ( $ components [ 5 ] , 1 0 ) , $ components [ 1 ] ) ; if ( strlen ( $ components [ 2 ] ) | | strlen ( $ components [ 3 ] ) ) { array _push ( $ args , urldecode ( $ components [ 2 ] ) , urldecode ( $ components [ 3 ] ) ) ; } } else { throw new \ Unexpected Value Exception ( 'Invalid proxy url ' . $ proxy ) ; } } return call _user _func _array ( array ( $ this , 'command ' ) , $ args ) ; } 
public function network Traffic ( ) { $ network Traffic = $ this - > command ( 'network _traffic ' ) ; $ request Traffic = array ( ) ; if ( count ( $ network Traffic ) = = = 0 ) { return null ; } foreach ( $ network Traffic as $ traffic ) { $ request Traffic [ ] = new Request ( $ traffic [ "request " ] , $ traffic [ "response Parts " ] ) ; } return $ request Traffic ; } 
public function cookies ( ) { $ cookies = $ this - > command ( 'cookies ' ) ; $ obj Cookies = array ( ) ; foreach ( $ cookies as $ cookie ) { $ obj Cookies [ $ cookie [ "name " ] ] = new Cookie ( $ cookie ) ; } return $ obj Cookies ; } 
public function set Cookie ( $ cookie ) { 
public function javascript Errors ( ) { $ js Errors = array ( ) ; $ errors = $ this - > response [ "error " ] [ "args " ] [ 0 ] ; foreach ( $ errors as $ error ) { $ js Errors [ ] = new JSError Item ( $ error [ "message " ] , $ error [ "stack " ] ) ; } return $ js Errors ; } 
public function message ( ) { $ error = "One or more errors were raised in the Javascript code on the page . If you don 't care about these errors , you can ignore them by setting js _errors : false in your Poltergeist configuration (see documentation for details ) . " ; 
private function compile Node ( bool $ is Compiling Host Trie , Trie Node $ curr Trie Node , Ast Node $ ast , Route $ route , ? Trie Node $ host Trie ) : void { $ ast Children = $ ast - > children ; $ num Ast Children = \ count ( $ ast Children ) ; $ is Endpoint = false ; $ segment Contains Variable = false ; $ segment Buffer = [ ] ; foreach ( $ is Compiling Host Trie ? \ array _reverse ( $ ast Children ) : $ ast Children as $ i = > $ child Ast Node ) { $ is Endpoint = $ is Endpoint | | ( ( $ is Compiling Host Trie | | $ host Trie = = = null ) & & ( $ i = = = $ num Ast Children - 1 | | $ child Ast Node - > type = = = Ast Node Types : : OPTIONAL _ROUTE _PART | | ( $ ast Children [ $ i + 1 ] - > type = = = Ast Node Types : : OPTIONAL _ROUTE _PART ) ) ) ; switch ( $ child Ast Node - > type ) { case Ast Node Types : : SEGMENT _DELIMITER : 
private function compile Variable Node ( Ast Node $ ast Node ) : Route Variable { $ rules = [ ] ; foreach ( $ ast Node - > children as $ child Ast Node ) { if ( $ child Ast Node - > type ! = = Ast Node Types : : VARIABLE _RULE ) { throw new Invalid Argument Exception ( "Unexpected node type { $child Ast Node - >type } " ) ; } $ rule Params = $ child Ast Node - > has Children ( ) ? $ child Ast Node - > children [ 0 ] - > value : [ ] ; $ rules [ ] = $ this - > rule Factory - > create Rule ( $ child Ast Node - > value , $ rule Params ) ; } return new Route Variable ( $ ast Node - > value , $ rules ) ; } 
private static function create Trie Node ( array & $ segment Buffer , bool & $ segment Contains Variable , bool $ is Endpoint , Route $ route , ? Trie Node $ host Trie ) : Trie Node { $ routes = $ is Endpoint ? $ route : [ ] ; if ( $ segment Contains Variable ) { $ node = new Variable Trie Node ( $ segment Buffer , [ ] , $ routes , $ host Trie ) ; } else { $ node = new Literal Trie Node ( \ implode ( ' ' , $ segment Buffer ) , [ ] , $ routes , $ host Trie ) ; } 
private static function flush Text Buffer ( string & $ text Buffer , array & $ tokens ) : void { if ( $ text Buffer ! = = ' ' ) { $ tokens [ ] = new Token ( Token Types : : T _TEXT , $ text Buffer ) ; $ text Buffer = ' ' ; } } 
private static function lex Number ( string $ number , array & $ tokens , int & $ cursor ) : void { $ float Val = ( float ) $ number ; $ int Val = ( int ) $ number ; 
private static function lex Punctuation ( string $ punctuation , array & $ tokens , int & $ cursor ) : void { $ tokens [ ] = new Token ( Token Types : : T _PUNCTUATION , $ punctuation ) ; $ cursor + + ; } 
private static function lex Quoted String ( string $ quoted String , array & $ tokens , int & $ cursor ) : void { $ tokens [ ] = new Token ( Token Types : : T _QUOTED _STRING , \ stripcslashes ( \ substr ( \ trim ( $ quoted String ) , 1 , - 1 ) ) ) ; $ cursor + = \ mb _strlen ( $ quoted String ) ; } 
private static function lex Text Char ( string $ char , string & $ text Buffer , int & $ cursor ) : void { $ text Buffer . = $ char ; $ cursor + + ; } 
private static function lex Variable Name ( string $ variable Name , array & $ tokens , int & $ cursor ) : void { 
public function add ( Route $ route ) : void { $ this - > routes [ ] = $ route ; if ( $ route - > name ! = = null ) { $ this - > named Routes [ $ route - > name ] = & $ route ; } } 
public function get Named Route ( string $ name ) : ? Route { if ( ! isset ( $ this - > named Routes [ $ name ] ) ) { return null ; } return $ this - > named Routes [ $ name ] ; } 
public function create Trie ( ) : Trie Node { if ( $ this - > trie Cache ! = = null & & ( $ trie = $ this - > trie Cache - > get ( ) ) ! = = null ) { return $ trie ; } 
public function parse Headers ( array $ server ) : array { $ headers = [ ] ; foreach ( $ server as $ key = > $ value ) { $ uppercased Key = \ strtoupper ( $ key ) ; if ( isset ( self : : $ special Case Headers [ $ uppercased Key ] ) | | \ strpos ( $ uppercased Key , 'HTTP _ ' ) = = = 0 ) { $ value = ( array ) $ value ; $ headers [ self : : normalize Name ( $ key ) ] = $ value ; } } return $ headers ; } 
private static function normalize Name ( $ name ) : string { $ dashed Name = \ str _replace ( ' _ ' , ' - ' , $ name ) ; if ( \ stripos ( $ dashed Name , 'HTTP - ' ) = = = 0 ) { $ dashed Name = \ substr ( $ dashed Name , 5 ) ; } return $ dashed Name ; } 
public function expect ( string $ type , $ value = null , string $ message = null ) : void { if ( $ this - > test ( $ type , $ value ) ) { return ; } $ current Token = $ this - > get Current ( ) ; if ( $ message = = = null ) { 
public function get Current ( ) : ? Token { return \ count ( $ this - > tokens ) > $ this - > cursor ? $ this - > tokens [ $ this - > cursor ] : null ; } 
public function next ( ) : ? Token { return \ count ( $ this - > tokens ) > + + $ this - > cursor ? $ this - > tokens [ $ this - > cursor ] : null ; } 
public function next If Type ( string $ type , $ value = null ) : bool { $ current Token = $ this - > get Current ( ) ; $ type Matches = $ current Token ! = = null & & $ current Token - > type = = = $ type ; if ( $ type Matches & & ( $ value = = = null | | $ current Token - > value = = = $ value ) ) { $ this - > next ( ) ; return true ; } return false ; } 
public function peek ( int $ lookahead = 1 ) : ? Token { if ( $ this - > cursor + $ lookahead > = \ count ( $ this - > tokens ) ) { return null ; } return $ this - > tokens [ $ this - > cursor + $ lookahead ] ; } 
public function add Child ( Ast Node $ node ) : Ast Node { $ node - > parent = $ this ; $ this - > children [ ] = $ node ; return $ this ; } 
public function add Child ( Trie Node $ child Node ) : self { if ( $ child Node instanceof Literal Trie Node ) { $ this - > add Literal Child Node ( $ child Node ) ; } elseif ( $ child Node instanceof Variable Trie Node ) { $ this - > add Variable Child Node ( $ child Node ) ; } else { throw new Invalid Argument Exception ( 'Unexpected trie node type ' . \ get _class ( $ child Node ) ) ; } return $ this ; } 
public function get All Children ( ) : array { $ children = [ ] ; foreach ( $ this - > literal Children By Value as $ child Node ) { $ children [ ] = $ child Node ; } foreach ( $ this - > variable Children as $ child Node ) { $ children [ ] = $ child Node ; } return $ children ; } 
private function add Literal Child Node ( Literal Trie Node $ child Node ) : void { 
private function add Variable Child Node ( Variable Trie Node $ child Node ) : void { 
public function build All ( ) : array { $ built Routes = [ ] ; foreach ( $ this - > route Builders as $ route Builder ) { $ built Routes [ ] = $ route Builder - > build ( ) ; } return $ built Routes ; } 
public function group ( Route Group Options $ group Options , Closure $ callback ) : void { $ this - > group Options Stack [ ] = $ group Options ; $ callback ( $ this ) ; \ array _pop ( $ this - > group Options Stack ) ; } 
public function map ( $ http Methods , string $ path Template , string $ host Template = null , bool $ is Https Only = false ) : Route Builder { $ this - > apply Group Route Templates ( $ path Template , $ host Template , $ is Https Only ) ; $ route Builder = new Route Builder ( ( array ) $ http Methods , new Uri Template ( $ path Template , $ host Template , $ is Https Only ) ) ; $ this - > apply Group Constraints ( $ route Builder ) ; $ this - > apply Group Middleware ( $ route Builder ) ; $ this - > apply Group Attributes ( $ route Builder ) ; $ this - > route Builders [ ] = $ route Builder ; return $ route Builder ; } 
private function apply Group Attributes ( Route Builder $ route Builder ) : void { $ group Attributes = [ ] ; foreach ( $ this - > group Options Stack as $ group Options ) { $ group Attributes = \ array _merge ( $ group Attributes , $ group Options - > attributes ) ; } $ route Builder - > with Many Attributes ( $ group Attributes ) ; } 
private function apply Group Constraints ( Route Builder $ route Builder ) : void { $ group Constraint Bindings = [ ] ; foreach ( $ this - > group Options Stack as $ group Options ) { $ group Constraint Bindings = \ array _merge ( $ group Constraint Bindings , $ group Options - > constraints ) ; } $ route Builder - > with Many Constraints ( $ group Constraint Bindings ) ; } 
private function apply Group Middleware ( Route Builder $ route Builder ) : void { $ group Middleware Bindings = [ ] ; foreach ( $ this - > group Options Stack as $ group Options ) { $ group Middleware Bindings = \ array _merge ( $ group Middleware Bindings , $ group Options - > middleware Bindings ) ; } $ route Builder - > with Many Middleware ( $ group Middleware Bindings ) ; } 
private function apply Group Route Templates ( string & $ path Template , string & $ host Template = null , bool & $ is Https Only = false ) : void { $ group Path Template = ' ' ; $ group Host Template = ' ' ; $ group Is Https Only = false ; foreach ( $ this - > group Options Stack as $ group Options ) { $ group Path Template . = $ group Options - > path Template ; $ group Host Template = $ group Options - > host Template . $ group Host Template ; $ group Is Https Only = $ group Is Https Only | | $ group Options - > is Https Only ; } $ path Template = $ group Path Template . $ path Template ; $ host Template = ( $ host Template ? ? ' ' ) . $ group Host Template ; $ is Https Only = $ is Https Only | | $ group Is Https Only ; } 
public function register Rule Factories ( IRule Factory $ rule Factory ) : IRule Factory { $ rule Factory - > register Rule Factory ( Alpha Rule : : get Slug ( ) , function ( ) { return new Alpha Rule ( ) ; } ) ; $ rule Factory - > register Rule Factory ( Alphanumeric Rule : : get Slug ( ) , function ( ) { return new Alphanumeric Rule ( ) ; } ) ; $ rule Factory - > register Rule Factory ( Between Rule : : get Slug ( ) , function ( $ min , $ max , bool $ is Inclusive = true ) { return new Between Rule ( $ min , $ max , $ is Inclusive ) ; } ) ; $ rule Factory - > register Rule Factory ( Date Rule : : get Slug ( ) , function ( $ formats ) { return new Date Rule ( $ formats ) ; } ) ; $ rule Factory - > register Rule Factory ( In Rule : : get Slug ( ) , function ( array $ acceptable Values ) { return new In Rule ( $ acceptable Values ) ; } ) ; $ rule Factory - > register Rule Factory ( Integer Rule : : get Slug ( ) , function ( ) { return new Integer Rule ( ) ; } ) ; $ rule Factory - > register Rule Factory ( Not In Rule : : get Slug ( ) , function ( array $ unacceptable Values ) { return new Not In Rule ( $ unacceptable Values ) ; } ) ; $ rule Factory - > register Rule Factory ( Numeric Rule : : get Slug ( ) , function ( ) { return new Numeric Rule ( ) ; } ) ; $ rule Factory - > register Rule Factory ( Regex Rule : : get Slug ( ) , function ( string $ regex ) { return new Regex Rule ( $ regex ) ; } ) ; $ rule Factory - > register Rule Factory ( Uuid V 4Rule : : get Slug ( ) , function ( ) { return new Uuid V 4Rule ( ) ; } ) ; return $ rule Factory ; } 
private static function get Match Candidates ( Trie Node $ node , array $ segments , int $ segment Iter , array $ host Segments , array & $ route Vars ) : iterable { 
public function build ( ) : Route { if ( $ this - > action = = = null ) { throw new Logic Exception ( 'No controller specified for route ' ) ; } return new Route ( $ this - > uri Template , $ this - > action , $ this - > constraints , $ this - > middleware Bindings , $ this - > name , $ this - > attributes ) ; } 
public function to Method ( string $ controller Class Name , string $ controller Method Name ) : self { $ this - > action = new Method Route Action ( $ controller Class Name , $ controller Method Name ) ; return $ this ; } 
public function with Attribute ( string $ name , $ value ) : self { $ this - > attributes [ $ name ] = $ value ; return $ this ; } 
public function with Many Attributes ( array $ attributes ) : self { $ this - > attributes = \ array _merge ( $ this - > attributes , $ attributes ) ; return $ this ; } 
public function with Many Constraints ( array $ constraints ) : self { $ this - > constraints = \ array _merge ( $ this - > constraints , $ constraints ) ; return $ this ; } 
public function with Many Middleware ( array $ middleware Bindings ) : self { foreach ( $ middleware Bindings as $ middleware Binding ) { if ( \ is _string ( $ middleware Binding ) ) { $ this - > middleware Bindings [ ] = new Middleware Binding ( $ middleware Binding ) ; } elseif ( $ middleware Binding instanceof Middleware Binding ) { $ this - > middleware Bindings [ ] = $ middleware Binding ; } else { throw new Invalid Argument Exception ( 'Middleware binding must either be a string or an instance of ' . Middleware Binding : : class ) ; } } return $ this ; } 
public function with Middleware ( string $ middleware Class Name , array $ middleware Properties = [ ] ) : self { $ this - > middleware Bindings [ ] = new Middleware Binding ( $ middleware Class Name , $ middleware Properties ) ; return $ this ; } 
private function parse Punctuation ( Token Stream $ tokens , Ast Node & $ curr Node , bool $ parsing Path ) : void { if ( ( $ token = $ tokens - > get Current ( ) ) = = = null ) { return ; } switch ( $ token - > value ) { case ' / ' : if ( ! $ parsing Path ) { throw new Invalid Argument Exception ( "Unexpected { $token - >type } \ " { $token - >value } \ " in host " ) ; } $ curr Node - > add Child ( new Ast Node ( Ast Node Types : : SEGMENT _DELIMITER , $ token - > value ) ) ; $ tokens - > next ( ) ; break ; case ' . ' : * Optional parts in hosts must end with ' . ' , eg [foo . [bar . ] ]example .com * So , make sure that the previous non -optional route part ends with ' . ' * / $ is Valid = false ; for ( $ i = \ count ( $ curr Node - > children ) - 1 ; $ i > = 0 ; $ i - - ) { $ child Node = $ curr Node - > children [ $ i ] ; if ( $ child Node - > type ! = = Ast Node Types : : OPTIONAL _ROUTE _PART ) { if ( $ child Node - > type = = = Ast Node Types : : SEGMENT _DELIMITER ) { $ is Valid = true ; } break ; } } if ( ! $ is Valid ) { throw new Invalid Argument Exception ( 'Expected optional host part to end with \ ' . \ ' ' ) ; } } 
private function parse Text ( Token Stream $ tokens , Ast Node $ curr Node ) : void { if ( ( $ token = $ tokens - > get Current ( ) ) = = = null ) { return ; } $ curr Node - > add Child ( new Ast Node ( Ast Node Types : : TEXT , $ token - > value ) ) ; $ tokens - > next ( ) ; } 
private function parse Tokens ( Token Stream $ tokens , Ast Node $ ast ) : void { $ parsing Path = $ ast - > type = = = Ast Node Types : : PATH ; $ curr Node = $ ast ; while ( ( $ token = $ tokens - > get Current ( ) ) ! = = null ) { switch ( $ token - > type ) { case Token Types : : T _TEXT : $ this - > parse Text ( $ tokens , $ curr Node ) ; break ; case Token Types : : T _NUMBER : 
private function parse Variable ( Token Stream $ tokens , Ast Node & $ curr Node ) : void { if ( ( $ token = $ tokens - > get Current ( ) ) = = = null ) { return ; } $ variable Node = new Ast Node ( Ast Node Types : : VARIABLE , $ token - > value ) ; $ curr Node - > add Child ( $ variable Node ) ; $ curr Node = $ variable Node ; $ tokens - > next ( ) ; 
private function parse Variable Rule ( Token Stream $ tokens , Ast Node $ curr Node ) : void { 
public function is Match ( string $ segment Value , array & $ route Variables ) : bool { if ( $ this - > only Contains Variable ) { foreach ( $ this - > parts [ 0 ] - > rules as $ rule ) { if ( ! $ rule - > passes ( $ segment Value ) ) { return false ; } } $ route Variables [ $ this - > parts [ 0 ] - > name ] = $ segment Value ; return true ; } $ matches = [ ] ; if ( \ preg _match ( $ this - > regex , $ segment Value , $ matches , PREG _UNMATCHED _AS _NULL ) ! = = 1 ) { return false ; } 
protected function decode Response ( $ action , $ data ) { if ( ! array _key _exists ( $ action , $ this - > decode Settings [ static : : DECODE _ACTION ] ) ) { throw new De Captcha Errors ( ' н е т action ' ) ; } $ decode Setting = $ this - > decode Settings [ static : : DECODE _ACTION ] [ $ action ] ; $ decode Format = array _key _exists ( static : : DECODE _FORMAT , $ decode Setting ) ? $ decode Setting [ static : : DECODE _FORMAT ] : $ this - > decode Settings [ static : : DECODE _FORMAT ] ; $ values = [ ] ; switch ( $ decode Format ) { case static : : RESPONSE _TYPE _STRING : foreach ( explode ( $ decode Setting [ static : : DECODE _SEPARATOR ] , $ data ) as $ key = > $ value ) { foreach ( $ decode Setting [ static : : DECODE _PARAMS ] as $ param = > $ param Setting ) { if ( $ key = = = $ param Setting [ static : : DECODE _PARAM _SETTING _MARKER ] ) { $ values [ $ param ] = $ value ; } } } break ; case static : : RESPONSE _TYPE _JSON : foreach ( json _decode ( $ data , true ) as $ key = > $ value ) { foreach ( $ decode Setting [ static : : DECODE _PARAMS ] as $ param = > $ param Setting ) { if ( count ( explode ( ' . ' , $ param Setting [ static : : DECODE _PARAM _SETTING _MARKER ] ) ) > 1 ) { if ( $ key = = = explode ( ' . ' , $ param Setting [ static : : DECODE _PARAM _SETTING _MARKER ] ) [ 0 ] ) { if ( array _key _exists ( explode ( ' . ' , $ param Setting [ static : : DECODE _PARAM _SETTING _MARKER ] ) [ 1 ] , $ value ) ) { $ values [ $ param ] = $ value [ explode ( ' . ' , $ param Setting [ static : : DECODE _PARAM _SETTING _MARKER ] ) [ 1 ] ] ; } } } if ( $ key = = = $ param Setting [ static : : DECODE _PARAM _SETTING _MARKER ] ) { $ values [ $ param ] = $ value ; } } } break ; } return $ values ; } 
protected function get File Path ( $ file Name ) { if ( strpos ( $ file Name , 'http : / / ' ) ! = = false | | strpos ( $ file Name , 'https : / / ' ) ! = = false ) { try { $ current = file _get _contents ( $ file Name ) ; } catch ( \ Exception $ e ) { throw new De Captcha Errors ( De Captcha Errors : : ERROR _FILE _IS _NOT _LOADED , $ file Name , $ this - > error Lang ) ; } $ path = tempnam ( sys _get _temp _dir ( ) , 'captcha ' ) ; file _put _contents ( $ path , $ current ) ; return $ path ; } if ( file _exists ( $ file Name ) ) { return $ file Name ; } throw new De Captcha Errors ( De Captcha Errors : : ERROR _FILE _NOT _FOUND , $ file Name , $ this - > error Lang ) ; } 
public function get Param Spec ( $ param , $ spec = null , $ coding = null ) { if ( is _null ( $ spec ) ) { $ spec = $ param ; } if ( ! array _key _exists ( $ param , $ this - > params ) | | is _null ( $ this - > params [ $ param ] ) ) { if ( ! array _key _exists ( $ spec , $ this - > params ) | | is _null ( $ this - > params [ $ spec ] ) ) { return null ; } $ param = $ spec ; } switch ( $ spec ) { case static : : PARAM _SPEC _FILE : switch ( $ coding ) { case static : : PARAM _SLUG _CODING _BASE 6 4 : return base 6 4 _encode ( file _get _contents ( $ this - > params [ $ param ] ) ) ; } return ( version _compare ( PHP _VERSION , ' 5 . 5 . 0 ' ) > = 0 ) ? new \ CURLFile ( $ this - > get File Path ( $ this - > params [ $ param ] ) ) : ' @ ' . $ this - > get File Path ( $ this - > params [ $ param ] ) ; case static : : PARAM _SPEC _API _KEY : return is _callable ( $ this - > params [ $ param ] ) ? $ this - > params [ $ param ] ( ) : $ this - > params [ $ param ] ; case static : : PARAM _SPEC _CAPTCHA : return ( int ) $ this - > params [ $ param ] ; case static : : PARAM _SPEC _CODE : return ( string ) $ this - > params [ $ param ] ; } return null ; } 
protected function get Params ( $ action , $ field = null ) { if ( empty ( $ this - > actions [ $ action ] ) ) { return [ ] ; } $ fields = $ this - > actions [ $ action ] [ static : : ACTION _FIELDS ] ; if ( ! is _null ( $ field ) ) { $ fields = $ fields [ $ field ] [ static : : ACTION _FIELDS ] ; } $ params = [ ] ; foreach ( $ fields as $ field = > $ settings ) { $ value = null ; if ( array _key _exists ( self : : PARAM _SLUG _DEFAULT , $ settings ) ) { $ value = $ settings [ self : : PARAM _SLUG _DEFAULT ] ; } if ( array _key _exists ( $ field , $ this - > params ) & & ( ! array _key _exists ( self : : PARAM _SLUG _VARIABLE , $ settings ) ^ ( array _key _exists ( self : : PARAM _SLUG _VARIABLE , $ settings ) & & $ settings [ self : : PARAM _SLUG _VARIABLE ] = = = false ) ) ) { $ value = $ this - > params [ $ field ] ; } if ( array _key _exists ( self : : PARAM _SLUG _SPEC , $ settings ) ) { $ value = $ this - > get Param Spec ( $ field , $ settings [ self : : PARAM _SLUG _SPEC ] , array _key _exists ( self : : PARAM _SLUG _CODING , $ settings ) ? $ settings [ self : : PARAM _SLUG _CODING ] : null ) ; } if ( is _null ( $ value ) ) { if ( array _key _exists ( self : : PARAM _SLUG _REQUIRE , $ settings ) & & $ settings [ self : : PARAM _SLUG _REQUIRE ] = = = true ) { throw new De Captcha Errors ( De Captcha Errors : : ERROR _PARAM _REQUIRE , array _key _exists ( $ field , $ this - > params Names ) ? $ this - > params Names [ $ field ] : $ field , $ this - > error Lang ) ; } continue ; } if ( array _key _exists ( $ field , $ this - > params Names ) ) { switch ( $ settings [ self : : PARAM _SLUG _TYPE ] ) { case self : : PARAM _FIELD _TYPE _FLOAT : $ value = ( float ) $ value ; break ; case self : : PARAM _FIELD _TYPE _INTEGER : $ value = ( int ) $ value ; break ; case self : : PARAM _FIELD _TYPE _STRING : $ value = ( string ) $ value ; break ; case self : : PARAM _FIELD _TYPE _BOOLEAN : $ value = ( bool ) $ value ; break ; case self : : PARAM _FIELD _TYPE _OBJECT : $ value = $ this - > get Params ( $ action , $ field ) ; break ; } if ( array _key _exists ( self : : PARAM _SLUG _ENUM , $ settings ) & & ! in _array ( $ value , $ settings [ static : : PARAM _SLUG _ENUM ] ) ) { throw new De Captcha Errors ( De Captcha Errors : : ERROR _PARAM _ENUM , ( array _key _exists ( $ field , $ this - > params Names ) ? $ this - > params Names [ $ field ] : $ field ) . ' = ' . $ value , $ this - > error Lang ) ; } $ params [ $ this - > params Names [ $ field ] ] = $ value ; } } return $ params ; } 
protected function get Response ( $ action ) { return $ this - > curl Response ( $ this - > get Action Url ( $ action ) , $ this - > get Params ( $ action ) , array _key _exists ( static : : ACTION _METHOD , $ this - > actions [ $ action ] ) & & $ this - > actions [ $ action ] [ static : : ACTION _METHOD ] = = = static : : ACTION _METHOD _POST , array _key _exists ( static : : ACTION _JSON , $ this - > actions [ $ action ] ) & & $ this - > actions [ $ action ] [ static : : ACTION _JSON ] = = = true ) ; } 
protected function execution Delayed ( $ delay = 0 , $ callback = null ) { $ time = microtime ( true ) ; $ time Passed = $ time - $ this - > last Run Time ; if ( $ time Passed < $ delay ) { usleep ( ( $ delay - $ time Passed ) * 1 0 0 0 0 0 0 ) ; } $ this - > last Run Time = microtime ( true ) ; return $ callback instanceof \ Closure ? $ callback ( $ this ) : $ callback ; } 
protected function curl Response ( $ url , $ data , $ is Post = true , $ is Json = false ) { $ curl = curl _init ( ) ; if ( $ is Json ) { $ data = json _encode ( $ data ) ; } elseif ( ! $ is Post ) { $ uri = [ ] ; foreach ( $ data as $ key = > $ value ) { $ uri [ ] = " $key = $value " ; } $ url . = ' ? ' . implode ( ' & ' , $ uri ) ; } curl _setopt ( $ curl , CURLOPT _URL , $ url ) ; if ( ! $ is Json & & version _compare ( PHP _VERSION , ' 5 . 5 . 0 ' ) > = 0 & & version _compare ( PHP _VERSION , ' 7 . 0 ' ) < 0 & & defined ( 'CURLOPT _SAFE _UPLOAD ' ) ) { curl _setopt ( $ curl , CURLOPT _SAFE _UPLOAD , false ) ; } curl _setopt ( $ curl , CURLOPT _RETURNTRANSFER , true ) ; curl _setopt ( $ curl , CURLOPT _ENCODING , 'gzip ,deflate ' ) ; curl _setopt ( $ curl , CURLOPT _TIMEOUT , 3 0 ) ; curl _setopt ( $ curl , CURLOPT _CONNECTTIMEOUT , 3 0 ) ; curl _setopt ( $ curl , CURLOPT _POST , $ is Post ) ; if ( $ is Post ) { curl _setopt ( $ curl , CURLOPT _POSTFIELDS , $ data ) ; } if ( $ is Json ) { curl _setopt ( $ curl , CURLOPT _HTTPHEADER , [ 'Content -Type : application /json ; charset =utf - 8 ' , 'Accept : application /json ' , 'Content -Length : ' . strlen ( $ data ) , ] ) ; } $ result = curl _exec ( $ curl ) ; if ( curl _errno ( $ curl ) ) { throw new De Captcha Errors ( De Captcha Errors : : ERROR _CURL , curl _error ( $ curl ) , $ this - > error Lang ) ; } curl _close ( $ curl ) ; return $ result ; } 
public function recognize ( $ file Path , $ additionally = [ ] ) { try { $ this - > reset Limits ( ) ; if ( $ file Path ) { $ additionally [ static : : ACTION _FIELD _FILE ] = $ file Path ; } $ this - > set Params ( $ additionally ) ; return $ this - > request Recognize ( ) & & $ this - > request Code ( ) ; } catch ( De Captcha Errors $ e ) { if ( $ this - > cause An Error ) { throw $ e ; } $ this - > error Object = $ e ; return false ; } } 
protected function request Repeat ( $ action , $ decode Action , $ set Param , $ decode Ser Param , $ ok , $ sleep , $ repeat , $ error = null ) { if ( is _null ( $ error ) ) { $ error = static : : DECODE _PARAM _RESPONSE ; } while ( $ this - > limit Has Not Yet Ended ( $ action ) ) { $ this - > execution Delayed ( $ sleep ) ; $ response = $ this - > get Response ( $ action ) ; $ data Recognize = $ this - > decode Response ( $ decode Action , $ response ) ; if ( $ data Recognize [ static : : DECODE _PARAM _RESPONSE ] = = = $ ok & & ! empty ( $ data Recognize [ $ decode Ser Param ] ) ) { $ this - > set Param ( $ set Param , $ data Recognize [ $ decode Ser Param ] ) ; $ this - > execution Delayed ( static : : SLEEP _BETWEEN ) ; return true ; } elseif ( $ data Recognize [ static : : DECODE _PARAM _RESPONSE ] = = = $ repeat ) { continue ; } throw new De Captcha Errors ( $ data Recognize [ $ error ] , null , $ this - > error Lang ) ; } throw new De Captcha Errors ( De Captcha Errors : : ERROR _LIMIT , null , $ this - > error Lang ) ; } 
protected function request Universal ( $ action ) { $ this - > set Param ( static : : ACTION _FIELD _ACTION , $ action ) ; $ response = $ this - > get Response ( static : : ACTION _UNIVERSAL ) ; return $ this - > decode Response ( static : : DECODE _ACTION _UNIVERSAL , $ response ) ; } 
protected function request Recognize ( ) { return $ this - > request Repeat ( static : : ACTION _RECOGNIZE , static : : DECODE _ACTION _RECOGNIZE , static : : PARAM _SPEC _CAPTCHA , static : : DECODE _PARAM _CAPTCHA , static : : RESPONSE _RECOGNIZE _OK , static : : SLEEP _RECOGNIZE , static : : RESPONSE _RECOGNIZE _REPEAT , static : : DECODE _PARAM _ERROR ) ; } 
protected function request Code ( ) { return $ this - > request Repeat ( static : : ACTION _UNIVERSAL _WITH _CAPTCHA , static : : DECODE _ACTION _GET , static : : PARAM _SPEC _CODE , static : : DECODE _PARAM _CODE , static : : RESPONSE _GET _OK , static : : SLEEP _GET , static : : RESPONSE _GET _REPEAT , static : : DECODE _PARAM _ERROR ) ; } 
public function get Balance ( ) { $ this - > set Param ( static : : ACTION _FIELD _ACTION , static : : ACTION _BALANCE ) ; $ response = $ this - > get Response ( static : : ACTION _BALANCE ) ; $ result = $ this - > decode Response ( static : : DECODE _ACTION _BALANCE , $ response ) ; if ( $ result [ static : : DECODE _PARAM _RESPONSE ] ! = 0 ) { return 0 ; } return ( float ) $ result [ static : : DECODE _PARAM _BALANCE ] ; } 
public function get Text ( $ name , $ separator = ' ; ' ) { $ get Result = function ( $ name , $ texts ) { if ( is _array ( $ name ) ) { $ name = implode ( ' _ ' , $ name ) ; } if ( ! isset ( $ texts [ $ name ] ) ) { return null ; } if ( is _array ( $ texts [ $ name ] ) ) { if ( isset ( $ texts [ $ name ] [ $ this - > lang ] ) ) { return $ texts [ $ name ] [ $ this - > lang ] ; } return array _values ( $ texts [ $ name ] ) [ 0 ] ; } return $ texts [ $ name ] ; } ; $ result = $ get Result ( $ name , $ this - > texts ) ; if ( is _array ( $ result ) ) { if ( $ separator ) { $ result = implode ( $ separator , $ result ) ; } } return $ result ; } 
public function is There Such ( $ name ) { if ( is _string ( $ name ) & & defined ( "static : : $name " ) ) { return constant ( "static : : $name " ) ; } if ( is _int ( $ name ) ) { return $ name ; } return null ; } 
public function _get Create Table SQL ( $ table Name , array $ columns , array $ options = [ ] ) { $ query Fields = $ this - > platform - > get Column Declaration List SQL ( $ columns ) ; if ( isset ( $ options [ 'primary ' ] ) & & ! empty ( $ options [ 'primary ' ] ) ) { $ key Columns = array _unique ( array _values ( $ options [ 'primary ' ] ) ) ; $ query Fields . = ' , PRIMARY KEY ( ' . implode ( ' , ' , $ key Columns ) . ' ) ' ; } $ query = 'CREATE TABLE ' . $ table Name . ' ( ' . $ query Fields . ' ) ' ; $ sql [ ] = $ query ; if ( isset ( $ options [ 'indexes ' ] ) & & ! empty ( $ options [ 'indexes ' ] ) ) { foreach ( $ options [ 'indexes ' ] as $ index ) { $ sql [ ] = $ this - > platform - > get Create Index SQL ( $ index , $ table Name ) ; } } if ( isset ( $ options [ 'foreign Keys ' ] ) ) { foreach ( ( array ) $ options [ 'foreign Keys ' ] as $ definition ) { $ sql [ ] = $ this - > platform - > get Create Foreign Key SQL ( $ definition , $ table Name ) ; } } return $ sql ; } 
protected function get Column Comment ( Column $ column ) { $ comment = $ column - > get Comment ( ) ; if ( $ this - > platform - > is Commented Doctrine Type ( $ column - > get Type ( ) ) ) { $ comment . = $ this - > platform - > get Doctrine Type Comment ( $ column - > get Type ( ) ) ; } return $ comment ; } 
public function group ( array $ attributes , Closure $ routes ) : Router { 
public function map ( ? string $ method , string $ route , $ controller , $ middleware = [ ] , string $ domain = null , string $ name = null ) : Router { $ name = $ name ? : $ this - > current Name ; $ uri = $ this - > current Prefix . $ route ; $ middleware = is _array ( $ middleware ) ? $ middleware : [ $ middleware ] ; if ( is _string ( $ controller ) & & is _callable ( $ controller ) = = false ) { $ controller = $ this - > current Namespace . " \ \ " . $ controller ; } $ route = new Route ( $ name , $ uri , $ method , $ controller , array _merge ( $ this - > current Middleware , $ middleware ) , $ domain ? : $ this - > current Domain ) ; $ this - > routes [ ] = $ route ; if ( $ name ) { $ this - > names [ $ name ] = $ route ; $ this - > current Name = null ; } return $ this ; } 
public function dispatch ( ) : Router { $ this - > prepare ( ) ; $ method = $ this - > request - > get Method ( ) ; $ scheme = $ this - > request - > get Uri ( ) - > get Scheme ( ) ; $ domain = substr ( $ this - > request - > get Uri ( ) - > get Host ( ) , strlen ( $ scheme . ' : / / ' ) ) ; $ uri = $ this - > request - > get Uri ( ) - > get Path ( ) ; sort ( $ this - > routes , SORT _DESC ) ; foreach ( $ this - > routes as $ route ) { $ parameters = [ ] ; if ( $ this - > compare Method ( $ route - > get Method ( ) , $ method ) & & $ this - > compare Domain ( $ route - > get Domain ( ) , $ domain ) & & $ this - > compare Uri ( $ route - > get Uri ( ) , $ uri , $ parameters ) ) { $ this - > current Route = $ route ; $ this - > publisher - > publish ( $ this - > run ( $ route , $ parameters ) ) ; return $ this ; } } throw new Route Not Found Exception ( ) ; } 
private function compare Method ( ? string $ route Method , string $ request Method ) : bool { return $ route Method = = null | | $ route Method = = $ request Method ; } 
private function compare Domain ( ? string $ route Domain , string $ request Domain ) : bool { return $ route Domain = = null | | preg _match ( ' @ ^ ' . $ route Domain . ' $ @ ' , $ request Domain ) ; } 
private function compare Uri ( string $ route Uri , string $ request Uri , array & $ parameters ) : bool { $ pattern = ' @ ^ ' . $ this - > regex Uri ( $ route Uri ) . ' $ @ ' ; return preg _match ( $ pattern , $ request Uri , $ parameters ) ; } 
private function run ( Route $ route , array $ parameters ) { $ controller = $ route - > get Controller ( ) ; if ( count ( $ middleware = $ route - > get Middleware ( ) ) > 0 ) { $ controller Runner = function ( Server Request $ request ) use ( $ controller , $ parameters ) { return $ this - > run Controller ( $ controller , $ parameters , $ request ) ; } ; return $ this - > run Controller Through Middleware ( $ middleware , $ this - > request , $ controller Runner ) ; } else { return $ this - > run Controller ( $ controller , $ parameters , $ this - > request ) ; } } 
private function run Controller Through Middleware ( array $ middleware , Server Request Interface $ request , Closure $ controller Runner , $ i = 0 ) { if ( isset ( $ middleware [ $ i + 1 ] ) ) { $ next = function ( Server Request Interface $ request ) use ( $ middleware , $ controller Runner , $ i ) { return $ this - > run Controller Through Middleware ( $ middleware , $ request , $ controller Runner , $ i + 1 ) ; } ; } else { $ next = $ controller Runner ; } if ( is _callable ( $ middleware [ $ i ] ) ) { return $ middleware [ $ i ] ( $ request , $ next ) ; } if ( is _subclass _of ( $ middleware [ $ i ] , Middleware : : class ) ) { if ( is _string ( $ middleware [ $ i ] ) ) { $ middleware [ $ i ] = new $ middleware [ $ i ] ; } return $ middleware [ $ i ] - > handle ( $ request , $ next ) ; } throw new Invalid Middleware Exception ( 'Invalid middleware for route : ' . $ this - > current Route ) ; } 
private function run Controller ( $ controller , array $ parameters , Server Request Interface $ request ) { try { if ( is _string ( $ controller ) & & strpos ( $ controller , ' @ ' ) ) { list ( $ class Name , $ method Name ) = explode ( ' @ ' , $ controller ) ; if ( class _exists ( $ class Name ) = = false ) { throw new Invalid Controller Exception ( "Controller class ` $controller ` not found . " ) ; } $ class Object = new $ class Name ( ) ; if ( method _exists ( $ class Object , $ method Name ) = = false ) { throw new Invalid Controller Exception ( "Controller method ` $method Name ` not found . " ) ; } $ parameters = $ this - > arrange Method Parameters ( $ class Name , $ method Name , $ parameters , $ request ) ; $ controller = [ $ class Object , $ method Name ] ; } elseif ( is _callable ( $ controller ) ) { $ parameters = $ this - > arrange Function Parameters ( $ controller , $ parameters , $ request ) ; } else { throw new Invalid Controller Exception ( 'Invalid controller : ' . $ controller ) ; } return call _user _func _array ( $ controller , $ parameters ) ; } catch ( Reflection Exception $ e ) { throw new Invalid Controller Exception ( ' ' , 0 , $ e ) ; } } 
private function arrange Method Parameters ( string $ class , string $ method , array $ parameters , Server Request Interface $ request ) { return $ this - > arrange Parameters ( new Reflection Method ( $ class , $ method ) , $ parameters , $ request ) ; } 
private function arrange Parameters ( Reflection Function Abstract $ reflection , array $ parameters , Server Request Interface $ request ) { return array _map ( function ( Reflection Parameter $ parameter ) use ( $ parameters , $ request ) { if ( isset ( $ parameters [ $ parameter - > get Name ( ) ] ) ) { return $ parameters [ $ parameter - > get Name ( ) ] ; } if ( ( $ parameter - > get Type ( ) & & $ parameter - > get Type ( ) - > get Name ( ) = = Server Request Interface : : class ) | | ( $ parameter - > get Type ( ) & & $ parameter - > get Type ( ) - > get Name ( ) = = Server Request : : class ) | | ( $ parameter - > get Name ( ) = = 'request ' ) ) { return $ request ; } if ( ( $ parameter - > get Type ( ) & & $ parameter - > get Type ( ) - > get Name ( ) = = Router : : class ) | | ( $ parameter - > get Name ( ) = = 'router ' ) ) { return $ this ; } if ( $ parameter - > is Optional ( ) ) { return $ parameter - > get Default Value ( ) ; } return null ; } , $ reflection - > get Parameters ( ) ) ; } 
private function regex Uri ( string $ route ) : string { return preg _replace _callback ( ' @ { ( [ ^ } ] + ) } @ ' , function ( array $ match ) { return $ this - > regex Parameter ( $ match [ 1 ] ) ; } , $ route ) ; } 
private function regex Parameter ( string $ name ) : string { if ( $ name [ - 1 ] = = ' ? ' ) { $ name = substr ( $ name , 0 , - 1 ) ; $ suffix = ' ? ' ; } else { $ suffix = ' ' ; } $ pattern = $ this - > parameters [ $ name ] ? ? ' [ ^ / ] + ' ; return ' ( ? < ' . $ name . ' > ' . $ pattern . ' ) ' . $ suffix ; } 
public function any ( string $ route , $ controller , $ middleware = [ ] , string $ domain = null , string $ name = null ) : Router { return $ this - > map ( null , $ route , $ controller , $ middleware , $ domain , $ name ) ; } 
public function define ( string $ name , string $ pattern ) : Router { $ this - > parameters [ $ name ] = $ pattern ; return $ this ; } 
public function url ( string $ route Name , array $ parameters = [ ] ) : ? string { if ( isset ( $ this - > names [ $ route Name ] ) = = false ) { return null ; } $ uri = $ this - > names [ $ route Name ] - > get Uri ( ) ; foreach ( $ parameters as $ name = > $ value ) { $ uri = preg _replace ( ' / \ ? ? \ { ' . $ name . ' \ ? ? \ } / ' , $ value , $ uri ) ; } $ uri = preg _replace ( ' / { [ ^ \ } ] + \ ? \ } / ' , ' ' , $ uri ) ; $ uri = str _replace ( ' / ? ' , ' ' , $ uri ) ; return $ uri ; } 
private function prepare ( ) : void { if ( $ this - > request = = null ) { $ this - > request = Server Request Factory : : from Globals ( ) ; } if ( $ this - > publisher = = null ) { $ this - > publisher = new Publisher ( ) ; } } 
public function get Access Token ( ) { $ client = new Client ( array ( 'base _uri ' = > 'https : / /api -ssl .bitly .com /oauth /access _token ' , ) ) ; $ response = $ client - > post ( null , array ( 'auth ' = > array ( $ this - > username , $ this - > password , ) , ) ) ; return $ response - > get Body ( ) - > get Contents ( ) ; } 
public function shorten ( Link Interface $ link ) { $ client = $ this - > create Client ( ) ; $ response = $ client - > post ( $ this - > get Uri ( ) , array _merge ( array ( 'json ' = > array ( 'long Url ' = > $ link - > get Long Url ( ) , ) , ) , $ this - > options ) ) ; $ response = $ this - > validate ( $ response - > get Body ( ) - > get Contents ( ) ) ; $ link - > set Short Url ( $ response - > id ) ; } 
public function expand ( Link Interface $ link ) { $ client = $ this - > create Client ( ) ; $ response = $ client - > get ( $ this - > get Uri ( array ( 'short Url ' = > $ link - > get Short Url ( ) , ) ) , $ this - > options ) ; $ response = $ this - > validate ( $ response - > get Body ( ) - > get Contents ( ) , true ) ; $ link - > set Long Url ( $ response - > long Url ) ; } 
private function get Uri ( array $ parameters = array ( ) ) { if ( $ this - > api Key ) { $ parameters = array _merge ( $ parameters , array ( 'key ' = > $ this - > api Key ) ) ; } if ( 0 = = = count ( $ parameters ) ) { return ; } return sprintf ( ' ? %s ' , http _build _query ( $ parameters ) ) ; } 
private function validate ( $ api Raw Response , $ check Status = false ) { $ response = json _decode ( $ api Raw Response ) ; if ( null = = = $ response ) { throw new Invalid Api Response Exception ( 'Google response is probably mal -formed because cannot be json -decoded . ' ) ; } if ( property _exists ( $ response , 'error ' ) ) { throw new Invalid Api Response Exception ( sprintf ( 'Google returned status code " %s " with message " %s " . ' , property _exists ( $ response - > error , 'code ' ) ? $ response - > error - > code : ' ' , property _exists ( $ response - > error , 'message ' ) ? $ response - > error - > message : ' ' ) ) ; } if ( ! property _exists ( $ response , 'id ' ) ) { throw new Invalid Api Response Exception ( 'Property "id " does not exist within Google response . ' ) ; } if ( ! property _exists ( $ response , 'long Url ' ) ) { throw new Invalid Api Response Exception ( 'Property "long Url " does not exist within Google response . ' ) ; } if ( ! $ check Status ) { return $ response ; } if ( ! property _exists ( $ response , 'status ' ) ) { throw new Invalid Api Response Exception ( 'Property "status " does not exist within Google response . ' ) ; } if ( 'OK ' ! = = $ response - > status ) { throw new Invalid Api Response Exception ( sprintf ( 'Google returned status code " %s " . ' , $ response - > status ) ) ; } return $ response ; } 
public function get Access Token ( ) { $ client = new Client ( array ( 'base _uri ' = > 'https : / /api .weixin .qq .com ' , ) ) ; $ api Raw Response = $ client - > get ( ' /cgi -bin /token ' , array ( 'query ' = > array ( 'grant _type ' = > 'client _credential ' , 'appid ' = > $ this - > appid , 'secret ' = > $ this - > appsecret , ) , ) ) ; $ response = json _decode ( $ api Raw Response - > get Body ( ) - > get Contents ( ) ) ; if ( null = = = $ response ) { throw new Invalid Api Response Exception ( 'Wechat response is probably mal -formed because cannot be json -decoded . ' ) ; } if ( property _exists ( $ response , 'errcode ' ) ) { throw new Invalid Api Response Exception ( sprintf ( 'Wecaht returned status code " %s " with message " %s " . ' , property _exists ( $ response , 'errcode ' ) ? $ response - > errcode : ' ' , property _exists ( $ response , 'errmsg ' ) ? $ response - > errmsg : ' ' ) ) ; } return $ response - > access _token ; } 
public function shorten ( Link Interface $ link ) { $ client = $ this - > create Client ( ) ; $ response = $ client - > post ( ' /admin /create ' , array _merge ( array ( 'json ' = > array ( 'url ' = > $ link - > get Long Url ( ) , ) , ) , $ this - > options ) ) ; $ response = $ this - > validate ( $ response - > get Body ( ) - > get Contents ( ) , true ) ; $ link - > set Short Url ( $ response - > Short Url ) ; } 
public function expand ( Link Interface $ link ) { $ client = $ this - > create Client ( ) ; $ response = $ client - > post ( ' /admin /query ' , array _merge ( array ( 'json ' = > array ( 'short Url ' = > $ link - > get Short Url ( ) , ) , ) , $ this - > options ) ) ; $ response = $ this - > validate ( $ response - > get Body ( ) - > get Contents ( ) , true ) ; $ link - > set Long Url ( $ response - > Long Url ) ; } 
private function validate ( $ api Raw Response , $ check Status = false ) { $ response = json _decode ( $ api Raw Response ) ; if ( null = = = $ response ) { throw new Invalid Api Response Exception ( 'Baidu response is probably mal -formed because cannot be json -decoded . ' ) ; } if ( ! $ check Status ) { return $ response ; } if ( ! property _exists ( $ response , 'Code ' ) ) { throw new Invalid Api Response Exception ( 'Property "Code " does not exist within Baidu response . ' ) ; } if ( 0 ! = = $ response - > Code ) { throw new Invalid Api Response Exception ( sprintf ( 'Baidu returned code error message " %s : %s " . ' , $ response - > Code , $ response - > Err Msg ) ) ; } return $ response ; } 
public function shorten ( Link Interface $ link ) { $ client = $ this - > create Client ( ) ; $ response = $ client - > post ( sprintf ( ' /cgi -bin /shorturl ?access _token = %s ' , $ this - > auth - > get Access Token ( ) ) , array _merge ( array ( 'json ' = > array ( 'action ' = > 'long 2short ' , 'long _url ' = > $ link - > get Long Url ( ) , ) , ) , $ this - > options ) ) ; $ response = $ this - > validate ( $ response - > get Body ( ) - > get Contents ( ) ) ; $ link - > set Short Url ( $ response - > short _url ) ; } 
private function validate ( $ api Raw Response ) { $ response = json _decode ( $ api Raw Response ) ; if ( null = = = $ response ) { throw new Invalid Api Response Exception ( 'Wechat response is probably mal -formed because cannot be json -decoded . ' ) ; } if ( ! property _exists ( $ response , 'errcode ' ) ) { throw new Invalid Api Response Exception ( 'Property "errcode " does not exist within Wechat response . ' ) ; } if ( 0 ! = = $ response - > errcode ) { throw new Invalid Api Response Exception ( sprintf ( 'Wechat returned status code " %s " with message " %s " ' , $ response - > errcode , property _exists ( $ response , 'errmsg ' ) ? $ response - > errmsg : ' ' ) ) ; } return $ response ; } 
protected function execute ( Input Interface $ input , Output Interface $ output ) { $ link = new Link ( ) ; $ link - > set Long Url ( $ input - > get Argument ( 'long -url ' ) ) ; $ options = $ input - > get Option ( 'options ' ) ? json _decode ( $ input - > get Option ( 'options ' ) , true ) : array ( ) ; $ provider = new Baidu Provider ( $ options ) ; try { $ provider - > shorten ( $ link ) ; $ output - > writeln ( sprintf ( ' <info >Success : < /info > %s ' , $ link - > get Short Url ( ) ) ) ; } catch ( \ Exception $ e ) { $ output - > writeln ( sprintf ( ' <error >Failure : < /error > %s ' , $ e - > get Message ( ) ) ) ; } } 
public function shorten ( Link Interface $ link , $ domain = null ) { $ client = $ this - > create Client ( ) ; $ response = $ client - > get ( sprintf ( ' /v 3 /shorten ?access _token = %s &long Url = %s &domain = %s ' , $ this - > auth - > get Access Token ( ) , urlencode ( $ link - > get Long Url ( ) ) , $ domain ) , $ this - > options ) ; $ response = $ this - > validate ( $ response - > get Body ( ) - > get Contents ( ) ) ; $ link - > set Short Url ( $ response - > data - > url ) ; } 
public function expand ( Link Interface $ link , $ hash = null ) { $ client = $ this - > create Client ( ) ; $ response = $ client - > get ( sprintf ( ' /v 3 /expand ?access _token = %s &short Url = %s &hash = %s ' , $ this - > auth - > get Access Token ( ) , urlencode ( $ link - > get Short Url ( ) ) , $ hash ) , $ this - > options ) ; $ response = $ this - > validate ( $ response - > get Body ( ) - > get Contents ( ) ) ; $ link - > set Long Url ( $ response - > data - > expand [ 0 ] - > long _url ) ; } 
private function validate ( $ api Raw Response ) { $ response = json _decode ( $ api Raw Response ) ; if ( null = = = $ response ) { throw new Invalid Api Response Exception ( 'Bit .ly response is probably mal -formed because cannot be json -decoded . ' ) ; } if ( ! property _exists ( $ response , 'status _code ' ) ) { throw new Invalid Api Response Exception ( 'Property "status _code " does not exist within Bit .ly response . ' ) ; } if ( 2 0 0 ! = = $ response - > status _code ) { throw new Invalid Api Response Exception ( sprintf ( 'Bit .ly returned status code " %s " with message " %s " ' , $ response - > status _code , property _exists ( $ response , 'status _txt ' ) ? $ response - > status _txt : ' ' ) ) ; } return $ response ; } 
public function find One By Provider And Short Url ( $ provider Name , $ short Url ) { $ provider = $ this - > chain Provider - > get Provider ( $ provider Name ) ; $ link = $ this - > create ( ) ; $ link - > set Provider Name ( $ provider - > get Name ( ) ) ; $ link - > set Short Url ( $ short Url ) ; $ provider - > expand ( $ link ) ; return $ link ; } 
public function find One By Provider And Long Url ( $ provider Name , $ long Url ) { $ provider = $ this - > chain Provider - > get Provider ( $ provider Name ) ; $ link = $ this - > create ( ) ; $ link - > set Provider Name ( $ provider - > get Name ( ) ) ; $ link - > set Long Url ( $ long Url ) ; $ provider - > shorten ( $ link ) ; return $ link ; } 
public function shorten ( Link Interface $ link ) { $ client = $ this - > create Client ( ) ; $ response = $ client - > get ( 'shorten .json ' , array _merge ( array ( 'query ' = > array ( 'source ' = > $ this - > api Key , 'url _long ' = > $ link - > get Long Url ( ) , ) , ) , $ this - > options ) ) ; $ response = $ this - > validate ( $ response - > get Body ( ) - > get Contents ( ) ) ; $ link - > set Short Url ( $ response - > urls [ 0 ] - > url _short ) ; } 
public function expand ( Link Interface $ link ) { $ client = $ this - > create Client ( ) ; $ response = $ client - > get ( 'expand .json ' , array _merge ( array ( 'query ' = > array ( 'source ' = > $ this - > api Key , 'url _short ' = > $ link - > get Short Url ( ) , ) , ) , $ this - > options ) ) ; $ response = $ this - > validate ( $ response - > get Body ( ) - > get Contents ( ) ) ; $ link - > set Long Url ( $ response - > urls [ 0 ] - > url _long ) ; } 
private function validate ( $ api Raw Response ) { $ response = json _decode ( $ api Raw Response ) ; if ( null = = = $ response ) { throw new Invalid Api Response Exception ( 'Sina response is probably mal -formed because cannot be json -decoded . ' ) ; } if ( property _exists ( $ response , 'error ' ) ) { throw new Invalid Api Response Exception ( sprintf ( 'Sina returned status code " %s " with message " %s " . ' , property _exists ( $ response , 'error _code ' ) ? $ response - > error _code : ' ' , property _exists ( $ response , 'error ' ) ? $ response - > error : ' ' ) ) ; } if ( property _exists ( $ response , 'urls ' ) ) { if ( empty ( $ response - > urls [ 0 ] - > url _long ) ) { throw new Invalid Api Response Exception ( 'Property "long Url " does not exist within Sina response . ' ) ; } } return $ response ; } 
protected function execute ( Input Interface $ input , Output Interface $ output ) { $ link = new Link ( ) ; $ link - > set Short Url ( $ input - > get Argument ( 'short -url ' ) ) ; $ options = $ input - > get Option ( 'options ' ) ? json _decode ( $ input - > get Option ( 'options ' ) , true ) : array ( ) ; $ provider = new Bitly Provider ( new OAuth Client ( $ input - > get Argument ( 'username ' ) , $ input - > get Argument ( 'password ' ) ) , $ options ) ; try { $ provider - > expand ( $ link ) ; $ output - > writeln ( sprintf ( ' <info >Success : < /info > %s ' , $ link - > get Long Url ( ) ) ) ; } catch ( \ Exception $ e ) { $ output - > writeln ( sprintf ( ' <error >Failure : < /error > %s ' , $ e - > get Message ( ) ) ) ; } } 
public function get Provider ( $ name ) { if ( ! $ this - > has Provider ( $ name ) ) { throw new \ Runtime Exception ( sprintf ( 'Unable to retrieve the provider named : " %s " ' , $ name ) ) ; } return $ this - > providers [ $ name ] ; } 
public function get Config Tree Builder ( ) { $ builder = new Tree Builder ( 'sb _json _request ' ) ; if ( \ method _exists ( $ builder , 'get Root Node ' ) ) { $ root Node = $ builder - > get Root Node ( ) ; } else { 
public function on Kernel Request ( Get Response Event $ event ) { $ request = $ event - > get Request ( ) ; if ( false = = = $ this - > is Available ( $ request ) ) { return ; } if ( false = = = $ this - > transform ( $ request ) ) { $ response = Response : : create ( 'Unable to parse request . ' , 4 0 0 ) ; $ event - > set Response ( $ response ) ; } } 
private function transform ( Request $ request ) { $ data = json _decode ( $ request - > get Content ( ) , true ) ; if ( json _last _error ( ) ! = = JSON _ERROR _NONE ) { return false ; } if ( is _array ( $ data ) ) { $ request - > request - > replace ( $ data ) ; } return true ; } 
protected function load Internal ( array $ configs , Container Builder $ container ) { $ listener = new Definition ( $ configs [ 'listener ' ] [ 'request _transformer ' ] ) ; $ listener - > add Tag ( 'kernel .event _listener ' , [ 'event ' = > 'kernel .request ' , 'method ' = > 'on Kernel Request ' , 'priority ' = > $ configs [ 'listener ' ] [ 'priority ' ] , ] ) ; $ container - > set Definition ( 'sb _json _request .request _transformer ' , $ listener ) ; } 
public function handle ( Request $ request , Closure $ next ) { 
public function get Details ( $ ip _address = null ) { $ response _details = $ this - > get Request Details ( ( string ) $ ip _address ) ; return $ this - > format Details Object ( $ response _details ) ; } 
public function format Details Object ( $ details = [ ] ) { $ country = $ details [ 'country ' ] ? ? null ; $ details [ 'country _name ' ] = $ this - > countries [ $ country ] ? ? null ; if ( array _key _exists ( 'loc ' , $ details ) ) { $ coords = explode ( ' , ' , $ details [ 'loc ' ] ) ; $ details [ 'latitude ' ] = $ coords [ 0 ] ; $ details [ 'longitude ' ] = $ coords [ 1 ] ; } else { $ details [ 'latitude ' ] = null ; $ details [ 'longitude ' ] = null ; } return new Details ( $ details ) ; } 
public function get Request Details ( string $ ip _address ) { if ( ! $ this - > cache - > has ( $ ip _address ) ) { $ url = self : : API _URL ; if ( $ ip _address ) { $ url . = " / $ip _address " ; } try { $ response = $ this - > http _client - > request ( self : : REQUEST _TYPE _GET , $ url , $ this - > build Headers ( ) ) ; } catch ( Guzzle Exception $ e ) { throw new IPinfo Exception ( $ e - > get Message ( ) ) ; } catch ( Exception $ e ) { throw new IPinfo Exception ( $ e - > get Message ( ) ) ; } if ( $ response - > get Status Code ( ) = = self : : STATUS _CODE _QUOTA _EXCEEDED ) { throw new IPinfo Exception ( 'IPinfo request quota exceeded . ' ) ; } elseif ( $ response - > get Status Code ( ) > = 4 0 0 ) { throw new IPinfo Exception ( 'Exception : ' . json _encode ( [ 'status ' = > $ response - > get Status Code ( ) , 'reason ' = > $ response - > get Reason Phrase ( ) , ] ) ) ; } $ raw _details = json _decode ( $ response - > get Body ( ) , true ) ; $ this - > cache - > set ( $ ip _address , $ raw _details ) ; } return $ this - > cache - > get ( $ ip _address ) ; } 
public function set ( string $ name , $ value ) { if ( ! $ this - > cache - > has ( $ name ) ) { $ this - > element _queue [ ] = $ name ; } $ this - > cache - > set ( $ name , $ value , $ this - > ttl ) ; $ this - > manage Size ( ) ; } 
private function manage Size ( ) { $ overflow = count ( $ this - > element _queue ) - $ this - > maxsize ; if ( $ overflow > 0 ) { foreach ( array _slice ( $ this - > element _queue , 0 , $ overflow ) as $ name ) { if ( $ this - > cache - > has ( $ name ) ) { $ this - > cache - > delete ( $ name ) ; } } $ this - > element _queue = array _slice ( $ this - > element _queue , $ overflow ) ; } } 
public function _get Public Data ( ) { $ response = $ this - > get Properties From Response ( ) ; $ result = array ( ) ; if ( isset ( $ response [ 'type ' ] ) & & $ response [ 'type ' ] = = 'Error ' ) { $ result = array ( 'success ' = > 0 , 'error ' = > array ( 'message ' = > $ response [ 'error ' ] , 'code ' = > $ response [ 'code ' ] ) ) ; } elseif ( ! empty ( $ response [ 'secure ' ] ) ) { $ result = array ( 'success ' = > 0 , 'secure ' = > $ response [ 'secure ' ] ) ; } elseif ( $ this - > is Successful ( ) ) { $ result [ 'success ' ] = 1 ; } else { $ result = array ( 'success ' = > 0 , 'error ' = > array ( 'message ' = > 'Internal error ' ) ) ; } return $ result ; } 
public function post ( $ params = array ( ) , $ headers = array ( ) ) { if ( empty ( $ params ) ) { return null ; } $ this - > http Action - > set Api Params ( $ params ) ; $ this - > http Action - > set Api Headers ( array _merge ( array ( $ this - > get Api Base Header ( ) ) , $ headers ) ) ; return ( array ) $ this - > prepare Properties From Response ( $ this - > http Action - > post ( $ this - > get Api Url ( ) ) ) ; } 
public function offset Set ( $ offset , $ value ) { $ tx Key = isset ( $ this - > attribute Map [ $ offset ] ) ? $ this - > attribute Map [ $ offset ] : null ; if ( is _array ( $ tx Key ) ) { $ checked Value = ( $ value ) ? ( string ) $ value : ' ' ; $ is Hex = $ this - > util - > is Hex ( $ checked Value ) ; $ checked Value = $ this - > util - > strip Zero ( $ checked Value ) ; if ( ! isset ( $ tx Key [ 'allow Less ' ] ) | | ( isset ( $ tx Key [ 'allow Less ' ] ) & & $ tx Key [ 'allow Less ' ] = = = false ) ) { / / check length if ( isset ( $ tx Key [ 'length ' ] ) ) { if ( $ is Hex ) { if ( strlen ( $ checked Value ) > $ tx Key [ 'length ' ] * 2 ) { throw new Invalid Argument Exception ( $ offset . ' exceeds the length limit . ' ) ; } } else { if ( strlen ( $ checked Value ) > $ tx Key [ 'length ' ] ) { throw new Invalid Argument Exception ( $ offset . ' exceeds the length limit . ' ) ; } } } } if ( ! isset ( $ tx Key [ 'allow Zero ' ] ) | | ( isset ( $ tx Key [ 'allow Zero ' ] ) & & $ tx Key [ 'allow Zero ' ] = = = false ) ) { / / check zero if ( preg _match ( ' / ^ 0 * $ / ' , $ checked Value ) = = = 1 ) { / / set value to empty string $ value = ' ' ; } } $ this - > tx Data [ $ tx Key [ 'key ' ] ] = $ value ; } } 
public function offset Exists ( $ offset ) { $ tx Key = isset ( $ this - > attribute Map [ $ offset ] ) ? $ this - > attribute Map [ $ offset ] : null ; if ( is _array ( $ tx Key ) ) { return isset ( $ this - > tx Data [ $ tx Key [ 'key ' ] ] ) ; } return false ; } 
public function offset Get ( $ offset ) { $ tx Key = isset ( $ this - > attribute Map [ $ offset ] ) ? $ this - > attribute Map [ $ offset ] : null ; if ( is _array ( $ tx Key ) & & isset ( $ this - > tx Data [ $ tx Key [ 'key ' ] ] ) ) { return $ this - > tx Data [ $ tx Key [ 'key ' ] ] ; } return null ; } 
public function serialize ( ) { $ chain Id = $ this - > offset Get ( 'chain Id ' ) ; / / sort tx data if ( ksort ( $ this - > tx Data ) ! = = true ) { throw new Runtime Exception ( 'Cannot sort tx data by keys . ' ) ; } if ( $ chain Id & & $ chain Id > 0 ) { $ tx Data = array _fill ( 0 , 9 , ' ' ) ; } else { $ tx Data = array _fill ( 0 , 6 , ' ' ) ; } foreach ( $ this - > tx Data as $ key = > $ data ) { if ( $ key > = 0 ) { $ tx Data [ $ key ] = $ data ; } } return $ this - > rlp - > encode ( $ tx Data ) ; } 
public function sign ( string $ private Key ) { $ tx Hash = $ this - > hash ( false ) ; $ private Key = $ this - > secp 2 5 6k 1 - > key From Private ( $ private Key , 'hex ' ) ; $ signature = $ private Key - > sign ( $ tx Hash , [ 'canonical ' = > true ] ) ; $ r = $ signature - > r ; $ s = $ signature - > s ; $ v = $ signature - > recovery Param + 3 5 ; $ chain Id = $ this - > offset Get ( 'chain Id ' ) ; if ( $ chain Id & & $ chain Id > 0 ) { $ v + = ( int ) $ chain Id * 2 ; } $ this - > offset Set ( 'r ' , ' 0x ' . $ r - > to String ( 1 6 ) ) ; $ this - > offset Set ( 's ' , ' 0x ' . $ s - > to String ( 1 6 ) ) ; $ this - > offset Set ( 'v ' , $ v ) ; $ this - > private Key = $ private Key ; return $ this - > serialize ( ) - > to String ( 'hex ' ) ; } 
public function hash ( $ include Signature = false ) { $ chain Id = $ this - > offset Get ( 'chain Id ' ) ; / / sort tx data if ( ksort ( $ this - > tx Data ) ! = = true ) { throw new Runtime Exception ( 'Cannot sort tx data by keys . ' ) ; } if ( $ include Signature ) { $ tx Data = $ this - > tx Data ; } else { $ raw Tx Data = $ this - > tx Data ; if ( $ chain Id & & $ chain Id > 0 ) { $ v = ( int ) $ chain Id ; $ this - > offset Set ( 'r ' , ' ' ) ; $ this - > offset Set ( 's ' , ' ' ) ; $ this - > offset Set ( 'v ' , $ v ) ; $ tx Data = array _fill ( 0 , 9 , ' ' ) ; } else { $ tx Data = array _fill ( 0 , 6 , ' ' ) ; } foreach ( $ this - > tx Data as $ key = > $ data ) { if ( $ key > = 0 ) { $ tx Data [ $ key ] = $ data ; } } $ this - > tx Data = $ raw Tx Data ; } $ serialized Tx = $ this - > rlp - > encode ( $ tx Data ) - > to String ( 'utf 8 ' ) ; return $ this - > util - > sha 3 ( $ serialized Tx ) ; } 
public function get From Address ( ) { $ from = $ this - > offset Get ( 'from ' ) ; if ( $ from ) { return $ from ; } if ( ! isset ( $ this - > private Key ) | | ! ( $ this - > private Key instanceof Key Pair ) ) { / / recover from hash $ r = $ this - > offset Get ( 'r ' ) ; $ s = $ this - > offset Get ( 's ' ) ; $ v = $ this - > offset Get ( 'v ' ) ; $ chain Id = $ this - > offset Get ( 'chain Id ' ) ; if ( ! $ r | | ! $ s ) { throw new Runtime Exception ( 'Invalid signature r and s . ' ) ; } $ tx Hash = $ this - > hash ( false ) ; if ( $ chain Id & & $ chain Id > 0 ) { $ v - = ( $ chain Id * 2 ) ; } $ v - = 3 5 ; $ public Key = $ this - > secp 2 5 6k 1 - > recover Pub Key ( $ tx Hash , [ 'r ' = > $ r , 's ' = > $ s ] , $ v ) ; $ public Key = $ public Key - > encode ( 'hex ' ) ; } else { $ public Key = $ this - > private Key - > get Public ( false , 'hex ' ) ; } $ from = ' 0x ' . substr ( $ this - > util - > sha 3 ( substr ( hex 2bin ( $ public Key ) , 1 ) ) , 2 4 ) ; $ this - > offset Set ( 'from ' , $ from ) ; return $ from ; } 
public static function error Html ( $ e , $ header , $ debug = TRUE ) { $ pattern = [ ' / \ { \ {title \ } \ } / ' , ' / \ { \ {header \ } \ } / ' , ' / \ { \ {exception \ } \ } / ' , ] ; $ title = $ header ; $ exception = $ debug ? $ e : 'something error . . . ' ; $ replacement = [ $ title , $ header , $ exception ] ; return preg _replace ( $ pattern , $ replacement , self : : $ _html _blade ) ; } 
public static function run ( array $ middlewares , Requests $ request ) { 
public static function _ _callstatic ( $ method , $ params ) { 
public static function group ( array $ filter , Closure $ routes ) { 
protected static function _path Parse ( $ path ) { 
protected static function _is Variable Route ( $ path ) { $ matched = [ ] ; preg _match _all ( self : : $ _variable _regexp , $ path , $ matched ) ; if ( empty ( $ matched [ 0 ] ) ) { return FALSE ; } return TRUE ; } 
protected static function _variable Path Parse ( $ path , $ method ) { 
protected static function _variable Route Cache Control ( $ value ) { 
protected static function _set Map Tree ( $ method , $ path , $ content ) { $ path = self : : _path Parse ( self : : $ _filter [ 'prefix ' ] . $ path ) ; $ callback = is _string ( $ content ) ? self : : _namespace Parse ( ' \ \ ' . self : : $ _filter [ 'namespace ' ] . $ content ) : $ content ; if ( self : : _is Variable Route ( $ path ) ) { 
protected static function _get Redirect Url ( $ path , $ param ) { $ base _url = rtrim ( Config : : get ( 'app .base _url ' ) , ' / ' ) ; $ path = self : : _path Parse ( $ path ) ; $ url = $ base _url . $ path . ' ? ' . http _build _query ( $ param ) ; return $ url ; } 
protected static function _check Middleware ( Requests $ request , $ middleware _symbols ) { 
protected static function _run Dispatch ( Requests $ request , $ callback , $ middleware _symbols , $ params = [ ] ) { 
public static function dispatch ( Requests $ request ) { 
public static function redirect ( $ path , $ param = [ ] ) { $ url = self : : _get Redirect Url ( $ path , $ param ) ; return Response : : redirect ( $ url ) ; } 
public static function init ( array $ db _confs ) { 
protected function _connect ( ) { extract ( $ this - > _config , EXTR _SKIP ) ; $ dsn = isset ( $ unix _socket ) ? 'mysql :unix _socket = ' . $ unix _socket . ' ;dbname = ' . $ dbname : 'mysql :dbname = ' . $ dbname . ' ;host = ' . $ host . ( isset ( $ port ) ? ' ;port = ' . $ port : ' ' ) ; $ options = isset ( $ options ) ? $ options + $ this - > _options : $ this - > _options ; try { $ this - > _pdo = new PDO ( $ dsn , $ user , $ password , $ options ) ; 
public static function dot Get ( $ array , $ key , $ default = NULL ) { if ( is _null ( $ key ) ) { return $ array ; } if ( isset ( $ array [ $ key ] ) ) { return $ array [ $ key ] ; } foreach ( explode ( ' . ' , $ key ) as $ segment ) { if ( ! is _array ( $ array ) | | ! array _key _exists ( $ segment , $ array ) ) { return $ default ; } $ array = $ array [ $ segment ] ; } return $ array ; } 
public static function dot Has ( $ array , $ key ) { if ( empty ( $ array ) | | is _null ( $ key ) ) { return FALSE ; } if ( array _key _exists ( $ key , $ array ) ) { return TRUE ; } foreach ( explode ( ' . ' , $ key ) as $ segment ) { if ( ! is _array ( $ array ) | | ! array _key _exists ( $ segment , $ array ) ) { return FALSE ; } $ array = $ array [ $ segment ] ; } return TRUE ; } 
public static function header ( $ headers ) { if ( is _array ( $ headers ) ) { 
public static function get Header ( $ key ) { if ( ! array _key _exists ( $ key , Http Cache : : $ header ) ) { return NULL ; } return Http Cache : : $ header [ $ key ] ; } 
protected function _connect ( ) { extract ( $ this - > _config , EXTR _SKIP ) ; $ dsn = 'pgsql :dbname = ' . $ dbname . ( isset ( $ host ) ? ' ;host = ' . $ host : ' ' ) . ( isset ( $ port ) ? ' ;port = ' . $ port : ' ' ) . ( isset ( $ sslmode ) ? ' ;sslmode = ' . $ sslmode : ' ' ) ; $ options = isset ( $ options ) ? $ options + $ this - > _options : $ this - > _options ; try { $ this - > _pdo = new PDO ( $ dsn , $ user , $ password , $ options ) ; 
public function insert Get Last Id ( array $ data ) { 
protected function _connect ( ) { extract ( $ this - > _config , EXTR _SKIP ) ; if ( $ dbname = = ' :memory : ' ) { $ dsn = 'sqlite : :memory : ' ; } else { $ path = realpath ( $ dbname ) ; if ( $ path = = = FALSE ) { throw new \ Invalid Argument Exception ( "Database $dbname does not exist . " ) ; } $ dsn = 'sqlite : ' . $ path ; } $ options = isset ( $ options ) ? $ options + $ this - > _options : $ this - > _options ; try { $ this - > _pdo = new PDO ( $ dsn , ' ' , ' ' , $ options ) ; } catch ( PDOException $ e ) { throw $ e ; } } 
protected static function _get Di Params ( array $ params ) { $ di _params = [ ] ; foreach ( $ params as $ param ) { $ class = $ param - > get Class ( ) ; if ( $ class ) { 
public static function singleton ( $ instance , $ name = NULL ) { if ( ! is _object ( $ instance ) ) { throw new \ Invalid Argument Exception ( "Object need ! " ) ; } $ class _name = $ name = = NULL ? get _class ( $ instance ) : $ name ; 
public static function get Singleton ( $ class _name ) { return array _key _exists ( $ class _name , self : : $ _singleton ) ? self : : $ _singleton [ $ class _name ] : NULL ; } 
public static function register ( $ abstract , $ concrete = NULL ) { if ( $ concrete = = NULL ) { $ instance = self : : get Instance ( $ abstract ) ; self : : singleton ( $ instance ) ; } else { $ instance = self : : get Instance ( $ concrete ) ; self : : singleton ( $ instance , $ abstract ) ; } } 
public static function get Instance ( $ class _name ) { 
public static function get Instance With Singleton ( $ class _name ) { 
public static function run ( $ class _name , $ method , $ params = [ ] ) { 
public static function run ( Tcp Connection $ con ) { try { 
public static function init ( ) { try { 
public static function register ( ) { 
public function pipe ( $ pipe ) { if ( FALSE = = = is _callable ( $ pipe ) ) { throw new Invalid Argument Exception ( 'pipe should be callable . ' ) ; } $ this - > _pipes [ ] = $ pipe ; return $ this ; } 
public function flow ( $ payload ) { foreach ( $ this - > _pipes as $ pipe ) { 
public static function init ( array $ rd _confs ) { 
public static function subscribe ( $ channels , Closure $ callback , $ connection = 'default ' , $ method = 'subscribe ' ) { $ loop = self : : $ _clients [ $ connection ] - > pub Sub Loop ( ) ; call _user _func _array ( [ $ loop , $ method ] , ( array ) $ channels ) ; 
public static function psubscribe ( $ channels , Closure $ callback , $ connection = 'default ' ) { return self : : subscribe ( $ channels , $ callback , $ connection , 'psubscribe ' ) ; } 
protected function _connect ( ) { extract ( $ this - > _config , EXTR _SKIP ) ; $ dsn = 'mysql :dbname = ' . $ dbname . ' ;host = ' . $ host . ' ;port = ' . $ port ; $ options = isset ( $ options ) ? $ options + $ this - > _options : $ this - > _options ; try { $ this - > _pdo = new PDO ( $ dsn , $ user , $ password , $ options ) ; } catch ( PDOException $ e ) { throw $ e ; } } 
protected function _reset ( ) { $ this - > _table = ' ' ; $ this - > _prepare _sql = ' ' ; $ this - > _cols _str = ' * ' ; $ this - > _where _str = ' ' ; $ this - > _orderby _str = ' ' ; $ this - > _groupby _str = ' ' ; $ this - > _having _str = ' ' ; $ this - > _join _str = ' ' ; $ this - > _limit _str = ' ' ; $ this - > _insert _str = ' ' ; $ this - > _update _str = ' ' ; $ this - > _bind _params = [ ] ; } 
protected function _reset Build Attr ( ) { $ this - > _table = ' ' ; $ this - > _prepare _sql = ' ' ; $ this - > _cols _str = ' * ' ; $ this - > _where _str = ' ' ; $ this - > _orderby _str = ' ' ; $ this - > _groupby _str = ' ' ; $ this - > _having _str = ' ' ; $ this - > _join _str = ' ' ; $ this - > _limit _str = ' ' ; } 
protected function _wrap Prepare Sql ( ) { 
protected function _execute ( ) { try { $ this - > _wrap Prepare Sql ( ) ; $ this - > _pdo St = $ this - > _pdo - > prepare ( $ this - > _prepare _sql ) ; $ this - > _bind Params ( ) ; $ this - > _pdo St - > execute ( ) ; $ this - > _reset ( ) ; 
protected function _bind Params ( ) { if ( is _array ( $ this - > _bind _params ) ) { foreach ( $ this - > _bind _params as $ plh = > $ param ) { $ data _type = PDO : : PARAM _STR ; if ( is _numeric ( $ param ) ) { $ data _type = PDO : : PARAM _INT ; } if ( is _null ( $ param ) ) { $ data _type = PDO : : PARAM _NULL ; } if ( is _bool ( $ param ) ) { $ data _type = PDO : : PARAM _BOOL ; } $ this - > _pdo St - > bind Value ( $ plh , $ param , $ data _type ) ; } } } 
protected function _wrap Table ( $ table ) { $ prefix = array _key _exists ( 'prefix ' , $ this - > _config ) ? $ this - > _config [ 'prefix ' ] : ' ' ; return $ prefix . $ table ; } 
protected static function _wrap Row ( $ str ) { 
protected function _condition _constructor ( $ args _num , $ params , & $ construct _str ) { 
protected function _store Build Attr ( ) { 
protected function _re Store Build Attr ( array $ data ) { foreach ( $ this - > _build Attrs as $ build Attr ) { $ this - > $ build Attr = $ data [ $ build Attr ] ; } } 
protected function _sub Builder ( Closure $ callback ) { 
public function table ( $ table ) { $ this - > _table = self : : _wrap Row ( $ this - > _wrap Table ( $ table ) ) ; return $ this ; } 
public function select ( ) { $ cols = func _get _args ( ) ; if ( ! func _num _args ( ) | | in _array ( ' * ' , $ cols ) ) { $ this - > _cols _str = ' * ' ; } else { 
public function where ( ) { $ operator = 'AND ' ; 
public function or Where ( ) { $ operator = 'OR ' ; 
public function where In ( $ field , array $ data , $ condition = 'IN ' , $ operator = 'AND ' ) { if ( ! in _array ( $ condition , [ 'IN ' , 'NOT IN ' ] ) | | ! in _array ( $ operator , [ 'AND ' , 'OR ' ] ) ) { throw new \ Invalid Argument Exception ( "Error where In mode " ) ; } 
public function where Between ( $ field , $ start , $ end , $ operator = 'AND ' ) { if ( ! in _array ( $ operator , [ 'AND ' , 'OR ' ] ) ) { throw new \ Invalid Argument Exception ( "Logical operator " ) ; } 
public function where Null ( $ field , $ condition = 'NULL ' , $ operator = 'AND ' ) { if ( ! in _array ( $ condition , [ 'NULL ' , 'NOT NULL ' ] ) | | ! in _array ( $ operator , [ 'AND ' , 'OR ' ] ) ) { throw new \ Invalid Argument Exception ( "Logical operator " ) ; } 
public function where Brackets ( Closure $ callback , $ operator = 'AND ' ) { if ( ! in _array ( $ operator , [ 'AND ' , 'OR ' ] ) ) { throw new \ Invalid Argument Exception ( "Logical operator " ) ; } 
public function where Exists ( Closure $ callback , $ condition = 'EXISTS ' , $ operator = 'AND ' ) { if ( ! in _array ( $ condition , [ 'EXISTS ' , 'NOT EXISTS ' ] ) | | ! in _array ( $ operator , [ 'AND ' , 'OR ' ] ) ) { throw new \ Invalid Argument Exception ( "Error where Exists mode " ) ; } 
public function where In Sub ( $ field , Closure $ callback , $ condition = 'IN ' , $ operator = 'AND ' ) { if ( ! in _array ( $ condition , [ 'IN ' , 'NOT IN ' ] ) | | ! in _array ( $ operator , [ 'AND ' , 'OR ' ] ) ) { throw new \ Invalid Argument Exception ( "Error where In mode " ) ; } 
public function group By ( $ field ) { 
public function having ( ) { $ operator = 'AND ' ; 
public function or Having ( ) { $ operator = 'OR ' ; 
public function order By ( $ field , $ mode = 'ASC ' ) { $ mode = strtoupper ( $ mode ) ; if ( ! in _array ( $ mode , [ 'ASC ' , 'DESC ' ] ) ) { throw new \ Invalid Argument Exception ( "Error order by mode " ) ; } 
public function join ( $ table , $ one , $ two , $ type = 'INNER ' ) { if ( ! in _array ( $ type , [ 'INNER ' , 'LEFT ' , 'RIGHT ' ] ) ) { throw new \ Invalid Argument Exception ( "Error join mode " ) ; } 
public function from Sub ( Closure $ callback ) { $ sub _attr = $ this - > _sub Builder ( $ callback ) ; $ this - > _table . = ' ( ' . $ sub _attr [ ' _prepare _sql ' ] . ' ) AS tb _ ' . uniqid ( ) . ' ' ; return $ this ; } 
public function paginate ( $ step , $ page = NULL ) { 
public function get ( ) { $ this - > _build Query ( ) ; $ this - > _execute ( ) ; return $ this - > _pdo St - > fetch All ( PDO : : FETCH _ASSOC ) ; } 
public function row ( ) { $ this - > _build Query ( ) ; $ this - > _execute ( ) ; return $ this - > _pdo St - > fetch ( PDO : : FETCH _ASSOC ) ; } 
public function get List ( $ field ) { $ this - > _cols _str = ' ' . self : : _quote ( $ field ) . ' ' ; $ this - > _build Query ( ) ; $ this - > _execute ( ) ; return $ this - > _pdo St - > fetch All ( PDO : : FETCH _COLUMN , 0 ) ; } 
public function count ( $ field = ' * ' ) { if ( trim ( $ field ) ! = ' * ' ) { $ field = self : : _quote ( $ field ) ; } $ this - > _cols _str = ' COUNT ( ' . $ field . ' ) AS count _num ' ; return $ this - > row ( ) [ 'count _num ' ] ; } 
public function insert ( array $ data ) { 
public function update ( array $ data ) { 
public function delete ( ) { 
public function query ( $ sql ) { try { return $ this - > _pdo - > query ( $ sql ) ; } catch ( PDOException $ e ) { 
public function prepare ( $ sql , array $ driver _options = [ ] ) { try { return $ this - > _pdo - > prepare ( $ sql , $ driver _options ) ; } catch ( PDOException $ e ) { 
public function begin Trans ( ) { try { return $ this - > _pdo - > begin Transaction ( ) ; } catch ( PDOException $ e ) { 
public function handle ( \ Exception $ e ) { $ http Code = 5 0 0 ; 
public function generate Id ( $ size = 0 , $ mode = self : : MODE _NORMAL ) { $ size = $ size > 0 ? $ size : $ this - > size ; switch ( $ mode ) { case self : : MODE _DYNAMIC : return $ this - > core - > random ( $ this - > generator , $ size ) ; default : return $ this - > normal Random ( $ size ) ; } } 
public function formated Id ( $ alphabet , $ size , Generator Interface $ generator = null ) { $ generator = $ generator ? : $ this - > generator ; $ alphabet = $ alphabet ? : Core Interface : : SAFE _SYMBOLS ; return $ this - > core - > random ( $ generator , $ size , $ alphabet ) ; } 
private function normal Random ( $ size ) { $ id = ' ' ; while ( 1 < = $ size - - ) { $ rand = mt _rand ( ) / ( mt _getrandmax ( ) + 1 ) ; $ id . = $ this - > alphbet [ $ rand * 6 4 | 0 ] ; } return $ id ; } 
public function load Configuration ( ) : void { $ builder = $ this - > get Container Builder ( ) ; $ config = $ this - > validate Config ( $ this - > defaults ) ; 
public function before Compile ( ) : void { $ builder = $ this - > get Container Builder ( ) ; $ config = $ this - > validate Config ( $ this - > defaults ) ; 
public static function normalize DSN ( $ dsn , $ user = null , $ pass = null ) { 
public static function connect ( $ dsn , $ user = null , $ password = null , $ args = [ ] ) { 
public function dsql ( $ properties = [ ] ) { $ c = $ this - > query _class ; $ q = new $ c ( $ properties ) ; $ q - > connection = $ this ; return $ q ; } 
public function execute ( Expression $ expr ) { 
public function begin Transaction ( ) { 
public function commit ( ) { 
public function roll Back ( ) { 
public function iterate ( $ ret ) { foreach ( $ ret as $ key = > $ row ) { $ this - > rows + + ; yield $ key = > $ row ; } } 
public function execute ( Expression $ expr ) { if ( $ expr instanceof Query ) { $ this - > queries + + ; if ( $ expr - > mode = = = 'select ' | | $ expr - > mode = = = null ) { $ this - > selects + + ; } } else { $ this - > expressions + + ; } try { $ ret = parent : : execute ( $ expr ) ; } catch ( \ Exception $ e ) { if ( $ this - > callback & & is _callable ( $ this - > callback ) ) { call _user _func ( $ this - > callback , $ this - > queries , $ this - > selects , $ this - > rows , $ this - > expressions , true ) ; } else { printf ( " [ERROR ] Queries : % 3d , Selects : % 3d , Rows fetched : % 4d , Expressions % 3d \n " , $ this - > queries , $ this - > selects , $ this - > rows , $ this - > expressions ) ; } throw $ e ; } return $ this - > iterate ( $ ret ) ; } 
public function last Insert ID ( $ m = null ) { if ( $ m instanceof \ atk 4 \ data \ Model ) { 
public function execute ( Expression $ expr ) { $ this - > start _time = microtime ( true ) ; try { $ ret = parent : : execute ( $ expr ) ; $ took = microtime ( true ) - $ this - > start _time ; if ( $ this - > callback & & is _callable ( $ this - > callback ) ) { call _user _func ( $ this - > callback , $ expr , $ took , false ) ; } else { printf ( " [ % 0 2 . 6f ] %s \n " , $ took , $ expr - > get Debug Query ( ) ) ; } } catch ( \ Exception $ e ) { $ took = microtime ( true ) - $ this - > start _time ; if ( $ this - > callback & & is _callable ( $ this - > callback ) ) { call _user _func ( $ this - > callback , $ expr , $ took , true ) ; } else { printf ( " [ERROR % 0 2 . 6f ] %s \n " , $ took , $ expr - > get Debug Query ( ) ) ; } throw $ e ; } return $ ret ; } 
public function _render _limit ( ) { if ( isset ( $ this - > args [ 'limit ' ] ) ) { $ cnt = ( int ) $ this - > args [ 'limit ' ] [ 'cnt ' ] ; $ shift = ( int ) $ this - > args [ 'limit ' ] [ 'shift ' ] ; return ' ' . trim ( ( $ shift ? 'OFFSET ' . $ shift . ' ROWS ' : ' ' ) . ' ' . 
public function expr ( $ properties = [ ] , $ arguments = null ) { 
public function reset ( $ tag = null ) { 
protected function _consume ( $ sql _code , $ escape _mode = 'param ' ) { if ( ! is _object ( $ sql _code ) ) { switch ( $ escape _mode ) { case 'param ' : return $ this - > _param ( $ sql _code ) ; case 'escape ' : return $ this - > _escape ( $ sql _code ) ; case 'soft -escape ' : return $ this - > _escape Soft ( $ sql _code ) ; case 'none ' : return $ sql _code ; } throw new Exception ( [ ' $escape _mode value is incorrect ' , 'escape _mode ' = > $ escape _mode , ] ) ; } 
protected function is Unescapable Pattern ( $ value ) { return is _object ( $ value ) | | $ value = = = ' * ' | | strpos ( $ value , ' ( ' ) ! = = false | | strpos ( $ value , $ this - > escape _char ) ! = = false ; } 
protected function _escape Soft ( $ value ) { 
protected function _escape ( $ value ) { 
protected function _param ( $ value ) { 
public function render ( ) { $ nameless _count = 0 ; if ( ! isset ( $ this - > _param Base ) ) { $ this - > _param Base = $ this - > param Base ; } if ( $ this - > template = = = null ) { throw new Exception ( 'Template is not defined for Expression ' ) ; } $ res = preg _replace _callback ( ' / \ [ [a -z 0 - 9 _ ] * \ ] | { [a -z 0 - 9 _ ] * } /i ' , function ( $ matches ) use ( & $ nameless _count ) { $ identifier = substr ( $ matches [ 0 ] , 1 , - 1 ) ; $ escaping = ( $ matches [ 0 ] [ 0 ] = = ' [ ' ) ? 'param ' : 'escape ' ; 
public function get Debug Query ( $ html = null ) { $ d = $ this - > render ( ) ; $ pp = [ ] ; foreach ( array _reverse ( $ this - > params ) as $ key = > $ val ) { if ( is _numeric ( $ val ) ) { $ d = preg _replace ( ' / ' . $ key . ' ( [ ^ _ ] | $ ) / ' , $ val . ' \ 1 ' , $ d ) ; } elseif ( is _string ( $ val ) ) { $ d = preg _replace ( ' / ' . $ key . ' ( [ ^ _ ] | $ ) / ' , " ' " . addslashes ( $ val ) . " ' \ \ 1 " , $ d ) ; } elseif ( $ val = = = null ) { $ d = preg _replace ( ' / ' . $ key . ' ( [ ^ _ ] | $ ) / ' , 'NULL \ 1 ' , $ d ) ; } else { $ d = preg _replace ( ' / ' . $ key . ' ( [ ^ _ ] | $ ) / ' , $ val . ' \ \ 1 ' , $ d ) ; } $ pp [ ] = $ key ; } if ( class _exists ( 'Sql Formatter ' ) ) { if ( $ html ) { $ result = \ Sql Formatter : : format ( $ d ) ; } else { $ result = \ Sql Formatter : : format ( $ d , false ) ; } } else { $ result = $ d ; 
public function execute ( $ connection = null ) { if ( $ connection = = = null ) { $ connection = $ this - > connection ; } 
public function get ( ) { $ stmt = $ this - > execute ( ) ; if ( $ stmt instanceof \ Generator ) { return iterator _to _array ( $ stmt ) ; } return $ stmt - > fetch All ( ) ; } 
public function get One ( ) { $ data = $ this - > get Row ( ) ; if ( ! $ data ) { throw new Exception ( [ 'Unable to fetch single cell of data for get One from this query ' , 'result ' = > $ data , 'query ' = > $ this - > get Debug Query ( ) , ] ) ; } $ one = array _shift ( $ data ) ; return $ one ; } 
public function get Row ( ) { $ stmt = $ this - > execute ( ) ; if ( $ stmt instanceof \ Generator ) { return $ stmt - > current ( ) ; } return $ stmt - > fetch ( ) ; } 
public function _render _limit ( ) { if ( isset ( $ this - > args [ 'limit ' ] ) ) { return ' limit ' . ( int ) $ this - > args [ 'limit ' ] [ 'cnt ' ] . ' offset ' . ( int ) $ this - > args [ 'limit ' ] [ 'shift ' ] ; } } 
public function field ( $ field , $ alias = null ) { 
protected function _render _field ( $ add _alias = true ) { 
public function table ( $ table , $ alias = null ) { 
protected function _render _table ( $ add _alias = true ) { 
public function join ( $ foreign _table , $ master _field = null , $ join _kind = null , $ _foreign _alias = null ) { 
public function _render _join ( ) { if ( ! isset ( $ this - > args [ 'join ' ] ) ) { return ' ' ; } $ joins = [ ] ; foreach ( $ this - > args [ 'join ' ] as $ j ) { $ jj = ' ' ; $ jj . = $ j [ 't ' ] . ' join ' ; $ jj . = $ this - > _escape ( $ j [ 'f 1 ' ] ) ; if ( $ j [ 'fa ' ] ! = = null ) { $ jj . = ' as ' . $ this - > _escape ( $ j [ 'fa ' ] ) ; } $ jj . = ' on ' ; if ( isset ( $ j [ 'expr ' ] ) ) { $ jj . = $ this - > _consume ( $ j [ 'expr ' ] ) ; } else { $ jj . = $ this - > _escape ( $ j [ 'fa ' ] ? : $ j [ 'f 1 ' ] ) . ' . ' . $ this - > _escape ( $ j [ 'f 2 ' ] ) . ' = ' . ( $ j [ 'm 1 ' ] = = = null ? ' ' : $ this - > _escape ( $ j [ 'm 1 ' ] ) . ' . ' ) . $ this - > _escape ( $ j [ 'm 2 ' ] ) ; } $ joins [ ] = $ jj ; } return ' ' . implode ( ' ' , $ joins ) ; } 
public function where ( $ field , $ cond = null , $ value = null , $ kind = 'where ' , $ num _args = null ) { 
public function having ( $ field , $ cond = null , $ value = null ) { $ num _args = func _num _args ( ) ; return $ this - > where ( $ field , $ cond , $ value , 'having ' , $ num _args ) ; } 
protected function _ _render _where ( $ kind ) { 
protected function _ _render _condition ( $ row ) { if ( count ( $ row ) = = = 3 ) { list ( $ field , $ cond , $ value ) = $ row ; } elseif ( count ( $ row ) = = = 2 ) { list ( $ field , $ cond ) = $ row ; } elseif ( count ( $ row ) = = = 1 ) { list ( $ field ) = $ row ; } $ field = $ this - > _consume ( $ field , 'soft -escape ' ) ; if ( count ( $ row ) = = 1 ) { 
public function group ( $ group ) { 
protected function _render _group ( ) { if ( ! isset ( $ this - > args [ 'group ' ] ) ) { return ' ' ; } $ g = array _map ( function ( $ a ) { return $ this - > _consume ( $ a , 'soft -escape ' ) ; } , $ this - > args [ 'group ' ] ) ; return ' group by ' . implode ( ' , ' , $ g ) ; } 
public function set ( $ field , $ value = null ) { if ( $ value = = = false ) { throw new Exception ( [ 'Value "false " is not supported by SQL ' , 'field ' = > $ field , 'value ' = > $ value , ] ) ; } if ( is _array ( $ value ) ) { throw new Exception ( [ 'Array values are not supported by SQL ' , 'field ' = > $ field , 'value ' = > $ value , ] ) ; } if ( is _array ( $ field ) ) { foreach ( $ field as $ key = > $ value ) { $ this - > set ( $ key , $ value ) ; } return $ this ; } if ( is _string ( $ field ) | | $ field instanceof Expression | | $ field instanceof Expressionable ) { $ this - > args [ 'set ' ] [ ] = [ $ field , $ value ] ; } else { throw new Exception ( [ 'Field name should be string or Expressionable ' , 'field ' = > $ field , ] ) ; } return $ this ; } 
protected function _render _set ( ) { 
protected function _render _set _fields ( ) { 
protected function _render _set _values ( ) { 
public function option ( $ option , $ mode = 'select ' ) { 
protected function _render _option ( ) { if ( ! isset ( $ this - > args [ 'option ' ] [ $ this - > mode ] ) ) { return ' ' ; } return ' ' . implode ( ' ' , $ this - > args [ 'option ' ] [ $ this - > mode ] ) ; } 
public function order ( $ order , $ desc = null ) { 
public function _render _order ( ) { if ( ! isset ( $ this - > args [ 'order ' ] ) ) { return ' ' ; } $ x = [ ] ; foreach ( $ this - > args [ 'order ' ] as $ tmp ) { list ( $ arg , $ desc ) = $ tmp ; $ x [ ] = $ this - > _consume ( $ arg , 'soft -escape ' ) . ( $ desc ? ( ' ' . $ desc ) : ' ' ) ; } return ' order by ' . implode ( ' , ' , array _reverse ( $ x ) ) ; } 
public function mode ( $ mode ) { $ prop = 'template _ ' . $ mode ; if ( isset ( $ this - > { $ prop } ) ) { $ this - > mode = $ mode ; $ this - > template = $ this - > { $ prop } ; } else { throw new Exception ( [ 'Query does not have this mode ' , 'mode ' = > $ mode , ] ) ; } return $ this ; } 
public function expr ( $ properties = [ ] , $ arguments = null ) { $ c = $ this - > expression _class ; $ e = new $ c ( $ properties , $ arguments ) ; $ e - > connection = $ this - > connection ; return $ e ; } 
public function case Expr ( $ operand = null ) { $ q = $ this - > dsql ( [ 'template ' = > ' [case ] ' ] ) ; if ( $ operand ! = = null ) { $ q - > args [ 'case _operand ' ] = $ operand ; } return $ q ; } 
protected function _render _case ( ) { if ( ! isset ( $ this - > args [ 'case _when ' ] ) ) { return ; } $ ret = ' ' ; 
public function limit ( $ cnt , $ shift = null ) { 
public function parse ( $ value ) { $ value = trim ( $ value ) ; if ( $ this - > parser - > string _helper - > starts With ( ' # ' , $ value ) ) { return null ; } return $ this - > parse Value ( $ value ) ; } 
private function parse Value ( $ value ) { foreach ( self : : $ value _types as $ type ) { $ parsed _value = $ value ; if ( $ type ! = = 'string ' ) { $ parsed _value = $ this - > parser - > string _helper - > strip Comments ( $ value ) ; } list ( $ is _function , $ parse _function ) = $ this - > fetch Function Names ( $ type ) ; if ( $ this - > parser - > string _helper - > $ is _function ( $ parsed _value ) ) { return $ this - > $ parse _function ( $ parsed _value ) ; } } return ( isset ( $ parsed _value ) ) ? $ this - > parse Unquoted String ( $ parsed _value ) : $ value ; } 
private function parse String ( $ value ) { $ single = false ; $ regex = self : : REGEX _QUOTE _DOUBLE _STRING ; $ symbol = ' " ' ; if ( $ this - > parser - > string _helper - > starts With ( ' \ ' ' , $ value ) ) { $ single = true ; $ regex = self : : REGEX _QUOTE _SINGLE _STRING ; $ symbol = " ' " ; } $ matches = $ this - > fetch String Matches ( $ value , $ regex , $ symbol ) ; $ value = trim ( $ matches [ 0 ] , $ symbol ) ; $ value = strtr ( $ value , self : : $ character _map ) ; return ( $ single ) ? $ value : $ this - > variable _parser - > parse ( $ value , true ) ; } 
private function fetch String Matches ( $ value , $ regex , $ symbol ) { if ( ! preg _match ( ' / ' . $ regex . ' / ' , $ value , $ matches ) ) { throw new Parse Exception ( sprintf ( 'Missing end %s quote ' , $ symbol ) , $ value , $ this - > parser - > line _num ) ; } return $ matches ; } 
private function create Message ( $ message , $ line , $ line _num ) { if ( ! is _null ( $ line ) ) { $ message . = sprintf ( " near %s " , $ line ) ; } if ( ! is _null ( $ line _num ) ) { $ message . = sprintf ( " at line %d " , $ line _num ) ; } return $ message ; } 
public function starts With ( $ string , $ line ) { return $ string = = = " " | | strrpos ( $ line , $ string , - strlen ( $ line ) ) ! = = false ; } 
public function parse ( $ value , $ quoted _string = false ) { $ matches = $ this - > fetch Variable Matches ( $ value ) ; if ( is _array ( $ matches ) ) { if ( $ this - > parser - > string _helper - > is Variable Clone ( $ value , $ matches , $ quoted _string ) ) { return $ this - > fetch Variable ( $ value , $ matches [ 1 ] [ 0 ] , $ matches , $ quoted _string ) ; } $ value = $ this - > do Replacements ( $ value , $ matches , $ quoted _string ) ; } return $ value ; } 
private function fetch Variable Matches ( $ value ) { preg _match _all ( ' / ' . self : : REGEX _ENV _VARIABLE . ' / ' , $ value , $ matches ) ; if ( ! is _array ( $ matches ) | | ! isset ( $ matches [ 0 ] ) | | empty ( $ matches [ 0 ] ) ) { return false ; } return $ matches ; } 
private function fetch Variable ( $ value , $ variable _name , $ matches , $ quoted _string ) { if ( $ this - > has Parameter Expansion ( $ variable _name ) ) { $ replacement = $ this - > fetch Parameter Expansion ( $ variable _name ) ; } elseif ( $ this - > has Variable ( $ variable _name ) ) { $ replacement = $ this - > get Variable ( $ variable _name ) ; } else { throw new Parse Exception ( sprintf ( 'Variable has not been defined : %s ' , $ variable _name ) , $ value , $ this - > parser - > line _num ) ; } if ( $ this - > parser - > string _helper - > is Bool In String ( $ replacement , $ quoted _string , count ( $ matches [ 0 ] ) ) ) { $ replacement = ( $ replacement ) ? 'true ' : 'false ' ; } return $ replacement ; } 
private function has Parameter Expansion ( $ variable ) { if ( ( strpos ( $ variable , self : : SYMBOL _DEFAULT _VALUE ) ! = = false ) | | ( strpos ( $ variable , self : : SYMBOL _ASSIGN _DEFAULT _VALUE ) ! = = false ) ) { return true ; } return false ; } 
private function fetch Parameter Expansion ( $ variable _name ) { $ parameter _type = $ this - > fetch Parameter Expansion Type ( $ variable _name ) ; list ( $ parameter _symbol , $ empty _flag ) = $ this - > fetch Parameter Expansion Symbol ( $ variable _name , $ parameter _type ) ; list ( $ variable , $ default ) = $ this - > split Variable Default ( $ variable _name , $ parameter _symbol ) ; $ value = $ this - > get Variable ( $ variable ) ; return $ this - > parse Variable Parameter ( $ variable , $ default , $ this - > has Variable ( $ variable ) , $ empty _flag & & empty ( $ value ) , $ parameter _type ) ; } 
private function fetch Parameter Expansion Symbol ( $ variable _name , $ type ) { $ class = new \ Reflection Class ( $ this ) ; $ symbol = $ class - > get Constant ( 'SYMBOL _ ' . strtoupper ( $ type ) ) ; $ pos = strpos ( $ variable _name , $ symbol ) ; $ check _empty = substr ( $ variable _name , ( $ pos - 1 ) , 1 ) = = = " : " ; if ( $ check _empty ) { $ symbol = sprintf ( " : %s " , $ symbol ) ; } return array ( $ symbol , $ check _empty ) ; } 
private function split Variable Default ( $ variable _name , $ parameter _symbol ) { $ variable _default = explode ( $ parameter _symbol , $ variable _name , 2 ) ; if ( count ( $ variable _default ) ! = = 2 | | empty ( $ variable _default [ 1 ] ) ) { throw new Parse Exception ( 'You must have valid parameter expansion syntax , eg . $ {parameter : =word } ' , $ variable _name , $ this - > parser - > line _num ) ; } return array ( trim ( $ variable _default [ 0 ] ) , trim ( $ variable _default [ 1 ] ) ) ; } 
private function parse Variable Parameter ( $ variable , $ default , $ exists , $ empty , $ type ) { if ( $ exists & & ! $ empty ) { return $ this - > get Variable ( $ variable ) ; } return $ this - > assign Variable Parameter Default ( $ variable , $ default , $ empty , $ type ) ; } 
private function assign Variable Parameter Default ( $ variable , $ default , $ empty , $ type ) { $ default = $ this - > parser - > value _parser - > parse ( $ default ) ; if ( $ type = = = "assign _default _value " & & $ empty ) { $ this - > parser - > lines [ $ variable ] = $ default ; } return $ default ; } 
private function has Variable ( $ variable ) { if ( array _key _exists ( $ variable , $ this - > parser - > lines ) ) { return true ; } if ( array _key _exists ( $ variable , $ this - > context ) ) { return true ; } return false ; } 
private function get Variable ( $ variable ) { if ( array _key _exists ( $ variable , $ this - > parser - > lines ) ) { return $ this - > parser - > lines [ $ variable ] ; } if ( array _key _exists ( $ variable , $ this - > context ) ) { return $ this - > context [ $ variable ] ; } return null ; } 
public function parse ( $ key ) { $ key = trim ( $ key ) ; if ( $ this - > parser - > string _helper - > starts With ( ' # ' , $ key ) ) { return false ; } if ( ! ctype _alnum ( str _replace ( ' _ ' , ' ' , $ key ) ) | | $ this - > parser - > string _helper - > starts With Number ( $ key ) ) { throw new Parse Exception ( sprintf ( 'Key can only contain alphanumeric and underscores and can not start with a number : %s ' , $ key ) , $ key , $ this - > parser - > line _num ) ; } return $ key ; } 
protected function do Parse ( $ content ) { $ raw _lines = array _filter ( $ this - > make Lines ( $ content ) , 'strlen ' ) ; if ( empty ( $ raw _lines ) ) { return ; } return $ this - > parse Content ( $ raw _lines ) ; } 
private function parse Content ( array $ raw _lines ) { $ this - > lines = array ( ) ; $ this - > line _num = 0 ; foreach ( $ raw _lines as $ raw _line ) { $ this - > line _num + + ; if ( $ this - > string _helper - > starts With ( ' # ' , $ raw _line ) | | ! $ raw _line ) { continue ; } $ this - > parse Line ( $ raw _line ) ; } return $ this - > lines ; } 
private function parse Line ( $ raw _line ) { $ raw _line = $ this - > parse Export ( $ raw _line ) ; list ( $ key , $ value ) = $ this - > parse Key Value ( $ raw _line ) ; $ key = $ this - > key _parser - > parse ( $ key ) ; if ( ! is _string ( $ key ) ) { return ; } $ this - > lines [ $ key ] = $ this - > value _parser - > parse ( $ value ) ; } 
private function parse Export ( $ raw _line ) { $ line = trim ( $ raw _line ) ; if ( $ this - > string _helper - > starts With ( "export " , $ line ) ) { $ export _line = explode ( "export " , $ raw _line , 2 ) ; if ( count ( $ export _line ) ! = = 2 | | empty ( $ export _line [ 1 ] ) ) { throw new Parse Exception ( 'You must have a export key = value ' , $ raw _line , $ this - > line _num ) ; } $ line = trim ( $ export _line [ 1 ] ) ; } return $ line ; } 
private function parse Key Value ( $ raw _line ) { $ key _value = explode ( " = " , $ raw _line , 2 ) ; if ( count ( $ key _value ) ! = = 2 ) { throw new Parse Exception ( 'You must have a key = value ' , $ raw _line , $ this - > line _num ) ; } return $ key _value ; } 
public function get Content ( $ key Name = null ) { if ( ! is _null ( $ key Name ) ) { return ( array _key _exists ( $ key Name , $ this - > lines ) ) ? $ this - > lines [ $ key Name ] : null ; } return $ this - > lines ; } 
public function get Worker Url ( $ ressources = ' ' , $ params = [ ] ) { if ( is _array ( $ params ) ) { return $ this - > get Worker Url V 2 ( $ ressources , $ params ) ; } $ url = ( getenv ( 'ZENATON _WORKER _URL ' ) ? : self : : ZENATON _WORKER _URL ) . ' : ' . ( getenv ( 'ZENATON _WORKER _PORT ' ) ? : self : : DEFAULT _WORKER _PORT ) . ' /api / ' . self : : WORKER _API _VERSION . ' / ' . $ ressources . ' ? ' ; return $ this - > add App Env ( $ url , $ params ) ; } 
public function get Website Url ( $ ressources = ' ' , $ params = [ ] ) { if ( is _array ( $ params ) ) { return $ this - > get Website Url V 2 ( $ ressources , $ params ) ; } $ url = ( getenv ( 'ZENATON _API _URL ' ) ? : self : : ZENATON _API _URL ) . ' / ' . $ ressources . ' ? ' . self : : API _TOKEN . ' = ' . $ this - > api Token . ' & ' ; return $ this - > add App Env ( $ url , $ params ) ; } 
public function start Task ( Task Interface $ task ) { $ response = $ this - > http - > post ( $ this - > get Task Worker Url ( ) , [ self : : ATTR _PROG = > self : : PROG , self : : ATTR _NAME = > get _class ( $ task ) , self : : ATTR _DATA = > $ this - > serializer - > encode ( $ this - > properties - > get Properties From Object ( $ task ) ) , self : : ATTR _MAX _PROCESSING _TIME = > method _exists ( $ task , 'get Max Processing Time ' ) ? $ task - > get Max Processing Time ( ) : null , ] ) ; if ( $ response - > has Errors ( ) ) { if ( strpos ( $ response - > body - > error , 'Your worker does not listen ' ) ! = = false ) { throw new Agent Not Listening Exception ( $ this - > app Id , $ this - > app Env ) ; } if ( strpos ( $ response - > body - > error , 'Unknown version ' ) ! = = false ) { throw new Agent Update Required Exception ( ' > = 0 . 6 . 0 ' ) ; } throw new Agent Exception ( $ response - > body - > error ) ; } } 
public function start Workflow ( Workflow Interface $ flow ) { $ canonical = null ; 
public function find Workflow ( $ workflow Name , $ custom Id ) { $ params = [ static : : ATTR _ID = > $ custom Id , static : : ATTR _NAME = > $ workflow Name , static : : ATTR _PROG = > static : : PROG , ] ; $ response = $ this - > http - > get ( $ this - > get Instance Website Url ( $ params ) ) ; if ( $ response - > code = = = 4 0 4 ) { return null ; } if ( $ response - > has Errors ( ) ) { throw Api Exception : : unexpected Status Code ( $ response - > code ) ; } return $ this - > properties - > get Object From Name And Properties ( $ response - > body - > data - > name , $ this - > serializer - > decode ( $ response - > body - > data - > properties ) ) ; } 
public function send Event ( $ workflow Name , $ custom Id , Event Interface $ event ) { $ url = $ this - > get Send Event URL ( ) ; $ body = [ self : : ATTR _PROG = > self : : PROG , self : : ATTR _NAME = > $ workflow Name , self : : ATTR _ID = > $ custom Id , self : : EVENT _NAME = > get _class ( $ event ) , self : : EVENT _INPUT = > $ this - > serializer - > encode ( $ this - > properties - > get Properties From Object ( $ event ) ) , ] ; $ this - > http - > post ( $ url , $ body ) ; } 
protected function add App Env ( $ url , $ params = ' ' ) { static $ triggered Deprecation = false ; if ( ! $ triggered Deprecation ) { trigger _error ( 'You are running a Zenaton agent version < = 0 . 4 . 5 which is using deprecated code . Please consider upgrading your agent . ' , E _USER _DEPRECATED ) ; } $ triggered Deprecation = true ; 
public static function timezone ( $ timezone ) { if ( ! in _array ( $ timezone , Date Time Zone : : list Identifiers ( ) ) ) { throw new External Zenaton Exception ( 'Unknown timezone ' ) ; } self : : $ _timezone = $ timezone ; } 
public function _get Timestamp Or Duration ( ) { if ( null = = = $ this - > _buffer ) { return [ null , null ] ; } list ( $ now , $ then ) = $ this - > _init Now Then ( ) ; $ this - > _mode = null ; 
protected function same Month Day Later ( $ now , $ day ) { return $ this - > same Month Day ( $ now , $ day ) & & $ this - > later ( $ now ) ; } 
protected function same Week Day Later ( $ now , $ day ) { return $ this - > same Week Day ( $ now , $ day ) & & $ this - > later ( $ now ) ; } 
protected function later ( $ now ) { 
private function get Class Properties ( $ argument , $ filter = null ) { if ( null = = = $ filter ) { $ filter = \ Reflection Property : : IS _STATIC | \ Reflection Property : : IS _PUBLIC | \ Reflection Property : : IS _PROTECTED | \ Reflection Property : : IS _PRIVATE ; } $ reflection Class = new \ Reflection Class ( $ argument ) ; if ( $ parent Class = $ reflection Class - > get Parent Class ( ) ) { return array _merge ( $ this - > get Class Properties ( $ parent Class - > get Name ( ) , $ filter ) , $ reflection Class - > get Properties ( $ filter ) ) ; } return $ reflection Class - > get Properties ( $ filter ) ; } 
public function send ( Event Interface $ event ) { $ this - > client - > send Event ( $ this - > class , $ this - > id , $ event ) ; return $ this ; } 
public function load ( array $ configs , Container Builder $ container ) { $ configuration = new Configuration ( ) ; $ config = $ this - > process Configuration ( $ configuration , $ configs ) ; $ config = $ this - > fix Configuration ( $ config ) ; $ bundles = $ container - > get Parameter ( 'kernel .bundles ' ) ; $ loader = new Loader \ Xml File Loader ( $ container , new File Locator ( _ _DIR _ _ . ' / . . /Resources /config ' ) ) ; if ( isset ( $ bundles [ 'Sonata Block Bundle ' ] , $ bundles [ 'Knp Menu Bundle ' ] ) ) { $ loader - > load ( 'blocks .xml ' ) ; } $ loader - > load ( 'event .xml ' ) ; $ loader - > load ( 'services .xml ' ) ; $ loader - > load ( 'commands .xml ' ) ; $ this - > configure Seo Page ( $ config [ 'page ' ] , $ container ) ; $ this - > configure Sitemap ( $ config [ 'sitemap ' ] , $ container ) ; $ container - > get Definition ( 'sonata .seo .twig .extension ' ) - > replace Argument ( 1 , $ config [ 'encoding ' ] ) ; } 
protected function configure Sitemap ( array $ config , Container Builder $ container ) { $ source = $ container - > get Definition ( 'sonata .seo .sitemap .manager ' ) ; if ( method _exists ( $ source , 'set Shared ' ) ) { 
protected function fix Configuration ( array $ config ) { foreach ( $ config [ 'sitemap ' ] [ 'doctrine _orm ' ] as $ pos = > $ sitemap ) { $ sitemap [ 'group ' ] = $ sitemap [ 'group ' ] ? ? false ; $ sitemap [ 'types ' ] = $ sitemap [ 'types ' ] ? ? [ ] ; $ sitemap [ 'connection ' ] = $ sitemap [ 'connection ' ] ? ? 'doctrine .dbal .default _connection ' ; $ sitemap [ 'route ' ] = $ sitemap [ 'route ' ] ? ? false ; $ sitemap [ 'parameters ' ] = $ sitemap [ 'parameters ' ] ? ? false ; $ sitemap [ 'query ' ] = $ sitemap [ 'query ' ] ? ? false ; if ( false = = = $ sitemap [ 'route ' ] ) { throw new \ Runtime Exception ( 'Route cannot be empty , please review the sonata _seo .sitemap configuration ' ) ; } if ( false = = = $ sitemap [ 'query ' ] ) { throw new \ Runtime Exception ( 'Query cannot be empty , please review the sonata _seo .sitemap configuration ' ) ; } if ( false = = = $ sitemap [ 'parameters ' ] ) { throw new \ Runtime Exception ( 'Route \ 's parameters cannot be empty , please review the sonata _seo .sitemap configuration ' ) ; } $ config [ 'sitemap ' ] [ 'doctrine _orm ' ] [ $ pos ] = $ sitemap ; } foreach ( $ config [ 'sitemap ' ] [ 'services ' ] as $ pos = > $ sitemap ) { if ( ! \ is _array ( $ sitemap ) ) { $ sitemap = [ 'group ' = > false , 'types ' = > [ ] , 'id ' = > $ sitemap , ] ; } else { $ sitemap [ 'group ' ] = $ sitemap [ 'group ' ] ? ? false ; $ sitemap [ 'types ' ] = $ sitemap [ 'types ' ] ? ? [ ] ; if ( ! isset ( $ sitemap [ 'id ' ] ) ) { throw new \ Runtime Exception ( 'Service id must to be defined , please review the sonata _seo .sitemap configuration ' ) ; } } $ config [ 'sitemap ' ] [ 'services ' ] [ $ pos ] = $ sitemap ; } return $ config ; } 
public function configure Settings ( Options Resolver $ resolver ) { $ resolver - > set Defaults ( [ 'template ' = > ' @Sonata Seo /Block /block _facebook _send _button .html .twig ' , 'url ' = > null , 'width ' = > null , 'height ' = > null , 'colorscheme ' = > $ this - > colorscheme List [ 'light ' ] , ] ) ; } 
public function build Edit Form ( Form Mapper $ form Mapper , Block Interface $ block ) { $ form Mapper - > add ( 'settings ' , Immutable Array Type : : class , [ 'keys ' = > [ [ 'url ' , Url Type : : class , [ 'required ' = > false , 'label ' = > 'form .label _url ' , ] ] , [ 'width ' , Integer Type : : class , [ 'required ' = > false , 'label ' = > 'form .label _width ' , ] ] , [ 'height ' , Integer Type : : class , [ 'required ' = > false , 'label ' = > 'form .label _height ' , ] ] , [ 'colorscheme ' , Choice Type : : class , [ 'required ' = > true , 'choices ' = > $ this - > colorscheme List , 'label ' = > 'form .label _colorscheme ' , ] ] , ] , 'translation _domain ' = > 'Sonata Seo Bundle ' , ] ) ; } 
public function add Source ( $ group , Source Iterator Interface $ source , array $ types = [ ] ) { if ( ! isset ( $ this - > sources [ $ group ] ) ) { $ this - > sources [ $ group ] = new \ std Class ( ) ; $ this - > sources [ $ group ] - > sources = new Chain Source Iterator ( ) ; $ this - > sources [ $ group ] - > types = [ ] ; } $ this - > sources [ $ group ] - > sources - > add Source ( $ source ) ; if ( $ types ) { $ this - > sources [ $ group ] - > types + = array _diff ( $ types , $ this - > sources [ $ group ] - > types ) ; } } 
public function configure Settings ( Options Resolver $ resolver ) { $ resolver - > set Defaults ( [ 'template ' = > ' @Sonata Seo /Block /block _facebook _like _button .html .twig ' , 'url ' = > null , 'width ' = > null , 'show _faces ' = > true , 'share ' = > true , 'layout ' = > $ this - > layout List [ 'standard ' ] , 'colorscheme ' = > $ this - > colorscheme List [ 'light ' ] , 'action ' = > $ this - > action Types [ 'like ' ] , ] ) ; } 
public function build Edit Form ( Form Mapper $ form Mapper , Block Interface $ block ) { $ form Mapper - > add ( 'settings ' , Immutable Array Type : : class , [ 'keys ' = > [ [ 'url ' , Url Type : : class , [ 'required ' = > false , 'label ' = > 'form .label _url ' , ] ] , [ 'width ' , Integer Type : : class , [ 'required ' = > false , 'label ' = > 'form .label _width ' , ] ] , [ 'show _faces ' , Checkbox Type : : class , [ 'required ' = > false , 'label ' = > 'form .label _show _faces ' , ] ] , [ 'share ' , Checkbox Type : : class , [ 'required ' = > false , 'label ' = > 'form .label _share ' , ] ] , [ 'layout ' , Choice Type : : class , [ 'required ' = > true , 'choices ' = > $ this - > layout List , 'label ' = > 'form .label _layout ' , ] ] , [ 'colorscheme ' , Choice Type : : class , [ 'required ' = > true , 'choices ' = > $ this - > colorscheme List , 'label ' = > 'form .label _colorscheme ' , ] ] , [ 'action ' , Choice Type : : class , [ 'required ' = > true , 'choices ' = > $ this - > action Types , 'label ' = > 'form .label _action ' , ] ] , ] , 'translation _domain ' = > 'Sonata Seo Bundle ' , ] ) ; } 
public function on Block ( Block Event $ event ) { $ context = $ event - > get Setting ( 'context ' , null ) ; if ( null = = = $ context ) { return ; } foreach ( $ this - > block Services as $ type = > $ block Service ) { if ( $ block Service - > handle Context ( $ context ) ) { $ block = new Block ( ) ; $ block - > set Id ( uniqid ( ) ) ; $ block - > set Settings ( $ event - > get Settings ( ) ) ; $ block - > set Type ( $ type ) ; $ event - > add Block ( $ block ) ; return ; } } } 
public function configure Settings ( Options Resolver $ resolver ) { parent : : configure Settings ( $ resolver ) ; $ resolver - > set Defaults ( [ 'menu _template ' = > ' @Sonata Seo /Block /breadcrumb .html .twig ' , 'include _homepage _link ' = > true , 'context ' = > false , ] ) ; } 
protected function get Root Menu ( Block Context Interface $ block Context ) { $ settings = $ block Context - > get Settings ( ) ; $ menu = $ this - > factory - > create Item ( 'breadcrumb ' ) ; $ menu - > set Children Attribute ( 'class ' , 'breadcrumb ' ) ; if ( method _exists ( $ menu , 'set Current Uri ' ) ) { $ menu - > set Current Uri ( $ settings [ 'current _uri ' ] ) ; } if ( method _exists ( $ menu , 'set Current ' ) ) { $ menu - > set Current ( $ settings [ 'current _uri ' ] ) ; } if ( $ settings [ 'include _homepage _link ' ] ) { $ menu - > add Child ( 'sonata _seo _homepage _breadcrumb ' , [ 'uri ' = > ' / ' ] ) ; } return $ menu ; } 
public function add Title ( $ title ) { $ this - > title = $ title . $ this - > separator . $ this - > title ; return $ this ; } 
public function add Meta ( $ type , $ name , $ content , array $ extras = [ ] ) { if ( ! \ is _string ( $ content ) ) { @ trigger _error ( sprintf ( 'Passing meta content of type %s in %s is deprecated since version 2 .x and will be unsupported in version 3 . Please cast the value to a string first . ' , \ gettype ( $ content ) , _ _METHOD _ _ ) , E _USER _DEPRECATED ) ; } if ( ! isset ( $ this - > metas [ $ type ] ) ) { $ this - > metas [ $ type ] = [ ] ; } $ this - > metas [ $ type ] [ $ name ] = [ $ content , $ extras ] ; return $ this ; } 
public function set Metas ( array $ metadatas ) { $ this - > metas = [ ] ; foreach ( $ metadatas as $ type = > $ metas ) { if ( ! \ is _array ( $ metas ) ) { throw new \ Runtime Exception ( ' $metas must be an array ' ) ; } foreach ( $ metas as $ name = > $ meta ) { list ( $ content , $ extras ) = $ this - > normalize ( $ meta ) ; $ this - > add Meta ( $ type , $ name , $ content , $ extras ) ; } } return $ this ; } 
public function configure Settings ( Options Resolver $ resolver ) { $ resolver - > set Defaults ( [ 'template ' = > ' @Sonata Seo /Block /block _facebook _like _box .html .twig ' , 'url ' = > null , 'width ' = > null , 'height ' = > null , 'colorscheme ' = > $ this - > colorscheme List [ 'light ' ] , 'show _faces ' = > true , 'show _header ' = > true , 'show _posts ' = > false , 'show _border ' = > true , ] ) ; } 
public function build Edit Form ( Form Mapper $ form Mapper , Block Interface $ block ) { $ form Mapper - > add ( 'settings ' , Immutable Array Type : : class , [ 'keys ' = > [ [ 'url ' , Url Type : : class , [ 'required ' = > false , 'label ' = > 'form .label _url ' , ] ] , [ 'width ' , Integer Type : : class , [ 'required ' = > false , 'label ' = > 'form .label _width ' , ] ] , [ 'height ' , Integer Type : : class , [ 'required ' = > false , 'label ' = > 'form .label _height ' , ] ] , [ 'colorscheme ' , Choice Type : : class , [ 'required ' = > true , 'choices ' = > $ this - > colorscheme List , 'label ' = > 'form .label _colorscheme ' , ] ] , [ 'show _faces ' , Checkbox Type : : class , [ 'required ' = > false , 'label ' = > 'form .label _show _faces ' , ] ] , [ 'show _header ' , Checkbox Type : : class , [ 'required ' = > false , 'label ' = > 'form .label _show _header ' , ] ] , [ 'show _posts ' , Checkbox Type : : class , [ 'required ' = > false , 'label ' = > 'form .label _show _posts ' , ] ] , [ 'show _border ' , Checkbox Type : : class , [ 'required ' = > false , 'label ' = > 'form .label _show _border ' , ] ] , ] , 'translation _domain ' = > 'Sonata Seo Bundle ' , ] ) ; } 
public function execute ( Input Interface $ input , Output Interface $ output ) { $ this - > get Container ( ) - > get ( 'router ' ) - > get Context ( ) - > set Host ( $ input - > get Argument ( 'host ' ) ) ; $ this - > get Container ( ) - > get ( 'router ' ) - > get Context ( ) - > set Scheme ( $ input - > get Option ( 'scheme ' ) ) ; $ this - > get Container ( ) - > get ( 'router ' ) - > get Context ( ) - > set Base Url ( $ input - > get Option ( 'baseurl ' ) ) ; $ temp Folder = sys _get _temp _dir ( ) . ' /sonata _sitemap _ ' . md 5 ( _ _DIR _ _ ) ; $ fs = new Filesystem ( ) ; 
public function configure Settings ( Options Resolver $ resolver ) { $ resolver - > set Defaults ( [ 'template ' = > ' @Sonata Seo /Block /block _twitter _mention _button .html .twig ' , 'user ' = > null , 'text ' = > null , 'recommend ' = > null , 'large _button ' = > false , 'opt _out ' = > false , 'language ' = > $ this - > language List [ 'en ' ] , ] ) ; } 
public function build Edit Form ( Form Mapper $ form Mapper , Block Interface $ block ) { $ form Mapper - > add ( 'settings ' , Immutable Array Type : : class , [ 'keys ' = > [ [ 'user ' , Text Type : : class , [ 'required ' = > true , 'label ' = > 'form .label _user ' , ] ] , [ 'text ' , Text Type : : class , [ 'required ' = > false , 'label ' = > 'form .label _text ' , ] ] , [ 'recommend ' , Text Type : : class , [ 'required ' = > false , 'label ' = > 'form .label _recommend ' , ] ] , [ 'large _button ' , Checkbox Type : : class , [ 'required ' = > false , 'label ' = > 'form .label _large _button ' , ] ] , [ 'opt _out ' , Checkbox Type : : class , [ 'required ' = > false , 'label ' = > 'form .label _opt _out ' , ] ] , [ 'language ' , Choice Type : : class , [ 'required ' = > true , 'choices ' = > $ this - > language List , 'label ' = > 'form .label _language ' , ] ] , ] , 'translation _domain ' = > 'Sonata Seo Bundle ' , ] ) ; } 
public function execute ( Block Context Interface $ block Context , Response $ response = null ) { $ tweet = $ block Context - > get Setting ( 'tweet ' ) ; if ( ( $ uri Matched = preg _match ( self : : TWEET _URL _PATTERN , $ tweet ) ) | | preg _match ( self : : TWEET _ID _PATTERN , $ tweet ) ) { 
public function build Edit Form ( Form Mapper $ form , Block Interface $ block ) { $ form - > add ( 'settings ' , Immutable Array Type : : class , [ 'keys ' = > [ [ 'tweet ' , Textarea Type : : class , [ 'required ' = > true , 'label ' = > 'form .label _tweet ' , 'sonata _help ' = > 'form .help _tweet ' , ] ] , [ 'maxwidth ' , Integer Type : : class , [ 'required ' = > false , 'label ' = > 'form .label _maxwidth ' , 'sonata _help ' = > 'form .help _maxwidth ' , ] ] , [ 'hide _media ' , Checkbox Type : : class , [ 'required ' = > false , 'label ' = > 'form .label _hide _media ' , 'sonata _help ' = > 'form .help _hide _media ' , ] ] , [ 'hide _thread ' , Checkbox Type : : class , [ 'required ' = > false , 'label ' = > 'form .label _hide _thread ' , 'sonata _help ' = > 'form .help _hide _thread ' , ] ] , [ 'omit _script ' , Checkbox Type : : class , [ 'required ' = > false , 'label ' = > 'form .label _omit _script ' , 'sonata _help ' = > 'form .help _omit _script ' , ] ] , [ 'align ' , Choice Type : : class , [ 'required ' = > false , 'choices ' = > [ 'left ' = > 'form .label _align _left ' , 'right ' = > 'form .label _align _right ' , 'center ' = > 'form .label _align _center ' , 'none ' = > 'form .label _align _none ' , ] , 'label ' = > 'form .label _align ' , ] ] , [ 'related ' , Text Type : : class , [ 'required ' = > false , 'label ' = > 'form .label _related ' , 'sonata _help ' = > 'form .help _related ' , ] ] , [ 'lang ' , Choice Type : : class , [ 'required ' = > true , 'choices ' = > $ this - > language List , 'label ' = > 'form .label _lang ' , ] ] , ] , 'translation _domain ' = > 'Sonata Seo Bundle ' , ] ) ; } 
protected function build Uri ( $ uri Matched , array $ settings ) { $ api Params = $ settings ; $ supported Params = $ this - > get Supported Api Params ( ) ; if ( $ uri Matched ) { 
public function build ( Container Builder $ container ) { parent : : build ( $ container ) ; $ container - > add Compiler Pass ( new Breadcrumb Block Services Compiler Pass ( ) ) ; $ container - > add Compiler Pass ( new Service Compiler Pass ( ) ) ; } 
public function get Config Tree Builder ( ) { $ tree Builder = new Tree Builder ( 'sonata _seo ' ) ; 
private function get Fonts ( ) { if ( empty ( $ this - > fonts ) ) { $ files = File Helper : : find Files ( Craft : : get Alias ( self : : FONT _DIR ) , [ 'only ' = > self : : FONT _EXT ] ) ; $ filenames = [ ] ; $ fonts = [ ] ; foreach ( $ files as $ file ) { $ path Info = pathinfo ( $ file ) ; $ safename = in _array ( $ path Info [ 'filename ' ] , $ filenames ) ? $ path Info [ 'basename ' ] : $ path Info [ 'filename ' ] ; $ safename = $ this - > safe Name ( $ safename ) ; $ fonts [ $ safename ] = Array Helper : : merge ( [ 'path ' = > $ file , 'safename ' = > $ safename ] , $ path Info ) ; $ filenames [ ] = $ path Info [ 'filename ' ] ; } $ this - > fonts = $ fonts ; } return $ this - > fonts ; } 
private function get Icons ( ) { if ( ! empty ( $ this - > icon Font ) ) { $ fonts = $ this - > get Fonts ( ) ; if ( ! empty ( $ fonts ) & & isset ( $ fonts [ $ this - > icon Font ] ) ) { $ font = Font : : load ( $ fonts [ $ this - > icon Font ] [ 'path ' ] ) ; $ font - > parse ( ) ; if ( $ font ! = = null ) { return $ font - > get Unicode Char Map ( ) ; } } } return null ; } 
public function get Font Css ( ) { $ shared Asset = new shared Asset ( ) ; $ scss = " " ; foreach ( $ this - > get Fonts ( ) as $ safe Name = > $ path Info ) { $ font File = $ path Info [ 'path ' ] ; $ font = Font : : load ( $ font File ) ; $ font - > parse ( ) ; if ( ! empty ( $ font ) ) { $ icon Font Name = $ safe Name ; if ( ! empty ( $ icon Font Name ) ) { $ scss . = " @font -face { font -family : 'dq -iconpicker - " . $ icon Font Name . " ' ; src : url ( ' . . /fonts / " . $ path Info [ 'basename ' ] . " ' ) ; font -weight : 1 0 0 ; font -style : normal ; } \n \n " ; $ scss . = ' [class * = "dq -icon - ' . $ icon Font Name . ' " ] { / * use !important to prevent issues with browser extensions that change fonts * / font -family : dq -iconpicker - ' . $ icon Font Name . ' !important ; speak : none ; font -style : normal ; font -weight : normal ; font -variant : normal ; text -transform : none ; line -height : 1 ; display : inline -block ; vertical -align : baseline ; / * Better Font Rendering = = = = = = = = = = = * / -webkit -font -smoothing : antialiased ; -moz -osx -font -smoothing : grayscale ; } ' . " \n \n " ; } } } file _put _contents ( Craft : : get Alias ( $ shared Asset - > source Path . ' /css /fonts .css ' ) , $ scss ) ; 
public static function hash And Encrypt ( string $ password , Key $ aes Key ) : string { $ hash = \ password _hash ( Base 6 4 : : encode ( \ hash ( 'sha 3 8 4 ' , $ password , true ) ) , PASSWORD _DEFAULT ) ; if ( ! \ is _string ( $ hash ) ) { throw new \ Exception ( "Unknown hashing error . " ) ; } return Crypto : : encrypt ( $ hash , $ aes Key ) ; } 
public static function decrypt And Verify Legacy ( string $ password , string $ ciphertext , string $ aes Key ) : bool { if ( Binary : : safe Strlen ( $ aes Key ) ! = = 1 6 ) { throw new \ Exception ( "Encryption keys must be 1 6 bytes long " ) ; } $ hash = Crypto : : legacy Decrypt ( $ ciphertext , $ aes Key ) ; if ( ! \ is _string ( $ hash ) ) { throw new \ Exception ( "Unknown hashing error . " ) ; } return \ password _verify ( Base 6 4 : : encode ( \ hash ( 'sha 2 5 6 ' , $ password , true ) ) , $ hash ) ; } 
public static function decrypt And Verify ( string $ password , string $ ciphertext , Key $ aes Key ) : bool { $ hash = Crypto : : decrypt ( $ ciphertext , $ aes Key ) ; if ( ! \ is _string ( $ hash ) ) { throw new \ Exception ( "Unknown hashing error . " ) ; } return \ password _verify ( Base 6 4 : : encode ( \ hash ( 'sha 3 8 4 ' , $ password , true ) ) , $ hash ) ; } 
public static function rotate Key ( string $ ciphertext , Key $ old Key , Key $ new Key ) : string { $ plaintext = Crypto : : decrypt ( $ ciphertext , $ old Key ) ; return Crypto : : encrypt ( $ plaintext , $ new Key ) ; } 
public static function upgrade From Version 1 ( string $ password , string $ ciphertext , string $ old Key , Key $ new Key ) : string { if ( ! self : : decrypt And Verify Legacy ( $ password , $ ciphertext , $ old Key ) ) { throw new \ Exception ( 'The correct password is necessary for legacy migration . ' ) ; } $ plaintext = Crypto : : legacy Decrypt ( $ ciphertext , $ old Key ) ; return self : : hash And Encrypt ( $ plaintext , $ new Key ) ; } 
public static function exclude Everything Not In Breadcrumb Path ( Array Node $ node , $ breadcrumb Path ) { if ( $ breadcrumb Path = = = null ) { return ; } $ path = explode ( ' . ' , $ breadcrumb Path ) ; self : : exclude Everything Not In Path ( $ node , $ path ) ; } 
private static function child Node ( Array Node $ node , $ child Node Name ) { if ( $ node instanceof Prototyped Array Node & & ' * ' = = = $ child Node Name ) { return self : : node Prototype Property ( ) - > get Value ( $ node ) ; } $ children = self : : node Children Property ( ) - > get Value ( $ node ) ; if ( ! isset ( $ children [ $ child Node Name ] ) ) { throw new Undefined Child Node ( $ node , $ child Node Name ) ; } return $ children [ $ child Node Name ] ; } 
private function create Request ( Uri $ uri ) { $ headers = [ 'Accept -Encoding ' = > 'gzip ' , 'Connection ' = > 'keep -alive ' ] ; if ( $ uri - > get Session Identifier ( ) ) { $ session = $ this - > session Container - > get Session ( $ uri - > get Session Identifier ( ) ) ; foreach ( $ session - > get Cookies ( ) as $ key = > $ value ) { $ uri - > add Cookie ( $ key , $ value ) ; } } $ request = Request Factory : : get Request ( $ uri , 'GET ' , 'php : / /memory ' , $ headers ) ; return $ request ; } 
protected function execute ( Input Interface $ input , Output Interface $ output ) { $ this - > init ( $ input , $ output ) ; $ config = $ this - > init Configuration ( $ input - > get Option ( 'config _file ' ) ) ; $ rules = $ config - > get Rules ( ) ; foreach ( $ rules as $ name = > $ rule ) { $ info = Init : : get Init Information By Class ( get _class ( $ rule ) ) ; $ output - > writeln ( ' ' . $ name . ' : ' ) ; $ output - > writeln ( ' class : ' . get _class ( $ rule ) ) ; $ output - > writeln ( ' description : ' . str _replace ( " \n " , " \n " , $ info [ 'documentation ' ] ) ) ; if ( count ( $ info [ 'parameters ' ] ) > 0 ) { $ output - > writeln ( ' parameter : ' ) ; foreach ( $ info [ 'parameters ' ] as $ parameter ) { $ output - > writeln ( ' ' . $ parameter [ 'name ' ] . ' : ' . $ parameter [ 'description ' ] . ' (default : ' . $ parameter [ 'default ' ] . ' ) ' ) ; } } $ output - > writeln ( ' ' ) ; } } 
private function init Configuration ( $ config File ) { $ config Array = $ this - > get Config Array ( $ config File ) ; $ config = new Configuration ( new Uri ( ' ' ) , $ this - > event Dispatcher , $ config Array ) ; return $ config ; } 
public function process ( $ results , Uri Aware Response $ response ) { foreach ( $ results as $ result ) { if ( $ result - > get Status ( ) = = Check Result : : STATUS _FAILURE ) { $ this - > memory [ ] = ( string ) $ response - > get Uri ( ) ; } } } 
private function init Configuration ( $ num _urls , $ run _level , Uri $ uri , Dispatcher $ dispatcher ) { $ config Array = $ this - > get Config Array ( _ _DIR _ _ . ' / . . / . . /settings / ' . self : : CONFIG _FILE ) ; $ config = new Configuration ( $ uri , $ dispatcher , $ config Array ) ; $ crawler = $ config - > get Extension ( ' _Response Retriever ' ) - > get Retriever ( ) ; $ crawler - > set Start Page ( $ uri ) ; $ config - > get Extension ( ' _Smoke Stop ' ) - > get Strategy ( ' _Count Stop ' ) - > init ( $ num _urls ) ; $ config - > get Extension ( ' _Progress Bar ' ) - > set Max ( $ num _urls ) ; $ config - > get Extension ( ' _Smoke Run Level ' ) - > set Run Level ( $ run _level ) ; $ this - > config = $ config ; } 
private function get Rule Keys ( ) { $ keys = array ( ) ; foreach ( $ this - > config - > get Rules ( ) as $ key = > $ rule ) { $ keys [ ] = $ key ; } return $ keys ; } 
protected function write Smoke Credentials ( $ url = null ) { if ( defined ( 'SMOKE _CREDENTIALS ' ) ) { $ this - > output - > writeln ( " \n " . SMOKE _CREDENTIALS . " \n " ) ; } else { $ this - > output - > writeln ( " \n Smoke " . SMOKE _VERSION . " by Nils Langner \n " ) ; } if ( $ url ) { $ this - > output - > writeln ( ' <info >Scanning ' . $ url . " < /info > \n " ) ; } } 
protected function get Config Array ( $ config File , $ mandatory = false ) { $ config Array = array ( ) ; if ( $ config File ) { if ( strpos ( $ config File , 'http : / / ' ) = = = 0 | | strpos ( $ config File , 'https : / / ' ) = = = 0 ) { $ curl Client = new Client ( ) ; $ file Content = ( string ) $ curl Client - > get ( $ config File ) - > get Body ( ) ; } else { if ( file _exists ( $ config File ) ) { $ file Content = file _get _contents ( $ config File ) ; } else { throw new \ Runtime Exception ( "Config file was not found ( ' " . $ config File . " ' ) . " ) ; } } $ config Array = Env Aware Yaml : : parse ( $ file Content ) ; } else { if ( $ mandatory ) { throw new \ Runtime Exception ( 'Config file was not defined . ' ) ; } } return $ config Array ; } 
private function check Relation ( $ relation , $ expected , $ current ) { switch ( $ relation ) { case 'equals ' : if ( $ expected ! = = $ current ) { return false ; } break ; case 'less than ' : if ( $ expected < = $ current ) { return false ; } break ; case 'greater than ' : if ( $ expected > = $ current ) { return false ; } break ; } return true ; } 
public function is Filtered ( Uri Interface $ current Uri , Uri Interface $ start Uri ) { $ start Domain Elements = explode ( ' . ' , $ start Uri - > get Host ( ) ) ; $ current Domain Elements = explode ( ' . ' , $ current Uri - > get Host ( ) ) ; $ start Domain Length = count ( $ start Domain Elements ) ; $ current Domain Length = count ( $ current Domain Elements ) ; if ( $ current Domain Length < $ start Domain Length ) { return true ; } return $ current Uri - > get Host ( $ start Domain Length ) ! = = $ start Uri - > get Host ( $ start Domain Length ) ; } 
protected function configure Command ( $ description , $ help , $ name ) { $ this - > set Definition ( [ new Input Option ( 'config _file ' , 'c ' , Input Option : : VALUE _REQUIRED , 'config file ' ) , new Input Option ( 'bootstrap ' , 'b ' , Input Option : : VALUE _OPTIONAL , 'bootstrap file ' ) , ] ) - > set Description ( $ description ) - > set Help ( $ help ) - > set Name ( $ name ) ; } 
protected function do Validation ( Response Interface $ response ) { $ document = new Document ( ( string ) $ response - > get Body ( ) , false ) ; $ urls = $ document - > get Dependencies ( $ response - > get Uri ( ) ) ; $ invalid Urls = array ( ) ; foreach ( $ urls as $ url ) { if ( function _exists ( 'idn _to _ascii ' ) ) { $ idn Url = $ url - > get Scheme ( ) . ' : / / ' . idn _to _ascii ( $ url - > get Host ( ) ) . $ url - > get Path ( ) ; } else { $ idn Url = $ url - > get Scheme ( ) . ' : / / ' . $ url - > get Host ( ) . $ url - > get Path ( ) ; } if ( ! filter _var ( $ idn Url , FILTER _VALIDATE _URL ) ) { $ invalid Urls [ ] = ( string ) $ url ; } } $ this - > assert ( count ( $ invalid Urls ) = = = 0 , 'Invalid urls found ( ' . implode ( ' , ' , $ invalid Urls ) . ' ) . ' ) ; } 
public function do Run ( Input Interface $ input , Output Interface $ output ) { $ this - > register Commands ( ) ; return parent : : do Run ( $ input , $ output ) ; } 
private function register Commands ( ) { $ this - > add ( new Scan Command ( ) ) ; $ this - > add ( new Explain Command ( ) ) ; $ this - > add ( new Warm Up Command ( ) ) ; $ this - > add ( new Custom Command ( ) ) ; } 
public function get Section ( $ section ) { if ( $ this - > has Section ( $ section ) ) { return $ this - > config Array [ $ section ] ; } else { throw new \ Runtime Exception ( 'The section ( ' . $ section . ' ) you are trying to access does not exist . ' ) ; } } 
public function process ( $ results , Response Interface $ response ) { foreach ( $ this - > reporters as $ reporter ) { $ reporter - > process Results ( $ results , $ response ) ; } } 
protected function execute ( Input Interface $ input , Output Interface $ output ) { $ this - > init ( $ input , $ output , $ input - > get Argument ( 'url ' ) ) ; $ this - > init Configuration ( new Uri ( $ input - > get Argument ( 'url ' ) ) , $ this - > event Dispatcher ) ; $ time Strategy = $ this - > config - > get Extension ( ' _Smoke Stop ' ) - > get Strategy ( ' _Time Stop ' ) ; $ time Strategy - > init ( $ input - > get Option ( 'duration ' ) ) ; return $ this - > scan ( ) ; } 
private function init Configuration ( Uri $ uri , Dispatcher $ dispatcher ) { $ config Array = $ this - > get Config Array ( _ _DIR _ _ . ' / . . / . . /settings /warmup .yml ' ) ; $ config = new Configuration ( $ uri , $ dispatcher , $ config Array ) ; $ crawler = $ config - > get Extension ( ' _Response Retriever ' ) - > get Retriever ( ) ; $ crawler - > set Start Page ( $ uri ) ; $ this - > config = $ config ; } 
protected function execute ( Input Interface $ input , Output Interface $ output ) { $ this - > init ( $ input , $ output ) ; $ this - > init Configuration ( $ input - > get Option ( 'config _file ' ) , $ this - > event Dispatcher ) ; if ( $ input - > get Option ( 'bootstrap ' ) ) { include $ input - > get Option ( 'bootstrap ' ) ; } return $ this - > scan ( ) ; } 
private function init Configuration ( $ config File , Dispatcher $ dispatcher ) { $ config Array = $ this - > get Config Array ( $ config File , true ) ; if ( is _string ( $ config Array ) ) { throw new \ Runtime Exception ( 'Unable to load config file . Please check ' . $ config File ) ; } $ this - > config = new Configuration ( new Uri ( 'http : / /www .example .com ' ) , $ dispatcher , $ config Array ) ; } 
public static function get Subscribed Events ( ) { return [ Events : : POST _COMMENTED = > 'on Post Commented ' , Events : : POST _VOTED = > 'on Post Voted ' , Events : : COMMENT _VOTED = > 'on Comment Voted ' , Events : : USER _MENTIONED _COMMENT = > 'on User Mentioned ' , Events : : CATEGORY _FOLLOWED = > 'on Category Followed ' ] ; } 
public function on Post Commented ( Post Commented Event $ event ) { if ( $ event - > get Post ( ) - > get User ( ) = = = $ event - > get Comment ( ) - > get User ( ) ) { return ; } $ notification = $ this - > notification Helper - > create Comment Post Notification ( $ event - > get Post ( ) , $ event - > get Comment ( ) ) ; $ this - > notification Helper - > send Notification ( $ event - > get Post ( ) - > get User ( ) , $ notification ) ; } 
public function on Post Voted ( Vote Post Event $ event ) { if ( $ event - > get Post ( ) - > get User ( ) = = = $ event - > get Voter ( ) ) { return ; } $ this - > notification Helper - > create Vote Post Notification ( $ event - > get Post ( ) , $ event - > get Voter ( ) ) ; } 
public function on Comment Voted ( Vote Comment Event $ event ) { 
public function on User Mentioned ( Comment Mention User Event $ event ) { foreach ( $ event - > get Mentioned Users ( ) as $ user ) { if ( $ event - > get Comment ( ) - > get User ( ) = = = $ user | | $ event - > get Comment ( ) - > get Post ( ) - > get User ( ) = = = $ user ) { continue ; } $ this - > notification Helper - > create Mention User In Post Notification ( $ event - > get Comment ( ) ) ; } } 
public function on Category Followed ( Category Followed Event $ event ) { if ( $ event - > get Category ( ) - > get Creator ( ) = = = $ event - > get Follower ( ) ) { return ; } $ this - > notification Helper - > create Follow Category Notification ( $ event - > get Category ( ) , $ event - > get Follower ( ) ) ; } 
public function inbox Action ( Request $ request ) { $ threads = $ this - > provider - > get Inbox Threads Pager ( $ request - > query - > get ( 'page ' , 1 ) ) ; return $ this - > render ( $ this - > configuration - > get Template ( 'Chat :inbox .html .twig ' ) , [ 'threads ' = > $ threads ] ) ; } 
public function sent Action ( Request $ request ) { $ threads = $ this - > provider - > get Sent Threads Pager ( $ request - > query - > get ( 'page ' , 1 ) ) ; return $ this - > render ( $ this - > configuration - > get Template ( 'Chat :sent .html .twig ' ) , [ 'threads ' = > $ threads ] ) ; } 
public function create Action ( Request $ request ) { $ this - > deny Access Unless Granted ( 'IS _AUTHENTICATED _REMEMBERED ' ) ; $ username = $ request - > query - > get ( 'mail _to ' ) ; $ user = $ this - > get User Manager ( ) - > find User By Name ( $ username ) ; if ( is _null ( $ user ) ) { throw $ this - > create Not Found Exception ( ) ; } $ form = $ this - > create Form ( New Chat Type : : class , $ this - > create Blank Thread Message ( $ user ) ) ; $ form Handler = $ this - > get ( 'fos _message .new _thread _form .handler ' ) ; if ( $ message = $ form Handler - > process ( $ form ) ) { return new Redirect Response ( $ this - > get ( 'router ' ) - > generate ( 'fos _message _thread _view ' , [ 'thread Id ' = > $ message - > get Thread ( ) - > get Id ( ) , ] ) ) ; } return $ this - > render ( $ this - > configuration - > get Template ( 'Chat :new _chat .html .twig ' ) , array ( 'form ' = > $ form - > create View ( ) , 'recipient ' = > $ user , 'data ' = > $ form - > get Data ( ) , ) ) ; } 
public function get Config Tree Builder ( ) { $ tree Builder = new Tree Builder ( ) ; $ root Node = $ tree Builder - > root ( 'phpdish _chat ' ) ; $ root Node - > children ( ) - > array Node ( 'resources ' ) - > children ( ) - > array Node ( 'message ' ) - > children ( ) - > scalar Node ( 'interface ' ) - > default Value ( \ FOS \ Message Bundle \ Model \ Message : : class ) - > cannot Be Empty ( ) - > end ( ) - > scalar Node ( 'model ' ) - > default Value ( Message : : class ) - > cannot Be Empty ( ) - > end ( ) - > end ( ) - > end ( ) - > array Node ( 'message _metadata ' ) - > children ( ) - > scalar Node ( 'interface ' ) - > default Value ( \ FOS \ Message Bundle \ Model \ Message Metadata : : class ) - > cannot Be Empty ( ) - > end ( ) - > scalar Node ( 'model ' ) - > default Value ( Message Metadata : : class ) - > cannot Be Empty ( ) - > end ( ) - > end ( ) - > end ( ) - > array Node ( 'message _thread ' ) - > children ( ) - > scalar Node ( 'interface ' ) - > default Value ( \ FOS \ Message Bundle \ Model \ Thread Interface : : class ) - > cannot Be Empty ( ) - > end ( ) - > scalar Node ( 'model ' ) - > default Value ( Thread : : class ) - > cannot Be Empty ( ) - > end ( ) - > end ( ) - > end ( ) - > array Node ( 'message _thread _metadata ' ) - > children ( ) - > scalar Node ( 'interface ' ) - > default Value ( \ FOS \ Message Bundle \ Model \ Thread Metadata : : class ) - > cannot Be Empty ( ) - > end ( ) - > scalar Node ( 'model ' ) - > default Value ( Thread Metadata : : class ) - > cannot Be Empty ( ) - > end ( ) - > end ( ) - > end ( ) - > end ( ) - > end ( ) - > end ( ) ; $ this - > add Templates Section ( $ root Node ) ; return $ tree Builder ; } 
public function execute ( Input Interface $ input , Output Interface $ output ) { $ this - > raw Command = $ this - > get Application ( ) - > get ( 'sylius :theme :assets :install ' ) ; $ this - > set Help ( $ this - > raw Command - > get Help ( ) ) ; $ arguments = array ( 'command ' = > 'sylius :theme :assets :install ' , 'target ' = > $ input - > get Argument ( 'target ' ) , ' - -symlink ' = > $ input - > get Option ( 'symlink ' ) , ' - -relative ' = > $ input - > get Option ( 'relative ' ) , ) ; $ greet Input = new Array Input ( $ arguments ) ; $ this - > raw Command - > run ( $ greet Input , $ output ) ; } 
public function translate Wallet History Type ( $ history ) { switch ( $ history - > get Type ( ) ) { case Payment Interface : : TYPE _BUY _BOOK : $ text = $ this - > translator - > trans ( 'payment .type .buy _book ' ) ; break ; case Payment Interface : : TYPE _FOLLOW _CATEGORY : $ text = $ this - > translator - > trans ( 'payment .type .subscribe _category ' ) ; break ; case Payment Interface : : TYPE _CATEGORY _INCOME : $ text = $ this - > translator - > trans ( 'payment .type .category _income ' ) ; break ; case Payment Interface : : TYPE _BOOK _INCOME : $ text = $ this - > translator - > trans ( 'payment .type .book _income ' ) ; break ; case Payment Interface : : TYPE _WITHDRAW : $ text = $ this - > translator - > trans ( 'payment .type .withdraw ' ) ; break ; default : $ text = $ this - > translator - > trans ( 'payment .type .unknown ' ) ; } return $ text ; } 
public function translate Wallet History Status ( Wallet History Interface $ history ) { switch ( $ history - > get Status ( ) ) { case Payment Interface : : STATUS _OK : if ( $ history - > is Income ( ) ) { $ text = $ this - > translator - > trans ( 'payment .status .have _received ' ) ; } elseif ( $ history - > get Type ( ) = = = Payment Interface : : TYPE _WITHDRAW ) { $ text = $ this - > translator - > trans ( 'payment .status .have _tansfer ' ) ; } else { $ text = $ this - > translator - > trans ( 'payment .status .paid ' ) ; } break ; case Payment Interface : : STATUS _WAITING : if ( $ history - > get Type ( ) = = = Payment Interface : : TYPE _WITHDRAW ) { $ text = $ this - > translator - > trans ( 'payment .status .processing ' ) ; } else { $ text = $ this - > translator - > trans ( 'payment .status .unpaid ' ) ; } break ; case Payment Interface : : STATUS _CLOSED : $ text = $ this - > translator - > trans ( 'payment .status .closed ' ) ; break ; default : $ text = $ this - > translator - > trans ( 'payment .status .unknown ' ) ; } return $ text ; } 
public function load ( Object Manager $ manager ) { $ title = ' 基 于 PHP 的 内 网 穿 透 工 具 “Spike ” ' ; $ body = < < <EOT Spike [ https : 之 前 由 于 要 与 一 个 同 事 远 程 协 作 开 发 一 款app 需 要 用 到 内 网 穿 透 服 务 ， 在 网 上 找 到 了frp 与ngrok ； 后 来 我 在 想 能 不 能 用php 也 写 出 来 一 个 这 样 的 服 务 软 件 ？ 大 家 都 知 道php 多 进 程 多 线 程 不 够 友 好 ， 在window 上 还 不 支 持 ； 写 服 务 确 实 很 吃 力 ； 不 过 幸 运 的 是 有 [React PHP ] (https : 基 于React PHP 的IO 多 路 复 用 ， 使 得Spike 并 没 有 比Frp 性 能 差 太 多 ； 下 面 是 我 简 单 做 的 一 个benchmark ， 基 于apache ab 检 验http 隧 道 的 服 务 性 能 ； 客 户 端 与 服 务 端 都 搭 在 本 地 ， 代 理 同 事 电 脑 上 的http 服 务 。 不 是 特 别 符 合 应 用 场 景 ， 大 家 简 单 看 一 下 。 Spike : ` ` ` Concurrency Level : 1 0 Time taken for tests : 3 7 . 7 2 7 seconds Complete requests : 1 0 0 Failed requests : 0 Total transferred : 2 5 6 9 9 0 0 bytes HTML transferred : 2 5 1 4 6 0 0 bytes Requests per second : 2 . 6 5 [ # /sec ] (mean ) Time per request : 3 7 7 2 . 7 4 7 [ms ] (mean ) Time per request : 3 7 7 . 2 7 5 [ms ] (mean , across all concurrent requests ) Transfer rate : 6 6 . 5 2 [Kbytes /sec ] received Connection Times (ms ) min mean [ + / -sd ] median max Connect : 0 0 0 . 4 0 3 Processing : 5 3 3 3 6 0 2 5 9 1 . 9 3 7 1 4 4 0 9 6 Waiting : 5 1 6 3 5 8 7 5 9 2 . 3 3 7 0 1 4 0 7 6 Total : 5 3 4 3 6 0 2 5 9 1 . 9 3 7 1 5 4 0 9 7 Percentage of the requests served within a certain time (ms ) 5 0 % 3 7 1 5 6 6 % 3 7 9 1 7 5 % 3 8 2 2 8 0 % 3 8 4 4 9 0 % 3 9 7 0 9 5 % 4 0 1 5 9 8 % 4 0 5 3 9 9 % 4 0 9 7 1 0 0 % 4 0 9 7 (longest request ) ` ` ` Frp : ` ` ` Concurrency Level : 1 0 Time taken for tests : 3 8 . 2 3 0 seconds Complete requests : 1 0 0 Failed requests : 0 Total transferred : 2 5 6 9 9 0 0 bytes HTML transferred : 2 5 1 4 6 0 0 bytes Requests per second : 2 . 6 2 [ # /sec ] (mean ) Time per request : 3 8 2 3 . 0 4 5 [ms ] (mean ) Time per request : 3 8 2 . 3 0 4 [ms ] (mean , across all concurrent requests ) Transfer rate : 6 5 . 6 5 [Kbytes /sec ] received Connection Times (ms ) min mean [ + / -sd ] median max Connect : 0 0 0 . 2 0 1 Processing : 3 7 9 3 6 5 0 6 4 4 . 4 3 8 0 9 4 1 4 0 Waiting : 3 6 0 3 6 3 3 6 4 5 . 5 3 7 8 9 4 1 2 4 Total : 3 8 0 3 6 5 0 6 4 4 . 4 3 8 0 9 4 1 4 0 Percentage of the requests served within a certain time (ms ) 5 0 % 3 8 0 9 6 6 % 3 8 4 7 7 5 % 3 9 0 9 8 0 % 3 9 2 3 9 0 % 4 0 2 6 9 5 % 4 0 5 3 9 8 % 4 1 2 9 9 9 % 4 1 4 0 1 0 0 % 4 1 4 0 (longest request ) ` ` ` 从 上 面 可 以 看 出Spike 性 能 要 稍 微 好 点 ， 不 过 这 个 地 方 有 点 不 公 平 ， 我 在 做spike 的 测 试 时 只 开 启 了 服 务 端 的 日 志 ， 客 户 端 的 日 志 是 关 闭 的 ； 而FRP 的 两 端 日 志 都 是 开 启 的 ； 我 不 知 道 怎 么 关frp 的 日 志 ； 在 这 里 简 单 提 一 点 由 于Spike 的 日 志IO 是 同 步 的 所 以 日 志 的 读 写 会 耗 掉 部 分 性 能 ， 提 升 日 志 等 级 减 少 日 志 写 入 可 以 提 升 不 少 的 性 能 ； 最 后 再 次 附 上 项 目 地 址 ： [https : EOT ; $ this - > create Topic ( $ title , $ body ) ; $ title = 'Composer 的 源 管 理 工 具 Composer Registry Manager ' ; $ body = < < <EOT 惯 例 先 附 上 项 目 地 址 ： [https : 之 前 使 用 的 是 简 称 ， 由 于crm 容 易 与 常 说 的crm 系 统 混 淆 ， 所 以 这 次 改 成 全 称 并 重 新 在packagist 发 布 了 ； 如 果 以 前 安 装 的 同 学 请 先 使 用 下 面 命 令 卸 载 ` ` `bash $ composer global remove slince /crm ` ` ` 使 用 下 面 命 令 安 装 ` ` `bash $ composer global require slince /composer -registry -manager ^ 1 . 2 ` ` ` 此 次 在 1 . 2 版 本 中 做 了 个 不 小 的 重 构 ，API 没 有 做 任 何 改 变 ， 主 要 改 善 了 下 以 前 的 一 些 写 法 ， 重 写 了 部 分 单 元 测 试 ； 除 此 之 外 将 源 管 理 配 置 从 库 文 件 的 位 置 移 出 ： Windows 下 移 至 `C : \Users \ 用 户 名 下 \App Data \Roaming \Composer Registry Manager \crm .json ` Linux 下 移 至 ` ~ / .config /composer -registry -manager /crm .json ` 从 而 修 复 了 因 版 本 升 级 导 致 原 先 做 的 配 置 丢 失 的 问 题 ； 上 一 张GIF 图 : ! [screenshot ] (https : 感 谢 [NRM ] (http : 再 次 附 上 地 址 ； 欢 迎star ， 欢 迎fork ； [https : EOT ; $ this - > create Topic ( $ title , $ body ) ; } 
protected function create Topic ( $ title , $ body ) { $ manager = $ this - > get Topic Manager ( ) ; $ topic = $ manager - > create Topic ( $ this - > get Reference ( 'general -user ' ) ) ; $ topic - > set Updated At ( Carbon : : now ( ) ) - > set Title ( $ title ) - > set Original Body ( $ body ) - > set Threads ( [ $ this - > get Reference ( 'thread -share ' ) ] ) - > set Enabled ( true ) ; $ manager - > save Topic ( $ topic ) ; } 
public function on Kernel Request ( Get Response Event $ event ) { $ request = $ event - > get Request ( ) ; $ locale = null ; if ( ! $ request - > has Previous Session ( ) ) { $ locale = $ this - > get Client Preferred Locale ( $ request ) ; } elseif ( ! $ request - > attributes - > get ( ' _locale ' ) ) { $ locale = $ request - > get Session ( ) - > get ( ' _locale ' , $ this - > get Client Preferred Locale ( $ request ) ) ; } if ( $ locale ! = = null ) { $ request - > set Locale ( $ locale ) ; } } 
public function get Config Tree Builder ( ) { $ tree Builder = new Tree Builder ( ) ; $ root Node = $ tree Builder - > root ( 'phpdish _user ' ) ; $ root Node - > children ( ) - > scalar Node ( 'avatar _downloader ' ) - > is Required ( ) - > cannot Be Empty ( ) - > end ( ) - > array Node ( 'resources ' ) - > children ( ) - > array Node ( 'user ' ) - > children ( ) - > scalar Node ( 'interface ' ) - > default Value ( User Interface : : class ) - > cannot Be Empty ( ) - > end ( ) - > scalar Node ( 'model ' ) - > default Value ( User : : class ) - > cannot Be Empty ( ) - > end ( ) - > end ( ) - > end ( ) - > array Node ( 'profile ' ) - > children ( ) - > scalar Node ( 'interface ' ) - > default Value ( Profile Interface : : class ) - > cannot Be Empty ( ) - > end ( ) - > scalar Node ( 'model ' ) - > default Value ( Profile : : class ) - > cannot Be Empty ( ) - > end ( ) - > end ( ) - > end ( ) - > array Node ( 'point _history ' ) - > children ( ) - > scalar Node ( 'interface ' ) - > default Value ( Point History Interface : : class ) - > cannot Be Empty ( ) - > end ( ) - > scalar Node ( 'model ' ) - > default Value ( Point History : : class ) - > cannot Be Empty ( ) - > end ( ) - > end ( ) - > end ( ) - > end ( ) - > end ( ) - > end ( ) ; $ this - > add Templates Section ( $ root Node ) ; return $ tree Builder ; } 
protected function execute ( Input Interface $ input , Output Interface $ output ) { $ output Style = new Symfony Style ( $ input , $ output ) ; $ output Style - > writeln ( ' <info >Installing PHPDish . . . < /info > ' ) ; $ output Style - > writeln ( static : : PHPDISH _LOGO ) ; $ this - > ensure Directory Writable And Exists ( $ this - > get Container ( ) - > get Parameter ( 'kernel .cache _dir ' ) , $ output ) ; $ this - > ensure Directory Writable And Exists ( $ this - > get Container ( ) - > get Parameter ( 'app .dir .media ' ) , $ output ) ; $ this - > ensure Directory Writable And Exists ( $ this - > get Container ( ) - > get Parameter ( 'app .dir .uploads ' ) , $ output ) ; $ this - > ensure Directory Writable And Exists ( $ this - > get Container ( ) - > get Parameter ( 'app .dir .avatar ' ) , $ output ) ; $ this - > get Application ( ) - > set Auto Exit ( false ) ; foreach ( $ this - > commands as $ index = > $ command ) { $ output Style - > new Line ( ) ; $ output Style - > section ( sprintf ( 'Step %d of %d . <info > %s < /info > ' , $ index + 1 , count ( $ this - > commands ) , $ command [ 'message ' ] ) ) ; $ this - > execute Command ( $ command [ 'command ' ] , $ output , isset ( $ command [ 'options ' ] ) ? $ command [ 'options ' ] : [ ] ) ; } $ output - > writeln ( 'PHPDish has been successfully installed . ' ) ; } 
public function get ( $ source Class ) { if ( isset ( $ this - > factories [ $ source Class ] ) ) { $ factory = $ this - > factory [ $ source Class ] ; $ grid = $ factory - > get Grid ( ) ; } else { $ reflection = new \ Reflection Class ( $ source Class ) ; if ( ! $ reflection - > is Instantiable ( ) ) { throw new \ Invalid Argument Exception ( sprintf ( 'The " %s " cannot be instantiated ' ) ) ; } $ grid = $ this - > factory - > create Grid ( $ source Class ) ; } 
public function on User Followed ( User Followed Event $ event ) { if ( $ event - > get User ( ) = = = $ event - > get Follower ( ) ) { return ; } $ notification = $ this - > notification Helper - > create Follow User Notification ( $ event - > get Follower ( ) ) ; $ this - > notification Helper - > send Notification ( $ event - > get User ( ) , $ notification ) ; } 
public function index Action ( Request $ request ) { $ manager = $ this - > get Topic Manager ( ) ; $ criteria = Criteria : : create ( ) ; $ criteria - > order By ( [ 'is Top ' = > 'desc ' , 'last Comment At ' = > 'desc ' ] ) - > where ( Criteria : : expr ( ) - > eq ( 'enabled ' , true ) ) ; $ tab = $ request - > query - > get ( 'tab ' ) ; if ( $ tab = = = 'following ' ) { $ this - > deny Access Unless Granted ( 'IS _AUTHENTICATED _REMEMBERED ' ) ; 
public function create Action ( Request $ request ) { $ this - > deny Access Unless Granted ( 'IS _AUTHENTICATED _REMEMBERED ' ) ; $ manager = $ this - > get Topic Manager ( ) ; $ topic = $ manager - > create Topic ( $ this - > get User ( ) ) ; $ form = $ this - > create Form ( Topic Type : : class , $ topic ) ; $ form - > handle Request ( $ request ) ; if ( $ form - > is Submitted ( ) & & $ form - > is Valid ( ) ) { $ manager - > save Topic ( $ topic ) ; 
public function view Action ( $ id , Request $ request ) { $ topic = $ this - > get Topic Manager ( ) - > find Topic By Id ( $ id ) ; if ( ! $ topic | | ! $ topic - > is Enabled ( ) ) { throw $ this - > create Not Found Exception ( ) ; } $ replies = $ this - > get Reply Manager ( ) - > find Topic Replies ( $ topic , $ request - > query - > get Int ( 'page ' , 1 ) ) ; $ reply = $ this - > get Reply Manager ( ) - > create Reply ( $ topic , $ this - > get User ( ) ) ; $ form = $ this - > create Form ( Topic Reply Type : : class , $ reply ) ; 
public function edit Action ( $ id , Request $ request ) { $ topic = $ this - > get Topic Manager ( ) - > find Topic By Id ( $ id ) ; if ( ! $ topic ) { throw $ this - > create Not Found Exception ( ) ; } $ this - > deny Access Unless Granted ( 'edit ' , $ topic ) ; $ form = $ this - > create Form ( Topic Type : : class , $ topic ) ; $ form - > handle Request ( $ request ) ; if ( $ form - > is Submitted ( ) & & $ form - > is Valid ( ) ) { $ this - > get Topic Manager ( ) - > save Topic ( $ topic ) ; return $ this - > redirect To Route ( 'topic _view ' , [ 'id ' = > $ topic - > get Id ( ) , ] ) ; } return $ this - > render ( $ this - > configuration - > get Template ( 'Topic :create .html .twig ' ) , [ 'form ' = > $ form - > create View ( ) , 'topic ' = > $ topic , 'threads ' = > $ this - > get Thread Manager ( ) - > find Enabled Threads ( 1 0 ) ] ) ; } 
public function delete Action ( $ id ) { $ topic = $ this - > get Topic Manager ( ) - > find Topic By Id ( $ id ) ; if ( ! $ topic | | ! $ topic - > is Enabled ( ) ) { throw $ this - > create Not Found Exception ( ) ; } $ this - > deny Access Unless Granted ( 'edit ' , $ topic ) ; $ this - > get Topic Manager ( ) - > block Topic ( $ topic ) ; return $ this - > handle View ( $ this - > view ( [ 'result ' = > true , ] ) ) ; } 
public function reply Topic Action ( $ id , Request $ request ) { $ this - > deny Access Unless Granted ( 'IS _AUTHENTICATED _REMEMBERED ' ) ; $ topic = $ this - > get Topic Manager ( ) - > find Topic By Id ( $ id ) ; $ reply = $ this - > get Reply Manager ( ) - > create Reply ( $ topic , $ this - > get User ( ) ) ; $ form = $ this - > create Form ( Topic Reply Type : : class , $ reply ) ; $ form - > handle Request ( $ request ) ; $ view = $ this - > view ( ) - > set Format ( 'json ' ) ; if ( $ form - > is Submitted ( ) & & $ form - > is Valid ( ) ) { $ this - > get Reply Manager ( ) - > save Reply ( $ reply ) ; 
public function toggle Recommend Action ( $ id ) { $ topic = $ this - > get Topic Manager ( ) - > find Topic By Id ( $ id ) ; if ( ! $ topic | | ! $ topic - > is Enabled ( ) ) { throw $ this - > create Not Found Exception ( ) ; } $ this - > deny Access Unless Granted ( 'ROLE _ADMIN ' , $ topic ) ; $ topic - > set Recommended ( ! $ topic - > is Recommended ( ) ) ; $ manager = $ this - > get Doctrine ( ) - > get Manager ( ) ; $ manager - > persist ( $ topic ) ; $ manager - > flush ( ) ; return $ this - > handle View ( $ this - > view ( [ 'is _recommended ' = > $ topic - > is Recommended ( ) , ] ) ) ; } 
public function toggle Top Action ( $ id ) { $ topic = $ this - > get Topic Manager ( ) - > find Topic By Id ( $ id ) ; if ( ! $ topic | | ! $ topic - > is Enabled ( ) ) { throw $ this - > create Not Found Exception ( ) ; } $ this - > deny Access Unless Granted ( 'ROLE _ADMIN ' , $ topic ) ; $ topic - > set Top ( ! $ topic - > is Top ( ) ) ; $ manager = $ this - > get Doctrine ( ) - > get Manager ( ) ; $ manager - > persist ( $ topic ) ; $ manager - > flush ( ) ; return $ this - > handle View ( $ this - > view ( [ 'is _top ' = > $ topic - > is Top ( ) , ] ) ) ; } 
public function toggle Voter Action ( $ id ) { $ this - > deny Access Unless Granted ( 'IS _AUTHENTICATED _REMEMBERED ' ) ; $ topic = $ this - > get Topic Manager ( ) - > find Topic By Id ( $ id ) ; if ( ! $ topic ) { throw new \ Invalid Argument Exception ( $ this - > get ( 'translator ' ) - > trans ( 'topic .not _exists ' ) ) ; } if ( $ is Voted = $ topic - > is Voted By ( $ this - > get User ( ) ) ) { $ this - > get Topic Manager ( ) - > remove Voter ( $ topic , $ this - > get User ( ) ) ; } else { $ this - > get Topic Manager ( ) - > add Voter ( $ topic , $ this - > get User ( ) ) ; } return $ this - > json ( [ 'vote _count ' = > $ topic - > get Vote Count ( ) , 'is _voted ' = > ! $ is Voted ] ) ; } 
public function get User Topics Action ( $ username , Request $ request ) { $ user = $ this - > get User Manager ( ) - > find User By Name ( $ username ) ; $ topics = $ this - > get Topic Manager ( ) - > find User Topics ( $ user , $ request - > query - > get Int ( 'page ' , 1 ) ) ; return $ this - > render ( $ this - > configuration - > get Template ( 'Topic :user _topics .html .twig ' ) , [ 'user ' = > $ user , 'topics ' = > $ topics , ] ) ; } 
public function today Hot Topics Action ( $ limit = null ) { $ date = Carbon : : today ( ) - > modify ( ' - 1 0 0 days ' ) ; $ topics = $ this - > get Topic Manager ( ) - > find Hot Topics ( $ date , $ limit ? : 1 0 ) ; return $ this - > render ( $ this - > configuration - > get Template ( 'Topic : _today _hot .html .twig ' ) , [ 'topics ' = > $ topics , ] ) ; } 
public function push ( $ title , $ route = null , $ route Parameters = [ ] ) { $ this - > crumbs [ ] = [ 'title ' = > $ title , 'route ' = > $ route , 'route Parameters ' = > $ route Parameters ] ; } 
public function unshift ( $ title , $ route = null , $ route Parameters = [ ] ) { array _unshift ( $ this - > crumbs , [ 'title ' = > $ title , 'route ' = > $ route , 'route Parameters ' = > $ route Parameters ] ) ; } 
public function remove ( $ title ) { $ this - > crumbs = array _filter ( $ this - > crumbs , function ( $ crumb ) use ( $ title ) { return $ crumb [ 'title ' ] ! = = $ title ; } ) ; } 
public function load ( Object Manager $ manager ) { $ manager = $ this - > get Category Manager ( ) ; $ category = $ manager - > create Category ( $ this - > get Reference ( 'general -user ' ) ) ; $ category - > set Name ( ' 小 风 的PHP 研 究 所 ' ) - > set Description ( ' 小 风 的PHP 研 究 所 ' ) - > set Slug ( 'php -labs ' ) ; $ manager - > save Category ( $ category ) ; $ this - > add Reference ( 'general -category ' , $ category ) ; } 
public function generate ( $ id String , $ width = 2 5 6 ) { $ avatar = new MDAvatars ( $ id String , $ width ) ; $ tmp File = sys _get _temp _dir ( ) . ' / ' . md 5 ( uniqid ( 'avatar ' ) ) ; $ avatar - > Save ( $ tmp File , $ width ) ; $ content = new Stream ( fopen ( $ tmp File , 'r + ' ) ) ; $ file = new File ( $ this - > namer - > transform With Extension ( 'png ' ) , $ content ) ; $ this - > file Manager - > upload ( $ file ) ; @ unlink ( $ tmp File ) ; return $ file ; } 
public function withdraw Action ( $ id ) { $ form = $ this - > create Form ( Withdraw Type : : class ) ; $ history = $ this - > admin - > get Subject ( ) ; $ request = $ this - > get Request ( ) ; $ form - > handle Request ( $ request ) ; if ( $ form - > is Submitted ( ) & & $ form - > is Valid ( ) ) { $ translator = $ this - > get ( 'translator ' ) ; $ wallet Manager = $ this - > get Wallet Manager ( ) ; $ action = $ form - > get Data ( ) [ 'action ' ] ; $ note = $ form - > get Data ( ) [ 'note ' ] ; if ( $ action = = = 'approve ' ) { $ wallet Manager - > approve Withdraw ( $ history , $ note ) ; $ this - > add Flash ( 'sonata _flash _success ' , $ translator - > trans ( 'payment .withdraw _approve ' ) ) ; } else { $ wallet Manager - > refuse Withdraw ( $ history , $ note ) ; $ this - > add Flash ( 'sonata _flash _success ' , $ translator - > trans ( 'payment .withdraw _declined ' ) ) ; } return $ this - > redirect ( $ this - > admin - > generate Url ( 'list ' , [ 'filter ' = > $ this - > admin - > get Filter Parameters ( ) ] ) ) ; } $ form View = $ form - > create View ( ) ; return $ this - > render With Extra Params ( 'PHPDish Admin Bundle :Payment :handle _withdraw .html .twig ' , [ 'action ' = > 'withdraw ' , 'form ' = > $ form View , 'history ' = > $ history ] , null ) ; } 
public function load Source ( $ columns , $ page = 1 , $ limit = Grid Interface : : MAX _RESULTS _NUM ) { $ this - > initialize ( ) ; $ qb = $ this - > create Query Builder ( ) ; 
public function get Functions ( ) : array { return [ new \ Twig _Simple Function ( 'get _category ' , [ $ this - > category Manager , 'find Category By Id ' ] ) , new \ Twig _Simple Function ( 'get _category _by _slug ' , [ $ this - > category Manager , 'find Category By Slug ' ] ) , new \ Twig _Simple Function ( 'get _categories ' , [ $ this , 'get Categories ' ] ) , new \ Twig _Simple Function ( 'get _categories _pager ' , [ $ this - > category Manager , 'find Categories Pager ' ] ) , new \ Twig _Simple Function ( 'get _post ' , [ $ this - > post Manager , 'find Post By Id ' ] ) , new \ Twig _Simple Function ( 'get _posts ' , [ $ this , 'get Posts ' ] ) , new \ Twig _Simple Function ( 'get _posts _pager ' , [ $ this - > post Manager , 'find Posts Pager ' ] ) , new \ Twig _Simple Function ( 'get _comment ' , [ $ this - > comment Manager , 'find Comment By Id ' ] ) , new \ Twig _Simple Function ( 'get _comments ' , [ $ this , 'get Comments ' ] ) , new \ Twig _Simple Function ( 'get _comments _pager ' , [ $ this - > comment Manager , 'find Comments Pager ' ] ) , ] ; } 
public function get Categories ( $ criteria , array $ order By = [ ] , ? int $ limit = null ) { if ( $ criteria instanceof Criteria ) { return $ this - > category Manager - > find Categories ( $ criteria ) ; } else { return $ this - > category Manager - > get Category Repository ( ) - > find By ( $ criteria , $ order By , $ limit ) ; } } 
public function get Posts ( $ criteria , array $ order By = [ ] , ? int $ limit = null ) { if ( $ criteria instanceof Criteria ) { return $ this - > post Manager - > find Posts ( $ criteria ) ; } else { return $ this - > post Manager - > get Post Repository ( ) - > find By ( $ criteria , $ order By , $ limit ) ; } } 
public function get Comments ( $ criteria , array $ order By = [ ] , ? int $ limit = null ) { if ( $ criteria instanceof Criteria ) { return $ this - > comment Manager - > find Comments ( $ criteria ) ; } else { return $ this - > comment Manager - > get Comment Repository ( ) - > find By ( $ criteria , $ order By , $ limit ) ; } } 
public function upload ( File Interface $ file , $ overwrite = true ) { $ body = $ file - > get Content ( ) ; if ( $ body instanceof Stream Interface ) { 
public function download ( File Interface $ file , $ streaming = true ) { if ( $ streaming ) { $ this - > assert Streaming Support ( ) ; 
public function has ( $ file ) { $ key = $ file instanceof File Interface ? $ file - > get Key ( ) : $ file ; return $ this - > filesystem - > has ( $ key ) ; } 
public function remove Locale ( $ locale ) { if ( ( $ key = array _search ( $ this - > enabled Locales , $ locale ) ) ! = = false ) { unset ( $ this - > enabled Locales [ $ key ] ) ; } } 
public function load ( array $ configs , Container Builder $ container ) { $ configuration = new Configuration ( ) ; $ config = $ this - > process Configuration ( $ configuration , $ configs ) ; if ( $ config [ 'templates _namespace ' ] ) { $ container - > set Parameter ( 'phpdish .templates _namespace ' , $ config [ 'templates _namespace ' ] ) ; } 
protected function add Templates Section ( Array Node Definition $ root Node ) { $ root Node - > children ( ) - > scalar Node ( 'templates _namespace ' ) - > default Null ( ) - > end ( ) - > array Node ( 'templates ' ) - > scalar Prototype ( ) - > end ( ) - > end ( ) - > end ( ) ; } 
public function create Post ( User Interface $ user ) { $ post = new $ this - > post Entity ; $ post - > set User ( $ user ) ; return $ post ; } 
public function save Post ( Post Interface $ post ) { if ( ! $ post - > get Id ( ) ) { $ post - > get Category ( ) - > set Post Count ( $ post - > get Category ( ) - > get Post Count ( ) + 1 ) ; } 
public function find Posts ( Criteria $ criteria ) { return $ this - > get Post Repository ( ) - > create Query Builder ( 'p ' ) - > add Criteria ( $ criteria ) - > get Query ( ) - > get Result ( ) ; } 
public function find Posts Pager ( Criteria $ criteria , $ page = 1 , $ limit = null ) { $ query = $ this - > get Post Repository ( ) - > create Query Builder ( 'p ' ) - > add Criteria ( $ criteria ) - > get Query ( ) ; return $ this - > create Paginator ( $ query , $ page , $ limit ) ; } 
public function find Category Posts ( Category Interface $ category , $ page = 1 , $ limit = null ) { $ qb = $ this - > get Post Repository ( ) - > create Query Builder ( 'p ' ) - > join ( 'p .user ' , 'pu ' ) - > add Select ( 'pu ' ) - > where ( 'p .category = :category ' ) - > set Parameter ( 'category ' , $ category ) - > and Where ( 'p .enabled = :enabled ' ) - > set Parameter ( 'enabled ' , true ) - > order By ( 'p .created At ' , 'desc ' ) ; return $ this - > create Paginator ( $ qb - > get Query ( ) , $ page , $ limit ) ; } 
public function block Post ( Post Interface $ post ) { $ post - > disable ( ) ; $ this - > entity Manager - > persist ( $ post ) ; $ this - > entity Manager - > flush ( ) ; } 
public function increase Post Views ( Post Interface $ post , $ views = 1 ) { $ post - > add View Count ( $ views ) ; $ this - > entity Manager - > persist ( $ post ) ; $ this - > entity Manager - > flush ( ) ; } 
public function get User Post Count ( User Interface $ user , $ ignore Empty Post = true ) { $ qb = $ this - > get Post Repository ( ) - > create Query Builder ( 'p ' ) ; $ qb - > select ( $ qb - > expr ( ) - > count ( 'p ' ) ) - > where ( 'p .enabled = :enabled ' ) - > set Parameter ( 'enabled ' , true ) - > and Where ( 'p .user = :user ' ) - > set Parameter ( 'user ' , $ user ) ; if ( $ ignore Empty Post ) { $ qb - > and Where ( 'p .original Body is not null ' ) ; } return $ qb - > get Query ( ) - > get Single Scalar Result ( ) ; } 
public function add Voter ( Post Interface $ post , User Interface $ user ) { $ post - > add Voter ( $ user ) - > add Vote Count ( ) ; $ this - > entity Manager - > persist ( $ post ) ; $ this - > entity Manager - > flush ( ) ; 
public function remove Voter ( Post Interface $ post , User Interface $ user ) { $ post - > remove Voter ( $ user ) - > add Vote Count ( - 1 ) ; $ this - > entity Manager - > persist ( $ post ) ; $ this - > entity Manager - > flush ( ) ; } 
public function find Template ( $ template , $ throw = true ) { 
public function safe Chunk ( string $ html , float $ percent ) : string { return $ this - > html Chunker - > chunk ( $ html , $ percent ) ; } 
public function load User By OAuth User Response ( User Response Interface $ response ) { 
protected function create New User ( User Response Interface $ response ) { $ user = $ this - > user Manager - > create User ( ) - > set Enabled ( true ) - > set Username ( $ this - > generate Username ( $ response ) ) - > set Password ( ' ' ) - > set Email ( $ response - > get Email ( ) ? : ' ' ) - > set Created At ( $ now = Carbon : : now ( ) ) - > set Updated At ( $ now ) ; try { $ avatar = $ this - > file Downloader - > download ( $ response - > get Profile Picture ( ) ) ; $ user - > set Avatar ( $ avatar - > get Key ( ) ) ; } catch ( \ Exception $ exception ) { $ user - > set Avatar ( ' ' ) ; } return $ user ; } 
protected function generate Username ( User Response Interface $ response ) { $ username = $ response - > get Nickname ( ) ; return $ this - > user Manager - > find User By Username ( $ username ) ? $ username . $ response - > get Username ( ) : $ username ; } 
protected function get Authenticated User ( ) { return ( $ token = $ this - > token Storage - > get Token ( ) ) ? ( $ token - > get User ( ) instanceof User Interface ? $ token - > get User ( ) : null ) : null ; } 
public function process ( Container Builder $ container ) { if ( $ algolia Client = $ container - > find Definition ( 'algolia _client ' ) ) { $ algolia Client - > set Arguments ( [ ' %algolia .application _id % ' , ' %algolia .api _key % ' , ] ) ; } 
public function get Current Theme ( ) { if ( $ this - > theme = = = null ) { $ this - > theme = $ this - > theme Context - > get Theme ( ) ; } return $ this - > theme ; } 
public function get Themes ( ) { if ( $ this - > themes = = = null ) { $ this - > themes = $ this - > theme Finder - > find ( ) ; } return $ this - > themes ; } 
public function get Filter By Operator ( $ operator ) { 
protected function create Pagerfanta ( $ keyword , $ entity , $ options ) { $ page = $ options [ 'page ' ] ? ? 1 ; $ length = $ options [ 'length ' ] ? ? 1 0 ; unset ( $ options [ 'page ' ] ) ; unset ( $ options [ 'length ' ] ) ; 
private function resolve Status Code ( \ Exception $ exception ) { if ( $ exception instanceof Http Exception Interface ) { $ status Code = $ exception - > get Status Code ( ) ; } else { if ( in _array ( $ exception - > get Code ( ) , array _keys ( Response : : $ status Texts ) ) ) { $ status Code = $ exception - > get Code ( ) ; } else { $ status Code = static : : DEFAULT _STATUS _CODE ; } } return $ status Code ; } 
private function create Forbidden Response For API ( ) { if ( $ this - > authorization Checker - > is Granted ( 'IS _AUTHENTICATED _REMEMBERED ' ) ) { $ response = new Json Response ( [ 'error ' = > ' 访 问 拒 绝 ' , ] , Response : : HTTP _FORBIDDEN ) ; } else { $ response = new Json Response ( [ 'error ' = > ' 请 先 登 录 ' , 'redirect ' = > $ this - > router - > generate ( 'login ' ) , ] , Response : : HTTP _FORBIDDEN ) ; } return $ response ; } 
public function process Body Image ( $ body ) { return preg _replace _callback ( ' # <img src = " ( . * ) " # ' , function ( $ matches ) { if ( strpos ( 'http ' , $ matches [ 1 ] ) = = = 0 ) { return $ matches [ 0 ] ; } return str _replace ( $ matches [ 1 ] , $ this - > base Url . $ matches [ 1 ] , $ matches [ 0 ] ) ; } , $ body ) ; } 
public function build Media Url ( $ key , $ alias = null ) { $ service Id = $ alias ? 'phpdish .media .url _builder . ' . $ alias : 'phpdish .media .url _builder ' ; try { $ url Builder = $ this - > container - > get ( $ service Id ) ; } catch ( Service Not Found Exception $ exception ) { throw new \ Invalid Argument Exception ( sprintf ( 'Invalid Media Service Alias " %s " ' , $ alias ) ) ; } return $ url Builder - > build ( $ key ) ; } 
public function parse ( $ name ) : Template Reference Interface { if ( $ name instanceof Template Reference Interface ) { return $ name ; } if ( isset ( $ this - > cache [ $ name ] ) ) { return $ this - > cache [ $ name ] ; } 
public function build ( Container Builder $ container ) { parent : : build ( $ container ) ; $ container - > add Compiler Pass ( new Algolia Pass ( ) ) ; $ container - > add Compiler Pass ( new Register Plugin Pass ( ) ) ; $ container - > add Compiler Pass ( new Inject Assets Pass ( ) ) ; } 
public function delete Action ( $ id ) { $ manager = $ this - > get Reply Manager ( ) ; $ reply = $ manager - > find Reply By Id ( $ id ) ; if ( ! $ reply ) { throw $ this - > create Not Found Exception ( ) ; } $ this - > deny Access Unless Granted ( 'edit ' , $ reply ) ; $ manager - > block Reply ( $ reply ) ; return $ this - > handle View ( $ this - > view ( [ 'result ' = > true , ] ) ) ; } 
public function get User Replies Action ( $ username , Request $ request ) { $ user = $ this - > get User Manager ( ) - > find User By Name ( $ username ) ; $ replies = $ this - > get Reply Manager ( ) - > find User Replies ( $ user , $ request - > query - > get Int ( 'page ' , 1 ) ) ; return $ this - > render ( $ this - > configuration - > get Template ( 'Topic :user _replies .html .twig ' ) , [ 'user ' = > $ user , 'replies ' = > $ replies , ] ) ; } 
public function toggle Voter Action ( $ id ) { $ this - > deny Access Unless Granted ( 'IS _AUTHENTICATED _REMEMBERED ' ) ; $ reply = $ this - > get Reply Manager ( ) - > find Reply By Id ( $ id ) ; if ( ! $ reply ) { throw new \ Invalid Argument Exception ( $ this - > get ( 'translator ' ) - > trans ( 'reply .not _exists ' ) ) ; } if ( $ is Voted = $ reply - > is Voted By ( $ this - > get User ( ) ) ) { $ this - > get Reply Manager ( ) - > remove Voter ( $ reply , $ this - > get User ( ) ) ; } else { $ this - > get Reply Manager ( ) - > add Voter ( $ reply , $ this - > get User ( ) ) ; } return $ this - > json ( [ 'vote _count ' = > $ reply - > get Vote Count ( ) , 'is _voted ' = > ! $ is Voted ] ) ; } 
protected function get Templates ( Twig _Environment $ environment ) { if ( $ this - > templates ) { return $ this - > templates ; } $ this - > templates [ ] = $ environment - > load ( $ this - > default Template ) ; if ( $ this - > theme ) { if ( ! $ this - > theme instanceof \ Twig _Template & & ! $ this - > theme instanceof \ Twig _Template Wrapper ) { $ template = $ environment - > load ( $ this - > theme ) ; } else { $ template = $ this - > theme ; } $ this - > templates [ ] = $ template ; } return $ this - > templates ; } 
public function check ( ) { $ this - > ensure Exists ( $ this - > directory ) ; $ this - > ensure Is Writable ( $ this - > directory ) ; return true ; } 
public function ensure Is Writable ( $ directory ) { if ( is _writable ( $ directory ) ) { return ; } try { $ this - > filesystem - > chmod ( $ directory , 0 7 5 5 ) ; $ this - > output - > writeln ( sprintf ( ' <comment >Changed " %s " permissions to 0 7 5 5 . < /comment > ' , realpath ( $ directory ) ) ) ; } catch ( IOException $ exception ) { $ this - > output - > writeln ( ' ' ) ; $ this - > output - > writeln ( ' <error >Cannot run command due to bad directory permissions (tried to change permissions to 0 7 5 5 ) . < /error > ' ) ; $ this - > output - > writeln ( ' ' ) ; throw new \ Runtime Exception ( sprintf ( 'Set " %s " writable and run command " <comment > %s < /comment > " ' , realpath ( dirname ( $ directory ) ) , $ this - > name ) ) ; } } 
public function ensure Exists ( $ directory ) { if ( is _dir ( $ directory ) ) { return ; } try { $ this - > filesystem - > mkdir ( $ directory , 0 7 5 5 ) ; $ this - > output - > writeln ( sprintf ( ' <comment >Created " %s " directory . < /comment > ' , realpath ( $ directory ) ) ) ; } catch ( IOException $ exception ) { $ this - > output - > writeln ( ' ' ) ; $ this - > output - > writeln ( ' <error >Cannot run command due to unexisting directory (tried to create it automatically , failed ) . < /error > ' ) ; $ this - > output - > writeln ( ' ' ) ; throw new \ Runtime Exception ( sprintf ( 'Create directory " %s " and run command " <comment > %s < /comment > " ' , realpath ( $ directory ) , $ this - > name ) ) ; } } 
public function factory ( ) { $ source = new Entity ( self : : get Source Class ( ) ) ; $ grid Builder = $ this - > grid Factory - > create Builder ( 'grid ' , $ source , [ 'persistence ' = > true , 'route ' = > 'admin _user _index ' , 'filterable ' = > true , 'sortable ' = > true , 'max _per _page ' = > 2 0 , ] ) ; $ this - > add Columns ( $ grid Builder ) ; $ this - > add Filters ( $ grid Builder ) ; return $ grid Builder - > get Grid ( ) ; } 
public function on Payment Paid ( Payment Event $ event ) { $ payment = $ event - > get Payment ( ) ; 
public function find Threads ( Criteria $ criteria ) { return $ this - > get Thread Repository ( ) - > create Query Builder ( 't ' ) - > add Criteria ( $ criteria ) - > get Query ( ) - > get Result ( ) ; } 
public function find Threads Pager ( Criteria $ criteria , $ page , $ limit = null ) { $ qb = $ this - > get Thread Repository ( ) - > create Query Builder ( 't ' ) - > add Criteria ( $ criteria ) ; return $ this - > create Paginator ( $ qb - > get Query ( ) , $ page , $ limit ) ; } 
public function find User Following Threads ( User Interface $ user , $ page , $ limit = null , Criteria $ criteria = null ) { $ qb = $ this - > get Thread Repository ( ) - > create Query Builder ( 't ' ) - > left Join ( 't .followers ' , 'f ' ) - > where ( 'f .id = :user Id ' ) - > set Parameter ( 'user Id ' , $ user ) ; $ criteria & & $ qb - > add Criteria ( $ criteria ) ; return $ this - > create Paginator ( $ qb - > get Query ( ) , $ page , $ limit ) ; } 
public function find Threads By Names ( $ names ) { $ qb = $ this - > get Thread Repository ( ) - > create Query Builder ( 't ' ) ; return $ qb - > where ( $ qb - > expr ( ) - > in ( 't .name ' , $ names ) ) - > get Query ( ) - > get Result ( ) ; } 
public function save Thread ( Thread Interface $ thread ) { $ this - > entity Manager - > persist ( $ thread ) ; $ this - > entity Manager - > flush ( ) ; } 
public function create Threads By Names ( $ names ) { $ threads = [ ] ; foreach ( $ names as $ name ) { $ thread = $ this - > create Thread ( ) ; $ thread - > set Name ( $ name ) - > set Slug ( $ this - > pinyin - > permalink ( $ name ) ) - > set Description ( $ name ) ; $ threads [ ] = $ thread ; } return $ threads ; } 
public function search Threads ( $ term ) { $ qb = $ this - > get Thread Repository ( ) - > create Query Builder ( 't ' ) ; return $ qb - > where ( $ qb - > expr ( ) - > like ( 't .name ' , ' :term ' ) ) - > or Where ( $ qb - > expr ( ) - > like ( 't .description ' , ' :term ' ) ) - > set Parameter ( 'term ' , " % { $term } % " ) - > set Max Results ( 1 0 ) - > get Query ( ) - > get Result ( ) ; } 
public function follow Thread ( Thread Interface $ thread , User Interface $ user ) { $ thread - > add Follower ( $ user ) ; $ thread - > set Follower Count ( $ thread - > get Follower Count ( ) + 1 ) ; $ this - > save Thread ( $ thread ) ; } 
public function un Follow Thread ( Thread Interface $ thread , User Interface $ user ) { $ thread - > remove Follower ( $ user ) ; $ thread - > set Follower Count ( $ thread - > get Follower Count ( ) - 1 ? : 0 ) ; $ this - > save Thread ( $ thread ) ; } 
public function check ( ) { $ table = new Table ( $ this - > output ) ; $ fulfilled = true ; foreach ( $ this - > requirements as $ requirement ) { $ row = [ $ requirement - > get Label ( ) ] ; if ( $ requirement - > is Fulfilled ( ) ) { $ row [ ] = ' <info >Yes < /info > ' ; $ fulfilled = $ fulfilled & & true ; } elseif ( $ requirement - > is Required ( ) ) { $ row [ ] = ' <error >Error < /error > ' ; $ fulfilled = $ fulfilled & & false ; } else { $ row [ ] = ' <comment >Warning < /comment > ' ; $ fulfilled = $ fulfilled & & true ; } $ table - > add Row ( $ row ) ; } $ table - > render ( ) ; return $ fulfilled ; } 
private function get Interfaces Mapping ( array $ resources ) : array { $ interfaces = [ ] ; foreach ( $ resources as $ alias = > $ resource ) { foreach ( $ resource as $ resource Item ) { $ interfaces [ $ resource Item [ 'interface ' ] ] = $ resource Item [ 'model ' ] ; } } return $ interfaces ; } 
public function create Payment ( User Interface $ user = null ) { $ payment = new $ this - > payment Entity ; $ now = Carbon : : now ( ) ; $ payment - > set User ( $ user ) - > set Status ( Payment Interface : : STATUS _WAITING ) - > set Created At ( $ now ) - > set Updated At ( $ now ) ; return $ payment ; } 
public function save Payment ( Payment Interface $ payment ) { 
public function charge ( Payment Interface $ payment ) { $ qr Code = $ this - > youzan Pay - > charge ( [ 'name ' = > strip _tags ( $ payment - > get Description ( ) ) , 'price ' = > $ payment - > get Amount ( ) , 'source ' = > $ payment - > get Serial No ( ) ] ) ; $ payment - > set Qr Id ( $ qr Code - > get Id ( ) ) ; $ this - > save Payment ( $ payment ) ; return $ qr Code ; } 
public function notify Payment ( $ qr Id ) { $ payment = $ this - > find Payment By Qr Id ( $ qr Id ) ; if ( ! $ payment ) { return null ; } 
public function locate ( $ file , $ current Path = null , $ first = true ) { if ( $ this - > current Theme & & $ file [ 0 ] = = = ' @ ' ) { $ bundle Name = substr ( $ file , 1 ) ; if ( false ! = = strpos ( $ bundle Name , ' / ' ) ) { list ( $ bundle Name , $ path ) = explode ( ' / ' , $ bundle Name , 2 ) ; } if ( in _array ( $ bundle Name , $ this - > theme Manager - > get Namespaces ( ) ) ) { try { $ file Path = $ this - > _kernel - > locate Resource ( $ file , $ this - > current Theme - > get Path ( ) , $ first ) ; return $ file Path ; } catch ( \ Exception $ exception ) { 
public function find All ( ) { if ( ! file _exists ( $ this - > installed Json ) ) { return [ ] ; } $ installed = \ Guzzle Http \ json _decode ( file _get _contents ( $ this - > installed Json ) , true ) ; foreach ( $ installed as $ package ) { if ( ! isset ( $ package [ 'type ' ] ) | | $ package [ 'type ' ] ! = = 'phpdish -plugin ' | | ! isset ( $ package [ 'extra ' ] [ 'phpdish ' ] [ 'class ' ] ) | | ! class _exists ( $ package [ 'extra ' ] [ 'phpdish ' ] [ 'class ' ] ) ) { continue ; } $ plugin Class = $ package [ 'extra ' ] [ 'phpdish ' ] [ 'class ' ] ; $ this - > plugins [ ] = $ this - > initialize Plugin ( $ plugin Class ) ; } return $ this - > plugins ; } 
public function load ( Object Manager $ manager ) { $ job = new Thread ( ) ; $ job - > set Created At ( Carbon : : now ( ) ) - > set Updated At ( Carbon : : now ( ) ) - > set Enabled ( true ) - > set Name ( ' 招 聘 ' ) - > set Slug ( 'job ' ) - > set Description ( ' 招 聘 节 点 ' ) ; $ question = new Thread ( ) ; $ question - > set Created At ( Carbon : : now ( ) ) - > set Updated At ( Carbon : : now ( ) ) - > set Enabled ( true ) - > set Name ( ' 问 答 ' ) - > set Slug ( 'question ' ) - > set Description ( ' 问 答 节 点 ' ) ; $ share = new Thread ( ) ; $ share - > set Created At ( Carbon : : now ( ) ) - > set Updated At ( Carbon : : now ( ) ) - > set Enabled ( true ) - > set Name ( ' 创 造 与 分 享 ' ) - > set Slug ( 'creation -share ' ) - > set Description ( ' 创 造 与 分 享 ' ) ; $ manager - > persist ( $ job ) ; $ manager - > persist ( $ question ) ; $ manager - > persist ( $ share ) ; $ manager - > flush ( ) ; $ this - > add Reference ( 'thread -share ' , $ share ) ; } 
public function upload ( Request $ request ) { $ uploaded File = $ request - > files - > get ( static : : UPLOAD _FIELD _NAME ) ; if ( is _null ( $ uploaded File ) ) { throw new \ Invalid Argument Exception ( 'Bad arguments ' ) ; } list ( $ uploader , $ url Builder ) = $ this - > get Uploader And Builder ( $ request ) ; $ file = $ uploader - > upload ( $ uploaded File ) ; $ response = [ 'key ' = > $ file - > get Key ( ) , 'path ' = > $ url Builder - > build ( $ file ) ] ; if ( $ file instanceof Image ) { $ response [ 'thumb ' ] = $ url Builder - > build Image Resize Url ( $ file , 'middle _square ' ) ; } $ file - > get Content ( ) - > close ( ) ; return $ this - > json ( $ response ) ; } 
protected function get Uploader And Builder ( Request $ request ) { if ( $ config Key = $ request - > headers - > get ( 'media _mapping ' ) ) { $ uploader = $ this - > get ( 'phpdish _media .file _uploader . ' . $ config Key ) ; $ url Builder = $ this - > get ( 'phpdish _media .url _builder . ' . $ config Key ) ; } else { $ uploader = $ this - > get ( 'phpdish _media .file _uploader ' ) ; $ url Builder = $ this - > get ( 'phpdish _media .url _builder ' ) ; } return [ $ uploader , $ url Builder ] ; } 
public function format ( $ money ) { if ( ! $ money instanceof Money ) { $ money = new Money ( $ money , new Currency ( 'RMB ' ) ) ; } return $ this - > formatter - > format ( $ money ) ; } 
public function process ( Container Builder $ container ) { $ listener Registry = $ container - > get Parameter ( 'phpdish .plugin .listener _registry ' ) ; $ event Dispatcher Definition = $ container - > find Definition ( 'event _dispatcher ' ) ; foreach ( $ listener Registry as $ index = > $ listener ) { if ( is _array ( $ listener ) ) { list ( $ event Name , $ listener , $ priority ) = $ listener ; if ( is _array ( $ listener ) ) { list ( $ class , $ method ) = $ listener ; } else { $ class = $ listener ; $ method = ' _ _invoke ' ; } $ id = 'phpdish .plugin .listener _ ' . $ index ; $ listener Definition = new Definition ( $ class ) ; $ listener Definition - > set Autowired ( true ) ; $ container - > set Definition ( $ id , $ listener Definition ) ; $ event Dispatcher Definition - > add Method Call ( 'add Listener ' , [ $ event Name , [ new Service Closure Argument ( new Reference ( $ id ) ) , $ method ] , $ priority ] ) ; } else { $ id = 'phpdish .plugin .subscriber _ ' . $ index ; $ listener Definition = new Definition ( $ listener ) ; $ listener Definition - > set Autowired ( true ) ; $ container - > set Definition ( $ id , $ listener Definition ) ; $ event Dispatcher Definition - > add Method Call ( 'add Subscriber ' , [ new Reference ( $ id ) ] ) ; } } $ container - > get Parameter Bag ( ) - > remove ( 'phpdish .plugin .listener _registry ' ) ; } 
public function get ( $ source Class ) { if ( isset ( $ this - > factory [ $ source Class ] ) ) { $ factory = $ this - > factory [ $ source Class ] ; $ grid = $ factory - > factory ( ) ; } else { $ reflection = new \ Reflection Class ( $ source Class ) ; if ( ! $ reflection - > is Instantiable ( ) ) { throw new \ Invalid Argument Exception ( sprintf ( 'The " %s " cannot be instantiated ' ) ) ; } $ source = new Entity ( $ source Class ) ; $ this - > grid - > set Source ( $ source ) ; $ grid = $ this - > grid ; } 
public function load ( array $ configs , Container Builder $ container ) { 
public function load ( Object Manager $ manager ) { $ friend Link = new Friend Link ( ) ; $ friend Link - > set Name ( 'PHPDish ' ) - > set Url ( 'https : / /www .phpdish .com ' ) ; $ this - > get Friend Link Manager ( ) - > save Friend Link ( $ friend Link ) ; } 
public function find All Templates ( ) { if ( null ! = = $ this - > templates ) { return $ this - > templates ; } 
private function find Templates In Bundle ( Bundle Interface $ bundle ) { $ name = $ bundle - > get Name ( ) ; $ templates = array _merge ( $ this - > find Templates In Folder ( $ bundle - > get Path ( ) . ' /Resources /views ' ) , $ this - > find Templates In Folder ( $ this - > root Dir . ' / ' . $ name . ' /views ' ) ) ; 
public function load ( array $ configs , Container Builder $ container ) { $ configuration = new Configuration ( ) ; $ config = $ this - > process Configuration ( $ configuration , $ configs ) ; $ loader = new Loader \ Yaml File Loader ( $ container , new File Locator ( _ _DIR _ _ . ' / . . /Resources /config ' ) ) ; $ loader - > load ( 'services .yml ' ) ; if ( isset ( $ config [ 'youzan ' ] ) ) { $ container - > set Definition ( 'phpdish .payment _gateway .youzan .api _context ' , new Definition ( Api Context : : class , [ $ config [ 'youzan ' ] [ 'client _id ' ] , $ config [ 'youzan ' ] [ 'client _secret ' ] , $ config [ 'youzan ' ] [ 'kdt _id ' ] ] ) ) ; if ( $ container - > has Definition ( 'phpdish .payment _gateway .youzan ' ) ) { $ youzan Pay Def = $ container - > get Definition ( 'phpdish .payment _gateway .youzan ' ) ; $ youzan Pay Def - > replace Argument ( 0 , new Reference ( 'phpdish .payment _gateway .youzan .api _context ' ) ) ; } } 
public function on Category Persist ( Category Persist Event $ event ) { $ category = $ event - > get Category ( ) ; $ cover = $ category - > get Cover ( ) ; if ( ! $ cover | | $ cover = = = ' /avatar /user 1 .jpg ' ) { $ avatar = $ this - > avatar Generator - > generate ( $ category - > get Name ( ) ) ; $ category - > set Cover ( $ avatar - > get Key ( ) ) ; } } 
public function create User Link ( $ user ) { return sprintf ( ' <a href = " %s " target = " _blank " data -username = " %s " > @ %s < /a > ' , $ this - > router - > generate ( 'user _view ' , [ 'username ' = > $ user - > get Username ( ) , ] ) , $ user - > get Username ( ) , $ user - > get Username ( ) ) ; } 
public function create Action ( Request $ request ) { $ this - > deny Access Unless Granted ( 'IS _AUTHENTICATED _REMEMBERED ' ) ; $ manager = $ this - > get Payment Manager ( ) ; $ payment = $ manager - > create Payment ( $ this - > get User ( ) ) ; $ form = $ this - > create Form ( Payment Type : : class , $ payment ) ; $ form - > handle Request ( $ request ) ; if ( $ form - > is Valid ( ) & & $ form - > is Submitted ( ) ) { $ manager - > save Payment ( $ payment ) ; $ qr Code = $ manager - > charge ( $ payment ) ; return $ this - > json ( [ 'payment ' = > $ payment , 'qrcode ' = > $ qr Code ] ) ; } throw new \ Invalid Argument Exception ( 'Invalid request ' ) ; } 
public function get Payment Result Action ( Request $ request ) { $ qr Id = $ request - > query - > get ( 'qr _id ' ) ; if ( ! $ qr Id ) { throw new \ Invalid Argument Exception ( "Bad Request " ) ; } $ result = $ this - > get ( 'phpdish .payment _gateway .youzan ' ) - > check QRStatus ( $ qr Id ) ; if ( $ result ) { 
public function notify Action ( Request $ request ) { $ you Zan Pay = $ this - > get ( 'phpdish .payment _gateway .youzan ' ) ; try { $ result = $ you Zan Pay - > verify Webhook ( $ request ) ; $ trade = $ you Zan Pay - > get Trade ( $ result [ 'id ' ] ) ; if ( $ trade ) { 
public function withdraw Action ( Request $ request ) { $ this - > deny Access Unless Granted ( 'IS _AUTHENTICATED _REMEMBERED ' ) ; $ wallet Manager = $ this - > get Wallet Manager ( ) ; $ wallet = $ wallet Manager - > get User Wallet ( $ this - > get User ( ) ) ; $ history = $ wallet Manager - > withdraw ( $ wallet , $ request - > request - > get ( 'amount ' ) , $ request - > request - > get ( 'alipay _account ' ) ) ; $ view = $ this - > view ( [ 'history ' = > $ history ] ) - > set Context ( ( new Context ( ) ) - > set Groups ( [ 'Default ' ] ) ) ; return $ this - > handle View ( $ view ) ; } 
public function get Wallet Action ( Request $ request ) { $ this - > deny Access Unless Granted ( 'IS _AUTHENTICATED _REMEMBERED ' ) ; $ wallet = $ this - > get Wallet Manager ( ) - > get User Wallet ( $ this - > get User ( ) ) ; $ histories = $ this - > get Wallet Manager ( ) - > find User Wallet Histories ( $ wallet , $ request - > query - > get Int ( 'page ' , 1 ) ) ; return $ this - > render ( $ this - > configuration - > get Template ( 'Wallet :index .html .twig ' ) , [ 'wallet ' = > $ wallet , 'histories ' = > $ histories ] ) ; } 
public function get Summary ( ) { return $ this - > get Posts ( ) - > matching ( Criteria : : create ( ) - > where ( Criteria : : expr ( ) - > is Null ( 'parent ' ) ) - > and Where ( Criteria : : expr ( ) - > eq ( 'enabled ' , true ) ) ) ; } 
public function create Action ( Request $ request ) { $ this - > deny Access Unless Granted ( 'IS _AUTHENTICATED _REMEMBERED ' ) ; $ manager = $ this - > get Category Manager ( ) ; $ category = $ manager - > create Category ( $ this - > get User ( ) ) ; $ form = $ this - > create Form ( Category Type : : class , $ category ) ; $ form - > handle Request ( $ request ) ; $ translator = $ this - > get ( 'translator ' ) ; if ( ( $ number = $ manager - > get User Categories Number ( $ this - > get User ( ) ) ) > = 2 ) { $ this - > add Flash ( 'danger ' , $ translator - > trans ( 'category .more _than _ 2 _categories ' , [ ' %count % ' = > $ number ] ) ) ; } if ( $ form - > is Submitted ( ) & & $ form - > is Valid ( ) ) { 
public function view Action ( $ slug , Request $ request ) { $ category = $ this - > get Category Manager ( ) - > find Category By Slug ( $ slug ) ; $ criteria = Criteria : : create ( ) - > where ( Criteria : : expr ( ) - > eq ( 'category ' , $ category - > get Id ( ) ) ) - > and Where ( Criteria : : expr ( ) - > eq ( 'enabled ' , true ) ) ; if ( $ request - > query - > get ( 'orderby ' ) = = = 'hot ' ) { $ criteria - > order By ( [ 'view Count ' = > 'desc ' , 'created At ' = > 'desc ' , ] ) ; } else { $ criteria - > order By ( [ 'created At ' = > 'desc ' , ] ) ; } $ posts = $ this - > get Post Manager ( ) - > find Posts Pager ( $ criteria , $ request - > query - > get Int ( 'page ' , 1 ) ) ; return $ this - > render ( $ this - > configuration - > get Template ( 'Category :view .html .twig ' ) , [ 'category ' = > $ category , 'posts ' = > $ posts , ] ) ; } 
public function edit Action ( $ slug , Request $ request ) { $ manager = $ this - > get Category Manager ( ) ; $ category = $ manager - > find Category By Slug ( $ slug ) ; if ( ! $ category ) { throw $ this - > create Not Found Exception ( ) ; } $ this - > deny Access Unless Granted ( 'edit ' , $ category ) ; $ form = $ this - > create Form ( Category Type : : class , $ category ) ; $ form - > handle Request ( $ request ) ; if ( $ form - > is Valid ( ) & & $ form - > is Submitted ( ) ) { $ manager - > save Category ( $ category ) ; $ this - > add Flash ( 'success ' , $ this - > get ( 'translator ' ) - > trans ( 'category .edit _success ' ) ) ; return $ this - > redirect To Route ( 'category _view ' , [ 'slug ' = > $ category - > get Slug ( ) , ] ) ; } return $ this - > render ( $ this - > configuration - > get Template ( 'Category :create .html .twig ' ) , [ 'form ' = > $ form - > create View ( ) , 'category ' = > $ category , 'has Many Categories ' = > false , 'is Book ' = > false ] ) ; } 
public function get Followers Action ( $ slug , Request $ request ) { $ category = $ this - > get Category Manager ( ) - > find Category By Slug ( $ slug ) ; $ users = $ this - > get User Manager ( ) - > find Category Followers ( $ category , $ request - > query - > get Int ( 'page ' , 1 ) ) ; return $ this - > render ( $ this - > configuration - > get Template ( 'Category :followers .html .twig ' ) , [ 'category ' = > $ category , 'users ' = > $ users , ] ) ; } 
public function follow Action ( $ slug ) { $ this - > deny Access Unless Granted ( 'IS _AUTHENTICATED _REMEMBERED ' ) ; $ category = $ this - > get Category Manager ( ) - > find Category By Slug ( $ slug ) ; if ( $ category - > is Charging ( ) & & ! $ category - > is Belongs To ( $ this - > get User ( ) ) ) { 
public function un Follow Action ( $ slug ) { $ this - > deny Access Unless Granted ( 'IS _AUTHENTICATED _REMEMBERED ' ) ; $ category = $ this - > get Category Manager ( ) - > find Category By Slug ( $ slug ) ; $ this - > get Category Manager ( ) - > un Follow Category ( $ category , $ this - > get User ( ) ) ; $ view = $ this - > view ( [ 'follower _count ' = > $ category - > get Follower Count ( ) , ] ) ; return $ this - > handle View ( $ view ) ; } 
public function user Categories Action ( User Interface $ user ) { $ categories = $ this - > get Category Manager ( ) - > find User Categories ( $ user ) ; return $ this - > render ( $ this - > configuration - > get Template ( 'Category :user _categories .html .twig ' ) , [ 'categories ' = > $ categories , 'user ' = > $ user , ] ) ; } 
public function on Topic Replied ( Reply Topic Event $ event ) { if ( $ event - > get Topic ( ) - > get User ( ) = = = $ event - > get Reply ( ) - > get User ( ) ) { return ; } $ notification = $ this - > notification Helper - > create Reply Topic Notification ( $ event - > get Topic ( ) , $ event - > get Reply ( ) ) ; $ this - > notification Helper - > send Notification ( $ event - > get Topic ( ) - > get User ( ) , $ notification ) ; } 
public function on Topic Voted ( Vote Topic Event $ event ) { 
public function on Reply Voted ( Vote Reply Event $ event ) { 
public function on User Mentioned ( Reply Mention User Event $ event ) { 
public function get Theme ( ) { if ( $ this - > current Theme Name ) { foreach ( $ this - > theme Finder - > find ( ) as $ theme ) { if ( $ theme - > get Name ( ) = = = $ this - > current Theme Name ) { return $ theme ; } } throw new \ Invalid Argument Exception ( sprintf ( 'The theme " %s " is not found ' , $ this - > current Theme Name ) ) ; } return null ; } 
public function load ( array $ configs , Container Builder $ container ) { $ configuration = new Configuration ( ) ; $ config = $ this - > process Configuration ( $ configuration , $ configs ) ; 
public function add Post Count ( $ count = 1 ) { $ this - > post Count + = $ count ; $ this - > post Count = max ( $ this - > post Count , 0 ) ; return $ this ; } 
public function create Action ( Request $ request ) { $ this - > deny Access Unless Granted ( 'IS _AUTHENTICATED _REMEMBERED ' ) ; $ manager = $ this - > get Book Manager ( ) ; $ book = $ manager - > create Book ( $ this - > get User ( ) ) ; $ form = $ this - > create Form ( Book Type : : class , $ book ) ; $ form - > handle Request ( $ request ) ; $ translator = $ this - > get ( 'translator ' ) ; if ( ( $ number = $ manager - > get User Book Number ( $ this - > get User ( ) ) ) > = 5 ) { $ this - > add Flash ( 'danger ' , $ translator - > trans ( 'book .more _than _ 5 _books ' , [ ' %count % ' = > $ number ] ) ) ; } if ( $ form - > is Submitted ( ) & & $ form - > is Valid ( ) ) { $ manager - > save Book ( $ book ) ; $ this - > add Flash ( 'success ' , $ translator - > trans ( 'book .add _success ' ) ) ; return $ this - > redirect To Route ( 'book _view ' , [ 'slug ' = > $ book - > get Slug ( ) , ] ) ; } return $ this - > render ( $ this - > configuration - > get Template ( 'Category :create .html .twig ' ) , [ 'form ' = > $ form - > create View ( ) , 'has Many Categories ' = > $ number > = 5 , 'is Book ' = > true ] ) ; } 
public function view Action ( $ slug , Request $ request ) { $ book = $ this - > get Book Manager ( ) - > find Book ( $ slug ) ; return $ this - > render ( $ this - > configuration - > get Template ( 'Book :view .html .twig ' ) , [ 'book ' = > $ book , ] ) ; } 
public function edit Action ( $ slug , Request $ request ) { $ manager = $ this - > get Book Manager ( ) ; $ book = $ manager - > find Book ( $ slug ) ; if ( ! $ book ) { throw $ this - > create Not Found Exception ( ) ; } $ this - > deny Access Unless Granted ( 'edit ' , $ book ) ; $ form = $ this - > create Form ( Book Type : : class , $ book ) ; $ form - > handle Request ( $ request ) ; if ( $ form - > is Valid ( ) & & $ form - > is Submitted ( ) ) { $ manager - > save Book ( $ book ) ; $ this - > add Flash ( 'success ' , $ this - > get ( 'translator ' ) - > trans ( 'book .edit _success ' ) ) ; return $ this - > redirect To Route ( 'book _view ' , [ 'slug ' = > $ book - > get Slug ( ) , ] ) ; } return $ this - > render ( $ this - > configuration - > get Template ( 'Category :create .html .twig ' ) , [ 'form ' = > $ form - > create View ( ) , 'category ' = > $ book , 'has Many Categories ' = > false , 'is Book ' = > true ] ) ; } 
public function get Summary Action ( $ slug ) { $ book = $ this - > get Book Manager ( ) - > find Book ( $ slug ) ; $ chapters Tree = $ this - > get Book Manager ( ) - > find Book Chapters Tree ( $ book ) ; return $ this - > render ( $ this - > configuration - > get Template ( 'Book :summary .html .twig ' ) , [ 'book ' = > $ book , 'chapters Tree ' = > $ chapters Tree ] ) ; } 
public function get Followers Action ( $ slug , Request $ request ) { $ book = $ this - > get Book Manager ( ) - > find Book ( $ slug ) ; $ users = $ this - > get User Manager ( ) - > find Category Followers ( $ book , $ request - > query - > get Int ( 'page ' , 1 ) ) ; return $ this - > render ( $ this - > configuration - > get Template ( 'Book :followers .html .twig ' ) , [ 'book ' = > $ book , 'users ' = > $ users , ] ) ; } 
public function view Chapter Action ( $ slug , $ chapter Id , Request $ request ) { $ book = $ this - > get Book Manager ( ) - > find Book ( $ slug ) ; $ chapter = $ this - > get Book Manager ( ) - > find Chapter ( $ chapter Id ) ; $ chapters Tree = $ this - > get Book Manager ( ) - > find Book Chapters Tree ( $ book ) ; 
public function get User Books Action ( $ username , Request $ request ) { $ user = $ this - > get User Manager ( ) - > find User By Name ( $ username ) ; $ books = $ this - > get Book Manager ( ) - > find User Books ( $ user ) ; return $ this - > render ( $ this - > configuration - > get Template ( 'Book :user _books .html .twig ' ) , [ 'user ' = > $ user , 'books ' = > $ books ] ) ; } 
public function add Summary Action ( $ slug , Request $ request ) { $ book = $ this - > get Book Manager ( ) - > find Book ( $ slug ) ; $ this - > deny Access Unless Granted ( 'edit ' , $ book ) ; $ chapter = $ this - > get Book Manager ( ) - > add Book Chapter ( $ book , $ request - > request - > get ( 'title ' ) ) ; return $ this - > handle View ( $ this - > view ( [ 'chapter ' = > $ chapter ] ) - > set Context ( ( new Context ( ) ) - > set Groups ( [ 'Default ' ] ) ) ) ; } 
public function edit Summary Action ( $ slug , $ id , Request $ request ) { $ book = $ this - > get Book Manager ( ) - > find Book ( $ slug ) ; $ this - > deny Access Unless Granted ( 'edit ' , $ book ) ; $ chapter = $ this - > get Book Manager ( ) - > find Chapter ( $ id ) ; $ chapter - > set Title ( $ request - > request - > get ( 'title ' ) ) ; $ this - > get Post Manager ( ) - > save Post ( $ chapter ) ; return $ this - > handle View ( $ this - > view ( [ 'chapter ' = > $ chapter ] ) - > set Context ( ( new Context ( ) ) - > set Groups ( [ 'Default ' ] ) ) ) ; } 
public function add Chapter Action ( $ slug , Request $ request ) { $ book = $ this - > get Book Manager ( ) - > find Book ( $ slug ) ; $ this - > deny Access Unless Granted ( 'edit ' , $ book ) ; 
public function edit Chapter Action ( $ slug , $ id , Request $ request ) { $ book = $ this - > get Book Manager ( ) - > find Book ( $ slug ) ; $ this - > deny Access Unless Granted ( 'edit ' , $ book ) ; 
public function move Chapter Action ( $ slug , $ id , Request $ request ) { $ book = $ this - > get Book Manager ( ) - > find Book ( $ slug ) ; $ this - > deny Access Unless Granted ( 'edit ' , $ book ) ; $ chapter = $ this - > get Book Manager ( ) - > find Chapter ( $ id ) ; $ this - > get Book Manager ( ) - > move Book Chapter ( $ book , $ chapter , $ request - > request - > get ( 'direction ' ) , $ request - > request - > get ( 'step ' ) ) ; return $ this - > handle View ( $ this - > view ( [ 'chapter ' = > $ chapter ] ) - > set Context ( ( new Context ( ) ) - > set Groups ( [ 'Default ' ] ) ) ) ; } 
public function process ( Container Builder $ container ) { if ( ! $ container - > has Parameter ( 'phpdish .resources ' ) | | ! $ container - > has Definition ( 'phpdish _resource .resource _registry ' ) ) { return ; } $ resource Registry = $ container - > find Definition ( 'phpdish _resource .resource _registry ' ) ; $ resource Registry - > set Argument ( 0 , $ container - > get Parameter ( 'phpdish .resources ' ) ) ; } 
public function get Comparison ( ) { $ this - > assert Comparable ( ) ; return new Comparison ( $ this - > column - > get Name ( ) , $ this - > operator , $ this - > value ) ; } 
public function initialize ( $ data ) { $ this - > value = $ data [ 'value ' ] ; 
public function get Template ( $ key ) { if ( isset ( $ this - > templates [ $ key ] ) ) { return $ this - > templates [ $ key ] ; } return $ this - > default Template Namespace . ' : ' . $ key ; } 
public function create Menu ( array $ options = [ ] ) { $ menu = $ this - > factory - > create Item ( 'root ' ) ; $ menu - > set Children Attribute ( 'class ' , 'nav navbar -nav ' ) ; $ menu - > add Child ( 'homepage ' , [ 'label ' = > 'menu .homepage ' , 'route ' = > 'homepage ' , ] ) ; $ menu - > add Child ( 'Category ' , [ 'label ' = > 'menu .category ' , 'route ' = > 'post ' , ] ) ; $ menu - > add Child ( 'Topic ' , [ 'label ' = > 'menu .ask _question ' , 'route ' = > 'thread _view ' , 'route Parameters ' = > [ 'slug ' = > 'question ' , ] , ] ) ; $ menu - > add Child ( 'job ' , [ 'label ' = > 'menu .job ' , 'route ' = > 'thread _view ' , 'route Parameters ' = > [ 'slug ' = > 'job ' , ] , ] ) ; $ github = $ menu - > add Child ( 'Git Hub ' , [ 'label ' = > 'Git Hub ' , 'uri ' = > 'https : / /github .com /slince /phpdish ' ] ) ; $ github - > set Link Attribute ( 'target ' , ' _blank ' ) ; $ this - > event Dispatcher - > dispatch ( Events : : NAV _MENU _BUILT , new Filter Menu Event ( $ menu ) ) ; return $ menu ; } 
public function save Friend Link ( Friend Link $ friend Link ) { $ this - > entity Manager - > persist ( $ friend Link ) ; $ this - > entity Manager - > flush ( ) ; } 
public function add Column ( $ column , $ type , $ options = [ ] ) { if ( ! $ column instanceof Column Interface ) { $ column = $ this - > factory - > create Column ( $ column , $ type , $ options ) ; } $ this - > columns [ $ column - > get Name ( ) ] = $ column ; } 
protected function load Entities ( ) { if ( $ this - > request ) { if ( $ filters = $ this - > request - > get ( 'filters ' ) ) { $ this - > apply Filters ( $ filters ) ; } } $ this - > entities = $ this - > source - > load Source ( $ this - > columns ) ; } 
protected function apply Filters ( array $ filter Items ) { foreach ( $ filter Items as $ column Name = > $ filter Item ) { if ( is _numeric ( $ column Name ) ) { if ( ! is _array ( $ filter Item ) ) { 
public function transform ( $ value ) { if ( null = = = $ value ) { return ' ' ; } $ thread Names = [ ] ; foreach ( $ value as $ thread ) { if ( ! $ thread instanceof Thread Interface ) { throw new Unexpected Type Exception ( $ thread , Thread Interface : : class ) ; } $ thread Names [ ] = $ thread - > get Name ( ) ; } return implode ( ' , ' , $ thread Names ) ; } 
public function reverse Transform ( $ value ) { if ( null = = = $ value | | ' ' = = = $ value ) { return null ; } $ thread Names = array _unique ( array _filter ( array _map ( 'trim ' , explode ( ' , ' , $ value ) ) ) ) ; if ( count ( $ thread Names ) = = = 0 ) { return null ; } $ threads = $ this - > thread Manager - > find Threads By Names ( $ thread Names ) ; $ existing Thread Names = array _map ( function ( Thread Interface $ thread ) { return $ thread - > get Name ( ) ; } , $ threads ) ; 
public function process ( Container Builder $ container ) { $ this - > container = $ container ; $ this - > routing Loader Definition = $ container - > find Definition ( 'phpdish .plugin .route _loader ' ) ; $ this - > translator Definition = $ container - > find Definition ( 'translator ' ) ; 
public function install ( $ plugin Metadata ) { 
public function create Notification ( $ subject , $ message = null ) { $ notification = new $ this - > notification Entity ( ) ; $ notification - > set Subject ( $ subject ) ; $ message & & $ notification - > set Message ( $ message ) ; return $ notification ; } 
public function send Notification ( $ participants , Notification Interface $ notification , $ send = false ) { foreach ( $ participants as $ participant ) { $ metadata = new $ this - > metadata Entity ( ) ; $ metadata - > set Participant ( $ participant ) ; $ notification - > add Metadata ( $ metadata ) ; } $ this - > entity Manager - > persist ( $ notification ) ; $ send & & $ this - > entity Manager - > flush ( ) ; } 
public function find Notifications Pager ( User Interface $ participant , $ seen = null , $ page , $ limit = null ) { $ qb = $ this - > get Notification Qb ( $ participant , $ seen ) ; return $ this - > create Paginator ( $ qb - > get Query ( ) , $ page , $ limit ) ; } 
public function find Notification Metadata Pager ( User Interface $ participant , $ seen , $ page , $ limit = null ) { $ qb = $ this - > get Participant Metadata Qb ( $ participant , $ seen ) ; $ qb - > inner Join ( 'm .notification ' , 'mn ' ) - > add Select ( [ 'mn ' ] ) ; return $ this - > create Paginator ( $ qb - > get Query ( ) , $ page , $ limit ) ; } 
public function get Notification Count ( User Interface $ participant , $ seen = null ) { $ qb = $ this - > get Participant Metadata Qb ( $ participant , $ seen ) ; $ qb - > select ( $ qb - > expr ( ) - > count ( 'm ' ) ) ; return $ qb - > get Query ( ) - > get Single Scalar Result ( ) ; } 
protected function get Participant Metadata Qb ( User Interface $ participant , $ seen ) { $ qb = $ this - > get Metadata Repository ( ) - > create Query Builder ( 'm ' ) - > where ( 'm .participant = :participant ' ) - > set Parameter ( 'participant ' , $ participant ) ; if ( $ seen ! = = null ) { $ qb - > and Where ( 'm .seen = :seen ' ) - > set Parameter ( 'seen ' , ( boolean ) $ seen ) ; } return $ qb ; } 
public function mark All As Seen ( User Interface $ participant ) { $ notifications = $ this - > find Notification Metadata ( $ participant , false ) ; foreach ( $ notifications as $ notification ) { $ notification - > set Seen ( true ) ; } $ this - > entity Manager - > flush ( ) ; } 
public function mark As Seen ( $ notification Meta ) { foreach ( $ notification Meta as $ notification Metadata ) { $ notification Metadata - > set Seen ( true ) ; } $ this - > entity Manager - > flush ( ) ; } 
protected function ensure Directory Writable And Exists ( $ directory , $ output ) { $ checker = $ this - > get Container ( ) - > get ( 'phpdish .installer .directory _checker ' ) ; $ checker - > set Output ( $ output ) ; $ checker - > set Directory ( $ directory ) ; $ checker - > check ( ) ; } 
protected function execute Command ( $ command , Output Interface $ output = null , array $ options = [ ] ) { if ( is _null ( $ output ) ) { $ output = new Null Output ( ) ; } $ options = array _merge ( $ options , [ 'command ' = > $ command , ] ) ; $ this - > get Application ( ) - > run ( new Array Input ( $ options ) , $ output ) ; return $ this ; } 
protected function bulk Run Commands ( array $ commands , Output Interface $ output , $ render Progressbar = false ) { if ( $ render Progressbar ) { $ progressbar = new Progress Bar ( $ output , count ( $ commands ) ) ; } foreach ( $ commands as $ command Item ) { if ( is _string ( $ command Item ) ) { $ command = $ command Item ; $ options = [ ] ; } else { $ command = $ command Item [ 'command ' ] ; $ options = $ command Item [ 'options ' ] ; } $ this - > execute Command ( $ command , null , $ options ) ; $ render Progressbar & & $ progressbar - > advance ( 1 ) ; } $ render Progressbar & & $ progressbar - > finish ( ) ; } 
public function add Resources Section ( Array Node Definition $ root Node ) { $ root Node - > children ( ) - > array Node ( 'resources ' ) - > children ( ) - > array Node ( 'post ' ) - > children ( ) - > scalar Node ( 'interface ' ) - > default Value ( Post Interface : : class ) - > cannot Be Empty ( ) - > end ( ) - > scalar Node ( 'model ' ) - > default Value ( Post : : class ) - > cannot Be Empty ( ) - > end ( ) - > end ( ) - > end ( ) - > array Node ( 'comment ' ) - > children ( ) - > scalar Node ( 'interface ' ) - > default Value ( Comment Interface : : class ) - > cannot Be Empty ( ) - > end ( ) - > scalar Node ( 'model ' ) - > default Value ( Comment : : class ) - > cannot Be Empty ( ) - > end ( ) - > end ( ) - > end ( ) - > array Node ( 'category ' ) - > children ( ) - > scalar Node ( 'interface ' ) - > default Value ( Category Interface : : class ) - > cannot Be Empty ( ) - > end ( ) - > scalar Node ( 'model ' ) - > default Value ( Category : : class ) - > cannot Be Empty ( ) - > end ( ) - > end ( ) - > end ( ) - > end ( ) - > end ( ) - > end ( ) ; } 
public function on Kernel Response ( Filter Response Event $ event ) { if ( ! $ this - > pjax Helper - > is Pjax Request ( $ event - > get Request ( ) ) ) { return ; } $ this - > filter Response ( $ event - > get Request ( ) , $ event - > get Response ( ) ) ; } 
protected function filter Response ( Request $ request , Response $ response ) { $ crawler = new Crawler ( $ response - > get Content ( ) ) ; $ body = $ this - > fetch Body ( $ crawler , $ this - > pjax Helper - > get Container ( $ request ) ) ; $ response - > set Content ( $ this - > make Title ( $ crawler ) . $ body ) ; } 
protected function fetch Body ( Crawler $ crawler , $ container ) { $ content = $ crawler - > filter ( $ container ) ; if ( $ content - > count ( ) = = 0 ) { return ' ' ; } return $ content - > html ( ) ; } 
public function build Image Resize Url ( Image Interface $ image , $ filter , $ runtime Config = [ ] ) { return $ this - > imagine Cache Manager - > get Browser Path ( $ image - > get Key ( ) , $ filter , $ runtime Config ) ; } 
public function edit Profile Action ( Request $ request ) { $ this - > deny Access Unless Granted ( 'IS _AUTHENTICATED _REMEMBERED ' ) ; $ user = $ this - > get User ( ) ; $ form = $ this - > create Form ( Change User Profile Type : : class , $ user ) ; $ form - > handle Request ( $ request ) ; if ( $ form - > is Submitted ( ) & & $ form - > is Valid ( ) ) { $ this - > get User Manager ( ) - > save User ( $ user ) ; $ translator = $ this - > get ( 'translator ' ) ; $ this - > add Flash ( 'success ' , $ translator - > trans ( 'profile .edit .success ' ) ) ; return $ this - > redirect To Route ( 'setting _profile ' ) ; } return $ this - > render ( $ this - > configuration - > get Template ( 'Setting :profile .html .twig ' ) , [ 'form ' = > $ form - > create View ( ) , ] ) ; } 
public function bind Social Site Action ( Request $ request ) { $ this - > deny Access Unless Granted ( 'IS _AUTHENTICATED _REMEMBERED ' ) ; return $ this - > render ( $ this - > configuration - > get Template ( 'Setting :bind _social .html .twig ' ) ) ; } 
public function merge Resources ( $ alias , $ resources ) { $ this - > resources = array _merge ( $ this - > resources , [ $ alias = > $ resources ] ) ; } 
public function get Resource Item By Model ( $ model ) { foreach ( $ this - > resources as $ alias = > $ resource ) { foreach ( $ resource as $ resource Item ) { if ( $ resource Item [ 'model ' ] = = = $ model ) { return $ resource Item ; } } } return null ; } 
public function grid ( Grid Interface $ grid , $ theme = null ) { $ this - > initialize Template ( $ theme ) ; $ grid - > initialize ( ) ; return $ this - > render Block ( 'grid ' , [ 'grid ' = > $ grid ] ) ; } 
protected function has Block ( $ name ) { foreach ( $ this - > templates as $ template ) { if ( $ template - > has Block ( $ name ) ) { return true ; } } return false ; } 
public function find ( ) { $ finder = new Finder ( ) ; $ finder - > in ( $ this - > directory ) - > name ( $ this - > filename ) - > ignore Unreadable Dirs ( ) ; $ themes = [ ] ; foreach ( $ finder as $ file ) { $ theme = $ this - > hydrate Theme ( $ file ) ; if ( $ theme = = = false ) { continue ; } $ themes [ ] = $ theme ; } return $ themes ; } 
private function convert Authors Arrays To Authors Objects ( array $ authors Arrays ) : array { return array _map ( function ( array $ author Array ) { $ author = new Theme Author ( ) ; $ author - > set Name ( $ author Array [ 'name ' ] ? ? null ) ; $ author - > set Email ( $ author Array [ 'email ' ] ? ? null ) ; $ author - > set Homepage ( $ author Array [ 'homepage ' ] ? ? null ) ; $ author - > set Role ( $ author Array [ 'role ' ] ? ? null ) ; return $ author ; } , $ authors Arrays ) ; } 
private function convert Screenshots Arrays To Screenshots Objects ( array $ screenshots Arrays ) : array { return array _map ( function ( array $ screenshot Array ) { if ( ! array _key _exists ( 'path ' , $ screenshot Array ) ) { throw new \ Invalid Argument Exception ( 'Screenshot path is required . ' ) ; } $ theme Screenshot = new Theme Screenshot ( $ screenshot Array [ 'path ' ] ) ; $ theme Screenshot - > set Title ( $ screenshot Array [ 'title ' ] ? ? null ) ; $ theme Screenshot - > set Description ( $ screenshot Array [ 'description ' ] ? ? null ) ; return $ theme Screenshot ; } , $ screenshots Arrays ) ; } 
public function index Action ( Request $ request ) { $ posts = $ this - > get Post Manager ( ) - > find Latest Enabled Posts ( $ request - > query - > get Int ( 'page ' , 1 ) ) ; return $ this - > render ( $ this - > configuration - > get Template ( 'Post :index .html .twig ' ) , [ 'posts ' = > $ posts , ] ) ; } 
public function create Action ( Request $ request ) { $ this - > deny Access Unless Granted ( 'IS _AUTHENTICATED _REMEMBERED ' ) ; $ translator = $ this - > get ( 'translator ' ) ; 
public function view Action ( $ id , Request $ request ) { $ post = $ this - > get Post Manager ( ) - > find Post By Id ( $ id ) ; if ( ! $ post - > is Enabled ( ) ) { throw $ this - > create Not Found Exception ( ) ; } 
public function edit Action ( $ id , Request $ request ) { $ post = $ this - > get Post Manager ( ) - > find Post By Id ( $ id ) ; if ( ! $ post ) { throw $ this - > create Not Found Exception ( ) ; } $ this - > deny Access Unless Granted ( 'edit ' , $ post ) ; $ form = $ this - > create Form ( Post Type : : class , $ post , [ 'user ' = > $ this - > get User ( ) , ] ) ; $ form - > handle Request ( $ request ) ; if ( $ form - > is Valid ( ) & & $ form - > is Submitted ( ) ) { $ this - > get Post Manager ( ) - > save Post ( $ post ) ; return $ this - > redirect To Route ( 'post _view ' , [ 'id ' = > $ post - > get Id ( ) , ] ) ; } return $ this - > render ( $ this - > configuration - > get Template ( 'Post :create .html .twig ' ) , [ 'form ' = > $ form - > create View ( ) , 'post ' = > $ post , ] ) ; } 
public function delete Action ( $ id ) { $ manager = $ this - > get Post Manager ( ) ; $ post = $ manager - > find Post By Id ( $ id ) ; if ( ! $ post ) { throw $ this - > create Not Found Exception ( ) ; } $ this - > deny Access Unless Granted ( 'edit ' , $ post ) ; $ manager - > block Post ( $ post ) ; return $ this - > handle View ( $ this - > view ( [ 'result ' = > true , ] ) ) ; } 
public function get User Posts Action ( $ username , Request $ request ) { $ user = $ this - > get User Manager ( ) - > find User By Name ( $ username ) ; $ posts = $ this - > get Post Manager ( ) - > find User Enabled Posts ( $ user , $ request - > query - > get Int ( 'page ' , 1 ) ) ; return $ this - > render ( $ this - > configuration - > get Template ( 'Post :user _posts .html .twig ' ) , [ 'user ' = > $ user , 'posts ' = > $ posts , ] ) ; } 
public function recommend Posts Action ( $ limit ) { $ criteria = Criteria : : create ( ) - > order By ( [ 'is Recommended ' = > 'desc ' , 'created At ' = > 'desc ' ] ) - > and Where ( Criteria : : expr ( ) - > gte ( 'created At ' , Carbon : : parse ( ' - 1 0 0 days ' ) ) ) - > set Max Results ( $ limit ) ; $ posts = $ this - > get Post Manager ( ) - > find Posts ( $ criteria ) ; return $ this - > render ( $ this - > configuration - > get Template ( 'Post :recommend _posts .html .twig ' ) , [ 'posts ' = > $ posts , ] ) ; } 
public function toggle Voter Action ( $ id ) { $ this - > deny Access Unless Granted ( 'IS _AUTHENTICATED _REMEMBERED ' ) ; $ post = $ this - > get Post Manager ( ) - > find Post By Id ( $ id ) ; if ( ! $ post ) { throw new \ Invalid Argument Exception ( $ this - > get ( 'translator ' ) - > trans ( 'post .not _exists ' ) ) ; } if ( $ is Voted = $ post - > is Voted By ( $ this - > get User ( ) ) ) { $ this - > get Post Manager ( ) - > remove Voter ( $ post , $ this - > get User ( ) ) ; } else { $ this - > get Post Manager ( ) - > add Voter ( $ post , $ this - > get User ( ) ) ; } return $ this - > json ( [ 'vote _count ' = > $ post - > get Vote Count ( ) , 'is _voted ' = > ! $ is Voted ] ) ; } 
public function register Bundles ( ) { $ bundles = [ new \ Symfony \ Bundle \ Framework Bundle \ Framework Bundle ( ) , new \ Symfony \ Bundle \ Security Bundle \ Security Bundle ( ) , new \ Symfony \ Bundle \ Twig Bundle \ Twig Bundle ( ) , new \ Symfony \ Bundle \ Monolog Bundle \ Monolog Bundle ( ) , new \ Symfony \ Bundle \ Swiftmailer Bundle \ Swiftmailer Bundle ( ) , new \ Doctrine \ Bundle \ Doctrine Bundle \ Doctrine Bundle ( ) , new \ Sensio \ Bundle \ Framework Extra Bundle \ Sensio Framework Extra Bundle ( ) , new \ Symfony \ Bundle \ Assetic Bundle \ Assetic Bundle ( ) , new \ Doctrine \ Bundle \ Migrations Bundle \ Doctrine Migrations Bundle ( ) , new \ Doctrine \ Bundle \ Fixtures Bundle \ Doctrine Fixtures Bundle ( ) , new \ Stof \ Doctrine Extensions Bundle \ Stof Doctrine Extensions Bundle ( ) , new \ JMS \ Serializer Bundle \ JMSSerializer Bundle ( ) , new \ FOS \ User Bundle \ FOSUser Bundle ( ) , new \ FOS \ Rest Bundle \ FOSRest Bundle ( ) , new \ FOS \ Message Bundle \ FOSMessage Bundle ( ) , new \ Knp \ Bundle \ Paginator Bundle \ Knp Paginator Bundle ( ) , new \ Knp \ Bundle \ Markdown Bundle \ Knp Markdown Bundle ( ) , new \ Knp \ Bundle \ Gaufrette Bundle \ Knp Gaufrette Bundle ( ) , new \ Knp \ Bundle \ Menu Bundle \ Knp Menu Bundle ( ) , new \ White October \ Pagerfanta Bundle \ White October Pagerfanta Bundle ( ) , new \ Liip \ Imagine Bundle \ Liip Imagine Bundle ( ) , new \ Http \ Httplug Bundle \ Httplug Bundle ( ) , new \ HWI \ Bundle \ OAuth Bundle \ HWIOAuth Bundle ( ) , new \ Algolia \ Search Bundle \ Algolia Search Bundle ( ) , new \ Exercise \ HTMLPurifier Bundle \ Exercise HTMLPurifier Bundle ( ) , 
protected function get Kernel Parameters ( ) { $ simple Plugins = [ ] ; $ simple Plugin Metas = [ ] ; foreach ( $ this - > simple Plugins as $ simple Plugin ) { $ simple Plugins [ $ simple Plugin - > get Name ( ) ] = get _class ( $ simple Plugin ) ; $ simple Plugin Metas [ $ simple Plugin - > get Name ( ) ] = [ 'path ' = > $ simple Plugin - > get Path ( ) , 'router Source ' = > $ simple Plugin - > get Router Resource ( ) , 'services Source ' = > $ simple Plugin - > get Services Source ( ) , ] ; } return array _merge ( parent : : get Kernel Parameters ( ) , [ 'kernel .simple _plugins ' = > $ simple Plugins , 'kernel .simple _plugins _metadata ' = > $ simple Plugin Metas ] ) ; } 
protected function find Simple Plugins ( ) { $ finder = new Cached Plugin Finder ( $ this - > get Cache Dir ( ) . ' /phpdish _plugins .php ' , new Plugin Finder ( $ this - > get Project Dir ( ) ) ) ; return $ finder - > find All ( ) ; } 
public function initialize ( $ data ) { isset ( $ data [ 'from ' ] ) & & $ this - > from = $ data [ 'from ' ] ; isset ( $ data [ 'to ' ] ) & & $ this - > from = $ data [ 'to ' ] ; } 
protected function is Resource ( Class Metadata $ metadata ) : bool { if ( ! $ reflection Class = $ metadata - > get Reflection Class ( ) ) { return false ; } return $ reflection Class - > implements Interface ( Identifiable Interface : : class ) ; } 
public function download ( $ media Url ) { try { $ response = $ this - > http Client - > get ( $ media Url ) ; } catch ( \ Exception $ exception ) { throw new \ Runtime Exception ( sprintf ( 'Fail to donwload the resource " %s " ' , $ media Url ) ) ; } 
public function build Form ( Form Builder Interface $ builder , array $ options ) { $ support Locales = $ this - > locale Manager - > all ( ) ; $ builder - > add ( 'username ' , Text Type : : class , [ 'label ' = > 'form .user .username ' , ] ) - > add ( 'gender ' , Choice Type : : class , [ 'choices ' = > [ 'form .user .gender .male ' = > User : : GENDER _MEN , 'form .user .gender .female ' = > User : : GENDER _WOMEN , ] , 'placeholder ' = > 'form .user .gender .placeholder ' , 'label ' = > 'form .user .gender .gender ' , ] ) - > add ( 'email ' , Text Type : : class , [ 'label ' = > 'form .user .email ' , ] ) - > add ( 'description ' , Textarea Type : : class , [ 'label ' = > 'form .user .description ' , ] ) - > add ( 'profile ' , Profile Type : : class ) - > add ( 'avatar ' , Hidden Type : : class , [ 'label ' = > 'form .user .avatar ' , ] ) - > add ( 'locale ' , Choice Type : : class , [ 'choices ' = > $ this - > wrap Locale Choices ( ) , 'label ' = > 'form .user .locale .locale ' , ] ) ; } 
public function add View Count ( $ view Count ) { $ this - > view Count + = $ view Count ; $ this - > view Count < 0 & & $ this - > view Count = 0 ; return $ this ; } 
public function get Images ( ) { if ( ! is _null ( $ this - > images ) ) { return $ this - > images ; } return $ this - > images = Markdown Helper : : extract Images ( $ this - > get Original Body ( ) ) ; } 
public function get Inbox Threads Pager ( $ page , $ limit = null ) { $ participant = $ this - > get Authenticated Participant ( ) ; $ query = $ this - > thread Manager - > get Participant Inbox Threads Query Builder ( $ participant ) - > get Query ( ) ; return $ this - > create Paginator ( $ query , $ page , $ limit ) ; } 
public function get Sent Threads Pager ( $ page , $ limit = null ) { $ participant = $ this - > get Authenticated Participant ( ) ; $ query = $ this - > thread Manager - > get Participant Sent Threads Query Builder ( $ participant ) - > get Query ( ) ; return $ this - > create Paginator ( $ query , $ page , $ limit ) ; } 
public function get Functions ( ) : array { return [ new \ Twig _Simple Function ( 'get _thread ' , [ $ this - > thread Manager , 'find Thread By Id ' ] ) , new \ Twig _Simple Function ( 'get _thread _by _slug ' , [ $ this - > thread Manager , 'find Thread By Slug ' ] ) , new \ Twig _Simple Function ( 'get _threads ' , [ $ this , 'get Threads ' ] ) , new \ Twig _Simple Function ( 'get _threads _pager ' , [ $ this - > thread Manager , 'find Threads Pager ' ] ) , new \ Twig _Simple Function ( 'get _topic ' , [ $ this - > topic Manager , 'find Topic By Id ' ] ) , new \ Twig _Simple Function ( 'get _topics ' , [ $ this , 'get Topics ' ] ) , new \ Twig _Simple Function ( 'get _topics _pager ' , [ $ this - > topic Manager , 'find Topics Pager ' ] ) , new \ Twig _Simple Function ( 'get _topics _pager _by _thread ' , [ $ this - > topic Manager , 'find Thread Topics ' ] ) , new \ Twig _Simple Function ( 'get _reply ' , [ $ this - > reply Manager , 'find Reply By Id ' ] ) , new \ Twig _Simple Function ( 'get _replies ' , [ $ this , 'get Replies ' ] ) , new \ Twig _Simple Function ( 'get _replies _pager ' , [ $ this - > reply Manager , 'find Replies Pager ' ] ) , ] ; } 
public function get Threads ( $ criteria , array $ order By = [ ] , ? int $ limit = null ) { if ( $ criteria instanceof Criteria ) { return $ this - > thread Manager - > find Threads ( $ criteria ) ; } else { return $ this - > thread Manager - > get Thread Repository ( ) - > find By ( $ criteria , $ order By , $ limit ) ; } } 
public function get Topics ( $ criteria , array $ order By = [ ] , ? int $ limit = null ) { if ( $ criteria instanceof Criteria ) { return $ this - > topic Manager - > find Topics ( $ criteria ) ; } else { return $ this - > topic Manager - > get Topic Repository ( ) - > find By ( $ criteria , $ order By , $ limit ) ; } } 
public function get Replies ( $ criteria , array $ order By = [ ] , ? int $ limit = null ) { if ( $ criteria instanceof Criteria ) { return $ this - > reply Manager - > find Replies ( $ criteria ) ; } else { return $ this - > reply Manager - > get Reply Repository ( ) - > find By ( $ criteria , $ order By , $ limit ) ; } } 
public function upload ( Uploaded File $ uploaded File ) { $ file = $ this - > file Factory - > create File From Uploaded File ( $ uploaded File ) ; $ this - > file Manager - > upload ( $ file , true ) ; return $ file ; } 
public function find Comments Pager ( Criteria $ criteria , $ page = 1 , $ limit = null ) { $ query = $ this - > get Comment Repository ( ) - > create Query Builder ( 'c ' ) - > join ( 'c .user ' , 'cu ' ) - > add Select ( 'cu ' ) - > add Criteria ( $ criteria ) - > get Query ( ) ; return $ this - > create Paginator ( $ query , $ page , $ limit ) ; } 
public function find Comments ( Criteria $ criteria ) { return $ this - > get Comment Repository ( ) - > create Query Builder ( 'c ' ) - > join ( 'c .user ' , 'cu ' ) - > add Select ( 'cu ' ) - > add Criteria ( $ criteria ) - > get Query ( ) - > get Result ( ) ; } 
public function create Comment ( Post Interface $ post , User Interface $ user ) { $ comment = new $ this - > comment Entity ; $ comment - > set Post ( $ post ) - > set User ( $ user ) ; $ post - > add Comment Count ( ) ; return $ comment ; } 
public function save Comment ( Comment Interface $ comment ) { $ new = ! $ comment - > get Id ( ) ; $ parsed Body = $ this - > body Processor - > process ( $ comment - > get Original Body ( ) ) ; $ comment - > set Updated At ( Carbon : : now ( ) ) - > set Body ( $ parsed Body ) ; 
public function add Voter ( Comment Interface $ comment , User Interface $ user ) { $ comment - > add Voter ( $ user ) - > add Vote Count ( ) ; $ this - > entity Manager - > persist ( $ comment ) ; $ this - > entity Manager - > flush ( ) ; 
public function remove Voter ( Comment Interface $ comment , User Interface $ user ) { $ comment - > remove Voter ( $ user ) - > add Vote Count ( - 1 ) ; $ this - > entity Manager - > persist ( $ comment ) ; $ this - > entity Manager - > flush ( ) ; } 
public function get Comment Repository ( ) { if ( $ this - > comment Repository ) { return $ this - > comment Repository ; } return $ this - > entity Manager - > get Repository ( $ this - > comment Entity ) ; } 
public function load ( $ resource , $ type = null ) { $ routes = new Route Collection ( ) ; foreach ( $ this - > router Resources as $ resource ) { $ type = pathinfo ( $ resource , PATHINFO _EXTENSION ) ; if ( $ type = = = 'yml ' ) { $ type = 'yaml ' ; } $ imported Routes = $ this - > import ( $ resource , $ type ) ; $ routes - > add Collection ( $ imported Routes ) ; } return $ routes ; } 
public function index Action ( Request $ request ) { $ post Manager = $ this - > get Post Manager ( ) ; $ posts = $ post Manager - > find Latest Posts ( $ request - > query - > get Int ( 'page ' , 1 ) ) ; $ topics = $ this - > get Topic Manager ( ) - > find Hot Topics ( Carbon : : now ( ) - > add Days ( - 1 0 ) , 1 5 ) ; return $ this - > render ( 'PHPDish Web Bundle :Default :index .html .twig ' , [ 'posts ' = > $ posts , 'topics ' = > $ topics , ] ) ; } 
public function count Notification Action ( ) { $ this - > deny Access Unless Granted ( 'IS _AUTHENTICATED _REMEMBERED ' ) ; $ count = $ this - > get ( 'phpdish _notification .manager .notification ' ) - > get Notification Count ( $ this - > get User ( ) , false ) ; $ nb Message Count = $ this - > get ( 'fos _message .provider ' ) - > get Nb Unread Messages ( ) ; return $ this - > json ( [ 'count ' = > $ count + $ nb Message Count , ] ) ; } 
public function get Nb Results ( ) { return $ this - > index Manager - > count ( $ this - > query , $ this - > entity Class , $ this - > options ) ; } 
public function get Slice ( $ offset , $ length ) { return array _filter ( $ this - > index Manager - > search ( $ this - > query , $ this - > entity Class , $ this - > entity Manager , $ offset / $ length + 1 , $ length , $ this - > options ) ) ; } 
public function auto Complete Action ( Request $ request ) { $ query = $ request - > query - > get ( 'query ' ) ; $ threads = $ this - > get Thread Manager ( ) - > search Threads ( $ query ) ; return $ this - > json ( [ 'threads ' = > $ threads ] ) ; } 
public function hot Threads Action ( ) { $ threads = $ this - > get Thread Manager ( ) - > find Enabled Threads ( 1 5 ) ; return $ this - > render ( $ this - > configuration - > get Template ( 'Thread : _hot _threads .html .twig ' ) , [ 'threads ' = > $ threads ] ) ; } 
public function index Action ( Request $ request ) { $ criteria = Criteria : : create ( ) - > where ( Criteria : : expr ( ) - > eq ( 'enabled ' , true ) ) - > order By ( [ 'follower Count ' = > 'desc ' , 'created At ' = > 'desc ' , ] ) ; if ( $ request - > query - > get ( 'tab ' ) = = = 'following ' ) { $ threads = $ this - > get Thread Manager ( ) - > find User Following Threads ( $ this - > get User ( ) , $ request - > query - > get Int ( 'page ' , 1 ) , null , $ criteria ) ; } else { $ threads = $ this - > get Thread Manager ( ) - > find Threads Pager ( $ criteria , $ request - > query - > get Int ( 'page ' , 1 ) ) ; } $ translator = $ this - > get ( 'translator ' ) ; $ seo Page = $ this - > get ( 'sonata .seo .page ' ) ; $ seo Page - > set Title ( $ translator - > trans ( 'thread .explore ' ) ) - > remove Meta ( 'name ' , 'keywords ' ) - > add Meta ( 'name ' , 'description ' , $ translator - > trans ( 'thread .explore ' ) ) - > add Meta ( 'property ' , 'og :title ' , $ translator - > trans ( 'thread .explore ' ) ) - > add Meta ( 'property ' , 'og :url ' , $ this - > generate Url ( 'threads ' , [ ] , Url Generator Interface : : ABSOLUTE _URL ) ) - > add Meta ( 'property ' , 'og :description ' , $ translator - > trans ( 'thread .explore ' ) ) ; return $ this - > render ( $ this - > configuration - > get Template ( 'Thread :index .html .twig ' ) , [ 'threads ' = > $ threads ] ) ; } 
public function view Action ( $ slug , Request $ request ) { $ thread = $ this - > get Thread Manager ( ) - > find Thread By Slug ( $ slug ) ; if ( ! $ thread ) { throw $ this - > create Not Found Exception ( ) ; } $ criteria = Criteria : : create ( ) ; $ criteria - > order By ( [ 'last Comment At ' = > 'desc ' ] ) - > where ( Criteria : : expr ( ) - > eq ( 'enabled ' , true ) ) ; $ tab = $ request - > query - > get ( 'tab ' ) ; if ( $ tab & & $ tab = = = 'recommend ' ) { $ criteria - > and Where ( Criteria : : expr ( ) - > eq ( 'recommended ' , true ) ) ; } $ topics = $ this - > get Topic Manager ( ) - > find Thread Topics ( $ thread , $ request - > query - > get Int ( 'page ' , 1 ) , null , $ criteria ) ; 
public function edit Action ( $ slug , Request $ request ) { $ thread = $ this - > get Thread Manager ( ) - > find Thread By Slug ( $ slug ) ; if ( ! $ thread ) { throw $ this - > create Not Found Exception ( ) ; } $ this - > deny Access Unless Granted ( 'edit ' , $ thread ) ; $ form = $ this - > create Form ( Thread Type : : class , $ thread ) ; $ form - > handle Request ( $ request ) ; if ( $ form - > is Valid ( ) & & $ form - > is Submitted ( ) ) { $ this - > get Thread Manager ( ) - > save Thread ( $ thread ) ; $ this - > add Flash ( 'success ' , $ this - > get ( 'translator ' ) - > trans ( 'thread .edit _success ' ) ) ; return $ this - > redirect To Route ( 'thread _view ' , [ 'slug ' = > $ thread - > get Slug ( ) , ] ) ; } return $ this - > render ( $ this - > configuration - > get Template ( 'Thread :create .html .twig ' ) , [ 'thread ' = > $ thread , 'form ' = > $ form - > create View ( ) ] ) ; } 
public function follow Action ( $ slug ) { $ this - > deny Access Unless Granted ( 'IS _AUTHENTICATED _REMEMBERED ' ) ; $ thread = $ this - > get Thread Manager ( ) - > find Thread By Slug ( $ slug ) ; $ this - > get Thread Manager ( ) - > follow Thread ( $ thread , $ this - > get User ( ) ) ; return $ this - > json ( [ 'follower _count ' = > $ thread - > get Follower Count ( ) , ] ) ; } 
public function un Follow Action ( $ slug ) { $ this - > deny Access Unless Granted ( 'IS _AUTHENTICATED _REMEMBERED ' ) ; $ thread = $ this - > get Thread Manager ( ) - > find Thread By Slug ( $ slug ) ; $ this - > get Thread Manager ( ) - > un Follow Thread ( $ thread , $ this - > get User ( ) ) ; return $ this - > json ( [ 'follower _count ' = > $ thread - > get Follower Count ( ) , ] ) ; } 
public function get Config Tree Builder ( ) { $ tree Builder = new Tree Builder ( ) ; $ root Node = $ tree Builder - > root ( 'phpdish _permission ' ) ; $ root Node - > children ( ) - > array Node ( 'resources ' ) - > children ( ) - > array Node ( 'privileger ' ) - > children ( ) - > scalar Node ( 'interface ' ) - > default Value ( Privileger Interface : : class ) - > cannot Be Empty ( ) - > end ( ) - > scalar Node ( 'model ' ) - > cannot Be Empty ( ) - > end ( ) - > end ( ) - > end ( ) - > array Node ( 'role ' ) - > children ( ) - > scalar Node ( 'interface ' ) - > default Value ( Role Interface : : class ) - > cannot Be Empty ( ) - > end ( ) - > scalar Node ( 'model ' ) - > default Value ( Role : : class ) - > cannot Be Empty ( ) - > end ( ) - > end ( ) - > end ( ) - > array Node ( 'permission ' ) - > children ( ) - > scalar Node ( 'interface ' ) - > default Value ( Permission Interface : : class ) - > cannot Be Empty ( ) - > end ( ) - > scalar Node ( 'model ' ) - > default Value ( Permission : : class ) - > cannot Be Empty ( ) - > end ( ) - > end ( ) - > end ( ) - > end ( ) - > end ( ) - > end ( ) ; return $ tree Builder ; } 
public function process ( Container Builder $ container ) { if ( $ change Password = $ container - > find Definition ( 'fos _user .resetting .controller ' ) ) { $ change Password - > set Class ( Resetting Controller : : class ) - > add Method Call ( 'set Resource Configuration ' , [ new Reference ( 'phpdish _resource .configuration .phpdish _user ' ) ] ) ; } } 
public function find Categories ( Criteria $ criteria ) { return $ this - > get Category Repository ( ) - > create Query Builder ( 'c ' ) - > add Criteria ( $ criteria ) - > get Query ( ) - > get Result ( ) ; } 
public function find Categories Pager ( Criteria $ criteria , $ page , $ limit = null ) { $ query = $ this - > get Category Repository ( ) - > create Query Builder ( 'c ' ) - > add Criteria ( $ criteria ) - > get Query ( ) ; return $ this - > create Paginator ( $ query , $ page , $ limit ) ; } 
public function find All Enabled Categories ( ) { $ criteria = Criteria : : create ( ) - > where ( Criteria : : expr ( ) - > eq ( 'enabled ' , true ) ) ; return $ this - > find Categories ( $ criteria ) ; } 
public function find User Categories ( User Interface $ user ) { return $ this - > create Get User Categories Query Builder ( $ user ) - > and Where ( 'c .is Book = :is Book ' ) - > set Parameter ( 'is Book ' , false ) - > get Query ( ) - > get Result ( ) ; } 
public function get User Categories Number ( User Interface $ user ) { $ qb = $ this - > create Get User Categories Query Builder ( $ user ) - > and Where ( 'c .is Book = :is Book ' ) - > set Parameter ( 'is Book ' , false ) ; return ( int ) $ qb - > select ( $ qb - > expr ( ) - > count ( 'c ' ) ) - > get Query ( ) - > get Single Scalar Result ( ) ; } 
public function create Get User Categories Query Builder ( User Interface $ user ) { return $ this - > get Category Repository ( ) - > create Query Builder ( 'c ' ) - > where ( 'c .creator = :user Id ' ) - > set Parameter ( 'user Id ' , $ user - > get Id ( ) ) - > order By ( 'c .created At ' , 'desc ' ) ; } 
public function add Manager For Category ( Category Interface $ category , User Interface $ user ) { $ category - > add Manager ( $ user ) ; return $ this - > save Category ( $ category ) ; } 
public function add Category Income ( User Interface $ user , Category Interface $ category , User Interface $ follower , $ amount = null ) { $ wallet = $ this - > wallet Manager - > get User Wallet ( $ user ) ; $ history = $ this - > wallet Manager - > create History ( ) ; if ( $ category - > is Book ( ) ) { $ description = $ this - > translator - > trans ( 'payment .buy _your _book ' , [ ' %username % ' = > sprintf ( ' <a href = " %s " > %s < /a > ' , $ this - > router - > generate ( 'user _view ' , [ 'username ' = > $ follower - > get Username ( ) ] ) , $ follower - > get Username ( ) ) , ' %book % ' = > sprintf ( ' <a href = " %s " > 《 %s 》 < /a > ' , $ this - > router - > generate ( 'book _view ' , [ 'slug ' = > $ category - > get Slug ( ) ] ) , $ category - > get Name ( ) ) , ] ) ; } else { $ description = $ this - > translator - > trans ( 'payment .subscribe _your _category ' , [ ' %username % ' = > sprintf ( ' <a href = " %s " > %s < /a > ' , $ this - > router - > generate ( 'user _view ' , [ 'username ' = > $ follower - > get Username ( ) ] ) , $ follower - > get Username ( ) ) , ' %category % ' = > sprintf ( ' <a href = " %s " > 《 %s 》 < /a > ' , $ this - > router - > generate ( 'category _view ' , [ 'slug ' = > $ category - > get Slug ( ) ] ) , $ category - > get Name ( ) ) , ] ) ; } 
public function pay For Category ( Category Interface $ category , User Interface $ user ) { if ( $ category - > is Charging ( ) ) { 
public function follow Category ( Category Interface $ category , User Interface $ user ) { $ category - > add Follower ( $ user ) ; $ category - > set Follower Count ( $ category - > get Follower Count ( ) + 1 ) ; $ result = $ this - > save Category ( $ category ) ; 
public function un Follow Category ( Category Interface $ category , User Interface $ user ) { $ category - > remove Follower ( $ user ) ; $ category - > set Follower Count ( $ category - > get Follower Count ( ) - 1 ? : 0 ) ; return $ this - > save Category ( $ category ) ; } 
public function create Category ( User Interface $ user ) { $ category = new $ this - > category Entity ; $ category - > set Creator ( $ user ) - > set Created At ( Carbon : : now ( ) ) ; return $ category ; } 
public function save Category ( Category Interface $ category ) { $ event = new Category Persist Event ( $ category ) ; $ this - > event Dispatcher - > dispatch ( Events : : CATEGORY _PRE _PERSIST , $ event ) ; if ( $ event - > is Persistence Aborted ( ) ) { return false ; } $ category - > set Updated At ( Carbon : : now ( ) ) ; $ this - > entity Manager - > persist ( $ category ) ; $ this - > entity Manager - > flush ( ) ; return true ; } 
public function create Topic ( User Interface $ user ) { $ topic = new $ this - > topic Entity ; $ now = Carbon : : now ( ) ; $ topic - > set User ( $ user ) - > set Last Comment At ( $ now ) - > set Created At ( $ now ) - > set Last Comment User ( $ user ) ; return $ topic ; } 
public function save Topic ( Topic Interface $ topic ) { $ parsed Body = $ this - > body Processor - > process ( $ topic - > get Original Body ( ) ) ; $ topic - > set Updated At ( Carbon : : now ( ) ) - > set Body ( $ parsed Body ) ; 
public function block Topic ( Topic Interface $ topic ) { $ topic - > disable ( ) ; $ this - > entity Manager - > persist ( $ topic ) ; $ this - > entity Manager - > flush ( ) ; } 
public function find Thread Topics ( Thread Interface $ thread , $ page , $ limit = null , Criteria $ criteria = null ) { $ qb = $ this - > get Topic Repository ( ) - > create Query Builder ( 't ' ) - > inner Join ( 't .threads ' , 'th ' ) - > where ( 'th .id = :thread Id ' ) - > set Parameter ( 'thread Id ' , $ thread ) ; $ criteria & & $ qb - > add Criteria ( $ criteria ) ; return $ this - > create Paginator ( $ qb - > get Query ( ) , $ page , $ limit ) ; } 
public function find User Topics ( User Interface $ user , $ page , $ limit = null ) { $ criteria = Criteria : : create ( ) - > where ( Criteria : : expr ( ) - > eq ( 'user ' , $ user - > get Id ( ) ) ) - > order By ( [ 'created At ' = > 'DESC ' , ] ) ; return $ this - > find Topics Pager ( $ criteria , $ page , $ limit ) ; } 
public function find Topics Pager ( Criteria $ criteria , $ page , $ limit = null ) { $ query = $ this - > get Topic Repository ( ) - > create Query Builder ( 't ' ) - > add Criteria ( $ criteria ) - > get Query ( ) ; return $ this - > create Paginator ( $ query , $ page , $ limit ) ; } 
public function find Topics ( Criteria $ criteria ) { return $ this - > get Topic Repository ( ) - > create Query Builder ( 't ' ) - > add Criteria ( $ criteria ) - > get Query ( ) - > get Result ( ) ; } 
public function find Hot Topics ( \ Date Time $ date , $ limit ) { $ criteria = Criteria : : create ( ) - > where ( Criteria : : expr ( ) - > gt ( 'created At ' , $ date ) ) - > and Where ( Criteria : : expr ( ) - > eq ( 'enabled ' , true ) ) - > order By ( [ 'comment Count ' = > 'desc ' , 'created At ' = > 'desc ' ] ) - > set Max Results ( $ limit ) ; return $ this - > find Topics ( $ criteria ) ; } 
public function find Following Threads Topics Query ( User Interface $ user , Criteria $ criteria = null ) { $ qb = $ this - > get Topic Repository ( ) - > create Query Builder ( 't ' ) - > left Join ( 't .threads ' , 'tt ' ) - > left Join ( 'tt .followers ' , 'f ' ) - > where ( 'f .id = :user Id ' ) - > set Parameter ( 'user Id ' , $ user ) - > order By ( 't .created At ' , 'desc ' ) ; if ( $ criteria ) { $ qb - > add Criteria ( $ criteria ) ; } return $ qb - > get Query ( ) ; } 
public function find Following Threads Topics ( User Interface $ user , $ page , $ limit = null ) { $ query = $ this - > find Following Threads Topics Query ( $ user , Criteria : : create ( ) - > where ( Criteria : : expr ( ) - > eq ( 'enabled ' , true ) ) ) ; return $ this - > create Paginator ( $ query , $ page , $ limit ) ; } 
public function get User Topic Count ( User Interface $ user ) { $ qb = $ this - > get Topic Repository ( ) - > create Query Builder ( 'p ' ) ; $ qb - > select ( $ qb - > expr ( ) - > count ( 'p ' ) ) - > where ( 'p .enabled = :enabled ' ) - > set Parameter ( 'enabled ' , true ) - > and Where ( 'p .user = :user ' ) - > set Parameter ( 'user ' , $ user ) ; return $ qb - > get Query ( ) - > get Single Scalar Result ( ) ; } 
public function add Voter ( Topic Interface $ topic , User Interface $ user ) { $ topic - > add Voter ( $ user ) - > add Vote Count ( ) ; $ this - > save Topic ( $ topic ) ; $ event = new Vote Topic Event ( $ topic , $ user ) ; $ this - > event Dispatcher - > dispatch ( Events : : TOPIC _VOTED , $ event ) ; } 
public function remove Voter ( Topic Interface $ topic , User Interface $ user ) { $ topic - > remove Voter ( $ user ) - > add Vote Count ( - 1 ) ; $ this - > save Topic ( $ topic ) ; } 
public function post Persist ( Post Interface $ post , Lifecycle Event Args $ event ) { $ user = $ post - > get User ( ) ; $ this - > handle User Post Count ( $ user ) ; } 
protected function handle User Post Count ( User Interface $ user ) { $ count = $ this - > post Manager - > get User Post Count ( $ user ) ; $ user - > set Post Count ( $ count ) ; $ this - > user Manager - > save User ( $ user ) ; } 
public function request Action ( ) { $ form = $ this - > create Form ( Resetting Request Type : : class , null , [ 'action ' = > $ this - > generate Url ( 'fos _user _resetting _send _email ' ) ] ) ; return $ this - > render ( $ this - > configuration - > get Template ( 'Resetting :request .html .twig ' ) , [ 'form ' = > $ form - > create View ( ) , 'last Username ' = > $ this - > get ( 'session ' ) - > get ( static : : LAST _USERNAME _SESSION _KEY ) ? : ' ' ] ) ; } 
public function send Email Action ( Request $ request ) { $ form = $ this - > create Form ( Resetting Request Type : : class ) ; $ form - > handle Request ( $ request ) ; if ( $ form - > is Submitted ( ) & & $ form - > is Valid ( ) ) { $ this - > get Event Dispatcher ( ) - > add Listener ( FOSUser Events : : RESETTING _SEND _EMAIL _INITIALIZE , [ $ this , 'on Send Email Initialize ' ] ) ; return parent : : send Email Action ( $ request ) ; } 
public function on Send Email Initialize ( Get Response Nullable User Event $ event ) { $ response = $ this - > redirect To Route ( 'fos _user _resetting _request ' ) ; $ translator = $ this - > get ( 'translator ' ) ; if ( $ event - > get User ( ) = = = null ) { $ this - > add Flash ( 'danger ' , $ translator - > trans ( 'resetting .username _or _email _not _exists ' ) ) ; $ event - > set Response ( $ response ) ; } elseif ( ! $ event - > get User ( ) - > get Email ( ) ) { $ this - > add Flash ( 'warning ' , $ translator - > trans ( 'resetting .user _missing _email ' ) ) ; $ event - > set Response ( $ response ) ; } } 
public function get Config Tree Builder ( ) { $ tree Builder = new Tree Builder ( ) ; $ root Node = $ tree Builder - > root ( 'phpdish _notification ' ) ; $ root Node - > children ( ) - > array Node ( 'resources ' ) - > children ( ) - > array Node ( 'notification ' ) - > children ( ) - > scalar Node ( 'interface ' ) - > default Value ( Notification Interface : : class ) - > cannot Be Empty ( ) - > end ( ) - > scalar Node ( 'model ' ) - > default Value ( Notification : : class ) - > cannot Be Empty ( ) - > end ( ) - > end ( ) - > end ( ) - > array Node ( 'notification _metadata ' ) - > children ( ) - > scalar Node ( 'interface ' ) - > default Value ( Notification Metadata Interface : : class ) - > cannot Be Empty ( ) - > end ( ) - > scalar Node ( 'model ' ) - > default Value ( Notification Metadata : : class ) - > cannot Be Empty ( ) - > end ( ) - > end ( ) - > end ( ) - > end ( ) - > end ( ) - > end ( ) ; $ this - > add Templates Section ( $ root Node ) ; return $ tree Builder ; } 
public function parse ( $ body ) { $ this - > parsed Body = $ body ; $ this - > mentioned Names = static : : extract User Names ( $ body ) ; if ( $ this - > mentioned Names ) { $ this - > mentioned Users = $ this - > adapter - > find Users ( $ this - > mentioned Names ) ; foreach ( $ this - > mentioned Users as $ user ) { $ search = ' @ ' . $ user - > get Username ( ) ; $ replace = $ this - > adapter - > create User Link ( $ user ) ; $ this - > parsed Body = str _replace ( $ search , $ replace , $ this - > parsed Body ) ; } } return $ this ; } 
public function get Config Tree Builder ( ) { $ tree Builder = new Tree Builder ( ) ; $ root Node = $ tree Builder - > root ( 'phpdish _forum ' ) ; $ root Node - > children ( ) - > array Node ( 'resources ' ) - > children ( ) - > array Node ( 'topic ' ) - > children ( ) - > scalar Node ( 'interface ' ) - > default Value ( Topic Interface : : class ) - > cannot Be Empty ( ) - > end ( ) - > scalar Node ( 'model ' ) - > default Value ( Topic : : class ) - > cannot Be Empty ( ) - > end ( ) - > end ( ) - > end ( ) - > array Node ( 'reply ' ) - > children ( ) - > scalar Node ( 'interface ' ) - > default Value ( Reply Interface : : class ) - > cannot Be Empty ( ) - > end ( ) - > scalar Node ( 'model ' ) - > default Value ( Reply : : class ) - > cannot Be Empty ( ) - > end ( ) - > end ( ) - > end ( ) - > array Node ( 'thread ' ) - > children ( ) - > scalar Node ( 'interface ' ) - > default Value ( Thread Interface : : class ) - > cannot Be Empty ( ) - > end ( ) - > scalar Node ( 'model ' ) - > default Value ( Thread : : class ) - > cannot Be Empty ( ) - > end ( ) - > end ( ) - > end ( ) - > end ( ) - > end ( ) - > end ( ) ; $ this - > add Templates Section ( $ root Node ) ; return $ tree Builder ; } 
public function create Follow User Notification ( User Interface $ follower ) { $ notification = $ this - > notification Manager - > create Notification ( $ this - > translator - > trans ( 'notification .follow _user .subject ' , [ ' %username % ' = > $ follower - > get Username ( ) , ' %url % ' = > $ this - > router - > generate ( 'user _view ' , [ 'username ' = > $ follower - > get Username ( ) ] ) ] ) ) ; $ notification - > add Parameters ( [ 'subject ' = > Notification : : SUBJECT _FOLLOW _USER , 'follower _id ' = > $ follower - > get Id ( ) , 'follower _username ' = > $ follower - > get Username ( ) , ] ) ; return $ notification ; } 
public function create Reply Topic Notification ( Topic Interface $ topic , Reply Interface $ reply ) { $ notification = $ this - > notification Manager - > create Notification ( $ this - > translator - > trans ( 'notification .reply _topic .subject ' , [ ' %user Url % ' = > $ this - > router - > generate ( 'user _view ' , [ 'username ' = > $ reply - > get User ( ) - > get Username ( ) ] ) , ' %username % ' = > $ reply - > get User ( ) - > get Username ( ) , ' %topic Url % ' = > $ this - > router - > generate ( 'topic _view ' , [ 'id ' = > $ topic - > get Id ( ) ] ) , ' %topic Title % ' = > $ topic - > get Title ( ) ] ) , $ reply - > get Body ( ) ) ; $ notification - > add Parameters ( [ 'subject ' = > Notification : : SUBJECT _REPLY _TOPIC , 'topic _id ' = > $ topic - > get Id ( ) , 'reply _id ' = > $ reply - > get Id ( ) , 'reply _user _id ' = > $ reply - > get User ( ) - > get Id ( ) , 'reply _user _username ' = > $ reply - > get User ( ) - > get Username ( ) , ] ) ; return $ notification ; } 
public function create Comment Post Notification ( Post Interface $ post , Comment Interface $ comment ) { $ notification = $ this - > notification Manager - > create Notification ( $ this - > translator - > trans ( 'notification .comment _post .subject ' , [ ' %user Url % ' = > $ this - > router - > generate ( 'user _view ' , [ 'username ' = > $ comment - > get User ( ) - > get Username ( ) ] ) , ' %username % ' = > $ comment - > get User ( ) - > get Username ( ) , ' %post Url % ' = > $ this - > router - > generate ( 'post _view ' , [ 'id ' = > $ post - > get Id ( ) ] ) , ' %post Title % ' = > $ post - > get Title ( ) ] ) , $ comment - > get Body ( ) ) ; $ notification - > add Parameters ( [ 'subject ' = > Notification : : SUBJECT _COMMENT _POST , 'post _id ' = > $ post - > get Id ( ) , 'comment _id ' = > $ comment - > get Id ( ) , 'comment _user _id ' = > $ comment - > get User ( ) - > get Id ( ) , 'comment _user _username ' = > $ comment - > get User ( ) - > get Username ( ) , ] ) ; return $ notification ; } 
public function create Mention User In Post Notification ( Comment Interface $ comment ) { $ notification = $ this - > notification Manager - > create Notification ( $ this - > translator - > trans ( 'notification .mention _user _post .subject ' , [ ' %user Url % ' = > $ this - > router - > generate ( 'user _view ' , [ 'username ' = > $ comment - > get User ( ) - > get Username ( ) ] ) , ' %username % ' = > $ comment - > get User ( ) - > get Username ( ) , ' %post Url % ' = > $ this - > router - > generate ( 'post _view ' , [ 'id ' = > $ comment - > get Post ( ) - > get Id ( ) ] ) , ' %post Title % ' = > $ comment - > get Post ( ) - > get Title ( ) ] ) ) ; $ notification - > add Parameters ( [ 'subject ' = > Notification : : SUBJECT _MENTION _USER _IN _POST , 'post _id ' = > $ comment - > get Post ( ) - > get Id ( ) , 'comment _id ' = > $ comment - > get Id ( ) , 'comment _user _id ' = > $ comment - > get User ( ) - > get Id ( ) , 'comment _user _username ' = > $ comment - > get User ( ) - > get Username ( ) , ] ) ; return $ notification ; } 
public function create Mention User In Topic Notification ( Reply Interface $ reply ) { $ notification = $ this - > notification Manager - > create Notification ( $ this - > translator - > trans ( 'notification .mention _user _topic .subject ' , [ ' %user Url % ' = > $ this - > router - > generate ( 'user _view ' , [ 'username ' = > $ reply - > get User ( ) - > get Username ( ) ] ) , ' %username % ' = > $ reply - > get User ( ) - > get Username ( ) , ' %topic Url % ' = > $ this - > router - > generate ( 'post _view ' , [ 'id ' = > $ reply - > get Topic ( ) - > get Id ( ) ] ) , ' %topic Title % ' = > $ reply - > get Topic ( ) - > get Title ( ) ] ) ) ; $ notification - > add Parameters ( [ 'subject ' = > Notification : : SUBJECT _MENTION _USER _IN _TOPIC , 'topic _id ' = > $ reply - > get Topic ( ) - > get Id ( ) , 'reply _id ' = > $ reply - > get Id ( ) , 'reply _user _id ' = > $ reply - > get User ( ) - > get Id ( ) , 'reply _user _username ' = > $ reply - > get User ( ) - > get Username ( ) , ] ) ; return $ notification ; } 
public function create Follow Category Notification ( Category Interface $ category , User Interface $ follower ) { if ( $ category - > is Book ( ) ) { $ notification = $ this - > notification Manager - > create Notification ( $ this - > translator - > trans ( 'notification .follow _book .subject ' , [ ' %user Url % ' = > $ this - > router - > generate ( 'user _view ' , [ 'username ' = > $ follower - > get Username ( ) ] ) , ' %username % ' = > $ follower - > get Username ( ) , ' %book Url % ' = > $ this - > router - > generate ( 'book _view ' , [ 'slug ' = > $ category - > get Slug ( ) ] ) , ' %book Title % ' = > $ category - > get Name ( ) ] ) ) ; } else { $ notification = $ this - > notification Manager - > create Notification ( $ this - > translator - > trans ( 'notification .follow _category .subject ' , [ ' %user Url % ' = > $ this - > router - > generate ( 'user _view ' , [ 'username ' = > $ follower - > get Username ( ) ] ) , ' %username % ' = > $ follower - > get Username ( ) , ' %category Url % ' = > $ this - > router - > generate ( 'category _view ' , [ 'slug ' = > $ category - > get Slug ( ) ] ) , ' %category Title % ' = > $ category - > get Name ( ) ] ) ) ; } $ notification - > add Parameters ( [ 'subject ' = > Notification : : SUBJECT _FOLLOW _CATEGORY , 'category _id ' = > $ category - > get Id ( ) , 'follower _id ' = > $ follower - > get Id ( ) , 'follower _username ' = > $ follower - > get Username ( ) , ] ) ; return $ notification ; } 
public function create Withdraw Notification ( Payment Interface $ payment ) { $ message = $ payment - > get Status ( ) = = = Payment Interface : : STATUS _OK ? $ this - > translator - > trans ( 'notification .withdraw .subject .your _withdraw _was _approved ' , [ ' %payment % ' = > $ payment - > get Description ( ) ] ) : $ this - > translator - > trans ( 'notification .withdraw .subject .your _withdraw _was _declined ' , [ ' %payment % ' = > $ payment - > get Description ( ) ] ) ; $ notification = $ this - > notification Manager - > create Notification ( $ this - > translator - > trans ( 'notification .withdraw .subject ' ) , $ message ) ; $ notification - > add Parameters ( [ 'subject ' = > Notification : : SUBJECT _HANDLE _WITHDRAW , 'payment _id ' = > $ payment - > get Id ( ) , 'payment _serial _no ' = > $ payment - > get Serial No ( ) , ] ) ; return $ notification ; } 
public function create Vote Topic Notification ( Topic Interface $ topic , User Interface $ user ) { $ notification = $ this - > notification Manager - > create Notification ( $ this - > translator - > trans ( 'notification .vote _topic .subject ' , [ ' %user Url % ' = > $ this - > router - > generate ( 'user _view ' , [ 'username ' = > $ user - > get Username ( ) ] ) , ' %username % ' = > $ user - > get Username ( ) , ' %topic Url % ' = > $ this - > router - > generate ( 'topic _view ' , [ 'id ' = > $ topic - > get Id ( ) ] ) , ' %topic Title % ' = > $ topic - > get Title ( ) ] ) ) ; $ notification - > add Parameters ( [ 'subject ' = > Notification : : SUBJECT _VOTE _TOPIC , 'topic _id ' = > $ topic - > get Id ( ) , 'voter _id ' = > $ user - > get Id ( ) , 'voter _username ' = > $ user - > get Username ( ) , ] ) ; return $ notification ; } 
public function create Vote Reply Notification ( Topic Interface $ topic , Reply Interface $ reply , User Interface $ user ) { $ notification = $ this - > notification Manager - > create Notification ( $ this - > translator - > trans ( 'notification .vote _reply .subject ' , [ ' %user Url % ' = > $ this - > router - > generate ( 'user _view ' , [ 'username ' = > $ user - > get Username ( ) ] ) , ' %username % ' = > $ user - > get Username ( ) , ' %topic Url % ' = > $ this - > router - > generate ( 'topic _view ' , [ 'id ' = > $ topic - > get Id ( ) ] ) , ' %topic Title % ' = > $ topic - > get Title ( ) ] ) ) ; $ notification - > add Parameters ( [ 'subject ' = > Notification : : SUBJECT _VOTE _REPLY , 'topic _id ' = > $ topic - > get Id ( ) , 'reply _id ' = > $ reply - > get Id ( ) , 'voter _id ' = > $ user - > get Id ( ) , 'voter _username ' = > $ user - > get Username ( ) , ] ) ; return $ notification ; } 
public function create Vote Post Notification ( Post Interface $ post , User Interface $ user ) { $ notification = $ this - > notification Manager - > create Notification ( $ this - > translator - > trans ( 'notification .vote _post .subject ' , [ ' %user Url % ' = > $ this - > router - > generate ( 'user _view ' , [ 'username ' = > $ user - > get Username ( ) ] ) , ' %username % ' = > $ user - > get Username ( ) , ' %post Url % ' = > $ this - > router - > generate ( 'post _view ' , [ 'id ' = > $ post - > get Id ( ) ] ) , ' %post Title % ' = > $ post - > get Title ( ) ] ) ) ; $ notification - > add Parameters ( [ 'subject ' = > Notification : : SUBJECT _VOTE _POST , 'post _id ' = > $ post - > get Id ( ) , 'voter _id ' = > $ user - > get Id ( ) , 'voter _username ' = > $ user - > get Username ( ) , ] ) ; return $ notification ; } 
public function create Vote Comment Notification ( Post Interface $ post , Comment Interface $ comment , User Interface $ user ) { $ notification = $ this - > notification Manager - > create Notification ( $ this - > translator - > trans ( 'notification .vote _comment .subject ' , [ ' %user Url % ' = > $ this - > router - > generate ( 'user _view ' , [ 'username ' = > $ user - > get Username ( ) ] ) , ' %username % ' = > $ user - > get Username ( ) , ' %post Url % ' = > $ this - > router - > generate ( 'post _view ' , [ 'id ' = > $ post - > get Id ( ) ] ) , ' %post Title % ' = > $ post - > get Title ( ) ] ) ) ; $ notification - > add Parameters ( [ 'subject ' = > Notification : : SUBJECT _VOTE _COMMENT , 'post _id ' = > $ post - > get Id ( ) , 'comment _id ' = > $ comment - > get Id ( ) , 'voter _id ' = > $ user - > get Id ( ) , 'voter _username ' = > $ user - > get Username ( ) , ] ) ; return $ notification ; } 
public function send Notification ( $ participant , $ notification ) { $ participants = is _array ( $ participant ) ? $ participant : [ $ participant ] ; $ this - > notification Manager - > send Notification ( $ participants , $ notification , true ) ; } 
public function user Following Action ( User Interface $ user ) { $ following = $ this - > get User Manager ( ) - > find User Following ( $ user , 1 ) ; return $ this - > render ( $ this - > configuration - > get Template ( 'User :user _grid .html .twig ' ) , [ 'users ' = > $ following , ] ) ; } 
public function user Followers Action ( User Interface $ user ) { $ following = $ this - > get User Manager ( ) - > find User Followers ( $ user , 1 ) ; return $ this - > render ( $ this - > configuration - > get Template ( 'User :user _grid .html .twig ' ) , [ 'users ' = > $ following , ] ) ; } 
public function get User Following Action ( $ username , Request $ request ) { $ manager = $ this - > get User Manager ( ) ; $ user = $ manager - > find User By Name ( $ username ) ; $ following = $ manager - > find User Following ( $ user , $ request - > query - > get Int ( 'page ' , 1 ) ) ; return $ this - > render ( $ this - > configuration - > get Template ( 'User :user _following .html .twig ' ) , [ 'user ' = > $ user , 'users ' = > $ following , ] ) ; } 
public function get User Followers Action ( $ username , Request $ request ) { $ manager = $ this - > get User Manager ( ) ; $ user = $ manager - > find User By Name ( $ username ) ; $ followers = $ manager - > find User Followers ( $ user , $ request - > query - > get Int ( 'page ' , 1 ) ) ; $ view = $ this - > view ( [ 'user ' = > $ user , 'followers ' = > $ followers , ] ) - > set Template ( $ this - > configuration - > get Template ( 'User :user _followers .html .twig ' ) ) ; return $ this - > handle View ( $ view ) ; } 
public function follow Action ( $ username ) { $ this - > deny Access Unless Granted ( 'IS _AUTHENTICATED _REMEMBERED ' ) ; $ manager = $ this - > get User Manager ( ) ; $ user = $ manager - > find User By Name ( $ username ) ; $ view = $ this - > view ( ) ; try { $ manager - > follow User ( $ user , $ this - > get User ( ) ) ; $ view - > set Status Code ( static : : HTTP _CREATED ) - > set Data ( [ 'follower _count ' = > $ user - > get Follower Count ( ) , ] ) ; } catch ( \ Exception $ exception ) { $ view - > set Status Code ( static : : HTTP _BAD _REQUEST ) - > set Data ( [ 'error ' = > $ exception - > get Message ( ) , ] ) ; } return $ this - > handle View ( $ view ) ; } 
public function un Follow Action ( $ username ) { $ this - > deny Access Unless Granted ( 'IS _AUTHENTICATED _REMEMBERED ' ) ; $ manager = $ this - > get User Manager ( ) ; $ user = $ manager - > find User By Name ( $ username ) ; $ view = $ this - > view ( ) ; $ manager - > un Follow User ( $ user , $ this - > get User ( ) ) ; $ view - > set Status Code ( static : : HTTP _OK ) - > set Data ( [ 'follower _count ' = > $ user - > get Follower Count ( ) , ] ) ; return $ this - > handle View ( $ view ) ; } 
public function point Action ( $ username , Request $ request ) { $ this - > deny Access Unless Granted ( 'IS _AUTHENTICATED _REMEMBERED ' ) ; $ manager = $ this - > get User Manager ( ) ; $ user = $ manager - > find User By Name ( $ username ) ; $ histories = $ this - > get Point Manager ( ) - > find Point Histories ( $ user , $ request - > get ( 'page ' , 1 ) ) ; return $ this - > render ( $ this - > configuration - > get Template ( 'User :point _history .html .twig ' ) , [ 'histories ' = > $ histories , 'user ' = > $ user , ] ) ; } 
public function process ( Container Builder $ container ) { 
public function on Register Success ( Form Event $ event ) { $ user = $ event - > get Form ( ) - > get Data ( ) ; $ response = new Redirect Response ( $ this - > router - > generate ( 'user _view ' , [ 'username ' = > $ user - > get Username ( ) , ] ) ) ; $ event - > set Response ( $ response ) ; } 
public function on Resetting Reset Success ( Form Event $ event ) { $ response = new Redirect Response ( $ this - > router - > generate ( 'setting _profile ' ) ) ; $ event - > set Response ( $ response ) ; } 
public function post Persist ( $ user , Lifecycle Event Args $ event ) { $ now = Carbon : : now ( ) ; $ user - > set Created At ( $ now ) - > set Updated At ( $ now ) ; $ user - > set Avatar ( $ this - > avatar Generator - > generate ( $ user - > get Username ( ) ) - > get Key ( ) ) ; 
public function process ( $ body ) { $ body = $ this - > markdown Parser - > transform Markdown ( $ body ) ; $ body = $ this - > html Purifier - > purify ( $ body ) ; 
public function create Wallet ( User Interface $ user ) { $ wallet = new $ this - > wallet Entity ; $ now = Carbon : : now ( ) ; $ wallet - > set User ( $ user ) - > set Created At ( $ now ) - > set Updated At ( $ now ) ; return $ wallet ; } 
public function save Wallet ( Wallet Interface $ wallet ) { $ this - > entity Manager - > persist ( $ wallet ) ; $ this - > entity Manager - > flush ( ) ; } 
public function add History ( Wallet Interface $ wallet , Wallet History Interface $ history ) { $ wallet - > add History ( $ history ) ; 
public function create History ( ) { $ history = new $ this - > payment Entity ; $ now = Carbon : : now ( ) ; $ history - > set Updated At ( $ now ) - > set Created At ( $ now ) ; return $ history ; } 
public function get User Wallet ( User Interface $ user ) { $ wallet = $ this - > get Wallet Repository ( ) - > find One By ( [ 'user ' = > $ user ] ) ; if ( ! $ wallet ) { $ wallet = $ this - > create Wallet ( $ user ) ; $ this - > save Wallet ( $ wallet ) ; } $ wallet - > set User ( $ user ) ; return $ wallet ; } 
public function find User Wallet Histories ( Wallet Interface $ wallet , $ page , $ limit = null ) { $ query = $ this - > get History Repository ( ) - > create Query Builder ( 'wh ' ) - > where ( 'wh .wallet = :wallet ' ) - > set Parameter ( 'wallet ' , $ wallet ) - > order By ( 'wh .updated At ' , 'desc ' ) - > get Query ( ) ; return $ this - > create Paginator ( $ query , $ page , $ limit ) ; } 
public function withdraw ( Wallet Interface $ wallet , $ amount , $ alipay ) { $ amount = intval ( $ amount ) ; if ( $ amount < Payment Interface : : WITHDRAW _MAX _AMOUNT ) { throw new \ Logic Exception ( $ this - > translator - > trans ( 'withdraw .amount _should _greater _than ' , Payment Interface : : WITHDRAW _MAX _AMOUNT ) ) ; } if ( $ wallet - > get Amount ( ) < $ amount ) { throw new \ Logic Exception ( $ this - > translator - > trans ( 'withdraw .not _encough _balance ' ) ) ; } if ( ! $ alipay ) { throw new \ Logic Exception ( $ this - > translator - > trans ( 'withdraw .need _provide _alipay ' ) ) ; } $ history = $ this - > create History ( ) ; $ history - > set Type ( Payment Interface : : TYPE _WITHDRAW ) - > set Amount ( $ amount ) - > set Description ( ' ' ) - > set Status ( Payment Interface : : STATUS _WAITING ) - > set Description ( $ this - > translator - > trans ( 'withdraw .to ' , [ ' %alipay % ' = > $ alipay ] ) ) - > set User ( $ wallet - > get User ( ) ) ; 
public function refuse Withdraw ( Wallet History Interface $ history , $ reason = null ) { $ history - > get Wallet ( ) - > release ( $ history - > get Amount ( ) ) ; 
public function approve Withdraw ( Wallet History Interface $ history , $ reason = null ) { $ wallet = $ history - > get Wallet ( ) ; $ wallet - > set Freeze Amount ( $ wallet - > get Freeze Amount ( ) - $ history - > get Amount ( ) ) ; 
protected function execute ( Input Interface $ input , Output Interface $ output ) { $ output Style = new Symfony Style ( $ input , $ output ) ; $ output Style - > writeln ( 'Creating PHPDish database . ' ) ; 
protected function create Schema With Progressbar ( Output Interface $ output ) { ksort ( $ this - > commands ) ; $ this - > bulk Run Commands ( $ this - > commands , $ output , true ) ; } 
protected function is Database Present ( ) { $ connection = $ this - > get Container ( ) - > get ( 'doctrine .dbal .default _connection ' ) ; $ database Name = $ connection - > get Database ( ) ; try { return in _array ( $ database Name , $ connection - > get Schema Manager ( ) - > list Databases ( ) ) ; } catch ( \ Exception $ exception ) { $ message = $ exception - > get Message ( ) ; $ mysql Database Error = false ! = = strpos ( $ message , sprintf ( "Unknown database ' %s ' " , $ database Name ) ) ; $ postgres Database Error = false ! = = strpos ( $ message , sprintf ( 'database " %s " does not exist ' , $ database Name ) ) ; if ( $ mysql Database Error | | $ postgres Database Error ) { return false ; } throw $ exception ; } } 
public function get Root Dir ( ) { if ( null = = = $ this - > root Dir ) { $ r = new \ Reflection Object ( $ this ) ; $ dir = $ root Dir = dirname ( $ r - > get File Name ( ) ) ; while ( ! file _exists ( $ dir . ' /composer .json ' ) ) { if ( $ dir = = = dirname ( $ dir ) ) { return $ this - > root Dir = $ root Dir ; } $ dir = dirname ( $ dir ) ; } $ this - > root Dir = $ dir ; } return $ this - > root Dir ; } 
public function create Reply ( Topic Interface $ topic , User Interface $ user = null ) { $ reply = new $ this - > reply Entity ; $ reply - > set Topic ( $ topic ) - > set Created At ( Carbon : : now ( ) ) ; $ user & & $ reply - > set User ( $ user ) ; return $ reply ; } 
public function save Reply ( Reply Interface $ reply ) { $ parsed Body = $ this - > body Processor - > process ( $ reply - > get Original Body ( ) ) ; $ reply - > set Updated At ( Carbon : : now ( ) ) - > set Body ( $ parsed Body ) ; if ( $ new = ! $ reply - > get Id ( ) ) { $ reply - > get Topic ( ) - > add Comment Count ( 1 ) - > set Last Comment At ( Carbon : : now ( ) ) - > set Last Comment User ( $ reply - > get User ( ) ) ; } $ this - > entity Manager - > persist ( $ reply ) ; $ this - > entity Manager - > flush ( ) ; 
public function find Replies Pager ( Criteria $ criteria , $ page , $ limit = null ) { $ qb = $ this - > get Replies Qb ( ) - > add Criteria ( $ criteria ) ; return $ this - > create Paginator ( $ qb - > get Query ( ) , $ page , $ limit ) ; } 
public function find Topic Replies ( Topic Interface $ topic , $ page , $ limit = null , Criteria $ criteria = null ) { $ qb = $ this - > get Replies Qb ( ) - > where ( 'r .topic = :topic ' ) - > set Parameter ( 'topic ' , $ topic ) - > and Where ( 'r .enabled = :enabled ' ) - > set Parameter ( 'enabled ' , true ) ; if ( $ criteria ) { $ qb - > add Criteria ( $ criteria ) ; } return $ this - > create Paginator ( $ qb - > get Query ( ) , $ page , $ limit ) ; } 
public function find User Replies ( User Interface $ user , $ page , $ limit = null , Criteria $ criteria = null ) { $ qb = $ this - > get Reply Repository ( ) - > create Query Builder ( 'r ' ) - > add Select ( 'rt ' ) - > join ( 'r .topic ' , 'rt ' ) - > where ( 'r .user = :user ' ) - > set Parameter ( 'user ' , $ user ) - > and Where ( 'r .enabled = :enabled ' ) - > set Parameter ( 'enabled ' , true ) - > order By ( 'r .created At ' , 'desc ' ) ; if ( $ criteria ) { $ qb - > add Criteria ( $ criteria ) ; } return $ this - > create Paginator ( $ qb - > get Query ( ) , $ page , $ limit ) ; } 
public function block Reply ( Reply Interface $ reply ) { $ reply - > disable ( ) ; $ topic = $ reply - > get Topic ( ) ; $ topic - > add Comment Count ( - 1 ) ; $ this - > entity Manager - > persist ( $ reply ) ; $ this - > entity Manager - > flush ( ) ; return true ; } 
public function reply Topic ( User Interface $ user , Topic Interface $ topic , $ body ) { $ reply = $ this - > create Reply ( $ topic , $ user ) ; $ reply - > set Original Body ( $ body ) ; $ this - > save Reply ( $ reply ) ; return $ reply ; } 
public function add Voter ( Reply Interface $ reply , User Interface $ user ) { $ reply - > add Voter ( $ user ) - > add Vote Count ( ) ; $ this - > entity Manager - > persist ( $ reply ) ; $ this - > entity Manager - > flush ( ) ; 
public function remove Voter ( Reply Interface $ reply , User Interface $ user ) { $ reply - > remove Voter ( $ user ) - > add Vote Count ( - 1 ) ; $ this - > entity Manager - > persist ( $ reply ) ; $ this - > entity Manager - > flush ( ) ; } 
public function search Action ( Request $ request ) { $ keyword = $ request - > query - > get ( 'q ' ) ; $ type = $ request - > query - > get ( 'type ' , static : : TYPE _TOPIC ) ; $ search Result = $ this - > searc From ( $ keyword , $ type , [ 'length ' = > 1 0 , 'page ' = > $ request - > query - > get Int ( 'page ' , 1 ) ] ) ; return $ this - > render ( 'PHPDish Web Bundle :Search :result .html .twig ' , [ 'search Result ' = > $ search Result , 'keyword ' = > $ keyword ] ) ; } 
protected function searc From ( $ keyword , $ type , $ options ) { $ search Service = $ this - > get ( 'phpdish .searcher ' ) ; if ( $ type = = = static : : TYPE _TOPIC ) { $ search Result = $ search Service - > query Topics ( $ keyword , $ options ) ; } elseif ( $ type = = = static : : TYPE _USER ) { $ search Result = $ search Service - > query Users ( $ keyword , $ options ) ; } else { $ search Result = $ search Service - > query Posts ( $ keyword , $ options ) ; } return $ search Result ; } 
public function transform From Url ( $ url ) { $ extension = Extension Finder : : find ( $ url ) ; return $ this - > transform With Extension ( strrchr ( $ url , $ extension ) ) ; } 
public function transform With Extension ( $ extension ) { $ base Dir = Carbon : : now ( ) - > format ( 'Y /md ' ) ; do { $ path = " { $base Dir } / { $this - >generate Key ( ) } . " . $ extension ; } while ( $ this - > filesystem - > has ( $ path ) ) ; return $ path ; } 
public function get Config Tree Builder ( ) { $ tree Builder = new Tree Builder ( ) ; $ root Node = $ tree Builder - > root ( 'phpdish _payment ' ) ; $ root Node - > children ( ) - > array Node ( 'youzan ' ) - > children ( ) - > scalar Node ( 'client _id ' ) - > cannot Be Empty ( ) - > end ( ) - > scalar Node ( 'client _secret ' ) - > cannot Be Empty ( ) - > end ( ) - > scalar Node ( 'kdt _id ' ) - > cannot Be Empty ( ) - > end ( ) - > end ( ) - > end ( ) ; $ this - > add Resources Section ( $ root Node ) ; $ this - > add Templates Section ( $ root Node ) ; return $ tree Builder ; } 
public function chunk ( $ html , $ percent ) { $ total Length = mb _strlen ( $ html ) ; $ reserved Length = intval ( $ total Length * $ percent ) ; $ chunk Html = mb _substr ( $ html , 0 , $ reserved Length , 'utf - 8 ' ) ; $ junk Tag Pattern = ' # <img [ ^ > ] + $ # ' ; 
public function add Action ( $ id , Request $ request ) { $ this - > deny Access Unless Granted ( 'IS _AUTHENTICATED _REMEMBERED ' ) ; $ post = $ this - > get Post Manager ( ) - > find Post By Id ( $ id ) ; $ comment = $ this - > get Post Comment Manager ( ) - > create Comment ( $ post , $ this - > get User ( ) ) ; $ form = $ this - > create Form ( Comment Type : : class , $ comment ) ; $ form - > handle Request ( $ request ) ; $ view = $ this - > view ( ) ; if ( $ form - > is Submitted ( ) & & $ form - > is Valid ( ) ) { $ this - > get Post Comment Manager ( ) - > save Comment ( $ comment ) ; 
public function delete Action ( $ id ) { $ manager = $ this - > get Post Comment Manager ( ) ; $ comment = $ manager - > find Comment By Id ( $ id ) ; if ( ! $ comment ) { throw $ this - > create Not Found Exception ( ) ; } $ this - > deny Access Unless Granted ( 'edit ' , $ comment ) ; $ manager - > block Comment ( $ comment ) ; return $ this - > handle View ( $ this - > view ( [ 'result ' = > true , ] ) ) ; } 
public function toggle Voter Action ( $ id ) { $ this - > deny Access Unless Granted ( 'IS _AUTHENTICATED _REMEMBERED ' ) ; $ comment = $ this - > get Post Comment Manager ( ) - > find Comment By Id ( $ id ) ; if ( ! $ comment ) { throw new \ Invalid Argument Exception ( $ this - > get ( 'translator ' ) - > trans ( 'comment .not _exists ' ) ) ; } if ( $ is Voted = $ comment - > is Voted By ( $ this - > get User ( ) ) ) { $ this - > get Post Comment Manager ( ) - > remove Voter ( $ comment , $ this - > get User ( ) ) ; } else { $ this - > get Post Comment Manager ( ) - > add Voter ( $ comment , $ this - > get User ( ) ) ; } return $ this - > json ( [ 'vote _count ' = > $ comment - > get Vote Count ( ) , 'is _voted ' = > ! $ is Voted ] ) ; } 
public function create Column ( $ name , $ type , $ options = [ ] ) { $ column = new Column ( $ name , $ type , $ options [ 'sortable ' ] ? ? true ) ; if ( $ options [ 'filterable ' ] ) { 
public function create Grid ( $ source , $ alias = null ) { $ source = $ this - > create Source ( $ source , $ alias ) ; $ grid = new Grid ( $ source ) ; $ grid - > set Factory ( $ this ) ; return $ grid ; } 
public function get Functions ( ) { return [ new \ Twig _Simple Function ( 'get _user ' , [ $ this - > user Manager , 'find User By Id ' ] ) , new \ Twig _Simple Function ( 'get _user _by _username ' , [ $ this - > user Manager , 'find User By Username ' ] ) , new \ Twig _Simple Function ( 'get _user _by _email ' , [ $ this - > user Manager , 'find User By Email ' ] ) , new \ Twig _Simple Function ( 'get _user _by _username _or _email ' , [ $ this - > user Manager , 'find User By Username Or Email ' ] ) , new \ Twig _Simple Function ( 'get _users ' , [ $ this , 'get Users ' ] ) , new \ Twig _Simple Function ( 'get _users _pager ' , [ $ this - > user Manager , 'find Users Pager ' ] ) , new \ Twig _Simple Function ( 'get _category _authors ' , [ $ this , 'get Category Authors ' ] ) , ] ; } 
public function get Category Authors ( $ limit = 1 0 ) { $ qb = $ this - > user Manager - > get User Repository ( ) - > create Query Builder ( 'u ' ) ; return $ qb - > select ( 'distinct u ' ) - > inner Join ( 'u .categories ' , 'c ' ) - > where ( 'c .post Count > :post Count ' ) - > set Parameter ( 'post Count ' , 0 ) - > set Max Results ( $ limit ) - > order By ( 'u .updated At ' , 'desc ' ) - > get Query ( ) - > get Result ( ) ; } 
public function get Users ( $ criteria , array $ order By = [ ] , ? int $ limit = null ) { if ( $ criteria instanceof Criteria ) { return $ this - > user Manager - > find Users By Criteria ( $ criteria ) ; } else { return $ this - > user Manager - > get User Repository ( ) - > find By ( $ criteria , $ order By , $ limit ) ; } } 
public function get Point History Label ( Point History Interface $ history ) { static $ labels = [ Point History : : TYPE _SIGN _IN = > 'point .history .type .sign _in ' , Point History : : TYPE _CHECK _IN = > 'point .history .type .check _in ' , 
public function load ( Object Manager $ manager ) { $ user 1 = $ this - > get User Manipulator ( ) - > create ( ' 优 雅 的 风 ' , ' 1 2 3 4 5 6 , 'user 1 @ hpdish .com ' , true , f lse ) ; $ user 2 = $ this - > get User Manipulator ( ) - > create ( ' 风 中 的 少 年 ' , ' 1 2 3 4 5 6 ' , 'user 2 @p h dish .com ' , true , fa l e ) ; $ avatar Generator = $ this - > get Avatar Generator ( ) ; $ user 1 - > set Avatar ( $ avatar Generator - > generate ( ' 优 雅 的 风 ' ) - >get Ke y ( ) ) ; $ user 2 - > set Avatar ( $ avatar Generator - > generate ( ' 风 中 的 少 年 ' ) - >get Key ( ) ) ; $ user Manager = $ this - > get User Manager ( ) ; $ user Manager - > update User ( $ user 1 ) ; $ user Manager - > update User ( $ user 2 ) ; $ this - > add Reference ( 'general -user ' , $ user 1 ) ; } 
protected function create Paginator ( Query $ query , $ page , $ limit = null ) { $ paginator = new Pagerfanta ( new Doctrine ORMAdapter ( $ query ) ) ; $ paginator - > set Current Page ( $ page ) ; $ paginator - > set Max Per Page ( $ limit ? : $ this - > get Max Per Page ( ) ) ; return $ paginator ; } 
protected function execute ( Input Interface $ input , Output Interface $ output ) { $ checker = $ this - > get Container ( ) - > get ( 'phpdish .installer .requirements _checker ' ) ; $ checker - > set Output ( $ output ) ; $ fulfilled = $ checker - > check ( $ output ) ; if ( ! $ fulfilled ) { throw new Runtime Exception ( 'Some system requirements are not fulfilled . Please check output messages and fix them . ' ) ; } $ output - > writeln ( ' <info >Success ! Your system can run PHPDish properly . < /info > ' ) ; } 
public function create File From Uploaded File ( Uploaded File $ uploaded File ) { $ file = $ this - > is Image ( $ uploaded File ) ? new Image ( ) : new File ( ) ; $ file - > set Extension ( $ uploaded File - > guess Extension ( ) ) - > set Size ( $ uploaded File - > get Size ( ) ) - > set Content Type ( $ uploaded File - > get Mime Type ( ) ) - > set Content ( stream _for ( fopen ( $ uploaded File - > get Real Path ( ) , 'r ' ) ) ) - > set Key ( $ this - > namer - > transform ( $ uploaded File ) ) ; return $ file ; } 
public function create File With Extension ( $ extension ) { $ key = $ this - > namer - > transform With Extension ( $ extension ) ; return $ this - > create File By Key ( $ key ) ; } 
public function freeze ( $ amount ) { if ( $ this - > amount < $ amount ) { throw new \ Logic Exception ( 'Not enough balance ' ) ; } $ this - > amount - = $ amount ; $ this - > freeze Amount + = $ amount ; return $ this ; } 
public function release ( $ amount ) { if ( $ this - > freeze Amount < $ amount ) { throw new \ Logic Exception ( 'Not enough frozen balance ' ) ; } $ this - > amount + = $ amount ; $ this - > freeze Amount - = $ amount ; return $ this ; } 
public function warm Up ( $ cache Dir ) { $ all Templates = $ this - > finder - > find All Templates ( ) ; $ filesystem = new Filesystem ( ) ; $ templates = array ( ) ; 
public function execute ( Input Interface $ input , Output Interface $ output ) { $ this - > raw Command = $ this - > get Application ( ) - > get ( 'sylius :theme :list ' ) ; $ arguments = array ( 'command ' = > 'sylius :theme :list ' , ) ; $ greet Input = new Array Input ( $ arguments ) ; $ this - > raw Command - > run ( $ greet Input , $ output ) ; } 
public function create Point History ( User Interface $ user , $ amount , $ type = null ) { $ history = new $ this - > point History Entity ; $ history - > set User ( $ user ) - > set Amount ( $ amount ) - > set Type ( $ type ) ; return $ history ; } 
public function save Point History ( Point History Interface $ history ) { $ this - > entity Manager - > persist ( $ history ) ; $ this - > entity Manager - > flush ( ) ; } 
public function find Point Histories ( User Interface $ user , $ page , $ limit = null ) { $ query = $ this - > get Point History Repository ( ) - > create Query Builder ( 'p ' ) - > where ( 'p .user = :user ' ) - > set Parameter ( 'user ' , $ user ) - > get Query ( ) ; return $ this - > create Paginator ( $ query , $ page , $ limit ) ; } 
public function register Bundles ( ) { $ bundles = [ new Easy Corp \ Bundle \ Easy Admin Bundle \ Easy Admin Bundle ( ) , 
public function get Theme ( ) : ? Theme Interface { return $ this - > current Theme Name ? $ this - > theme Repository - > find One By Name ( $ this - > current Theme Name ) : null ; } 
public function build Form ( Form Builder Interface $ builder , array $ options ) { $ builder - > add ( 'title ' , Text Type : : class , [ 'label ' = > 'form .post .title ' , ] ) - > add ( 'category ' , Entity Type : : class , [ 'class ' = > 'PHPDish Post Bundle :Category ' , 'choice _label ' = > 'name ' , 'choices ' = > $ this - > get Current User Categories ( $ options ) , ] ) - > add ( 'original Body ' , Textarea Type : : class , [ 'label ' = > 'form .post .body ' , ] ) ; } 
public function find All ( ) { if ( $ this - > plugins ) { return $ this - > plugins ; } if ( $ this - > cached ) { foreach ( $ this - > cache as $ plugin Item ) { if ( class _exists ( $ plugin Item [ 'class ' ] ) ) { $ this - > plugins [ ] = new $ plugin Item [ 'class ' ] ; } } } else { $ this - > plugins = $ this - > decorated Finder - > find All ( ) ; } return $ this - > plugins ; } 
public function process ( Container Builder $ container ) { 
public function index ( Request $ request ) { $ this - > deny Access Unless Granted ( 'IS _AUTHENTICATED _REMEMBERED ' ) ; $ meta = $ this - > notification Manager - > find Notification Metadata Pager ( $ this - > get User ( ) , null , $ request - > query - > get Int ( 'page ' , 1 ) ) ; 
public function get Children ( ) { return $ this - > children - > matching ( Criteria : : create ( ) - > where ( Criteria : : expr ( ) - > eq ( 'enabled ' , true ) ) ) ; } 
public function get Config Tree Builder ( ) { $ tree Builder = new Tree Builder ( ) ; $ root Node = $ tree Builder - > root ( 'phpdish _core ' ) ; $ this - > add Assets Section ( $ root Node ) ; return $ tree Builder ; } 
public function build ( Container Builder $ container ) { parent : : build ( $ container ) ; $ container - > add Compiler Pass ( new Doctrine Target Entities Resolver Pass ( ) , Pass Config : : TYPE _BEFORE _OPTIMIZATION , 1 ) ; $ container - > add Compiler Pass ( new Register Resource Pass ( ) ) ; $ container - > add Compiler Pass ( new Inject Resource Configuration Pass ( ) ) ; $ container - > add Compiler Pass ( new Inject Service Manager ( ) ) ; } 
public function encode Password ( $ raw , $ salt ) { if ( $ this - > difficulty = = = static : : DIFFICULTY _SIMPLE ) { $ salt = null ; } return $ this - > message Digest Password Encoder - > encode Password ( $ raw , $ salt ) ; } 
public function is Password Valid ( $ encoded , $ raw , $ salt ) { if ( $ this - > difficulty = = = static : : DIFFICULTY _SIMPLE ) { $ salt = null ; } return $ this - > message Digest Password Encoder - > is Password Valid ( $ encoded , $ raw , $ salt ) ; } 
public function load ( Object Manager $ manager ) { $ manager = $ this - > get Category Manager ( ) ; $ post = $ manager - > create Post ( $ this - > get Reference ( 'general -user ' ) ) ; $ body = < < <EOT 此 次 基 准 测 试 只 是 简 单 测 算 一 下node 与php 在 冒 泡 排 序 方 面 的 时 间 损 耗 情 况 ， 基 本 思 想 是 使 用 冒 泡 排 序 各 自 运 算 1 0 0 次 之 后 求 出 平 均 值 ； 冒 泡 排 序 算 法 摘 自 网 上 ， 测 试 代 码 如 下 ： # # 代 码 Java Script : ` ` `javascript function sort (arr ) { var n =arr .length ; var temp =null ; for (var i = 0 ; i <n - 1 ; i + + ) { for (var j = 0 ; j <n - 1 -i ; j + + ) { if (arr [j ] >arr [j + 1 ] ) { temp =arr [j ] ; arr [j ] =arr [j + 1 ] ; arr [j + 1 ] =temp ; } } } return arr ; } const array = [ 4 9 , 3 8 , 6 5 , 9 7 , 7 6 , 1 3 , 2 7 , 4 9 , 3 8 , 6 5 , 9 7 , 7 6 , 1 3 , 2 7 ] ; const start Time = new Date ( ) ; for (let i = 0 ; i < = 9 9 ; i + + ) { const arr = sort (array ) ; } console .log ( (new Date ( ) - start Time ) / 1 0 0 0 / 1 0 0 ) ; ` ` ` PHP : ` ` `php function bubble _sort ( \ $array ) { \ $count = count ( \ $array ) ; if ( \ $count < = 0 ) return false ; for ( \ $i = 0 ; \ $i < \ $count ; \ $i + + ) { for ( \ $j = \ $count - 1 ; \ $j > \ $i ; \ $j - - ) { if ( \ $array [ \ $j ] < \ $array [ \ $j - 1 ] ) { \ $tmp = \ $array [ \ $j ] ; \ $array [ \ $j ] = \ $array [ \ $j - 1 ] ; \ $array [ \ $j - 1 ] = \ $tmp ; } } } return \ $array ; } \ $array = [ 4 9 , 3 8 , 6 5 , 9 7 , 7 6 , 1 3 , 2 7 , 4 9 , 3 8 , 6 5 , 9 7 , 7 6 , 1 3 , 2 7 ] ; \ $start Time = microtime (true ) ; for ( \ $i = 0 ; \ $i < = 9 9 ; \ $i + + ) { \ $arr = bubble _sort ( \ $array ) ; } echo number _format ( (microtime (true ) - \ $start Time ) / 1 0 0 , 1 0 ) ; ` ` ` 注 意 ： 为 了 测 试php 5 并 没 有 采 用php 7 的 强 调 语 法 类 型 # # 测 试 结 果 如 图 ： PHP 5 . 6 ! [clipboard .png ] (https : Node 7 . 9 : ! [clipboard .png ] (https : PHP 7 . 1 ! [clipboard .png ] (https : # # 结 论 三 次 测 算 的 结 果 分 别 是 ： | 环 境 | 时 间 (s ) | | - - - | - - - | |php 5 . 6 | 0 . 0 0 0 0 2 0 7 9 0 1 | |node 7 . 9 | 0 . 0 0 0 5 0 9 9 9 9 9 9 9 9 9 9 9 9 9 9 | |php 7 . 1 | 0 . 0 0 0 0 1 0 1 2 0 9 | 测 试 机 器 ! [clipboard .png ] (https : 从 本 次 测 试 的 结 果 来 看 在 执 行 速 度 上 PHP 7 . 1 > PHP 5 . 6 > Node 7 . 9 ; EOT ; $ post - > set Category ( $ this - > get Reference ( 'general -category ' ) ) - > set Title ( ' 一 个 简 单 的Node Js 与PHP 的benchmark ' ) - > set Original Body ( $ body ) ; $ manager - > save Post ( $ post ) ; } 
public function post Persist ( Topic Interface $ topic , Lifecycle Event Args $ event ) { $ user = $ topic - > get User ( ) ; $ this - > handle User Topic Count ( $ user ) ; } 
protected function handle User Topic Count ( User Interface $ user ) { $ count = $ this - > topic Manager - > get User Topic Count ( $ user ) ; $ user - > set Topic Count ( $ count ) ; $ this - > user Manager - > save User ( $ user ) ; } 
public function find Book ( $ slug ) { $ category = $ this - > category Manager - > find Category By Slug ( $ slug ) ; if ( ! $ category | | ! $ category - > is Book ( ) ) { throw new \ Invalid Argument Exception ( 'The book is not exists ' ) ; } return $ category ; } 
public function find Book Chapters Tree ( Book Interface $ book ) { $ repo = $ this - > post Manager - > get Post Repository ( ) ; return $ repo - > create Query Builder ( 'p ' ) - > where ( 'p .category = :book ' ) - > and Where ( 'p .enabled = :enabled ' ) - > set Parameter ( 'enabled ' , true ) - > set Parameter ( 'book ' , $ book ) - > order By ( 'p .level , p .left ' , 'ASC ' ) - > get Query ( ) - > set Hint ( \ Doctrine \ ORM \ Query : : HINT _INCLUDE _META _COLUMNS , true ) - > get Result ( 'tree ' ) ; } 
public function find User Books ( User Interface $ user ) { $ qb = $ this - > create Get User Books Query Builder ( $ user ) ; return $ qb - > get Query ( ) - > get Result ( ) ; } 
public function get User Book Number ( User Interface $ user ) { $ qb = $ this - > create Get User Books Query Builder ( $ user ) ; return ( int ) $ qb - > select ( $ qb - > expr ( ) - > count ( 'c ' ) ) - > get Query ( ) - > get Single Scalar Result ( ) ; } 
public function create Book ( User Interface $ user ) { $ book = $ this - > category Manager - > create Category ( $ user ) ; $ book - > as Book ( ) ; return $ book ; } 
public function add Book Chapter ( Book Interface $ book , $ chapter ) { if ( is _string ( $ chapter ) ) { $ title = $ chapter ; $ chapter = $ this - > post Manager - > create Post ( $ book - > get Creator ( ) ) ; $ chapter - > set Title ( $ title ) ; } $ chapter - > set Updated At ( Carbon : : now ( ) ) - > set Category ( $ book ) ; $ this - > post Manager - > save Post ( $ chapter ) ; return $ chapter ; } 
public function move Book Chapter ( Book Interface $ book , Chapter Interface $ chapter , $ direction , $ step ) { $ func = $ direction = = = static : : MOVE _DIRECTION _UP ? 'move Up ' : 'move Down ' ; $ this - > post Manager - > get Post Repository ( ) - > $ func ( $ chapter , $ step ) ; 
public function create Menu ( array $ options = [ ] ) { $ menu = $ this - > factory - > create Item ( 'root ' ) ; $ menu - > set Children Attribute ( 'class ' , 'list -group vertical -menu ' ) ; $ menu - > add Child ( 'Profile ' , [ 'label ' = > 'menu .profile ' , 'route ' = > 'setting _profile ' , ] ) - > set Attribute ( 'class ' , 'list -group -item if i -envelope -o ' ) ; $ menu - > add Child ( 'Change Password ' , [ 'label ' = > 'menu .change _password ' , 'route ' = > 'setting _change _password ' , ] ) - > set Attribute ( 'class ' , 'list -group -item if i -password ' ) ; $ menu - > add Child ( 'Social Binding ' , [ 'label ' = > 'menu .social _binding ' , 'route ' = > 'setting _social _binding ' , ] ) - > set Attribute ( 'class ' , 'list -group -item if i -sync ' ) ; 
public function warm Up ( $ cache Dir ) { $ plugins = $ this - > plugin Finder - > find All ( ) ; $ processed = [ ] ; foreach ( $ plugins as $ plugin ) { $ processed [ ] = [ 'class ' = > get _class ( $ plugin ) , 'path ' = > $ plugin - > get Root Dir ( ) ] ; } $ var = var _export ( $ processed , true ) ; $ export = < < <EOT < ?php return $var ; EOT ; $ this - > write Cache File ( $ cache Dir . ' /phpdish _plugins .php ' , $ export ) ; } 
public function set Profile ( Profile Interface $ profile ) { $ this - > profile - > clear ( ) ; $ profile - > set User ( $ this ) ; $ this - > profile [ ] = $ profile ; return $ this ; } 
public function index Action ( ) { $ this - > breadcrumb - > push ( 'admin .user .index ' ) ; $ grid = $ this - > grid Factory - > get ( User : : class ) ; return $ this - > render ( 'PHPDish Admin Bundle :User :index .html .twig ' , [ 'grid ' = > $ grid ] ) ; } 
public function save User ( User Interface $ user ) { $ user - > set Updated At ( Carbon : : now ( ) ) ; $ this - > object Manager - > persist ( $ user ) ; $ this - > object Manager - > flush ( ) ; return true ; } 
public function find Users By Names ( $ user Names ) { $ qb = $ this - > get Repository ( ) - > create Query Builder ( 'u ' ) ; return $ qb - > where ( $ qb - > expr ( ) - > in ( 'u .username ' , $ user Names ) ) - > get Query ( ) - > get Result ( ) ; } 
public function find User Following ( User Interface $ user , $ page , $ limit = null ) { $ query = $ this - > get Repository ( ) - > create Query Builder ( 'u ' ) - > inner Join ( 'u .followers ' , 'f ' ) - > where ( 'f .id = :user Id ' ) - > set Parameter ( 'user Id ' , $ user - > get Id ( ) ) - > get Query ( ) ; return $ this - > create Paginator ( $ query , $ page , $ limit ) ; } 
public function find Category Followers ( Category Interface $ category , $ page , $ limit = null ) { $ query = $ this - > get Repository ( ) - > create Query Builder ( 'u ' ) - > inner Join ( 'u .following Categories ' , 'f ' ) - > where ( 'f .id = :category Id ' ) - > set Parameter ( 'category Id ' , $ category - > get Id ( ) ) - > get Query ( ) ; return $ this - > create Paginator ( $ query , $ page , $ limit ) ; } 
public function find Topic Voters ( Topic Interface $ topic , $ page , $ limit = null ) { $ query = $ this - > get Repository ( ) - > create Query Builder ( 'u ' ) - > inner Join ( 'u .voted Topics ' , 'vt ' ) - > where ( 'vt .id = :topic Id ' ) - > set Parameter ( 'topic Id ' , $ topic - > get Id ( ) ) - > get Query ( ) ; return $ this - > create Paginator ( $ query , $ page , $ limit ) ; } 
public function find Topic Reply Voters ( Reply Interface $ reply , $ page , $ limit = null ) { $ query = $ this - > get Repository ( ) - > create Query Builder ( 'u ' ) - > inner Join ( 'u .voted Replies ' , 'vr ' ) - > where ( 'vr .id = :reply Id ' ) - > set Parameter ( 'reply Id ' , $ reply - > get Id ( ) ) - > get Query ( ) ; return $ this - > create Paginator ( $ query , $ page , $ limit ) ; } 
public function find Post Voters ( Post Interface $ post , $ page , $ limit = null ) { $ query = $ this - > get Repository ( ) - > create Query Builder ( 'u ' ) - > inner Join ( 'u .voted Posts ' , 'vp ' ) - > where ( 'vp .id = :post Id ' ) - > set Parameter ( 'post Id ' , $ post - > get Id ( ) ) - > get Query ( ) ; return $ this - > create Paginator ( $ query , $ page , $ limit ) ; } 
public function find Comment Voters ( Comment Interface $ comment , $ page , $ limit = null ) { $ query = $ this - > get Repository ( ) - > create Query Builder ( 'u ' ) - > inner Join ( 'u .voted Comments ' , 'vc ' ) - > where ( 'vc .id = :comment Id ' ) - > set Parameter ( 'comment Id ' , $ comment - > get Id ( ) ) - > get Query ( ) ; return $ this - > create Paginator ( $ query , $ page , $ limit ) ; } 
public function follow User ( User Interface $ user , User Interface $ follower ) { if ( $ user - > get Id ( ) = = $ follower - > get Id ( ) ) { throw new \ Logic Exception ( $ this - > translator - > trans ( 'follow .cannot _follow _yourself ' ) ) ; } $ user - > add Follower ( $ follower ) ; $ user - > set Follower Count ( $ user - > get Follower Count ( ) + 1 ) ; $ follower - > set Following Count ( $ follower - > get Following Count ( ) + 1 ) ; $ this - > object Manager - > persist ( $ user ) ; $ this - > object Manager - > persist ( $ follower ) ; $ this - > object Manager - > flush ( ) ; 
public function un Follow User ( User Interface $ user , User Interface $ follower ) { $ user - > remove Follower ( $ follower ) ; $ user - > set Follower Count ( $ user - > get Follower Count ( ) - 1 ) ; $ follower - > set Following Count ( $ follower - > get Following Count ( ) - 1 ) ; $ this - > object Manager - > persist ( $ user ) ; $ this - > object Manager - > persist ( $ follower ) ; $ this - > object Manager - > flush ( ) ; return true ; } 
public function find Users By Criteria ( Criteria $ criteria ) { return $ this - > get Repository ( ) - > create Query Builder ( 'u ' ) - > add Criteria ( $ criteria ) - > get Query ( ) - > get Result ( ) ; } 
public function find Users Pager ( Criteria $ criteria , $ page , $ limit = null ) { $ query = $ this - > get Repository ( ) - > create Query Builder ( 'u ' ) - > add Criteria ( $ criteria ) - > get Query ( ) ; return $ this - > create Paginator ( $ query , $ page , $ limit ) ; } 
protected function supports ( $ attribute , $ subject ) { $ entity Class = $ this - > get Resource Class ( ) ; return in _array ( $ attribute , $ this - > actions ) & & $ subject instanceof $ entity Class ; } 
protected function vote On Attribute ( $ attribute , $ subject , Token Interface $ token ) { $ user = $ token - > get User ( ) ; $ this - > has Authenticated User = $ user instanceof User Interface ; 
protected function can View ( $ entity , User Interface $ user ) { return $ this - > can Edit ( $ entity , $ user ) | | $ entity - > is Enabled ( ) ; } 
public function build ( Container Builder $ container ) { $ container - > add Compiler Pass ( Doctrine Orm Mappings Pass : : create Xml Mapping Driver ( [ $ this - > get Config Files Path ( ) = > $ this - > get Model Namespace ( ) ] , [ sprintf ( ' %s .object _manager ' , $ this - > get Bundle Prefix ( ) ) ] ) ) ; } 
public function is Valid ( $ record ) : bool { $ record = ( $ record instanceof Record ? $ record : new Record ( $ record ) ) ; foreach ( $ this - > filters as $ value ) { [ $ index , $ filter ] = $ value ; $ value = $ record - > _ _get ( $ index ) ; if ( $ filter - > is Valid ( $ value ) ) { continue ; } return false ; } return true ; } 
public function convert ( Traversable $ traversable ) { $ result = [ ] ; foreach ( $ traversable as $ key = > $ value ) { if ( $ this - > recursive & & $ value instanceof Traversable ) { $ value = $ this - > convert ( $ value ) ; } $ result [ $ key ] = $ value ; } return $ result ; } 
public function is Valid ( $ input ) : bool { foreach ( $ this - > get Filters ( ) as $ filter ) { if ( ! $ filter - > is Valid ( $ input ) ) { continue ; } return true ; } return false ; } 
public function convert ( Traversable $ traversable ) { $ name = $ this - > get Node Name ( $ traversable ) ; $ child Node = $ this - > document - > create Element ( $ name ) ; $ this - > document - > append Child ( $ child Node ) ; $ this - > parse Node ( $ traversable , $ child Node ) ; return $ this - > document - > save Xml ( ) ; } 
public function convert ( Traversable $ traversable ) { return json _encode ( ( new Arr ( true ) ) - > convert ( $ traversable ) , $ this - > json Encode Flags ) ; } 
protected function cast ( $ input ) { if ( $ input instanceof $ this - > precision ) { return $ input ; } if ( class _exists ( $ this - > precision ) ) { return new $ this - > precision ( $ input ) ; } settype ( $ input , $ this - > precision ) ; return $ input ; } 
public function is Valid ( $ actual ) : bool { if ( $ this - > precision = = self : : NORMAL ) { return $ this - > expected = = $ actual ; } if ( $ this - > precision = = self : : IDENTICAL ) { return $ this - > expected = = = $ actual ; } return $ this - > cast ( $ this - > expected ) = = $ this - > cast ( $ actual ) ; } 
public static function reconstitute From Events ( Aggregate Root Id $ aggregate Root Id , Generator $ events ) : Aggregate Root { $ aggregate Root = new static ( $ aggregate Root Id ) ; foreach ( $ events as $ event ) { $ aggregate Root - > apply ( $ event ) ; } return $ aggregate Root ; } 
private function dump Commands ( array $ commands ) : string { $ code = [ ] ; foreach ( $ commands as $ command ) { $ code [ ] = < < <EOF final class { $command - >name ( ) } { { $this - >dump Fields ( $command ) } { $this - >dump Constructor ( $command ) } { $this - >dump Methods ( $command ) } } EOF ; } return rtrim ( implode ( ' ' , $ code ) ) ; } 
private function fields From Definition ( Definition With Fields $ definition ) : array { $ fields = $ this - > fields From ( $ definition - > fields From ( ) ) ; foreach ( $ definition - > fields ( ) as $ field ) { array _push ( $ fields , $ field ) ; } return $ fields ; } 
public function call ( $ string , $ method , $ args ) { if ( $ this - > method Uses String As First Argument ( $ method ) ) { array _unshift ( $ args , ( string ) $ string ) ; } $ underscore Result = call _user _func _array ( [ 'Underscore \Types \Strings ' , $ method ] , $ args ) ; if ( $ this - > method Returns AString ( $ method ) ) { return new Str ( $ underscore Result ) ; } return $ underscore Result ; } 
public function between ( $ start , $ end ) { if ( $ start = = ' ' & & $ end = = ' ' ) { return $ this ; } if ( $ start ! = ' ' & & strpos ( $ this - > string , $ start ) = = = false ) { return new static ( ) ; } if ( $ end ! = ' ' & & strpos ( $ this - > string , $ end ) = = = false ) { return new static ( ) ; } if ( $ start = = ' ' ) { return new static ( substr ( $ this - > string , 0 , strpos ( $ this - > string , $ end ) ) ) ; } if ( $ end = = ' ' ) { return new static ( substr ( $ this - > string , strpos ( $ this - > string , $ start ) + strlen ( $ start ) ) ) ; } $ string Without Start = explode ( $ start , $ this - > string ) [ 1 ] ; $ middle = explode ( $ end , $ string Without Start ) [ 0 ] ; return new static ( $ middle ) ; } 
public function tease ( $ length = 2 0 0 , $ more Text Indicator = ' . . . ' ) { $ sanitized String = $ this - > sanitize For Tease ( $ this - > string ) ; if ( strlen ( $ sanitized String ) = = 0 ) { return new static ( ) ; } if ( strlen ( $ sanitized String ) < = $ length ) { return new static ( $ sanitized String ) ; } $ ww = wordwrap ( $ sanitized String , $ length , " \n " ) ; $ shortened String = substr ( $ ww , 0 , strpos ( $ ww , " \n " ) ) . $ more Text Indicator ; return new static ( $ shortened String ) ; } 
private function sanitize For Tease ( $ string ) { $ string = trim ( $ string ) ; 
public function replace First ( $ search , $ replace ) { if ( $ search = = ' ' ) { return $ this ; } $ position = strpos ( $ this - > string , $ search ) ; if ( $ position = = = false ) { return $ this ; } $ result String = substr _replace ( $ this - > string , $ replace , $ position , strlen ( $ search ) ) ; return new static ( $ result String ) ; } 
public function replace Last ( $ search , $ replace ) { if ( $ search = = ' ' ) { return $ this ; } $ position = strrpos ( $ this - > string , $ search ) ; if ( $ position = = = false ) { return $ this ; } $ result String = substr _replace ( $ this - > string , $ replace , $ position , strlen ( $ search ) ) ; return new static ( $ result String ) ; } 
public function possessive ( ) { if ( $ this - > string = = ' ' ) { return new static ( ) ; } $ no Apostrophe Edge Cases = [ 'it ' ] ; if ( in _array ( $ this - > string , $ no Apostrophe Edge Cases ) ) { return new static ( $ this - > string . 's ' ) ; } return new static ( $ this - > string . ' \ ' ' . ( $ this - > string [ strlen ( $ this - > string ) - 1 ] ! = 's ' ? 's ' : ' ' ) ) ; } 
public function segment ( $ delimiter , $ index ) { $ segments = explode ( $ delimiter , $ this - > string ) ; if ( $ index < 0 ) { $ segments = array _reverse ( $ segments ) ; $ index = abs ( $ index ) - 1 ; } $ segment = isset ( $ segments [ $ index ] ) ? $ segments [ $ index ] : ' ' ; return new static ( $ segment ) ; } 
public function contains ( $ needle , $ case Sensitive = false , $ absolute = false ) { return $ this - > find ( $ needle , $ case Sensitive , $ absolute ) ; } 
public function response ( $ request ) { $ response = $ request - > all ( ) ; $ rcvd _checksum = $ request - > checksum ; $ rcvd _data = $ this - > get All Response Params ( $ response ) ; $ checksum _check = $ this - > verify Checksum ( $ rcvd _checksum , $ rcvd _data , $ this - > secret ) ; if ( ! $ checksum _check ) { return "Recieved Checksum Mismatch . " ; } $ this - > response = $ response ; return $ this - > response ; } 
public function response ( $ request ) { $ payment _request _id = Request : : input ( 'payment _request _id ' ) ; $ payment _id = Request : : input ( 'payment _id ' ) ; $ client = new \ Guzzle Http \ Client ( ) ; $ response = $ client - > get ( $ this - > get End Point ( 'payment -requests / ' . $ payment _request _id . ' / ' . $ payment _id . ' / ' ) , [ 'headers ' = > array ( 'X -Api -Key ' = > $ this - > api _key , 'X -Auth -Token ' = > $ this - > auth _token , ) , ] ) - > get Body ( ) - > get Contents ( ) ; $ response = json _decode ( $ response ) ; if ( $ response - > success ) { return $ response ; } return false ; } 
protected function encrypt ( ) { $ this - > hash = ' ' ; $ hash Sequence = "key |txnid |amount |productinfo |firstname |email |udf 1 |udf 2 |udf 3 |udf 4 |udf 5 |udf 6 |udf 7 |udf 8 |udf 9 |udf 1 0 " ; $ hash Vars Seq = explode ( ' | ' , $ hash Sequence ) ; $ hash _string = ' ' ; foreach ( $ hash Vars Seq as $ hash _var ) { $ hash _string . = isset ( $ this - > parameters [ $ hash _var ] ) ? $ this - > parameters [ $ hash _var ] : ' ' ; $ hash _string . = ' | ' ; } $ hash _string . = $ this - > salt ; $ this - > hash = strtolower ( hash ( 'sha 5 1 2 ' , $ hash _string ) ) ; } 
protected function decrypt ( $ response ) { $ hash Sequence = "status | | | | | |udf 5 |udf 4 |udf 3 |udf 2 |udf 1 |email |firstname |productinfo |amount |txnid |key " ; $ hash Vars Seq = explode ( ' | ' , $ hash Sequence ) ; $ hash _string = $ this - > salt . " | " ; foreach ( $ hash Vars Seq as $ hash _var ) { $ hash _string . = isset ( $ response [ $ hash _var ] ) ? $ response [ $ hash _var ] : ' ' ; $ hash _string . = ' | ' ; } $ hash _string = trim ( $ hash _string , ' | ' ) ; return strtolower ( hash ( 'sha 5 1 2 ' , $ hash _string ) ) ; } 
public function register ( ) { $ gateway = Config : : get ( 'indipay .gateway ' ) ; $ this - > app - > bind ( 'indipay ' , 'Softon \Indipay \Indipay ' ) ; $ this - > app - > bind ( 'Softon \Indipay \Gateways \Payment Gateway Interface ' , 'Softon \Indipay \Gateways \ \ ' . $ gateway . 'Gateway ' ) ; } 
public function response ( $ request ) { $ enc Response = $ request - > enc Resp ; $ rcvd String = $ this - > decrypt ( $ enc Response , $ this - > working Key ) ; parse _str ( $ rcvd String , $ dec Response ) ; return $ dec Response ; } 
protected function encrypt ( $ plain Text , $ key ) { $ secret Key = $ this - > hextobin ( md 5 ( $ key ) ) ; $ init Vector = pack ( "C * " , 0x 0 0 , 0x 0 1 , 0x 0 2 , 0x 0 3 , 0x 0 4 , 0x 0 5 , 0x 0 6 , 0x 0 7 , 0x 0 8 , 0x 0 9 , 0x 0a , 0x 0b , 0x 0c , 0x 0d , 0x 0e , 0x 0f ) ; $ open Mode = @ mcrypt _module _open ( MCRYPT _RIJNDAEL _ 1 2 8 , ' ' , 'cbc ' , ' ' ) ; $ block Size = @ mcrypt _get _block _size ( MCRYPT _RIJNDAEL _ 1 2 8 , 'cbc ' ) ; $ plain Pad = $ this - > pkcs 5 _pad ( $ plain Text , $ block Size ) ; if ( @ mcrypt _generic _init ( $ open Mode , $ secret Key , $ init Vector ) ! = - 1 ) { $ encrypted Text = @ mcrypt _generic ( $ open Mode , $ plain Pad ) ; @ mcrypt _generic _deinit ( $ open Mode ) ; } return bin 2hex ( $ encrypted Text ) ; } 
protected function decrypt ( $ encrypted Text , $ key ) { $ secret Key = $ this - > hextobin ( md 5 ( $ key ) ) ; $ init Vector = pack ( "C * " , 0x 0 0 , 0x 0 1 , 0x 0 2 , 0x 0 3 , 0x 0 4 , 0x 0 5 , 0x 0 6 , 0x 0 7 , 0x 0 8 , 0x 0 9 , 0x 0a , 0x 0b , 0x 0c , 0x 0d , 0x 0e , 0x 0f ) ; $ encrypted Text = $ this - > hextobin ( $ encrypted Text ) ; $ open Mode = @ mcrypt _module _open ( MCRYPT _RIJNDAEL _ 1 2 8 , ' ' , 'cbc ' , ' ' ) ; @ mcrypt _generic _init ( $ open Mode , $ secret Key , $ init Vector ) ; $ decrypted Text = @ mdecrypt _generic ( $ open Mode , $ encrypted Text ) ; $ decrypted Text = rtrim ( $ decrypted Text , " \ 0 " ) ; @ mcrypt _generic _deinit ( $ open Mode ) ; return $ decrypted Text ; } 
public function response ( $ request ) { $ response = $ request - > all ( ) ; $ response _hash = $ this - > decrypt ( $ response ) ; if ( $ response _hash ! = $ response [ 'signature ' ] ) { return 'Hash Mismatch Error ' ; } return $ response ; } 
protected function encrypt ( ) { $ hash _string = $ this - > vanity Url . $ this - > parameters [ 'order Amount ' ] . $ this - > parameters [ 'merchant Txn Id ' ] . $ this - > parameters [ 'currency ' ] ; $ this - > hash = hash _hmac ( 'sha 1 ' , $ hash _string , $ this - > secret Key ) ; } 
protected function decrypt ( $ response ) { $ hash _string = ' ' ; $ hash _string . = $ response [ 'Tx Id ' ] ; $ hash _string . = $ response [ 'Tx Status ' ] ; $ hash _string . = $ response [ 'amount ' ] ; $ hash _string . = $ response [ 'pg Txn No ' ] ; $ hash _string . = $ response [ 'issuer Ref No ' ] ; $ hash _string . = $ response [ 'auth Id Code ' ] ; $ hash _string . = $ response [ 'first Name ' ] ; $ hash _string . = $ response [ 'last Name ' ] ; $ hash _string . = $ response [ 'pg Resp Code ' ] ; $ hash _string . = $ response [ 'address Zip ' ] ; return hash _hmac ( 'sha 1 ' , $ hash _string , $ this - > secret Key ) ; } 
protected function encrypt ( ) { $ this - > hash = ' ' ; $ hash _string = $ this - > secret Key . " | " . urlencode ( $ this - > parameters [ 'account _id ' ] ) . " | " . urlencode ( $ this - > parameters [ 'amount ' ] ) . " | " . urlencode ( $ this - > parameters [ 'reference _no ' ] ) . " | " . $ this - > parameters [ 'return _url ' ] . " | " . urlencode ( $ this - > parameters [ 'mode ' ] ) ; $ this - > hash = md 5 ( $ hash _string ) ; } 
private function parse Scenario ( $ scenario String ) { $ parsed Scenario = array ( ) ; $ scenarios = explode ( $ this - > method Delimiter , $ scenario String ) ; foreach ( $ scenarios as $ scenario ) { $ arguments = null ; $ scenario Element = explode ( $ this - > argument Delimiter , $ scenario ) ; if ( isset ( $ scenario Element [ 1 ] ) ) { $ arguments = $ scenario Element [ 1 ] ; } $ parsed Scenario [ ] = new Expression ( $ this - > method Parser - > parse ( $ scenario Element [ 0 ] ) , $ arguments ) ; } return $ parsed Scenario ; } 
private function run Scenario ( $ parsed Scenario ) { foreach ( $ parsed Scenario as $ expression ) { call _user _func _array ( array ( $ this , $ expression - > get Name ( ) ) , array ( $ expression - > get Arguments ( ) ) ) ; } return $ this ; } 
public function replace ( $ source , $ value ) { 
public function range ( ) { $ args = func _get _args ( ) ; $ arg _num = count ( $ args ) ; if ( $ arg _num % 2 ! = 0 ) { throw new \ Invalid Argument Exception ( 'Number of args must be even ' , 1 ) ; } $ value = ' [ ' ; for ( $ i = 0 ; $ i < $ arg _num ; ) { $ value . = self : : sanitize ( $ args [ $ i + + ] ) . ' - ' . self : : sanitize ( $ args [ $ i + + ] ) ; } $ value . = ' ] ' ; return $ this - > add ( $ value ) ; } 
public function add Modifier ( $ modifier ) { if ( strpos ( $ this - > modifiers , $ modifier ) = = = false ) { $ this - > modifiers . = $ modifier ; } return $ this ; } 
public function clean ( array $ options = array ( ) ) { $ options = array _merge ( array ( 'prefixes ' = > ' ' , 'source ' = > ' ' , 'suffixes ' = > ' ' , 'modifiers ' = > 'gm ' , 'replace Limit ' = > ' 1 ' ) , $ options ) ; $ this - > prefixes = $ options [ 'prefixes ' ] ; $ this - > source = $ options [ 'source ' ] ; $ this - > suffixes = $ options [ 'suffixes ' ] ; $ this - > modifiers = $ options [ 'modifiers ' ] ; 
public function add Range ( int $ start , int $ end ) : void { $ this - > pages = array _merge ( $ this - > pages , range ( $ start , $ end ) ) ; } 
public function add Raw ( string $ content , Pages Interface $ pages = null ) : void { $ this - > sources [ ] = new Raw Source ( $ content , $ pages ) ; } 
public function add File ( string $ filename , Pages Interface $ pages = null ) : void { $ this - > sources [ ] = new File Source ( $ filename , $ pages ) ; } 
public function add Iterator ( iterable $ iterator , Pages Interface $ pages = null ) : void { foreach ( $ iterator as $ filename ) { $ this - > add File ( $ filename , $ pages ) ; } } 
protected static function json Unserialize From Properties ( $ properties ) { if ( ! is _array ( $ properties ) & & ! is _object ( $ properties ) ) { throw Unserialization Exception : : invalid Property ( 'Linked CRS ' , 'properties ' , $ properties , 'array or object ' ) ; } $ properties = new \ Array Object ( $ properties ) ; if ( ! $ properties - > offset Exists ( 'href ' ) ) { throw Unserialization Exception : : missing Property ( 'Linked CRS ' , 'properties .href ' , 'string ' ) ; } $ href = ( string ) $ properties [ 'href ' ] ; $ type = isset ( $ properties [ 'type ' ] ) ? ( string ) $ properties [ 'type ' ] : null ; return new self ( $ href , $ type ) ; } 
protected function set Optional Constructor Args ( array $ args ) { foreach ( $ args as $ arg ) { if ( $ arg instanceof Coordinate Reference System ) { $ this - > crs = $ arg ; } if ( $ arg instanceof Bounding Box ) { $ this - > bounding Box = $ arg ; } } } 
public static function invalid Value ( $ context , $ value , $ expected Type ) { return new self ( sprintf ( ' %s expected value of type %s , %s given ' , $ context , $ expected Type , is _object ( $ value ) ? get _class ( $ value ) : gettype ( $ value ) ) ) ; } 
public static function invalid Property ( $ context , $ property , $ value , $ expected Type ) { return new self ( sprintf ( ' %s expected " %s " property of type %s , %s given ' , $ context , $ property , $ expected Type , is _object ( $ value ) ? get _class ( $ value ) : gettype ( $ value ) ) ) ; } 
protected static function json Unserialize From Properties ( $ properties ) { if ( ! is _array ( $ properties ) & & ! is _object ( $ properties ) ) { throw Unserialization Exception : : invalid Property ( 'Named CRS ' , 'properties ' , $ properties , 'array or object ' ) ; } $ properties = new \ Array Object ( $ properties ) ; if ( ! $ properties - > offset Exists ( 'name ' ) ) { throw Unserialization Exception : : missing Property ( 'Named CRS ' , 'properties .name ' , 'string ' ) ; } $ name = ( string ) $ properties [ 'name ' ] ; return new self ( $ name ) ; } 
protected function get Base Installation Path ( ) { if ( ! $ this - > composer | | ! $ this - > composer - > get Package ( ) ) { return self : : DEFAULT _ROOT ; } $ extra = $ this - > composer - > get Package ( ) - > get Extra ( ) ; if ( ! $ extra | | empty ( $ extra [ 'module -dir ' ] ) ) { return self : : DEFAULT _ROOT ; } return $ extra [ 'module -dir ' ] ; } 
protected function get Module Name ( Package Interface $ package ) { $ name = $ package - > get Pretty Name ( ) ; $ split = explode ( " / " , $ name ) ; if ( count ( $ split ) ! = = 2 ) { throw new \ Exception ( $ this - > usage ( ) ) ; } $ split Name To Use = explode ( " - " , $ split [ 1 ] ) ; if ( count ( $ split Name To Use ) < 2 ) { throw new \ Exception ( $ this - > usage ( ) ) ; } if ( array _pop ( $ split Name To Use ) ! = = 'module ' ) { throw new \ Exception ( $ this - > usage ( ) ) ; } return implode ( ' ' , array _map ( 'ucfirst ' , $ split Name To Use ) ) ; } 
public function register Container Configuration ( Loader Interface $ loader ) { $ loader - > load ( function ( Container Builder $ container ) use ( $ loader ) { $ container - > load From Extension ( 'framework ' , [ 'router ' = > [ 'resource ' = > 'kernel :load Routes ' , 'type ' = > 'service ' , ] , ] ) ; $ this - > config Files = array _unique ( $ this - > config Files ) ; foreach ( $ this - > config Files as $ path ) { $ loader - > load ( $ path ) ; } $ container - > add Object Resource ( $ this ) ; } ) ; } 
public function load Routes ( Loader Interface $ loader ) { $ routes = new Route Collection Builder ( $ loader ) ; $ routes - > import ( _ _DIR _ _ . ' /config /routing .yml ' ) ; return $ routes - > build ( ) ; } 
protected function build Container ( ) { $ container = parent : : build Container ( ) ; foreach ( $ this - > compiler Passes as $ pass ) { $ container - > add Compiler Pass ( $ pass ) ; } return $ container ; } 
public function organise Arguments ( Reflection Function Abstract $ function , array $ arguments ) : array { $ organised Arguments = $ this - > decorated Argument Organiser - > organise Arguments ( $ function , $ arguments ) ; if ( $ function - > is Variadic ( ) ) { $ organised Arguments + = array _diff ( $ arguments , $ organised Arguments ) ; } return $ organised Arguments ; } 
public function load ( Container Builder $ container , array $ config ) : void { $ definition = new Definition ( Variadic Argument Organiser : : class , [ new Reference ( 'fob _variadic .argument .mixed _organiser .inner ' ) , ] ) ; $ definition - > set Decorated Service ( Argument Extension : : MIXED _ARGUMENT _ORGANISER _ID ) ; $ container - > set Definition ( 'fob _variadic .argument .mixed _organiser ' , $ definition ) ; } 
public function config Path ( $ path = ' ' ) { return $ this - > base Path . DIRECTORY _SEPARATOR . 'vendor ' . DIRECTORY _SEPARATOR . 'matthewbdaly ' . DIRECTORY _SEPARATOR . 'artisan -standalone ' . DIRECTORY _SEPARATOR . 'config ' . ( $ path ? DIRECTORY _SEPARATOR . $ path : $ path ) ; } 
public function get Namespace ( ) { if ( ! is _null ( $ this - > namespace ) ) { return $ this - > namespace ; } $ path = $ this - > base Path ; $ composer = json _decode ( file _get _contents ( $ path . DIRECTORY _SEPARATOR . 'composer .json ' ) , true ) ; foreach ( ( array ) data _get ( $ composer , 'autoload .psr - 4 ' ) as $ namespace = > $ path ) { return $ this - > namespace = $ namespace ; } throw new Runtime Exception ( 'Unable to detect application namespace . ' ) ; } 
public function get Adapter ( array $ config ) { $ client = new \ Redis ( ) ; $ dsn = $ this - > get Dsn ( ) ; if ( empty ( $ dsn ) ) { if ( false = = = $ client - > connect ( $ config [ 'host ' ] , $ config [ 'port ' ] ) ) { throw new Connect Exception ( sprintf ( 'Could not connect to Redis database on " %s : %s " . ' , $ config [ 'host ' ] , $ config [ 'port ' ] ) ) ; } } else { if ( false = = = $ client - > connect ( $ dsn - > get First Host ( ) , $ dsn - > get First Port ( ) ) ) { throw new Connect Exception ( sprintf ( 'Could not connect to Redis database on " %s : %s " . ' , $ dsn - > get First Host ( ) , $ dsn - > get First Port ( ) ) ) ; } if ( ! empty ( $ dsn - > get Password ( ) ) ) { if ( false = = = $ client - > auth ( $ dsn - > get Password ( ) ) ) { throw new Connect Exception ( 'Could not connect authenticate connection to Redis database . ' ) ; } } $ config [ 'database ' ] = $ dsn - > get Database ( ) ; } if ( null ! = = $ config [ 'database ' ] & & false = = = $ client - > select ( $ config [ 'database ' ] ) ) { throw new Connect Exception ( sprintf ( 'Could not select Redis database with index " %s " . ' , $ config [ 'database ' ] ) ) ; } $ pool = new Redis Cache Pool ( $ client ) ; if ( null ! = = $ config [ 'pool _namespace ' ] ) { $ pool = new Namespaced Cache Pool ( $ pool , $ config [ 'pool _namespace ' ] ) ; } return $ pool ; } 
public function get Adapter ( array $ config ) { $ redis = new \ Redis ( ) ; $ redis - > connect ( $ config [ 'host ' ] , $ config [ 'port ' ] ) ; $ client = new Redis Cache ( ) ; $ client - > set Redis ( $ redis ) ; return new Doctrine Cache Pool ( $ client ) ; } 
protected function parse Parameters ( $ params ) { $ parameters = explode ( ' & ' , $ params ) ; foreach ( $ parameters as $ parameter ) { $ kv = explode ( ' = ' , $ parameter , 2 ) ; $ this - > parameters [ $ kv [ 0 ] ] = isset ( $ kv [ 1 ] ) ? $ kv [ 1 ] : null ; } return ' ' ; } 
public function get Adapter ( array $ config ) { $ memcache = new Memcache ( ) ; $ memcache - > connect ( $ config [ 'host ' ] , $ config [ 'port ' ] ) ; $ client = new Memcache Cache ( ) ; $ client - > set Memcache ( $ memcache ) ; return new Doctrine Cache Pool ( $ client ) ; } 
public function get Adapter ( array $ config ) { $ couchbase = new Couchbase ( $ config [ 'host ' ] , $ config [ 'user ' ] , $ config [ 'password ' ] , $ config [ 'bucket ' ] ) ; $ client = new Couchbase Cache ( ) ; $ client - > set Couchbase ( $ couchbase ) ; return new Doctrine Cache Pool ( $ client ) ; } 
public function load ( array $ configs , Container Builder $ container ) { $ configuration = new Configuration ( ) ; $ config = $ this - > process Configuration ( $ configuration , $ configs ) ; $ loader = new Loader \ Yaml File Loader ( $ container , new File Locator ( _ _DIR _ _ . ' / . . /Resources /config ' ) ) ; $ loader - > load ( 'services .yml ' ) ; 
private function find References ( array $ options ) { foreach ( $ options as $ key = > $ value ) { if ( is _array ( $ value ) ) { $ options [ $ key ] = $ this - > find References ( $ value ) ; } elseif ( ' _service ' = = = substr ( $ key , - 8 ) | | 0 = = = strpos ( $ value , ' @ ' ) | | 'service ' = = = $ key ) { $ options [ $ key ] = new Reference ( ltrim ( $ value , ' @ ' ) ) ; } } return $ options ; } 
public function get Adapter ( array $ config ) { $ client = new Client ( [ 'scheme ' = > $ config [ 'scheme ' ] , 'host ' = > $ config [ 'host ' ] , 'port ' = > $ config [ 'port ' ] , ] ) ; return new Doctrine Cache Pool ( new Predis Cache ( $ client ) ) ; } 
public static function validate ( array $ options , $ adapter Name ) { parent : : validate ( $ options , $ adapter Name ) ; if ( empty ( $ options [ 'dsn ' ] ) ) { return ; } $ dsn = new DSN ( $ options [ 'dsn ' ] ) ; if ( ! $ dsn - > is Valid ( ) ) { throw new \ Invalid Argument Exception ( 'Invalid DSN : ' . $ options [ 'dsn ' ] ) ; } } 
public function create Adapter ( array $ options = [ ] ) { if ( ! empty ( $ options [ 'dsn ' ] ) ) { $ dsn = new DSN ( $ options [ 'dsn ' ] ) ; if ( ! $ dsn - > is Valid ( ) ) { throw new \ Invalid Argument Exception ( 'Invalid DSN : ' . $ options [ 'dsn ' ] ) ; } $ this - > DSN = $ dsn ; } return parent : : create Adapter ( $ options ) ; } 
public function get Adapter ( array $ config ) { $ client = new Memcache ( ) ; $ client - > connect ( $ config [ 'host ' ] , $ config [ 'port ' ] ) ; foreach ( $ config [ 'redundant _servers ' ] as $ server ) { if ( ! isset ( $ server [ 'host ' ] ) ) { continue ; } $ port = $ config [ 'port ' ] ; if ( isset ( $ server [ 'port ' ] ) ) { $ port = $ server [ 'port ' ] ; } $ client - > addserver ( $ server [ 'host ' ] , $ port ) ; } return new Memcache Cache Pool ( $ client ) ; } 
public function get Adapter ( array $ config ) { $ dsn = $ this - > get Dsn ( ) ; if ( empty ( $ dsn ) ) { $ manager = new Manager ( sprintf ( 'mongodb : / / %s : %s ' , $ config [ 'host ' ] , $ config [ 'port ' ] ) ) ; } else { $ manager = new Manager ( $ dsn - > get Dsn ( ) ) ; } $ collection = Mongo DBCache Pool : : create Collection ( $ manager , $ config [ 'namespace ' ] ) ; return new Mongo DBCache Pool ( $ collection ) ; } 
public function get Config Tree Builder ( ) { $ tree Builder = new Tree Builder ( 'cache _adapter ' ) ; if ( method _exists ( $ tree Builder , 'get Root Node ' ) ) { $ root Node = $ tree Builder - > get Root Node ( ) ; } else { $ root Node = $ tree Builder - > root ( 'cache _adapter ' ) ; } $ root Node - > children ( ) - > append ( $ this - > get Clusters Node ( ) ) - > end ( ) ; return $ tree Builder ; } 
public function create Adapter ( array $ options = [ ] ) { $ this - > verify Dependencies ( ) ; $ resolver = new Options Resolver ( ) ; static : : configure Option Resolver ( $ resolver ) ; $ config = $ resolver - > resolve ( $ options ) ; return $ this - > get Adapter ( $ config ) ; } 
public static function validate ( array $ options , $ adapter Name ) { static : : verify Dependencies ( ) ; $ resolver = new Options Resolver ( ) ; static : : configure Option Resolver ( $ resolver ) ; try { $ resolver - > resolve ( $ options ) ; } catch ( \ Exception $ e ) { $ message = sprintf ( 'Error while configure adapter %s . Verify your configuration at "cache _adapter .providers . %s .options " . %s ' , $ adapter Name , $ adapter Name , $ e - > get Message ( ) ) ; throw new Configuration Exception ( $ message , $ e - > get Code ( ) , $ e ) ; } } 
protected static function configure Option Resolver ( Options Resolver $ resolver ) { parent : : configure Option Resolver ( $ resolver ) ; $ resolver - > set Required ( [ 'namespace ' , 'service ' ] ) ; $ resolver - > set Allowed Types ( 'namespace ' , [ 'string ' ] ) ; } 
protected static function configure Option Resolver ( Options Resolver $ resolver ) { parent : : configure Option Resolver ( $ resolver ) ; $ resolver - > set Required ( 'services ' ) ; $ resolver - > set Allowed Types ( 'services ' , [ 'array ' ] ) ; $ resolver - > set Default ( 'skip _on _failure ' , false ) ; } 
public function get Adapter ( array $ config ) { $ client = new Filesystem Cache ( $ config [ 'directory ' ] , $ config [ 'extension ' ] , ( int ) $ config [ 'umask ' ] ) ; return new Doctrine Cache Pool ( $ client ) ; } 
protected static function configure Option Resolver ( Options Resolver $ resolver ) { $ resolver - > set Defaults ( [ 'extension ' = > Filesystem Cache : : EXTENSION , 'umask ' = > ' 0 0 0 2 ' , ] ) ; $ resolver - > set Required ( [ 'directory ' ] ) ; $ resolver - > set Allowed Types ( 'directory ' , [ 'string ' ] ) ; $ resolver - > set Allowed Types ( 'extension ' , [ 'string ' ] ) ; $ resolver - > set Allowed Types ( 'umask ' , [ 'string ' , 'int ' ] ) ; } 
public function get Adapter ( array $ config ) { $ connection = new Connection ( $ config [ 'host ' ] , $ config [ 'port ' ] ) ; $ bucket = new Bucket ( $ connection , $ config [ 'type ' ] ) ; return new Doctrine Cache Pool ( new Riak Cache ( $ bucket ) ) ; } 
public function get Adapter ( array $ config ) { $ client = new Memcached ( $ config [ 'persistent _id ' ] ) ; $ client - > add Server ( $ config [ 'host ' ] , $ config [ 'port ' ] ) ; foreach ( $ config [ 'redundant _servers ' ] as $ server ) { if ( ! isset ( $ server [ 'host ' ] ) ) { continue ; } $ port = $ config [ 'port ' ] ; if ( isset ( $ server [ 'port ' ] ) ) { $ port = $ server [ 'port ' ] ; } $ client - > add Server ( $ server [ 'host ' ] , $ port ) ; } foreach ( $ config [ 'driver _options ' ] as $ constant = > $ value ) { $ client - > set Option ( constant ( $ constant ) , $ value ) ; } $ pool = new Memcached Cache Pool ( $ client ) ; if ( null ! = = $ config [ 'pool _namespace ' ] ) { $ pool = new Namespaced Cache Pool ( $ pool , $ config [ 'pool _namespace ' ] ) ; } return $ pool ; } 
public function get Adapter ( array $ config ) { $ dsn = $ this - > get Dsn ( ) ; if ( empty ( $ dsn ) ) { $ client = new Client ( [ 'scheme ' = > $ config [ 'scheme ' ] , 'host ' = > $ config [ 'host ' ] , 'port ' = > $ config [ 'port ' ] , 'persistent ' = > $ config [ 'persistent ' ] , ] ) ; } else { $ client = new Client ( $ dsn - > get Dsn ( ) ) ; } $ pool = new Predis Cache Pool ( $ client ) ; if ( null ! = = $ config [ 'pool _namespace ' ] ) { $ pool = new Namespaced Cache Pool ( $ pool , $ config [ 'pool _namespace ' ] ) ; } return $ pool ; } 
public function add Server ( $ host , $ port , $ weight = 0 ) { $ server List = $ this - > get Server List ( ) ; foreach ( $ server List as $ server ) { if ( $ server [ 'host ' ] = = = $ host & & $ server [ 'port ' ] = = = $ port ) { return false ; } } return parent : : add Server ( $ host , $ port , $ weight ) ; } 
public function get Adapter ( array $ config ) { $ memcached = new Memcached ( ) ; $ memcached - > add Server ( $ config [ 'host ' ] , $ config [ 'port ' ] ) ; $ client = new Memcached Cache ( ) ; $ client - > set Memcached ( $ memcached ) ; return new Doctrine Cache Pool ( $ client ) ; } 
public function process ( Container Builder $ container ) { $ service Ids = array _keys ( $ container - > find Tagged Service Ids ( 'cache .provider ' ) ) ; foreach ( $ service Ids as $ service Id ) { $ instance = $ container - > get ( $ service Id ) ; $ class = get _class ( $ instance ) ; $ container - > set Alias ( $ class , $ service Id ) ; } } 
public function get Adapter ( array $ config ) { $ mongo = new Mongo Client ( ) ; $ collection = $ mongo - > select Collection ( $ config [ 'host ' ] , $ config [ 'collection ' ] ) ; return new Doctrine Cache Pool ( new Mongo DBCache ( $ collection ) ) ; } 
public function get Adapter ( array $ config ) { $ pool = new Array Cache Pool ( ) ; if ( null ! = = $ config [ 'pool _namespace ' ] ) { $ pool = new Namespaced Cache Pool ( $ pool , $ config [ 'pool _namespace ' ] ) ; } return $ pool ; } 
public function sync File ( $ relative Url , $ force Download = false , $ allow Missing = false ) { $ fs = new Filesystem ( ) ; 
public static function from Xdr ( Xdr Buffer $ xdr ) { $ model = new Change Trust Result ( ) ; $ raw Error Code = $ xdr - > read Integer ( ) ; $ error Code Map = [ ' 0 ' = > 'success ' , ' - 1 ' = > static : : MALFORMED , ' - 2 ' = > static : : NO _ISSUER , ' - 3 ' = > static : : INVALID _LIMIT , ' - 4 ' = > static : : LOW _RESERVE , ' - 5 ' = > static : : SELF _NOT _ALLOWED , ] ; if ( ! isset ( $ error Code Map [ $ raw Error Code ] ) ) { throw new \ Error Exception ( sprintf ( 'Unknown error code %s ' , $ raw Error Code ) ) ; } 
public static function new Master Node ( $ entropy ) { $ hmac = hash _hmac ( 'sha 5 1 2 ' , $ entropy , 'ed 2 5 5 1 9 seed ' , true ) ; return new Hd Node ( substr ( $ hmac , 0 , 3 2 ) , substr ( $ hmac , 3 2 , 3 2 ) ) ; } 
public function derive Path ( $ path ) { $ path Parts = $ this - > parse Derivation Path ( $ path ) ; $ derived = $ this ; foreach ( $ path Parts as $ index ) { $ derived = $ derived - > derive ( $ index ) ; } return $ derived ; } 
protected function parse Derivation Path ( $ path ) { $ parsed = [ ] ; $ parts = explode ( ' / ' , $ path ) ; if ( strtolower ( $ parts [ 0 ] ) ! = 'm ' ) throw new \ Invalid Argument Exception ( 'Path must start with "m " ' ) ; 
public static function from Xdr ( Xdr Buffer $ xdr ) { $ model = new Inflation Result ( ) ; $ raw Error Code = $ xdr - > read Integer ( ) ; $ error Code Map = [ ' 0 ' = > 'success ' , ' - 1 ' = > static : : NOT _TIME , ] ; if ( ! isset ( $ error Code Map [ $ raw Error Code ] ) ) { throw new \ Error Exception ( sprintf ( 'Unknown error code %s ' , $ raw Error Code ) ) ; } 
public static function from Xdr ( Xdr Buffer $ xdr ) { $ op Result Code = $ xdr - > read Integer ( ) ; 
public static function is Valid Account ( $ account Id ) { 
public function get Native Balance ( ) { Math Safety : : require 6 4Bit ( ) ; foreach ( $ this - > get Balances ( ) as $ balance ) { if ( $ balance - > is Native Asset ( ) ) return $ balance - > get Balance ( ) ; } return 0 ; } 
public function get Native Balance Stroops ( ) { Math Safety : : require 6 4Bit ( ) ; foreach ( $ this - > get Balances ( ) as $ balance ) { if ( $ balance - > is Native Asset ( ) ) return $ balance - > get Unscaled Balance ( ) ; } return " 0 " ; } 
public function get Custom Asset Balance Value ( Asset $ asset ) { foreach ( $ this - > get Balances ( ) as $ balance ) { if ( $ balance - > get Asset Code ( ) ! = = $ asset - > get Asset Code ( ) ) continue ; if ( $ balance - > get Asset Issuer Account Id ( ) ! = $ asset - > get Issuer ( ) - > get Account Id String ( ) ) continue ; return $ balance - > get Balance ( ) ; } return null ; } 
public function get Custom Asset Balance ( Asset $ asset ) { foreach ( $ this - > get Balances ( ) as $ balance ) { if ( $ balance - > get Asset Code ( ) ! = = $ asset - > get Asset Code ( ) ) continue ; if ( $ balance - > get Asset Issuer Account Id ( ) ! = $ asset - > get Issuer ( ) - > get Account Id String ( ) ) continue ; return $ balance ; } return null ; } 
public function get Custom Asset Balance Stroops ( Asset $ asset ) { Math Safety : : require 6 4Bit ( ) ; foreach ( $ this - > get Balances ( ) as $ balance ) { if ( $ balance - > get Asset Code ( ) ! = = $ asset - > get Asset Code ( ) ) continue ; if ( $ balance - > get Asset Issuer Account Id ( ) ! = $ asset - > get Issuer ( ) - > get Account Id String ( ) ) continue ; return $ balance - > get Unscaled Balance ( ) ; } return null ; } 
public static function get Entropy Checksum Hex ( $ entropy Bytes ) { $ checksum Length Bits = ( strlen ( $ entropy Bytes ) * 8 ) / 3 2 ; $ hash Bytes = hash ( 'sha 2 5 6 ' , $ entropy Bytes , true ) ; 
public static function bitstring To Hex ( $ bitstring ) { $ chunk Size Bits = 8 ; 
public function mnemonic To Entropy ( $ mnenomic ) { $ bitstring = $ this - > parse Mnemonic ( $ mnenomic ) ; 
public function mnemonic To Seed Bytes With Error Checking ( $ mnemonic , $ passphrase = ' ' ) { 
protected function parse Mnemonic ( $ mnemonic ) { $ words = explode ( ' ' , $ mnemonic ) ; if ( count ( $ words ) % 3 ! = = 0 ) throw new \ Invalid Argument Exception ( 'Invalid mnemonic (number of words must be a multiple of 3 ) ' ) ; $ word Bitstrings = [ ] ; foreach ( $ words as $ word ) { $ word Idx = $ this - > get Word Index ( $ word ) ; 
public function sign With ( Signing Interface $ signer ) { $ decorated Signature = $ signer - > sign Transaction ( $ this ) ; $ this - > signatures [ ] = $ decorated Signature ; return $ decorated Signature ; } 
public function authorize Trustline ( Asset $ asset , $ trustor Id , $ source Account Id = null ) { if ( $ trustor Id instanceof Keypair ) { $ trustor Id = $ trustor Id - > get Public Key ( ) ; } $ op = new Allow Trust Op ( $ asset , new Account Id ( $ trustor Id ) , $ source Account Id ) ; $ op - > set Is Authorized ( true ) ; return $ this - > add Operation ( $ op ) ; } 
public function revoke Trustline ( Asset $ asset , $ trustor Id , $ source Account Id = null ) { if ( $ trustor Id instanceof Keypair ) { $ trustor Id = $ trustor Id - > get Public Key ( ) ; } $ op = new Allow Trust Op ( $ asset , new Account Id ( $ trustor Id ) , $ source Account Id ) ; $ op - > set Is Authorized ( false ) ; return $ this - > add Operation ( $ op ) ; } 
public function add Merge Operation ( $ destination Account Id , $ source Account Id = null ) { if ( $ destination Account Id instanceof Keypair ) { $ destination Account Id = $ destination Account Id - > get Public Key ( ) ; } return $ this - > add Operation ( new Account Merge Op ( $ destination Account Id , $ source Account Id ) ) ; } 
public static function from Xdr ( Xdr Buffer $ xdr ) { $ model = new Create Account Result ( ) ; $ raw Error Code = $ xdr - > read Integer ( ) ; $ error Code Map = [ ' 0 ' = > 'success ' , ' - 1 ' = > static : : MALFORMED , ' - 2 ' = > static : : UNDERFUNDED , ' - 3 ' = > static : : LOW _RESERVE , ' - 4 ' = > static : : ALREADY _EXIST , ] ; if ( ! isset ( $ error Code Map [ $ raw Error Code ] ) ) { throw new \ Error Exception ( sprintf ( 'Unknown error code %s ' , $ raw Error Code ) ) ; } 
public static function from Xdr ( Xdr Buffer $ xdr ) { $ model = new Allow Trust Result ( ) ; $ raw Error Code = $ xdr - > read Integer ( ) ; $ error Code Map = [ ' 0 ' = > 'success ' , ' - 1 ' = > static : : MALFORMED , ' - 2 ' = > static : : NO _TRUST _LINE , ' - 3 ' = > static : : TRUST _NOT _REQUIRED , ' - 4 ' = > static : : CANT _REVOKE , ' - 5 ' = > static : : SELF _NOT _ALLOWED , ] ; if ( ! isset ( $ error Code Map [ $ raw Error Code ] ) ) { throw new \ Error Exception ( sprintf ( 'Unknown error code %s ' , $ raw Error Code ) ) ; } 
public function to Xdr ( ) { $ bytes = ' ' ; 
public static function opaque Variable ( $ value ) { $ max Length = pow ( 2 , 3 2 ) - 1 ; if ( strlen ( $ value ) > $ max Length ) throw new \ Invalid Argument Exception ( sprintf ( 'Value of length %s is greater than the maximum allowed length of %s ' , strlen ( $ value ) , $ max Length ) ) ; $ bytes = ' ' ; $ bytes . = self : : unsigned Integer ( strlen ( $ value ) ) ; $ bytes . = self : : apply Padding ( $ value ) ; return $ bytes ; } 
public static function signed Big Integer 6 4 ( Big Integer $ value ) { $ xdr Bytes = ' ' ; $ big Int Bytes = $ value - > to Bytes ( true ) ; $ big Int Bits = $ value - > to Bits ( true ) ; 
public static function unsigned Big Integer 6 4 ( Big Integer $ value ) { $ xdr Bytes = ' ' ; $ big Int Bytes = $ value - > to Bytes ( true ) ; 
public static function optional ( Xdr Encodable Interface $ value = null ) { $ bytes = ' ' ; if ( $ value ! = = null ) { $ bytes . = self : : boolean ( true ) ; $ bytes . = $ value - > to Xdr ( ) ; } else { $ bytes . = self : : boolean ( false ) ; } return $ bytes ; } 
private static function apply Padding ( $ value , $ target Length = 4 , $ right Padding = true ) { 
public static function from Xdr ( Xdr Buffer $ xdr ) { $ model = new Manage Offer Result ( ) ; $ raw Error Code = $ xdr - > read Integer ( ) ; $ error Code Map = [ ' 0 ' = > 'success ' , ' - 1 ' = > static : : MALFORMED , ' - 2 ' = > static : : SELL _NO _TRUST , ' - 3 ' = > static : : BUY _NO _TRUST , ' - 4 ' = > static : : SELL _NOT _AUTHORIZED , ' - 5 ' = > static : : BUY _NOT _AUTHORIZED , ' - 6 ' = > static : : LINE _FULL , ' - 7 ' = > static : : UNDERFUNDED , ' - 8 ' = > static : : CROSS _SELF , ' - 9 ' = > static : : SELL _NO _ISSUER , ' - 1 0 ' = > static : : BUY _NO _ISSUER , ' - 1 1 ' = > static : : NOT _FOUND , ' - 1 2 ' = > static : : LOW _RESERVE , ] ; if ( ! isset ( $ error Code Map [ $ raw Error Code ] ) ) { throw new \ Error Exception ( sprintf ( 'Unknown error code %s ' , $ raw Error Code ) ) ; } 
public function get Unique Bucket Hashes ( ) { $ hashes = [ ] ; if ( $ this - > curr ! = self : : HASH _EMPTY ) $ hashes [ ] = $ this - > curr ; if ( $ this - > snap ! = self : : HASH _EMPTY ) $ hashes [ ] = $ this - > snap ; return array _values ( array _unique ( $ hashes ) ) ; } 
public static function from Xdr ( Xdr Buffer $ xdr ) { $ model = new Set Options Result ( ) ; $ raw Error Code = $ xdr - > read Integer ( ) ; $ error Code Map = [ ' 0 ' = > 'success ' , ' - 1 ' = > static : : LOW _RESERVE , ' - 2 ' = > static : : TOO _MANY _SIGNERS , ' - 3 ' = > static : : BAD _FLAGS , ' - 4 ' = > static : : INVALID _INFLATION , ' - 5 ' = > static : : CANT _CHANGE , ' - 6 ' = > static : : UNKNOWN _FLAG , ' - 7 ' = > static : : THRESHOLD _OUT _OF _RANGE , ' - 8 ' = > static : : BAD _SIGNER , ' - 9 ' = > static : : INVALID _HOME _DOMAIN , ] ; if ( ! isset ( $ error Code Map [ $ raw Error Code ] ) ) { throw new \ Error Exception ( sprintf ( 'Unknown error code %s ' , $ raw Error Code ) ) ; } 
public static function hex Dump ( $ data , $ newline = " \n " ) { $ output = ' ' ; static $ from = ' ' ; static $ to = ' ' ; static $ width = 1 6 ; # number of bytes per line static $ pad = ' . ' ; # padding for non -visible characters if ( $ from = = = ' ' ) { for ( $ i = 0 ; $ i < = 0x FF ; $ i + + ) { $ from . = chr ( $ i ) ; $ to . = ( $ i > = 0x 2 0 & & $ i < = 0x 7E ) ? chr ( $ i ) : $ pad ; } } $ hex = str _split ( bin 2hex ( $ data ) , $ width * 2 ) ; $ chars = str _split ( strtr ( $ data , $ from , $ to ) , $ width ) ; $ offset = 0 ; foreach ( $ hex as $ i = > $ line ) { $ output . = sprintf ( ' % 6X ' , $ offset ) . ' : ' . implode ( ' ' , str _split ( $ line , 2 ) ) . ' [ ' . $ chars [ $ i ] . ' ] ' . $ newline ; $ offset + = $ width ; } return $ output ; } 
public static function from Xdr ( Xdr Buffer $ xdr ) { $ destination = Account Id : : from Xdr ( $ xdr ) ; return new Account Merge Op ( $ destination - > get Account Id String ( ) ) ; } 
public function get Field ( $ field Name ) { if ( ! isset ( $ this - > raw Data [ $ field Name ] ) ) return null ; return $ this - > raw Data [ $ field Name ] ; } 
public function must Get Field ( $ field Name ) { if ( ! isset ( $ this - > raw Data [ $ field Name ] ) ) throw new \ Invalid Argument Exception ( sprintf ( "Field ' %s ' not present in response " , $ field Name ) ) ; return $ this - > raw Data [ $ field Name ] ; } 
public function get Account ( $ account Id ) { 
public function account Exists ( $ account Id ) { 
public function set Auth Required ( $ is Required ) { if ( $ is Required ) { $ this - > set Flags = $ this - > set Flags | static : : FLAG _AUTH _REQUIRED ; $ this - > clear Flags = $ this - > clear Flags & ~ ( static : : FLAG _AUTH _REQUIRED ) ; } else { $ this - > set Flags = $ this - > set Flags & ~ ( static : : FLAG _AUTH _REQUIRED ) ; $ this - > clear Flags = $ this - > clear Flags | static : : FLAG _AUTH _REQUIRED ; } return $ this ; } 
public function set Auth Revocable ( $ is Revocable ) { if ( $ is Revocable ) { $ this - > set Flags = $ this - > set Flags | static : : FLAG _AUTH _REVOCABLE ; $ this - > clear Flags = $ this - > clear Flags & ~ ( static : : FLAG _AUTH _REVOCABLE ) ; } else { $ this - > set Flags = $ this - > set Flags & ~ ( static : : FLAG _AUTH _REVOCABLE ) ; $ this - > clear Flags = $ this - > clear Flags | static : : FLAG _AUTH _REVOCABLE ; } return $ this ; } 
public static function from Hash X ( $ x ) { $ signer Key = new Signer Key ( static : : TYPE _HASH _X ) ; $ signer Key - > key = hash ( 'sha 2 5 6 ' , $ x , true ) ; return $ signer Key ; } 
public static function from Raw Response ( $ requested Url , $ http Method , $ raw , Client Exception $ client Exception = null ) { $ title = isset ( $ raw [ 'title ' ] ) ? $ raw [ 'title ' ] : 'Unknown Exception ' ; $ exception = new Horizon Exception ( $ title , $ client Exception ) ; $ exception - > title = $ title ; $ exception - > requested Url = $ requested Url ; $ exception - > http Method = $ http Method ; if ( isset ( $ raw [ 'type ' ] ) ) $ exception - > type = $ raw [ 'type ' ] ; if ( isset ( $ raw [ 'status ' ] ) ) $ exception - > http Status Code = $ raw [ 'status ' ] ; if ( isset ( $ raw [ 'detail ' ] ) ) $ exception - > detail = $ raw [ 'detail ' ] ; if ( ! empty ( $ raw [ 'extras ' ] [ 'result _codes ' ] [ 'operations ' ] ) ) { $ exception - > operation Result Codes = $ raw [ 'extras ' ] [ 'result _codes ' ] [ 'operations ' ] ; } if ( ! empty ( $ raw [ 'extras ' ] [ 'result _codes ' ] [ 'transaction ' ] ) ) { $ exception - > transaction Result Code = $ raw [ 'extras ' ] [ 'result _codes ' ] [ 'transaction ' ] ; } 
public static function new From Mnemonic ( $ mnemonic , $ passphrase = ' ' , $ index = 0 ) { $ bip 3 9 = new Bip 3 9 ( ) ; $ seed Bytes = $ bip 3 9 - > mnemonic To Seed Bytes With Error Checking ( $ mnemonic , $ passphrase ) ; $ master Node = Hd Node : : new Master Node ( $ seed Bytes ) ; $ account Node = $ master Node - > derive Path ( sprintf ( "m / 4 4 ' / 1 4 8 ' / %s ' " , $ index ) ) ; return static : : new From Raw Seed ( $ account Node - > get Private Key Bytes ( ) ) ; } 
public function get Public Key Checksum ( ) { $ checksum Bytes = substr ( $ this - > get Public Key Bytes ( ) , - 2 ) ; $ unpacked = unpack ( 'v ' , $ checksum Bytes ) ; return array _shift ( $ unpacked ) ; } 
protected static function crc 1 6 ( $ binary String ) { $ crc = 0x 0 0 0 0 ; $ polynomial = 0x 1 0 2 1 ; foreach ( str _split ( $ binary String ) as $ byte ) { $ byte = ord ( $ byte ) ; for ( $ i = 0 ; $ i < 8 ; $ i + + ) { $ bit = ( ( $ byte > > ( 7 - $ i ) & 1 ) = = 1 ) ; $ c 1 5 = ( ( $ crc > > 1 5 & 1 ) = = 1 ) ; $ crc < < = 1 ; if ( $ c 1 5 ^ $ bit ) $ crc ^ = $ polynomial ; } } return $ crc & 0xffff ; } 
public static function from Xdr ( Xdr Buffer $ xdr ) { $ model = new Account Merge Result ( ) ; $ raw Error Code = $ xdr - > read Integer ( ) ; $ error Code Map = [ ' 0 ' = > 'success ' , ' - 1 ' = > static : : MALFORMED , ' - 2 ' = > static : : NO _ACCOUNT , ' - 3 ' = > static : : IMMUTABLE _SET , ' - 4 ' = > static : : HAS _SUB _ENTRIES , ] ; if ( ! isset ( $ error Code Map [ $ raw Error Code ] ) ) { throw new \ Error Exception ( sprintf ( 'Unknown error code %s ' , $ raw Error Code ) ) ; } 
public static function opaque Fixed String ( $ xdr , $ length ) { $ bytes = static : : opaque Fixed ( $ xdr , $ length ) ; 
public static function address From Raw Bytes ( $ raw Bytes ) { $ version = pack ( 'C ' , self : : VERSION _BYTE _ACCOUNT _ID ) ; $ payload = $ raw Bytes ; $ checksum = Checksum : : generate ( $ version . $ payload ) ; return Base 3 2 : : encode ( $ version . $ payload . $ checksum ) ; } 
public static function from Xdr ( Xdr Buffer $ xdr ) { $ model = new Bump Sequence Result ( ) ; $ raw Error Code = $ xdr - > read Integer ( ) ; $ error Code Map = [ ' 0 ' = > 'success ' , ' - 1 ' = > static : : BAD _SEQ , ] ; if ( ! isset ( $ error Code Map [ $ raw Error Code ] ) ) { throw new \ Error Exception ( sprintf ( 'Unknown error code %s ' , $ raw Error Code ) ) ; } 
public static function from Xdr ( Xdr Buffer $ xdr ) { $ model = new Manage Data Result ( ) ; $ raw Error Code = $ xdr - > read Integer ( ) ; $ error Code Map = [ ' 0 ' = > 'success ' , ' - 1 ' = > static : : NOT _SUPPORTED _YET , ' - 2 ' = > static : : NAME _NOT _FOUND , ' - 3 ' = > static : : LOW _RESERVE , ' - 4 ' = > static : : INVALID _NAME , ] ; if ( ! isset ( $ error Code Map [ $ raw Error Code ] ) ) { throw new \ Error Exception ( sprintf ( 'Unknown error code %s ' , $ raw Error Code ) ) ; } 
public static function from Xdr ( Xdr Buffer $ xdr ) { $ model = new Payment Result ( ) ; $ raw Error Code = $ xdr - > read Integer ( ) ; $ error Code Map = [ ' 0 ' = > 'success ' , ' - 1 ' = > static : : MALFORMED , ' - 2 ' = > static : : UNDERFUNDED , ' - 3 ' = > static : : SRC _NO _TRUST , ' - 4 ' = > static : : SRC _NOT _AUTHORIZED , ' - 5 ' = > static : : NO _DESTINATION , ' - 6 ' = > static : : NO _TRUST , ' - 7 ' = > static : : NOT _AUTHORIZED , ' - 8 ' = > static : : LINE _FULL , ' - 9 ' = > static : : NO _ISSUER , ] ; if ( ! isset ( $ error Code Map [ $ raw Error Code ] ) ) { throw new \ Error Exception ( sprintf ( 'Unknown error code %s ' , $ raw Error Code ) ) ; } 
public static function from Xdr ( Xdr Buffer $ xdr ) { $ model = new Path Payment Result ( ) ; $ raw Error Code = $ xdr - > read Integer ( ) ; $ error Code Map = [ ' 0 ' = > 'success ' , ' - 1 ' = > static : : MALFORMED , ' - 2 ' = > static : : UNDERFUNDED , ' - 3 ' = > static : : SRC _NO _TRUST , ' - 4 ' = > static : : SRC _NOT _AUTHORIZED , ' - 5 ' = > static : : NO _DESTINATION , ' - 6 ' = > static : : NO _TRUST , ' - 7 ' = > static : : NOT _AUTHORIZED , ' - 8 ' = > static : : LINE _FULL , ' - 9 ' = > static : : NO _ISSUER , ' - 1 0 ' = > static : : TOO _FEW _OFFERS , ' - 1 1 ' = > static : : OFFER _CROSS _SELF , ' - 1 2 ' = > static : : OVER _SENDMAX , ] ; if ( ! isset ( $ error Code Map [ $ raw Error Code ] ) ) { throw new \ Error Exception ( sprintf ( 'Unknown error code %s ' , $ raw Error Code ) ) ; } 
protected function parse Raw Data ( $ raw Data ) { if ( ! $ raw Data ) return ; if ( ! empty ( $ raw Data [ 'result _xdr ' ] ) ) { $ xdr = new Xdr Buffer ( base 6 4 _decode ( $ raw Data [ 'result _xdr ' ] ) ) ; $ this - > result = Transaction Result : : from Xdr ( $ xdr ) ; } } 
public function sign ( $ keypairs Orsecret Key Strings , Server $ server = null ) { if ( ! is _array ( $ keypairs Orsecret Key Strings ) ) $ keypairs Orsecret Key Strings = [ $ keypairs Orsecret Key Strings ] ; $ transaction Hash = null ; if ( $ server ) { $ transaction Hash = $ server - > get Api Client ( ) - > hash ( $ this - > transaction Builder ) ; } else { $ transaction Hash = $ this - > transaction Builder - > hash ( ) ; } foreach ( $ keypairs Orsecret Key Strings as $ keypair Or Secret Key String ) { if ( is _string ( $ keypair Or Secret Key String ) ) { $ keypair Or Secret Key String = Keypair : : new From Seed ( $ keypair Or Secret Key String ) ; } $ decorated = $ keypair Or Secret Key String - > sign Decorated ( $ transaction Hash ) ; $ this - > signatures - > append ( $ decorated ) ; } return $ this ; } 
public function submit Transaction ( Transaction Builder $ transaction Builder , $ signing Account Seed String ) { $ transaction Envelope = $ transaction Builder - > sign ( $ signing Account Seed String ) ; return $ this - > submit B 6 4Transaction ( base 6 4 _encode ( $ transaction Envelope - > to Xdr ( ) ) ) ; } 
public function stream Effects ( $ since Cursor = 'now ' , callable $ callback = null ) { $ url = sprintf ( ' /effects ' ) ; $ params = [ ] ; if ( $ since Cursor ) $ params [ 'cursor ' ] = $ since Cursor ; if ( $ params ) { $ url . = ' ? ' . http _build _query ( $ params ) ; } $ this - > get And Stream ( $ url , function ( $ raw Data ) use ( $ callback ) { $ parsed Object = Effect : : from Raw Response Data ( $ raw Data ) ; $ parsed Object - > set Api Client ( $ this ) ; $ callback ( $ parsed Object ) ; } ) ; } 
public function stream Ledgers ( $ since Cursor = 'now ' , callable $ callback = null ) { $ url = sprintf ( ' /ledgers ' ) ; $ params = [ ] ; if ( $ since Cursor ) $ params [ 'cursor ' ] = $ since Cursor ; if ( $ params ) { $ url . = ' ? ' . http _build _query ( $ params ) ; } $ this - > get And Stream ( $ url , function ( $ raw Data ) use ( $ callback ) { $ parsed Object = Ledger : : from Raw Response Data ( $ raw Data ) ; $ parsed Object - > set Api Client ( $ this ) ; $ callback ( $ parsed Object ) ; } ) ; } 
public function stream Operations ( $ since Cursor = 'now ' , callable $ callback = null ) { $ url = sprintf ( ' /operations ' ) ; $ params = [ ] ; if ( $ since Cursor ) $ params [ 'cursor ' ] = $ since Cursor ; if ( $ params ) { $ url . = ' ? ' . http _build _query ( $ params ) ; } $ this - > get And Stream ( $ url , function ( $ raw Data ) use ( $ callback ) { $ parsed Object = Operation : : from Raw Response Data ( $ raw Data ) ; $ parsed Object - > set Api Client ( $ this ) ; $ callback ( $ parsed Object ) ; } ) ; } 
public function stream Payments ( $ since Cursor = 'now ' , callable $ callback = null ) { $ url = sprintf ( ' /payments ' ) ; $ params = [ ] ; if ( $ since Cursor ) $ params [ 'cursor ' ] = $ since Cursor ; if ( $ params ) { $ url . = ' ? ' . http _build _query ( $ params ) ; } $ this - > get And Stream ( $ url , function ( $ raw Data ) use ( $ callback ) { switch ( $ raw Data [ 'type ' ] ) { case 'create _account ' : $ parsed Object = Create Account Operation : : from Raw Response Data ( $ raw Data ) ; break ; case 'payment ' : $ parsed Object = Payment : : from Raw Response Data ( $ raw Data ) ; break ; case 'account _merge ' : $ parsed Object = Account Merge Operation : : from Raw Response Data ( $ raw Data ) ; break ; case 'path _payment ' : $ parsed Object = Path Payment : : from Raw Response Data ( $ raw Data ) ; break ; } $ parsed Object - > set Api Client ( $ this ) ; $ callback ( $ parsed Object ) ; } ) ; } 
public function stream Transactions ( $ since Cursor = 'now ' , callable $ callback = null ) { $ url = sprintf ( ' /transactions ' ) ; $ params = [ ] ; if ( $ since Cursor ) $ params [ 'cursor ' ] = $ since Cursor ; if ( $ params ) { $ url . = ' ? ' . http _build _query ( $ params ) ; } $ this - > get And Stream ( $ url , function ( $ raw Data ) use ( $ callback ) { $ parsed Object = Transaction : : from Raw Response Data ( $ raw Data ) ; $ parsed Object - > set Api Client ( $ this ) ; $ callback ( $ parsed Object ) ; } ) ; } 
protected function post Transaction ( $ relative Url , $ parameters = array ( ) ) { $ api Response = null ; try { $ api Response = $ this - > http Client - > post ( $ relative Url , [ 'form _params ' = > $ parameters ] ) ; } catch ( Client Exception $ e ) { 
public function from Text ( $ patch Text ) { $ patches = array ( ) ; if ( ! $ patch Text ) { return $ patches ; } $ lines = explode ( " \n " , $ patch Text ) ; while ( count ( $ lines ) ) { $ line = $ lines [ 0 ] ; if ( ! preg _match ( " / ^ @ @ - ( \d + ) , ? ( \d * ) \ + ( \d + ) , ? ( \d * ) @ @ $ / " , $ line , $ m ) ) { throw new \ Invalid Argument Exception ( "Invalid patch string : " . $ line ) ; } $ patch = new Patch Object ( ) ; $ patch - > set Start 1 ( $ m [ 1 ] ) ; if ( $ m [ 2 ] = = ' ' ) { $ patch - > set Start 1 ( $ patch - > get Start 1 ( ) - 1 ) ; $ patch - > set Length 1 ( 1 ) ; } elseif ( $ m [ 2 ] = = ' 0 ' ) { $ patch - > set Length 1 ( 0 ) ; } else { $ patch - > set Start 1 ( $ patch - > get Start 1 ( ) - 1 ) ; $ patch - > set Length 1 ( $ m [ 2 ] ) ; } $ patch - > set Start 2 ( $ m [ 3 ] ) ; if ( $ m [ 4 ] = = ' ' ) { $ patch - > set Start 2 ( $ patch - > get Start 2 ( ) - 1 ) ; $ patch - > set Length 2 ( 1 ) ; } elseif ( $ m [ 4 ] = = ' 0 ' ) { $ patch - > set Length 2 ( 0 ) ; } else { $ patch - > set Start 2 ( $ patch - > get Start 2 ( ) - 1 ) ; $ patch - > set Length 2 ( $ m [ 4 ] ) ; } $ patches [ ] = $ patch ; array _shift ( $ lines ) ; while ( count ( $ lines ) ) { $ line = $ lines [ 0 ] ; if ( $ line ) { $ sign = mb _substr ( $ line , 0 , 1 ) ; } else { $ sign = ' ' ; } $ text = Utils : : unescape String ( mb _substr ( $ line , 1 ) ) ; switch ( $ sign ) { case ' + ' : 
public function to Text ( $ patches ) { $ text = ' ' ; foreach ( $ patches as $ patch ) { $ text . = ( string ) $ patch ; } return $ text ; } 
public function add Context ( Patch Object $ patch , $ text ) { if ( ! mb _strlen ( $ text ) ) { return ; } $ padding = 0 ; $ pattern = mb _substr ( $ text , $ patch - > get Start 1 ( ) , $ patch - > get Length 1 ( ) ) ; 
public function make ( $ a , $ b = null , $ c = null ) { $ diff = $ this - > get Diff ( ) ; if ( is _string ( $ a ) & & is _string ( $ b ) & & is _null ( $ c ) ) { 
public function split Max ( & $ patches ) { $ patch Size = $ this - > get Match ( ) - > get Max Bits ( ) ; if ( $ patch Size = = 0 ) { 
public function add Padding ( & $ patches ) { $ padding Length = $ this - > get Margin ( ) ; $ null Padding = ' ' ; for ( $ i = 1 ; $ i < = $ padding Length ; $ i + + ) { $ null Padding . = chr ( $ i ) ; } 
public function apply ( $ patches , $ text ) { if ( empty ( $ patches ) ) { return array ( $ text , array ( ) ) ; } 
protected function deep Copy ( $ patches ) { $ patches Copy = array ( ) ; foreach ( $ patches as $ patch ) { $ patch Copy = clone $ patch ; $ patches Copy [ ] = $ patch Copy ; } return $ patches Copy ; } 
public function main ( $ text , $ pattern , $ loc = 0 ) { 
public function bitap ( $ text , $ pattern , $ loc ) { if ( $ this - > get Max Bits ( ) ! = 0 & & $ this - > get Max Bits ( ) < mb _strlen ( $ pattern ) ) { throw new \ Range Exception ( 'Pattern too long for this application . ' ) ; } 
protected function bitap Score ( $ errors , $ match Loc , $ pattern Len , $ search Loc ) { $ accuracy = $ errors / $ pattern Len ; $ proximity = abs ( $ search Loc - $ match Loc ) ; if ( ! $ this - > get Distance ( ) ) { 
public function alphabet ( $ pattern ) { $ s = array ( ) ; foreach ( preg _split ( " / /u " , $ pattern , - 1 , PREG _SPLIT _NO _EMPTY ) as $ char ) { $ s [ $ char ] = 0 ; } for ( $ i = 0 ; $ i < mb _strlen ( $ pattern ) ; $ i + + ) { $ s [ mb _substr ( $ pattern , $ i , 1 ) ] | = 1 < < ( mb _strlen ( $ pattern ) - $ i - 1 ) ; } return $ s ; } 
public function cleanup Merge ( ) { $ diffs = $ this - > get Changes ( ) ; $ diffs [ ] = array ( self : : EQUAL , ' ' , ) ; $ pointer = 0 ; $ count _delete = 0 ; $ count _insert = 0 ; $ text _delete = ' ' ; $ text _insert = ' ' ; while ( $ pointer < count ( $ diffs ) ) { if ( $ diffs [ $ pointer ] [ 0 ] = = self : : INSERT ) { $ count _insert + + ; $ text _insert . = $ diffs [ $ pointer ] [ 1 ] ; $ pointer + + ; } elseif ( $ diffs [ $ pointer ] [ 0 ] = = self : : DELETE ) { $ count _delete + + ; $ text _delete . = $ diffs [ $ pointer ] [ 1 ] ; $ pointer + + ; } elseif ( $ diffs [ $ pointer ] [ 0 ] = = self : : EQUAL ) { 
public function cleanup Semantic Lossless ( ) { $ diffs = $ this - > get Changes ( ) ; $ pointer = 1 ; 
protected function cleanup Semantic Score ( $ one , $ two ) { if ( $ one = = ' ' | | $ two = = ' ' ) { 
public function cleanup Semantic ( ) { $ diffs = $ this - > get Changes ( ) ; $ changes = false ; 
public function cleanup Efficiency ( ) { $ diffs = $ this - > get Changes ( ) ; $ changes = false ; 
public function pretty Html ( ) { $ diffs = $ this - > get Changes ( ) ; $ html = ' ' ; foreach ( $ diffs as $ change ) { $ op = $ change [ 0 ] ; $ data = $ change [ 1 ] ; $ text = str _replace ( array ( ' & ' , ' < ' , ' > ' , " \n " , ) , array ( ' &amp ; ' , ' &lt ; ' , ' &gt ; ' , ' &para ; <br > ' , ) , $ data ) ; if ( $ op = = self : : INSERT ) { $ html . = ' <ins style = "background : #e 6ffe 6 ; " > ' . $ text . ' < /ins > ' ; } elseif ( $ op = = self : : DELETE ) { $ html . = ' <del style = "background : #ffe 6e 6 ; " > ' . $ text . ' < /del > ' ; } else { $ html . = ' <span > ' . $ text . ' < /span > ' ; } } return $ html ; } 
public function text 1 ( ) { $ diffs = $ this - > get Changes ( ) ; $ text = ' ' ; foreach ( $ diffs as $ change ) { $ op = $ change [ 0 ] ; $ data = $ change [ 1 ] ; if ( $ op ! = self : : INSERT ) { $ text . = $ data ; } } return $ text ; } 
public function text 2 ( ) { $ diffs = $ this - > get Changes ( ) ; $ text = ' ' ; foreach ( $ diffs as $ change ) { $ op = $ change [ 0 ] ; $ data = $ change [ 1 ] ; if ( $ op ! = self : : DELETE ) { $ text . = $ data ; } } return $ text ; } 
public function to Delta ( ) { $ diffs = $ this - > get Changes ( ) ; $ text = array ( ) ; foreach ( $ diffs as $ change ) { $ op = $ change [ 0 ] ; $ data = $ change [ 1 ] ; if ( $ op = = self : : INSERT ) { $ text [ ] = ' + ' . Utils : : escape String ( $ data ) ; } elseif ( $ op = = self : : DELETE ) { $ text [ ] = ' - ' . mb _strlen ( $ data ) ; } else { $ text [ ] = ' = ' . mb _strlen ( $ data ) ; } } return implode ( " \t " , $ text ) ; } 
public function from Delta ( $ text 1 , $ delta ) { $ diffs = array ( ) ; 
public function x Index ( $ loc ) { $ diffs = $ this - > get Changes ( ) ; $ chars 1 = 0 ; $ chars 2 = 0 ; $ last _chars 1 = 0 ; $ last _chars 2 = 0 ; $ i = 0 ; foreach ( $ diffs as $ change ) { $ op = $ change [ 0 ] ; $ text = $ change [ 1 ] ; 
public function levenshtein ( ) { $ diffs = $ this - > get Changes ( ) ; $ levenshtein = 0 ; $ insertions = 0 ; $ deletions = 0 ; foreach ( $ diffs as $ change ) { $ op = $ change [ 0 ] ; $ text = $ change [ 1 ] ; switch ( $ op ) { case self : : INSERT : $ insertions + = mb _strlen ( $ text ) ; break ; case self : : DELETE : $ deletions + = mb _strlen ( $ text ) ; break ; case self : : EQUAL : 
public function main ( $ text 1 , $ text 2 , $ checklines = true , $ deadline = null ) { 
protected function compute ( $ text 1 , $ text 2 , $ checklines , $ deadline ) { if ( $ text 1 = = ' ' ) { 
protected function line Mode ( $ text 1 , $ text 2 , $ deadline ) { 
protected function bisect ( $ text 1 , $ text 2 , $ deadline ) { 
protected function bisect Split ( $ text 1 , $ text 2 , $ x , $ y , $ deadline ) { $ text 1A = mb _substr ( $ text 1 , 0 , $ x ) ; $ text 2A = mb _substr ( $ text 2 , 0 , $ y ) ; $ text 1B = mb _substr ( $ text 1 , $ x ) ; $ text 2B = mb _substr ( $ text 2 , $ y ) ; 
public function common Prefix ( $ text 1 , $ text 2 ) { 
public function common Suffix ( $ text 1 , $ text 2 ) { 
public function commont Overlap ( $ text 1 , $ text 2 ) { 
public function half Match ( $ text 1 , $ text 2 ) { if ( mb _strlen ( $ text 1 ) > mb _strlen ( $ text 2 ) ) { $ longtext = $ text 1 ; $ shorttext = $ text 2 ; } else { $ shorttext = $ text 1 ; $ longtext = $ text 2 ; } if ( mb _strlen ( $ longtext ) < 4 | | mb _strlen ( $ shorttext ) * 2 < mb _strlen ( mb _strlen ( $ longtext ) ) ) { 
protected function half Match I ( $ longtext , $ shorttext , $ i ) { $ seed = mb _substr ( $ longtext , $ i , ( int ) ( mb _strlen ( $ longtext ) / 4 ) ) ; $ best _common = $ best _longtext _a = $ best _longtext _b = $ best _shorttext _a = $ best _shorttext _b = ' ' ; $ j = mb _strpos ( $ shorttext , $ seed ) ; while ( $ j ! = = false ) { $ prefix Legth = $ this - > common Prefix ( mb _substr ( $ longtext , $ i ) , mb _substr ( $ shorttext , $ j ) ) ; $ suffix Legth = $ this - > common Suffix ( mb _substr ( $ longtext , 0 , $ i ) , mb _substr ( $ shorttext , 0 , $ j ) ) ; if ( mb _strlen ( $ best _common ) < $ suffix Legth + $ prefix Legth ) { $ best _common = mb _substr ( $ shorttext , $ j - $ suffix Legth , $ suffix Legth ) . mb _substr ( $ shorttext , $ j , $ prefix Legth ) ; $ best _longtext _a = mb _substr ( $ longtext , 0 , $ i - $ suffix Legth ) ; $ best _longtext _b = mb _substr ( $ longtext , $ i + $ prefix Legth ) ; $ best _shorttext _a = mb _substr ( $ shorttext , 0 , $ j - $ suffix Legth ) ; $ best _shorttext _b = mb _substr ( $ shorttext , $ j + $ prefix Legth ) ; } $ j = mb _strpos ( $ shorttext , $ seed , $ j + 1 ) ; } if ( mb _strlen ( $ best _common ) * 2 > = mb _strlen ( $ longtext ) ) { return array ( $ best _longtext _a , $ best _longtext _b , $ best _shorttext _a , $ best _shorttext _b , $ best _common ) ; } else { return null ; } } 
public function lines To Chars ( $ text 1 , $ text 2 ) { 
protected function lines To Chars Munge ( $ text , array & $ line Array , array & $ line Hash ) { 
public function chars To Lines ( & $ diffs , $ line Array ) { foreach ( $ diffs as & $ diff ) { $ text = ' ' ; for ( $ i = 0 ; $ i < mb _strlen ( $ diff [ 1 ] ) ; $ i + + ) { $ char = mb _substr ( $ diff [ 1 ] , $ i , 1 ) ; $ text . = $ line Array [ Utils : : unicode Ord ( $ char ) ] ; } $ diff [ 1 ] = $ text ; } unset ( $ diff ) ; } 
public function diff _main ( $ text 1 , $ text 2 , $ checklines = true ) { return $ this - > diff - > main ( $ text 1 , $ text 2 , $ checklines ) - > get Changes ( ) ; } 
public function diff _cleanup Semantic ( & $ diffs ) { $ this - > diff - > set Changes ( $ diffs ) ; $ this - > diff - > cleanup Semantic ( ) ; $ diffs = $ this - > diff - > get Changes ( ) ; } 
public function diff _cleanup Efficiency ( & $ diffs ) { $ this - > diff - > set Changes ( $ diffs ) ; $ this - > diff - > cleanup Efficiency ( ) ; $ diffs = $ this - > diff - > get Changes ( ) ; } 
public function match _main ( $ text , $ pattern , $ loc = 0 ) { return $ this - > match - > main ( $ text , $ pattern , $ loc ) ; } 
public function patch _make ( $ a , $ b = null , $ c = null ) { return $ this - > patch - > make ( $ a , $ b , $ c ) ; } 
public static function unicode Chr ( $ code ) { 
public static function unicode Ord ( $ char ) { if ( mb _internal _encoding ( ) ! = 'UCS - 2LE ' ) { $ char = iconv ( mb _internal _encoding ( ) , 'UCS - 2LE ' , $ char ) ; } $ code = 0 ; for ( $ i = 0 ; $ i < strlen ( $ char ) ; $ i + + ) { $ code + = ord ( $ char [ $ i ] ) * pow ( 2 5 6 , $ i ) ; } return $ code ; } 
public function send ( $ notifiable , Notification $ notification ) { if ( ! ( $ to = $ this - > get Recipients ( $ notifiable , $ notification ) ) ) { return ; } $ message = $ notification - > { 'to Smsc Ru ' } ( $ notifiable ) ; if ( \ is _string ( $ message ) ) { $ message = new Smsc Ru Message ( $ message ) ; } $ this - > send Message ( $ to , $ message ) ; } 
protected function get Recipients ( $ notifiable , Notification $ notification ) { $ to = $ notifiable - > route Notification For ( 'smscru ' , $ notification ) ; if ( $ to = = = null | | $ to = = = false | | $ to = = = ' ' ) { return [ ] ; } return \ is _array ( $ to ) ? $ to : [ $ to ] ; } 
public function version ( ) { $ app = $ this - > app ; $ tab = explode ( 'Laravel Components ' , $ app - > version ( ) ) ; return intval ( empty ( $ tab [ 1 ] ) ? $ app : : VERSION : $ tab [ 1 ] ) ; } 
public function register ( ) { 
public function boot ( ) { 
public function register Pug Compiler ( $ sub Extension = ' ' ) { 
public function get Config ( ) { $ key = $ this - > version ( ) > = 5 ? 'laravel -pug ' : 'laravel -pug : :config ' ; return array _merge ( array ( 'allow _composite _extensions ' = > true , ) , $ this - > app - > make ( 'config ' ) - > get ( $ key ) ) ; } 
public function construct ( array $ pug Target , Filesystem $ files , array $ config , $ default Cache Path = null ) { $ this - > pug Target = $ pug Target ; $ cache Path = null ; foreach ( array ( 'cache _dir ' , 'cache ' , 'default Cache ' ) as $ name ) { if ( isset ( $ config [ $ name ] ) ) { $ cache Path = $ config [ $ name ] ; break ; } } if ( ! $ cache Path ) { $ cache Path = $ default Cache Path ? : $ this - > get Cache Path ( ) ; } parent : : _ _construct ( $ files , $ cache Path ) ; } 
public function get Pug ( ) { if ( ! $ this - > pug ) { $ this - > pug = $ this - > pug Target [ 0 ] [ $ this - > pug Target [ 1 ] ] ; } return $ this - > pug ; } 
public function get Cache Path ( ) { if ( $ this - > cache Path ) { return $ this - > cache Path ; } $ cache Path = $ this - > get Option ( 'cache ' ) ; return is _string ( $ cache Path ) ? $ cache Path : $ this - > get Option ( 'default Cache ' ) ; } 
public function get Option ( $ name , $ default = null ) { $ pug = $ this - > get Pug ( ) ; try { if ( method _exists ( $ pug , 'has Option ' ) & & ! $ pug - > has Option ( $ name ) ) { throw new \ Invalid Argument Exception ( 'invalid option ' ) ; } return $ pug - > get Option ( $ name ) ; } catch ( \ Invalid Argument Exception $ exception ) { return $ default ; } } 
private function has Expired Import ( $ path ) { $ compiled = $ this - > get Compiled Path ( $ path ) ; $ imports Map = $ compiled . ' .imports .serialize .txt ' ; $ files = $ this - > files ; if ( ! $ files - > exists ( $ imports Map ) ) { return true ; } $ import Paths = unserialize ( $ files - > get ( $ imports Map ) ) ; $ time = $ files - > last Modified ( $ compiled ) ; foreach ( $ import Paths as $ import Path ) { if ( ! $ files - > exists ( $ import Path ) | | $ files - > last Modified ( $ import Path ) > = $ time ) { return true ; } } return false ; } 
public function is Expired ( $ path ) { if ( ! $ this - > cache Path | | parent : : is Expired ( $ path ) ) { return true ; } return is _subclass _of ( ' \Pug \Pug ' , ' \Phug \Renderer ' ) & & $ this - > has Expired Import ( $ path ) ; } 
public function extract Path ( $ path ) { if ( $ path & & method _exists ( $ this , 'set Path ' ) ) { $ this - > set Path ( $ path ) ; } if ( ! $ path & & method _exists ( $ this , 'get Path ' ) ) { $ path = $ this - > get Path ( ) ; } if ( ! $ path ) { throw new Invalid Argument Exception ( 'Missing path argument . ' ) ; } return $ path ; } 
public function get Compiler ( ) { $ pug = $ this - > get Pug ( ) ; if ( $ pug instanceof \ Phug \ Renderer ) { $ pug = clone $ pug - > get Compiler ( ) ; } return $ pug ; } 
public function compile With ( $ path , callable $ callback = null ) { $ path = $ this - > extract Path ( $ path ) ; if ( $ this - > cache Path ) { $ pug = $ this - > get Compiler ( ) ; $ compiled = $ this - > get Compiled Path ( $ path ) ; $ contents = $ pug - > compile ( $ this - > files - > get ( $ path ) , $ path ) ; if ( $ callback ) { $ contents = call _user _func ( $ callback , $ contents ) ; } if ( $ pug instanceof \ Phug \ Compiler ) { $ this - > files - > put ( $ compiled . ' .imports .serialize .txt ' , serialize ( $ pug - > get Current Import Paths ( ) ) ) ; } $ this - > files - > put ( $ compiled , $ contents ) ; } } 
public function compile ( $ path = null ) { $ app = Blade : : get Facade Application ( ) ; if ( isset ( $ app [ 'view ' ] ) ) { $ this - > enable Blade Directives ( ) ; } $ this - > footer = array ( ) ; $ this - > compile With ( $ path , array ( $ this , 'compile String ' ) ) ; } 
public function register ( ) { $ this - > app - > singleton ( 'amocrm ' , function ( Container $ app ) { $ config = $ app [ 'config ' ] ; return new Amo Crm Manager ( $ config ) ; } ) ; $ this - > app - > singleton ( 'amocrm .fields ' , function ( Container $ app ) { $ manager = $ app [ 'amocrm ' ] ; return $ manager - > get Fields ( ) ; } ) ; $ this - > app - > singleton ( 'amocrm .b 2bfamily ' , function ( Container $ app ) { $ manager = $ app [ 'amocrm ' ] ; return $ manager - > get B 2BFamily ( ) ; } ) ; } 
public function get Client ( ) { if ( ! $ this - > client instanceof Client ) { $ this - > client = new Client ( $ this - > config - > get ( 'amocrm .domain ' ) , $ this - > config - > get ( 'amocrm .login ' ) , $ this - > config - > get ( 'amocrm .hash ' ) ) ; } return $ this - > client ; } 
public function get B 2BFamily ( ) { $ client = $ this - > get Client ( ) ; return new B 2BFamily ( $ client , $ this - > config - > get ( 'amocrm .b 2bfamily .appkey ' ) , $ this - > config - > get ( 'amocrm .b 2bfamily .secret ' ) , $ this - > config - > get ( 'amocrm .b 2bfamily .email ' ) , $ this - > config - > get ( 'amocrm .b 2bfamily .password ' ) ) ; } 
private function hash Print ( $ input ) { 
private function has Expired Import ( $ source Path , $ cache Path ) { $ imports Map = $ cache Path . ' .imports .serialize .txt ' ; if ( ! file _exists ( $ imports Map ) ) { return true ; } $ import Paths = unserialize ( file _get _contents ( $ imports Map ) ) ? : [ ] ; $ import Paths [ ] = $ source Path ; $ time = filemtime ( $ cache Path ) ; foreach ( $ import Paths as $ import Path ) { if ( ! file _exists ( $ import Path ) | | filemtime ( $ import Path ) > = $ time ) { 
public function resolve ( $ file ) { return $ this - > locator - > locate ( $ file , $ this - > paths , isset ( $ this - > options [ 'extensions ' ] ) ? $ this - > options [ 'extensions ' ] : [ ' ' , ' .pug ' , ' .jade ' ] ) ; } 
public function is Expired ( $ file , & $ cache Path = null ) { if ( isset ( $ this - > options [ 'up _to _date _check ' ] ) & & ! $ this - > options [ 'up _to _date _check ' ] ) { return false ; } if ( ! $ this - > cache Directory ) { return true ; } $ source Path = $ this - > resolve ( $ file ) ; $ cache Path = rtrim ( $ this - > cache Directory , ' \ \ / ' ) . DIRECTORY _SEPARATOR . $ this - > hash Print ( $ source Path ) . ' .php ' ; if ( ! file _exists ( $ cache Path ) ) { return true ; } return $ this - > has Expired Import ( $ source Path , $ cache Path ) ; } 
public function display File ( $ _ _pug _file , array $ _ _pug _parameters = [ ] ) { if ( $ this - > is Expired ( $ _ _pug _file , $ _ _pug _cache _file ) ) { if ( isset ( $ this - > options [ 'render ' ] ) ) { call _user _func ( $ this - > options [ 'render ' ] , $ _ _pug _file , $ _ _pug _parameters , $ this - > options ) ; return ; } if ( isset ( $ this - > options [ 'renderer ' ] ) ) { $ this - > options [ 'renderer ' ] - > display File ( $ _ _pug _file , $ _ _pug _parameters ) ; return ; } if ( isset ( $ this - > options [ 'renderer _class _name ' ] ) ) { $ class Name = $ this - > options [ 'renderer _class _name ' ] ; $ renderer = new $ class Name ( $ this - > options ) ; $ renderer - > display File ( $ _ _pug _file , $ _ _pug _parameters ) ; return ; } $ facade = isset ( $ this - > options [ 'facade ' ] ) ? $ this - > options [ 'facade ' ] : static : : FACADE ; if ( is _callable ( [ $ facade , 'display File ' ] ) ) { $ facade : : display File ( $ _ _pug _file , $ _ _pug _parameters , $ this - > options ) ; return ; } throw new \ Runtime Exception ( 'No valid render method , renderer engine , renderer class or facade provided . ' ) ; } if ( isset ( $ this - > options [ 'shared _variables ' ] ) ) { $ _ _pug _parameters = array _merge ( $ this - > options [ 'shared _variables ' ] , $ _ _pug _parameters ) ; } if ( isset ( $ this - > options [ 'globals ' ] ) ) { $ _ _pug _parameters = array _merge ( $ this - > options [ 'globals ' ] , $ _ _pug _parameters ) ; } if ( isset ( $ this - > options [ 'self ' ] ) & & $ this - > options [ 'self ' ] ) { $ self = $ this - > options [ 'self ' ] = = = true ? 'self ' : strval ( $ this - > options [ 'self ' ] ) ; $ _ _pug _parameters = [ $ self = > $ _ _pug _parameters ] ; } extract ( $ _ _pug _parameters ) ; include $ _ _pug _cache _file ; } 
public static function get Extensions Options ( array $ extensions , array $ options = [ ] ) { $ methods = static : : get Extensions Getters ( ) ; foreach ( $ extensions as $ extension Class Name ) { if ( is _a ( $ extension Class Name , Module Interface : : class , true ) ) { if ( ! isset ( $ options [ 'modules ' ] ) ) { $ options [ 'modules ' ] = [ ] ; } $ options [ 'modules ' ] [ ] = $ extension Class Name ; continue ; } static : : extract Extension Options ( $ options , $ extension Class Name , $ methods ) ; } return $ options ; } 
public static function add Extension ( $ extension Class Name ) { if ( ! class _exists ( $ extension Class Name ) ) { throw new Phug Exception ( 'Invalid ' . $ extension Class Name . ' extension given : ' . 'it must be a class name . ' ) ; } if ( ! static : : has Extension ( $ extension Class Name ) ) { self : : $ extensions [ ] = $ extension Class Name ; if ( $ renderer = self : : $ renderer ) { $ renderer - > set Options Recursive ( static : : get Options ( ) ) ; } } } 
public static function remove Extension ( $ extension Class Name ) { if ( static : : has Extension ( $ extension Class Name ) ) { if ( self : : $ renderer ) { self : : remove Extension From Current Renderer ( $ extension Class Name ) ; self : : $ renderer - > init Compiler ( ) ; } self : : $ extensions = array _diff ( self : : $ extensions , [ $ extension Class Name ] ) ; } } 
public static function remove Options ( $ path , $ options ) { if ( self : : $ renderer & & ( empty ( $ path ) | | self : : $ renderer - > has Option ( $ path ) ) ) { if ( is _array ( $ options ) ) { foreach ( $ options as $ key = > $ value ) { if ( is _int ( $ key ) ) { $ callbacks = self : : $ renderer - > get Option ( $ path ) ; if ( ! is _array ( $ callbacks ) | | is _callable ( $ callbacks ) ) { $ callbacks = [ $ callbacks ] ; } self : : $ renderer - > set Option ( $ path , array _filter ( $ callbacks , function ( $ item ) use ( $ value ) { return $ item ! = = $ value ; } ) ) ; continue ; } static : : remove Options ( array _merge ( $ path , [ $ key ] ) , $ value ) ; } return ; } self : : $ renderer - > unset Option ( $ path ) ; } } 
public static function reset ( ) { static : : reset Facade Options ( ) ; self : : $ renderer = null ; self : : $ extensions = [ ] ; self : : $ filters = [ ] ; self : : $ keywords = [ ] ; } 
public static function get Renderer ( array $ options = [ ] ) { $ options = static : : get Options ( $ options ) ; if ( ! self : : $ renderer ) { $ renderer Class Name = self : : get Renderer Class Name ( ) ; self : : $ renderer = new $ renderer Class Name ( $ options ) ; } elseif ( ! empty ( $ options ) ) { self : : $ renderer - > re Init Options ( $ options ) ; self : : $ renderer - > get Compiler ( ) - > get Formatter ( ) - > init Formats ( ) ; } return self : : $ renderer ; } 
public static function set Filter ( $ name , $ filter ) { if ( ! ( is _callable ( $ filter ) | | class _exists ( $ filter ) | | method _exists ( $ filter , 'parse ' ) ) ) { throw new Phug Exception ( 'Invalid ' . $ name . ' filter given : ' . 'it must be a callable or a class name . ' ) ; } self : : $ filters [ self : : normalize Filter Name ( $ name ) ] = $ filter ; if ( self : : $ renderer ) { self : : $ renderer - > set Options Recursive ( static : : get Options ( ) ) ; } } 
public static function add Filter ( $ name , $ filter ) { $ key = self : : normalize Filter Name ( $ name ) ; if ( isset ( self : : $ filters [ $ key ] ) ) { throw new Phug Exception ( 'Filter ' . $ name . ' is already set . ' ) ; } self : : set Filter ( $ name , $ filter ) ; } 
public static function remove Filter ( $ name ) { $ key = self : : normalize Filter Name ( $ name ) ; if ( isset ( self : : $ filters [ $ key ] ) ) { unset ( self : : $ filters [ $ key ] ) ; if ( self : : $ renderer ) { self : : $ renderer - > unset Option ( [ 'filters ' , $ key ] ) ; } } } 
public static function set Keyword ( $ name , $ keyword ) { if ( ! is _callable ( $ keyword ) ) { throw new Phug Exception ( 'Invalid ' . $ name . ' keyword given : ' . 'it must be a callable or a class name . ' ) ; } self : : $ keywords [ self : : normalize Keyword Name ( $ name ) ] = $ keyword ; if ( self : : $ renderer ) { self : : $ renderer - > set Options Recursive ( static : : get Options ( ) ) ; } } 
public static function add Keyword ( $ name , $ keyword ) { $ key = self : : normalize Keyword Name ( $ name ) ; if ( isset ( self : : $ keywords [ $ key ] ) ) { throw new Phug Exception ( 'Keyword ' . $ name . ' is already set . ' ) ; } self : : set Keyword ( $ name , $ keyword ) ; } 
public static function remove Keyword ( $ name ) { $ key = self : : normalize Keyword Name ( $ name ) ; if ( isset ( self : : $ keywords [ $ key ] ) ) { unset ( self : : $ keywords [ $ key ] ) ; if ( self : : $ renderer ) { self : : $ renderer - > unset Option ( [ 'keywords ' , $ key ] ) ; } } } 
public static function cache Directory ( $ source , $ destination = null , $ options = null ) { if ( $ destination & & ! is _array ( $ destination ) ) { $ destination = [ 'cache _dir ' = > $ destination , ] ; } return static : : get Renderer ( array _merge ( $ options ? : [ ] , 
public static function textual Cache Directory ( $ source , $ destination = null , $ options = null ) { list ( $ success , $ errors , $ error Details ) = static : : cache Directory ( $ source , $ destination , $ options ) ; return " $success templates cached . \n " . " $errors templates failed to be cached . \n " . implode ( ' ' , array _map ( function ( $ detail ) { return $ detail [ 'input File ' ] . " \n " . $ detail [ 'error ' ] - > get Message ( ) . " \n " . $ detail [ 'error ' ] - > get Trace As String ( ) ; } , $ error Details ) ) ; } 
public function run ( $ arguments ) { $ output File = $ this - > get Named Argument ( $ arguments , [ ' - -output -file ' , ' -o ' ] ) ; $ bootstrap File = $ this - > get Named Argument ( $ arguments , [ ' - -bootstrap ' , ' -b ' ] ) ; if ( $ bootstrap File ) { include $ bootstrap File ; } elseif ( file _exists ( 'phug Bootstrap .php ' ) ) { include 'phug Bootstrap .php ' ; } list ( , $ action ) = array _pad ( $ arguments , 2 , null ) ; $ arguments = array _slice ( $ arguments , 2 ) ; $ facade = $ this - > facade ; $ method = $ this - > convert To Camel Case ( $ action ) ; $ custom Methods = $ this - > get Custom Methods ( ) ; if ( ! $ action ) { echo "You must provide a method . \n " ; $ this - > list Available Methods ( $ custom Methods ) ; return false ; } if ( ! in _array ( $ method , iterator _to _array ( $ this - > get Available Methods ( $ custom Methods ) ) ) ) { echo "The method $action is not available as CLI command in the $facade facade . \n " ; $ this - > list Available Methods ( $ custom Methods ) ; return false ; } return $ this - > execute ( $ facade , $ method , $ arguments , $ output File ) ; } 
public function get Available Methods ( $ custom Methods = null ) { foreach ( [ $ this - > methods , $ custom Methods ? : $ this - > get Custom Methods ( ) ] as $ methods ) { foreach ( $ methods as $ method = > $ action ) { $ method = is _int ( $ method ) ? $ action : $ method ; if ( substr ( $ method , 0 , 2 ) ! = = ' _ _ ' ) { yield $ method ; } } } } 
public function list Available Methods ( $ custom Methods = null ) { echo "Available methods are : \n " ; foreach ( $ this - > get Available Methods ( $ custom Methods ? : $ this - > get Custom Methods ( ) ) as $ method ) { $ action = $ this - > convert To Kebab Case ( $ method ) ; $ target = isset ( $ this - > methods [ $ method ] ) ? $ this - > methods [ $ method ] : $ method ; $ key = array _search ( $ target , $ this - > methods ) ; if ( is _int ( $ key ) ) { $ key = $ this - > methods [ $ key ] ; } echo ' - ' . $ action . ( $ key & & $ key ! = = $ method ? ' ( ' . $ this - > convert To Kebab Case ( $ key ) . ' alias ) ' : ' ' ) . " \n " ; } } 
public function get Column Attributes ( $ grid Field , $ record , $ column Name ) { $ errors = $ this - > get Errors ( $ record ) ; return [ 'class ' = > count ( $ errors ) ? 'seo -editor -error ' . implode ( ' ' , $ errors ) : 'seo -editor -valid ' , ] ; } 
public function get Column Content ( $ grid Field , $ record , $ column Name ) { $ field = new Textarea Field ( 'Meta Description ' ) ; $ value = $ grid Field - > get Data Field Value ( $ record , $ column Name ) ; $ value = $ this - > format Value ( $ grid Field , $ record , $ column Name , $ value ) ; $ field - > set Name ( $ this - > get Field Name ( $ field - > get Name ( ) , $ grid Field , $ record ) ) ; $ field - > set Value ( $ value ) ; $ field - > set Attribute ( 'data -name ' , 'Meta Description ' ) ; return $ field - > Field ( ) . $ this - > get Error Messages ( ) ; } 
public function get Errors ( Data Object $ record ) { $ errors = [ ] ; if ( strlen ( $ record - > Meta Description ) < 1 0 ) { $ errors [ ] = 'seo -editor -error -too -short ' ; } if ( strlen ( $ record - > Meta Description ) > 1 6 0 ) { $ errors [ ] = 'seo -editor -error -too -long ' ; } if ( strlen ( Site Tree : : get ( ) - > filter ( 'Meta Description ' , $ record - > Meta Description ) - > count ( ) > 1 ) ) { $ errors [ ] = 'seo -editor -error -duplicate ' ; } return $ errors ; } 
public function get List ( ) { $ list = parent : : get List ( ) ; $ params = $ this - > request - > request Var ( 'q ' ) ; if ( isset ( $ params [ 'Remove Empty Meta Titles ' ] ) & & $ params [ 'Remove Empty Meta Titles ' ] ) { $ list = $ this - > remove Empty Attributes ( $ list , 'Meta Title ' ) ; } if ( isset ( $ params [ 'Remove Empty Meta Descriptions ' ] ) & & $ params [ 'Remove Empty Meta Descriptions ' ] ) { $ list = $ this - > remove Empty Attributes ( $ list , 'Meta Description ' ) ; } $ list = $ this - > mark Duplicates ( $ list ) ; if ( isset ( $ params [ 'Duplicates Only ' ] ) & & $ params [ 'Duplicates Only ' ] ) { $ list = $ list - > filter ( 'Is Duplicate ' , true ) ; } $ list = $ list - > sort ( 'ID ' ) ; return $ list ; } 
private function mark Duplicates ( $ list ) { $ duplicates = $ this - > find Duplicates ( $ list , 'Meta Title ' ) - > map ( 'ID ' , 'ID ' ) - > to Array ( ) ; $ duplicate List = new Array List ( ) ; foreach ( $ list as $ item ) { if ( in _array ( $ item - > ID , $ duplicates ) ) { $ item - > Is Duplicate = true ; $ duplicate List - > push ( $ item ) ; } } $ duplicates = $ this - > find Duplicates ( $ list , 'Meta Description ' ) - > map ( 'ID ' , 'ID ' ) - > to Array ( ) ; foreach ( $ list as $ item ) { if ( in _array ( $ item - > ID , $ duplicates ) ) { $ item - > Is Duplicate = true ; if ( ! $ list - > by ID ( $ item - > ID ) ) { $ duplicate List - > push ( $ item ) ; } } } $ duplicate List - > merge ( $ list ) ; $ duplicate List - > remove Duplicates ( ) ; return $ duplicate List ; } 
private function find Duplicates ( SS _List $ list , $ type ) { $ page Attributes = $ list - > map ( 'ID ' , $ type ) - > to Array ( ) ; $ potential Duplicate Attributes = array _unique ( array _diff _assoc ( $ page Attributes , array _unique ( $ page Attributes ) ) ) ; $ duplicate Attributes = array _filter ( $ page Attributes , function ( $ value ) use ( $ potential Duplicate Attributes ) { return in _array ( $ value , $ potential Duplicate Attributes ) ; } ) ; if ( ! count ( $ duplicate Attributes ) ) { return $ list ; } return $ list - > filter ( [ 'ID ' = > array _keys ( $ duplicate Attributes ) , ] ) ; } 
private function remove Empty Attributes ( SS _List $ list , $ type ) { $ page Attributes = $ list - > map ( 'ID ' , $ type ) - > to Array ( ) ; $ empty Attributess = array _map ( function ( $ value ) { return $ value = = ' ' ; } , $ page Attributes ) ; if ( ! count ( $ empty Attributess ) ) { return $ list ; } return $ list - > filter ( [ 'ID :not ' = > array _keys ( array _filter ( $ empty Attributess , function ( $ value ) { return $ value = = 1 ; } ) ) ] ) ; } 
public function process Record ( $ record , $ column Map , & $ results , $ preview = false ) { $ page = $ this - > find Existing Object ( $ record , $ column Map ) ; if ( ! $ page | | ! $ page - > exists ( ) ) { return false ; } foreach ( $ record as $ field Name = > $ val ) { if ( $ field Name = = 'Meta Title ' | | $ field Name = = 'Meta Description ' ) { $ sql Value = Convert : : raw 2sql ( $ val ) ; DB : : query ( "UPDATE Site Tree SET { $field Name } = ' { $sql Value } ' WHERE ID = { $page - >ID } " ) ; if ( $ page - > is Published ( ) ) { DB : : query ( "UPDATE Site Tree _Live SET { $field Name } = ' { $sql Value } ' WHERE ID = { $page - >ID } " ) ; } } } return $ page - > ID ; } 
public function handle ( $ request , $ next ) { return resolve ( All Releases : : class ) - > authorize ( $ request ) ? $ next ( $ request ) : abort ( 4 0 3 ) ; } 
public function create ( $ key , $ position , $ reference Value , $ value ) { return $ this - > _create ( $ key , $ position , $ reference Value , $ value ) ; } 
public function create ( $ key , $ member ) { $ connection = $ this - > _rediska - > get Connection By Key Name ( $ key ) ; $ member = $ this - > _rediska - > get Serializer ( ) - > serialize ( $ member ) ; $ command = array ( 'ZREM ' , $ this - > _rediska - > get Option ( 'namespace ' ) . $ key , $ member ) ; return new Rediska _Connection _Exec ( $ connection , $ command ) ; } 
public function set Option ( $ name , $ value ) { if ( method _exists ( $ this , "set $name " ) ) { return call _user _func ( array ( $ this , "set $name " ) , $ value ) ; } else if ( array _key _exists ( $ name , $ this - > _options ) ) { $ this - > _options [ $ name ] = $ value ; return $ this ; } else { throw new $ this - > _options Exception ( "Unknown option ' $name ' " ) ; } } 
public function get Option ( $ name ) { if ( method _exists ( $ this , "get $name " ) ) { return call _user _func ( array ( $ this , "get $name " ) ) ; } else if ( array _key _exists ( $ name , $ this - > _options ) ) { return $ this - > _options [ $ name ] ; } else { throw new $ this - > _options Exception ( "Unknown option ' $name ' " ) ; } } 
public function create ( $ key Or Keys ) { if ( is _array ( $ key Or Keys ) ) { $ keys = $ key Or Keys ; if ( empty ( $ keys ) ) { throw new Rediska _Command _Exception ( 'Not present keys for delete ' ) ; } $ connections = array ( ) ; $ keys By Connections = array ( ) ; foreach ( $ keys as $ key ) { $ connection = $ this - > _rediska - > get Connection By Key Name ( $ key ) ; $ connection Alias = $ connection - > get Alias ( ) ; if ( ! array _key _exists ( $ connection Alias , $ connections ) ) { $ connections [ $ connection Alias ] = $ connection ; $ keys By Connections [ $ connection Alias ] = array ( ) ; } $ keys By Connections [ $ connection Alias ] [ ] = $ key ; } $ commands = array ( ) ; foreach ( $ keys By Connections as $ connection Alias = > $ keys ) { $ command = array ( 'DEL ' ) ; foreach ( $ keys as $ key ) { $ command [ ] = $ this - > _rediska - > get Option ( 'namespace ' ) . $ key ; } $ commands [ ] = new Rediska _Connection _Exec ( $ connections [ $ connection Alias ] , $ command ) ; } return $ commands ; } else { $ key = $ key Or Keys ; $ connection = $ this - > _rediska - > get Connection By Key Name ( $ key ) ; $ command = array ( 'DEL ' , $ this - > _rediska - > get Option ( 'namespace ' ) . $ key ) ; return new Rediska _Connection _Exec ( $ connection , $ command ) ; } } 
public function create ( ) { $ connections = $ this - > _rediska - > get Connections ( ) ; $ index = rand ( 0 , count ( $ connections ) - 1 ) ; $ connection = $ connections [ $ index ] ; $ command = array ( 'RANDOMKEY ' ) ; return new Rediska _Connection _Exec ( $ connection , $ command ) ; } 
public function parse Response ( $ response ) { if ( $ response = = ' ' ) { return null ; } else { if ( $ this - > _rediska - > get Option ( 'namespace ' ) ! = ' ' & & strpos ( $ response , $ this - > _rediska - > get Option ( 'namespace ' ) ) = = = 0 ) { $ response = substr ( $ response , strlen ( $ this - > _rediska - > get Option ( 'namespace ' ) ) ) ; } return $ response ; } } 
public function create ( $ channel Or Channels , $ message ) { $ channels = array ( ) ; if ( ! is _array ( $ channel Or Channels ) ) { $ channels = array ( $ channel Or Channels ) ; } else { $ channels = $ channel Or Channels ; } 
public function create ( $ pattern ) { $ commands = array ( ) ; $ command = array ( 'KEYS ' , $ this - > _rediska - > get Option ( 'namespace ' ) . $ pattern ) ; foreach ( $ this - > _rediska - > get Connections ( ) as $ connection ) { $ commands [ ] = new Rediska _Connection _Exec ( $ connection , $ command ) ; } return $ commands ; } 
public function parse Responses ( $ responses ) { $ keys = array ( ) ; foreach ( $ responses as $ response ) { if ( ! empty ( $ response ) ) { $ keys = array _merge ( $ keys , is _array ( $ response ) ? $ response : explode ( ' ' , $ response ) ) ; } } $ keys = array _unique ( $ keys ) ; if ( $ this - > _rediska - > get Option ( 'namespace ' ) ! = ' ' ) { $ namespace Length = strlen ( $ this - > _rediska - > get Option ( 'namespace ' ) ) ; foreach ( $ keys as & $ key ) { if ( strpos ( $ key , $ this - > _rediska - > get Option ( 'namespace ' ) ) = = = 0 ) { $ key = substr ( $ key , $ namespace Length ) ; } } } return $ keys ; } 
public function start ( ) { $ this - > _start Time = microtime ( true ) ; $ this - > _profiler - > start Callback ( $ this ) ; return $ this - > _start Time ; } 
public function stop ( ) { $ this - > _stop Time = microtime ( true ) ; $ this - > _profiler - > stop Call Back ( $ this ) ; return $ this - > get Elapsed Time ( ) ; } 
public function get Elapsed Time ( $ decimals = null ) { if ( ! $ this - > has Stopped ( ) ) { return false ; } $ elapsed Time = $ this - > _stop Time - $ this - > _start Time ; if ( $ decimals ) { return number _format ( $ elapsed Time , $ decimals ) ; } else { return $ elapsed Time ; } } 
public function initialize ( ) { if ( $ this - > _execs = = = null ) { $ this - > _execs = call _user _func _array ( array ( $ this , 'create ' ) , $ this - > _arguments ) ; if ( ! is _array ( $ this - > _execs ) ) { $ this - > _execs = array ( $ this - > _execs ) ; } return true ; } return false ; } 
public function write ( ) { $ this - > initialize ( ) ; foreach ( $ this - > _execs as $ exec ) { $ exec - > write ( ) ; } $ this - > _is Written = true ; return true ; } 
public function read ( ) { $ responses = array ( ) ; if ( ! $ this - > _is Written ) { throw new Rediska _Command _Exception ( 'You need write before ' ) ; } foreach ( $ this - > _execs as $ exec ) { $ responses [ ] = $ exec - > read ( ) ; } if ( isset ( $ responses [ 0 ] ) & & $ responses [ 0 ] = = = self : : QUEUED ) { $ this - > _is Queued = true ; return true ; } else { $ this - > _is Written = false ; return $ this - > parse Responses ( $ responses ) ; } } 
public function parse Responses ( $ responses ) { foreach ( $ responses as & $ response ) { $ response = $ this - > parse Response ( $ response ) ; } if ( sizeof ( $ responses ) = = 1 ) { return $ responses [ 0 ] ; } } 
protected function _arguments To String ( $ arguments ) { $ strings = array ( ) ; foreach ( $ arguments as $ name = > $ value ) { $ key = ! is _integer ( $ name ) ? " ' $name ' = > " : ' ' ; if ( is _object ( $ value ) ) { $ argument = get _class ( $ value ) . ' $ ' . $ name ; } else if ( is _numeric ( $ value ) ) { $ argument = $ value ; } else if ( is _string ( $ value ) ) { $ argument = " ' $value ' " ; } else if ( is _array ( $ value ) ) { $ argument = 'array ( ' . $ this - > _arguments To String ( $ value ) . ' ) ' ; } else if ( is _null ( $ value ) ) { $ argument = 'null ' ; } else if ( $ value = = = true ) { $ argument = 'true ' ; } else if ( $ value = = = false ) { $ argument = 'false ' ; } $ strings [ ] = $ key . $ argument ; } return implode ( ' , ' , $ strings ) ; } 
protected function _get And Validate Arguments ( $ arguments ) { $ class Name = get _class ( $ this ) ; if ( ! isset ( self : : $ _argument Names [ $ class Name ] ) ) { $ reflection = new Reflection Method ( $ this , 'create ' ) ; self : : $ _argument Names [ $ class Name ] = array ( ) ; foreach ( $ reflection - > get Parameters ( ) as $ parameter ) { self : : $ _argument Names [ $ class Name ] [ ] = $ parameter ; } } $ count = 0 ; $ argument Names And Values = array ( ) ; foreach ( self : : $ _argument Names [ $ class Name ] as $ parameter ) { if ( array _key _exists ( $ count , $ arguments ) ) { $ value = $ arguments [ $ count ] ; } else if ( $ parameter - > is Optional ( ) ) { $ value = $ parameter - > get Default Value ( ) ; } else { throw new Rediska _Command _Exception ( "Argument ' { $parameter - >get Name ( ) } ' not present for command ' $this - > _name ' " ) ; } $ argument Names And Values [ $ parameter - > get Name ( ) ] = $ value ; $ count + + ; } return $ argument Names And Values ; } 
protected function _throw Exception If Not Supported ( $ version = null ) { if ( null = = = $ version ) { $ version = $ this - > _version ; } $ redis Version = $ this - > _rediska - > get Option ( 'redis Version ' ) ; if ( version _compare ( $ version , $ redis Version ) = = 1 ) { throw new Rediska _Command _Exception ( "Command ' { $this - > _name } ' requires { $version } + version of Redis server . Current version is { $redis Version } . To change it specify 'redis Version ' option . " ) ; } } 
protected function _execute Command ( $ name , $ args = array ( ) ) { $ command = Rediska _Commands : : get ( $ this - > _rediska , $ name , $ args ) ; $ response = $ command - > execute ( ) ; unset ( $ command ) ; return $ response ; } 
public static function register ( $ prepend = false ) { if ( self : : is Registered ( ) ) { return false ; } if ( ! is _bool ( $ prepend ) ) { $ prepend = ( bool ) $ prepend ; } if ( version _compare ( PHP _VERSION , ' 5 . 3 . 0 ' , ' < ' ) ) { self : : $ _is Registered = spl _autoload _register ( self : : $ _callback ) ; } else { self : : $ _is Registered = spl _autoload _register ( self : : $ _callback , true , $ prepend ) ; } return self : : $ _is Registered ; } 
public static function unregister ( ) { if ( ! self : : is Registered ( ) ) { return false ; } self : : $ _is Registered = ! spl _autoload _unregister ( self : : $ _callback ) ; return self : : $ _is Registered ; } 
public static function load ( $ class Name ) { if ( 0 ! = = strpos ( $ class Name , 'Rediska ' ) ) { return false ; } $ path = self : : get Rediska Path ( ) . ' / ' . str _replace ( ' _ ' , ' / ' , $ class Name ) . ' .php ' ; return include $ path ; } 
public static function get Rediska Path ( ) { if ( ! self : : $ _rediska Path ) { self : : $ _rediska Path = realpath ( dirname ( _ _FILE _ _ ) . ' / . . ' ) ; } return self : : $ _rediska Path ; } 
public function add Connection ( $ connection String , $ weight = Rediska _Connection : : DEFAULT _WEIGHT ) { if ( isset ( $ this - > _backends [ $ connection String ] ) ) { throw new Rediska _Key Distributor _Exception ( "Connection ' $connection String ' already exists . " ) ; } $ this - > _backends [ $ connection String ] = $ weight ; $ this - > _backends Count + + ; $ this - > _hashring Is Initialized = false ; return $ this ; } 
public function remove Connection ( $ connection String ) { if ( ! isset ( $ this - > _backends [ $ connection String ] ) ) { throw new Rediska _Key Distributor _Exception ( "Connection ' $connection String ' not exist . " ) ; } unset ( $ this - > _backends [ $ connection String ] ) ; $ this - > _backends Count - - ; $ this - > _hashring Is Initialized = false ; return $ this ; } 
public function get Connection By Key Name ( $ name ) { $ connections = $ this - > get Connections By Key Name ( $ name , 1 ) ; if ( empty ( $ connections ) ) { throw new Rediska _Key Distributor _Exception ( 'No connections exist ' ) ; } return $ connections [ 0 ] ; } 
public function get Connections By Key Name ( $ name , $ count ) { 
public function add Channel ( $ channel ) { $ connection = $ this - > get Connection By Channel Name ( $ channel ) ; if ( ! array _key _exists ( $ connection - > get Alias ( ) , $ this - > _channels By Connections ) ) { $ this - > _channels By Connections [ $ connection - > get Alias ( ) ] = array ( ) ; $ this - > _connections [ $ connection - > get Alias ( ) ] = $ connection ; } if ( ! in _array ( $ channel , $ this - > _channels By Connections [ $ connection - > get Alias ( ) ] ) ) { $ this - > _channels By Connections [ $ connection - > get Alias ( ) ] [ ] = $ channel ; } return $ connection ; } 
public function has Channel ( $ channel ) { $ connection = $ this - > get Connection By Channel Name ( $ channel ) ; return isset ( $ this - > _channels By Connections [ $ connection - > get Alias ( ) ] ) & & in _array ( $ channel , $ this - > _channels By Connections [ $ connection - > get Alias ( ) ] ) ; } 
public function remove Channel ( $ channel ) { $ connection = $ this - > get Connection By Channel Name ( $ channel ) ; $ key = array _search ( $ channel , $ this - > _channels By Connections [ $ connection - > get Alias ( ) ] ) ; unset ( $ this - > _channels By Connections [ $ connection - > get Alias ( ) ] [ $ key ] ) ; if ( empty ( $ this - > _channels By Connections [ $ connection - > get Alias ( ) ] ) ) { unset ( $ this - > _channels By Connections [ $ connection - > get Alias ( ) ] ) ; unset ( $ this - > _connections [ $ connection - > get Alias ( ) ] ) ; 
public function get Connection By Channel Name ( $ name ) { 
public function get Connection By Alias ( $ alias ) { if ( ! isset ( $ this - > _connections [ $ alias ] ) ) { throw new Rediska _Pub Sub _Exception ( "Can 't find connection ' $alias ' " ) ; } return $ this - > _connections [ $ alias ] ; } 
public function get Channels By Connection ( Rediska _Connection $ connection ) { if ( ! isset ( $ this - > _channels By Connections [ $ connection - > get Alias ( ) ] ) ) { throw new Rediska _Pub Sub _Exception ( "Channels by this connection not present " ) ; } return $ this - > _channels By Connections [ $ connection - > get Alias ( ) ] ; } 
public function get ( $ name Or Pattern ) { $ config Get = new Rediska _Connection _Exec ( $ this - > _connection , array ( 'CONFIG ' , 'GET ' , $ name Or Pattern ) ) ; $ values After Names = $ config Get - > execute ( ) ; if ( preg _match ( ' / \W /i ' , $ name Or Pattern ) ) { 
public function set ( $ name , $ value ) { $ exec = new Rediska _Connection _Exec ( $ this - > _connection , array ( 'CONFIG ' , 'SET ' , $ name , $ value ) ) ; $ exec - > execute ( ) ; return $ this ; } 
public function count ( ) { $ exec = new Rediska _Connection _Exec ( $ this - > _connection , array ( 'CONFIG ' , 'GET ' , ' * ' ) ) ; $ names And Values = $ exec - > execute ( ) ; return count ( $ names And Values ) / 2 ; } 
protected function _sanitize Value ( $ value ) { $ value = trim ( $ value ) ; 
protected function _throw If Not Supported ( ) { $ version = ' 2 . 0 ' ; $ redis Version = $ this - > _rediska - > get Option ( 'redis Version ' ) ; if ( version _compare ( $ version , $ this - > _rediska - > get Option ( 'redis Version ' ) ) = = 1 ) { throw new Rediska _Transaction _Exception ( "Transaction requires { $version } + version of Redis server . Current version is { $redis Version } . To change it specify 'redis Version ' option . " ) ; } } 
public function create ( $ name , $ timeout = null ) { $ this - > _queues - > add ( $ name ) ; $ this - > _queue Objects [ $ name ] = new Rediska _Key _List ( $ this - > _get Key Name ( "queue _ $name " ) , array ( 'rediska ' = > $ this - > _rediska ) ) ; return true ; } 
public function delete ( $ name ) { if ( $ this - > _queues - > remove ( $ name ) ) { if ( isset ( $ this - > _queue Objects [ $ name ] ) ) { unset ( $ this - > _queue Objects [ $ name ] ) ; } return $ this - > _rediska - > delete ( $ this - > _get Key Name ( "queue _ $name " ) ) ; } } 
public function count ( Zend _Queue $ queue = null ) { if ( $ queue = = = null ) { $ queue = $ this - > _queue ; } $ queue Name = $ queue - > get Name ( ) ; if ( ! $ this - > is Exists ( $ queue Name ) ) { require _once 'Zend /Queue /Exception .php ' ; throw new Zend _Queue _Exception ( 'Queue does not exist : ' . $ queue Name ) ; } if ( ! isset ( $ this - > _queue Objects [ $ queue Name ] ) ) { $ this - > _queue Objects [ $ queue Name ] = new Rediska _Key _List ( $ this - > _get Key Name ( "queue _ $queue Name " ) , array ( 'rediska ' = > $ this - > _rediska ) ) ; } return count ( $ this - > _queue Objects [ $ queue Name ] ) ; } 
public function send ( $ message , Zend _Queue $ queue = null ) { if ( $ queue = = = null ) { $ queue = $ this - > _queue ; } $ queue Name = $ queue - > get Name ( ) ; if ( ! $ this - > is Exists ( $ queue Name ) ) { require _once 'Zend /Queue /Exception .php ' ; throw new Zend _Queue _Exception ( 'Queue does not exist : ' . $ queue Name ) ; } if ( ! isset ( $ this - > _queue Objects [ $ queue Name ] ) ) { $ this - > _queue Objects [ $ queue Name ] = new Rediska _Key _List ( $ this - > _get Key Name ( "queue _ $queue Name " ) , array ( 'rediska ' = > $ this - > _rediska ) ) ; } $ result = $ this - > _queue Objects [ $ queue Name ] - > prepend ( $ message ) ; if ( $ result = = = false ) { require _once 'Zend /Queue /Exception .php ' ; throw new Zend _Queue _Exception ( 'Failed to insert message into queue : ' . $ queue Name ) ; } $ options = array ( 'queue ' = > $ queue , 'data ' = > array ( 'body ' = > $ message ) , ) ; $ classname = $ queue - > get Message Class ( ) ; if ( ! class _exists ( $ classname ) ) { require _once 'Zend /Loader .php ' ; Zend _Loader : : load Class ( $ classname ) ; } return new $ classname ( $ options ) ; } 
public function receive ( $ max Messages = null , $ timeout = null , Zend _Queue $ queue = null ) { if ( $ max Messages = = = null ) { $ max Messages = 1 ; } if ( $ queue = = = null ) { $ queue = $ this - > _queue ; } $ queue Name = $ queue - > get Name ( ) ; if ( ! $ this - > is Exists ( $ queue Name ) ) { require _once 'Zend /Queue /Exception .php ' ; throw new Zend _Queue _Exception ( 'Queue does not exist : ' . $ queue Name ) ; } if ( ! isset ( $ this - > _queue Objects [ $ queue Name ] ) ) { $ this - > _queue Objects [ $ queue Name ] = new Rediska _Key _List ( $ this - > _get Key Name ( "queue _ $queue Name " ) , array ( 'rediska ' = > $ this - > _rediska ) ) ; } $ messages = array ( ) ; for ( $ i = 0 ; $ i < $ max Messages ; $ i + + ) { $ message = $ this - > _queue Objects [ $ queue Name ] - > pop ( ) ; if ( ! is _null ( $ message ) ) { $ messages [ ] = array ( 'body ' = > $ message ) ; } } $ options = array ( 'queue ' = > $ queue , 'data ' = > $ messages , 'message Class ' = > $ queue - > get Message Class ( ) , ) ; $ classname = $ queue - > get Message Set Class ( ) ; if ( ! class _exists ( $ classname ) ) { require _once 'Zend /Loader .php ' ; Zend _Loader : : load Class ( $ classname ) ; } return new $ classname ( $ options ) ; } 
public function delete Message ( Zend _Queue _Message $ message ) { $ queue Name = $ this - > _queue - > get Name ( ) ; if ( ! isset ( $ this - > _queue Objects [ $ queue Name ] ) ) { $ this - > _queue Objects [ $ queue Name ] = new Rediska _Key _List ( $ this - > _get Key Name ( "queue _ $queue Name " ) , array ( 'rediska ' = > $ this - > _rediska ) ) ; } return ( boolean ) $ this - > _queue Objects [ $ queue Name ] - > remove ( $ message - > body ) ; } 
public function create ( $ old Key , $ new Key , $ overwrite = true ) { $ old Key Connection = $ this - > _rediska - > get Connection By Key Name ( $ old Key ) ; $ new Key Connection = $ this - > _rediska - > get Connection By Key Name ( $ new Key ) ; $ command = ' ' ; if ( $ old Key Connection = = = $ new Key Connection ) { if ( $ overwrite ) { $ command = array ( ) ; } else { $ command = " " ; } $ command = array ( $ overwrite ? 'RENAME ' : 'RENAMENX ' , $ this - > _rediska - > get Option ( 'namespace ' ) . $ old Key , $ this - > _rediska - > get Option ( 'namespace ' ) . $ new Key ) ; } else { $ this - > set Atomic ( false ) ; $ command = array ( 'GET ' , $ this - > _rediska - > get Option ( 'namespace ' ) . $ old Key ) ; } return new Rediska _Connection _Exec ( $ old Key Connection , $ command ) ; } 
public function parse Responses ( $ responses ) { if ( ! $ this - > is Atomic ( ) ) { $ old Value = $ this - > _rediska - > get Serializer ( ) - > unserialize ( $ responses [ 0 ] ) ; if ( ! is _null ( $ old Value ) ) { $ reply = $ this - > _rediska - > set ( $ this - > new Key , $ old Value , $ this - > overwrite ) ; if ( $ reply ) { $ this - > _rediska - > delete ( $ this - > old Key ) ; } return $ reply ; } else { throw new Rediska _Command _Exception ( 'No such key ' ) ; } } else { return ( boolean ) $ responses [ 0 ] ; } } 
public function start ( $ context ) { $ profile = new Rediska _Profiler _Profile ( $ this , $ context ) ; $ profile - > start ( ) ; $ this - > _profiles [ ] = $ profile ; return $ profile ; } 
public function stop ( ) { $ has Unstopped = false ; foreach ( array _reverse ( $ this - > _profiles ) as $ profile ) { if ( ! $ profile - > has Stopped ( ) ) { $ has Unstopped = true ; break ; } } if ( $ has Unstopped ) { $ profile - > stop ( ) ; } else { throw new Rediska _Profiler _Exception ( 'You need start profiler before stop it ' ) ; } return $ profile ; } 
public function get Total Elapsed Time ( $ decimals = null ) { $ total Elapsed Time = 0 ; foreach ( $ this - > get Profiles ( ) as $ profile ) { if ( $ profile - > has Stopped ( ) ) { $ total Elapsed Time + = $ profile - > get Elapsed Time ( ) ; } } if ( $ decimals ) { return number _format ( $ total Elapsed Time , $ decimals ) ; } else { return $ total Elapsed Time ; } } 
public function add Connection ( $ connection String , $ weight = Rediska _Connection : : DEFAULT _WEIGHT ) { if ( in _array ( $ connection String , $ this - > _connections ) ) { throw new Rediska _Key Distributor _Exception ( "Connection ' $connection String ' already exists . " ) ; } $ this - > _connections [ ] = $ connection String ; $ this - > _connection Count + + ; 
public function remove Connection ( $ connection String ) { if ( ! in _array ( $ connection String , $ this - > _connections ) ) { throw new Rediska _Key Distributor _Exception ( "Connection ' $connection String ' does not exist . " ) ; } $ index = array _search ( $ connection String , $ this - > _connections ) ; unset ( $ this - > _connections [ $ index ] ) ; $ this - > _connection Count - - ; 
public function get Connection By Key Name ( $ name ) { if ( empty ( $ this - > _connections ) ) { throw new Rediska _Key Distributor _Exception ( "No connection exists . " ) ; } if ( $ this - > _connection Count = = 1 ) { return $ this - > _connections [ 0 ] ; } $ index = abs ( crc 3 2 ( $ name ) % $ this - > _connection Position Count ) ; return $ this - > _connection Positions [ $ index ] ; } 
public function set ( $ field Or Data , $ value = null , $ overwrite = true ) { $ result = $ this - > _get Rediska On ( ) - > set To Hash ( $ this - > get Name ( ) , $ field Or Data , $ value , $ overwrite ) ; if ( ! is _null ( $ this - > get Expire ( ) ) & & ( ( ! $ overwrite & & $ result ) | | ( $ overwrite ) ) ) { $ this - > expire ( $ this - > get Expire ( ) , $ this - > is Expire Timestamp ( ) ) ; } return $ result ; } 
public function offset Set ( $ field , $ value ) { if ( is _null ( $ field ) ) { throw new Rediska _Key _Exception ( 'Field must be present ' ) ; } $ this - > set ( $ field , $ value ) ; return $ value ; } 
public function increment ( $ field , $ amount = 1 ) { $ result = $ this - > _get Rediska On ( ) - > increment In Hash ( $ this - > get Name ( ) , $ field , $ amount ) ; if ( ! is _null ( $ this - > get Expire ( ) ) & & $ result ) { $ this - > expire ( $ this - > get Expire ( ) , $ this - > is Expire Timestamp ( ) ) ; } return $ result ; } 
public function remove ( $ field ) { $ result = $ this - > _get Rediska On ( ) - > delete From Hash ( $ this - > get Name ( ) , $ field ) ; if ( ! is _null ( $ this - > get Expire ( ) ) & & $ result ) { $ this - > expire ( $ this - > get Expire ( ) , $ this - > is Expire Timestamp ( ) ) ; } return $ result ; } 
public function authenticate ( ) { $ identity = $ this - > get Identity ( ) ; $ user Id Key = str _replace ( ' * ' , $ identity , $ this - > get Option ( 'user Id Key ' ) ) ; $ user Id = $ this - > get Rediska ( ) - > get ( $ user Id Key ) ; if ( is _null ( $ user Id ) ) { $ code = Zend _Auth _Result : : FAILURE _IDENTITY _NOT _FOUND ; $ message = 'User with the supplied identity could not be found . ' ; } else { $ user Data Key = str _replace ( ' * ' , $ user Id , $ this - > get Option ( 'user Data Key ' ) ) ; $ user Data = $ this - > get Rediska ( ) - > get ( $ user Data Key ) ; if ( is _null ( $ user Data ) ) { throw new Zend _Auth _Adapter _Exception ( "User data key ' $user Data Key ' not found " ) ; } $ credential Attribute Name = $ this - > get Option ( 'credential Attribute Name ' ) ; if ( $ this - > get Option ( 'user Data Is Array ' ) ) { if ( ! array _key _exists ( $ credential Attribute Name , $ user Data ) ) { throw new Zend _Auth _Adapter _Exception ( "Credential key with name ' $credential Attribute Name ' not found in user data " ) ; } $ credential = $ user Data [ $ credential Attribute Name ] ; } else { if ( ! isset ( $ user Data - > $ credential Attribute Name ) ) { throw new Zend _Auth _Adapter _Exception ( "Credential attribute with name ' $credential Attribute Name ' not found in user data " ) ; } $ credential = $ user Data - > $ credential Attribute Name ; } if ( $ this - > get Credential ( ) = = $ credential ) { $ code = Zend _Auth _Result : : SUCCESS ; $ message = 'Authentication successful . ' ; $ this - > _user Data = $ user Data ; } else { $ code = Zend _Auth _Result : : FAILURE _CREDENTIAL _INVALID ; $ message = 'Supplied credential is invalid . ' ; } } return new Zend _Auth _Result ( $ code , $ identity , array ( $ message ) ) ; } 
public function create ( $ key , array $ options = array ( ) ) { $ connection = $ this - > _rediska - > get Connection By Key Name ( $ key ) ; $ command = array ( 'SORT ' , $ this - > _rediska - > get Option ( 'namespace ' ) . $ key ) ; foreach ( $ options as $ name = > $ value ) { if ( ! array _key _exists ( $ name , $ this - > _options ) ) { throw new Rediska _Command _Exception ( "Unknown option ' $name ' " ) ; } $ this - > _options [ $ name ] = $ value ; } 
public function write ( $ id , $ data ) { try { $ timestamp = time ( ) ; $ this - > _set [ $ timestamp ] = $ id ; } catch ( Rediska _Connection _Exec _Exception $ e ) { $ this - > _delete Set Or Throw Exception ( $ e ) ; } return $ this - > get Rediska ( ) - > set And Expire ( $ this - > _get Key Name ( $ id ) , $ data , $ this - > get Option ( 'lifetime ' ) ) ; } 
public function destroy ( $ id ) { try { $ this - > _set - > remove ( $ id ) ; } catch ( Rediska _Connection _Exec _Exception $ e ) { $ this - > _delete Set Or Throw Exception ( $ e ) ; } return $ this - > get Rediska ( ) - > delete ( $ this - > _get Key Name ( $ id ) ) ; } 
public function gc ( $ maxlifetime ) { try { return $ this - > _set - > remove By Score ( 0 , time ( ) - $ this - > get Option ( 'lifetime ' ) ) ; } catch ( Rediska _Connection _Exec _Exception $ e ) { $ this - > _delete Set Or Throw Exception ( $ e ) ; } } 
public function subscribe ( $ channel Or Channels ) { if ( ! is _array ( $ channel Or Channels ) ) { $ channels = array ( $ channel Or Channels ) ; } else { $ channels = $ channel Or Channels ; } $ this - > _exec Command ( self : : SUBSCRIBE , $ channels ) ; return $ this ; } 
public function unsubscribe ( $ channel Or Channels = null ) { if ( is _null ( $ channel Or Channels ) ) { $ channels = $ this - > _subscriptions ; } elseif ( ! is _array ( $ channel Or Channels ) ) { $ channels = array ( $ channel Or Channels ) ; } else { $ channels = $ channel Or Channels ; } $ this - > _exec Command ( self : : UNSUBSCRIBE , $ channels ) ; return $ this ; } 
public function publish ( $ message ) { $ rediska = $ this - > get Rediska ( ) ; if ( $ this - > get Server Alias ( ) ! = = null ) { $ rediska = $ rediska - > on ( $ this - > get Server Alias ( ) ) ; } return $ rediska - > publish ( $ this - > _subscriptions , $ message ) ; } 
public function get Message ( $ timeout = null ) { 
public function offset Set ( $ offset , $ value ) { if ( ! is _null ( $ offset ) ) { throw new Rediska _Pub Sub _Exception ( 'Offset is not allowed in Rediska _Pub Sub _Channel ' ) ; } $ this - > publish ( $ value ) ; return $ value ; } 
protected function _exec Command ( $ command , $ channels ) { 
protected function _add Message To Buffer ( Rediska _Pub Sub _Response _Message $ message ) { $ key = " { $message - >get Connection ( ) - >get Alias ( ) } - { $message - >get Channel ( ) } " ; if ( ! isset ( self : : $ _messages [ $ key ] ) ) { self : : $ _messages [ $ key ] = array ( ) ; } self : : $ _messages [ $ key ] [ ] = $ message ; } 
protected function _get Response From Connection ( Rediska _Connection $ connection ) { $ response = Rediska _Connection _Exec : : read Response From Connection ( $ connection ) ; if ( $ response = = = null | | $ response = = = true ) { return null ; } list ( $ type , $ channel , $ body ) = $ response ; if ( $ this - > get Rediska ( ) - > get Option ( 'namespace ' ) ! = = ' ' & & strpos ( $ channel , $ this - > get Rediska ( ) - > get Option ( 'namespace ' ) ) = = = 0 ) { $ channel = substr ( $ channel , strlen ( $ this - > get Rediska ( ) - > get Option ( 'namespace ' ) ) ) ; } switch ( $ type ) { case self : : SUBSCRIBE : return new Rediska _Pub Sub _Response _Subscribe ( $ connection , $ channel ) ; case self : : UNSUBSCRIBE : return new Rediska _Pub Sub _Response _Unsubscribe ( $ connection , $ channel ) ; case self : : MESSAGE : $ message = $ this - > get Rediska ( ) - > get Serializer ( ) - > unserialize ( $ body ) ; return new Rediska _Pub Sub _Response _Message ( $ connection , $ channel , $ message ) ; default : throw new Rediska _Pub Sub _Response _Exception ( 'Unknown reponse type : ' . $ type ) ; } } 
protected function _throw If Not Supported ( ) { $ version = ' 1 . 3 . 8 ' ; $ redis Version = $ this - > get Rediska ( ) - > get Option ( 'redis Version ' ) ; if ( version _compare ( $ version , $ this - > get Rediska ( ) - > get Option ( 'redis Version ' ) ) = = 1 ) { throw new Rediska _Pub Sub _Exception ( "Publish /Subscribe requires { $version } + version of Redis server . Current version is { $redis Version } . To change it specify 'redis Version ' option . " ) ; } } 
public function create ( $ key , $ value , $ seconds ) { $ connection = $ this - > get Rediska ( ) - > get Connection By Key Name ( $ key ) ; $ command = array ( 'SETEX ' , $ this - > get Rediska ( ) - > get Option ( 'namespace ' ) . $ key , $ seconds , $ this - > get Rediska ( ) - > get Serializer ( ) - > serialize ( $ value ) ) ; return new Rediska _Connection _Exec ( $ connection , $ command ) ; } 
public function create ( $ key , $ min , $ max , $ with Scores = false , $ limit = null , $ offset = null , $ revert = false ) { if ( $ revert ) { $ this - > _throw Exception If Not Supported ( ' 2 . 1 . 6 ' ) ; } $ connection = $ this - > _rediska - > get Connection By Key Name ( $ key ) ; $ command = array ( $ revert ? 'ZREVRANGEBYSCORE ' : 'ZRANGEBYSCORE ' , $ this - > _rediska - > get Option ( 'namespace ' ) . $ key , $ revert ? $ max : $ min , $ revert ? $ min : $ max ) ; if ( ! is _null ( $ limit ) ) { if ( is _null ( $ offset ) ) { $ offset = 0 ; } $ command [ ] = 'LIMIT ' ; $ command [ ] = $ offset ; $ command [ ] = $ limit ; } if ( $ with Scores ) { $ this - > _throw Exception If Not Supported ( ' 1 . 3 . 4 ' ) ; $ command [ ] = 'WITHSCORES ' ; } return new Rediska _Connection _Exec ( $ connection , $ command ) ; } 
public function parse Response ( $ response ) { $ values = $ response ; if ( $ this - > with Scores ) { $ values = Rediska _Command _Response _Value And Score : : combine ( $ this - > _rediska , $ values ) ; } else { $ values = array _map ( array ( $ this - > _rediska - > get Serializer ( ) , 'unserialize ' ) , $ values ) ; } return $ values ; } 
public function unserialize ( $ value ) { set _error _handler ( array ( $ this , 'catch Unserialize Notice ' ) ) ; $ unserialized Value = @ unserialize ( $ value ) ; restore _error _handler ( ) ; if ( ! $ this - > _unserialized ) { $ this - > _unserialized = true ; throw new Rediska _Serializer _Adapter _Exception ( "Can 't unserialize value " ) ; } return $ unserialized Value ; } 
public function catch Unserialize Notice ( $ errno , $ errstr , $ errfile , $ errline , $ errcontext ) { if ( ! error _reporting ( ) & & strpos ( $ errstr , 'unserialize ( ) ' ) ! = = false ) { $ this - > _unserialized = false ; return true ; } else { return false ; } } 
public function create ( $ key , $ push To Key = null ) { $ connection = $ this - > _rediska - > get Connection By Key Name ( $ key ) ; if ( is _null ( $ push To Key ) ) { $ command = array ( 'RPOP ' , $ this - > _rediska - > get Option ( 'namespace ' ) . $ key ) ; } else { $ to Connection = $ this - > _rediska - > get Connection By Key Name ( $ push To Key ) ; if ( $ connection - > get Alias ( ) = = $ to Connection - > get Alias ( ) ) { $ this - > _throw Exception If Not Supported ( ' 1 . 1 ' ) ; $ command = array ( 'RPOPLPUSH ' , $ this - > _rediska - > get Option ( 'namespace ' ) . $ key , $ this - > _rediska - > get Option ( 'namespace ' ) . $ push To Key ) ; } else { $ this - > set Atomic ( false ) ; $ command = array ( 'RPOP ' , $ this - > _rediska - > get Option ( 'namespace ' ) . $ key ) ; } } return new Rediska _Connection _Exec ( $ connection , $ command ) ; } 
public function parse Response ( $ response ) { if ( ! $ this - > is Atomic ( ) ) { $ value = $ this - > _rediska - > get Serializer ( ) - > unserialize ( $ response ) ; $ this - > _rediska - > prepend To List ( $ this - > push To Key , $ value ) ; return $ value ; } else { return $ this - > _rediska - > get Serializer ( ) - > unserialize ( $ response ) ; } } 
public function create ( array $ keys , $ store Key = null ) { if ( empty ( $ keys ) ) { throw new Rediska _Command _Exception ( 'You must specify sets ' ) ; } $ connections = array ( ) ; $ keys By Connections = array ( ) ; foreach ( $ keys as $ key ) { $ connection = $ this - > _rediska - > get Connection By Key Name ( $ key ) ; $ connection Alias = $ connection - > get Alias ( ) ; if ( ! array _key _exists ( $ connection Alias , $ connections ) ) { $ connections [ $ connection Alias ] = $ connection ; $ keys By Connections [ $ connection Alias ] = array ( ) ; } $ keys By Connections [ $ connection Alias ] [ ] = $ key ; } if ( count ( $ connections ) = = 1 ) { $ connection Values = array _values ( $ connections ) ; $ connection = $ connection Values [ 0 ] ; if ( ! is _null ( $ store Key ) ) { $ store Connection = $ this - > _rediska - > get Connection By Key Name ( $ store Key ) ; if ( $ store Connection = = = $ connection ) { $ command = array ( $ this - > _store Command , $ this - > _rediska - > get Option ( 'namespace ' ) . $ store Key ) ; } else { $ this - > set Atomic ( false ) ; $ this - > _store Connection = $ store Connection ; $ command = array ( $ this - > _command ) ; } } else { $ command = array ( $ this - > _command ) ; } $ connection Keys = array _keys ( $ connections ) ; $ connection Alias = $ connection Keys [ 0 ] ; foreach ( $ keys By Connections [ $ connection Alias ] as $ key ) { $ command [ ] = $ this - > _rediska - > get Option ( 'namespace ' ) . $ key ; } return new Rediska _Connection _Exec ( $ connection , $ command ) ; } else { $ this - > set Atomic ( false ) ; $ commands = array ( ) ; foreach ( $ keys By Connections as $ connection Alias = > $ keys ) { foreach ( $ keys as $ key ) { $ command = array ( 'SMEMBERS ' , $ this - > _rediska - > get Option ( 'namespace ' ) . $ key ) ; $ commands [ ] = new Rediska _Connection _Exec ( $ connections [ $ connection Alias ] , $ command ) ; } } return $ commands ; } } 
public function parse Responses ( $ responses ) { if ( ! $ this - > is Atomic ( ) ) { if ( $ this - > _store Connection ) { $ values = $ responses [ 0 ] ; } else { $ values = array _values ( $ this - > _compare Sets ( $ responses ) ) ; } $ unserialized Values = array _map ( array ( $ this - > _rediska - > get Serializer ( ) , 'unserialize ' ) , $ values ) ; if ( is _null ( $ this - > store Key ) ) { return $ unserialized Values ; } else { $ this - > _rediska - > delete ( $ this - > store Key ) ; foreach ( $ unserialized Values as $ value ) { $ this - > _rediska - > add To Set ( $ this - > store Key , $ value ) ; } return true ; } } else { $ reply = $ responses [ 0 ] ; if ( is _null ( $ this - > store Key ) ) { $ reply = array _map ( array ( $ this - > _rediska - > get Serializer ( ) , 'unserialize ' ) , $ reply ) ; } else { $ reply = ( boolean ) $ reply ; } return $ reply ; } } 
public function serialize ( $ value ) { $ options = 0 ; if ( $ this - > _options [ 'encodeasobject ' ] ) { $ options = $ options | JSON _FORCE _OBJECT ; } if ( $ this - > _options [ 'encodehexquote ' ] ) { $ options = $ options | JSON _HEX _QUOT ; } if ( $ this - > _options [ 'encodehextag ' ] ) { $ options = $ options | JSON _HEX _TAG ; } if ( $ this - > _options [ 'encodehexamp ' ] ) { $ options = $ options | JSON _HEX _AMP ; } if ( $ this - > _options [ 'encodehexapos ' ] ) { $ options = $ options | JSON _HEX _APOS ; } $ serialized Value = json _encode ( $ value ) ; if ( json _last _error ( ) ! = JSON _ERROR _NONE ) { throw new Rediska _Serializer _Adapter _Exception ( "Can 't serialize value " ) ; } return $ serialized Value ; } 
public function unserialize ( $ value ) { $ decoded Value = json _decode ( $ value ) ; if ( $ decoded Value = = = null & & $ value ! = = 'null ' ) { throw new Rediska _Serializer _Adapter _Exception ( "Can 't unserialize value " ) ; } return $ decoded Value ; } 
public function add ( $ name ) { $ result = $ this - > _queues Set - > add ( $ name ) ; if ( $ result ) { $ queues Cache = $ this - > _get Queues Cache ( ) ; $ queues Cache [ ] = $ name ; $ this - > _set Queues Cache ( $ queues Cache ) ; } return $ result ; } 
public function remove ( $ name ) { $ result = $ this - > _queues Set - > remove ( $ name ) ; if ( $ result ) { $ queues Cache = $ this - > _get Queues Cache ( ) ; $ key = array _search ( $ name , $ queues Cache ) ; unset ( $ queues Cache [ $ key ] ) ; $ this - > _set Queues Cache ( $ queues Cache ) ; } return $ result ; } 
protected function _get Queues Cache ( ) { if ( $ this - > _queues Cache = = = null ) { $ this - > _queues Cache = $ this - > _queues Set - > to Array ( ) ; } return $ this - > _queues Cache ; } 
public function watch ( $ key Or Keys ) { $ this - > _throw If Not Supported ( 'Watch ' , ' 2 . 1 ' ) ; $ command = array ( 'WATCH ' ) ; if ( ! is _array ( $ key Or Keys ) ) { $ keys = array ( $ key Or Keys ) ; } else { $ keys = $ key Or Keys ; } foreach ( $ keys as $ key ) { $ command [ ] = $ this - > _rediska - > get Option ( 'namespace ' ) . $ key ; } $ exec = new Rediska _Connection _Exec ( $ this - > _connection , $ command ) ; $ exec - > execute ( ) ; $ this - > _is Watched = true ; return $ this ; } 
public function unwatch ( ) { $ this - > _throw If Not Supported ( 'Unwatch ' , ' 2 . 1 ' ) ; $ command = 'UNWATCH ' ; $ exec = new Rediska _Connection _Exec ( $ this - > _connection , $ command ) ; $ exec - > execute ( ) ; $ this - > _is Watched = false ; return $ this ; } 
public function execute ( ) { $ results = array ( ) ; $ this - > _rediska - > get Profiler ( ) - > start ( $ this ) ; $ multi = new Rediska _Connection _Exec ( $ this - > _connection , 'MULTI ' ) ; $ multi - > execute ( ) ; foreach ( $ this - > _commands as $ command ) { $ command - > execute ( ) ; } $ exec = new Rediska _Connection _Exec ( $ this - > _connection , 'EXEC ' ) ; $ responses = $ exec - > execute ( ) ; $ this - > _rediska - > get Profiler ( ) - > stop ( ) ; if ( ! $ responses ) { throw new Rediska _Transaction _Aborted Exception ( 'Transaction has been aborted by server ' ) ; } foreach ( $ this - > _commands as $ i = > $ command ) { $ results [ ] = $ command - > parse Responses ( array ( $ responses [ $ i ] ) ) ; } $ this - > _reset ( ) ; return $ results ; } 
protected function _add Command ( $ name , $ args = array ( ) ) { $ this - > _specified Connection - > set Connection ( $ this - > _connection ) ; $ command = Rediska _Commands : : get ( $ this - > _rediska , $ name , $ args ) ; $ command - > initialize ( ) ; if ( ! $ command - > is Atomic ( ) ) { throw new Rediska _Exception ( "Command ' $name ' doesn 't work properly (not atomic ) in transaction on multiple servers " ) ; } $ this - > _commands [ ] = $ command ; $ this - > _specified Connection - > reset Connection ( ) ; return $ this ; } 
public function create ( array $ keys , $ store Key , $ aggregation = self : : SUM ) { if ( empty ( $ keys ) ) { throw new Rediska _Command _Exception ( 'You must specify sorted sets ' ) ; } 
public function parse Responses ( $ responses ) { if ( $ this - > is Atomic ( ) ) { return $ responses [ 0 ] ; } else { $ sets = array ( ) ; $ values With Scores = array ( ) ; foreach ( $ this - > _keys as $ key ) { $ sets [ $ key ] = array ( ) ; $ response = current ( $ responses ) ; next ( $ responses ) ; $ is Value = true ; foreach ( $ response as $ value Or Score ) { if ( $ is Value ) { $ value = $ value Or Score ; $ sets [ $ key ] [ ] = $ value ; if ( ! isset ( $ values With Scores [ $ value ] ) ) { $ values With Scores [ $ value ] = array ( ) ; } } else { $ score = $ value Or Score ; $ values With Scores [ $ value ] [ ] = $ score * $ this - > _weights [ $ key ] ; } $ is Value = ! $ is Value ; } } $ aggregation = strtolower ( $ this - > aggregation ) ; $ pipeline = $ this - > _rediska - > pipeline ( ) ; $ count = 0 ; foreach ( $ this - > _compare Sets ( $ sets ) as $ value ) { $ scores = $ values With Scores [ $ value ] ; switch ( $ aggregation ) { case self : : SUM : $ score = array _sum ( $ scores ) ; break ; case self : : MIN : $ score = min ( $ scores ) ; break ; case self : : MAX : $ score = max ( $ scores ) ; break ; default : throw new Rediska _Command _Exception ( 'Unknown aggregation method ' . $ this - > aggregation ) ; } $ value = $ this - > _rediska - > get Serializer ( ) - > unserialize ( $ value ) ; $ pipeline - > add To Sorted Set ( $ this - > store Key , $ value , $ score ) ; $ count + + ; } $ pipeline - > execute ( ) ; return $ count ; } } 
public function new Action ( ) { $ current User = Zend _Auth : : get Instance ( ) - > get Storage ( ) - > read ( ) ; $ form = new Form _Post ; if ( $ this - > get Request ( ) - > is Post ( ) & & $ form - > is Valid ( $ this - > get Request ( ) - > get Post ( ) ) ) { $ post Data = $ form - > get Values ( ) ; $ post Data [ 'id ' ] = Post : : fetch Next Id ( ) ; $ post Data [ 'user Id ' ] = $ current User [ 'id ' ] ; 
public function index Action ( ) { $ current User = Zend _Auth : : get Instance ( ) - > get Storage ( ) - > read ( ) ; $ feed = new Feed ( $ current User [ 'id ' ] ) ; $ this - > view - > posts = array ( ) ; 
public function create ( $ key Or Keys ) { if ( is _array ( $ key Or Keys ) ) { $ this - > _multi = true ; $ keys = $ key Or Keys ; if ( empty ( $ keys ) ) { throw new Rediska _Command _Exception ( 'Not present keys for get ' ) ; } $ sorted Result = array ( ) ; $ this - > _keys = $ keys ; $ connections = array ( ) ; $ keys By Connections = array ( ) ; foreach ( $ keys as $ key ) { $ connection = $ this - > _rediska - > get Connection By Key Name ( $ key ) ; $ connection Alias = $ connection - > get Alias ( ) ; if ( ! array _key _exists ( $ connection Alias , $ connections ) ) { $ connections [ $ connection Alias ] = $ connection ; $ keys By Connections [ $ connection Alias ] = array ( ) ; } $ keys By Connections [ $ connection Alias ] [ ] = $ key ; } $ result = array ( ) ; $ commands = array ( ) ; foreach ( $ keys By Connections as $ connection Alias = > $ keys ) { $ command = array ( 'MGET ' ) ; foreach ( $ keys as $ key ) { $ command [ ] = $ this - > _rediska - > get Option ( 'namespace ' ) . $ key ; $ this - > _keys By Connections [ ] = $ key ; } $ commands [ ] = new Rediska _Connection _Exec ( $ connections [ $ connection Alias ] , $ command ) ; } return $ commands ; } else { $ key = $ key Or Keys ; $ connection = $ this - > _rediska - > get Connection By Key Name ( $ key ) ; $ command = array ( 'GET ' , $ this - > _rediska - > get Option ( 'namespace ' ) . $ key ) ; return new Rediska _Connection _Exec ( $ connection , $ command ) ; } } 
public function parse Responses ( $ responses ) { if ( is _array ( $ this - > key Or Keys ) ) { $ result = array ( ) ; if ( ! empty ( $ responses ) ) { $ merged Responses = array ( ) ; foreach ( $ responses as $ response ) { $ merged Responses = array _merge ( $ merged Responses , $ response ) ; } $ unsorted Result = array ( ) ; foreach ( $ this - > _keys By Connections as $ i = > $ key ) { $ unsorted Result [ $ key ] = $ merged Responses [ $ i ] ; } foreach ( $ this - > _keys as $ key ) { if ( isset ( $ unsorted Result [ $ key ] ) ) { $ result [ $ key ] = $ this - > _rediska - > get Serializer ( ) - > unserialize ( $ unsorted Result [ $ key ] ) ; } } } return $ result ; } else { return $ this - > _rediska - > get Serializer ( ) - > unserialize ( $ responses [ 0 ] ) ; } } 
static public function factory ( $ config ) { $ config = self : : _parse Config ( $ config ) ; if ( ! isset ( $ config [ 'key Name ' ] ) ) { throw new Zend _Log _Exception ( 'key Name not present ' ) ; } if ( ! isset ( $ config [ 'rediska ' ] ) ) { $ config [ 'rediska ' ] = Rediska : : DEFAULT _NAME ; } return new self ( $ config [ 'key Name ' ] , $ config [ 'rediska ' ] ) ; } 
public function add ( $ value , $ score ) { $ result = $ this - > _get Rediska On ( ) - > add To Sorted Set ( $ this - > get Name ( ) , $ value , $ score ) ; if ( ! is _null ( $ this - > get Expire ( ) ) & & $ result ) { $ this - > expire ( $ this - > get Expire ( ) , $ this - > is Expire Timestamp ( ) ) ; } return $ result ; } 
public function get Length By Score ( $ min , $ max ) { return $ this - > _get Rediska On ( ) - > get Sorted Set Length By Score ( $ this - > get Name ( ) , $ min , $ max ) ; } 
public function get By Score ( $ min , $ max , $ with Scores = false , $ limit = null , $ offset = null , $ revert = false ) { return $ this - > _get Rediska On ( ) - > get From Sorted Set By Score ( $ this - > get Name ( ) , $ min , $ max , $ with Scores , $ limit , $ offset , $ revert ) ; } 
public function remove By Score ( $ min , $ max ) { return $ this - > _get Rediska On ( ) - > Delete From Sorted Set By Score ( $ this - > get Name ( ) , $ min , $ max ) ; } 
public function increment Score ( $ value , $ score ) { return $ this - > _get Rediska On ( ) - > increment Score In Sorted Set ( $ this - > get Name ( ) , $ value , $ score ) ; } 
public function get By Rank ( $ with Scores = false , $ start = 0 , $ end = - 1 , $ revert = false , $ response Iterator = false ) { return $ this - > _get Rediska On ( ) - > get Sorted Set ( $ this - > get Name ( ) , $ with Scores , $ start , $ end , $ revert , $ response Iterator ) ; } 
public function remove By Rank ( $ start , $ end ) { return $ this - > _get Rediska On ( ) - > delete From Sorted Set By Rank ( $ this - > get Name ( ) , $ start , $ end ) ; } 
public function get Rank ( $ value , $ revert = false ) { return $ this - > _get Rediska On ( ) - > get Rank From Sorted Set ( $ this - > get Name ( ) , $ value , $ revert ) ; } 
public function union ( $ set Or Sets , $ store Key Name , $ aggregation = 'sum ' ) { $ sets = $ this - > _prepare Sets For Comapre ( $ set Or Sets ) ; return $ this - > _get Rediska On ( ) - > union Sorted Sets ( $ sets , $ store Key Name , $ aggregation ) ; } 
public function intersect ( $ set Or Sets , $ store Key Name , $ aggregation = 'sum ' ) { $ sets = $ this - > _prepare Sets For Comapre ( $ set Or Sets ) ; return $ this - > _get Rediska On ( ) - > intersect Sorted Sets ( $ sets , $ store Key Name , $ aggregation ) ; } 
public function to Array ( $ with Scores = false , $ start = 0 , $ end = - 1 , $ revert = false , $ response Iterator = false ) { return $ this - > get By Rank ( $ with Scores , $ start , $ end , $ revert , $ response Iterator ) ; } 
public function from Array ( array $ array ) { $ pipeline = $ this - > _get Rediska On ( ) - > pipeline ( ) ; foreach ( $ array as $ score = > $ value ) { $ pipeline - > add To Sorted Set ( $ this - > get Name ( ) , $ value , $ score ) ; } if ( ! is _null ( $ this - > get Expire ( ) ) ) { $ pipeline - > expire ( $ this - > get Name ( ) , $ this - > get Expire ( ) , $ this - > is Expire Timestamp ( ) ) ; } $ pipeline - > execute ( ) ; return true ; } 
public function create ( $ key , $ start = 0 , $ end = - 1 , $ response Iterator = false ) { $ connection = $ this - > _rediska - > get Connection By Key Name ( $ key ) ; $ command = array ( 'LRANGE ' , $ this - > _rediska - > get Option ( 'namespace ' ) . $ key , $ start , $ end ) ; $ exec = new Rediska _Connection _Exec ( $ connection , $ command ) ; if ( $ response Iterator ) { $ exec - > set Response Iterator ( true ) ; $ exec - > set Response Callback ( array ( $ this - > get Rediska ( ) - > get Serializer ( ) , 'unserialize ' ) ) ; } return $ exec ; } 
public function set Name ( $ name ) { $ this - > _options [ 'name ' ] = $ name ; if ( $ this - > _options [ 'add To Manager ' ] ) { Rediska _Manager : : add ( $ this ) ; } return $ this ; } 
public function set Servers ( array $ servers ) { $ this - > _connections = array ( ) ; foreach ( $ servers as $ alias = > $ server Options ) { if ( ! isset ( $ server Options [ 'alias ' ] ) & & is _string ( $ alias ) ) { $ server Options [ 'alias ' ] = $ alias ; } $ this - > add Server ( isset ( $ server Options [ 'host ' ] ) ? $ server Options [ 'host ' ] : Rediska _Connection : : DEFAULT _HOST , isset ( $ server Options [ 'port ' ] ) ? $ server Options [ 'port ' ] : Rediska _Connection : : DEFAULT _PORT , $ server Options ) ; } return $ this ; } 
public function add Server ( $ host , $ port = Rediska _Connection : : DEFAULT _PORT , array $ options = array ( ) ) { if ( ! isset ( $ options [ 'alias ' ] ) ) { $ connection String = " $host : $port " ; } else { $ connection String = $ options [ 'alias ' ] ; } if ( array _key _exists ( $ connection String , $ this - > _connections ) ) { throw new Rediska _Exception ( "Server ' $connection String ' already added . " ) ; } $ options [ 'host ' ] = $ host ; $ options [ 'port ' ] = $ port ; if ( isset ( $ options [ 'use Socket ' ] ) ) { if ( $ options [ 'use Socket ' ] = = true ) { $ connection Class = static : : CONNECTION _SOCKET _CLASS ; } unset ( $ options [ 'use Socket ' ] ) ; } else { $ connection Class = static : : CONNECTION _CLASS ; } $ this - > _connections [ $ connection String ] = new $ connection Class ( $ options ) ; if ( $ this - > _key Distributor ) { $ this - > _key Distributor - > add Connection ( $ connection String , isset ( $ options [ 'weight ' ] ) ? $ options [ 'weight ' ] : Rediska _Connection : : DEFAULT _WEIGHT ) ; } return $ this ; } 
public function remove Server ( $ alias Or Connection ) { if ( $ alias Or Connection instanceof Rediska _Connection ) { $ alias = $ alias Or Connection - > get Alias ( ) ; } if ( ! isset ( $ this - > _connections [ $ alias ] ) ) { throw new Rediska _Exception ( "Can 't find connection ' $alias ' " ) ; } unset ( $ this - > _connections [ $ alias ] ) ; if ( $ this - > _key Distributor ) { $ this - > _key Distributor - > remove Connection ( $ alias ) ; } return $ this ; } 
public function get Connection By Key Name ( $ name ) { if ( $ this - > _specified Connection - > get Connection ( ) ) { $ connection = $ this - > _specified Connection - > get Connection ( ) ; } elseif ( count ( $ this - > _connections ) = = 1 ) { $ connections = array _values ( $ this - > _connections ) ; $ connection = $ connections [ 0 ] ; } else { $ alias = $ this - > _key Distributor - > get Connection By Key Name ( $ name ) ; $ connection = $ this - > _connections [ $ alias ] ; } return $ connection ; } 
public function get Connection By Alias ( $ alias ) { if ( ! isset ( $ this - > _connections [ $ alias ] ) ) { throw new Rediska _Exception ( "Can 't find connection ' $alias ' " ) ; } return $ this - > _connections [ $ alias ] ; } 
public function get Connections ( ) { if ( $ this - > _specified Connection - > get Connection ( ) ) { return array ( $ this - > _specified Connection - > get Connection ( ) ) ; } else { return array _values ( $ this - > _connections ) ; } } 
public function on ( $ alias Or Connection ) { if ( $ alias Or Connection instanceof Rediska _Connection ) { $ connection = $ alias Or Connection ; } else { $ alias = $ alias Or Connection ; $ connection = $ this - > get Connection By Alias ( $ alias ) ; } $ this - > _specified Connection - > set Connection ( $ connection ) ; return $ this - > _specified Connection ; } 
public function transaction ( $ alias Or Connection = null ) { if ( $ alias Or Connection instanceof Rediska _Connection ) { $ connection = $ alias Or Connection ; } elseif ( $ alias Or Connection ! = = null ) { $ connection = $ this - > get Connection By Alias ( $ alias Or Connection ) ; } elseif ( $ this - > _specified Connection - > get Connection ( ) ) { $ connection = $ this - > _specified Connection - > get Connection ( ) ; } else { $ connections = $ this - > get Connections ( ) ; if ( count ( $ connections ) = = 1 ) { $ connection = $ connections [ 0 ] ; } else { throw new Rediska _Transaction _Exception ( 'You must specify connection by $alias Or Connection argument ! ' ) ; } } return new Rediska _Transaction ( $ this , $ this - > _specified Connection , $ connection ) ; } 
public function subscribe ( $ channel Or Channels , $ timeout = null ) { return new Rediska _Pub Sub _Channel ( $ channel Or Channels , array ( 'rediska ' = > $ this , 'timeout ' = > $ timeout , 'server Alias ' = > $ this - > _specified Connection - > get Connection ( ) ) ) ; } 
public function config ( $ alias Or Connection = null ) { if ( $ alias Or Connection instanceof Rediska _Connection ) { $ connection = $ alias Or Connection ; } elseif ( $ alias Or Connection ! = = null ) { $ connection = $ this - > get Connection By Alias ( $ alias Or Connection ) ; } elseif ( $ this - > _specified Connection - > get Connection ( ) ) { $ connection = $ this - > _specified Connection - > get Connection ( ) ; } else { $ connections = $ this - > get Connections ( ) ; if ( count ( $ connections ) = = 1 ) { $ connection = $ connections [ 0 ] ; } else { throw new Rediska _Transaction _Exception ( 'You must specify connection by $alias Or Connection argument ! ' ) ; } } return new Rediska _Config ( $ this , $ connection ) ; } 
public function set Key Distributor ( $ name ) { $ this - > _options [ 'key Distributor ' ] = $ name ; if ( is _object ( $ name ) ) { $ this - > _key Distributor = $ name ; } else if ( in _array ( $ name , array ( 'crc 3 2 ' , 'consistent Hashing ' ) ) ) { $ name = ucfirst ( $ name ) ; $ class Name = "Rediska _Key Distributor _ $name " ; $ this - > _key Distributor = new $ class Name ; } else { if ( ! @ class _exists ( $ name ) ) { throw new Rediska _Exception ( "Key distributor ' $name ' not found . You need include it before or setup autoload . " ) ; } $ this - > _key Distributor = new $ name ; } if ( ! $ this - > _key Distributor instanceof Rediska _Key Distributor _Interface ) { throw new Rediska _Exception ( " ' $name ' must implement Rediska _Key Distributor _Interface " ) ; } 
public function get Serializer ( ) { if ( $ this - > _serializer = = = null ) { $ this - > _serializer = new Rediska _Serializer ( $ this - > _options [ 'serializer Adapter ' ] ) ; } return $ this - > _serializer ; } 
public function get Profiler ( ) { if ( ! $ this - > _profiler ) { if ( is _string ( $ this - > _options [ 'profiler ' ] ) ) { $ this - > _options [ 'profiler ' ] = array ( 'name ' = > $ this - > _options [ 'profiler ' ] ) ; } if ( $ this - > _options [ 'profiler ' ] = = = false ) { $ this - > _profiler = new Rediska _Profiler _Null ( ) ; } else if ( $ this - > _options [ 'profiler ' ] = = = true ) { $ this - > _profiler = new Rediska _Profiler ( ) ; } else if ( is _array ( $ this - > _options [ 'profiler ' ] ) ) { if ( ! isset ( $ this - > _options [ 'profiler ' ] [ 'name ' ] ) ) { throw new Rediska _Exception ( "You must specify profiler 'name ' . " ) ; } else if ( in _array ( $ this - > _options [ 'profiler ' ] [ 'name ' ] , array ( 'stream ' ) ) ) { $ name = ucfirst ( $ this - > _options [ 'profiler ' ] [ 'name ' ] ) ; $ class Name = "Rediska _Profiler _ $name " ; $ options = $ this - > _options [ 'profiler ' ] ; unset ( $ options [ 'name ' ] ) ; $ this - > _profiler = new $ class Name ( $ options ) ; } else if ( @ class _exists ( $ this - > _options [ 'profiler ' ] [ 'name ' ] ) ) { $ class Name = $ this - > _options [ 'profiler ' ] [ 'name ' ] ; $ options = $ this - > _options [ 'profiler ' ] ; unset ( $ options [ 'name ' ] ) ; $ this - > _profiler = new $ class Name ( $ options ) ; } else { throw new Rediska _Exception ( "Profiler ' { $this - > _options [ 'profiler ' ] [ 'name ' ] } ' not found . You need include it before or setup autoload . " ) ; } } elseif ( is _object ( $ this - > _options [ 'profiler ' ] ) ) { $ this - > _profiler = $ this - > _options [ 'profiler ' ] ; } else { throw new Rediska _Exception ( "Profiler option must be a boolean , object or array of options " ) ; } if ( ! $ this - > _profiler instanceof Rediska _Profiler _Interface ) { $ profiler Class = get _class ( $ this - > _profiler ) ; throw new Rediska _Serializer _Exception ( "Profiler ' $profiler Class ' must implement Rediska _Profiler _Interface " ) ; } } return $ this - > _profiler ; } 
protected function _execute Command ( $ name , $ args = array ( ) ) { $ this - > _specified Connection - > reset Connection ( ) ; $ command = Rediska _Commands : : get ( $ this , $ name , $ args ) ; $ this - > get Profiler ( ) - > start ( $ command ) ; $ response = $ command - > execute ( ) ; $ this - > get Profiler ( ) - > stop ( ) ; unset ( $ command ) ; return $ response ; } 
public function create ( $ key , $ field Or Fields ) { if ( is _array ( $ field Or Fields ) ) { $ this - > _fields = array _values ( $ field Or Fields ) ; if ( empty ( $ this - > _fields ) ) { throw new Rediska _Command _Exception ( 'Not present fields ' ) ; } $ command = array _merge ( array ( 'HMGET ' , $ this - > _rediska - > get Option ( 'namespace ' ) . $ key ) , $ this - > _fields ) ; } else { $ field = $ field Or Fields ; $ command = array ( 'HGET ' , $ this - > _rediska - > get Option ( 'namespace ' ) . $ key , $ field ) ; } $ connection = $ this - > _rediska - > get Connection By Key Name ( $ key ) ; return new Rediska _Connection _Exec ( $ connection , $ command ) ; } 
public function parse Response ( $ response ) { if ( ! empty ( $ this - > _fields ) ) { $ result = array ( ) ; $ fields Count = count ( $ this - > _fields ) ; for ( $ i = 0 ; $ i < $ fields Count ; $ i + + ) { $ result [ $ this - > _fields [ $ i ] ] = $ this - > _rediska - > get Serializer ( ) - > unserialize ( $ response [ $ i ] ) ; } return $ result ; } else { return $ this - > _rediska - > get Serializer ( ) - > unserialize ( $ response ) ; } } 
public static function add ( $ name , $ class Name ) { if ( ! class _exists ( $ class Name ) ) { throw new Rediska _Exception ( "Class ' $class Name ' not found . You must include before or setup autoload " ) ; } $ class Reflection = new Reflection Class ( $ class Name ) ; if ( ! in _array ( 'Rediska _Command _Interface ' , $ class Reflection - > get Interface Names ( ) ) ) { throw new Rediska _Exception ( "Class ' $class Name ' must implement Rediska _Command _Interface interface " ) ; } $ lower Name = strtolower ( $ name ) ; self : : $ _commands [ $ lower Name ] = $ class Name ; return true ; } 
public static function remove ( $ name ) { $ lower Name = self : : _get Command Lower Name And Throw If Not Present ( $ name ) ; unset ( self : : $ _commands [ $ lower Name ] ) ; return true ; } 
public static function get ( Rediska $ rediska , $ name , $ arguments ) { $ lower Name = self : : _get Command Lower Name And Throw If Not Present ( $ name ) ; return new self : : $ _commands [ $ lower Name ] ( $ rediska , $ name , $ arguments ) ; } 
protected static function _get Command Lower Name And Throw If Not Present ( $ name ) { $ lower Name = strtolower ( $ name ) ; if ( ! isset ( self : : $ _commands [ $ lower Name ] ) ) { throw new Rediska _Exception ( "Command ' $name ' not found " ) ; } return $ lower Name ; } 
public function execute ( ) { $ results = array ( ) ; if ( ! empty ( $ this - > _commands ) ) { $ this - > _rediska - > get Profiler ( ) - > start ( $ this ) ; foreach ( $ this - > _commands as $ command ) { $ command - > write ( ) ; } foreach ( $ this - > _commands as $ command ) { $ results [ ] = $ command - > read ( ) ; } $ this - > _rediska - > get Profiler ( ) - > stop ( ) ; } return $ results ; } 
protected function _add Command ( $ name , $ args = array ( ) ) { if ( $ this - > _one Time Connection ) { $ connection = $ this - > _one Time Connection ; $ this - > _one Time Connection = null ; } else { $ connection = $ this - > _default Connection ; } if ( $ connection ! = = null ) { $ this - > _specified Connection - > set Connection ( $ connection ) ; } else { $ this - > _specified Connection - > reset Connection ( ) ; } $ command = Rediska _Commands : : get ( $ this - > _rediska , $ name , $ args ) ; $ command - > initialize ( ) ; if ( ! $ command - > is Atomic ( ) ) { throw new Rediska _Exception ( "Command ' $name ' doesn 't work properly (not atomic ) in pipeline on multiple servers " ) ; } $ this - > _commands [ ] = $ command ; $ this - > _specified Connection - > reset Connection ( ) ; return $ this ; } 
public function create ( $ from Key , $ to Key , $ member ) { $ from Key Connection = $ this - > _rediska - > get Connection By Key Name ( $ from Key ) ; $ to Key Connection = $ this - > _rediska - > get Connection By Key Name ( $ to Key ) ; $ member = $ this - > _rediska - > get Serializer ( ) - > serialize ( $ member ) ; if ( $ from Key Connection = = = $ to Key Connection ) { $ command = array ( 'SMOVE ' , $ this - > _rediska - > get Option ( 'namespace ' ) . $ from Key , $ this - > _rediska - > get Option ( 'namespace ' ) . $ to Key , $ member ) ; } else { $ this - > set Atomic ( false ) ; $ command = array ( 'SISMEMBER ' , $ this - > _rediska - > get Option ( 'namespace ' ) . $ from Key , $ member ) ; } return new Rediska _Connection _Exec ( $ from Key Connection , $ command ) ; } 
public function parse Responses ( $ responses ) { if ( ! $ this - > is Atomic ( ) ) { if ( $ responses [ 0 ] ) { $ this - > _rediska - > delete From Set ( $ this - > from Key , $ this - > member ) ; return $ this - > _rediska - > add To Set ( $ this - > to Key , $ this - > member ) ; } else { return false ; } } else { return ( boolean ) $ responses [ 0 ] ; } } 
public function get Command ( $ timeout = null ) { if ( ! $ timeout & & $ this - > get Timeout ( ) ) { $ timeout = $ this - > get Timeout ( ) ; } 
protected function _get Response From Connection ( Rediska _Connection $ connection ) { $ response = Rediska _Connection _Exec : : read Response From Connection ( $ connection ) ; if ( $ response = = = null | | $ response = = = true ) { return null ; } $ timestamp And Command = explode ( ' ' , $ response , 2 ) ; $ command = $ timestamp And Command [ 1 ] ; if ( $ command = = ' "MONITOR " ' ) { return null ; } return $ timestamp And Command ; } 
public function create ( ) { $ command = array ( 'LASTSAVE ' ) ; $ commands = array ( ) ; foreach ( $ this - > _rediska - > get Connections ( ) as $ connection ) { $ this - > _connections [ ] = $ connection - > get Alias ( ) ; $ commands [ ] = new Rediska _Connection _Exec ( $ connection , $ command ) ; } return $ commands ; } 
public function parse Responses ( $ responses ) { $ timestamps = array ( ) ; $ count = 0 ; foreach ( $ this - > _connections as $ connection ) { $ timestamps [ $ connection ] = $ responses [ $ count ] ; $ count + + ; } if ( count ( $ timestamps ) = = 1 ) { $ timestamps = array _values ( $ timestamps ) ; $ timestamps = $ timestamps [ 0 ] ; } return $ timestamps ; } 
public function write ( ) { $ result = $ this - > get Connection ( ) - > write ( $ this - > get Command ( ) ) ; $ this - > _is Written = true ; return $ result ; } 
public function read ( ) { if ( ! $ this - > is Written ( ) ) { throw new Rediska _Connection _Exec _Exception ( 'You must write command before read ' ) ; } $ this - > _is Written = false ; if ( $ this - > get Response Iterator ( ) ! = = null ) { if ( $ this - > get Response Iterator ( ) = = = true ) { $ class Name = 'Rediska _Connection _Exec _Multi Bulk Iterator ' ; } else { $ class Name = $ this - > get Response Iterator ( ) ; } $ response = new $ class Name ( $ this - > get Connection ( ) , $ this - > get Response Callback ( ) ) ; } else { $ response = self : : read Response From Connection ( $ this - > get Connection ( ) ) ; if ( $ this - > _response Callback ! = = null ) { $ response = call _user _func ( $ this - > get Response Callback ( ) , $ response ) ; } } return $ response ; } 
public function get Connection ( ) { if ( $ this - > _response Iterator = = = null ) { return $ this - > _connection ; } else { if ( $ this - > _connection Clone = = = null ) { $ this - > _connection Clone = clone $ this - > _connection ; } return $ this - > _connection Clone ; } return $ this - > _connection ; } 
public function set Response Callback ( $ callback ) { if ( $ callback ! = = null & & ! is _callable ( $ callback ) ) { throw new Rediska _Connection _Exec _Exception ( 'Bad callback ' ) ; } $ this - > _response Callback = $ callback ; return $ this ; } 
public static function transform Multi Bulk Command ( array $ command ) { $ command String = self : : REPLY _MULTY _BULK . count ( $ command ) . Rediska : : EOL ; foreach ( $ command as $ argument ) { $ command String . = self : : REPLY _BULK . strlen ( $ argument ) . Rediska : : EOL . $ argument . Rediska : : EOL ; } return $ command String ; } 
public static function read Response From Connection ( Rediska _Connection $ connection ) { $ reply = $ connection - > read Line ( ) ; if ( $ reply = = = null ) { return $ reply ; } $ type = substr ( $ reply , 0 , 1 ) ; $ data = substr ( $ reply , 1 ) ; switch ( $ type ) { case self : : REPLY _STATUS : if ( $ data = = 'OK ' ) { return true ; } else { return $ data ; } case self : : REPLY _ERROR : throw new Rediska _Connection _Exec _Exception ( $ data ) ; case self : : REPLY _INTEGER : if ( strpos ( $ data , ' . ' ) ! = = false ) { $ number = ( integer ) $ data ; } else { $ number = ( float ) $ data ; } return $ number ; case self : : REPLY _BULK : if ( $ data = = ' - 1 ' ) { return null ; } else { $ length = ( integer ) $ data ; return $ connection - > read ( $ length ) ; } case self : : REPLY _MULTY _BULK : $ count = ( integer ) $ data ; $ replies = array ( ) ; for ( $ i = 0 ; $ i < $ count ; $ i + + ) { $ replies [ ] = self : : read Response From Connection ( $ connection ) ; } return $ replies ; default : throw new Rediska _Connection _Exec _Exception ( "Invalid reply type : ' $type ' " ) ; } } 
public function stop Callback ( Rediska _Profiler _Profile $ profile ) { $ command String = $ profile - > get Context ( ) - > _ _to String ( ) ; $ matches = array ( ) ; preg _match ( ' / ^ ( . + ) \ ( ( . * ) \ ) $ /s ' , $ command String , $ matches ) ; $ row = array ( ( double ) $ profile - > get Elapsed Time ( 4 ) ) ; if ( isset ( $ matches [ 1 ] ) ) { $ row [ ] = $ matches [ 1 ] ; $ row [ ] = $ matches [ 2 ] ; } else { $ row [ ] = $ command String ; } $ this - > get Message ( ) - > add Row ( $ row ) ; $ place Holders = array ( ' %rediska Name % ' = > $ profile - > get Context ( ) - > get Rediska ( ) - > get Name ( ) , ' %count % ' = > $ this - > count ( ) , ' %total Elapsed Time % ' = > $ this - > get Total Elapsed Time ( 4 ) , ) ; $ label = str _replace ( array _keys ( $ place Holders ) , array _values ( $ place Holders ) , $ this - > get Label ( ) ) ; $ this - > get Message ( ) - > set Label ( $ label ) ; } 
public function append ( $ value , $ create If Not Exists = true ) { $ result = $ this - > _get Rediska On ( ) - > append To List ( $ this - > get Name ( ) , $ value , $ create If Not Exists ) ; if ( ! is _null ( $ this - > get Expire ( ) ) & & $ result ) { $ this - > expire ( $ this - > get Expire ( ) , $ this - > is Expire Timestamp ( ) ) ; } return $ result ; } 
public function prepend ( $ value , $ create If Not Exists = true ) { $ result = $ this - > _get Rediska On ( ) - > prepend To List ( $ this - > get Name ( ) , $ value , $ create If Not Exists ) ; if ( ! is _null ( $ this - > get Expire ( ) ) & & $ result ) { $ this - > expire ( $ this - > get Expire ( ) , $ this - > is Expire Timestamp ( ) ) ; } return $ result ; } 
public function truncate ( $ start , $ end ) { $ result = $ this - > _get Rediska On ( ) - > truncate List ( $ this - > get Name ( ) , $ start , $ end ) ; if ( ! is _null ( $ this - > get Expire ( ) ) & & $ result ) { $ this - > expire ( $ this - > get Expire ( ) , $ this - > is Expire Timestamp ( ) ) ; } return $ result ; } 
public function set ( $ index , $ value ) { $ result = $ this - > _get Rediska On ( ) - > set To List ( $ this - > get Name ( ) , $ index , $ value ) ; if ( ! is _null ( $ this - > get Expire ( ) ) & & $ result ) { $ this - > expire ( $ this - > get Expire ( ) , $ this - > is Expire Timestamp ( ) ) ; } return $ result ; } 
public function insert After ( $ reference Value , $ value ) { return $ this - > _get Rediska On ( ) - > insert To List After ( $ this - > get Name ( ) , $ reference Value , $ value ) ; } 
public function insert Before ( $ reference Value , $ value ) { return $ this - > _get Rediska On ( ) - > insert To List Before ( $ this - > get Name ( ) , $ reference Value , $ value ) ; } 
public function insert ( $ position , $ reference Value , $ value ) { return $ this - > _get Rediska On ( ) - > insert To List ( $ this - > get Name ( ) , $ position , $ reference Value , $ value ) ; } 
public function remove ( $ value , $ count = 0 ) { $ result = $ this - > _get Rediska On ( ) - > delete From List ( $ this - > get Name ( ) , $ value , $ count ) ; if ( ! is _null ( $ this - > get Expire ( ) ) & & $ result ) { $ this - > expire ( $ this - > get Expire ( ) , $ this - > is Expire Timestamp ( ) ) ; } return $ result ; } 
public function shift ( ) { $ result = $ this - > _get Rediska On ( ) - > shift From List ( $ this - > get Name ( ) ) ; if ( ! is _null ( $ this - > get Expire ( ) ) & & $ result ) { $ this - > expire ( $ this - > get Expire ( ) , $ this - > is Expire Timestamp ( ) ) ; } return $ result ; } 
public function shift Blocking ( $ timeout = 0 ) { $ result = $ this - > _get Rediska On ( ) - > shift From List Blocking ( $ this - > get Name ( ) , $ timeout ) ; if ( ! is _null ( $ this - > get Expire ( ) ) & & $ result ) { $ this - > expire ( $ this - > get Expire ( ) , $ this - > is Expire Timestamp ( ) ) ; } return $ result ; } 
public function pop ( $ push To = null ) { if ( $ push To instanceof Rediska _Key _List ) { $ push To = $ push To - > get Name ( ) ; } $ result = $ this - > _get Rediska On ( ) - > pop From List ( $ this - > get Name ( ) , $ push To ) ; if ( ! is _null ( $ this - > get Expire ( ) ) & & $ result ) { $ this - > expire ( $ this - > get Expire ( ) , $ this - > is Expire Timestamp ( ) ) ; } return $ result ; } 
public function pop Blocking ( $ timeout = 0 , $ push To Key = null ) { $ result = $ this - > _get Rediska On ( ) - > pop From List Blocking ( $ this - > get Name ( ) , $ timeout , $ push To Key ) ; if ( ! is _null ( $ this - > get Expire ( ) ) & & $ result ) { $ this - > expire ( $ this - > get Expire ( ) , $ this - > is Expire Timestamp ( ) ) ; } return $ result ; } 
public function get Values ( $ start = 0 , $ end = - 1 , $ response Iterator = false ) { return $ this - > _get Rediska On ( ) - > get List ( $ this - > get Name ( ) , $ start , $ end , $ response Iterator ) ; } 
public function to Array ( $ start = 0 , $ end = - 1 , $ response Iterator = false ) { return $ this - > get Values ( $ start , $ end , $ response Iterator ) ; } 
public function from Array ( array $ array ) { $ pipeline = $ this - > _get Rediska On ( ) - > pipeline ( ) ; foreach ( $ array as $ item ) { $ pipeline - > append To List ( $ this - > get Name ( ) , $ item ) ; } if ( ! is _null ( $ this - > get Expire ( ) ) ) { $ pipeline - > expire ( $ this - > get Name ( ) , $ this - > get Expire ( ) , $ this - > is Expire Timestamp ( ) ) ; } $ pipeline - > execute ( ) ; return true ; } 
public function create ( $ key , $ with Scores = false , $ start = 0 , $ end = - 1 , $ revert = false , $ response Iterator = false ) { $ connection = $ this - > _rediska - > get Connection By Key Name ( $ key ) ; $ command = array ( $ revert ? 'ZREVRANGE ' : 'ZRANGE ' , $ this - > _rediska - > get Option ( 'namespace ' ) . $ key , $ start , $ end ) ; if ( $ with Scores ) { $ command [ ] = 'WITHSCORES ' ; } $ exec = new Rediska _Connection _Exec ( $ connection , $ command ) ; if ( $ response Iterator ) { if ( $ with Scores ) { $ response Iterator = 'Rediska _Command _Get Sorted Set _With Scores Iterator ' ; } $ exec - > set Response Iterator ( $ response Iterator ) ; $ exec - > set Response Callback ( array ( $ this , 'parse Iterator Response ' ) ) ; } return $ exec ; } 
public function load ( $ id , $ do Not Test Cache Validity = false ) { $ id = ( array ) $ id ; foreach ( $ id as $ key ) { $ key = $ this - > _options [ 'storage ' ] [ 'prefix _key ' ] . $ key ; $ this - > _get Transaction By Key ( $ key ) - > get From Hash ( $ key , self : : FIELD _DATA ) ; } $ old Serializaer Adapter = $ this - > get Rediska ( ) - > get Serializer ( ) - > get Adapter ( ) ; $ this - > get Rediska ( ) - > set Serializer Adapter ( 'to String ' ) ; $ result = $ this - > _exec Transactions ( ) ; $ this - > get Rediska ( ) - > get Serializer ( ) - > set Adapter ( $ old Serializaer Adapter ) ; if ( count ( $ result ) = = 1 ) { if ( null = = = ( $ result = array _shift ( $ result ) ) ) { return false ; } else { return $ result ; } } else { return $ result ; } } 
public function save ( $ data , $ id , $ tags = array ( ) , $ specific Lifetime = false ) { if ( ! is _array ( $ tags ) ) $ tags = array ( $ tags ) ; $ lifetime = $ this - > get Lifetime ( $ specific Lifetime ) ; $ old Tags = explode ( ' , ' , $ this - > get Rediska ( ) - > get From Hash ( $ this - > _options [ 'storage ' ] [ 'prefix _key ' ] . $ id , self : : FIELD _TAGS ) ) ; $ this - > _get Transaction By Key ( $ this - > _options [ 'storage ' ] [ 'prefix _key ' ] . $ id ) - > set To Hash ( $ this - > _options [ 'storage ' ] [ 'prefix _key ' ] . $ id , array ( self : : FIELD _DATA = > $ data , self : : FIELD _TAGS = > implode ( ' , ' , $ tags ) , self : : FIELD _MTIME = > time ( ) , self : : FIELD _INF = > $ lifetime ? 0 : 1 ) ) ; $ this - > _get Transaction By Key ( $ this - > _options [ 'storage ' ] [ 'prefix _key ' ] . $ id ) - > expire ( $ this - > _options [ 'storage ' ] [ 'prefix _key ' ] . $ id , $ lifetime ? $ lifetime : self : : MAX _LIFETIME ) ; if ( $ add Tags = ( $ old Tags ? array _diff ( $ tags , $ old Tags ) : $ tags ) ) { foreach ( $ add Tags as $ add ) { $ this - > _get Transaction By Key ( $ this - > _options [ 'storage ' ] [ 'set _tags ' ] ) - > add To Set ( $ this - > _options [ 'storage ' ] [ 'set _tags ' ] , $ add ) ; } foreach ( $ add Tags as $ tag ) { $ this - > _get Transaction By Key ( $ this - > _options [ 'storage ' ] [ 'prefix _tag _ids ' ] . $ tag ) - > add To Set ( $ this - > _options [ 'storage ' ] [ 'prefix _tag _ids ' ] . $ tag , $ id ) ; } } if ( $ rem Tags = ( $ old Tags ? array _diff ( $ old Tags , $ tags ) : false ) ) { foreach ( $ rem Tags as $ tag ) { $ this - > _get Transaction By Key ( $ this - > _options [ 'storage ' ] [ 'prefix _tag _ids ' ] . $ tag ) - > delete From Set ( $ this - > _options [ 'storage ' ] [ 'prefix _tag _ids ' ] . $ tag , $ id ) ; } } $ this - > _get Transaction By Key ( $ this - > _options [ 'storage ' ] [ 'set _ids ' ] ) - > add To Set ( $ this - > _options [ 'storage ' ] [ 'set _ids ' ] , $ id ) ; try { $ this - > _exec Transactions ( ) ; return true ; } catch ( Rediska _Transaction _Exception $ e ) { $ this - > _log ( $ e - > get Message ( ) , Zend _Log : : ERR ) ; return false ; } } 
public function remove ( $ id ) { $ tags = explode ( ' , ' , $ this - > get Rediska ( ) - > get From Hash ( $ this - > _options [ 'storage ' ] [ 'prefix _key ' ] . $ id , self : : FIELD _TAGS ) ) ; $ this - > _get Transaction By Key ( $ this - > _options [ 'storage ' ] [ 'prefix _key ' ] . $ id ) - > delete ( $ this - > _options [ 'storage ' ] [ 'prefix _key ' ] . $ id ) ; $ this - > _get Transaction By Key ( $ this - > _options [ 'storage ' ] [ 'set _ids ' ] , $ id ) - > delete From Set ( $ this - > _options [ 'storage ' ] [ 'set _ids ' ] , $ id ) ; foreach ( $ tags as $ tag ) { $ this - > _get Transaction By Key ( $ this - > _options [ 'storage ' ] [ 'prefix _tag _ids ' ] . $ tag ) - > delete From Set ( $ this - > _options [ 'storage ' ] [ 'prefix _tag _ids ' ] . $ tag , $ id ) ; } $ result = $ this - > _exec Transactions ( ) ; if ( count ( $ result ) ) { return array _shift ( $ result ) ; } else { return false ; } } 
public function clean ( $ mode = Zend _Cache : : CLEANING _MODE _ALL , $ tags = array ( ) ) { if ( $ tags & & ! is _array ( $ tags ) ) { $ tags = array ( $ tags ) ; } $ result = true ; switch ( $ mode ) { case Zend _Cache : : CLEANING _MODE _ALL : $ this - > _remove Ids ( $ this - > get Ids ( ) ) ; break ; case Zend _Cache : : CLEANING _MODE _OLD : break ; case Zend _Cache : : CLEANING _MODE _MATCHING _TAG : $ this - > _remove Ids By Matching Tags ( $ tags ) ; break ; case Zend _Cache : : CLEANING _MODE _NOT _MATCHING _TAG : $ this - > _remove Ids By Not Matching Tags ( $ tags ) ; break ; case Zend _Cache : : CLEANING _MODE _MATCHING _ANY _TAG : $ this - > _remove Ids By Matching Any Tags ( $ tags ) ; break ; default : Zend _Cache : : throw Exception ( 'Invalid mode for clean ( ) method : ' . $ mode ) ; } return $ this - > _collect Garbage ( ) ; } 
public function set Directives ( $ directives ) { parent : : set Directives ( $ directives ) ; $ lifetime = $ this - > get Lifetime ( false ) ; if ( $ lifetime > self : : MAX _LIFETIME ) { $ this - > _log ( 'redis backend has a limit of 3 0 days ( ' . self : : MAX _LIFETIME . ' seconds ) for the lifetime ' ) ; } } 
public function get Ids Not Matching Tags ( $ tags = array ( ) ) { $ sets = $ this - > _preprocess Tag Ids ( $ tags ) ; array _unshift ( $ sets , $ this - > _options [ 'storage ' ] [ 'set _ids ' ] ) ; $ data = $ this - > get Rediska ( ) - > diff Sets ( $ sets ) ; return $ data ; } 
public function get Metadatas ( $ id ) { $ meta Data = $ this - > get Rediska ( ) - > get From Hash ( $ this - > _options [ 'storage ' ] [ 'prefix _key ' ] . $ id , array ( self : : FIELD _DATA , self : : FIELD _TAGS , self : : FIELD _MTIME , self : : FIELD _INF ) ) ; if ( ! $ meta Data [ self : : FIELD _MTIME ] ) { return false ; } $ lifetime = $ this - > get Rediska ( ) - > get Lifetime ( $ this - > _options [ 'storage ' ] [ 'prefix _key ' ] . $ id ) ; $ tags = explode ( ' , ' , $ meta Data [ self : : FIELD _TAGS ] ) ; $ expire = $ meta Data [ self : : FIELD _INF ] = = = ' 1 ' ? false : time ( ) + $ lifetime ; return array ( 'expire ' = > $ expire , 'tags ' = > $ tags , 'mtime ' = > $ meta Data [ self : : FIELD _MTIME ] , ) ; } 
public function touch ( $ id , $ extra Lifetime ) { $ data = $ this - > get Rediska ( ) - > get From Hash ( $ this - > _options [ 'storage ' ] [ 'prefix _key ' ] . $ id , array ( self : : FIELD _INF ) ) ; $ lifetime = $ this - > get Rediska ( ) - > get Lifetime ( $ this - > _options [ 'storage ' ] [ 'prefix _key ' ] . $ id ) ; if ( $ data [ self : : FIELD _INF ] = = = 0 ) { $ expire At = time ( ) + $ lifetime + $ extra Lifetime ; return ( bool ) $ this - > get Rediska ( ) - > expire ( $ this - > _options [ 'storage ' ] [ 'prefix _key ' ] . $ id , $ expire At , true ) ; } return false ; } 
protected function _collect Garbage ( ) { $ exists = array ( ) ; $ tags = $ this - > get Tags ( ) ; foreach ( $ tags as $ tag ) { $ prefix _tag _ids = $ this - > _options [ 'storage ' ] [ 'prefix _tag _ids ' ] . $ tag ; $ tag Members = $ this - > get Rediska ( ) - > get Set ( $ prefix _tag _ids ) ; $ this - > _get Transaction By Key ( $ prefix _tag _ids ) - > watch ( $ prefix _tag _ids ) ; $ expired = array ( ) ; if ( count ( $ tag Members ) ) { foreach ( $ tag Members as $ id ) { if ( ! isset ( $ exists [ $ id ] ) ) { $ exists [ $ id ] = $ this - > get Rediska ( ) - > exists ( $ this - > _options [ 'storage ' ] [ 'prefix _key ' ] . $ id ) ; } if ( ! $ exists [ $ id ] ) { $ expired [ ] = $ id ; } } if ( ! count ( $ expired ) ) continue ; } if ( ! count ( $ tag Members ) | | count ( $ expired ) = = count ( $ tag Members ) ) { $ this - > _get Transaction By Key ( $ this - > _options [ 'storage ' ] [ 'set _tags ' ] ) - > delete From Set ( $ this - > _options [ 'storage ' ] [ 'set _tags ' ] , $ tag ) ; $ this - > _get Transaction By Key ( $ this - > _options [ 'storage ' ] [ 'prefix _tag _ids ' ] . $ tag ) - > delete ( $ this - > _options [ 'storage ' ] [ 'prefix _tag _ids ' ] . $ tag ) ; } else { $ this - > _get Transaction By Key ( $ this - > _options [ 'storage ' ] [ 'prefix _tag _ids ' ] . $ tag ) - > delete From Set ( $ this - > _options [ 'storage ' ] [ 'prefix _tag _ids ' ] . $ tag , $ expired ) ; } $ this - > _get Transaction By Key ( $ this - > _options [ 'storage ' ] [ 'set _ids ' ] ) - > delete From Set ( $ this - > _options [ 'storage ' ] [ 'set _ids ' ] , $ expired ) ; } try { return ( bool ) $ this - > _exec Transactions ( ) ; } catch ( Rediska _Transaction _Aborted Exception $ e ) { $ this - > _log ( $ e - > get Message ( ) , Zend _Log : : ERR ) ; return false ; } } 
protected function _get Transaction By Key ( $ key ) { $ connection = $ this - > get Rediska ( ) - > get Connection By Key Name ( $ key ) ; if ( ! $ this - > _transaction [ $ connection - > get Alias ( ) ] ) { $ this - > _transaction [ $ connection - > get Alias ( ) ] = $ this - > get Rediska ( ) - > transaction ( $ connection ) ; } return $ this - > _transaction [ $ connection - > get Alias ( ) ] ; } 
public function create ( $ key Or Data , $ value Or Overwrite = null , $ overwrite = true ) { if ( is _array ( $ key Or Data ) ) { $ this - > _throw Exception If Not Supported ( ' 1 . 1 ' ) ; $ this - > _multiple = true ; $ data = $ key Or Data ; $ overwrite = ( $ value Or Overwrite = = = null | | $ value Or Overwrite ) ; if ( empty ( $ data ) ) { throw new Rediska _Command _Exception ( 'Not present keys and values for set ' ) ; } $ connections = array ( ) ; $ keys By Connections = array ( ) ; foreach ( $ data as $ key = > $ value ) { $ connection = $ this - > _rediska - > get Connection By Key Name ( $ key ) ; $ connection Alias = $ connection - > get Alias ( ) ; if ( ! array _key _exists ( $ connection Alias , $ connections ) ) { $ connections [ $ connection Alias ] = $ connection ; $ keys By Connections [ $ connection Alias ] = array ( ) ; } $ keys By Connections [ $ connection Alias ] [ $ key ] = $ value ; } $ commands = array ( ) ; $ namespace = $ this - > _rediska - > get Option ( 'namespace ' ) ; foreach ( $ keys By Connections as $ connection Alias = > $ data ) { $ command = array ( $ overwrite ? 'MSET ' : 'MSETNX ' ) ; foreach ( $ data as $ key = > $ value ) { $ command [ ] = $ namespace . $ key ; $ command [ ] = $ this - > _rediska - > get Serializer ( ) - > serialize ( $ value ) ; } $ commands [ ] = new Rediska _Connection _Exec ( $ connections [ $ connection Alias ] , $ command ) ; } return $ commands ; } else { $ key = $ key Or Data ; $ value = $ value Or Overwrite ; $ connection = $ this - > _rediska - > get Connection By Key Name ( $ key ) ; $ value = $ this - > _rediska - > get Serializer ( ) - > serialize ( $ value ) ; $ command = array ( $ overwrite ? 'SET ' : 'SETNX ' , $ this - > _rediska - > get Option ( 'namespace ' ) . $ key , $ value ) ; return new Rediska _Connection _Exec ( $ connection , $ command ) ; } } 
public function parse Responses ( $ responses ) { if ( $ this - > _multiple ) { if ( ! empty ( $ responses ) ) { foreach ( $ responses as $ response ) { if ( ! $ response ) { return false ; } } return true ; } else { return false ; } } else { return ( boolean ) $ responses [ 0 ] ; } } 
public function create ( $ key Or Keys , $ timeout = 0 ) { if ( ! is _array ( $ key Or Keys ) ) { $ keys = array ( $ key Or Keys ) ; } elseif ( ! empty ( $ key Or Keys ) ) { $ keys = $ key Or Keys ; } else { throw new Rediska _Command _Exception ( 'Not present keys for shift ' ) ; } $ connections = array ( ) ; $ keys By Connections = array ( ) ; foreach ( $ keys as $ key ) { $ connection = $ this - > _rediska - > get Connection By Key Name ( $ key ) ; $ connection Alias = $ connection - > get Alias ( ) ; if ( ! array _key _exists ( $ connection Alias , $ connections ) ) { $ connections [ $ connection Alias ] = $ connection ; $ keys By Connections [ $ connection Alias ] = array ( ) ; } $ keys By Connections [ $ connection Alias ] [ ] = $ key ; } 
public function parse Response ( $ response ) { if ( ! is _array ( $ this - > key Or Keys ) & & ! empty ( $ response ) ) { $ result = $ this - > _rediska - > get Serializer ( ) - > unserialize ( $ response [ 1 ] ) ; } else { $ result = Rediska _Command _Response _List Name And Value : : factory ( $ this - > _rediska , $ response ) ; } return $ result ; } 
public function create ( $ all = false ) { if ( $ all ) { $ command = array ( 'FLUSHALL ' ) ; } else { $ command = array ( 'FLUSHDB ' ) ; } $ commands = array ( ) ; foreach ( $ this - > _rediska - > get Connections ( ) as $ connection ) { $ commands [ ] = new Rediska _Connection _Exec ( $ connection , $ command ) ; } return $ commands ; } 
public function add ( $ value ) { $ result = $ this - > _get Rediska On ( ) - > add To Set ( $ this - > get Name ( ) , $ value ) ; if ( ! is _null ( $ this - > get Expire ( ) ) & & $ result ) { $ this - > expire ( $ this - > get Expire ( ) , $ this - > is Expire Timestamp ( ) ) ; } return $ result ; } 
public function remove ( $ value ) { $ result = $ this - > _get Rediska On ( ) - > delete From Set ( $ this - > get Name ( ) , $ value ) ; if ( ! is _null ( $ this - > get Expire ( ) ) & & $ result ) { $ this - > expire ( $ this - > get Expire ( ) , $ this - > is Expire Timestamp ( ) ) ; } return $ result ; } 
public function move ( $ set , $ value ) { if ( $ set instanceof Rediska _Key _Set ) { $ set = $ set - > get Name ( ) ; } return $ this - > _get Rediska On ( ) - > move To Set ( $ this - > get Name ( ) , $ set , $ value ) ; } 
public function intersect ( $ set Or Sets , $ store Key Name = null ) { $ sets = $ this - > _prepare Sets For Compare ( $ set Or Sets ) ; return $ this - > _get Rediska On ( ) - > intersect Sets ( $ sets , $ store Key Name ) ; } 
public function union ( $ set Or Sets , $ store Key Name = null ) { $ sets = $ this - > _prepare Sets For Compare ( $ set Or Sets ) ; return $ this - > _get Rediska On ( ) - > union Sets ( $ sets , $ store Key Name ) ; } 
public function diff ( $ set Or Sets , $ store Key Name = null ) { $ sets = $ this - > _prepare Sets For Compare ( $ set Or Sets ) ; return $ this - > _get Rediska On ( ) - > diff Sets ( $ sets , $ store Key Name ) ; } 
public function get Rediska ( ) { if ( ! is _object ( $ this - > _rediska ) ) { $ this - > _rediska = self : : get Rediska Instance ( $ this - > _rediska , $ this - > _options Exception , $ this - > _rediska Option Name ) ; } return $ this - > _rediska ; } 
public function set Value ( $ value ) { if ( $ this - > get Expire ( ) ! = = null & & ! $ this - > is Expire Timestamp ( ) ) { $ reply = $ this - > set And Expire ( $ value , $ this - > get Expire ( ) ) ; } else { $ reply = $ this - > _get Rediska On ( ) - > set ( $ this - > get Name ( ) , $ value ) ; if ( $ reply & & ! is _null ( $ this - > get Expire ( ) ) ) { $ this - > expire ( $ this - > get Expire ( ) , $ this - > is Expire Timestamp ( ) ) ; } } return $ reply ; } 
public function set And Expire ( $ value , $ seconds ) { return $ this - > _get Rediska On ( ) - > set And Expire ( $ this - > get Name ( ) , $ value , $ seconds ) ; } 
public function set Bit ( $ offset , $ bit ) { return $ this - > _get Rediska On ( ) - > set Bit ( $ this - > get Name ( ) , $ offset , $ bit ) ; } 
public function set Range ( $ offset , $ value ) { return $ this - > _get Rediska On ( ) - > set Range ( $ this - > get Name ( ) , $ offset , $ value ) ; } 
public function get Range ( $ start , $ end = - 1 ) { return $ this - > _get Rediska On ( ) - > get Range ( $ this - > get Name ( ) , $ start , $ end ) ; } 
public function substring ( $ start , $ end = - 1 ) { return $ this - > _get Rediska On ( ) - > substring ( $ this - > get Name ( ) , $ start , $ end ) ; } 
public function get Or Set Value ( $ object = null , $ expire = null , $ expire Is Timestamp = false ) { return new Rediska _Key _Get Or Set Value ( $ this , $ object , $ expire , $ expire Is Timestamp ) ; } 
public function signup Action ( ) { $ form = new Form _User ; if ( $ this - > get Request ( ) - > is Post ( ) & & $ form - > is Valid ( $ this - > get Request ( ) - > get Post ( ) ) ) { $ user Data = $ form - > get Values ( ) ; $ user Data [ 'id ' ] = User : : fetch Next Id ( ) ; 
public function login Action ( ) { $ form = new Form _User Login ; if ( $ this - > get Request ( ) - > is Post ( ) & & $ form - > is Valid ( $ this - > get Request ( ) - > get Post ( ) ) ) { $ auth = Zend _Auth : : get Instance ( ) ; $ options = array ( 'user Id Key ' = > 'user Id Key : * ' , 'user Data Key ' = > 'users : * ' , 'user Data Is Array ' = > true ) ; $ adapter = new Rediska _Zend _Auth _Adapter _Redis ( $ options ) ; 
public function followers Action ( ) { $ user Id = $ this - > _get Param ( 'user Id ' ) ; $ user = new User ( $ user Id ) ; $ this - > view - > user = $ user - > get Value ( ) ; $ followers = new Followers ( $ user Id ) ; $ this - > view - > users = User : : get Multiple ( $ followers - > to Array ( ) ) ; $ this - > _set Users IFollow ( ) ; } 
public function following Action ( ) { $ user Id = $ this - > _get Param ( 'user Id ' ) ; $ following = new Following ( $ user Id ) ; $ this - > view - > users = User : : get Multiple ( $ following - > to Array ( ) ) ; $ this - > _set Users IFollow ( ) ; } 
public function follow Action ( ) { $ auth = Zend _Auth : : get Instance ( ) ; if ( ! $ auth - > has Identity ( ) ) { throw new Zend _Auth _Exception ( "You 're not authorized to see this page " ) ; } $ user Id = $ this - > _get Param ( 'user Id ' ) ; $ follower = $ auth - > get Storage ( ) - > read ( ) ; if ( $ user Id ! = $ follower [ 'id ' ] ) { $ followers = new Followers ( $ user Id ) ; $ followers [ ] = $ follower [ 'id ' ] ; $ following = new Following ( $ follower [ 'id ' ] ) ; $ following [ ] = $ user Id ; } $ this - > _redirect ( ' /user /followers /user Id / ' . $ user Id ) ; } 
public function create ( $ key , $ seconds Or Timestamp , $ is Timestamp = false ) { $ connection = $ this - > _rediska - > get Connection By Key Name ( $ key ) ; if ( $ is Timestamp ) { $ this - > _throw Exception If Not Supported ( ' 1 . 1 ' ) ; $ command = 'EXPIREAT ' ; } else { $ command = 'EXPIRE ' ; } $ command = array ( $ command , $ this - > _rediska - > get Option ( 'namespace ' ) . $ key , $ seconds Or Timestamp ) ; return new Rediska _Connection _Exec ( $ connection , $ command ) ; } 
public function rename ( $ new Name , $ overwrite = true ) { try { $ this - > _get Rediska On ( ) - > rename ( $ this - > get Name ( ) , $ new Name , $ overwrite ) ; } catch ( Rediska _Exception $ e ) { return false ; } $ this - > set Name ( $ new Name ) ; if ( ! is _null ( $ this - > get Expire ( ) ) ) { $ this - > expire ( $ this - > get Expire ( ) , $ this - > is Expire Timestamp ( ) ) ; } return true ; } 
public function expire ( $ seconds Or Timestamp , $ is Timestamp = false ) { return $ this - > _get Rediska On ( ) - > expire ( $ this - > get Name ( ) , $ seconds Or Timestamp , $ is Timestamp ) ; } 
public function move To Db ( $ db Index ) { $ result = $ this - > _get Rediska On ( ) - > move To Db ( $ this - > get Name ( ) , $ db Index ) ; if ( ! is _null ( $ this - > get Expire ( ) ) & & $ result ) { $ this - > expire ( $ this - > get Expire ( ) , $ this - > is Expire Timestamp ( ) ) ; } return $ result ; } 
public function set Expire ( $ seconds Or Timestamp , $ is Timestamp = false ) { if ( $ seconds Or Timestamp ! = = null ) { trigger _error ( 'Expire option is deprecated , because expire behaviour was changed in Redis 2 . 2 . Use expire method instead . ' , E _USER _WARNING ) ; } $ this - > _options [ 'expire ' ] = $ seconds Or Timestamp ; $ this - > _options [ 'expire Is Timestamp ' ] = $ is Timestamp ; return $ this ; } 
protected function _get Rediska On ( ) { $ rediska = $ this - > get Rediska ( ) ; if ( ! is _null ( $ this - > get Server Alias ( ) ) ) { $ rediska = $ rediska - > on ( $ this - > get Server Alias ( ) ) ; } return $ rediska ; } 
public function set Adapter ( $ adapter ) { if ( is _object ( $ adapter ) ) { $ this - > _adapter = $ adapter ; } else if ( in _array ( $ adapter , array ( 'php Serialize ' , 'json ' , 'to String ' ) ) ) { $ adapter = ucfirst ( $ adapter ) ; $ class Name = "Rediska _Serializer _Adapter _ $adapter " ; $ this - > _adapter = new $ class Name ; } else { if ( ! @ class _exists ( $ adapter ) ) { throw new Rediska _Serializer _Exception ( "Serializer adapter ' $adapter ' not found . You need include it before or setup autoload . " ) ; } $ this - > _adapter = new $ adapter ; } if ( ! $ this - > _adapter instanceof Rediska _Serializer _Adapter _Interface ) { throw new Rediska _Serializer _Exception ( " ' $adapter ' must implement Rediska _Serializer _Adapter _Interface " ) ; } return $ this ; } 
public function serialize ( $ value ) { if ( is _numeric ( $ value ) | | is _string ( $ value ) ) { return ( string ) $ value ; } else { return $ this - > _adapter - > serialize ( $ value ) ; } } 
public function unserialize ( $ value ) { if ( is _null ( $ value ) ) { return null ; } else if ( is _numeric ( $ value ) ) { if ( strpos ( $ value , ' . ' ) = = = false ) { $ unserialized Value = ( integer ) $ value ; } else { $ unserialized Value = ( float ) $ value ; } if ( ( string ) $ unserialized Value ! = = $ value ) { $ unserialized Value = $ value ; } } else { try { $ unserialized Value = $ this - > _adapter - > unserialize ( $ value ) ; } catch ( Rediska _Serializer _Adapter _Exception $ e ) { $ unserialized Value = $ value ; } } return $ unserialized Value ; } 
public function get Stream ( ) { if ( ! is _resource ( $ this - > _stream ) ) { $ stream = $ this - > _stream ; if ( is _array ( $ stream ) & & isset ( $ stream [ 'stream ' ] ) ) { $ stream = $ stream [ 'stream ' ] ; } if ( ! $ this - > _stream = @ fopen ( $ stream , $ this - > get Mode ( ) , false ) ) { throw new Rediska _Profiler _Exception ( " ' $stream ' cannot be opened with mode ' { $this - >get Mode ( ) } ' " ) ; } } return $ this - > _stream ; } 
public function set Mode ( $ mode ) { if ( is _resource ( $ this - > _stream ) & & $ this - > _mode ! = $ mode ) { $ meta = stream _get _meta _data ( $ this - > _stream ) ; $ this - > set Stream ( $ meta [ 'uri ' ] ) ; } $ this - > _mode = $ mode ; return $ this ; } 
public function stop Callback ( Rediska _Profiler _Profile $ profile ) { $ place Holders = array ( ' %timestamp % ' = > date ( 'Y -m -d H :i :s ' ) , ' %profile % ' = > $ profile - > get Context ( ) , ' %elapsed Time % ' = > $ profile - > get Elapsed Time ( 4 ) ) ; $ data = str _replace ( array _keys ( $ place Holders ) , array _values ( $ place Holders ) , $ this - > _format . Rediska : : EOL ) ; $ this - > _write ( $ data ) ; } 
public function reset ( ) { parent : : reset ( ) ; $ prev Mode = $ this - > get Mode ( ) ; $ this - > set Mode ( 'w ' ) ; $ this - > _write ( ' ' ) ; $ this - > set Mode ( $ prev Mode ) ; return $ this ; } 
public static function add ( $ rediska ) { if ( $ rediska instanceof Rediska ) { if ( ! self : : has ( $ rediska - > get Name ( ) ) ) { foreach ( self : : $ _instances as $ name = > $ instance ) { if ( $ instance = = = $ rediska & & $ name ! = $ rediska - > get Name ( ) ) { unset ( self : : $ _instances [ $ name ] ) ; break ; } } } $ name = $ rediska - > get Name ( ) ; } else if ( is _array ( $ rediska ) ) { if ( isset ( $ rediska [ 'name ' ] ) ) { $ name = $ rediska [ 'name ' ] ; } else { $ name = Rediska : : DEFAULT _NAME ; } } else { throw new Rediska _Exception ( 'Rediska must be a instance or options ' ) ; } if ( self : : has ( $ name ) ) { $ result = false ; } else { $ result = true ; } self : : $ _instances [ $ name ] = $ rediska ; return $ result ; } 
public static function get ( $ name = Rediska : : DEFAULT _NAME ) { if ( ! self : : has ( $ name ) ) { throw new Rediska _Exception ( "Rediska instance ' $name ' not present " ) ; } self : : _instance From Options ( $ name ) ; return self : : $ _instances [ $ name ] ; } 
public static function get All ( ) { foreach ( self : : $ _instances as $ name = > $ instance Or Options ) { self : : _instance From Options ( $ name ) ; } return self : : $ _instances ; } 
public static function remove ( $ rediska ) { if ( $ rediska instanceof Rediska ) { $ name = $ rediska - > get Name ( ) ; } else if ( is _string ( $ rediska ) ) { $ name = $ rediska ; } else { throw new Rediska _Exception ( 'Rediska must be a instance or name ' ) ; } if ( ! isset ( self : : $ _instances [ $ name ] ) ) { throw new Rediska _Exception ( "Rediska instance ' $name ' not present " ) ; } unset ( self : : $ _instances [ $ name ] ) ; return true ; } 
protected static function _instance From Options ( $ name ) { if ( ! is _object ( self : : $ _instances [ $ name ] ) ) { $ options = self : : $ _instances [ $ name ] ; self : : $ _instances [ $ name ] = new Rediska ( $ options ) ; } } 
public function parse Responses ( $ responses ) { $ info = array ( ) ; $ count = 0 ; foreach ( $ this - > _connections as $ connection ) { $ info [ $ connection ] = array ( ) ; foreach ( explode ( Rediska : : EOL , $ responses [ $ count ] ) as $ param ) { if ( ! $ param | | ! strpos ( $ param , ' : ' ) ! = = false ) { continue ; } list ( $ name , $ string Value ) = explode ( ' : ' , $ param , 2 ) ; if ( strpos ( $ string Value , ' . ' ) ! = = false ) { $ value = ( float ) $ string Value ; } else { $ value = ( integer ) $ string Value ; } if ( ( string ) $ value ! = $ string Value ) { $ value = $ string Value ; } $ info [ $ connection ] [ $ name ] = $ value ; } $ info [ $ connection ] = new Rediska _Info ( $ info [ $ connection ] ) ; $ count + + ; } if ( count ( $ info ) = = 1 ) { $ info = array _shift ( $ info ) ; } return $ info ; } 
public function increment ( $ subject ) { $ bucket = $ this - > _get Bucket Name ( ) ; $ transaction = $ this - > _get Transaction ( ) ; $ this - > _set Multi Increment Transaction Part ( $ transaction , $ subject , $ bucket ) ; $ transaction - > execute ( ) ; } 
public function get Rate By Interval ( $ subject , $ interval ) { $ bucket = $ this - > _get Bucket Name ( ) ; $ count = ( int ) floor ( $ interval / $ this - > bucket Interval ) ; $ transaction = $ this - > _get Transaction ( ) ; $ this - > _set Mulit Exec Get Count Part ( $ transaction , $ subject , $ bucket , $ count ) ; return array _sum ( $ transaction - > execute ( ) ) ; } 
public function increment And Get Count By Interval ( $ subject , $ interval ) { $ bucket = $ this - > _get Bucket Name ( ) ; $ count = ( int ) floor ( $ interval / $ this - > _bucket Interval ) ; $ transaction = $ this - > _get Transaction ( ) ; $ this - > _set Multi Increment Transaction Part ( $ transaction , $ subject , $ bucket ) ; $ this - > _set Mulit Exec Get Count Part ( $ transaction , $ subject , $ bucket , $ count ) ; return array _sum ( array _slice ( $ transaction - > execute ( ) , 4 ) ) ; } 
public function reset ( $ subject ) { $ key Name = $ this - > _get Key Name ( $ subject ) ; return ( bool ) $ this - > _rediska - > delete ( $ key Name ) ; } 
protected function _get Bucket Name ( $ time = null ) { $ time = $ time ? : time ( ) ; return ( int ) floor ( ( $ time % $ this - > _bucket Span ) / $ this - > _bucket Interval ) ; } 
protected function _set Multi Increment Transaction Part ( Rediska _Transaction $ transaction , $ subject , $ bucket ) { $ key Name = $ this - > _get Key Name ( $ subject ) ; $ transaction - > incrementinhash ( $ key Name , $ bucket , 1 ) - > deletefromhash ( $ key Name , ( $ bucket + 1 ) % $ this - > _bucket Count ) - > deletefromhash ( $ key Name , ( $ bucket + 2 ) % $ this - > _bucket Count ) - > expire ( $ key Name , $ this - > _subject Expire ) ; } 
protected function _set Mulit Exec Get Count Part ( Rediska _Transaction $ transaction , $ subject , $ bucket , $ count ) { $ key Name = $ this - > _get Key Name ( $ subject ) ; 
public function create ( $ key , $ amount = 1 ) { $ connection = $ this - > _rediska - > get Connection By Key Name ( $ key ) ; if ( $ amount = = 1 ) { $ command = array ( 'DECR ' , $ this - > _rediska - > get Option ( 'namespace ' ) . $ key ) ; } else { $ command = array ( 'DECRBY ' , $ this - > _rediska - > get Option ( 'namespace ' ) . $ key , $ amount ) ; } return new Rediska _Connection _Exec ( $ connection , $ command ) ; } 
public function create ( $ key , $ reference Value , $ value ) { return $ this - > _create ( $ key , self : : BEFORE , $ reference Value , $ value ) ; } 
public function create ( $ key , $ field Or Data , $ value = null , $ overwrite = true ) { if ( is _array ( $ field Or Data ) ) { $ data = $ field Or Data ; if ( empty ( $ data ) ) { throw new Rediska _Command _Exception ( 'Not present fields and values for set ' ) ; } $ command = array ( 'HMSET ' , $ this - > _rediska - > get Option ( 'namespace ' ) . $ key ) ; foreach ( $ data as $ field = > $ value ) { $ command [ ] = $ field ; $ command [ ] = $ this - > _rediska - > get Serializer ( ) - > serialize ( $ value ) ; } } else { $ field = $ field Or Data ; $ value = $ this - > _rediska - > get Serializer ( ) - > serialize ( $ value ) ; $ command = array ( $ overwrite ? 'HSET ' : 'HSETNX ' , $ this - > _rediska - > get Option ( 'namespace ' ) . $ key , $ field , $ value ) ; } $ connection = $ this - > _rediska - > get Connection By Key Name ( $ key ) ; return new Rediska _Connection _Exec ( $ connection , $ command ) ; } 
public function create ( $ key ) { $ connection = $ this - > _rediska - > get Connection By Key Name ( $ key ) ; $ command = array ( 'HGETALL ' , $ this - > _rediska - > get Option ( 'namespace ' ) . $ key ) ; return new Rediska _Connection _Exec ( $ connection , $ command ) ; } 
public function parse Response ( $ response ) { $ is Field = true ; $ result = array ( ) ; foreach ( $ response as $ field Or Value ) { if ( $ is Field ) { $ field = $ field Or Value ; } else { $ result [ $ field ] = $ this - > _rediska - > get Serializer ( ) - > unserialize ( $ field Or Value ) ; } $ is Field = ! $ is Field ; } return $ result ; } 
public function connect ( ) { if ( $ this - > is Connected ( ) ) { return false ; } $ this - > _socket = $ this - > _create Socket Connection ( ) ; 
public function disconnect ( ) { if ( ! $ this - > is Connected ( ) ) { return false ; } @ socket _close ( $ this - > _socket ) ; $ this - > _socket = null ; $ this - > _read Buffer = null ; return true ; } 
public function write ( $ string ) { if ( $ string = = ' ' ) { return false ; } $ this - > connect ( ) ; $ string = ( string ) $ string . Rediska : : EOL ; $ offset = 0 ; $ length = strlen ( $ string ) ; while ( true ) { $ sent = @ socket _write ( $ this - > get Socket ( ) , substr ( $ string , $ offset , $ length ) , $ length ) ; if ( $ sent = = = false ) { $ error Code = socket _last _error ( ) ; $ error Message = socket _strerror ( $ error Code ) ; 
protected function _create Socket Connection ( ) { $ socket = socket _create ( AF _INET , SOCK _STREAM , getprotobyname ( 'tcp ' ) ) ; socket _set _option ( $ socket , SOL _SOCKET , TCP _NODELAY , 1 ) ; @ socket _set _nonblock ( $ socket ) ; $ result = @ socket _connect ( $ socket , $ this - > get Host ( ) , $ this - > get Port ( ) ) ; if ( $ result = = = false ) { $ error Code = socket _last _error ( $ socket ) ; if ( $ error Code ! = = SOCKET _EINPROGRESS ) { return null ; } } else { 
protected function _get Read Buffer ( ) { if ( $ this - > _read Buffer = = = null ) { $ this - > _read Buffer = new Rediska _Connection _Socket _Read Buffer ( $ this ) ; } return $ this - > _read Buffer ; } 
public function create ( $ alias Or Connection ) { if ( $ alias Or Connection = = = false ) { $ host = 'no ' ; $ port = 'one ' ; } else { if ( $ alias Or Connection instanceof Rediska _Connection ) { $ connection = $ alias Or Connection ; } else { $ alias = $ alias Or Connection ; $ connection = $ this - > _rediska - > get Connection By Alias ( $ alias ) ; } $ host = $ connection - > get Host ( ) ; $ port = $ connection - > get Port ( ) ; } $ command = array ( 'SLAVEOF ' , $ host , $ port ) ; $ commands = array ( ) ; foreach ( $ this - > _rediska - > get Connections ( ) as $ connection ) { $ commands [ ] = new Rediska _Connection _Exec ( $ connection , $ command ) ; } return $ commands ; } 
public function connect ( ) { if ( ! $ this - > is Connected ( ) ) { $ socket Address = 'tcp : / / ' . $ this - > get Host ( ) . ' : ' . $ this - > get Port ( ) ; if ( $ this - > _options [ 'persistent ' ] ) { $ flag = STREAM _CLIENT _PERSISTENT | STREAM _CLIENT _CONNECT ; } else { $ flag = STREAM _CLIENT _CONNECT ; } $ socket Params = array ( $ socket Address , & $ errno , & $ errmsg , $ this - > get Timeout ( ) , $ flag ) ; $ stream Context = $ this - > get Stream Context ( ) ; if ( $ stream Context ) { $ socket Params [ ] = $ stream Context ; } $ this - > _socket = call _user _func _array ( 'stream _socket _client ' , $ socket Params ) ; 
public function write ( $ string ) { if ( $ string ! = = ' ' ) { $ need To Write = ( string ) $ string . Rediska : : EOL ; $ this - > connect ( ) ; while ( $ need To Write ) { $ bytes = @ fwrite ( $ this - > _socket , $ need To Write ) ; if ( $ bytes = = = false ) { $ this - > disconnect ( ) ; throw new Rediska _Connection _Exception ( "Can 't write to socket . " ) ; } if ( $ bytes = = 0 ) { return true ; } $ need To Write = substr ( $ need To Write , $ bytes ) ; } return true ; } else { return false ; } } 
public function read ( $ length ) { if ( ! $ this - > is Connected ( ) ) { throw new Rediska _Connection _Exception ( "Can 't read without connection to Redis server . Do connect or write first . " ) ; } if ( $ length > 0 ) { $ data = $ this - > _read And Throw Exception ( $ length ) ; } else { $ data = null ; } if ( $ length ! = = - 1 ) { $ this - > _read And Throw Exception ( 2 ) ; } return $ data ; } 
public function read Line ( ) { if ( ! $ this - > is Connected ( ) ) { throw new Rediska _Connection _Exception ( "Can 't read without connection to Redis server . Do connect or write first . " ) ; } $ reply = @ fgets ( $ this - > _socket ) ; if ( $ reply = = = false | | $ reply = = = ' ' ) { $ meta Data = stream _get _meta _data ( $ this - > _socket ) ; if ( $ meta Data [ 'timed _out ' ] ) { throw new Rediska _Connection _Timeout Exception ( "Connection read timed out . " ) ; } if ( $ this - > _options [ 'blocking Mode ' ] & & ! $ meta Data [ 'eof ' ] ) { $ this - > disconnect ( ) ; throw new Rediska _Connection _Exception ( "Can 't read from socket . " ) ; } $ reply = null ; } else { $ reply = trim ( $ reply ) ; } return $ reply ; } 
public function set Read Timeout ( $ timeout ) { $ this - > _options [ 'read Timeout ' ] = $ timeout ; if ( $ this - > is Connected ( ) ) { $ seconds = floor ( $ this - > _options [ 'read Timeout ' ] ) ; $ microseconds = ( $ this - > _options [ 'read Timeout ' ] - $ seconds ) * 1 0 0 0 0 0 0 ; stream _set _timeout ( $ this - > _socket , $ seconds , $ microseconds ) ; } return $ this ; } 
public function set Blocking Mode ( $ flag = true ) { $ this - > _options [ 'blocking Mode ' ] = $ flag ; if ( $ this - > is Connected ( ) ) { stream _set _blocking ( $ this - > _socket , $ this - > _options [ 'blocking Mode ' ] ) ; } return $ this ; } 
public function get Stream Context ( ) { if ( $ this - > _options [ 'stream Context ' ] ! = = null ) { if ( is _resource ( $ this - > _options [ 'stream Context ' ] ) ) { return $ this - > _options [ 'stream Context ' ] ; } if ( is _array ( $ this - > _options [ 'stream Context ' ] ) ) { return stream _context _create ( $ this - > _options [ 'stream Context ' ] ) ; } } return null ; } 
protected function _read And Throw Exception ( $ length ) { $ data = @ stream _get _contents ( $ this - > _socket , $ length ) ; $ info = stream _get _meta _data ( $ this - > _socket ) ; if ( $ info [ 'timed _out ' ] ) { throw new Rediska _Connection _Timeout Exception ( "Connection read timed out . " ) ; } if ( $ data = = = false ) { $ this - > disconnect ( ) ; throw new Rediska _Connection _Exception ( "Can 't read from socket . " ) ; } return $ data ; } 
public function create ( $ key , $ start , $ end = - 1 ) { if ( $ this - > get Name ( ) = = 'substring ' ) { trigger _error ( 'Substring is deprecated . Use get Range command instead ' , E _USER _WARNING ) ; } $ redis Version = $ this - > get Rediska ( ) - > get Option ( 'redis Version ' ) ; $ is Version Less Then 2 = version _compare ( ' 2 . 0 . 4 ' , $ redis Version ) > = 0 ; $ command = array ( $ is Version Less Then 2 ? 'SUBSTR ' : 'GETRANGE ' , $ this - > _rediska - > get Option ( 'namespace ' ) . $ key , $ start , $ end ) ; $ connection = $ this - > _rediska - > get Connection By Key Name ( $ key ) ; return new Rediska _Connection _Exec ( $ connection , $ command ) ; } 
public function create ( ) { $ command = array ( 'QUIT ' ) ; $ this - > _affected Connections = $ this - > _rediska - > get Connections ( ) ; $ commands = array ( ) ; foreach ( $ this - > _affected Connections as $ connection ) { $ commands [ ] = new Rediska _Connection _Exec ( $ connection , $ command ) ; } return $ commands ; } 
public function create ( $ key , $ reference Value , $ value ) { return $ this - > _create ( $ key , self : : AFTER , $ reference Value , $ value ) ; } 
public function create ( $ key Or Keys , $ timeout = 0 , $ push To Key = null ) { 
public function parse Response ( $ response ) { if ( $ this - > push To Key ! = = null ) { if ( empty ( $ response ) ) { return null ; } if ( ! $ this - > is Atomic ( ) ) { $ command = array ( 'LPUSH ' , $ this - > _rediska - > get Option ( 'namespace ' ) . $ this - > push To Key , $ response [ 1 ] ) ; $ exec = new Rediska _Connection _Exec ( $ this - > _store Connection , $ command ) ; $ exec - > execute ( ) ; $ value = $ response [ 1 ] ; } else { $ value = $ response ; } return $ this - > _rediska - > get Serializer ( ) - > unserialize ( $ value ) ; } else { if ( ! is _array ( $ this - > key Or Keys ) & & ! empty ( $ response ) ) { $ result = $ this - > _rediska - > get Serializer ( ) - > unserialize ( $ response [ 1 ] ) ; } else { $ result = Rediska _Command _Response _List Name And Value : : factory ( $ this - > _rediska , $ response ) ; } return $ result ; } } 
public function report Message ( $ message ) { foreach ( $ this - > reporters as $ reporter ) { $ reporter - > report Message ( $ message ) ; } foreach ( $ this - > callbacks as $ callback ) { call _user _func ( $ callback , $ message ) ; } } 
public function validate ( Nonce Context Interface $ context = null ) { $ context or $ context = new Request Globals Context ( ) ; $ value = $ context - > offset Exists ( $ this - > action ) ? $ context [ $ this - > action ] : ' ' ; if ( ! $ value | | ! is _string ( $ value ) ) { return false ; } $ life Filter = $ this - > life Filter ( ) ; add _filter ( 'nonce _life ' , $ life Filter ) ; $ valid = wp _verify _nonce ( $ value , $ this - > hashed Action ( ) ) ; remove _filter ( 'nonce _life ' , $ life Filter ) ; return ( bool ) $ valid ; } 
public function publish ( $ data , $ routing Key = ' ' , array $ headers = [ ] ) { $ this - > driver - > publish ( $ this - > exchange Name , new Message ( $ data , $ routing Key , $ headers ) ) ; return null ; } 
public function publish ( $ data , $ routing Key = ' ' , array $ headers = [ ] ) { $ response = null ; $ correlation Id = uniqid ( ' ' , false ) ; $ reply To = $ this - > driver - > declare Simple Queue ( ' ' , Driver : : QUEUE _EXCLUSIVE ) ; $ this - > driver - > publish ( $ this - > exchange Name , new Message ( $ data , $ routing Key , $ headers , $ correlation Id , $ reply To ) ) ; $ this - > driver - > consume ( $ reply To , function ( Message $ message ) use ( $ correlation Id , & $ response ) { if ( $ message - > get Correlation Id ( ) = = $ correlation Id ) { $ response = $ message - > get Body ( ) ; return Queue Handler : : STOP _CONSUMING ; } return Queue Handler : : CONTINUE _CONSUMING ; } , $ this - > timeout ) ; return $ response ; } 
protected function execute ( Input Interface $ input , Output Interface $ output ) { $ exchange = $ input - > get Argument ( 'exchange ' ) ; $ queue = $ input - > get Argument ( 'queue ' ) ; $ routing Key = ( $ input - > get Option ( 'routing Key ' ) ! = = null ) ? $ input - > get Option ( 'routing Key ' ) : ' ' ; $ this - > driver - > bind Queue ( $ input - > get Argument ( 'exchange ' ) , $ input - > get Argument ( 'queue ' ) , $ routing Key ) ; $ output - > writeln ( sprintf ( ' <info >Bind exchange <comment > %s < /comment > to queue <comment > %s < /comment > [ <comment > %s < /comment > ] < /info > ' , $ exchange , $ queue , $ routing Key ) ) ; } 
public function publish ( $ data , $ routing Key = ' ' , array $ headers = [ ] ) { $ return Value = $ this - > publisher - > publish ( $ this - > serializer - > serialize ( $ data ) , $ routing Key , $ headers ) ; return $ this - > serializer - > deserialize ( $ return Value ) ; } 
public function handle ( Message $ message ) { try { $ this - > handler - > handle ( $ message ) ; return self : : CONTINUE _CONSUMING ; } catch ( \ Exception $ e ) { $ this - > logger - > error ( $ e ) ; return self : : STOP _CONSUMING ; } } 
public function handle ( Event Interface $ event ) { if ( ! ( $ event instanceof Daemon Started ) ) { throw Listener Exception : : bad Event Given ( $ event ) ; } $ this - > metric Service - > increment ( 'daemon .started ' ) ; } 
public function declare Simple Queue ( $ queue Name = ' ' , $ type = self : : QUEUE _DURABLE ) { $ flag = AMQP _DURABLE ; if ( $ type = = = self : : QUEUE _EXCLUSIVE ) { $ flag = AMQP _EXCLUSIVE ; } $ queue = $ this - > get Queue ( $ queue Name ) ; $ queue - > set Flags ( $ flag ) ; $ queue - > declare Queue ( ) ; return $ queue - > get Name ( ) ; } 
public function declare Exchange ( $ exchange Name = ' ' , $ type = self : : EXCHANGE _TYPE _FANOUT ) { $ exchange = $ this - > get Exchange ( $ exchange Name ) ; $ exchange - > set Type ( $ type ) ; $ exchange - > set Flags ( AMQP _DURABLE ) ; $ exchange - > declare Exchange ( ) ; return $ exchange - > get Name ( ) ; } 
public function bind Queue ( $ exchange , $ queue Name , $ routing Key = ' ' ) { $ queue = $ this - > get Queue ( $ queue Name ) ; $ queue - > bind ( $ exchange , $ routing Key ) ; } 
public function declare And Bind Queue ( $ exchange , $ queue Name , $ routing Key = ' ' ) { $ this - > declare Simple Queue ( $ queue Name ) ; $ this - > bind Queue ( $ exchange , $ queue Name , $ routing Key ) ; } 
public function publish ( $ exchange Name , Message $ message ) { $ exchange = $ this - > get Exchange ( $ exchange Name ) ; $ exchange - > publish ( $ message - > get Body ( ) , $ message - > get Routing Key ( ) , AMQP _NOPARAM , self : : get Message Properties ( $ message ) ) ; } 
public function consume ( $ queue Name , callable $ callback , $ timeout = 0 , $ auto Ack = true ) { $ this - > connection - > set Read Timeout ( $ timeout ) ; $ this - > get Channel ( ) - > set Prefetch Count ( 1 ) ; $ queue = $ this - > get Queue ( $ queue Name ) ; $ flags = $ auto Ack ? AMQP _AUTOACK : AMQP _NOPARAM ; try { $ queue - > consume ( function ( \ AMQPEnvelope $ message ) use ( $ callback , $ queue Name ) { $ burrow Message = new Message ( $ message - > get Body ( ) , $ message - > get Routing Key ( ) , $ message - > get Headers ( ) , $ message - > get Correlation Id ( ) , $ message - > get Reply To ( ) ) ; $ burrow Message - > set Delivery Tag ( $ message - > get Delivery Tag ( ) ) ; $ burrow Message - > set Queue ( $ queue Name ) ; return $ callback ( $ burrow Message ) ; } , $ flags ) ; } catch ( \ AMQPQueue Exception $ e ) { if ( $ e - > get Message ( ) = = = 'Consumer timeout exceed ' ) { throw Timeout Exception : : build ( $ e , $ timeout ) ; } throw Consumer Exception : : build ( $ e ) ; } } 
public function ack ( Message $ message ) { $ queue = $ this - > get Queue ( $ message - > get Queue ( ) ) ; $ queue - > ack ( $ message - > get Delivery Tag ( ) ) ; } 
public function nack ( Message $ message , $ requeue = true ) { $ queue = $ this - > get Queue ( $ message - > get Queue ( ) ) ; $ queue - > nack ( $ message - > get Delivery Tag ( ) , $ requeue ? AMQP _REQUEUE : AMQP _NOPARAM ) ; } 
private function get Channel ( ) { if ( null = = = $ this - > channel ) { $ this - > connection - > connect ( ) ; $ this - > channel = new \ AMQPChannel ( $ this - > connection ) ; } return $ this - > channel ; } 
private function get Queue ( $ queue Name ) { $ queue = new \ AMQPQueue ( $ this - > get Channel ( ) ) ; if ( $ queue Name ) { $ queue - > set Name ( $ queue Name ) ; } return $ queue ; } 
private function get Exchange ( $ exchange Name ) { $ exchange = new \ AMQPExchange ( $ this - > get Channel ( ) ) ; if ( $ exchange Name ) { $ exchange - > set Name ( $ exchange Name ) ; } return $ exchange ; } 
private static function get Message Properties ( Message $ message ) { $ properties = [ self : : DELIVERY _MODE = > 2 , self : : CONTENT _TYPE = > 'text /plain ' , self : : APPLICATION _HEADERS = > $ message - > get Headers ( ) ] ; if ( $ message - > get Correlation Id ( ) ! = = null ) { $ properties [ self : : CORRELATION _ID ] = $ message - > get Correlation Id ( ) ; } if ( $ message - > get Reply To ( ) ! = = null ) { $ properties [ self : : REPLY _TO ] = $ message - > get Reply To ( ) ; } return $ properties ; } 
public function start ( ) { $ this - > event Emitter - > emit ( new Daemon Started ( ) ) ; $ this - > logger - > info ( 'Starting daemon . . . ' ) ; $ options = $ this - > handler - > options ( new Consume Options ( ) ) ; $ this - > driver - > consume ( $ this - > queue Name , function ( Message $ message ) { $ this - > event Emitter - > emit ( new Message Received ( ) ) ; $ this - > monitor - > monitor ( $ this , $ message ) ; $ result = $ this - > handler - > handle ( $ message ) ; $ this - > event Emitter - > emit ( new Message Consumed ( ) ) ; pcntl _signal _dispatch ( ) ; return $ result ; } , $ options - > get Timeout ( ) , $ options - > is Auto Ack ( ) ) ; $ this - > stop ( ) ; } 
public function stop ( ) { $ this - > logger - > info ( 'Closing daemon . . . ' ) ; $ this - > driver - > close ( ) ; $ this - > event Emitter - > emit ( new Daemon Stopped ( ) ) ; } 
public function provide Listeners ( Listener Acceptor Interface $ listener Acceptor ) { $ listener Acceptor - > add Listener ( Daemon Started : : NAME , new Send Metric On Daemon Started ( $ this - > metric Service ) ) ; $ listener Acceptor - > add Listener ( Daemon Stopped : : NAME , new Send Metric On Daemon Stopped ( $ this - > metric Service ) ) ; $ listener Acceptor - > add Listener ( Message Received : : NAME , new Send Metric On Message Received ( $ this - > metric Service ) ) ; $ send Metric On Message Consumed = new Send Metric On Message Consumed ( $ this - > metric Service ) ; $ listener Acceptor - > add Listener ( Message Received : : NAME , $ send Metric On Message Consumed ) ; $ listener Acceptor - > add Listener ( Message Consumed : : NAME , $ send Metric On Message Consumed ) ; } 
protected function execute ( Input Interface $ input , Output Interface $ output ) { $ name = $ input - > get Argument ( 'name ' ) ; $ type = $ input - > get Argument ( 'type ' ) ; Assertion : : choice ( $ type , [ Driver : : EXCHANGE _TYPE _DIRECT , Driver : : EXCHANGE _TYPE _TOPIC , Driver : : EXCHANGE _TYPE _FANOUT , Driver : : EXCHANGE _TYPE _HEADERS ] , 'The type of the exchange must be one of the four valid values . ' ) ; $ this - > driver - > declare Exchange ( $ name , $ type ) ; $ output - > writeln ( sprintf ( ' <info >Declare exchange <comment > %s < /comment > [ <comment > %s < /comment > ] < /info > ' , $ name , $ type ) ) ; } 
public function deserialize ( $ message ) { if ( $ message = = = null ) { return null ; } Assertion : : string ( $ message , 'The message to deserialize must be a valid string ' ) ; return json _decode ( $ message ) ; } 
public function handle ( Message $ message ) { try { $ result = $ this - > handler - > handle ( $ message ) ; $ this - > driver - > ack ( $ message ) ; return $ result ; } catch ( \ Exception $ e ) { $ this - > driver - > nack ( $ message , $ this - > requeue On Failure ) ; throw $ e ; } } 
public static function build ( \ Exception $ e , $ timeout ) { return new self ( sprintf ( 'The connection timed out after %d sec while awaiting incoming data ' , $ timeout ) , $ e - > get Code ( ) , $ e ) ; } 
public static function create ( $ type , $ options = [ ] , $ contextual Tags = [ ] ) { $ collector = Factory : : create ( $ type , $ options ) ; switch ( $ type ) { case 'dogstatsd ' : return new Dog Stats DMetric Service ( $ collector , $ contextual Tags ) ; case 'statsd ' : return new Stats DMetric Service ( $ collector ) ; } throw new \ Exception ( sprintf ( 'Metric Service for %s is not implemented ' , $ type ) ) ; } 
protected function execute ( Input Interface $ input , Output Interface $ output ) { $ configuration = $ this - > get Configuration ( $ input ) ; $ this - > declare Queues ( $ configuration , $ output ) ; $ this - > bind ( $ configuration , $ output ) ; } 
protected function get Configuration ( Input Interface $ input ) { $ file = $ input - > get Argument ( 'file ' ) ; Assertion : : file ( $ file , 'You must provide a valid file name ' ) ; $ configuration String = file _get _contents ( $ file ) ; Assertion : : is Json String ( $ configuration String , 'The file must be a valid JSON ' ) ; $ configuration = @ json _decode ( $ configuration String , true ) ; if ( json _last _error ( ) ! = = JSON _ERROR _NONE ) { throw new \ Invalid Argument Exception ( 'Invalid json : ' . json _last _error _msg ( ) ) ; } self : : check Configuration ( $ configuration ) ; return $ configuration ; } 
private static function check Queues Configuration ( array $ configuration ) { Assertion : : key Isset ( $ configuration , 'queues ' , 'You must provide a `queues ` configuration ' ) ; $ queues = $ configuration [ 'queues ' ] ; Assertion : : is Array ( $ queues , 'The `queues ` configuration must be an array ' ) ; foreach ( $ queues as $ queue Information ) { if ( is _string ( $ queue Information ) ) { continue ; } Assertion : : key Isset ( $ queue Information , 'name ' , 'You must provide a name for the queue ' ) ; } } 
private static function check Exchanges Configuration ( array $ configuration ) { Assertion : : key Isset ( $ configuration , 'exchanges ' , 'You must provide an `exchanges ` configuration ' ) ; $ exchanges = $ configuration [ 'exchanges ' ] ; Assertion : : is Array ( $ exchanges , 'The `exchanges ` configuration must be an array ' ) ; foreach ( $ exchanges as $ exchange Information ) { self : : check Exchange Configuration ( $ exchange Information ) ; } } 
private static function check Exchange Configuration ( array $ exchange Information ) { Assertion : : key Isset ( $ exchange Information , 'name ' , 'You must provide a name for the exchange ' ) ; Assertion : : key Isset ( $ exchange Information , 'type ' , 'You must provide a type for the exchange ' ) ; self : : check Queues Configuration ( $ exchange Information ) ; } 
public function handle ( Event Interface $ event ) { if ( $ event instanceof Message Received ) { $ this - > message Received At = $ this - > clock - > timestamp In Ms ( ) ; return ; } if ( ! ( $ event instanceof Message Consumed ) ) { throw Listener Exception : : bad Event Given ( $ event ) ; } $ this - > metric Service - > increment ( 'daemon .message _consumed ' ) ; $ this - > metric Service - > timing ( 'daemon .message _processing _time ' , $ this - > clock - > timestamp In Ms ( ) - $ this - > message Received At ) ; } 
public function handle ( Message $ message ) { 
public function build ( Queue Consumer $ consumer ) { Assertion : : not Null ( $ this - > sync , 'You must specify if the handler must be sync or async ' ) ; 
public function handle ( Message $ message ) { $ return Value = $ this - > consumer - > consume ( $ message - > get Body ( ) , $ message - > get Headers ( ) ) ; $ this - > handle Sync Message ( $ message , $ return Value ) ; return self : : CONTINUE _CONSUMING ; } 
private function handle Sync Message ( Message $ message , $ return Value ) { self : : check Message Is Sync ( $ message ) ; $ this - > logger - > debug ( 'Send return value back ! ' , [ 'return Value ' = > $ return Value , 'correlation Id ' = > $ message - > get Correlation Id ( ) , 'reply To ' = > $ message - > get Reply To ( ) ] ) ; $ this - > driver - > publish ( ' ' , new Message ( $ return Value , $ message - > get Reply To ( ) , $ message - > get Headers ( ) , $ message - > get Correlation Id ( ) ) ) ; } 
public function deserialize ( $ message ) { if ( $ message = = = null ) { return null ; } Assertion : : string ( $ message , 'The message to deserialize must be a valid string ' ) ; return unserialize ( $ message ) ; } 
protected function execute ( Input Interface $ input , Output Interface $ output ) { $ queue = $ input - > get Argument ( 'name ' ) ; $ this - > driver - > declare Simple Queue ( $ queue ) ; $ output - > writeln ( sprintf ( ' <info >Declare queue <comment > %s < /comment > < /info > ' , $ queue ) ) ; } 
public static function get Driver ( $ connection ) { if ( is _array ( $ connection ) & & isset ( $ connection [ 'host ' ] , $ connection [ 'port ' ] , $ connection [ 'user ' ] , $ connection [ 'pwd ' ] ) ) { $ connection = self : : get Connection From Array ( $ connection ) ; } if ( $ connection instanceof Abstract Connection ) { return new Php Amqp Lib Driver ( $ connection ) ; } if ( $ connection instanceof \ AMQPConnection ) { return new Pecl Amqp Driver ( $ connection ) ; } throw new \ Invalid Argument Exception ( 'You provided an unsupported connection ' ) ; } 
protected static function get Pecl Connection ( array $ connection ) { $ amqp Connection = new \ AMQPConnection ( ) ; $ amqp Connection - > set Host ( $ connection [ 'host ' ] ) ; $ amqp Connection - > set Port ( $ connection [ 'port ' ] ) ; $ amqp Connection - > set Login ( $ connection [ 'user ' ] ) ; $ amqp Connection - > set Password ( $ connection [ 'pwd ' ] ) ; return $ amqp Connection ; } 
protected function execute ( Input Interface $ input , Output Interface $ output ) { $ name = $ input - > get Argument ( 'name ' ) ; $ this - > driver - > delete Exchange ( $ name ) ; $ output - > writeln ( sprintf ( ' <info >Delete exchange <comment > %s < /comment > < /info > ' , $ name ) ) ; } 
private function check Headers ( array $ headers ) { foreach ( $ headers as $ key = > $ value ) { Assertion : : string ( $ key , 'Header key must be a string ' ) ; Assertion : : not Blank ( $ key , 'Header key must be a non empty string ' ) ; Assertion : : not Null ( $ value , 'Value cannot be null ' ) ; if ( ! is _string ( $ value ) & & ! is _numeric ( $ value ) & & ! is _bool ( $ value ) ) { throw new \ Invalid Argument Exception ( 'Value must be a string , a number or a boolean . ' ) ; } } } 
public function declare Simple Queue ( $ queue Name = ' ' , $ type = self : : QUEUE _DURABLE ) { $ durable = ( $ type = = = self : : QUEUE _DURABLE ) ; $ exclusive = ( $ type = = = self : : QUEUE _EXCLUSIVE ) ; list ( $ name , , ) = $ this - > get Channel ( ) - > queue _declare ( $ queue Name , false , $ durable , $ exclusive , false ) ; return $ name ; } 
public function declare Exchange ( $ exchange Name = ' ' , $ type = self : : EXCHANGE _TYPE _FANOUT ) { list ( $ name , , ) = $ this - > get Channel ( ) - > exchange _declare ( $ exchange Name , $ type , false , true , false ) ; return $ name ; } 
public function bind Queue ( $ exchange , $ queue Name , $ routing Key = ' ' ) { $ this - > get Channel ( ) - > queue _bind ( $ queue Name , $ exchange , $ routing Key ) ; } 
public function publish ( $ exchange Name , Message $ message ) { $ this - > get Channel ( ) - > basic _publish ( new AMQPMessage ( $ message - > get Body ( ) , self : : get Message Properties ( $ message ) ) , $ exchange Name , $ message - > get Routing Key ( ) ) ; } 
public function consume ( $ queue Name , callable $ callback , $ timeout = 0 , $ auto Ack = true ) { $ this - > stop = false ; $ this - > get Channel ( ) - > basic _qos ( null , 1 , null ) ; $ this - > get Channel ( ) - > basic _consume ( $ queue Name , ' ' , false , $ auto Ack , false , false , function ( AMQPMessage $ message ) use ( $ callback , $ queue Name ) { $ burrow Message = new Message ( $ message - > get Body ( ) , ' ' , 
public function nack ( Message $ message , $ requeue = true ) { $ this - > get Channel ( ) - > basic _reject ( $ message - > get Delivery Tag ( ) , $ requeue ) ; } 
public function close ( ) { $ this - > stop = true ; $ this - > get Channel ( ) - > close ( ) ; $ this - > connection - > close ( ) ; } 
private function wait ( $ timeout ) { while ( count ( $ this - > get Channel ( ) - > callbacks ) & & ! $ this - > stop ) { try { $ this - > get Channel ( ) - > wait ( null , false , $ timeout ) ; } catch ( AMQPTimeout Exception $ e ) { throw Timeout Exception : : build ( $ e , $ timeout ) ; } catch ( \ Exception $ e ) { if ( $ e instanceof AMQPException Interface ) { throw Consumer Exception : : build ( $ e ) ; } throw $ e ; } } } 
private static function get Headers ( AMQPMessage $ message ) { return $ message - > has ( self : : APPLICATION _HEADERS ) ? $ message - > get ( self : : APPLICATION _HEADERS ) - > get Native Data ( ) : [ ] ; } 
private static function get Correlation Id ( AMQPMessage $ message ) { return $ message - > has ( self : : CORRELATION _ID ) ? $ message - > get ( self : : CORRELATION _ID ) : ' ' ; } 
private static function get Reply To ( AMQPMessage $ message ) { return $ message - > has ( self : : REPLY _TO ) ? $ message - > get ( self : : REPLY _TO ) : ' ' ; } 
public function consume ( $ message , array $ headers = [ ] ) { return $ this - > serializer - > serialize ( $ this - > consumer - > consume ( $ this - > serializer - > deserialize ( $ message ) , $ headers ) ) ; } 
protected function build Class ( $ name ) { $ stub = parent : : build Class ( $ name ) ; return $ this - > replace Model Import ( $ stub ) - > replace Model ( $ stub ) ; } 
protected function replace Model ( & $ stub ) { $ model = explode ( ' \ \ ' , $ this - > get Model ( ) ) ; $ model = array _pop ( $ model ) ; $ stub = str _replace ( 'Model Name ' , $ model , $ stub ) ; return $ stub ; } 
protected function qualify Class ( $ name ) { $ root Namespace = $ this - > laravel - > get Namespace ( ) ; if ( Str : : starts With ( $ name , $ root Namespace ) ) { return $ name ; } if ( Str : : contains ( $ name , ' / ' ) ) { $ name = str _replace ( ' / ' , ' \ \ ' , $ name ) ; } if ( ! Str : : contains ( Str : : lower ( $ name ) , 'datatable ' ) ) { $ name . = $ this - > type ; } return $ this - > get Default Namespace ( trim ( $ root Namespace , ' \ \ ' ) ) . ' \ \ ' . $ name ; } 
public function process ( Request $ request ) { $ action = $ request - > get ( 'action ' ) ; if ( ! in _array ( $ action , $ this - > actions ) ) { throw new Data Tables Editor Exception ( 'Requested action not supported ! ' ) ; } return $ this - > { $ action } ( $ request ) ; } 
public function create ( Request $ request ) { $ instance = $ this - > resolve Model ( ) ; $ connection = $ instance - > get Connection ( ) ; $ affected = [ ] ; $ errors = [ ] ; $ connection - > begin Transaction ( ) ; foreach ( $ request - > get ( 'data ' ) as $ data ) { $ validator = $ this - > get Validation Factory ( ) - > make ( $ data , $ this - > create Rules ( ) , $ this - > create Messages ( ) , $ this - > attributes ( ) ) ; if ( $ validator - > fails ( ) ) { foreach ( $ this - > format Errors ( $ validator ) as $ error ) { $ errors [ ] = $ error ; } continue ; } if ( method _exists ( $ this , 'creating ' ) ) { $ data = $ this - > creating ( $ instance , $ data ) ; } if ( method _exists ( $ this , 'saving ' ) ) { $ data = $ this - > saving ( $ instance , $ data ) ; } $ model = $ instance - > new Query ( ) - > create ( $ data ) ; $ model - > set Attribute ( 'DT _Row Id ' , $ model - > get Key ( ) ) ; if ( method _exists ( $ this , 'created ' ) ) { $ this - > created ( $ model , $ data ) ; } if ( method _exists ( $ this , 'saved ' ) ) { $ this - > saved ( $ model , $ data ) ; } $ affected [ ] = $ model ; } if ( ! $ errors ) { $ connection - > commit ( ) ; } else { $ connection - > roll Back ( ) ; } return $ this - > to Json ( $ affected , $ errors ) ; } 
protected function to Json ( array $ data , array $ errors = [ ] ) { $ response = [ 'data ' = > $ data ] ; if ( $ errors ) { $ response [ 'field Errors ' ] = $ errors ; } return new Json Response ( $ response , 2 0 0 ) ; } 
public function edit ( Request $ request ) { $ instance = $ this - > resolve Model ( ) ; $ connection = $ instance - > get Connection ( ) ; $ affected = [ ] ; $ errors = [ ] ; $ connection - > begin Transaction ( ) ; foreach ( $ request - > get ( 'data ' ) as $ key = > $ data ) { $ model = $ instance - > new Query ( ) - > find ( $ key ) ; $ validator = $ this - > get Validation Factory ( ) - > make ( $ data , $ this - > edit Rules ( $ model ) , $ this - > edit Messages ( ) , $ this - > attributes ( ) ) ; if ( $ validator - > fails ( ) ) { foreach ( $ this - > format Errors ( $ validator ) as $ error ) { $ errors [ ] = $ error ; } continue ; } if ( method _exists ( $ this , 'updating ' ) ) { $ data = $ this - > updating ( $ model , $ data ) ; } if ( method _exists ( $ this , 'saving ' ) ) { $ data = $ this - > saving ( $ model , $ data ) ; } $ model - > update ( $ data ) ; if ( method _exists ( $ this , 'updated ' ) ) { $ this - > updated ( $ model , $ data ) ; } if ( method _exists ( $ this , 'saved ' ) ) { $ this - > saved ( $ model , $ data ) ; } $ model - > set Attribute ( 'DT _Row Id ' , $ model - > get Key ( ) ) ; $ affected [ ] = $ model ; } if ( ! $ errors ) { $ connection - > commit ( ) ; } else { $ connection - > roll Back ( ) ; } return $ this - > to Json ( $ affected , $ errors ) ; } 
public function remove ( Request $ request ) { $ instance = $ this - > resolve Model ( ) ; $ connection = $ instance - > get Connection ( ) ; $ affected = [ ] ; $ errors = [ ] ; $ connection - > begin Transaction ( ) ; foreach ( $ request - > get ( 'data ' ) as $ key = > $ data ) { $ model = $ instance - > new Query ( ) - > find ( $ key ) ; $ validator = $ this - > get Validation Factory ( ) - > make ( $ data , $ this - > remove Rules ( $ model ) , $ this - > remove Messages ( ) , $ this - > attributes ( ) ) ; if ( $ validator - > fails ( ) ) { foreach ( $ this - > format Errors ( $ validator ) as $ error ) { $ errors [ ] = $ error [ 'status ' ] ; } continue ; } try { if ( method _exists ( $ this , 'deleting ' ) ) { $ this - > deleting ( $ model , $ data ) ; } $ model - > delete ( ) ; if ( method _exists ( $ this , 'deleted ' ) ) { $ this - > deleted ( $ model , $ data ) ; } } catch ( Query Exception $ exception ) { $ error = config ( 'app .debug ' ) ? $ exception - > error Info [ 2 ] : $ this - > remove Exception Message ( $ exception , $ model ) ; $ errors [ ] = $ error ; } $ affected [ ] = $ model ; } if ( ! $ errors ) { $ connection - > commit ( ) ; } else { $ connection - > roll Back ( ) ; } $ response = [ 'data ' = > $ affected ] ; if ( $ errors ) { $ response [ 'error ' ] = implode ( " \n " , $ errors ) ; } return new Json Response ( $ response , 2 0 0 ) ; } 
protected function vote On Attribute ( $ attribute , $ subject , Token Interface $ token ) { return $ this - > is Logged In User ( $ token ) | | ! $ this - > in List ( $ subject - > get Name ( ) ) ; } 
public function explorer Action ( ) { $ response = $ this - > render ( ' @Graph QLBundle /Feature /explorer .html .twig ' , [ 'graph QLUrl ' = > $ this - > generate Url ( 'youshido _graphql _graphql _default ' ) , 'token Header ' = > 'access -token ' ] ) ; $ date = \ Date Time : : create From Format ( 'U ' , strtotime ( 'tomorrow ' ) , new \ Date Time Zone ( 'UTC ' ) ) ; $ response - > set Expires ( $ date ) ; $ response - > set Public ( ) ; return $ response ; } 
public function is Security Enabled For ( $ attribute ) { if ( Security Manager Interface : : RESOLVE _FIELD _ATTRIBUTE = = $ attribute ) { return $ this - > field Security Enabled ; } else if ( Security Manager Interface : : RESOLVE _ROOT _OPERATION _ATTRIBUTE = = $ attribute ) { return $ this - > root Operation Security Enabled ; } return false ; } 
public function load ( array $ configs , Container Builder $ container ) { $ configuration = new Configuration ( ) ; $ this - > config = $ this - > process Configuration ( $ configuration , $ configs ) ; $ prepared Headers = [ ] ; $ headers = $ this - > config [ 'response ' ] [ 'headers ' ] ? $ this - > config [ 'response ' ] [ 'headers ' ] : $ this - > get Default Headers ( ) ; foreach ( $ headers as $ header ) { $ prepared Headers [ $ header [ 'name ' ] ] = $ header [ 'value ' ] ; } $ container - > set Parameter ( 'graphql .response .headers ' , $ prepared Headers ) ; $ container - > set Parameter ( 'graphql .schema _class ' , $ this - > config [ 'schema _class ' ] ) ; $ container - > set Parameter ( 'graphql .schema _service ' , $ this - > config [ 'schema _service ' ] ) ; $ container - > set Parameter ( 'graphql .logger ' , $ this - > config [ 'logger ' ] ) ; $ container - > set Parameter ( 'graphql .max _complexity ' , $ this - > config [ 'max _complexity ' ] ) ; $ container - > set Parameter ( 'graphql .response .json _pretty ' , $ this - > config [ 'response ' ] [ 'json _pretty ' ] ) ; $ container - > set Parameter ( 'graphql .security .guard _config ' , [ 'field ' = > $ this - > config [ 'security ' ] [ 'guard ' ] [ 'field ' ] , 'operation ' = > $ this - > config [ 'security ' ] [ 'guard ' ] [ 'operation ' ] ] ) ; $ container - > set Parameter ( 'graphql .security .black _list ' , $ this - > config [ 'security ' ] [ 'black _list ' ] ) ; $ container - > set Parameter ( 'graphql .security .white _list ' , $ this - > config [ 'security ' ] [ 'white _list ' ] ) ; $ loader = new Loader \ Xml File Loader ( $ container , new File Locator ( _ _DIR _ _ . ' / . . /Resources /config ' ) ) ; $ loader - > load ( 'services .xml ' ) ; } 
public function get Config Tree Builder ( ) { $ tree Builder = new Tree Builder ( ) ; $ root Node = $ tree Builder - > root ( 'graphql ' ) ; $ root Node - > children ( ) - > scalar Node ( 'schema _class ' ) - > default Value ( null ) - > end ( ) - > scalar Node ( 'schema _service ' ) - > default Value ( null ) - > end ( ) - > integer Node ( 'max _complexity ' ) - > default Value ( null ) - > end ( ) - > scalar Node ( 'logger ' ) - > default Value ( null ) - > end ( ) - > array Node ( 'security ' ) - > add Defaults If Not Set ( ) - > can Be Unset ( ) - > children ( ) - > array Node ( 'guard ' ) - > add Defaults If Not Set ( ) - > can Be Unset ( ) - > children ( ) - > boolean Node ( 'operation ' ) - > default False ( ) - > end ( ) - > boolean Node ( 'field ' ) - > default False ( ) - > end ( ) - > end ( ) - > end ( ) - > array Node ( 'white _list ' ) - > can Be Unset ( ) - > default Value ( [ ] ) - > prototype ( 'scalar ' ) - > end ( ) - > end ( ) - > array Node ( 'black _list ' ) - > can Be Unset ( ) - > default Value ( [ ] ) - > prototype ( 'scalar ' ) - > end ( ) - > end ( ) - > end ( ) - > end ( ) - > array Node ( 'response ' ) - > add Defaults If Not Set ( ) - > can Be Unset ( ) - > children ( ) - > boolean Node ( 'json _pretty ' ) - > default True ( ) - > end ( ) - > array Node ( 'headers ' ) - > prototype ( 'array ' ) - > children ( ) - > scalar Node ( 'name ' ) - > end ( ) - > scalar Node ( 'value ' ) - > default Value ( null ) - > end ( ) - > end ( ) - > end ( ) - > end ( ) - > end ( ) - > end ( ) - > end ( ) ; return $ tree Builder ; } 
public function default Action ( ) { try { $ this - > initialize Schema Service ( ) ; } catch ( Unable To Initialize Schema Service Exception $ e ) { return new Json Response ( [ [ 'message ' = > 'Schema class ' . $ this - > get Schema Class ( ) . ' does not exist ' ] ] , 2 0 0 , $ this - > get Response Headers ( ) ) ; } if ( $ this - > get ( 'request _stack ' ) - > get Current Request ( ) - > get Method ( ) = = 'OPTIONS ' ) { return $ this - > create Empty Response ( ) ; } list ( $ queries , $ is Multi Query Request ) = $ this - > get Payload ( ) ; $ query Responses = array _map ( function ( $ query Data ) { return $ this - > execute Query ( $ query Data [ 'query ' ] , $ query Data [ 'variables ' ] ) ; } , $ queries ) ; $ response = new Json Response ( $ is Multi Query Request ? $ query Responses : $ query Responses [ 0 ] , 2 0 0 , $ this - > get Parameter ( 'graphql .response .headers ' ) ) ; if ( $ this - > get Parameter ( 'graphql .response .json _pretty ' ) ) { $ response - > set Encoding Options ( $ response - > get Encoding Options ( ) | JSON _PRETTY _PRINT ) ; } return $ response ; } 
private function get Payload ( ) { $ request = $ this - > get ( 'request _stack ' ) - > get Current Request ( ) ; $ query = $ request - > get ( 'query ' , null ) ; $ variables = $ request - > get ( 'variables ' , [ ] ) ; $ is Multi Query Request = false ; $ queries = [ ] ; $ variables = is _string ( $ variables ) ? json _decode ( $ variables , true ) ? : [ ] : [ ] ; $ content = $ request - > get Content ( ) ; if ( ! empty ( $ content ) ) { if ( $ request - > headers - > has ( 'Content -Type ' ) & & 'application /graphql ' = = $ request - > headers - > get ( 'Content -Type ' ) ) { $ queries [ ] = [ 'query ' = > $ content , 'variables ' = > [ ] , ] ; } else { $ params = json _decode ( $ content , true ) ; if ( $ params ) { 
private function make Schema Service ( ) { if ( $ this - > container - > has ( $ this - > get Schema Service ( ) ) ) { return $ this - > container - > get ( $ this - > get Schema Service ( ) ) ; } $ schema Class = $ this - > get Schema Class ( ) ; if ( ! $ schema Class | | ! class _exists ( $ schema Class ) ) { throw new Unable To Initialize Schema Service Exception ( ) ; } if ( $ this - > container - > has ( $ schema Class ) ) { return $ this - > container - > get ( $ schema Class ) ; } $ schema = new $ schema Class ( ) ; if ( $ schema instanceof Container Aware Interface ) { $ schema - > set Container ( $ this - > container ) ; } return $ schema ; } 
protected function execute ( Input Interface $ input , Output Interface $ output ) { $ is Composer Call = $ input - > get Option ( 'composer ' ) ; $ container = $ this - > get Container ( ) ; $ root Dir = $ container - > get Parameter ( 'kernel .root _dir ' ) ; $ config File = $ root Dir . DIRECTORY _SEPARATOR . ' . . ' . DIRECTORY _SEPARATOR . 'config /packages /graphql .yml ' ; $ class Name = 'Schema ' ; $ schema Namespace = self : : PROJECT _NAMESPACE . ' \ \Graph QL ' ; $ graphql Path = rtrim ( $ root Dir , DIRECTORY _SEPARATOR ) . DIRECTORY _SEPARATOR . 'Graph QL ' ; $ class Path = $ graphql Path . DIRECTORY _SEPARATOR . $ class Name . ' .php ' ; $ input Helper = $ this - > get Helper ( 'question ' ) ; if ( file _exists ( $ class Path ) ) { if ( ! $ is Composer Call ) { $ output - > writeln ( sprintf ( 'Schema class %s was found . ' , $ schema Namespace . ' \ \ ' . $ class Name ) ) ; } } else { $ question = new Confirmation Question ( sprintf ( 'Confirm creating class at %s ? [Y /n ] ' , $ schema Namespace . ' \ \ ' . $ class Name ) , true ) ; if ( ! $ input Helper - > ask ( $ input , $ output , $ question ) ) { return ; } if ( ! is _dir ( $ graphql Path ) ) { mkdir ( $ graphql Path , 0 7 7 7 , true ) ; } file _put _contents ( $ class Path , $ this - > get Schema Class Template ( $ schema Namespace , $ class Name ) ) ; $ output - > writeln ( 'Schema file has been created at ' ) ; $ output - > writeln ( $ class Path . " \n " ) ; if ( ! file _exists ( $ config File ) ) { $ question = new Confirmation Question ( sprintf ( 'Config file not found (look at %s ) . Create it ? [Y /n ] ' , $ config File ) , true ) ; if ( ! $ input Helper - > ask ( $ input , $ output , $ question ) ) { return ; } touch ( $ config File ) ; } $ original Config Data = file _get _contents ( $ config File ) ; if ( strpos ( $ original Config Data , 'graphql ' ) = = = false ) { $ project Name Space = self : : PROJECT _NAMESPACE ; $ config Data = < < <CONFIG graphql : schema _class : " { $project Name Space } \ \ \ \Graph QL \ \ \ \ { $class Name } " CONFIG ; file _put _contents ( $ config File , $ config Data . $ original Config Data ) ; } } if ( ! $ this - > graph QLRoute Exists ( ) ) { $ question = new Confirmation Question ( 'Confirm adding Graph QL route ? [Y /n ] ' , true ) ; $ resource = $ this - > get Main Route Config ( ) ; if ( $ resource & & $ input Helper - > ask ( $ input , $ output , $ question ) ) { $ route Config Data = < < <CONFIG graphql : resource : " @Graph QLBundle /Controller / " CONFIG ; file _put _contents ( $ resource , $ route Config Data , FILE _APPEND ) ; $ output - > writeln ( 'Config was added to ' . $ resource ) ; } } else { if ( ! $ is Composer Call ) { $ output - > writeln ( 'Graph QL default route was found . ' ) ; } } } 
protected function get Main Route Config ( ) { $ router Resources = $ this - > get Container ( ) - > get ( 'router ' ) - > get Route Collection ( ) - > get Resources ( ) ; foreach ( $ router Resources as $ resource ) { if ( method _exists ( $ resource , 'get Resource ' ) & & substr ( $ resource - > get Resource ( ) , - 1 1 ) = = 'routes .yaml ' ) { return $ resource - > get Resource ( ) ; } } return null ; } 
public function process ( Container Builder $ container ) { if ( $ logger Alias = $ container - > get Parameter ( 'graphql .logger ' ) ) { if ( strpos ( $ logger Alias , ' @ ' ) = = = 0 ) { $ logger Alias = substr ( $ logger Alias , 1 ) ; } if ( ! $ container - > has ( $ logger Alias ) ) { throw new \ Runtime Exception ( sprintf ( 'Logger " %s " not found ' , $ logger Alias ) ) ; } $ container - > get Definition ( 'graphql .processor ' ) - > add Method Call ( 'set Logger ' , [ new Reference ( $ logger Alias ) ] ) ; } if ( $ max Complexity = $ container - > get Parameter ( 'graphql .max _complexity ' ) ) { $ container - > get Definition ( 'graphql .processor ' ) - > add Method Call ( 'set Max Complexity ' , [ $ max Complexity ] ) ; } $ this - > process Security Guard ( $ container ) ; } 
private function process Security Guard ( Container Builder $ container ) { $ guard Config = $ container - > get Parameter ( 'graphql .security .guard _config ' ) ; $ white List = $ container - > get Parameter ( 'graphql .security .white _list ' ) ; $ black List = $ container - > get Parameter ( 'graphql .security .black _list ' ) ; if ( ( ! $ guard Config [ 'field ' ] & & ! $ guard Config [ 'operation ' ] ) & & ( $ white List | | $ black List ) ) { if ( $ white List & & $ black List ) { throw new \ Runtime Exception ( 'Configuration error : Only one white or black list allowed ' ) ; } $ this - > add List Voter ( $ container , Blacklist Voter : : class , $ black List ) ; $ this - > add List Voter ( $ container , Whitelist Voter : : class , $ white List ) ; } } 
private function add List Voter ( Container Builder $ container , $ voter Class , array $ list ) { if ( $ list ) { $ container - > get Definition ( 'graphql .security .voter ' ) - > set Class ( $ voter Class ) - > add Method Call ( 'set Enabled ' , [ true ] ) - > add Method Call ( 'set List ' , [ $ list ] ) ; $ container - > set Parameter ( 'graphql .security .guard _config ' , [ 'operation ' = > true , 'field ' = > false , ] ) ; } } 
public function get Hash Sign ( $ xml ) { $ doc = new \ DOMDocument ( ) ; @ $ doc - > load XML ( $ xml ) ; return $ this - > get Hash Sign From Doc ( $ doc ) ; } 
public function get Hash Sign From File ( $ filename ) { $ doc = new \ DOMDocument ( ) ; @ $ doc - > load ( $ filename ) ; return $ this - > get Hash Sign From Doc ( $ doc ) ; } 
public function get Hash Sign From Doc ( \ DOMDocument $ document ) { $ xpt = $ this - > get Xpath ( $ document ) ; $ exts = $ xpt - > query ( 'ext :UBLExtensions /ext :UBLExtension ' , $ document - > document Element ) ; if ( $ exts - > length = = 0 ) { return ' ' ; } return $ this - > get Hash ( $ exts , $ xpt ) ; } 
private function get Xpath ( \ DOMDocument $ document ) { $ xpt = new \ DOMXPath ( $ document ) ; $ xpt - > register Namespace ( 'ext ' , self : : EXT _NAMESPACE ) ; $ xpt - > register Namespace ( 'ds ' , self : : DS _NAMESPACE ) ; return $ xpt ; } 
public function get Image ( $ sale ) { $ client = $ sale - > get Client ( ) ; $ params = [ $ sale - > get Company ( ) - > get Ruc ( ) , $ sale - > get Tipo Doc ( ) , $ sale - > get Serie ( ) , $ sale - > get Correlativo ( ) , number _format ( $ sale - > get Mto IGV ( ) , 2 , ' . ' , ' ' ) , number _format ( $ sale - > get Mto Imp Venta ( ) , 2 , ' . ' , ' ' ) , $ sale - > get Fecha Emision ( ) - > format ( 'Y -m -d ' ) , $ client - > get Tipo Doc ( ) , $ client - > get Num Doc ( ) , ] ; $ content = implode ( ' | ' , $ params ) . ' | ' ; return $ this - > get Qr Image ( $ content ) ; } 
public function get Template ( $ document ) { $ class Name = get _class ( $ document ) ; switch ( $ class Name ) { case \ Greenter \ Model \ Sale \ Invoice : : class : case \ Greenter \ Model \ Sale \ Note : : class : $ name = 'invoice ' ; break ; case \ Greenter \ Model \ Retention \ Retention : : class : $ name = 'retention ' ; break ; case \ Greenter \ Model \ Perception \ Perception : : class : $ name = 'perception ' ; break ; case \ Greenter \ Model \ Despatch \ Despatch : : class : $ name = 'despatch ' ; break ; case \ Greenter \ Model \ Summary \ Summary : : class : $ name = 'summary ' ; break ; case \ Greenter \ Model \ Voided \ Voided : : class : case \ Greenter \ Model \ Voided \ Reversion : : class : $ name = 'voided ' ; break ; default : throw new \ Exception ( 'Not found template for ' . $ class Name ) ; } return $ name . ' .html .twig ' ; } 
public function get Value Legend ( $ legends , $ code ) { foreach ( $ legends as $ legend ) { if ( $ legend - > get Code ( ) = = $ code ) { return $ legend - > get Value ( ) ; } } return ' ' ; } 
public function render ( Document Interface $ document , $ parameters = [ ] ) { $ html = $ this - > twig - > render ( $ this - > template , [ 'doc ' = > $ document , 'params ' = > $ parameters , ] ) ; return $ html ; } 
private function build Twig ( $ directory , $ options ) { $ dirs = $ this - > get Directories ( $ directory ) ; $ loader = new \ Twig _Loader _Filesystem ( $ dirs ) ; $ twig = new \ Twig _Environment ( $ loader , $ options ) ; $ twig - > add Runtime Loader ( new Runtime Loader ( ) ) ; $ twig - > add Extension ( new Report Twig Extension ( ) ) ; return $ twig ; } 
public function get ( $ length = null ) { if ( $ length = = = null ) { $ length = $ this - > limit - $ this - > position ; } elseif ( $ length > $ this - > remaining ( ) ) { throw new Buffer Under Flow Exception ( ) ; } $ data = substr ( $ this - > byte Array , $ this - > position , $ length ) ; $ this - > position + = $ length ; return $ data ; } 
public function get String ( ) { $ zero Byte Index = strpos ( $ this - > byte Array , " \ 0 " , $ this - > position ) ; if ( $ zero Byte Index = = = false ) { return ' ' ; } else { $ data String = $ this - > get ( $ zero Byte Index - $ this - > position ) ; $ this - > position + + ; return $ data String ; } } 
public function limit ( $ new Limit = null ) { if ( $ new Limit = = null ) { return $ this - > limit ; } else { $ this - > limit = $ new Limit ; return null ; } } 
public function put ( $ source Byte Array ) { $ new Position = min ( $ this - > remaining ( ) , strlen ( $ source Byte Array ) ) ; $ this - > byte Array = substr _replace ( $ this - > byte Array , $ source Byte Array , $ this - > position , $ new Position ) ; $ this - > position = $ new Position ; return $ this ; } 
public static function get Packet From Data ( $ raw Data ) { $ header = ord ( $ raw Data [ 0 ] ) ; $ data = substr ( $ raw Data , 1 ) ; switch ( $ header ) { case Steam Packet : : S 2A _INFO _DETAILED _HEADER : return new S 2AINFODETAILEDPacket ( $ data ) ; case Steam Packet : : S 2A _INFO 2 _HEADER : return new S 2AINFO 2Packet ( $ data ) ; case Steam Packet : : S 2A _PLAYER _HEADER : return new S 2APLAYERPacket ( $ data ) ; case Steam Packet : : S 2A _RULES _HEADER : return new S 2ARULESPacket ( $ data ) ; case Steam Packet : : S 2C _CHALLENGE _HEADER : return new S 2CCHALLENGEPacket ( $ data ) ; case Steam Packet : : M 2A _SERVER _BATCH _HEADER : return new M 2ASERVERBATCHPacket ( $ data ) ; case Steam Packet : : RCON _GOLDSRC _CHALLENGE _HEADER : case Steam Packet : : RCON _GOLDSRC _NO _CHALLENGE _HEADER : case Steam Packet : : RCON _GOLDSRC _RESPONSE _HEADER : return new RCONGold Src Response ( $ data ) ; default : throw new Packet Format Exception ( 'Unknown packet with header 0x ' . dechex ( $ header ) . ' received . ' ) ; } } 
public static function reassemble Packet ( $ split Packets , $ is Compressed = false , $ packet Checksum = 0 ) { $ packet Data = join ( ' ' , $ split Packets ) ; if ( $ is Compressed ) { $ packet Data = bzdecompress ( $ packet Data ) ; if ( crc 3 2 ( $ packet Data ) ! = $ packet Checksum ) { throw new Packet Format Exception ( 'CRC 3 2 checksum mismatch of uncompressed packet data . ' ) ; } } $ packet Data = substr ( $ packet Data , 4 ) ; return self : : get Packet From Data ( $ packet Data ) ; } 
public static function get Global Percentages ( $ app Id ) { $ params = [ 'gameid ' = > $ app Id ] ; $ data = Web Api : : get JSONObject ( 'ISteam User Stats ' , 'Get Global Achievement Percentages For App ' , 2 , $ params ) ; $ percentages = [ ] ; foreach ( $ data - > achievementpercentages - > achievements as $ achievement Data ) { $ percentages [ $ achievement Data - > name ] = ( float ) $ achievement Data - > percent ; } return $ percentages ; } 
public function close ( ) { if ( ! empty ( $ this - > socket ) & & $ this - > socket - > is Open ( ) ) { $ this - > socket - > close ( ) ; } } 
public function receive Packet ( $ buffer Length = 0 ) { if ( ! $ this - > socket - > select ( self : : $ timeout ) ) { throw new Timeout Exception ( ) ; } if ( $ buffer Length = = 0 ) { $ this - > buffer - > clear ( ) ; } else { $ this - > buffer = Byte Buffer : : allocate ( $ buffer Length ) ; } try { $ data = $ this - > socket - > recv ( $ this - > buffer - > remaining ( ) ) ; $ this - > buffer - > put ( $ data ) ; } catch ( Connection Reset Exception $ e ) { $ this - > socket - > close ( ) ; throw $ e ; } $ bytes Read = $ this - > buffer - > position ( ) ; $ this - > buffer - > rewind ( ) ; $ this - > buffer - > limit ( $ bytes Read ) ; return $ bytes Read ; } 
public function send ( Steam Packet $ data Packet ) { $ this - > logger - > debug ( "Sending packet of type \ " " . get _class ( $ data Packet ) . " \ " . . . " ) ; $ this - > socket - > send ( $ data Packet - > _ _to String ( ) ) ; } 
public function get Reply ( ) { $ this - > receive Packet ( 1 4 0 0 ) ; $ is Compressed = false ; if ( $ this - > buffer - > get Long ( ) = = - 2 ) { do { $ request Id = $ this - > buffer - > get Long ( ) ; $ is Compressed = ( ( $ request Id & 0x 8 0 0 0 0 0 0 0 ) ! = 0 ) ; $ packet Count = $ this - > buffer - > get Byte ( ) ; $ packet Number = $ this - > buffer - > get Byte ( ) + 1 ; if ( $ is Compressed ) { $ split Size = $ this - > buffer - > get Long ( ) ; $ packet Checksum = $ this - > buffer - > get Unsigned Long ( ) ; } else { $ split Size = $ this - > buffer - > get Short ( ) ; } $ split Packets [ $ packet Number ] = $ this - > buffer - > get ( ) ; $ this - > logger - > debug ( "Received packet $packet Number of $packet Count for request # $request Id " ) ; if ( sizeof ( $ split Packets ) < $ packet Count ) { try { $ bytes Read = $ this - > receive Packet ( ) ; } catch ( Timeout Exception $ e ) { $ bytes Read = 0 ; } } else { $ bytes Read = 0 ; } } while ( $ bytes Read > 0 & & $ this - > buffer - > get Long ( ) = = - 2 ) ; if ( $ is Compressed ) { $ packet = Steam Packet Factory : : reassemble Packet ( $ split Packets , true , $ packet Checksum ) ; } else { $ packet = Steam Packet Factory : : reassemble Packet ( $ split Packets ) ; } } else { $ packet = Steam Packet Factory : : get Packet From Data ( $ this - > buffer - > get ( ) ) ; } if ( $ is Compressed ) { $ this - > logger - > debug ( "Received compressed reply of type \ " " . get _class ( $ packet ) . " \ " " ) ; } else { $ this - > logger - > debug ( "Received reply of type \ " " . get _class ( $ packet ) . " \ " " ) ; } return $ packet ; } 
public function get Reply ( ) { $ this - > receive Packet ( 1 5 0 0 ) ; if ( $ this - > buffer - > get Long ( ) ! = - 1 ) { throw new Packet Format Exception ( "Master query response has wrong packet header . " ) ; } $ packet = Steam Packet Factory : : get Packet From Data ( $ this - > buffer - > get ( ) ) ; $ this - > logger - > debug ( "Received reply of type \ " " . get _class ( $ packet ) . " \ " " ) ; return $ packet ; } 
public static function create Inventory ( $ steam Id , $ fetch Now = true , $ bypass Cache = false ) { return parent : : create ( self : : APP _ID , $ steam Id , $ fetch Now , $ bypass Cache ) ; } 
public function get Reply ( ) { $ bytes Read = $ this - > receive Packet ( 1 4 0 0 ) ; if ( $ this - > buffer - > get Long ( ) = = - 2 ) { do { $ request Id = $ this - > buffer - > get Long ( ) ; $ packet Count And Number = $ this - > buffer - > get Byte ( ) ; $ packet Count = $ packet Count And Number & 0x F ; $ packet Number = ( $ packet Count And Number > > 4 ) + 1 ; $ split Packets [ $ packet Number - 1 ] = $ this - > buffer - > get ( ) ; $ this - > logger - > debug ( "Received packet $packet Number of $packet Count for request # $request Id " ) ; if ( sizeof ( $ split Packets ) < $ packet Count ) { try { $ bytes Read = $ this - > receive Packet ( ) ; } catch ( \ Steam Condenser \ Exceptions \ Timeout Exception $ e ) { $ bytes Read = 0 ; } } else { $ bytes Read = 0 ; } } while ( $ bytes Read > 0 & & $ this - > buffer - > get Long ( ) = = - 2 ) ; $ packet = Steam Packet Factory : : reassemble Packet ( $ split Packets ) ; } else { $ packet = Steam Packet Factory : : get Packet From Data ( $ this - > buffer - > get ( ) ) ; } $ this - > logger - > debug ( "Received packet of type \ " " . get _class ( $ packet ) . " \ " " ) ; return $ packet ; } 
public function rcon Exec ( $ password , $ command ) { if ( $ this - > rcon Challenge = = - 1 | | $ this - > is HLTV ) { $ this - > rcon Get Challenge ( ) ; } $ this - > rcon Send ( "rcon { $this - >rcon Challenge } $password $command " ) ; if ( $ this - > is HLTV ) { try { $ response = $ this - > get Reply ( ) - > get Response ( ) ; } catch ( \ Steam Condenser \ Exceptions \ Timeout Exception $ e ) { $ response = ' ' ; } } else { $ response = $ this - > get Reply ( ) - > get Response ( ) ; } if ( trim ( $ response ) = = 'Bad rcon _password . ' ) { throw new \ Steam Condenser \ Exceptions \ RCONNo Auth Exception ( ) ; } elseif ( trim ( $ response ) = = 'You have been banned from this server . ' ) { throw new \ Steam Condenser \ Exceptions \ RCONBan Exception ( ) ; } $ this - > rcon Send ( "rcon { $this - >rcon Challenge } $password " ) ; do { $ response Part = $ this - > get Reply ( ) - > get Response ( ) ; $ response . = $ response Part ; } while ( strlen ( $ response Part ) > 0 ) ; return $ response ; } 
public function rcon Get Challenge ( ) { $ this - > rcon Send ( 'challenge rcon ' ) ; $ response = trim ( $ this - > get Reply ( ) - > get Response ( ) ) ; if ( $ response = = 'You have been banned from this server . ' ) { throw new RCONBan Exception ( ) ; } $ this - > rcon Challenge = floatval ( substr ( $ response , 1 4 ) ) ; } 
public function rcon Send ( $ command ) { $ this - > send ( new \ Steam Condenser \ Servers \ Packets \ RCON \ RCONGold Src Request ( $ command ) ) ; } 
public function connect ( $ ip Address , $ port Number , $ timeout ) { $ this - > ip Address = $ ip Address ; $ this - > port Number = $ port Number ; if ( $ this - > sockets Enabled ) { if ( ! $ this - > socket = socket _create ( AF _INET , SOCK _STREAM , SOL _TCP ) ) { throw new Socket Exception ( socket _last _error ( $ this - > socket ) ) ; } socket _set _nonblock ( $ this - > socket ) ; socket _connect ( $ this - > socket , $ ip Address , $ port Number ) ; $ write = [ $ this - > socket ] ; $ read = $ except = null ; $ sec = floor ( $ timeout / 1 0 0 0 ) ; $ usec = $ timeout % 1 0 0 0 ; if ( ! socket _select ( $ read , $ write , $ except , $ sec , $ usec ) ) { $ error Code = socket _last _error ( $ this - > socket ) ; } else { $ error Code = socket _get _option ( $ this - > socket , SOL _SOCKET , SO _ERROR ) ; } if ( $ error Code ) { throw new Socket Exception ( $ error Code ) ; } socket _set _block ( $ this - > socket ) ; } else { if ( ! $ this - > socket = fsockopen ( "tcp : / / $ip Address " , $ port Number , $ socket Errno , $ socket Errstr , $ timeout / 1 0 0 0 ) ) { throw new Socket Exception ( $ socket Errstr ) ; } stream _set _blocking ( $ this - > socket , true ) ; } } 
public function get Servers ( $ region Code = Master Server : : REGION _ALL , $ filter = ' ' , $ force = false ) { $ fail Count = 0 ; $ finished = false ; $ port Number = 0 ; $ host Name = ' 0 . 0 . 0 . 0 ' ; $ server Array = [ ] ; while ( true ) { $ fail Count = 0 ; try { do { $ this - > socket - > send ( new A 2MGETSERVERSBATCH 2Packet ( $ region Code , " $host Name : $port Number " , $ filter ) ) ; try { $ server String Array = $ this - > socket - > get Reply ( ) - > get Servers ( ) ; foreach ( $ server String Array as $ server String ) { $ server String = explode ( ' : ' , $ server String ) ; $ host Name = $ server String [ 0 ] ; $ port Number = $ server String [ 1 ] ; if ( $ host Name ! = ' 0 . 0 . 0 . 0 ' & & $ port Number ! = 0 ) { $ server Array [ ] = [ $ host Name , $ port Number ] ; } else { $ finished = true ; } } $ fail Count = 0 ; } catch ( Timeout Exception $ e ) { $ fail Count + + ; if ( $ fail Count = = self : : $ retries ) { throw $ e ; } $ this - > logger - > info ( "Request to master server { $this - >ip Address } timed out , retrying . . . " ) ; } } while ( ! $ finished ) ; break ; } catch ( Timeout Exception $ e ) { if ( $ this - > rotate Ip ( ) ) { if ( $ force ) { break ; } throw $ e ; } $ this - > logger - > info ( "Request to master server failed , retrying { $this - >ip Address } . . . " ) ; } } return array _unique ( $ server Array , SORT _REGULAR ) ; } 
public function internal Fetch ( ) { $ params = [ 'language ' = > $ this - > language ] ; $ data = Web Api : : get JSONData ( "IEcon Items _ { $this - >app Id } " , 'Get Schema ' , 1 , $ params ) ; $ this - > attributes = [ ] ; foreach ( $ data - > attributes as $ attribute ) { $ this - > attributes [ $ attribute - > defindex ] = $ attribute ; $ this - > attributes [ $ attribute - > name ] = $ attribute ; } $ this - > effects = [ ] ; foreach ( $ data - > attribute _controlled _attached _particles as $ effect ) { $ this - > effects [ $ effect - > id ] = $ effect ; } $ this - > items = [ ] ; $ this - > item Names = [ ] ; foreach ( $ data - > items as $ item ) { $ this - > items [ $ item - > defindex ] = $ item ; $ this - > item Names [ $ item - > name ] = $ item - > defindex ; } if ( ! empty ( $ data - > levels ) ) { $ this - > item Levels = [ ] ; foreach ( $ data - > item _levels as $ item Level Type ) { $ item Levels = [ ] ; foreach ( $ item Level Type - > levels as $ item Level ) { $ item Levels [ $ item Level - > level ] = $ item Level - > name ; } $ this - > item Levels [ $ item Level Type - > name ] = $ item Levels ; } } $ this - > item Sets = [ ] ; foreach ( $ data - > item _sets as $ item Set ) { $ this - > item Sets [ $ item Set - > item _set ] = $ item Set ; } $ this - > origins = [ ] ; foreach ( $ data - > origin Names as $ origin ) { $ this - > origins [ $ origin - > origin ] = $ origin - > name ; } $ this - > qualities = [ ] ; $ index = - 1 ; foreach ( $ data - > qualities as $ key = > $ value ) { $ index + + ; if ( property _exists ( $ data - > quality Names , $ key ) ) { $ quality Name = $ data - > quality Names - > $ key ; } if ( empty ( $ quality Name ) ) { $ quality Name = ucwords ( $ key ) ; } $ this - > qualities [ $ index ] = $ quality Name ; } } 
public static function convert Community Id To Steam Id ( $ community Id ) { $ steam Id 1 = bcmod ( $ community Id , 2 ) ; $ steam Id 2 = bcsub ( $ community Id , 7 6 5 6 1 1 9 7 9 6 0 2 6 5 7 2 8 ) ; if ( $ steam Id 2 < = 0 ) { throw new Steam Condenser Exception ( "Steam ID $community Id is too small . " ) ; } $ steam Id 2 = ( $ steam Id 2 - $ steam Id 1 ) / 2 ; return "STEAM _ 0 : $steam Id 1 : $steam Id 2 " ; } 
public static function convert Steam Id To Community Id ( $ steam Id ) { if ( $ steam Id = = 'STEAM _ID _LAN ' | | $ steam Id = = 'BOT ' ) { throw new Steam Condenser Exception ( "Cannot convert Steam ID \ " $steam Id \ " to a community ID . " ) ; } if ( preg _match ( ' / ^STEAM _ [ 0 - 1 ] : [ 0 - 1 ] : [ 0 - 9 ] + $ / ' , $ steam Id ) ) { $ steam Id = explode ( ' : ' , substr ( $ steam Id , 8 ) ) ; return bcadd ( $ steam Id [ 0 ] + $ steam Id [ 1 ] * 2 , 7 6 5 6 1 1 9 7 9 6 0 2 6 5 7 2 8 ) ; } elseif ( preg _match ( ' / ^ \ [U : [ 0 - 1 ] : [ 0 - 9 ] + \ ] $ / ' , $ steam Id ) ) { $ steam Id = explode ( ' : ' , substr ( $ steam Id , 3 , strlen ( $ steam Id ) - 1 ) ) ; return bcadd ( $ steam Id [ 0 ] + $ steam Id [ 1 ] , 7 6 5 6 1 1 9 7 9 6 0 2 6 5 7 2 7 ) ; } else { throw new Steam Condenser Exception ( "Steam ID \ " $steam Id \ " doesn 't have the correct format . " ) ; } } 
public static function resolve Vanity Url ( $ vanity Url ) { $ params = [ 'vanityurl ' = > $ vanity Url ] ; $ result = Web Api : : get JSONObject ( 'ISteam User ' , 'Resolve Vanity URL ' , 1 , $ params ) ; $ result = $ result - > response ; if ( $ result - > success ! = 1 ) { return null ; } return $ result - > steamid ; } 
public function fetch Friends ( ) { $ friends Data = $ this - > get Data ( $ this - > get Base Url ( ) . ' /friends ?xml = 1 ' ) ; $ this - > friends = [ ] ; foreach ( $ friends Data - > friends - > friend as $ friend ) { $ this - > friends [ ] = self : : create ( ( string ) $ friend , false ) ; } return $ this - > friends ; } 
public function fetch Games ( ) { $ params = [ 'steamid ' = > $ this - > get Steam Id 6 4 ( ) , 'include _appinfo ' = > 1 , 'include _played _free _games ' = > 1 ] ; $ games Data = Web Api : : get JSONObject ( 'IPlayer Service ' , 'Get Owned Games ' , 1 , $ params ) ; foreach ( $ games Data - > response - > games as $ game Data ) { $ game = Steam Game : : create ( $ game Data ) ; $ this - > games [ $ game - > get App Id ( ) ] = $ game ; if ( property _exists ( $ game Data , 'playtime _ 2weeks ' ) ) { $ recent = $ game Data - > playtime _ 2weeks ; } else { $ recent = 0 ; } $ total = $ game Data - > playtime _forever ; $ this - > playtimes [ $ game - > get App Id ( ) ] = [ $ recent , $ total ] ; } return $ this - > games ; } 
public function fetch Groups ( ) { $ params = [ 'steamid ' = > $ this - > get Steam Id 6 4 ( ) ] ; $ result = Web Api : : get JSONObject ( 'ISteam User ' , 'Get User Group List ' , 1 , $ params ) ; $ this - > groups = [ ] ; foreach ( $ result - > response - > groups as $ group Data ) { $ this - > groups [ ] = Steam Group : : create ( $ group Data - > gid , false ) ; } return $ this - > groups ; } 
public function get Steam Id 6 4 ( ) { if ( empty ( $ this - > steam Id 6 4 ) ) { $ this - > steam Id 6 4 = self : : resolve Vanity Url ( $ this - > custom Url ) ; } return $ this - > steam Id 6 4 ; } 
public function get Recent Playtime ( $ app Id ) { if ( empty ( $ this - > playtimes ) ) { $ this - > fetch Games ( ) ; } return $ this - > playtimes [ $ app Id ] [ 0 ] ; } 
public function get Total Playtime ( $ app Id ) { if ( empty ( $ this - > playtimes ) ) { $ this - > fetch Games ( ) ; } return $ this - > playtimes [ $ app Id ] [ 1 ] ; } 
protected function internal Fetch ( ) { $ profile = $ this - > get Data ( $ this - > get Base Url ( ) . ' ?xml = 1 ' ) ; if ( ! empty ( $ profile - > error ) ) { throw new Steam Condenser Exception ( ( string ) $ profile - > error ) ; } if ( ! empty ( $ profile - > privacy Message ) ) { throw new Steam Condenser Exception ( ( string ) $ profile - > privacy Message ) ; } $ this - > nickname = htmlspecialchars _decode ( ( string ) $ profile - > steam ID ) ; $ this - > steam Id 6 4 = ( string ) $ profile - > steam ID 6 4 ; $ this - > limited = ( bool ) ( int ) $ profile - > is Limited Account ; $ this - > trade Ban State = ( string ) $ profile - > trade Ban State ; $ this - > vac Banned = ( bool ) ( int ) $ profile - > vac Banned ; $ this - > image Url = substr ( ( string ) $ profile - > avatar Icon , 0 , - 4 ) ; $ this - > online State = ( string ) $ profile - > online State ; $ this - > privacy State = ( string ) $ profile - > privacy State ; $ this - > state Message = ( string ) $ profile - > state Message ; $ this - > visibility State = ( int ) $ profile - > visibility State ; if ( $ this - > is Public ( ) ) { $ this - > custom Url = strtolower ( ( string ) $ profile - > custom URL ) ; $ this - > hours Played = ( float ) $ profile - > hours Played 2Wk ; $ this - > location = ( string ) $ profile - > location ; $ this - > member Since = ( string ) $ profile - > member Since ; $ this - > real Name = htmlspecialchars _decode ( ( string ) $ profile - > realname ) ; $ this - > summary = htmlspecialchars _decode ( ( string ) $ profile - > summary ) ; } } 
public function rotate Ip ( ) { if ( sizeof ( $ this - > ip Addresses ) = = 1 ) { return true ; } $ this - > ip Index = ( $ this - > ip Index + 1 ) % sizeof ( $ this - > ip Addresses ) ; $ this - > ip Address = $ this - > ip Addresses [ $ this - > ip Index ] ; $ this - > init Socket ( ) ; return $ this - > ip Index = = 0 ; } 
public function init Socket ( ) { $ this - > rcon Socket = new Sockets \ RCONSocket ( $ this - > ip Address , $ this - > port ) ; $ this - > socket = new Sockets \ Source Socket ( $ this - > ip Address , $ this - > port ) ; } 
public function rcon Auth ( $ password ) { $ this - > rcon Request Id = $ this - > generate Rcon Request Id ( ) ; $ this - > rcon Socket - > send ( new Packets \ RCON \ RCONAuth Request ( $ this - > rcon Request Id , $ password ) ) ; $ reply = $ this - > rcon Socket - > get Reply ( ) ; if ( $ reply = = null ) { throw new RCONBan Exception ( ) ; } $ reply = $ this - > rcon Socket - > get Reply ( ) ; $ this - > rcon Authenticated = $ reply - > get Request Id ( ) = = $ this - > rcon Request Id ; return $ this - > rcon Authenticated ; } 
public function rcon Exec ( $ command ) { if ( ! $ this - > rcon Authenticated ) { throw new RCONNo Auth Exception ( ) ; } $ this - > rcon Socket - > send ( new Packets \ RCON \ RCONExec Request ( $ this - > rcon Request Id , $ command ) ) ; $ is Multi = false ; $ response = [ ] ; do { $ response Packet = $ this - > rcon Socket - > get Reply ( ) ; if ( $ response Packet = = null | | $ response Packet instanceof Packets \ RCON \ RCONAuth Response ) { $ this - > rcon Authenticated = false ; throw new RCONNo Auth Exception ( ) ; } if ( ! $ is Multi & & strlen ( $ response Packet - > get Response ( ) ) > 0 ) { $ is Multi = true ; $ this - > rcon Socket - > send ( new Packets \ RCON \ RCONTerminator ( $ this - > rcon Request Id ) ) ; } $ response [ ] = $ response Packet - > get Response ( ) ; } while ( $ is Multi & & ! ( empty ( $ response [ sizeof ( $ response ) - 2 ] ) & & empty ( $ response [ sizeof ( $ response ) - 1 ] ) ) ) ; return trim ( join ( ' ' , $ response ) ) ; } 
public function connect ( $ ip Address , $ port Number , $ timeout ) { $ this - > ip Address = $ ip Address ; $ this - > port Number = $ port Number ; if ( $ this - > sockets Enabled ) { if ( ! $ this - > socket = socket _create ( AF _INET , SOCK _DGRAM , SOL _UDP ) ) { throw new Socket Exception ( socket _last _error ( $ this - > socket ) ) ; } if ( ! socket _connect ( $ this - > socket , $ ip Address , $ port Number ) ) { throw new Socket Exception ( socket _last _error ( $ this - > socket ) ) ; } socket _set _block ( $ this - > socket ) ; } else { if ( ! $ this - > socket = fsockopen ( "udp : / / $ip Address " , $ port Number , $ socket Errno , $ socket Errstr ) ) { throw new Socket Exception ( $ socket Errstr ) ; } stream _set _blocking ( $ this - > socket , true ) ; } } 
public static function create ( ) { $ args = func _get _args ( ) ; $ class Name = empty ( self : : $ class Name ) ? get _class ( ) : self : : $ class Name ; $ class = new \ Reflection Class ( $ class Name ) ; $ constructor = $ class - > get Constructor ( ) ; $ arity = $ constructor - > get Number Of Parameters ( ) ; if ( sizeof ( $ args ) < $ arity ) { array _fill ( 0 , $ arity , null ) ; } $ bypass Cache = ( sizeof ( $ args ) > $ arity + 1 ) ? array _pop ( $ args ) : false ; $ fetch = ( sizeof ( $ args ) > $ arity ) ? array _pop ( $ args ) : true ; $ object = $ class - > new Instance Without Constructor ( ) ; $ constructor - > set Accessible ( true ) ; $ constructor - > invoke Args ( $ object , $ args ) ; $ cached Object = $ object - > cached Instance ( ) ; if ( $ cached Object ! = null & & ! $ bypass Cache ) { $ object = $ cached Object ; } if ( $ fetch & & ( $ bypass Cache | | ! $ object - > is Fetched ( ) ) ) { $ object - > fetch ( ) ; $ object - > cache ( ) ; } return $ object ; } 
protected function cached Instance ( ) { $ find Instance = function ( $ id , $ cache ) use ( & $ find Instance ) { self : : select Ids ( $ id , $ ids ) ; if ( array _key _exists ( $ id , $ cache ) ) { return ( empty ( $ ids ) ) ? $ cache [ $ id ] : $ find Instance ( $ id , $ cache [ $ id ] ) ; } return null ; } ; foreach ( $ this - > cache Ids ( ) as $ id ) { $ instance = $ find Instance ( $ id , self : : $ cache ) ; if ( $ instance ! = null ) { return $ instance ; } } return null ; } 
public static function is Cached ( $ id ) { $ find Id = function ( $ id , $ cache ) use ( & $ find Id ) { self : : select Ids ( $ id , $ ids ) ; if ( array _key _exists ( $ id , $ cache ) ) { return ( is _array ( $ ids ) ) ? $ find Id ( $ id , $ cache [ $ id ] ) : true ; } return false ; } ; return $ find Id ( $ id , self : : $ cache ) ; } 
protected function cache ( ) { $ cache Instance = function ( $ id , & $ cache ) use ( & $ cache Instance ) { self : : select Ids ( $ id , $ ids ) ; if ( empty ( $ ids ) ) { $ cache [ $ id ] = $ this ; } else { $ cache Instance ( $ ids , $ cache [ $ id ] ) ; } } ; foreach ( $ this - > cache Ids ( ) as $ cache Id ) { $ cache Instance ( $ cache Id , self : : $ cache ) ; } } 
protected function cache Ids ( ) { $ values = function ( $ id ) use ( & $ values ) { return is _array ( $ id ) ? array _map ( $ values , $ id ) : $ this - > { $ id } ; } ; return array _map ( $ values , self : : $ cache Ids ) ; } 
public static function get Packet From Data ( $ raw Data ) { $ byte Buffer = new Byte Buffer ( $ raw Data ) ; $ request Id = $ byte Buffer - > get Long ( ) ; $ header = $ byte Buffer - > get Long ( ) ; $ data = $ byte Buffer - > get String ( ) ; switch ( $ header ) { case RCONPacket : : SERVERDATA _AUTH _RESPONSE : return new RCONAuth Response ( $ request Id ) ; case RCONPacket : : SERVERDATA _RESPONSE _VALUE : return new RCONExec Response ( $ request Id , $ data ) ; default : throw new Packet Format Exception ( 'Unknown packet with header ' . dechex ( $ header ) . ' received . ' ) ; } } 
public function init Socket ( ) { $ this - > socket = new Sockets \ Gold Src Socket ( $ this - > ip Address , $ this - > port , $ this - > is HLTV ) ; } 
public function rcon Auth ( $ password ) { $ this - > rcon Password = $ password ; try { $ this - > rcon Authenticated = true ; $ this - > rcon Exec ( ' ' ) ; } catch ( RCONNo Auth Exception $ e ) { $ this - > rcon Authenticated = false ; $ this - > rcon Password = null ; } return $ this - > rcon Authenticated ; } 
public function rcon Exec ( $ command ) { if ( ! $ this - > rcon Authenticated ) { throw new RCONNo Auth Exception ( ) ; } try { return trim ( $ this - > socket - > rcon Exec ( $ this - > rcon Password , $ command ) ) ; } catch ( RCONNo Auth Exception $ e ) { $ this - > rcon Authenticated = false ; throw $ e ; } } 
public function close ( ) { if ( ! empty ( $ this - > socket ) ) { if ( $ this - > sockets Enabled ) { socket _close ( $ this - > socket ) ; } else { fclose ( $ this - > socket ) ; } $ this - > socket = null ; } } 
public function recv ( $ length = 1 2 8 ) { if ( $ this - > sockets Enabled ) { $ data = socket _read ( $ this - > socket , $ length ) ; if ( $ data = = = false ) { $ error Code = socket _last _error ( $ this - > socket ) ; if ( defined ( 'SOCKET _ECONNRESET ' ) & & $ error Code = = SOCKET _ECONNRESET ) { throw new Connection Reset Exception ( ) ; } throw new Socket Exception ( $ error Code ) ; } } else { $ data = fread ( $ this - > socket , $ length ) ; if ( $ data = = = false ) { throw new Socket Exception ( 'Could not read from socket . ' ) ; } } return $ data ; } 
public function select ( $ timeout = 0 ) { $ read = [ $ this - > socket ] ; $ write = null ; $ except = null ; $ sec = floor ( $ timeout / 1 0 0 0 ) ; $ usec = $ timeout % 1 0 0 0 ; if ( $ this - > sockets Enabled ) { $ select = socket _select ( $ read , $ write , $ except , $ sec , $ usec ) ; } else { $ select = stream _select ( $ read , $ write , $ except , $ sec , $ usec ) ; } return $ select > 0 ; } 
public function send ( $ data ) { if ( $ this - > sockets Enabled ) { $ send Result = socket _send ( $ this - > socket , $ data , strlen ( $ data ) , 0 ) ; if ( $ send Result = = = false ) { throw new Socket Exception ( socket _last _error ( $ this - > socket ) ) ; } } else { $ send Result = fwrite ( $ this - > socket , $ data , strlen ( $ data ) ) ; if ( $ send Result = = = false ) { throw new Socket Exception ( 'Could not send data . ' ) ; } } } 
public static function get News For App ( $ app Id , $ count = 5 , $ max Length = null ) { $ params = [ 'appid ' = > $ app Id , 'count ' = > $ count , 'maxlength ' = > $ max Length ] ; $ data = Web Api : : get JSONObject ( 'ISteam News ' , 'Get News For App ' , 2 , $ params ) ; $ news Items = [ ] ; foreach ( $ data - > appnews - > newsitems as $ news Data ) { $ news Items [ ] = new App News ( $ app Id , $ news Data ) ; } return $ news Items ; } 
protected function get Data ( $ url ) { if ( ! $ xml = file _get _contents ( $ url ) ) { preg _match ( ' / ^ . * ( \d { 3 } ) ( . * ) $ / ' , $ http _response _header [ 0 ] , $ http _status ) ; $ error Message = "Failed to retrieve XML data because of an HTTP error : { $http _status [ 1 ] } (status code : { $http _status [ 0 ] } ) " ; throw new Steam Condenser Exception ( $ error Message , 0 ) ; } try { return new \ Simple XMLElement ( $ xml ) ; } catch ( \ Exception $ e ) { $ error Message = "XML could not be parsed : " . $ e - > get Message ( ) ; throw new Steam Condenser Exception ( $ error Message , 0 , $ e ) ; } } 
public function get Classes Equipped ( ) { $ classes Equipped = [ ] ; foreach ( $ this - > equipped as $ class Id = > $ equipped ) { if ( $ equipped ) { $ classes Equipped [ ] = $ class Id ; } } return $ classes Equipped ; } 
public function get Member Count ( ) { if ( empty ( $ this - > member Count ) ) { $ total Pages = $ this - > fetch Page ( 1 ) ; if ( $ total Pages = = 1 ) { $ this - > fetch Time = time ( ) ; } } return $ this - > member Count ; } 
public function get Members ( ) { if ( sizeof ( $ this - > members ) ! = $ this - > member Count ) { $ this - > fetch ( ) ; } return $ this - > members ; } 
private function fetch Page ( $ page ) { $ url = " { $this - >get Base Url ( ) } /memberslistxml ?p = $page " ; $ member Data = $ this - > get Data ( $ url ) ; if ( $ page = = 1 ) { preg _match ( ' / \ / ( [ 0 - 9a -f ] + ) \ .jpg $ / ' , ( string ) $ member Data - > group Details - > avatar Icon , $ matches ) ; $ this - > avatar Hash = $ matches [ 1 ] ; $ this - > custom Url = ( string ) $ member Data - > group Details - > group URL ; $ this - > group Id 6 4 = ( string ) $ member Data - > group ID 6 4 ; $ this - > name = ( string ) $ member Data - > group Details - > group Name ; $ this - > headline = ( string ) $ member Data - > group Details - > headline ; $ this - > summary = ( string ) $ member Data - > group Details - > summary ; } $ this - > member Count = ( int ) $ member Data - > member Count ; $ total Pages = ( int ) $ member Data - > total Pages ; foreach ( $ member Data - > members - > steam ID 6 4 as $ member ) { array _push ( $ this - > members , Steam Id : : create ( ( string ) $ member , false ) ) ; } return $ total Pages ; } 
protected function internal Fetch ( ) { if ( empty ( $ this - > member Count ) | | sizeof ( $ this - > members ) = = $ this - > member Count ) { $ page = 0 ; } else { $ page = 1 ; } do { $ total Pages = $ this - > fetch Page ( + + $ page ) ; } while ( $ page < $ total Pages ) ; $ this - > fetch Time = time ( ) ; } 
public static function create ( $ app Id , $ steam Id , $ fetch Now = true , $ bypass Cache = false ) { if ( is _numeric ( $ steam Id ) ) { $ steam Id 6 4 = $ steam Id ; } else { $ steam Id 6 4 = Steam Id : : resolve Vanity Url ( $ steam Id ) ; } switch ( $ app Id ) { case Dot A 2Beta Inventory : : APP _ID : $ inventory Class = 'Dota 2 \ \Dota 2Beta Inventory ' ; break ; case Dot A 2Inventory : : APP _ID : $ inventory Class = 'Dota 2 \ \Dota 2Inventory ' ; break ; case Portal 2Inventory : : APP _ID : $ inventory Class = 'Portal 2 \ \Portal 2Inventory ' ; break ; case TF 2Beta Inventory : : APP _ID : $ inventory Class = 'TF 2 \ \TF 2Beta Inventory ' ; break ; case TF 2Inventory : : APP _ID : $ inventory Class = 'TF 2 \ \TF 2Inventory ' ; break ; default : $ inventory Class = 'Game Inventory ' ; } self : : overwrite Class ( " \ \Steam Condenser \ \Community \ \ $inventory Class " ) ; return self : : create Cacheable ( $ app Id , $ steam Id 6 4 , $ fetch Now , $ bypass Cache ) ; } 
public function get Item Schema ( ) { if ( $ this - > item Schema = = null ) { $ this - > item Schema = Game Item Schema : : create ( $ this - > app Id , self : : $ schema Language ) ; } return $ this - > item Schema ; } 
protected function internal Fetch ( ) { $ params = [ 'Steam ID ' = > $ this - > steam Id 6 4 ] ; $ result = Web Api : : get JSONData ( "IEcon Items _ { $this - >get App Id ( ) } " , 'Get Player Items ' , 1 , $ params ) ; $ this - > items = [ ] ; $ this - > preliminary Items = [ ] ; foreach ( $ result - > items as $ item Data ) { if ( $ item Data ! = null ) { $ inventory Class = get _called _class ( ) ; $ item Class = $ inventory Class : : ITEM _CLASS ; $ item = new $ item Class ( $ this , $ item Data ) ; if ( $ item - > is Preliminary ( ) ) { $ this - > preliminary Items [ ] = $ item ; } else { $ this - > items [ $ item - > get Backpack Position ( ) - 1 ] = $ item ; } } } } 
public function get Bots Equipped ( ) { $ bots Equipped = [ ] ; foreach ( $ this - > equipped as $ bot Id = > $ equipped ) { if ( $ equipped ) { $ bots Equipped [ ] = $ bot Id ; } } return $ bots Equipped ; } 
public static function get Golden Wrenches ( ) { if ( self : : $ golden Wrenches = = null ) { self : : $ golden Wrenches = [ ] ; $ data = Web Api : : get JSONObject ( 'ITFItems _ 4 4 0 ' , 'Get Golden Wrenches ' , 2 ) ; foreach ( $ data - > results - > wrenches as $ wrench Data ) { self : : $ golden Wrenches [ ] = new TF 2Golden Wrench ( $ wrench Data ) ; } } return self : : $ golden Wrenches ; } 
public static function get JSON ( $ interface , $ method , $ version = 1 , $ params = null ) { return self : : load ( 'json ' , $ interface , $ method , $ version , $ params ) ; } 
public static function get JSONData ( $ interface , $ method , $ version = 1 , $ params = null ) { $ result = self : : get JSONObject ( $ interface , $ method , $ version , $ params ) - > result ; if ( $ result - > status ! = 1 ) { throw new Web Api Exception ( Web Api Exception : : STATUS _BAD , $ result - > status , $ result - > status Detail ) ; } return $ result ; } 
public static function get JSONObject ( $ interface , $ method , $ version = 1 , $ params = null ) { return json _decode ( self : : get JSON ( $ interface , $ method , $ version , $ params ) ) ; } 
public static function load ( $ format , $ interface , $ method , $ version = 1 , $ params = null ) { return self : : instance ( ) - > _load ( $ format , $ interface , $ method , $ version , $ params ) ; } 
private static function instance ( ) { if ( self : : $ instance = = null ) { self : : $ instance = new Web Api ( ) ; self : : $ instance - > set Logger ( \ Steam Condenser \ get Logger ( get _class ( ) ) ) ; } return self : : $ instance ; } 
public static function set Api Key ( $ api Key ) { if ( $ api Key ! = null & & ! preg _match ( ' / ^ [ 0 - 9A -F ] { 3 2 } $ / ' , $ api Key ) ) { throw new Web Api Exception ( Web Api Exception : : INVALID _KEY ) ; } self : : $ api Key = $ api Key ; } 
protected function _load ( $ format , $ interface , $ method , $ version = 1 , $ params = null ) { $ protocol = ( self : : $ secure ) ? 'https ' : 'http ' ; $ url = " $protocol : / /api .steampowered .com / $interface / $method /v $version / " ; $ params [ 'format ' ] = $ format ; if ( self : : $ api Key ! = null ) { $ params [ 'key ' ] = self : : $ api Key ; } if ( $ params ! = null & & ! empty ( $ params ) ) { $ url . = ' ? ' ; $ url _params = [ ] ; foreach ( $ params as $ k = > $ v ) { $ url _params [ ] = " $k = $v " ; } $ url . = join ( ' & ' , $ url _params ) ; } return $ this - > request ( $ url ) ; } 
protected function request ( $ url ) { $ this - > logger - > debug ( "Querying Steam Web API : " . str _replace ( self : : $ api Key , 'SECRET ' , $ url ) ) ; $ data = file _get _contents ( $ url ) ; if ( empty ( $ data ) ) { preg _match ( ' / ^ . * ( \d { 3 } ) ( . * ) $ / ' , $ http _response _header [ 0 ] , $ http _status ) ; if ( $ http _status [ 1 ] = = 4 0 1 ) { throw new Web Api Exception ( Web Api Exception : : UNAUTHORIZED ) ; } throw new Web Api Exception ( Web Api Exception : : HTTP _ERROR , $ http _status [ 1 ] , $ http _status [ 2 ] ) ; } return $ data ; } 
public function send ( Steam Packet $ data Packet ) { if ( empty ( $ this - > socket ) | | ! $ this - > socket - > is Open ( ) ) { $ this - > socket = new TCPSocket ( ) ; $ this - > socket - > connect ( $ this - > ip Address , $ this - > port Number , Steam Socket : : $ timeout ) ; } parent : : send ( $ data Packet ) ; } 
public function get Reply ( ) { try { if ( $ this - > receive Packet ( 4 ) = = 0 ) { $ this - > socket - > close ( ) ; return null ; } } catch ( Connection Reset Exception $ e ) { $ this - > socket - > close ( ) ; return null ; } $ packet Size = $ this - > buffer - > get Long ( ) ; $ remaining Bytes = $ packet Size ; $ packet Data = ' ' ; do { $ received Bytes = $ this - > receive Packet ( $ remaining Bytes ) ; $ remaining Bytes - = $ received Bytes ; $ packet Data . = $ this - > buffer - > get ( ) ; } while ( $ remaining Bytes > 0 ) ; $ packet = RCONPacket Factory : : get Packet From Data ( $ packet Data ) ; $ this - > logger - > debug ( 'Received packet of type ' . get _class ( $ packet ) ) ; return $ packet ; } 
protected function get Player Status Attributes ( $ status Header ) { $ status Attributes = [ ] ; foreach ( preg _split ( " / \s + / " , $ status Header ) as $ attribute ) { if ( $ attribute = = 'connected ' ) { $ status Attributes [ ] = 'time ' ; } else if ( $ attribute = = 'frag ' ) { $ status Attributes [ ] = 'score ' ; } else { $ status Attributes [ ] = $ attribute ; } } return $ status Attributes ; } 
protected function split Player Status ( $ attributes , $ player Status ) { if ( $ attributes [ 0 ] ! = 'userid ' ) { $ player Status = preg _replace ( ' / ^ \d + + / ' , ' ' , $ player Status ) ; } $ first Quote = strpos ( $ player Status , ' " ' ) ; $ last Quote = strrpos ( $ player Status , ' " ' ) ; $ data = [ substr ( $ player Status , 0 , $ first Quote ) , substr ( $ player Status , $ first Quote + 1 , $ last Quote - 1 - $ first Quote ) , substr ( $ player Status , $ last Quote + 1 ) ] ; $ data = array _merge ( array _filter ( preg _split ( " / \s + / " , trim ( $ data [ 0 ] ) ) ) , [ $ data [ 1 ] ] , preg _split ( " / \s + / " , trim ( $ data [ 2 ] ) ) ) ; $ data = array _values ( $ data ) ; if ( sizeof ( $ attributes ) > sizeof ( $ data ) & & in _array ( 'state ' , $ attributes ) ) { array _splice ( $ data , 3 , 0 , [ null , null , null ] ) ; } elseif ( sizeof ( $ attributes ) < sizeof ( $ data ) ) { unset ( $ data [ 1 ] ) ; $ data = array _values ( $ data ) ; } $ player Data = [ ] ; for ( $ i = 0 ; $ i < sizeof ( $ data ) ; $ i + + ) { $ player Data [ $ attributes [ $ i ] ] = $ data [ $ i ] ; } return $ player Data ; } 
public function get Players ( $ rcon Password = null ) { if ( $ this - > player Hash = = null ) { $ this - > update Players ( $ rcon Password ) ; } return $ this - > player Hash ; } 
protected function handle Response For Request ( $ request Type , $ repeat On Failure = true ) { switch ( $ request Type ) { case self : : REQUEST _CHALLENGE : $ expected Response = ' \Steam Condenser \Servers \Packets \S 2CCHALLENGEPacket ' ; $ request Packet = new A 2SPLAYERPacket ( ) ; break ; case self : : REQUEST _INFO : $ expected Response = ' \Steam Condenser \Servers \Packets \S 2AINFOBase Packet ' ; $ request Packet = new A 2SINFOPacket ( ) ; break ; case self : : REQUEST _PLAYER : $ expected Response = ' \Steam Condenser \Servers \Packets \S 2APLAYERPacket ' ; $ request Packet = new A 2SPLAYERPacket ( $ this - > challenge Number ) ; break ; case self : : REQUEST _RULES : $ expected Response = ' \Steam Condenser \Servers \Packets \S 2ARULESPacket ' ; $ request Packet = new A 2SRULESPacket ( $ this - > challenge Number ) ; break ; default : throw new Steam Condenser Exception ( 'Called with wrong request type . ' ) ; } $ this - > socket - > send ( $ request Packet ) ; $ response Packet = $ this - > socket - > get Reply ( ) ; if ( $ response Packet instanceof S 2AINFOBase Packet ) { $ this - > info Hash = $ response Packet - > get Info ( ) ; } elseif ( $ response Packet instanceof S 2APLAYERPacket ) { $ this - > player Hash = $ response Packet - > get Player Hash ( ) ; } elseif ( $ response Packet instanceof S 2ARULESPacket ) { $ this - > rules Hash = $ response Packet - > get Rules Array ( ) ; } elseif ( $ response Packet instanceof S 2CCHALLENGEPacket ) { $ this - > challenge Number = $ response Packet - > get Challenge Number ( ) ; } else { throw new Steam Condenser Exception ( 'Response of type ' . get _class ( $ response Packet ) . ' cannot be handled by this method . ' ) ; } if ( ! ( $ response Packet instanceof $ expected Response ) ) { $ this - > logger - > info ( "Expected { $expected Response } , got " . get _class ( $ response Packet ) . ' . ' ) ; if ( $ repeat On Failure ) { $ this - > handle Response For Request ( $ request Type , false ) ; } } } 
public function update Ping ( ) { $ this - > socket - > send ( new A 2SINFOPacket ( ) ) ; $ start Time = microtime ( true ) ; $ this - > socket - > get Reply ( ) ; $ end Time = microtime ( true ) ; $ this - > ping = intval ( round ( ( $ end Time - $ start Time ) * 1 0 0 0 ) ) ; return $ this - > ping ; } 
public function update Players ( $ rcon Password = null ) { $ this - > handle Response For Request ( self : : REQUEST _PLAYER ) ; if ( ! $ this - > rcon Authenticated ) { if ( $ rcon Password = = null ) { return ; } $ this - > rcon Auth ( $ rcon Password ) ; } $ players = [ ] ; foreach ( explode ( " \n " , $ this - > rcon Exec ( 'status ' ) ) as $ line ) { if ( strpos ( $ line , ' # ' ) = = = 0 & & $ line ! = ' #end ' ) { $ players [ ] = trim ( substr ( $ line , 1 ) ) ; } } $ attributes = $ this - > get Player Status Attributes ( array _shift ( $ players ) ) ; foreach ( $ players as $ player ) { $ player Data = $ this - > split Player Status ( $ attributes , $ player ) ; if ( array _key _exists ( $ player Data [ 'name ' ] , $ this - > player Hash ) ) { $ this - > player Hash [ $ player Data [ 'name ' ] ] - > add Information ( $ player Data ) ; } } } 
public function add Information ( $ player Data ) { if ( $ player Data [ 'name ' ] ! = $ this - > name ) { throw new Steam Condenser Exception ( 'Information to add belongs to a different player . ' ) ; } $ this - > extended = true ; $ this - > connection Id = intval ( $ player Data [ 'userid ' ] ) ; if ( array _key _exists ( 'state ' , $ player Data ) ) { $ this - > state = $ player Data [ 'state ' ] ; } $ this - > steam Id = $ player Data [ 'uniqueid ' ] ; if ( ! $ this - > is Bot ( ) ) { $ this - > loss = intval ( $ player Data [ 'loss ' ] ) ; $ this - > ping = intval ( $ player Data [ 'ping ' ] ) ; if ( array _key _exists ( 'adr ' , $ player Data ) ) { $ address = explode ( ' : ' , $ player Data [ 'adr ' ] ) ; $ this - > ip Address = $ address [ 0 ] ; $ this - > client Port = intval ( $ address [ 1 ] ) ; } if ( array _key _exists ( 'rate ' , $ player Data ) ) { $ this - > rate = $ player Data [ 'rate ' ] ; } } } 
public static function get Leaderboard ( $ game Name , $ id ) { $ leaderboards = self : : get Leaderboards ( $ game Name ) ; if ( is _int ( $ id ) ) { if ( array _key _exists ( $ id , $ leaderboards ) ) { return $ leaderboards [ $ id ] ; } else { return null ; } } else { foreach ( array _values ( $ leaderboards ) as $ board ) { if ( $ board - > get Name ( ) = = $ id ) { return $ board ; } } } } 
public static function get Leaderboards ( $ game Name ) { if ( ! array _key _exists ( $ game Name , self : : $ leaderboards ) ) { self : : load Leaderboards ( $ game Name ) ; } return self : : $ leaderboards [ $ game Name ] ; } 
private static function load Leaderboards ( $ game Name ) { $ url = "http : / /steamcommunity .com /stats / $game Name /leaderboards / ?xml = 1 " ; $ boards Data = new \ Simple XMLElement ( file _get _contents ( $ url ) ) ; if ( ! empty ( $ boards Data - > error ) ) { throw new Steam Condenser Exception ( ( string ) $ boards Data - > error ) ; } self : : $ leaderboards [ $ game Name ] = [ ] ; foreach ( $ boards Data - > leaderboard as $ board Data ) { $ leaderboard = new Game Leaderboard ( $ board Data ) ; self : : $ leaderboards [ $ game Name ] [ $ leaderboard - > get Id ( ) ] = $ leaderboard ; } } 
public function get Entry For Steam Id ( $ steam Id ) { if ( is _object ( $ steam Id ) ) { $ id = $ steam Id - > get Steam Id 6 4 ( ) ; } else { $ id = $ steam Id ; } $ xml = $ this - > load Data For Steam Id ( $ id ) ; foreach ( $ xml - > entries - > entry as $ entry Data ) { if ( $ entry Data - > steamid = = $ id ) { return new Game Leaderboard Entry ( $ entry Data , $ this ) ; } } return null ; } 
public function get Entry Range ( $ first , $ last ) { if ( $ last < $ first ) { throw new Steam Condenser Exception ( 'First entry must be prior to last entry for leaderboard entry lookup . ' ) ; } if ( ( $ last - $ first ) > 5 0 0 0 ) { throw new Steam Condenser Exception ( 'Leaderboard entry lookup is currently limited to a maximum of 5 0 0 1 entries per request . ' ) ; } $ xml = $ this - > load Data ( [ 'start ' = > $ first , 'end ' = > $ last ] ) ; return $ this - > parse Entries ( $ xml ) ; } 
protected function load Data ( array $ params ) { $ url = $ this - > url ; if ( ! empty ( $ params ) ) { $ url _params = [ ] ; foreach ( $ params as $ k = > $ v ) { $ url _params [ ] = " $k = $v " ; } $ url . = ' & ' . join ( ' & ' , $ url _params ) ; } $ xml = new \ Simple XMLElement ( file _get _contents ( $ url ) ) ; if ( ! empty ( $ xml - > error ) ) { throw new Steam Condenser Exception ( ( string ) $ xml - > error ) ; } return $ xml ; } 
protected function load Data For Steam Id ( $ steam Id ) { if ( is _object ( $ steam Id ) ) { $ id = $ steam Id - > get Steam Id 6 4 ( ) ; } else { $ id = $ steam Id ; } return $ this - > load Data ( [ 'steamid ' = > $ id ] ) ; } 
protected function parse Entries ( \ Simple XMLElement $ xml ) { $ entries = [ ] ; foreach ( $ xml - > entries - > entry as $ entry Data ) { $ rank = ( int ) $ entry Data - > rank ; $ entries [ $ rank ] = new Game Leaderboard Entry ( $ entry Data , $ this ) ; } return $ entries ; } 
public static function create ( \ std Class $ game Data ) { if ( array _key _exists ( $ game Data - > appid , self : : $ games ) ) { return self : : $ games [ $ game Data - > appid ] ; } else { return new Steam Game ( $ game Data ) ; } } 
public static function check Steam Inf ( $ path ) { $ steam Inf = file _get _contents ( $ path ) ; preg _match ( ' / ^ \s *app ID = ( \d + ) \s * $ /im ' , $ steam Inf , $ app Id ) ; preg _match ( ' / ^ \s *Patch Version = ( [ \d \ . ] + ) \s * $ /im ' , $ steam Inf , $ version ) ; if ( $ app Id = = null | | $ version = = null ) { throw new Steam Condenser Exception ( "The steam .inf file at \ " $path \ " is invalid . " ) ; } $ app Id = ( int ) $ app Id [ 1 ] ; $ version = ( int ) str _replace ( ' . ' , ' ' , $ version [ 1 ] ) ; return self : : check Up To Date ( $ app Id , $ version ) ; } 
public static function check Up To Date ( $ app Id , $ version ) { $ params = [ 'appid ' = > $ app Id , 'version ' = > $ version ] ; $ result = Web Api : : get JSONObject ( 'ISteam Apps ' , 'Up To Date Check ' , 1 , $ params ) ; $ result = $ result - > response ; if ( ! $ result - > success ) { throw new Steam Condenser Exception ( $ result - > error ) ; } return $ result - > up _to _date ; } 
public function get Player Count ( ) { $ params = [ 'appid ' = > $ this - > app Id ] ; $ result = Web Api : : get JSONObject ( 'ISteam User Stats ' , 'Get Number Of Current Players ' , 1 , $ params ) ; return $ result - > response - > player _count ; } 
public function get User Stats ( $ steam Id ) { if ( ! $ this - > has Stats ( ) ) { return null ; } return Game Stats : : create ( $ steam Id , $ this - > app Id ) ; } 
public function index ( $ work Order Id ) { $ work Order = $ this - > work Order - > find Or Fail ( $ work Order Id ) ; $ parts = $ this - > presenter - > table ( $ work Order ) ; $ inventory = $ this - > presenter - > table Inventory ( $ work Order , $ this - > inventory ) ; $ navbar Parts = $ this - > presenter - > navbar Parts ( $ work Order ) ; $ navbar Inventory = $ this - > presenter - > navbar Inventory ( ) ; return view ( 'work -orders .parts .index ' , compact ( 'parts ' , 'inventory ' , 'work Order ' , 'navbar Parts ' , 'navbar Inventory ' ) ) ; } 
public function store ( Request $ request ) { $ event = $ this - > event - > create ( $ request ) ; if ( $ event ) { $ message = 'Successfully created event . ' ; return redirect ( ) - > route ( 'maintenance .events .index ' ) - > with Success ( $ message ) ; } else { $ message = 'There was an issue creating an event . Please try again . ' ; return redirect ( ) - > route ( 'maintenance .events .create ' ) - > with Errors ( $ message ) ; } } 
public function show ( $ id ) { $ event = $ this - > event - > find ( $ id ) ; $ api Object = $ this - > event - > find Api Object ( $ event - > api _id ) ; if ( $ api Object ) { return view ( 'events .show ' , compact ( 'event ' , 'api Object ' ) ) ; } abort ( 4 0 4 ) ; } 
public function update ( Request $ request , $ id ) { $ event = $ this - > event - > update ( $ request , $ id ) ; if ( $ event ) { $ message = 'Successfully updated event . ' ; return redirect ( ) - > route ( 'maintenance .events .show ' , [ $ event - > id ] ) - > with Success ( $ message ) ; } else { $ message = 'There was an issue updating this event . Please try again . ' ; return redirect ( ) - > route ( 'maintenance .events .create ' ) - > with Errors ( $ message ) ; } } 
public function destroy ( $ id ) { if ( $ this - > event - > delete ( $ id ) ) { $ message = 'Successfully deleted event ' ; return redirect ( ) - > route ( 'maintenance .events .index ' ) - > with Success ( $ message ) ; } else { $ message = 'There was an error trying to delete this event . Please try again . ' ; return redirect ( ) - > route ( 'maintenance .events .show ' , [ $ id ] ) - > with Errors ( $ message ) ; } } 
public function store ( Work Order Request $ request ) { $ work Order = $ this - > work Order - > new Instance ( ) ; return $ this - > dispatch ( new Store ( $ request , $ work Order ) ) ; } 
public function show ( $ id ) { $ work Order = $ this - > work Order - > find Or Fail ( $ id ) ; $ sessions = $ this - > presenter - > table Sessions ( $ work Order ) ; $ history = $ this - > presenter - > table History ( 'work -orders ' , $ work Order - > revisions ( ) ) ; $ navbar = $ this - > presenter - > navbar Show ( $ work Order ) ; $ form Comment = $ this - > presenter - > form Comment ( $ work Order , $ work Order - > comments ( ) - > get Related ( ) ) ; return view ( 'work -orders .show ' , compact ( 'work Order ' , 'sessions ' , 'history ' , 'navbar ' , 'form Comment ' ) ) ; } 
public function edit ( $ id ) { $ work Order = $ this - > work Order - > find Or Fail ( $ id ) ; $ form = $ this - > presenter - > form ( $ work Order ) ; return view ( 'work -orders .edit ' , compact ( 'form ' ) ) ; } 
public function update ( Work Order Request $ request , $ id ) { $ work Order = $ this - > work Order - > find Or Fail ( $ id ) ; return $ this - > dispatch ( new Update ( $ request , $ work Order ) ) ; } 
public function get Take ( $ work Order Id , $ item Id , $ stock Id ) { return $ this - > processor - > get Take ( $ work Order Id , $ item Id , $ stock Id ) ; } 
public function post Take ( Part Take Request $ request , $ work Order Id , $ item Id , $ stock Id ) { try { if ( $ this - > processor - > post Take ( $ request , $ work Order Id , $ item Id , $ stock Id ) ) { flash ( ) - > success ( 'Success ! ' , 'Successfully added parts to work order . ' ) ; return redirect ( ) - > route ( 'maintenance .work -orders .parts .index ' , [ $ work Order Id ] ) ; } else { flash ( ) - > error ( 'Error ! ' , 'There was an issue adding parts to this work order . Please try again . ' ) ; return redirect ( ) - > route ( 'maintenance .work -orders .parts .stocks .take ' , [ $ work Order Id , $ item Id , $ stock Id ] ) ; } } catch ( Not Enough Stock Exception $ e ) { flash ( ) - > error ( 'Not Enough Stock ' , "There isn 't enough stock available to take the requested quantity . " ) ; return redirect ( ) - > route ( 'maintenance .work -orders .parts .stocks .take ' , [ $ work Order Id , $ item Id , $ stock Id ] ) ; } } 
public function get Put ( $ work Order Id , $ inventory Id , $ stock Id ) { return $ this - > processor - > get Put ( $ work Order Id , $ inventory Id , $ stock Id ) ; } 
public function post Put ( Part Return Request $ request , $ work Order Id , $ inventory Id , $ stock Id ) { if ( $ this - > processor - > post Put ( $ request , $ work Order Id , $ inventory Id , $ stock Id ) ) { flash ( ) - > success ( 'Success ! ' , 'Successfully returned parts to the inventory . ' ) ; return redirect ( ) - > route ( 'maintenance .work -orders .parts .index ' , [ $ work Order Id ] ) ; } else { flash ( ) - > error ( 'Error ! ' , 'There was an issue returning parts into the inventory . Please try again . ' ) ; return redirect ( ) - > route ( 'maintenance .work -orders .parts .stocks .put ' , [ $ work Order Id ] ) ; } } 
public function store ( Work Request $ request ) { $ work Request = $ this - > work Request - > create ( $ request ) ; if ( $ work Request ) { $ message = 'Successfully created work request . You will receive a response shortly . ' ; return redirect ( ) - > route ( 'maintenance .client .work -requests .index ' ) - > with Success ( $ message ) ; } else { $ message = 'There was an issue creating a work request . Please try again . ' ; return redirect ( ) - > route ( 'maintenance .client .work -requests .create ' ) - > with Errors ( $ message ) ; } } 
public function show ( $ id ) { $ work Request = $ this - > work Request - > model ( ) - > find Or Fail ( $ id ) ; return view ( 'client .work -requests .show ' , compact ( 'work Request ' ) ) ; } 
public function edit ( $ id ) { $ work Request = $ this - > work Request - > model ( ) - > find Or Fail ( $ id ) ; return view ( 'client .work -requests .edit ' , compact ( 'work Request ' ) ) ; } 
public function update ( Work Request $ request , $ id ) { $ work Request = $ this - > work Request - > update ( $ request , $ id ) ; if ( $ work Request ) { $ message = 'Successfully updated work request . ' ; return redirect ( ) - > route ( 'maintenance .client .work -requests .show ' , [ $ work Request - > id ] ) - > with Success ( $ message ) ; } else { $ message = 'There was an issue updating your work request . Please try again . ' ; return redirect ( ) - > route ( 'maintenance .client .work -requests .edit ' , [ $ id ] ) - > with Errors ( $ message ) ; } } 
public function destroy ( $ id ) { $ work Request = $ this - > work Request - > model ( ) - > find Or Fail ( $ id ) ; if ( $ work Request - > delete ( ) ) { $ message = 'Successfully deleted work request . ' ; return redirect ( ) - > route ( 'maintenance .client .work -requests .index ' ) - > with Success ( $ message ) ; } else { $ message = 'There was an issue deleting this work request . Please try again . ' ; return redirect ( ) - > route ( 'maintenance .client .work -requests .show ' , [ $ id ] ) - > with Errors ( $ message ) ; } } 
public function get Revised Location Attribute ( $ id ) { if ( $ id ) { $ location = $ this - > location ( ) - > find ( $ id ) ; if ( $ location instanceof Location ) { return $ location - > trail ; } } return ; } 
public function scope Location ( $ query , $ location Id = null ) { if ( ! is _null ( $ location Id ) ) { 
public function store ( Report Request $ request , $ event Id ) { $ report = $ this - > event - > create Report ( $ request , $ event Id ) ; if ( $ report ) { $ message = 'Successfully created event report . ' ; return redirect ( ) - > route ( 'maintenance .events .show ' , [ $ event Id , ' #tab -report ' ] ) - > with Success ( $ message ) ; } else { $ message = 'There was an issue creating a report for this event . Please try again . ' ; return redirect ( ) - > route ( 'maintenance .events .show ' , [ $ event Id , ' #tab -report ' ] ) - > with Errors ( $ message ) ; } } 
public function handle ( ) { $ this - > report - > user _id = auth ( ) - > id ( ) ; $ this - > report - > work _order _id = $ this - > work Order - > get Key ( ) ; $ this - > report - > description = $ this - > request - > clean ( $ this - > request - > input ( 'description ' ) ) ; if ( $ this - > report - > save ( ) ) { $ this - > work Order - > complete ( $ this - > request - > input ( 'status ' ) ) ; return true ; } return false ; } 
public function create ( $ work Order Id ) { $ work Order = $ this - > work Order - > find Or Fail ( $ work Order Id ) ; $ form = $ this - > presenter - > form ( $ work Order , $ work Order - > attachments ( ) - > get Related ( ) ) ; return view ( 'work -orders .attachments .create ' , compact ( 'form ' ) ) ; } 
public function store ( Attachment Request $ request , $ work Order Id ) { $ work Order = $ this - > work Order - > find Or Fail ( $ work Order Id ) ; return $ this - > dispatch ( new Store ( $ request , $ work Order - > attachments ( ) ) ) ; } 
public function show ( $ work Order Id , $ attachment Id ) { $ work Order = $ this - > work Order - > find Or Fail ( $ work Order Id ) ; $ attachment = $ work Order - > attachments ( ) - > find Or Fail ( $ attachment Id ) ; return view ( 'work -orders .attachments .show ' , compact ( 'work Order ' , 'attachment ' ) ) ; } 
public function edit ( $ work Order Id , $ attachment Id ) { $ work Order = $ this - > work Order - > find Or Fail ( $ work Order Id ) ; $ attachment = $ work Order - > attachments ( ) - > find Or Fail ( $ attachment Id ) ; $ form = $ this - > presenter - > form ( $ work Order , $ attachment ) ; return view ( 'work -orders .attachments .edit ' , compact ( 'form ' ) ) ; } 
public function update ( Attachment Update Request $ request , $ work Order Id , $ attachment Id ) { $ work Order = $ this - > work Order - > find Or Fail ( $ work Order Id ) ; $ attachment = $ work Order - > attachments ( ) - > find Or Fail ( $ attachment Id ) ; return $ this - > dispatch ( new Update ( $ request , $ attachment ) ) ; } 
public function destroy ( $ work Order Id , $ attachment Id ) { $ work Order = $ this - > work Order - > find Or Fail ( $ work Order Id ) ; $ attachment = $ work Order - > attachments ( ) - > find Or Fail ( $ attachment Id ) ; return $ this - > dispatch ( new Destroy ( $ attachment ) ) ; } 
public function download ( $ work Order Id , $ attachment Id ) { $ work Order = $ this - > work Order - > find Or Fail ( $ work Order Id ) ; $ attachment = $ work Order - > attachments ( ) - > find Or Fail ( $ attachment Id ) ; return response ( ) - > download ( $ attachment - > download _path ) ; } 
public function form ( Work Order $ work Order , Work Order Report $ report ) { return $ this - > form - > of ( 'work -orders .report ' , function ( Form Grid $ form ) use ( $ work Order , $ report ) { if ( $ report - > exists ) { $ method = 'PATCH ' ; $ url = route ( 'maintenance .work -orders .report .update ' , [ $ work Order - > get Key ( ) , $ report - > get Key ( ) ] ) ; $ form - > submit = 'Save ' ; } else { $ method = 'POST ' ; $ url = route ( 'maintenance .work -orders .report .store ' , [ $ work Order - > get Key ( ) ] ) ; $ form - > submit = 'Create ' ; } $ form - > attributes ( compact ( 'method ' , 'url ' ) ) ; $ form - > with ( $ report ) ; $ form - > fieldset ( function ( Fieldset $ fieldset ) use ( $ work Order ) { $ fieldset - > control ( 'select ' , 'status ' ) - > options ( function ( ) { $ statuses = Status : : all ( ) - > pluck ( 'name ' , 'id ' ) ; $ statuses [ 0 ] = 'None ' ; return $ statuses ; } ) - > value ( function ( ) use ( $ work Order ) { if ( $ work Order - > status instanceof Status ) { return $ work Order - > status - > get Key ( ) ; } } ) - > attributes ( [ 'class ' = > 'select 2 ' , ] ) ; $ fieldset - > control ( 'input :textarea ' , 'description ' ) ; } ) ; } ) ; } 
public function get Icon Attribute ( ) { $ class = $ this - > attributes [ 'notifiable _type ' ] ; $ config = App : : make ( Config Service : : class ) ; * Looks like the notification icon could not be * found , we 'll return the default notification icon * / $ default Icon = $ config - > set Prefix ( 'maintenance ' ) - > get ( 'notifications .icons .default ' ) ; return $ default Icon ; } return ; } 
public function handle ( ) { $ this - > stock - > location _id = $ this - > request - > input ( 'location ' , $ this - > stock - > location _id ) ; $ this - > stock - > quantity = $ this - > request - > input ( 'quantity ' , $ this - > stock - > quantity ) ; $ this - > stock - > cost = $ this - > request - > input ( 'cost ' ) ; $ this - > stock - > reason = $ this - > request - > input ( 'reason ' ) ; return $ this - > stock - > save ( ) ; } 
public function index ( $ inventory _id , $ stock _id ) { $ item = $ this - > inventory - > find ( $ inventory _id ) ; $ stock = $ this - > inventory Stock - > find ( $ stock _id ) ; $ data = $ this - > input All ( ) ; $ data [ 'stock _id ' ] = $ stock - > id ; $ movements = $ this - > inventory Stock Movement - > set Input ( $ data ) - > get By Page With Filter ( ) ; return view ( 'inventory .stocks .movements .index ' , [ 'title ' = > "Viewing Stock Movements for Item : $item - >name in Location : " . render Node ( $ stock - > location ) , 'item ' = > $ item , 'stock ' = > $ stock , 'movements ' = > $ movements , ] ) ; } 
public function show ( $ inventory _id , $ stock _id , $ movement _id ) { $ item = $ this - > inventory - > find ( $ inventory _id ) ; $ stock = $ this - > inventory Stock - > find ( $ stock _id ) ; $ movement = $ this - > inventory Stock Movement - > find ( $ movement _id ) ; return view ( 'inventory .stocks .movements .show ' , [ 'title ' = > 'Viewing Movement : ' . $ movement - > id , 'item ' = > $ item , 'stock ' = > $ stock , 'movement ' = > $ movement , ] ) ; } 
public function rollback ( $ inventory _id , $ stock _id , $ movement _id ) { $ item = $ this - > inventory - > find ( $ inventory _id ) ; $ stock = $ this - > inventory Stock - > find ( $ stock _id ) ; $ movement = $ this - > inventory Stock Movement - > find ( $ movement _id ) ; if ( $ stock - > rollback ( $ movement ) ) { $ this - > message = 'Successfully rolled back movement ' ; $ this - > message Type = 'success ' ; $ this - > redirect = route Back ( 'maintenance .inventory .stock .movements .index ' , [ $ item - > id , $ stock - > id , ] ) ; } else { $ this - > message = 'There was an error trying to roll back this movement . Please try again . ' ; $ this - > message Type = 'success ' ; $ this - > redirect = route Back ( 'maintenance .inventory .stock .movements .index ' , [ $ item - > id , $ stock - > id , ] ) ; } return $ this - > response ( ) ; } 
public function get Revised Status Attribute ( $ id ) { if ( $ id ) { $ status = $ this - > status ( ) - > find ( $ id ) ; if ( $ status instanceof Status ) { return $ status - > get Label ( ) ; } } return ; } 
public function get Revised Priority Attribute ( $ id ) { if ( $ id ) { $ priority = $ this - > priority ( ) - > find ( $ id ) ; if ( $ priority instanceof Priority ) { return $ priority - > get Label ( ) ; } } return ; } 
public function close Sessions ( ) { $ closed = [ ] ; foreach ( $ this - > sessions as $ session ) { if ( $ session instanceof Work Order Session & & is _null ( $ session - > out ) ) { $ session - > out = $ this - > fresh Timestamp ( ) ; if ( $ session - > save ( ) ) { $ closed [ ] = $ session ; } } } return $ closed ; } 
public function user Checked In ( ) { $ session = $ this - > get Current Session ( ) ; if ( $ session instanceof Work Order Session ) { return $ session - > in & & is _null ( $ session - > out ) ; } return false ; } 
public function get Started At Label ( ) { if ( $ this - > started _at ) { $ class = 'label label -success ' ; $ icon = 'fa fa -check ' ; $ message = $ this - > started _at ; } else { $ class = 'label label -danger ' ; $ icon = 'fa fa -times ' ; $ message = 'Has not been started . ' ; } $ icon = HTML : : create ( 'i ' , ' ' , [ 'class ' = > $ icon ] ) ; return HTML : : raw ( " <span class = ' $class ' > $icon $message < /span > " ) ; } 
public function get Completed At Label ( ) { if ( $ this - > is Complete ( ) ) { $ class = 'label label -success ' ; $ icon = 'fa fa -check ' ; $ message = $ this - > completed _at ; } else { $ class = 'label label -danger ' ; $ icon = 'fa fa -times ' ; $ message = 'No report has been created . ' ; } $ icon = HTML : : create ( 'i ' , ' ' , [ 'class ' = > $ icon ] ) ; return HTML : : raw ( " <span class = ' $class ' > $icon $message < /span > " ) ; } 
public function complete ( $ status Id ) { if ( is _null ( $ this - > started _at ) ) { $ this - > started _at = $ this - > fresh Timestamp ( ) ; } $ this - > completed _at = $ this - > fresh Timestamp ( ) ; $ this - > status _id = $ status Id ; return $ this - > save ( ) ; } 
public function table ( Status $ status ) { return $ this - > table - > of ( 'work -orders .statuses ' , function ( Table Grid $ table ) use ( $ status ) { $ table - > with ( $ status ) - > paginate ( $ this - > per Page ) ; $ table - > column ( 'Status ' , function ( Column $ column ) { $ column - > value = function ( Status $ status ) { return link _to _route ( 'maintenance .work -orders .statuses .edit ' , $ status - > get Label ( ) , [ $ status - > get Key ( ) ] ) ; } ; } ) ; $ table - > column ( 'created _at ' ) ; $ table - > column ( 'created _by ' , function ( Column $ column ) { $ column - > value = function ( Status $ status ) { if ( $ status - > user instanceof User ) { return $ status - > user - > get Recipient Name ( ) ; } else { return HTML : : create ( 'em ' , 'None ' ) ; } } ; } ) ; } ) ; } 
public function form ( Status $ status ) { return $ this - > form - > of ( 'work -orders .statuses ' , function ( Form Grid $ form ) use ( $ status ) { if ( $ status - > exists ) { $ method = 'PATCH ' ; $ url = route ( 'maintenance .work -orders .statuses .update ' , [ $ status - > get Key ( ) ] ) ; $ form - > submit = 'Save ' ; } else { $ method = 'POST ' ; $ url = route ( 'maintenance .work -orders .statuses .store ' , [ $ status - > get Key ( ) ] ) ; $ form - > submit = 'Create ' ; } $ colors = config ( 'maintenance .colors ' , [ ] ) ; $ form - > with ( $ status ) ; $ form - > attributes ( compact ( 'method ' , 'url ' ) ) ; $ form - > fieldset ( function ( Fieldset $ fieldset ) use ( $ colors ) { $ fieldset - > control ( 'input :text ' , 'name ' ) - > attributes ( [ 'placeholder ' = > 'ex . Awaiting Parts / Supplies ' , ] ) ; $ fieldset - > control ( 'select ' , 'color ' ) - > options ( $ colors ) - > value ( function ( Status $ status ) { return $ status - > color ; } ) - > attributes ( [ 'class ' = > 'select 2 -color ' , ] ) ; } ) ; } ) ; } 
public function handle ( ) { $ quantity = $ this - > request - > input ( 'quantity ' ) ; $ reason = link _to _route ( 'maintenance .work -orders .show ' , 'Used for Work Order ' , [ $ this - > work Order - > get Key ( ) ] ) ; $ this - > stock - > take ( $ quantity , $ reason ) ; 
public function index ( ) { $ priorities = $ this - > presenter - > table ( $ this - > priority ) ; $ navbar = $ this - > presenter - > navbar ( ) ; return view ( 'work -orders .priorities .index ' , compact ( 'priorities ' , 'navbar ' ) ) ; } 
public function store ( Priority Request $ request ) { $ priority = $ this - > priority - > new Instance ( ) ; return $ this - > dispatch ( new Store ( $ request , $ priority ) ) ; } 
public function edit ( $ id ) { $ priority = $ this - > priority - > find Or Fail ( $ id ) ; $ form = $ this - > presenter - > form ( $ priority ) ; return view ( 'work -orders .priorities .edit ' , compact ( 'form ' ) ) ; } 
public function update ( Priority Request $ request , $ id ) { $ priority = $ this - > priority - > find Or Fail ( $ id ) ; return $ this - > dispatch ( new Update ( $ request , $ priority ) ) ; } 
public function handle ( ) { $ this - > metric - > name = $ this - > request - > input ( 'name ' , $ this - > metric - > name ) ; $ this - > metric - > symbol = $ this - > request - > input ( 'symbol ' , $ this - > metric - > symbol ) ; return $ this - > metric - > save ( ) ; } 
public function scope Stock ( $ query , $ operator = null , $ stock = null ) { if ( $ operator & & $ stock ) { return $ query - > where Has ( 'stocks ' , function ( $ query ) use ( $ operator , $ stock ) { if ( $ output = $ this - > get Operator ( $ operator ) ) { return $ query - > where ( 'quantity ' , $ output [ 0 ] , $ stock ) ; } else { return $ query ; } } ) ; } return $ query ; } 
public function scope Sku ( $ query , $ sku = null ) { if ( $ sku ) { return $ query - > where Has ( 'sku ' , function ( $ query ) use ( $ sku ) { return $ query - > where ( 'code ' , 'LIKE ' , ' % ' . $ sku . ' % ' ) ; } ) ; } return $ query ; } 
public function get Current Stock Attribute ( ) { $ stock = $ this - > get Total Stock ( ) ; if ( $ this - > has Metric ( ) ) { return sprintf ( ' %s %s ' , $ stock , $ this - > get Metric Symbol ( ) ) ; } return $ stock ; } 
public function get Revised Metric Attribute ( $ id ) { if ( $ id ) { $ metric = $ this - > metric ( ) - > find ( $ id ) ; if ( $ metric ) { return $ metric - > name ; } } return ; } 
protected function get Operator ( $ string ) { $ allowed _operators = [ ' > ' , ' < ' , ' = ' , ' > = ' , ' < = ' ] ; $ output = preg _split ( " / [ \ [ \ ] ] / " , $ string ) ; if ( is _array ( $ output ) ) { if ( array _key _exists ( ' 1 ' , $ output ) & & array _key _exists ( ' 2 ' , $ output ) ) { if ( in _array ( $ output [ 1 ] , $ allowed _operators ) ) { return [ $ output [ 1 ] , $ output [ 2 ] ] ; } } else { return $ output ; } } return false ; } 
public function scope Sort ( $ query , $ field = null , $ sort = null ) { if ( $ field & & $ sort ) { $ columns = Schema : : get Column Listing ( $ this - > get Table ( ) ) ; if ( in _array ( $ field , $ columns ) ) { if ( $ sort = = = 'asc ' | | $ sort = = = 'desc ' ) { return $ query - > order By ( $ field , $ sort ) ; } } } return $ query - > latest ( ) ; } 
public function store ( Work Order Request $ request ) { if ( $ this - > processor - > store ( $ request ) ) { flash ( ) - > success ( 'Success ! ' , 'Successfully created work order . ' ) ; return redirect ( ) - > route ( 'maintenance .work -orders .index ' ) ; } else { flash ( ) - > error ( 'Error ! ' , 'There was an issue creating this work order . Please try again . ' ) ; return redirect ( ) - > route ( 'maintenance .work -orders .create ' ) ; } } 
public function get Full Path Attribute ( ) { $ config = sprintf ( 'filesystems . %s .root ' , $ this - > get Disk ( ) ) ; $ default = storage _path ( 'app ' ) ; $ base Path = config ( $ config , $ default ) ; return $ base Path . DIRECTORY _SEPARATOR . $ this - > file _path ; } 
public function index ( ) { $ statuses = $ this - > presenter - > table ( $ this - > status ) ; $ navbar = $ this - > presenter - > navbar ( ) ; return view ( 'work -orders .statuses .index ' , compact ( 'statuses ' , 'navbar ' ) ) ; } 
public function store ( Status Request $ request ) { $ status = $ this - > status - > new Instance ( ) ; return $ this - > dispatch ( new Store ( $ request , $ status ) ) ; } 
public function edit ( $ id ) { $ status = $ this - > status - > find Or Fail ( $ id ) ; $ form = $ this - > presenter - > form ( $ status ) ; return view ( 'work -orders .statuses .edit ' , compact ( 'form ' ) ) ; } 
public function update ( Status Request $ request , $ id ) { $ status = $ this - > status - > find Or Fail ( $ id ) ; return $ this - > dispatch ( new Update ( $ request , $ status ) ) ; } 
public function up ( ) { Schema : : create ( 'inventories ' , function ( Blueprint $ table ) { $ table - > increments ( 'id ' ) ; $ table - > timestamps ( ) ; $ table - > soft Deletes ( ) ; $ table - > integer ( 'category _id ' ) - > unsigned ( ) - > nullable ( ) ; $ table - > integer ( 'user _id ' ) - > unsigned ( ) - > nullable ( ) ; $ table - > integer ( 'metric _id ' ) - > unsigned ( ) ; $ table - > string ( 'name ' ) ; $ table - > text ( 'description ' ) - > nullable ( ) ; $ table - > foreign ( 'category _id ' ) - > references ( 'id ' ) - > on ( 'categories ' ) - > on Update ( 'restrict ' ) - > on Delete ( 'set null ' ) ; $ table - > foreign ( 'user _id ' ) - > references ( 'id ' ) - > on ( 'users ' ) - > on Update ( 'restrict ' ) - > on Delete ( 'set null ' ) ; $ table - > foreign ( 'metric _id ' ) - > references ( 'id ' ) - > on ( 'metrics ' ) - > on Update ( 'restrict ' ) - > on Delete ( 'cascade ' ) ; } ) ; Schema : : create ( 'inventory _stocks ' , function ( Blueprint $ table ) { $ table - > increments ( 'id ' ) ; $ table - > timestamps ( ) ; $ table - > soft Deletes ( ) ; $ table - > integer ( 'user _id ' ) - > unsigned ( ) - > nullable ( ) ; $ table - > integer ( 'inventory _id ' ) - > unsigned ( ) ; $ table - > integer ( 'location _id ' ) - > unsigned ( ) ; $ table - > decimal ( 'quantity ' , 8 , 2 ) - > default ( 0 ) ; $ table - > string ( 'aisle ' ) - > nullable ( ) ; $ table - > string ( 'row ' ) - > nullable ( ) ; $ table - > string ( 'bin ' ) - > nullable ( ) ; $ table - > unique ( [ 'inventory _id ' , 'location _id ' ] ) ; $ table - > foreign ( 'user _id ' ) - > references ( 'id ' ) - > on ( 'users ' ) - > on Update ( 'restrict ' ) - > on Delete ( 'set null ' ) ; $ table - > foreign ( 'inventory _id ' ) - > references ( 'id ' ) - > on ( 'inventories ' ) - > on Update ( 'restrict ' ) - > on Delete ( 'cascade ' ) ; $ table - > foreign ( 'location _id ' ) - > references ( 'id ' ) - > on ( 'locations ' ) - > on Update ( 'restrict ' ) - > on Delete ( 'cascade ' ) ; } ) ; Schema : : create ( 'inventory _stock _movements ' , function ( Blueprint $ table ) { $ table - > increments ( 'id ' ) ; $ table - > timestamps ( ) ; $ table - > soft Deletes ( ) ; $ table - > integer ( 'stock _id ' ) - > unsigned ( ) ; $ table - > integer ( 'user _id ' ) - > unsigned ( ) - > nullable ( ) ; $ table - > decimal ( 'before ' , 8 , 2 ) - > default ( 0 ) ; $ table - > decimal ( 'after ' , 8 , 2 ) - > default ( 0 ) ; $ table - > decimal ( 'cost ' , 8 , 2 ) - > default ( 0 ) - > nullable ( ) ; $ table - > string ( 'reason ' ) - > nullable ( ) ; $ table - > foreign ( 'stock _id ' ) - > references ( 'id ' ) - > on ( 'inventory _stocks ' ) - > on Update ( 'restrict ' ) - > on Delete ( 'cascade ' ) ; $ table - > foreign ( 'user _id ' ) - > references ( 'id ' ) - > on ( 'users ' ) - > on Update ( 'restrict ' ) - > on Delete ( 'set null ' ) ; } ) ; } 
public function create ( $ item Id ) { $ item = $ this - > inventory - > find Or Fail ( $ item Id ) ; $ form = $ this - > presenter - > form ( $ item , $ variant = true ) ; return view ( 'inventory .variants .create ' , compact ( 'form ' ) ) ; } 
public function store ( Inventory Request $ request , $ item Id ) { $ item = $ this - > inventory - > find Or Fail ( $ item Id ) ; $ variant = $ item - > new Variant ( ) ; $ variant - > name = $ request - > input ( 'name ' , $ item - > name ) ; $ variant - > category _id = $ request - > input ( 'category ' , $ item - > category _id ) ; $ variant - > metric _id = $ request - > input ( 'metric ' , $ item - > metric _id ) ; return $ variant - > save ( ) ; } 
public function create ( $ work Order Id ) { $ work Order = $ this - > work Order - > find Or Fail ( $ work Order Id ) ; if ( $ work Order - > is Complete ( ) ) { throw new Report Exists Exception ( ) ; } $ form = $ this - > presenter - > form ( $ work Order , $ this - > report ) ; return view ( 'work -orders .report .create ' , compact ( 'form ' ) ) ; } 
public function store ( Report Request $ request , $ work Order Id ) { $ work Order = $ this - > work Order - > find Or Fail ( $ work Order Id ) ; $ report = $ this - > report - > new Instance ( ) ; return $ this - > dispatch ( new Store ( $ request , $ work Order , $ report ) ) ; } 
public function table ( $ work Order ) { return $ this - > table - > of ( 'work -orders ' , function ( Table Grid $ table ) use ( $ work Order ) { $ table - > with ( $ work Order ) - > paginate ( $ this - > per Page ) ; $ table - > attributes ( [ 'class ' = > 'table table -hover table -striped ' , ] ) ; $ table - > column ( 'ID ' , 'id ' ) ; $ table - > column ( 'subject ' , function ( Column $ column ) { $ column - > value = function ( Work Order $ work Order ) { return link _to _route ( 'maintenance .work -orders .show ' , $ work Order - > subject , [ $ work Order - > get Key ( ) ] ) ; } ; } ) ; $ table - > column ( 'Created At ' , 'created _at ' ) ; $ table - > column ( 'created _by ' , function ( Column $ column ) { $ column - > value = function ( Work Order $ work Order ) { return $ work Order - > user - > fullname ; } ; } ) ; $ table - > column ( 'priority ' , function ( Column $ column ) { $ column - > value = function ( Work Order $ work Order ) { if ( $ work Order - > priority instanceof Priority ) { return $ work Order - > priority - > get Label ( ) ; } return HTML : : create ( 'em ' , 'None ' ) ; } ; } ) ; $ table - > column ( 'status ' , function ( Column $ column ) { $ column - > value = function ( Work Order $ work Order ) { if ( $ work Order - > status instanceof Status ) { return $ work Order - > status - > get Label ( ) ; } return HTML : : create ( 'em ' , 'None ' ) ; } ; } ) ; } ) ; } 
public function table Assigned ( $ work Order ) { $ work Order = $ work Order - > where Has ( 'assignments ' , function ( Builder $ query ) { $ query - > where ( 'to _user _id ' , auth ( ) - > id ( ) ) ; } ) ; return $ this - > table ( $ work Order ) ; } 
public function table Sessions ( Work Order $ work Order ) { $ presenter = new Work Order Session Presenter ( $ this - > form , $ this - > table ) ; return $ presenter - > table Per Worker ( $ work Order ) ; } 
public function form ( Work Order $ work Order ) { return $ this - > form - > of ( 'work -orders ' , function ( Form Grid $ form ) use ( $ work Order ) { if ( $ work Order - > exists ) { $ method = 'PATCH ' ; $ url = route ( 'maintenance .work -orders .update ' , [ $ work Order - > get Key ( ) ] ) ; $ form - > submit = 'Save ' ; } else { $ method = 'POST ' ; $ url = route ( 'maintenance .work -orders .store ' ) ; $ form - > submit = 'Create ' ; } $ form - > with ( $ work Order ) ; $ form - > attributes ( compact ( 'method ' , 'url ' ) ) ; $ form - > fieldset ( function ( Fieldset $ fieldset ) { $ fieldset - > control ( 'select ' , 'category ' ) - > value ( function ( Work Order $ work Order ) { return $ work Order - > category _id ; } ) - > options ( function ( ) { return Category : : get Select Hierarchy ( 'work -orders ' ) ; } ) ; $ fieldset - > control ( 'select ' , 'location ' ) - > value ( function ( Work Order $ work Order ) { return $ work Order - > location _id ; } ) - > options ( function ( ) { return Location : : get Select Hierarchy ( ) ; } ) ; $ fieldset - > control ( 'select ' , 'status ' ) - > options ( function ( ) { $ statuses = Status : : all ( ) - > pluck ( 'name ' , 'id ' ) ; $ statuses [ 0 ] = 'None ' ; return $ statuses ; } ) ; $ fieldset - > control ( 'select ' , 'priority ' ) - > value ( function ( Work Order $ work Order ) { return $ work Order - > priority _id ; } ) - > options ( function ( ) { $ priorities = Priority : : all ( ) - > pluck ( 'name ' , 'id ' ) ; $ priorities [ 0 ] = 'None ' ; return $ priorities ; } ) ; $ fieldset - > control ( 'select ' , 'assets [ ] ' ) - > label ( 'Assets ' ) - > options ( function ( ) { return Asset : : all ( ) - > pluck ( 'name ' , 'id ' ) ; } ) - > attributes ( [ 'class ' = > 'select 2 ' , 'multiple ' = > true , ] ) ; $ fieldset - > control ( 'input :text ' , 'subject ' ) - > attributes ( [ 'placeholder ' = > 'ex . Worked on HVAC ' , ] ) ; $ fieldset - > control ( 'input :textarea ' , 'description ' ) ; } ) ; } ) ; } 
public function form Comment ( Work Order $ work Order , Comment $ comment ) { $ presenter = new Work Order Comment Presenter ( $ this - > form , $ this - > table ) ; return $ presenter - > form ( $ work Order , $ comment ) ; } 
public function handle ( Filesystem $ filesystem ) { $ files = $ this - > request - > file ( 'files ' ) ; if ( is _array ( $ files ) ) { $ uploaded = [ ] ; foreach ( $ files as $ file ) { 
public function table ( Asset $ asset ) { return $ this - > table - > of ( 'assets ' , function ( Table Grid $ table ) use ( $ asset ) { $ table - > with ( $ asset ) - > paginate ( $ this - > per Page ) ; $ table - > attributes ( [ 'class ' = > 'table table -hover table -striped ' , ] ) ; $ table - > column ( 'tag ' ) ; $ table - > column ( 'name ' , function ( Column $ column ) { $ column - > value = function ( Asset $ asset ) { return link _to _route ( 'maintenance .assets .show ' , $ asset - > name , [ $ asset - > get Key ( ) ] ) ; } ; } ) ; $ table - > column ( 'category ' , function ( Column $ column ) { $ column - > value = function ( Asset $ asset ) { return $ asset - > category - > trail ; } ; } ) ; $ table - > column ( 'location ' , function ( Column $ column ) { $ column - > value = function ( Asset $ asset ) { return $ asset - > location - > trail ; } ; } ) ; $ table - > column ( 'created _at ' ) ; } ) ; } 
public function form ( Asset $ asset ) { return $ this - > form - > of ( 'assets ' , function ( Form Grid $ form ) use ( $ asset ) { if ( $ asset - > exists ) { $ method = 'PATCH ' ; $ route = route ( 'maintenance .assets .update ' , [ $ asset - > get Key ( ) ] ) ; $ form - > submit = 'Save ' ; } else { $ method = 'POST ' ; $ route = route ( 'maintenance .assets .store ' ) ; $ form - > submit = 'Create ' ; } $ categories = Category : : get Select Hierarchy ( 'assets ' ) ; $ locations = Location : : get Select Hierarchy ( ) ; $ form - > resource ( $ this , $ route , $ asset , compact ( 'method ' ) ) ; $ form - > fieldset ( function ( Fieldset $ fieldset ) use ( $ categories , $ locations ) { $ fieldset - > control ( 'input :text ' , 'tag ' ) - > attributes ( [ 'placeholder ' = > 'ex . 1 0 0 0 1 0 ' , ] ) ; $ fieldset - > control ( 'input :text ' , 'name ' ) - > attributes ( [ 'placeholder ' = > 'ex . Ford F 1 5 0 ' , ] ) ; $ fieldset - > control ( 'select ' , 'category ' ) - > options ( $ categories ) - > value ( function ( Asset $ asset ) { return $ asset - > category _id ; } ) ; $ fieldset - > control ( 'select ' , 'location ' ) - > options ( $ locations ) - > value ( function ( Asset $ asset ) { return $ asset - > location _id ; } ) ; $ fieldset - > control ( 'input :textarea ' , 'description ' ) ; $ fieldset - > control ( 'select ' , 'condition ' ) - > options ( trans ( 'assets .conditions ' ) ) - > value ( function ( Asset $ asset ) { return $ asset - > condition _number ; } ) ; $ fieldset - > control ( 'input :text ' , 'vendor ' ) - > attributes ( [ 'placeholder ' = > 'ex . Ford ' , ] ) ; $ fieldset - > control ( 'input :text ' , 'make ' ) - > attributes ( [ 'placeholder ' = > 'ex . F ' , ] ) ; $ fieldset - > control ( 'input :text ' , 'model ' ) - > attributes ( [ 'placeholder ' = > 'ex . 1 5 0 ' , ] ) ; $ fieldset - > control ( 'input :text ' , 'serial ' ) - > attributes ( [ 'placeholder ' = > 'ex . 1 5 3 4 2 3 - 1 3 4 3 2 4 3 2 - 2 3 4 2 4 2 3 ' , ] ) ; $ fieldset - > control ( 'input :text ' , 'size ' ) - > attributes ( [ 'placeholder ' = > 'ex . 1 9 0 5 x 2 4 6 3 ' , ] ) ; $ fieldset - > control ( 'input :text ' , 'weight ' ) - > attributes ( [ 'placeholder ' = > 'ex . 1 Ton ' , ] ) ; $ fieldset - > control ( 'input :text ' , 'acquired _at ' ) - > attributes ( [ 'class ' = > 'pickadate ' , 'placeholder ' = > 'Click to Select a Date ' , ] ) ; $ fieldset - > control ( 'input :text ' , 'end _of _life ' ) - > attributes ( [ 'class ' = > 'pickadate ' , 'placeholder ' = > 'Click to Select a Date ' , ] ) ; } ) ; } ) ; } 
public function table ( $ item ) { return $ this - > table - > of ( 'inventory ' , function ( Table Grid $ table ) use ( $ item ) { $ table - > with ( $ item ) - > paginate ( $ this - > per Page ) ; $ table - > attributes ( [ 'class ' = > 'table table -hover table -striped ' , ] ) ; $ table - > column ( 'ID ' , 'id ' ) ; $ table - > column ( 'sku ' , function ( Column $ column ) { $ column - > label = 'SKU ' ; $ column - > value = function ( Inventory $ item ) { return $ item - > get Sku ( ) ; } ; } ) ; $ table - > column ( 'name ' , function ( Column $ column ) { $ column - > value = function ( Inventory $ item ) { return link _to _route ( 'maintenance .inventory .show ' , $ item - > name , [ $ item - > get Key ( ) ] ) ; } ; } ) ; $ table - > column ( 'category ' , function ( Column $ column ) { $ column - > value = function ( Inventory $ item ) { return $ item - > category - > trail ; } ; } ) ; $ table - > column ( 'current _stock ' , function ( Column $ column ) { $ column - > value = function ( Inventory $ item ) { return $ item - > get Total Stock ( ) ; } ; } ) ; } ) ; } 
public function table Stocks ( Inventory $ item ) { return ( new Inventory Stock Presenter ( $ this - > form , $ this - > table ) ) - > table ( $ item ) ; } 
public function form ( Inventory $ inventory , $ variant = false ) { return $ this - > form - > of ( 'inventory ' , function ( Form Grid $ form ) use ( $ inventory , $ variant ) { if ( $ inventory - > exists ) { if ( $ variant = = = true ) { 
public function navbar Stocks ( Inventory $ item ) { return ( new Inventory Stock Presenter ( $ this - > form , $ this - > table ) ) - > navbar ( $ item ) ; } 
public function store ( Attachment Request $ request , $ work Order Id ) { if ( $ uploaded = $ this - > processor - > store ( $ request , $ work Order Id ) ) { $ count = ( is _array ( $ uploaded ) ? count ( $ uploaded ) : 0 ) ; flash ( ) - > success ( 'Success ! ' , "Successfully uploaded $count file (s ) . " ) ; return redirect ( ) - > route ( 'maintenance .work -orders .attachments .index ' , [ $ work Order Id ] ) ; } else { flash ( ) - > error ( 'Error ! ' , 'There was an issue uploading the files you selected . Please try again . ' ) ; return redirect ( ) - > route ( 'maintenance .work -orders .attachments .create ' , [ $ work Order Id ] ) ; } } 
public function update ( Attachment Update Request $ request , $ work Order Id , $ attachment Id ) { if ( $ this - > processor - > update ( $ request , $ work Order Id , $ attachment Id ) ) { flash ( ) - > success ( 'Success ! ' , 'Successfully updated attachment . ' ) ; return redirect ( ) - > route ( 'maintenance .work -orders .attachments .show ' , [ $ work Order Id , $ attachment Id ] ) ; } else { flash ( ) - > error ( 'Error ! ' , 'There was an issue updating this attachment . Please try again . ' ) ; return redirect ( ) - > route ( 'maintenance .work -orders .attachments .edit ' , [ $ work Order Id , $ attachment Id ] ) ; } } 
public function destroy ( $ work Order Id , $ attachment Id ) { if ( $ this - > processor - > destroy ( $ work Order Id , $ attachment Id ) ) { flash ( ) - > success ( 'Success ! ' , 'Successfully deleted attachment . ' ) ; return redirect ( ) - > route ( 'maintenance .work -orders .attachments .index ' , [ $ work Order Id ] ) ; } else { flash ( ) - > error ( 'Error ! ' , 'There was an issue deleting this attachment . Please try again . ' ) ; return redirect ( ) - > route ( 'maintenance .work -orders .attachments .show ' , [ $ work Order Id , $ attachment Id ] ) ; } } 
public function handle ( ) { 
public function handle ( ) { $ session = $ this - > work Order - > get Last Users Session ( auth ( ) - > id ( ) ) ; $ session - > out = $ session - > fresh Timestamp ( ) ; return $ session - > save ( ) ; } 
public function table ( Metric $ metric ) { return $ this - > table - > of ( 'metrics ' , function ( Table Grid $ table ) use ( $ metric ) { $ table - > with ( $ metric ) - > paginate ( $ this - > per Page ) ; $ table - > column ( 'name ' ) ; $ table - > column ( 'symbol ' ) ; $ table - > column ( 'Created ' , 'created _at ' ) ; } ) ; } 
public function table History ( $ for , Morph Many $ revisions ) { return $ this - > table - > of ( " $for .revisions " , function ( Table Grid $ table ) use ( $ revisions ) { $ table - > with ( $ revisions ) - > paginate ( $ this - > per Page ) ; $ table - > page Name = 'history ' ; $ table - > column ( 'user _responsible ' , function ( Column $ column ) { $ column - > value = function ( Revision $ revision ) { $ user = $ revision - > get User Responsible ( ) ; if ( $ user instanceof User ) { return $ user - > get Recipient Name ( ) ; } return HTML : : create ( 'em ' , 'None ' ) ; } ; } ) ; $ table - > column ( 'changed ' , function ( Column $ column ) { $ column - > value = function ( Revision $ revision ) { return $ revision - > get Column Name ( ) ; } ; } ) ; $ table - > column ( 'from ' , function ( Column $ column ) { $ column - > value = function ( Revision $ revision ) { $ old = $ revision - > get Old Value ( ) ; if ( is _null ( $ old ) ) { return HTML : : create ( 'em ' , 'None ' ) ; } return $ old ; } ; } ) ; $ table - > column ( 'to ' , function ( Column $ column ) { $ column - > value = function ( Revision $ revision ) { $ new = $ revision - > get New Value ( ) ; if ( is _null ( $ new ) ) { return HTML : : create ( 'em ' , 'None ' ) ; } return $ new ; } ; } ) ; $ table - > column ( 'On ' , 'created _at ' ) ; } ) ; } 
public function store ( Image Request $ request , $ id ) { $ asset = $ this - > asset - > find ( $ id ) ; $ attachments = $ this - > image - > upload ( $ request , $ asset , $ asset - > images ( ) ) ; if ( $ attachments ) { $ message = 'Successfully uploaded files . ' ; return redirect ( ) - > route ( 'maintenance .assets .images .index ' , [ $ asset - > id ] ) - > with Success ( $ message ) ; } else { $ message = 'There was an issue uploading the files you selected . Please try again . ' ; return redirect ( ) - > route ( 'maintenance .assets .images .create ' , [ $ id ] ) - > with Errors ( $ message ) ; } } 
public function show ( $ id , $ image Id ) { $ asset = $ this - > asset - > find ( $ id ) ; $ image = $ asset - > images ( ) - > find ( $ image Id ) ; if ( $ image ) { return view ( 'assets .images .show ' , compact ( 'asset ' , 'image ' ) ) ; } abort ( 4 0 4 ) ; } 
public function update ( Attachment Update Request $ request , $ id , $ image Id ) { $ asset = $ this - > asset - > find ( $ id ) ; $ image = $ this - > image - > update ( $ request , $ asset - > images ( ) , $ image Id ) ; if ( $ image ) { $ message = 'Successfully updated image . ' ; return redirect ( ) - > route ( 'maintenance .assets .images .show ' , [ $ asset - > id , $ image - > id ] ) - > with Success ( $ message ) ; } else { $ message = 'There was an issue updating this image . Please try again . ' ; return redirect ( ) - > route ( 'maintenance .assets .images .show ' , [ $ id , $ image Id ] ) - > with Errors ( $ message ) ; } } 
public function destroy ( $ id , $ image Id ) { $ asset = $ this - > asset - > find ( $ id ) ; $ image = $ asset - > images ( ) - > find ( $ image Id ) ; if ( $ image & & $ image - > delete ( ) ) { $ message = 'Successfully deleted attachment . ' ; return redirect ( ) - > route ( 'maintenance .assets .images .index ' , [ $ asset - > id ] ) - > with Success ( $ message ) ; } else { $ message = 'There was an issue deleting this attachment . Please try again . ' ; return redirect ( ) - > route ( 'maintenance .assets .images .show ' , [ $ asset - > id , $ image - > id ] ) - > with Errors ( $ message ) ; } } 
public function download ( $ id , $ image Id ) { $ asset = $ this - > asset - > find ( $ id ) ; $ image = $ asset - > images ( ) - > find ( $ image Id ) ; if ( $ image ) { return response ( ) - > download ( $ image - > download _path ) ; } abort ( 4 0 4 ) ; } 
public function index ( ) { $ metrics = $ this - > presenter - > table ( $ this - > metric ) ; $ navbar = $ this - > presenter - > navbar ( ) ; return view ( 'metrics .index ' , compact ( 'metrics ' , 'navbar ' ) ) ; } 
public function store ( Metric Request $ request ) { $ metric = $ this - > metric - > new Instance ( ) ; return $ this - > dispatch ( new Store ( $ request , $ metric ) ) ; } 
public function edit ( $ id ) { $ metric = $ this - > metric - > find Or Fail ( $ id ) ; $ form = $ this - > presenter - > form ( $ metric ) ; return view ( 'metrics .edit ' , compact ( 'form ' ) ) ; } 
public function index ( ) { $ navbar = $ this - > presenter - > navbar ( ) ; $ assets = $ this - > presenter - > table ( $ this - > asset ) ; return view ( 'assets .index ' , compact ( 'assets ' , 'navbar ' ) ) ; } 
public function store ( Asset Request $ request ) { $ asset = $ this - > asset - > new Instance ( ) ; $ asset - > user _id = $ this - > guard - > id ( ) ; $ asset - > tag = $ request - > input ( 'tag ' ) ; $ asset - > category _id = $ request - > input ( 'category ' ) ; $ asset - > location _id = $ request - > input ( 'location ' ) ; $ asset - > name = $ request - > input ( 'name ' ) ; $ asset - > condition = $ request - > input ( 'condition ' ) ; $ asset - > vendor = $ request - > input ( 'vendor ' ) ; $ asset - > make = $ request - > input ( 'make ' ) ; $ asset - > model = $ request - > input ( 'model ' ) ; $ asset - > size = $ request - > input ( 'size ' ) ; $ asset - > weight = $ request - > input ( 'weight ' ) ; $ asset - > serial = $ request - > input ( 'serial ' ) ; $ asset - > acquired _at = $ request - > format Date With Time ( $ request - > input ( 'acquired _at ' ) ) ; $ asset - > end _of _life = $ request - > format Date With Time ( $ request - > input ( 'end _of _life ' ) ) ; return $ asset - > save ( ) ; } 
public function edit ( $ id ) { $ asset = $ this - > asset - > find Or Fail ( $ id ) ; $ form = $ this - > presenter - > form ( $ asset ) ; return view ( 'assets .edit ' , compact ( 'form ' ) ) ; } 
public function update ( Asset Request $ request , $ id ) { $ asset = $ this - > asset - > find Or Fail ( $ id ) ; $ asset - > tag = $ request - > input ( 'tag ' ) ; $ asset - > category _id = $ request - > input ( 'category ' ) ; $ asset - > location _id = $ request - > input ( 'location ' ) ; $ asset - > name = $ request - > input ( 'name ' ) ; $ asset - > condition = $ request - > input ( 'condition ' ) ; $ asset - > vendor = $ request - > input ( 'vendor ' ) ; $ asset - > make = $ request - > input ( 'make ' ) ; $ asset - > model = $ request - > input ( 'model ' ) ; $ asset - > size = $ request - > input ( 'size ' ) ; $ asset - > weight = $ request - > input ( 'weight ' ) ; $ asset - > serial = $ request - > input ( 'serial ' ) ; $ asset - > acquired _at = $ request - > format Date With Time ( $ request - > input ( 'acquired _at ' ) ) ; $ asset - > end _of _life = $ request - > format Date With Time ( $ request - > input ( 'end _of _life ' ) ) ; return $ asset - > save ( ) ; } 
public function handle ( ) { $ this - > attachment - > name = $ this - > request - > input ( 'name ' , $ this - > attachment - > name ) ; return $ this - > attachment - > save ( ) ; } 
public function scope Id ( $ query , $ id = null ) { if ( ! is _null ( $ id ) ) { $ query - > where ( 'id ' , $ id ) ; } return $ query ; } 
public function response ( ) { if ( $ this - > is Ajax ( ) ) { if ( $ this - > errors ) { return $ this - > response Json ( [ 'errors ' = > $ this - > errors , ] ) ; } else { return $ this - > response Json ( [ 'message ' = > $ this - > message , 'message Type ' = > $ this - > message Type , 'redirect ' = > $ this - > redirect , ] ) ; } } else { if ( $ this - > errors ) { return redirect ( $ this - > redirect ) - > with Input ( ) - > with Errors ( $ this - > errors ) ; } else { return redirect ( $ this - > redirect ) - > with Input ( ) - > with ( 'message ' , $ this - > message ) - > with ( 'message Type ' , $ this - > message Type ) ; } } } 
protected function input ( $ name , $ clean = false ) { if ( $ this - > input Has ( $ name ) ) { if ( $ clean ) { return $ this - > clean ( Input : : get ( $ name ) ) ; } else { return Input : : get ( $ name ) ; } } return ; } 
public static function get Select Hierarchy ( $ belongs To = null ) { $ query = static : : roots ( ) ; if ( ! is _null ( $ belongs To ) ) { $ query - > where ( 'belongs _to ' , $ belongs To ) ; } $ roots = $ query - > with ( 'children ' ) - > get ( ) ; $ options = [ 0 = > 'None ' ] ; foreach ( $ roots as $ root ) { $ options = $ options + static : : get Rendered Node ( $ root ) ; } return $ options ; } 
public static function get Rendered Node ( Node $ node ) { $ options = [ ] ; if ( $ node - > is Root ( ) ) { $ name = $ node - > name ; } else { $ depth = str _repeat ( ' - - ' , $ node - > depth ) ; $ name = sprintf ( ' %s %s ' , $ depth , $ node - > name ) ; } $ options [ $ node - > id ] = $ name ; if ( $ node - > children ( ) - > count ( ) > 0 ) { foreach ( $ node - > children as $ child ) { $ options = $ options + static : : get Rendered Node ( $ child ) ; } } return $ options ; } 
public function handle ( ) { $ session = new Work Order Session ( ) ; $ session - > user _id = auth ( ) - > id ( ) ; $ session - > work _order _id = $ this - > work Order - > id ; $ session - > in = $ session - > fresh Timestamp ( ) ; if ( $ this - > work Order - > sessions - > count ( ) = = = 0 | | is _null ( $ this - > work Order - > started _at ) ) { $ this - > work Order - > update ( [ 'started _at ' = > $ this - > work Order - > fresh Timestamp ( ) ] ) ; } return $ session - > save ( ) ; } 
public function handle ( ) { $ this - > priority - > name = $ this - > request - > input ( 'name ' , $ this - > priority - > name ) ; $ this - > priority - > color = $ this - > request - > input ( 'color ' , $ this - > priority - > color ) ; return $ this - > priority - > save ( ) ; } 
public function handle ( ) { $ this - > work Order - > category _id = $ this - > request - > input ( 'category ' ) ; $ this - > work Order - > location _id = $ this - > request - > input ( 'location ' ) ; $ this - > work Order - > status _id = $ this - > request - > input ( 'status ' ) ; $ this - > work Order - > priority _id = $ this - > request - > input ( 'priority ' ) ; $ this - > work Order - > subject = $ this - > request - > input ( 'subject ' ) ; $ this - > work Order - > description = $ this - > request - > clean ( $ this - > request - > input ( 'description ' ) ) ; $ this - > work Order - > started _at = $ this - > request - > input ( 'started _at ' ) ; $ this - > work Order - > completed _at = $ this - > request - > input ( 'completed _at ' ) ; if ( $ this - > work Order - > save ( ) ) { $ assets = $ this - > request - > input ( 'assets ' , [ ] ) ; if ( is _array ( $ assets ) & & count ( $ assets ) > 0 ) { $ this - > work Order - > assets ( ) - > sync ( $ assets ) ; } return true ; } return false ; } 
public function boot ( Factory $ view ) { foreach ( $ this - > composers as $ callback = > $ views ) { $ view - > composer ( $ views , $ callback ) ; } } 
public function run ( ) { $ metrics = $ this - > get Seed Data ( ) ; foreach ( $ metrics as $ metric ) { $ this - > metric - > model ( ) - > create ( $ metric ) ; } } 
public function handle ( ) { 
public function handle ( Filesystem $ filesystem ) { try { if ( $ filesystem - > delete ( $ this - > attachment - > get Storage File Path ( ) ) ) { return $ this - > attachment - > delete ( ) ; } } catch ( File Not Found Exception $ e ) { 
public function index ( $ item Id ) { $ item = $ this - > inventory - > find Or Fail ( $ item Id ) ; $ navbar = $ this - > presenter - > navbar ( $ item ) ; $ stocks = $ this - > presenter - > table ( $ item ) ; return view ( 'inventory .stocks .index ' , compact ( 'stocks ' , 'navbar ' ) ) ; } 
public function create ( $ item Id ) { $ item = $ this - > inventory - > find Or Fail ( $ item Id ) ; $ form = $ this - > presenter - > form ( $ item , $ item - > stocks ( ) - > get Related ( ) ) ; return view ( 'inventory .stocks .create ' , compact ( 'form ' ) ) ; } 
public function store ( Inventory Stock Request $ request , $ item Id ) { $ item = $ this - > inventory - > find Or Fail ( $ item Id ) ; $ stock = $ item - > stocks ( ) - > get Related ( ) ; return $ this - > dispatch ( new Store ( $ request , $ item , $ stock ) ) ; } 
public function show ( $ item Id , $ stock Id ) { $ item = $ this - > inventory - > find Or Fail ( $ item Id ) ; $ stock = $ item - > stocks ( ) - > find Or Fail ( $ stock Id ) ; $ movements = $ this - > presenter - > table Movements ( $ item , $ stock ) ; return view ( 'inventory .stocks .show ' , compact ( 'item ' , 'stock ' , 'movements ' ) ) ; } 
public function edit ( $ item Id , $ stock Id ) { $ item = $ this - > inventory - > find Or Fail ( $ item Id ) ; $ stock = $ item - > stocks ( ) - > find Or Fail ( $ stock Id ) ; $ form = $ this - > presenter - > form ( $ item , $ stock ) ; return view ( 'inventory .stocks .edit ' , compact ( 'form ' ) ) ; } 
public function update ( Inventory Stock Request $ request , $ item Id , $ stock Id ) { $ item = $ this - > inventory - > find Or Fail ( $ item Id ) ; $ stock = $ item - > stocks ( ) - > find Or Fail ( $ stock Id ) ; return $ this - > dispatch ( new Update ( $ request , $ item , $ stock ) ) ; } 
public function destroy ( $ item Id , $ stock Id ) { $ item = $ this - > inventory - > find Or Fail ( $ item Id ) ; $ stock = $ item - > stocks ( ) - > find Or Fail ( $ stock Id ) ; return $ stock - > delete ( ) ; } 
public function up ( ) { Schema : : create ( 'asset _manuals ' , function ( Blueprint $ table ) { $ table - > integer ( 'asset _id ' ) - > unsigned ( ) ; $ table - > integer ( 'attachment _id ' ) - > unsigned ( ) ; $ table - > foreign ( 'asset _id ' ) - > references ( 'id ' ) - > on ( 'assets ' ) - > on Update ( 'restrict ' ) - > on Delete ( 'cascade ' ) ; $ table - > foreign ( 'attachment _id ' ) - > references ( 'id ' ) - > on ( 'attachments ' ) - > on Update ( 'restrict ' ) - > on Delete ( 'cascade ' ) ; } ) ; Schema : : create ( 'asset _images ' , function ( Blueprint $ table ) { $ table - > integer ( 'asset _id ' ) - > unsigned ( ) ; $ table - > integer ( 'attachment _id ' ) - > unsigned ( ) ; $ table - > foreign ( 'asset _id ' ) - > references ( 'id ' ) - > on ( 'assets ' ) - > on Update ( 'restrict ' ) - > on Delete ( 'cascade ' ) ; $ table - > foreign ( 'attachment _id ' ) - > references ( 'id ' ) - > on ( 'attachments ' ) - > on Update ( 'restrict ' ) - > on Delete ( 'cascade ' ) ; } ) ; } 
public function index ( $ id ) { $ asset = $ this - > asset - > model ( ) - > find Or Fail ( $ id ) ; return view ( 'assets .meters .index ' , compact ( 'asset ' ) ) ; } 
public function create ( $ id ) { $ asset = $ this - > asset - > model ( ) - > find Or Fail ( $ id ) ; return view ( 'assets .meters .create ' , compact ( 'asset ' ) ) ; } 
public function store ( Meter Request $ request , $ id ) { $ meter = $ this - > meter - > create ( $ request , $ id ) ; if ( $ meter ) { $ message = 'Successfully created meter . ' ; return redirect ( ) - > route ( 'maintenance .assets .meters .index ' , [ $ id ] ) - > with Success ( $ message ) ; } else { $ message = 'There was an issue creating a meter . Please try again . ' ; return redirect ( ) - > route ( 'maintenance .assets .meters .create ' , [ $ id ] ) - > with Errors ( $ message ) ; } } 
public function show ( $ id , $ meter Id ) { $ asset = $ this - > asset - > model ( ) - > find Or Fail ( $ id ) ; $ meter = $ asset - > meters ( ) - > find Or Fail ( $ meter Id ) ; return view ( 'assets .meters .show ' , compact ( 'asset ' , 'meter ' ) ) ; } 
public function edit ( $ id , $ meter Id ) { $ asset = $ this - > asset - > model ( ) - > find Or Fail ( $ id ) ; $ meter = $ asset - > meters ( ) - > find Or Fail ( $ meter Id ) ; $ last Reading = $ meter - > get Last Reading ( ) ; return view ( 'assets .meters .edit ' , compact ( 'asset ' , 'meter ' , 'last Reading ' ) ) ; } 
public function update ( Meter Request $ request , $ id , $ meter Id ) { $ meter = $ this - > meter - > update ( $ request , $ id , $ meter Id ) ; if ( $ meter ) { $ message = 'Successfully updated meter . ' ; return redirect ( ) - > route ( 'maintenance .assets .meters .show ' , [ $ id , $ meter - > id ] ) - > with Success ( $ message ) ; } else { $ message = 'There was an issue updating this meter . Please try again . ' ; return redirect ( ) - > route ( 'maintenance .assets .meters .edit ' , [ $ id , $ meter Id ] ) - > with Errors ( $ message ) ; } } 
public function destroy ( $ id , $ meter Id ) { $ asset = $ this - > asset - > model ( ) - > find Or Fail ( $ id ) ; $ meter = $ asset - > meters ( ) - > find Or Fail ( $ meter Id ) ; if ( $ meter - > delete ( ) ) { $ message = 'Successfully deleted meter . ' ; return redirect ( ) - > route ( 'maintenance .assets .meters .index ' , [ $ id ] ) - > with Success ( $ message ) ; } else { $ message = 'There was an issue deleting this meter . Please try again . ' ; return redirect ( ) - > route ( 'maintenance .assets .meters .show ' , [ $ id , $ meter Id ] ) - > with Errors ( $ message ) ; } } 
public function store ( $ work Order Id ) { if ( $ this - > work Order Notification Validator - > passes ( ) ) { $ work Order = $ this - > work Order - > find ( $ work Order Id ) ; $ data = $ this - > input All ( ) ; $ data [ 'work _order _id ' ] = $ work Order - > id ; $ this - > work Order Notification - > set Input ( $ data ) - > create ( ) ; $ this - > message = 'Successfully updated notifications ' ; $ this - > message Type = 'success ' ; $ this - > redirect = route ( 'maintenance .work -orders .show ' , [ $ work Order - > id ] ) ; } else { $ this - > errors = $ this - > work Order Notification Validator - > get Errors ( ) ; $ this - > redirect = route ( 'maintenance .work -orders .show ' , [ $ work Order Id ] ) ; } return $ this - > response ( ) ; } 
public function update ( $ work Order Id , $ notification Id ) { if ( $ this - > work Order Notification Validator - > passes ( ) ) { $ work Order = $ this - > work Order - > find ( $ work Order Id ) ; $ notifications = $ this - > work Order Notification - > find ( $ notification Id ) ; $ data = $ this - > input All ( ) ; $ data [ 'work _order _id ' ] = $ work Order - > id ; $ this - > work Order Notification - > set Input ( $ data ) - > update ( $ notifications - > id ) ; $ this - > message = 'Successfully updated notifications ' ; $ this - > message Type = 'success ' ; $ this - > redirect = route ( 'maintenance .work -orders .show ' , [ $ work Order - > id ] ) ; } else { $ this - > errors = $ this - > work Order Notification Validator - > get Errors ( ) ; $ this - > redirect = route ( 'maintenance .work -orders .show ' , [ $ work Order Id ] ) ; } return $ this - > response ( ) ; } 
public function started At Formatted ( ) { if ( $ this - > entity - > started _at ) { $ date = new \ Date Time ( ) ; $ date - > set Timestamp ( strtotime ( $ this - > entity - > started _at ) ) ; return $ date - > format ( 'M d S Y - h :ia ' ) ; } return ; } 
public function completed At Formatted ( ) { if ( $ this - > entity - > completed _at ) { $ date = new \ Date Time ( ) ; $ date - > set Timestamp ( strtotime ( $ this - > entity - > completed _at ) ) ; return $ date - > format ( 'M d S Y - h :ia ' ) ; } return ; } 
public function handle ( ) { $ this - > work Request - > subject = $ this - > request - > input ( 'subject ' , $ this - > work Request - > subject ) ; $ this - > work Request - > best _time = $ this - > request - > input ( 'best _time ' , $ this - > work Request - > best _time ) ; $ this - > work Request - > description = $ this - > request - > clean ( $ this - > request - > input ( 'description ' , $ this - > work Request - > description ) ) ; return $ this - > work Request - > save ( ) ; } 
public function index ( ) { $ work Orders = $ this - > presenter - > table Assigned ( $ this - > work Order ) ; $ navbar = $ this - > presenter - > navbar ( ) ; return view ( 'work -orders .assigned .index ' , compact ( 'work Orders ' , 'navbar ' ) ) ; } 
public function form ( Work Order $ work Order , Comment $ comment ) { return $ this - > form - > of ( 'work -orders .comments ' , function ( Form Grid $ form ) use ( $ work Order , $ comment ) { if ( $ comment - > exists ) { $ method = 'PATCH ' ; $ url = route ( 'work -orders .comments .update ' , [ $ work Order - > get Key ( ) , $ comment - > get Key ( ) ] ) ; $ form - > submit = 'Save ' ; } else { $ method = 'POST ' ; $ url = route ( 'work -orders .comments .store ' , [ $ work Order - > get Key ( ) ] ) ; $ form - > submit = 'Create ' ; } $ form - > attributes ( compact ( 'method ' , 'url ' ) ) ; $ form - > with ( $ comment ) ; $ form - > fieldset ( function ( Fieldset $ fieldset ) { $ fieldset - > control ( 'input :text ' , 'content ' ) ; } ) ; } ) ; } 
public function get Hours ( ) { if ( array _key _exists ( 'out ' , $ this - > attributes ) ) { if ( $ this - > attributes [ 'out ' ] ) { $ hours = abs ( round ( ( strtotime ( $ this - > attributes [ 'in ' ] ) - strtotime ( $ this - > attributes [ 'out ' ] ) ) / 3 6 0 0 , 2 ) ) ; return $ hours ; } } return ; } 
public function handle ( ) { $ this - > stock - > user _id = auth ( ) - > id ( ) ; $ this - > stock - > inventory _id = $ this - > inventory - > get Key ( ) ; $ this - > stock - > location _id = $ this - > request - > input ( 'location ' ) ; $ this - > stock - > quantity = $ this - > request - > input ( 'quantity ' ) ; $ this - > stock - > cost = $ this - > request - > input ( 'cost ' ) ; $ this - > stock - > reason = $ this - > request - > input ( 'reason ' ) ; return $ this - > stock - > save ( ) ; } 
public function start Formatted ( Event $ api Object ) { $ start = new \ Date Time ( ) ; $ start - > set Timestamp ( strtotime ( $ api Object - > start ) ) ; if ( $ api Object - > all _day ) { return $ start - > format ( 'M d S Y ' ) ; } else { return $ start - > format ( 'M d S Y - h :ia ' ) ; } } 
public function start Date Formatted ( Event $ api Object ) { $ start = new \ Date Time ( ) ; $ start - > set Timestamp ( strtotime ( $ api Object - > start ) ) ; return $ start - > format ( 'm /d /Y ' ) ; } 
public function end Formatted ( Event $ api Object ) { $ end = new \ Date Time ( ) ; $ end - > set Timestamp ( strtotime ( $ api Object - > end ) ) ; if ( $ api Object - > all _day ) { return $ end - > format ( 'M d S Y ' ) ; } return $ end - > format ( 'M d S Y - h :ia ' ) ; } 
public function end Date Formatted ( Event $ api Object ) { $ end = new \ Date Time ( ) ; $ end - > set Timestamp ( strtotime ( $ api Object - > start ) ) ; return $ end - > format ( 'm /d /Y ' ) ; } 
public function end Time Formatted ( Event $ api Object ) { if ( ! $ api Object - > all _day ) { $ end = new \ Date Time ( ) ; $ end - > set Timestamp ( strtotime ( $ api Object - > start ) ) ; return $ end - > format ( 'h :i A ' ) ; } return ; } 
public function recur Frequency Formatted ( Event $ api Object ) { if ( $ this - > recur Frequency ( $ api Object ) ) { return ucfirst ( strtolower ( $ this - > recur Frequency ( $ api Object ) ) ) ; } return 'None ' ; } 
public function recur Frequency ( Event $ api Object ) { if ( $ api Object - > rrule Array & & array _key _exists ( 'FREQ ' , $ api Object - > rrule Array ) ) { $ freq = $ api Object - > rrule Array [ 'FREQ ' ] ; return $ freq ; } return ; } 
public function recur Days ( Event $ api Object ) { if ( $ api Object - > rrule Array & & array _key _exists ( 'BYDAY ' , $ api Object - > rrule Array ) ) { $ freq = $ api Object - > rrule Array [ 'BYDAY ' ] ; return $ freq ; } return ; } 
public function tags ( ) { if ( $ this - > entity - > parent Event ) { $ event = $ this - > entity - > parent Event ; } else { $ event = $ this - > entity ; } return view ( 'viewers .event .tags ' , [ 'event ' = > $ event , ] ) ; } 
public function store ( Inventory Stock Request $ request , $ item Id ) { if ( $ this - > processor - > store ( $ request , $ item Id ) ) { flash ( ) - > success ( 'Success ! ' , 'Successfully created stock . ' ) ; return redirect ( ) - > route ( 'maintenance .inventory .stocks .index ' , [ $ item Id ] ) ; } else { flash ( ) - > error ( 'Error ! ' , 'There was an issue creating an inventory stock . Please try again . ' ) ; return redirect ( ) - > route ( 'maintenance .inventory .stocks .create ' , [ $ item Id ] ) ; } } 
public function update ( Inventory Stock Request $ request , $ item Id , $ stock Id ) { if ( $ this - > processor - > update ( $ request , $ item Id , $ stock Id ) ) { flash ( ) - > success ( 'Success ! ' , 'Successfully updated stock . ' ) ; return redirect ( ) - > route ( 'maintenance .inventory .stocks .show ' , [ $ item Id , $ stock Id ] ) ; } else { flash ( ) - > error ( 'Error ! ' , 'There was an issue updating this stock . Please try again . ' ) ; return redirect ( ) - > route ( 'maintenance .inventory .stocks .update ' , [ $ item Id , $ stock Id ] ) ; } } 
public function destroy ( $ item Id , $ stock Id ) { if ( $ this - > processor - > destroy ( $ item Id , $ stock Id ) ) { flash ( ) - > success ( 'Success ! ' , 'Successfully deleted stock . ' ) ; return redirect ( ) - > route ( 'maintenance .inventory .stocks .index ' , [ $ item Id ] ) ; } else { flash ( ) - > error ( 'Error ! ' , 'There was an issue deleting this stock . Please try again . ' ) ; return redirect ( ) - > route ( 'maintenance .inventory .stocks .show ' , [ $ item Id , $ stock Id ] ) ; } } 
public function table ( Work Order $ work Order ) { $ attachments = $ work Order - > attachments ( ) ; return $ this - > table - > of ( 'work -orders .attachments ' , function ( Table Grid $ table ) use ( $ work Order , $ attachments ) { $ table - > with ( $ attachments ) - > paginate ( $ this - > per Page ) ; $ table - > column ( 'type ' , function ( Column $ column ) { $ column - > value = function ( Attachment $ attachment ) { return $ attachment - > icon ; } ; } ) ; $ table - > column ( 'name ' , function ( Column $ column ) use ( $ work Order ) { $ column - > value = function ( Attachment $ attachment ) use ( $ work Order ) { $ route = 'maintenance .work -orders .attachments .show ' ; $ params = [ $ work Order - > get Key ( ) , $ attachment - > get Key ( ) ] ; return link _to _route ( $ route , $ attachment - > name , $ params ) ; } ; } ) ; $ table - > column ( 'uploaded _by ' , function ( Column $ column ) { $ column - > value = function ( Attachment $ attachment ) { if ( $ attachment - > user instanceof User ) { return $ attachment - > user - > get Recipient Name ( ) ; } } ; } ) ; $ table - > column ( 'Uploaded On ' , 'created _at ' ) ; } ) ; } 
public function form ( Work Order $ work Order , Attachment $ attachment ) { return $ this - > form - > of ( 'work -orders .attachments ' , function ( Form Grid $ form ) use ( $ work Order , $ attachment ) { $ files = true ; if ( $ attachment - > exists ) { $ url = route ( 'maintenance .work -orders .attachments .update ' , [ $ work Order - > get Key ( ) , $ attachment - > get Key ( ) ] ) ; $ method = 'PATCH ' ; $ form - > submit = 'Save ' ; $ form - > with ( $ attachment ) ; } else { $ url = route ( 'maintenance .work -orders .attachments .store ' , [ $ work Order - > get Key ( ) ] ) ; $ method = 'POST ' ; $ form - > submit = 'Upload ' ; } $ form - > attributes ( compact ( 'url ' , 'method ' , 'files ' ) ) ; $ form - > fieldset ( function ( Fieldset $ fieldset ) use ( $ attachment ) { if ( $ attachment - > exists ) { 
public function authenticate ( Login Request $ request ) { $ throttles = $ this - > is Using Throttles Logins Trait ( ) ; if ( $ throttles & & $ this - > has Too Many Login Attempts ( $ request ) ) { return $ this - > send Lockout Response ( $ request ) ; } $ credentials = $ this - > get Credentials ( $ request ) ; try { if ( Auth : : attempt ( $ credentials , $ request - > has ( 'remember ' ) ) ) { return $ this - > handle User Was Authenticated ( $ request , $ throttles ) ; } } catch ( Exception $ e ) { 
protected function handle User Was Authenticated ( Request $ request , $ throttles ) { if ( $ throttles ) { $ this - > clear Login Attempts ( $ request ) ; } $ user = auth ( ) - > user ( ) ; if ( $ user instanceof User & & $ user - > adldap User instanceof Adldap User ) { $ this - > handle Ldap User Was Authenticated ( $ user , $ user - > adldap User ) ; } flash ( ) - > success ( 'Success ! ' , "You 're logged in ! " ) ; return redirect ( ) - > intended ( $ this - > redirect Path ( ) ) ; } 
protected function handle Ldap User Was Authenticated ( User $ user , Adldap User $ adldap User ) { if ( $ adldap User - > in Group ( 'Help Desk ' ) ) { $ admin = Role : : admin ( ) ; if ( $ admin instanceof Role ) { $ user - > attach Role ( $ admin - > get Key ( ) ) ; } } } 
public function deleted ( Inventory Stock $ stock ) { $ movements = $ stock - > movements ( ) - > get ( ) ; if ( count ( $ movements ) > 0 ) { foreach ( $ movements as $ movement ) { $ movement - > delete ( ) ; } } } 
public function restored ( Inventory Stock $ stock ) { $ movements = $ stock - > movements ( ) - > only Trashed ( ) - > get ( ) ; if ( count ( $ movements ) > 0 ) { foreach ( $ movements as $ movement ) { $ movement - > restore ( ) ; } } } 
public function up ( ) { Schema : : create ( 'suppliers ' , function ( Blueprint $ table ) { $ table - > increments ( 'id ' ) ; $ table - > timestamps ( ) ; $ table - > string ( 'name ' ) ; $ table - > string ( 'address ' ) - > nullable ( ) ; $ table - > string ( 'postal _code ' ) - > nullable ( ) ; $ table - > string ( 'zip _code ' ) - > nullable ( ) ; $ table - > string ( 'region ' ) - > nullable ( ) ; $ table - > string ( 'city ' ) - > nullable ( ) ; $ table - > string ( 'country ' ) - > nullable ( ) ; $ table - > string ( 'contact _title ' ) - > nullable ( ) ; $ table - > string ( 'contact _name ' ) - > nullable ( ) ; $ table - > string ( 'contact _phone ' ) - > nullable ( ) ; $ table - > string ( 'contact _fax ' ) - > nullable ( ) ; $ table - > string ( 'contact _email ' ) - > nullable ( ) ; } ) ; Schema : : create ( 'inventory _suppliers ' , function ( Blueprint $ table ) { $ table - > increments ( 'id ' ) ; $ table - > timestamps ( ) ; $ table - > integer ( 'inventory _id ' ) - > unsigned ( ) ; $ table - > integer ( 'supplier _id ' ) - > unsigned ( ) ; $ table - > foreign ( 'inventory _id ' ) - > references ( 'id ' ) - > on ( 'inventories ' ) - > on Update ( 'restrict ' ) - > on Delete ( 'cascade ' ) ; $ table - > foreign ( 'supplier _id ' ) - > references ( 'id ' ) - > on ( 'suppliers ' ) - > on Update ( 'restrict ' ) - > on Delete ( 'cascade ' ) ; } ) ; } 
public function table ( Priority $ priority ) { return $ this - > table - > of ( 'work -orders .priorities ' , function ( Table Grid $ table ) use ( $ priority ) { $ table - > with ( $ priority ) ; $ table - > column ( 'priority ' , function ( Column $ column ) { $ column - > value = function ( Priority $ priority ) { return link _to _route ( 'maintenance .work -orders .priorities .edit ' , $ priority - > get Label ( ) , [ $ priority - > get Key ( ) ] ) ; } ; } ) ; $ table - > column ( 'created _at ' ) ; $ table - > column ( 'created _by ' , function ( Column $ column ) { $ column - > value = function ( Priority $ priority ) { if ( $ priority - > user instanceof User ) { return $ priority - > user - > get Recipient Name ( ) ; } else { return HTML : : create ( 'em ' , 'None ' ) ; } } ; } ) ; } ) ; } 
public function form ( Priority $ priority ) { return $ this - > form - > of ( 'work -orders .priorities ' , function ( Form Grid $ form ) use ( $ priority ) { if ( $ priority - > exists ) { $ url = route ( 'maintenance .work -orders .priorities .update ' , [ $ priority - > get Key ( ) ] ) ; $ method = 'PATCH ' ; $ form - > submit = 'Save ' ; } else { $ url = route ( 'maintenance .work -orders .priorities .store ' ) ; $ method = 'POST ' ; $ form - > submit = 'Create ' ; } $ colors = config ( 'maintenance .colors ' , [ ] ) ; $ form - > attributes ( compact ( 'method ' , 'url ' ) ) ; $ form - > with ( $ priority ) ; $ form - > fieldset ( function ( Fieldset $ fieldset ) use ( $ colors ) { $ fieldset - > control ( 'input :text ' , 'name ' ) - > attributes ( [ 'placeholder ' = > 'ex . High / Low ' , ] ) ; $ fieldset - > control ( 'select ' , 'color ' ) - > options ( $ colors ) - > value ( function ( Priority $ priority ) { return $ priority - > color ; } ) - > attributes ( [ 'class ' = > 'select 2 -color ' , ] ) ; } ) ; } ) ; } 
public function handle ( ) { $ this - > inventory - > user _id = auth ( ) - > id ( ) ; $ this - > inventory - > category _id = $ this - > request - > input ( 'category ' ) ; $ this - > inventory - > metric _id = $ this - > request - > input ( 'metric ' ) ; $ this - > inventory - > name = $ this - > request - > input ( 'name ' ) ; $ this - > inventory - > description = $ this - > request - > clean ( $ this - > request - > input ( 'description ' ) ) ; return $ this - > inventory - > save ( ) ; } 
public function format Date With Time ( $ date , $ time = null ) { if ( ! empty ( $ date ) ) { if ( ! empty ( $ time ) ) { return date ( 'Y -m -d H :i :s ' , strtotime ( $ date . ' ' . $ time ) ) ; } return date ( 'Y -m -d H :i :s ' , strtotime ( $ date ) ) ; } return ; } 
public function table ( Work Order $ work Order , Inventory $ item ) { $ stocks = $ item - > stocks ( ) ; return $ this - > table - > of ( 'work -orders .parts .stocks ' , function ( Table Grid $ table ) use ( $ work Order , $ item , $ stocks ) { $ table - > with ( $ stocks ) - > paginate ( $ this - > per Page ) ; $ table - > column ( 'location ' , function ( Column $ column ) use ( $ item ) { $ column - > value = function ( Inventory Stock $ stock ) use ( $ item ) { $ name = $ stock - > location - > trail ; return link _to _route ( 'maintenance .inventory .stocks .show ' , $ name , [ $ item - > get Key ( ) , $ stock - > get Key ( ) ] ) ; } ; } ) ; $ table - > column ( 'quantity ' ) ; $ table - > column ( 'select ' , function ( Column $ column ) use ( $ work Order , $ item ) { $ column - > value = function ( Inventory Stock $ stock ) use ( $ work Order , $ item ) { $ route = 'maintenance .work -orders .parts .stocks .take ' ; $ params = [ $ work Order - > get Key ( ) , $ item - > get Key ( ) , $ stock - > get Key ( ) ] ; $ attributes = [ 'class ' = > 'btn btn -default btn -sm ' , ] ; return link _to _route ( $ route , 'Select ' , $ params , $ attributes ) ; } ; } ) ; } ) ; } 
public function form Take ( Work Order $ work Order , Inventory $ inventory , Inventory Stock $ stock ) { return $ this - > form - > of ( 'work -orders .parts .stocks .take ' , function ( Form Grid $ form ) use ( $ work Order , $ inventory , $ stock ) { $ form - > attributes ( [ 'method ' = > 'POST ' , 'url ' = > route ( 'maintenance .work -orders .parts .stocks .take ' , [ $ work Order - > get Key ( ) , $ inventory - > get Key ( ) , $ stock - > get Key ( ) ] ) , ] ) ; $ form - > submit = 'Save ' ; $ form - > fieldset ( function ( Fieldset $ fieldset ) use ( $ inventory ) { $ metric = $ inventory - > get Metric Symbol ( ) ; $ fieldset - > control ( 'input :text ' , 'quantity ' ) - > value ( 0 ) - > attribute ( [ 'placeholder ' = > "Enter Quantity in $metric " , ] ) ; } ) ; } ) ; } 
public function form Put ( Work Order $ work Order , Inventory $ inventory , Inventory Stock $ stock ) { return $ this - > form - > of ( 'work -orders .parts .stocks .put ' , function ( Form Grid $ form ) use ( $ work Order , $ inventory , $ stock ) { $ form - > attributes ( [ 'method ' = > 'POST ' , 'url ' = > route ( 'maintenance .work -orders .parts .stocks .put ' , [ $ work Order - > get Key ( ) , $ inventory - > get Key ( ) , $ stock - > get Key ( ) ] ) , ] ) ; $ form - > submit = 'Save ' ; $ form - > fieldset ( function ( Fieldset $ fieldset ) use ( $ inventory , $ stock ) { $ metric = $ inventory - > get Metric Symbol ( ) ; $ fieldset - > control ( 'input :text ' , 'quantity ' , function ( Field $ field ) { $ field - > label = 'Return Quantity ' ; } ) - > value ( $ stock - > pivot - > quantity ) - > attribute ( [ 'placeholder ' = > "Enter Quantity in $metric " , ] ) ; } ) ; } ) ; } 
public function update ( Inventory Request $ request , $ id ) { if ( $ this - > processor - > update ( $ request , $ id ) ) { flash ( ) - > success ( 'Success ! ' , 'Successfully updated inventory item . ' ) ; return redirect ( ) - > route ( 'maintenance .inventory .show ' , [ $ id ] ) ; } else { flash ( ) - > error ( 'Error ! ' , 'There was an issue updating this inventory item . Please try again . ' ) ; return redirect ( ) - > route ( 'maintenance .inventory .edit ' , [ $ id ] ) ; } } 
public function destroy ( $ id ) { if ( $ this - > processor - > destroy ( $ id ) ) { flash ( ) - > success ( 'Success ! ' , 'Successfully deleted inventory item . ' ) ; return redirect ( ) - > route ( 'maintenance .inventory .index ' ) ; } else { flash ( ) - > error ( 'Error ! ' , 'There was an issue deleting this inventory item . Please try again . ' ) ; return redirect ( ) - > route ( 'maintenance .inventory .show ' , [ $ id ] ) ; } } 
public function create ( $ title , $ message , $ level = 'info ' , $ key = 'flash _message ' ) { $ timer = $ this - > timer ; session ( ) - > flash ( $ key , compact ( 'title ' , 'message ' , 'level ' , 'info ' , 'timer ' ) ) ; } 
public function create ( $ work Order Id ) { try { return $ this - > processor - > create ( $ work Order Id ) ; } catch ( Report Exists Exception $ e ) { flash ( ) - > error ( 'Error ! ' , 'This work order already has already been completed . ' ) ; return redirect ( ) - > route ( 'maintenance .work -orders .show ' , [ $ work Order Id ] ) ; } } 
public function store ( Report Request $ request , $ work Order Id ) { if ( $ this - > processor - > store ( $ request , $ work Order Id ) ) { flash ( ) - > success ( 'Success ! ' , 'Successfully created work order report . ' ) ; return redirect ( ) - > route ( 'maintenance .work -orders .show ' , [ $ work Order Id ] ) ; } else { flash ( ) - > error ( 'Error ! ' , 'There was an issue creating a work order report . Please try again ' ) ; return redirect ( ) - > route ( 'maintenance .work -orders .report .create ' , [ $ work Order Id ] ) ; } } 
public function index ( $ resource Id ) { $ routes = $ this - > routes ; $ eventable = $ this - > get Eventable Repository ( ) - > model ( ) - > find Or Fail ( $ resource Id ) ; return view ( 'events .eventables .index ' , compact ( 'eventable ' , 'routes ' ) ) ; } 
public function store ( Event Request $ request , $ resource Id ) { $ eventable = $ this - > get Eventable Repository ( ) - > model ( ) - > find Or Fail ( $ resource Id ) ; $ event = $ this - > event - > create ( $ request ) ; if ( $ event & & method _exists ( $ eventable , 'events ' ) ) { $ eventable - > events ( ) - > attach ( $ event - > id ) ; $ message = 'Successfully created event . ' ; return redirect ( ) - > route ( $ this - > routes [ 'index ' ] , $ eventable - > id ) - > with Success ( $ message ) ; } else { $ message = 'There was an issue creating an event . Please try again . ' ; return redirect ( ) - > route ( $ this - > routes [ 'create ' ] ) - > with Errors ( $ message ) ; } } 
public function show ( $ resource Id , $ event Id ) { $ routes = $ this - > routes ; $ eventable = $ this - > get Eventable Repository ( ) - > model ( ) - > find Or Fail ( $ resource Id ) ; if ( method _exists ( $ eventable , 'events ' ) ) { $ event = $ eventable - > events ( ) - > find ( $ event Id ) ; if ( $ event ) { $ api Object = $ this - > event - > find Api Object ( $ event - > api _id ) ; return view ( 'events .eventables .show ' , compact ( 'routes ' , 'eventable ' , 'event ' , 'api Object ' ) ) ; } } abort ( 4 0 4 ) ; } 
public function update ( Event Request $ request , $ resource Id , $ event Id ) { $ eventable = $ this - > get Eventable Repository ( ) - > model ( ) - > find Or Fail ( $ resource Id ) ; $ event = $ this - > event - > update ( $ request , $ event Id ) ; if ( $ event ) { $ message = 'Successfully updated event . ' ; return redirect ( ) - > route ( $ this - > routes [ 'show ' ] , [ $ eventable - > id , $ event - > id ] ) - > with Success ( $ message ) ; } else { $ message = 'There was an issue updating this event . Please try again . ' ; return redirect ( ) - > route ( $ this - > routes [ 'edit ' ] , [ $ eventable - > id ] ) - > with Errors ( $ message ) ; } } 
public function destroy ( $ resource Id , $ event Id ) { $ eventable = $ this - > get Eventable Repository ( ) - > model ( ) - > find Or Fail ( $ resource Id ) ; if ( method _exists ( $ eventable , 'events ' ) ) { $ event = $ eventable - > events ( ) - > find ( $ event Id ) ; if ( $ event & & $ this - > event - > delete ( $ event - > id ) ) { $ message = 'Successfully deleted event . ' ; return redirect ( ) - > route ( $ this - > routes [ 'index ' ] , $ eventable - > id ) - > with Success ( $ message ) ; } else { $ message = 'There was an issue deleting this event . Please try again . ' ; return redirect ( ) - > route ( $ this - > routes [ 'show ' ] , $ eventable - > id , $ event - > id ) - > with Errors ( $ message ) ; } } abort ( 4 0 4 ) ; } 
public function get Revised Category Attribute ( $ id ) { if ( $ id ) { $ category = $ this - > category ( ) - > find ( $ id ) ; if ( $ category instanceof Category ) { return $ category - > trail ; } } return ; } 
public function scope Category ( $ query , $ category Id = null ) { if ( $ category Id ) { 
public function run ( ) { $ statuses = $ this - > get Seed Data ( ) ; foreach ( $ statuses as $ status ) { $ this - > status - > model ( ) - > create ( $ status ) ; } } 
public function form ( ) { return $ this - > form - > of ( 'label ' , function ( Form Grid $ form ) { $ form - > attributes ( [ 'url ' = > route ( 'maintenance .login .index ' ) ] ) ; $ form - > submit = 'Sign In ' ; $ form - > fieldset ( function ( Fieldset $ fieldset ) { $ fieldset - > control ( 'input :text ' , 'email ' ) - > label ( 'Email ' ) - > attributes ( [ 'placeholder ' = > 'Enter your Email ' ] ) ; $ fieldset - > control ( 'input :password ' , 'password ' ) - > label ( 'Password ' ) - > attributes ( [ 'placeholder ' = > 'Enter your Password ' ] ) ; } ) ; } ) ; } 
public function store ( Manual Request $ request , $ id ) { $ asset = $ this - > asset - > find ( $ id ) ; $ attachments = $ this - > manual - > upload ( $ request , $ asset , $ asset - > manuals ( ) ) ; if ( $ attachments ) { $ message = 'Successfully uploaded files . ' ; return redirect ( ) - > route ( 'maintenance .assets .manuals .index ' , [ $ asset - > id ] ) - > with Success ( $ message ) ; } else { $ message = 'There was an issue uploading the files you selected . Please try again . ' ; return redirect ( ) - > route ( 'maintenance .assets .manuals .create ' , [ $ id ] ) - > with Errors ( $ message ) ; } } 
public function show ( $ id , $ manual Id ) { $ asset = $ this - > asset - > find ( $ id ) ; $ manual = $ asset - > manuals ( ) - > find ( $ manual Id ) ; if ( $ manual ) { return view ( 'assets .manuals .show ' , compact ( 'asset ' , 'manual ' ) ) ; } abort ( 4 0 4 ) ; } 
public function update ( Attachment Update Request $ request , $ id , $ manual Id ) { $ asset = $ this - > asset - > find ( $ id ) ; $ manual = $ this - > manual - > update ( $ request , $ asset - > manuals ( ) , $ manual Id ) ; if ( $ manual ) { $ message = 'Successfully updated manual . ' ; return redirect ( ) - > route ( 'maintenance .assets .manuals .show ' , [ $ asset - > id , $ manual - > id ] ) - > with Success ( $ message ) ; } else { $ message = 'There was an issue updating this manual . Please try again . ' ; return redirect ( ) - > route ( 'maintenance .assets .manuals .show ' , [ $ id , $ manual Id ] ) - > with Errors ( $ message ) ; } } 
public function destroy ( $ id , $ manual Id ) { $ asset = $ this - > asset - > find ( $ id ) ; $ manual = $ asset - > manuals ( ) - > find ( $ manual Id ) ; if ( $ manual & & $ manual - > delete ( ) ) { $ message = 'Successfully deleted manual . ' ; return redirect ( ) - > route ( 'maintenance .assets .manuals .index ' , [ $ asset - > id ] ) - > with Success ( $ message ) ; } else { $ message = 'There was an issue deleting this manual . Please try again . ' ; return redirect ( ) - > route ( 'maintenance .assets .manuals .show ' , [ $ asset - > id , $ manual - > id ] ) - > with Errors ( $ message ) ; } } 
public function download ( $ id , $ manual Id ) { $ asset = $ this - > asset - > find ( $ id ) ; $ manual = $ asset - > manuals ( ) - > find ( $ manual Id ) ; if ( $ manual ) { return response ( ) - > download ( $ manual - > download _path ) ; } abort ( 4 0 4 ) ; } 
public function store ( $ asset Id , $ work Order Id ) { if ( $ this - > asset - > attach Work Order ( $ asset Id , $ work Order Id ) ) { $ message = 'Successfully attached work order . ' ; return redirect ( ) - > route ( 'maintenance .assets .work -orders .index ' , [ $ asset Id ] ) - > with Success ( $ message ) ; } else { $ message = 'There was an issue attaching this work order . Please try again . ' ; return redirect ( ) - > route ( 'maintenance .assets .work -orders .attach .index ' , [ $ asset Id ] ) - > with Errors ( $ message ) ; } } 
public function remove ( $ asset Id , $ work Order Id ) { if ( $ this - > asset - > detach Work Order ( $ asset Id , $ work Order Id ) ) { $ message = 'Successfully detached work order . ' ; return redirect ( ) - > route ( 'maintenance .assets .work -orders .index ' , [ $ asset Id ] ) - > with Success ( $ message ) ; } else { $ message = 'There was an issue detaching this work order . Please try again . ' ; return redirect ( ) - > route ( 'maintenance .assets .work -orders .index ' , [ $ asset Id ] ) - > with Errors ( $ message ) ; } } 
public function store ( $ work Request Id ) { if ( $ this - > update Validator - > passes ( ) ) { $ work Request = $ this - > work Request - > find ( $ work Request Id ) ; $ update = $ this - > update - > set Input ( $ this - > input All ( ) ) - > create ( ) ; $ this - > work Request - > save Update ( $ work Request , $ update ) ; $ this - > message = 'Successfully added update ' ; $ this - > message Type = 'success ' ; $ this - > redirect = route Back ( 'maintenance .work -requests .show ' , [ $ work Request - > id ] ) ; } else { $ this - > errors = $ this - > update Validator - > get Errors ( ) ; $ this - > redirect = route Back ( 'maintenance .work -requests .show ' , [ $ work Request Id ] ) ; } return $ this - > response ( ) ; } 
public function destroy ( $ work Request Id , $ update Id ) { $ work Request = $ this - > work Request - > find ( $ work Request Id ) ; if ( $ this - > update - > destroy ( $ update Id ) ) { $ this - > message = 'Successfully deleted update ' ; $ this - > message Type = 'success ' ; $ this - > redirect = route ( 'maintenance .work -requests .show ' , [ $ work Request - > id , ' #tab _updates ' ] ) ; } else { $ this - > message = 'There was an error trying to delete this update . Please try again . ' ; $ this - > message Type = 'danger ' ; $ this - > redirect = route ( 'maintenance .work -requests .show ' , [ $ work Request - > id , ' #tab _updates ' ] ) ; } return $ this - > response ( ) ; } 
public function index ( $ work Order Id , $ item Id ) { $ work Order = $ this - > work Order - > find Or Fail ( $ work Order Id ) ; $ item = $ this - > inventory - > find Or Fail ( $ item Id ) ; $ stocks = $ this - > presenter - > table ( $ work Order , $ item ) ; $ variants = $ this - > presenter - > table Variants ( $ work Order , $ item ) ; return view ( 'work -orders .parts .stocks .index ' , compact ( 'stocks ' , 'variants ' ) ) ; } 
public function get Take ( $ work Order Id , $ item Id , $ stock Id ) { $ work Order = $ this - > work Order - > find Or Fail ( $ work Order Id ) ; $ item = $ this - > inventory - > find Or Fail ( $ item Id ) ; $ stock = $ item - > stocks ( ) - > find Or Fail ( $ stock Id ) ; $ form = $ this - > presenter - > form Take ( $ work Order , $ item , $ stock ) ; return view ( 'work -orders .parts .stocks .take ' , compact ( 'work Order ' , 'item ' , 'stock ' , 'form ' ) ) ; } 
public function post Take ( Part Take Request $ request , $ work Order Id , $ item Id , $ stock Id ) { $ work Order = $ this - > work Order - > find Or Fail ( $ work Order Id ) ; $ item = $ this - > inventory - > find Or Fail ( $ item Id ) ; $ stock = $ item - > stocks ( ) - > find Or Fail ( $ stock Id ) ; return $ this - > dispatch ( new Take ( $ request , $ work Order , $ stock ) ) ; } 
public function get Put ( $ work Order Id , $ item Id , $ stock Id ) { $ work Order = $ this - > work Order - > find Or Fail ( $ work Order Id ) ; $ item = $ this - > inventory - > find Or Fail ( $ item Id ) ; $ stock = $ work Order - > parts ( ) - > find Or Fail ( $ stock Id ) ; $ form = $ this - > presenter - > form Put ( $ work Order , $ item , $ stock ) ; return view ( 'work -orders .parts .stocks .put ' , compact ( 'work Order ' , 'item ' , 'stock ' , 'form ' ) ) ; } 
public function post Put ( Part Return Request $ request , $ work Order Id , $ item Id , $ stock Id ) { $ work Order = $ this - > work Order - > find Or Fail ( $ work Order Id ) ; 
public function index ( ) { $ work Requests = $ this - > presenter - > table ( $ this - > work Request ) ; $ navbar = $ this - > presenter - > navbar ( ) ; return view ( 'work -requests .index ' , compact ( 'work Requests ' , 'navbar ' ) ) ; } 
public function store ( Work Http Request $ request ) { $ work Request = $ this - > work Request - > new Instance ( ) ; if ( $ this - > dispatch ( new Store ( $ request , $ work Request ) ) ) { $ this - > dispatch ( new Store From Work Request ( $ work Request ) ) ; return true ; } return false ; } 
public function edit ( $ id ) { $ work Request = $ this - > work Request - > find Or Fail ( $ id ) ; $ form = $ this - > presenter - > form ( $ work Request ) ; return view ( 'work -requests .edit ' , compact ( 'form ' ) ) ; } 
public function update ( Work Http Request $ request , $ id ) { $ work Request = $ this - > work Request - > find Or Fail ( $ id ) ; return $ this - > dispatch ( new Update ( $ request , $ work Request ) ) ; } 
public function create ( $ id = null ) { 
public function store ( Category Request $ request , $ id = null ) { $ category = $ this - > repository - > create ( $ request , $ id ) ; if ( $ category ) { $ message = "Successfully created $this - >resource " ; return redirect ( ) - > route ( $ this - > routes [ 'index ' ] ) - > with Success ( $ message ) ; } else { $ message = "There was an issue creating a $this - >resource . Please try again . " ; return redirect ( ) - > route ( $ this - > routes [ 'create ' ] , $ id ) - > with Errors ( $ message ) ; } } 
public function edit ( $ id ) { $ category = $ this - > repository - > find ( $ id ) ; return view ( 'categories .edit ' , [ 'category ' = > $ category , 'resource ' = > $ this - > resource , 'routes ' = > $ this - > routes , ] ) ; } 
public function update ( Category Request $ request , $ id ) { $ category = $ this - > repository - > update ( $ request , $ id ) ; if ( $ category ) { $ message = "Successfully updated $this - >resource " ; return redirect ( ) - > route ( $ this - > routes [ 'index ' ] ) - > with Success ( $ message ) ; } else { $ message = "There was an issue updating this $this - >resource . Please try again . " ; return redirect ( ) - > route ( $ this - > routes [ 'edit ' ] , $ id ) - > with Errors ( $ message ) ; } } 
public function destroy ( $ id ) { $ record = $ this - > repository - > find ( $ id ) ; if ( $ record - > delete ( ) ) { $ message = "Successfully deleted $this - >resource . " ; return redirect ( ) - > route ( $ this - > routes [ 'index ' ] ) - > with Success ( $ message ) ; } else { $ message = "There was an issue deleting this $this - >resource . Please try again . " ; return redirect ( ) - > route ( $ this - > routes [ 'index ' ] ) - > with Errors ( $ message ) ; } } 
public function handle ( ) { $ this - > inventory - > category _id = $ this - > request - > input ( 'category ' , $ this - > inventory - > category _id ) ; $ this - > inventory - > metric _id = $ this - > request - > input ( 'metric ' , $ this - > inventory - > metric _id ) ; $ this - > inventory - > name = $ this - > request - > input ( 'name ' , $ this - > inventory - > name ) ; $ this - > inventory - > description = $ this - > request - > clean ( $ this - > request - > input ( 'description ' , $ this - > inventory - > description ) ) ; return $ this - > inventory - > save ( ) ; } 
public function table ( Work Order $ work Order ) { $ sessions = $ work Order - > sessions ( ) ; return $ this - > table - > of ( 'work -orders .sessions ' , function ( Table Grid $ table ) use ( $ sessions ) { $ table - > with ( $ sessions ) - > paginate ( $ this - > per Page ) ; $ table - > attributes ( [ 'class ' = > 'table table -hover table -striped ' , ] ) ; $ table - > column ( 'user ' , function ( Column $ column ) { $ column - > value = function ( Work Order Session $ session ) { return $ session - > user - > fullname ; } ; } ) ; $ table - > column ( 'Hours ' , function ( Column $ column ) { $ column - > value = function ( Work Order Session $ session ) { return $ session - > get Hours ( ) ; } ; } ) ; $ table - > column ( 'in ' ) ; $ table - > column ( 'out ' , function ( Column $ column ) { $ column - > value = function ( Work Order Session $ session ) { return $ session - > get Out Label ( ) ; } ; } ) ; } ) ; } 
public function table Per Worker ( Work Order $ work Order ) { $ sessions = $ work Order - > get Unique Sessions ( ) ; return $ this - > table - > of ( 'work -orders .sessions .per -worker ' , function ( Table Grid $ table ) use ( $ sessions ) { $ table - > with ( $ sessions ) ; $ table - > attributes ( [ 'class ' = > 'table table -hover table -striped ' , ] ) ; $ table - > column ( 'worker ' , function ( Column $ column ) { $ column - > value = function ( Work Order Session $ session ) { return $ session - > user - > fullname ; } ; } ) ; $ table - > column ( 'total _hours ' , function ( Column $ column ) { $ column - > value = function ( Work Order Session $ session ) { return $ session - > total _hours ; } ; } ) ; } ) ; } 
public function deleted ( Inventory $ model ) { $ stocks = $ model - > stocks ( ) - > get ( ) ; if ( count ( $ stocks ) > 0 ) { foreach ( $ stocks as $ stock ) { $ stock - > delete ( ) ; } } } 
public function restored ( Inventory $ model ) { $ stocks = $ model - > stocks ( ) - > only Trashed ( ) - > get ( ) ; if ( count ( $ stocks ) > 0 ) { foreach ( $ stocks as $ stock ) { $ stock - > restore ( ) ; } } } 
public function index ( ) { $ inventory = $ this - > presenter - > table No Variants ( $ this - > inventory ) ; $ navbar = $ this - > presenter - > navbar ( ) ; return view ( 'inventory .index ' , compact ( 'inventory ' , 'navbar ' ) ) ; } 
public function store ( Inventory Request $ request ) { $ item = $ this - > inventory - > new Instance ( ) ; return $ this - > dispatch ( new Store ( $ request , $ item ) ) ; } 
public function show ( $ id ) { $ item = $ this - > inventory - > find ( $ id ) ; $ variants = $ this - > presenter - > table Variants ( $ item ) ; $ stocks = $ this - > presenter - > table Stocks ( $ item ) ; $ navbar Profile = $ this - > presenter - > navbar Profile ( $ item ) ; $ navbar Variants = $ this - > presenter - > navbar Variants ( $ item ) ; $ navbar Stocks = $ this - > presenter - > navbar Stocks ( $ item ) ; return view ( 'inventory .show ' , compact ( 'item ' , 'stocks ' , 'variants ' , 'navbar Profile ' , 'navbar Variants ' , 'navbar Stocks ' ) ) ; } 
public function edit ( $ id ) { $ item = $ this - > inventory - > find Or Fail ( $ id ) ; $ form = $ this - > presenter - > form ( $ item ) ; return view ( 'inventory .edit ' , compact ( 'form ' ) ) ; } 
public function update ( Inventory Request $ request , $ id ) { $ item = $ this - > inventory - > find Or Fail ( $ id ) ; return $ this - > dispatch ( new Update ( $ request , $ item ) ) ; } 
public function handle ( ) { $ this - > work Request - > user _id = auth ( ) - > id ( ) ; $ this - > work Request - > subject = $ this - > request - > input ( 'subject ' ) ; $ this - > work Request - > best _time = $ this - > request - > input ( 'best _time ' ) ; $ this - > work Request - > description = $ this - > request - > clean ( $ this - > request - > input ( 'description ' ) ) ; return $ this - > work Request - > save ( ) ; } 
public function table ( Inventory $ item ) { $ stocks = $ item - > stocks ( ) ; return $ this - > table - > of ( 'inventory .stocks ' , function ( Table Grid $ table ) use ( $ item , $ stocks ) { $ table - > with ( $ stocks ) ; $ table - > attributes ( [ 'class ' = > 'table table -hover table -striped ' , ] ) ; $ table - > column ( 'quantity ' ) ; $ table - > column ( 'location ' , function ( Column $ column ) use ( $ item ) { $ column - > value = function ( Inventory Stock $ stock ) use ( $ item ) { $ name = $ stock - > location - > trail ; return link _to _route ( 'maintenance .inventory .stocks .show ' , $ name , [ $ item - > get Key ( ) , $ stock - > get Key ( ) ] ) ; } ; } ) ; $ table - > column ( 'last _movement ' , function ( Column $ column ) { $ column - > value = function ( Inventory Stock $ stock ) { return $ stock - > last _movement ; } ; } ) ; $ table - > column ( 'last _movement _by ' , function ( Column $ column ) { $ column - > value = function ( Inventory Stock $ stock ) { return $ stock - > last _movement _by ; } ; } ) ; } ) ; } 
public function table Movements ( Inventory $ item , Inventory Stock $ stock ) { $ movements = $ stock - > movements ( ) ; return $ this - > table - > of ( 'inventory .stocks .movements ' , function ( Table Grid $ table ) use ( $ item , $ movements ) { $ table - > with ( $ movements ) - > paginate ( $ this - > per Page ) ; $ table - > page Name = 'stock -movements ' ; $ table - > column ( 'before ' ) ; $ table - > column ( 'after ' ) ; $ table - > column ( 'change ' ) ; $ table - > column ( 'cost ' ) ; $ table - > column ( 'reason ' ) ; $ table - > column ( 'Change By ' , function ( Column $ column ) { return $ column - > value = function ( Inventory Stock Movement $ movement ) { if ( $ movement - > user instanceof User ) { return $ movement - > user - > get Recipient Name ( ) ; } return HTML : : create ( 'em ' , 'Unknown ' ) ; } ; } ) ; $ table - > column ( 'Change On ' , 'created _at ' ) ; } ) ; } 
public function form ( Inventory $ item , Inventory Stock $ stock ) { return $ this - > form - > of ( 'inventory .stocks ' , function ( Form Grid $ form ) use ( $ item , $ stock ) { if ( $ stock - > exists ) { $ method = 'PATCH ' ; $ url = route ( 'maintenance .inventory .stocks .update ' , [ $ item - > get Key ( ) , $ stock - > get Key ( ) ] ) ; $ form - > submit = 'Save ' ; } else { $ method = 'POST ' ; $ url = route ( 'maintenance .inventory .stocks .store ' , [ $ item - > get Key ( ) ] ) ; $ form - > submit = 'Create ' ; } $ locations = Location : : get Select Hierarchy ( ) ; $ form - > with ( $ stock ) ; $ form - > attributes ( compact ( 'method ' , 'url ' ) ) ; $ form - > fieldset ( function ( Fieldset $ fieldset ) use ( $ locations ) { $ fieldset - > control ( 'select ' , 'location ' ) - > value ( function ( Inventory Stock $ stock ) { return $ stock - > location _id ; } ) - > options ( $ locations ) ; $ fieldset - > control ( 'input :text ' , 'quantity ' ) - > attributes ( [ 'placeholder ' = > 'ex . 4 5 ' , ] ) ; $ fieldset - > control ( 'input :text ' , 'reason ' ) - > attributes ( [ 'placeholder ' = > 'ex . Stock Update ' , ] ) ; $ fieldset - > control ( 'input :text ' , 'cost ' ) - > attributes ( [ 'placeholder ' = > 'ex . 1 5 . 0 0 ' , ] ) ; } ) ; } ) ; } 
public function navbar ( Inventory $ item ) { return $ this - > fluent ( [ 'id ' = > 'inventory -stocks ' , 'title ' = > 'Item Stocks ' , 'url ' = > route ( 'maintenance .inventory .stocks .index ' , [ $ item - > get Key ( ) ] ) , 'menu ' = > view ( 'inventory .stocks . _nav ' , compact ( 'item ' ) ) , 'attributes ' = > [ 'class ' = > 'navbar -default ' , ] , ] ) ; } 
public function run ( ) { $ priorities = $ this - > get Seed Data ( ) ; foreach ( $ priorities as $ priority ) { $ this - > priority - > model ( ) - > create ( $ priority ) ; } } 
public function up ( ) { Schema : : create ( 'assets ' , function ( Blueprint $ table ) { $ table - > increments ( 'id ' ) ; $ table - > timestamps ( ) ; $ table - > soft Deletes ( ) ; $ table - > date ( 'acquired _at ' ) - > nullable ( ) ; $ table - > date ( 'end _of _life ' ) - > nullable ( ) ; $ table - > integer ( 'user _id ' ) - > unsigned ( ) - > nullable ( ) ; $ table - > integer ( 'location _id ' ) - > unsigned ( ) - > nullable ( ) ; $ table - > integer ( 'category _id ' ) - > unsigned ( ) ; $ table - > string ( 'tag ' ) - > nullable ( ) ; $ table - > string ( 'name ' ) ; $ table - > text ( 'description ' ) - > nullable ( ) ; $ table - > integer ( 'condition ' ) - > nullable ( ) ; $ table - > string ( 'size ' ) - > nullable ( ) ; $ table - > string ( 'weight ' ) - > nullable ( ) ; $ table - > string ( 'vendor ' ) - > nullable ( ) ; $ table - > string ( 'make ' ) - > nullable ( ) ; $ table - > string ( 'model ' ) - > nullable ( ) ; $ table - > string ( 'serial ' ) - > nullable ( ) ; $ table - > decimal ( 'price ' , 1 0 , 2 ) - > nullable ( ) ; $ table - > foreign ( 'user _id ' ) - > references ( 'id ' ) - > on ( 'users ' ) - > on Update ( 'restrict ' ) - > on Delete ( 'set null ' ) ; $ table - > foreign ( 'location _id ' ) - > references ( 'id ' ) - > on ( 'locations ' ) - > on Update ( 'restrict ' ) - > on Delete ( 'set null ' ) ; $ table - > foreign ( 'category _id ' ) - > references ( 'id ' ) - > on ( 'categories ' ) - > on Update ( 'restrict ' ) - > on Delete ( 'cascade ' ) ; } ) ; Schema : : create ( 'asset _meters ' , function ( Blueprint $ table ) { $ table - > integer ( 'asset _id ' ) - > unsigned ( ) ; $ table - > integer ( 'meter _id ' ) - > unsigned ( ) ; $ table - > foreign ( 'asset _id ' ) - > references ( 'id ' ) - > on ( 'assets ' ) - > on Update ( 'restrict ' ) - > on Delete ( 'cascade ' ) ; $ table - > foreign ( 'meter _id ' ) - > references ( 'id ' ) - > on ( 'meters ' ) - > on Update ( 'restrict ' ) - > on Delete ( 'cascade ' ) ; } ) ; } 
public function table ( Work Order $ work Order ) { $ parts = $ work Order - > parts ( ) ; return $ this - > table - > of ( 'work -orders .parts ' , function ( Table Grid $ table ) use ( $ work Order , $ parts ) { $ table - > with ( $ parts ) - > paginate ( $ this - > per Page ) ; $ table - > page Name = 'page -parts ' ; $ table - > column ( 'ID ' , 'id ' ) ; $ table - > column ( 'SKU ' , function ( Column $ column ) { $ column - > value = function ( Inventory Stock $ stock ) { return $ stock - > item - > get Sku ( ) ; } ; } ) ; $ table - > column ( 'name ' , function ( Column $ column ) { $ column - > value = function ( Inventory Stock $ stock ) { return $ stock - > item - > name ; } ; } ) ; $ table - > column ( 'location ' , function ( Column $ column ) { $ column - > value = function ( Inventory Stock $ stock ) { return $ stock - > location - > trail ; } ; } ) ; $ table - > column ( 'taken ' , function ( Column $ column ) { $ column - > value = function ( Inventory Stock $ stock ) { return $ stock - > quantity ; } ; } ) ; $ table - > column ( 'return ' , function ( Column $ column ) use ( $ work Order ) { $ column - > label = 'Return Stock ' ; $ column - > value = function ( Inventory Stock $ stock ) use ( $ work Order ) { $ route = 'maintenance .work -orders .parts .stocks .put ' ; $ params = [ $ work Order - > get Key ( ) , $ stock - > item - > get Key ( ) , $ stock - > get Key ( ) ] ; $ attributes = [ 'class ' = > 'btn btn -default btn -sm ' , ] ; return link _to _route ( $ route , 'Return ' , $ params , $ attributes ) ; } ; } ) ; } ) ; } 
public function table Inventory ( Work Order $ work Order , Inventory $ inventory ) { $ inventory = $ inventory - > no Variants ( ) ; return $ this - > table - > of ( 'work -orders .inventory ' , function ( Table Grid $ table ) use ( $ inventory , $ work Order ) { $ table - > with ( $ inventory ) - > paginate ( $ this - > per Page ) ; $ table - > page Name = 'page -inventory ' ; $ table - > column ( 'ID ' , 'id ' ) ; $ table - > column ( 'sku ' , function ( Column $ column ) { $ column - > label = 'SKU ' ; $ column - > value = function ( Inventory $ item ) { return $ item - > get Sku ( ) ; } ; } ) ; $ table - > column ( 'name ' , function ( Column $ column ) { $ column - > value = function ( Inventory $ item ) { return link _to _route ( 'maintenance .inventory .show ' , $ item - > name , [ $ item - > get Key ( ) ] ) ; } ; } ) ; $ table - > column ( 'category ' , function ( Column $ column ) { $ column - > value = function ( Inventory $ item ) { return $ item - > category - > trail ; } ; } ) ; $ table - > column ( 'current _stock ' , function ( Column $ column ) { $ column - > value = function ( Inventory $ item ) { return $ item - > get Total Stock ( ) ; } ; } ) ; $ table - > column ( 'select ' , function ( Column $ column ) use ( $ work Order ) { $ column - > value = function ( Inventory $ item ) use ( $ work Order ) { $ route = 'maintenance .work -orders .parts .stocks .index ' ; $ params = [ $ work Order - > get Key ( ) , $ item - > get Key ( ) ] ; $ attributes = [ 'class ' = > 'btn btn -default btn -sm ' , ] ; return link _to _route ( $ route , 'Select ' , $ params , $ attributes ) ; } ; } ) ; } ) ; } 
public function navbar Parts ( Work Order $ work Order ) { return $ this - > fluent ( [ 'id ' = > 'work -orders -parts ' , 'title ' = > 'Parts Added ' , 'url ' = > route ( 'maintenance .work -orders .parts .index ' , [ $ work Order - > get Key ( ) ] ) , 'menu ' = > view ( 'work -orders .parts . _nav ' , compact ( 'work Order ' ) ) , 'attributes ' = > [ 'class ' = > 'navbar -default ' , ] , ] ) ; } 
public function index ( $ work Order Id ) { $ work Order = $ this - > work Order - > find Or Fail ( $ work Order Id ) ; $ sessions = $ this - > presenter - > table ( $ work Order ) ; $ navbar = $ this - > presenter - > navbar ( ) ; return view ( 'work -orders .sessions .index ' , compact ( 'sessions ' , 'navbar ' ) ) ; } 
public function start ( $ work Order Id ) { $ work Order = $ this - > work Order - > find Or Fail ( $ work Order Id ) ; return $ this - > dispatch ( new Start ( $ work Order ) ) ; } 
public function end ( $ work Order Id ) { $ work Order = $ this - > work Order - > find Or Fail ( $ work Order Id ) ; return $ this - > dispatch ( new End ( $ work Order ) ) ; } 
public function handle ( ) { $ this - > priority - > user _id = auth ( ) - > id ( ) ; $ this - > priority - > name = $ this - > request - > input ( 'name ' ) ; $ this - > priority - > color = $ this - > request - > input ( 'color ' ) ; return $ this - > priority - > save ( ) ; } 
public function handle ( ) { $ this - > status - > name = $ this - > request - > input ( 'name ' , $ this - > status - > name ) ; $ this - > status - > color = $ this - > request - > input ( 'color ' , $ this - > status - > color ) ; return $ this - > status - > save ( ) ; } 
public function get Change Attribute ( ) { if ( $ this - > before > $ this - > after ) { return sprintf ( ' - %s ' , $ this - > before - $ this - > after ) ; } elseif ( $ this - > after > $ this - > before ) { return sprintf ( ' + %s ' , $ this - > after - $ this - > before ) ; } else { return 'None ' ; } } 
public function store ( Note Request $ request , $ id ) { $ note = $ this - > inventory - > create Note ( $ request , $ id ) ; if ( $ note ) { $ message = 'Successfully created note . ' ; return redirect ( ) - > route ( 'maintenance .inventory .show ' , [ $ id ] ) - > with Success ( $ message ) ; } else { $ message = 'There was an issue creating a note . Please try again . ' ; return redirect ( ) - > route ( 'maintenance .inventory .notes .create ' , [ $ id ] ) - > with Errors ( $ message ) ; } } 
public function show ( $ id , $ note Id ) { $ item = $ this - > inventory - > find ( $ id ) ; $ note = $ item - > notes ( ) - > find ( $ note Id ) ; if ( $ note ) { return view ( 'inventory .notes .show ' , compact ( 'item ' , 'note ' ) ) ; } abort ( 4 0 4 ) ; } 
public function update ( Note Request $ request , $ id , $ note Id ) { $ note = $ this - > inventory - > update Note ( $ request , $ id , $ note Id ) ; if ( $ note ) { $ message = 'Successfully updated note . ' ; return redirect ( ) - > route ( 'maintenance .inventory .notes .show ' , [ $ id , $ note Id ] ) - > with Success ( $ message ) ; } else { $ message = 'There was an issue updating this note . Please try again . ' ; return redirect ( ) - > route ( 'maintenance .inventory .notes .update ' , [ $ id , $ note Id ] ) - > with Errors ( $ message ) ; } } 
public function destroy ( $ id , $ note Id ) { if ( $ this - > inventory - > delete Note ( $ id , $ note Id ) ) { $ message = 'Successfully updated note . ' ; return redirect ( ) - > route ( 'maintenance .inventory .show ' , [ $ id ] ) - > with Success ( $ message ) ; } else { $ message = 'There was an issue deleting this note . Please try again . ' ; return redirect ( ) - > route ( 'maintenance .inventory .notes .show ' , [ $ id , $ note Id ] ) - > with Errors ( $ message ) ; } } 
public function handle ( ) { $ this - > status - > user _id = auth ( ) - > id ( ) ; $ this - > status - > name = $ this - > request - > input ( 'name ' ) ; $ this - > status - > color = $ this - > request - > input ( 'color ' ) ; return $ this - > status - > save ( ) ; } 
public function get Last Movement Attribute ( ) { if ( $ this - > movements - > count ( ) > 0 ) { $ movement = $ this - > movements - > first ( ) ; if ( $ movement instanceof Inventory Stock Movement & & $ movement - > after > $ movement - > before ) { return sprintf ( ' <b > %s < /b > (Stock was added - %s ) - <b >Reason : < /b > %s ' , $ movement - > change , $ movement - > created _at , $ movement - > reason ) ; } elseif ( $ movement - > before > $ movement - > after ) { return sprintf ( ' <b > %s < /b > (Stock was removed - %s ) - <b >Reason : < /b > %s ' , $ movement - > change , $ movement - > created _at , $ movement - > reason ) ; } else { return sprintf ( ' <b > %s < /b > (No Change - %s ) - <b >Reason : < /b > %s ' , $ movement - > change , $ movement - > created _at , $ movement - > reason ) ; } } return ; } 
public function get Last Movement By Attribute ( ) { if ( $ this - > movements - > count ( ) > 0 ) { $ movement = $ this - > movements - > first ( ) ; if ( $ movement instanceof Inventory Stock Movement & & $ movement - > user instanceof User ) { return $ movement - > user - > get Recipient Name ( ) ; } } return ; } 
public function get Quantity Metric Attribute ( ) { $ quantity = $ this - > get Attribute ( 'quantity ' ) ; if ( $ this - > item & & $ this - > item - > metric ) { $ metric = $ this - > item - > metric - > name ; } else { $ metric = null ; } return trim ( sprintf ( ' %s %s ' , $ quantity , $ metric ) ) ; } 
public function btn Put Back Some For Work Order ( Work Order $ work Order ) { if ( $ this - > entity - > item ) { return view ( 'viewers .inventory .stock .buttons .put -back -some -work -order ' , [ 'work Order ' = > $ work Order , 'stock ' = > $ this - > entity , ] ) ; } return ; } 
public function btn Put Back All For Work Order ( Work Order $ work Order ) { if ( $ this - > entity - > item ) { return view ( 'viewers .inventory .stock .buttons .put -back -all -work -order ' , [ 'work Order ' = > $ work Order , 'stock ' = > $ this - > entity , ] ) ; } return ; } 
public function up ( ) { Schema : : create ( 'work _requests ' , function ( Blueprint $ table ) { $ table - > increments ( 'id ' ) ; $ table - > timestamps ( ) ; $ table - > soft Deletes ( ) ; $ table - > integer ( 'user _id ' ) - > unsigned ( ) - > nullable ( ) ; $ table - > string ( 'subject ' ) ; $ table - > text ( 'description ' ) ; $ table - > string ( 'best _time ' ) ; $ table - > foreign ( 'user _id ' ) - > references ( 'id ' ) - > on ( 'users ' ) - > on Update ( 'restrict ' ) - > on Delete ( 'set null ' ) ; } ) ; Schema : : create ( 'work _orders ' , function ( Blueprint $ table ) { $ table - > increments ( 'id ' ) ; $ table - > timestamps ( ) ; $ table - > soft Deletes ( ) ; $ table - > integer ( 'user _id ' ) - > unsigned ( ) - > nullable ( ) ; $ table - > integer ( 'category _id ' ) - > unsigned ( ) - > nullable ( ) ; $ table - > integer ( 'location _id ' ) - > unsigned ( ) - > nullable ( ) ; $ table - > integer ( 'request _id ' ) - > unsigned ( ) - > nullable ( ) ; $ table - > integer ( 'status _id ' ) - > unsigned ( ) ; $ table - > integer ( 'priority _id ' ) - > unsigned ( ) ; $ table - > date Time ( 'started _at ' ) - > nullable ( ) ; $ table - > date Time ( 'completed _at ' ) - > nullable ( ) ; $ table - > string ( 'subject ' ) ; $ table - > text ( 'description ' ) - > nullable ( ) ; $ table - > foreign ( 'user _id ' ) - > references ( 'id ' ) - > on ( 'users ' ) - > on Update ( 'restrict ' ) - > on Delete ( 'set null ' ) ; $ table - > foreign ( 'location _id ' ) - > references ( 'id ' ) - > on ( 'locations ' ) - > on Update ( 'restrict ' ) - > on Delete ( 'set null ' ) ; $ table - > foreign ( 'category _id ' ) - > references ( 'id ' ) - > on ( 'categories ' ) - > on Update ( 'restrict ' ) - > on Delete ( 'set null ' ) ; $ table - > foreign ( 'request _id ' ) - > references ( 'id ' ) - > on ( 'work _requests ' ) - > on Update ( 'restrict ' ) - > on Delete ( 'set null ' ) ; $ table - > foreign ( 'status _id ' ) - > references ( 'id ' ) - > on ( 'statuses ' ) - > on Update ( 'restrict ' ) - > on Delete ( 'cascade ' ) ; $ table - > foreign ( 'priority _id ' ) - > references ( 'id ' ) - > on ( 'priorities ' ) - > on Update ( 'restrict ' ) - > on Delete ( 'cascade ' ) ; $ table - > unique ( [ 'request _id ' ] ) ; } ) ; Schema : : create ( 'work _order _notifications ' , function ( Blueprint $ table ) { $ table - > increments ( 'id ' ) ; $ table - > timestamps ( ) ; $ table - > integer ( 'user _id ' ) - > unsigned ( ) ; $ table - > integer ( 'work _order _id ' ) - > unsigned ( ) ; $ table - > tiny Integer ( 'status ' ) - > default ( 0 ) ; $ table - > tiny Integer ( 'priority ' ) - > default ( 0 ) ; $ table - > tiny Integer ( 'parts ' ) - > default ( 0 ) ; $ table - > tiny Integer ( 'customer _updates ' ) - > default ( 0 ) ; $ table - > tiny Integer ( 'technician _updates ' ) - > default ( 0 ) ; $ table - > tiny Integer ( 'completion _report ' ) - > default ( 0 ) ; $ table - > foreign ( 'user _id ' ) - > references ( 'id ' ) - > on ( 'users ' ) - > on Update ( 'restrict ' ) - > on Delete ( 'cascade ' ) ; $ table - > foreign ( 'work _order _id ' ) - > references ( 'id ' ) - > on ( 'work _orders ' ) - > on Update ( 'restrict ' ) - > on Delete ( 'cascade ' ) ; } ) ; Schema : : create ( 'work _order _reports ' , function ( Blueprint $ table ) { $ table - > increments ( 'id ' ) ; $ table - > timestamps ( ) ; $ table - > integer ( 'user _id ' ) - > unsigned ( ) ; $ table - > integer ( 'work _order _id ' ) - > unsigned ( ) ; $ table - > text ( 'description ' ) ; $ table - > foreign ( 'user _id ' ) - > references ( 'id ' ) - > on ( 'users ' ) - > on Update ( 'restrict ' ) - > on Delete ( 'cascade ' ) ; $ table - > foreign ( 'work _order _id ' ) - > references ( 'id ' ) - > on ( 'work _orders ' ) - > on Update ( 'restrict ' ) - > on Delete ( 'cascade ' ) ; } ) ; Schema : : create ( 'work _order _sessions ' , function ( Blueprint $ table ) { $ table - > increments ( 'id ' ) ; $ table - > timestamps ( ) ; $ table - > integer ( 'user _id ' ) - > unsigned ( ) ; $ table - > integer ( 'work _order _id ' ) - > unsigned ( ) ; $ table - > date Time ( 'in ' ) ; $ table - > date Time ( 'out ' ) - > nullable ( ) ; $ table - > decimal ( 'hours ' , 5 , 2 ) - > nullable ( ) ; 
public function handle ( ) { $ this - > metric - > user _id = auth ( ) - > id ( ) ; $ this - > metric - > name = $ this - > request - > input ( 'name ' ) ; $ this - > metric - > symbol = $ this - > request - > input ( 'symbol ' ) ; return $ this - > metric - > save ( ) ; } 
public function end ( $ work Order Id ) { if ( $ this - > processor - > end ( $ work Order Id ) ) { flash ( ) - > success ( 'Success ! ' , 'Successfully ended your session . Your hours have been logged . ' ) ; return redirect ( ) - > route ( 'maintenance .work -orders .show ' , [ $ work Order Id ] ) ; } else { flash ( ) - > error ( 'Error ! ' , 'There was an issue ending your session . Please try again . ' ) ; return redirect ( ) - > route ( 'maintenance .work -orders .show ' , [ $ work Order Id ] ) ; } } 
public function table ( $ work Request ) { return $ this - > table - > of ( 'work -requests ' , function ( Table Grid $ table ) use ( $ work Request ) { $ table - > with ( $ work Request ) - > paginate ( $ this - > per Page ) ; $ table - > attributes ( [ 'class ' = > 'table table -hover table -striped ' , ] ) ; $ table - > column ( 'ID ' , 'id ' ) ; $ table - > column ( 'subject ' , function ( Column $ column ) { $ column - > value = function ( Work Request $ work Request ) { return link _to _route ( 'maintenance .work -requests .show ' , $ work Request - > subject , [ $ work Request - > get Key ( ) ] ) ; } ; } ) ; $ table - > column ( 'best _time ' ) ; $ table - > column ( 'created _at ' ) ; } ) ; } 
public function form ( Work Request $ request ) { return $ this - > form - > of ( 'work -requests ' , function ( Form Grid $ form ) use ( $ request ) { if ( $ request - > exists ) { $ method = 'PATCH ' ; $ url = route ( 'maintenance .work -requests .update ' , [ $ request - > get Key ( ) ] ) ; $ form - > submit = 'Save ' ; } else { $ method = 'POST ' ; $ url = route ( 'maintenance .work -requests .store ' ) ; $ form - > submit = 'Create ' ; } $ form - > with ( $ request ) ; $ form - > attributes ( compact ( 'method ' , 'url ' ) ) ; $ form - > fieldset ( function ( Fieldset $ fieldset ) { $ fieldset - > control ( 'input :text ' , 'subject ' ) - > attributes ( [ 'placeholder ' = > 'Enter Subject ' , ] ) ; $ fieldset - > control ( 'input :text ' , 'best _time ' ) - > attributes ( [ 'placeholder ' = > 'Enter Best Time ' , ] ) ; $ fieldset - > control ( 'input :textarea ' , 'description ' ) ; } ) ; } ) ; } 
public function store ( $ work Order _id ) { if ( $ this - > assignment Validator - > passes ( ) ) { $ work Order = $ this - > work Order - > find ( $ work Order _id ) ; $ data = $ this - > input All ( ) ; $ data [ 'work _order _id ' ] = $ work Order - > id ; $ records = $ this - > assignment - > set Input ( $ data ) - > create ( ) ; if ( $ records ) { $ this - > message = 'Successfully assigned worker (s ) ' ; $ this - > message Type = 'success ' ; $ this - > redirect = route ( 'maintenance .work -orders .show ' , [ $ work Order - > id ] ) ; } else { $ this - > message = 'There was an error trying to assign workers to this work order . Please try again . ' ; $ this - > message Type = 'danger ' ; $ this - > redirect = route ( 'maintenance .work -orders .show ' , [ $ work Order - > id ] ) ; } } else { $ this - > errors = $ this - > assignment Validator - > get Errors ( ) ; $ this - > redirect = route ( 'maintenance .work -orders .show ' , [ $ work Order _id ] ) ; } return $ this - > response ( ) ; } 
public function destroy ( $ work Order _id , $ assignment _id ) { if ( $ this - > assignment - > destroy ( $ assignment _id ) ) { $ this - > message = 'Successfully removed worker from this work order . ' ; $ this - > message Type = 'success ' ; $ this - > redirect = route ( 'maintenance .work -orders .show ' , [ $ work Order _id ] ) ; } else { $ this - > message = 'There was an error trying to remove this worker from this work order . Please try again later . ' ; $ this - > message Type = 'danger ' ; $ this - > redirect = route ( 'maintenance .work -orders .show ' , [ $ work Order _id ] ) ; } return $ this - > response ( ) ; } 
public function get Reading With Metric Attribute ( ) { if ( $ this - > meter & & $ this - > meter - > metric ) { return $ this - > reading . ' ' . $ this - > meter - > metric - > symbol ; } return $ this - > reading ; } 
public function select ( string $ name , iterable $ list = [ ] , $ selected = null , array $ select Attributes = [ ] , array $ options Attributes = [ ] , array $ optgroups Attributes = [ ] ) : Htmlable { $ this - > type = 'select ' ; 
public function datalist ( string $ id , array $ list = [ ] ) : Htmlable { $ this - > type = 'datalist ' ; $ attributes [ 'id ' ] = $ id ; $ html = [ ] ; if ( Arr : : is Assoc ( $ list ) ) { foreach ( $ list as $ value = > $ display ) { $ html [ ] = $ this - > option ( $ display , $ value , null , [ ] ) ; } } else { foreach ( $ list as $ value ) { $ html [ ] = $ this - > option ( $ value , $ value , null , [ ] ) ; } } $ attributes = $ this - > get Html Builder ( ) - > attributes ( $ attributes ) ; $ list = \ implode ( ' ' , $ html ) ; return $ this - > to Html String ( " <datalist { $attributes } > { $list } < /datalist > " ) ; } 
public function get Select Option ( $ display , string $ value , $ selected , array $ attributes = [ ] , array $ optgroups = [ ] ) : Htmlable { if ( \ is _iterable ( $ display ) ) { return $ this - > option Group ( $ display , $ value , $ selected , $ optgroups , $ attributes ) ; } return $ this - > option ( $ display , $ value , $ selected , $ attributes ) ; } 
protected function option Group ( iterable $ list , string $ label , $ selected , array $ attributes = [ ] , array $ options Attributes = [ ] , int $ level = 0 ) : Htmlable { $ html = [ ] ; $ space = \ str _repeat ( ' &nbsp ; ' , $ level ) ; foreach ( $ list as $ value = > $ display ) { if ( \ is _iterable ( $ display ) ) { $ html [ ] = $ this - > option ( $ display , $ value , $ selected , $ options Attributes [ $ value ] ? ? [ ] , $ level + 5 ) ; } else { $ html [ ] = $ this - > option ( $ space . $ display , $ value , $ selected , $ options Attributes [ $ value ] ? ? [ ] ) ; } } return $ this - > to Html String ( \ sprintf ( ' <optgroup label = " %s " %s > %s < /optgroup > ' , $ this - > entities ( $ label ) , $ this - > get Html Builder ( ) - > attributes ( $ attributes ) , \ implode ( ' ' , $ html ) ) ) ; } 
protected function option ( string $ display , string $ value , $ selected , array $ attributes = [ ] , array $ optgroups = [ ] ) : Htmlable { $ selected = $ this - > get Selected Value ( $ value , $ selected ) ; $ options = [ 'value ' = > $ value , 'selected ' = > $ selected ] + $ attributes ; return $ this - > to Html String ( \ sprintf ( ' <option %s > %s < /option > ' , $ this - > get Html Builder ( ) - > attributes ( $ options ) , $ this - > entities ( $ display ) ) ) ; } 
protected function placeholder Option ( string $ display , $ selected ) : Htmlable { $ options = [ 'selected ' = > $ this - > get Selected Value ( null , $ selected ) , 'disabled ' = > true , 'value ' = > ' ' , ] ; return $ this - > to Html String ( \ sprintf ( ' <option %s > %s < /option > ' , $ this - > get Html Builder ( ) - > attributes ( $ options ) , $ this - > entities ( $ display ) ) ) ; } 
protected function get Selected Value ( ? string $ value , $ selected ) : ? string { $ selection = $ selected instanceof Arrayable ? $ selected - > to Array ( ) : $ selected ; if ( \ is _array ( $ selection ) ) { if ( \ in _array ( $ value , $ selection , true ) | | \ in _array ( ( string ) $ value , $ selection , true ) ) { return 'selected ' ; } elseif ( $ selected instanceof Collection ) { return $ selected - > contains ( $ value ) ? 'selected ' : null ; } return null ; } if ( \ is _int ( $ value ) & & \ is _bool ( $ selected ) ) { return ( bool ) $ value = = = $ selected ; } return ( ( string ) $ value = = = ( string ) $ selected ) ? 'selected ' : null ; } 
public function select Year ( string $ name , $ begin , $ end , $ selected = null , array $ options = [ ] ) : Htmlable { return $ this - > select Range ( $ name , $ begin , $ end , $ selected , $ options ) ; } 
public function open ( array $ options = [ ] ) : Htmlable { $ method = $ options [ 'method ' ] ? ? 'post ' ; 
protected function get Appendage ( string $ method ) : string { list ( $ method , $ appendage ) = [ \ strtoupper ( $ method ) , ' ' ] ; 
protected function get Action ( array $ options ) : string { 
protected function render Component ( string $ name , array $ arguments ) : Htmlable { $ component = static : : $ components [ $ name ] ; $ data = $ this - > get Component Data ( $ component [ 'signature ' ] , $ arguments ) ; return new Html String ( $ this - > view - > make ( $ component [ 'view ' ] , $ data ) - > render ( ) ) ; } 
protected function get Component Data ( array $ signature , array $ arguments ) : array { $ data = [ ] ; $ i = 0 ; foreach ( $ signature as $ variable = > $ default ) { 
protected function register ( ) { $ this - > app - > after Resolving ( 'blade .compiler ' , function ( Blade Compiler $ blade Compiler ) { $ namespaces = [ 'Html ' = > \ get _class _methods ( Html Builder : : class ) , 'Form ' = > \ get _class _methods ( Form Builder : : class ) , ] ; foreach ( $ namespaces as $ namespace = > $ methods ) { foreach ( $ methods as $ method ) { if ( \ in _array ( $ method , $ this - > directives ) ) { $ snake Method = Str : : snake ( $ method ) ; $ directive = \ strtolower ( $ namespace ) . ' _ ' . $ snake Method ; $ blade Compiler - > directive ( $ directive , function ( $ expression ) use ( $ namespace , $ method ) { return " < ?php echo $namespace : : $method ( $expression ) ; ? > " ; } ) ; } } } } ) ; } 
protected function entities ( string $ value , bool $ encoding = false ) : string { return $ this - > html - > entities ( $ value , $ encoding ) ; } 
public function model ( $ model , array $ options = [ ] ) : Htmlable { $ this - > model = $ model ; return $ this - > open ( $ options ) ; } 
public function label ( string $ name , ? string $ value = null , array $ options = [ ] ) : Htmlable { $ this - > labels [ ] = $ name ; $ options = $ this - > html - > attributes ( $ options ) ; $ value = $ this - > entities ( $ this - > format Label ( $ name , $ value ) ) ; return $ this - > to Html String ( ' <label for = " ' . $ name . ' " ' . $ options . ' > ' . $ value . ' < /label > ' ) ; } 
protected function format Label ( string $ name , ? string $ value ) : string { return $ value ? ? \ ucwords ( \ str _replace ( ' _ ' , ' ' , $ name ) ) ; } 
protected function missing Old And Model ( string $ name ) : bool { return \ is _null ( $ this - > old ( $ name ) ) & & \ is _null ( $ this - > get Model Value Attribute ( $ name ) ) ; } 
public function reset ( ? string $ value = null , array $ attributes = [ ] ) : Htmlable { return $ this - > input ( 'reset ' , null , $ value , $ attributes ) ; } 
public function submit ( ? string $ value = null , array $ options = [ ] ) : Htmlable { return $ this - > input ( 'submit ' , null , $ value , $ options ) ; } 
public function button ( ? string $ value = null , array $ options = [ ] , bool $ escape = true ) : Htmlable { if ( ! \ array _key _exists ( 'type ' , $ options ) ) { $ options [ 'type ' ] = 'button ' ; } if ( $ escape ) { $ value = $ this - > html - > entities ( $ value ) ; } return $ this - > to Html String ( ' <button ' . $ this - > html - > attributes ( $ options ) . ' > ' . $ value . ' < /button > ' ) ; } 
public function get Value Attribute ( ? string $ name , $ value = null ) { if ( \ is _null ( $ name ) ) { return $ value ; } if ( ! \ is _null ( $ old = $ this - > old ( $ name ) ) & & $ name ! = = ' _method ' ) { return $ old ; } if ( \ class _exists ( Kernel : : class , false ) ) { $ has Null Middleware = \ app ( Kernel : : class ) - > has Middleware ( Convert Empty Strings To Null : : class ) ; if ( $ has Null Middleware & & \ is _null ( $ old ) & & \ is _null ( $ value ) & & ! \ is _null ( $ this - > view - > shared ( 'errors ' ) ) & & \ count ( $ this - > view - > shared ( 'errors ' ) ) > 0 ) { return null ; } } if ( ! \ is _null ( $ request = $ this - > request ( $ name ) ) & & $ name ! = = ' _method ' ) { return $ request ; } if ( ! \ is _null ( $ value ) ) { return $ value ; } if ( isset ( $ this - > model ) ) { return $ this - > get Model Value Attribute ( $ name ) ; } } 
protected function request ( string $ name ) { if ( ! $ this - > consider Request | | ! isset ( $ this - > request ) ) { return null ; } return $ this - > request - > input ( $ this - > transform Key ( $ name ) ) ; } 
public function entities ( $ value , bool $ encoding = false ) : string { if ( $ value instanceof Htmlable ) { return $ value - > to Html ( ) ; } return \ htmlentities ( $ value , ENT _QUOTES , 'UTF - 8 ' , $ encoding ) ; } 
public function script ( string $ url , array $ attributes = [ ] , ? bool $ secure = null ) : Htmlable { $ attributes [ 'src ' ] = $ this - > url - > asset ( $ url , $ secure ) ; return $ this - > to Html String ( ' <script ' . $ this - > attributes ( $ attributes ) . ' > < /script > ' ) ; } 
public function style ( string $ url , array $ attributes = [ ] , ? bool $ secure = null ) : Htmlable { $ defaults = [ 'media ' = > 'all ' , 'type ' = > 'text /css ' , 'rel ' = > 'stylesheet ' ] ; $ attributes = \ array _merge ( $ defaults , $ attributes ) ; $ attributes [ 'href ' ] = $ this - > url - > asset ( $ url , $ secure ) ; return $ this - > to Html String ( ' <link ' . $ this - > attributes ( $ attributes ) . ' > ' ) ; } 
public function image ( string $ url , ? string $ alt = null , array $ attributes = [ ] , ? bool $ secure = null ) : Htmlable { $ attributes [ 'alt ' ] = $ alt ; return $ this - > to Html String ( ' <img src = " ' . $ this - > url - > asset ( $ url , $ secure ) . ' " ' . $ this - > attributes ( $ attributes ) . ' > ' ) ; } 
public function link Asset ( string $ url , ? string $ title = null , array $ attributes = [ ] , ? bool $ secure = null ) : Htmlable { $ url = $ this - > url - > asset ( $ url , $ secure ) ; return $ this - > link ( $ url , $ title ? : $ url , $ attributes , $ secure ) ; } 
public function link Route ( string $ name , ? string $ title = null , array $ parameters = [ ] , array $ attributes = [ ] ) : Htmlable { return $ this - > link ( $ this - > url - > route ( $ name , $ parameters ) , $ title , $ attributes ) ; } 
public function mailto ( string $ email , ? string $ title = null , array $ attributes = [ ] , bool $ escape = true ) : Htmlable { $ email = $ this - > email ( $ email ) ; $ title = $ title ? : $ email ; if ( $ escape ) { $ title = $ this - > entities ( $ title ) ; } $ email = $ this - > obfuscate ( 'mailto : ' ) . $ email ; return $ this - > to Html String ( ' <a href = " ' . $ email . ' " ' . $ this - > attributes ( $ attributes ) . ' > ' . $ title . ' < /a > ' ) ; } 
public function dl ( array $ list , array $ attributes = [ ] ) : Htmlable { $ attributes = $ this - > attributes ( $ attributes ) ; $ html = " <dl { $attributes } > " ; foreach ( $ list as $ key = > $ value ) { $ html . = " <dt > { $key } < /dt > " ; foreach ( ( array ) $ value as $ description ) { $ html . = " <dd > { $description } < /dd > " ; } } $ html . = ' < /dl > ' ; return $ this - > to Html String ( $ html ) ; } 
protected function listing Element ( $ key , string $ type , $ value ) : string { if ( \ is _array ( $ value ) ) { return $ this - > nested Listing ( $ key , $ type , $ value ) ; } else { return ' <li > ' . $ this - > entities ( $ value ) . ' < /li > ' ; } } 
public function attributes ( array $ attributes ) : string { $ html = [ ] ; 
protected function attribute Element ( $ key , $ value ) { 
public function meta ( ? string $ name , $ content , array $ attributes = [ ] ) : Htmlable { $ attributes = \ array _merge ( \ compact ( 'name ' , 'content ' ) , $ attributes ) ; return $ this - > to Html String ( ' <meta ' . $ this - > attributes ( $ attributes ) . ' > ' ) ; } 
protected function register Html Builder ( ) : void { $ this - > app - > singleton ( 'html ' , function ( $ app ) { return new Html Builder ( $ app - > make ( 'url ' ) , $ app - > make ( 'view ' ) ) ; } ) ; } 
protected function register Form Builder ( ) : void { $ this - > app - > singleton ( 'form ' , function ( $ app ) { return ( new Form Builder ( $ app - > make ( 'html ' ) , $ app - > make ( 'url ' ) , $ app - > make ( 'view ' ) , $ app - > make ( 'request ' ) ) ) - > set Session Store ( $ app - > make ( 'session .store ' ) ) ; } ) ; } 
public function checkbox ( string $ name , $ value = 1 , ? bool $ checked = null , array $ options = [ ] ) : Htmlable { return $ this - > checkable ( 'checkbox ' , $ name , $ value , $ checked , $ options ) ; } 
public function radio ( string $ name , $ value = null , ? bool $ checked = null , array $ options = [ ] ) : Htmlable { \ is _null ( $ value ) & & $ value = $ name ; return $ this - > checkable ( 'radio ' , $ name , $ value , $ checked , $ options ) ; } 
protected function checkable ( string $ type , string $ name , $ value , ? bool $ checked , array $ options ) : Htmlable { $ this - > type = $ type ; $ checked = $ this - > get Checked State ( $ type , $ name , $ value , $ checked ) ; $ checked & & $ options [ 'checked ' ] = 'checked ' ; return $ this - > input ( $ type , $ name , $ value , $ options ) ; } 
public function old ( string $ name ) { if ( ! isset ( $ this - > session ) ) { return null ; } $ key = $ this - > transform Key ( $ name ) ; $ payload = $ this - > session - > get Old Input ( $ key ) ; if ( ! \ is _array ( $ payload ) ) { return $ payload ; } if ( ! \ in _array ( $ this - > type , [ 'select ' , 'checkbox ' ] ) ) { if ( ! isset ( $ this - > payload [ $ key ] ) ) { $ this - > payload [ $ key ] = Collection : : make ( $ payload ) ; } if ( ! empty ( $ this - > payload [ $ key ] ) ) { $ value = $ this - > payload [ $ key ] - > shift ( ) ; return $ value ; } } return $ payload ; } 
public function search ( string $ name , ? string $ value = null , array $ options = [ ] ) : Htmlable { return $ this - > input ( 'search ' , $ name , $ value , $ options ) ; } 
public function datetime ( string $ name , $ value = null , array $ options = [ ] ) : Htmlable { if ( $ value instanceof Date Time ) { $ value = $ value - > format ( Date Time : : RFC 3 3 3 9 ) ; } return $ this - > input ( 'datetime ' , $ name , $ value , $ options ) ; } 
public function file ( string $ name , array $ options = [ ] ) : Htmlable { return $ this - > input ( 'file ' , $ name , null , $ options ) ; } 
public function up ( ) { Schema : : create ( 'cas _proxy _granting _tickets ' , function ( Blueprint $ table ) { $ table - > charset = 'utf 8 ' ; $ table - > collation = 'utf 8 _general _ci ' ; $ table - > increments ( 'id ' ) ; $ table - > string ( 'ticket ' , 2 5 6 ) - > unique ( ) ; $ table - > string ( 'pgt _url ' , 1 0 2 4 ) ; $ table - > integer ( 'service _id ' ) - > unsigned ( ) ; $ table - > integer ( 'user _id ' ) - > unsigned ( ) ; $ table - > text ( 'proxies ' ) - > nullable ( ) ; $ table - > timestamp ( 'created _at ' ) - > nullable ( ) ; $ table - > timestamp ( 'expire _at ' ) - > nullable ( ) ; $ table - > foreign ( 'service _id ' ) - > references ( 'id ' ) - > on ( 'cas _services ' ) ; $ table - > foreign ( 'user _id ' ) - > references ( config ( 'cas .user _table .id ' ) ) - > on ( config ( 'cas .user _table .name ' ) ) ; } ) ; } 
protected function remove Xml First Line ( $ str ) { $ first = ' < ?xml version = " 1 . 0 " ? > ' ; if ( Str : : starts With ( $ str , $ first ) ) { return trim ( substr ( $ str , strlen ( $ first ) ) ) ; } return $ str ; } 
public function up ( ) { Schema : : create ( 'cas _service _hosts ' , function ( Blueprint $ table ) { $ table - > increments ( 'id ' ) ; $ table - > string ( 'host ' ) - > charset ( 'utf 8 ' ) - > collate ( 'utf 8 _general _ci ' ) - > unique ( ) ; $ table - > integer ( 'service _id ' ) - > unsigned ( ) ; $ table - > foreign ( 'service _id ' ) - > references ( 'id ' ) - > on ( 'cas _services ' ) ; } ) ; } 
public function up ( ) { Schema : : create ( 'cas _services ' , function ( Blueprint $ table ) { $ table - > increments ( 'id ' ) ; $ table - > string ( 'name ' ) - > charset ( 'utf 8 ' ) - > collate ( 'utf 8 _general _ci ' ) - > unique ( ) ; $ table - > boolean ( 'allow _proxy ' ) - > default ( false ) ; $ table - > boolean ( 'enabled ' ) - > default ( true ) ; $ table - > timestamps ( ) ; } ) ; } 
private function tokenize ( $ input ) { $ tokens = array ( ) ; $ splits = preg _split ( " / ( [ " . implode ( " " , $ this - > whitespaces ) . " ] + ) /u " , $ input , - 1 , PREG _SPLIT _DELIM _CAPTURE ) ; foreach ( $ splits as $ split ) { if ( $ split = = = ' ' ) { $ tokens [ ] = new Empty Token ( $ split ) ; continue ; } if ( preg _match ( " / ^ [ " . implode ( " " , $ this - > whitespaces ) . " ] + $ /um " , $ split ) ) { $ tokens [ ] = new Whitespace Token ( $ split ) ; continue ; } $ tokens [ ] = new Word Token ( $ split ) ; } return $ tokens ; } 
public function run ( t \ Token Registry $ tokens ) { foreach ( $ tokens as $ token ) { if ( ! $ token instanceof t \ Word Token ) { continue ; } $ string = $ token - > get Filtered Content ( ) ; $ pattern = $ token - > get Merged Pattern ( $ this - > options - > get Quality ( ) ) ; $ length = $ token - > length ( ) ; $ last One = 0 ; $ result = array ( ) ; for ( $ i = 1 ; $ i < = $ length ; $ i + + ) { $ curr Pattern = mb _substr ( $ pattern , $ i , 1 ) ; if ( $ i < $ this - > options - > get Left Min ( ) ) { continue ; } if ( $ i > ( $ length - $ this - > options - > get Right Min ( ) ) ) { continue ; } if ( 0 = = $ curr Pattern ) { continue ; } if ( 0 = = = ( int ) $ curr Pattern % 2 ) { continue ; } $ sylable = mb _substr ( $ string , $ last One , $ i - $ last One ) ; $ last One = $ i ; $ result [ ] = $ sylable ; } $ result [ ] = mb _substr ( $ string , $ last One ) ; $ token - > set Filtered Content ( implode ( $ this - > options - > get Hyphen ( ) , $ result ) ) ; } return $ tokens ; } 
protected function do Concatenate ( t \ Token Registry $ tokens ) { $ string = ' ' ; foreach ( $ tokens as $ token ) { $ string . = $ token - > get Filtered Content ( ) ; } return $ string ; } 
public function load ( $ locale ) { $ locale = $ this - > unify Locale ( $ locale ) ; $ file = self : : $ file Location . DIRECTORY _SEPARATOR . $ locale . ' .ini ' ; $ this - > dictionary = array ( ) ; if ( ! file _exists ( realpath ( $ file ) ) ) { return $ this ; } foreach ( parse _ini _file ( $ file ) as $ key = > $ val ) { $ this - > dictionary [ str _replace ( ' @ : ' , ' ' , $ key ) ] = $ val ; } return $ this ; } 
public static function parse File ( $ locale ) { $ path = self : : $ file Location . DIRECTORY _SEPARATOR ; $ file = $ path . 'hyph _ ' . $ locale . ' .dic ' ; if ( ! file _Exists ( $ file ) ) { throw new \ Org \ Heigl \ Hyphenator \ Exception \ Path Not Found Exception ( 'The given Path does not exist ' ) ; } $ items = file ( $ file ) ; $ source = trim ( $ items [ 0 ] ) ; if ( 0 = = = strpos ( $ source , 'ISO 8 8 5 9 ' ) ) { $ source = str _Replace ( 'ISO 8 8 5 9 ' , 'ISO - 8 8 5 9 ' , $ source ) ; } unset ( $ items [ 0 ] ) ; $ fh = fopen ( $ path . $ locale . ' .ini ' , 'w + ' ) ; foreach ( $ items as $ item ) { 
public function get Patterns For Word ( $ word ) { $ return = array ( ) ; $ word = ' . ' . $ word . ' . ' ; $ strlen = mb _strlen ( $ word ) ; for ( $ i = 0 ; $ i < = $ strlen ; $ i + + ) { for ( $ j = 2 ; $ j < = ( $ strlen - $ i ) ; $ j + + ) { $ substr = mb _substr ( $ word , $ i , $ j ) ; if ( ! isset ( $ this - > dictionary [ $ substr ] ) ) { continue ; } $ return [ $ substr ] = $ this - > dictionary [ $ substr ] ; } } return $ return ; } 
private function unify Locale ( $ locale ) { if ( 2 = = strlen ( $ locale ) ) { return strtolower ( $ locale ) ; } if ( preg _match ( ' / ( [a -z A -Z ] { 2 } ) [ ^a -z A -Z ] + ( [a -z A -Z ] { 2 } ) /i ' , $ locale , $ result ) ) { return strtolower ( $ result [ 1 ] ) . ' _ ' . strtoupper ( $ result [ 2 ] ) ; } return ( string ) $ locale ; } 
public function add ( Tokenizer $ tokenizer ) { if ( ! in _array ( $ tokenizer , $ this - > registry ) ) { $ this - > registry [ ] = $ tokenizer ; } return $ this ; } 
public function get Tokenizer With Key ( $ key ) { if ( array _key _exists ( $ key , $ this - > registry ) ) { return $ this - > registry [ $ key ] ; } return null ; } 
public function tokenize ( $ string ) { if ( ! $ string instanceof Token Registry ) { $ wt = new Word Token ( $ string ) ; $ string = new Token Registry ( ) ; $ string - > add ( $ wt ) ; } foreach ( $ this as $ tokenizer ) { $ string = $ tokenizer - > run ( $ string ) ; } return $ string ; } 
private function tokenize ( $ input ) { $ tokens = array ( ) ; $ splits = preg _split ( " / ( < \ / ? [ ^ > ] + \ / ? > ) /u " , $ input , - 1 , PREG _SPLIT _DELIM _CAPTURE ) ; foreach ( $ splits as $ split ) { if ( ! $ split ) { continue ; } if ( 0 = = = mb _strpos ( $ split , ' < ' ) ) { $ tokens [ ] = new Non Word Token ( $ split ) ; continue ; } $ tokens [ ] = new Word Token ( $ split ) ; } return $ tokens ; } 
public function run ( $ input ) { if ( $ input instanceof Token Registry ) { 
private function tokenize ( $ input ) { $ tokens = [ ] ; $ splits = preg _split ( sprintf ( ' / ( ( ? : ( ? < = \W ) % 1 $s | \b \w + % 2 $s ) \w + ? \b ) /u ' , $ this - > options - > get No Hyphenate String ( ) , $ this - > options - > get Custom Hyphen ( ) ) , $ input , - 1 , PREG _SPLIT _DELIM _CAPTURE ) ; foreach ( $ splits as $ split ) { if ( ' ' = = $ split ) { continue ; } if ( 0 = = = mb _strpos ( $ split , $ this - > options - > get No Hyphenate String ( ) ) ) { $ tokens [ ] = new Excluded Word Token ( str _replace ( $ this - > options - > get No Hyphenate String ( ) , ' ' , $ split ) ) ; continue ; } if ( false ! = = mb _strpos ( $ split , $ this - > options - > get Custom Hyphen ( ) ) ) { $ tokens [ ] = new Excluded Word Token ( str _replace ( $ this - > options - > get Custom Hyphen ( ) , $ this - > options - > get Hyphen ( ) , $ split ) ) ; continue ; } $ tokens [ ] = new Word Token ( $ split ) ; } return $ tokens ; } 
public function set Options ( \ Org \ Heigl \ Hyphenator \ Options $ options ) { $ this - > options = $ options ; return $ this ; } 
public function add ( Dictionary $ dict ) { if ( ! in _array ( $ dict , $ this - > registry ) ) { $ this - > registry [ ] = $ dict ; } return $ this ; } 
public function get Dictionary With Key ( $ key ) { if ( array _key _exists ( $ key , $ this - > registry ) ) { return $ this - > registry [ $ key ] ; } return null ; } 
public function get Hyphenation Pattterns ( $ word ) { $ pattern = array ( ) ; foreach ( $ this as $ dictionary ) { $ pattern = array _merge ( $ pattern , $ dictionary - > get Patterns For Word ( $ word ) ) ; } return $ pattern ; } 
public function set Filters ( $ filters ) { $ this - > filters = array ( ) ; if ( ! is _array ( $ filters ) ) { $ filters = explode ( ' , ' , $ filters ) ; } foreach ( $ filters as $ filter ) { $ this - > add Filter ( $ filter ) ; } return $ this ; } 
public function add Filter ( $ filter ) { if ( is _string ( $ filter ) ) { $ filter = trim ( $ filter ) ; } elseif ( ! $ filter instanceof Filter ) { throw new \ Unexpected Value Exception ( 'Expceted instanceof Org \Heigl \Hyphenator \Filter \Filter or string ' ) ; } if ( ! $ filter ) { return $ this ; } $ this - > filters [ ] = $ filter ; return $ this ; } 
public function set Tokenizers ( $ tokenizers ) { $ this - > tokenizers = array ( ) ; if ( ! is _array ( $ tokenizers ) ) { $ tokenizers = explode ( ' , ' , $ tokenizers ) ; } foreach ( $ tokenizers as $ tokenizer ) { $ this - > add Tokenizer ( $ tokenizer ) ; } return $ this ; } 
public function add Tokenizer ( $ tokenizer ) { if ( is _string ( $ tokenizer ) ) { $ tokenizer = trim ( $ tokenizer ) ; } elseif ( ! $ tokenizer instanceof Tokenizer ) { throw new \ Unexpected Value Exception ( 'Expceted instanceof Org \Heigl \Hyphenator \Tokenizer \Tokenizer or string ' ) ; } if ( ! $ tokenizer ) { return $ this ; } $ this - > tokenizers [ ] = $ tokenizer ; return $ this ; } 
public static function factory ( $ file ) { if ( ! file _Exists ( $ file ) ) { $ file = $ file . ' .dist ' ; if ( ! file _exists ( $ file ) ) { throw new \ Org \ Heigl \ Hyphenator \ Exception \ Path Not Found Exception ( $ file ) ; } } $ params = parse _ini _file ( $ file ) ; if ( ! is _array ( $ params ) | | 1 > count ( $ params ) ) { throw new \ Org \ Heigl \ Hyphenator \ Exception \ Invalid Argument Exception ( $ file . ' is not a parseable file ' ) ; } $ option = new Options ( ) ; foreach ( $ params as $ key = > $ val ) { if ( ! method _Exists ( $ option , 'set ' . $ key ) ) { continue ; } call _user _Func ( array ( $ option , 'set ' . $ key ) , $ val ) ; } return $ option ; } 
public function set Pattern ( $ pattern ) { $ item = trim ( $ pattern ) ; $ strlen = mb _strlen ( $ item ) ; $ return = array ( ) ; for ( $ i = 0 ; $ i < $ strlen ; $ i + + ) { if ( ( ( $ i ) < = $ strlen ) & & preg _match ( ' / [ 0 - 9 ] /u ' , mb _substr ( $ item , $ i , 1 ) ) ) { $ this - > pattern . = mb _substr ( $ item , $ i , 1 ) ; $ i + + ; } else { $ this - > pattern . = ' 0 ' ; } } $ this - > text = preg _replace ( array ( ' / [ 0 - 9 ] /u ' , ' / \ ' /u ' ) , array ( ' ' , ' \ \ ’ ' ) , $ t em ) ; if ( strlen ( $ this - > pattern ) = = mb _strlen ( $ this - > text ) ) { $ this - > pattern . = ' 0 ' ; } return $ this ; } 
public function get Text ( ) { if ( ! $ this - > text ) { throw new \ Org \ Heigl \ Hyphenator \ Exception \ No Pattern Set Exception ( 'No Pattern set ' ) ; } return $ this - > text ; } 
public function get Pattern ( ) { if ( ! $ this - > pattern ) { throw new \ Org \ Heigl \ Hyphenator \ Exception \ No Pattern Set Exception ( 'No Pattern set ' ) ; } return $ this - > pattern ; } 
public function set Options ( Options $ options ) { $ this - > options = $ options ; $ this - > tokenizers - > cleanup ( ) ; foreach ( $ this - > options - > get Tokenizers ( ) as $ tokenizer ) { $ this - > add Tokenizer ( $ tokenizer ) ; } return $ this ; } 
public function get Options ( ) { if ( null = = = $ this - > options ) { $ opt File = $ this - > get Home Path ( ) . DIRECTORY _SEPARATOR . 'Hyphenator .properties ' ; $ this - > set Options ( Options : : factory ( $ opt File ) ) ; } return $ this - > options ; } 
public function add Dictionary ( $ dictionary ) { if ( ! $ dictionary instanceof \ Org \ Heigl \ Hyphenator \ Dictionary \ Dictionary ) { \ Org \ Heigl \ Hyphenator \ Dictionary \ Dictionary : : set File Location ( $ this - > get Home Path ( ) . ' /files /dictionaries ' ) ; $ dictionary = \ Org \ Heigl \ Hyphenator \ Dictionary \ Dictionary : : factory ( $ dictionary ) ; } $ this - > dicts - > add ( $ dictionary ) ; return $ this ; } 
public function add Filter ( $ filter ) { if ( ! $ filter instanceof \ Org \ Heigl \ Hyphenator \ Filter \ Filter ) { $ filter = ' \ \Org \ \Heigl \ \Hyphenator \ \Filter \ \ ' . ucfirst ( $ filter ) . 'Filter ' ; $ filter = new $ filter ( ) ; } $ filter - > set Options ( $ this - > get Options ( ) ) ; $ this - > filters - > add ( $ filter ) ; return $ this ; } 
public function add Tokenizer ( $ tokenizer ) { if ( ! $ tokenizer instanceof \ Org \ Heigl \ Hyphenator \ Tokenizer \ Tokenizer ) { $ tokenizer = ' \ \Org \ \Heigl \Hyphenator \ \Tokenizer \ \ ' . ucfirst ( $ tokenizer ) . 'Tokenizer ' ; $ tokenizer = new $ tokenizer ( ) ; } $ this - > tokenizers - > add ( $ tokenizer ) ; return $ this ; } 
public function get Tokenizers ( ) { if ( 0 = = $ this - > tokenizers - > count ( ) ) { foreach ( $ this - > get Options ( ) - > get Tokenizers ( ) as $ tokenizer ) { $ this - > add Tokenizer ( $ tokenizer ) ; } } return $ this - > tokenizers ; } 
public function get Dictionaries ( ) { if ( 0 = = $ this - > dicts - > count ( ) ) { $ this - > add Dictionary ( $ this - > get Options ( ) - > get Default Locale ( ) ) ; } return $ this - > dicts ; } 
public function get Filters ( ) { if ( 0 = = $ this - > filters - > count ( ) ) { foreach ( $ this - > get Options ( ) - > get Filters ( ) as $ filter ) { $ this - > add Filter ( $ filter ) ; } } return $ this - > filters ; } 
public function hyphenate ( $ string ) { $ tokens = $ this - > tokenizers - > tokenize ( $ string ) ; $ tokens = $ this - > get Hyphenation Pattern ( $ tokens ) ; $ tokens = $ this - > filter ( $ tokens ) ; if ( 1 = = = count ( $ tokens ) & & 1 = = = $ this - > get Filters ( ) - > count ( ) ) { $ tokens - > rewind ( ) ; return $ tokens - > current ( ) - > get Hyphenated Content ( ) ; } return $ this - > get Filters ( ) - > concatenate ( $ tokens ) ; } 
public function get Hyphenation Pattern ( Tokenizer \ Token Registry $ registry ) { $ min Word Length = $ this - > get Options ( ) - > get Min Word Length ( ) ; foreach ( $ registry as $ token ) { if ( ! $ token instanceof \ Org \ Heigl \ Hyphenator \ Tokenizer \ Word Token ) { continue ; } if ( $ min Word Length > $ token - > length ( ) ) { continue ; } $ this - > get Pattern For Token ( $ token ) ; } return $ registry ; } 
public function get Pattern For Token ( Tokenizer \ Word Token $ token ) { foreach ( $ this - > get Dictionaries ( ) as $ dictionary ) { $ token - > add Pattern ( $ dictionary - > get Patterns For Word ( $ token - > get ( ) ) ) ; } return $ token ; } 
public static function set Default Home Path ( $ home Path ) { if ( ! file _exists ( $ home Path ) ) { throw new Exception \ Path Not Found Exception ( $ home Path . ' does not exist ' ) ; } if ( ! is _Dir ( $ home Path ) ) { throw new Exception \ Path Not Dir Exception ( $ home Path . ' is not a directory ' ) ; } self : : $ default Home Path = realpath ( $ home Path ) ; } 
public static function get Default Home Path ( ) { if ( is _Dir ( self : : $ default Home Path ) ) { return self : : $ default Home Path ; } if ( defined ( 'HYPHENATOR _HOME ' ) & & is _Dir ( HYPHENATOR _HOME ) ) { return realpath ( HYPHENATOR _HOME ) ; } if ( $ home = getenv ( 'HYPHENATOR _HOME ' ) ) { if ( is _Dir ( $ home ) ) { return $ home ; } } return _ _DIR _ _ . ' /share ' ; } 
public function set Home Path ( $ home Path ) { if ( ! file _exists ( $ home Path ) ) { throw new Exception \ Path Not Found Exception ( $ home Path . ' does not exist ' ) ; } if ( ! is _Dir ( $ home Path ) ) { throw new Exception \ Path Not Dir Exception ( $ home Path . ' is not a directory ' ) ; } $ this - > home Path = realpath ( $ home Path ) ; return $ this ; } 
public static function factory ( $ path = null , $ locale = null ) { $ hyphenator = new Hyphenator ( ) ; if ( null ! = = $ path & & file _Exists ( $ path ) ) { $ hyphenator - > set Home Path ( $ path ) ; } if ( null ! = = $ locale ) { $ hyphenator - > get Options ( ) - > set Default Locale ( $ locale ) ; } return $ hyphenator ; } 
public static function _ _autoload ( $ class Name ) { if ( 0 ! = = strpos ( $ class Name , 'Org \ \Heigl \ \Hyphenator ' ) ) { return false ; } $ class Name = substr ( $ class Name , strlen ( 'Org \ \Heigl \ \Hyphenator \ \ ' ) ) ; $ file = str _replace ( ' \ \ ' , ' / ' , $ class Name ) . ' .php ' ; $ file Name = _ _DIR _ _ . DIRECTORY _SEPARATOR . $ file ; if ( ! file _exists ( realpath ( $ file Name ) ) ) { return false ; } if ( ! @ include _once $ file Name ) { return false ; } return true ; } 
public function replace ( Token $ old Token , array $ new Tokens ) { 
public function get Token With Key ( $ key ) { if ( array _key _exists ( $ key , $ this - > registry ) ) { return $ this - > registry [ $ key ] ; } return null ; } 
public function run ( t \ Token Registry $ tokens ) { foreach ( $ tokens as $ token ) { if ( ! $ token instanceof t \ Word Token ) { continue ; } $ string = $ token - > get Filtered Content ( ) ; $ pattern = $ token - > get Merged Pattern ( $ this - > options - > get Quality ( ) ) ; $ length = $ token - > length ( ) ; $ result = array ( ) ; for ( $ i = 1 ; $ i < = $ length ; $ i + + ) { $ curr Pattern = mb _substr ( $ pattern , $ i , 1 ) ; if ( $ i < $ this - > options - > get Left Min ( ) ) { continue ; } if ( $ i > $ length - $ this - > options - > get Right Min ( ) ) { continue ; } if ( 0 = = $ curr Pattern ) { continue ; } if ( 0 = = = ( int ) $ curr Pattern % 2 ) { continue ; } $ start = mb _substr ( $ string , 0 , $ i ) ; $ end = mb _substr ( $ string , $ i ) ; $ result [ ] = $ start . $ this - > options - > get Hyphen ( ) . $ end ; } $ token - > set Hyphenated Content ( $ result ) ; } return $ tokens ; } 
public function get Merged Pattern ( $ quality = \ Org \ Heigl \ Hyphenator \ Hyphenator : : QUALITY _HIGHEST ) { $ content = $ this - > get Hyphenate Content ( ) ; $ end Pattern = str _repeat ( ' 0 ' , mb _strlen ( $ content ) + 1 ) ; foreach ( $ this - > pattern as $ string = > $ pattern ) { $ str Start = - 1 ; while ( false ! = = $ str Start = @ mb _strpos ( $ content , $ string , $ str Start + 1 ) ) { $ str Len = mb _strlen ( $ string ) ; for ( $ i = 0 ; $ i < = $ str Len ; $ i + + ) { $ start = $ i + $ str Start ; $ current Quality = substr ( $ end Pattern , $ start , 1 ) ; $ pattern Quality = substr ( $ pattern , $ i , 1 ) ; if ( $ current Quality > = $ pattern Quality ) { continue ; } if ( $ quality < $ pattern Quality ) { continue ; } $ end Pattern = substr ( $ end Pattern , 0 , $ start ) . $ pattern Quality . substr ( $ end Pattern , $ start + 1 ) ; } } } return substr ( $ end Pattern , 1 , strlen ( $ end Pattern ) - 2 ) ; } 
public function add ( Filter $ filter ) { if ( ! in _array ( $ filter , $ this - > registry ) ) { $ this - > registry [ ] = $ filter ; } return $ this ; } 
public function get Filter With Key ( $ key ) { if ( array _key _exists ( $ key , $ this - > registry ) ) { return $ this - > registry [ $ key ] ; } return null ; } 
public function filter ( \ Org \ Heigl \ Hyphenator \ Tokenizer \ Token Registry $ tokens ) { foreach ( $ this as $ filter ) { $ tokens = $ filter - > run ( $ tokens ) ; } return $ tokens ; } 
private function tokenize ( $ input ) { $ tokens = array ( ) ; $ signs = ' \ \ ' . implode ( ' \ \ ' , $ this - > tokens ) ; $ splits = preg _split ( ' / ( [ ' . $ signs . ' ] + ) /u ' , $ input , - 1 , PREG _SPLIT _DELIM _CAPTURE ) ; foreach ( $ splits as $ split ) { if ( ' ' = = $ split ) { continue ; } if ( in _array ( mb _substr ( $ split , 0 , 1 ) , $ this - > tokens ) ) { $ tokens [ ] = new Non Word Token ( $ split ) ; continue ; } $ tokens [ ] = new Word Token ( $ split ) ; } return $ tokens ; } 
public function fetch Token ( $ authorization Code ) { $ additional Params = [ 'code ' = > $ authorization Code , 'redirect _uri ' = > $ this - > configuration - > get Redirect Url ( ) , ] ; $ response = parent : : fetch Access Token ( 'authentication /v 1 /gettoken ' , 'authorization _code ' , $ additional Params ) ; $ this - > save Refresh Token ( $ response ) ; } 
public function migrate Orders ( ) { $ start = $ count = 0 ; $ batch = Order : : get ( ) - > sort ( 'Created ' , 'ASC ' ) - > limit ( $ start , self : : $ batch _size ) ; while ( $ batch - > exists ( ) ) { foreach ( $ batch as $ order ) { $ this - > migrate ( $ order ) ; echo ' . ' ; $ count + + ; } $ start + = self : : $ batch _size ; $ batch = $ batch - > limit ( $ start , self : : $ batch _size ) ; } ; echo " $count orders updated . \n <br / > " ; } 
public function migrate ( Order $ order ) { 
public function migrate Member Fields ( $ order ) { if ( $ member = $ order - > Member ( ) ) { $ fieldstocopy = array ( 'First Name ' , 'Surname ' , 'Email ' , 'Address ' , 'Address Line 2 ' , 'City ' , 'Country ' , 'Home Phone ' , 'Mobile Phone ' , 'Notes ' , ) ; foreach ( $ fieldstocopy as $ field ) { if ( ! $ order - > $ field ) { $ order - > $ field = $ member - > $ field ; } } } } 
public function migrate Shipping Values ( $ order ) { 
public function migrate Order Calculation ( $ order ) { if ( ! is _numeric ( $ order - > Total ) | | $ order - > Total < = 0 ) { $ order - > calculate ( ) ; $ order - > write ( ) ; } } 
public function viaphp ( ) { $ ps = singleton ( Product : : class ) ; $ q = $ ps - > build SQL ( ' "Silver Shop _Product " . "Allow Purchase " = 1 ' ) ; $ select = $ q - > select ; $ select [ 'New Popularity ' ] = self : : config ( ) - > number _sold _calculation _type . ' ( "Silver Shop _Order Item " . "Quantity " ) AS "New Popularity " ' ; $ q - > select ( $ select ) ; $ q - > groupby ( ' "Product " . "ID " ' ) ; $ q - > orderby ( ' "New Popularity " DESC ' ) ; $ q - > left Join ( 'Silver Shop _Product _Order Item ' , ' "Silver Shop _Product " . "ID " = "Silver Shop _Product _Order Item " . "Product ID " ' ) ; $ q - > left Join ( 'Silver Shop _Order Item ' , ' "Silver Shop _Product _Order Item " . "ID " = "Silver Shop _Order Item " . "ID " ' ) ; $ records = $ q - > execute ( ) ; $ productssold = $ ps - > build Data Object Set ( $ records , "Data Object Set " , $ q , Product : : class ) ; 
public function require Default Records ( ) { parent : : require Default Records ( ) ; if ( ! self : : get ( ) - > exists ( ) & & $ this - > config ( ) - > create _default _pages ) { $ page = self : : create ( ) - > update ( [ 'Title ' = > 'Checkout ' , 'URLSegment ' = > Checkout Page Controller : : config ( ) - > url _segment , 'Show In Menus ' = > 0 , ] ) ; $ page - > write ( ) ; $ page - > publish Single ( ) ; $ page - > flush Cache ( ) ; DB : : alteration _message ( 'Checkout page created ' , 'created ' ) ; } } 
public function make Payment ( $ gateway , $ gatewaydata = array ( ) , $ success Url = null , $ cancel Url = null ) { * @var Service Factory $factory * / $ factory = Service Factory : : create ( ) ; $ service = $ factory - > get Service ( $ payment , Service Factory : : INTENT _PAYMENT ) ; 
protected function get Gateway Data ( $ custom Data ) { $ shipping = $ this - > order - > get Shipping Address ( ) ; $ billing = $ this - > order - > get Billing Address ( ) ; $ num Payments = Payment : : get ( ) - > filter ( array ( 'Order ID ' = > $ this - > order - > ID ) ) - > count ( ) - 1 ; $ transaction Id = $ this - > order - > Reference . ( $ num Payments > 0 ? " - $num Payments " : ' ' ) ; return array _merge ( $ custom Data , array ( 'transaction Id ' = > $ transaction Id , 'first Name ' = > $ this - > order - > First Name , 'last Name ' = > $ this - > order - > Surname , 'email ' = > $ this - > order - > Email , 'company ' = > $ this - > order - > Company , 'billing Address 1 ' = > $ billing - > Address , 'billing Address 2 ' = > $ billing - > Address Line 2 , 'billing City ' = > $ billing - > City , 'billing Postcode ' = > $ billing - > Postal Code , 'billing State ' = > $ billing - > State , 'billing Country ' = > $ billing - > Country , 'billing Phone ' = > $ billing - > Phone , 'shipping Address 1 ' = > $ shipping - > Address , 'shipping Address 2 ' = > $ shipping - > Address Line 2 , 'shipping City ' = > $ shipping - > City , 'shipping Postcode ' = > $ shipping - > Postal Code , 'shipping State ' = > $ shipping - > State , 'shipping Country ' = > $ shipping - > Country , 'shipping Phone ' = > $ shipping - > Phone , ) ) ; } 
public function create Payment ( $ gateway ) { if ( ! Gateway Info : : is Supported ( $ gateway ) ) { $ this - > error ( _t ( _ _CLASS _ _ . " .Invalid Gateway " , " ` {gateway } ` isn 't a valid payment gateway . " , 'gateway is the name of the payment gateway ' , array ( 'gateway ' = > $ gateway ) ) ) ; return false ; } if ( ! $ this - > order - > can Pay ( Security : : get Current User ( ) ) ) { $ this - > error ( _t ( _ _CLASS _ _ . " .Cant Pay " , "Order can 't be paid for . " ) ) ; return false ; } $ payment = Payment : : create ( ) - > init ( $ gateway , $ this - > order - > Total Outstanding ( true ) , Shop Config Extension : : config ( ) - > base _currency ) ; $ this - > order - > Payments ( ) - > add ( $ payment ) ; return $ payment ; } 
public function complete Payment ( ) { if ( ! $ this - > order - > Is Paid ( ) ) { 
public function can Place ( Order $ order ) { if ( ! $ order ) { $ this - > error ( _t ( _ _CLASS _ _ . " .No Order " , "Order does not exist . " ) ) ; return false ; } 
public function place Order ( ) { if ( ! $ this - > order ) { $ this - > error ( _t ( _ _CLASS _ _ . " .No Order Started " , "A new order has not yet been started . " ) ) ; return false ; } if ( ! $ this - > can Place ( $ this - > order ) ) { $cart = Shopping Cart : :curr ( ) ; if ( $cart & & $cart - >ID = = $this - >order - >ID ) { } * / 
public function Nice ( ) { $ val = Shop Config Extension : : country Code 2name ( $ this - > value ) ; if ( ! $ val ) { $ val = $ this - > value ; } return _t ( _ _CLASS _ _ . ' . ' . $ this - > value , $ val ) ; } 
public function set Contact Details ( $ email , $ firstname , $ surname ) { $ this - > order - > Email = $ email ; $ this - > order - > First Name = $ firstname ; $ this - > order - > Surname = $ surname ; $ this - > order - > write ( ) ; } 
public function set Shipping Address ( Address $ address ) { $ this - > order - > Shipping Address ID = $ address - > ID ; if ( $ member = Security : : get Current User ( ) ) { $ this - > order - > Member ID = $ member - > ID ; } $ this - > order - > write ( ) ; $ this - > order - > extend ( 'on Set Shipping Address ' , $ address ) ; Shop User Info : : singleton ( ) - > set Address ( $ address ) ; } 
public function set Payment Method ( $ paymentmethod ) { $ methods = Gateway Info : : get Supported Gateways ( ) ; if ( ! isset ( $ methods [ $ paymentmethod ] ) ) { Shop Tools : : get Session ( ) - > set ( 'Checkout .Payment Method ' , null ) - > clear ( 'Checkout .Payment Method ' ) ; return $ this - > error ( _t ( _ _CLASS _ _ . ' .No Payment Method ' , 'Payment method does not exist ' ) ) ; } Shop Tools : : get Session ( ) - > set ( 'Checkout .Payment Method ' , $ paymentmethod ) ; return true ; } 
public function get Selected Payment Method ( $ nice = false ) { $ methods = Gateway Info : : get Supported Gateways ( ) ; reset ( $ methods ) ; $ method = count ( $ methods ) = = = 1 ? key ( $ methods ) : Shop Tools : : get Session ( ) - > get ( 'Checkout .Payment Method ' ) ; if ( $ nice & & isset ( $ methods [ $ method ] ) ) { $ method = $ methods [ $ method ] ; } return $ method ; } 
public function validate Member ( $ member ) { if ( ! Checkout Config : : config ( ) - > membership _required ) { return true ; } if ( empty ( $ member ) | | ! ( $ member instanceof Member ) ) { return false ; } return true ; } 
protected function build Email ( $ template , $ subject ) { $ from = Shop Config Extension : : config ( ) - > email _from ? Shop Config Extension : : config ( ) - > email _from : Email : : config ( ) - > admin _email ; $ to = $ this - > order - > get Latest Email ( ) ; $ checkoutpage = Checkout Page : : get ( ) - > first ( ) ; $ completemessage = $ checkoutpage ? $ checkoutpage - > Purchase Complete : ' ' ; $ email = Email : : create ( ) - > set HTMLTemplate ( $ template ) - > set From ( $ from ) - > set To ( $ to ) - > set Subject ( $ subject ) ; $ email - > set Data ( [ 'Purchase Complete Message ' = > $ completemessage , 'Order ' = > $ this - > order , 'Base URL ' = > Director : : absolute Base URL ( ) , ] ) ; return $ email ; } 
public function send Email ( $ template , $ subject , $ copy To Admin = true ) { $ email = $ this - > build Email ( $ template , $ subject ) ; if ( $ copy To Admin ) { $ email - > set Bcc ( Email : : config ( ) - > admin _email ) ; } if ( $ this - > debug Mode ) { return $ this - > debug ( $ email ) ; } else { return $ email - > send ( ) ; } } 
public function send Confirmation ( ) { $ subject = _t ( 'Silver Shop \Shop Email .Confirmation Subject ' , 'Order # {Order No } confirmation ' , ' ' , array ( 'Order No ' = > $ this - > order - > Reference ) ) ; return $ this - > send Email ( 'Silver Shop /Model /Order _Confirmation Email ' , $ subject , self : : config ( ) - > bcc _confirmation _to _admin ) ; } 
public function send Admin Notification ( ) { $ subject = _t ( 'Silver Shop \Shop Email .Admin Notification Subject ' , 'Order # {Order No } notification ' , ' ' , array ( 'Order No ' = > $ this - > order - > Reference ) ) ; $ email = $ this - > build Email ( 'Silver Shop /Model /Order _Admin Notification Email ' , $ subject ) - > set To ( Email : : config ( ) - > admin _email ) ; if ( $ this - > debug Mode ) { return $ this - > debug ( $ email ) ; } else { return $ email - > send ( ) ; } } 
public function send Receipt ( ) { $ subject = _t ( 'Silver Shop \Shop Email .Receipt Subject ' , 'Order # {Order No } receipt ' , ' ' , array ( 'Order No ' = > $ this - > order - > Reference ) ) ; return $ this - > send Email ( 'Silver Shop /Model /Order _Receipt Email ' , $ subject , self : : config ( ) - > bcc _receipt _to _admin ) ; } 
public function send Cancel Notification ( ) { $ email = Email : : create ( ) - > set Subject ( _t ( 'Silver Shop \Shop Email .Cancel Subject ' , 'Order # {Order No } cancelled by member ' , ' ' , [ 'Order No ' = > $ this - > order - > Reference ] ) ) - > set From ( Email : : config ( ) - > admin _email ) - > set To ( Email : : config ( ) - > admin _email ) - > set Body ( $ this - > order - > render With ( Order : : class ) ) ; if ( $ this - > debug Mode ) { return $ this - > debug ( $ email ) ; } else { return $ email - > send ( ) ; } } 
public function send Status Change ( $ title , $ note = null ) { if ( ! $ note ) { $ latest Log = Order Status Log : : get ( ) - > filter ( "Order ID " , $ this - > order - > ID ) - > filter ( "Sent To Customer " , 1 ) - > first ( ) ; if ( $ latest Log ) { $ note = $ latest Log - > Note ; $ title = $ latest Log - > Title ; } } if ( Config : : inst ( ) - > get ( Order Processor : : class , 'receipt _email ' ) ) { $ admin Email = Config : : inst ( ) - > get ( Order Processor : : class , 'receipt _email ' ) ; } else { $ admin Email = Email : : config ( ) - > admin _email ; } $ email = Email : : create ( ) - > set From ( $ admin Email ) - > set Subject ( _t ( 'Silver Shop \Shop Email .Status Change Subject ' , 'Silver Shop – {Title } ' , [ T itle ' = $ i tle ] ) ) - > set To ( $ this - > order - > get Latest Email ( ) ) - > set HTMLTemplate ( 'Silver Shop /Model /Order _Status Email ' ) - > set Data ( [ 'Order ' = > $ this - > order , 'Note ' = > $ note , 'From Email ' = > $ admin Email ] ) ; if ( $ this - > debug Mode ) { return $ this - > debug ( $ email ) ; } else { return $ email - > send ( ) ; } } 
protected function debug ( Email $ email ) { $ email - > render ( ) ; $ template = $ email - > get HTMLTemplate ( ) ; $ headers = $ email - > get Swift Message ( ) - > get Headers ( ) - > to String ( ) ; return " <h 2 >Email HTML template : $template < /h 2 > \n " . " <pre > $headers < /pre > " . $ email - > get Body ( ) ; } 
protected static function build _url ( $ action , $ buyable , $ params = [ ] ) { if ( ! $ action | | ! $ buyable ) { return false ; } if ( Security Token : : is _enabled ( ) & & ! self : : config ( ) - > disable _security _token ) { $ params [ Security Token : : inst ( ) - > get Name ( ) ] = Security Token : : inst ( ) - > get Value ( ) ; } $ class Name = get _class ( $ buyable ) ; $ link = Controller : : join _links ( [ self : : config ( ) - > url _segment , $ action , Shop Tools : : sanitise Class Name ( $ class Name ) , $ buyable - > ID ] ) ; return empty ( $ params ) ? $ link : $ link . ' ? ' . http _build _query ( $ params ) ; } 
public static function direct ( $ status = true ) { if ( Director : : is _ajax ( ) ) { return ( string ) $ status ; } if ( self : : config ( ) - > direct _to _cart _page & & ( $ cartlink = Cart Page : : find _link ( ) ) ) { return Controller : : curr ( ) - > redirect ( $ cartlink ) ; } else { return Controller : : curr ( ) - > redirect Back ( ) ; } } 
public function removeall ( $ request ) { if ( $ product = $ this - > buyable From Request ( ) ) { $ this - > cart - > remove ( $ product , null , $ request - > get Vars ( ) ) ; } $ this - > update Locale ( $ request ) ; $ this - > extend ( 'update Remove All Response ' , $ request , $ response , $ product ) ; return $ response ? $ response : self : : direct ( ) ; } 
public function setquantity ( $ request ) { $ product = $ this - > buyable From Request ( ) ; $ quantity = ( int ) $ request - > get Var ( 'quantity ' ) ; if ( $ product ) { $ this - > cart - > set Quantity ( $ product , $ quantity , $ request - > get Vars ( ) ) ; } $ this - > update Locale ( $ request ) ; $ this - > extend ( 'update Set Quantity Response ' , $ request , $ response , $ product , $ quantity ) ; return $ response ? $ response : self : : direct ( ) ; } 
public function clear ( $ request ) { $ this - > update Locale ( $ request ) ; $ this - > cart - > clear ( ) ; $ this - > extend ( 'update Clear Response ' , $ request , $ response ) ; return $ response ? $ response : self : : direct ( ) ; } 
public function index ( ) { if ( $ cart = $ this - > Cart ( ) ) { return $ this - > redirect ( $ cart - > Cart Link ) ; } elseif ( $ response = Error Page : : response _for ( 4 0 4 ) ) { return $ response ; } return $ this - > http Error ( 4 0 4 , _t ( 'Silver Shop \Cart \Shopping Cart .No Cart Initialised ' , 'no cart initialised ' ) ) ; } 
public function debug ( ) { if ( Director : : is Dev ( ) | | Permission : : check ( 'ADMIN ' ) ) { 
public function get Filter ( ) { if ( ! is _array ( $ this - > data ) ) { return null ; } $ allowed = array _keys ( Data Object : : get Schema ( ) - > database Fields ( $ this - > class Name ) ) ; $ fields = array _flip ( array _intersect ( $ allowed , $ this - > required ) ) ; $ singleton = singleton ( $ this - > class Name ) ; $ new = [ ] ; foreach ( $ fields as $ field = > $ value ) { $ field = Convert : : raw 2sql ( $ field ) ; if ( in _array ( $ field , $ allowed ) ) { if ( isset ( $ this - > data [ $ field ] ) ) { 
public function submit ( $ data , $ form , $ request ) { $ member = Security : : get Current User ( ) ; if ( ! $ member ) { return false ; } $ form - > save Into ( $ member ) ; $ member - > write ( ) ; $ form - > session Message ( _t ( _ _CLASS _ _ . ' .Details Saved ' , 'Your details have been saved ' ) , 'good ' ) ; $ this - > extend ( 'update Shop Account Form Response ' , $ request , $ form , $ data , $ response ) ; return $ response ? : $ this - > get Controller ( ) - > redirect Back ( ) ; } 
public function proceed ( $ data , $ form , $ request ) { $ member = Security : : get Current User ( ) ; if ( ! $ member ) { return false ; } $ form - > save Into ( $ member ) ; $ member - > write ( ) ; $ form - > session Message ( _t ( _ _CLASS _ _ . ' .Details Saved ' , 'Your details have been saved ' ) , 'good ' ) ; $ this - > extend ( 'update Shop Account Form Response ' , $ request , $ form , $ data , $ response ) ; return $ response ? : $ this - > get Controller ( ) - > redirect ( Checkout Page : : find _link ( ) ) ; } 
public function get Modifier ( $ class Name , $ forcecreate = false ) { if ( ! Class Info : : exists ( $ class Name ) ) { user _error ( "Modifier class \ " $class Name \ " does not exist . " ) ; } 
public function Unit Price ( ) { if ( $ this - > Order ( ) - > Is Cart ( ) ) { $ buyable = $ this - > Buyable ( ) ; $ unitprice = ( $ buyable ) ? $ buyable - > selling Price ( ) : $ this - > Unit Price ; $ this - > extend ( 'update Unit Price ' , $ unitprice ) ; return $ this - > Unit Price = $ unitprice ; } return $ this - > Unit Price ; } 
protected function calculatetotal ( ) { $ total = $ this - > Unit Price ( ) * $ this - > Quantity ; $ this - > extend ( 'update Total ' , $ total ) ; $ this - > Calculated Total = $ total ; return $ total ; } 
public function uniquedata ( ) { $ required = self : : config ( ) - > required _fields ; 
public function on Before Write ( ) { parent : : on Before Write ( ) ; if ( $ this - > Order ID & & $ this - > Order ( ) & & $ this - > Order ( ) - > is Cart ( ) ) { $ this - > calculatetotal ( ) ; } } 
public function Product Variation ( $ forcecurrent = false ) { if ( $ this - > Product Variation ID & & $ this - > Product Variation Version & & ! $ forcecurrent ) { return Versioned : : get _version ( Variation : : class , $ this - > Product Variation ID , $ this - > Product Variation Version ) ; } elseif ( $ this - > Product Variation ID & & $ product = Variation : : get ( ) - > by ID ( $ this - > Product Variation ID ) ) { return $ product ; } return null ; } 
public function set Data ( Order $ order , array $ data ) { $ address = $ this - > get Address ( $ order ) ; 
public function get Required Fields ( ) { $ fields = self : : config ( ) - > required _fields ; 
public function to String ( $ separator = ' , ' ) { $ fields = array ( $ this - > Company , $ this - > get Name ( ) , $ this - > Address , $ this - > Address Line 2 , $ this - > City , $ this - > State , $ this - > Postal Code , $ this - > Country ) ; $ this - > extend ( 'update To String ' , $ fields ) ; return implode ( $ separator , array _filter ( $ fields ) ) ; } 
public function get Address ( ) { $ address = null ; if ( $ data = $ this - > get Location Data ( ) ) { $ address = Address : : create ( ) ; $ address - > update ( $ data ) ; $ address - > ID = 0 ; 
public function Cart Form ( ) { $ cart = $ this - > Cart ( ) ; if ( ! $ cart ) { return false ; } $ form = Cart Form : : create ( $ this , 'Cart Form ' , $ cart ) ; $ this - > extend ( 'update Cart Form ' , $ form ) ; return $ form ; } 
public function value ( $ subtotal = 0 ) { $ total Weight = $ this - > Weight ( ) ; if ( ! $ total Weight ) { return $ this - > Amount = 0 ; } $ amount = 0 ; $ table = $ this - > config ( ) - > weight _cost ; if ( ! empty ( $ table ) & & is _array ( $ table ) ) { 
public function Weight ( ) { if ( $ this - > weight ) { return $ this - > weight ; } $ weight = 0 ; $ order = $ this - > Order ( ) ; if ( $ order & & $ order Items = $ order - > Items ( ) ) { foreach ( $ order Items as $ order Item ) { if ( $ product = $ order Item - > Product ( ) ) { $ weight = $ weight + ( $ product - > Weight * $ order Item - > Quantity ) ; } } } return $ this - > weight = $ weight ; } 
public function addtocart ( $ data , $ form ) { if ( $ variation = $ this - > get Buyable ( $ data ) ) { $ quantity = ( isset ( $ data [ 'Quantity ' ] ) & & is _numeric ( $ data [ 'Quantity ' ] ) ) ? ( int ) $ data [ 'Quantity ' ] : 1 ; $ cart = Shopping Cart : : singleton ( ) ; $ request = $ this - > get Request ( ) ; $ order = $ cart - > current ( ) ; if ( $ request & & $ request - > is Ajax ( ) & & $ order ) { Shop Tools : : install _locale ( $ order - > Locale ) ; } 
public function namespace Data ( array $ data ) { $ newdata = array ( ) ; foreach ( $ data as $ key = > $ value ) { $ newdata [ $ this - > namespace Field Name ( $ key ) ] = $ value ; } return $ newdata ; } 
public function Sum ( $ field , $ onproduct = false ) { $ total = 0 ; foreach ( $ this - > get Iterator ( ) as $ item ) { $ quantity = ( $ field = = = 'Quantity ' ) ? 1 : $ item - > Quantity ; if ( ! $ onproduct ) { $ total + = $ item - > $ field * $ quantity ; } elseif ( $ item - > has Method ( $ field ) ) { $ total + = $ item - > $ field ( ) * $ quantity ; } elseif ( $ product = $ item - > Product ( ) ) { $ total + = $ product - > $ field * $ quantity ; } } return $ total ; } 
public function Sub Total ( ) { $ result = 0 ; foreach ( $ this - > get Iterator ( ) as $ item ) { $ result + = $ item - > Total ( ) ; } return $ result ; } 
public function on Before Write ( ) { parent : : on Before Write ( ) ; if ( isset ( $ _POST [ 'Product Attributes ' ] ) & & is _array ( $ _POST [ 'Product Attributes ' ] ) ) { $ this - > Attribute Values ( ) - > set By IDList ( array _values ( $ _POST [ 'Product Attributes ' ] ) ) ; } $ img = $ this - > Image ( ) ; if ( $ img & & $ img - > exists ( ) ) { $ img - > do Publish ( ) ; } } 
public function Item ( ) { $ filter = array ( ) ; $ this - > extend ( 'update Item Filter ' , $ filter ) ; $ item = Shopping Cart : : singleton ( ) - > get ( $ this , $ filter ) ; if ( ! $ item ) { 
public function Payment Error Message ( ) { $ order = $ this - > Cart ( ) ; if ( ! $ order ) { return false ; } $ last Payment = $ order - > Payments ( ) - > sort ( 'Created ' , 'DESC ' ) - > first ( ) ; if ( ! $ last Payment ) { return false ; } $ error Messages = $ last Payment - > Messages ( ) - > exclude ( 'Message ' , ' ' ) - > sort ( 'Created ' , 'DESC ' ) ; $ last Error Message = null ; foreach ( $ error Messages as $ error Message ) { if ( $ error Message instanceof Gateway Error Message ) { $ last Error Message = $ error Message ; break ; } } if ( ! $ last Error Message ) { return false ; } return $ last Error Message - > Message ; } 
public function get Viewer ( $ action ) { if ( Checkout Page : : config ( ) - > first _step & & $ action = = 'index ' ) { $ action = Checkout Page : : config ( ) - > first _step ; } return parent : : get Viewer ( $ action ) ; } 
public function Product ( $ forcecurrent = false ) { 
public function update CMSFields ( Field List $ fields ) { $ fields - > add Fields To Tab ( 'Root .Variations ' , [ Listbox Field : : create ( 'Variation Attribute Types ' , _t ( _ _CLASS _ _ . ' .Attributes ' , "Attributes " ) , Attribute Type : : get ( ) - > map ( 'ID ' , 'Title ' ) - > to Array ( ) ) - > set Description ( _t ( _ _CLASS _ _ . ' .Attributes Description ' , 'These are fields to indicate the way (s ) each variation varies . Once selected , they can be edited on each variation . ' ) ) , Grid Field : : create ( 'Variations ' , _t ( _ _CLASS _ _ . ' .Variations ' , 'Variations ' ) , $ this - > owner - > Variations ( ) , Grid Field Config _Record Editor : : create ( ) ) ] ) ; if ( $ this - > owner - > Variations ( ) - > exists ( ) ) { $ fields - > add Field To Tab ( 'Root .Pricing ' , Label Field : : create ( 'variationspriceinstructinos ' , _t ( _ _CLASS _ _ . ' .Variations Info ' , 'Price - Because you have one or more variations , the price can be set in the "Variations " tab . ' ) ) ) ; $ fields - > remove Field From Tab ( 'Root .Pricing ' , 'Base Price ' ) ; $ fields - > remove Field From Tab ( 'Root .Main ' , 'Internal Item ID ' ) ; } } 
public function get Variation By Attributes ( array $ attributes ) { if ( ! is _array ( $ attributes ) ) { return null ; } $ attrs = array _filter ( array _values ( $ attributes ) ) ; $ set = Variation : : get ( ) - > filter ( 'Product ID ' , $ this - > owner - > ID ) ; foreach ( $ attrs as $ i = > $ valueid ) { $ alias = "A $i " ; $ set = $ set - > inner Join ( 'Silver Shop _Variation _Attribute Values ' , " \ "Silver Shop _Variation \ " . \ "ID \ " = \ " $alias \ " . \ "Silver Shop _Variation ID \ " " , $ alias ) - > where ( [ " \ " $alias \ " . \ "Silver Shop _Attribute Value ID \ " = ? " = > $ valueid ] ) ; } return $ set - > first ( ) ; } 
public function generate Variations From Attributes ( Attribute Type $ attributetype , array $ values ) { 
public function possible Values For Attribute Type ( $ type ) { if ( ! is _numeric ( $ type ) ) { $ type = $ type - > ID ; } if ( ! $ type ) { return null ; } $ list = Attribute Value : : get ( ) - > inner Join ( 'Silver Shop _Variation _Attribute Values ' , ' "Silver Shop _Attribute Value " . "ID " = "Silver Shop _Variation _Attribute Values " . "Silver Shop _Attribute Value ID " ' ) - > inner Join ( 'Silver Shop _Variation ' , ' "Silver Shop _Variation _Attribute Values " . "Silver Shop _Variation ID " = "Silver Shop _Variation " . "ID " ' ) - > where ( "Type ID = $type AND \ "Silver Shop _Variation \ " . \ "Product ID \ " = " . $ this - > owner - > ID ) ; if ( ! Product : : config ( ) - > allow _zero _price ) { $ list = $ list - > where ( ' "Silver Shop _Variation " . "Price " > 0 ' ) ; } return $ list ; } 
public function on After Delete ( ) { $ remove = false ; 
public function get Image At ( $ width = null , $ height = null , $ upscale = false ) { if ( ! $ this - > owner - > exists ( ) ) { return $ this - > owner ; } $ real Width = $ this - > owner - > get Width ( ) ; $ real Height = $ this - > owner - > get Height ( ) ; if ( $ width & & $ height ) { return $ real Width < $ width & & $ real Height < $ height & & ! $ upscale ? $ this - > owner : $ this - > owner - > Fit ( $ width , $ height ) ; } else { if ( $ width ) { return $ real Width < $ width & & ! $ upscale ? $ this - > owner : $ this - > owner - > Scale Width ( $ width ) ; } else { return $ real Height < $ height & & ! $ upscale ? $ this - > owner : $ this - > owner - > Scale Height ( $ height ) ; } } } 
public function get Component By Type ( $ type ) { foreach ( $ this - > components as $ component ) { if ( $ this - > namespaced ) { if ( $ component - > Proxy ( ) instanceof $ type ) { return $ component - > Proxy ( ) ; } } else { if ( $ component instanceof $ type ) { return $ component ; } } } } 
public function get Form Fields ( ) { $ fields = Field List : : create ( ) ; foreach ( $ this - > get Components ( ) as $ component ) { if ( $ cfields = $ component - > get Form Fields ( $ this - > order ) ) { $ fields - > merge ( $ cfields ) ; } else { user _error ( 'get Fields on ' . get _class ( $ component ) . ' must return a Field List ' ) ; } } return $ fields ; } 
public function validate Data ( $ data ) { $ result = Validation Result : : create ( ) ; foreach ( $ this - > get Components ( ) as $ component ) { try { $ component - > validate Data ( $ this - > order , $ this - > dependant Data ( $ component , $ data ) ) ; } catch ( Validation Exception $ e ) { 
public function get Data ( ) { $ data = array ( ) ; foreach ( $ this - > get Components ( ) as $ component ) { $ orderdata = $ component - > get Data ( $ this - > order ) ; if ( is _array ( $ orderdata ) ) { $ data = array _merge ( $ data , $ orderdata ) ; } else { user _error ( 'get Data on ' . $ component - > name ( ) . ' must return an array ' ) ; } } return $ data ; } 
public function set Data ( $ data ) { foreach ( $ this - > get Components ( ) as $ component ) { $ component - > set Data ( $ this - > order , $ this - > dependant Data ( $ component , $ data ) ) ; } } 
protected function dependant Data ( $ component , $ data ) { if ( ! $ this - > namespaced ) { 
public function current ( ) { $ session = Shop Tools : : get Session ( ) ; 
public function set Current ( Order $ cart ) { if ( ! $ cart - > Is Cart ( ) ) { trigger _error ( 'Passed Order object is not cart status ' , E _ERROR ) ; } $ this - > order = $ cart ; $ session = Shop Tools : : get Session ( ) ; $ session - > set ( self : : config ( ) - > cartid _session _name , $ cart - > ID ) ; return $ this ; } 
protected function find Or Make ( ) { if ( $ this - > current ( ) ) { return $ this - > current ( ) ; } $ this - > order = Order : : create ( ) ; if ( Member : : config ( ) - > login _joins _cart & & ( $ member = Security : : get Current User ( ) ) ) { $ this - > order - > Member ID = $ member - > ID ; } $ this - > order - > write ( ) ; $ this - > order - > extend ( 'on Start Order ' ) ; $ session = Shop Tools : : get Session ( ) ; $ session - > set ( self : : config ( ) - > cartid _session _name , $ this - > order - > ID ) ; return $ this - > order ; } 
public function add ( Buyable $ buyable , $ quantity = 1 , $ filter = [ ] ) { $ order = $ this - > find Or Make ( ) ; 
public function remove ( Buyable $ buyable , $ quantity = null , $ filter = [ ] ) { $ order = $ this - > current ( ) ; if ( ! $ order ) { return $ this - > error ( _t ( _ _CLASS _ _ . ' .No Order ' , 'No current order . ' ) ) ; } 
public function remove Order Item ( Order Item $ item , $ quantity = null ) { $ order = $ this - > current ( ) ; if ( ! $ order ) { return $ this - > error ( _t ( _ _CLASS _ _ . ' .No Order ' , 'No current order . ' ) ) ; } if ( ! $ item | | $ item - > Order ID ! = $ order - > ID ) { return $ this - > error ( _t ( _ _CLASS _ _ . ' .Item Not Found ' , 'Item not found . ' ) ) ; } 
public function set Quantity ( Buyable $ buyable , $ quantity = 1 , $ filter = [ ] ) { if ( $ quantity < = 0 ) { return $ this - > remove ( $ buyable , $ quantity , $ filter ) ; } $ item = $ this - > find Or Make Item ( $ buyable , $ quantity , $ filter ) ; if ( ! $ item | | ! $ this - > update Order Item Quantity ( $ item , $ quantity , $ filter ) ) { return false ; } return $ item ; } 
public function update Order Item Quantity ( Order Item $ item , $ quantity = 1 , $ filter = [ ] ) { $ order = $ this - > current ( ) ; if ( ! $ order ) { return $ this - > error ( _t ( _ _CLASS _ _ . ' .No Order ' , 'No current order . ' ) ) ; } if ( ! $ item | | $ item - > Order ID ! = $ order - > ID ) { return $ this - > error ( _t ( _ _CLASS _ _ . ' .Item Not Found ' , 'Item not found . ' ) ) ; } $ buyable = $ item - > Buyable ( ) ; 
private function find Or Make Item ( Buyable $ buyable , $ quantity = 1 , $ filter = [ ] ) { $ order = $ this - > find Or Make ( ) ; if ( ! $ buyable | | ! $ order ) { return null ; } $ item = $ this - > get ( $ buyable , $ filter ) ; if ( ! $ item ) { $ member = Security : : get Current User ( ) ; $ buyable = $ this - > get Correct Buyable ( $ buyable ) ; if ( ! $ buyable - > can Purchase ( $ member , $ quantity ) ) { return $ this - > error ( _t ( _ _CLASS _ _ . ' .Cannot Purchase ' , 'This {Title } cannot be purchased . ' , ' ' , [ 'Title ' = > $ buyable - > i 1 8n _singular _name ( ) ] ) ) ; 
public function get ( Buyable $ buyable , $ customfilter = array ( ) ) { $ order = $ this - > current ( ) ; if ( ! $ buyable | | ! $ order ) { return null ; } $ buyable = $ this - > get Correct Buyable ( $ buyable ) ; $ filter = array ( 'Order ID ' = > $ order - > ID , ) ; $ itemclass = Config : : inst ( ) - > get ( get _class ( $ buyable ) , 'order _item ' ) ; $ relationship = Config : : inst ( ) - > get ( $ itemclass , 'buyable _relationship ' ) ; $ filter [ $ relationship . 'ID ' ] = $ buyable - > ID ; $ required = [ 'Order ID ' , $ relationship . 'ID ' ] ; if ( is _array ( $ itemclass : : config ( ) - > required _fields ) ) { $ required = array _merge ( $ required , $ itemclass : : config ( ) - > required _fields ) ; } $ query = new Match Object Filter ( $ itemclass , array _merge ( $ customfilter , $ filter ) , $ required ) ; $ item = $ itemclass : : get ( ) - > where ( $ query - > get Filter ( ) ) - > first ( ) ; if ( ! $ item ) { return $ this - > error ( _t ( _ _CLASS _ _ . ' .Item Not Found ' , 'Item not found . ' ) ) ; } return $ item ; } 
public function get Correct Buyable ( Buyable $ buyable ) { if ( $ buyable instanceof Product & & $ buyable - > has Extension ( Product Variations Extension : : class ) & & $ buyable - > Variations ( ) - > count ( ) > 0 ) { foreach ( $ buyable - > Variations ( ) as $ variation ) { if ( $ variation - > can Purchase ( ) ) { return $ variation ; } } } return $ buyable ; } 
public function archiveorderid ( $ requested Order Id = null ) { $ session = Shop Tools : : get Session ( ) ; $ session Id = $ session - > get ( self : : config ( ) - > cartid _session _name ) ; $ order = Order : : get ( ) - > filter ( 'Status :not ' , 'Cart ' ) - > by Id ( $ session Id ) ; if ( $ order & & ! $ order - > Is Cart ( ) ) { Order Manipulation Extension : : add _session _order ( $ order ) ; } 
public function clear ( $ write = true ) { $ session = Shop Tools : : get Session ( ) ; $ session - > set ( self : : config ( ) - > cartid _session _name , null ) - > clear ( self : : config ( ) - > cartid _session _name ) ; $ order = $ this - > current ( ) ; $ this - > order = null ; if ( $ write ) { if ( ! $ order ) { return $ this - > error ( _t ( _ _CLASS _ _ . ' .No Cart Found ' , 'No cart found . ' ) ) ; } $ order - > write ( ) ; } $ this - > message ( _t ( _ _CLASS _ _ . ' .Cleared ' , 'Cart was successfully cleared . ' ) ) ; return true ; } 
public function set Modifiers ( array $ modifiers ) { $ modifiers = array _map ( 'strtolower ' , $ modifiers ) ; if ( ( $ extras = array _diff ( $ modifiers , [ 'not ' , 'nocase ' , 'case ' , 'splitwords ' ] ) ) ! = array ( ) ) { throw new Invalid Argument Exception ( get _class ( $ this ) . ' does not accept ' . implode ( ' , ' , $ extras ) . ' as modifiers ' ) ; } $ this - > modifiers = $ modifiers ; $ this - > subfilter Modifiers = array _filter ( $ modifiers , function ( $ v ) { return $ v ! = 'splitwords ' ; } ) ; if ( ! empty ( $ this - > subfilters ) ) { foreach ( $ this - > subfilters as $ f ) { $ f - > set Modifiers ( $ this - > subfilter Modifiers ) ; } } } 
public function apply ( Data Query $ query ) { $ or Group = $ query - > disjunctive Group ( ) ; $ or Group = parent : : apply ( $ or Group ) ; if ( count ( $ this - > subfilters ) > 0 ) { foreach ( $ this - > subfilters as $ f ) { $ or Group = $ f - > apply ( $ or Group ) ; } } 
public function value ( $ incoming ) { $ this - > Rate = self : : config ( ) - > rate ; 
public static function price _for _display ( $ price ) { $ currency = Shop Config Extension : : get _site _currency ( ) ; $ field = DBMoney : : create _field ( DBMoney : : class , 0 , 'Price ' ) ; $ field - > set Amount ( $ price ) ; $ field - > set Currency ( $ currency ) ; return $ field ; } 
public static function install _locale ( $ locale ) { 
public static function get Session ( HTTPRequest $ request = null ) { if ( $ request & & ( $ session = $ request - > get Session ( ) ) ) { return $ session ; } if ( Controller : : has _curr ( ) & & ( $ request = Controller : : curr ( ) - > get Request ( ) ) ) { return $ request - > get Session ( ) ; } try { if ( $ session = Injector : : inst ( ) - > get ( HTTPRequest : : class ) - > get Session ( ) ) { return $ session ; } } catch ( Not Found Exception Interface $ e ) { 
public function updatecart ( $ data , $ form ) { $ items = $ this - > cart - > Items ( ) ; $ updatecount = $ removecount = 0 ; $ request = $ this - > get Request ( ) ; $ order = Shopping Cart : : curr ( ) ; if ( $ request & & $ request - > is Ajax ( ) & & $ order ) { Shop Tools : : install _locale ( $ order - > Locale ) ; } $ numeric Converter = Numeric Field : : create ( ' _temp ' ) ; $ messages = [ ] ; $ bad Messages = [ ] ; if ( isset ( $ data [ 'Items ' ] ) & & is _array ( $ data [ 'Items ' ] ) ) { foreach ( $ data [ 'Items ' ] as $ itemid = > $ fields ) { $ item = $ items - > by ID ( $ itemid ) ; if ( ! $ item ) { continue ; } 
public function image By Filename ( & $ obj , $ val , $ record ) { $ filename = trim ( strtolower ( Convert : : raw 2sql ( $ val ) ) ) ; $ filenamedashes = str _replace ( ' ' , ' - ' , $ filename ) ; if ( $ filename & & $ image = Image : : get ( ) - > where Any ( [ "LOWER ( \ "File Filename \ " ) LIKE ' % $filename % ' " , "LOWER ( \ "File Filename \ " ) LIKE ' % $filenamedashes % ' " ] ) - > first ( ) ) { 
public function set Parent ( & $ obj , $ val , $ record ) { $ title = strtolower ( Convert : : raw 2sql ( $ val ) ) ; if ( $ title ) { 
public function set Content ( & $ obj , $ val , $ record ) { $ val = trim ( $ val ) ; if ( $ val ) { $ paragraphs = explode ( " \n " , $ val ) ; $ obj - > Content = ' <p > ' . implode ( ' < /p > <p > ' , $ paragraphs ) . ' < /p > ' ; } } 
public function get Countries List ( $ prefixisocode = false ) { $ countries = self : : config ( ) - > iso _ 3 1 6 6 _country _codes ; asort ( $ countries ) ; if ( $ allowed = $ this - > owner - > Allowed Countries ) { $ allowed = json _decode ( $ allowed ) ; if ( ! empty ( $ allowed ) ) { $ countries = array _intersect _key ( $ countries , array _flip ( $ allowed ) ) ; } } if ( $ prefixisocode ) { foreach ( $ countries as $ key = > $ value ) { $ countries [ $ key ] = " $key - $value " ; } } return $ countries ; } 
public function get Single Country ( $ fullname = false ) { $ countries = $ this - > get Countries List ( ) ; if ( count ( $ countries ) = = 1 ) { if ( $ fullname ) { return array _pop ( $ countries ) ; } else { reset ( $ countries ) ; return key ( $ countries ) ; } } return null ; } 
public static function country Code 2name ( $ code ) { $ codes = self : : config ( ) - > iso _ 3 1 6 6 _country _codes ; if ( isset ( $ codes [ $ code ] ) ) { return $ codes [ $ code ] ; } return $ code ; } 
public function Cart ( ) { $ order = Shopping Cart : : curr ( ) ; if ( ! $ order | | ! $ order - > Items ( ) | | ! $ order - > Items ( ) - > exists ( ) ) { return false ; } return $ order ; } 
public function convert Array To Values ( array $ values ) { $ set = Array List : : create ( ) ; foreach ( $ values as $ value ) { $ val = $ this - > Values ( ) - > find ( 'Value ' , $ value ) ; if ( ! $ val ) { 
public function get Drop Down Field ( $ emptystring = null , $ values = null ) { $ values = ( $ values ) ? $ values : $ this - > Values ( ) - > sort ( [ 'Sort ' = > 'ASC ' , 'Value ' = > 'ASC ' ] ) ; if ( $ values - > exists ( ) ) { $ field = Dropdown Field : : create ( 'Product Attributes [ ' . $ this - > ID . ' ] ' , $ this - > Name , $ values - > map ( 'ID ' , 'Value ' ) ) ; if ( $ emptystring ) { $ field - > set Empty String ( $ emptystring ) ; } return $ field ; } return null ; } 
public function Products Showable ( $ recursive = true ) { 
public function All Child Category IDs ( ) { $ ids = [ $ this - > ID ] ; $ allids = [ ] ; do { $ ids = Product Category : : get ( ) - > filter ( 'Parent ID ' , $ ids ) - > get IDList ( ) ; $ allids + = $ ids ; } while ( ! empty ( $ ids ) ) ; return $ allids ; } 
public function Child Categories ( $ recursive = false ) { $ ids = array ( $ this - > ID ) ; if ( $ recursive ) { $ ids + = $ this - > All Child Category IDs ( ) ; } return Product Category : : get ( ) - > filter ( 'Parent ID ' , $ ids ) ; } 
public function Groups Menu ( ) { if ( $ this - > Parent ( ) instanceof Product Category ) { return $ this - > Parent ( ) - > Groups Menu ( ) ; } return Product Category : : get ( ) - > filter ( 'Parent ID ' , $ this - > ID ) ; } 
public function Nested Title ( $ level = 1 0 , $ separator = ' > ' , $ field = 'Menu Title ' ) { $ item = $ this ; while ( $ item & & $ level > 0 ) { $ parts [ ] = $ item - > { $ field } ; $ item = $ item - > Parent ; $ level - - ; } return implode ( $ separator , array _reverse ( $ parts ) ) ; } 
public function Item Edit Form ( ) { $ form = parent : : Item Edit Form ( ) ; $ printlink = $ this - > Link ( 'printorder ' ) . ' ?print = 1 ' ; $ printwindowjs = < < <JS window .open ( ' $printlink ' , 'print _order ' , 'toolbar = 0 ,scrollbars = 1 ,location = 1 ,statusbar = 0 ,menubar = 0 ,resizable = 1 ,width = 8 0 0 ,height = 6 0 0 ,left = 5 0 ,top = 5 0 ' ) ;return false ; JS ; $ form - > Actions ( ) - > push ( Literal Field : : create ( 'Print Order ' , " <button class = \ "no -ajax grid -print -button btn action btn -primary font -icon -print \ " onclick = \ "javascript : $printwindowjs \ " > " . _t ( 'Silver Shop \Model \Order .Print ' , 'Print ' ) . ' < /button > ' ) ) ; return $ form ; } 
public function printorder ( ) { Requirements : : clear ( ) ; 
private function nextstep ( ) { $ steps = $ this - > owner - > get Steps ( ) ; $ found = false ; foreach ( $ steps as $ step = > $ class ) { 
public function get List ( ) { $ list = parent : : get List ( ) ; if ( $ this - > model Class = = Order : : class ) { 
public function get Edit Form ( $ id = null , $ fields = null ) { $ form = parent : : get Edit Form ( $ id , $ fields ) ; if ( $ this - > model Class = = Order : : class ) { $ config = $ form - > Fields ( ) - > field By Name ( $ this - > sanitise Class Name ( $ this - > model Class ) ) - > get Config ( ) ; $ config - > get Component By Type ( Grid Field Sortable Header : : class ) - > set Field Sorting ( [ 'Status I 1 8N ' = > 'Status ' ] ) ; $ config - > get Component By Type ( Grid Field Detail Form : : class ) - > set Item Request Class ( Order Grid Field Detail Form _Item Request : : class ) ; 
private function get Subset ( Field List $ fields , $ subset = array ( ) ) { if ( empty ( $ subset ) ) { return $ fields ; } $ subfieldlist = Field List : : create ( ) ; foreach ( $ subset as $ field ) { if ( $ field = $ fields - > field By Name ( $ field ) ) { $ subfieldlist - > push ( $ field ) ; } } return $ subfieldlist ; } 
public function modify ( $ subtotal , $ forcecalculation = false ) { $ order = $ this - > Order ( ) ; $ value = ( $ order - > Is Cart ( ) | | $ forcecalculation ) ? $ this - > value ( $ subtotal ) : $ this - > Amount ; switch ( $ this - > Type ) { case 'Chargable ' : $ subtotal + = $ value ; break ; case 'Deductable ' : $ subtotal - = $ value ; break ; case 'Ignored ' : break ; } $ value = round ( $ value , Order : : config ( ) - > rounding _precision ) ; $ this - > Amount = $ value ; return $ subtotal ; } 
public static function setup Steps ( $ steps = null ) { if ( ! is _array ( $ steps ) ) { 
public function on After Init ( ) { $ action = $ this - > owner - > get Request ( ) - > param ( 'Action ' ) ; $ steps = $ this - > get Steps ( ) ; if ( ! Shopping Cart : : curr ( ) & & ! empty ( $ action ) & & isset ( $ steps [ $ action ] ) ) { Controller : : curr ( ) - > redirect ( $ this - > owner - > Link ( ) ) ; return ; } } 
public function Is Current Step ( $ name ) { if ( $ this - > owner - > get Action ( ) = = = $ name ) { return true ; } elseif ( ! $ this - > owner - > get Action ( ) | | $ this - > owner - > get Action ( ) = = = 'index ' ) { return $ this - > action Pos ( $ name ) = = = 0 ; } return false ; } 
private function action Pos ( $ incoming ) { $ count = 0 ; foreach ( $ this - > get Steps ( ) as $ action = > $ step ) { if ( $ action = = $ incoming ) { return $ count ; } $ count + + ; } } 
public static function find _link ( $ url Segment = false , $ action = false , $ id = false ) { $ base = Cart Page Controller : : config ( ) - > url _segment ; if ( $ page = self : : get ( ) - > first ( ) ) { $ base = $ page - > Link ( ) ; } return Controller : : join _links ( $ base , $ action , $ id ) ; } 
public function Products ( $ recursive = true ) { $ products = $ this - > Products Showable ( $ recursive ) ; 
public function get Sorter ( ) { $ options = array ( ) ; foreach ( Product Category : : config ( ) - > sort _options as $ k = > $ v ) { 
public function Trim Cents ( ) { $ val = $ this - > value ; if ( floor ( $ val ) = = $ val ) { return floor ( $ val ) ; } return $ val ; } 
public function get CMSFields ( ) { $ self = $ this ; $ this - > before Update CMSFields ( function ( Field List $ fields ) use ( $ self ) { $ fields - > field By Name ( 'Root .Main .Title ' ) - > set Title ( _t ( _ _CLASS _ _ . ' .Page Title ' , 'Product Title ' ) ) ; $ fields - > add Fields To Tab ( 'Root .Main ' , [ Text Field : : create ( 'Internal Item ID ' , _t ( _ _CLASS _ _ . ' .Internal Item ID ' , 'Product Code /SKU ' ) , ' ' , 3 0 ) , Dropdown Field : : create ( 'Parent ID ' , _t ( _ _CLASS _ _ . ' .Category ' , 'Category ' ) , $ self - > get Category Options ( ) ) - > set Description ( _t ( _ _CLASS _ _ . ' .Category Description ' , 'This is the parent page or default category . ' ) ) , Listbox Field : : create ( 'Product Categories ' , _t ( _ _CLASS _ _ . ' .Additional Categories ' , 'Additional Categories ' ) , $ self - > get Category Options No Parent ( ) ) , Text Field : : create ( 'Model ' , _t ( _ _CLASS _ _ . ' .Model ' , 'Model ' ) , ' ' , 3 0 ) , Checkbox Field : : create ( 'Featured ' , _t ( _ _CLASS _ _ . ' .Featured ' , 'Featured Product ' ) ) , Checkbox Field : : create ( 'Allow Purchase ' , _t ( _ _CLASS _ _ . ' .Allow Purchase ' , 'Allow product to be purchased ' ) , 1 ) , ] , 'Content ' ) ; $ fields - > add Fields To Tab ( 'Root .Pricing ' , [ Text Field : : create ( 'Base Price ' , $ this - > field Label ( 'Base Price ' ) ) - > set Description ( _t ( _ _CLASS _ _ . ' .Price Desc ' , 'Base price to sell this product at . ' ) ) - > set Max Length ( 1 2 ) , ] ) ; $ field Substitutes = [ 'Length Unit ' = > $ self : : config ( ) - > length _unit ] ; $ fields - > add Fields To Tab ( 'Root .Shipping ' , [ Text Field : : create ( 'Weight ' , _t ( _ _CLASS _ _ . ' .Weight With Unit ' , 'Weight ( {Weight Unit } ) ' , ' ' , [ 'Weight Unit ' = > self : : config ( ) - > weight _unit ] ) , ' ' , 1 2 ) , Text Field : : create ( 'Height ' , _t ( _ _CLASS _ _ . ' .Height With Unit ' , 'Height ( {Length Unit } ) ' , ' ' , $ field Substitutes ) , ' ' , 1 2 ) , Text Field : : create ( 'Width ' , _t ( _ _CLASS _ _ . ' .Width With Unit ' , 'Width ( {Length Unit } ) ' , ' ' , $ field Substitutes ) , ' ' , 1 2 ) , Text Field : : create ( 'Depth ' , _t ( _ _CLASS _ _ . ' .Depth With Unit ' , 'Depth ( {Length Unit } ) ' , ' ' , $ field Substitutes ) , ' ' , 1 2 ) , ] ) ; if ( ! $ fields - > data Field By Name ( 'Image ' ) ) { $ fields - > add Field To Tab ( 'Root .Images ' , Upload Field : : create ( 'Image ' , _t ( _ _CLASS _ _ . ' .Image ' , 'Product Image ' ) ) ) ; } } ) ; return parent : : get CMSFields ( ) ; } 
private function get Category Options ( ) { $ categories = Product Category : : get ( ) - > map ( 'ID ' , 'Nested Title ' ) - > to Array ( ) ; $ categories = [ 0 = > _t ( 'Silver Stripe \CMS \Model \Site Tree .PARENTTYPE _ROOT ' , 'Top -level page ' ) , ] + $ categories ; if ( $ this - > Parent ID & & ! ( $ this - > Parent ( ) instanceof Product Category ) ) { $ categories = [ $ this - > Parent ID = > $ this - > Parent ( ) - > Title . ' ( ' . $ this - > Parent ( ) - > i 1 8n _singular _name ( ) . ' ) ' , ] + $ categories ; } return $ categories ; } 
private function get Category Options No Parent ( ) { $ ancestors = $ this - > get Ancestors ( ) - > column ( 'ID ' ) ; $ categories = Product Category : : get ( ) ; if ( ! empty ( $ ancestors ) ) { $ categories = $ categories - > exclude ( 'ID ' , $ ancestors ) ; } return $ categories - > map ( 'ID ' , 'Nested Title ' ) - > to Array ( ) ; } 
public function get Category IDs ( ) { $ ids = array ( ) ; 
public function can Purchase ( $ member = null , $ quantity = 1 ) { $ global = self : : config ( ) - > global _allow _purchase ; if ( ! $ global | | ! $ this - > Allow Purchase ) { return false ; } $ allowpurchase = false ; $ extension = self : : has _extension ( Product Variations Extension : : class ) ; if ( $ extension & & Variation : : get ( ) - > filter ( 'Product ID ' , $ this - > ID ) - > first ( ) ) { foreach ( $ this - > Variations ( ) as $ variation ) { if ( $ variation - > can Purchase ( $ member , $ quantity ) ) { $ allowpurchase = true ; break ; } } } else { $ allowpurchase = ( $ this - > selling Price ( ) > 0 | | self : : config ( ) - > allow _zero _price ) ; } 
public function selling Price ( ) { $ price = $ this - > Base Price ; 
public function Image ( ) { $ image = $ this - > get Component ( 'Image ' ) ; $ this - > extend ( 'update Image ' , $ image ) ; if ( $ image & & $ image - > exists ( ) ) { return $ image ; } $ image = Site Config : : current _site _config ( ) - > Default Product Image ( ) ; if ( $ image & & $ image - > exists ( ) ) { return $ image ; } return null ; } 
public function submitpayment ( $ data , $ form ) { $ data = $ form - > get Data ( ) ; $ cancel Url = $ this - > get Failure Link ( ) ? $ this - > get Failure Link ( ) : $ this - > controller - > Link ( ) ; $ order = $ this - > config - > get Order ( ) ; 
public function dopayment ( $ data , $ form ) { if ( self : : config ( ) - > allow _paying & & $ this - > order & & $ this - > order - > can Pay ( ) ) { 
public function docancel ( $ data , $ form ) { if ( self : : config ( ) - > allow _cancelling & & $ this - > order - > can Cancel ( ) ) { $ this - > order - > Status = 'Member Cancelled ' ; $ this - > order - > write ( ) ; if ( self : : config ( ) - > email _notification ) { Order Email Notifier : : create ( $ this - > order ) - > send Cancel Notification ( ) ; } $ this - > controller - > session Message ( _t ( _ _CLASS _ _ . ' .Order Cancelled ' , 'Order sucessfully cancelled ' ) , 'warning ' ) ; if ( Security : : get Current User ( ) & & $ link = $ this - > order - > Link ( ) ) { $ this - > controller - > redirect ( $ link ) ; } else { $ this - > controller - > redirect Back ( ) ; } } } 
protected function get CCFields ( array $ gateways ) { $ field Factory = new Gateway Fields Factory ( null , array ( 'Card ' ) ) ; $ onsite Gateways = array ( ) ; $ all Required = array ( ) ; foreach ( $ gateways as $ gateway = > $ title ) { if ( ! Gateway Info : : is Offsite ( $ gateway ) ) { $ required = Gateway Info : : required Fields ( $ gateway ) ; $ onsite Gateways [ $ gateway ] = $ field Factory - > get Field Name ( $ required ) ; $ all Required + = $ required ; } } $ all Required = array _unique ( $ all Required ) ; $ all Required = $ field Factory - > get Field Name ( array _combine ( $ all Required , $ all Required ) ) ; if ( empty ( $ onsite Gateways ) ) { return null ; } $ cc Fields = $ field Factory - > get Card Fields ( ) ; 
public static function add _session _order ( Order $ order ) { $ history = self : : get _session _order _ids ( ) ; if ( ! is _array ( $ history ) ) { $ history = array ( ) ; } $ history [ $ order - > ID ] = $ order - > ID ; Shop Tools : : get Session ( ) - > set ( self : : $ sessname , $ history ) ; } 
public static function get _session _order _ids ( ) { $ history = Shop Tools : : get Session ( ) - > get ( self : : $ sessname ) ; if ( ! is _array ( $ history ) ) { $ history = null ; } return $ history ; } 
public function orderfromid ( ) { $ request = $ this - > owner - > get Request ( ) ; $ id = ( int ) $ request - > param ( 'ID ' ) ; if ( ! $ id ) { $ id = ( int ) $ request - > post Var ( 'Order ID ' ) ; } return $ this - > allorders ( ) - > by ID ( $ id ) ; } 
public function allorders ( ) { $ filters = array ( 'ID ' = > - 1 
public function Past Orders ( $ paginated = false ) { $ orders = $ this - > allorders ( ) - > filter ( 'Status ' , Order : : config ( ) - > placed _status ) ; if ( $ paginated ) { $ orders = Paginated List : : create ( $ orders , $ this - > owner - > get Request ( ) ) ; } return $ orders ; } 
public function order ( HTTPRequest $ request ) { 
public function Actions Form ( ) { if ( $ order = $ this - > orderfromid ( ) ) { $ form = Order Actions Form : : create ( $ this - > owner , 'Actions Form ' , $ order ) ; $ form - > extend ( 'update Actions Form ' , $ order ) ; if ( ! $ form - > Actions ( ) - > exists ( ) ) { return null ; } return $ form ; } return null ; } 
public function create ( $ data ) { $ result = Validation Result : : create ( ) ; if ( ! Checkout : : member _creation _enabled ( ) ) { $ result - > add Error ( _t ( 'Silver Shop \Checkout \Checkout .Membership Is Not Allowed ' , 'Creating new memberships is not allowed ' ) ) ; throw new Validation Exception ( $ result ) ; } $ idfield = Config : : inst ( ) - > get ( Member : : class , 'unique _identifier _field ' ) ; if ( ! isset ( $ data [ $ idfield ] ) | | empty ( $ data [ $ idfield ] ) ) { $ result - > add Error ( _t ( 'Silver Shop \Checkout \Checkout .Id Field Not Found ' , 'Required field not found : {Identifier Field } ' , 'Identifier is the field that holds the unique user -identifier , commonly this is \ 'Email \ ' ' , [ 'Identifier Field ' = > $ idfield ] ) ) ; throw new Validation Exception ( $ result ) ; } if ( ! isset ( $ data [ 'Password ' ] ) | | empty ( $ data [ 'Password ' ] ) ) { $ result - > add Error ( _t ( 'Silver Shop \Checkout \Checkout .Password Required ' , 'A password is required ' ) ) ; throw new Validation Exception ( $ result ) ; } $ idval = $ data [ $ idfield ] ; if ( $ member = Member Extension : : get _by _identifier ( $ idval ) ) { 
public static function get _by _identifier ( $ idvalue ) { return Member : : get ( ) - > filter ( Member : : config ( ) - > unique _identifier _field , $ idvalue ) - > first ( ) ; } 
public function after Member Logged In ( ) { if ( Member : : config ( ) - > login _joins _cart & & $ order = Shopping Cart : : singleton ( ) - > current ( ) ) { $ order - > Member ID = $ this - > owner - > ID ; $ order - > write ( ) ; } } 
public function get Past Orders ( ) { return Order : : get ( ) - > filter ( 'Member ID ' , $ this - > owner - > ID ) - > filter ( 'Status :not ' , Order : : config ( ) - > hidden _status ) ; } 
public function AJAXLink Hidden Field ( ) { if ( $ quantitylink = $ this - > item - > setquantity Link ( ) ) { return Hidden Field : : create ( $ this - > Main ID ( ) . ' _Quantity _Set Quantity Link ' ) - > set Value ( $ quantitylink ) - > add Extra Class ( 'ajax Quantity Field _qtylink ' ) ; } } 
public function get Existing Address Fields ( ) { $ member = Security : : get Current User ( ) ; if ( $ member & & $ member - > Address Book ( ) - > exists ( ) ) { $ addressoptions = $ member - > Address Book ( ) - > sort ( 'Created ' , 'DESC ' ) - > map ( 'ID ' , 'to String ' ) - > to Array ( ) ; $ addressoptions [ 'newaddress ' ] = _t ( 'Silver Shop \Model \Address .Create New Address ' , 'Create new address ' ) ; $ fieldtype = count ( $ addressoptions ) > 3 ? Dropdown Field : : class : Optionset Field : : class ; $ label = _t ( "Silver Shop \Model \Address .Existing { $this - >addresstype }Address " , "Existing { $this - >addresstype } Address " ) ; return Field List : : create ( $ fieldtype : : create ( $ this - > addresstype . 'Address ID ' , $ label , $ addressoptions , $ member - > { 'Default ' . $ this - > addresstype . 'Address ID ' } ) - > add Extra Class ( 'existing Values ' ) ) ; } return null ; } 
public function validate Data ( Order $ order , array $ data ) { $ result = Validation Result : : create ( ) ; $ existing ID = ! empty ( $ data [ $ this - > addresstype . 'Address ID ' ] ) ? ( int ) $ data [ $ this - > addresstype . 'Address ID ' ] : 0 ; if ( $ existing ID ) { $ member = Security : : get Current User ( ) ; 
public function set Data ( Order $ order , array $ data ) { $ existing ID = ! empty ( $ data [ $ this - > addresstype . 'Address ID ' ] ) ? ( int ) $ data [ $ this - > addresstype . 'Address ID ' ] : 0 ; if ( $ existing ID > 0 ) { $ order - > { $ this - > addresstype . 'Address ID ' } = $ existing ID ; $ order - > write ( ) ; $ order - > extend ( 'on Set ' . $ this - > addresstype . 'Address ' , $ address ) ; } else { parent : : set Data ( $ order , $ data ) ; } } 
public function get CMSFields ( ) { $ fields = Field List : : create ( Tab Set : : create ( 'Root ' , Tab : : create ( 'Main ' ) ) ) ; $ fs = ' <div class = "field " > ' ; $ fe = ' < /div > ' ; $ parts = array ( Dropdown Field : : create ( 'Status ' , $ this - > field Label ( 'Status ' ) , self : : get _order _status _options ( ) ) , Literal Field : : create ( 'Customer ' , $ fs . $ this - > render With ( 'Silver Shop \Admin \Order Admin _Customer ' ) . $ fe ) , Literal Field : : create ( 'Addresses ' , $ fs . $ this - > render With ( 'Silver Shop \Admin \Order Admin _Addresses ' ) . $ fe ) , Literal Field : : create ( 'Content ' , $ fs . $ this - > render With ( 'Silver Shop \Admin \Order Admin _Content ' ) . $ fe ) , ) ; if ( $ this - > Notes ) { $ parts [ ] = Literal Field : : create ( 'Notes ' , $ fs . $ this - > render With ( 'Silver Shop \Admin \Order Admin _Notes ' ) . $ fe ) ; } $ fields - > add Fields To Tab ( 'Root .Main ' , $ parts ) ; $ this - > extend ( 'update CMSFields ' , $ fields ) ; if ( $ payments = $ fields - > field By Name ( 'Root .Payments .Payments ' ) ) { $ fields - > remove By Name ( 'Payments ' ) ; $ fields - > insert After ( 'Content ' , $ payments ) ; $ payments - > add Extra Class ( 'order -payments ' ) ; } return $ fields ; } 
public function get Default Search Context ( ) { $ context = parent : : get Default Search Context ( ) ; $ fields = $ context - > get Fields ( ) ; $ valid States = self : : config ( ) - > placed _status ; $ status Options = array _filter ( self : : get _order _status _options ( ) , function ( $ k ) use ( $ valid States ) { return in _array ( $ k , $ valid States ) ; } , ARRAY _FILTER _USE _KEY ) ; $ fields - > push ( 
public function get Components ( $ component Name , $ id = null ) { $ components = parent : : get Components ( $ component Name , $ id ) ; if ( $ component Name = = = 'Items ' & & get _class ( $ components ) ! = = Unsaved Relation List : : class ) { $ query = $ components - > data Query ( ) ; $ components = Order Item List : : create ( Order Item : : class , 'Order ID ' ) ; $ components - > set Data Query ( $ query ) ; $ components = $ components - > for Foreign ID ( $ this - > ID ) ; } return $ components ; } 
public function calculate ( ) { if ( ! $ this - > Is Cart ( ) ) { return $ this - > Total ; } $ calculator = Order Total Calculator : : create ( $ this ) ; return $ this - > Total = $ calculator - > calculate ( ) ; } 
public function get Modifier ( $ class Name , $ forcecreate = false ) { $ calculator = Order Total Calculator : : create ( $ this ) ; return $ calculator - > get Modifier ( $ class Name , $ forcecreate ) ; } 
public function Total Outstanding ( $ include Authorized = true ) { return round ( $ this - > Grand Total ( ) - ( $ include Authorized ? $ this - > Total Paid Or Authorized ( ) : $ this - > Total Paid ( ) ) , self : : config ( ) - > rounding _precision ) ; } 
public function Link ( ) { if ( Security : : get Current User ( ) ) { $ link = Controller : : join _links ( Account Page : : find _link ( ) , 'order ' , $ this - > ID ) ; } $ link = Checkout Page : : find _link ( false , 'order ' , $ this - > ID ) ; $ this - > extend ( 'update Link ' , $ link ) ; return $ link ; } 
public function can Cancel ( $ member = null ) { $ extended = $ this - > extended Can ( _ _FUNCTION _ _ , $ member ) ; if ( $ extended ! = = null ) { return $ extended ; } switch ( $ this - > Status ) { case 'Unpaid ' : return self : : config ( ) - > cancel _before _payment ; case 'Paid ' : return self : : config ( ) - > cancel _before _processing ; case 'Processing ' : return self : : config ( ) - > cancel _before _sending ; case 'Sent ' : case 'Complete ' : return self : : config ( ) - > cancel _after _sending ; } return false ; } 
public function can Pay ( $ member = null ) { $ extended = $ this - > extended Can ( _ _FUNCTION _ _ , $ member ) ; if ( $ extended ! = = null ) { return $ extended ; } if ( ! in _array ( $ this - > Status , self : : config ( ) - > payable _status ) ) { return false ; } if ( $ this - > Total Outstanding ( true ) > 0 & & empty ( $ this - > Paid ) ) { return true ; } return false ; } 
public function can Delete ( $ member = null ) { $ extended = $ this - > extended Can ( _ _FUNCTION _ _ , $ member ) ; if ( $ extended ! = = null ) { return $ extended ; } return false ; } 
public function can View ( $ member = null ) { $ extended = $ this - > extended Can ( _ _FUNCTION _ _ , $ member ) ; if ( $ extended ! = = null ) { return $ extended ; } return true ; } 
public function get Name ( ) { $ firstname = $ this - > First Name ? $ this - > First Name : $ this - > Member ( ) - > First Name ; $ surname = $ this - > First Name ? $ this - > Surname : $ this - > Member ( ) - > Surname ; return implode ( ' ' , array _filter ( array ( $ firstname , $ surname ) ) ) ; } 
public function get Billing Address ( ) { if ( ! $ this - > Separate Billing Address & & $ this - > Shipping Address ID = = = $ this - > Billing Address ID ) { return $ this - > get Shipping Address ( ) ; } else { return $ this - > get Address ( 'Billing ' ) ; } } 
public function generate Reference ( ) { $ reference = str _pad ( $ this - > ID , self : : $ reference _id _padding , ' 0 ' , STR _PAD _LEFT ) ; $ this - > extend ( 'generate Reference ' , $ reference ) ; $ candidate = $ reference ; 
protected function on Before Write ( ) { parent : : on Before Write ( ) ; if ( ! $ this - > get Field ( 'Reference ' ) & & in _array ( $ this - > Status , self : : $ placed _status ) ) { $ this - > generate Reference ( ) ; } 
protected function status Transition ( $ from Status , $ to Status ) { 
protected function on Before Delete ( ) { foreach ( $ this - > Items ( ) as $ item ) { $ item - > delete ( ) ; } foreach ( $ this - > Modifiers ( ) as $ modifier ) { $ modifier - > delete ( ) ; } foreach ( $ this - > Order Status Logs ( ) as $ log Entry ) { $ log Entry - > delete ( ) ; } 
public function provide I 1 8n Entities ( ) { $ entities = parent : : provide I 1 8n Entities ( ) ; 
public function Field ( $ properties = array ( ) ) { $ editables = $ this - > editable Items ( ) ; $ customcartdata = array ( 'Items ' = > $ editables , ) ; 
protected function editable Items ( ) { $ editables = Array List : : create ( ) ; foreach ( $ this - > items as $ item ) { $ buyable = $ item - > Buyable ( ) ; if ( ! $ buyable ) { continue ; } 
public static function find _link ( $ url Segment = false ) { $ page = self : : get _if _account _page _exists ( ) ; return ( $ url Segment ) ? $ page - > URLSegment : $ page - > Link ( ) ; } 
public static function get _order _link ( $ order ID , $ url Segment = false ) { $ page = self : : get _if _account _page _exists ( ) ; return ( $ url Segment ? $ page - > URLSegment . ' / ' : $ page - > Link ( ) ) . 'order / ' . $ order ID ; } 
public function browse ( $ _ , $ assoc _args ) { $ this - > set _composer _auth _env _var ( ) ; if ( empty ( $ assoc _args [ 'format ' ] ) | | 'table ' = = = $ assoc _args [ 'format ' ] ) { WP _CLI : : line ( WP _CLI : : colorize ( ' %CAlthough the package index will remain in place for backward compatibility reasons , it has been deprecated and will not be updated further . Please refer to https : / /github .com /wp -cli /ideas /issues / 5 1 to read about its potential replacement . %n ' ) ) ; } $ this - > show _packages ( 'browse ' , $ this - > get _community _packages ( ) , $ assoc _args ) ; } 
public function install ( $ args , $ assoc _args ) { list ( $ package _name ) = $ args ; $ this - > set _composer _auth _env _var ( ) ; $ git _package = false ; $ dir _package = false ; $ version = 'dev -master ' ; if ( $ this - > is _git _repository ( $ package _name ) ) { $ git _package = $ package _name ; preg _match ( ' # ( [ ^ : \ / ] + \ / [ ^ \ / ] + ) \ .git # ' , $ package _name , $ matches ) ; if ( ! empty ( $ matches [ 1 ] ) ) { $ package _name = $ this - > check _git _package _name ( $ matches [ 1 ] ) ; } else { WP _CLI : : error ( "Couldn 't parse package name from expected path ' <name > / <package > ' . " ) ; } } elseif ( ( false ! = = strpos ( $ package _name , ' : / / ' ) & & false ! = = stripos ( $ package _name , ' .zip ' ) ) | | ( pathinfo ( $ package _name , PATHINFO _EXTENSION ) = = = 'zip ' & & is _file ( $ package _name ) ) ) { 
public function list _ ( $ args , $ assoc _args ) { $ this - > set _composer _auth _env _var ( ) ; $ this - > show _packages ( 'list ' , $ this - > get _installed _packages ( ) , $ assoc _args ) ; } 
public function path ( $ args ) { $ packages _dir = WP _CLI : : get _runner ( ) - > get _packages _dir _path ( ) ; if ( ! empty ( $ args ) ) { $ packages _dir . = 'vendor / ' . $ args [ 0 ] ; if ( ! is _dir ( $ packages _dir ) ) { WP _CLI : : error ( 'Invalid package name . ' ) ; } } WP _CLI : : line ( $ packages _dir ) ; } 
public function update ( ) { $ this - > set _composer _auth _env _var ( ) ; $ composer = $ this - > get _composer ( ) ; 
public function uninstall ( $ args ) { list ( $ package _name ) = $ args ; $ this - > set _composer _auth _env _var ( ) ; $ package = $ this - > get _installed _package _by _name ( $ package _name ) ; if ( false = = = $ package ) { WP _CLI : : error ( 'Package not installed . ' ) ; } $ package _name = $ package - > get Pretty Name ( ) ; 
private function get _composer ( ) { $ this - > avoid _composer _ca _bundle ( ) ; try { $ composer _path = $ this - > get _composer _json _path ( ) ; 
private function get _community _packages ( ) { static $ community _packages ; if ( null = = = $ community _packages ) { $ this - > avoid _composer _ca _bundle ( ) ; try { $ community _packages = $ this - > package _index ( ) - > get Packages ( ) ; } catch ( Exception $ e ) { WP _CLI : : error ( $ e - > get Message ( ) ) ; } } return $ community _packages ; } 
private function package _index ( ) { static $ package _index ; if ( ! $ package _index ) { $ config _args = [ 'config ' = > [ 'secure -http ' = > true , 'home ' = > dirname ( $ this - > get _composer _json _path ( ) ) , ] , ] ; $ config = new Config ( ) ; $ config - > merge ( $ config _args ) ; $ config - > set Config Source ( new Json Config Source ( $ this - > get _composer _json ( ) ) ) ; try { $ package _index = new Composer Repository ( [ 'url ' = > self : : PACKAGE _INDEX _URL ] , new Null IO ( ) , $ config ) ; } catch ( Exception $ e ) { WP _CLI : : error ( $ e - > get Message ( ) ) ; } } return $ package _index ; } 
private function show _packages ( $ context , $ packages , $ assoc _args ) { if ( 'list ' = = = $ context ) { $ default _fields = [ 'name ' , 'authors ' , 'version ' , 'update ' , 'update _version ' , ] ; } elseif ( 'browse ' = = = $ context ) { $ default _fields = [ 'name ' , 'description ' , 'authors ' , 'version ' , ] ; } $ defaults = [ 'fields ' = > implode ( ' , ' , $ default _fields ) , 'format ' = > 'table ' , ] ; $ assoc _args = array _merge ( $ defaults , $ assoc _args ) ; $ composer = $ this - > get _composer ( ) ; $ list = [ ] ; foreach ( $ packages as $ package ) { $ name = $ package - > get Pretty Name ( ) ; if ( isset ( $ list [ $ name ] ) ) { $ list [ $ name ] [ 'version ' ] [ ] = $ package - > get Pretty Version ( ) ; } else { $ package _output = [ ] ; $ package _output [ 'name ' ] = $ package - > get Pretty Name ( ) ; $ package _output [ 'description ' ] = $ package - > get Description ( ) ; $ package _output [ 'authors ' ] = implode ( ' , ' , array _column ( ( array ) $ package - > get Authors ( ) , 'name ' ) ) ; $ package _output [ 'version ' ] = [ $ package - > get Pretty Version ( ) ] ; $ update = 'none ' ; $ update _version = ' ' ; if ( 'list ' = = = $ context ) { try { $ latest = $ this - > find _latest _package ( $ package , $ composer , null ) ; if ( $ latest & & $ latest - > get Full Pretty Version ( ) ! = = $ package - > get Full Pretty Version ( ) ) { $ update = 'available ' ; $ update _version = $ latest - > get Pretty Version ( ) ; } } catch ( Exception $ e ) { WP _CLI : : warning ( $ e - > get Message ( ) ) ; $ update = 'error ' ; $ update _version = $ update ; } } $ package _output [ 'update ' ] = $ update ; $ package _output [ 'update _version ' ] = $ update _version ; $ package _output [ 'pretty _name ' ] = $ package - > get Pretty Name ( ) ; 
private function get _package _by _shortened _identifier ( $ package _name ) { 
private function get _installed _packages ( ) { $ composer = $ this - > get _composer ( ) ; $ repo = $ composer - > get Repository Manager ( ) - > get Local Repository ( ) ; $ existing = json _decode ( file _get _contents ( $ this - > get _composer _json _path ( ) ) , true ) ; $ installed _package _keys = ! empty ( $ existing [ 'require ' ] ) ? array _keys ( $ existing [ 'require ' ] ) : [ ] ; if ( empty ( $ installed _package _keys ) ) { return [ ] ; } 
private function get _installed _package _by _name ( $ package _name ) { foreach ( $ this - > get _installed _packages ( ) as $ package ) { if ( $ package _name = = = $ package - > get Pretty Name ( ) ) { return $ package ; } 
private static function get _package _name _and _version _from _dir _package ( $ dir _package ) { $ composer _file = $ dir _package . ' /composer .json ' ; if ( ! file _exists ( $ composer _file ) ) { WP _CLI : : error ( sprintf ( "Invalid package : composer .json file ' %s ' not found . " , $ composer _file ) ) ; } $ composer _data = json _decode ( file _get _contents ( $ composer _file ) , true ) ; if ( null = = = $ composer _data ) { WP _CLI : : error ( sprintf ( "Invalid package : failed to parse composer .json file ' %s ' as json . " , $ composer _file ) ) ; } if ( empty ( $ composer _data [ 'name ' ] ) ) { WP _CLI : : error ( sprintf ( "Invalid package : no name in composer .json file ' %s ' . " , $ composer _file ) ) ; } $ package _name = $ composer _data [ 'name ' ] ; $ version = 'dev -master ' ; if ( ! empty ( $ composer _data [ 'version ' ] ) ) { $ version = $ composer _data [ 'version ' ] ; } return [ $ package _name , $ version ] ; } 
private function get _composer _json _path ( ) { static $ composer _path ; if ( null = = = $ composer _path | | getenv ( 'WP _CLI _TEST _PACKAGE _GET _COMPOSER _JSON _PATH ' ) ) { if ( getenv ( 'WP _CLI _PACKAGES _DIR ' ) ) { $ composer _path = Utils \ trailingslashit ( getenv ( 'WP _CLI _PACKAGES _DIR ' ) ) . 'composer .json ' ; } else { $ composer _path = Utils \ trailingslashit ( Utils \ get _home _dir ( ) ) . ' .wp -cli /packages /composer .json ' ; } 
private function create _default _composer _json ( $ composer _path ) { $ composer _dir = pathinfo ( $ composer _path , PATHINFO _DIRNAME ) ; if ( ! is _dir ( $ composer _dir ) ) { if ( ! @ mkdir ( $ composer _dir , 0 7 7 7 , true ) ) { 
private function check _git _package _name ( $ package _name , $ version = ' ' ) { 
private function get _raw _git _version ( $ version ) { if ( ' ' = = = $ version ) { return 'master ' ; } 
private function guess _version _constraint _from _tag ( $ tag ) { $ matches = [ ] ; if ( 1 ! = = preg _match ( ' / ( ? :version |v ) \s * ( ( ? : [ 0 - 9 ] + \ . ? ) + ) ( ? : - . * ) /i ' , $ tag , $ matches ) ) { return $ tag ; } $ constraint = " ^ { $matches [ 1 ] } " ; WP _CLI : : debug ( "Guessing version constraint to use : { $constraint } " , 'packages ' ) ; return $ constraint ; } 
private function set _composer _auth _env _var ( ) { $ changed = false ; $ composer _auth = getenv ( 'COMPOSER _AUTH ' ) ; if ( false ! = = $ composer _auth ) { $ composer _auth = json _decode ( $ composer _auth , true ) ; } if ( empty ( $ composer _auth ) | | ! is _array ( $ composer _auth ) ) { $ composer _auth = [ ] ; } $ github _token = getenv ( 'GITHUB _TOKEN ' ) ; if ( ! isset ( $ composer _auth [ 'github -oauth ' ] ) & & is _string ( $ github _token ) ) { $ composer _auth [ 'github -oauth ' ] = [ 'github .com ' = > $ github _token ] ; $ changed = true ; } if ( $ changed ) { putenv ( 'COMPOSER _AUTH = ' . json _encode ( $ composer _auth ) ) ; } } 
private function avoid _composer _ca _bundle ( ) { if ( Utils \ inside _phar ( ) & & ! getenv ( 'SSL _CERT _FILE ' ) & & ! getenv ( 'SSL _CERT _DIR ' ) & & ! ini _get ( 'openssl .cafile ' ) & & ! ini _get ( 'openssl .capath ' ) ) { $ certificate = Utils \ extract _from _phar ( WP _CLI _VENDOR _DIR . self : : SSL _CERTIFICATE ) ; putenv ( "SSL _CERT _FILE = { $certificate } " ) ; } } 
private function get _composer _json _path _backup _decoded ( ) { $ composer _json _obj = $ this - > get _composer _json ( ) ; $ json _path = $ composer _json _obj - > get Path ( ) ; $ composer _backup = file _get _contents ( $ json _path ) ; if ( false = = = $ composer _backup ) { $ error = error _get _last ( ) ; WP _CLI : : error ( sprintf ( "Failed to read ' %s ' : %s " , $ json _path , $ error [ 'message ' ] ) ) ; } try { $ composer _backup _decoded = $ composer _json _obj - > read ( ) ; } catch ( Exception $ e ) { WP _CLI : : error ( sprintf ( "Failed to parse ' %s ' as json : %s " , $ json _path , $ e - > get Message ( ) ) ) ; } return [ $ json _path , $ composer _backup , $ composer _backup _decoded ] ; } 
private function register _revert _shutdown _function ( $ json _path , $ composer _backup , & $ revert ) { 
protected function set Object ( Data Object $ object , $ name = 'Object ' ) { $ this - > { $ name . 'ID ' } = $ object - > ID ; $ this - > { $ name . 'Type ' } = $ object - > Class Name ; } 
private function load Custom Config ( ) { $ custom = $ this - > get Custom Config ( ) ; if ( ! is _array ( $ custom ) ) { return ; } foreach ( $ custom as $ class = > $ settings ) { foreach ( $ settings as $ setting = > $ value ) { Config : : modify ( ) - > set ( $ class , $ setting , $ value ) ; } } } 
public function run ( $ request ) { $ confirm = $ request - > get Var ( 'confirm ' ) ; $ jobs = Data Object : : get ( Queued Job Descriptor : : class ) ; if ( ! $ confirm ) { echo "Really delete " . $ jobs - > count ( ) . " jobs ? Please add ?confirm = 1 to the URL to confirm . " ; return ; } echo "Deleting " . $ jobs - > count ( ) . " jobs . . . <br > \n " ; $ jobs - > remove All ( ) ; echo "Done . " ; } 
public function process ( ) { FROM "Queued Job Descriptor " WHERE "Job Status " IN ( \ ' ' . $ status List . ' \ ' ) AND "Last Edited " < \ ' ' . $ cut Off . ' \ ' ' . $ limit ) ; $ stale Jobs = $ stale - > column ( "ID " ) ; break ; / / If Number , we need to save n records , then delete from the rest case "number " : $ fresh = DB : : query ( 'SELECT "ID " FROM "Queued Job Descriptor " ORDER BY "Last Edited " ASC LIMIT ' . $ this - > config ( ) - > cleanup _value ) ; $ fresh Job IDs = implode ( ' \ ' , \ ' ' , $ fresh - > column ( "ID " ) ) ; $ stale = DB : : query ( 'SELECT "ID " FROM "Queued Job Descriptor " WHERE "ID " NOT IN ( \ ' ' . $ fresh Job IDs . ' \ ' ) AND "Job Status " IN ( \ ' ' . $ status List . ' \ ' ) ' . $ limit ) ; $ stale Jobs = $ stale - > column ( "ID " ) ; break ; default : $ this - > add Message ( "Incorrect configuration values set . Cleanup ignored " ) ; $ this - > is Complete = true ; return ; } if ( empty ( $ stale Jobs ) ) { $ this - > add Message ( "No jobs to clean up . " ) ; $ this - > is Complete = true ; $ this - > reenqueue ( ) ; return ; } $ num Jobs = count ( $ stale Jobs ) ; $ stale Jobs = implode ( ' \ ' , \ ' ' , $ stale Jobs ) ; DB : : query ( 'DELETE FROM "Queued Job Descriptor " WHERE "ID " IN ( \ ' ' . $ stale Jobs . ' \ ' ) ' ) ; $ this - > add Message ( $ num Jobs . " jobs cleaned up . " ) ; / / let 's make sure there is a cleanup Job in the queue $ this - > reenqueue ( ) ; $ this - > is Complete = true ; } 
public function queue Job ( Queued Job $ job , $ start After = null , $ user Id = null , $ queue Name = null ) { $ signature = $ job - > get Signature ( ) ; 
public function start Job ( $ job Descriptor , $ start After = null ) { if ( $ start After & & strtotime ( $ start After ) > DBDatetime : : now ( ) - > get Timestamp ( ) ) { $ this - > queue Handler - > schedule Job ( $ job Descriptor , $ start After ) ; } else { 
protected function copy Job To Descriptor ( $ job , $ job Descriptor ) { $ data = $ job - > get Job Data ( ) ; $ job Descriptor - > Total Steps = $ data - > total Steps ; $ job Descriptor - > Steps Processed = $ data - > current Step ; if ( $ data - > is Complete ) { $ job Descriptor - > Job Status = Queued Job : : STATUS _COMPLETE ; $ job Descriptor - > Job Finished = DBDatetime : : now ( ) - > Rfc 2 8 2 2 ( ) ; } $ job Descriptor - > Saved Job Data = serialize ( $ data - > job Data ) ; $ job Descriptor - > Saved Job Messages = serialize ( $ data - > messages ) ; } 
public function get Next Pending Job ( $ type = null ) { 
public function check Job Health ( $ queue = null ) { $ queue = $ queue ? : Queued Job : : QUEUED ; 
public function check Default Jobs ( $ queue = null ) { $ queue = $ queue ? : Queued Job : : QUEUED ; if ( count ( $ this - > default Jobs ) ) { $ active Jobs = Queued Job Descriptor : : get ( ) - > filter ( 'Job Status ' , [ Queued Job : : STATUS _NEW , Queued Job : : STATUS _INIT , Queued Job : : STATUS _RUN , Queued Job : : STATUS _WAIT , Queued Job : : STATUS _PAUSED , ] ) ; foreach ( $ this - > default Jobs as $ title = > $ job Config ) { if ( ! isset ( $ job Config [ 'filter ' ] ) | | ! isset ( $ job Config [ 'type ' ] ) ) { $ this - > get Logger ( ) - > error ( "Default Job config : $title incorrectly set up . Please check the readme for examples " , [ 'file ' = > _ _FILE _ _ , 'line ' = > _ _LINE _ _ , ] ) ; continue ; } $ job = $ active Jobs - > filter ( array _merge ( [ 'Implementation ' = > $ job Config [ 'type ' ] ] , $ job Config [ 'filter ' ] ) ) ; if ( ! $ job - > count ( ) ) { $ this - > get Logger ( ) - > error ( "Default Job config : $title was missing from Queue " , [ 'file ' = > _ _FILE _ _ , 'line ' = > _ _LINE _ _ , ] ) ; Email : : create ( ) - > set To ( isset ( $ job Config [ 'email ' ] ) ? $ job Config [ 'email ' ] : Config : : inst ( ) - > get ( Email : : class , 'queued _job _admin _email ' ) ) - > set From ( Config : : inst ( ) - > get ( Email : : class , 'admin _email ' ) ) - > set Subject ( 'Default Job " ' . $ title . ' " missing ' ) - > set Data ( $ job Config ) - > add Data ( 'Title ' , $ title ) - > add Data ( 'Site ' , Director : : absolute Base URL ( ) ) - > set HTMLTemplate ( 'Queued Jobs Default Job ' ) - > send ( ) ; if ( isset ( $ job Config [ 'recreate ' ] ) & & $ job Config [ 'recreate ' ] ) { if ( ! array _key _exists ( 'construct ' , $ job Config ) | | ! isset ( $ job Config [ 'start Date Format ' ] ) | | ! isset ( $ job Config [ 'start Time String ' ] ) ) { $ this - > get Logger ( ) - > error ( "Default Job config : $title incorrectly set up . Please check the readme for examples " , [ 'file ' = > _ _FILE _ _ , 'line ' = > _ _LINE _ _ , ] ) ; continue ; } Queued Job Service : : singleton ( ) - > queue Job ( Injector : : inst ( ) - > create With Args ( $ job Config [ 'type ' ] , $ job Config [ 'construct ' ] ) , date ( $ job Config [ 'start Date Format ' ] , strtotime ( $ job Config [ 'start Time String ' ] ) ) ) ; $ this - > get Logger ( ) - > info ( "Default Job config : $title has been re -added to the Queue " , [ 'file ' = > _ _FILE _ _ , 'line ' = > _ _LINE _ _ , ] ) ; } } } } } 
protected function restart Stalled Job ( $ stalled Job ) { if ( $ stalled Job - > Resume Counts < static : : config ( ) - > get ( 'stall _threshold ' ) ) { $ stalled Job - > restart ( ) ; $ log Level = 'warning ' ; $ message = _t ( _ _CLASS _ _ . ' .STALLED _JOB _RESTART _MSG ' , 'A job named {name } ( # {id } ) appears to have stalled . It will be stopped and restarted , please ' . 'login to make sure it has continued ' , [ 'name ' = > $ stalled Job - > Job Title , 'id ' = > $ stalled Job - > ID ] ) ; } else { $ stalled Job - > pause ( ) ; $ log Level = 'error ' ; $ message = _t ( _ _CLASS _ _ . ' .STALLED _JOB _MSG ' , 'A job named {name } ( # {id } ) appears to have stalled . It has been paused , please login to check it ' , [ 'name ' = > $ stalled Job - > Job Title , 'id ' = > $ stalled Job - > ID ] ) ; } $ this - > get Logger ( ) - > log ( $ log Level , $ message , [ 'file ' = > _ _FILE _ _ , 'line ' = > _ _LINE _ _ , ] ) ; $ from = Config : : inst ( ) - > get ( Email : : class , 'admin _email ' ) ; $ to = Config : : inst ( ) - > get ( Email : : class , 'queued _job _admin _email ' ) ; $ subject = _t ( _ _CLASS _ _ . ' .STALLED _JOB ' , 'Stalled job ' ) ; if ( $ to ) { $ mail = Email : : create ( $ from , $ to , $ subject ) - > set Data ( [ 'Job ID ' = > $ stalled Job - > ID , 'Message ' = > $ message , 'Site ' = > Director : : absolute Base URL ( ) , ] ) - > set HTMLTemplate ( 'Queued Jobs Stalled Job ' ) ; $ mail - > send ( ) ; } } 
protected function initialise Job ( Queued Job Descriptor $ job Descriptor ) { 
protected function grab Mutex ( Queued Job Descriptor $ job Descriptor ) { 
public function run Job ( $ job Id ) { 
protected function has Passed Time Limit ( ) { 
protected function is Memory Too High ( ) { $ used = $ this - > get Memory Usage ( ) ; $ limit = $ this - > get Memory Limit ( ) ; return $ limit & & ( $ used > $ limit ) ; } 
protected function get Memory Limit ( ) { 
protected function parse Memory ( $ mem String ) { switch ( strtolower ( substr ( $ mem String , - 1 ) ) ) { case "b " : return round ( substr ( $ mem String , 0 , - 1 ) ) ; case "k " : return round ( substr ( $ mem String , 0 , - 1 ) * 1 0 2 4 ) ; case "m " : return round ( substr ( $ mem String , 0 , - 1 ) * 1 0 2 4 * 1 0 2 4 ) ; case "g " : return round ( substr ( $ mem String , 0 , - 1 ) * 1 0 2 4 * 1 0 2 4 * 1 0 2 4 ) ; default : return round ( $ mem String ) ; } } 
public function get Job List ( $ type = null , $ include Up Until = 0 ) { return Data Object : : get ( Queued Job Descriptor : : class , $ this - > get Job List Filter ( $ type , $ include Up Until ) ) ; } 
public function get Job List Filter ( $ type = null , $ include Up Until = 0 ) { $ util = singleton ( QJUtils : : class ) ; $ filter = [ 'Job Status < > ' = > Queued Job : : STATUS _COMPLETE ] ; if ( $ include Up Until ) { $ filter [ 'Job Finished > ' ] = DBDatetime : : create ( ) - > set Value ( DBDatetime : : now ( ) - > get Timestamp ( ) - $ include Up Until ) - > Rfc 2 8 2 2 ( ) ; } $ filter = $ util - > db Quote ( $ filter , ' OR ' ) ; if ( $ type ) { $ filter = $ util - > db Quote ( [ 'Job Type = ' = > ( string ) $ type ] ) . ' AND ( ' . $ filter . ' ) ' ; } return $ filter ; } 
public function run Queue ( $ queue ) { if ( ! self : : config ( ) - > get ( 'disable _health _check ' ) ) { $ this - > check Job Health ( $ queue ) ; } $ this - > checkdefault Jobs ( $ queue ) ; $ this - > queue Runner - > run Queue ( $ queue ) ; } 
public function process Job Queue ( $ name ) { 
public function queue Task ( $ request ) { $ name = $ request - > param ( 'Task Name ' ) ; $ tasks = $ this - > get Tasks ( ) ; $ variables = $ request - > get Vars ( ) ; unset ( $ variables [ 'url ' ] ) ; unset ( $ variables [ 'flush ' ] ) ; unset ( $ variables [ 'flushtoken ' ] ) ; unset ( $ variables [ 'is Dev ' ] ) ; $ querystring = http _build _query ( $ variables ) ; $ title = function ( $ content ) { printf ( Director : : is _cli ( ) ? " %s \n \n " : ' <h 1 > %s < /h 1 > ' , $ content ) ; } ; $ message = function ( $ content ) { printf ( Director : : is _cli ( ) ? " %s \n " : ' <p > %s < /p > ' , $ content ) ; } ; foreach ( $ tasks as $ task ) { if ( $ task [ 'segment ' ] = = $ name ) { $ inst = Injector : : inst ( ) - > create ( $ task [ 'class ' ] ) ; if ( ! $ inst - > is Enabled ( ) ) { $ message ( 'The task is disabled ' ) ; return ; } $ title ( sprintf ( 'Queuing Task %s ' , $ inst - > get Title ( ) ) ) ; $ job = new Run Build Task Job ( $ task [ 'class ' ] , $ querystring ) ; $ job ID = Injector : : inst ( ) - > get ( Queued Job Service : : class ) - > queue Job ( $ job ) ; $ message ( 'Done : queued with job ID ' . $ job ID ) ; $ admin Url = Director : : base URL ( ) . Admin Root Controller : : config ( ) - > get ( 'url _base ' ) ; $ admin Link = $ admin Url . " /queuedjobs / " . str _replace ( ' \ \ ' , ' - ' , Queued Job Descriptor : : class ) ; $ message ( "Visit <a href = \ " $admin Link \ " >queued jobs admin < /a > to see job status " ) ; return ; } } $ message ( sprintf ( 'The build task " %s " could not be found ' , Convert : : raw 2xml ( $ name ) ) ) ; } 
protected function write Log Line ( $ line , $ prefix = null ) { if ( ! $ prefix ) { $ prefix = ' [ ' . DBDatetime : : now ( ) - > Rfc 2 8 2 2 ( ) . ' ] ' ; } if ( Director : : is _cli ( ) ) { echo $ prefix . $ line . " \n " ; } else { echo Convert : : raw 2xml ( $ prefix . $ line ) . " <br > " ; } } 
protected function log Descriptor Status ( $ descriptor , $ queue ) { if ( is _null ( $ descriptor ) ) { $ this - > write Log Line ( 'No new jobs on queue ' . $ queue ) ; } if ( $ descriptor = = = false ) { $ this - > write Log Line ( 'Job is still running on queue ' . $ queue ) ; } if ( $ descriptor instanceof Queued Job Descriptor ) { $ this - > write Log Line ( 'Running ' . $ descriptor - > Job Title . ' and others from queue ' . $ queue . ' . ' ) ; } } 
public function list Jobs ( ) { $ service = $ this - > get Service ( ) ; for ( $ i = 1 ; $ i < = 3 ; $ i + + ) { $ jobs = $ service - > get Job List ( $ i ) ; $ num = $ jobs ? $ jobs - > Count ( ) : 0 ; $ this - > write Log Line ( 'Found ' . $ num . ' jobs for mode ' . $ i . ' . ' ) ; } } 
protected function refresh Descriptor ( ) { if ( $ this - > descriptor ) { $ this - > descriptor = Queued Job Descriptor : : get ( ) - > by ID ( $ this - > descriptor - > ID ) ; } } 
public function unserialize ( $ serialized ) { $ data = unserialize ( $ serialized ) ; if ( ! isset ( $ data [ 'descriptor ' ] ) ) { throw new Invalid Argument Exception ( 'Malformed data ' ) ; } $ descriptor = Queued Job Descriptor : : get ( ) - > filter ( 'ID ' , $ data [ 'descriptor ' ] ) - > first ( ) ; if ( ! $ descriptor ) { throw new Invalid Argument Exception ( 'Descriptor not found ' ) ; } $ this - > descriptor = $ descriptor ; } 
public function should Expire ( $ started At ) { if ( $ this - > descriptor - > has Method ( 'should Expire ' ) ) { return $ this - > descriptor - > should Expire ( $ started At ) ; } return true ; } 
public function can Run Task ( ) { $ this - > refresh Descriptor ( ) ; return in _array ( $ this - > descriptor - > Job Status , array ( Queued Job : : STATUS _NEW , Queued Job : : STATUS _INIT , Queued Job : : STATUS _WAIT ) ) ; } 
public function is Cancelled ( ) { $ this - > refresh Descriptor ( ) ; 
public function run ( $ request ) { $ queue = $ request - > request Var ( 'queue ' ) ? : Queued Job : : QUEUED ; $ stalled Job Count = $ this - > get Service ( ) - > check Job Health ( $ queue ) ; echo $ stalled Job Count = = = 0 ? 'All jobs are healthy ' : 'Detected and attempted restart on ' . $ stalled Job Count . ' stalled jobs ' ; } 
public function pause ( $ force = false ) { if ( $ force | | in _array ( $ this - > Job Status , [ Queued Job : : STATUS _WAIT , Queued Job : : STATUS _RUN , Queued Job : : STATUS _INIT ] ) ) { $ this - > Job Status = Queued Job : : STATUS _PAUSED ; $ this - > write ( ) ; return true ; } return false ; } 
public function resume ( $ force = false ) { if ( $ force | | in _array ( $ this - > Job Status , [ Queued Job : : STATUS _PAUSED , Queued Job : : STATUS _BROKEN ] ) ) { $ this - > Job Status = Queued Job : : STATUS _WAIT ; $ this - > Resume Counts + + ; $ this - > write ( ) ; Queued Job Service : : singleton ( ) - > start Job ( $ this ) ; return true ; } return false ; } 
public function activate On Queue ( ) { 
protected function get Job Dir ( ) { 
public function cleanup Job ( ) { 
public function get Messages ( ) { if ( strlen ( $ this - > Saved Job Messages ) ) { $ messages = @ unserialize ( $ this - > Saved Job Messages ) ; if ( ! empty ( $ messages ) ) { return DBField : : create _field ( 'HTMLText ' , ' <ul > <li > ' . nl 2br ( implode ( ' < /li > <li > ' , Convert : : raw 2xml ( $ messages ) ) ) . ' < /li > < /ul > ' ) ; } return ' ' ; } } 
public function get Last Message ( ) { if ( strlen ( $ this - > Saved Job Messages ) ) { $ msgs = @ unserialize ( $ this - > Saved Job Messages ) ; if ( is _array ( $ msgs ) & & sizeof ( $ msgs ) ) { return array _pop ( $ msgs ) ; } } } 
public function get Job Type String ( ) { $ map = $ this - > get Job Type Values ( ) ; return isset ( $ map [ $ this - > Job Type ] ) ? $ map [ $ this - > Job Type ] : ' (Unknown ) ' ; } 
public function get Job Type Values ( ) { return [ Queued Job : : IMMEDIATE = > _t ( _ _CLASS _ _ . ' .TYPE _IMMEDIATE ' , 'Immediate ' ) , Queued Job : : QUEUED = > _t ( _ _CLASS _ _ . ' .TYPE _QUEUED ' , 'Queued ' ) , Queued Job : : LARGE = > _t ( _ _CLASS _ _ . ' .TYPE _LARGE ' , 'Large ' ) , ] ; } 
public function setup ( ) { parent : : setup ( ) ; Environment : : increase Time Limit To ( ) ; $ restart = $ this - > current Step = = 0 ; if ( ! $ this - > temp File | | ! file _exists ( $ this - > temp File ) ) { $ tmpfile = tempnam ( Temp Folder : : get Temp Folder ( BASE _PATH ) , 'sitemap ' ) ; if ( file _exists ( $ tmpfile ) ) { $ this - > temp File = $ tmpfile ; } $ restart = true ; } if ( $ restart ) { $ this - > pages To Process = DB : : query ( 'SELECT ID FROM Site Tree _Live WHERE Show In Search = 1 ' ) - > column ( ) ; } } 
public function prepare For Restart ( ) { parent : : prepare For Restart ( ) ; 
protected function complete Job ( ) { $ content = ' < ?xml version = " 1 . 0 " encoding = "UTF - 8 " ? > ' . ' <urlset xmlns = "http : / /www .sitemaps .org /schemas /sitemap / 0 . 9 " > ' ; $ content . = file _get _contents ( $ this - > temp File ) ; $ content . = ' < /urlset > ' ; $ sitemap = Director : : base Folder ( ) . ' /sitemap .xml ' ; file _put _contents ( $ sitemap , $ content ) ; if ( file _exists ( $ this - > temp File ) ) { unlink ( $ this - > temp File ) ; } $ nextgeneration = Injector : : inst ( ) - > create ( Generate Google Sitemap Job : : class ) ; Queued Job Service : : singleton ( ) - > queue Job ( $ nextgeneration , DBDatetime : : create ( ) - > set Value ( DBDatetime : : now ( ) - > get Timestamp ( ) + $ this - > config ( ) - > get ( 'regenerate _time ' ) ) - > Rfc 2 8 2 2 ( ) ) ; } 
public function run Queue ( $ queue ) { 
public function handle Action ( Grid Field $ grid Field , $ action Name , $ arguments , $ data ) { $ actions = $ this - > get Actions ( null ) ; if ( in _array ( $ action Name , $ actions ) ) { $ item = $ grid Field - > get List ( ) - > by ID ( $ arguments [ 'Record ID ' ] ) ; if ( ! $ item ) { return ; } $ item - > $ action Name ( ) ; Requirements : : clear ( ) ; } } 
public function get Title ( ) { $ title = 'Unknown ' ; if ( $ root = $ this - > get Root ( ) ) { $ title = $ root - > Title ; } return _t ( _ _CLASS _ _ . ' .Title ' , "Publish items beneath {title } " , [ 'title ' = > $ title ] ) ; } 
public function setup ( ) { if ( ! $ this - > get Root ( ) ) { 
public function process ( ) { $ remaining Children = $ this - > remaining Children ; 
protected function get Queue ( $ request ) { $ queue = $ request - > get Var ( 'queue ' ) ; if ( ! $ queue ) { $ queue = 'Queued ' ; } switch ( strtolower ( $ queue ) ) { case 'immediate ' : $ queue = Queued Job : : IMMEDIATE ; break ; case 'queued ' : $ queue = Queued Job : : QUEUED ; break ; case 'large ' : $ queue = Queued Job : : LARGE ; break ; default : break ; } return $ queue ; } 
public static function cast Model ( Active Record $ model ) { $ attributes = array _merge ( $ model - > get Attributes ( ) , $ model - > get Related Records ( ) ) ; $ results = [ ] ; foreach ( $ attributes as $ key = > $ value ) { $ results [ Caster : : PREFIX _VIRTUAL . $ key ] = $ value ; } return $ results ; } 
public function action Index ( ) { $ config = new Configuration ; $ config - > get Presenter ( ) - > add Casters ( $ this - > get Casters ( ) ) ; $ shell = new Shell ( $ config ) ; $ shell - > set Includes ( $ this - > include ) ; $ shell - > run ( ) ; } 
public function css ( $ file , $ media = null ) { $ css _file = $ this - > process Scss File ( $ file ) ; return parent : : css ( $ css _file , $ media ) ; } 
public function process Scss File ( $ file ) { if ( ! preg _match ( ' / \ .scss $ / ' , $ file ) ) { 
public function save Map ( $ content ) { $ asset _handler = Requirements : : backend ( ) - > get Asset Handler ( ) ; $ css _file = $ this - > options [ 'source Map Write To ' ] ; $ asset _handler - > set Content ( $ css _file , $ content ) ; $ url = $ asset _handler - > get Content URL ( $ css _file ) ; $ this - > options [ 'source Map URL ' ] = $ url ; return $ this - > options [ 'source Map URL ' ] ; } 
public function write ( $ data ) { $ size = mb _strlen ( $ data , 'UTF - 8 ' ) ; if ( $ this - > exists ( $ this - > id ) ) { shmop _delete ( $ this - > shmid ) ; shmop _close ( $ this - > shmid ) ; $ this - > shmid = shmop _open ( $ this - > id , "c " , $ this - > perms , $ size ) ; shmop _write ( $ this - > shmid , $ data , 0 ) ; } else { $ this - > shmid = shmop _open ( $ this - > id , "c " , $ this - > perms , $ size ) ; shmop _write ( $ this - > shmid , $ data , 0 ) ; } } 
public function read ( ) { $ size = shmop _size ( $ this - > shmid ) ; $ data = shmop _read ( $ this - > shmid , 0 , $ size ) ; return $ data ; } 
private static function get Initial Value ( string & $ key , bool $ padding _enabled ) : string { if ( false = = = $ padding _enabled ) { return \ hex 2bin ( 'A 6A 6A 6A 6A 6A 6A 6A 6 ' ) ; } $ MLI = \ mb _strlen ( $ key , ' 8bit ' ) ; $ iv = \ hex 2bin ( 'A 6 5 9 5 9A 6 ' ) . self : : to XBits ( 3 2 , $ MLI ) ; $ n = \ intval ( \ ceil ( $ MLI / 8 ) ) ; $ key = \ str _pad ( $ key , 8 * $ n , " \ 0 " , STR _PAD _RIGHT ) ; return $ iv ; } 
public static function wrap ( string $ kek , string $ key , bool $ padding _enabled = false ) : string { $ A = self : : get Initial Value ( $ key , $ padding _enabled ) ; self : : check Key Size ( $ key , $ padding _enabled ) ; $ P = \ str _split ( $ key , 8 ) ; $ N = \ count ( $ P ) ; $ C = [ ] ; if ( 1 = = = $ N ) { $ B = self : : encrypt ( $ kek , $ A . $ P [ 0 ] ) ; $ C [ 0 ] = self : : get MSB ( $ B ) ; $ C [ 1 ] = self : : get LSB ( $ B ) ; } elseif ( 1 < $ N ) { $ R = $ P ; for ( $ j = 0 ; $ j < = 5 ; + + $ j ) { for ( $ i = 1 ; $ i < = $ N ; + + $ i ) { $ B = self : : encrypt ( $ kek , $ A . $ R [ $ i - 1 ] ) ; $ t = $ i + $ j * $ N ; $ A = self : : to XBits ( 6 4 , $ t ) ^ self : : get MSB ( $ B ) ; $ R [ $ i - 1 ] = self : : get LSB ( $ B ) ; } } $ C = \ array _merge ( [ $ A ] , $ R ) ; } return \ implode ( ' ' , $ C ) ; } 
public static function unwrap ( string $ kek , string $ key , bool $ padding _enabled = false ) : string { $ P = \ str _split ( $ key , 8 ) ; $ A = $ P [ 0 ] ; $ N = \ count ( $ P ) ; if ( 2 > $ N ) { throw new \ Invalid Argument Exception ( 'Bad data ' ) ; } if ( 2 = = = $ N ) { $ B = self : : decrypt ( $ kek , $ P [ 0 ] . $ P [ 1 ] ) ; $ unwrapped = self : : get LSB ( $ B ) ; $ A = self : : get MSB ( $ B ) ; } else { $ R = $ P ; for ( $ j = 5 ; $ j > = 0 ; - - $ j ) { for ( $ i = $ N - 1 ; $ i > = 1 ; - - $ i ) { $ t = $ i + $ j * ( $ N - 1 ) ; $ B = self : : decrypt ( $ kek , ( self : : to XBits ( 6 4 , $ t ) ^ $ A ) . $ R [ $ i ] ) ; $ A = self : : get MSB ( $ B ) ; $ R [ $ i ] = self : : get LSB ( $ B ) ; } } unset ( $ R [ 0 ] ) ; $ unwrapped = \ implode ( ' ' , $ R ) ; } if ( false = = = self : : check Initial Value ( $ unwrapped , $ padding _enabled , $ A ) ) { throw new \ Invalid Argument Exception ( 'Integrity check failed ! ' ) ; } return $ unwrapped ; } 
public function list _ ( $ args , $ assoc _args ) { global $ wp _registered _sidebars ; Utils \ wp _register _unused _sidebar ( ) ; if ( ! empty ( $ assoc _args [ 'format ' ] ) & & 'ids ' = = = $ assoc _args [ 'format ' ] ) { $ sidebars = wp _list _pluck ( $ wp _registered _sidebars , 'id ' ) ; } else { $ sidebars = $ wp _registered _sidebars ; } $ formatter = new Formatter ( $ assoc _args , $ this - > fields ) ; $ formatter - > display _items ( $ sidebars ) ; } 
public function list _ ( $ args , $ assoc _args ) { list ( $ sidebar _id ) = $ args ; $ this - > validate _sidebar ( $ sidebar _id ) ; $ output _widgets = $ this - > get _sidebar _widgets ( $ sidebar _id ) ; if ( ! empty ( $ assoc _args [ 'format ' ] ) & & 'ids ' = = = $ assoc _args [ 'format ' ] ) { $ output _widgets = wp _list _pluck ( $ output _widgets , 'id ' ) ; } $ formatter = new Formatter ( $ assoc _args , $ this - > fields ) ; $ formatter - > display _items ( $ output _widgets ) ; } 
public function add ( $ args , $ assoc _args ) { list ( $ name , $ sidebar _id ) = $ args ; $ position = Utils \ get _flag _value ( $ args , 2 , 1 ) - 1 ; $ this - > validate _sidebar ( $ sidebar _id ) ; $ widget = $ this - > get _widget _obj ( $ name ) ; if ( false = = = $ widget ) { WP _CLI : : error ( 'Invalid widget type . ' ) ; } $ widget _options = $ this - > get _widget _options ( $ name ) ; $ option _keys = $ widget _options ; if ( ! isset ( $ widget _options [ ' _multiwidget ' ] ) ) { $ widget _options [ ' _multiwidget ' ] = 1 ; } unset ( $ option _keys [ ' _multiwidget ' ] ) ; $ option _keys = array _keys ( $ option _keys ) ; $ last _key = array _pop ( $ option _keys ) ; $ option _index = $ last _key + 1 ; $ widget _options [ $ option _index ] = $ this - > sanitize _widget _options ( $ name , $ assoc _args , array ( ) ) ; $ this - > update _widget _options ( $ name , $ widget _options ) ; $ widget _id = $ name . ' - ' . $ option _index ; $ this - > move _sidebar _widget ( $ widget _id , null , $ sidebar _id , null , $ position ) ; WP _CLI : : success ( 'Added widget to sidebar . ' ) ; } 
public function update ( $ args , $ assoc _args ) { list ( $ widget _id ) = $ args ; if ( ! $ this - > validate _sidebar _widget ( $ widget _id ) ) { WP _CLI : : error ( "Widget doesn 't exist . " ) ; } if ( empty ( $ assoc _args ) ) { WP _CLI : : error ( 'No options specified to update . ' ) ; } list ( $ name , $ option _index ) = $ this - > get _widget _data ( $ widget _id ) ; $ widget _options = $ this - > get _widget _options ( $ name ) ; $ clean _options = $ this - > sanitize _widget _options ( $ name , $ assoc _args , $ widget _options [ $ option _index ] ) ; $ widget _options [ $ option _index ] = array _merge ( ( array ) $ widget _options [ $ option _index ] , $ clean _options ) ; $ this - > update _widget _options ( $ name , $ widget _options ) ; WP _CLI : : success ( 'Widget updated . ' ) ; } 
public function move ( $ args , $ assoc _args ) { list ( $ widget _id ) = $ args ; if ( ! $ this - > validate _sidebar _widget ( $ widget _id ) ) { WP _CLI : : error ( "Widget doesn 't exist . " ) ; } if ( empty ( $ assoc _args [ 'position ' ] ) & & empty ( $ assoc _args [ 'sidebar -id ' ] ) ) { WP _CLI : : error ( 'A new position or new sidebar must be specified . ' ) ; } list ( $ name , $ option _index , $ current _sidebar _id , $ current _sidebar _index ) = $ this - > get _widget _data ( $ widget _id ) ; $ new _sidebar _id = ! empty ( $ assoc _args [ 'sidebar -id ' ] ) ? $ assoc _args [ 'sidebar -id ' ] : $ current _sidebar _id ; $ this - > validate _sidebar ( $ new _sidebar _id ) ; $ new _sidebar _index = ! empty ( $ assoc _args [ 'position ' ] ) ? $ assoc _args [ 'position ' ] - 1 : $ current _sidebar _index ; 
public function deactivate ( $ args , $ assoc _args ) { $ count = 0 ; $ errors = 0 ; foreach ( $ args as $ widget _id ) { if ( ! $ this - > validate _sidebar _widget ( $ widget _id ) ) { WP _CLI : : warning ( "Widget ' { $widget _id } ' doesn 't exist . " ) ; $ errors + + ; continue ; } list ( $ name , $ option _index , $ sidebar _id , $ sidebar _index ) = $ this - > get _widget _data ( $ widget _id ) ; if ( 'wp _inactive _widgets ' = = = $ sidebar _id ) { WP _CLI : : warning ( sprintf ( " ' %s ' is already deactivated . " , $ widget _id ) ) ; continue ; } $ this - > move _sidebar _widget ( $ widget _id , $ sidebar _id , 'wp _inactive _widgets ' , $ sidebar _index , 0 ) ; $ count + + ; } Utils \ report _batch _operation _results ( 'widget ' , 'deactivate ' , count ( $ args ) , $ count , $ errors ) ; } 
public function delete ( $ args , $ assoc _args ) { $ count = 0 ; $ errors = 0 ; foreach ( $ args as $ widget _id ) { if ( ! $ this - > validate _sidebar _widget ( $ widget _id ) ) { WP _CLI : : warning ( "Widget ' { $widget _id } ' doesn 't exist . " ) ; $ errors + + ; continue ; } 
public function reset ( $ args , $ assoc _args ) { global $ wp _registered _sidebars ; $ all = Utils \ get _flag _value ( $ assoc _args , 'all ' , false ) ; 
private function validate _sidebar ( $ sidebar _id ) { global $ wp _registered _sidebars ; Utils \ wp _register _unused _sidebar ( ) ; if ( ! array _key _exists ( $ sidebar _id , $ wp _registered _sidebars ) ) { WP _CLI : : error ( 'Invalid sidebar . ' ) ; } } 
private function validate _sidebar _widget ( $ widget _id ) { $ sidebars _widgets = $ this - > wp _get _sidebars _widgets ( ) ; $ widget _exists = false ; foreach ( $ sidebars _widgets as $ sidebar _id = > $ widgets ) { if ( in _array ( $ widget _id , $ widgets , true ) ) { $ widget _exists = true ; break ; } } return $ widget _exists ; } 
private function get _sidebar _widgets ( $ sidebar _id ) { $ all _widgets = $ this - > wp _get _sidebars _widgets ( ) ; if ( empty ( $ all _widgets [ $ sidebar _id ] ) ) { return array ( ) ; } $ prepared _widgets = array ( ) ; foreach ( $ all _widgets [ $ sidebar _id ] as $ key = > $ widget _id ) { $ prepared _widget = new std Class ( ) ; $ parts = explode ( ' - ' , $ widget _id ) ; $ option _index = array _pop ( $ parts ) ; $ widget _name = implode ( ' - ' , $ parts ) ; $ prepared _widget - > name = $ widget _name ; $ prepared _widget - > id = $ widget _id ; $ prepared _widget - > position = $ key + 1 ; $ widget _options = get _option ( 'widget _ ' . $ widget _name ) ; $ prepared _widget - > options = $ widget _options [ $ option _index ] ; $ prepared _widgets [ ] = $ prepared _widget ; } return $ prepared _widgets ; } 
private function get _widget _data ( $ widget _id ) { $ parts = explode ( ' - ' , $ widget _id ) ; $ option _index = array _pop ( $ parts ) ; $ name = implode ( ' - ' , $ parts ) ; $ sidebar _id = false ; $ sidebar _index = false ; $ all _widgets = $ this - > wp _get _sidebars _widgets ( ) ; foreach ( $ all _widgets as $ s _id = > & $ widgets ) { $ key = array _search ( $ widget _id , $ widgets , true ) ; if ( false ! = = $ key ) { $ sidebar _id = $ s _id ; $ sidebar _index = $ key ; break ; } } return array ( $ name , $ option _index , $ sidebar _id , $ sidebar _index ) ; } 
private function move _sidebar _widget ( $ widget _id , $ current _sidebar _id , $ new _sidebar _id , $ current _index , $ new _index ) { $ all _widgets = $ this - > wp _get _sidebars _widgets ( ) ; $ needs _placement = true ; 
private function get _widget _obj ( $ id _base ) { global $ wp _widget _factory ; $ widget = wp _filter _object _list ( $ wp _widget _factory - > widgets , array ( 'id _base ' = > $ id _base ) ) ; if ( empty ( $ widget ) ) { return false ; } return array _pop ( $ widget ) ; } 
private function sanitize _widget _options ( $ id _base , $ dirty _options , $ old _options ) { $ widget = $ this - > get _widget _obj ( $ id _base ) ; if ( empty ( $ widget ) ) { return array ( ) ; } 
public function get Random Integer ( $ min = 0 , $ max = PHP _INT _MAX ) { $ min = ( int ) $ min ; $ max = ( int ) $ max ; $ range = $ max - $ min ; $ bits = $ this - > get Bits In Integer ( $ range ) ; $ bytes = $ this - > get Bytes In Bits ( $ bits ) ; $ mask = ( int ) ( ( 1 < < $ bits ) - 1 ) ; do { $ byte String = $ this - > generator - > generate ( $ bytes ) ; $ result = hexdec ( bin 2hex ( $ byte String ) ) & $ mask ; } while ( $ result > $ range ) ; return ( int ) $ result + $ min ; } 
public function get Random String ( $ length , $ charset = null ) { $ length = ( int ) $ length ; if ( ! $ charset ) { $ charset = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz 0 1 2 3 4 5 6 7 8 9 . / ' ; } $ charset Length = strlen ( $ charset ) ; $ needed Bytes = $ this - > get Bytes In Bits ( $ length * ( $ this - > get Bits In Integer ( $ charset Length ) + 1 ) ) ; $ string = ' ' ; do { $ byte String = $ this - > generator - > generate ( $ needed Bytes ) ; for ( $ i = 0 ; $ i < $ needed Bytes ; + + $ i ) { if ( ord ( $ byte String [ $ i ] ) > ( 2 5 5 - ( 2 5 5 % $ charset Length ) ) ) { continue ; } $ string . = $ charset [ ord ( $ byte String [ $ i ] ) % $ charset Length ] ; } } while ( strlen ( $ string ) < $ length ) ; return substr ( $ string , 0 , $ length ) ; } 
public function encode ( $ string ) { $ encoded = ' ' ; if ( $ string ) { $ bin String = ' ' ; 
public function decode ( $ string ) { $ decoded = ' ' ; $ string = preg _replace ( " / [ ^ { $this - >charset } ] / " , ' ' , rtrim ( strtoupper ( $ string ) , $ this - > charset [ 3 2 ] ) ) ; if ( $ string ) { $ bin String = ' ' ; foreach ( str _split ( $ string ) as $ char ) { $ bin String . = str _pad ( decbin ( strpos ( $ this - > charset , $ char ) ) , 5 , 0 , STR _PAD _LEFT ) ; } $ bin String = substr ( $ bin String , 0 , ( floor ( strlen ( $ bin String ) / 8 ) * 8 ) ) ; foreach ( str _split ( $ bin String , 8 ) as $ chunk ) { $ chunk = str _pad ( $ chunk , 8 , 0 , STR _PAD _RIGHT ) ; $ decoded . = chr ( bindec ( $ chunk ) ) ; } } return $ decoded ; } 
public function generate ( $ byte Count ) { $ bytes = ' ' ; if ( strlen ( ! $ this - > random String ) ) { $ this - > random String = chr ( 0 ) ; } do { $ bytes . = $ this - > random String ; } while ( strlen ( $ bytes ) < $ byte Count ) ; return substr ( $ bytes , 0 , $ byte Count ) ; } 
public function generate ( $ byte Count ) { $ bytes = ' ' ; if ( self : : is Supported ( ) ) { if ( $ fp = @ fopen ( $ this - > file , 'rb ' ) ) { if ( function _exists ( 'stream _set _read _buffer ' ) ) { stream _set _read _buffer ( $ fp , 0 ) ; } $ file Bytes = fread ( $ fp , $ byte Count ) ; if ( $ file Bytes ) { $ bytes = $ file Bytes ; } } } return str _pad ( $ bytes , $ byte Count , chr ( 0 ) ) ; } 
public static function is Supported ( ) { $ supported = false ; $ class = _ _CLASS _ _ ; $ self = new $ class ; if ( file _exists ( $ self - > file ) & & is _readable ( $ self - > file ) ) { $ supported = true ; } return $ supported ; } 
public function generate ( $ byte Count ) { $ bits Per Round = 2 ; $ msec Per Round = 4 0 0 ; $ hash Length = 2 0 ; $ total = $ byte Count ; $ generated = ' ' ; do { $ bytes = ( $ total > $ hash Length ) ? $ hash Length : $ total ; $ total - = $ bytes ; $ entropy = rand ( ) . uniqid ( mt _rand ( ) , true ) ; $ entropy . = implode ( ' ' , @ fstat ( @ fopen ( _ _FILE _ _ , 'r ' ) ) ) ; $ entropy . = memory _get _usage ( ) ; for ( $ i = 0 ; $ i < 3 ; $ i + + ) { $ counter 1 = microtime ( true ) ; $ var = sha 1 ( mt _rand ( ) ) ; for ( $ j = 0 ; $ j < 5 0 ; $ j + + ) { $ var = sha 1 ( $ var ) ; } $ counter 2 = microtime ( true ) ; $ entropy . = $ counter 1 . $ counter 2 ; } $ rounds = ( int ) ( $ msec Per Round * 5 0 / ( int ) ( ( $ counter 2 - $ counter 1 ) * 1 0 0 0 0 0 0 ) ) ; $ iterations = $ bytes * ( int ) ( ceil ( 8 / $ bits Per Round ) ) ; for ( $ i = 0 ; $ i < $ iterations ; $ i + + ) { $ counter 1 = microtime ( ) ; $ var = sha 1 ( mt _rand ( ) ) ; for ( $ j = 0 ; $ j < $ rounds ; $ j + + ) { $ var = sha 1 ( $ var ) ; } $ counter 2 = microtime ( ) ; $ entropy . = $ counter 1 . $ counter 2 ; } $ generated . = sha 1 ( $ entropy , true ) ; } while ( $ byte Count > strlen ( $ generated ) ) ; $ bytes = substr ( $ generated , 0 , $ byte Count ) ; return str _pad ( $ bytes , $ byte Count , chr ( 0 ) ) ; } 
public function generate ( $ byte Count ) { $ bytes = ' ' ; if ( self : : is Supported ( ) ) { $ ssl Strong = false ; $ ssl Bytes = openssl _random _pseudo _bytes ( $ byte Count , $ ssl Strong ) ; if ( $ ssl Strong ) { $ bytes = $ ssl Bytes ; } unset ( $ ssl Strong ) ; } return str _pad ( $ bytes , $ byte Count , chr ( 0 ) ) ; } 
public static function is Supported ( ) { $ supported = false ; if ( function _exists ( 'openssl _random _pseudo _bytes ' ) ) { if ( version _compare ( PHP _VERSION , ' 5 . 3 . 7 ' ) > = 0 | | ( PHP _OS & " \x DF \x DF \x DF " ) ! = = 'WIN ' ) { $ supported = true ; } } return $ supported ; } 
public function generate ( $ byte Count ) { $ bytes = ' ' ; if ( self : : is Supported ( ) ) { try { $ util = new \ COM ( 'CAPICOM .Utilities . 1 ' ) ; $ capicom Bytes = base 6 4 _decode ( $ util - > Get Random ( $ byte Count , 0 ) ) ; if ( $ capicom Bytes ) { $ bytes = $ capicom Bytes ; } } catch ( \ Exception $ e ) { } } return str _pad ( $ bytes , $ byte Count , chr ( 0 ) ) ; } 
public function add Generator Path ( $ prefix , $ path ) { $ path = realpath ( $ path ) ; $ success = false ; if ( $ path & & ! array _key _exists ( $ prefix , $ this - > generator Paths ) ) { $ this - > generator Paths [ $ prefix ] = $ path ; $ success = true ; } return $ success ; } 
public function remove Generator Path ( $ prefix Or Path ) { if ( array _key _exists ( $ prefix Or Path , $ this - > generator Paths ) ) { $ prefix = $ prefix Or Path ; unset ( $ this - > generator Paths [ $ prefix ] ) ; } elseif ( ( $ prefix Or Path = realpath ( $ prefix Or Path ) ) & & in _array ( $ prefix Or Path , $ this - > generator Paths ) ) { $ path = $ prefix Or Path ; $ generator Paths = $ this - > generator Paths ; $ this - > generator Paths = array _filter ( $ generator Paths , function ( $ value ) use ( $ path ) { return ( $ value ! = $ path ) ; } ) ; } return $ this ; } 
public function get Generator ( ) { if ( ! $ this - > generators ) { $ this - > load Generators ( ) ; } $ generators = $ this - > generators ; usort ( $ generators , function ( $ a , $ b ) { return ( $ b : : get Priority ( ) - $ a : : get Priority ( ) ) ; } ) ; $ generator = null ; if ( isset ( $ generators [ 0 ] ) ) { $ class = $ generators [ 0 ] ; $ generator = new $ class ; } return $ generator ; } 
public function load Generators ( ) { 
public function generate ( $ byte Count ) { $ bytes = ' ' ; if ( self : : is Supported ( ) ) { $ mcrypt Str = mcrypt _create _iv ( $ byte Count , MCRYPT _DEV _URANDOM ) ; if ( $ mcrypt Str ! = = false ) { $ bytes = $ mcrypt Str ; } } return str _pad ( $ bytes , $ byte Count , chr ( 0 ) ) ; } 
public function get Attribute ( $ attribute , $ fallback = null ) { if ( 'name ' = = = $ attribute ) { return $ this - > name ; } return parent : : get Attribute ( $ attribute , $ fallback ) ; } 
public function label ( $ text , $ screen Reader Only = false , $ extra Classes = [ ] ) { if ( $ text = = = null ) { return $ this ; } $ element = clone $ this ; $ element - > label = Label : : create ( ) - > text ( $ text ) - > add Class If ( $ screen Reader Only , 'sr -only ' ) - > add Class ( 'col -form -label ' ) - > add Class ( $ extra Classes ) ; return $ element ; } 
public function help Text ( $ text , $ small = true , $ muted = true , $ extra Class = null ) { if ( $ text = = = null ) { return $ this ; } $ element = clone $ this ; $ element - > help Text = $ small ? Small : : create ( ) - > text ( $ text ) : P : : create ( ) - > text ( $ text ) ; $ element - > help Text = $ element - > help Text - > add Class If ( $ extra Class ! = = null , $ extra Class ) - > add Class If ( $ muted , 'text -muted ' ) ; return $ element ; } 
public function show As Row ( $ row Config = 'default ' ) { $ row Config = app ( 'config ' ) - > get ( "bs 4 .form _rows . $row Config " , null ) ; if ( $ row Config = = = null ) { throw new \ Invalid Argument Exception ( "Unknown configuration entry : bs 4 .form _rows . $row Config " ) ; } $ element = clone $ this ; 
public function read Only ( $ show As Plain Text = false ) { $ element = clone $ this ; $ element - > plain Text = $ show As Plain Text ; return $ element - > attribute ( 'readonly ' , 'readonly ' ) ; } 
public function open Form ( $ method , $ action , array $ options = [ ] ) : Htmlable { 
public function close Form ( ) : Htmlable { $ out = $ this - > current Form - > close ( ) ; $ this - > current Form = null ; $ this - > form State = null ; return $ out ; } 
public function form Group ( $ control = null , $ label = null , $ help Text = null ) : Form Group { $ element = new Form Group ( $ this - > form State , $ control ) ; return $ element - > help Text ( $ help Text ) - > label ( $ label ) ; } 
public function input Group ( $ control = null , $ prefix = null , $ suffix = null ) : Input Group { $ element = new Input Group ( $ control ) ; return $ element - > prefix ( $ prefix ) - > suffix ( $ suffix ) ; } 
public function input ( $ type = null , $ name = null , $ value = null ) : Input { $ value = $ this - > get Field Value ( $ name , $ value ) ; $ element = new Input ( $ this - > form State ) ; return $ element - > type If ( $ type , $ type ) - > name If ( $ name , $ name ) - > id If ( $ name , field _name _to _id ( $ name ) ) - > value If ( $ value ! = = null , $ value ) ; } 
public function simple File ( $ name = null ) : File { $ element = new File ( $ this - > form State ) ; return $ element - > name If ( $ name , $ name ) - > id If ( $ name , field _name _to _id ( $ name ) ) ; } 
public function file ( $ name = null , $ description = null ) : Custom File { $ element = new Custom File ( $ this - > form State ) ; return $ element - > name If ( $ name , $ name ) - > id If ( $ name , field _name _to _id ( $ name , 'wrapper ' ) ) - > description ( $ description ) ; } 
public function text Area ( $ name = null , $ value = null ) : Text Area { $ value = $ this - > get Field Value ( $ name , $ value ) ; $ element = new Text Area ( $ this - > form State ) ; return $ element - > name If ( $ name , $ name ) - > id If ( $ name , field _name _to _id ( $ name ) ) - > value If ( $ value ! = = null , $ value ) ; } 
public function check Box ( $ name = null , $ description = null , $ is Checked = false ) : Check Box { $ is Checked = $ this - > get Field Value ( $ name , $ is Checked ) ; $ element = new Check Box ( $ this - > form State ) ; return $ element - > name If ( $ name , $ name ) - > id If ( $ name , field _name _to _id ( $ name , 'wrapper ' ) ) - > description ( $ description ) - > checked ( $ is Checked ) ; } 
public function radio ( $ name = null , $ description = null , $ is Checked = false ) : Radio { $ is Checked = $ this - > get Field Value ( $ name , $ is Checked ) ; $ element = new Radio ( $ this - > form State ) ; return $ element - > name If ( $ name , $ name ) - > id If ( $ name , field _name _to _id ( $ name , 'wrapper ' ) ) - > description ( $ description ) - > checked ( $ is Checked ) ; } 
public function radio Group ( $ name , $ options , $ selected Option = null ) : Radio Group { $ element = new Radio Group ( $ this - > form State ) ; return $ element - > name ( $ name ) - > id ( field _name _to _id ( $ name ) . ' _radio _group ' ) - > options ( $ options ) - > selected Option ( $ selected Option ) ; } 
public function select ( $ name = null , $ options = [ ] , $ value = null ) : Select { $ value = $ this - > get Field Value ( $ name , $ value ) ; $ element = new Select ( $ this - > form State ) ; return $ element - > name If ( $ name , $ name ) - > id If ( $ name , field _name _to _id ( $ name ) ) - > options ( $ options ) - > value If ( $ value ! = = null , $ value ) ; } 
public function text ( $ name = null , $ value = null ) : Input { return $ this - > input ( 'text ' , $ name , $ value ) ; } 
public function password ( $ name = null , $ value = null ) : Input { return $ this - > input ( 'password ' , $ name , $ value ) ; } 
public function email ( $ name = null , $ value = null ) : Input { return $ this - > input ( 'email ' , $ name , $ value ) ; } 
public function hidden ( $ name = null , $ value = null ) : Input { $ value = $ this - > get Field Value ( $ name , $ value ) ; $ element = new Input ( $ this - > form State ) ; return $ element - > type ( 'hidden ' ) - > name If ( $ name , $ name ) - > value If ( $ value ! = = null , $ value ) ; } 
public function submit ( $ text , $ variant = 'primary ' , $ outlined = false ) : Button { return $ this - > button ( $ text , $ variant , $ outlined ) - > type ( 'submit ' ) ; } 
public function button ( $ text , $ variant = 'secondary ' , $ outlined = false ) : Button { return Button : : create ( ) - > variant ( $ variant , $ outlined ) - > html ( $ text ) ; } 
public function prefix ( $ prefix , $ is Plain Text = true ) { if ( $ prefix = = = null ) { return $ this ; } $ element = clone $ this ; $ element - > prefixes [ ] = [ 'content ' = > $ prefix , 'plaintext ' = > $ is Plain Text , ] ; return $ element ; } 
public function suffix ( $ suffix , $ is Plain Text = true ) { if ( $ suffix = = = null ) { return $ this ; } $ element = clone $ this ; $ element - > suffixes [ ] = [ 'content ' = > $ suffix , 'plaintext ' = > $ is Plain Text , ] ; return $ element ; } 
private function assemble Addons ( $ addons , $ addon Container Class ) { if ( 0 = = = \ count ( $ addons ) ) { return $ this ; } $ div = Div : : create ( ) - > add Class ( $ addon Container Class ) - > add Children ( $ addons , function ( $ token ) { $ content = $ token [ 'content ' ] ? ? ' ' ; $ plain Text = $ token [ 'plaintext ' ] ? ? true ; 
public function checked ( $ is Checked = true ) { $ is Checked = $ is Checked | | $ is Checked = = = 'y ' | | $ is Checked = = = 1 ; $ element = clone $ this ; return $ is Checked ? $ element - > control Attribute ( 'checked ' , 'checked ' ) : $ element - > forget Control Attribute ( 'checked ' ) ; } 
public function disabled ( $ disabled = true ) { $ element = clone $ this ; return $ disabled ? $ element - > control Attribute ( 'disabled ' , 'disabled ' ) : $ element - > forget Control Attribute ( 'disabled ' ) ; } 
public function js ( array $ dependencies = [ 'jquery .slim ' , 'popper ' ] ) { $ dependencies [ ] = 'bs 4 ' ; $ urls = collect ( [ 'jquery ' = > 'https : / /code .jquery .com /jquery - ' . config ( 'bs 4 .versions .jquery ' ) . ' .min .js ' , 'jquery .slim ' = > 'https : / /code .jquery .com /jquery - ' . config ( 'bs 4 .versions .jquery ' ) . ' .slim .min .js ' , 'popper ' = > 'https : / /cdnjs .cloudflare .com /ajax /libs /popper .js / ' . config ( 'bs 4 .versions .popper ' ) . ' /umd /popper .min .js ' , 'bs 4 ' = > self : : $ BS 4 _CDN . config ( 'bs 4 .versions .bootstrap ' ) . ' /js /bootstrap .min .js ' , ] ) ; return $ this - > html - > div ( ) - > add Children ( $ urls - > filter ( function ( $ value , $ key ) use ( $ dependencies ) { return \ in _array ( $ key , $ dependencies , true ) ; } ) - > map ( function ( $ v ) { return $ this - > map Script Element ( $ v ) ; } ) ) ; } 
public function add Progress ( $ progress , $ options = [ ] ) { $ options [ 'progress ' ] = $ progress ; $ element = clone $ this ; $ element - > bars [ ] = $ options ; return $ element ; } 
public function boot ( ) { $ this - > merge Config From ( _ _DIR _ _ . ' / . . / . . /config /bs 4 .php ' , 'bs 4 ' ) ; $ this - > load Views From ( _ _DIR _ _ . ' / . . / . . /resources /views ' , 'bs ' ) ; $ this - > load Translations From ( _ _DIR _ _ . ' / . . / . . /resources /lang ' , 'bs ' ) ; if ( $ this - > app - > running In Console ( ) ) { $ this - > publishes ( [ _ _DIR _ _ . ' / . . / . . /resources /views ' = > resource _path ( 'views /vendor /bs ' ) , ] , 'views ' ) ; $ this - > publishes ( [ _ _DIR _ _ . ' / . . / . . /resources /lang ' = > resource _path ( 'lang /vendor /bs ' ) , ] , 'lang ' ) ; $ this - > publishes ( [ _ _DIR _ _ . ' / . . / . . /config ' = > config _path ( ) , ] , 'config ' ) ; } } 
public function register ( ) { $ this - > app - > singleton ( Bootstrap : : class ) ; $ this - > app - > singleton ( Form Error Provider Contract : : class , Form Error Provider : : class ) ; $ this - > app - > singleton ( Old Form Input Provider Contract : : class , Old Form Input Provider : : class ) ; $ this - > app - > bind ( Form State Contract : : class , Form State : : class ) ; } 
public function get Attribute ( $ attribute , $ fallback = null ) { if ( \ in _array ( $ attribute , $ this - > delegated Control Attributes , true ) ) { return $ this - > get Control Attribute ( $ attribute , $ fallback ) ; } return parent : : get Attribute ( $ attribute , $ fallback ) ; } 
public function name ( $ name ) { $ element = clone $ this ; $ element - > control = $ this - > control - > name If ( $ name , $ name ) ; return $ element ; } 
public function wrap Control In ( $ wrapper ) { if ( $ wrapper = = = null ) { return $ this ; } $ element = clone $ this ; $ element - > control Wrapper = $ wrapper ; return $ element ; } 
public function size ( $ size ) { if ( ! property _exists ( $ this , 'sizable Class ' ) ) { throw new Runtime Exception ( 'You must specify the sizable CSS class ' ) ; } $ size = strtolower ( $ size ) ; if ( ! \ in _array ( $ size , [ 'lg ' , 'sm ' ] , true ) ) { throw new Runtime Exception ( 'Invalid size ' ) ; } return $ this - > add Class ( " { $this - >sizable Class } - $size " ) ; } 
public function merge Properties ( array $ properties , Node Interface $ node ) : array { $ node Properties = $ node - > get Properties ( ) ; if ( $ node Properties instanceof \ Traversable ) { $ node Properties = iterator _to _array ( $ node Properties ) ; } return array _merge ( $ properties , $ node Properties ) ; } 
private function unscrub ( $ msg ) { $ args = $ msg - > arguments ; $ session = $ this ; foreach ( $ msg - > callbacks as $ id = > $ path ) { if ( ! isset ( $ this - > wrapped [ $ id ] ) ) { $ this - > wrapped [ $ id ] = function ( ) use ( $ session , $ id ) { $ session - > request ( ( int ) $ id , func _get _args ( ) ) ; } ; } $ location = & $ args ; foreach ( $ path as $ part ) { if ( is _array ( $ location ) ) { $ location = & $ location [ $ part ] ; continue ; } $ location = & $ location - > $ part ; } $ location = $ this - > wrapped [ $ id ] ; } return $ args ; } 
public function client Temp F ( $ cb ) { $ this - > remote - > temperature ( function ( $ deg C ) use ( $ cb ) { $ deg F = round ( $ deg C * 9 / 5 + 3 2 ) ; $ cb ( $ deg F ) ; } ) ; } 
public function get Property Value ( $ path , $ cb ) { $ value = null ; try { $ value = $ this - > cr Session - > get Property ( $ path ) - > get Value ( ) ; } catch ( \ Exception $ e ) { $ this - > remote - > set Exception ( get _class ( $ e ) , $ e - > get Message ( ) ) ; } $ this - > remote - > set Value ( $ value , function ( ) use ( $ cb ) { $ cb ( ) ; } ) ; } 
public function get Nodes ( $ session Name , $ path , $ cb ) { if ( ! $ this - > validate Session Name ( $ session Name , $ cb ) ) return false ; $ exception = null ; $ msg = null ; $ names = array ( ) ; try { $ parent = $ this - > sessions [ $ session Name ] - > get Node ( $ path ) ; $ nodes = $ parent - > get Nodes ( ) ; $ names = array _keys ( $ nodes - > get Array Copy ( ) ) ; } catch ( \ Exception $ e ) { $ exception = get _class ( $ e ) ; $ msg = $ e - > get Message ( ) ; } $ cb ( $ names , $ exception , $ msg ) ; } 
public function get Properties ( $ session Name , $ path , $ cb ) { if ( ! $ this - > validate Session Name ( $ session Name , $ cb ) ) return false ; $ exception = null ; $ msg = null ; $ names = array ( ) ; try { $ parent = $ this - > sessions [ $ session Name ] - > get Node ( $ path ) ; $ properties = $ parent - > get Properties ( ) ; $ names = array _keys ( $ properties ) ; } catch ( \ Exception $ e ) { $ exception = get _class ( $ e ) ; $ msg = $ e - > get Message ( ) ; } $ cb ( $ names , $ exception , $ msg ) ; } 
public function get Property Value ( $ session Name , $ path , $ cb ) { if ( ! array _key _exists ( $ session Name , $ this - > sessions ) ) { $ cb ( null , 'Repository Exception ' , 'Named session $session Name not found ' ) ; } $ exception = null ; $ msg = null ; $ val = null ; try { $ val = $ this - > sessions [ $ session Name ] - > get Property ( $ path ) - > get Value ( ) ; } catch ( \ Exception $ e ) { $ exception = get _class ( $ e ) ; $ msg = $ e - > get Message ( ) ; } $ cb ( $ val , $ exception , $ msg ) ; } 
public function item Exists ( $ session Name , $ path , $ cb ) { if ( ! $ this - > validate Session Name ( $ session Name , $ cb ) ) return false ; $ exists = $ this - > sessions [ $ session Name ] - > item Exists ( $ path ) ; $ cb ( $ exists , null , null ) ; } 
public function create Session ( $ session Name , $ name , $ password ) { $ credentials = new \ PHPCR \ Simple Credentials ( $ name , $ password ) ; $ this - > sessions [ $ session Name ] = $ this - > repository - > login ( $ credentials ) ; } 
public function boot ( ) { 
public function register ( ) { $ config Path = _ _DIR _ _ . ' /config /ytake -laravel -smarty .php ' ; $ this - > merge Config From ( $ config Path , 'ytake -laravel -smarty ' ) ; $ this - > publishes ( [ $ config Path = > $ this - > resolve Configure Path ( ) . DIRECTORY _SEPARATOR . 'ytake -laravel -smarty .php ' , ] ) ; $ this - > app - > singleton ( 'smarty .view ' , function ( $ app ) { $ smarty Template = new Smarty ; $ factory = new Smarty Factory ( $ app [ 'view .engine .resolver ' ] , $ app [ 'view .finder ' ] , $ app [ 'events ' ] , $ smarty Template , $ this - > app [ 'config ' ] ) ; 
protected function connection ( Memcached Extension $ memcached , array $ servers ) { foreach ( $ servers as $ server ) { $ memcached - > add Server ( $ server [ 'host ' ] , $ server [ 'port ' ] , $ server [ 'weight ' ] ) ; } return $ memcached ; } 
protected function read ( array $ keys ) { $ map = $ lookup = [ ] ; list ( $ map , $ lookup ) = $ this - > each Keys ( $ keys , $ map , $ lookup ) ; $ result = [ ] ; $ memcached Result = $ this - > memcached - > get Multi ( $ map ) ; foreach ( $ memcached Result as $ k = > $ v ) { $ result [ $ lookup [ $ k ] ] = $ v ; } return $ result ; } 
protected function delete ( array $ keys ) { foreach ( $ keys as $ k ) { $ k = sha 1 ( $ k ) ; $ this - > memcached - > delete ( $ k ) ; } return true ; } 
public function _sub Template Render ( $ template , $ cache _id , $ compile _id , $ caching , $ cache _lifetime , $ data , $ scope , $ force Tpl Cache , $ uid = null , $ content _func = null ) { $ this - > template Resource Name = $ template ; parent : : _sub Template Render ( $ template , $ cache _id , $ compile _id , $ caching , $ cache _lifetime , $ data , $ scope , $ force Tpl Cache , $ uid , $ content _func ) ; } 
public function _sub Template Register ( ) { foreach ( $ this - > compiled - > includes as $ name = > $ count ) { 
protected function normalize Name ( string $ name , Smarty Factory $ view Factory ) { $ name = str _replace ( ' . ' . $ view Factory - > get Smarty File Extension ( ) , ' ' , $ name ) ; return str _replace ( ' / ' , ' . ' , $ name ) ; } 
public function set Smarty Configure ( ) { $ config = $ this - > config - > get ( 'ytake -laravel -smarty ' ) ; $ smarty = $ this - > smarty ; $ smarty - > set Template Dir ( array _get ( $ config , 'template _path ' ) ) ; $ smarty - > set Compile Dir ( array _get ( $ config , 'compile _path ' ) ) ; $ smarty - > set Cache Dir ( array _get ( $ config , 'cache _path ' ) ) ; $ smarty - > set Config Dir ( array _get ( $ config , 'config _paths ' ) ) ; foreach ( array _get ( $ config , 'plugins _paths ' , [ ] ) as $ plugins ) { $ smarty - > add Plugins Dir ( $ plugins ) ; } $ smarty - > error _reporting = array _get ( $ config , 'error _reporting ' , E _ALL & ~ E _NOTICE ) ; 
public function handle ( ) { $ removed Files = $ this - > smarty Factory - > get Smarty ( ) - > clear Compiled Template ( $ this - > option ( 'file ' ) , $ this - > option ( 'compile _id ' ) ) ; if ( $ removed Files > 0 ) { $ this - > info ( "Removed $removed Files compiled Smarty file " . ( $ removed Files > 1 ? 's ' : ' ' ) . ' . ' ) ; } return 0 ; } 
protected function evaluate Path ( string $ path , array $ data = [ ] ) { extract ( $ data , EXTR _SKIP ) ; try { if ( ! $ this - > smarty - > is Cached ( $ path ) ) { foreach ( $ data as $ var = > $ val ) { $ this - > smarty - > assign ( $ var , $ val ) ; } } 
public function handle ( ) { 
protected function read ( array $ keys ) { $ map = $ lookup = [ ] ; list ( $ map , $ lookup ) = $ this - > each Keys ( $ keys , $ map , $ lookup ) ; $ result = [ ] ; foreach ( $ map as $ key ) { $ result [ $ lookup [ $ key ] ] = $ this - > redis - > get ( $ key ) ; } return $ result ; } 
protected function write ( array $ keys , $ expire = 1 ) { foreach ( $ keys as $ k = > $ v ) { $ k = sha 1 ( $ k ) ; $ this - > redis - > setex ( $ k , $ expire , $ v ) ; } return true ; } 
protected function delete ( array $ keys ) { foreach ( $ keys as $ k ) { $ k = sha 1 ( $ k ) ; $ this - > redis - > del ( $ k ) ; } return true ; } 
public function handle ( ) { $ configure File Extension = $ this - > config - > get ( 'ytake -laravel -smarty .extension ' , 'tpl ' ) ; $ file Extension = ( is _null ( $ this - > option ( 'extension ' ) ) ) ? $ configure File Extension : $ this - > option ( 'extension ' ) ; ob _start ( ) ; $ compile Files = $ this - > smarty - > compile All Templates ( $ file Extension , $ this - > force Compile ( ) ) ; $ contents = ob _get _contents ( ) ; ob _get _clean ( ) ; $ this - > comment ( str _replace ( " <br > " , " " , trim ( $ contents ) ) ) ; $ this - > info ( " { $compile Files } template files recompiled " ) ; return 0 ; } 
protected function each Keys ( array $ keys , array $ map , array $ lookup ) { foreach ( $ keys as $ k ) { $ hash = sha 1 ( $ k ) ; $ map [ ] = $ hash ; $ lookup [ $ hash ] = $ k ; } return [ $ map , $ lookup ] ; } 
public function run ( ) { if ( ! $ this - > is Windows ( ) ) { $ command = $ this - > tests Path . "vendor /bin /selenium -server -standalone " . $ this - > get Web Driver ( ) . $ this - > selenium Params . ' > > selenium .log 2 > & 1 & ' ; print ( 'executing : ' . $ command ) ; exec ( $ command ) ; return ; } $ command = "START java .exe -jar " . $ this - > get Web Driver ( ) . $ this - > selenium Params . ' ' . _ _DIR _ _ . ' \bin \selenium -server -standalone .jar ' ; print ( 'executing : ' . $ command ) ; pclose ( popen ( $ command , 'r ' ) ) ; } 
public function get Webdriver ( ) { $ browser = $ this - > browser ; $ config = parse _ini _file ( _ _DIR _ _ . ' /config .dist .ini ' , true ) ; if ( file _exists ( _ _DIR _ _ . ' /config .ini ' ) ) { $ config = parse _ini _file ( _ _DIR _ _ . ' /config .ini ' , true ) ; } if ( $ browser = = 'chrome ' ) { $ driver [ 'type ' ] = 'webdriver .chrome .driver ' ; } elseif ( $ browser = = 'firefox ' ) { $ driver [ 'type ' ] = 'webdriver .gecko .driver ' ; } elseif ( $ browser = = 'Microsoft Edge ' ) { $ driver [ 'type ' ] = 'webdriver .edge .driver ' ; } elseif ( $ browser = = 'edg ' ) { $ driver [ 'type ' ] = 'webdriver .edg .driver ' ; } elseif ( $ browser = = 'internet explorer ' ) { $ driver [ 'type ' ] = 'webdriver .ie .driver ' ; } 
public function handle ( $ request , Closure $ next ) { $ response = $ next ( $ request ) ; 
public function get Aperture ( ) { if ( ! isset ( $ this - > data [ self : : APERTURE ] ) ) { return false ; } return $ this - > data [ self : : APERTURE ] ; } 
public function get Author ( ) { if ( ! isset ( $ this - > data [ self : : AUTHOR ] ) ) { return false ; } return $ this - > data [ self : : AUTHOR ] ; } 
public function get Headline ( ) { if ( ! isset ( $ this - > data [ self : : HEADLINE ] ) ) { return false ; } return $ this - > data [ self : : HEADLINE ] ; } 
public function get Credit ( ) { if ( ! isset ( $ this - > data [ self : : CREDIT ] ) ) { return false ; } return $ this - > data [ self : : CREDIT ] ; } 
public function get Source ( ) { if ( ! isset ( $ this - > data [ self : : SOURCE ] ) ) { return false ; } return $ this - > data [ self : : SOURCE ] ; } 
public function get Jobtitle ( ) { if ( ! isset ( $ this - > data [ self : : JOB _TITLE ] ) ) { return false ; } return $ this - > data [ self : : JOB _TITLE ] ; } 
public function get Iso ( ) { if ( ! isset ( $ this - > data [ self : : ISO ] ) ) { return false ; } return $ this - > data [ self : : ISO ] ; } 
public function get Exposure ( ) { if ( ! isset ( $ this - > data [ self : : EXPOSURE ] ) ) { return false ; } return $ this - > data [ self : : EXPOSURE ] ; } 
public function get Exposure Milliseconds ( ) { if ( ! isset ( $ this - > data [ self : : EXPOSURE ] ) ) { return false ; } if ( is _numeric ( $ this - > data [ self : : EXPOSURE ] ) ) { return $ this - > data [ self : : EXPOSURE ] + 0 ; } $ exposure Parts = explode ( ' / ' , $ this - > data [ self : : EXPOSURE ] ) ; return ( int ) reset ( $ exposure Parts ) / ( int ) end ( $ exposure Parts ) ; } 
public function get Focus Distance ( ) { if ( ! isset ( $ this - > data [ self : : FOCAL _DISTANCE ] ) ) { return false ; } return $ this - > data [ self : : FOCAL _DISTANCE ] ; } 
public function get Width ( ) { if ( ! isset ( $ this - > data [ self : : WIDTH ] ) ) { return false ; } return $ this - > data [ self : : WIDTH ] ; } 
public function get Height ( ) { if ( ! isset ( $ this - > data [ self : : HEIGHT ] ) ) { return false ; } return $ this - > data [ self : : HEIGHT ] ; } 
public function get Title ( ) { if ( ! isset ( $ this - > data [ self : : TITLE ] ) ) { return false ; } return $ this - > data [ self : : TITLE ] ; } 
public function get Caption ( ) { if ( ! isset ( $ this - > data [ self : : CAPTION ] ) ) { return false ; } return $ this - > data [ self : : CAPTION ] ; } 
public function get Copyright ( ) { if ( ! isset ( $ this - > data [ self : : COPYRIGHT ] ) ) { return false ; } return $ this - > data [ self : : COPYRIGHT ] ; } 
public function get Keywords ( ) { if ( ! isset ( $ this - > data [ self : : KEYWORDS ] ) ) { return false ; } return $ this - > data [ self : : KEYWORDS ] ; } 
public function get Camera ( ) { if ( ! isset ( $ this - > data [ self : : CAMERA ] ) ) { return false ; } return $ this - > data [ self : : CAMERA ] ; } 
public function get Horizontal Resolution ( ) { if ( ! isset ( $ this - > data [ self : : HORIZONTAL _RESOLUTION ] ) ) { return false ; } return $ this - > data [ self : : HORIZONTAL _RESOLUTION ] ; } 
public function get Vertical Resolution ( ) { if ( ! isset ( $ this - > data [ self : : VERTICAL _RESOLUTION ] ) ) { return false ; } return $ this - > data [ self : : VERTICAL _RESOLUTION ] ; } 
public function get Software ( ) { if ( ! isset ( $ this - > data [ self : : SOFTWARE ] ) ) { return false ; } return $ this - > data [ self : : SOFTWARE ] ; } 
public function get Focal Length ( ) { if ( ! isset ( $ this - > data [ self : : FOCAL _LENGTH ] ) ) { return false ; } return $ this - > data [ self : : FOCAL _LENGTH ] ; } 
public function get Creation Date ( ) { if ( ! isset ( $ this - > data [ self : : CREATION _DATE ] ) ) { return false ; } return $ this - > data [ self : : CREATION _DATE ] ; } 
public function get Color Space ( ) { if ( ! isset ( $ this - > data [ self : : COLORSPACE ] ) ) { return false ; } return $ this - > data [ self : : COLORSPACE ] ; } 
public function get Mime Type ( ) { if ( ! isset ( $ this - > data [ self : : MIMETYPE ] ) ) { return false ; } return $ this - > data [ self : : MIMETYPE ] ; } 
public function get File Size ( ) { if ( ! isset ( $ this - > data [ self : : FILESIZE ] ) ) { return false ; } return $ this - > data [ self : : FILESIZE ] ; } 
public function get Orientation ( ) { if ( ! isset ( $ this - > data [ self : : ORIENTATION ] ) ) { return false ; } return $ this - > data [ self : : ORIENTATION ] ; } 
public function get GPS ( ) { if ( ! isset ( $ this - > data [ self : : GPS ] ) ) { return false ; } return $ this - > data [ self : : GPS ] ; } 
public function map Raw Data ( array $ data ) { $ mapped Data = array ( ) ; $ gps Data = array ( ) ; foreach ( $ data as $ field = > $ value ) { if ( $ this - > is Section ( $ field ) & & is _array ( $ value ) ) { $ sub Data = $ this - > map Raw Data ( $ value ) ; $ mapped Data = array _merge ( $ mapped Data , $ sub Data ) ; continue ; } if ( ! $ this - > is Field Known ( $ field ) ) { 
protected function is Field Known ( & $ field ) { $ lcf Field = lcfirst ( $ field ) ; if ( array _key _exists ( $ lcf Field , $ this - > map ) ) { $ field = $ lcf Field ; return true ; } $ ucf Field = ucfirst ( $ field ) ; if ( array _key _exists ( $ ucf Field , $ this - > map ) ) { $ field = $ ucf Field ; return true ; } return false ; } 
protected function extract GPSCoordinate ( $ components ) { if ( ! is _array ( $ components ) ) { $ components = array ( $ components ) ; } $ components = array _map ( array ( $ this , 'normalize Component ' ) , $ components ) ; if ( count ( $ components ) > 2 ) { return floatval ( $ components [ 0 ] ) + ( floatval ( $ components [ 1 ] ) / 6 0 ) + ( floatval ( $ components [ 2 ] ) / 3 6 0 0 ) ; } return reset ( $ components ) ; } 
protected function normalize Component ( $ component ) { $ parts = explode ( ' / ' , $ component ) ; if ( count ( $ parts ) > 1 ) { if ( $ parts [ 1 ] ) { return intval ( $ parts [ 0 ] ) / intval ( $ parts [ 1 ] ) ; } return 0 ; } return floatval ( reset ( $ parts ) ) ; } 
public function set Tool Path ( $ path ) { if ( ! file _exists ( $ path ) ) { throw new Invalid Argument Exception ( sprintf ( 'Given path ( % 1 $s ) to the exiftool binary is invalid ' , $ path ) ) ; } $ this - > tool Path = $ path ; return $ this ; } 
public function get Tool Path ( ) { if ( empty ( $ this - > tool Path ) ) { $ path = exec ( 'which ' . self : : TOOL _NAME ) ; $ this - > set Tool Path ( $ path ) ; } return $ this - > tool Path ; } 
